		DBG_SS_CERTPOLI,
		"%hs[%u]: %ws%hs%ws\n",
		pszType,
		i,
		apwsz[i],
		L'\0' != *pwszName? " -- " : "",
		pwszName));
    }
}
#endif // DBG_CERTSRV


HRESULT
CCertPolicyEnterprise::_SetSystemStringProp(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszName,
    OPTIONAL IN WCHAR const *pwszValue)
{
    HRESULT hr;
    BSTR strName = NULL;
    VARIANT varValue;

    varValue.vt = VT_NULL;
    varValue.bstrVal = NULL;

    if (!myConvertWszToBstr(&strName, pwszName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }

    if (NULL != pwszValue)
    {
        if (!myConvertWszToBstr(&varValue.bstrVal, pwszValue, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:myConvertWszToBstr");
	}
	varValue.vt = VT_BSTR;
    }
    
    hr = pServer->SetCertificateProperty(strName, PROPTYPE_STRING, &varValue);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

error:
    VariantClear(&varValue);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


HRESULT
CCertPolicyEnterprise::_AddStringArray(
    IN WCHAR const *pwszzValue,
    IN BOOL fURL,
    IN OUT DWORD *pcStrings,
    IN OUT LPWSTR **papwszRegValues)
{
    HRESULT hr;
    DWORD cString = 0;
    WCHAR const *pwsz;
    LPCWSTR *awszFormatStrings = NULL;
    LPWSTR *awszOutputStrings = NULL;

    // Count the number of strings we're adding
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        cString++;
    }
    if (0 == cString)		// no strings
    {
	hr = S_OK;
        goto error;
    }
    awszFormatStrings = (LPCWSTR *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cString * sizeof(LPWSTR));
    if (NULL == awszFormatStrings)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:LocalAlloc");
    }

    cString = 0;
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        // Skip strings that start with a an unescaped minus sign.
        // Strings with an escaped minus sign (2 minus signs) are not skipped.

        if (L'-' == *pwsz)
        {
	    pwsz++;
	    if (L'-' != *pwsz)
	    {
                continue;
	    }
        }
        awszFormatStrings[cString++] = pwsz;
    }

    // if no strings to add, don't modify
    if (cString > 0)
    {
        awszOutputStrings = (LPWSTR *) LocalAlloc(
			        LMEM_FIXED | LMEM_ZEROINIT,
			        (cString + *pcStrings) * sizeof(LPWSTR));
        if (NULL == awszOutputStrings)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "Policy:LocalAlloc");
        }

        if (0 != *pcStrings)
        {
            CSASSERT(NULL != *papwszRegValues);
            CopyMemory(
		awszOutputStrings,
		*papwszRegValues,
		*pcStrings * sizeof(LPWSTR));
        }

        hr = myFormatCertsrvStringArray(
		fURL,				// fURL
		m_strMachineDNSName,		// pwszServerName_p1_2
		m_strCASanitizedName,		// pwszSanitizedName_p3_7
		m_iCert,			// iCert_p4
		MAXDWORD,			// iCertTarget_p4
		m_strDomainDN,			// pwszDomainDN_p5
		m_strConfigDN,			// pwszConfigDN_p6
		m_iCRL,				// iCRL_p8
		FALSE,				// fDeltaCRL_p9
		TRUE,				// fDSAttrib_p10_11
		cString,			// cStrings
		awszFormatStrings,		// apwszStringsIn
		awszOutputStrings + (*pcStrings)); // apwszStringsOut
	_JumpIfError(hr, error, "Policy:myFormatCertsrvStringArray");

        *pcStrings = (*pcStrings) + cString;
        if (*papwszRegValues)
        {
            LocalFree(*papwszRegValues);
        }
        *papwszRegValues = awszOutputStrings;
        awszOutputStrings = NULL;
    }
    hr = S_OK;

error:
    if (NULL != awszOutputStrings)
    {
        LocalFree(awszOutputStrings);
    }
    if (NULL != awszFormatStrings)
    {
        LocalFree(awszFormatStrings);
    }
    return(hr);	
}


HRESULT
CCertPolicyEnterprise::_ReadRegistryStringArray(
    IN HKEY hkey,
    IN BOOL fURL,
    IN DWORD dwFlags,
    IN DWORD cRegNames,
    IN DWORD *aFlags,
    IN WCHAR const * const *apwszRegNames,
    IN OUT DWORD *pcStrings,
    IN OUT LPWSTR **papwszRegValues)
{
    HRESULT hr;
    DWORD i;
    WCHAR *pwszzValue = NULL;
    DWORD cbValue;
    DWORD dwType;

    for (i = 0; i < cRegNames; i++)
    {
        if (0 == (dwFlags & aFlags[i]))
        {
	    continue;
        }
        if (NULL != pwszzValue)
        {
	    LocalFree(pwszzValue);
	    pwszzValue = NULL;
        }
        hr = RegQueryValueEx(
		        hkey,
		        apwszRegNames[i],
		        NULL,           // lpdwReserved
		        &dwType,
		        NULL,
		        &cbValue);
        if (S_OK != hr)
        {
	    _PrintErrorStr2(
			hr,
			"Policy:RegQueryValueEx",
			apwszRegNames[i],
			ERROR_FILE_NOT_FOUND);
	    continue;
        }
        if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _PrintErrorStr(hr, "Policy:RegQueryValueEx TYPE", apwszRegNames[i]);
	    continue;
        }

        // Handle malformed registry values cleanly by adding two WCHAR L'\0's
	// allocate space for 3 WCHARs to allow for unaligned (odd) cbValue;

        pwszzValue = (WCHAR *) LocalAlloc(
				        LMEM_FIXED,
				        cbValue + 3 * sizeof(WCHAR));
        if (NULL == pwszzValue)
        {
	    hr = E_OUTOFMEMORY;
	    _JumpErrorStr(hr, error, "Policy:LocalAlloc", apwszRegNames[i]);
        }
        hr = RegQueryValueEx(
		        hkey,
		        apwszRegNames[i],
		        NULL,           // lpdwReserved
		        &dwType,
		        (BYTE *) pwszzValue,
		        &cbValue);
        if (S_OK != hr)
        {
	    _PrintErrorStr(hr, "Policy:RegQueryValueEx", apwszRegNames[i]);
	    continue;
        }

        // Handle malformed registry values cleanly:

        pwszzValue[cbValue / sizeof(WCHAR)] = L'\0';
        pwszzValue[cbValue / sizeof(WCHAR) + 1] = L'\0';

        hr = _AddStringArray(
			pwszzValue,
			fURL,
			pcStrings,
			papwszRegValues);
        _JumpIfErrorStr(hr, error, "_AddStringArray", apwszRegNames[i]);
    }
    hr = S_OK;

error:
    if (NULL != pwszzValue)
    {
        LocalFree(pwszzValue);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_InitRevocationExtension
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_InitRevocationExtension(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cb;

    cb = sizeof(m_dwRevocationFlags);
    hr = RegQueryValueEx(
                hkey,
                wszREGREVOCATIONTYPE,
                NULL,           // lpdwReserved
                &dwType,
                (BYTE *) &m_dwRevocationFlags,
                &cb);
    if (S_OK != hr ||
	REG_DWORD != dwType ||
	sizeof(m_dwRevocationFlags) != cb)
    {
	m_dwRevocationFlags = 0;
        goto error;
    }
    DBGPRINT((DBG_SS_CERTPOL, "Revocation Flags = %x\n", m_dwRevocationFlags));

    // clean up from previous call

    if (NULL != m_wszASPRevocationURL)
    {
	LocalFree(m_wszASPRevocationURL);
	m_wszASPRevocationURL = NULL;
    }

    if (REVEXT_ASPENABLE & m_dwRevocationFlags)
    {
        hr = _ReadRegistryString(
			    hkey,
			    TRUE,			// fURL
			    wszREGREVOCATIONURL,	// pwszRegName
			    L"?",			// pwszSuffix
			    &m_wszASPRevocationURL);	// pstrRegValue
        _JumpIfErrorStr(hr, error, "_ReadRegistryString", wszREGREVOCATIONURL);
        _DumpStringArray("ASP", 1, &m_wszASPRevocationURL);
    }

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_InitRequestExtensionList
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_InitRequestExtensionList(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD adwFlags[] = {
	EDITF_REQUESTEXTENSIONLIST,
    };
    WCHAR *apwszRegNames[] = {
	wszREGENABLEREQUESTEXTENSIONLIST,
    };
    WCHAR *apwszRegNamesEnrollee[] = {
	wszREGENABLEENROLLEEREQUESTEXTENSIONLIST,
    };

    CSASSERT(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));
    CSASSERT(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNamesEnrollee));

    // clean up from previous call

    if (NULL != m_apwszEnableRequestExtensions)
    {
        _FreeStringArray(
		    &m_cEnableRequestExtensions,
		    &m_apwszEnableRequestExtensions);
    }
    if (NULL != m_apwszEnableEnrolleeRequestExtensions)
    {
        _FreeStringArray(
		    &m_cEnableEnrolleeRequestExtensions,
		    &m_apwszEnableEnrolleeRequestExtensions);
    }

    hr = _ReadRegistryStringArray(
			hkey,
			FALSE,			// fURL
			m_dwEditFlags,
			ARRAYSIZE(adwFlags),
			adwFlags,
			apwszRegNames,
			&m_cEnableRequestExtensions,
			&m_apwszEnableRequestExtensions);
    _JumpIfError(hr, error, "_ReadRegistryStringArray");

    _DumpStringArray(
		"Request",
		m_cEnableRequestExtensions,
		m_apwszEnableRequestExtensions);

    hr = _ReadRegistryStringArray(
			hkey,
			FALSE,			// fURL
			m_dwEditFlags,
			ARRAYSIZE(adwFlags),
			adwFlags,
			apwszRegNamesEnrollee,
			&m_cEnableEnrolleeRequestExtensions,
			&m_apwszEnableEnrolleeRequestExtensions);
    _JumpIfError(hr, error, "_ReadRegistryStringArray");

    _DumpStringArray(
		"EnrolleeRequest",
		m_cEnableEnrolleeRequestExtensions,
		m_apwszEnableEnrolleeRequestExtensions);

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_InitDisableExtensionList
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_InitDisableExtensionList(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD adwFlags[] = {
	EDITF_DISABLEEXTENSIONLIST,
    };
    WCHAR *apwszRegNames[] = {
	wszREGDISABLEEXTENSIONLIST,
    };

    CSASSERT(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));

    // clean up from previous call

    if (NULL != m_apwszDisableExtensions)
    {
        _FreeStringArray(&m_cDisableExtensions, &m_apwszDisableExtensions);
    }


    hr = _ReadRegistryStringArray(
			hkey,
			FALSE,			// fURL
			m_dwEditFlags,
			ARRAYSIZE(adwFlags),
			adwFlags,
			apwszRegNames,
			&m_cDisableExtensions,
			&m_apwszDisableExtensions);
    _JumpIfError(hr, error, "_ReadRegistryStringArray");

    _DumpStringArray(
		"Disable",
		m_cDisableExtensions,
		m_apwszDisableExtensions);

error:
    ;
}


// end_sdksample

//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_InitDefaultSMIMEExtension
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_InitDefaultSMIMEExtension(
    IN HKEY hkey)
{
    HRESULT hr;
    CRYPT_SMIME_CAPABILITIES SMIME = { 0, NULL };
    CRYPT_SMIME_CAPABILITY *pSMIME;
    DWORD cSMIME;
    DWORD i;
    LPWSTR *apwszSMIME = NULL;
    DWORD adwFlags[] = {
	EDITF_ENABLEDEFAULTSMIME,
    };
    WCHAR *apwszRegNames[] = {
	wszREGDEFAULTSMIME,
    };

    CSASSERT(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));

    // clean up from previous call

    if (NULL != m_pbSMIME)
    {
	LocalFree(m_pbSMIME);
	m_pbSMIME = NULL;
    }

    cSMIME = 0;
    hr = _ReadRegistryStringArray(
			hkey,
			FALSE,			// fURL
			m_dwEditFlags,
			ARRAYSIZE(adwFlags),
			adwFlags,
			apwszRegNames,
			&cSMIME,
			&apwszSMIME);
    _JumpIfError(hr, error, "_ReadRegistryStringArray");

    _DumpStringArray("SMIME", cSMIME, apwszSMIME);

    if (0 != cSMIME)
    {
	SMIME.rgCapability = (CRYPT_SMIME_CAPABILITY *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cSMIME * sizeof(SMIME.rgCapability[0]));
	if (NULL == SMIME.rgCapability)
	{
	    _JumpError(E_OUTOFMEMORY, error, "Policy:LocalAlloc");
	}
	SMIME.cCapability = cSMIME;

	for (i = 0; i < cSMIME; i++)
	{
	    WCHAR *pwszKeyLength = wcschr(apwszSMIME[i], L',');

	    pSMIME = &SMIME.rgCapability[i];
	    if (NULL != pwszKeyLength)
	    {
		DWORD dwKeyLength;

		*pwszKeyLength++ = L'\0';
		dwKeyLength = _wtoi(pwszKeyLength);
		if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    X509_INTEGER,
			    &dwKeyLength,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &pSMIME->Parameters.pbData,
			    &pSMIME->Parameters.cbData))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "Policy:myEncodeObject");
		}
	    }
	    if (!myConvertWszToSz(&pSMIME->pszObjId, apwszSMIME[i], -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:myConvertWszToSz");
	    }
	}
	if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    PKCS_SMIME_CAPABILITIES,
		    &SMIME,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &m_pbSMIME,
		    &m_cbSMIME))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "Policy:myEncodeObject");
	}
    }

error:
    if (NULL != apwszSMIME)
    {
	_FreeStringArray(&cSMIME, &apwszSMIME);
    }
    if (NULL != SMIME.rgCapability)
    {
	for (i = 0; i < SMIME.cCapability; i++)
	{
	    pSMIME = &SMIME.rgCapability[i];

	    if (NULL != pSMIME->Parameters.pbData)
	    {
		LocalFree(pSMIME->Parameters.pbData);
	    }
	    if (NULL != pSMIME->pszObjId)
	    {
		LocalFree(pSMIME->pszObjId);
	    }
	}
	LocalFree(SMIME.rgCapability);
    }
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_InitSubjectAltNameExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

VOID
CCertPolicyEnterprise::_InitSubjectAltNameExtension(
    IN HKEY hkey,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszObjectId,
    IN DWORD iAltName)
{
    DWORD err;
    DWORD dwType;
    DWORD cbbuf;
    WCHAR awcbuf[MAX_PATH];

    // ObjectId may be needed as a BSTR even if registry isn't set
    
    if (!myConvertWszToBstr(
		    &m_astrSubjectAltNameObjectId[iAltName],
		    pwszObjectId,
		    -1))
    {
	_JumpError(E_OUTOFMEMORY, error, "Policy:myConvertWszToBstr");
    }

    cbbuf = sizeof(awcbuf) - sizeof(WCHAR);
    err = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,         // lpdwReserved
		    &dwType,
		    (BYTE *) awcbuf,
		    &cbbuf);
    if (ERROR_SUCCESS != err ||
        REG_SZ != dwType ||
        sizeof(awcbuf) - sizeof(WCHAR) <= cbbuf)
    {
        goto error;
    }
    awcbuf[ARRAYSIZE(awcbuf) - 1] = L'\0';  // Just in case
    if (0 == LSTRCMPIS(awcbuf, wszATTREMAIL1) ||
	0 == LSTRCMPIS(awcbuf, wszATTREMAIL2))
    {
	if (!myConvertWszToBstr(
			&m_astrSubjectAltNameProp[iAltName],
			wszPROPSUBJECTEMAIL,
			-1))
	{
	    _JumpError(E_OUTOFMEMORY, error, "Policy:myConvertWszToBstr");
	}
    }
    DBGPRINT((
	DBG_SS_CERTPOLI,
	"Policy: %ws(RDN=%ws): %ws\n",
	pwszRegName,
	awcbuf,
	m_astrSubjectAltNameProp[iAltName]));

error:
    ;
}

// begin_sdksample


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::Initialize
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyEnterprise::Initialize(
    /* [in] */ BSTR const strConfig)
{
    HRESULT hr;
    HKEY hkey = NULL;
    DWORD dwType;
    DWORD dwSize;
    ICertServerPolicy *pServer = NULL;
    BOOL fCritSecEntered = FALSE;	// no_sdksample
    BOOL fUpgraded;
    BSTR bstrDescription = NULL;
    ICreateErrorInfo *pCreateErrorInfo = NULL;	// no_sdksample

    CERT_RDN_ATTR rdnAttr = { szOID_COMMON_NAME, CERT_RDN_ANY_TYPE, };

    rdnAttr.Value.pbData = NULL;

    DBGPRINT((DBG_SS_CERTPOL, "Policy:Initialize:\n"));

    // end_sdksample

    hr = S_OK;
    if (!m_fTemplateCriticalSection)
    {
	__try
	{
	    InitializeCriticalSection(&m_TemplateCriticalSection);
	    m_fTemplateCriticalSection = TRUE;
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
        _JumpIfError(hr, error, "InitializeCriticalSection");
    }
    EnterCriticalSection(&m_TemplateCriticalSection);
    fCritSecEntered = TRUE;
    if (NULL != m_pCreateErrorInfo)
    {
	m_pCreateErrorInfo->Release();
	m_pCreateErrorInfo = NULL;
    }
    // begin_sdksample

    __try
    {
	_Cleanup();

	m_strCAName = SysAllocString(strConfig);
	if (NULL == m_strCAName)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "CCertPolicyEnterprise::SysAllocString");
	}

	// force loading the description from resources

	hr = GetDescription(&bstrDescription);
	_LeaveIfError(hr, "CCertPolicyEnterprise::GetDescription");

	// get server callbacks

	hr = polGetServerCallbackInterface(&pServer, 0);
	_LeaveIfError(hr, "Policy:polGetServerCallbackInterface");

	hr = ReqInitialize(pServer);
	_JumpIfError(hr, error, "ReqInitialize");

	hr = TPInitialize(pServer);			// no_sdksample
	_JumpIfError(hr, error, "TPInitialize");	// no_sdksample

	// get storage location
	hr = polGetCertificateStringProperty(
				    pServer,
				    wszPROPMODULEREGLOC,
				    &m_strRegStorageLoc);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPMODULEREGLOC);


	// get CA type

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPCATYPE,
				    (LONG *) &m_CAType);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCATYPE);

	// end_sdksample

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPUSEDS,
				    (LONG *) &m_fUseDS);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszREGCAUSEDS);

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPLOGLEVEL,
				    (LONG *) &m_dwLogLevel);
	if (S_OK != hr)
	{
	    m_dwLogLevel = CERTLOG_WARNING;
	    _PrintErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPLOGLEVEL);
	}

	// begin_sdksample

	// get sanitized name

	hr = polGetCertificateStringProperty(
				    pServer,
				    wszPROPSANITIZEDCANAME,
				    &m_strCASanitizedName);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPSANITIZEDCANAME);

	// get sanitized name

	hr = polGetCertificateStringProperty(
				    pServer,
				    wszPROPSANITIZEDSHORTNAME,
				    &m_strCASanitizedDSName);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPSANITIZEDSHORTNAME);

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPSERVERUPGRADED,
				    (LONG *) &fUpgraded);
	if (S_OK != hr)
	{
	    fUpgraded = FALSE;
	    _PrintErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPSERVERUPGRADED);
	}

	hr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		m_strRegStorageLoc,
		0,              // dwReserved
		fUpgraded?
		    KEY_ALL_ACCESS :
		    (KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE),
		&hkey);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:Initialize:RegOpenKeyEx",
		    m_strRegStorageLoc);

	// Ignore error codes.

	dwSize = sizeof(m_dwDispositionFlags);
	hr = RegQueryValueEx(
			hkey,
			wszREGREQUESTDISPOSITION,
			0,
			&dwType,
			(BYTE *) &m_dwDispositionFlags,
			&dwSize);
	if (S_OK != hr || REG_DWORD != dwType)
	{
	    m_dwDispositionFlags = REQDISP_PENDINGFIRST | REQDISP_ISSUE;
	}
	DBGPRINT((
	    DBG_SS_CERTPOL,
	    "Disposition Flags = %x\n",
	    m_dwDispositionFlags));

	dwSize = sizeof(m_dwEditFlags);
	hr = RegQueryValueEx(
			hkey,
			wszREGEDITFLAGS,
			0,
			&dwType,
			(BYTE *) &m_dwEditFlags,
			&dwSize);
	if (S_OK != hr || REG_DWORD != dwType)
	{
	    m_dwEditFlags =
		    IsEnterpriseCA(m_CAType)?	// no_sdksample
		    EDITF_DEFAULT_ENTERPRISE :	// no_sdksample
		    EDITF_DEFAULT_STANDALONE;
	}
	if (fUpgraded)
	{
	    DBGPRINT((
		DBG_SS_CERTPOL,
		"Initialize: setting EDITF_SERVERUPGRADED\n"));

	    m_dwEditFlags |= EDITF_SERVERUPGRADED;
	    dwSize = sizeof(m_dwEditFlags);
	    hr = RegSetValueEx(
			    hkey,
			    wszREGEDITFLAGS,
			    0,
			    REG_DWORD,
			    (BYTE *) &m_dwEditFlags,
			    dwSize);
	    _PrintIfError(hr, "Policy:RegSetValueEx");
	}
	DBGPRINT((DBG_SS_CERTPOL, "Edit Flags = %x\n", m_dwEditFlags));

	dwSize = sizeof(m_CAPathLength);
	hr = RegQueryValueEx(
			hkey,
			wszREGCAPATHLENGTH,
			0,
			&dwType,
			(BYTE *) &m_CAPathLength,
			&dwSize);
	if (S_OK != hr || REG_DWORD != dwType)
	{
	    m_CAPathLength = CAPATHLENGTH_INFINITE;
	}
	DBGPRINT((DBG_SS_CERTPOL, "CAPathLength = %x\n", m_CAPathLength));


	// Initialize the insertion string array.
	// Machine DNS name (%1)

	hr = polGetCertificateStringProperty(
			    pServer,
			    wszPROPMACHINEDNSNAME,
			    &m_strMachineDNSName);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPMACHINEDNSNAME);

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPCERTCOUNT,
				    (LONG *) &m_iCert);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCERTCOUNT);

	if (0 == m_iCert)	// no CA certs?
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _LeaveIfErrorStr(
			hr,
			"Policy:polGetCertificateLongProperty",
			wszPROPCERTCOUNT);
	}
	m_iCert--;

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPCRLINDEX,
				    (LONG *) &m_iCRL);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCRLINDEX);

	_InitRevocationExtension(hkey);
	_InitRequestExtensionList(hkey);
	_InitDisableExtensionList(hkey);

	// end_sdksample

	_InitSubjectAltNameExtension(
				hkey,
				wszREGSUBJECTALTNAME,
				TEXT(szOID_SUBJECT_ALT_NAME),
				0);
	_InitSubjectAltNameExtension(
				hkey,
				wszREGSUBJECTALTNAME2,
				TEXT(szOID_SUBJECT_ALT_NAME2),
				1);

	hr = polGetCertificateLongProperty(
                                pServer,
                                wszPROPTEMPLATECHANGESEQUENCENUMBER,
                                (LONG *) &m_dwCATemplListSequenceNum);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPTEMPLATECHANGESEQUENCENUMBER);

	_InitDefaultSMIMEExtension(hkey);

	hr = _LoadDSConfig(pServer, FALSE);
	_PrintIfError(hr, "Policy:_LoadDSConfig");

	// if we fail the bind, don't sweat it, as we'll try again later,
	// at each request, and when GPO download happens.

	pCreateErrorInfo = m_pCreateErrorInfo;
	m_pCreateErrorInfo = NULL;

	// begin_sdksample
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != bstrDescription)
    {
        SysFreeString(bstrDescription);
    }
    if (NULL != hkey)
    {
	RegCloseKey(hkey);
    }
    if (NULL != pServer)
    {
	pServer->Release();
    }
    // end_sdksample
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&m_TemplateCriticalSection);
    }
    if (NULL != pCreateErrorInfo)
    {
	HRESULT hr2 = SetModuleErrorInfo(pCreateErrorInfo);
	pCreateErrorInfo->Release();
	_PrintIfError(hr2, "Policy:SetModuleErrorInfo");
    }
    // begin_sdksample
    return(myHError(hr));	// Reg routines return Win32 error codes
}


DWORD
polFindObjIdInList(
    IN WCHAR const *pwsz,
    IN DWORD count,
    IN WCHAR const * const *ppwsz)
{
    DWORD i;

    for (i = 0; i < count; i++)
    {
	if (NULL == pwsz || NULL == ppwsz[i])
	{
	    i = count;
	    break;
	}
	if (0 == wcscmp(pwsz, ppwsz[i]))
	{
	    break;
	}
    }
    return(i < count? i : MAXDWORD);
}


HRESULT
CCertPolicyEnterprise::_EnumerateExtensions(
    IN ICertServerPolicy *pServer,
    IN LONG bNewRequest,
    IN BOOL fFirstPass,
    IN BOOL fEnableEnrolleeExtensions,
    IN DWORD cCriticalExtensions,
    OPTIONAL IN WCHAR const * const *apwszCriticalExtensions)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strName = NULL;
    LONG ExtFlags;
    VARIANT varValue;
    BOOL fClose = FALSE;
    BOOL fEnable;
    BOOL fDisable;
    BOOL fCritical;

    VariantInit(&varValue);

    hr = pServer->EnumerateExtensionsSetup(0);
    _JumpIfError(hr, error, "Policy:EnumerateExtensionsSetup");

    fClose = TRUE;
    while (TRUE)
    {
        hr = pServer->EnumerateExtensions(&strName);
        if (S_FALSE == hr)
        {
            hr = S_OK;
            break;
        }
        _JumpIfError(hr, error, "Policy:EnumerateExtensions");

        hr = pServer->GetCertificateExtension(
                                        strName,
                                        PROPTYPE_BINARY,
                                        &varValue);
        _JumpIfError(hr, error, "Policy:GetCertificateExtension");

        hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	_JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

	fEnable = FALSE;
	fDisable = FALSE;
	fCritical = FALSE;

        if (fFirstPass)
        {
            if (bNewRequest && (EXTENSION_DISABLE_FLAG & ExtFlags))
            {
                switch (EXTENSION_ORIGIN_MASK & ExtFlags)
                {
                    case EXTENSION_ORIGIN_REQUEST:
                    case EXTENSION_ORIGIN_RENEWALCERT:
                    case EXTENSION_ORIGIN_PKCS7:
                    case EXTENSION_ORIGIN_CMC:
                    if ((EDITF_ENABLEREQUESTEXTENSIONS & m_dwEditFlags) ||
			MAXDWORD != polFindObjIdInList(
				    strName,
				    m_cEnableRequestExtensions,
				    m_apwszEnableRequestExtensions) ||
			(fEnableEnrolleeExtensions &&
			 MAXDWORD != polFindObjIdInList(
				    strName,
				    m_cEnableEnrolleeRequestExtensions,
				    m_apwszEnableEnrolleeRequestExtensions)))
                    {
			ExtFlags &= ~EXTENSION_DISABLE_FLAG;
			fEnable = TRUE;
                    }
                    break;
                }
            }
        }
        else
        {
            if (0 == (EXTENSION_DISABLE_FLAG & ExtFlags) &&
		MAXDWORD != polFindObjIdInList(
				    strName,
				    m_cDisableExtensions,
				    m_apwszDisableExtensions))
            {
                ExtFlags |= EXTENSION_DISABLE_FLAG;
                fDisable = TRUE;
            }
            if (0 == (EXTENSION_CRITICAL_FLAG & ExtFlags) &&
		MAXDWORD != polFindObjIdInList(
				    strName,
				    cCriticalExtensions,
				    apwszCriticalExtensions))
            {
                ExtFlags |= EXTENSION_CRITICAL_FLAG;
                fCritical = TRUE;
            }
        }

        if (fDisable || fEnable)
        {
            hr = pServer->SetCertificateExtension(
			            strName,
			            PROPTYPE_BINARY,
			            ExtFlags,
			            &varValue);
            _JumpIfError(hr, error, "Policy:SetCertificateExtension");
        }

        if (fFirstPass || fDisable || fEnable)
        {
	    DBGPRINT((
		DBG_SS_CERTPOL,
                "Policy:EnumerateExtensions(%ws, Flags=%x, %x bytes)%hs%hs\n",
                strName,
                ExtFlags,
                SysStringByteLen(varValue.bstrVal),
		fDisable? " DISABLING" : (fEnable? " ENABLING" : ""),
		fCritical? " +CRITICAL" : ""));
        }
	if (NULL != strName)
	{
	    SysFreeString(strName);
	    strName = NULL;
	}
        VariantClear(&varValue);
    }

error:
    if (fClose)
    {
        hr2 = pServer->EnumerateExtensionsClose();
        if (S_OK != hr2)
        {
            if (S_OK == hr)
            {
                hr = hr2;
            }
	    _PrintError(hr2, "Policy:EnumerateExtensionsClose");
        }
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    VariantClear(&varValue);
    return(hr);
}


HRESULT
EnumerateAttributes(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strName = NULL;
    BOOL fClose = FALSE;
    BSTR strValue = NULL;

    hr = pServer->EnumerateAttributesSetup(0);
    _JumpIfError(hr, error, "Policy:EnumerateAttributesSetup");

    fClose = TRUE;
    while (TRUE)
    {
        hr = pServer->EnumerateAttributes(&strName);
	if (S_FALSE == hr)
	{
	    hr = S_OK;
	    break;
	}
	_JumpIfError(hr, error, "Policy:EnumerateAttributes");

        hr = pServer->GetRequestAttribute(strName, &strValue);
	_JumpIfError(hr, error, "Policy:GetRequestAttribute");

	DBGPRINT((
		DBG_SS_CERTPOL,
                "Policy:EnumerateAttributes(%ws = %ws)\n",
                strName,
                strValue));
        if (NULL != strName)
        {
            SysFreeString(strName);
            strName = NULL;
        }
        if (NULL != strValue)
        {
            SysFreeString(strValue);
            strValue = NULL;
        }
    }

error:
    if (fClose)
    {
        hr2 = pServer->EnumerateAttributesClose();
        if (S_OK != hr2)
        {
	    _PrintError(hr2, "Policy:EnumerateAttributesClose");
            if (S_OK == hr)
            {
                hr = hr2;
            }
        }
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strValue)
    {
        SysFreeString(strValue);
    }
    return(hr);
}


HRESULT
GetRequestId(
    IN ICertServerPolicy *pServer,
    OUT LONG *plRequestId)
{
    HRESULT hr;

    hr = polGetRequestLongProperty(pServer, wszPROPREQUESTREQUESTID, plRequestId);
    _JumpIfError(hr, error, "Policy:polGetRequestLongProperty");

    DBGPRINT((
	DBG_SS_CERTPOL,
	"Policy:GetRequestId(%ws = %u)\n",
	wszPROPREQUESTREQUESTID,
	*plRequestId));

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_AddRevocationExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddRevocationExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strASPExtension = NULL;
    VARIANT varExtension;

    if (NULL != m_wszASPRevocationURL)
    {
	strASPExtension = SysAllocString(m_wszASPRevocationURL);
	if (NULL == strASPExtension)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}

	varExtension.vt = VT_BSTR;
	varExtension.bstrVal = strASPExtension;
	hr = polSetCertificateExtension(
				pServer,
				TEXT(szOID_NETSCAPE_REVOCATION_URL),
				PROPTYPE_STRING,
				0,
				&varExtension);
	_JumpIfErrorStr(hr, error, "Policy:polSetCertificateExtension", L"ASP");
    }

error:
    if (NULL != strASPExtension)
    {
        SysFreeString(strASPExtension);
    }
    return(hr);
}


#define HIGHBIT(bitno)	(1 << (7 - (bitno)))	// bit counted from high end

#define SSLBIT_CLIENT	((BYTE) HIGHBIT(0))	// certified for client auth
#define SSLBIT_SERVER	((BYTE) HIGHBIT(1))	// certified for server auth
#define SSLBIT_SMIME	((BYTE) HIGHBIT(2))	// certified for S/MIME
#define SSLBIT_SIGN	((BYTE) HIGHBIT(3))	// certified for signing

#define SSLBIT_RESERVED	((BYTE) HIGHBIT(4))	// reserved for future use

#define SSLBIT_CASSL	((BYTE) HIGHBIT(5))	// CA for SSL auth certs
#define SSLBIT_CASMIME	((BYTE) HIGHBIT(6))	// CA for S/MIME certs
#define SSLBIT_CASIGN	((BYTE) HIGHBIT(7))	// CA for signing certs

#define NSCERTTYPE_CLIENT  ((BYTE) SSLBIT_CLIENT)
#define NSCERTTYPE_SERVER  ((BYTE) (SSLBIT_SERVER | SSLBIT_CLIENT))
#define NSCERTTYPE_SMIME   ((BYTE) SSLBIT_SMIME)
#define NSCERTTYPE_CA	   ((BYTE) (SSLBIT_CASSL | SSLBIT_CASMIME | SSLBIT_CASIGN))

//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_AddOldCertTypeExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddOldCertTypeExtension(
    IN ICertServerPolicy *pServer,
    IN BOOL fCA)
{
    HRESULT hr = S_OK;
    ICertEncodeBitString *pBitString = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strBitString = NULL;
    BSTR strCertType = NULL;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    VARIANT varConstraints;
    DWORD cb;

    VariantInit(&varConstraints);

    if (EDITF_ADDOLDCERTTYPE & m_dwEditFlags)
    {
	BYTE CertType;

	if (!fCA)
	{
	    hr = polGetCertificateExtension(
				    pServer,
				    TEXT(szOID_BASIC_CONSTRAINTS2),
				    PROPTYPE_BINARY,
				    &varConstraints);
	    if (S_OK == hr)
	    {
		cb = sizeof(Constraints);
		if (!CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_BASIC_CONSTRAINTS2,
				    (BYTE const *) varConstraints.bstrVal,
				    SysStringByteLen(varConstraints.bstrVal),
				    0,
				    &Constraints,
				    &cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "Policy:CryptDecodeObject");
		}
		fCA = Constraints.fCA;
	    }
	}

	hr = CoCreateInstance(
			CLSID_CCertEncodeBitString,
			NULL,               // pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertEncodeBitString,
			(VOID **) &pBitString);
	_JumpIfError(hr, error, "Policy:CoCreateInstance");

	CertType = NSCERTTYPE_CLIENT;	// Default to client auth. cert
	if (fCA)
	{
	    CertType = NSCERTTYPE_CA;
	}
	else
	{
	    hr = polGetRequestAttribute(pServer, wszPROPCERTTYPE, &strCertType);
	    if (S_OK == hr)
	    {
		if (0 == LSTRCMPIS(strCertType, L"server"))
		{
		    CertType = NSCERTTYPE_SERVER;
		}
	    }
	}

        if (!myConvertWszToBstr(
		    &strBitString,
		    (WCHAR const *) &CertType,
		    sizeof(CertType)))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:myConvertWszToBstr");
	}

	hr = pBitString->Encode(
			    sizeof(CertType) * 8,
			    strBitString,
			    &strExtension);
	_JumpIfError(hr, error, "Policy:BitString:Encode");

        varExtension.vt = VT_BSTR;
	varExtension.bstrVal = strExtension;
	hr = polSetCertificateExtension(
				pServer,
				TEXT(szOID_NETSCAPE_CERT_TYPE),
				PROPTYPE_BINARY,
				0,
				&varExtension);
	_JumpIfError(hr, error, "Policy:polSetCertificateExtension");
    }

error:
    VariantClear(&varConstraints);
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strBitString)
    {
        SysFreeString(strBitString);
    }
    if (NULL != strCertType)
    {
        SysFreeString(strCertType);
    }
    if (NULL != pBitString)
    {
        pBitString->Release();
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_AddAuthorityKeyId
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddAuthorityKeyId(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    VARIANT varExtensionT;
    PCERT_AUTHORITY_KEY_ID2_INFO pInfo = NULL;
    DWORD cbInfo = 0;
    LONG ExtFlags = 0;

    VariantInit(&varExtension);

    // Optimization

    if ((EDITF_ENABLEAKIKEYID |
	 EDITF_ENABLEAKIISSUERNAME |
	 EDITF_ENABLEAKIISSUERSERIAL) ==
	((EDITF_ENABLEAKIKEYID |
	  EDITF_ENABLEAKIISSUERNAME |
	  EDITF_ENABLEAKIISSUERSERIAL |
	  EDITF_ENABLEAKICRITICAL) & m_dwEditFlags))
    {
        goto error;
    }

    hr = polGetCertificateExtension(
			    pServer,
			    TEXT(szOID_AUTHORITY_KEY_IDENTIFIER2),
			    PROPTYPE_BINARY,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:polGetCertificateExtension");

    hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
    _JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

    if (VT_BSTR != varExtension.vt)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Policy:GetCertificateExtension");
    }

    cbInfo = 0;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
                    X509_AUTHORITY_KEY_ID2,
                    (BYTE *) varExtension.bstrVal,
                    SysStringByteLen(varExtension.bstrVal),
		    CERTLIB_USE_LOCALALLOC,
                    (VOID **) &pInfo,
                    &cbInfo))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "Policy:myDecodeObject");
    }

    // Make Any Modifications Here

    if (0 == (EDITF_ENABLEAKIKEYID & m_dwEditFlags))
    {
        pInfo->KeyId.cbData = 0;
        pInfo->KeyId.pbData = NULL;
    }
    if (0 == (EDITF_ENABLEAKIISSUERNAME & m_dwEditFlags))
    {
        pInfo->AuthorityCertIssuer.cAltEntry = 0;
        pInfo->AuthorityCertIssuer.rgAltEntry = NULL;
    }
    if (0 == (EDITF_ENABLEAKIISSUERSERIAL & m_dwEditFlags))
    {
        pInfo->AuthorityCertSerialNumber.cbData = 0;
        pInfo->AuthorityCertSerialNumber.pbData = NULL;
    }
    if (EDITF_ENABLEAKICRITICAL & m_dwEditFlags)
    {
	ExtFlags |= EXTENSION_CRITICAL_FLAG;
    }
    if (0 ==
	((EDITF_ENABLEAKIKEYID |
	  EDITF_ENABLEAKIISSUERNAME |
	  EDITF_ENABLEAKIISSUERSERIAL) & m_dwEditFlags))
    {
	ExtFlags |= EXTENSION_DISABLE_FLAG;
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_AUTHORITY_KEY_ID2,
		    pInfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }
    if (!myConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }

    varExtensionT.vt = VT_BSTR;
    varExtensionT.bstrVal = strExtension;
    hr = polSetCertificateExtension(
			    pServer,
			    TEXT(szOID_AUTHORITY_KEY_IDENTIFIER2),
			    PROPTYPE_BINARY,
			    ExtFlags,
			    &varExtensionT);
    _JumpIfError(hr, error, "Policy:polSetCertificateExtension(AuthorityKeyId2)");

error:
    VariantClear(&varExtension);
    if (NULL != pInfo)
    {
	LocalFree(pInfo);
    }
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicy::_AddDefaultKeyUsageExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddDefaultKeyUsageExtension(
    IN ICertServerPolicy *pServer,
    IN BOOL fCA)
{
    HRESULT hr;
    BSTR strName = NULL;
    ICertEncodeBitString *pBitString = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strBitString = NULL;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    VARIANT varConstraints;
    VARIANT varKeyUsage;
    CRYPT_BIT_BLOB *pKeyUsage = NULL;
    DWORD cb;
    BYTE abKeyUsage[1];
    BYTE *pbKeyUsage;
    DWORD cbKeyUsage;

    VariantInit(&varConstraints);
    VariantInit(&varKeyUsage);

    if (EDITF_ADDOLDKEYUSAGE & m_dwEditFlags)
    {
	BOOL fModified = FALSE;

	if (!fCA)
	{
	    hr = polGetCertificateExtension(
				    pServer,
				    TEXT(szOID_BASIC_CONSTRAINTS2),
				    PROPTYPE_BINARY,
				    &varConstraints);
	    if (S_OK == hr)
	    {
		cb = sizeof(Constraints);
		if (!CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_BASIC_CONSTRAINTS2,
				    (BYTE const *) varConstraints.bstrVal,
				    SysStringByteLen(varConstraints.bstrVal),
				    0,
				    &Constraints,
				    &cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "Policy:CryptDecodeObject");
		}
		fCA = Constraints.fCA;
	    }
	}

	ZeroMemory(abKeyUsage, sizeof(abKeyUsage));
	pbKeyUsage = abKeyUsage;
	cbKeyUsage = sizeof(abKeyUsage);

	hr = polGetCertificateExtension(
				pServer,
				TEXT(szOID_KEY_USAGE),
				PROPTYPE_BINARY,
				&varKeyUsage);
	if (S_OK == hr)
	{
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_KEY_USAGE,
			    (BYTE const *) varKeyUsage.bstrVal,
			    SysStringByteLen(varKeyUsage.bstrVal),
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pKeyUsage,
			    &cb))
	    {
		hr = GetLastError();
		_PrintError(hr, "Policy:myDecodeObject");
	    }
	    else if (0 != cb && NULL != pKeyUsage && 0 != pKeyUsage->cbData)
	    {
		pbKeyUsage = pKeyUsage->pbData;
		cbKeyUsage = pKeyUsage->cbData;
	    }
	}

	if ((CERT_KEY_ENCIPHERMENT_KEY_USAGE & pbKeyUsage[0]) &&
	    (CERT_KEY_AGREEMENT_KEY_USAGE & pbKeyUsage[0]))
	{
	    pbKeyUsage[0] &= ~CERT_KEY_AGREEMENT_KEY_USAGE;
	    pbKeyUsage[0] |= CERT_DIGITAL_SIGNATURE_KEY_USAGE;
	    fModified = TRUE;
	}
	if (fCA)
	{
	    pbKeyUsage[0] |= myCASIGN_KEY_USAGE;
	    fModified = TRUE;
	}
	if (fModified)
	{
	    hr = CoCreateInstance(
			    CLSID_CCertEncodeBitString,
			    NULL,               // pUnkOuter
			    CLSCTX_INPROC_SERVER,
			    IID_ICertEncodeBitString,
			    (VOID **) &pBitString);
	    _JumpIfError(hr, error, "Policy:CoCreateInstance");

	    if (!myConvertWszToBstr(
			&strBitString,
			(WCHAR const *) pbKeyUsage,
			cbKeyUsage))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:myConvertWszToBstr");
	    }

	    hr = pBitString->Encode(cbKeyUsage * 8, strBitString, &strExtension);
	    _JumpIfError(hr, error, "Policy:Encode");

	    if (!myConvertWszToBstr(&strName, TEXT(szOID_KEY_USAGE), -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:myConvertWszToBstr");
	    }
	    varExtension.vt = VT_BSTR;
	    varExtension.bstrVal = strExtension;
	    hr = pServer->SetCertificateExtension(
				    strName,
				    PROPTYPE_BINARY,
				    0,
				    &varExtension);
	    _JumpIfError(hr, error, "Policy:SetCertificateExtension");
	}
    }
    hr = S_OK;

error:
    VariantClear(&varConstraints);
    VariantClear(&varKeyUsage);
    if (NULL != pKeyUsage)
    {
        LocalFree(pKeyUsage);
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strBitString)
    {
        SysFreeString(strBitString);
    }
    if (NULL != pBitString)
    {
        pBitString->Release();
    }
    return(hr);
}


HRESULT
CCertPolicyEnterprise::_AddEnhancedKeyUsageExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    BSTR strUsage = NULL;
    char *pszUsage = NULL;
    char *psz;
    char *pszNext;
    CERT_ENHKEY_USAGE ceu;
    CERT_POLICIES_INFO cpi;
    BYTE *pbKeyUsage = NULL;
    DWORD cbKeyUsage;
    BYTE *pbPolicies = NULL;
    DWORD cbPolicies;
    CERT_POLICY_INFO *pcpi = NULL;
    DWORD i;
    VARIANT varExtension;
    
    ZeroMemory(&ceu, sizeof(ceu));
    ZeroMemory(&cpi, sizeof(cpi));
    VariantInit(&varExtension);

    if (0 == (EDITF_ATTRIBUTEEKU & m_dwEditFlags))
    {
	hr = S_OK;
	goto error;
    }
    hr = polGetRequestAttribute(pServer, wszPROPCERTUSAGE, &strUsage);
    if (S_OK != hr)
    {
	hr = S_OK;
	goto error;
    }
    if (!myConvertWszToSz(&pszUsage, strUsage, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToSz");
    }
    for (psz = pszUsage; '\0' != *psz; psz = pszNext)
    {
	pszNext = &psz[strcspn(psz, ",")];
	if ('\0' != *pszNext)
	{
	    pszNext++;
	}
	ceu.cUsageIdentifier++;
    }
    if (0 == ceu.cUsageIdentifier)
    {
	hr = S_OK;
	goto error;
    }

    ceu.rgpszUsageIdentifier = (char **) LocalAlloc(
		LMEM_FIXED,
		ceu.cUsageIdentifier * sizeof(ceu.rgpszUsageIdentifier[0]));
    if (NULL == ceu.rgpszUsageIdentifier)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myLocalAlloc");
    }

    // Destructively parse comma separated ObjIds into individual strings

    i = 0;
    for (psz = pszUsage; '\0' != *psz; psz = pszNext)
    {
	char *pszEnd;
	
	CSASSERT(i < ceu.cUsageIdentifier);
	pszNext = &psz[strcspn(psz, ",")];
	pszEnd = pszNext;
	if ('\0' != *pszNext)
	{
	    *pszNext++ = '\0';
	}
	while (' ' == *psz)
	{
	    psz++;
	}
	while (pszEnd > psz && ' ' == *--pszEnd)
	{
	    *pszEnd = '\0';
	}
	if ('\0' != *psz)
	{
	    hr = myVerifyObjIdA(psz);
	    _JumpIfError(hr, error, "Policy:myVerifyObjIdA");

	    ceu.rgpszUsageIdentifier[i++] = psz;
	}
    }
    ceu.cUsageIdentifier = i;
    if (0 == ceu.cUsageIdentifier)
    {
	hr = S_OK;
	goto error;
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ENHANCED_KEY_USAGE,
		    &ceu,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbKeyUsage,
		    &cbKeyUsage))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }

    varExtension.bstrVal = NULL;
    if (!myConvertWszToBstr(
			&varExtension.bstrVal,
			(WCHAR const *) pbKeyUsage,
			cbKeyUsage))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:myConvertWszToBstr");
    }
    varExtension.vt = VT_BSTR;
    hr = polSetCertificateExtension(
			    pServer,
			    TEXT(szOID_ENHANCED_KEY_USAGE),
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:polSetCertificateExtension");

    cpi.cPolicyInfo = ceu.cUsageIdentifier;
    cpi.rgPolicyInfo = (CERT_POLICY_INFO *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cpi.cPolicyInfo * sizeof(cpi.rgPolicyInfo[0]));
    if (NULL == cpi.rgPolicyInfo)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:LocalAlloc");
    }
    for (i = 0; i < cpi.cPolicyInfo; i++)
    {
	cpi.rgPolicyInfo[i].pszPolicyIdentifier = ceu.rgpszUsageIdentifier[i];
    }
    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_POLICIES,
		    &cpi,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbPolicies,
		    &cbPolicies))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }

    if (!myConvertWszToBstr(
			&varExtension.bstrVal,
			(WCHAR const *) pbPolicies,
			cbPolicies))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:myConvertWszToBstr");
    }
    hr = polSetCertificateExtension(
			    pServer,
			    TEXT(szOID_APPLICATION_CERT_POLICIES),
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:polSetCertificateExtension");

error:
    if (NULL != pcpi)
    {
	LocalFree(pcpi);
    }
    VariantClear(&varExtension);
    if (NULL != ceu.rgpszUsageIdentifier)
    {
	LocalFree(ceu.rgpszUsageIdentifier);
    }
    if (NULL != pbPolicies)
    {
	LocalFree(pbPolicies);
    }
    if (NULL != pbKeyUsage)
    {
	LocalFree(pbKeyUsage);
    }
    if (NULL != pszUsage)
    {
	LocalFree(pszUsage);
    }
    if (NULL != strUsage)
    {
	SysFreeString(strUsage);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicy::_AddDefaultBasicConstraintsExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddDefaultBasicConstraintsExtension(
    IN ICertServerPolicy *pServer,
    IN BOOL               fCA)
{
    HRESULT hr;
    VARIANT varExtension;
    LONG ExtFlags;
    CERT_EXTENSION Ext;
    CERT_EXTENSION *pExtension = NULL;
    BSTR strCertType = NULL;

    VariantInit(&varExtension);

    if (EDITF_BASICCONSTRAINTSCA & m_dwEditFlags)
    {
        hr = polGetCertificateExtension(
				pServer,
				TEXT(szOID_BASIC_CONSTRAINTS2),
				PROPTYPE_BINARY,
				&varExtension);
        if (S_OK == hr)
        {
	    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
	    DWORD cb;

	    hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	    if (S_OK == hr)
	    {
                Ext.pszObjId = szOID_BASIC_CONSTRAINTS2;
                Ext.fCritical = FALSE;
                if (EXTENSION_CRITICAL_FLAG & ExtFlags)
                {
                    Ext.fCritical = TRUE;
                }
                Ext.Value.pbData = (BYTE *) varExtension.bstrVal;
                Ext.Value.cbData = SysStringByteLen(varExtension.bstrVal);
		pExtension = &Ext;

		cb = sizeof(Constraints);
		if (!fCA && CryptDecodeObject(
			        X509_ASN_ENCODING,
			        X509_BASIC_CONSTRAINTS2,
			        Ext.Value.pbData,
			        Ext.Value.cbData,
			        0,
			        &Constraints,
			        &cb))
		{
		    fCA = Constraints.fCA;
		}
	    }
	}
    }

    if (EDITF_ATTRIBUTECA & m_dwEditFlags)
    {
        if (!fCA)
        {
	    hr = polGetRequestAttribute(pServer, wszPROPCERTTYPE, &strCertType);
            if (S_OK == hr)
            {
                if (0 == LSTRCMPIS(strCertType, L"ca"))
                {
                    fCA = TRUE;
                }
            }
        }
        if (!fCA)
        {
	    hr = polGetRequestAttribute(pServer, wszPROPCERTTEMPLATE, &strCertType);
            if (S_OK == hr)
            {
                if (0 == LSTRCMPIS(strCertType, wszCERTTYPE_SUBORDINATE_CA) ||
		    0 == LSTRCMPIS(strCertType, wszCERTTYPE_CROSS_CA))
                {
                    fCA = TRUE;
                }
            }
	}
    }

    // For standalone, the extension is only enabled if it's a CA

    hr = AddBasicConstraintsCommon(pServer, pExtension, fCA, fCA);
    _JumpIfError(hr, error, "Policy:AddBasicConstraintsCommon");

error:
    VariantClear(&varExtension);
    if (NULL != strCertType)
    {
        SysFreeString(strCertType);
    }
    return(hr);
}


HRESULT
CCertPolicyEnterprise::AddBasicConstraintsCommon(
    IN ICertServerPolicy *pServer,
    IN CERT_EXTENSION const *pExtension,
    IN BOOL fCA,
    IN BOOL fEnableExtension)
{
    HRESULT hr;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    CERT_CONTEXT const *pIssuerCert;
    CERT_EXTENSION *pIssuerExtension;
    LONG ExtFlags = 0;
    BYTE *pbConstraints = NULL;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    CERT_BASIC_CONSTRAINTS2_INFO IssuerConstraints;
    ZeroMemory(&IssuerConstraints, sizeof(IssuerConstraints));

    DWORD cb;

    pIssuerCert = _GetIssuer(pServer);
    if (NULL == pIssuerCert)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "_GetIssuer");
    }

    if (NULL != pExtension)
    {
        cb = sizeof(Constraints);
        if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_BASIC_CONSTRAINTS2,
			pExtension->Value.pbData,
			pExtension->Value.cbData,
			0,
			&Constraints,
			&cb))
        {
	    hr = myHLastError();
	    _JumpError(hr, error, "Policy:CryptDecodeObject");
        }

        // Cert templates use CAPATHLENGTH_INFINITE to indicate
        // fPathLenConstraint should be FALSE.

        if (CAPATHLENGTH_INFINITE == Constraints.dwPathLenConstraint)
        {

            // NOTE: This is ok as certcli already sets fPathLenConstraint to FALSE
            // for templates in this case.
	    Constraints.fPathLenConstraint = FALSE;

            // NOTE: This is ok as autoenrollment ignores dwPathLenConstraint
            // if fPathLenConstraint is FALSE;
	    Constraints.dwPathLenConstraint = 0;
        }
        if (pExtension->fCritical)
        {
	    ExtFlags = EXTENSION_CRITICAL_FLAG;
        }
    }
    else
    {
	Constraints.fCA = fCA;
	Constraints.fPathLenConstraint = FALSE;
	Constraints.dwPathLenConstraint = 0;
    }
    if (EDITF_BASICCONSTRAINTSCRITICAL & m_dwEditFlags)
    {
        ExtFlags = EXTENSION_CRITICAL_FLAG;
    }

    // Check basic constraints against the issuer's cert.

    pIssuerExtension = CertFindExtension(
				szOID_BASIC_CONSTRAINTS2,
				pIssuerCert->pCertInfo->cExtension,
				pIssuerCert->pCertInfo->rgExtension);
    if (NULL != pIssuerExtension)
    {
        cb = sizeof(IssuerConstraints);
        if (!CryptDecodeObject(
			        X509_ASN_ENCODING,
			        X509_BASIC_CONSTRAINTS2,
			        pIssuerExtension->Value.pbData,
			        pIssuerExtension->Value.cbData,
			        0,
			        &IssuerConstraints,
			        &cb))
        {
            hr = myHLastError();
            _JumpError(hr, error, "Policy:CryptDecodeObject");
        }
        if (!IssuerConstraints.fCA)
        {
            hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
            _JumpError(hr, error, "Policy:CA cert not a CA cert");
        }
    }

    if (Constraints.fCA)
    {
        if (IssuerConstraints.fPathLenConstraint)
        {
            if (0 == IssuerConstraints.dwPathLenConstraint)
            {
                hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
                _JumpError(hr, error, "Policy:CA cert is a leaf CA cert");
            }
            if (!Constraints.fPathLenConstraint ||
                Constraints.dwPathLenConstraint >
	            IssuerConstraints.dwPathLenConstraint - 1)
            {
                Constraints.fPathLenConstraint = TRUE;
                Constraints.dwPathLenConstraint =
                IssuerConstraints.dwPathLenConstraint - 1;
            }
        }
        if (CAPATHLENGTH_INFINITE != m_CAPathLength)
        {
            if (0 == m_CAPathLength)
            {
                hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
                _JumpError(hr, error, "Policy:Registry says not to issue CA certs");
            }
            if (!Constraints.fPathLenConstraint ||
                Constraints.dwPathLenConstraint > m_CAPathLength - 1)
            {
                Constraints.fPathLenConstraint = TRUE;
                Constraints.dwPathLenConstraint = m_CAPathLength - 1;
            }
        }
    }

    if (!fEnableExtension)
    {
        ExtFlags |= EXTENSION_DISABLE_FLAG;
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
                    X509_BASIC_CONSTRAINTS2,
                    &Constraints,
		    0,
		    CERTLIB_USE_LOCALALLOC,
                    &pbConstraints,
                    &cb))
    {
        hr = myHLastError();
        _JumpError(hr, error, "Policy:myEncodeObject");
    }

    if (!myConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbConstraints,
			cb))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:myConvertWszToBstr");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = polSetCertificateExtension(
			    pServer,
			    TEXT(szOID_BASIC_CONSTRAINTS2),
			    PROPTYPE_BINARY,
			    ExtFlags,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:polSetCertificateExtension");

error:
    if (NULL != pbConstraints)
    {
        LocalFree(pbConstraints);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicy::_SetValidityPeriod
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_SetValidityPeriod(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    BSTR strPeriodString = NULL;
    BSTR strPeriodCount = NULL;
    BSTR strNameNotBefore = NULL;
    BSTR strNameNotAfter = NULL;
    VARIANT varValue;
    LONG lDelta;
    ENUM_PERIOD enumValidityPeriod;
    BOOL fValidDigitString;

    VariantInit(&varValue);

    if (!(EDITF_ATTRIBUTEENDDATE & m_dwEditFlags))
    {
	hr = S_OK;
	goto error;
    }

    hr = polGetRequestAttribute(
			pServer,
			wszPROPVALIDITYPERIODSTRING,
			&strPeriodString);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		hr,
		"Policy:polGetRequestAttribute",
		wszPROPVALIDITYPERIODSTRING,
		CERTSRV_E_PROPERTY_EMPTY);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    hr = polGetRequestAttribute(
			pServer,
			wszPROPVALIDITYPERIODCOUNT,
			&strPeriodCount);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		hr,
		"Policy:polGetRequestAttribute",
		wszPROPVALIDITYPERIODCOUNT,
		CERTSRV_E_PROPERTY_EMPTY);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    // Swap Count and String BSTRs if backwards -- Windows 2000 had it wrong.

    lDelta = myWtoI(strPeriodCount, &fValidDigitString);
    if (!fValidDigitString)
    {
	BSTR str = strPeriodCount;

	strPeriodCount = strPeriodString;
	strPeriodString = str;

	lDelta = myWtoI(strPeriodCount, &fValidDigitString);
	if (!fValidDigitString)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Policy:myWtoI");
	}
    }

    hr = myTranslatePeriodUnits(strPeriodString, lDelta, &enumValidityPeriod, &lDelta);
    _JumpIfError(hr, error, "Policy:myTranslatePeriodUnits");

    strNameNotBefore = SysAllocString(wszPROPCERTIFICATENOTBEFOREDATE);
    if (NULL == strNameNotBefore)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strNameNotBefore,
				PROPTYPE_DATE,
				&varValue);
    _JumpIfError(hr, error, "Policy:GetCertificateProperty");

    hr = myMakeExprDate(&varValue.date, lDelta, enumValidityPeriod);
    _JumpIfError(hr, error, "Policy:myMakeExprDate");

    strNameNotAfter = SysAllocString(wszPROPCERTIFICATENOTAFTERDATE);
    if (NULL == strNameNotAfter)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->SetCertificateProperty(
				strNameNotAfter,
				PROPTYPE_DATE,
				&varValue);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

    hr = S_OK;

error:
    VariantClear(&varValue);
    if (NULL != strPeriodString)
    {
	SysFreeString(strPeriodString);
    }
    if (NULL != strPeriodCount)
    {
	SysFreeString(strPeriodCount);
    }
    if (NULL != strNameNotBefore)
    {
        SysFreeString(strNameNotBefore);
    }
    if (NULL != strNameNotAfter)
    {
        SysFreeString(strNameNotAfter);
    }
    return(hr);
}

// end_sdksample


HRESULT
polBuildErrorInfo(
    IN HRESULT hrLog,
    IN DWORD dwLogId,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const * const *ppwszInsert,
    IN OUT ICreateErrorInfo **ppCreateErrorInfo)
{
    HRESULT hr;
    ICreateErrorInfo *pCreateErrorInfo = NULL;

    CSASSERT(NULL != pwszDescription);
    hr = ::LogModuleStatus(
		    g_hInstance,
		    hrLog,
		    dwLogId,
		    TRUE,
		    pwszDescription,
		    ppwszInsert,
		    &pCreateErrorInfo);
    _JumpIfError(hr, error, "LogModuleStatus");

    if (NULL != *ppCreateErrorInfo)
    {
	(*ppCreateErrorInfo)->Release();
    }
    *ppCreateErrorInfo = pCreateErrorInfo;
    pCreateErrorInfo = NULL;

error:
    if (NULL != pCreateErrorInfo)
    {
        pCreateErrorInfo->Release();
    }
    return(hr);
}


// make a binary BSTR from Base64 string (or Encode UTF8 string)

HRESULT
polReencodeBinary(
    IN OUT BSTR *pstr)
{
    HRESULT hr;
    BYTE *pbOut = NULL;
    DWORD cbOut;
    BSTR strOut;

    hr = myEncodeOtherNameBinary(*pstr, &pbOut, &cbOut);
    _JumpIfError(hr, error, "Policy:myEncodeOtherNameBinary");

    strOut = NULL;
    if (!myConvertWszToBstr(&strOut, (WCHAR const *) pbOut, cbOut))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToBstr");
    }
    SysFreeString(*pstr);
    *pstr = strOut;

error:
    if (NULL != pbOut)
    {
	LocalFree(pbOut);
    }
    return(hr);
}


// make a binary BSTR (Encode a UTF8 string)

HRESULT
polReencodeUTF8(
    IN OUT BSTR *pstr)
{
    HRESULT hr;
    BYTE *pbOut = NULL;
    DWORD cbOut;
    BSTR strOut;

    hr = myEncodeUTF8(*pstr, &pbOut, &cbOut);
    _JumpIfError(hr, error, "Policy:myEncodeUTF8");

    strOut = NULL;
    if (!myConvertWszToBstr(&strOut, (WCHAR const *) pbOut, cbOut))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToBstr");
    }
    SysFreeString(*pstr);
    *pstr = strOut;

error:
    if (NULL != pbOut)
    {
	LocalFree(pbOut);
    }
    return(hr);
}


HRESULT
polReencodeIPAddress(
    IN OUT BSTR *pstr)
{
    HRESULT hr;
    BYTE abOut[CB_IPV6ADDRESS];
    DWORD cbOut;
    BSTR strOut;

    cbOut = sizeof(abOut);
    hr = myParseIPAddress(*pstr, abOut, &cbOut);
    _JumpIfError(hr, error, "Policy:myParseIPAddress");

    CSASSERT(CB_IPV4ADDRESS == cbOut || CB_IPV6ADDRESS == cbOut);

    strOut = NULL;
    if (!myConvertWszToBstr(&strOut, (WCHAR const *) abOut, cbOut))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToBstr");
    }
    SysFreeString(*pstr);
    *pstr = strOut;
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// polReencodeGUID -- translate a stringized GUID to a binary GUID encoded with
// an OCTET string wrapper.
//
// Input string: "{f7c3ac41-b8ce-4fb4-aa58-3d1dc0e36b39}" (braces are optional)
//---------------------------------------------------------------------------

HRESULT
polReencodeGUID(
    IN OUT BSTR *pstr)
{
    HRESULT hr;
    GUID guid;
    CRYPT_DATA_BLOB blob;
    BYTE *pbOut = NULL;
    DWORD cbOut;
    BSTR strOut;
    WCHAR *pwszAlloc = NULL;
    WCHAR *pwsz;

    pwsz = *pstr;
    if (wcLBRACE != *pwsz)
    {
	DWORD cwc = wcslen(pwsz) + 2;

	pwszAlloc = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszAlloc)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:LocalAlloc");
	}
	*pwszAlloc = wcLBRACE;
	wcscpy(&pwszAlloc[1], pwsz);
	wcscat(pwszAlloc, wszRBRACE);
	pwsz = pwszAlloc;
    }

    hr = CLSIDFromString(pwsz, &guid);
    _JumpIfErrorStr(hr, error, "CLSIDFromString", pwsz);

    blob.pbData = (BYTE *) &guid;
    blob.cbData = sizeof(guid);

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &blob,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbOut,
		    &cbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }
    strOut = NULL;
    if (!myConvertWszToBstr(&strOut, (WCHAR const *) pbOut, cbOut))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToBstr");
    }
    SysFreeString(*pstr);
    *pstr = strOut;
    hr = S_OK;

error:
    if (NULL != pwszAlloc)
    {
	LocalFree(pwszAlloc);
    }
    if (NULL != pbOut)
    {
	LocalFree(pbOut);
    }
    return(hr);
}


HRESULT
myCertStrToName(
    IN WCHAR const *pwszName,
    OUT CERT_NAME_BLOB *pName)
{
    HRESULT hr;
    WCHAR const *pwszError;

    pName->cbData = 0;
    pName->pbData = NULL;

    if (!CertStrToName(
		X509_ASN_ENCODING,
		pwszName,
		CERT_X500_NAME_STR |
		    CERT_NAME_STR_REVERSE_FLAG |
		    CERT_NAME_STR_NO_PLUS_FLAG |
		    CERT_NAME_STR_COMMA_FLAG,
		NULL,	// pvReserved
		NULL,	// pbEncoded
		&pName->cbData,
		&pwszError))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:CertStrToName");
    }
    pName->pbData = (BYTE *) LocalAlloc(LMEM_FIXED, pName->cbData);
    if (NULL == pName->pbData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:LocalAlloc");
    }
    if (!CertStrToName(
		X509_ASN_ENCODING,
		pwszName,
		CERT_X500_NAME_STR |
		    CERT_NAME_STR_REVERSE_FLAG |
		    CERT_NAME_STR_NO_PLUS_FLAG |
		    CERT_NAME_STR_COMMA_FLAG,
		NULL,	// pvReserved
		pName->pbData,
		&pName->cbData,
		&pwszError))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:CertStrToName");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
polReencodeDN(
    IN OUT BSTR *pstr)
{
    HRESULT hr;
    CERT_NAME_BLOB Name = { 0, NULL };
    BSTR strOut;

    hr = myCertStrToName(*pstr, &Name);
    _JumpIfError(hr, error, "Policy:myCertStrToName");

    strOut = NULL;
    if (!myConvertWszToBstr(&strOut, (WCHAR const *) Name.pbData, Name.cbData))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToBstr");
    }
    SysFreeString(*pstr);
    *pstr = strOut;
    hr = S_OK;

error:
    if (NULL != Name.pbData)
    {
        LocalFree(Name.pbData);
    }
    return(hr);
}


HRESULT
polSetAltNameEntry(
    IN ICertEncodeAltName *pAltName,
    IN DWORD iName,
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValue)
{
    HRESULT hr;
    BSTR strT = NULL;
    BSTR strT2 = NULL;

    DBGPRINT((
	DBG_SS_CERTPOL,
	"Policy:polSetAltNameEntry[%u]: %ws = %ws\n",
	iName,
	pwszName,
	pwszValue));
    if (!myConvertWszToBstr(&strT, pwszValue, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }
    if (iswdigit(pwszName[0]))	// Other name...
    {
	hr = myVerifyObjId(pwszName);
	_JumpIfError(hr, error, "Policy:myVerifyObjId");

	if (!myConvertWszToBstr(&strT2, pwszName, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:myConvertWszToBstr");
	}
	hr = pAltName->SetNameEntry(
				EAN_NAMEOBJECTID | iName,
				CERT_ALT_NAME_OTHER_NAME,
				strT2);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");

	// Binary BSTR (from Base64 or possible Encoded UTF8 string):

	hr = polReencodeBinary(&strT);
	_JumpIfError(hr, error, "Policy:polReencodeBinary");

	hr = pAltName->SetNameEntry(
				iName,
				CERT_ALT_NAME_OTHER_NAME,
				strT);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");
    }
    else if (0 == LSTRCMPIS(pwszName, wszPROPUPN))
    {
	strT2 = SysAllocString(TEXT(szOID_NT_PRINCIPAL_NAME));
	if (NULL == strT2)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}
	hr = pAltName->SetNameEntry(
				EAN_NAMEOBJECTID | iName,
				CERT_ALT_NAME_OTHER_NAME,
				strT2);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");

	// Binary BSTR (Encoded UTF8 string):

	hr = polReencodeUTF8(&strT);
	_JumpIfError(hr, error, "Policy:polReencodeUTF8");

	hr = pAltName->SetNameEntry(
				iName,
				CERT_ALT_NAME_OTHER_NAME,
				strT);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");
    }
    else if (0 == LSTRCMPIS(pwszName, wszPROPGUID))
    {
	strT2 = SysAllocString(TEXT(szOID_NTDS_REPLICATION));
	if (NULL == strT2)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}
	hr = pAltName->SetNameEntry(
				EAN_NAMEOBJECTID | iName,
				CERT_ALT_NAME_OTHER_NAME,
				strT2);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");

	// Binary BSTR (Encoded UTF8 string):

	hr = polReencodeGUID(&strT);
	_JumpIfError(hr, error, "Policy:polReencodeUTF8");

	hr = pAltName->SetNameEntry(
				iName,
				CERT_ALT_NAME_OTHER_NAME,
				strT);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");
    }
    else if (0 == LSTRCMPIS(pwszName, wszPROPEMAIL))
    {
	hr = pAltName->SetNameEntry(
				iName,
				CERT_ALT_NAME_RFC822_NAME,
				strT);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");
    }
    else if (0 == LSTRCMPIS(pwszName, wszPROPDNS))
    {
	hr = pAltName->SetNameEntry(
				iName,
				CERT_ALT_NAME_DNS_NAME,
				strT);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");
    }
    else if (0 == LSTRCMPIS(pwszName, wszPROPDN))
    {
	// Binary BSTR (from DN string):

	hr = polReencodeDN(&strT);
	_JumpIfError(hr, error, "Policy:polReencodeDN");

	hr = pAltName->SetNameEntry(
				iName,
				CERT_ALT_NAME_DIRECTORY_NAME,
				strT);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");
    }
    else if (0 == LSTRCMPIS(pwszName, wszPROPURL))
    {
	hr = pAltName->SetNameEntry(
				iName,
				CERT_ALT_NAME_URL,
				strT);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");
    }
    else if (0 == LSTRCMPIS(pwszName, wszPROPIPADDRESS))
    {
	// Binary BSTR (from IP Address string):

	hr = polReencodeIPAddress(&strT);
	_JumpIfError(hr, error, "Policy:polReencodeIPAddress");

	hr = pAltName->SetNameEntry(
				iName,
				CERT_ALT_NAME_IP_ADDRESS,
				strT);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");
    }
    else if (0 == LSTRCMPIS(pwszName, wszPROPOID))
    {
	hr = pAltName->SetNameEntry(
				iName,
				CERT_ALT_NAME_REGISTERED_ID,
				strT);
	_JumpIfError(hr, error, "Policy:AltName:SetNameEntry");
    }
    else
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Policy:pwszName");
    }
    hr = S_OK;

error:
    if (NULL != strT)
    {
        SysFreeString(strT);
    }
    if (NULL != strT2)
    {
        SysFreeString(strT2);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_AddSubjectAltNameExtension
//
// SubjectAltName request attribute syntax example:
//
// SAN:1.2.3.4={asn}Base64String & ...
//   or
// SAN:1.2.3.4={octet}Base64String & ...
//   or
// SAN:1.2.3.4={utf8}UTF8String & ...
//
// Or:
//
// SAN:
//    1.2.3.4={asn}Base64String&	(this is the OtherName mechanism)
//    email=foo@bar.com&
//    dns=foo.bar.com&
//    dn="CN=xxx,OU=xxx,DC=xxx"&
//    url="http://foo.com/default.htlm"&
//    ipaddress=172.134.10.134&
//    oid=1.2.3.4&
//    upn=foo@bar.com&
//    guid=f7c3ac41-b8ce-4fb4-aa58-3d1dc0e36b39
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_AddSubjectAltNameExtension(
    IN ICertServerPolicy *pServer,
    IN DWORD iAltName)
{
    HRESULT hr;
    BSTR strValue = NULL;
    WCHAR *pwszDup = NULL;
    ICertEncodeAltName *pAltName = NULL;
    BSTR strExtension = NULL;
    VARIANT varValue;

    VariantInit(&varValue);

    if (1 == iAltName && (EDITF_ATTRIBUTESUBJECTALTNAME2 & m_dwEditFlags))
    {
	hr = polGetRequestAttribute(pServer, wszPROPSUBJECTALTNAME2, &strValue);
	if (S_OK != hr)
	{
	    _PrintErrorStr2(
			hr,
			"Policy:polGetRequestAttribute",
			wszPROPSUBJECTALTNAME2,
			CERTSRV_E_PROPERTY_EMPTY);
	    if (CERTSRV_E_PROPERTY_EMPTY != hr)
	    {
		goto error;
	    }
	}
    }

    if (NULL == strValue && NULL != m_astrSubjectAltNameProp[iAltName])
    {
	hr = pServer->GetRequestProperty(
				    m_astrSubjectAltNameProp[iAltName],
				    PROPTYPE_STRING,
				    &varValue);
	if (S_OK != hr)
	{
	    DBGPRINT((
		DBG_SS_CERTPOL,
		"Policy:GetRequestProperty(%ws):%hs %x\n",
		m_astrSubjectAltNameProp[iAltName],
		CERTSRV_E_PROPERTY_EMPTY == hr? " MISSING ATTRIBUTE" : "",
		hr));
	    if (CERTSRV_E_PROPERTY_EMPTY != hr)
	    {
		_JumpErrorStr(
			hr,
			error,
			"Policy:GetRequestProperty",
			m_astrSubjectAltNameProp[iAltName]);
	    }
	}
	else if (VT_BSTR != varValue.vt)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:varValue.vt");
	}
        if (VT_BSTR == varValue.vt &&		// could be empty
	    NULL != varValue.bstrVal &&
	    L'\0' != varValue.bstrVal[0])
	{
	    DWORD cwc;
	    
	    cwc = WSZARRAYSIZE(wszPROPEMAIL) + 3 + wcslen(varValue.bstrVal);
	    strValue = SysAllocStringLen(NULL, cwc);
	    if (NULL == strValue)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:SysAllocStringLen");
	    }
	    wcscpy(strValue, wszPROPEMAIL);
	    wcscat(strValue, L"=\"");
	    wcscat(strValue, varValue.bstrVal);
	    wcscat(strValue, L"\"");
	    CSASSERT(SysStringByteLen(strValue) == wcslen(strValue) * sizeof(WCHAR));
	}
    }
    if (NULL != strValue)
    {
	WCHAR *pwszT;
	DWORD cName;
	DWORD iName;
	VARIANT varExtension;

	hr = myDupString(strValue, &pwszDup);
	_JumpIfError(hr, error, "myDupString");

	pwszT = pwszDup;	// Destructively parse value
	cName = 0;
	while (TRUE)
	{
	    WCHAR const *pwszName;
	    WCHAR const *pwszValue;
	    
	    hr = myParseNextAttribute(&pwszT, TRUE, &pwszName, &pwszValue);
	    if (S_FALSE == hr)
	    {
		break;
	    }
	    _JumpIfError(hr, error, "myParseNextAttribute");

	    cName++;
	}

	hr = CoCreateInstance(
			CLSID_CCertEncodeAltName,
			NULL,               // pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertEncodeAltName,
			(VOID **) &pAltName);
	_JumpIfError(hr, error, "Policy:CoCreateInstance");

	hr = pAltName->Reset(cName);
	_JumpIfError(hr, error, "Policy:AltName:Reset");

	pwszT = strValue;	// Destructively parse value
	for (iName = 0; ; iName++)
	{
	    WCHAR const *pwszName;
	    WCHAR const *pwszValue;
	    
	    hr = myParseNextAttribute(&pwszT, TRUE, &pwszName, &pwszValue);
	    if (S_FALSE == hr)
	    {
		break;
	    }
	    _JumpIfError(hr, error, "myParseNextAttribute");

	    hr = polSetAltNameEntry(pAltName, iName, pwszName, pwszValue);
	    _JumpIfError(hr, error, "polSetAltNameEntry");
	}
	CSASSERT(iName == cName);

	hr = pAltName->Encode(&strExtension);
	_JumpIfError(hr, error, "Policy:AltName:Encode");

	myRegisterMemAlloc(strExtension, -1, CSM_SYSALLOC);

        varExtension.vt = VT_BSTR;
	varExtension.bstrVal = strExtension;
	hr = pServer->SetCertificateExtension(
				m_astrSubjectAltNameObjectId[iAltName],
				PROPTYPE_BINARY,
				0,
				&varExtension);
	_JumpIfError(hr, error, "Policy:SetCertificateExtension");
    }
    hr = S_OK;

error:
    if (NULL != strValue)
    {
        SysFreeString(strValue);
    }
    if (NULL != pwszDup)
    {
        LocalFree(pwszDup);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != pAltName)
    {
        pAltName->Release();
    }
    VariantClear(&varValue);
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_PatchExchangeSubjectAltName
//
// If the request is for one of the Exchange templates, and if it contains an
// RFC822 entry and a Directory Name entry consisting solely of a single common
// name, strip out the common name entry.  The common name entry was used for
// display purposes by Outlook, but it interferes with name constraints
// enforcement.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::_PatchExchangeSubjectAltName(
    IN ICertServerPolicy *pServer,
    OPTIONAL IN BSTRC strTemplateName)
{
    HRESULT hr;
    BSTR strName = NULL;
    LONG ExtFlags;
    VARIANT varExtension;
    VARIANT varExtension2;
    CERT_ALT_NAME_INFO *pAltName = NULL;
    CERT_ALT_NAME_ENTRY *pRFC822Name;
    CERT_ALT_NAME_ENTRY *pDirectoryName;
    CERT_RDN const *prdn;
    CERT_ALT_NAME_INFO AltName;
    DWORD cbEncoded;
    BYTE *pbEncoded = NULL;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;

    VariantInit(&varExtension);
    VariantInit(&varExtension2);

    if (NULL == strTemplateName ||
	(0 != LSTRCMPIS(strTemplateName, wszCERTTYPE_EXCHANGE_USER) &&
	 0 != LSTRCMPIS(strTemplateName, wszCERTTYPE_EXCHANGE_USER_SIGNATURE)))
    {
	goto skip;	// not an Exchange request.

    }

    strName = SysAllocString(TEXT(szOID_SUBJECT_ALT_NAME2));
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }

    hr = pServer->GetCertificateExtension(
				    strName,
				    PROPTYPE_BINARY,
				    &varExtension);
    _PrintIfError2(hr, "Policy:GetCertificateExtension", hr);
    if (S_OK != hr || VT_BSTR != varExtension.vt)
    {
	goto skip;	// skip if the extension doesn't exist.
    }

    hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
    _JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

    if (EXTENSION_DISABLE_FLAG & ExtFlags)
    {
	goto skip;	// skip if the extension is disabled.
    }

    if (!myDecodeObject(
		X509_ASN_ENCODING,
		X509_ALTERNATE_NAME,
		(BYTE *) varExtension.bstrVal,
		SysStringByteLen(varExtension.bstrVal),
		CERTLIB_USE_LOCALALLOC,
		(VOID **) &pAltName,
		&cbEncoded))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:myDecodeObject");
    }
    if (2 != pAltName->cAltEntry)
    {
	goto skip;	// skip if the extension isn't as expected
    }

    pRFC822Name = &pAltName->rgAltEntry[0];
    pDirectoryName = &pAltName->rgAltEntry[1];
    if (CERT_ALT_NAME_RFC822_NAME == pRFC822Name->dwAltNameChoice &&
	CERT_ALT_NAME_DIRECTORY_NAME == pDirectoryName->dwAltNameChoice)
    {
    }
    else
    if (CERT_ALT_NAME_DIRECTORY_NAME == pRFC822Name->dwAltNameChoice &&
	CERT_ALT_NAME_RFC822_NAME == pDirectoryName->dwAltNameChoice)
    {
	pDirectoryName = &pAltName->rgAltEntry[0];
	pRFC822Name = &pAltName->rgAltEntry[1];
    }
    else
    {
	goto skip;	// skip if the extension doesn't contain one of each
    }
    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_UNICODE_NAME,
		pDirectoryName->DirectoryName.pbData,
		pDirectoryName->DirectoryName.cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfo,
		&cbNameInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }
    if (1 != pNameInfo->cRDN)
    {
	goto skip;	// skip if the entry doesn't contain one common name
    }
    prdn = &pNameInfo->rgRDN[0];
    if (1 != prdn->cRDNAttr ||
	0 != strcmp(prdn->rgRDNAttr[0].pszObjId, szOID_COMMON_NAME))
    {
	goto skip;	// skip if the entry doesn't contain one common name
    }

    // rewrite the extension with only the RFC822 entry.

    AltName.cAltEntry = 1;
    AltName.rgAltEntry = pRFC822Name;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &AltName,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }

    varExtension2.bstrVal = NULL;
    if (!myConvertWszToBstr(
			&varExtension2.bstrVal,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }
    varExtension2.vt = VT_BSTR;

    hr = pServer->SetCertificateExtension(
			    strName,
			    PROPTYPE_BINARY,
			    0,
			    &varExtension2);
    _JumpIfError(hr, error, "Policy:SetCertificateExtension");

skip:
    hr = S_OK;

error:
    VariantClear(&varExtension);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    if (NULL != pAltName)
    {
	LocalFree(pAltName);
    }
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(hr);
}

// begin_sdksample


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_AddV1TemplateNameExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyEnterprise::AddV1TemplateNameExtension(
    IN ICertServerPolicy *pServer,
    OPTIONAL IN WCHAR const *pwszTemplateName)
{
    HRESULT hr;
    BSTR strName = NULL;
    LONG ExtFlags = 0;
    VARIANT varExtension;
    CERT_NAME_VALUE *pName = NULL;
    CERT_NAME_VALUE NameValue;
    DWORD cbEncoded;
    BYTE *pbEncoded = NULL;
    BOOL fUpdate = TRUE;

    VariantInit(&varExtension);

    strName = SysAllocString(TEXT(szOID_ENROLL_CERTTYPE_EXTENSION));
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }

    hr = pServer->GetCertificateExtension(
				    strName,
				    PROPTYPE_BINARY,
				    &varExtension);
    _PrintIfError2(hr, "Policy:GetCertificateExtension", hr);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	if (NULL == pwszTemplateName)
	{
	    hr = S_OK;
	    goto error;
	}
    }
    else
    {
	_JumpIfError(hr, error, "Policy:GetCertificateExtension");

	hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	_JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

	if (VT_BSTR == varExtension.vt &&
	    0 == (EXTENSION_DISABLE_FLAG & ExtFlags) &&
	    NULL != pwszTemplateName)
	{
	    if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			(BYTE *) varExtension.bstrVal,
			SysStringByteLen(varExtension.bstrVal),
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pName,
			&cbEncoded))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "Policy:myDecodeObject");
	    }

	    // case sensitive compare -- be sure to match case of template

	    if (0 == lstrcmp(
			(WCHAR const *) pName->Value.pbData,
			pwszTemplateName))
	    {
		fUpdate = FALSE;
	    }
	}
    }
    if (fUpdate)
    {
	if (NULL == pwszTemplateName)
	{
	    ExtFlags |= EXTENSION_DISABLE_FLAG;
	}
	else
	{
	    VariantClear(&varExtension);
	    varExtension.bstrVal = NULL;

	    NameValue.dwValueType = CERT_RDN_UNICODE_STRING;
	    NameValue.Value.pbData = (BYTE *) pwszTemplateName;
	    NameValue.Value.cbData = 0;

	    if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    X509_UNICODE_ANY_STRING,
			    &NameValue,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    &pbEncoded,
			    &cbEncoded))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "Policy:myEncodeObject");
	    }
	    if (!myConvertWszToBstr(
				&varExtension.bstrVal,
				(WCHAR const *) pbEncoded,
				cbEncoded))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:myConvertWszToBstr");
	    }
	    varExtension.vt = VT_BSTR;
	    ExtFlags &= ~EXTENSION_DISABLE_FLAG;
	}
	hr = pServer->SetCertificateExtension(
				strName,
				PROPTYPE_BINARY,
				ExtFlags,
				&varExtension);
	_JumpIfError(hr, error, "Policy:SetCertificateExtension");
    }
    hr = S_OK;

error:
    VariantClear(&varExtension);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    if (NULL != pName)
    {
	LocalFree(pName);
    }
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(hr);
}

// end_sdksample

HRESULT CCertPolicyEnterprise::_DuplicateAppPoliciesToEKU(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    BYTE *pbEKU = NULL;
    DWORD cbEKU;
    VARIANT varAppPolicies;
    VARIANT varEKU;

    VariantInit(&varAppPolicies);
    VariantInit(&varEKU);

    hr = polGetCertificateExtension(
            pServer,
            TEXT(szOID_APPLICATION_CERT_POLICIES),
            PROPTYPE_BINARY,
            &varAppPolicies);

    // if app policies extension is found 
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
        _JumpIfError(hr, error, "PropGetExtension(szOID_APPLICATION_CERT_POLICIES)");

        hr = polGetCertificateExtension(
                pServer,
                TEXT(szOID_ENHANCED_KEY_USAGE),
                PROPTYPE_BINARY,
                &varEKU);

        // and EKU extension not found
        if (CERTSRV_E_PROPERTY_EMPTY == hr)
        {
            // copy all app policies OIDs into EKU format
            hr = myConvertAppPoliciesToEKU(
                (BYTE *) varAppPolicies.bstrVal,
                SysStringByteLen(varAppPolicies.bstrVal),
                &pbEKU,
                &cbEKU);
            _JumpIfError(hr, error, "ConvertAppPoliciesToEKU");

            // If app policies extension was empty, myConvertAppPoliciesToEKU returns NULL.
            // Write EKU only if there was at least one app policy.
            if(pbEKU)
            {
                varEKU.bstrVal = NULL;
                if (!myConvertWszToBstr(
                        &varEKU.bstrVal,
                        (WCHAR const *) pbEKU,
                        cbEKU))
                {
                    hr = E_OUTOFMEMORY;
                    _JumpError(hr, error, "Policy:myConvertWszToBstr");
                }

                varEKU.vt = VT_BSTR;

                // set EKU extension with all app policies OIDs
                hr = polSetCertificateExtension(
                        pServer,
                        TEXT(szOID_ENHANCED_KEY_USAGE),
                        PROPTYPE_BINARY,
                        0,
                        &varEKU);
                _JumpIfError(hr, error, "Policy:polSetCertificateExtension");        
            }
        }
        _JumpIfError(hr, error, "polGetCertificateExtension(szOID_ENHANCED_KEY_USAGE)");
    }

    hr = S_OK;

error:
    VariantClear(&varAppPolicies);
    VariantClear(&varEKU);
    if (NULL != pbEKU)
    {
        LocalFree(pbEKU);
    }
    return hr;
}

HRESULT
CCertPolicyEnterprise::FindTemplate(
    OPTIONAL IN WCHAR const *pwszTemplateName,
    OPTIONAL IN WCHAR const *pwszTemplateObjId,
    OUT CTemplatePolicy **ppTemplate)
{
    HRESULT hr;
    DWORD i;

    hr = CERTSRV_E_UNSUPPORTED_CERT_TYPE;
    *ppTemplate = NULL;
    for (i = 0; i < m_cTemplatePolicies; i++)
    {
        if (NULL == m_apTemplatePolicies[i])
        {
            continue;
        }
        if (m_apTemplatePolicies[i]->IsRequestedTemplate(
						pwszTemplateName,
						pwszTemplateObjId))
        {
	    *ppTemplate = m_apTemplatePolicies[i];
	    hr = S_OK;
	    break;
        }
    }
    _JumpIfErrorStr(hr, error, "FindTemplate", pwszTemplateName);

error:
    return(hr);
}


HRESULT
CCertPolicyEnterprise::_AddTemplateToCA(
    IN HCAINFO hCAInfo,
    IN WCHAR const *pwszTemplateName,
    OUT BOOL *pfAdded)
{
    HRESULT hr;
    HCERTTYPE hCertType = NULL;
    CTemplatePolicy *pTemplate;

    *pfAdded = FALSE;
    hr = FindTemplate(pwszTemplateName, NULL, &pTemplate);
    if (S_OK != hr)
    {
	hr = CAFindCertTypeByName(
			pwszTemplateName,
			m_pld,
			CT_FIND_LOCAL_SYSTEM |
			    CT_ENUM_MACHINE_TYPES |
			    CT_ENUM_USER_TYPES |
			    CT_FLAG_SCOPE_IS_LDAP_HANDLE |
			    CT_FLAG_NO_CACHE_LOOKUP,
			&hCertType);
	_JumpIfErrorStr(hr, error, "CAFindCertTypeByName", pwszTemplateName);

	hr = CAAddCACertificateType(hCAInfo, hCertType);
	_JumpIfErrorStr(hr, error, "CAAddCACertificateType", pwszTemplateName);

	*pfAdded = TRUE;
    }
    CSASSERT(S_OK == hr);

error:
    DBGPRINT((
	DBG_SS_CERTPOL,
	"_AddTemplateToCA(%ws) --> %x\n",
	pwszTemplateName,
	hr));

    if (NULL != hCertType)
    {
        CACloseCertType(hCertType);
    }
    return(hr);
}


VOID
CCertPolicyEnterprise::_ReleaseTemplates()
{
    DWORD i;
    
    if (NULL != m_apTemplatePolicies)
    {
        for (i = 0; i < m_cTemplatePolicies; i++)
        {
            if (NULL != m_apTemplatePolicies[i])
            {
                delete m_apTemplatePolicies[i];
            }
        }
        LocalFree(m_apTemplatePolicies);
        m_apTemplatePolicies = NULL;
    }
    m_cTemplatePolicies = 0;
}


HRESULT 
CCertPolicyEnterprise::_LogLoadTemplateError(
    IN ICertServerPolicy *pServer,
    IN HRESULT hr, 
    LPCWSTR pcwszTemplate)
{
    LPCWSTR apwsz[2];
    LPCWSTR pwszError;

    _PrintErrorStr(hr, "LogLoadTemplateError", pcwszTemplate);
    
    pwszError = myGetErrorMessageText(hr, TRUE);
    apwsz[0] = pcwszTemplate;
    apwsz[1] = pwszError;

    HRESULT hr2 = LogPolicyEvent(
			g_hInstance,
			S_OK,
			MSG_LOAD_TEMPLATE,
			pServer,
			wszPROPEVENTLOGWARNING,
			apwsz);
    _PrintIfError(hr2, "LogPolicyEvent");

    LOCAL_FREE(const_cast<LPWSTR>(pwszError));
    return(hr2);
}


HRESULT
CCertPolicyEnterprise::_LoadTemplates(
    IN ICertServerPolicy *pServer,
    OPTIONAL OUT HCAINFO *phCAInfo)
{
    HRESULT hr;
    HCERTTYPE hCertType = NULL;
    DWORD dwLogId = 0;
    WCHAR **ppwszTemplates = NULL;
    int iTempl, iTemplPol;
    HCAINFO hCAInfo = NULL;
    
    _ReleaseTemplates();

    hr = CAFindByName(
		m_strCASanitizedDSName,
		(WCHAR const *) m_pld,
		CA_FIND_INCLUDE_UNTRUSTED | CA_FLAG_SCOPE_IS_LDAP_HANDLE,
		&hCAInfo);
    if (S_OK != hr)
    {
	dwLogId = MSG_NO_CA_OBJECT;
	_JumpError(hr, error, "Policy:CAFindByName");
    }

    hr = CAGetCAProperty(hCAInfo, CA_PROP_CERT_TYPES, &ppwszTemplates);
    if (S_OK != hr ||
        !ppwszTemplates ||
        !ppwszTemplates[0] ||
        !wcscmp(ppwszTemplates[0], L" "))
    {
        dwLogId = MSG_NO_CERT_TYPES;
        _JumpError(hr, error, "CAGetCAProperty");
    }

    // count # of templates in the CA's list
    for (m_cTemplatePolicies = 0; 
         ppwszTemplates[m_cTemplatePolicies];
         m_cTemplatePolicies++)
        NULL;

    m_apTemplatePolicies = (CTemplatePolicy **) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    sizeof(CTemplatePolicy *) * m_cTemplatePolicies);
    _JumpIfAllocFailed(m_apTemplatePolicies, error);

    for (iTempl = 0, iTemplPol = 0; NULL != ppwszTemplates[iTempl]; iTempl++)
    {
        hr = CAFindCertTypeByName(
			    ppwszTemplates[iTempl],
			    m_pld,
			    CT_FIND_LOCAL_SYSTEM |
				CT_ENUM_MACHINE_TYPES |
				CT_ENUM_USER_TYPES |
				CT_FLAG_SCOPE_IS_LDAP_HANDLE |
				(iTempl? 0 : CT_FLAG_NO_CACHE_LOOKUP),
			    &hCertType);
        if (S_OK != hr)
        {
            // failed to retrieve the template with this name, log an error and
	    // move to the next template name

            _LogLoadTemplateError(pServer, hr, ppwszTemplates[iTempl]);
            continue;
        }

        m_apTemplatePolicies[iTemplPol] = new CTemplatePolicy;
        _JumpIfAllocFailed(m_apTemplatePolicies[iTemplPol], error);

        hr = m_apTemplatePolicies[iTemplPol]->Initialize(hCertType, pServer, this);
        if (S_OK != hr)
        {
            _LogLoadTemplateError(pServer, hr, ppwszTemplates[iTempl]);
            
            delete m_apTemplatePolicies[iTemplPol];
            m_apTemplatePolicies[iTemplPol] = NULL;
            CACloseCertType(hCertType);

            continue;
        }
        iTemplPol++;
    }

    m_cTemplatePolicies = iTemplPol; // # of templates we retrieved successfully
    if (NULL != phCAInfo)
    {
        CAFreeCAProperty(hCAInfo, ppwszTemplates);
	ppwszTemplates = NULL;

	*phCAInfo = hCAInfo;
	hCAInfo = NULL;
    }

error:
    if (0 != dwLogId)
    {
	_BuildErrorInfo(hr, dwLogId);
    }
    if (NULL != ppwszTemplates)
    {
        CAFreeCAProperty(hCAInfo, ppwszTemplates);
    }
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    if (S_OK != hr)
    {
        LOCAL_FREE(m_apTemplatePolicies);
        m_apTemplatePolicies = NULL;
        m_cTemplatePolicies = 0;
    }
    return hr;
}


HRESULT
CCertPolicyEnterprise::_UpgradeTemplatesInDS(
    IN const HCAINFO hCAInfo,
    IN BOOL fForceLoad,
    OUT BOOL *pfTemplateAdded)
{
    HRESULT hr;
    HKEY hkey = NULL;
    DWORD cb;
    BOOL fTemplateAdded = FALSE;

    *pfTemplateAdded = FALSE;
    if (fForceLoad && (EDITF_SERVERUPGRADED & m_dwEditFlags))
    {
	BOOL fUpgradeComplete = TRUE;

	if (FIsAdvancedServer())
	{
	    CTemplatePolicy *pTemplate;

	    hr = FindTemplate(wszCERTTYPE_DC, NULL, &pTemplate);
	    if (S_OK == hr)
	    {
		BOOL fAdded;
		
		hr = _AddTemplateToCA(
				hCAInfo,
				wszCERTTYPE_DC_AUTH,
				&fAdded);
		if (S_OK == hr && fAdded)
		{
		    fTemplateAdded = TRUE;
		}
		if (S_OK != hr)
		{
		    fUpgradeComplete = FALSE;
		}
		hr = _AddTemplateToCA(
				hCAInfo,
				wszCERTTYPE_DS_EMAIL_REPLICATION,
				&fAdded);
		if (S_OK == hr && fAdded)
		{
		    fTemplateAdded = TRUE;
		}
		if (S_OK != hr)
		{
		    fUpgradeComplete = FALSE;
		}
		if (fTemplateAdded)
		{
		    hr = CAUpdateCA(hCAInfo);
		    _JumpIfError(hr, error, "CAUpdateCA");
		}
	    }
	}
	DBGPRINT((
	    DBG_SS_CERTPOL,
	    "_UpdateTemplates: %ws EDITF_SERVERUPGRADED\n",
	    fUpgradeComplete? L"clearing" : L"keeping"));

	if (fUpgradeComplete)
	{
	    m_dwEditFlags &= ~EDITF_SERVERUPGRADED;

	    hr = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,
			m_strRegStorageLoc,
			0,              // dwReserved
			KEY_ALL_ACCESS,
			&hkey);
	    if (S_OK != hr)
	    {
		_PrintIfError(hr, "Policy:RegOpenKeyEx");
	    }
	    else
	    {
		cb = sizeof(m_dwEditFlags);
		hr = RegSetValueEx(
				hkey,
				wszREGEDITFLAGS,
				0,
				REG_DWORD,
				(BYTE *) &m_dwEditFlags,
				cb);
		_PrintIfError(hr, "Policy:RegSetValueEx");
	    }
	}
    }
    *pfTemplateAdded = fTemplateAdded;
    hr = S_OK;

error:
    if (NULL != hkey)
    {
	RegCloseKey(hkey);
    }
    return hr;
}


HRESULT
CCertPolicyEnterprise::_UpdateTemplates(
    IN ICertServerPolicy *pServer,
    IN BOOL fForceLoad)
{
    HRESULT hr;
    BOOL fUpdateTemplates;
    DWORD dwChangeSequence;
    HCAINFO hCAInfo = NULL;
    DWORD dwCATemplListSequenceNum;

    if (NULL == m_hCertTypeQuery)
    {
	hr = HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
        _JumpError(hr, error, "NULL m_hCertTypeQuery");
    }

    hr = CACertTypeQuery(m_hCertTypeQuery, &dwChangeSequence);
    _JumpIfError(hr, error, "CACertTypeQuery");

    hr = polGetCertificateLongProperty(
				pServer,
				wszPROPTEMPLATECHANGESEQUENCENUMBER,
				(LONG *) &dwCATemplListSequenceNum);
    _JumpIfErrorStr(
		hr,
		error, 
		"polGetCertificateLongProperty",
		wszPROPTEMPLATECHANGESEQUENCENUMBER);

    fUpdateTemplates = fForceLoad ||
			!m_fConfigLoaded ||
			dwChangeSequence != m_TemplateSequence ||
			dwCATemplListSequenceNum != m_dwCATemplListSequenceNum;
    DBGPRINT((
	DBG_SS_CERTPOL,
	"_UpdateTemplates(fForce=%u) Sequence=%u->%u, %u->%u: fUpdate=%u\n",
	fForceLoad,
	m_TemplateSequence,
	dwChangeSequence,
	m_dwCATemplListSequenceNum,
	dwCATemplListSequenceNum,
	fUpdateTemplates));

    while (fUpdateTemplates)
    {
	BOOL fTemplateAdded;
	
	hr = _LoadTemplates(pServer, &hCAInfo);
	_JumpIfError(hr, error, "_LoadTemplates");

	m_TemplateSequence = dwChangeSequence;
	m_dwCATemplListSequenceNum = dwCATemplListSequenceNum;

        hr = _UpgradeTemplatesInDS(hCAInfo, fForceLoad, &fTemplateAdded);
        _PrintIfError(hr, "UpgradeTemplatesInDS");

	if (!fTemplateAdded)
	{
	    break;
	}
    }
    hr = S_OK;

error:
    if (NULL != hCAInfo)
    {
        CACloseCA(hCAInfo);
    }
    return(hr);
}


HRESULT
CCertPolicyEnterprise::_BuildErrorInfo(
    IN HRESULT hrLog,
    IN DWORD dwLogId)
{
    HRESULT hr;

    hr = polBuildErrorInfo(
		    hrLog,
		    dwLogId,
		    m_strDescription,
		    NULL,
		    &m_pCreateErrorInfo);
    _JumpIfError(hr, error, "polBuildErrorInfo");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::VerifyRequest
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

#pragma warning(push)
#pragma warning(disable: 4509) // nonstandard extension used: uses SEH and has destructor
// begin_sdksample

STDMETHODIMP
CCertPolicyEnterprise::VerifyRequest(
    /* [in] */ BSTR const, // strConfig
    /* [in] */ LONG Context,
    /* [in] */ LONG bNewRequest,
    /* [in] */ LONG, // Flags
    /* [out, retval] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr = E_FAIL;
    ICertServerPolicy *pServer = NULL;
    LONG lRequestId;
    CRequestInstance Request;
    BSTR strDisposition = NULL;
    BOOL fCritSecEntered = FALSE;	// no_sdksample
    DWORD dwEnrollmentFlags = 0;	// no_sdksample
    BOOL fEnableEnrolleeExtensions;
    BOOL fReenroll = FALSE;
    DWORD cCriticalExtensions = 0;
    WCHAR const * const *apwszCriticalExtensions = NULL;

    lRequestId = 0;

    // end_sdksample
    if (!m_fTemplateCriticalSection)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    // begin_sdksample

    __try
    {
	if (NULL == pDisposition)
	{
	    hr = E_POINTER;
	    _LeaveError(hr, "Policy:pDisposition");
	}
	*pDisposition = VR_INSTANT_BAD;

	hr = polGetServerCallbackInterface(&pServer, Context);
	_LeaveIfError(hr, "Policy:polGetServerCallbackInterface");

	hr = GetRequestId(pServer, &lRequestId);
	_JumpIfError(hr, deny, "Policy:GetRequestId");

	// only need to check user access for original submitter:
	// resubmit can only be called by admins

	if (bNewRequest && (0 == (m_dwEditFlags & EDITF_IGNOREREQUESTERGROUP)))
	{
	    BOOL fRequesterAccess = FALSE;

	    // Is this user allowed to request certs?
	    hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPREQUESTERCAACCESS,
				    (LONG *) &fRequesterAccess);
	    _PrintIfErrorStr(
			hr,
			"Policy:polGetCertificateLongProperty",
			wszPROPREQUESTERCAACCESS);
	    if (hr != S_OK || !fRequesterAccess)
	    {
		hr = CERTSRV_E_ENROLL_DENIED;
		_JumpError(hr, deny, "Policy:fRequesterAccess");
	    }
	}

	// end_sdksample

	EnterCriticalSection(&m_TemplateCriticalSection);
	fCritSecEntered = TRUE;

	if (NULL != m_pCreateErrorInfo)
	{
	    m_pCreateErrorInfo->Release();
	    m_pCreateErrorInfo = NULL;
	}
	hr = S_OK;
	if (IsEnterpriseCA(m_CAType))
	{
	    hr = _UpdateTemplates(pServer, FALSE);
	    _PrintIfError(hr, "Policy:_UpdateTemplates(will rebind)");
	}
	if (!m_fConfigLoaded || S_OK != hr)
	{
	    // Uninitialized or possible LDAP handle gone bad -- rebind
	    // _LoadDSConfig calls _UpdateTemplates

	    hr = _LoadDSConfig(pServer, TRUE);
	    Request.SaveErrorInfo(m_pCreateErrorInfo);
	    m_pCreateErrorInfo = NULL;
	    _LeaveIfError(hr, "Policy:_LoadDSConfig");
	}

	// begin_sdksample

	hr = Request.Initialize(
			    this,
			    IsEnterpriseCA(m_CAType),	// no_sdksample
			    bNewRequest,		// no_sdksample
			    pServer,
			    &fEnableEnrolleeExtensions);
	_LeaveIfError(hr, "Policy:VerifyRequest:Request.Initialize");

	LeaveCriticalSection(&m_TemplateCriticalSection); // no_sdksample
	fCritSecEntered = FALSE;			// no_sdksample

	hr = _EnumerateExtensions(
			    pServer,
			    bNewRequest,
			    TRUE,
			    fEnableEnrolleeExtensions,
			    0,
			    NULL);
	_LeaveIfError(hr, "_EnumerateExtensions");

	if (IsStandaloneCA(m_CAType))	// no_sdksample
	{
	    hr = _AddDefaultBasicConstraintsExtension(
						pServer,
						Request.IsCARequest());
	    _LeaveIfError(hr, "_AddDefaultBasicConstraintsExtension");

	    hr = _AddDefaultKeyUsageExtension(pServer, Request.IsCARequest());
	    _LeaveIfError(hr, "_AddDefaultKeyUsageExtension");

	    hr = _AddEnhancedKeyUsageExtension(pServer);
	    _LeaveIfError(hr, "_AddEnhancedKeyUsageExtension");
	}

	hr = _SetValidityPeriod(pServer);
	_LeaveIfError(hr, "_SetValidityPeriod");

	hr = EnumerateAttributes(pServer);
	_LeaveIfError(hr, "Policy:EnumerateAttributes");

	hr = _AddRevocationExtension(pServer);
	_LeaveIfError(hr, "_AddRevocationExtension");

	hr = _AddOldCertTypeExtension(pServer, Request.IsCARequest());
	_LeaveIfError(hr, "_AddOldCertTypeExtension");

	hr = _AddAuthorityKeyId(pServer);
	_LeaveIfError(hr, "_AddAuthorityKeyId");

	// end_sdksample

	hr = _PatchExchangeSubjectAltName(pServer, Request.GetTemplateName());
	_LeaveIfError(hr, "_PatchExchangeSubjectAltName");

	cCriticalExtensions = 0;
	if (IsEnterpriseCA(m_CAType))
	{
	    hr = Request.ApplyTemplate(
				pServer,
				&fReenroll,
				&dwEnrollmentFlags,
				&cCriticalExtensions,
				&apwszCriticalExtensions);
	    _JumpIfError(hr, deny, "_ApplyTemplate"); // pass hr as Disposition
	}

	hr = _AddSubjectAltNameExtension(pServer, 0);
	_LeaveIfError(hr, "_AddSubjectAltNameExtension");

	hr = _AddSubjectAltNameExtension(pServer, 1);
	_LeaveIfError(hr, "_AddSubjectAltNameExtension");

	// bug# 630833: if application policies are present but no EKU, copy
	// all app policies to EKU extension
	hr = _DuplicateAppPoliciesToEKU(pServer);
	_LeaveIfError(hr, "_DuplicateAppPoliciesToEKU");

	// begin_sdksample

	// pass hr as Disposition

	if ((EDITF_DISABLEEXTENSIONLIST & m_dwEditFlags) ||
	    NULL != apwszCriticalExtensions)
	{
	    hr = _EnumerateExtensions(
				pServer,
				bNewRequest,
				FALSE,
				FALSE,
				cCriticalExtensions,
				apwszCriticalExtensions);
	    _LeaveIfError(hr, "_EnumerateExtensions");
	}

	if (bNewRequest &&
	    (
	     ((CT_FLAG_PEND_ALL_REQUESTS & dwEnrollmentFlags) && !fReenroll) ||	// no_sdksample
	     (REQDISP_PENDINGFIRST & m_dwDispositionFlags)))
	{
	    *pDisposition = VR_PENDING;
	}
	else switch (REQDISP_MASK & m_dwDispositionFlags)
	{
	    default:
	    case REQDISP_PENDING:
		*pDisposition = VR_PENDING;
		break;

	    case REQDISP_ISSUE:
		*pDisposition = VR_INSTANT_OK;
		break;

	    case REQDISP_DENY:
		*pDisposition = VR_INSTANT_BAD;
		break;

	    case REQDISP_USEREQUESTATTRIBUTE:
		*pDisposition = VR_INSTANT_OK;
		hr = polGetRequestAttribute(
				    pServer,
				    wszPROPDISPOSITION,
				    &strDisposition);
		if (S_OK == hr)
		{
		    if (0 == LSTRCMPIS(strDisposition, wszPROPDISPOSITIONDENY))
		    {
			*pDisposition = VR_INSTANT_BAD;
		    }
		    if (0 == LSTRCMPIS(strDisposition, wszPROPDISPOSITIONPENDING))
		    {
			*pDisposition = VR_PENDING;
		    }
		}
		hr = S_OK;
		break;
	}
deny:
	if (FAILED(hr))
	{
	    *pDisposition = hr;	// pass failed HRESULT back as Disposition
	}
	else if (hr != S_OK)
	{
	    *pDisposition = VR_INSTANT_BAD;
	}
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:				// no_sdksample
    {
	HRESULT hr2 = hr;
#define wszFORMATREQUESTID	L"RequestId=%u"
	WCHAR wszRequestId[ARRAYSIZE(wszFORMATREQUESTID) + cwcDWORDSPRINTF];

	if (S_OK == hr2 && NULL != pDisposition && FAILED(*pDisposition))
	{
	    hr2 = *pDisposition;
	}
	if (S_OK != hr2)
	{
	    wsprintf(wszRequestId, wszFORMATREQUESTID, lRequestId);
	    _PrintErrorStr(hr2, "VerifyRequest", wszRequestId);
	}
    }
    if (NULL != strDisposition)
    {
	SysFreeString(strDisposition);
    }
    if (NULL != pServer)
    {
        pServer->Release();
    }
    // end_sdksample
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&m_TemplateCriticalSection);
    }
    Request.SetErrorInfo();
    // begin_sdksample
    //_PrintIfError(hr, "Policy:VerifyRequest(hr)");
    //_PrintError(*pDisposition, "Policy:VerifyRequest(*pDisposition)");
    return(hr);
}
#pragma warning(pop)	// no_sdksample


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::GetDescription
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyEnterprise::GetDescription(
    /* [out, retval] */ BSTR __RPC_FAR *pstrDescription)
{
    HRESULT hr = S_OK;
    WCHAR sz[MAX_PATH];

    if(!m_strDescription)
    {
#ifdef IDS_MODULE_NAME						// no_sdksample
	if (!LoadString(g_hInstance, IDS_MODULE_NAME, sz, ARRAYSIZE(sz))) // no_sdksample
	{							// no_sdksample
	    sz[0] = L'\0';					// no_sdksample
	}							// no_sdksample
#else								// no_sdksample
	CSASSERT(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
	wcsncpy(sz, wsz_SAMPLE_DESCRIPTION, ARRAYSIZE(sz));
	sz[ARRAYSIZE(sz) - 1] = L'\0';
#endif								// no_sdksample

	m_strDescription = SysAllocString(sz);
	if (NULL == m_strDescription)
	{
	    hr = E_OUTOFMEMORY;
	    return hr;
	}
    }

    if (NULL != *pstrDescription)
    {
        SysFreeString(*pstrDescription);
    }

    *pstrDescription = SysAllocString(m_strDescription);
    if (NULL == *pstrDescription)
    {
        hr = E_OUTOFMEMORY;
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::ShutDown
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyEnterprise::ShutDown(VOID)
{
    // called once, as Server unloading policy dll
    _Cleanup();
    ReqCleanup();	// no_sdksample
    TPCleanup();	// no_sdksample
    return(S_OK);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::GetManageModule
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyEnterprise::GetManageModule(
    /* [out, retval] */ ICertManageModule **ppManageModule)
{
    HRESULT hr;
    
    *ppManageModule = NULL;
    hr = CoCreateInstance(
		    CLSID_CCertManagePolicyModule,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
		    IID_ICertManageModule,
                    (VOID **) ppManageModule);
    _JumpIfError(hr, error, "CoCreateInstance");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_GetIssuer
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

PCCERT_CONTEXT
CCertPolicyEnterprise::_GetIssuer(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    VARIANT varValue;
    BSTR strName = NULL;

    VariantInit(&varValue);
    if (NULL != m_pCert)
    {
        hr = S_OK;
	goto error;
    }
    strName = SysAllocString(wszPROPRAWCACERTIFICATE);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateProperty(strName, PROPTYPE_BINARY, &varValue);
    _JumpIfError(hr, error, "Policy:GetCertificateProperty");

    m_pCert = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    (BYTE *) varValue.bstrVal,
				    SysStringByteLen(varValue.bstrVal));
    if (NULL == m_pCert)
    {
	hr = myHLastError();
	_JumpError(hr, error, "Policy:CertCreateCertificateContext");
    }

error:
    VariantClear(&varValue);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(m_pCert);
}


STDMETHODIMP
CCertPolicyEnterprise::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
        &IID_ICertPolicy,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (IsEqualGUID(*arr[i], riid))
        {
            return(S_OK);
        }
    }
    return(S_FALSE);
}

// end_sdksample
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\default\policy.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       policy.h
//
//--------------------------------------------------------------------------

// policy.h: Declaration of CCertPolicyEnterprise


#include "resource.h"

#include <certca.h>
#include <userenv.h>
#include <dsgetdc.h>
#include <winldap.h>

/////////////////////////////////////////////////////////////////////////////
// certpol


extern HANDLE g_hEventLog;
extern HINSTANCE g_hInstance;

#define MAX_INSERTION_ARRAY_SIZE 100
#define  B3_VERSION_NUMBER 2031

#define CONFIGURE_EVENT_FORMAT TEXT("CA Configuration %ls")


#define DS_ATTR_COMMON_NAME		L"cn"
//#define DS_ATTR_DISTINGUISHED_NAME	L"distinguishedName"
#define DS_ATTR_DNS_NAME		L"dNSHostName"
#define DS_ATTR_EMAIL_ADDR		L"mail"
#define DS_ATTR_OBJECT_GUID		L"objectGUID"
#define DS_ATTR_UPN			L"userPrincipalName"


class CTemplatePolicy;

HRESULT
polGetProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    IN DWORD PropType,
    OUT VARIANT *pvarOut);

HRESULT
polBuildErrorInfo(
    IN HRESULT hrLog,
    IN DWORD dwLogId,
    IN WCHAR const *pwszDescription,
    IN WCHAR const * const *ppwszInsert,	// array of insert strings
    OPTIONAL IN OUT ICreateErrorInfo **ppCreateErrorInfo);

HRESULT
TPInitialize(
    IN ICertServerPolicy *pServer);

VOID
TPCleanup();


// begin_sdksample

HRESULT
ReqInitialize(
    IN ICertServerPolicy *pServer);

VOID
ReqCleanup(VOID);


class CRequestInstance;

#ifndef __BSTRC__DEFINED__
#define __BSTRC__DEFINED__
typedef OLECHAR const *BSTRC;
#endif

HRESULT
polGetServerCallbackInterface(
    OUT ICertServerPolicy **ppServer,
    IN LONG Context);

HRESULT
polGetRequestStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut);

HRESULT
polGetCertificateStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut);

HRESULT
polGetRequestLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut);

HRESULT
polGetCertificateLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut);

HRESULT
polGetRequestAttribute(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszAttributeName,
    OUT BSTR *pstrOut);

HRESULT
polGetCertificateExtension(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszExtensionName,
    IN DWORD dwPropType,
    IN OUT VARIANT *pvarOut);

HRESULT
polSetCertificateExtension(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszExtensionName,
    IN DWORD dwPropType,
    IN DWORD dwExtFlags,
    IN VARIANT const *pvarIn);

DWORD
polFindObjIdInList(
    IN WCHAR const *pwsz,
    IN DWORD count,
    IN WCHAR const * const *ppwsz);

// 
// Class CCertPolicyEnterprise
// 
// Actual policy module for a CA Policy
//
//

class CCertPolicyEnterprise: 
    public CComDualImpl<ICertPolicy2, &IID_ICertPolicy2, &LIBID_CERTPOLICYLib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertPolicyEnterprise, &CLSID_CCertPolicy>
{
public:
    CCertPolicyEnterprise()
    {
	m_strDescription = NULL;

        // RevocationExtension variables:

	m_dwRevocationFlags = 0;
	m_wszASPRevocationURL = NULL;

        m_dwDispositionFlags = 0;
        m_dwEditFlags = 0;

	m_cEnableRequestExtensions = 0;
	m_apwszEnableRequestExtensions = NULL;

	m_cEnableEnrolleeRequestExtensions = 0;
	m_apwszEnableEnrolleeRequestExtensions = NULL;

	m_cDisableExtensions = 0;
	m_apwszDisableExtensions = NULL;

	// CA Name
        m_strRegStorageLoc = NULL;

	m_strCAName = NULL;
        m_strCASanitizedName = NULL;
        m_strCASanitizedDSName = NULL;
        m_strMachineDNSName = NULL;

        // CA and cert type info

        m_CAType = ENUM_UNKNOWN_CA;

        m_pCert = NULL;
        m_iCRL = 0;

	// end_sdksample
	//+--------------------------------------

	// CertTypeExtension variables:

	m_astrSubjectAltNameProp[0] = NULL;
	m_astrSubjectAltNameProp[1] = NULL;
	m_astrSubjectAltNameObjectId[0] = NULL;
	m_astrSubjectAltNameObjectId[1] = NULL;

	m_fTemplateCriticalSection = FALSE;
	m_pCreateErrorInfo = NULL;

	m_pbSMIME = NULL;
        m_fUseDS = FALSE;
	m_dwLogLevel = CERTLOG_WARNING;
        m_pld = NULL;
	m_pwszHostName = NULL;
	m_hCertTypeQuery = NULL;
        m_strDomainDN = NULL;
        m_strConfigDN = NULL;
        m_cTemplatePolicies = 0;
        m_apTemplatePolicies = NULL;
	m_fConfigLoaded = FALSE;
	m_dwCATemplListSequenceNum = 0;
	m_TemplateSequence = 0;

	//+--------------------------------------
	// begin_sdksample
    }
    ~CCertPolicyEnterprise();

BEGIN_COM_MAP(CCertPolicyEnterprise)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertPolicy)
    COM_INTERFACE_ENTRY(ICertPolicy2)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertPolicyEnterprise) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertPolicyEnterprise,
    wszCLASS_CERTPOLICY TEXT(".1"),
    wszCLASS_CERTPOLICY,
    IDS_CERTPOLICY_DESC,
    THREADFLAGS_BOTH)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ICertPolicy
public:
    STDMETHOD(Initialize)( 
		/* [in] */ BSTR const strConfig);

    STDMETHOD(VerifyRequest)( 
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG Context,
		/* [in] */ LONG bNewRequest,
		/* [in] */ LONG Flags,
		/* [out, retval] */ LONG __RPC_FAR *pDisposition);

    STDMETHOD(GetDescription)( 
		/* [out, retval] */ BSTR __RPC_FAR *pstrDescription);

    STDMETHOD(ShutDown)();

// ICertPolicy2
public:
    STDMETHOD(GetManageModule)(
		/* [out, retval] */ ICertManageModule **ppManageModule);

public:
    HRESULT AddBasicConstraintsCommon(
		IN ICertServerPolicy *pServer,
		IN CERT_EXTENSION const *pExtension,
		IN BOOL fCA,
		IN BOOL fEnableExtension);

    BSTRC GetPolicyDescription() { return(m_strDescription); }

// end_sdksample

    HRESULT FindTemplate(
		OPTIONAL IN WCHAR const *pwszTemplateName,
		OPTIONAL IN WCHAR const *pwszTemplateObjId,
		OUT CTemplatePolicy **ppTemplate);

    DWORD GetLogLevel() { return(m_dwLogLevel); }
    DWORD GetEditFlags() { return(m_dwEditFlags); }
    BYTE const *GetSMIME(OUT DWORD *pcbSMIME)
    {
	*pcbSMIME = m_cbSMIME;
	return(m_pbSMIME);
    }

// begin_sdksample

    HRESULT AddV1TemplateNameExtension(
		IN ICertServerPolicy *pServer,
		OPTIONAL IN WCHAR const *pwszTemplateName);

private:
    CERT_CONTEXT const *_GetIssuer(
		IN ICertServerPolicy *pServer);

    HRESULT _EnumerateExtensions(
		IN ICertServerPolicy *pServer,
		IN LONG bNewRequest,
		IN BOOL fFirstPass,
		IN BOOL fEnableEnrolleeExtensions,
		IN DWORD cCriticalExtensions,
		IN WCHAR const * const *apwszCriticalExtensions);

#if DBG_CERTSRV
    VOID _DumpStringArray(
		IN char const *pszType,
		IN DWORD count,
		IN LPWSTR const *apwsz);
#else
    #define _DumpStringArray(pszType, count, apwsz)
#endif

    VOID _FreeStringArray(
		IN OUT DWORD *pcString,
		IN OUT LPWSTR **papwsz);

    VOID _Cleanup();


    HRESULT _SetSystemStringProp(
		IN ICertServerPolicy *pServer,
		IN WCHAR const *pwszName,
		OPTIONAL IN WCHAR const *pwszValue);

    HRESULT _AddStringArray(
		IN WCHAR const *pwszzValue,
		IN BOOL fURL,
		IN OUT DWORD *pcStrings,
		IN OUT LPWSTR **papwszRegValues);

    HRESULT _ReadRegistryString(
		IN HKEY hkey,
		IN BOOL fURL,
		IN WCHAR const *pwszRegName,
		IN WCHAR const *pwszSuffix,
		OUT LPWSTR *pwszRegValue);

    HRESULT _ReadRegistryStringArray(
		IN HKEY hkey,
		IN BOOL fURL,
		IN DWORD dwFlags,
		IN DWORD cRegNames,
		IN DWORD *aFlags,
		IN WCHAR const * const *apwszRegNames,
		IN OUT DWORD *pcStrings,
		IN OUT LPWSTR **papwszRegValues);

    VOID _InitRevocationExtension(
		IN HKEY hkey);

    VOID _InitRequestExtensionList(
		IN HKEY hkey);

    VOID _InitDisableExtensionList(
		IN HKEY hkey);

    HRESULT _AddRevocationExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddOldCertTypeExtension(
		IN ICertServerPolicy *pServer,
		IN BOOL fCA);

    HRESULT _AddAuthorityKeyId(
		IN ICertServerPolicy *pServer);

    HRESULT _AddDefaultKeyUsageExtension(
		IN ICertServerPolicy *pServer,
		IN BOOL fCA);

    HRESULT _AddEnhancedKeyUsageExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddDefaultBasicConstraintsExtension(
		IN ICertServerPolicy *pServer,
		IN BOOL fCA);

    HRESULT _SetValidityPeriod(
		IN ICertServerPolicy *pServer);

// end_sdksample

    VOID _InitSubjectAltNameExtension(
		IN HKEY hkey,
		IN WCHAR const *pwszRegName,
		IN WCHAR const *pwszObjectId,
		IN DWORD iAltName);

    VOID _InitDefaultSMIMEExtension(
		IN HKEY hkey);

    HRESULT _AddSubjectAltNameExtension(
		IN ICertServerPolicy *pServer,
		IN DWORD iAltName);

    HRESULT _PatchExchangeSubjectAltName(
		IN ICertServerPolicy *pServer,
		OPTIONAL IN BSTRC strTemplateName);

    HRESULT _LoadDSConfig(
		IN ICertServerPolicy *pServer,
		IN BOOL fRediscover);

    VOID _UnloadDSConfig();

    HRESULT _UpdateTemplates(
		IN ICertServerPolicy *pServer,
		IN BOOL fForceLoad);

    HRESULT _UpgradeTemplatesInDS(
		IN const HCAINFO hCAInfo,
		IN BOOL fForceLoad,
		OUT BOOL *pfTemplateAdded);

    HRESULT _LogLoadTemplateError(
                IN ICertServerPolicy *pServer,
                HRESULT hr, 
                LPCWSTR pcwszTemplate);

    HRESULT _LoadTemplates(
		IN ICertServerPolicy *pServer,
		OPTIONAL OUT HCAINFO *phCAInfo);

    VOID _ReleaseTemplates();

    HRESULT _AddTemplateToCA(
		IN HCAINFO hCAInfo,
		IN WCHAR const *pwszTemplateName,
		OUT BOOL *pfAdded);

    HRESULT _BuildErrorInfo(
		IN HRESULT hrLog,
		IN DWORD dwLogId);

    HRESULT _DuplicateAppPoliciesToEKU(
        IN ICertServerPolicy *pServer);

// begin_sdksample

private:
    // RevocationExtension variables:

    CERT_CONTEXT const *m_pCert;

    BSTR m_strDescription;

    DWORD m_dwRevocationFlags;
    LPWSTR m_wszASPRevocationURL;

    DWORD m_dwDispositionFlags;
    DWORD m_dwEditFlags;
    DWORD m_CAPathLength;

    DWORD m_cEnableRequestExtensions;
    LPWSTR *m_apwszEnableRequestExtensions;

    DWORD m_cEnableEnrolleeRequestExtensions;
    LPWSTR *m_apwszEnableEnrolleeRequestExtensions;

    DWORD m_cDisableExtensions;
    LPWSTR *m_apwszDisableExtensions;

    // CertTypeExtension variables:

    BSTR m_strRegStorageLoc;
    BSTR m_strCAName;

    BSTR m_strCASanitizedName;
    BSTR m_strCASanitizedDSName;

    BSTR m_strMachineDNSName;

    // CA and cert type info

    ENUM_CATYPES m_CAType;

    DWORD m_iCert;
    DWORD m_iCRL;

    // end_sdksample
    //+--------------------------------------

    // SubjectAltNameExtension variables:

    BSTR m_astrSubjectAltNameProp[2];
    BSTR m_astrSubjectAltNameObjectId[2];

    CRITICAL_SECTION m_TemplateCriticalSection;
    BOOL m_fTemplateCriticalSection;
    ICreateErrorInfo *m_pCreateErrorInfo;

    BOOL              m_fUseDS;
    DWORD             m_dwLogLevel;
    LDAP             *m_pld;
    WCHAR            *m_pwszHostName;
    HCERTTYPEQUERY    m_hCertTypeQuery;
    DWORD             m_TemplateSequence;
    BSTR              m_strDomainDN;
    BSTR  	      m_strConfigDN;

    DWORD             m_cTemplatePolicies;
    CTemplatePolicy **m_apTemplatePolicies;
    BOOL              m_fConfigLoaded;
    DWORD             m_dwCATemplListSequenceNum;
    BYTE *m_pbSMIME;
    DWORD m_cbSMIME;

    //+--------------------------------------
    // begin_sdksample
};

// end_sdksample


// Class CTemplatePolicy
// Sub Policy information for a CA policy

typedef struct _OBJECTIDLIST {
    DWORD cObjId;
    WCHAR **rgpwszObjId;
} OBJECTIDLIST;
 
// Template properties that can be cloned via CopyMemory:

typedef struct _TEMPLATEPROPERTIES {
    DWORD	dwTemplateMajorVersion;
    DWORD	dwTemplateMinorVersion;
    DWORD	dwSchemaVersion;
    DWORD	dwEnrollmentFlags;
    DWORD	dwSubjectNameFlags;
    DWORD	dwPrivateKeyFlags;
    DWORD	dwGeneralFlags;
    DWORD	dwMinKeyLength;
    DWORD	dwcSignatureRequired;
    LLFILETIME	llftExpirationPeriod;
    LLFILETIME	llftOverlapPeriod;
} TEMPLATEPROPERTIES;

 
class CTemplatePolicy
{
public:
    CTemplatePolicy();
    ~CTemplatePolicy();

    HRESULT Initialize(
		IN HCERTTYPE hCertType,
		IN ICertServerPolicy *pServer,
		IN CCertPolicyEnterprise *pPolicy);

    HRESULT AccessCheck(
		IN HANDLE hToken);

    HRESULT Clone(
		OUT CTemplatePolicy **ppTemplate);

    HRESULT Apply(
		IN ICertServerPolicy *pServer, 
		IN CRequestInstance *pRequest,
		OUT BOOL *pfReenroll);

    HRESULT GetFlags(
		IN DWORD dwOption,
		OUT DWORD *pdwFlags);

    HRESULT GetCriticalExtensions(
		OUT DWORD *pcCriticalExtensions,
		OUT WCHAR const * const **papwszCriticalExtensions);

    BOOL IsRequestedTemplate(
		OPTIONAL IN WCHAR const *pwszTemplateName,
		OPTIONAL IN WCHAR const *pwszTemplateObjId);

    HRESULT GetV1TemplateClass(
		OUT WCHAR const **ppwszV1TemplateClass);

    WCHAR const *GetTemplateName() { return(m_pwszTemplateName); }
    WCHAR const *GetTemplateObjId() { return(m_pwszTemplateObjId); }

private:
    VOID _Cleanup();

    HRESULT _CloneExtensions(
		IN CERT_EXTENSIONS const *pExtensionsIn,
		OUT CERT_EXTENSIONS **ppExtensionsOut);

    HRESULT _CloneObjectIdList(
		IN OBJECTIDLIST const *pObjectIdListIn,
		OUT OBJECTIDLIST *pObjectIdListOut);

    HRESULT _LogLoadResult(
		IN CCertPolicyEnterprise *pPolicy,
		IN ICertServerPolicy *pServer,
		IN HRESULT hrLoad);

    HRESULT _InitBasicConstraintsExtension(
		IN HKEY hkey);

    HRESULT _AddBasicConstraintsExtension(
                IN CRequestInstance *pRequest,
		IN ICertServerPolicy *pServer);

    HRESULT _InitKeyUsageExtension(
		IN HKEY hkey);

    HRESULT _AddKeyUsageExtension(
		IN ICertServerPolicy *pServer,
		IN CRequestInstance *pRequest);

    HRESULT _AddTemplateExtensionArray(
		IN ICertServerPolicy *pServer);

    HRESULT _AddTemplateExtension(
		IN ICertServerPolicy *pServer,
		IN CERT_EXTENSION const *pExt);

    HRESULT _AddSubjectName(
		IN ICertServerPolicy *pServer,
                IN CRequestInstance *pRequest);

    HRESULT _AddDSDistinguishedName(
		IN ICertServerPolicy *pServer,
		IN CRequestInstance *pRequest);

    HRESULT _AddAltSubjectName(
                IN ICertServerPolicy *pServer,
                IN CRequestInstance *pRequest);

    HRESULT _ApplyExpirationTime(
                IN ICertServerPolicy *pServer,
                IN CRequestInstance *pRequest);

    HRESULT _EnforceKeySizePolicy(
                IN ICertServerPolicy *pServer);

    HRESULT _EnforceKeyArchivalPolicy(
                IN ICertServerPolicy *pServer);

    HRESULT _EnforceSymmetricAlgorithms(
		IN ICertServerPolicy *pServer);

    HRESULT _EnforceMinimumTemplateVersion(
		IN CRequestInstance *pRequest);

    HRESULT _EnforceEnrollOnBehalfOfAllowed(
		IN ICertServerPolicy *pServer,
		OUT BOOL *pfEnrollOnBehalfOf);

    HRESULT _EnforceReenrollment(
		IN ICertServerPolicy *pServer,
		IN CRequestInstance *pRequest);

    HRESULT _EnforceSignaturePolicy(
                IN ICertServerPolicy *pServer,
		IN CRequestInstance *pRequest,
		IN BOOL fEnrollOnBehalfOf);

    HRESULT _LoadSignaturePolicies(
		IN ICertServerPolicy *pServer,
		IN WCHAR const *pwszPropNameRequest,
		OUT DWORD *pcPolicies,
		OUT OBJECTIDLIST **pprgPolicies);

private:
    HCERTTYPE              m_hCertType;
    TEMPLATEPROPERTIES	   m_tp;
    WCHAR                 *m_pwszTemplateName;
    WCHAR                 *m_pwszTemplateObjId;
    CERT_EXTENSIONS       *m_pExtensions;
    OBJECTIDLIST	   m_CriticalExtensions;
    OBJECTIDLIST	   m_PoliciesApplication;
    OBJECTIDLIST	   m_PoliciesIssuance;
    CCertPolicyEnterprise *m_pPolicy;
};


// begin_sdksample
// 
// Class CRequestInstance
// 
// Instance data for a certificate that is being created.
//

class CRequestInstance
{
    friend class CTemplatePolicy;	// no_sdksample

public:
    CRequestInstance()
    {
        m_strTemplateName = NULL;
	m_strTemplateObjId = NULL;
	m_pPolicy = NULL;

	// end_sdksample
	//+--------------------------------------

	m_pTemplate = NULL;
        m_hToken = NULL;
	m_pldGC = NULL;
	m_pldClientDC = NULL;
	m_pldT = NULL;
        m_SearchResult = NULL;
        m_PrincipalAttributes = NULL;

        m_strUserDN = NULL;
        m_pwszUPN = NULL;

        // The default version for clients is W2K beta3 (2031)

        m_RequestOsVersion.dwOSVersionInfoSize = sizeof(m_RequestOsVersion);
        m_RequestOsVersion.dwMajorVersion = 5;
        m_RequestOsVersion.dwMinorVersion = 0;
        m_RequestOsVersion.dwBuildNumber = B3_VERSION_NUMBER;
        m_RequestOsVersion.dwPlatformId = VER_PLATFORM_WIN32_NT;
        m_RequestOsVersion.szCSDVersion[0] = L'\0';
        m_RequestOsVersion.wServicePackMajor = 0;
        m_RequestOsVersion.wServicePackMinor = 0;
        m_RequestOsVersion.wSuiteMask = 0;
        m_RequestOsVersion.wProductType = 0;
        m_RequestOsVersion.wReserved = 0;
	m_fClientVersionSpecified = FALSE;
        m_fIsXenrollRequest = FALSE;
        m_fNewRequest = TRUE;
	m_pCreateErrorInfo = NULL;

	//+--------------------------------------
	// begin_sdksample
    }

    ~CRequestInstance();

    HRESULT Initialize(
		IN CCertPolicyEnterprise *pPolicy,
		IN BOOL fEnterpriseCA,	// no_sdksample
		IN BOOL bNewRequest,	// no_sdksample
		IN ICertServerPolicy *pServer,
		OUT BOOL *pfEnableEnrolleeExtensions);

    HRESULT SetTemplateName(
		IN ICertServerPolicy *pServer,
		IN OPTIONAL WCHAR const *pwszTemplateName,
		IN OPTIONAL WCHAR const *pwszTemplateObjId);

    BSTRC GetTemplateName() { return(m_strTemplateName); }
    BSTRC GetTemplateObjId() { return(m_strTemplateObjId); }

    // end_sdksample

    VOID SaveErrorInfo(
		OPTIONAL IN ICreateErrorInfo *pCreateErrorInfo);

    HRESULT SetErrorInfo();

    HRESULT BuildErrorInfo(
		IN HRESULT hrLog,
		IN DWORD dwLogId,
		OPTIONAL IN WCHAR const * const *ppwszInsert);

    HRESULT ApplyTemplate(
		IN ICertServerPolicy *pServer,
		OUT BOOL *pfReenroll,
		OUT DWORD *pdwEnrollmentFlags,
		OUT DWORD *pcCriticalExtensions,
		OUT WCHAR const * const **papwszCriticalExtensions);

    VOID GetTemplateVersion(
		OUT DWORD *pdwTemplateMajorVersion,
		OUT DWORD *pdwTemplateMinorVersion);

    BOOL IsNewRequest() { return m_fNewRequest; }

    // begin_sdksample

    BOOL IsCARequest() { return(m_fCA); }

    CCertPolicyEnterprise *GetPolicy() { return(m_pPolicy); }

private:

    HRESULT _SetFlagsProperty(
		IN ICertServerPolicy *pServer,
		IN WCHAR const *pwszPropName,
		IN DWORD dwFlags);

    BOOL _TemplateNamesMatch(
		IN WCHAR const *pwszTemplateName1,
		IN WCHAR const *pwszTemplateName2,
		OUT BOOL *pfTemplateMissing);

    // end_sdksample
    //+--------------------------------------

    HRESULT _InitToken(
		IN ICertServerPolicy *pServer);

    HRESULT _InitClientOSVersionInfo(
		IN ICertServerPolicy *pServer);

    HANDLE _GetToken() { return(m_hToken); }

    BOOL _IsUser() { return(m_fUser); }

    BOOL _IsXenrollRequest() { return(m_fIsXenrollRequest); }

    BOOL _ClientVersionSpecified() { return(m_fClientVersionSpecified); }


    // Return TRUE if the requesting client is running NT and the OS version is
    // older than the passed version.

    BOOL _IsNTClientOlder(
		IN DWORD dwMajor,
		IN DWORD dwMinor,
		IN DWORD dwBuild,
		IN DWORD dwPlatform)
    {
	return(
	    dwPlatform == m_RequestOsVersion.dwPlatformId &&
	    (dwMajor > m_RequestOsVersion.dwMajorVersion ||
	     (dwMajor == m_RequestOsVersion.dwMajorVersion &&
	      (dwMinor > m_RequestOsVersion.dwMinorVersion ||
	       (dwMinor == m_RequestOsVersion.dwMinorVersion &&
		dwBuild > m_RequestOsVersion.dwBuildNumber)))));
    }

    HRESULT _GetValueString(
		IN WCHAR const *pwszName,
		OUT BSTRC *pstrValue);

    HRESULT _GetValues(
		IN WCHAR const *pwszName,
		OUT WCHAR ***pppwszValues);

    HRESULT _FreeValues(
		IN WCHAR **ppwszValues);

    HRESULT _GetObjectGUID(
		OUT BSTR *pstrGuid);

    HRESULT _LoadPrincipalObject(
		IN ICertServerPolicy *pServer,
		IN CTemplatePolicy *pTemplate,
		IN BOOL fDNSNameRequired);

    VOID _ReleasePrincipalObject();

    VOID _Cleanup();		// add_sdksample

    HRESULT _GetDSObject(
		IN ICertServerPolicy *pServer,
		IN BOOL fDNSNameRequired,
		OPTIONAL IN WCHAR const *pwszClientDC);

private:			// add_sdksample
    HANDLE                 m_hToken;
    LDAP		  *m_pldGC;
    LDAP		  *m_pldClientDC;
    LDAP		  *m_pldT;
    BOOL                   m_fUser;		    // This is a user 
    BOOL                   m_fEnterpriseCA;

    LDAPMessage           *m_SearchResult;
    LDAPMessage           *m_PrincipalAttributes;  // Collected attrs for cert 
    BSTR                   m_strUserDN;		   // Path to principal object
    WCHAR                 *m_pwszUPN;		   // Principal Name

    OSVERSIONINFOEX        m_RequestOsVersion;	   // request version info
    BOOL                   m_fIsXenrollRequest;    // not Netscape keygen
    BOOL                   m_fClientVersionSpecified;
    CTemplatePolicy       *m_pTemplate;
    ICreateErrorInfo	  *m_pCreateErrorInfo;

    //+--------------------------------------
    // begin_sdksample
    CCertPolicyEnterprise *m_pPolicy;
    BSTR                   m_strTemplateName;	// certificate type requested
    BSTR                   m_strTemplateObjId;	// certificate type requested
    DWORD                  m_dwTemplateMajorVersion;
    DWORD                  m_dwTemplateMinorVersion;
    BOOL                   m_fCA;
    BOOL                   m_fNewRequest;   // set if new request, no_sdksample
};
// end_sdksample
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\default\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certpent.rc
//
#define IDS_CERTPOLICY_DESC             1
#define IDS_CERTMANAGEPOLICYMODULE_DESC 2
#define IDS_NO_CONFIGURABLE_DATA        3
#define IDC_RADIO1                      201
#define IDC_RADIO_ISSUE                 202
#define IDC_EDIT1                       203
#define IDC_ADD_CRL                     205
#define IDC_REMOVE_CRL                  206
#define IDC_ADD_AIA                     207
#define IDC_REMOVE_AIA                  208
#define IDC_TEXT_PENDFIRST              209
#define IDC_RADIO_PENDFIRST             211
#define IDC_RADIO2                      212
#define IDD_POLICYPG1                   609
#define IDS_MODULE_NAME                 611
#define IDS_MODULE_DESCR                612
#define IDS_MODULE_COPYRIGHT            613
#define IDS_WARNING_REBOOT              616
#define IDS_WARNING_NOSAVE              617
#define IDC_CRL_LIST                    737
#define IDC_AIA_LIST                    738
#define IDB_CHECKLIST                   739
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         206
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\default\request.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        request.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <ntdsapi.h>
#include <lm.h>
#include <winldap.h>
#include <security.h>

#include "cspelog.h"
#include "pollog.h"

#include "csprop.h"
#include "csldap.h"
#include "csdisp.h"
#include "policy.h"
#include "cainfop.h"

#define __dwFILE__	__dwFILE_POLICY_DEFAULT_REQUEST_CPP__



LDAP **g_rgGCCache = NULL;
LONG g_cGCCacheCur;
LONG g_cGCCacheMax;
CRITICAL_SECTION g_GCCacheCriticalSection;
BOOL g_fGCCacheCriticalSection = FALSE;


VOID
myLdapUnbind(
    IN OUT LDAP **ppld)
{
    if (NULL != *ppld)
    {
	ldap_unbind(*ppld);
	*ppld = NULL;
    }
}


HRESULT
myLdapBind(
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszClientDC, // require GC unless non-NULL
    IN OUT LDAP **ppld)
{
    HRESULT hr;
    ULONG ldaperr;
    DWORD GetDSNameFlags;
    WCHAR *pwszDomainControllerName;
    BOOL fGC = NULL == pwszClientDC;
    BOOL fRediscover = FALSE;
    LDAP *pld = *ppld;

    GetDSNameFlags = DS_RETURN_DNS_NAME;
    if (fGC)
    {
	// We want to talk to a GC, so grab the GC name.  Get the GC location.

	GetDSNameFlags |= DS_GC_SERVER_REQUIRED;
    }

    while (TRUE)
    {
        if (NULL != *ppld)
	{
            break;
	}

        // Clean up from previous loop execution

        if (NULL != pld)
        {
            ldap_unbind(pld);
            pld = NULL;
        }

        // Grab an LDAP handle for use during this instantiation

        pld = ldap_init(
		    const_cast<WCHAR *>(pwszClientDC),
		    fGC? LDAP_GC_PORT : LDAP_PORT);
        if (NULL == pld)
        {
	    hr = myHLdapLastError(NULL, NULL);
            if (!fRediscover)
            {
		_PrintError2(hr, "Policy:ldap_init", hr);
                fRediscover = TRUE;
                continue;
            }
	    _JumpError(hr, error, "Policy:ldap_init");
        }
	if (fRediscover && NULL == pwszClientDC)
	{
	    GetDSNameFlags |= DS_FORCE_REDISCOVERY;
	}

        ldaperr = ldap_set_option(
			    pld,
			    LDAP_OPT_GETDSNAME_FLAGS,
			    (VOID *) &GetDSNameFlags);
        if (LDAP_SUCCESS != ldaperr)
        {
	    hr = myHLdapError(pld, ldaperr, NULL);
            if (!fRediscover)
            {
		_PrintError2(hr, "Policy:ldap_set_option", hr);
                fRediscover = TRUE;
                continue;
            }
	    _JumpError(hr, error, "Policy:ldap_set_option");
        }

	if (NULL != pwszClientDC)
	{
	    DWORD SSPIFlags;

	    // Turn on mutual authentication -- just to make sure we can trust
	    // the client-supplied DC name.
	    
	    ldaperr = ldap_get_option(
				pld,
				LDAP_OPT_SSPI_FLAGS,
				(VOID *) &SSPIFlags);
	    if (LDAP_SUCCESS != ldaperr)
	    {
		hr = myHLdapError(pld, ldaperr, NULL);
		if (!fRediscover)
		{
		    _PrintError2(hr, "Policy:ldap_get_option", hr);
		    fRediscover = TRUE;
		    continue;
		}
		_JumpError(hr, error, "Policy:ldap_get_option");
	    }

	    SSPIFlags |= ISC_REQ_MUTUAL_AUTH;

	    ldaperr = ldap_set_option(
				pld,
				LDAP_OPT_SSPI_FLAGS,
				(VOID *) &GetDSNameFlags);
	    if (LDAP_SUCCESS != ldaperr)
	    {
		hr = myHLdapError(pld, ldaperr, NULL);
		if (!fRediscover)
		{
		    _PrintError2(hr, "Policy:ldap_set_option", hr);
		    fRediscover = TRUE;
		    continue;
		}
		_JumpError(hr, error, "Policy:ldap_set_option");
	    }
        }

        ldaperr = ldap_set_option(pld, LDAP_OPT_SIGN, LDAP_OPT_ON);
        if (LDAP_SUCCESS != ldaperr)
        {
	    hr = myHLdapError(pld, ldaperr, NULL);
            if (!fRediscover)
            {
                _PrintError2(hr, "Policy:ldap_set_option", hr);
                fRediscover = TRUE;
                continue;
            }
            _JumpError(hr, error, "Policy:ldap_set_option");
        }

	if (0 == (EDITF_ENABLELDAPREFERRALS & Flags) || NULL != pwszClientDC)
	{
	    ldaperr = ldap_set_option(pld, LDAP_OPT_REFERRALS, LDAP_OPT_OFF);
	    if (LDAP_SUCCESS != ldaperr)
	    {
		hr = myHLdapError(pld, ldaperr, NULL);
		if (!fRediscover)
		{
		    _PrintError2(hr, "Policy:ldap_set_option LDAP_OPT_REFERRALS", hr);
		    fRediscover = TRUE;
		    continue;
		}
		_JumpError(hr, error, "Policy:ldap_set_option LDAP_OPT_REFERRALS");
	    }
	}

        ldaperr = ldap_bind_s(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
        if (LDAP_SUCCESS != ldaperr)
        {
	    hr = myHLdapError(pld, ldaperr, NULL);
            if (!fRediscover)
            {
		_PrintError2(hr, "Policy:ldap_bind_s", hr);
                fRediscover = TRUE;
                continue;
            }
	    _JumpError(hr, error, "Policy:ldap_bind_s");
        }

	hr = myLdapGetDSHostName(pld, &pwszDomainControllerName);
        if (S_OK != hr)
        {
            if (!fRediscover)
            {
		_PrintError2(hr, "Policy:myLdapGetDSHostName", hr);
                fRediscover = TRUE;
                continue;
            }
	    _JumpError(hr, error, "Policy:myLdapGetDSHostName");
        }
	DBGPRINT((
	    DBG_SS_CERTPOLI,
	    "DC name = %ws\n",
	    pwszDomainControllerName));
        break;
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	myLdapUnbind(&pld);
    }
    *ppld = pld;
    return(hr);
}


HRESULT
reqGetLdapGC(
    IN DWORD Flags,
    OUT LDAP **ppldGC,
    OUT BOOL *pfCached)
{
    HRESULT hr;
    LDAP *pldGC;

    *pfCached = TRUE;
    myLdapUnbind(ppldGC);

    if (!g_fGCCacheCriticalSection || NULL == g_rgGCCache)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
        _JumpError(hr, error, "InitializeCriticalSection");
    }
    pldGC = NULL;

    EnterCriticalSection(&g_GCCacheCriticalSection);
    if (0 != g_cGCCacheCur)
    {
	pldGC = g_rgGCCache[--g_cGCCacheCur];
    }
    LeaveCriticalSection(&g_GCCacheCriticalSection);

    if (NULL == pldGC)
    {
	hr = myLdapBind(Flags, NULL, &pldGC);
	_JumpIfError(hr, error, "myLdapBind");

	*pfCached = FALSE;
    }
    *ppldGC = pldGC;
    hr = S_OK;

error:
    return(hr);
}


VOID
reqReleaseLdapGC(
    IN OUT LDAP **ppldGC)
{
    LDAP *pldGC = *ppldGC;

    if (NULL != pldGC)
    {
	*ppldGC = NULL;
	
	EnterCriticalSection(&g_GCCacheCriticalSection);
	CSASSERT(0 != g_cGCCacheMax);
	if (g_cGCCacheCur < g_cGCCacheMax)
	{
	    g_rgGCCache[g_cGCCacheCur++] = pldGC;
	    pldGC = NULL;
	}
	LeaveCriticalSection(&g_GCCacheCriticalSection);
	myLdapUnbind(&pldGC);
    }
}


WCHAR *
reqCombineTemplates(
    OPTIONAL IN WCHAR const *pwszTemplateName,
    OPTIONAL IN WCHAR const *pwszTemplateObjId,
    OPTIONAL IN WCHAR const *pwszTemplateRA)
{
    HRESULT hr;
    WCHAR const *apwszTemplate[3];
    WCHAR const *apwszDisplayName[3];
    DWORD i;
    DWORD cwc;
    WCHAR *pwszList = NULL;

    apwszTemplate[0] = pwszTemplateName;
    apwszTemplate[1] = pwszTemplateObjId;
    apwszTemplate[2] = pwszTemplateRA;
    ZeroMemory(apwszDisplayName, sizeof(apwszDisplayName));

    cwc = 0;
    for (i = 0; i < ARRAYSIZE(apwszTemplate); i++)
    {
	if (NULL != apwszTemplate[i])
	{
	    if (0 != cwc)
	    {
		cwc++;
	    }
	    cwc += wcslen(apwszTemplate[i]);
	    hr = myVerifyObjId(apwszTemplate[i]);
	    if (S_OK == hr)
	    {
		WCHAR const *pwszDisplay = NULL;

		pwszDisplay = myGetOIDName(apwszTemplate[i]); // Static: do not free!
		if (NULL != pwszDisplay && L'\0' != *pwszDisplay)
		{
		    apwszDisplayName[i] = pwszDisplay;
		    cwc += 2 + wcslen(pwszDisplay);
		}
	    }
	}
    }
    if (0 != cwc)
    {
	pwszList = (WCHAR *) LocalAlloc(LMEM_FIXED, (1 + cwc) * sizeof(WCHAR));
	if (NULL == pwszList)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:LocalAlloc");
	}
	pwszList[0] = L'\0';
	for (i = 0; i < ARRAYSIZE(apwszTemplate); i++)
	{
	    if (NULL != apwszTemplate[i])
	    {
		if (L'\0' != pwszList[0])
		{
		    wcscat(pwszList, L"/");
		}
		wcscat(pwszList, apwszTemplate[i]);
		if (NULL != apwszDisplayName[i])
		{
		    wcscat(pwszList, wszLPAREN);
		    wcscat(pwszList, apwszDisplayName[i]);
		    wcscat(pwszList, wszRPAREN);
		}
	    }
	}
	CSASSERT(wcslen(pwszList) == cwc);
    }

error:
    return(pwszList);
}


// begin_sdksample

HRESULT
ReqInitialize(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    
// end_sdksample
    hr = S_OK;
    __try
    {
	InitializeCriticalSection(&g_GCCacheCriticalSection);
	g_fGCCacheCriticalSection = TRUE;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "InitializeCriticalSection");

    hr = polGetCertificateLongProperty(
				pServer,
				wszPROPSESSIONCOUNT,
				&g_cGCCacheMax);
    if (S_OK != hr)
    {
	g_cGCCacheMax = DBSESSIONCOUNTDEFAULT;
    }
    g_rgGCCache = (LDAP **) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    g_cGCCacheMax * sizeof(g_rgGCCache[0]));
    if (NULL == g_rgGCCache)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:LocalAlloc");
    }
    g_cGCCacheCur = 0;
// begin_sdksample
    hr = S_OK;

error:		// no_sdksample
    return(hr);
}


VOID
ReqCleanup()
{
// end_sdksample
    if (g_fGCCacheCriticalSection)
    {
	EnterCriticalSection(&g_GCCacheCriticalSection);
	if (NULL != g_rgGCCache)
	{
	    while (0 != g_cGCCacheCur)
	    {
		myLdapUnbind(&g_rgGCCache[--g_cGCCacheCur]);
	    }
	    LocalFree(g_rgGCCache);
	}
	LeaveCriticalSection(&g_GCCacheCriticalSection);
        DeleteCriticalSection(&g_GCCacheCriticalSection);
    }
// begin_sdksample
}


CRequestInstance::~CRequestInstance()
{
    _Cleanup();
}


VOID
CRequestInstance::_Cleanup()
{
    if (NULL != m_strTemplateName)
    {
        SysFreeString(m_strTemplateName);
        m_strTemplateName = NULL;
    }
    if (NULL != m_strTemplateObjId)
    {
        SysFreeString(m_strTemplateObjId);
        m_strTemplateObjId = NULL;
    }
    // end_sdksample
    //+--------------------------------------

    _ReleasePrincipalObject();
    if (NULL != m_hToken)
    {
        CloseHandle(m_hToken);
        m_hToken = NULL;
    }
    if (NULL != m_strUserDN)
    {
        SysFreeString(m_strUserDN);
        m_strUserDN = NULL;
    }
    if (NULL != m_pwszUPN)
    {
        LocalFree(m_pwszUPN);
        m_pwszUPN = NULL;
    }
    delete m_pTemplate;
    m_pTemplate = NULL;

    if (NULL != m_pCreateErrorInfo)
    {
	m_pCreateErrorInfo->Release();
	m_pCreateErrorInfo = NULL;
    }

    //+--------------------------------------
    // begin_sdksample
}


// end_sdksample
VOID
CRequestInstance::SaveErrorInfo(
    OPTIONAL IN ICreateErrorInfo *pCreateErrorInfo)
{
    if (NULL != pCreateErrorInfo)
    {
	if (NULL != m_pCreateErrorInfo)
	{
	    m_pCreateErrorInfo->Release();
	}
	m_pCreateErrorInfo = pCreateErrorInfo;
    }
}


HRESULT
CRequestInstance::SetErrorInfo()
{
    HRESULT hr;
    
    if (NULL != m_pCreateErrorInfo)
    {
	hr = SetModuleErrorInfo(m_pCreateErrorInfo);
	_JumpIfError(hr, error, "Policy:SetErrorInfo");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CRequestInstance::BuildErrorInfo(
    IN HRESULT hrLog,
    IN DWORD dwLogId,
    OPTIONAL IN WCHAR const * const *ppwszInsert)
{
    HRESULT hr;

    hr = polBuildErrorInfo(
		    hrLog,
		    dwLogId,
		    m_pPolicy->GetPolicyDescription(),
		    ppwszInsert,
		    &m_pCreateErrorInfo);
    _JumpIfError(hr, error, "polBuildErrorInfo");

error:
    return(hr);
}
// begin_sdksample


static WCHAR const *s_apwszCATypes[] =
{
    wszCERTTYPE_SUBORDINATE_CA,
    wszCERTTYPE_CROSS_CA,
};

//+--------------------------------------------------------------------------
// CRequestInstance::Initialize
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::Initialize(
    IN CCertPolicyEnterprise *pPolicy,
    IN BOOL fEnterpriseCA,		// no_sdksample
    IN BOOL bNewRequest,		// no_sdksample
    IN ICertServerPolicy *pServer,
    OUT BOOL *pfEnableEnrolleeExtensions)
{
    HRESULT hr;
    HRESULT hrTemplate = S_OK;
    CERT_TEMPLATE_EXT *pTemplate = NULL;
    CERT_NAME_VALUE *pName = NULL;
    BSTR strTemplateObjId = NULL;	// from V2 template extension
    BSTR strTemplateName = NULL;	// from V1 template extension
    BSTR strTemplateRA = NULL;		// from request attributes
    WCHAR const *pwszTemplateName;
    WCHAR const *pwszTemplateObjId;
    WCHAR const *pwszV1TemplateClass;
    VARIANT varValue;
    DWORD cbType;
    DWORD i;
    BOOL fConflict;
    BOOL f;
    BOOL fTemplateMissing;
    BOOL fRAObjId = FALSE;
    CTemplatePolicy *ptp = NULL;	// no_sdksample
    WCHAR *pwszTemplateList = NULL;	// no_sdksample

    VariantInit(&varValue);
    *pfEnableEnrolleeExtensions = TRUE 
		    && !fEnterpriseCA	// no_sdksample
		    ;

    m_pPolicy = pPolicy;
    m_fCA = FALSE;
    m_fNewRequest = bNewRequest;	// no_sdksample

    // end_sdksample
    //+--------------------------------------

    m_fUser = TRUE;
    m_fEnterpriseCA = fEnterpriseCA;

    if (m_fEnterpriseCA && bNewRequest)
    {
	hr = _InitToken(pServer);
	_JumpIfError(hr, error, "Policy:_InitToken");
    }

    hr = _InitClientOSVersionInfo(pServer);
    _JumpIfError(hr, error, "Policy:_InitClientOSVersionInfo");

    //+--------------------------------------
    // begin_sdksample

    // Retrieve the template ObjId from the V2 cert template info extension

    m_dwTemplateMajorVersion = 0;
    m_dwTemplateMinorVersion = 0;
    hr = polGetCertificateExtension(
			    pServer,
			    TEXT(szOID_CERTIFICATE_TEMPLATE),
			    PROPTYPE_BINARY,
			    &varValue);
    _PrintIfErrorStr2(
		hr,
		"Policy:polGetCertificateExtension",
		TEXT(szOID_CERTIFICATE_TEMPLATE),
		CERTSRV_E_PROPERTY_EMPTY);
    if (S_OK == hr)
    {
        // There was a cert type indicator.
        // varValue points to an encoded string

        if (VT_BSTR != varValue.vt)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:varValue.vt");
	}
        if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERTIFICATE_TEMPLATE,
		    (BYTE *) varValue.bstrVal,
		    SysStringByteLen(varValue.bstrVal),
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pTemplate,
		    &cbType))
        {
            hr = myHLastError();
	    _JumpError(hr, error, "Policy:myDecodeObject");
        }
	if (!myConvertSzToBstr(&strTemplateObjId, pTemplate->pszObjId, -1))
	{
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:myConvertSzToBstr");
        }
	m_dwTemplateMajorVersion = pTemplate->dwMajorVersion;
	m_dwTemplateMinorVersion = pTemplate->dwMinorVersion;
	DBGPRINT((
	    DBG_SS_CERTPOL,
	    pTemplate->fMinorVersion?
		"Extension Template Info: %ws V%u.%u\n" :
		"Extension Template Info: %ws V%u%\n",
	    strTemplateObjId,
	    m_dwTemplateMajorVersion,
	    m_dwTemplateMinorVersion));
    }
    VariantClear(&varValue);

    // Retrieve template Name from the V1 cert template name extension

    hr = polGetCertificateExtension(
			    pServer,
			    TEXT(szOID_ENROLL_CERTTYPE_EXTENSION),
			    PROPTYPE_BINARY,
			    &varValue);
    _PrintIfErrorStr2(
		hr,
		"Policy:polGetCertificateExtension",
		TEXT(szOID_ENROLL_CERTTYPE_EXTENSION),
		CERTSRV_E_PROPERTY_EMPTY);
    if (S_OK == hr)
    {
        // There was a cert type indicator.
        // varValue points to an encoded string

        if (VT_BSTR != varValue.vt)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:varValue.vt");
	}
        if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    (BYTE *) varValue.bstrVal,
		    SysStringByteLen(varValue.bstrVal),
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pName,
		    &cbType))
        {
            hr = myHLastError();
	    _JumpError(hr, error, "Policy:myDecodeObject");
        }
        strTemplateName = SysAllocString((WCHAR *) pName->Value.pbData);
        if (NULL == strTemplateName)
        {
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
        }
	DBGPRINT((DBG_SS_CERTPOL, "Extension Template: %ws\n", strTemplateName));
    }

    fConflict = FALSE;
    fTemplateMissing = FALSE;

    // Retrieve the template from the request attributes

    hr = polGetRequestAttribute(pServer, wszPROPCERTTEMPLATE, &strTemplateRA);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		    hr,
		    "Policy:polGetRequestAttribute",
		    wszPROPCERTTEMPLATE,
		    CERTSRV_E_PROPERTY_EMPTY);
	hr = S_OK;

	// end_sdksample
	if (m_fEnterpriseCA &&
	    NULL == strTemplateObjId &&
	    NULL == strTemplateName)
	{
	    hrTemplate = CERTSRV_E_NO_CERT_TYPE;
	    _PrintError(hrTemplate, "Policy:Request contains no template name");
	}
	// begin_sdksample

    }
    else
    {
	DBGPRINT((DBG_SS_CERTPOL, "Attribute Template: %ws\n", strTemplateRA));
	if (NULL != strTemplateObjId &&
	    !_TemplateNamesMatch(strTemplateObjId, strTemplateRA, &f))
	{
	    fConflict = TRUE;
	    if (f)
	    {
		fTemplateMissing = TRUE;
	    }
	}
	if (NULL != strTemplateName &&
	    !_TemplateNamesMatch(strTemplateName, strTemplateRA, &f))
	{
	    fConflict = TRUE;
	    if (f)
	    {
		fTemplateMissing = TRUE;
	    }
	}
	hr = myVerifyObjId(strTemplateRA);
	fRAObjId = S_OK == hr;
    }

    if (NULL != strTemplateObjId &&
	NULL != strTemplateName &&
	!_TemplateNamesMatch(strTemplateObjId, strTemplateName, &f))
    {
	fConflict = TRUE;
	if (f)
	{
	    fTemplateMissing = TRUE;
	}
    }

    if (fConflict)
    {
	hrTemplate = CERTSRV_E_TEMPLATE_CONFLICT;
	if (NULL != strTemplateObjId)
	{
	    _PrintErrorStr(
			hrTemplate,
			"Policy:Extension Template ObjId",
			strTemplateObjId);
	}
	if (NULL != strTemplateName)
	{
	    _PrintErrorStr(
			hrTemplate,
			"Policy:Extension Template Name",
			strTemplateName);
	}
	if (NULL != strTemplateRA)
	{
	    _PrintErrorStr(
			hrTemplate,
			"Policy:Attribute Template",
			strTemplateRA);
	}
    }

    pwszTemplateName = strTemplateName;
    pwszTemplateObjId = strTemplateObjId;
    if (fRAObjId)
    {
	if (NULL == pwszTemplateObjId)
	{
	    pwszTemplateObjId = strTemplateRA;
	}
    }
    else
    {
	if (NULL == pwszTemplateName)
	{
	    pwszTemplateName = strTemplateRA;
	}
    }

    // end_sdksample

    if (m_fEnterpriseCA)
    {
	DWORD dwFlags;

	hr = m_pPolicy->FindTemplate(
			    pwszTemplateName,
			    pwszTemplateObjId,
			    &ptp);
	if (S_OK != hr)
	{
	    _PrintErrorStr(
		hr,
		"FindTemplate",
		NULL != pwszTemplateName? pwszTemplateName : pwszTemplateObjId);
	    if (S_OK == hrTemplate || fTemplateMissing)
	    {
		hrTemplate = hr;
	    }
	}
	else
	{
	    hr = ptp->GetFlags(CERTTYPE_GENERAL_FLAG, &dwFlags);
	    _JumpIfError(hr, error, "Policy:GetFlags");

	    if ((CT_FLAG_IS_CA | CT_FLAG_IS_CROSS_CA) & dwFlags)
	    {
		m_fCA = TRUE;
	    }

	    hr = ptp->GetFlags(CERTTYPE_ENROLLMENT_FLAG, &dwFlags);
	    _JumpIfError(hr, error, "Policy:GetFlags");

	    hr = _SetFlagsProperty(
			    pServer,
			    wszPROPCERTIFICATEENROLLMENTFLAGS,
			    dwFlags);
	    _JumpIfError(hr, error, "Policy:_SetFlagsProperty");

	    hr = ptp->GetFlags(CERTTYPE_GENERAL_FLAG, &dwFlags);
	    _JumpIfError(hr, error, "Policy:GetFlags");

	    hr = _SetFlagsProperty(
			    pServer,
			    wszPROPCERTIFICATEGENERALFLAGS,
			    dwFlags);
	    _JumpIfError(hr, error, "Policy:_SetFlagsProperty");

	    if (CT_FLAG_MACHINE_TYPE & dwFlags)
	    {
		m_fUser = FALSE;
	    }
	    pwszTemplateName = ptp->GetTemplateName();
	    pwszTemplateObjId = ptp->GetTemplateObjId();
	}
    }
    else

    // begin_sdksample

    {
	if (NULL != pwszTemplateName)
	{
	    for (i = 0; i < ARRAYSIZE(s_apwszCATypes); i++)
	    {
		if (0 == mylstrcmpiL(s_apwszCATypes[i], pwszTemplateName))
		{
		    m_fCA = TRUE;
		    break;
		}
	    }
	}
    }
    hr = SetTemplateName(pServer, pwszTemplateName, pwszTemplateObjId);
    _JumpIfError(hr, error, "Policy:SetTemplateName");

    pwszV1TemplateClass = pwszTemplateName;

    // end_sdksample

    if (NULL != ptp)
    {
	DWORD dwSubjectNameFlags;

	// on resubmitted requests we don't have the requester's token

	if (bNewRequest)
	{
	    CSASSERT(NULL != m_hToken);

	    hr = ptp->AccessCheck(m_hToken);
	    _JumpIfError(hr, error, "Policy:AccessCheck");
	}
	hr = ptp->GetV1TemplateClass(&pwszV1TemplateClass);
	_JumpIfError(hr, error, "AddTemplateNameExtension");

	hr = ptp->GetFlags(CERTTYPE_SUBJECT_NAME_FLAG, &dwSubjectNameFlags);
	_JumpIfError(hr, error, "GetFlags");

	if (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT & dwSubjectNameFlags)
	{
	    *pfEnableEnrolleeExtensions = TRUE;
	}

	hr = ptp->Clone(&m_pTemplate);
	_JumpIfError(hr, error, "Clone");
    }

    // begin_sdksample

    hr = pPolicy->AddV1TemplateNameExtension(pServer, pwszV1TemplateClass);
    _JumpIfError(hr, error, "AddTemplateNameExtension");

error:
    if (S_OK != hrTemplate)
    {
	hr = hrTemplate;	// override secondary errors

	// end_sdksample
	WCHAR const *apwsz[2];
	DWORD cpwsz = 0;
	DWORD LogMsg;

	switch (hrTemplate)
	{
	    default:
	    case CERTSRV_E_NO_CERT_TYPE:
		LogMsg = MSG_MISSING_CERT_TYPE;
		apwsz[cpwsz++] = wszPROPCERTTEMPLATE;
		break;

	    // The request specifies conflicting certificate templates: %1.
	    case CERTSRV_E_TEMPLATE_CONFLICT:
		LogMsg = MSG_CONFLICTING_CERT_TYPE;
		break;

	    // The request was for a certificate template that is not
	    // supported by the Certificate Services policy: %1.
	    case CERTSRV_E_UNSUPPORTED_CERT_TYPE:
		LogMsg = MSG_UNSUPPORTED_CERT_TYPE;
		break;
	}
	if (0 == cpwsz)
	{
	    WCHAR const *pwsz;
	    
	    pwszTemplateList = reqCombineTemplates(
					strTemplateName,
					strTemplateObjId,
					strTemplateRA);
	    
	    pwsz = pwszTemplateList;
	    if (NULL == pwsz)
	    {
		pwsz = strTemplateName;
		if (NULL == pwsz)
		{
		    pwsz = strTemplateObjId;
		    if (NULL == pwsz)
		    {
			pwsz = strTemplateRA;
			if (NULL == pwsz)
			{
			    pwsz = L"???";
			}
		    }
		}
	    }
	    apwsz[cpwsz++] = pwsz;
	}
	CSASSERT(ARRAYSIZE(apwsz) > cpwsz);
	apwsz[cpwsz] = NULL;

	BuildErrorInfo(hr, LogMsg, apwsz);
	// begin_sdksample
    }
    VariantClear(&varValue);

    // end_sdksample
    if (NULL != pwszTemplateList)
    {
        LocalFree(pwszTemplateList);
    }
    // begin_sdksample
    if (NULL != pName)
    {
        LocalFree(pName);
    }
    if (NULL != pTemplate)
    {
        LocalFree(pTemplate);
    }
    if (NULL != strTemplateObjId)
    {
        SysFreeString(strTemplateObjId);
    }
    if (NULL != strTemplateName)
    {
        SysFreeString(strTemplateName);
    }
    if (NULL != strTemplateRA)
    {
        SysFreeString(strTemplateRA);
    }
    return(hr);
}


// end_sdksample

//+--------------------------------------------------------------------------
// CRequestInstance::ApplyTemplate
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::ApplyTemplate(
    IN ICertServerPolicy *pServer,
    OUT BOOL *pfReenroll,
    OUT DWORD *pdwEnrollmentFlags,
    OUT DWORD *pcCriticalExtensions,
    OUT WCHAR const * const **papwszCriticalExtensions)
{
    HRESULT hr;

    *pdwEnrollmentFlags = 0;
    *pfReenroll = FALSE;
    *pcCriticalExtensions = 0;
    *papwszCriticalExtensions = NULL;
    if (NULL == m_pTemplate)
    {
	hr = CERTSRV_E_UNSUPPORTED_CERT_TYPE;
	_JumpErrorStr(
		hr,
		error,
		"Policy:ApplyTemplate:no cert template",
		m_strTemplateName);
    }
    hr = m_pTemplate->Apply(pServer, this, pfReenroll);
    _JumpIfError(hr, error, "Apply");

    hr = m_pTemplate->GetFlags(CERTTYPE_ENROLLMENT_FLAG, pdwEnrollmentFlags);
    _JumpIfError(hr, error, "GetFlags");

    hr = m_pTemplate->GetCriticalExtensions(
				    pcCriticalExtensions,
				    papwszCriticalExtensions);
    _JumpIfError(hr, error, "GetCriticalExtension");

error:
    DBGPRINT((DBG_SS_CERTPOLI, "Policy:_ApplyTemplate: %x\n", hr));
    return(hr);
}

// begin_sdksample


BOOL
CRequestInstance::_TemplateNamesMatch(
    IN WCHAR const *pwszTemplateName1,
    IN WCHAR const *pwszTemplateName2,
    OUT BOOL *pfTemplateMissing)
{
    HRESULT hr1;
    HRESULT hr2;
    BOOL fMatch = TRUE;

    *pfTemplateMissing = FALSE;

    if (0 == mylstrcmpiL(pwszTemplateName1, pwszTemplateName2))
    {
	goto done;	// identical names
    }

    // end_sdksample
    if (m_fEnterpriseCA)
    {
	CTemplatePolicy *pTemplate1;
	CTemplatePolicy *pTemplate2;

	hr1 = m_pPolicy->FindTemplate(pwszTemplateName1, NULL, &pTemplate1);
	hr2 = m_pPolicy->FindTemplate(pwszTemplateName2, NULL, &pTemplate2);
	if (S_OK == hr1 && S_OK == hr2)
	{
	    if (pTemplate1 == pTemplate2)
	    {
		goto done;
	    }
	}
	else
	{
	    *pfTemplateMissing = TRUE;
	}
    }
    else
    // begin_sdksample
    {
	hr1 = myVerifyObjId(pwszTemplateName1);
	hr2 = myVerifyObjId(pwszTemplateName2);
	if ((S_OK == hr1) ^ (S_OK == hr2))
	{
	    goto done;
	}
    }
    fMatch = FALSE;

done:
    return(fMatch);
}


//+--------------------------------------------------------------------------
// CRequestInstance::SetTemplateName
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::SetTemplateName(
    IN ICertServerPolicy *pServer,
    IN OPTIONAL WCHAR const *pwszTemplateName,
    IN OPTIONAL WCHAR const *pwszTemplateObjId)
{
    HRESULT hr;
    BSTR strProp = NULL;
    BSTR strTemplateName = NULL;

    if (NULL != pwszTemplateName)
    {
	m_strTemplateName = SysAllocString(pwszTemplateName);
	if (NULL == m_strTemplateName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}
	strTemplateName = m_strTemplateName;
    }

    if (NULL != pwszTemplateObjId)
    {
	m_strTemplateObjId = SysAllocString(pwszTemplateObjId);
	if (NULL == m_strTemplateObjId)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}
	strTemplateName = m_strTemplateObjId;
    }

    if (NULL != strTemplateName)
    {
	VARIANT var;

	strProp = SysAllocString(wszPROPCERTIFICATETEMPLATE);
	if (NULL == strProp)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}

	var.vt = VT_BSTR;
	var.bstrVal = strTemplateName;

	hr = pServer->SetCertificateProperty(strProp, PROPTYPE_STRING, &var);
	_JumpIfError(hr, error, "Policy:SetCertificateProperty");
    }
    hr = S_OK;

error:
    if (NULL != strProp)
    {
	SysFreeString(strProp);
    }
    return(hr);
}

// end_sdksample


HRESULT
CRequestInstance::_SetFlagsProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags)
{
    HRESULT hr;
    BSTR strPropName = NULL;
    VARIANT var;

    strPropName = SysAllocString(pwszPropName);
    if (NULL == strPropName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    var.vt = VT_I4;
    var.lVal = dwFlags;

    hr = pServer->SetCertificateProperty(strPropName, PROPTYPE_LONG, &var);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

error:
    if (NULL != strPropName)
    {
        SysFreeString(strPropName);
    }
    return(hr);
}


VOID
CRequestInstance::GetTemplateVersion(
    OUT DWORD *pdwTemplateMajorVersion,
    OUT DWORD *pdwTemplateMinorVersion)
{
    *pdwTemplateMajorVersion = m_dwTemplateMajorVersion;
    *pdwTemplateMinorVersion = m_dwTemplateMinorVersion;
}


//+--------------------------------------------------------------------------
// CRequestInstance::_InitToken
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::_InitToken(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    VARIANT varValue;
    HANDLE hToken;

    VariantInit(&varValue);

    hr = polGetProperty(
		    pServer,
		    FALSE,	// fRequest
		    wszPROPREQUESTERTOKEN,
		    PROPTYPE_BINARY,
		    &varValue);
    if(CERTSRV_E_PROPERTY_EMPTY == hr)
    {
        _PrintIfError(hr, "polGetProperty(PROPREQUESTERTOKEN)");
        hr = S_OK;
    }
    _JumpIfError(hr, error, "polGetProperty(PROPREQUESTERTOKEN)");
    
    // Got a token value

    if (sizeof(hToken) != SysStringByteLen(varValue.bstrVal) ||
        NULL == *(HANDLE *) varValue.bstrVal)
    {
        hr = E_HANDLE;
        BuildErrorInfo(hr, MSG_NO_REQUESTER_TOKEN, NULL);
        _JumpError(hr, error, "Policy:Token/Length");
    }

    hToken = *(HANDLE *) varValue.bstrVal;

    if (!DuplicateToken(hToken, SecurityIdentification, &m_hToken))
    {
        hr = myHLastError();
        BuildErrorInfo(hr, MSG_NO_REQUESTER_TOKEN, NULL);
        _JumpError(hr, error, "Policy:DuplicateToken");
    }

    hr = S_OK;

error:
    VariantClear(&varValue);
    return(hr);
}


//+--------------------------------------------------------------------------
// CRequestInstance::_InitClientOSVersionInfo
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::_InitClientOSVersionInfo(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    VARIANT varValue;
    DWORD dwFormat = 0;
    LONG l;
    BSTR strVersionInfo = NULL;
    BSTR strCSPProvider = NULL;

    VariantInit(&varValue);

    // In the following code, we also attempt to determine if the
    // request came from an xenroll.dll, so we know whether to put
    // the UPN in the subject name.  We put the UPN in the subject name
    // for old xenroll requests, as we know that autoenrollment on those
    // machines will need it to prevent enrollment loops.

    // Get the optional OS version information.  Ignore failure.

    hr = polGetRequestAttribute(pServer, wszPROPREQUESTOSVERSION, &strVersionInfo);
    if (S_OK == hr && NULL != strVersionInfo)
    {
        DWORD dwMajor, dwMinor, dwBuild, dwPlatform;

        if (4 == swscanf(
		    strVersionInfo,
		    L"%d.%d.%d.%d",
		    &dwMajor,
		    &dwMinor,
		    &dwBuild,
		    &dwPlatform))
        {
            m_RequestOsVersion.dwMajorVersion = dwMajor;
            m_RequestOsVersion.dwMinorVersion = dwMinor;
            m_RequestOsVersion.dwBuildNumber = dwBuild;
            m_RequestOsVersion.dwPlatformId = dwPlatform;
        }

        // We know this is an xenroll request,
        // as it has a OSVERSIONINFO property

        m_fIsXenrollRequest = TRUE;
	m_fClientVersionSpecified = TRUE;
    }
    hr = polGetRequestLongProperty(pServer, wszPROPREQUESTTYPE, &l);
    if (S_OK == hr)
    {
	dwFormat = CR_IN_FORMATMASK & l;
    }

    if (dwFormat == CR_IN_KEYGEN)
    {
        // KEYGEN requests only come from netscape, not xenroll,
        // so we know it's not an xenroll request.

        m_fIsXenrollRequest = FALSE;
    }
    else if (!m_fIsXenrollRequest)
    {
        hr = polGetRequestAttribute(
			    pServer,
			    wszPROPREQUESTCSPPROVIDER,
			    &strCSPProvider);
        if (S_OK == hr && NULL != strCSPProvider)
        {
            // xenroll includes a CSPPROVIDER attribute

            m_fIsXenrollRequest = TRUE;
        }
    }
    hr = S_OK;

//error:
    if (NULL != strVersionInfo)
    {
        SysFreeString(strVersionInfo);
    }
    if (NULL != strCSPProvider)
    {
        SysFreeString(strCSPProvider);
    }
    VariantClear(&varValue);
    return(hr);
}


//+--------------------------------------------------------------------------
// CRequestInstance::_LoadPrincipalObject
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::_LoadPrincipalObject(
    IN ICertServerPolicy *pServer,
    IN CTemplatePolicy *pTemplate,
    IN BOOL fDNSNameRequired)
{
    HRESULT hr;
    BSTR strProp = NULL;
    LPWSTR *awszUPN = NULL;
    BSTR strSamName = NULL;
    BSTR strClientDC = NULL;
    WCHAR *pwszUserName;
    DWORD dwFlags;
    VARIANT var;

    VariantInit(&var);

    // Get the name of the user or machine

    hr = polGetRequestStringProperty(
			pServer,
			wszPROPREQUESTERNAME,
			&strSamName);
    _JumpIfErrorStr(
		hr,
		error,
		"Policy:polGetRequestStringProperty",
		wszPROPREQUESTERNAME);

    if (L'\0' == *strSamName)
    {
	// can't have a zero length name
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "Policy:zero length name");
    }

    // See if there's a domain, as well

    pwszUserName = wcschr(strSamName, L'\\');
    if (NULL == pwszUserName)
    {
	WCHAR wszDN[MAX_PATH];
	DWORD cwc = ARRAYSIZE(wszDN);

        // No domain portion, so assume part of the current domain.

        if (GetUserNameEx(NameSamCompatible, wszDN, &cwc))
        {
            pwszUserName = wcschr(wszDN, L'\\');
            if (NULL != pwszUserName)
            {
		BSTR strT;
		DWORD cwcT;
		
		pwszUserName[1] = L'\0';

		cwcT = wcslen(wszDN) + wcslen(strSamName);
		strT = SysAllocStringLen(NULL, cwcT);
		if (NULL == strT)
                {
                    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "Policy:SysAllocString");
                }
		wcscpy(strT, wszDN);
		wcscat(strT, strSamName);
		CSASSERT(wcslen(strT) == cwcT);
		CSASSERT(SysStringLen(strT) == cwcT);
		SysFreeString(strSamName);
		strSamName = strT;
            }
        }
    }

    pwszUserName = wcschr(strSamName, L'\\');
    if (NULL == pwszUserName)
    {
        pwszUserName = strSamName;
    }
    else
    {
        pwszUserName++;
    }

    DBGPRINT((DBG_SS_CERTPOL, "pwszUserName = %ws\n", pwszUserName));
    DBGPRINT((DBG_SS_CERTPOL, "strSamName = %ws\n", strSamName));

    // If the user name ends in $, it's a hint that this is a machine account.

    if (pwszUserName[wcslen(pwszUserName) - 1] == L'$')
    {
        if (m_fUser)
	{
	    DBGPRINT((
		DBG_SS_CERTPOL,
		"USER TEMPLATE w/ '$': %ws\n",
		pwszUserName));
	}
    }
    else
    {
        if (!m_fUser)
	{
	    DBGPRINT((
		DBG_SS_CERTPOL,
		"MACHINE TEMPLATE w/o '$': %ws\n",
		pwszUserName));
	}
    }

    hr = polGetCertificateStringProperty(pServer, wszPROPUSERDN, &m_strUserDN);
    _JumpIfErrorStr(
		hr,
		error,
		"Policy:polGetCertificateStringProperty",
		wszPROPUSERDN);

    hr = _GetDSObject(pServer, fDNSNameRequired, NULL);

    // If we couldn't find the DS object or the DNS name is missing or out of
    // date, it is a machine object and the client specified his DC name, chase
    // the client supplied DC in hopes of finding more current information.

    if ((CERTSRV_E_SUBJECT_DNS_REQUIRED == hr ||
	 HRESULT_FROM_WIN32(DNS_ERROR_NAME_DOES_NOT_EXIST) == hr ||
	 (HRESULT) ERROR_DS_OBJ_NOT_FOUND == hr ||
	 HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND) == hr) &&
	fDNSNameRequired &&
	(EDITF_ENABLECHASECLIENTDC & m_pPolicy->GetEditFlags()) &&
	!m_fUser)
    {
	HRESULT hr2;
	
	_PrintError(hr, "_GetDSObject");

	hr2 = polGetRequestAttribute(pServer, wszPROPCLIENTDCDNS, &strClientDC);
	_PrintIfErrorStr(
		    hr2,
		    "Policy:polGetRequestAttribute",
		    wszPROPCLIENTDCDNS);
	if (S_OK == hr2 && NULL != strClientDC)
	{
	    _PrintErrorStr(hr, "_GetDSObject", strClientDC);
	    hr = _GetDSObject(pServer, TRUE, strClientDC);
	    _JumpIfErrorStr(hr, error, "_GetDSObject", strClientDC);
	}
    }
    _JumpIfError(hr, error, "_GetDSObject");

    hr = pTemplate->GetFlags(CERTTYPE_GENERAL_FLAG, &dwFlags);
    _JumpIfError(hr, error, "Policy:GetFlags");

    if (!m_fUser ^ (0 != (CT_FLAG_MACHINE_TYPE & dwFlags)))
    {
	// if m_fUser state no longer agrees with the template machine flag,
	// toggle the flag and store the corrected value in the database.

	dwFlags ^= CT_FLAG_MACHINE_TYPE;
	hr = _SetFlagsProperty(
			pServer,
			wszPROPCERTIFICATEGENERALFLAGS,
			dwFlags);
	_JumpIfError(hr, error, "Policy:_SetFlagsProperty");
    }

    // Build the UPN value.
    // If a machine, the UPN must be the DNS name.

    hr = _GetValues(m_fUser? DS_ATTR_UPN : DS_ATTR_DNS_NAME, &awszUPN);
    if (S_OK == hr && NULL != awszUPN && NULL != awszUPN[0])
    {
	hr = myDupString(awszUPN[0], &m_pwszUPN);
	_JumpIfError(hr, error, "myDupString");
    }
    else
    {
	if (m_fUser)
	{
            WCHAR **awszExplodedDN;
	    WCHAR **ppwszCurrent;
	    DWORD cwcT;

            // Build a UPN from the username -- without the SAM domain.
            // Get a buffer that will be big enough.

	    cwcT = wcslen(pwszUserName) + 1 + wcslen(m_strUserDN);
	    m_pwszUPN = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(1 + cwcT) * sizeof(WCHAR));
	    if (NULL == m_pwszUPN)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:LocalAlloc");
	    }

            wcscpy(m_pwszUPN, pwszUserName);
            awszExplodedDN = ldap_explode_dn(m_strUserDN, 0);
            if (NULL != awszExplodedDN)
            {
                wcscat(m_pwszUPN, L"@");
                for (ppwszCurrent = awszExplodedDN;
		     NULL != *ppwszCurrent;
		     ppwszCurrent++)
                {
		    WCHAR wszDC[4];

		    wcsncpy(wszDC, *ppwszCurrent, ARRAYSIZE(wszDC) - 1);
		    wszDC[ARRAYSIZE(wszDC) - 1] = L'\0';
		    if (0 == LSTRCMPIS(wszDC, L"DC="))
                    {
                        wcscat(
			    m_pwszUPN,
			    (*ppwszCurrent) + ARRAYSIZE(wszDC) - 1);
                        wcscat(m_pwszUPN, L".");
			CSASSERT(wcslen(m_pwszUPN) < cwcT);
                    }
                }

                // remove the trailing '.' or "@" if there was no DC=

                m_pwszUPN[wcslen(m_pwszUPN) - 1] = L'\0';

                // We're done referencing awszExplodedDN, so free it.
                // ldap_value_free frees the ldap_explode_dn return value

                ldap_value_free(awszExplodedDN);
            }
        }
	else
        {
            if (CERTSRV_E_PROPERTY_EMPTY == hr || S_OK == hr)
            {
                hr = CERTSRV_E_SUBJECT_DNS_REQUIRED;
            }
	    BuildErrorInfo(hr, MSG_NO_DNS_NAME, &m_strUserDN);
	    _JumpErrorStr(hr, error, "No DNS Name", m_strUserDN);
        }
    }
    DBGPRINT((DBG_SS_CERTPOL, "m_pwszUPN = %ws\n", m_pwszUPN));

    strProp = SysAllocString(wszPROPCERTIFICATEUPN);
    if (NULL == strProp)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }

    var.bstrVal = NULL;
    if (!myConvertWszToBstr(&var.bstrVal, m_pwszUPN, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }
    var.vt = VT_BSTR;

    hr = pServer->SetCertificateProperty(strProp, PROPTYPE_STRING, &var);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

error:
    if (NULL != strClientDC)
    {
        SysFreeString(strClientDC);
    }
    if (NULL != strSamName)
    {
        SysFreeString(strSamName);
    }
    if (NULL != awszUPN)
    {
        _FreeValues(awszUPN);
    }
    if (NULL != strProp)
    {
	SysFreeString(strProp);
    }
    VariantClear(&var);
    return(hr);
}


VOID
CRequestInstance::_ReleasePrincipalObject()
{
    if (NULL != m_pldGC)
    {
	if (NULL != m_SearchResult)
	{
	    ldap_msgfree(m_SearchResult);
	    m_SearchResult = NULL;
	}
	reqReleaseLdapGC(&m_pldGC);
	myLdapUnbind(&m_pldClientDC);
    }
}


#define wszHOSTPREFIX		L"HOST/"
#define DS_ATTR_SPN		L"servicePrincipalName"
#define DS_ATTR_BACKLINK	L"serverReferenceBL"

#define wszSEARCHUSER		L"(objectCategory=user)"
#define wszSEARCHCOMPUTER	L"(objectCategory=computer)"
#define wszSEARCHNTDSDSA	L"(objectCategory=nTDSDSA)"
#define wszSEARCHUSERCOMPUTER	L"(|" wszSEARCHUSER wszSEARCHCOMPUTER L")"
#define wszSEARCHSPN		L"(" DS_ATTR_SPN L"=" wszHOSTPREFIX L"%ws)"
#define wszSEARCHCOMPUTERSPN	L"(&" wszSEARCHCOMPUTER wszSEARCHSPN L")"
#define wszDSOBJECTCATEGORYATTRIBUTE       L"objectCategory"

WCHAR *s_apwszAttrsClientDC[] = {
    DS_ATTR_DNS_NAME,
    DS_ATTR_SPN,
    DS_ATTR_BACKLINK,
    NULL,
};

// Use the ldap GC handle to verify the client-supplied DC DNS name is a valid
// DC in our forest.  If it is, bind to the client supplied DC.

HRESULT
reqFindClientDC(
    IN LDAP *pldGC,
    IN WCHAR const *pwszClientDC,
    OUT LDAP **ppldClientDC)
{
    HRESULT hr;
    ULONG ldaperr;
    struct l_timeval timeout;
    WCHAR *pwszSearch = NULL;
    DWORD cwc;
    WCHAR *pwszError = NULL;
    LDAPMessage *pSearchResult = NULL;
    LDAPMessage *pEntry = NULL;
    WCHAR **ppwszValues = NULL;
    WCHAR *pwszServiceDN = NULL;

    myLdapUnbind(ppldClientDC);

    cwc = WSZARRAYSIZE(wszSEARCHCOMPUTERSPN) + wcslen(pwszClientDC);
    pwszSearch = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszSearch)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocStringByteLen");
    }
    wsprintf(pwszSearch, wszSEARCHCOMPUTERSPN, pwszClientDC);
    CSASSERT(wcslen(pwszSearch) <= cwc);

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    // ldap_search the GC for a Computer object with matching SPN.
    // Fetch the service object back link attribute from the Computer object.
    // Make sure the service object has a child object of class NTDSDSA

    ldaperr = ldap_search_ext_s(
			pldGC,
			NULL,
			LDAP_SCOPE_SUBTREE,
			pwszSearch,
			s_apwszAttrsClientDC,
			0,
			NULL,
			NULL,
			&timeout,
			10000,
			&pSearchResult);
    if (LDAP_SUCCESS != ldaperr)
    {
	hr = myHLdapError(pldGC, ldaperr, &pwszError);
	_PrintErrorStr(hr, "Policy:ldap_search_ext_s", pwszError);
	_JumpErrorStr(hr, error, "Policy:ldap_search_ext_s", pwszSearch);
    }
    if (0 == ldap_count_entries(pldGC, pSearchResult))
    {
	hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
	_JumpError(hr, error, "Policy:ldap_count_entries");
    }
    pEntry = ldap_first_entry(pldGC, pSearchResult);
    if (NULL == pEntry)
    {
	hr = myHLdapLastError(pldGC, NULL);
        _JumpError(hr, error, "Policy:ldap_first_entry");
    }
    ppwszValues = ldap_get_values(pldGC, pEntry, DS_ATTR_BACKLINK);
    if (NULL == ppwszValues || NULL == ppwszValues[0])
    {
        hr = CERTSRV_E_PROPERTY_EMPTY;
        _JumpErrorStr(hr, error, "Policy:ldap_get_values", DS_ATTR_BACKLINK);
    }
    hr = myDupString(ppwszValues[0], &pwszServiceDN);
    _JumpIfError(hr, error, "myDupString");

    if (NULL != ppwszValues)
    {
	ldap_value_free(ppwszValues);
	ppwszValues = NULL;
    }
    if (NULL != pSearchResult)
    {
	ldap_msgfree(pSearchResult);
	pSearchResult = NULL;
    }
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
	pwszError = NULL;
    }

    // ldap_search the GC for a child of the Service object with class NTDSDSA.

    ldaperr = ldap_search_ext_s(
			pldGC,
			pwszServiceDN,
			LDAP_SCOPE_ONELEVEL,
			wszSEARCHNTDSDSA,
			NULL,
			0,
			NULL,
			NULL,
			&timeout,
			10000,
			&pSearchResult);
    if (LDAP_SUCCESS != ldaperr)
    {
	hr = myHLdapError(pldGC, ldaperr, &pwszError);
	_PrintErrorStr(hr, "Policy:ldap_search_ext_s", pwszError);
	_JumpErrorStr(hr, error, "Policy:ldap_search_ext_s", pwszServiceDN);
    }
    if (0 == ldap_count_entries(pldGC, pSearchResult))
    {
	hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
	_JumpError(hr, error, "Policy:ldap_count_entries");
    }

    hr = myLdapBind(0, pwszClientDC, ppldClientDC);
    _JumpIfError(hr, error, "myLdapBind");

error:
    if (NULL != ppwszValues)
    {
	ldap_value_free(ppwszValues);
    }
    if (NULL != pSearchResult)
    {
	ldap_msgfree(pSearchResult);
    }
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    if (NULL != pwszServiceDN)
    {
	LocalFree(pwszServiceDN);
    }
    if (NULL != pwszSearch)
    {
	LocalFree(pwszSearch);
    }
    return(hr);
}


WCHAR *s_apwszAttrs[] = {
    wszDSOBJECTCLASSATTRIBUTE,
    //wszDSOBJECTCATEGORYATTRIBUTE,
    DS_ATTR_COMMON_NAME,
    DS_ATTR_DNS_NAME,
    DS_ATTR_EMAIL_ADDR,
    DS_ATTR_OBJECT_GUID,
    DS_ATTR_UPN,
    NULL,
};


HRESULT
CRequestInstance::_GetDSObject(
    IN ICertServerPolicy *pServer,
    IN BOOL fDNSNameRequired,
    OPTIONAL IN WCHAR const *pwszClientDC)
{
    HRESULT hr;
    ULONG ldaperr;
    struct l_timeval timeout;
    WCHAR **ppwszValues = NULL;
    BOOL fUser;
    LONG cRetry;
    WCHAR *pwszError = NULL;
    BSTR strDNS = NULL;

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    cRetry = 0;
    while (TRUE)
    {
	BOOL fCached;

	if (NULL != m_SearchResult)
	{
	    ldap_msgfree(m_SearchResult);
	    m_SearchResult = NULL;
	}
	hr = reqGetLdapGC(m_pPolicy->GetEditFlags(), &m_pldGC, &fCached);
	_JumpIfError(hr, error, "reqGetLdapGC");

	m_pldT = m_pldGC;

	if (NULL != pwszClientDC)
	{
	    hr = reqFindClientDC(m_pldGC, pwszClientDC, &m_pldClientDC);
	    _JumpIfError(hr, error, "reqFindClientDC");

	    m_pldT = m_pldClientDC;
	}

	ldaperr = ldap_search_ext_s(
			    m_pldT,
			    m_strUserDN,
			    LDAP_SCOPE_BASE,
			    wszSEARCHUSERCOMPUTER,
			    s_apwszAttrs,
			    0,
			    NULL,
			    NULL,
			    &timeout,
			    10000,
			    &m_SearchResult);
	if (LDAP_SUCCESS != ldaperr)
	{
	    if (NULL != pwszError)
	    {
		LocalFree(pwszError);
		pwszError = NULL;
	    }
	    hr = myHLdapError(m_pldT, ldaperr, &pwszError);

	    // only retry for cached GC handle & when hr != object not found

	    if (fCached &&
		(HRESULT) ERROR_DS_OBJ_NOT_FOUND != hr &&
		NULL == pwszClientDC &&
		cRetry++ < g_cGCCacheMax)
	    {
		// get rid of GC handle we have, it might be stale

		_PrintError2(hr, "Policy:ldap_search_ext_s", hr);
		myLdapUnbind(&m_pldGC);
		myLdapUnbind(&m_pldClientDC);
		continue;
	    }
	    _JumpErrorStr(hr, error, "Policy:ldap_search_ext_s", m_strUserDN);
	}
	break;
    }
    if (0 == ldap_count_entries(m_pldT, m_SearchResult))
    {
	hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
	_JumpError(hr, error, "Policy:ldap_count_entries");
    }

    m_PrincipalAttributes = ldap_first_entry(m_pldT, m_SearchResult);
    if (NULL == m_PrincipalAttributes)
    {
	hr = myHLdapLastError(m_pldT, NULL);
        _JumpError(hr, error, "Policy:ldap_first_entry");
    }
#if DBG_CERTSRV
    {
	DWORD i;

	for (i = 0; NULL != s_apwszAttrs[i]; i++)
	{
	    if (0 == LSTRCMPIS(s_apwszAttrs[i], DS_ATTR_OBJECT_GUID))
	    {
		BSTR strGuid = NULL;

		hr = _GetObjectGUID(&strGuid);
		if (S_OK == hr)
		{
		    WCHAR *pwsz;

		    hr = myCLSIDToWsz((CLSID const *) strGuid, &pwsz);
		    if (S_OK == hr)
		    {
			DBGPRINT((
			    DBG_SS_CERTPOL,
			    "%ws = %ws\n",
			    s_apwszAttrs[i],
			    pwsz));
			LocalFree(pwsz);
		    }
		    SysFreeString(strGuid);
		}
	    }
	    else
	    {
		hr = _GetValues(s_apwszAttrs[i], &ppwszValues);
		if (S_OK == hr)
		{
		    DWORD j;

		    for (j = 0; NULL != ppwszValues[j]; j++)
		    {
			DBGPRINT((
			    DBG_SS_CERTPOL,
			    "%ws[%u] = %ws\n",
			    s_apwszAttrs[i],
			    j,
			    ppwszValues[j]));
		    }
		    _FreeValues(ppwszValues);
		    ppwszValues = NULL;
		}
	    }
	    if (S_OK != hr)
	    {
		DBGPRINT((DBG_SS_CERTPOL, "%ws = NULL\n", s_apwszAttrs[i]));
	    }
	}
    }
#endif

    hr = _GetValues(wszDSOBJECTCLASSATTRIBUTE, &ppwszValues);
    _JumpIfErrorStr(hr, error, "Policy:_GetValues", wszDSOBJECTCLASSATTRIBUTE);

    fUser = TRUE;
    if (NULL != ppwszValues)
    {
	DWORD i;

	for (i = 0; NULL != ppwszValues[i]; i++)
	{
	    DBGPRINT((
		DBG_SS_CERTPOLI,
		"%ws[%u] = %ws\n",
		wszDSOBJECTCLASSATTRIBUTE,
		i,
		ppwszValues[i]));
	    if (0 == LSTRCMPIS(ppwszValues[i], L"computer"))
	    {
		fUser = FALSE;
		break;
	    }
	}
    }

    if (fUser != m_fUser)
    {
	DBGPRINT((
	    DBG_SS_CERTPOL,
	    fUser? "MACHINE -> USER: %ws\n" : "USER -> MACHINE: %ws\n",
	    m_strUserDN));
	m_fUser = fUser;
    }

    if (!m_fUser && fDNSNameRequired)
    {
	if (NULL != ppwszValues)
	{
	    _FreeValues(ppwszValues);
	    ppwszValues = NULL;
	}
	hr = _GetValues(DS_ATTR_DNS_NAME, &ppwszValues);
	if (S_OK != hr || NULL == ppwszValues || NULL == ppwszValues[0])
	{
	    _PrintIfError(hr, "Policy:_GetValues");
	    hr = CERTSRV_E_SUBJECT_DNS_REQUIRED;
	}
	_JumpIfErrorStr(hr, error, "Policy:_GetValues", DS_ATTR_DNS_NAME);

	hr = polGetRequestAttribute(pServer, wszPROPREQUESTMACHINEDNS, &strDNS);
	_PrintIfErrorStr(
		    hr,
		    "Policy:polGetRequestAttribute",
		    wszPROPREQUESTMACHINEDNS);
	if (S_OK == hr &&
	    NULL != strDNS &&
	    0 != mylstrcmpiL(ppwszValues[0], strDNS))
	{
	    hr = HRESULT_FROM_WIN32(DNS_ERROR_NAME_DOES_NOT_EXIST);
	    _PrintErrorStr(hr, "Policy:DNS name changed", ppwszValues[0]);
	    _JumpErrorStr(hr, error, "Policy:DNS name changed", strDNS);
	}
    }
    hr = S_OK;

error:
    if (S_OK != hr && NULL != pwszError)
    {
	WCHAR *apwsz[2];

	apwsz[0] = m_strUserDN;
	apwsz[1] = pwszError;
	BuildErrorInfo(
		hr,
		HRESULT_FROM_WIN32(ERROR_DS_REFERRAL) == hr?
		    MSG_DS_REFERRAL :
		    MSG_DS_SEARCH_ERROR,
		apwsz);
    }
    if (NULL != strDNS)
    {
	SysFreeString(strDNS);
    }
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    if (NULL != ppwszValues)
    {
        _FreeValues(ppwszValues);
    }
    return(hr);
}


HRESULT
CRequestInstance::_GetValues(
    IN WCHAR const *pwszName,
    OUT WCHAR ***pppwszValues)
{
    HRESULT hr;
    WCHAR **ppwszValues = NULL;

    ppwszValues = ldap_get_values(
			    m_pldT,
			    m_PrincipalAttributes,
			    const_cast<WCHAR *>(pwszName));
    if (NULL == ppwszValues || NULL == ppwszValues[0])
    {
        hr = CERTSRV_E_PROPERTY_EMPTY;
        _JumpErrorStr2(hr, error, "Policy:ldap_get_values", pwszName, hr);
    }
    *pppwszValues = ppwszValues;
    ppwszValues = NULL;
    hr = S_OK;

error:
    if (NULL != ppwszValues)
    {
	ldap_value_free(ppwszValues);
    }
    return(hr);
}


HRESULT
CRequestInstance::_GetObjectGUID(
    OUT BSTR *pstrGuid)
{
    struct berval **pGuidVal = NULL;
    HRESULT hr;

    *pstrGuid = NULL;
    pGuidVal = ldap_get_values_len(
			    m_pldT,
			    m_PrincipalAttributes,
			    DS_ATTR_OBJECT_GUID);
    if (NULL == pGuidVal || NULL == pGuidVal[0])
    {
        hr = CERTSRV_E_PROPERTY_EMPTY;
        _JumpError2(hr, error, "Policy:ldap_get_values_len", hr);
    }
    *pstrGuid = SysAllocStringByteLen(
				pGuidVal[0]->bv_val,
				~(sizeof(WCHAR) - 1) & pGuidVal[0]->bv_len);
    if (NULL == *pstrGuid)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocStringByteLen");
    }
    hr = S_OK;

error:
    if (NULL != pGuidVal)
    {
	ldap_value_free_len(pGuidVal);
    }
    return(hr);
}


HRESULT
CRequestInstance::_FreeValues(
    IN WCHAR **ppwszValues)
{
    if (NULL != ppwszValues)
    {
        ldap_value_free(ppwszValues);
    }
    return(S_OK);
}


HRESULT
CRequestInstance::_GetValueString(
    IN WCHAR const *pwszName,
    OUT BSTRC *pstrValue)
{
    HRESULT hr;
    WCHAR **ppwszValues = NULL;
    BSTR strReturn;
    DWORD i;
    DWORD cwc;

    *pstrValue = NULL;

    hr = _GetValues(pwszName, &ppwszValues);
    _JumpIfErrorStr(hr, error, "Policy:_GetValues", pwszName);

    if (NULL == ppwszValues || NULL == ppwszValues[0])
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpErrorStr(hr, error, "Policy:ppwszValues", pwszName);
    }

    cwc = 0;
    for (i = 0; NULL != ppwszValues[i]; i++)
    {
	if (0 != i)
	{
	    cwc++;
	}
	cwc += wcslen(ppwszValues[i]);
    }

    strReturn = SysAllocStringLen(NULL, cwc);
    if (NULL == strReturn)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocStringLen");
    }

    strReturn[0] = L'\0';
    for (i = 0; NULL != ppwszValues[i]; i++)
    {
	if (0 != i)
	{
	    wcscat(strReturn, L",");
	}
	wcscat(strReturn, ppwszValues[i]);
    }
    CSASSERT(SysStringByteLen(strReturn) == cwc * sizeof(WCHAR));
    CSASSERT(wcslen(strReturn) == cwc);
    *pstrValue = strReturn;

error:
    if (NULL != ppwszValues)
    {
        _FreeValues(ppwszValues);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\default\template.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        template.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <ntdsapi.h>
#include <lm.h>
#include <winldap.h>
#include <security.h>
#include <ntdsapi.h>

#include "cspelog.h"
#include "pollog.h"

#include "csprop.h"
#include "csldap.h"
#include "csdisp.h"
#include "csber.h"
#include "policy.h"
#include "cainfop.h"

#define __dwFILE__	__dwFILE_POLICY_DEFAULT_TEMPLATE_CPP__

// Versions of NT earlier than this build have an auto-enrollment loop problem
// with not having the basic constraints extension, so we must put one in certs
// for these builds.  This build marks when certcli started return no BC
// extension for templates that were not CA's.

#define VERSION_AUTOENROLLMENT_BC_AWARE   2036


// Versions of NT earlier than this build have an auto-enrollment loop problem
// with having the UPN anywhere but the CN.  Certs for these builds must have
// the UPN in the common name.

#define VERSION_AUTOENROLLMENT_UPN_AWARE   2090

#define VERSION_WIN2K_XENROLL_CLIENT	   (2195 + 1)


// All of the "known" Key Usage bits currently defined:

#define dwKNOWN_KEY_USAGE_BITS \
	(CERT_DIGITAL_SIGNATURE_KEY_USAGE | \
	 CERT_NON_REPUDIATION_KEY_USAGE | \
	 CERT_KEY_ENCIPHERMENT_KEY_USAGE | \
	 CERT_DATA_ENCIPHERMENT_KEY_USAGE | \
	 CERT_KEY_AGREEMENT_KEY_USAGE | \
	 CERT_KEY_CERT_SIGN_KEY_USAGE | \
	 CERT_OFFLINE_CRL_SIGN_KEY_USAGE | \
	 CERT_CRL_SIGN_KEY_USAGE | \
	 CERT_ENCIPHER_ONLY_KEY_USAGE | \
	 (CERT_DECIPHER_ONLY_KEY_USAGE << 8))

// Mask to turn off all the "known" Key Usage bits that aren't expclitly valid:

#define dwKUMASK(dwValid)	((DWORD) ((dwValid) | ~dwKNOWN_KEY_USAGE_BITS))

typedef struct _KEYUSAGEMASK {
    WCHAR const * const *apwszAlg;
    DWORD dwMask1;	// 1: CA mask (2: if any of these bits are set)
    DWORD dwMask2;	// 1: EE mask (2: clear these bits)
} KEYUSAGEMASK;

WCHAR const * const s_apwszRSA[] =	// RSA public key
{
    TEXT(szOID_RSA_RSA),
    TEXT(szOID_OIWSEC_rsaXchg),
    NULL
};

WCHAR const * const s_apwszDSA[] =	// DSA public key
{
    TEXT(szOID_X957_DSA),
    TEXT(szOID_OIWSEC_dsa),
    TEXT(szOID_INFOSEC_mosaicKMandUpdSig),
    NULL
};

WCHAR const * const s_apwszDH[] =	// DH public key
{
    TEXT(szOID_ANSI_X942_DH),
    TEXT(szOID_RSA_DH),
    NULL
};

KEYUSAGEMASK g_aKeyUsageMask1[] =
{
  {
    s_apwszRSA,

    // Valid CA cert Key Usage bits -> mask = 0xffff7ff6

    dwKUMASK(
	CERT_DIGITAL_SIGNATURE_KEY_USAGE |
	CERT_NON_REPUDIATION_KEY_USAGE |
	CERT_KEY_ENCIPHERMENT_KEY_USAGE |
	CERT_DATA_ENCIPHERMENT_KEY_USAGE |
	CERT_KEY_CERT_SIGN_KEY_USAGE |
	CERT_CRL_SIGN_KEY_USAGE), // same as CERT_OFFLINE_CRL_SIGN_KEY_USAGE

    // Valid EE cert Key Usage bits -> mask = 0xffff7ff0

    dwKUMASK(
	CERT_DIGITAL_SIGNATURE_KEY_USAGE |
	CERT_NON_REPUDIATION_KEY_USAGE |
	CERT_KEY_ENCIPHERMENT_KEY_USAGE |
	CERT_DATA_ENCIPHERMENT_KEY_USAGE),
  },

  {
    s_apwszDSA,

    // Valid CA cert Key Usage bits -> mask = 0xffff7fc6

    dwKUMASK(
	CERT_DIGITAL_SIGNATURE_KEY_USAGE |
	CERT_NON_REPUDIATION_KEY_USAGE |
	CERT_KEY_CERT_SIGN_KEY_USAGE |
	CERT_CRL_SIGN_KEY_USAGE), // same as CERT_OFFLINE_CRL_SIGN_KEY_USAGE

    // Valid EE cert Key Usage bits -> mask = 0xffff7fc0

    dwKUMASK(
	CERT_DIGITAL_SIGNATURE_KEY_USAGE |
	CERT_NON_REPUDIATION_KEY_USAGE),
  },

  {
    s_apwszDH,

    // Valid CA cert Key Usage bits -> mask = 0xffff7f09

    dwKUMASK(
	CERT_KEY_AGREEMENT_KEY_USAGE |
	CERT_ENCIPHER_ONLY_KEY_USAGE),

    // Valid EE cert Key Usage bits -> mask = 0xffff7f09

    dwKUMASK(
	CERT_KEY_AGREEMENT_KEY_USAGE |
	CERT_ENCIPHER_ONLY_KEY_USAGE),
  },
};


KEYUSAGEMASK g_aKeyUsageMask2[] =
{
  {
    s_apwszRSA,

    // CERT_KEY_ENCIPHERMENT_KEY_USAGE(SHOULD not be set w/Cert,CRL sign)
    // CERT_DATA_ENCIPHERMENT_KEY_USAGE (SHOULD not be set w/Cert,CRL sign)

    CERT_KEY_CERT_SIGN_KEY_USAGE |
	CERT_CRL_SIGN_KEY_USAGE, // same as CERT_OFFLINE_CRL_SIGN_KEY_USAGE

    CERT_KEY_ENCIPHERMENT_KEY_USAGE |
	CERT_DATA_ENCIPHERMENT_KEY_USAGE,
  },
};


CRITICAL_SECTION g_DSCacheCriticalSection;
BOOL g_fDSCacheCriticalSection = FALSE;


HRESULT
TPInitialize(
    IN ICertServerPolicy *) // pServer
{
    return(S_OK);
}


VOID
TPCleanup()
{
}


HRESULT
tpCAGetCertTypeProperty(
    IN HCERTTYPE hCertType,
    IN WCHAR const *pwszPropName,
    WCHAR ***papwszValues)
{
    HRESULT hr;
    
    *papwszValues = NULL;
    hr = CAGetCertTypeProperty(hCertType, pwszPropName, papwszValues);
    _PrintIfErrorStr2(
	    hr,
	    "Policy:CAGetCertTypeProperty",
	    pwszPropName,
	    HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
    if (S_OK != hr)
    {
	*papwszValues = NULL;
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	{
	    goto error;
	}
	hr = S_OK;
    }

error:
    return(hr);
}


HRESULT
tpCAGetCertTypeStringProperty(
    IN HCERTTYPE hCertType,
    IN WCHAR const *pwszPropName,
    OUT WCHAR **ppwszValue)
{
    HRESULT hr;
    WCHAR **apwszValues = NULL;
    
    *ppwszValue = NULL;
    hr = CAGetCertTypeProperty(hCertType, pwszPropName, &apwszValues);
    if (S_OK != hr)
    {
	apwszValues = NULL;
	_JumpErrorStr(hr, error, "CAGetCertTypeProperty", pwszPropName);
    }
    if (NULL == apwszValues || NULL == apwszValues[0])
    {
	hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	_JumpErrorStr(hr, error, "CAGetCertTypeProperty", pwszPropName);
    }
    hr = myDupString(apwszValues[0], ppwszValue);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != apwszValues)
    {
        CAFreeCertTypeProperty(hCertType, apwszValues);
    }
    return(hr);
}


HRESULT
tpCAGetCertTypeObjectIdList(
    IN HCERTTYPE hCertType,
    IN WCHAR const *pwszPropName,
    OUT OBJECTIDLIST *prgPolicies)
{
    HRESULT hr;
    WCHAR **apwsz;

    prgPolicies->cObjId = 0;
    prgPolicies->rgpwszObjId = NULL;

    hr = tpCAGetCertTypeProperty(
			    hCertType,
			    pwszPropName,
			    &prgPolicies->rgpwszObjId);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:tpCAGetCertTypeProperty",
		pwszPropName);

    apwsz = prgPolicies->rgpwszObjId;
    if (NULL != apwsz)
    {
	while (NULL != *apwsz++)
	{
	    prgPolicies->cObjId++;
	}
    }
    hr = S_OK;

error:
    return(hr);
}


CTemplatePolicy::CTemplatePolicy()
{
    m_hCertType = NULL;
    ZeroMemory(&m_tp, sizeof(m_tp));
    m_pwszTemplateName = NULL;
    m_pwszTemplateObjId = NULL;
    m_pExtensions = NULL;
    ZeroMemory(&m_CriticalExtensions, sizeof(m_CriticalExtensions));
    ZeroMemory(&m_PoliciesIssuance, sizeof(m_PoliciesIssuance));
    ZeroMemory(&m_PoliciesApplication, sizeof(m_PoliciesApplication));
    m_pPolicy = NULL;
}


CTemplatePolicy::~CTemplatePolicy()
{
    _Cleanup();
}


VOID
CTemplatePolicy::_Cleanup()
{
    ZeroMemory(&m_tp, sizeof(m_tp));
    if (NULL != m_hCertType)
    {
        CACloseCertType(m_hCertType);
        m_hCertType = NULL;
    }
    if (NULL != m_pwszTemplateName)
    {
        LocalFree(m_pwszTemplateName);
        m_pwszTemplateName = NULL;
    }
    if (NULL != m_pwszTemplateObjId)
    {
        LocalFree(m_pwszTemplateObjId);
        m_pwszTemplateObjId = NULL;
    }
    if (NULL != m_pExtensions)
    {
	LocalFree(m_pExtensions);
	m_pExtensions = NULL;
    }
    if (NULL != m_CriticalExtensions.rgpwszObjId)
    {
	LocalFree(m_CriticalExtensions.rgpwszObjId);
    }
    ZeroMemory(&m_CriticalExtensions, sizeof(m_CriticalExtensions));

    if (NULL != m_PoliciesIssuance.rgpwszObjId)
    {
	LocalFree(m_PoliciesIssuance.rgpwszObjId);
    }
    ZeroMemory(&m_PoliciesIssuance, sizeof(m_PoliciesIssuance));

    if (NULL != m_PoliciesApplication.rgpwszObjId)
    {
	LocalFree(m_PoliciesApplication.rgpwszObjId);
    }
    ZeroMemory(&m_PoliciesApplication, sizeof(m_PoliciesApplication));

    m_pPolicy = NULL;
}


HRESULT
CTemplatePolicy::_LogLoadResult(
    IN CCertPolicyEnterprise *pPolicy,
    IN ICertServerPolicy *pServer,
    IN HRESULT hrLoad)
{
    HRESULT hr;
    WCHAR const *pwszError = NULL;
    WCHAR const *apwsz[2];
    DWORD level;
    DWORD MsgId;
    WCHAR const *pwszLogProp;
    WCHAR *pwszNameAndVersion = NULL;
#define wszFORMATVERSION	L"(v%u.%u): V%u"
    WCHAR wszVersion[ARRAYSIZE(wszFORMATVERSION) + 3 * cwcDWORDSPRINTF];
    WCHAR const *pwszTemplate;

    if (S_OK != hrLoad)
    {
	pwszError = myGetErrorMessageText(hrLoad, TRUE);
	level = CERTLOG_WARNING;
	MsgId = MSG_LOAD_TEMPLATE;
	pwszLogProp = wszPROPEVENTLOGWARNING;
    }
    else
    {
	level = CERTLOG_VERBOSE;
	MsgId = MSG_LOAD_TEMPLATE_SUCCEEDED;
	pwszLogProp = wszPROPEVENTLOGVERBOSE;
    }
    if (level > pPolicy->GetLogLevel())
    {
	hr = S_OK;
	goto error;
    }
    
    wsprintf(
	wszVersion,
	wszFORMATVERSION,
	m_tp.dwTemplateMajorVersion,
	m_tp.dwTemplateMinorVersion,
	m_tp.dwSchemaVersion);
    CSASSERT(wcslen(wszVersion) < ARRAYSIZE(wszVersion));

    pwszTemplate = m_pwszTemplateName;
    if (NULL == pwszTemplate)
    {
	pwszTemplate = L"???";
    }
    pwszNameAndVersion = (WCHAR *) LocalAlloc(
		    LMEM_FIXED,
		    (wcslen(pwszTemplate) + wcslen(wszVersion) + 1) *
			sizeof(WCHAR));
    if (NULL == pwszNameAndVersion)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:LocalAlloc");
    }
    wcscpy(pwszNameAndVersion, pwszTemplate);
    wcscat(pwszNameAndVersion, wszVersion);

    apwsz[0] = pwszNameAndVersion;
    apwsz[1] = pwszError;

    hr = LogPolicyEvent(
		g_hInstance,
		S_OK,
		MsgId,
		pServer,
		pwszLogProp,
		apwsz);
    _JumpIfError(hr, error, "CTemplatePolicy:Initialize:LogPolicyEvent");

error:
    if (NULL != pwszNameAndVersion)
    {
	LocalFree(pwszNameAndVersion);
    }
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    return(hr);
}


HRESULT
CTemplatePolicy::_CloneExtensions(
    IN CERT_EXTENSIONS const *pExtensionsIn,
    OUT CERT_EXTENSIONS **ppExtensionsOut)
{
    HRESULT hr;
    DWORD cb;
    CERT_EXTENSION *pExt;
    CERT_EXTENSION *pExtEnd;
    CERT_EXTENSION *pExtOut;
    BYTE *pbOut;

    *ppExtensionsOut = NULL;
    cb = sizeof(CERT_EXTENSIONS) +
	pExtensionsIn->cExtension * sizeof(pExtensionsIn->rgExtension[0]);

    pExtEnd = &pExtensionsIn->rgExtension[pExtensionsIn->cExtension];
    for (pExt = pExtensionsIn->rgExtension; pExt < pExtEnd; pExt++)
    {
	cb += DWORDROUND(strlen(pExt->pszObjId) + 1);
	cb += DWORDROUND(pExt->Value.cbData);
    }
    *ppExtensionsOut = (CERT_EXTENSIONS *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppExtensionsOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:LocalAlloc");
    }
    (*ppExtensionsOut)->cExtension = pExtensionsIn->cExtension;
    pExtOut = (CERT_EXTENSION *) &(*ppExtensionsOut)[1];
    (*ppExtensionsOut)->rgExtension = pExtOut;

    pbOut = (BYTE *) &pExtOut[pExtensionsIn->cExtension];
    for (pExt = pExtensionsIn->rgExtension; pExt < pExtEnd; pExt++, pExtOut++)
    {
	pExtOut->pszObjId = (char *) pbOut;
	strcpy(pExtOut->pszObjId, pExt->pszObjId);
	pbOut += DWORDROUND(strlen(pExt->pszObjId) + 1);

	pExtOut->fCritical = pExt->fCritical;
	pExtOut->Value.cbData = pExt->Value.cbData;

	pExtOut->Value.pbData = pbOut;
	CopyMemory(
	    pExtOut->Value.pbData,
	    pExt->Value.pbData,
	    pExt->Value.cbData);
	pbOut += DWORDROUND(pExt->Value.cbData);
    }
    CSASSERT(Add2Ptr(*ppExtensionsOut, cb) == pbOut);
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CTemplatePolicy::_CloneObjectIdList(
    IN OBJECTIDLIST const *pObjectIdListIn,
    OUT OBJECTIDLIST *pObjectIdListOut)
{
    HRESULT hr;
    
    ZeroMemory(pObjectIdListOut, sizeof(*pObjectIdListOut));
    pObjectIdListOut->cObjId = pObjectIdListIn->cObjId;
    if (0 != pObjectIdListIn->cObjId)
    {
	DWORD cb = (pObjectIdListIn->cObjId + 1) * sizeof(pObjectIdListIn->rgpwszObjId);
	WCHAR const * const *ppwsz;
	WCHAR const * const *ppwszEnd;
	WCHAR **ppwszOut;
	BYTE *pbOut;

	ppwszEnd = &pObjectIdListIn->rgpwszObjId[pObjectIdListIn->cObjId];
	for (ppwsz = pObjectIdListIn->rgpwszObjId; ppwsz < ppwszEnd; ppwsz++)
	{
	    cb += DWORDROUND((wcslen(*ppwsz) + 1) * sizeof(WCHAR));
	}
	pObjectIdListOut->rgpwszObjId = (WCHAR **) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == pObjectIdListOut->rgpwszObjId)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:LocalAlloc");
	}
	ppwszOut = pObjectIdListOut->rgpwszObjId;
	pbOut = (BYTE *) &ppwszOut[pObjectIdListOut->cObjId + 1];
	for (
	    ppwsz = pObjectIdListIn->rgpwszObjId;
	    ppwsz < ppwszEnd;
	    ppwsz++, ppwszOut++)
	{
	    *ppwszOut = (WCHAR *) pbOut;
	    wcscpy(*ppwszOut, *ppwsz);
	    pbOut += DWORDROUND((wcslen(*ppwszOut) + 1) * sizeof(WCHAR));
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::Initialize
// Populate the CTemplatePolicy object from the registry
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::Initialize(
    IN HCERTTYPE hCertType,
    IN ICertServerPolicy *pServer,
    IN CCertPolicyEnterprise *pPolicy)
{
    HRESULT hr;
    CERT_EXTENSIONS *pExtensions = NULL;
    OBJECTIDLIST CriticalExtensions;
    OBJECTIDLIST PoliciesIssuance;
    OBJECTIDLIST PoliciesApplication;

    ZeroMemory(&CriticalExtensions, sizeof(CriticalExtensions));
    ZeroMemory(&PoliciesIssuance, sizeof(PoliciesIssuance));
    ZeroMemory(&PoliciesApplication, sizeof(PoliciesApplication));
    _Cleanup();
    CSASSERT(0 == m_tp.dwTemplateMajorVersion);
    CSASSERT(0 == m_tp.dwTemplateMinorVersion);
    CSASSERT(0 == m_tp.dwSchemaVersion);
    CSASSERT(0 == m_tp.dwMinKeyLength);

    hr = tpCAGetCertTypeStringProperty(
				hCertType,
				CERTTYPE_PROP_DN,
				&m_pwszTemplateName);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:Initialize:tpCAGetCertTypeStringProperty",
		CERTTYPE_PROP_DN);

    hr = CAGetCertTypePropertyEx(
			hCertType,
			CERTTYPE_PROP_REVISION,
			&m_tp.dwTemplateMajorVersion);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:Initialize:CAGetCertTypePropertyEx",
		CERTTYPE_PROP_REVISION);

    hr = CAGetCertTypePropertyEx(
			hCertType,
			CERTTYPE_PROP_SCHEMA_VERSION,
			&m_tp.dwSchemaVersion);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:Initialize:CAGetCertTypePropertyEx",
		CERTTYPE_PROP_SCHEMA_VERSION);

    if (CERTTYPE_SCHEMA_VERSION_2 <= m_tp.dwSchemaVersion)
    {
	hr = tpCAGetCertTypeStringProperty(
				    hCertType,
				    CERTTYPE_PROP_OID,
				    &m_pwszTemplateObjId);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "CTemplatePolicy:Initialize:tpCAGetCertTypeStringProperty",
		    CERTTYPE_PROP_OID);

	hr = CAGetCertTypePropertyEx(
			    hCertType,
			    CERTTYPE_PROP_MINOR_REVISION,
			    &m_tp.dwTemplateMinorVersion);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "CTemplatePolicy:Initialize:CAGetCertTypePropertyEx",
		    CERTTYPE_PROP_MINOR_REVISION);

	hr = CAGetCertTypePropertyEx(
			    hCertType,
			    CERTTYPE_PROP_MIN_KEY_SIZE,
			    &m_tp.dwMinKeyLength);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "CTemplatePolicy:Initialize:CAGetCertTypePropertyEx",
		    CERTTYPE_PROP_MIN_KEY_SIZE);
    }

    if (!FIsAdvancedServer() && CERTTYPE_SCHEMA_VERSION_2 <= m_tp.dwSchemaVersion)
    {
	// V2 templates require Advanced Server

	hr = HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED);
	_JumpError(hr, error, "CTemplatePolicy:Initialize:m_tp.dwSchemaVersion");
    }
    m_pPolicy = pPolicy;

    hr = CAGetCertTypeFlagsEx(
			hCertType,
			CERTTYPE_ENROLLMENT_FLAG,
			&m_tp.dwEnrollmentFlags);
    _JumpIfError(hr, error, "CTemplatePolicy:Initialize:CAGetCertTypeFlagsEx");

    hr = CAGetCertTypeFlagsEx(
			hCertType,
			CERTTYPE_SUBJECT_NAME_FLAG,
			&m_tp.dwSubjectNameFlags);
    _JumpIfError(hr, error, "CTemplatePolicy:Initialize:CAGetCertTypeFlagsEx");

    hr = CAGetCertTypeFlagsEx(
			hCertType,
			CERTTYPE_PRIVATE_KEY_FLAG,
			&m_tp.dwPrivateKeyFlags);
    _JumpIfError(hr, error, "CTemplatePolicy:Initialize:CAGetCertTypeFlagsEx");

    hr = CAGetCertTypeFlagsEx(
			hCertType,
			CERTTYPE_GENERAL_FLAG,
			&m_tp.dwGeneralFlags);
    _JumpIfError(hr, error, "CTemplatePolicy:Initialize:CAGetCertTypeFlagsEx");

    hr = CAGetCertTypePropertyEx(
			hCertType,
			CERTTYPE_PROP_RA_SIGNATURE,
			&m_tp.dwcSignatureRequired);
    _PrintIfErrorStr2(
		hr,
		"CTemplatePolicy:Initialize:CAGetCertTypePropertyEx",
		CERTTYPE_PROP_RA_SIGNATURE,
		HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
    if (S_OK != hr)
    {
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	{
	    goto error;
	}
	m_tp.dwcSignatureRequired = 0;
    }
    hr = CAGetCertTypeExpiration(
			    hCertType,
			    &m_tp.llftExpirationPeriod.ft,
			    &m_tp.llftOverlapPeriod.ft);
    _JumpIfError(hr, error, "Policy:CAGetCertTypeExpiration");


    hr = CAGetCertTypeExtensions(hCertType, &pExtensions);
    _JumpIfError(hr, error, "CTemplatePolicy:Initialize:CAGetCertTypeExtensions");

    hr = _CloneExtensions(pExtensions, &m_pExtensions);
    _JumpIfError(hr, error, "CTemplatePolicy:_CloneExtensions");

    hr = tpCAGetCertTypeObjectIdList(
		hCertType,
		CERTTYPE_PROP_CRITICAL_EXTENSIONS,
		&CriticalExtensions);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:tpCAGetCertTypePolicies",
		CERTTYPE_PROP_CRITICAL_EXTENSIONS);

    hr = _CloneObjectIdList(&CriticalExtensions, &m_CriticalExtensions);
    _JumpIfError(hr, error, "CTemplatePolicy:_CloneObjectIdList");

    hr = tpCAGetCertTypeObjectIdList(
		hCertType,
		CERTTYPE_PROP_RA_POLICY,
		&PoliciesIssuance);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:tpCAGetCertTypePolicies",
		CERTTYPE_PROP_RA_POLICY);

    hr = _CloneObjectIdList(&PoliciesIssuance, &m_PoliciesIssuance);
    _JumpIfError(hr, error, "CTemplatePolicy:_CloneObjectIdList");

    hr = tpCAGetCertTypeObjectIdList(
		hCertType,
		CERTTYPE_PROP_RA_APPLICATION_POLICY,
		&PoliciesApplication);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:tpCAGetCertTypePolicies",
		CERTTYPE_PROP_RA_APPLICATION_POLICY);

    hr = _CloneObjectIdList(&PoliciesApplication, &m_PoliciesApplication);
    _JumpIfError(hr, error, "CTemplatePolicy:_CloneObjectIdList");

    m_hCertType = hCertType;	// Transfer ownership only on success

error:
    if (NULL != pExtensions)
    {
	CAFreeCertTypeExtensions(hCertType, pExtensions);
    }
    if (NULL != CriticalExtensions.rgpwszObjId)
    {
        CAFreeCertTypeProperty(hCertType, CriticalExtensions.rgpwszObjId);
    }
    if (NULL != PoliciesIssuance.rgpwszObjId)
    {
        CAFreeCertTypeProperty(hCertType, PoliciesIssuance.rgpwszObjId);
    }
    if (NULL != PoliciesApplication.rgpwszObjId)
    {
        CAFreeCertTypeProperty(hCertType, PoliciesApplication.rgpwszObjId);
    }
    DBGPRINT((
	DBG_SS_CERTPOL,
	"Policy:Template:Initialize(%ws, v%u.%u): V%u hr=%x\n",
	NULL != m_pwszTemplateName? m_pwszTemplateName : L"",
	m_tp.dwTemplateMajorVersion,
	m_tp.dwTemplateMinorVersion,
	m_tp.dwSchemaVersion,
	hr));
    _LogLoadResult(pPolicy, pServer, hr);
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::Clone
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::Clone(
    OUT CTemplatePolicy **ppTemplate)
{
    HRESULT hr;
    CTemplatePolicy *pTemplateClone = NULL;

    *ppTemplate = NULL;
    pTemplateClone = new CTemplatePolicy;
    if (NULL == pTemplateClone)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:Clone:new");
    }
    //pTemplateClone->m_hCertType = m_hCertType;
    pTemplateClone->m_tp = m_tp;

    if (NULL != m_pwszTemplateName)
    {
	hr = myDupString(
		    m_pwszTemplateName,
		    &pTemplateClone->m_pwszTemplateName);
	_JumpIfError(hr, error, "myDupString");
    }
    if (NULL != m_pwszTemplateObjId)
    {
	hr = myDupString(
		    m_pwszTemplateObjId,
		    &pTemplateClone->m_pwszTemplateObjId);
	_JumpIfError(hr, error, "myDupString");
    }

    hr = _CloneExtensions(m_pExtensions, &pTemplateClone->m_pExtensions);
    _JumpIfError(hr, error, "CTemplatePolicy:_CloneExtensions");

    hr = _CloneObjectIdList(
		&m_CriticalExtensions,
		&pTemplateClone->m_CriticalExtensions);
    _JumpIfError(hr, error, "CTemplatePolicy:_CloneObjectIdList");

    hr = _CloneObjectIdList(
		&m_PoliciesIssuance,
		&pTemplateClone->m_PoliciesIssuance);
    _JumpIfError(hr, error, "CTemplatePolicy:_CloneObjectIdList");

    hr = _CloneObjectIdList(
		&m_PoliciesApplication,
		&pTemplateClone->m_PoliciesApplication);
    _JumpIfError(hr, error, "CTemplatePolicy:_CloneObjectIdList");

    pTemplateClone->m_pPolicy = m_pPolicy;

    *ppTemplate = pTemplateClone;
    pTemplateClone = NULL;
    hr = S_OK;

error:
    if (NULL != pTemplateClone)
    {
	delete pTemplateClone;
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::AccessCheck
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::AccessCheck(
    IN HANDLE hToken)
{
    HRESULT hr;

    hr = CACertTypeAccessCheck(m_hCertType, hToken);
    if (E_ACCESSDENIED == hr)
    {
	// map E_ACCESSDENIED to a more meaningful error

	hr = CERTSRV_E_TEMPLATE_DENIED;
    }
    _JumpIfError(hr, error, "Policy:CACertTypeAccessCheck");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::Apply
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::Apply(
    IN ICertServerPolicy *pServer,
    IN CRequestInstance *pRequest,
    OUT BOOL *pfReenroll)
{
    HRESULT hr;
    DWORD dwRequestTemplateMinimumMajorVersion;
    DWORD dwRequestTemplateMinimumMinorVersion;
    BOOL fEnrollOnBehalfOf = FALSE;

    *pfReenroll = FALSE;

    pRequest->GetTemplateVersion(
			&dwRequestTemplateMinimumMajorVersion,
			&dwRequestTemplateMinimumMinorVersion);
    CONSOLEPRINT5((
	    DBG_SS_CERTPOL,
	    "Request cert type: %ws(v%u.%u/v%u.%u)\n",
	    pRequest->GetTemplateName(),
	    dwRequestTemplateMinimumMajorVersion,
	    dwRequestTemplateMinimumMinorVersion,
	    m_tp.dwTemplateMajorVersion,
	    m_tp.dwTemplateMinorVersion));

    hr = _AddBasicConstraintsExtension(pRequest, pServer);
    _JumpIfError(hr, error, "Policy:_AddBasicConstraintsExtension");

    hr = _AddKeyUsageExtension(pServer, pRequest);
    _JumpIfError(hr, error, "Policy:_AddKeyUsageExtension");

    hr = _AddTemplateExtensionArray(pServer);
    _JumpIfError(hr, error, "Policy:_AddTemplateExtensionArray");

    if (0 == (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT & m_tp.dwSubjectNameFlags))
    {
        hr = pRequest->_LoadPrincipalObject(
			    pServer,
			    this,
			    0 != ((CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME |
				   CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN |
				   CT_FLAG_SUBJECT_ALT_REQUIRE_DNS) &
				  m_tp.dwSubjectNameFlags));
        _JumpIfError(hr, error, "_LoadPrincipalObject");

        hr = _AddSubjectName(pServer, pRequest);
	_JumpIfError(hr, error, "Policy:_AddSubjectName");
    }
    hr = _AddAltSubjectName(pServer, pRequest);
    _JumpIfError(hr, error, "Policy:_AddAltSubjectName");

    pRequest->_ReleasePrincipalObject();

    hr = _ApplyExpirationTime(pServer, pRequest);
    _JumpIfError(hr, error, "Policy:_ApplyExpirationTime");

    hr = _EnforceKeySizePolicy(pServer);
    _JumpIfError(hr, error, "Policy:_EnforceKeySizePolicy");

    hr = _EnforceKeyArchivalPolicy(pServer);
    _JumpIfError(hr, error, "Policy:_EnforceKeyArchivalPolicy");

    hr = _EnforceSymmetricAlgorithms(pServer);
    _JumpIfError(hr, error, "Policy:_EnforceSymmetricAlgorithms");

    hr = _EnforceMinimumTemplateVersion(pRequest);
    _JumpIfError(hr, error, "Policy:_EnforceMinimumTemplateVersion");

    hr = _EnforceEnrollOnBehalfOfAllowed(pServer, &fEnrollOnBehalfOf);
    _JumpIfError(hr, error, "Policy:_EnforceEnrollOnBehalfOfAllowed");

    hr = S_FALSE;
    if (CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT & m_tp.dwEnrollmentFlags)
    {
	hr = _EnforceReenrollment(pServer, pRequest);
	_PrintIfError(hr, "Policy:_EnforceReenrollment");
	if (S_OK == hr)
	{
	    *pfReenroll = TRUE;
	}
    }
    if (S_OK != hr)
    {
	hr = _EnforceSignaturePolicy(pServer, pRequest, fEnrollOnBehalfOf);
	_JumpIfError(hr, error, "Policy:_EnforceSignaturePolicy");
    }
    CSASSERT(S_OK == hr);

error:
    pRequest->_ReleasePrincipalObject();
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::_AddBasicConstraintsExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_AddBasicConstraintsExtension(
    IN CRequestInstance *pRequest,
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    CERT_EXTENSION const *pExt;
    CERT_EXTENSION BasicConstraintsExtension;

    BasicConstraintsExtension.Value.pbData = NULL;

    pExt = CertFindExtension(
			szOID_BASIC_CONSTRAINTS2,
			m_pExtensions->cExtension,
			m_pExtensions->rgExtension);
    if (NULL == pExt)
    {
        if (pRequest->_IsNTClientOlder(
				5,
				0,
				VERSION_AUTOENROLLMENT_BC_AWARE,
				VER_PLATFORM_WIN32_NT))
        {

            CERT_BASIC_CONSTRAINTS2_INFO OldBasicConstraints =
		{ FALSE, FALSE, 0};

            // Older autoenrollment clients don't know how to deal with
            // having no basic constraints extension, so they might loop.
            // For an old client, we must fabricate a basic constraints.

            if (!myEncodeObject(
			X509_ASN_ENCODING,
			szOID_BASIC_CONSTRAINTS2,
			&OldBasicConstraints,
			0,
			CERTLIB_USE_LOCALALLOC,
			&BasicConstraintsExtension.Value.pbData,
			&BasicConstraintsExtension.Value.cbData))
	    {
                hr = myHLastError();
                _JumpError(hr, error, "Policy:myEncodeObject");
            }
            BasicConstraintsExtension.fCritical = TRUE;
            BasicConstraintsExtension.pszObjId = szOID_BASIC_CONSTRAINTS2;
            pExt = &BasicConstraintsExtension;
        }
    }
    hr = m_pPolicy->AddBasicConstraintsCommon(
				    pServer,
				    pExt,
				    FALSE, // fCA only enabled for standalone
				    NULL != pExt);
    _JumpIfError(hr, error, "Policy:AddBasicConstraintsCommon");

error:
    if (NULL != BasicConstraintsExtension.Value.pbData)
    {
        LocalFree(BasicConstraintsExtension.Value.pbData);
    }
    return(hr);
}


KEYUSAGEMASK const *
FindKeyUsage(
    IN WCHAR const *pwszAlg,
    IN KEYUSAGEMASK const *pKeyUsageMask,
    IN DWORD cKeyUsageMask)
{
    KEYUSAGEMASK const *pKeyUsageMaskRet = NULL;
    KEYUSAGEMASK const *pKeyUsageMaskEnd;

    for (
	pKeyUsageMaskEnd = &pKeyUsageMask[cKeyUsageMask];
	pKeyUsageMask < pKeyUsageMaskEnd;
	pKeyUsageMask++)
    {
        DWORD i;
	
	for (i = 0; NULL != pKeyUsageMask->apwszAlg[i]; i++)
	{
	    if (0 == wcscmp(pwszAlg, pKeyUsageMask->apwszAlg[i]))
	    {
		pKeyUsageMaskRet = pKeyUsageMask;
		break;
	    }
	}
	if (NULL != pKeyUsageMaskRet)
	{
	    break;
	}
    }
    return(pKeyUsageMaskRet);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::_AddKeyUsageExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_AddKeyUsageExtension(
    IN ICertServerPolicy *pServer,
    IN CRequestInstance *pRequest)
{
    HRESULT hr = S_OK;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strAlg = NULL;
    CERT_EXTENSION const *pExt;
    CRYPT_BIT_BLOB *pKeyUsage = NULL;
    BYTE *pbKeyUsage = NULL;
    DWORD cbKeyUsage;
    DWORD dwKU;
    KEYUSAGEMASK const *pKeyUsageMask;

    VariantInit(&varExtension);

    pExt = CertFindExtension(
			szOID_KEY_USAGE,
			m_pExtensions->cExtension,
			m_pExtensions->rgExtension);
    if (NULL == pExt)
    {
        hr = S_OK;
        goto error;
    }

    if (!myDecodeObject(
		X509_ASN_ENCODING,
		X509_KEY_USAGE,
		pExt->Value.pbData,
		pExt->Value.cbData,
		CERTLIB_USE_LOCALALLOC,
		(VOID **) &pKeyUsage,
		&cbKeyUsage))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:myDecodeObject");
    }

    hr = polGetCertificateStringProperty(
				pServer,
				wszPROPCERTIFICATEPUBLICKEYALGORITHM,
				&strAlg);
    _JumpIfError(hr, error, "Policy:polGetCertificateStringProperty");

    // Mask out any illegal bits

    dwKU = 0;
    CopyMemory(&dwKU, pKeyUsage->pbData, min(sizeof(dwKU), pKeyUsage->cbData));
    pKeyUsageMask = FindKeyUsage(
			    strAlg,
			    g_aKeyUsageMask1,
			    ARRAYSIZE(g_aKeyUsageMask1));
    if (NULL != pKeyUsageMask)
    {
	dwKU &= pRequest->IsCARequest()?
			    pKeyUsageMask->dwMask1 : pKeyUsageMask->dwMask2;
    }

    pKeyUsageMask = FindKeyUsage(
			    strAlg,
			    g_aKeyUsageMask2,
			    ARRAYSIZE(g_aKeyUsageMask2));
    if (NULL != pKeyUsageMask && (dwKU & pKeyUsageMask->dwMask1))
    {
	dwKU &= ~pKeyUsageMask->dwMask2;
    }

    CopyMemory(pKeyUsage->pbData, &dwKU, min(sizeof(dwKU), pKeyUsage->cbData));

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_KEY_USAGE,
		    pKeyUsage,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbKeyUsage,
		    &cbKeyUsage))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }

    if (!myConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbKeyUsage,
			cbKeyUsage))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    strExtension = NULL;
    hr = polSetCertificateExtension(
			    pServer,
			    TEXT(szOID_KEY_USAGE),
			    PROPTYPE_BINARY,
			    pExt->fCritical? EXTENSION_CRITICAL_FLAG : 0,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:polSetCertificateExtension");

error:
    VariantClear(&varExtension);
    if (NULL != strAlg)
    {
        SysFreeString(strAlg);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != pbKeyUsage)
    {
        LocalFree(pbKeyUsage);
    }
    if (NULL != pKeyUsage)
    {
        LocalFree(pKeyUsage);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::_AddTemplateExtensionArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_AddTemplateExtensionArray(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    DWORD i;

    for (i = 0; i < m_pExtensions->cExtension; i++)
    {
	CERT_EXTENSION const *pExt = &m_pExtensions->rgExtension[i];

	// Skip extensions that have special handling code.

	if (0 == strcmp(szOID_BASIC_CONSTRAINTS2, pExt->pszObjId) ||
	    0 == strcmp(szOID_KEY_USAGE, pExt->pszObjId))
	{
	    continue;
	}
	hr = _AddTemplateExtension(pServer, pExt);
	_JumpIfError(hr, error, "Policy:_AddTemplateExtension");
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::_AddTemplateExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_AddTemplateExtension(
    IN ICertServerPolicy *pServer,
    IN CERT_EXTENSION const *pExt)
{
    HRESULT hr = S_OK;
    BSTR strExtension = NULL;
    BSTR strObjId = NULL;
    VARIANT varExtension;

    if (!myConvertSzToBstr(&strObjId, pExt->pszObjId, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertSzToBstr");
    }

    if (!myConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pExt->Value.pbData,
			pExt->Value.cbData))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertWszToBstr");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    strObjId,
			    PROPTYPE_BINARY,
			    pExt->fCritical? EXTENSION_CRITICAL_FLAG : 0,
			    &varExtension);
    _JumpIfErrorStr(hr, error, "Policy:polSetCertificateExtension", strObjId);

error:
    if (NULL != strObjId)
    {
        SysFreeString(strObjId);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CTemplatePolicy::_AddSubjectName
//
// Build the subject name and add it to the cert, if required
//
// The subject name consists of:
// machine:  the CN is set to the UPN (machineDNSName)
// old user: the CN is set to the UPN (Kerberos name)
// user:     the CN is set to the DS_ATTR_COMMON_NAME
//
// both:  E= indicates an e-mail name
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_AddSubjectName(
    IN ICertServerPolicy *pServer,
    CRequestInstance *pRequest)
{
    HRESULT hr;
    BSTRC strCN = NULL;
    BSTRC strEMail = NULL;
    BSTR strPropEMail = NULL;
    VARIANT varValue;
    BSTR strSubjectDot = NULL;
    BSTR strSubjectCommonName = NULL;

    varValue.vt = VT_NULL;

    strSubjectDot = SysAllocString(wszPROPSUBJECTDOT);
    strSubjectCommonName = SysAllocString(wszPROPSUBJECTCOMMONNAME);
    if (NULL == strSubjectDot || NULL == strSubjectCommonName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }

    // Clear out any existing subject name info

    hr = pServer->SetCertificateProperty(
				    strSubjectDot,
				    PROPTYPE_STRING,
				    &varValue);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

    if (CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH & m_tp.dwSubjectNameFlags)
    {
	hr = _AddDSDistinguishedName(pServer, pRequest);
	_JumpIfError(hr, error, "Policy:_AddDSDistinguishedName");
    }
    else
    if ((CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME |
	 CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN) & m_tp.dwSubjectNameFlags)
    {
	if (!pRequest->_IsUser() ||
	    (pRequest->_IsXenrollRequest() &&
	     pRequest->_IsNTClientOlder(
				5,
				0,
				VERSION_AUTOENROLLMENT_UPN_AWARE,
				VER_PLATFORM_WIN32_NT)))

	{
	    // The UPN will be either a user UPN or the machine DNS name

	    if (NULL == pRequest->m_pwszUPN)
	    {
		hr = E_POINTER;	// We should never get this
		_JumpError(hr, error, "Policy:NULL UPN");
	    }
	    strCN = SysAllocString(pRequest->m_pwszUPN);
	    if (NULL == strCN)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:SysAllocString");
	    }
	}
	else
	{
	    // We are talking to an advanced client which can deal with a UPN
	    // in a SubjectAltName extension.  Put the DS CN in the cert.

	    hr = pRequest->_GetValueString(DS_ATTR_COMMON_NAME, &strCN);
	    _JumpIfErrorStr(
			hr,
			error,
			"Policy:_GetValueString",
			DS_ATTR_COMMON_NAME);
	}
	CSASSERT(NULL != strCN);
	varValue.vt = VT_BSTR;
	varValue.bstrVal = const_cast<BSTR>(strCN);

	hr = pServer->SetCertificateProperty(
				    strSubjectCommonName,
				    PROPTYPE_STRING,
				    &varValue);
	_JumpIfError(hr, error, "Policy:SetCertificateProperty");
    }

    if (CT_FLAG_SUBJECT_REQUIRE_EMAIL & m_tp.dwSubjectNameFlags)
    {
        hr = pRequest->_GetValueString(DS_ATTR_EMAIL_ADDR, &strEMail);
        if (S_OK != hr)
        {
	    if (CERTTYPE_SCHEMA_VERSION_2 <= m_tp.dwSchemaVersion &&
		0 == (EDITF_EMAILOPTIONAL & m_pPolicy->GetEditFlags()))
	    {
		hr = CERTSRV_E_SUBJECT_EMAIL_REQUIRED;
		_JumpError(hr, error, "Policy:_AddSubjectName:EMail");
	    }
	    pRequest->BuildErrorInfo(
				hr,
				MSG_NO_EMAIL_NAME,
				&pRequest->m_strUserDN);
	}
	else
	{
	    varValue.vt = VT_BSTR;
	    varValue.bstrVal = const_cast<BSTR>(strEMail);

	    strPropEMail = SysAllocString(wszPROPSUBJECTEMAIL);
	    if (NULL == strPropEMail)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:SysAllocStringLen");
	    }

	    hr = pServer->SetCertificateProperty(
					strPropEMail,
					PROPTYPE_STRING,
					&varValue);
	    _JumpIfError(hr, error, "Policy:SetCertificateProperty");
	}
    }
    hr = S_OK;

error:
    if (NULL != strPropEMail)
    {
        SysFreeString(strPropEMail);
    }
    if (NULL != strCN)
    {
        SysFreeString(const_cast<BSTR>(strCN));
    }
    if (NULL != strEMail)
    {
        SysFreeString(const_cast<BSTR>(strEMail));
    }
    if (NULL != strSubjectDot)
    {
        SysFreeString(strSubjectDot);
    }
    if (NULL != strSubjectCommonName)
    {
        SysFreeString(strSubjectCommonName);
    }
    return(hr);
}


HRESULT
tpDsUnquoteRdnValue(
    IN DWORD cwcVal,
    IN WCHAR const *pwcVal,
    OUT WCHAR **ppwszVal)
{
    HRESULT hr;
    DWORD cwc;

    *ppwszVal = NULL;
    cwc = 0;
    while (TRUE)
    {
	hr = DsUnquoteRdnValue(cwcVal, pwcVal, &cwc, *ppwszVal);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    if (NULL == *ppwszVal)
	    {
		if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) == hr)
		{
		    hr = S_OK;
		}
	    }
	    else
	    {
		LocalFree(*ppwszVal);
		*ppwszVal = NULL;
	    }
	    _JumpIfError(hr, error, "Policy:DsUnquoteRdnValue");
	}
	if (NULL != *ppwszVal)
	{
	    (*ppwszVal)[cwc] = L'\0';
	    break;
	}
	*ppwszVal = (WCHAR *) LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * (cwc + 1));
	if (NULL == *ppwszVal)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:LocalAlloc");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
tpSetRequestRDN(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwcKey,
    IN DWORD cwcKey,
    IN WCHAR const *pwcVal,
    IN DWORD cwcVal)
{
    HRESULT hr;
    WCHAR *pwszVal = NULL;
    BSTR strRDNName = NULL;
    BSTR strValueOld = NULL;
    BSTR strValue = NULL;
    VARIANT varNew;
    
    hr = tpDsUnquoteRdnValue(cwcVal, pwcVal, &pwszVal);
    _JumpIfError(hr, error, "Policy:tpDsUnquoteRdnValue");

    strRDNName = SysAllocStringLen(
			    NULL,
			    WSZARRAYSIZE(wszPROPSUBJECTDOT) + cwcKey);
    if (NULL == strRDNName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocStringLen");
    }
    wcscpy(strRDNName, wszPROPSUBJECTDOT);
    CopyMemory(
	&strRDNName[WSZARRAYSIZE(wszPROPSUBJECTDOT)],
	pwcKey,
	sizeof(WCHAR) * cwcKey);
    strRDNName[WSZARRAYSIZE(wszPROPSUBJECTDOT) + cwcKey] = L'\0';
    CSASSERT(SysStringByteLen(strRDNName) == wcslen(strRDNName) * sizeof(WCHAR));

    hr = polGetCertificateStringProperty(pServer, strRDNName, &strValueOld);
    if (S_OK == hr)
    {
	strValue = SysAllocStringLen(
			NULL,
			wcslen(pwszVal) +
			    WSZARRAYSIZE(wszNAMESEPARATORDEFAULT) +
			    wcslen(strValueOld));
	if (NULL == strValue)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocStringLen");
	}
	wcscpy(strValue, pwszVal);
	wcscat(strValue, wszNAMESEPARATORDEFAULT);
	wcscat(strValue, strValueOld);
    }
    else
    {
	strValue = SysAllocString(pwszVal);
	if (NULL == strValue)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocStringLen");
	}
    }
    CSASSERT(SysStringByteLen(strValue) == wcslen(strValue) * sizeof(WCHAR));
    varNew.vt = VT_BSTR;
    varNew.bstrVal = strValue;
    hr = pServer->SetCertificateProperty(strRDNName, PROPTYPE_STRING, &varNew);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = CERTSRV_E_BAD_REQUESTSUBJECT;
    }
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

error:
    if (NULL != pwszVal)
    {
	LocalFree(pwszVal);
    }
    if (NULL != strRDNName)
    {
        SysFreeString(strRDNName);
    }
    if (NULL != strValueOld)
    {
	SysFreeString(strValueOld);
    }
    if (NULL != strValue)
    {
	SysFreeString(strValue);
    }
    return(hr);
}


DWORD
s_myDsGetRdnW(
    IN OUT WCHAR const **ppwcDN,
    IN OUT DWORD *pcwcDN,
    OUT WCHAR const **ppwcKey,
    OUT DWORD *pcwcKey,
    OUT WCHAR const **ppwcVal,
    OUT DWORD *pcwcVal)
{
    HRESULT hr;
    WCHAR const *pwc = *ppwcDN;
    DWORD cwc = *pcwcDN;

    if (0 < cwc && L',' == *pwc)
    {
	pwc++;
	cwc--;
    }
    hr = ERROR_DS_NAME_UNPARSEABLE;

    *ppwcKey = pwc;
    while (TRUE)
    {
	if (0 == cwc)
	{
	    _JumpError(hr, error, "no key");
	}
	if (L'=' == *pwc)
	{
	    break;
	}
	pwc++;
	cwc--;
    }
    *pcwcKey = SAFE_SUBTRACT_POINTERS(pwc, *ppwcKey);
    pwc++;
    cwc--;

    *ppwcVal = pwc;
    if (0 == cwc)
    {
	_JumpError(hr, error, "no value");
    }
    while (TRUE)
    {
	if (0 == cwc || L',' == *pwc)
	{
	    break;
	}
	pwc++;
	cwc--;
    }
    *pcwcVal = SAFE_SUBTRACT_POINTERS(pwc, *ppwcVal);
    *ppwcDN = pwc;
    *pcwcDN = cwc;
    hr = S_OK;

error:
    return(hr);
}


typedef DWORD (WINAPI FNDSGETRDNW)(
    IN OUT LPCWCH   *ppDN,
    IN OUT DWORD    *pcDN,
    OUT    LPCWCH   *ppKey,
    OUT    DWORD    *pcKey,
    OUT    LPCWCH   *ppVal,
    OUT    DWORD    *pcVal);


DWORD
myDsGetRdn(
    IN OUT WCHAR const **ppwcDN,
    IN OUT DWORD *pcwcDN,
    OUT WCHAR const **ppwcKey,
    OUT DWORD *pcwcKey,
    OUT WCHAR const **ppwcVal,
    OUT DWORD *pcwcVal)
{
    HRESULT hr;
    HMODULE hModule;
    static FNDSGETRDNW *s_pfn = NULL;

    if (NULL == s_pfn)
    {
	hModule = GetModuleHandle(TEXT("ntdsapi.dll"));
	if (NULL == hModule)
	{
            hr = GetLastError();
	    goto error;
	}

	// load system function
	s_pfn = (FNDSGETRDNW *) GetProcAddress(hModule, "DsGetRdnW");
	if (NULL == s_pfn)
	{
            hr = GetLastError();
	    _PrintError(hr, "ntdsapi.dll!DsGetRdnW");

	    s_pfn = s_myDsGetRdnW;
	}
    }
    hr = (*s_pfn)(ppwcDN, pcwcDN, ppwcKey, pcwcKey, ppwcVal, pcwcVal);
    _JumpIfError(hr, error, "Policy:DsGetRdnW");

error:
    return(hr);
}


HRESULT
CTemplatePolicy::_AddDSDistinguishedName(
    IN ICertServerPolicy *pServer,
    CRequestInstance *pRequest)
{
    HRESULT hr;
    WCHAR const *pwcDN;
    DWORD cwcDN;
    DWORD cRDN;

    cRDN = 0;
    pwcDN = pRequest->m_strUserDN;
    if (NULL != pwcDN)
    {
	WCHAR const *pwcKey;
	WCHAR const *pwcVal;
	DWORD cwcKey;
	DWORD cwcVal;

	cwcDN = wcslen(pwcDN);
	while (0 != cwcDN)
	{
	    hr = myDsGetRdn(&pwcDN, &cwcDN, &pwcKey, &cwcKey, &pwcVal, &cwcVal);
	    if (S_OK != hr)
	    {
		hr = myHError(hr);
		_JumpError(hr, error, "Policy:myDsGetRdn");
	    }
	    if (0 != cwcKey && 0 != cwcVal)
	    {
		hr = tpSetRequestRDN(
				pServer,
				pwcKey,
				cwcKey,
				pwcVal,
				cwcVal);
		_JumpIfError(hr, error, "Policy:tpSetRequestRDN");

		cRDN++;
	    }
	}
    }
    if (0 == cRDN)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "Policy:m_strUserDN");
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_AddAltSubjectName
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_AddAltSubjectName(
    IN ICertServerPolicy *pServer,
    IN OUT CRequestInstance *pRequest)
{
    HRESULT hr = S_OK;
    DWORD cbExtension;
    VARIANT varExtension;
    DWORD iNameEntry;
    WCHAR **ppwszCurName;
    CERT_OTHER_NAME objectGuidOtherName;
    CERT_OTHER_NAME upnOtherName;

    WCHAR **apwszMailNames = NULL;
    WCHAR **apwszMachineNames = NULL;
    BYTE *pbExtension= NULL;
    BSTR strobjectGuid = NULL;
    CERT_ALT_NAME_INFO AltName;

    AltName.cAltEntry = 0;
    AltName.rgAltEntry = NULL;
    objectGuidOtherName.Value.pbData = NULL;
    objectGuidOtherName.Value.cbData = 0;
    upnOtherName.Value.pbData = NULL;
    upnOtherName.Value.cbData = 0;

    VariantInit(&varExtension);

    // If this cert template doesn't set the alt-subject-name, then enable
    // whatever alt subject name that was in the request.

    if (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME & m_tp.dwSubjectNameFlags)
    {
	LONG ExtFlags;

        hr = polGetCertificateExtension(
				pServer,
				TEXT(szOID_SUBJECT_ALT_NAME2),
				PROPTYPE_BINARY,
				&varExtension);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = CERTSRV_E_SUBJECT_ALT_NAME_REQUIRED;
	}
	_JumpIfError(hr, error, "Policy:polGetCertificateExtension");

	hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	_JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

	if (EXTENSION_DISABLE_FLAG & ExtFlags)
	{
            ExtFlags &= ~EXTENSION_DISABLE_FLAG;
            hr = polSetCertificateExtension(
			            pServer,
				    TEXT(szOID_SUBJECT_ALT_NAME2),
			            PROPTYPE_BINARY,
			            ExtFlags,
			            &varExtension);
	    _JumpIfError(hr, error, "Policy:polSetCertificateExtension");
        }
        CSASSERT(S_OK == hr);
        goto error;
    }

    // We do alt name entries for
    //   UPN/SPN
    //   rfc822 (mail name)
    //   DNSname
    //   DS location

    if ((CT_FLAG_SUBJECT_ALT_REQUIRE_UPN | CT_FLAG_SUBJECT_ALT_REQUIRE_SPN) &
	m_tp.dwSubjectNameFlags)
    {
        // Add the UPN

        if (NULL == pRequest->m_pwszUPN)
        {
	    hr = CERTSRV_E_SUBJECT_UPN_REQUIRED;
	    _JumpError(hr, error, "Policy:_AddAltSubjectName:UPN");
        }
	AltName.cAltEntry++;
    }

    if (CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL & m_tp.dwSubjectNameFlags)
    {
        hr = pRequest->_GetValues(DS_ATTR_EMAIL_ADDR, &apwszMailNames);
	if (S_OK != hr || NULL == apwszMailNames || NULL == apwszMailNames[0])
        {
	    _PrintIfError(hr, "_GetValues(email)");
	    if (CERTTYPE_SCHEMA_VERSION_2 <= m_tp.dwSchemaVersion &&
		0 == (EDITF_EMAILOPTIONAL & m_pPolicy->GetEditFlags()))
	    {
		hr = CERTSRV_E_SUBJECT_EMAIL_REQUIRED;
		_JumpError(hr, error, "Policy:_AddAltSubjectName:EMail");
	    }
	    pRequest->BuildErrorInfo(
				hr,
				MSG_NO_EMAIL_NAME,
				&pRequest->m_strUserDN);
	}
	else
	{
	    ppwszCurName = apwszMailNames;
	    while (NULL != *ppwszCurName)
	    {
		AltName.cAltEntry++;
		ppwszCurName++;
	    }
	}
    }

    if (CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID & m_tp.dwSubjectNameFlags)
    {
        hr = pRequest->_GetObjectGUID(&strobjectGuid);
	if (S_OK != hr || NULL == strobjectGuid)
        {
	    _PrintIfError(hr, "_GetObjectGUID");
	    hr = CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED;
	    _JumpError(hr, error, "Policy:_AddAltSubjectName:GUID");
	}
	AltName.cAltEntry++;
    }
    if (CT_FLAG_SUBJECT_ALT_REQUIRE_DNS & m_tp.dwSubjectNameFlags)
    {
        hr = pRequest->_GetValues(DS_ATTR_DNS_NAME, &apwszMachineNames);
	if (S_OK != hr || NULL == apwszMachineNames || NULL == apwszMachineNames[0])
        {
	    _PrintIfError(hr, "_GetValues(dns)");
	    hr = CERTSRV_E_SUBJECT_DNS_REQUIRED;
	    _JumpError(hr, error, "Policy:_AddAltSubjectName:DNS");
	}

	ppwszCurName = apwszMachineNames;
	while (NULL != *ppwszCurName)
	{
	    AltName.cAltEntry++;
	    ppwszCurName++;
        }
    }

    if (AltName.cAltEntry == 0)
    {
        hr = S_OK;
        goto error;
    }

    AltName.rgAltEntry = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
			    LMEM_FIXED,
                            sizeof(CERT_ALT_NAME_ENTRY) * AltName.cAltEntry);
    if (NULL == AltName.rgAltEntry)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:LocalAlloc");
    }
    iNameEntry = 0;

    if ((CT_FLAG_SUBJECT_ALT_REQUIRE_UPN | CT_FLAG_SUBJECT_ALT_REQUIRE_SPN) &
	m_tp.dwSubjectNameFlags)
    {
        // Add the UPN

	CERT_NAME_VALUE nameUpn;

	nameUpn.dwValueType = CERT_RDN_UTF8_STRING;
	nameUpn.Value.pbData = (BYTE *) pRequest->m_pwszUPN;
	nameUpn.Value.cbData = wcslen(pRequest->m_pwszUPN) * sizeof(WCHAR);

	if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    &nameUpn,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &upnOtherName.Value.pbData,
		    &upnOtherName.Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "Policy:myEncodeObject");
	}

	upnOtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
	AltName.rgAltEntry[iNameEntry].dwAltNameChoice= CERT_ALT_NAME_OTHER_NAME;
	AltName.rgAltEntry[iNameEntry++].pOtherName = &upnOtherName;
    }

    // Now do strobjectGuid

    if (CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID & m_tp.dwSubjectNameFlags)
    {
        CRYPT_DATA_BLOB blobGuid;

	CSASSERT(NULL != strobjectGuid);
        blobGuid.pbData = (BYTE *) strobjectGuid;
        blobGuid.cbData = SysStringByteLen(strobjectGuid);

        objectGuidOtherName.pszObjId = szOID_NTDS_REPLICATION;

        if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			&blobGuid,
			0,
			CERTLIB_USE_LOCALALLOC,
			&objectGuidOtherName.Value.pbData,
			&objectGuidOtherName.Value.cbData))
        {
            hr = myHLastError();
	    _JumpError(hr, error, "Policy:myEncodeObject");
        }
        AltName.rgAltEntry[iNameEntry].dwAltNameChoice= CERT_ALT_NAME_OTHER_NAME;
        AltName.rgAltEntry[iNameEntry++].pOtherName = &objectGuidOtherName;
    }

    // Now do rfc822

    if (CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL & m_tp.dwSubjectNameFlags)
    {
	ppwszCurName = apwszMailNames;
	if (NULL != ppwszCurName)
	{
	    while (NULL != *ppwszCurName)
	    {
		AltName.rgAltEntry[iNameEntry].dwAltNameChoice= CERT_ALT_NAME_RFC822_NAME;
		AltName.rgAltEntry[iNameEntry++].pwszRfc822Name = *ppwszCurName;
		ppwszCurName++;
	    }
	}
    }

    // Now do DNS

    if (CT_FLAG_SUBJECT_ALT_REQUIRE_DNS & m_tp.dwSubjectNameFlags)
    {
	ppwszCurName = apwszMachineNames;
	if (NULL != ppwszCurName)
	{
	    while (NULL != *ppwszCurName)
	    {
		AltName.rgAltEntry[iNameEntry].dwAltNameChoice= CERT_ALT_NAME_DNS_NAME;
		AltName.rgAltEntry[iNameEntry++].pwszRfc822Name = *ppwszCurName;
		ppwszCurName++;
	    }
	}
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &AltName,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbExtension,
		    &cbExtension))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:myEncodeObject");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = SysAllocStringByteLen(
					(char const *) pbExtension,
					cbExtension);
    if (NULL == varExtension.bstrVal)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocStringByteLen");
    }
    hr = polSetCertificateExtension(
			    pServer,
			    TEXT(szOID_SUBJECT_ALT_NAME2),
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:polSetCertificateExtension");

error:
    if (NULL != pbExtension)
    {
        LocalFree(pbExtension);
    }
    if (NULL != strobjectGuid)
    {
        SysFreeString(strobjectGuid);
    }
    if (NULL != AltName.rgAltEntry)
    {
        // clean each entry in array
        for (DWORD i = 0; i < AltName.cAltEntry; i++)
        {
            switch (AltName.rgAltEntry[i].dwAltNameChoice)
            {
                case CERT_ALT_NAME_DIRECTORY_NAME:
                {
                    if (NULL != AltName.rgAltEntry[i].DirectoryName.pbData)
                    {
                        LocalFree(AltName.rgAltEntry[i].DirectoryName.pbData);
                        AltName.rgAltEntry[i].DirectoryName.pbData = NULL;
                    }
                    break;
                }
                case CERT_ALT_NAME_OTHER_NAME:
                    // points to objectGuidOtherName or bstrUpn, which are
		    // freed separately
		    break;

                case CERT_ALT_NAME_RFC822_NAME:
                    // points to apwszMailNames, freed later
                    break;

                case CERT_ALT_NAME_DNS_NAME:
                    // points to apwszMachineNames, freed later
                    break;
            }
        }

        // free array
        LocalFree(AltName.rgAltEntry);
    }
    if (NULL != objectGuidOtherName.Value.pbData)
    {
        LocalFree(objectGuidOtherName.Value.pbData);
    }
    if (NULL != upnOtherName.Value.pbData)
    {
        LocalFree(upnOtherName.Value.pbData);
    }
    if (NULL != pRequest)
    {
        if (NULL != apwszMailNames)
        {
            pRequest->_FreeValues(apwszMailNames);
        }
        if (NULL != apwszMachineNames)
        {
            pRequest->_FreeValues(apwszMachineNames);
        }
    }
    VariantClear(&varExtension);
    return(hr);
}


#ifdef DBG_CERTSRV_DEBUG_PRINT
# define DBGPRINTTIMEORPERIOD(pszDesc, pft) \
    policyDbgPrintTimeOrPeriod((pszDesc), (pft))

VOID
policyDbgPrintTimeOrPeriod(
    IN char const *pszDesc,
    IN FILETIME const *pft)
{
    HRESULT hr;
    WCHAR *pwszTime = NULL;
    WCHAR awc[1];

    if (0 <= (LONG) pft->dwHighDateTime)
    {
	hr = myGMTFileTimeToWszLocalTime(pft, TRUE, &pwszTime);
	_PrintIfError(hr, "myGMTFileTimeToWszLocalTime");
    }
    else
    {
	hr = myFileTimePeriodToWszTimePeriod(pft, TRUE, &pwszTime);
	_PrintIfError(hr, "myFileTimePeriodToWszTimePeriod");
    }
    if (S_OK != hr)
    {
	awc[0] = L'\0';
	pwszTime = awc;
    }
    DBGPRINT((DBG_SS_CERTPOL, "%hs: %ws\n", pszDesc, pwszTime));

//error:
    if (NULL != pwszTime && awc != pwszTime)
    {
	LocalFree(pwszTime);
    }
}
#else // DBG_CERTSRV_DEBUG_PRINT
# define DBGPRINTTIMEORPERIOD(pszDesc, pft)
#endif // DBG_CERTSRV_DEBUG_PRINT


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_ApplyExpirationTime
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_ApplyExpirationTime(
    IN ICertServerPolicy *pServer,
    IN OUT CRequestInstance *pRequest)
{
    HRESULT hr = S_OK;
    VARIANT varValue;
    BSTR strNameNotBefore = NULL;
    BSTR strNameNotAfter = NULL;
    SYSTEMTIME SystemTime;
    LLFILETIME llftNotAfter;
    LLFILETIME llftNotAfterCalc;
    LLFILETIME llftNotBefore;
    LLFILETIME llftNotAfterOverlap;
    WCHAR const *pwszTemplate;

    VariantInit(&varValue);

    pwszTemplate = m_pwszTemplateName;
    if (NULL == pwszTemplate)
    {
	pwszTemplate = m_pwszTemplateObjId;
    }

    strNameNotBefore = SysAllocString(wszPROPCERTIFICATENOTBEFOREDATE);
    if (NULL == strNameNotBefore)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strNameNotBefore,
				PROPTYPE_DATE,
				&varValue);
    _JumpIfError(hr, error, "Policy:GetCertificateProperty");

    if (VT_DATE != varValue.vt)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Policy:varValue.vt");
    }

    if (!VariantTimeToSystemTime(varValue.date, &SystemTime))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:VariantTimeToSystemTime");
    }

    if (!SystemTimeToFileTime(&SystemTime, &llftNotBefore.ft))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:SystemTimeToFileTime");
    }

    strNameNotAfter = SysAllocString(wszPROPCERTIFICATENOTAFTERDATE);
    if (NULL == strNameNotAfter)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:SysAllocString");
    }
    VariantClear(&varValue);
    hr = pServer->GetCertificateProperty(
				strNameNotAfter,
				PROPTYPE_DATE,
				&varValue);
    _JumpIfError(hr, error, "Policy:GetCertificateProperty");

    if (VT_DATE != varValue.vt)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Policy:varValue.vt");
    }

    if (!VariantTimeToSystemTime(varValue.date, &SystemTime))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:VariantTimeToSystemTime");
    }

    if (!SystemTimeToFileTime(&SystemTime, &llftNotAfter.ft))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:SystemTimeToFileTime");
    }
    if (0 > m_tp.llftExpirationPeriod.ll)
    {
        llftNotAfterCalc.ll = llftNotBefore.ll - m_tp.llftExpirationPeriod.ll;
    }
    else
    {
        llftNotAfterCalc.ll = m_tp.llftExpirationPeriod.ll;
    }

    if (llftNotAfterCalc.ll > llftNotAfter.ll)
    {
	// truncated!

        llftNotAfterCalc.ll = llftNotAfter.ll;

	pRequest->BuildErrorInfo(
			    S_OK,
			    MSG_TEMPLATE_VALIDITY_TOO_LONG,
			    &pwszTemplate);
    }

    if (!FileTimeToSystemTime(&llftNotAfterCalc.ft, &SystemTime))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:FileTimeToSystemTime");
    }
    if (!SystemTimeToVariantTime(&SystemTime, &varValue.date))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:SystemTimeToVariantTime");
    }

    hr = pServer->SetCertificateProperty(
				strNameNotAfter,
				PROPTYPE_DATE,
				&varValue);
    if (S_OK != hr)
    {
	DBGPRINTTIMEORPERIOD("  Old NotBefore", &llftNotBefore.ft);
	DBGPRINTTIMEORPERIOD("   Old NotAfter", &llftNotAfter.ft);
	DBGPRINTTIMEORPERIOD("Template Period", &m_tp.llftExpirationPeriod.ft);
	DBGPRINTTIMEORPERIOD("   New NotAfter", &llftNotAfterCalc.ft);
    }
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

    // Verify new cert will be valid for at least as long as the overlap period

    if (0 > m_tp.llftOverlapPeriod.ll)
    {
        llftNotAfterOverlap.ll = llftNotBefore.ll - m_tp.llftOverlapPeriod.ll;
    }
    else
    {
        llftNotAfterOverlap.ll = m_tp.llftOverlapPeriod.ll;
    }

    if (llftNotAfterOverlap.ll > llftNotAfter.ll)
    {
	LONG RequestFlags;

	hr = polGetRequestLongProperty(
				pServer,
				wszPROPREQUESTFLAGS,
				&RequestFlags);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "Policy:polGetRequestLongProperty",
		    wszPROPREQUESTFLAGS);

	if (CR_FLG_RENEWAL & RequestFlags)
	{
	    // too little life left, log and fail!

	    pRequest->BuildErrorInfo(
			    S_OK,
			    MSG_TEMPLATE_OVERLAP_TOO_LONG,
			    &pwszTemplate);
	    hr =  CERTSRV_E_CERT_TYPE_OVERLAP;
	    _JumpError(hr, error, "Overlap too long");
	}
    }
    CSASSERT(S_OK == hr);

error:
    VariantClear(&varValue);
    if (NULL != strNameNotBefore)
    {
	SysFreeString(strNameNotBefore);
    }
    if (NULL != strNameNotAfter)
    {
	SysFreeString(strNameNotAfter);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_EnforceKeySizePolicy
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_EnforceKeySizePolicy(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;

    if (0 != m_tp.dwMinKeyLength)
    {
	LONG KeyLength;

	hr = polGetCertificateLongProperty(
				pServer,
				wszPROPCERTIFICATEPUBLICKEYLENGTH,
				&KeyLength);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCERTIFICATEPUBLICKEYLENGTH);

	if (m_tp.dwMinKeyLength > (DWORD) KeyLength)
	{
	    DBGPRINT((
		DBG_SS_ERROR,
		"Key Length %u, expected minimum %u\n",
		KeyLength,
		m_tp.dwMinKeyLength));

	    hr = CERTSRV_E_KEY_LENGTH;
	    _JumpError(hr, error, "Key too small");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_EnforceKeyArchivalPolicy
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_EnforceKeyArchivalPolicy(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    LONG fKeyArchived;

    hr = polGetCertificateLongProperty(
			    pServer,
			    wszPROPKEYARCHIVED,
			    &fKeyArchived);

    _JumpIfErrorStr(
		hr,
		error,
		"Policy:polGetCertificateLongProperty",
		wszPROPKEYARCHIVED);

    if (CT_FLAG_REQUIRE_PRIVATE_KEY_ARCHIVAL & m_tp.dwPrivateKeyFlags)
    {
	if (!fKeyArchived)
	{
	    hr = CERTSRV_E_ARCHIVED_KEY_REQUIRED;
	    _JumpError(hr, error, "missing archived key");
	}
    }
    else
    {
	if (fKeyArchived)
	{
	    hr = CERTSRV_E_ARCHIVED_KEY_UNEXPECTED;
	    _JumpError(hr, error, "unexpected archived key");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_EnforceSymmetricAlgorithms
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_EnforceSymmetricAlgorithms(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    VARIANT varExtension;
    BOOL fSetNeeded = FALSE;
    LONG ExtFlags = 0;
    BSTR strCSPProvider = NULL;

    VariantInit(&varExtension);
    if (CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS & m_tp.dwEnrollmentFlags)
    {
        hr = polGetCertificateExtension(
				pServer,
				TEXT(szOID_RSA_SMIMECapabilities),
				PROPTYPE_BINARY,
				&varExtension);
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    _JumpIfError(hr, error, "Policy:GetCertificateExtension");

	    hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	    _JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

	    if (EXTENSION_DISABLE_FLAG & ExtFlags)
	    {
		ExtFlags &= ~EXTENSION_DISABLE_FLAG;
		fSetNeeded = TRUE;
	    }
	}
	else
	{
	    BYTE const *pbSMIME;
	    DWORD cbSMIME;
	    
	    pbSMIME = m_pPolicy->GetSMIME(&cbSMIME);
	    if (0 == (EDITF_ENABLEDEFAULTSMIME & m_pPolicy->GetEditFlags()) ||
		NULL == pbSMIME)
	    {
		hr = CERTSRV_E_SMIME_REQUIRED;
		_JumpError(hr, error, "Policy:GetCertificateExtension");
	    }

	    varExtension.bstrVal = NULL;
	    if (!myConvertWszToBstr(
				&varExtension.bstrVal,
				(WCHAR const *) pbSMIME,
				cbSMIME))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:myConvertWszToBstr");
	    }
	    varExtension.vt = VT_BSTR;
	    fSetNeeded = TRUE;
	}
    }
    if (fSetNeeded)
    {
	hr = polSetCertificateExtension(
				pServer,
				TEXT(szOID_RSA_SMIMECapabilities),
				PROPTYPE_BINARY,
				ExtFlags,
				&varExtension);
	_JumpIfError(hr, error, "Policy:SetCertificateExtension");
    }
    hr = S_OK;

error:
    if (NULL != strCSPProvider)
    {
	SysFreeString(strCSPProvider);
    }
    VariantClear(&varExtension);
    return(hr);
}


#ifdef CERTSRV_EOBO_DCR_APPROVED
// Fail the request if:
// the request is for a V2 template
// AND
//     RequesterName is not the same as the CallerName (enroll-on-behalf-of)
//     AND
//     CT_FLAG_ALLOW_ENROLL_ON_BEHALF_OF is not set in the template flags
//   OR
//     RequesterName *is* the same as the CallerName (not enroll-on-behalf-of)
//     AND
//     CT_FLAG_ALLOW_ENROLL_ON_BEHALF_OF *is* set in the template flags
#else
// Fail the request if all of the following are true:
// 1: the request is for a V2 template
// 2: no signatures are required by the template
// 3: the RequesterName is not the same as the CallerName (enroll-on-behalf-of)
#endif

HRESULT
CTemplatePolicy::_EnforceEnrollOnBehalfOfAllowed(
    IN ICertServerPolicy *pServer,
    OUT BOOL *pfEnrollOnBehalfOf)
{
    HRESULT hr;
    BSTR strRequester = NULL;
    BSTR strCaller = NULL;

    *pfEnrollOnBehalfOf = FALSE;

    hr = polGetRequestStringProperty(
			    pServer,
			    wszPROPREQUESTERNAME,
			    &strRequester);
    _JumpIfErrorStr(
		hr,
		error,
		"Policy:polGetRequestStringProperty",
		wszPROPREQUESTERNAME);

    hr = polGetRequestStringProperty(
			    pServer,
			    wszPROPCALLERNAME,
			    &strCaller);
    _JumpIfErrorStr(
		hr,
		error,
		"Policy:polGetRequestStringProperty",
		wszPROPCALLERNAME);

    *pfEnrollOnBehalfOf = 0 != mylstrcmpiL(strRequester, strCaller);

    if (CERTTYPE_SCHEMA_VERSION_2 <= m_tp.dwSchemaVersion
#ifdef CERTSRV_EOBO_DCR_APPROVED
#else
	&& 0 == m_tp.dwcSignatureRequired
#endif
	)
    {
#ifdef CERTSRV_EOBO_DCR_APPROVED
	if (!*pfEnrollOnBehalfOf ^
	    (0 != (CT_FLAG_ALLOW_ENROLL_ON_BEHALF_OF & m_tp.dwEnrollmentFlags)))
#else
	if (*pfEnrollOnBehalfOf)
#endif
	{
	    hr = CERTSRV_E_BAD_RENEWAL_SUBJECT;
	    _JumpError(hr, error, "EnrollOnBehalfOf allowed/disallowed");
	}
    }
    hr = S_OK;		// caller matches requester

error:
    if (NULL != strRequester)
    {
	SysFreeString(strRequester);
    }
    if (NULL != strCaller)
    {
	SysFreeString(strCaller);
    }
    return(hr);
}


HRESULT
CTemplatePolicy::_EnforceMinimumTemplateVersion(
    IN CRequestInstance *pRequest)
{
    HRESULT hr;
    DWORD dwRequestTemplateMinimumMajorVersion;
    DWORD dwRequestTemplateMinimumMinorVersion;

    pRequest->GetTemplateVersion(
			&dwRequestTemplateMinimumMajorVersion,
			&dwRequestTemplateMinimumMinorVersion);

    if (m_tp.dwTemplateMajorVersion < dwRequestTemplateMinimumMajorVersion ||
	(m_tp.dwTemplateMajorVersion == dwRequestTemplateMinimumMajorVersion &&
	 m_tp.dwTemplateMinorVersion < dwRequestTemplateMinimumMinorVersion))
    {
	DBGPRINT((
	    DBG_SS_ERROR,
	    "Requested template version %u.%u, Loaded version %u.%u\n",
	    dwRequestTemplateMinimumMajorVersion,
	    dwRequestTemplateMinimumMinorVersion,
	    m_tp.dwTemplateMajorVersion,
	    m_tp.dwTemplateMinorVersion));
	hr = CERTSRV_E_BAD_TEMPLATE_VERSION;
	_JumpError(hr, error, "Policy:_EnforceMinimumTemplateVersion");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
tpSplitPolicies(
    IN BSTR strPolicies,
    OUT DWORD *pcPolicies,
    OUT OBJECTIDLIST **pprgPolicies)
{
    HRESULT hr;
    WCHAR const *pwszT;
    WCHAR *pwszOut;
    DWORD cPolicies;
    OBJECTIDLIST *prgPolicies;
    DWORD cObjId;
    WCHAR **rgpwszObjId;
    BOOL fNew;

    *pprgPolicies = NULL;

    pwszT = strPolicies;
    cPolicies = 1;		// plus one per newline separator
    cObjId = 0;
    while (L'\0' != *pwszT)
    {
	int ichar = wcscspn(pwszT, L",\n");
        if (ichar == 0)    // neither of these, look for end-of-string
            ichar = wcslen(pwszT);
        pwszT += ichar;

	switch (*pwszT)
	{
	    case L'\n':
		cPolicies++;	// plus one per newline separator
                pwszT++;        // step over the newline
		break;

	    case L',':
		cObjId++;	// plus one per comma separator
		pwszT++;        // step over the comma
		break;

	    case L'\0':
	    default:
		CSASSERT(L'\0' == *pwszT);
		break;
	}
    }
    cObjId += cPolicies;	// plus one per signature

    prgPolicies = (OBJECTIDLIST *) LocalAlloc(
				    LMEM_FIXED,
				    cPolicies * sizeof(prgPolicies[0]) +
				    cObjId * sizeof(WCHAR *) +
				    (wcslen(strPolicies) + 1) * sizeof(WCHAR));
    if (NULL == prgPolicies)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    *pprgPolicies = prgPolicies;
    *pcPolicies = cPolicies;

    rgpwszObjId = (WCHAR **) &prgPolicies[cPolicies];
    pwszOut = (WCHAR *) &rgpwszObjId[cObjId];
    wcscpy(pwszOut, strPolicies);

    fNew = TRUE;
    while (L'\0' != *pwszOut)
    {
	if (fNew)
	{
	    prgPolicies->cObjId = 0;
	    prgPolicies->rgpwszObjId = rgpwszObjId;
	}
	prgPolicies->cObjId++;
	*rgpwszObjId = pwszOut;
        rgpwszObjId++; // next array entry

	fNew = FALSE;

	int ichar = wcscspn(pwszOut , L",\n");
        if (ichar == 0)    // neither of these, look for end-of-string
            ichar = wcslen(pwszOut);
        pwszOut  += ichar;

	switch (*pwszOut)
	{
	    case L'\n':
		prgPolicies++;
		fNew = TRUE;
		// FALLTHROUGH

	    case L',':
		*pwszOut++ = L'\0';
		break;

	    case L'\0':
	    default:
		CSASSERT(L'\0' == *pwszOut);
		break;
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CTemplatePolicy::_LoadSignaturePolicies(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropNameRequest,
    OUT DWORD *pcSignaturePolicies,
    OUT OBJECTIDLIST **pprgSignaturePolicies) // from the signing cert(s)
{
    HRESULT hr;
    BSTR strSignaturePolicies = NULL;

    *pcSignaturePolicies = 0;
    *pprgSignaturePolicies = NULL;

    hr = polGetRequestStringProperty(
			    pServer,
			    pwszPropNameRequest,
			    &strSignaturePolicies);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = CERTSRV_E_SIGNATURE_POLICY_REQUIRED;
    }
    _JumpIfErrorStr(
		hr,
		error,
		"Policy:polGetRequestStringProperty",
		pwszPropNameRequest);

    hr = tpSplitPolicies(
		    strSignaturePolicies,
		    pcSignaturePolicies,
		    pprgSignaturePolicies);
    _JumpIfError(hr, error, "Policy:tpSplitPolicies");

error:
    if (NULL != strSignaturePolicies)
    {
	SysFreeString(strSignaturePolicies);
    }
    return(hr);
}


HRESULT
CTemplatePolicy::_EnforceReenrollment(
    IN ICertServerPolicy *pServer,
    IN CRequestInstance *pRequest)
{
    HRESULT hr;
    VARIANT var;
    CERT_CONTEXT const *pOldCert = NULL;
    CERT_EXTENSION const *pExt;
    CERT_TEMPLATE_EXT *pTemplateExt = NULL;
    WCHAR *pwszObjId = NULL;
    CERT_ALT_NAME_INFO *pAltName = NULL;
    CERT_NAME_VALUE *pName = NULL;
    DWORD cb;
    DWORD i;

    VariantInit(&var);

    if (NULL == m_pwszTemplateObjId)
    {
	hr = CERTSRV_E_UNSUPPORTED_CERT_TYPE;
	_JumpError(hr, error, "Policy:No template ObjId");
    }
    hr = polGetProperty(
		pServer,
		TRUE,		// fRequest
		wszPROPREQUESTRAWOLDCERTIFICATE,
		PROPTYPE_BINARY,
		&var);
    _JumpIfError(hr, error, "Policy:polGetProperty");

    if (VT_BSTR != var.vt || NULL == var.bstrVal)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "Policy:polGetProperty");
    }
    var.bstrVal;

    pOldCert = CertCreateCertificateContext(
				X509_ASN_ENCODING,
				(BYTE *) var.bstrVal,
				SysStringByteLen(var.bstrVal));
    if (NULL == pOldCert)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    pExt = CertFindExtension(
			szOID_CERTIFICATE_TEMPLATE,
			pOldCert->pCertInfo->cExtension,
			pOldCert->pCertInfo->rgExtension);
    if (NULL == pExt)
    {
	hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	_JumpError(hr, error, "CertFindExtension(Template)");
    }

    if (!myDecodeObject(
		X509_ASN_ENCODING,
		X509_CERTIFICATE_TEMPLATE,
		pExt->Value.pbData,
		pExt->Value.cbData,
		CERTLIB_USE_LOCALALLOC,
		(VOID **) &pTemplateExt,
		&cb))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:myDecodeObject");
    }
    if (!myConvertSzToWsz(&pwszObjId, pTemplateExt->pszObjId, MAXDWORD))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myConvertSzToWsz");
    }
    if (0 != lstrcmp(pwszObjId, m_pwszTemplateObjId))
    {
	hr = CERTSRV_E_UNSUPPORTED_CERT_TYPE;
	_JumpError(hr, error, "Policy:different cert type");
    }

    if (NULL == pRequest->m_pwszUPN)
    {
	hr = E_POINTER;		// We should never get this
	_JumpError(hr, error, "Policy:NULL UPN");
    }
    pExt = CertFindExtension(
			szOID_SUBJECT_ALT_NAME2,
			pOldCert->pCertInfo->cExtension,
			pOldCert->pCertInfo->rgExtension);
    if (NULL == pExt)
    {
	hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	_JumpError(hr, error, "CertFindExtension(SubjectAltName)");
    }

    if (!myDecodeObject(
		X509_ASN_ENCODING,
		X509_ALTERNATE_NAME,
		pExt->Value.pbData,
		pExt->Value.cbData,
		CERTLIB_USE_LOCALALLOC,
		(VOID **) &pAltName,
		&cb))
    {
        hr = myHLastError();
	_JumpError(hr, error, "Policy:myDecodeObject");
    }
    for (i = 0; i < pAltName->cAltEntry; i++)
    {
	CERT_ALT_NAME_ENTRY *pAltEntry = &pAltName->rgAltEntry[i];

	if (CERT_ALT_NAME_OTHER_NAME != pAltEntry->dwAltNameChoice)
	{
	    continue;
	}
	if (0 != strcmp(
		    pAltEntry->pOtherName->pszObjId,
		    szOID_NT_PRINCIPAL_NAME))
	{
	    continue;
	}
	if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    pAltEntry->pOtherName->Value.pbData,
		    pAltEntry->pOtherName->Value.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pName,
		    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "Policy:myDecodeObject");
	}
	if (CERT_RDN_UTF8_STRING != pName->dwValueType ||
	    0 != mylstrcmpiL(
		    pRequest->m_pwszUPN,
		    (WCHAR const *) pName->Value.pbData))
	{
	    hr = CERTSRV_E_BAD_REQUESTSUBJECT;
	    _JumpError(hr, error, "UPN doesn't match renewal UPN");
	}
    }
    if (NULL == pName)
    {
	hr = CERTSRV_E_BAD_REQUESTSUBJECT;
	_JumpError(hr, error, "missing renewal UPN");
    }
    hr = S_OK;

error:
    if (NULL != pName)
    {
	LocalFree(pName);
    }
    if (NULL != pAltName)
    {
	LocalFree(pAltName);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    if (NULL != pTemplateExt)
    {
	LocalFree(pTemplateExt);
    }
    if (NULL != pOldCert)
    {
	CertFreeCertificateContext(pOldCert);
    }
    VariantClear(&var);
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyEnterprise::_EnforceSignaturePolicy
//
// Fetch required lists of Issuance and Application ObjIds from the template.
// Fetch signing certificates' lists of Issuance and Application ObjIds from
// the cert server.
//
// Reject signatures that don't include all of the required Application ObjIds.
// Reject signatures that don't include at least one of the required Issuance
// ObjIds.
//
// The count of accepted signatures must be equal to or greater than the
// template-specified required signature count.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CTemplatePolicy::_EnforceSignaturePolicy(
    IN ICertServerPolicy *pServer,
    IN CRequestInstance *pRequest,
    IN BOOL fEnrollOnBehalfOf)
{
    HRESULT hr;
    DWORD cSignatureAccepted;
    DWORD cSignatureRejected;
    DWORD *prgdwRefCount = NULL;
    DWORD i;
    WCHAR const *awszStrings[3];
    WCHAR wszCountAccepted[50];
    WCHAR wszCountRequired[50];
    WCHAR *pwszMissing = NULL;
    OBJECTIDLIST *pPoliciesApplication;

    DWORD cSignatureIssuance;
    OBJECTIDLIST *prgSignatureIssuance = NULL;

    DWORD cSignatureApplication;
    OBJECTIDLIST *prgSignatureApplication = NULL;

    static WCHAR *s_pwszObjIdEA = TEXT(szOID_ENROLLMENT_AGENT);
    static OBJECTIDLIST s_PoliciesApplicationEA = { 1, &s_pwszObjIdEA };

    pPoliciesApplication = &m_PoliciesApplication;
    if (0 == m_tp.dwcSignatureRequired)
    {
	if (!fEnrollOnBehalfOf ||
	    CERTTYPE_SCHEMA_VERSION_2 <= m_tp.dwSchemaVersion)
	{
	    hr = S_OK;
	    goto error;
	}

	// V1 template with fEnrollOnBehalfOf request.
	// Enforce szOID_ENROLLMENT_AGENT

	pPoliciesApplication = &s_PoliciesApplicationEA;
    }
    hr = _LoadSignaturePolicies(
		pServer,
		wszPROPSIGNERPOLICIES,
		&cSignatureIssuance,	// from the signing cert(s)
		&prgSignatureIssuance);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:_LoadSignaturePolicies",
		CERTTYPE_PROP_RA_POLICY);

    hr = _LoadSignaturePolicies(
		pServer,
		wszPROPSIGNERAPPLICATIONPOLICIES,
		&cSignatureApplication,	// from the signing cert(s)
		&prgSignatureApplication);
    _JumpIfErrorStr(
		hr,
		error,
		"CTemplatePolicy:_LoadSignaturePolicies",
		CERTTYPE_PROP_RA_APPLICATION_POLICY);

    if (0 == m_PoliciesIssuance.cObjId && 0 == pPoliciesApplication->cObjId)
    {
	hr = CERTSRV_E_TEMPLATE_POLICY_REQUIRED;
	_JumpIfError(hr, error, "no template policies");
    }

    if (cSignatureIssuance != cSignatureApplication)
    {
	hr = NTE_BAD_SIGNATURE;		// must be an internal server problem
	_JumpError(hr, error, "Policy:bad request policies counts");
    }
    if (0 != m_PoliciesIssuance.cObjId)
    {
	prgdwRefCount = (DWORD *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    m_PoliciesIssuance.cObjId * sizeof(DWORD));
	if (NULL == prgdwRefCount)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:LocalAlloc");
	}
    }

    // Loop through each signature's Application and Issuance Policy OIDs

    cSignatureAccepted = 0;
    cSignatureRejected = 0;
    for (i = 0; i < cSignatureIssuance; i++)
    {
	BOOL fReject = FALSE;
	WCHAR **rgpwszObjId;
	DWORD cObjId;
	DWORD j;
	DWORD idx;

	// This signature must include ALL required Application Policy OIDs
	// If no Application Policy OIDs are required, all signatures are OK.

	rgpwszObjId = prgSignatureApplication[i].rgpwszObjId;
	cObjId = prgSignatureApplication[i].cObjId;
	for (j = 0; j < pPoliciesApplication->cObjId; j++)
	{
	    idx = polFindObjIdInList(
				pPoliciesApplication->rgpwszObjId[j],
				cObjId,
				rgpwszObjId);
	    if (MAXDWORD == idx)
	    {
		fReject = TRUE;
		_PrintErrorStr(
			S_OK,
			"Policy:missing Application Policy",
			pPoliciesApplication->rgpwszObjId[j]);
	    }
	}
	if (!fReject)
	{
	    DWORD cFound = 0;

	    // For each Issuance Policy OID in this signature that also exists
	    // in the required Issuance Policy OIDs, increment the ref count to
	    // show the OID was referenced by an accepted signature.
	    // Reject the signature if it doesn't reference any required OID.

	    rgpwszObjId = prgSignatureIssuance[i].rgpwszObjId;
	    cObjId = prgSignatureIssuance[i].cObjId;
	    for (j = 0; j < cObjId; j++)
	    {
		// "*" means the signing cert is good for *all* policies.

		if (0 == wcscmp(L"*", rgpwszObjId[j]))
		{
		    for (idx = 0; idx < m_PoliciesIssuance.cObjId; idx++)
		    {
			prgdwRefCount[idx]++;
			cFound++;
		    }
		}
		else
		{
		    idx = polFindObjIdInList(
					rgpwszObjId[j],
					m_PoliciesIssuance.cObjId,
					m_PoliciesIssuance.rgpwszObjId);
		    if (MAXDWORD != idx)
		    {
			prgdwRefCount[idx]++;
			cFound++;
		    }
		}
	    }

	    // If no Issuance Policy OIDs are required, all signatures are OK.

	    if (0 != m_PoliciesIssuance.cObjId && 0 == cFound)
	    {
		fReject = TRUE;
	    }
	}
	if (fReject)
	{
	    cSignatureRejected++;
	}
	else
	{
	    cSignatureAccepted++;
	}
	DBGPRINT((
	    DBG_SS_CERTPOL,
	    "Sig[%u]: %ws\n",
	    i,
	    fReject? L"Rejected" : L"Accepted"));
    }

    awszStrings[0] = m_pwszTemplateName;
    if (NULL == awszStrings[0])
    {
	awszStrings[0] = m_pwszTemplateObjId;
    }

    hr = S_OK;
    if (cSignatureAccepted < m_tp.dwcSignatureRequired)
    {
	hr = CERTSRV_E_SIGNATURE_COUNT;
	if (0 != cSignatureRejected)
	{
	    hr = CERTSRV_E_SIGNATURE_REJECTED;
	}
	_PrintError(hr, "Policy:not enough signatures");

	// The %1 Certificate Template requires %2 signatures,
	// but only %3 were accepted.

	wsprintf(wszCountRequired, L"%u", m_tp.dwcSignatureRequired);
	awszStrings[1] = wszCountRequired;

	wsprintf(wszCountAccepted, L"%u", cSignatureAccepted);
	awszStrings[2] = wszCountAccepted;

	pRequest->BuildErrorInfo(hr, MSG_SIGNATURE_COUNT, awszStrings);
    }
    DBGPRINT((
	S_OK != hr? DBG_SS_CERTPOLI : DBG_SS_CERTPOL,
	"Signatures: %u needed, %u accepted\n",
	m_tp.dwcSignatureRequired,
	cSignatureAccepted));
    for (i = 0; i < m_PoliciesIssuance.cObjId; i++)
    {
	if (0 == prgdwRefCount[i])
	{
	    hr = CERTSRV_E_ISSUANCE_POLICY_REQUIRED;
	    _PrintErrorStr(
		    hr,
		    "Policy:missing Issuance Policy",
		    m_PoliciesIssuance.rgpwszObjId[i]);
	    myAppendString(
		    m_PoliciesIssuance.rgpwszObjId[i],
		    L", ",
		    &pwszMissing);
	}
    }
    if (NULL != pwszMissing)
    {
	// The %1 Certificate Template requires the following issuance
	// policies that signing certificates did not include: %2.

	awszStrings[1] = pwszMissing;
	pRequest->BuildErrorInfo(
			    hr,
			    MSG_SIGNATURE_ISSUANCE_POLICY,
			    awszStrings);
    }
    _JumpIfError(hr, error, "Policy:missing Policy/Signature");

error:
    if (NULL != pwszMissing)
    {
	LocalFree(pwszMissing);
    }
    if (NULL != prgSignatureIssuance)
    {
	LocalFree(prgSignatureIssuance);
    }
    if (NULL != prgSignatureApplication)
    {
	LocalFree(prgSignatureApplication);
    }
    if (NULL != prgdwRefCount)
    {
        LocalFree(prgdwRefCount);
    }
    return(hr);
}


HRESULT
CTemplatePolicy::GetFlags(
    IN DWORD dwOption,
    OUT DWORD *pdwFlags)
{
    HRESULT hr;

    switch (dwOption)
    {
	case CERTTYPE_ENROLLMENT_FLAG:
	    *pdwFlags = m_tp.dwEnrollmentFlags;
	    break;

	case CERTTYPE_SUBJECT_NAME_FLAG:
	    *pdwFlags = m_tp.dwSubjectNameFlags;
	    break;

	case CERTTYPE_PRIVATE_KEY_FLAG:
	    *pdwFlags = m_tp.dwPrivateKeyFlags;
	    break;

	case CERTTYPE_GENERAL_FLAG:
	    *pdwFlags = m_tp.dwGeneralFlags;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:bad dwOption");

    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CTemplatePolicy::GetCriticalExtensions(
    OUT DWORD *pcCriticalExtensions,
    OUT WCHAR const * const **papwszCriticalExtensions)
{
    HRESULT hr;

    *pcCriticalExtensions = m_CriticalExtensions.cObjId;
    *papwszCriticalExtensions = m_CriticalExtensions.rgpwszObjId;
    hr = S_OK;
    return(hr);
}


HRESULT
CTemplatePolicy::GetV1TemplateClass(
    OUT WCHAR const **ppwszV1TemplateClass)
{
    WCHAR const *pwsz = NULL;

    *ppwszV1TemplateClass = NULL;
    if (CERTTYPE_SCHEMA_VERSION_2 > m_tp.dwSchemaVersion)
    {
	pwsz = m_pwszTemplateName;
    }
    else if (CT_FLAG_IS_CROSS_CA & m_tp.dwGeneralFlags)
    {
	pwsz = wszCERTTYPE_CROSS_CA;
    }
    *ppwszV1TemplateClass = pwsz;
    return(S_OK);
}


// IsRequestedTemplate - determine if the request specifies this template

BOOL
CTemplatePolicy::IsRequestedTemplate(
    OPTIONAL IN WCHAR const *pwszTemplateName,
    OPTIONAL IN WCHAR const *pwszTemplateObjId)
{
    HRESULT hr = CERTSRV_E_UNSUPPORTED_CERT_TYPE;

    if (NULL != pwszTemplateName)
    {
	if ((NULL != m_pwszTemplateName &&
	     0 == mylstrcmpiL(m_pwszTemplateName, pwszTemplateName)) ||
	    (NULL != m_pwszTemplateObjId &&
	     0 == lstrcmp(m_pwszTemplateObjId, pwszTemplateName)))
	{
	    hr = S_OK;
	}
    }
    if (S_OK != hr && NULL != pwszTemplateObjId)
    {
	if ((NULL != m_pwszTemplateName &&
	     0 == mylstrcmpiL(m_pwszTemplateName, pwszTemplateObjId)) ||
	    (NULL != m_pwszTemplateObjId &&
	     0 == lstrcmp(m_pwszTemplateObjId, pwszTemplateObjId)))
	{
	    hr = S_OK;
	}
    }
    _JumpIfErrorStr2(
		hr,
		error,
		"Policy:wrong CertType",
		m_pwszTemplateName,
		hr);

error:
    return(S_OK == hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\cemmchlp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       csmmchlp.h
//
//--------------------------------------------------------------------------

#define CERTMMC_HELPFILENAME L"Certmmc.hlp"

#define	IDH_CM_MODULE_LIST	70008125
#define	IDH_CRL_COMBO_UNITS	70008176
#define	IDH_CRL_DISABLE_PUBLISH	70008178
#define	IDH_CRL_EDIT_LASTUPDATE	70008177
#define	IDH_CRL_EDIT_NUMUNITS	70008175
#define	IDH_CRL_VIEW_CRL	70008179
#define	IDH_DQ_ADD_RESTRICTION	70008201
#define	IDH_DQ_DELETE_RESTRICTION	70008202
#define	IDH_DQ_QUERY_LIST	70008200
#define	IDH_DQ_RESET_BUTTON	70008203
#define	IDH_ED_COMBO_REASON	70008250
#define	IDH_NR_EDIT_NEWQUERY_FIELD	70008225
#define	IDH_NR_EDIT_NEWQUERY_OPERATION	70008226
#define	IDH_NR_EDIT_NEWQUERY_VALUE	70008227
#define	IDH_NR_DATEPICKER_NEWQUERY	70008228
#define IDH_NR_TIMEPICKER_NEWQUERY	70008229
#define	IDH_PP_BUTTON_DN	70008102
#define	IDH_PP_BUTTON_UP	70008101
#define	IDH_PP_CHECK1	70008075
#define	IDH_PP_EDIT_DATABASE_LOC	70008077
#define	IDH_PP_EDIT_LOG_LOC	70008078
#define	IDH_PP_EDIT_SHAREDFOLDER	70008076
#define	IDH_PP_LIST_AVAILABLE	70008100
#define	IDH_PP1_CANAME	70008000
#define	IDH_PP1_CSP_NAME	70008003
#define	IDH_PP1_DESCRIPTION	70008001
#define	IDH_PP1_HASHALG	70008004
#define	IDH_PP1_VIEW_CERT	70008002
#define	IDH_PP2_ACTIVE_MODULE	70008210
#define	IDH_PP2_CONFIGURE	70008209
#define	IDH_PP2_COPYRIGHT	70008028
#define	IDH_PP2_DESCRIPTION	70008026
#define	IDH_PP2_MODULENAME	70008025
#define	IDH_PP2_VERSION	70008027
#define	IDH_PP3_ACTIVE_MODULE	70008058
#define	IDH_PP3_ADDBUTTON1	70008051
#define	IDH_PP3_CONFIGURE	70008057
#define	IDH_PP3_COPYRIGHT	70008056
#define	IDH_PP3_DESCRIPTION	70008054
#define	IDH_PP3_EDIT1	70008050
#define	IDH_PP3_MODULENAME	70008053
#define	IDH_PP3_REMOVEBUTTON4	70008052
#define	IDH_PP3_VERSION	70008055
#define	IDH_RESTORE_DEFOK2	70008103
#define	IDH_ADDURL_EDITURL	70008400
#define	IDH_CRL_ADD	70008426
#define	IDH_CRL_LIST	70008425
#define	IDH_CRL_REMOVE	70008427
#define	IDH_EXIT_CHECK_FILE	70008451
#define	IDH_EXIT2_CHECK_DS	70008450
#define	IDH_DA_RADIO_PENDFIRST	70008500
#define	IDH_DA_RADIO_ISSUE	70008501
#define	IDH_POL2_ADD_AIA	70008529
#define	IDH_POL2_ADD_CRL	70008526
#define	IDH_POL2_AIA_LIST	70008528
#define	IDH_POL2_CRL_LIST	70008525
#define	IDH_POL2_REMOVE_AIA	70008530
#define	IDH_POL2_REMOVE_CRL	70008527
#define IDH_RADIO_REUSEKEY	70008541
#define IDH_RADIO_NEWKEY	70008542

#if defined (_CERTMMC_)

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE1[]=
{
	IDC_HASHALG,IDH_PP1_HASHALG,
	IDC_CANAME,IDH_PP1_CANAME,
	IDC_DESCRIPTION,IDH_PP1_DESCRIPTION,
	IDC_VIEW_CERT,IDH_PP1_VIEW_CERT,
	IDC_CSP_NAME,IDH_PP1_CSP_NAME,
	0, 0
};


const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE2[]=
{
	IDC_DESCRIPTION,IDH_PP2_DESCRIPTION,
	IDC_CONFIGURE,IDH_PP2_CONFIGURE,
	IDC_MODULENAME,IDH_PP2_MODULENAME,
	IDC_COPYRIGHT,IDH_PP2_COPYRIGHT,
	IDC_VERSION,IDH_PP2_VERSION,
	IDC_ACTIVE_MODULE,IDH_PP2_ACTIVE_MODULE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE3[]=
{
	IDC_ACTIVE_MODULE,IDH_PP3_ACTIVE_MODULE,
	IDC_EDIT1,IDH_PP3_EDIT1,
	IDC_BUTTON1,IDH_PP3_ADDBUTTON1,
	IDC_DESCRIPTION,IDH_PP3_DESCRIPTION,
	IDC_VERSION,IDH_PP3_VERSION,
	IDC_COPYRIGHT,IDH_PP3_COPYRIGHT,
	IDC_CONFIGURE,IDH_PP3_CONFIGURE,
	IDC_MODULENAME,IDH_PP3_MODULENAME,
	IDC_BUTTON4,IDH_PP3_REMOVEBUTTON4,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CERTSRV_PROPPAGE5[]=
{
	IDC_CHECK1,IDH_PP_CHECK1,
	IDC_EDIT_SHAREDFOLDER,IDH_PP_EDIT_SHAREDFOLDER,
	IDC_EDIT_LOG_LOC,IDH_PP_EDIT_LOG_LOC,
	IDC_EDIT_DATABASE_LOC,IDH_PP_EDIT_DATABASE_LOC,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CHOOSE_COLUMNS[]=
{
	IDC_LIST_AVAILABLE,IDH_PP_LIST_AVAILABLE,
	IDC_BUTTON_UP,IDH_PP_BUTTON_UP,
	IDC_BUTTON_DN,IDH_PP_BUTTON_DN,
	IDOK2,IDH_RESTORE_DEFOK2,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CHOOSE_MODULE[]=
{
	IDC_MODULE_LIST,IDH_CM_MODULE_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_CRL_PROPPAGE[]=
{
	IDC_EDIT_NUMUNITS,IDH_CRL_EDIT_NUMUNITS,
	IDC_COMBO_UNITS,IDH_CRL_COMBO_UNITS,
	IDC_EDIT_LASTUPDATE,IDH_CRL_EDIT_LASTUPDATE,
	IDC_DISABLE_PUBLISH,IDH_CRL_DISABLE_PUBLISH,
	IDC_VIEW_CRL,IDH_CRL_VIEW_CRL,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DEFINE_QUERY[]=
{
	IDC_RESET_BUTTON,IDH_DQ_RESET_BUTTON,
	IDC_QUERY_LIST,IDH_DQ_QUERY_LIST,
	IDC_ADD_RESTRICTION,IDH_DQ_ADD_RESTRICTION,
	IDC_DELETE_RESTRICTION,IDH_DQ_DELETE_RESTRICTION,
	0, 0
};

const DWORD g_aHelpIDs_IDD_NEW_RESTRICTION[]=
{
	IDC_EDIT_NEWQUERY_VALUE,IDH_NR_EDIT_NEWQUERY_VALUE,
	IDC_EDIT_NEWQUERY_FIELD,IDH_NR_EDIT_NEWQUERY_FIELD,
	IDC_EDIT_NEWQUERY_OPERATION,IDH_NR_EDIT_NEWQUERY_OPERATION,
	IDC_DATEPICKER_NEWQUERY, IDH_NR_DATEPICKER_NEWQUERY,
	IDC_TIMEPICKER_NEWQUERY, IDH_NR_TIMEPICKER_NEWQUERY,
	0, 0
};

const DWORD g_aHelpIDs_IDD_REVOCATION_DIALOG[]=
{
	IDC_COMBO_REASON,IDH_ED_COMBO_REASON,
	0, 0
};


const DWORD g_aHelpIDs_IDD_RENEW_REUSEKEYS[]=
{
	IDC_RADIO_REUSEKEY,IDH_RADIO_REUSEKEY,
	IDC_RADIO_NEWKEY,IDH_RADIO_NEWKEY,
	0,0
};

#endif // #if defined (_CERTMMC_)


#if defined (_CERTEXIT_)

//certexit.rc
const DWORD g_aHelpIDs_IDD_ADDURL[]=
{
	IDC_EDITURL, IDH_ADDURL_EDITURL,
	0,0
};

const DWORD g_aHelpIDs_IDD_EXITPG1[]=
{
	IDC_REMOVE_CRL, IDH_CRL_REMOVE,
	IDC_ADD_CRL, IDH_CRL_ADD,
	IDC_CRL_LIST, IDH_CRL_LIST,
	0,0
};

const DWORD g_aHelpIDs_IDD_EXITPG2[]=
{
	IDC_CHECK_FILE, IDH_EXIT_CHECK_FILE,
	IDC_CHECK_DS, IDH_EXIT2_CHECK_DS,
	0,0
};

#endif // #if defined (_CERTEXIT_)


#if defined (_CERTPDEF_)

//certpent.rc
const DWORD g_aHelpIDs_IDD_ADDURL[]=
{
	IDC_EDITURL, IDH_ADDURL_EDITURL,
	0,0
};

const DWORD g_aHelpIDs_IDD_POLICYPG1[]=
{
	IDC_RADIO_ISSUE,IDH_DA_RADIO_ISSUE,
	IDC_RADIO_PENDFIRST,IDH_DA_RADIO_PENDFIRST,
	0,0
};


const DWORD g_aHelpIDs_IDD_POLICYPG2[]=
{
	IDC_REMOVE_AIA,IDH_POL2_REMOVE_AIA,
	IDC_ADD_AIA,IDH_POL2_ADD_AIA,
	IDC_AIA_LIST,IDH_POL2_AIA_LIST,
	IDC_REMOVE_CRL,IDH_POL2_REMOVE_CRL,
	IDC_ADD_CRL,IDH_POL2_ADD_CRL,
	IDC_CRL_LIST,IDH_POL2_CRL_LIST,
	0,0
};

#endif // #if defined (_CERTPDEF_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\expolicy.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        expolicy.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "celib.h"
#include "policy.h"
#include "module.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertPolicyExchange, CCertPolicyExchange)
    OBJECT_ENTRY(CLSID_CCertManagePolicyModuleExchange, CCertManagePolicyModuleExchange)
END_OBJECT_MAP()

HINSTANCE g_hInstance = NULL;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    _Module.Init(ObjectMap, hInstance);
	    g_hInstance = hInstance;
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}


void __RPC_FAR *__RPC_USER
MIDL_user_allocate(size_t cb)
{
    return(LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb));
}


void __RPC_USER
MIDL_user_free(void __RPC_FAR *pb)
{
    LocalFree(pb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\exver.h ===
#include <ntverp.h>
#include "iisver.h"

//#define VER_IISMAJORVERSION	5

#ifdef VER_IISMINORVERSION
#undef VER_IISMINORVERSION
#endif
#define VER_IISMINORVERSION	5

#ifdef VER_IISPRODUCTBUILD
#undef VER_IISPRODUCTBUILD
#endif
#define VER_IISPRODUCTBUILD	2232

//
// Undo IIS's definitions and use our own
//
#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif
#define VER_PRODUCTNAME_STR			"Microsoft(R) Internet Services"

#ifdef VER_FILEVERSION
#undef VER_FILEVERSION
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#ifdef VER_FILESUBTYPE
#undef VER_FILESUBTYPE
#endif

#ifndef rmj
#define rmj VER_IISMAJORVERSION
#endif // !rmj 
#ifndef rmn
#define rmn VER_IISMINORVERSION
#endif // !rmn 
#define rmm VER_IISPRODUCTBUILD
#define rup 1
#define szVerName ""
#define szVerUser "_mpubld"


#ifdef MAC
#ifndef _rmacmaj
#define _rmacmaj 0x6
#endif
#ifndef _rmacmin
#define _rmacmin 0x
#endif
#ifndef _rmacint
#define _rmacint 0x
#endif
#ifndef _rmactype
#define _rmactype 
#endif
#ifndef _rmacstr
#define _rmacstr "6.0"
#endif
#endif //MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\iisver.h ===
//
// Apps' rc files should look like this:
//
/**
#include "windows.h"
#include "ntverp.h"

#define VER_FILEDESCRIPTION_STR         "File Description"
#define VER_INTERNALNAME_STR            "Internal Name"
#define VER_ORIGINALFILENAME_STR        "Original Name"
#define VER_FILETYPE                    VFT_DLL

#include "iisver.h"
#include "common.ver"

**/
//
// Apps may also define, in the same place as the other defines, above:
// VER_FILESUBTYPE
// VER_IISPRODUCTNAME_STR
// VER_IISMAJORVERSION
// VER_IISMINORVERSION
// VER_IISPRODUCTVERSION_STR
// VER_IISPRODUCTVERSION
// VER_IISPRODUCTBUILD
//

#ifndef VER_FILEDESCRIPTION_STR
#define VER_FILEDESCRIPTION_STR     "IIS Executable"
#endif

#ifndef VER_INTERNALNAME_STR
#define VER_INTERNALNAME_STR        "IISFile.exe"
#endif

#ifndef VER_ORIGINALFILENAME_STR
#define VER_ORIGINALFILENAME_STR    VER_INTERNALNAME_STR
#endif

#ifdef VER_PRODUCTNAME_STR
#undef VER_PRODUCTNAME_STR
#endif

#ifndef VER_IISPRODUCTNAME_STR
#define VER_IISPRODUCTNAME_STR      "Internet Information Services"
#endif

#define VER_PRODUCTNAME_STR         VER_IISPRODUCTNAME_STR

#ifndef VER_IISMAJORVERSION
#define VER_IISMAJORVERSION         5
#endif

#ifndef VER_IISMINORVERSION
#define VER_IISMINORVERSION         00
#endif

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#ifndef VER_IISPRODUCTVERSION_STR
#define VER_IISPRODUCTVERSION_STR      "5.00.0984"
#endif

#define VER_PRODUCTVERSION_STR      VER_IISPRODUCTVERSION_STR

//
// VER_PRODUCTBUILD is defined by ntverp.h as the nt build number
//

#ifndef VER_PRODUCTBUILD
#define VER_PRODUCTBUILD            0984
#endif

#ifndef VER_IISPRODUCTBUILD
#define VER_IISPRODUCTBUILD         VER_PRODUCTBUILD
#endif

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif

#ifndef VER_IISPRODUCTVERSION
#define VER_IISPRODUCTVERSION          VER_IISMAJORVERSION,VER_IISMINORVERSION,VER_IISPRODUCTBUILD,1
#endif

#define VER_PRODUCTVERSION          VER_IISPRODUCTVERSION

#ifndef VER_FILEVERSION
#define VER_FILEVERSION             VER_PRODUCTVERSION
#endif

#ifndef VER_FILETYPE
#define VER_FILETYPE                VFT_DLL
#endif

#ifndef VER_FILESUBTYPE
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\kmsattr.h ===
/*
 * kmsattr.h
 *
 * constants shared between KMServer.exe and ExPolicy.dll
 *
 * Owner : Greg Kramer (gregkr)
 *
 * Copyright 1986-1997 Microsoft Corporation. All Rights Reserved.
 *
 */

#ifndef _KMSATTR_H_
#define _KMSATTR_H_

// syntax of Submit::Attributes is
//      name:value\n
// '-' and ' ' are stripped from name.
// leading and trailing whitespace stripped from name and from value.

const   WCHAR   k_wszSubjAltNameRFC822  [] = L"SubjAltNameRFC822";
const   WCHAR   k_wszSubjAltNameDisplay [] = L"SubjAltNameDisplay";
const   WCHAR   k_wszKeyUsage           [] = L"KeyUsage";
const   WCHAR   k_wszKMServerName       [] = L"KMServerName";

// count of attributes sent from KMServer to ExPolicy :
// SubjAltNameRFC822, SubjAltNameDisplay, KeyUsage, and KMServerName
const   ULONG   k_cAttrNames            = 4;

const   WCHAR   k_wchTerminateName      = L':';
const   WCHAR   k_wchTerminateValue     = L'\n';

const   WCHAR   k_wszUsageSealing       [] = L"1";
const   WCHAR   k_wszUsageSigning       [] = L"2";
const   ULONG   k_cchmaxUsage           = 1;    // cch of longest value

const   ULONG   k_cchNamesAndTerminaters =
    (sizeof(k_wszSubjAltNameRFC822)  / sizeof(WCHAR) ) - 1 +
    (sizeof(k_wszSubjAltNameDisplay) / sizeof(WCHAR) ) - 1 +
    (sizeof(k_wszKeyUsage)           / sizeof(WCHAR) ) - 1 +
    (sizeof(k_wszKMServerName)       / sizeof(WCHAR) ) - 1 +
    k_cAttrNames +  // name terminaters
    k_cAttrNames;   // value terminaters
    // don't include string terminaters

const   WCHAR   k_wszSubjectAltName     [] = L"SubjectAltName";
const   WCHAR   k_wszSubjectAltName2    [] = L"SubjectAltName2";
const   WCHAR   k_wszIssuerAltName      [] = L"IssuerAltName";

const   WCHAR   k_wszSpecialAttribute   [] = L"Special";

const   ULONG   k_cchSpecialAttribute   =
    (sizeof(k_wszSpecialAttribute)   / sizeof(WCHAR) ) - 1;

#endif // ! _KMSATTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\listvw.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       listvw.cpp
//
//--------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <commctrl.h>
#include <assert.h>

#include "celib.h"
#include "listvw.h"

extern HINSTANCE g_hInstance;

typedef struct _DISPLAYSTRING_EXPANSION
{
   LPCWSTR szContractedToken;
   LPCWSTR szExpansionString;
} DISPLAYSTRING_EXPANSION, *PDISPLAYSTRING_EXPANSION;

DISPLAYSTRING_EXPANSION displayStrings[] =
{
    { wszFCSAPARM_SERVERDNSNAME, L"%SERVER_DNS_NAME%"},
    { wszFCSAPARM_SERVERSHORTNAME, L"%SERVER_SHORT_NAME%"},
    { wszFCSAPARM_SANITIZEDCANAME, L"%CA_NAME%"},
    { wszFCSAPARM_CERTFILENAMESUFFIX, L"%CERT_SUFFIX%"},
    { wszFCSAPARM_DOMAINDN, L"%DOMAIN_NAME%"},
    { wszFCSAPARM_CONFIGDN, L"%CONFIG_NAME%"},
    { wszFCSAPARM_SANITIZEDCANAMEHASH, L"%CA_NAME_HASH%"},
    { wszFCSAPARM_CRLFILENAMESUFFIX, L"%CRL_SUFFIX%"},
};

DISPLAYSTRING_EXPANSION escapedStrings[] =
{
    { L"%9", L"%%"},
};




HRESULT ValidateTokens(
    IN OUT LPWSTR szURL,
    OUT DWORD* pchBadBegin,
    OUT DWORD* pchBadEnd)
{
    HRESULT hr = S_FALSE;
    int i;
    LPWSTR pszMatch;
    LPWSTR pszFound = szURL;

    WCHAR rgszToken[MAX_PATH];

    *pchBadBegin = -1;
    *pchBadEnd = -1;

    // look for escape token open marker
    while(NULL != (pszFound = wcschr(pszFound, L'%')))
    {
        pszMatch = wcschr(&pszFound[1], L'%'); // look for closing marker
        if (pszMatch == NULL)
            goto Ret;

        DWORD dwChars = SAFE_SUBTRACT_POINTERS(pszMatch, pszFound) +1;   // dwChars is chars including markers
        if (dwChars == 2)
            goto NextMatch;   // %% is valid escape sequence
        
        if (dwChars > MAX_PATH)
            goto Ret;   // invalid escape token!

        // isolate the token
        CopyMemory(rgszToken, pszFound, dwChars * sizeof(WCHAR));
        rgszToken[dwChars] = L'\0';

        for (i=0; i<ARRAYSIZE(displayStrings); i++)
        {
            if (0 == _wcsicmp(rgszToken, displayStrings[i].szExpansionString))
            {
                // copy from displayStrings -- these are guaranteed to be properly uppercased
                CopyMemory(pszFound, displayStrings[i].szExpansionString, dwChars * sizeof(WCHAR));
                goto NextMatch;
            }
        }
        
        // if we get here, we found no match
        goto Ret;

NextMatch:
        pszFound = ++pszMatch;
    }

    hr = S_OK;
Ret:
    
    if (hr != S_OK)
    {
        *pchBadBegin = SAFE_SUBTRACT_POINTERS(pszFound, szURL); // offset to first incorrect %

        if (pszMatch)
            *pchBadEnd = SAFE_SUBTRACT_POINTERS(pszMatch, szURL) + 1; // offset past final incorrect %
    }
    
    return hr;
}


HRESULT 
ExpandDisplayString(
     IN LPCWSTR szContractedString,
     OUT LPWSTR* ppszDisplayString)
{
    HRESULT hr;
    DWORD dwChars;
    int i, iescapedStrings;
    LPWSTR pszTempContracted = NULL;
    LPWSTR pszFound;

    // account for %% escaping in contracted string --
    // replace "%%" with %9, let FormatString expand to "%%"
    pszTempContracted = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(szContractedString)+1)*sizeof(WCHAR));
    if (pszTempContracted == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }
    wcscpy(pszTempContracted, szContractedString);

    pszFound = wcsstr(pszTempContracted, L"%%");
    while(pszFound)
    {
        CopyMemory(pszFound, escapedStrings[0].szContractedToken, wcslen(escapedStrings[0].szContractedToken)*sizeof(WCHAR));
        pszFound = wcsstr(pszFound, L"%%");
    }


    LPCWSTR args[ARRAYSIZE(displayStrings)+ARRAYSIZE(escapedStrings)];
    for (i=0; i<ARRAYSIZE(displayStrings); i++)
    {
        args[i] = displayStrings[i].szExpansionString;
    }
    // and tell FormatString to expand %9 to %%
    for (iescapedStrings=0; iescapedStrings<ARRAYSIZE(escapedStrings); iescapedStrings++)
    {
        args[i+iescapedStrings] = escapedStrings[iescapedStrings].szExpansionString;
    }


    dwChars = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_STRING,
        pszTempContracted,
        0, //msgid
        0, //langid
        (LPWSTR)ppszDisplayString,
        1,  // minimum chars to alloc
        (va_list *)args);

    if (dwChars == 0)
    {
        hr = GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
        goto Ret;
    }

    hr = S_OK;
Ret:
    if (pszTempContracted)
        LocalFree(pszTempContracted);

    return hr;
}

HRESULT
ContractDisplayString(
     IN LPCWSTR szDisplayString,
     OUT LPWSTR* ppContractedString)
{
    HRESULT hr;
    int i;

    *ppContractedString = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(szDisplayString)+1) * sizeof(WCHAR));
    if (*ppContractedString == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }

    wcscpy(*ppContractedString, szDisplayString);

    for (i=0; i<ARRAYSIZE(displayStrings); i++)
    {
        DWORD chContractedToken, chExpansionString;

        LPWSTR pszFound = wcsstr(*ppContractedString, displayStrings[i].szExpansionString);
        while(pszFound)
        {
            // calc commonly used values
            chContractedToken = wcslen(displayStrings[i].szContractedToken);
            chExpansionString = wcslen(displayStrings[i].szExpansionString);

            // replace with token
            CopyMemory(pszFound, displayStrings[i].szContractedToken, chContractedToken*sizeof(WCHAR));

            // slide rest of string left
            MoveMemory(
                &pszFound[chContractedToken],         // destination
                &pszFound[chExpansionString],         // source
                (wcslen(&pszFound[chExpansionString])+1) *sizeof(WCHAR) );

            // step Found over insertion
            pszFound += chContractedToken;

            // find any other ocurrences after this one
            pszFound = wcsstr(pszFound, displayStrings[i].szExpansionString);
        }
    }

    hr = S_OK;
Ret:
    return hr;
}     

void AddStringToCheckList(
                    HWND            hWndListView,
                    LPCWSTR         szText, 
                    LPVOID          pvData,
                    BOOL            fCheck)
{
    LVITEMW                    lvI;
    ZeroMemory(&lvI, sizeof(lvI));
   
    //
    // set up the fields in the list view item struct that don't change from item to item
    //
    lvI.mask = LVIF_TEXT | LVIF_PARAM;
    lvI.pszText = (LPWSTR)szText;
    lvI.iSubItem = 0;
    lvI.lParam = (LPARAM)pvData; 
    lvI.iItem = ListView_GetItemCount(hWndListView);
    lvI.cchTextMax = wcslen(szText);

    ListView_InsertItem(hWndListView, &lvI);
    ListView_SetCheckState(hWndListView, lvI.iItem, fCheck);

    ListView_SetColumnWidth(hWndListView, 0, LVSCW_AUTOSIZE);
}

DWORD DetermineURLType(PCERTSVR_URL_PARSING prgURLParsing, int cURLParsingEntries, LPCWSTR szCandidateURL)
{
    int iURLTypeMatch;

    // determine URL type
    WCHAR rgsz[6];  // "http:\0" , etc
    lstrcpyn(rgsz, szCandidateURL, 6);
    WCHAR* pch = wcschr(rgsz, L':');    // find ':'
    if (NULL == pch)
        return -1;   // invalid item
    pch[1] = '\0';  // whack the elt after :
            
    // find the prefix in our list of known protocols
    for (iURLTypeMatch=0; iURLTypeMatch<cURLParsingEntries; iURLTypeMatch++)
    {
        if (0 == _wcsicmp(rgsz, prgURLParsing[iURLTypeMatch].szKnownPrefix))
            break;
    }
    if (iURLTypeMatch == cURLParsingEntries)     // no match
        return -1;
    
    return iURLTypeMatch;
}


HRESULT WriteChanges(HWND hListView, HKEY hkeyStorage, PCERTSVR_URL_PARSING prgURLParsing, DWORD cURLParsingEntries)
{
    HRESULT hr = S_OK;

    // empty item to dump to 
    LV_ITEM lvI;
    ZeroMemory(&lvI, sizeof(lvI));
    lvI.mask = LVIF_TEXT;
    WCHAR szText[MAX_PATH+1];
    lvI.pszText = szText;
    lvI.cchTextMax = MAX_PATH;
    
    LPWSTR pszContracted = NULL;

    int iURLArrayLen = cURLParsingEntries;
    int iURLTypeMatch;
    
    DWORD*  rgchszzEntries = NULL;
    LPWSTR* rgszzEntries = NULL;

    // entries will be sorted into one of the following
    rgchszzEntries = (DWORD*)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(DWORD) * cURLParsingEntries);
    if (NULL == rgchszzEntries)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }

    rgszzEntries = (LPWSTR*)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(LPWSTR) * cURLParsingEntries); 
    if (NULL == rgszzEntries)
    {
        hr = E_OUTOFMEMORY;
        goto Ret;
    }    
    
    // enumerate through all the items and add to the arrays
    for (lvI.iItem=0; ; lvI.iItem++)
    {
        BOOL fCheck = TRUE;
        LPWSTR pszTmp;
        
        // go until we hit end-of-list
        if (!ListView_GetItem(hListView, &lvI))
            break;
        
        // determine URL type
        iURLTypeMatch = DetermineURLType(prgURLParsing, iURLArrayLen, lvI.pszText);
        if (iURLTypeMatch == -1)    // no match
            continue;

        hr = ContractDisplayString(
             lvI.pszText,
             &pszContracted);

        // determine check state
        if (!ListView_GetCheckState(hListView, lvI.iItem))
        {
            // item not checked! add '-'
            fCheck = FALSE;
        }
        
        // alloc enough to hold existing, plus new [-]"string\0", plus \0 we'll tack on end of string
        DWORD dwAllocBytes = ((rgchszzEntries[iURLTypeMatch] + wcslen(pszContracted) + 2) * sizeof(WCHAR)) + (fCheck ? 0 : sizeof(WCHAR));

        if (NULL == rgszzEntries[iURLTypeMatch])
        {
            pszTmp  = (LPWSTR)LocalAlloc(LMEM_FIXED, dwAllocBytes);
        }
        else
        {
            pszTmp = (LPWSTR)LocalReAlloc(
                rgszzEntries[iURLTypeMatch], 
                dwAllocBytes, 
                LMEM_MOVEABLE);
        }
        if (NULL == pszTmp)
        {
            // leave ppszzEntries as valid as it already is, try to recover
            break;
        }
        
        rgszzEntries[iURLTypeMatch] = pszTmp;           // assign new mem to rgszz; meanwhile, pszTmp is shorthand
        DWORD chTmp = rgchszzEntries[iURLTypeMatch];  // temp assign
        
        if (!fCheck)
        {
            pszTmp[chTmp++] = L'-'; // item not checked
        }
        wcscpy(&pszTmp[chTmp], pszContracted);
        chTmp += wcslen(pszContracted)+1; // skip string\0
        pszTmp[chTmp] = L'\0';    // double NULL, don't count in rgchszzEntries
        
        // reassign chTmp to rgchszzEntries[iURLTypeMatch]
        rgchszzEntries[iURLTypeMatch] = chTmp;

        // clean up
        if (pszContracted)
            LocalFree(pszContracted);
        pszContracted = NULL;
        
        // next listbox entry!
    }

    // done, now commit all URL types to registry
    for (iURLTypeMatch=0; iURLTypeMatch<iURLArrayLen; iURLTypeMatch++)
    {
        hr = RegSetValueEx(
		    hkeyStorage,
		    prgURLParsing[iURLTypeMatch].szRegEntries,
		    0,
		    REG_MULTI_SZ,
		    (BYTE *) (NULL == rgszzEntries[iURLTypeMatch]?
			L"\0\0" : rgszzEntries[iURLTypeMatch]),
		    (NULL == rgszzEntries[iURLTypeMatch]?
			    2 : rgchszzEntries[iURLTypeMatch] + 1) *
			sizeof(WCHAR)); // now add 2nd '\0'
        
        // Zero
        if (rgszzEntries[iURLTypeMatch])
        {
            LocalFree(rgszzEntries[iURLTypeMatch]);
            rgszzEntries[iURLTypeMatch] = NULL;
            rgchszzEntries[iURLTypeMatch] = 0;
        }
        
        if (hr != ERROR_SUCCESS)
        {
            //ASSERT(!"RegSetValueEx error!");
            continue;
        }
    }

    hr = S_OK;
Ret:
    if (rgchszzEntries)
        LocalFree(rgchszzEntries);

    if (rgszzEntries)
        LocalFree(rgszzEntries);

    if (pszContracted)
        LocalFree(pszContracted);

    return hr;
}

HRESULT PopulateListView(
        HWND hListView, 
        HKEY hkeyStorage, 
        PCERTSVR_URL_PARSING prgURLParsing, 
        DWORD cURLParsingEntries,
        DWORD dwEnableFlags)
{
    HRESULT hr;
    LPWSTR pwszzMultiString = NULL, psz;
    for (DWORD i=0; i<cURLParsingEntries; i++)
    {
        DWORD cb=0, dwType;
        hr = RegQueryValueEx(
            hkeyStorage,
            prgURLParsing[i].szRegEntries,
            0,
            &dwType,
            NULL,
            &cb);
        if ((hr != ERROR_SUCCESS) || (dwType != REG_MULTI_SZ) || (cb == 0))
            continue;
        pwszzMultiString = (LPWSTR)LocalAlloc(LMEM_FIXED, cb);
        if (NULL == pwszzMultiString)
            continue;
        hr = RegQueryValueEx(
            hkeyStorage,
            prgURLParsing[i].szRegEntries,
            0,
            &dwType,
            (PBYTE)pwszzMultiString,
            &cb);
        if ((HRESULT) ERROR_SUCCESS != hr)
        {
            if (pwszzMultiString)
                LocalFree(pwszzMultiString); 
            pwszzMultiString = NULL;

            continue;
        }

        // walk pwszzMultiString components
        for (psz = pwszzMultiString; (psz) && (psz[0] != '\0'); psz += wcslen(psz)+1)
        {
            BOOL fCheck = TRUE;
            LPWSTR szDisplayString;

            // if string starts with -, this is unchecked 
            if (psz[0] == L'-')
            {
                fCheck = FALSE;
                psz++;  // step past this char
            }

            // enable flags -- override
            if (prgURLParsing[i].dwEnableFlag != (dwEnableFlags & prgURLParsing[i].dwEnableFlag))
                fCheck = FALSE;

            hr = ExpandDisplayString(
                 psz,
                 &szDisplayString);
            if (hr != S_OK)
                continue;

            // add this sz
            AddStringToCheckList(
                    hListView,
                    szDisplayString, //psz, 
                    NULL,
                    fCheck);
            
            LocalFree(szDisplayString);
        }

        if (pwszzMultiString) 
        {
            LocalFree(pwszzMultiString); 
            pwszzMultiString = NULL;
        }
    }

    hr = S_OK;
//Ret:
    return hr;
}

BOOL OnDialogHelp(LPHELPINFO pHelpInfo, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
    if (rgzHelpIDs == NULL || szHelpFile == NULL)
        return TRUE;

    if (pHelpInfo != NULL && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        WinHelp((HWND)pHelpInfo->hItemHandle, szHelpFile,
            HELP_WM_HELP, (ULONG_PTR)(LPVOID)rgzHelpIDs);
    }
    return TRUE;
}

BOOL OnDialogContextHelp(HWND hWnd, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
    if (rgzHelpIDs == NULL || szHelpFile == NULL)
        return TRUE;
    assert(IsWindow(hWnd));
    WinHelp(hWnd, szHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)rgzHelpIDs);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\makefile.inc ===
!include ..\sample\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certweb\certsgcl.inc ===
﻿<%' CODEPAGE=65001 'UTF-8%>
<%' certsgcl.inc - (CERT)srv web - (S)cript: (G)et (C)sp (L)ist
  ' Copyright (C) Microsoft Corporation, 1998 - 1999 %>

<Script Language="JavaScript">
	//----------------------------------------------------------------
	// convert a (signed) number into a (unsigned) hex string
	function toHex(number) {
		var sRight=(number&0x0FFFFFFF).toString(16).toUpperCase();
		sRight="0000000".substring(0, 7-sRight.length)+sRight;
		return ((number>>28)&0x0000000F).toString(16).toUpperCase()+sRight;
	}
</Script>

<%If True=bIncludeXEnroll Then%>
<%If "IE"=sBrowser Then%>
<!-- IE SPECIFIC:  -->
<Span ID=spnXEnroll Style="display:none">
	<!-- XEnroll will be inserted here -->
</Span>

<!-- A DHTML alert box, for the transient message routines -->
<Table Border=0 CellSpacing=0 CellPadding=0 ID=tblWorkingMsg Style="display:none; position:absolute;">
<TR>
	<TD BgColor=#000040 Height=3 ColSpan=3></TD>
</TR> <TR>
	<TD BgColor=#000040 Width=3></TD>
	<TD BgColor=#008080><Font Color=#FFFFFF><B><BR>&nbsp;&nbsp;&nbsp;&nbsp;<Span ID=spnWorkingMsg></Span>&nbsp;&nbsp;&nbsp;&nbsp;<BR><BR></B></Font></TD>
	<TD BgColor=#000040 Width=3></TD>
</TR> <TR>
	<TD BgColor=#000040 Height=3 ColSpan=3></TD>
</TR>
</Table>
<%End If%>

<%If "Text"<>sBrowser Then%>
<Script Language="JavaScript">
	//----------------------------------------------------------------
	// Show the message in the status bar and in the middle of the screen (DHTML only)
	function ShowTransientMessage(sMessage) {
		window.status=sMessage;
		<%If "IE"=sBrowser Then%>
		spnWorkingMsg.innerText=sMessage;
		tblWorkingMsg.style.display='';
		tblWorkingMsg.style.pixelTop=
			(document.body.clientHeight/2)-(tblWorkingMsg.offsetHeight/2)+(document.body.scrollTop);
		tblWorkingMsg.style.pixelLeft=
			(document.body.clientWidth/2)-(tblWorkingMsg.offsetWidth/2)+(document.body.scrollLeft);
		<%End If%>
	}

	//----------------------------------------------------------------
	// hide the message box
	function HideTransientMessage() {
		window.status="";
		<%If "IE"=sBrowser Then%>
		tblWorkingMsg.style.display='none';
		<%End If%>
	}
</Script>
<%End If%>

<%If "IE"=sBrowser Then%>
<Script Language="JavaScript">

	//----------------------------------------------------------------
	// IE SPECIFIC:
	// Download the appropriate version of XEnroll if the local 
	// version is too old, and wait for the control to finish downloading.
	// sContinueCmd will be executed when the control is ready
	function loadXEnroll(sContinueCmd) {

		// clear the current control, if there is one
		spnXEnroll.innerHTML="";
		
		// determine the file name from the CPU type.
		var sCPU=navigator.cpuClass.toLowerCase();
		if ("x86"!=sCPU && "ia64"!=sCPU) {
			alert(eval(L_BadCPU_ErrorMessage));
			g_fnOnLoadFail();
			return;
		}

		// load the control
		var sControl="<Object \n"
			+ "  ClassID=\"clsid:127698e4-e730-4e5c-a2b1-21490a70c8a1\"\n"
			+ "  Codebase=\"/CertControl/xenrlinf.cab#Version=<%=sXEnrollVersion%>\"\n"
			+ "  ID=XEnroll\n"
			+ "></Object>";
		// alert("About to create:\n" + sControl);
		spnXEnroll.innerHTML=sControl;

		// begin polling to see if the control is loaded
		setTimeout("loadXEnrollPhase2(\""+sContinueCmd+"\")", 1);
	}
	function loadXEnrollPhase2(sContinueCmd) {
		// continued from above

		// is the control loaded?
		if (4!=XEnroll.readyState) { // 4=READYSTATE_COMPLETE
			// no, show a message and wait a while
			ShowTransientMessage(L_DownloadingControl_Message);
			setTimeout("loadXEnrollPhase2(\""+sContinueCmd+"\")", 500);
		} else {
			// yes, hide the message
			HideTransientMessage();

			// smoke test the control
			var nResult=ConfirmXEnrollLoaded();
			if (0!=nResult) {
				if (438==nResult) {
					alert(L_ControlLoadFailed_ErrorMessage);
				} else {
					var sErrorNumber="0x"+toHex(nResult);
					alert(eval(L_ControlLoadFailedEx_ErrorMessage));
				}
				g_fnOnLoadFail();
				return;
			}

			// Continue with what the caller wanted us to do
			execScript(sContinueCmd, "JavaScript");
		}
	}

	//----------------------------------------------------------------
	// IE SPECIFIC:
	// disable all the controls on this page so the user can't do anything
	function disableAllControls() {

		// some pages do not have any controls
		if (null==document.UIForm) {
			return;
		}

		// disable every control on the page
		var nCount=document.UIForm.elements.length;
		var nIndex;
		for (nIndex=0; nIndex<nCount; nIndex++) { //>
			document.UIForm.elements(nIndex).disabled=true;
		}
	}

	//----------------------------------------------------------------
	// If XEnroll fails to load, this function will be called.
	// By default, disable all controls.
	var g_fnOnLoadFail=disableAllControls;

</Script>
<Script Language="VBScript">
	'-----------------------------------------------------------------
	' Strings to be localized
	Const L_BadCPU_ErrorMessage="""Your CPU (""+sCPU+"") is not supported."""
	Const L_DownloadingControl_Message="Downloading ActiveX control..."
	Const L_ControlLoadFailed_ErrorMessage="The proper version of the ActiveX control failed to download and install. You may not have sufficient permissions. Please ask your system administrator for assistance."
	Const L_ControlLoadFailedEx_ErrorMessage="""An unexpected error (""+sErrorNumber+"") occurred while downloading and installing the proper version of the ActiveX control. Please ask your system administrator for assistance."""

	'-----------------------------------------------------------------
	' IE SPECIFIC:
	' Test to make sure XEnroll loaded properly by calling a method on it.
	' For best results, the method we call should only be available in the 
	' most recent version of the control, however any method will detect
	' failure to create the object.
	Function ConfirmXEnrollLoaded()
		On Error Resume Next
		Dim nTest
		nTest=XEnroll.HashAlgID
		ConfirmXEnrollLoaded=Err.Number
	End Function
</Script>
<%End If '"IE"=sBrowser%>
<%End If 'True=bIncludeXEnroll%>

<%If True=bIncludeGetCspList Then%>
<%If "IE"=sBrowser Then%>
<Script Language="VBScript">
	Option Explicit

	'-----------------------------------------------------------------
	' Strings to be localized
	Const L_NoCSPs_ErrorMessage="(No CSPs found!)"
	Const EnhancedCSPString="Microsoft Enhanced Cryptographic Provider"
	Const BaseCSPString="Microsoft Base Cryptographic Provider"

	'-----------------------------------------------------------------
	' IE SPECIFIC:
	' Get the list of CSPs from XEnroll
	' returns error number
	' assumes XEnroll is named 'XEnroll' and the list box is 'document.UIForm.lbCSP'
	Function GetCSPList()
		On Error Resume Next
		Dim nProvType, nOrigProvType, nTotCSPs, nDefaultCSP, nBaseCSP, bNoDssBase, bNoDssDh, sUserAgent
		Const nMaxProvType=25 ' should be >= the number of providers defined in wincrypt.h (~line 431)
		nTotCSPs=0
		nDefaultCSP=-1
		nBaseCSP=-1

		' Special case stuff for DSS CSPs
		' We know we are an IE browser to get here.
		sUserAgent=navigator.userAgent
		If CInt(Mid(sUserAgent, InStr(sUserAgent, "MSIE")+5, 1))<=4 Then
			' IE 4 or below
			bNoDssDh=True
			bNoDssBase=True
			If 0<>InStr(sUserAgent, "NT)") Then 'NT 4 does not include version num in string.
				' except on NT4, which can
				bNoDssDh=False
			End If
		Else
			' IE 5 or above
			bNoDssDh=False
			If 0<>InStr(sUserAgent, "95") Then
				' Win95 can't
				bNoDssBase=True
			ElseIf 0<>InStr(sUserAgent, "NT)") Then 'NT 4 does not include version num in string.
				' NT4 can't
				bNoDssBase=True
			Else
				' Win98 and Win2K can
				bNoDssBase=False
			End If
		End If

		' save the original provider type
		nOrigProvType=XEnroll.ProviderType
		If 0<>Err.Number Then
			' something wrong with XEnroll
			GetCSPList=Err.Number 
			Exit Function
		End If

		' enumerate through each of the provider types
		For nProvType=0 To nMaxProvType 
			Dim nCSPIndex
			nCSPIndex=0
			XEnroll.ProviderType=nProvType
			
			' enumerate through each of the providers for this type
			Do 
				Dim sProviderName

				'get the name
				sProviderName=XEnroll.enumProviders(nCSPIndex, 0)
				
				If &H80070103=Err.Number Then 
					' no more providers
					Err.Clear
					Exit Do
				ElseIf 0<>Err.Number Then
					' something wrong with XEnroll
					'  - ex, Win16 IE4 XEnroll doesn't support this call.
					GetCSPList=Err.Number 
					Exit Function
				End If
			
				If ("Microsoft Base DSS Cryptographic Provider"=sProviderName And True=bNoDssBase) _
					Or ("Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"=sProviderName And True=bNoDssDh) Then
					' skip this provider
				Else 
					' For each provider, add an element to the list box.
					Dim oOption
					Set oOption=document.createElement("Option")
					oOption.text=sProviderName
					oOption.Value=nProvType
					document.UIForm.lbCSP.add(oOption)
					If InStr(sProviderName, EnhancedCSPString) <> 0 Then
						oOption.selected=True
						nDefaultCSP=nTotCSPs
					End If
					If InStr(sProviderName, BaseCSPString) <> 0 Then
						'just remember the base csp index
						nBaseCSP=nTotCSPs
					End If
					nTotCSPs=nTotCSPs+1
				End If
				
				' get the next provider
				nCSPIndex=nCSPIndex+1
			Loop
		Next
		
		' if there are no CSPs, we're kinda stuck
		If 0=nTotCSPs Then
			Set oElement=document.createElement("Option")
			oElement.text=L_NoCSPs_ErrorMessage
			document.UIForm.lbCSP.Options.Add oElement
		End If

		' remove the 'loading' text
		document.UIForm.lbCSP.remove(0)

		' select the default provider
		If -1 = nDefaultCSP Then
			'no enhanced csp, how about base
			If -1 <> nBaseCSP Then
				'ok, take base csp
				nDefaultCSP=nBaseCSP
			End If
		End If
		If -1<>nDefaultCSP Then
			document.UIForm.lbCSP.selectedIndex=nDefaultCSP
		End If
		If -1 = nDefaultCSP Then
			If 0 < nCSPIndex Then
				'well, best bet is the 1st available one
				document.UIForm.lbCSP.selectedIndex=0
			End If
		End If

		' restore the original provider type
		XEnroll.ProviderType=nOrigProvType

		' set the return value and exit
		If 0<>Err.Number Then
			GetCSPList=Err.Number
		ElseIf 0=nTotCSPs Then
			' signal no elements with -1
			GetCSPList=-1
		Else
			GetCSPList=0
		End If

	End Function

	Function AddCSPToList(sCSP)
		On Error Resume Next
		Dim oOption
		Dim nProviderType

		nProviderType = XEnroll.getProviderType(sCSP)
		If 0=Err.Number Then
			'csp available on the machine
			Set oOption=document.createElement("Option")
			oOption.text=sCSP
			oOption.Value=nProviderType
			document.UIForm.lbCSP.add(oOption)
			If InStr(sCSP, EnhancedCSPString) <> 0 Then
				oOption.selected=True
			End If
		End If
	End Function

</Script>

<%End If '"IE"=sBrowser%>
<%End If 'True=bIncludeGetCspList%>

<%If "IE"=sBrowser Then%>
<%If True=bIncludeTemplateCode Then%>
<Script Language="JavaScript">
	var CTINFO_INDEX_OFFLINE     =0;
	var CTINFO_INDEX_REALNAME    =1;
	var CTINFO_INDEX_KEYSPEC     =2;
	var CTINFO_INDEX_KEYFLAG     =3;
	var CTINFO_INDEX_ENROLLFLAG  =4;
	var CTINFO_INDEX_PRIVATEKEYFLAG  =5;
	var CTINFO_INDEX_SUBJECTFLAG =6;
	var CTINFO_INDEX_RASIGNATURE =7;
	var CTINFO_INDEX_CSPLIST     =8;
	var CTINFO_INDEX_EXTOID      =9;
	var CTINFO_INDEX_EXTMAJ      =10;
	var CTINFO_INDEX_EXTFMIN     =11;
	var CTINFO_INDEX_EXTMIN      =12;
        var CTINFO_INDEX_FRIENDLYNAME=13;

        function getTemplateStringInfo(nIndex, sInTemplate)
        {
		//extract sub string from template string in a format
		//of "substr1;substr2;substr3;substr4;..."
		//";" is the separator, index starts from 0
		var nTemplateIndex, sTemplate;
		if (null == sInTemplate)
		{
			nTemplateIndex=document.UIForm.lbCertTemplate.selectedIndex;
			sTemplate=document.UIForm.lbCertTemplate.options[nTemplateIndex].value;
		}
		else
		{
			sTemplate = sInTemplate;
		}
		var sTemp = sTemplate;
		var n, m, nEnd;
		var fFound = true;

		//find sub-string start location
		for (n = 0; n < nIndex; ++n)
		{
			m = sTemp.indexOf(";");
			if (-1 == m)
			{
				fFound = false;
				break;
			}
			sTemp = sTemp.substr(m+1);
		}

		if (fFound)
		{
			//sTemp starts from the substring, find end index
			nEnd = sTemp.indexOf(";");
			if (-1 != nEnd)
			{
				sTemp = sTemp.substring(0, nEnd);
			}
		}
		else
		{
			sTemp = "";
		}
		return sTemp;
	}


        function updateCSPListFromStrings(sCSPList)
        {
		var n, m, nCSP;
		var L_NoDesiredCSPInstalledMsg = "You need to install the following CSPs before the enrollment, ";
		var L_AndMsg = "and ";
		var sSupportedCSPs = "";

		//remove the current csp list
		var nCSP = document.UIForm.lbCSP.length;
		//note, strange reasons, can't nCSP-1
		for (n = 0; n < nCSP; ++n)
		{
			document.UIForm.lbCSP.remove(0);
		}

		//add to the list
		while (-1 != (m = sCSPList.indexOf("?")))
		{
			//get csp from the list
			sCSP = sCSPList.substring(0, m);
			AddCSPToList(sCSP);
			if ("" == sSupportedCSPs)
			{
				sSupportedCSPs = sCSP;
			}
			else
			{
				sSupportedCSPs = sSupportedCSPs + ", ";
			}
			//move to the next csp
			sCSPList = sCSPList.substring(m+1);
		}
		if ("" != sCSPList)
		{
			//add the last csp
			AddCSPToList(sCSPList);

			if ("" == sSupportedCSPs)
			{
				sSupportedCSPs = sCSPList + ".";
			}
			else
			{
				sSupportedCSPs = sSupportedCSPs + ", " + L_AndMsg + sCSPList + ".";
			}
		}
		if (0 == document.UIForm.lbCSP.length)
		{
			alert(L_NoDesiredCSPInstalledMsg + sSupportedCSPs);
		}
        }

</Script>
<%End If 'True=bIncludeTemplateCode Then%>
<%End If '"IE"=sBrowser%>

<%If "IE"=sBrowser Then
	If True=bIncludeCheckClientCode Then%>
<Script Language="JavaScript">
	//helper to decide downlevel browsers
	function isClientAbleToCreateCMC()
	{
		var sUserAgent = navigator.userAgent;
		var index;

		//check if W2K or newer
		index = sUserAgent.indexOf("Windows NT");
		if (-1 != index)
		{
			if (4 < parseInt(sUserAgent.substring(index+11, index+12)))
			{
				//either w2k or newer
				return true;
			}
		}
		if (-1 != sUserAgent.indexOf("Windows 98; Win 9x"))
		{
			//win ME
			return true;
		}
		return false;
	}

</Script>
<%	End If 'True=bIncludeTemplateCode Then
End If '"IE"=sBrowser%>

<%  ' ########## BEGIN SERVER SIDE EXECUTION ##########

	'-----------------------------------------------------------------
	' Strings To Be Localized
	Const L_Unexpected_ErrorMessage="Unexpected Error"
	Const L_NoTemplates_ErrorMessage="(No templates found!)"

	'-----------------------------------------------------------------
	' SCrdEnrl constants

	' flags for enumCAName, getCAName and setCAName
	Const SCARD_ENROLL_CA_REAL_NAME=0 'default
	Const SCARD_ENROLL_CA_MACHINE_NAME=1
	Const SCARD_ENROLL_CA_DISPLAY_NAME=2
	Const SCARD_ENROLL_CA_UNIQUE_NAME=3 'machineName\displayName

	' flags for getCertTemplateCount and enumCertTemplateName
	Const SCARD_ENROLL_USER_CERT_TEMPLATE=1
	Const SCARD_ENROLL_MACHINE_CERT_TEMPLATE=2
	Const SCARD_ENROLL_ENTERPRISE_CERT_TEMPLATE=&H08
	Const SCARD_ENROLL_OFFLINE_CERT_TEMPLATE=&H10
	Const SCARD_ENROLL_CROSS_CERT_TEMPLATE=&H20

	' flags for enumCertTemplateName, getCertTemplateName and setCertTemplateName
	Const SCARD_ENROLL_CERT_TEMPLATE_REAL_NAME=0 ' default
	Const SCARD_ENROLL_CERT_TEMPLATE_DISPLAY_NAME=4

	'-----------------------------------------------------------------
	' Get the list of Cert templates from SCrdEnr and write them to the web page
	' returns error number, or -1 if no templates
	Function WriteTemplateList()
		On Error Resume Next
		Dim nTest, bAnyElements, SCrdEnrl, bAnyElementsReturn

		'Stop 'debugging breakpoint
		bAnyElements=False

		' create the object
		Set SCrdEnrl=Server.CreateObject("SCrdEnr.SCrdEnr.1")
		' call an easy method to make sure everything is OK
		nTest=SCrdEnrl.CSPCount
		If 0<>Err.Number Then
			' something's wrong with SCrdEnrl
			WriteTemplateError Err.Number
			WriteTemplateList=Err.Number
			Exit Function
		End If

		' first, get the Enterprise (DS-backed) templates
		bAnyElementsReturn=EnumTemplates(SCrdEnrl, SCARD_ENROLL_USER_CERT_TEMPLATE Or SCARD_ENROLL_ENTERPRISE_CERT_TEMPLATE or SCARD_ENROLL_CROSS_CERT_TEMPLATE, "E")
		bAnyElements=bAnyElements Or bAnyElementsReturn

		' Second, get the Offline (non-Enterprise, non-DS-backed) templates
		bAnyElementsReturn=EnumTemplates(SCrdEnrl, SCARD_ENROLL_OFFLINE_CERT_TEMPLATE Or SCARD_ENROLL_CROSS_CERT_TEMPLATE, "O")
		bAnyElements=bAnyElements Or bAnyElementsReturn

		' if there are no templates, we're kinda stuck
		If False=bAnyElements Then
%>
			<Option Value="X"><%=L_NoTemplates_ErrorMessage%></Option>
<%
		End If

		' set the return value and exit
		If 0<>Err.Number Then
			WriteTemplateError Err.Number
			WriteTemplateList=Err.Number
		ElseIf False=bAnyElements Then
			' signal no elements with -1
			WriteTemplateList=-1
		Else
			WriteTemplateList=0
		End If

	End Function

	'-----------------------------------------------------------------
	' write an error message to the web page
	Sub WriteTemplateError(nErrNumber)
%>
			<Option Value="X">(<%=L_Unexpected_ErrorMessage%> 0x<%=HEX(nErrNumber)%>)</Option>
<%
	End Sub
		
	'-----------------------------------------------------------------
	' enumerate the templates the match the given flags and add them to the web page
	Function EnumTemplates(SCrdEnrl, nRequestedTemplateFlags, sPrefix)
		Dim nNumTemplates, sRealName, sDisplayName, nTemplateIndex, nNumCAs, nCAIndex, oElement, bAnyElements
		Dim sKeySpec, sKeyFlags, sCSP, sCSPs, sSubjectFlags, sPrivateKeyFlags, sEnrollmentFlags
		Dim sCTE, sCTEOid, sCTEMajor, sCTEMinor, sCTEMinorFlag, sRASignature
                Const SCARD_CTINFO_KEYSPEC=1
                Const SCARD_CTINFO_KEYFLAGS=2
                Const SCARD_CTINFO_EXT_OID=3
                Const SCARD_CTINFO_EXT_MAJOR=4
                Const SCARD_CTINFO_EXT_MINOR=5
                Const SCARD_CTINFO_EXT_MINOR_FLAG=6
                Const SCARD_CTINFO_SUBJECTFLAG=7
                Const SCARD_CTINFO_CSPLIST_FIRST=8
                Const SCARD_CTINFO_CSPLIST_NEXT=9
                Const SCARD_CTINFO_GENERALFLAGS=10
                Const SCARD_CTINFO_ENROLLMENTFLAGS=11
                Const SCARD_CTINFO_PRIVATEKEYFLAGS=12
                Const SCARD_CTINFO_RA_SIGNATURE=13
		On Error Resume Next

		bAnyElements=False

		' get the number of known templates
		nNumTemplates=SCrdEnrl.getCertTemplateCount(nRequestedTemplateFlags)
		' loop over all the known templates
		For nTemplateIndex=1 To nNumTemplates

			'get the CertTemplate name
			sRealName=SCrdEnrl.enumCertTemplateName(nTemplateIndex-1, nRequestedTemplateFlags Or SCARD_ENROLL_CERT_TEMPLATE_REAL_NAME)
			sDisplayName=SCrdEnrl.enumCertTemplateName(nTemplateIndex-1, nRequestedTemplateFlags Or SCARD_ENROLL_CERT_TEMPLATE_DISPLAY_NAME)

			
			' see it if supported by our CA

			' get the number of CAs that support this template
			nNumCAs=SCrdEnrl.getCACount(sRealName)

			' loop over all of those CAs and see if one is ours
			For nCAIndex=1 To nNumCAs

				' If we find our CA, add this template to the list
				If sServerConfig=SCrdEnrl.enumCAName(nCAIndex-1, SCARD_ENROLL_CA_UNIQUE_NAME, sRealName) Then
					'get template extension info
					'Stop
					sKeySpec = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_KEYSPEC))

					sKeyFlags = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_KEYFLAGS))

					sEnrollmentFlags = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_ENROLLMENTFLAGS))

					'get private key flags
					sPrivateKeyFlags = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_PRIVATEKEYFLAGS))

					sSubjectFlags = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_SUBJECTFLAG))

					'get # of RA signatures
					sRASignature = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_RA_SIGNATURE))

					'get csp list separated by ?
					sCSPs = Empty
					sCSP = SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_CSPLIST_FIRST) 
					While Not IsEmpty(sCSP)
						If IsEmpty(sCSPs) Then
							sCSPs = sCSP
						Else
							sCSPs = sCSPs + "?" + sCSP
						End If
						sCSP = Empty
						sCSP = SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_CSPLIST_NEXT)
					Wend
					'above actually return no more item error so clean up
					Err.Clear

					sCTEOid = SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_EXT_OID)
					If ""=sCTEOid Then
						sCTE=";;;"
					Else
						sCTEMajor = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_EXT_MAJOR))
						sCTEMinorFlag = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_EXT_MINOR_FLAG))
						sCTEMinor = CStr(SCrdEnrl.getCertTemplateInfo(sRealName, SCARD_CTINFO_EXT_MINOR))
						sCTE = sCTEOid & ";" & sCTEMajor & ";" & sCTEMinorFlag & ";" & sCTEMinor
					End If

					' add it to the document
%>
			<Option Value="<%=sPrefix%>;<%=sRealName%>;<%=sKeySpec%>;<%=sKeyFlags%>;<%=sEnrollmentFlags%>;<%=sPrivateKeyFlags%>;<%=sSubjectFlags%>;<%=sRASignature%>;<%=sCSPs%>;<%=sCTE%>;<%=sDisplayName%>"><%=sDisplayName%></Option>
<%
					bAnyElements=True
				End If

			Next ' <- End CA loop

		Next ' <- End known template loop

		' return success
		EnumTemplates=bAnyElements

	End Function

	Function IsUserTemplateAvailable()
		On Error Resume Next
		Dim nTest, nNumCAs, nCAIndex
		Const sUserTemplate="User"

		'init
		IsUserTemplateAvailable = False

		'create the scrdenrl object
		Set SCrdEnrl=Server.CreateObject("SCrdEnr.SCrdEnr.1")
		' call an easy method to make sure everything is OK
		nTest=SCrdEnrl.CSPCount
		If 0<>Err.Number Then
			' something's wrong with SCrdEnrl, just return FALSE
			Exit Function
		End If

		'see if any CA support User template
		nNumCAs=SCrdEnrl.getCACount(sUserTemplate)
		If 0=nNumCAs Then
			'no CA support it
			Exit Function
		End If

		'loop over all of those CAs and see if one is ours
		For nCAIndex=1 To nNumCAs
			' If we find our CA, add this template to the list
			If sServerConfig=SCrdEnrl.enumCAName(nCAIndex-1, SCARD_ENROLL_CA_UNIQUE_NAME, sUserTemplate) Then
				IsUserTemplateAvailable = True
				Exit Function 'found it
			End If
		Next 'CA loop	
	End Function 'IsUserTemplateAvailable

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\module.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

#include "commctrl.h"
#include "module.h"
#include "policy.h"

#include "celib.h"

// ..\inc
#include "listvw.h"

// help ids
#define _CERTPDEF_
#include "cemmchlp.h"

extern HINSTANCE g_hInstance;


STDMETHODIMP
CCertManagePolicyModuleExchange::GetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    UINT uiStr = 0;
    WCHAR const *pwsz = NULL;

    if (NULL == pvarProperty)
    {
        return E_POINTER;
    }
    VariantInit(pvarProperty);

    if (strPropertyName == NULL)
        return S_FALSE;

    if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_NAME))
        uiStr = IDS_MODULE_NAME;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_DESCRIPTION))
	pwsz = g_wszDescription;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_COPYRIGHT))
        uiStr = IDS_MODULE_COPYRIGHT;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_FILEVER))
        uiStr = IDS_MODULE_FILEVER;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_PRODUCTVER))
        uiStr = IDS_MODULE_PRODUCTVER;
    else
        return S_FALSE;

    // load string from resource
    WCHAR szStr[MAX_PATH];

    if (NULL == pwsz)
    {
	LoadString(g_hInstance, uiStr, szStr, ARRAYSIZE(szStr));
	pwsz = szStr;
    }

    pvarProperty->bstrVal = SysAllocString(pwsz);
    if (NULL == pvarProperty->bstrVal)
        return E_OUTOFMEMORY;

    pvarProperty->vt = VT_BSTR;

    return S_OK;
}

STDMETHODIMP
CCertManagePolicyModuleExchange::SetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvalProperty)
{
     if (strPropertyName == NULL)
         return S_FALSE;
     if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_DISPLAY_HWND))
     {
         if (pvalProperty->vt != VT_BSTR)
              return E_INVALIDARG;

         if (SysStringByteLen(pvalProperty->bstrVal) != sizeof(HWND))
              return E_INVALIDARG;

         // the value is stored as bytes in the bstr itself, not the bstr ptr
         m_hWnd = *(HWND*)pvalProperty->bstrVal;
         return S_OK;
     }

     return S_FALSE;
}

INT_PTR CALLBACK WizPage1DlgProc(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam);

INT_PTR CALLBACK WizPage2DlgProc(
  HWND hwnd,
  UINT uMsg,
  WPARAM  wParam,
  LPARAM  lParam);

INT_PTR CALLBACK dlgAddURL(
  HWND hwnd,
  UINT uMsg,
  WPARAM  wParam,
  LPARAM  lParam);

typedef struct _POLICY_CONFIGSTRUCT
{
    const BSTR*  pstrConfig;
    ENUM_CATYPES CAType;
    HKEY         hkeyStorageLocation;
    LONG         Flags;

    DWORD        dwPageModified;
} POLICY_CONFIGSTRUCT, *PPOLICY_CONFIGSTRUCT;

// dwPageModified
#define PAGE1 (0x1)
#define PAGE2 (0x2)


void MessageBoxWarnReboot(HWND hwndDlg)
{
    WCHAR szText[MAX_PATH], szTitle[MAX_PATH];

    LoadString(g_hInstance, IDS_MODULE_NAME, szTitle, ARRAYSIZE(szTitle));
    LoadString(g_hInstance, IDS_WARNING_REBOOT, szText, ARRAYSIZE(szText));
    MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
}

void MessageBoxNoSave(HWND hwndDlg)
{
    WCHAR szText[MAX_PATH], szTitle[MAX_PATH];

    LoadString(g_hInstance, IDS_MODULE_NAME, szTitle, ARRAYSIZE(szTitle));
    LoadString(g_hInstance, IDS_WARNING_NOSAVE, szText, ARRAYSIZE(szText));
    MessageBox(hwndDlg, szText, szTitle, MB_OK|MB_ICONINFORMATION);
}

STDMETHODIMP
CCertManagePolicyModuleExchange::Configure(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags)
{
    HRESULT hr;
    BSTR strName = NULL;
    VARIANT varValue;
    VariantInit(&varValue);

    ICertServerPolicy *pServer = NULL;
    POLICY_CONFIGSTRUCT sConfig = {NULL, ENUM_UNKNOWN_CA, NULL, 0, 0};

    BOOL fLocal;
    LPWSTR szMachine = NULL;
    HKEY hkeyHKLM = NULL;
    DWORD dwDisposition;

    hr = ceIsConfigLocal(strConfig, &szMachine, &fLocal);
    _JumpIfError(hr, Ret, "ceIsConfigLocal");

    // use callbacks for info
    hr = GetServerCallbackInterface(&pServer, 0);    // no context : 0
    _JumpIfError(hr, Ret, "GetServerCallbackInterface");

    // we need to find out who we're running under

    strName = SysAllocString(wszPROPCATYPE);
    if (NULL == strName)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, Ret, "SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strName,
				PROPTYPE_LONG,
				&varValue);
    _JumpIfError(hr, Ret, "GetCertificateProperty : wszPROPCATYPE");

    sConfig.CAType = (ENUM_CATYPES)varValue.lVal;
    VariantClear(&varValue);

    hr = PopulateRegistryDefaults(fLocal? NULL : szMachine, strStorageLocation);
    _PrintIfError(hr, "PopulateRegistryDefaults");

    if (!fLocal)
    {
        hr = RegConnectRegistry(
			szMachine,
			HKEY_LOCAL_MACHINE,
			&hkeyHKLM);
        _JumpIfError(hr, Ret, "RegConnectRegistry");
    }

    // open storage location: write perms if possible
    hr = RegCreateKeyEx(
        fLocal ? HKEY_LOCAL_MACHINE : hkeyHKLM,
        strStorageLocation,
        0,
        NULL,
        0,
        KEY_READ | KEY_WRITE,
        NULL,
        &sConfig.hkeyStorageLocation,
        &dwDisposition);
    if (hr != S_OK)
    {
        hr = RegOpenKeyEx(
            fLocal ? HKEY_LOCAL_MACHINE : hkeyHKLM,
            strStorageLocation,
            0,
            KEY_READ,       // fallback: read-only
            &sConfig.hkeyStorageLocation);
        _JumpIfError(hr, Ret, "RegOpenKeyEx");
    }

    sConfig.pstrConfig = &strConfig;
    sConfig.Flags = dwFlags;


    PROPSHEETPAGE page[2];
    ZeroMemory(&page[0], sizeof(PROPSHEETPAGE));
    page[0].dwSize = sizeof(PROPSHEETPAGE);
    page[0].dwFlags = PSP_DEFAULT;
    page[0].hInstance = g_hInstance;
    page[0].lParam = (LPARAM)&sConfig;

    // make 2nd page exactly the same as this
    CopyMemory(&page[1], &page[0], sizeof(PROPSHEETPAGE));

    // now page1 vs. page2 diffcs
    page[0].pszTemplate = MAKEINTRESOURCE(IDD_POLICYPG1);
    page[0].pfnDlgProc = WizPage1DlgProc;

    page[1].pszTemplate = MAKEINTRESOURCE(IDD_POLICYPG2);
    page[1].pfnDlgProc = WizPage2DlgProc;



    PROPSHEETHEADER sSheet;
    ZeroMemory(&sSheet, sizeof(PROPSHEETHEADER));
    sSheet.dwSize = sizeof(PROPSHEETHEADER);
    sSheet.dwFlags = PSH_PROPSHEETPAGE | PSH_PROPTITLE;
    sSheet.hwndParent = m_hWnd;
    sSheet.pszCaption = MAKEINTRESOURCE(IDS_MODULE_NAME);
    sSheet.nPages = ARRAYSIZE(page);
    sSheet.ppsp = page;


    // finally, invoke the modal sheet
    INT_PTR iRet;
    iRet = ::PropertySheet(&sSheet);

    if ((iRet > 0) && (sConfig.dwPageModified))  // successful modification
    {
        MessageBoxWarnReboot(NULL);
    }

Ret:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    if (sConfig.hkeyStorageLocation)
        RegCloseKey(sConfig.hkeyStorageLocation);

    if (szMachine)
        LocalFree(szMachine);

    if (hkeyHKLM)
        RegCloseKey(hkeyHKLM);

    if (pServer)
        pServer->Release();

    return hr;
}


CERTSVR_URL_PARSING rgPOSSIBLE_CRL_URLs[] =
{
 { L"ldap:", wszREGLDAPREVOCATIONCRLURL_OLD, REVEXT_CDPLDAPURL_OLD | REVEXT_CDPENABLE },
 { L"http:", wszREGREVOCATIONCRLURL_OLD,     REVEXT_CDPHTTPURL_OLD | REVEXT_CDPENABLE },
 { L"ftp:",  wszREGFTPREVOCATIONCRLURL_OLD,  REVEXT_CDPFTPURL_OLD | REVEXT_CDPENABLE },
 { L"file:", wszREGFILEREVOCATIONCRLURL_OLD, REVEXT_CDPFILEURL_OLD | REVEXT_CDPENABLE },
};


CERTSVR_URL_PARSING rgPOSSIBLE_AIA_URLs[] =
{
 { L"ldap:", wszREGLDAPISSUERCERTURL_OLD, ISSCERT_LDAPURL_OLD | ISSCERT_ENABLE},
 { L"http:", wszREGISSUERCERTURL_OLD,     ISSCERT_HTTPURL_OLD | ISSCERT_ENABLE},
 { L"ftp:",  wszREGFTPISSUERCERTURL_OLD,  ISSCERT_FTPURL_OLD | ISSCERT_ENABLE },
 { L"file:", wszREGFILEISSUERCERTURL_OLD, ISSCERT_FILEURL_OLD | ISSCERT_ENABLE},
};


void mySetModified(HWND hwndPage, POLICY_CONFIGSTRUCT* psConfig)
{
    if (psConfig->dwPageModified != 0)
    {
        PropSheet_Changed( ::GetParent(hwndPage), hwndPage);
    }
    else
    {
        PropSheet_UnChanged( ::GetParent(hwndPage), hwndPage);
    }
}

INT_PTR CALLBACK WizPage1DlgProc(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam)
{
    POLICY_CONFIGSTRUCT* psConfig;
    BOOL fReturn = FALSE;
    HRESULT hr;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            PROPSHEETPAGE* ps = (PROPSHEETPAGE *) lParam;
            psConfig = (POLICY_CONFIGSTRUCT*)ps->lParam;

            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)psConfig);

            DWORD dwRequestDisposition, dwType;
            DWORD cbRequestDisposition = sizeof(dwRequestDisposition);
            hr = RegQueryValueEx(
                psConfig->hkeyStorageLocation,
                wszREGREQUESTDISPOSITION,
                0,
                &dwType,
                (PBYTE)&dwRequestDisposition,
                &cbRequestDisposition);
            if ((hr != ERROR_SUCCESS) || (dwType != REG_DWORD))
                break;

            // if disposition includes Issue
            if ((dwRequestDisposition & REQDISP_MASK) == REQDISP_ISSUE)
            {
                // if pending bit set
                if (dwRequestDisposition & REQDISP_PENDINGFIRST)
                    SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_PENDFIRST), BM_SETCHECK, TRUE, BST_CHECKED);
                else
                    SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_ISSUE), BM_SETCHECK, TRUE, BST_CHECKED);
            }

            // disallow "Pend first" if Enterprise (bug #259346)
            if ((psConfig->CAType == ENUM_ENTERPRISE_ROOTCA) ||
                (psConfig->CAType == ENUM_ENTERPRISE_SUBCA))
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_RADIO_PENDFIRST), FALSE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_TEXT_PENDFIRST), FALSE);
            }

            psConfig->dwPageModified &= ~PAGE1; // we're virgin
            mySetModified(hwndDlg, psConfig);

            // no other work to be done
            fReturn = TRUE;
            break;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_POLICYPG1);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_POLICYPG1);
        break;
    }
    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam) -> code)
        {
        case PSN_APPLY:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                if (psConfig->dwPageModified & PAGE1)
                {
                    DWORD dwCheckState, dwRequestDisposition;
                    dwCheckState = (DWORD)SendMessage(GetDlgItem(hwndDlg, IDC_RADIO_ISSUE), BM_GETCHECK, 0, 0);

                    if (dwCheckState == BST_CHECKED)
                        dwRequestDisposition = REQDISP_ISSUE;
                    else
                        dwRequestDisposition = REQDISP_ISSUE | REQDISP_PENDINGFIRST;

                    hr = RegSetValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGREQUESTDISPOSITION,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwRequestDisposition,
                        sizeof(DWORD));
                    if (hr != ERROR_SUCCESS)
                    {
                        MessageBoxNoSave(hwndDlg);
                        psConfig->dwPageModified &= ~PAGE1;
                    }
                }
            }
            break;
        case PSN_RESET:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                psConfig->dwPageModified &= ~PAGE1;
                mySetModified(hwndDlg, psConfig);
            }
            break;
        default:
            break;
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_RADIO_ISSUE:
        case IDC_RADIO_PENDFIRST:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                if (BN_CLICKED == HIWORD(wParam))
                {
                    psConfig->dwPageModified |= PAGE1;
                    mySetModified(hwndDlg, psConfig);
                }
            }
            break;

        default:
            break;
        }
    default:
        break;
    }

    return fReturn;
}


INT_PTR CALLBACK WizPage2DlgProc(
  HWND hwndDlg,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam)
{
    POLICY_CONFIGSTRUCT* psConfig;
    HWND hListView;
    BOOL fCRLSelection= FALSE;
    BOOL fReturn = FALSE;
    HRESULT hr;


    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            ::SetWindowLong(hwndDlg, GWL_EXSTYLE, ::GetWindowLong(hwndDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

            PROPSHEETPAGE* ps = (PROPSHEETPAGE *) lParam;
            psConfig = (POLICY_CONFIGSTRUCT*)ps->lParam;

            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)psConfig);

            DWORD dwAllBits, dwType;
            DWORD cbDWSize=sizeof(dwAllBits);

            LVCOLUMN lvCol;
            lvCol.mask = LVCF_FMT | LVCF_TEXT;
            lvCol.fmt = LVCFMT_LEFT;  // Left-align the column.
            lvCol.pszText = L"";      // The text for the column.

                    // get all extension bits -
                    hr = RegQueryValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGREVOCATIONTYPE,		// CDP
                        0,
                        &dwType,
                        (PBYTE)&dwAllBits,
                        &cbDWSize);
                    _PrintIfError(hr, "RegQueryValueEx");
                    if (dwType != REG_DWORD)
                         dwAllBits = 0;

            // single column defn
            hListView = GetDlgItem(hwndDlg, IDC_CRL_LIST);
            ListView_SetExtendedListViewStyle(hListView, LVS_EX_CHECKBOXES);
            ListView_InsertColumn(hListView, 0, &lvCol);
            hr = PopulateListView(hListView, psConfig->hkeyStorageLocation, rgPOSSIBLE_CRL_URLs, ARRAYSIZE(rgPOSSIBLE_CRL_URLs), dwAllBits);
            _PrintIfError(hr, "PopulateListView");

            // if none, remove <REMOVE> button
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_REMOVE_CRL), (0 != ListView_GetItemCount(hListView)));


                    // get all extension bits -
                    hr = RegQueryValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGISSUERCERTURLFLAGS, 	// AIA
                        0,
                        &dwType,
                        (PBYTE)&dwAllBits,
                        &cbDWSize);
                    _PrintIfError(hr, "RegQueryValueEx");
                    if (dwType != REG_DWORD)
                         dwAllBits = 0;


            hListView = GetDlgItem(hwndDlg, IDC_AIA_LIST);
            ListView_SetExtendedListViewStyle(hListView, LVS_EX_CHECKBOXES);
            ListView_InsertColumn(hListView, 0, &lvCol);
            hr = PopulateListView(hListView, psConfig->hkeyStorageLocation, rgPOSSIBLE_AIA_URLs, ARRAYSIZE(rgPOSSIBLE_AIA_URLs), dwAllBits);
            _PrintIfError(hr, "PopulateListView");

            // if none, remove <REMOVE> button
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_REMOVE_AIA), (0 != ListView_GetItemCount(hListView)));

            psConfig->dwPageModified &= ~PAGE2; // we're virgin
            mySetModified(hwndDlg, psConfig);

            // no other work to be done
            fReturn = TRUE;
            break;
        }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_POLICYPG2);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_POLICYPG2);
        break;
    }
    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam) -> code)
        {
        case PSN_APPLY:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                BOOL fSaveFailed = FALSE;

                if (psConfig->dwPageModified & PAGE2)
                {
                    DWORD dwAllBits;
                    DWORD cbDWSize = sizeof(DWORD);
                    DWORD dwType;

                    fSaveFailed = TRUE; // assume failure

                    hListView = GetDlgItem(hwndDlg, IDC_CRL_LIST);
                    hr = WriteChanges(hListView, psConfig->hkeyStorageLocation, rgPOSSIBLE_CRL_URLs, ARRAYSIZE(rgPOSSIBLE_CRL_URLs));
                    _JumpIfError(hr, saveFailed, "WriteChanges");

                    hListView = GetDlgItem(hwndDlg, IDC_AIA_LIST);
                    hr = WriteChanges(hListView, psConfig->hkeyStorageLocation, rgPOSSIBLE_AIA_URLs, ARRAYSIZE(rgPOSSIBLE_AIA_URLs));
                    _JumpIfError(hr, saveFailed, "WriteChanges");

                    // get all extension bits - CDP
                    hr = RegQueryValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGREVOCATIONTYPE,
                        0,
                        &dwType,
                        (PBYTE)&dwAllBits,
                        &cbDWSize);
                    _PrintIfError(hr, "RegQueryValueEx");
                    if (dwType != REG_DWORD)
                         dwAllBits = 0;

                    // set all extension bits -
                    dwAllBits |= REVEXT_CDPLDAPURL_OLD | REVEXT_CDPHTTPURL_OLD | REVEXT_CDPFTPURL_OLD | REVEXT_CDPFILEURL_OLD | REVEXT_CDPENABLE;
                    hr = RegSetValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGREVOCATIONTYPE,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwAllBits,
                        sizeof(DWORD));
                    _JumpIfError(hr, saveFailed, "RegSetValue");



                    // get all extension bits - AIA
                    hr = RegQueryValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGISSUERCERTURLFLAGS, // AIA
                        0,
                        &dwType,
                        (PBYTE)&dwAllBits,
                        &cbDWSize);
                    _PrintIfError(hr, "RegQueryValueEx");
                    if (dwType != REG_DWORD)
                         dwAllBits = 0;

                    // set all extension bits -
                    dwAllBits |= ISSCERT_LDAPURL_OLD | ISSCERT_HTTPURL_OLD | ISSCERT_FTPURL_OLD| ISSCERT_FILEURL_OLD | ISSCERT_ENABLE;
                    hr = RegSetValueEx(
                        psConfig->hkeyStorageLocation,
                        wszREGISSUERCERTURLFLAGS,   // AIA
                        0,
                        REG_DWORD,
                        (PBYTE)&dwAllBits,
                        sizeof(DWORD));
                    _JumpIfError(hr, saveFailed, "RegSetValue");

                    // got all the way through the save
                    fSaveFailed = FALSE;
                }
saveFailed:
                if (fSaveFailed)
                {
                    MessageBoxNoSave(hwndDlg);
                    psConfig->dwPageModified &= ~PAGE2;
                }
            }
            break;
        case PSN_RESET:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                psConfig->dwPageModified &= ~PAGE2;
                mySetModified(hwndDlg, psConfig);
            }
            break;

        case LVN_ITEMCHANGED:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                // just catch check/uncheck on existing items
                NMLISTVIEW* pParam = (NMLISTVIEW*)lParam;
                if ((pParam != NULL) && (pParam->uChanged & CDIS_CHECKED))
                {
                    psConfig->dwPageModified |= PAGE2;
                    mySetModified(hwndDlg, psConfig);
                }

            }
            break;
        default:
            break;
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_ADD_CRL:
            fCRLSelection = TRUE;
            // fall through
        case IDC_ADD_AIA:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                LPWSTR szNewURL = NULL;

                ADDURL_DIALOGARGS dlgArgs = {
                    fCRLSelection ? rgPOSSIBLE_CRL_URLs : rgPOSSIBLE_AIA_URLs,
                    (DWORD)(fCRLSelection ? ARRAYSIZE(rgPOSSIBLE_CRL_URLs) : ARRAYSIZE(rgPOSSIBLE_AIA_URLs)),
                    &szNewURL};

                if (IDOK != DialogBoxParam(
                    g_hInstance,
                    MAKEINTRESOURCE(IDD_ADDURL),
                    hwndDlg,
                    dlgAddURL,
                    (LPARAM)&dlgArgs))
                    break;

                if (NULL != szNewURL)
                {
                    hListView = GetDlgItem(hwndDlg, fCRLSelection ? IDC_CRL_LIST : IDC_AIA_LIST);

                    AddStringToCheckList(
                        hListView,
                        szNewURL,
                        NULL,
                        TRUE);

                    LocalFree(szNewURL); szNewURL = NULL;

                    // enable <REMOVE> button
                    ::EnableWindow(GetDlgItem(hwndDlg, fCRLSelection ? IDC_REMOVE_CRL : IDC_REMOVE_AIA), TRUE);

                    psConfig->dwPageModified |= PAGE2;
                    mySetModified(hwndDlg, psConfig);
                }

                break;
            }
        case IDC_REMOVE_CRL:
            fCRLSelection = TRUE;
            // fall through
        case IDC_REMOVE_AIA:
            {
                // grab our LParam
                psConfig = (POLICY_CONFIGSTRUCT*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (psConfig == NULL)
                    break;

                hListView = GetDlgItem(hwndDlg, fCRLSelection ? IDC_CRL_LIST : IDC_AIA_LIST);

                int iSel;
                iSel = ListView_GetNextItem(hListView, -1, LVIS_SELECTED);

                // no selected item
                if (-1 == iSel)
                    break;

                ListView_DeleteItem(hListView, iSel);
                ListView_SetColumnWidth(hListView, 0, LVSCW_AUTOSIZE);

                // if none, remove <REMOVE> button
                ::EnableWindow(GetDlgItem(hwndDlg, (fCRLSelection? IDC_REMOVE_CRL : IDC_REMOVE_AIA)), (0 != ListView_GetItemCount(hListView)));

                psConfig->dwPageModified |= PAGE2;
                mySetModified(hwndDlg, psConfig);

                break;
            }

        default:
            break;
        }
    default:
        break;
    }

    return fReturn;
}


// attempt IA5 encoding

HRESULT
IsValidIA5URL(
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    BYTE *pb = NULL;
    DWORD cb;
    CERT_AUTHORITY_INFO_ACCESS caio;
    CERT_ACCESS_DESCRIPTION cad;

    caio.cAccDescr = 1;
    caio.rgAccDescr = &cad;

    cad.pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    cad.AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    cad.AccessLocation.pwszURL = const_cast<WCHAR *>(pwszURL);

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_AUTHORITY_INFO_ACCESS,
		    &caio,
		    0,
		    FALSE,
		    &pb,
		    &cb))
    {
	hr = ceHLastError();
	_JumpIfError(hr, error, "ceEncodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


INT_PTR CALLBACK dlgAddURL(
  HWND hwnd,
  UINT uMsg,
  WPARAM  wParam,
  LPARAM  lParam)
{
    BOOL fReturn = FALSE;
    LPWSTR* pszNewURL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
    {
        ::SetWindowLong(hwnd, GWL_EXSTYLE, ::GetWindowLong(hwnd, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);

        // stash the ADDURL_DIALOGARGS* we were given

        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lParam);
        break;
    }
    case WM_HELP:
    {
        OnDialogHelp((LPHELPINFO) lParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_ADDURL);
        break;
    }
    case WM_CONTEXTMENU:
    {
        OnDialogContextHelp((HWND)wParam, CERTMMC_HELPFILENAME, g_aHelpIDs_IDD_ADDURL);
        break;
    }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        {
            ADDURL_DIALOGARGS* pArgs;

            // snatch the ADDURL_DIALOGARGS* we were given
            pArgs = (ADDURL_DIALOGARGS*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (pArgs == NULL)
                break;

            WCHAR rgszURL[2*MAX_PATH];
            if (0 != GetDlgItemText(hwnd, IDC_EDITURL, rgszURL, (2*MAX_PATH)) )
            {
                if (-1 == DetermineURLType(
                    pArgs->rgAllowedURLs,
                    pArgs->cAllowedURLs,
                    rgszURL))
                {
                    // not found; bail with message
                    WCHAR szMsg[MAX_PATH*2];
                    LoadString(g_hInstance, IDS_INVALID_PREFIX, szMsg, ARRAYSIZE(szMsg));
                    for(DWORD dw=0; dw<pArgs->cAllowedURLs; dw++)
                    {
                        wcscat(szMsg, L"\n");
                        wcscat(szMsg, pArgs->rgAllowedURLs[dw].szKnownPrefix);
                    }
                    MessageBox(hwnd, szMsg, NULL, MB_OK);
                    return FALSE;
                }

                DWORD chBadBegin, chBadEnd;
                if (S_OK != ValidateTokens(
                        rgszURL,
                        &chBadBegin,
                        &chBadEnd))
                {
                    // not found; bail with message
                    WCHAR szMsg[MAX_PATH*2];
                    LoadString(g_hInstance, IDS_INVALID_TOKEN, szMsg, ARRAYSIZE(szMsg));
                    MessageBox(hwnd, szMsg, NULL, MB_OK);

                    // set selection starting from where validation failed
                    SendMessage(GetDlgItem(hwnd, IDC_EDITURL), EM_SETSEL, chBadBegin, chBadEnd);
                    return FALSE;
                }

                if (S_OK != IsValidIA5URL(rgszURL))
                {
                    // encoding error; bail with message
                    WCHAR szMsg[MAX_PATH*2];
                    LoadString(g_hInstance, IDS_INVALID_ENCODING, szMsg, ARRAYSIZE(szMsg));
                    MessageBox(hwnd, szMsg, NULL, MB_OK);

                    // set selection starting from where validation failed
                    SendMessage(GetDlgItem(hwnd, IDC_EDITURL), EM_SETSEL,  -1, -1);
                    return FALSE;
                }

                *(pArgs->ppszNewURL) = (LPWSTR) LocalAlloc(LMEM_FIXED, (wcslen(rgszURL)+1)*sizeof(WCHAR));
                if(*(pArgs->ppszNewURL) == NULL)
                {
                   return FALSE;
                }
                wcscpy(*(pArgs->ppszNewURL), rgszURL);
            }
        }
        // fall through for cleanup
        case IDCANCEL:
            EndDialog(hwnd, LOWORD(wParam));
            break;
        default:
            break;
        }

    default:
        break;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\module.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.h
//
// Contents:    CCertManagePolicyModuleExchange definition
//
//---------------------------------------------------------------------------

#include "expolicy.h"
#include "resource.h"       // main symbols


class CCertManagePolicyModuleExchange: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTPOLICYEXCHANGELib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManagePolicyModuleExchange, &CLSID_CCertManagePolicyModuleExchange>
{
public:
    CCertManagePolicyModuleExchange() {}
    ~CCertManagePolicyModuleExchange() {}

BEGIN_COM_MAP(CCertManagePolicyModuleExchange)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManagePolicyModuleExchange) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// UNDONE UNDONE
DECLARE_REGISTRY(
    CCertManagePolicyModuleExchange,
    wszCLASS_CERTMANAGEEXCHANGE TEXT(".1"),
    wszCLASS_CERTMANAGEEXCHANGE,
    IDS_CERTMANAGEPOLICYMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:
    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);
        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);
private:
    HWND m_hWnd;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\listvw.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       listvw.h
//
//--------------------------------------------------------------------------

typedef struct _CERTSVR_URL_PARSING
{
    LPWSTR szKnownPrefix;
    LPWSTR szRegEntries;
    DWORD  dwEnableFlag;
} CERTSVR_URL_PARSING, *PCERTSVR_URL_PARSING;

typedef struct _ADDURL_DIALOGARGS
{
    CERTSVR_URL_PARSING* rgAllowedURLs;
    DWORD cAllowedURLs;
    LPWSTR* ppszNewURL;
} ADDURL_DIALOGARGS, *PADDURL_DIALOGARGS;

DWORD DetermineURLType(
                    PCERTSVR_URL_PARSING prgURLParsing, 
                    int cURLParsingEntries, 
                    LPCWSTR szCandidateURL);

void AddStringToCheckList(
                    HWND            hWndListView,
                    LPCWSTR         szText, 
                    LPVOID          pvData,
                    BOOL            fCheck);


HRESULT WriteChanges(
                    HWND hListView, 
                    HKEY hkeyStorage, 
                    PCERTSVR_URL_PARSING prgURLParsing, 
                    DWORD cURLParsingEntries);

HRESULT PopulateListView(
                    HWND hListView, 
                    HKEY hkeyStorage, 
                    PCERTSVR_URL_PARSING prgURLParsing, 
                    DWORD cURLParsingEntries,
                    DWORD dwEnableFlags);

HRESULT ValidateTokens(
                    IN OUT LPWSTR szURL,
                    OUT DWORD* pchBadBegin,
                    OUT DWORD* pchBadEnd);

// help is embedded in certmmc.hlp

BOOL OnDialogHelp(LPHELPINFO pHelpInfo, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
BOOL OnDialogContextHelp(HWND hWnd, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\atl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       atl.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp: source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\$(TARGETNAME).res:	$(O)\$(TARGETNAME).tlb

SOURCE_DIR=..\..\celib

$(NTTARGETFILE0):	$(SOURCE_DIR)\$(@F)
    copy $(SOURCE_DIR)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#include <windows.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>

#define wszCLASS_CERTPOLICYEXCHANGEPREFIX TEXT("CertificateAuthority_MicrosoftExchange55") 

#define wszCLASS_CERTPOLICYEXCHANGE wszCLASS_CERTPOLICYEXCHANGEPREFIX  wszCERTPOLICYMODULE_POSTFIX

#define wszCLASS_CERTMANAGEEXCHANGE wszCLASS_CERTPOLICYEXCHANGEPREFIX wszCERTMANAGEPOLICY_POSTFIX

#define wsz_SAMPLE_NAME           L"ExPolicy.dll"
#define wsz_SAMPLE_DESCRIPTION    L"Exchange 5.5 Policy Module for Windows 2000"
#define wsz_SAMPLE_COPYRIGHT      L"(c)1999 Microsoft"
#define wsz_SAMPLE_FILEVER        L"v 1.0"
#define wsz_SAMPLE_PRODUCTVER     L"v 5.00"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by expolicy.rc
//

#define IDS_CERTPOLICY_DESC             1
#define IDS_CERTMANAGEPOLICYMODULE_DESC 2

#define IDS_MODULE_NAME                 101
#define IDS_MODULE_COPYRIGHT            102
#define IDS_MODULE_FILEVER              103
#define IDS_MODULE_PRODUCTVER           104
#define IDS_WARNING_REBOOT              105
#define IDS_WARNING_NOSAVE              106
#define IDS_INVALID_PREFIX              107
#define IDS_INVALID_TOKEN               108
#define IDS_INVALID_ENCODING            109

#define IDC_RADIO_ISSUE                 201
#define IDC_EDITURL                     202
#define IDC_ADD_CRL                     203
#define IDC_REMOVE_CRL                  204
#define IDC_ADD_AIA                     205
#define IDC_REMOVE_AIA                  206
#define IDC_TEXT_PENDFIRST              207
#define IDC_RADIO_PENDFIRST             208
#define IDC_CRL_LIST                    209
#define IDC_AIA_LIST                    210

#define IDD_ADDURL                      301
#define IDD_POLICYPG1                   302
#define IDD_POLICYPG2                   303

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         206
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\policy.h ===
// policy.h: Declaration of CCertPolicyExchange


#include "expolicy.h"
#include "resource.h"       // main symbols

#ifndef __BSTRC__DEFINED__
#define __BSTRC__DEFINED__
typedef OLECHAR const *BSTRC;
#endif

extern const WCHAR g_wszDescription[];

/////////////////////////////////////////////////////////////////////////////
// certpol

HRESULT
GetServerCallbackInterface(
    OUT ICertServerPolicy **ppServer,
    IN LONG Context);

HRESULT
PopulateRegistryDefaults(
    OPTIONAL IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszStorageLocation);

class CCertPolicyExchange: 
    public CComDualImpl<ICertPolicy2, &IID_ICertPolicy2, &LIBID_CERTPOLICYEXCHANGELib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertPolicyExchange, &CLSID_CCertPolicyExchange>
{
public:
    CCertPolicyExchange()
    {
        // RevocationExtension variables:

	m_dwRevocationFlags = 0;
	m_cCDPRevocationURL = 0;
	m_ppwszCDPRevocationURL = NULL;
	m_pwszASPRevocationURL = NULL;

	// AuthorityInfoAccessExtension variables:

        m_dwIssuerCertURLFlags = 0;
        m_cIssuerCertURL = 0;
	m_ppwszIssuerCertURL = NULL;

	m_bstrMachineDNSName = NULL;
	m_bstrCASanitizedName = NULL;
        m_pwszRegStorageLoc = NULL;
    }
    ~CCertPolicyExchange();

BEGIN_COM_MAP(CCertPolicyExchange)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertPolicy)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertPolicyExchange) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertPolicyExchange,
    wszCLASS_CERTPOLICYEXCHANGE TEXT(".1"),
    wszCLASS_CERTPOLICYEXCHANGE,
    IDS_CERTPOLICY_DESC,
    THREADFLAGS_BOTH)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ICertPolicy
public:
    STDMETHOD(Initialize)( 
	    /* [in] */ BSTR const strConfig);

    STDMETHOD(VerifyRequest)( 
	    /* [in] */ BSTR const strConfig,
	    /* [in] */ LONG Context,
	    /* [in] */ LONG bNewRequest,
	    /* [in] */ LONG Flags,
	    /* [out, retval] */ LONG __RPC_FAR *pDisposition);

    STDMETHOD(GetDescription)( 
	    /* [out, retval] */ BSTR __RPC_FAR *pstrDescription);

    STDMETHOD(ShutDown)();

// ICertPolicy2
public:
    STDMETHOD(GetManageModule)(
                /* [out, retval] */ ICertManageModule **ppManageModule);

private:
    VOID _Cleanup();

#if DBG_CERTSRV
    VOID _DumpStringArray(
		IN char const *pszType,
		IN DWORD cpwsz,
		IN WCHAR const * const *ppwsz);
#else
    #define _DumpStringArray(pszType, cpwsz, ppwsz)
#endif

    VOID _FreeStringArray(
		IN OUT DWORD *pcString,
		IN OUT WCHAR ***pppwsz);

    HRESULT _AddStringArray(
		IN WCHAR const *pwszzValue,
		IN BOOL fURL,
		IN OUT DWORD *pcStrings,
		IN OUT WCHAR ***pppwszRegValues);

    HRESULT _ReadRegistryString(
		IN HKEY hkey,
		IN BOOL fURL,
		IN WCHAR const *pwszRegName,
		IN WCHAR const *pwszSuffix,
		OUT WCHAR **pwszRegValue);

    HRESULT _ReadRegistryStringArray(
		IN HKEY hkey,
		IN BOOL fURL,
		IN DWORD dwFlags,
		IN DWORD cRegNames,
		IN DWORD *aFlags,
		IN WCHAR const * const *ppwszRegNames,
		IN OUT DWORD *pcStrings,
		IN OUT WCHAR ***pppwszRegValues);

    VOID _InitRevocationExtension(
		IN HKEY hkey);

    VOID _InitAuthorityInfoAccessExtension(
		IN HKEY hkey);

    HRESULT _AddIssuerAltName2Extension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddSubjectAltName2Extension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddRevocationExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddAuthorityInfoAccessExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddKeyUsageExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddEnhancedKeyUsageExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddSpecialAltNameExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddBasicConstraintsExtension(
                IN ICertServerPolicy *pServer);

private:
    // Add local variables here!

    // RevocationExtension variables:

    DWORD   m_dwRevocationFlags;
    DWORD   m_cCDPRevocationURL;
    WCHAR **m_ppwszCDPRevocationURL;
    WCHAR  *m_pwszASPRevocationURL;

    // AuthorityInfoAccessExtension variables:

    DWORD   m_dwIssuerCertURLFlags;
    DWORD   m_cIssuerCertURL;
    WCHAR **m_ppwszIssuerCertURL;

    BSTR    m_bstrMachineDNSName;
    BSTR    m_bstrCASanitizedName;
    WCHAR  *m_pwszRegStorageLoc;

    DWORD   m_iCert;
    DWORD   m_iCRL;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\certpsam.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certpsam.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "celib.h"
#include "policy.h"
#include "module.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertPolicySample, CCertPolicySample)
    OBJECT_ENTRY(CLSID_CCertManagePolicyModuleSample, CCertManagePolicyModuleSample)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return(_Module.GetClassObject(rclsid, riid, ppv));
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}


void __RPC_FAR *__RPC_USER
MIDL_user_allocate(size_t cb)
{
    return(LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb));
}


void __RPC_USER
MIDL_user_free(void __RPC_FAR *pb)
{
    LocalFree(pb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\expolicy\policy.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// copied from K2 SDK policy.cpp.
// modified by GregKr for expolicy.
//
// File:        expolicy.cpp
//
// Contents:    KMS-specific Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "policy.h"
#include "celib.h"
//#include "newcert.h"
#include <assert.h>

#include <exver.h>      // Exchange build version (rmj et al)
#include <kmsattr.h>    // strings used by both KMS and ExPolicy

#ifndef DBG_CERTSRV
#error -- DBG_CERTSRV not defined!
#endif

BOOL fDebug = DBG_CERTSRV;

#if DBG_CERTSRV
#define EXP_FLAVOR  L" debug"
#else
#define EXP_FLAVOR
#endif

#define MAKEFILEVERSION(_rmaj, _rmin, _bmaj, _bmin)         \
        L#_rmaj L"." L#_rmin L"." L#_bmaj L"." L#_bmin EXP_FLAVOR

#define MAKE_FILEVERSION_STR(_rmaj, _rmin, _bmaj, _bmin)	\
        MAKEFILEVERSION(_rmaj, _rmin, _bmaj, _bmin)

#define VER_FILEVERSION_STR				                    \
        MAKE_FILEVERSION_STR(rmj, rmn, rmm, rup)

const WCHAR g_wszDescription[] =
    L"Microsoft Exchange KMServer Policy Module " VER_FILEVERSION_STR;


// worker
HRESULT
GetServerCallbackInterface(
    OUT ICertServerPolicy **ppServer,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL == ppServer)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    hr = CoCreateInstance(
                    CLSID_CCertServerPolicy,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertServerPolicy,
                    (VOID **) ppServer);
    _JumpIfError(hr, error, "CoCreateInstance");

    if (*ppServer == NULL)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "NULL *ppServer");
    }

    // only set context if nonzero
    if (0 != Context)
    {
        hr = (*ppServer)->SetContext(Context);
        _JumpIfError(hr, error, "Policy:SetContext");
    }

error:
    return(hr);
}


WCHAR const * const s_rgpwszRegMultiStrValues[] =
{
    wszREGLDAPISSUERCERTURL_OLD,
    wszREGISSUERCERTURL_OLD,
    wszREGFTPISSUERCERTURL_OLD,
    wszREGFILEISSUERCERTURL_OLD,
    wszREGLDAPREVOCATIONCRLURL_OLD,
    wszREGREVOCATIONCRLURL_OLD,
    wszREGFTPREVOCATIONCRLURL_OLD,
    wszREGFILEREVOCATIONCRLURL_OLD,
};


typedef struct _REGDWORDVALUE
{
    WCHAR const *pwszName;
    DWORD        dwValueDefault;
} REGDWORDVALUE;

const REGDWORDVALUE s_rgRegDWordValues[] =
{
    {
	wszREGREQUESTDISPOSITION,
	REQDISP_ISSUE
    },
    {
	wszREGISSUERCERTURLFLAGS,
	ISSCERT_ENABLE |
	    ISSCERT_LDAPURL_OLD |
	    ISSCERT_HTTPURL_OLD |
	    ISSCERT_FTPURL_OLD |
	    ISSCERT_FILEURL_OLD
    },
    {
	wszREGREVOCATIONTYPE,
	REVEXT_CDPENABLE |
	    REVEXT_CDPLDAPURL_OLD |
	    REVEXT_CDPHTTPURL_OLD |
	    REVEXT_CDPFTPURL_OLD |
	    REVEXT_CDPFILEURL_OLD
    },
};


HRESULT
CopyMultiStrRegValue(
    IN HKEY hkeySrc,
    IN HKEY hkeyDest,
    IN WCHAR const *pwszName)
{
    HRESULT hr;
    DWORD cbValue;
    DWORD dwType;
    WCHAR *pwszzAlloc = NULL;
    WCHAR *pwszzValue;

    hr = RegQueryValueEx(hkeyDest, pwszName, NULL, &dwType, NULL, &cbValue);
    if (S_OK == hr && REG_MULTI_SZ == dwType)
    {
	goto error;	// preserve existing value
    }

    hr = RegQueryValueEx(hkeySrc, pwszName, NULL, &dwType, NULL, &cbValue);
    if (S_OK == hr && REG_MULTI_SZ == dwType && sizeof(WCHAR) < cbValue)
    {
	pwszzAlloc = (WCHAR *) LocalAlloc(LMEM_FIXED, cbValue);
	if (NULL == pwszzAlloc)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	hr = RegQueryValueEx(
			hkeySrc,
			pwszName,
			NULL,
			&dwType,
			(BYTE *) pwszzAlloc,
			&cbValue);
	_JumpIfError(hr, error, "RegQueryValueEx");

	pwszzValue = pwszzAlloc;
    }
    else
    {
	pwszzValue = L"\0";
	cbValue = 2 * sizeof(WCHAR);
    }

    hr = RegSetValueEx(
		    hkeyDest,
		    pwszName,
		    NULL,
		    REG_MULTI_SZ,
		    (BYTE const *) pwszzValue,
		    cbValue);
    _JumpIfError(hr, error, "RegSetValueEx");

error:
    if (NULL != pwszzAlloc)
    {
        LocalFree(pwszzAlloc);
    }
    return(ceHError(hr));
}


HRESULT
CopyDWordRegValue(
    IN HKEY hkeySrc,
    IN HKEY hkeyDest,
    IN REGDWORDVALUE const *prdv)
{
    HRESULT hr;
    DWORD cbValue;
    DWORD dwType;
    DWORD dwValue;

    hr = RegQueryValueEx(hkeyDest, prdv->pwszName, NULL, &dwType, NULL, &cbValue);
    if (S_OK == hr && REG_DWORD == dwType)
    {
	goto error;	// preserve existing value
    }

    cbValue = sizeof(dwValue);
    hr = RegQueryValueEx(
		    hkeySrc,
		    prdv->pwszName,
		    NULL,
		    &dwType,
		    (BYTE *) &dwValue,
		    &cbValue);
    if (S_OK != hr || REG_DWORD != dwType || sizeof(dwValue) != cbValue)
    {
	dwValue = prdv->dwValueDefault;
    }

    hr = RegSetValueEx(
		    hkeyDest,
		    prdv->pwszName,
		    NULL,
		    REG_DWORD,
		    (BYTE const *) &dwValue,
		    sizeof(dwValue));
    _JumpIfError(hr, error, "RegSetValueEx");

error:
    return(ceHError(hr));
}


HRESULT
PopulateRegistryDefaults(
    OPTIONAL IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszStorageLocation)
{
    HRESULT hr;
    HRESULT hr2;
    HKEY hkeyHKLM = NULL;
    HKEY hkeyDest = NULL;
    HKEY hkeySrc = NULL;
    DWORD dwDisposition;
    WCHAR const *pwsz;
    WCHAR *pwszSrc = NULL;
    DWORD cwcPrefix;
    DWORD cwc;
    DWORD i;

    DBGPRINT((TRUE, "pwszDest: '%ws'\n", pwszStorageLocation));
    pwsz = wcsrchr(pwszStorageLocation, L'\\');
    if (NULL == pwsz)
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "Invalid registry path");
    }
    pwsz++;
    cwcPrefix = SAFE_SUBTRACT_POINTERS(pwsz, pwszStorageLocation);
    cwc = cwcPrefix + WSZARRAYSIZE(wszCLASS_CERTPOLICY);
    pwszSrc = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszSrc)
    {
	hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszSrc, pwszStorageLocation, cwcPrefix * sizeof(WCHAR));
    wcscpy(&pwszSrc[cwcPrefix], wszCLASS_CERTPOLICY);
    assert(wcslen(pwszSrc) == cwc);

    DBGPRINT((TRUE, "pwszSrc: '%ws'\n", pwszSrc));

    if (NULL != pwszMachine)
    {
        hr = RegConnectRegistry(
			pwszMachine,
			HKEY_LOCAL_MACHINE,
			&hkeyHKLM);
        _JumpIfError(hr, error, "RegConnectRegistry");
    }

    // open destination storage location for write

    hr = RegCreateKeyEx(
		NULL == pwszMachine? HKEY_LOCAL_MACHINE : hkeyHKLM,
		pwszStorageLocation,
		0,
		NULL,
		0,
		KEY_READ | KEY_WRITE,
		NULL,
		&hkeyDest,
		&dwDisposition);
    if (hr != S_OK)
    {
        _JumpError(hr, error, "RegOpenKeyEx");
    }

    // open source storage location for read

    hr = RegOpenKeyEx(
		NULL == pwszMachine? HKEY_LOCAL_MACHINE : hkeyHKLM,
		pwszSrc,
		0,
		KEY_READ,
		&hkeySrc);
    _JumpIfError(hr, error, "RegOpenKeyEx");

    hr = S_OK;
    for (i = 0; i < ARRAYSIZE(s_rgpwszRegMultiStrValues); i++)
    {
	hr2 = CopyMultiStrRegValue(
			hkeySrc,
			hkeyDest,
			s_rgpwszRegMultiStrValues[i]);
	if (S_OK != hr2)
	{
	    _PrintErrorStr(
			hr2,
			"CopyMultiStrRegValue",
			s_rgpwszRegMultiStrValues[i]);
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }

    for (i = 0; i < ARRAYSIZE(s_rgRegDWordValues); i++)
    {
	hr2 = CopyDWordRegValue(
			hkeySrc,
			hkeyDest,
			&s_rgRegDWordValues[i]);
	if (S_OK != hr2)
	{
	    _PrintErrorStr(
			hr2,
			"CopyDWordRegValue",
			s_rgRegDWordValues[i].pwszName);
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }


error:
    if (NULL != pwszSrc)
    {
        LocalFree(pwszSrc);
    }
    if (NULL != hkeyHKLM)
    {
        RegCloseKey(hkeyHKLM);
    }
    if (NULL != hkeyDest)
    {
        RegCloseKey(hkeyDest);
    }
    if (NULL != hkeySrc)
    {
        RegCloseKey(hkeySrc);
    }
    return(ceHError(hr));
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::~CCertPolicyExchange -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertPolicyExchange::~CCertPolicyExchange()
{
    _Cleanup();
}


VOID
CCertPolicyExchange::_FreeStringArray(
    IN OUT DWORD *pcString,
    IN OUT LPWSTR **papstr)
{
    BSTR *apstr = *papstr;
    DWORD i;

    if (NULL != apstr)
    {
        for (i = *pcString; i-- > 0; )
        {
            if (NULL != apstr[i])
            {
                DBGPRINT((fDebug, "_FreeStringArray[%u]: '%ws'\n", i, apstr[i]));
                LocalFree(apstr[i]);
            }
        }
        LocalFree(apstr);
        *papstr = NULL;
    }
    *pcString = 0;
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_Cleanup -- free memory associated with this instance
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertPolicyExchange::_Cleanup()
{
    // RevocationExtension variables:

    _FreeStringArray(&m_cCDPRevocationURL, &m_ppwszCDPRevocationURL);

    if (NULL != m_pwszASPRevocationURL)
    {
        LocalFree(m_pwszASPRevocationURL);
    	m_pwszASPRevocationURL = NULL;
    }

    // AuthorityInfoAccessExtension variables:

    _FreeStringArray(&m_cIssuerCertURL, &m_ppwszIssuerCertURL);

    if (NULL != m_bstrMachineDNSName)
    {
        SysFreeString(m_bstrMachineDNSName);
        m_bstrMachineDNSName = NULL;
    }
    if (NULL != m_bstrCASanitizedName)
    {
        SysFreeString(m_bstrCASanitizedName);
        m_bstrCASanitizedName = NULL;
    }
}


HRESULT
CCertPolicyExchange::_ReadRegistryString(
    IN HKEY hkey,
    IN BOOL fURL,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszSuffix,
    OUT LPWSTR *ppwszOut)
{
    HRESULT hr;
    WCHAR *pwszRegValue = NULL;
    DWORD cbValue;
    DWORD dwType;

    *ppwszOut = NULL;
    hr = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,           // lpdwReserved
		    &dwType,
		    NULL,
		    &cbValue);
    _JumpIfErrorStr2(hr, error, "RegQueryValueEx", pwszRegName, ERROR_FILE_NOT_FOUND);

    if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpErrorStr(hr, error, "RegQueryValueEx TYPE", pwszRegName);
    }
    if (NULL != pwszSuffix)
    {
	cbValue += wcslen(pwszSuffix) * sizeof(WCHAR);
    }
    pwszRegValue = (WCHAR *) LocalAlloc(LMEM_FIXED, cbValue + sizeof(WCHAR));
    if (NULL == pwszRegValue)
    {
        hr = E_OUTOFMEMORY;
        _JumpErrorStr(hr, error, "LocalAlloc", pwszRegName);
    }
    hr = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,           // lpdwReserved
		    &dwType,
		    (BYTE *) pwszRegValue,
		    &cbValue);
    _JumpIfErrorStr(hr, error, "RegQueryValueEx", pwszRegName);

    // Handle malformed registry values cleanly:

    pwszRegValue[cbValue / sizeof(WCHAR)] = L'\0';
    if (NULL != pwszSuffix)
    {
	wcscat(pwszRegValue, pwszSuffix);
    }

    hr = ceFormatCertsrvStringArray(
			fURL,			// fURL
			m_bstrMachineDNSName, 	// pwszServerName_p1_2
			m_bstrCASanitizedName,	// pwszSanitizedName_p3_7
			m_iCert,		// iCert_p4
			MAXDWORD,		// iCertTarget_p4
			L"",			// pwszDomainDN_p5
			L"", 			// pwszConfigDN_p6
			m_iCRL,			// iCRL_p8
			FALSE,			// fDeltaCRL_p9,
			FALSE,			// fDSAttrib_p10_11,
			1,       		// cStrings
			(LPCWSTR *) &pwszRegValue, // apwszStringsIn
			ppwszOut);		// apwszStringsOut
    _JumpIfError(hr, error, "ceFormatCertsrvStringArray");

error:
    if (NULL != pwszRegValue)
    {
        LocalFree(pwszRegValue);
    }
    return(ceHError(hr));
}


#if DBG_CERTSRV

VOID
CCertPolicyExchange::_DumpStringArray(
    IN char const *pszType,
    IN DWORD cpwsz,
    IN WCHAR const * const *ppwsz)
{
    DWORD i;
    WCHAR const *pwszName;

    for (i = 0; i < cpwsz; i++)
    {
	pwszName = L"";
	if (iswdigit(ppwsz[i][0]))
	{
	    pwszName = ceGetOIDName(ppwsz[i]);	// Static: do not free!
	}
	DBGPRINT((
		fDebug,
		"%hs[%u]: %ws%hs%ws\n",
		pszType,
		i,
		ppwsz[i],
		L'\0' != *pwszName? " -- " : "",
		pwszName));
    }
}
#endif // DBG_CERTSRV




HRESULT
CCertPolicyExchange::_AddStringArray(
    IN WCHAR const *pwszzValue,
    IN BOOL fURL,
    IN OUT DWORD *pcStrings,
    IN OUT LPWSTR **papstrRegValues)
{
    HRESULT hr = S_OK;
    DWORD cString = 0;
    WCHAR const *pwsz;


    LPCWSTR *awszFormatStrings = NULL;
    LPWSTR *awszOutputStrings = NULL;


    // Count the number of strings we're adding
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        cString++;
    }
    if (0 == cString)		// no strings
    {
        goto error;
    }
    awszFormatStrings = (LPCWSTR *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cString * sizeof(LPWSTR));
    if (NULL == awszFormatStrings)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    cString = 0;
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        // Skip strings that start with a an unescaped minus sign.
        // Strings with an escaped minus sign (2 minus signs) are not skipped.

        if (L'-' == *pwsz)
        {
	    pwsz++;
	    if (L'-' != *pwsz)
	    {
                continue;
	    }
        }
        awszFormatStrings[cString++] = pwsz;
    }

    // if no strings to add, don't modify 
    if (cString > 0)
    {
        awszOutputStrings = (LPWSTR *) LocalAlloc(
			        LMEM_FIXED | LMEM_ZEROINIT,
			        (cString + *pcStrings)  * sizeof(LPWSTR));
        if (NULL == awszOutputStrings)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        if (0 != *pcStrings)
        {
            assert(NULL != *papstrRegValues);
            CopyMemory(awszOutputStrings, *papstrRegValues, *pcStrings * sizeof(LPWSTR));
        }

        hr = ceFormatCertsrvStringArray(
			fURL,			// fURL
			m_bstrMachineDNSName,	// pwszServerName_p1_2
			m_bstrCASanitizedName,	// pwszSanitizedName_p3_7
			m_iCert,		// iCert_p4
			MAXDWORD,		// iCertTarget_p4
			L"",			// pwszDomainDN_p5
			L"",			// pwszConfigDN_p6
			m_iCRL,			// iCRL_p8
			FALSE,			// fDeltaCRL_p9,
			FALSE,			// fDSAttrib_p10_11,
			cString,		// cStrings
			awszFormatStrings,	// apwszStringsIn
			&awszOutputStrings[*pcStrings]); // apwszStringsOut
        _JumpIfError(hr, error, "ceFormatCertsrvStringArray");

        *pcStrings = (*pcStrings) + cString;
        if (*papstrRegValues)
        {
            LocalFree(*papstrRegValues);
        }
        *papstrRegValues = awszOutputStrings;
        awszOutputStrings = NULL;
    }

error:

    if (awszOutputStrings)
    {
        LocalFree(awszOutputStrings);
    }
    if (awszFormatStrings)
    {
        LocalFree(awszFormatStrings);
    }
    return(ceHError(hr));
}


HRESULT
CCertPolicyExchange::_ReadRegistryStringArray(
    IN HKEY hkey,
    IN BOOL fURL,
    IN DWORD dwFlags,
    IN DWORD cRegNames,
    IN DWORD *aFlags,
    IN WCHAR const * const *apwszRegNames,
    IN OUT DWORD *pcStrings,
    IN OUT LPWSTR **papstrRegValues)
{
    HRESULT hr;
    DWORD i;
    WCHAR *pwszzValue = NULL;
    DWORD cbValue;
    DWORD dwType;

    for (i = 0; i < cRegNames; i++)
    {
        if (0 == (dwFlags & aFlags[i]))
        {
	    continue;
        }
        if (NULL != pwszzValue)
        {
	    LocalFree(pwszzValue);
	    pwszzValue = NULL;
        }
        hr = RegQueryValueEx(
		        hkey,
		        apwszRegNames[i],
		        NULL,           // lpdwReserved
		        &dwType,
		        NULL,
		        &cbValue);
        if (S_OK != hr)
        {
	    _PrintErrorStr2(hr, "RegQueryValueEx", apwszRegNames[i], ERROR_FILE_NOT_FOUND);
	    continue;
        }
        if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _PrintErrorStr(hr, "RegQueryValueEx TYPE", apwszRegNames[i]);
	    continue;
        }

        // Handle malformed registry values cleanly by adding two WCHAR L'\0's
	// allocate space for 3 WCHARs to allow for unaligned (odd) cbValue;

        pwszzValue = (WCHAR *) LocalAlloc(
				        LMEM_FIXED,
				        cbValue + 3 * sizeof(WCHAR));
        if (NULL == pwszzValue)
        {
	    hr = E_OUTOFMEMORY;
	    _JumpErrorStr(hr, error, "LocalAlloc", apwszRegNames[i]);
        }
        hr = RegQueryValueEx(
		        hkey,
		        apwszRegNames[i],
		        NULL,           // lpdwReserved
		        &dwType,
		        (BYTE *) pwszzValue,
		        &cbValue);
        if (S_OK != hr)
        {
	    _PrintErrorStr(hr, "RegQueryValueEx", apwszRegNames[i]);
	    continue;
        }

        // Handle malformed registry values cleanly:

        pwszzValue[cbValue / sizeof(WCHAR)] = L'\0';
        pwszzValue[cbValue / sizeof(WCHAR) + 1] = L'\0';

        hr = _AddStringArray(pwszzValue, fURL, pcStrings, papstrRegValues);
        _JumpIfErrorStr(hr, error, "_AddStringArray", apwszRegNames[i]);
    }
    hr = S_OK;

error:
    if (NULL != pwszzValue)
    {
        LocalFree(pwszzValue);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_InitRevocationExtension
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyExchange::_InitRevocationExtension(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cb;
    DWORD adwFlags[] = {
		REVEXT_CDPLDAPURL_OLD,
		REVEXT_CDPHTTPURL_OLD,
		REVEXT_CDPFTPURL_OLD,
		REVEXT_CDPFILEURL_OLD,
	    };
    WCHAR *apwszRegNames[] = {
		wszREGLDAPREVOCATIONCRLURL_OLD,
		wszREGREVOCATIONCRLURL_OLD,
		wszREGFTPREVOCATIONCRLURL_OLD,
		wszREGFILEREVOCATIONCRLURL_OLD,
	    };

    cb = sizeof(m_dwRevocationFlags);
    hr = RegQueryValueEx(
                hkey,
                wszREGREVOCATIONTYPE,
                NULL,           // lpdwReserved
                &dwType,
                (BYTE *) &m_dwRevocationFlags,
                &cb);
    if (S_OK != hr ||
	REG_DWORD != dwType ||
	sizeof(m_dwRevocationFlags) != cb)
    {
        goto error;
    }
    DBGPRINT((fDebug, "Revocation Flags = %x\n", m_dwRevocationFlags));


    // clean up from previous call
    if (NULL != m_ppwszCDPRevocationURL)
    {
        _FreeStringArray(&m_cCDPRevocationURL, &m_ppwszCDPRevocationURL);
    }

    if (NULL != m_pwszASPRevocationURL)
    {
        LocalFree(m_pwszASPRevocationURL);
        m_pwszASPRevocationURL = NULL;
    }

    if (REVEXT_CDPENABLE & m_dwRevocationFlags)
    {
        assert(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));
        hr = _ReadRegistryStringArray(
			    hkey,
			    TRUE,			// fURL
			    m_dwRevocationFlags,
			    ARRAYSIZE(adwFlags),
			    adwFlags,
			    apwszRegNames,
			    &m_cCDPRevocationURL,
			    &m_ppwszCDPRevocationURL);
        _JumpIfError(hr, error, "_ReadRegistryStringArray");

        _DumpStringArray("CDP", m_cCDPRevocationURL, m_ppwszCDPRevocationURL);
    }

    if (REVEXT_ASPENABLE & m_dwRevocationFlags)
    {
        hr = _ReadRegistryString(
			    hkey,
			    TRUE,			// fURL
			    wszREGREVOCATIONURL,	// pwszRegName
			    L"?",			// pwszSuffix
			    &m_pwszASPRevocationURL);	// pstrRegValue
        _JumpIfErrorStr(hr, error, "_ReadRegistryString", wszREGREVOCATIONCRLURL_OLD);
        _DumpStringArray("ASP", 1, &m_pwszASPRevocationURL);
    }

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_InitAuthorityInfoAccessExtension
//
//+--------------------------------------------------------------------------

VOID
CCertPolicyExchange::_InitAuthorityInfoAccessExtension(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cb;
    DWORD adwFlags[] = {
		ISSCERT_LDAPURL_OLD,
		ISSCERT_HTTPURL_OLD,
		ISSCERT_FTPURL_OLD,
		ISSCERT_FILEURL_OLD,
	    };
    WCHAR *apwszRegNames[] = {
		wszREGLDAPISSUERCERTURL_OLD,
		wszREGISSUERCERTURL_OLD,
		wszREGFTPISSUERCERTURL_OLD,
		wszREGFILEISSUERCERTURL_OLD,
	    };

    // clean up from previous call
    if (NULL != m_ppwszIssuerCertURL)
    {
        _FreeStringArray(&m_cIssuerCertURL, &m_ppwszIssuerCertURL);
    }



    cb = sizeof(m_dwIssuerCertURLFlags);
    hr = RegQueryValueEx(
                hkey,
		wszREGISSUERCERTURLFLAGS,
                NULL,           // lpdwReserved
                &dwType,
                (BYTE *) &m_dwIssuerCertURLFlags,
                &cb);
    if (S_OK != hr ||
	REG_DWORD != dwType ||
	sizeof(m_dwIssuerCertURLFlags) != cb)
    {
        goto error;
    }
    DBGPRINT((fDebug, "Issuer Cert Flags = %x\n", m_dwIssuerCertURLFlags));

    if (ISSCERT_ENABLE & m_dwIssuerCertURLFlags)
    {
        assert(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));
        hr = _ReadRegistryStringArray(
				hkey,
				TRUE,			// fURL
				m_dwIssuerCertURLFlags,
				ARRAYSIZE(adwFlags),
				adwFlags,
				apwszRegNames,
				&m_cIssuerCertURL,
				&m_ppwszIssuerCertURL);
        _JumpIfError(hr, error, "_ReadRegistryStringArray");

        _DumpStringArray("Issuer Cert", m_cIssuerCertURL, m_ppwszIssuerCertURL);
    }

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::Initialize
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyExchange::Initialize(
    /* [in] */ BSTR const strConfig)
{
    HRESULT hr;
    HKEY hkey = NULL;
    VARIANT varValue;
    ICertServerPolicy *pServer = NULL;
    BSTR strName = NULL;

    VariantInit(&varValue);

    _Cleanup();

    hr = GetServerCallbackInterface(&pServer, 0);
    _JumpIfError(hr, error, "GetServerCallbackInterface");

    // get storage location

    strName = SysAllocString(wszPROPMODULEREGLOC);
    if (NULL == strName)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strName,
				PROPTYPE_STRING,
				&varValue);
    _JumpIfError(hr, error, "GetCertificateProperty : wszPROPMODULEREGLOC");

    m_pwszRegStorageLoc = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(varValue.bstrVal) + 1) * sizeof(WCHAR));
    if (NULL == m_pwszRegStorageLoc)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "LocalAlloc");
    }
    wcscpy(m_pwszRegStorageLoc, varValue.bstrVal);
    VariantClear(&varValue);

    hr = PopulateRegistryDefaults(NULL, m_pwszRegStorageLoc);
    _PrintIfError(hr, "Policy:PopulateRegistryDefaults");

    hr = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
		m_pwszRegStorageLoc,
                0,              // dwReserved
                KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
                &hkey);

    if ((HRESULT) ERROR_SUCCESS != hr)
    {
	hr = HRESULT_FROM_WIN32(hr);
	_JumpIfError(hr, error, "RegOpenKeyEx");
    }

    // Initialize the insertion string array.
    // Machine DNS name (%1)

    SysFreeString(strName);
    strName = SysAllocString(wszPROPMACHINEDNSNAME);
    if (NULL == strName)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strName,
				PROPTYPE_STRING,
				&varValue);
    _JumpIfErrorStr(hr, error, "GetCertificateProperty", strName);

    m_bstrMachineDNSName = SysAllocString(varValue.bstrVal);
    if (NULL == m_bstrMachineDNSName)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }
    VariantClear(&varValue);

    SysFreeString(strName);
    strName = SysAllocString(wszPROPCERTCOUNT);
    if (NULL == strName)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strName,
				PROPTYPE_LONG,
				&varValue);
    _JumpIfErrorStr(hr, error, "GetCertificateProperty", strName);

    m_iCert = varValue.lVal - 1;

    SysFreeString(strName);
    strName = SysAllocString(wszPROPCRLINDEX);
    if (NULL == strName)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strName,
				PROPTYPE_LONG,
				&varValue);
    _JumpIfErrorStr(hr, error, "GetCertificateProperty", strName);

    m_iCRL = varValue.lVal;

    // get sanitized name

    SysFreeString(strName);
    strName = SysAllocString(wszPROPSANITIZEDCANAME);
    if (NULL == strName)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strName,
				PROPTYPE_STRING,
				&varValue);
    _JumpIfErrorStr(hr, error, "GetCertificateProperty", strName);

    m_bstrCASanitizedName = SysAllocString(varValue.bstrVal);
    if (NULL == m_bstrCASanitizedName)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }
    VariantClear(&varValue);

    _InitRevocationExtension(hkey);
    _InitAuthorityInfoAccessExtension(hkey);
    hr = S_OK;

error:
    VariantClear(&varValue);
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != pServer)
    {
        pServer->Release();
    }
    return(hr);
}


HRESULT
EnumerateExtensions(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strName = NULL;
    LONG ExtFlags;
    VARIANT varValue;
    BOOL fClose = FALSE;

    VariantInit(&varValue);
    hr = pServer->EnumerateExtensionsSetup(0);
    _JumpIfError(hr, error, "EnumerateExtensionsSetup");

    fClose = TRUE;
    while (TRUE)
    {
        hr = pServer->EnumerateExtensions(&strName);
        if (S_OK != hr)
        {
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }
	    _JumpError(hr, error, "EnumerateExtensions");
        }
        hr = pServer->GetCertificateExtension(
                                        strName,
                                        PROPTYPE_BINARY,
                                        &varValue);
	_JumpIfError(hr, error, "GetCertificateExtension");

        hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	_JumpIfError(hr, error, "GetCertificateExtensionFlags");

        if (fDebug)
        {
            wprintf(
                L"Policy:EnumerateExtensions(%ws, Flags=%x, %x bytes)\n",
                strName,
                ExtFlags,
                SysStringByteLen(varValue.bstrVal));
        }
        VariantClear(&varValue);
    }

error:
    if (fClose)
    {
        hr2 = pServer->EnumerateExtensionsClose();
        if (S_OK != hr2)
        {
	    _PrintError(hr2, "Policy:EnumerateExtensionsClose");
            if (S_OK == hr)
            {
                hr = hr2;
            }
        }
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    VariantClear(&varValue);
    return(hr);
}


HRESULT
EnumerateAttributes(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strName = NULL;
    BOOL fClose = FALSE;
    BSTR strValue = NULL;

    hr = pServer->EnumerateAttributesSetup(0);
    _JumpIfError(hr, error, "EnumerateAttributesSetup");

    fClose = TRUE;
    while (TRUE)
    {
        hr = pServer->EnumerateAttributes(&strName);
        if (S_OK != hr)
        {
            if (S_FALSE == hr)
            {
                hr = S_OK;
                break;
            }
	    _JumpError(hr, error, "EnumerateAttributes");
        }

        hr = pServer->GetRequestAttribute(strName, &strValue);
	_JumpIfError(hr, error, "GetRequestAttribute");

        if (fDebug)
        {
            wprintf(
                L"Policy:EnumerateAttributes(%ws = %ws)\n",
                strName,
                strValue);
        }
        if (NULL != strValue)
        {
            SysFreeString(strValue);
            strValue = NULL;
        }
    }

error:
    if (fClose)
    {
        hr2 = pServer->EnumerateAttributesClose();
        if (S_OK != hr2)
        {
	    _PrintError(hr2, "Policy:EnumerateAttributesClose");
            if (S_OK == hr)
            {
                hr = hr2;
            }
        }
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strValue)
    {
        SysFreeString(strValue);
    }
    return(hr);
}


HRESULT
CheckRequestProperties(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    VARIANT varValue;
    BSTR strName = NULL;

    VariantInit(&varValue);

    strName = SysAllocString(wszPROPREQUESTREQUESTID);
    if (NULL == strName)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    hr = pServer->GetRequestProperty(strName, PROPTYPE_LONG, &varValue);
    _JumpIfError(hr, error, "GetRequestProperty");

    if (fDebug)
    {
        wprintf(
            L"Policy:CheckRequestProperties(%ws = %x)\n",
            strName,
            varValue.lVal);
    }
    VariantClear(&varValue);

error:
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddRevocationExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddRevocationExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    ICertEncodeCRLDistInfo *pCRLDist = NULL;
    BSTR strCDPName = NULL;
    BSTR strCDPExtension = NULL;
    BSTR strName = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    DWORD i;

    varExtension.vt = VT_BSTR;
    if (NULL != m_ppwszCDPRevocationURL)
    {
	hr = CoCreateInstance(
			CLSID_CCertEncodeCRLDistInfo,
			NULL,               // pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertEncodeCRLDistInfo,
			(VOID **) &pCRLDist);
	_JumpIfError(hr, error, "CoCreateInstance");

	hr = pCRLDist->Reset(m_cCDPRevocationURL);
	_JumpIfError(hr, error, "Reset");

	for (i = 0; i < m_cCDPRevocationURL; i++)
	{
	    DWORD j;

	    hr = pCRLDist->SetNameCount(i, 1);
	    _JumpIfError(hr, error, "SetNameCount");

	    for (j = 0; j < 1; j++)
	    {
		BSTR str = SysAllocString(m_ppwszCDPRevocationURL[i]);

		if (NULL == str)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "SysAllocString");
		}
		hr = pCRLDist->SetNameEntry(i, j, CERT_ALT_NAME_URL, str);
		SysFreeString(str);
		_JumpIfError(hr, error, "SetNameEntry");
	    }
	}
	hr = pCRLDist->Encode(&strCDPExtension);
	_JumpIfError(hr, error, "Encode");

	strCDPName = SysAllocString(TEXT(szOID_CRL_DIST_POINTS));
	varExtension.bstrVal = strCDPExtension;
	hr = pServer->SetCertificateExtension(
				strCDPName,
				PROPTYPE_BINARY,
				0,
				&varExtension);
	_JumpIfErrorStr(hr, error, "SetCertificateExtension", L"CDP");
    }
    if (NULL != m_pwszASPRevocationURL)
    {
	strName = SysAllocString(TEXT(szOID_NETSCAPE_REVOCATION_URL));
	strExtension = SysAllocString(m_pwszASPRevocationURL);
	if (NULL == strName || NULL == strExtension)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "SysAllocString");
	}
	varExtension.bstrVal = strExtension;
	hr = pServer->SetCertificateExtension(
				strName,
				PROPTYPE_STRING,
				0,
				&varExtension);
	_JumpIfErrorStr(hr, error, "SetCertificateExtension", L"ASP");
	VariantClear(&varExtension);
    }

error:
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strCDPName)
    {
        SysFreeString(strCDPName);
    }
    if (NULL != strCDPExtension)
    {
        SysFreeString(strCDPExtension);
    }
    if (NULL != pCRLDist)
    {
        pCRLDist->Release();
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddAuthorityInfoAccessExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddAuthorityInfoAccessExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BSTR strName = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    DWORD i;

    CERT_AUTHORITY_INFO_ACCESS caio;
    caio.rgAccDescr = NULL;

    if (NULL == m_ppwszIssuerCertURL)
    {
	goto error;
    }

    caio.cAccDescr = m_cIssuerCertURL;
    caio.rgAccDescr = (CERT_ACCESS_DESCRIPTION *) LocalAlloc(
			LMEM_FIXED,
			sizeof(CERT_ACCESS_DESCRIPTION) * m_cIssuerCertURL);
    if (NULL == caio.rgAccDescr)
    {
        hr = E_OUTOFMEMORY;
	_JumpIfError(hr, error, "LocalAlloc");
    }

    for (i = 0; i < m_cIssuerCertURL; i++)
    {
	caio.rgAccDescr[i].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
	caio.rgAccDescr[i].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
	caio.rgAccDescr[i].AccessLocation.pwszURL = m_ppwszIssuerCertURL[i];
    }

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_AUTHORITY_INFO_ACCESS,
		    &caio,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	_JumpIfError(hr, error, "Policy:ceEncodeObject");
    }
    if (!ceConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToBstr");
    }
    strName = SysAllocString(TEXT(szOID_AUTHORITY_INFO_ACCESS));
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    strName,
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension(AuthInfoAccess)");

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != caio.rgAccDescr)
    {
        LocalFree(caio.rgAccDescr);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddIssuerAltName2Extension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddIssuerAltName2Extension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strCertType = NULL;
    BSTR strName = NULL;
    BSTR strValue = NULL;
    BSTR strKMServerName = NULL;

    LPBYTE  pbEncName   = NULL;
    ULONG   cbEncName   = 0;

    LPBYTE  pbEncExten  = NULL;
    ULONG   cbEncExten  = 0;

    CERT_ALT_NAME_ENTRY cane    = { 0 };
    CERT_ALT_NAME_INFO  cani    = { 0 };

    strKMServerName = SysAllocString(k_wszKMServerName);
    if (NULL == strKMServerName)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    hr = pServer->GetRequestAttribute(strKMServerName, &strValue);
    _JumpIfErrorStr(
		hr,
		error,
		CERTSRV_E_PROPERTY_EMPTY == hr?
		    "MISSING ATTRIBUTE -- GetRequestAttribute" :
		    "GetRequestAttribute",
		k_wszKMServerName);

    // CertStrToName to turn string into encoded name blob

    if (!CertStrToNameW(
		X509_ASN_ENCODING,
		strValue,
		CERT_X500_NAME_STR,
		NULL,
		NULL,
		&cbEncName,
		NULL))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "CertStrToNameW");
    }

    pbEncName = new BYTE [cbEncName];
    if (NULL == pbEncName)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "new");
    }

    if (!CertStrToNameW(
		X509_ASN_ENCODING,
		strValue,
		CERT_X500_NAME_STR,
		NULL,
		pbEncName,
		&cbEncName,
		NULL))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "CertStrToNameW");
    }

    // fill in alt name info

    cane.dwAltNameChoice        = CERT_ALT_NAME_DIRECTORY_NAME;
    cane.DirectoryName.cbData   = cbEncName;
    cane.DirectoryName.pbData   = pbEncName;

    cani.cAltEntry  = 1;
    cani.rgAltEntry = &cane;

    // encode alt name info

    if (!CryptEncodeObject(
		X509_ASN_ENCODING,
		X509_ALTERNATE_NAME,
		&cani,
		NULL,
		&cbEncExten))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "CryptEncodeObject");
    }

    pbEncExten = new BYTE [cbEncExten];
    if (NULL == pbEncExten)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "new");
    }

    if (!CryptEncodeObject(
		X509_ASN_ENCODING,
		X509_ALTERNATE_NAME,
		&cani,
		pbEncExten,
		&cbEncExten))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "CryptEncodeObject");
    }

    strName = SysAllocString(TEXT(szOID_ISSUER_ALT_NAME2));
    strExtension = SysAllocStringByteLen((char *) pbEncExten, cbEncExten);
    if (NULL == strName || NULL == strExtension)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    // add extension

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    strName,
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension(IssuerAltName2)");

error:
    delete [] pbEncName;
    delete [] pbEncExten;
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strKMServerName)
    {
        SysFreeString(strKMServerName);
    }
    return(hr);
}

//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddSubjectAltName2Extension
//
// Returns S_OK on success.
// Returns S_FALSE for special request.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddSubjectAltName2Extension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strCertType = NULL;
    BSTR strName = NULL;
    BSTR strDisplay = NULL;
    BSTR strRFC822 = NULL;

    BSTR strSubjAltNameRFC822 = NULL;
    BSTR strSubjAltNameDisplay = NULL;

    LPBYTE  pbEncName   = NULL;
    ULONG   cbEncName   = 0;

    LPBYTE  pbEncExten  = NULL;
    ULONG   cbEncExten  = 0;

    CERT_RDN_ATTR       rdnattr = { 0 };
    CERT_RDN            rdn     = { 0 };
    CERT_NAME_INFO      cni     = { 0 };
    CERT_ALT_NAME_ENTRY acane   [2] = { 0 };
    CERT_ALT_NAME_INFO  cani    = { 0 };

    strSubjAltNameDisplay = SysAllocString(k_wszSubjAltNameDisplay);
    if (NULL == strSubjAltNameDisplay)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    hr = pServer->GetRequestAttribute(strSubjAltNameDisplay, &strDisplay);
    _JumpIfErrorStr(
		hr,
		error,
		CERTSRV_E_PROPERTY_EMPTY == hr?
		    "MISSING ATTRIBUTE -- GetRequestAttribute" :
		    "GetRequestAttribute",
		k_wszSubjAltNameDisplay);

    strSubjAltNameRFC822 = SysAllocString(k_wszSubjAltNameRFC822);
    if (NULL == strSubjAltNameRFC822)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    hr = pServer->GetRequestAttribute(strSubjAltNameRFC822, &strRFC822);
    _JumpIfErrorStr(
		hr,
		error,
		CERTSRV_E_PROPERTY_EMPTY == hr?
		    "MISSING ATTRIBUTE -- GetRequestAttribute" :
		    "GetRequestAttribute",
		k_wszSubjAltNameRFC822);

    // this identifies special request from KMS

    if (0 == lstrcmpW(strDisplay, k_wszSpecialAttribute) &&
        0 == lstrcmpW(strRFC822, k_wszSpecialAttribute))
    {
        hr = _AddSpecialAltNameExtension(pServer);
	_JumpIfError(hr, error, "_AddSpecialAltNameExtension");

        // there are no subject names to add, so exit

        goto error;
    }

    // encode display name

    rdnattr.pszObjId        = szOID_COMMON_NAME;
    rdnattr.dwValueType     = CERT_RDN_UNICODE_STRING;
    rdnattr.Value.cbData    = SysStringByteLen(strDisplay);
    rdnattr.Value.pbData    = (LPBYTE) strDisplay;

    rdn.cRDNAttr    = 1;
    rdn.rgRDNAttr   = &rdnattr;

    cni.cRDN    = 1;
    cni.rgRDN   = &rdn;

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_NAME,
		    &cni,
		    NULL,
		    &cbEncName))
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "CryptEncodeObject");
    }

    pbEncName = new BYTE [cbEncName];
    if (NULL == pbEncName)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new");
    }

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_NAME,
		    &cni,
		    pbEncName,
		    &cbEncName))
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "CryptEncodeObject");
    }

    // fill in alt name info

    acane[0].dwAltNameChoice        = CERT_ALT_NAME_DIRECTORY_NAME;
    acane[0].DirectoryName.cbData   = cbEncName;
    acane[0].DirectoryName.pbData   = pbEncName;

    acane[1].dwAltNameChoice        = CERT_ALT_NAME_RFC822_NAME;
    acane[1].pwszRfc822Name         = strRFC822;

    cani.cAltEntry  = 2;
    cani.rgAltEntry = acane;

    // encode alt name info

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &cani,
		    NULL,
		    &cbEncExten))
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "CryptEncodeObject");
    }

    pbEncExten = new BYTE [cbEncExten];
    if (NULL == pbEncExten)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new");
    }

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &cani,
		    pbEncExten,
		    &cbEncExten))
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "CryptEncodeObject");
    }

    strName = SysAllocString(TEXT(szOID_SUBJECT_ALT_NAME2));
    strExtension = SysAllocStringByteLen((char *) pbEncExten, cbEncExten);
    if (NULL == strName || NULL == strExtension)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    // add extension

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			strName,
			PROPTYPE_BINARY,
			0,
			&varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension");

error:
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strSubjAltNameRFC822)
    {
        SysFreeString(strSubjAltNameRFC822);
    }
    if (NULL != strSubjAltNameDisplay)
    {
        SysFreeString(strSubjAltNameDisplay);
    }
    return(hr);
}

//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddSpecialAltNameExtension
//
// in response to request with both display and RFC822 equal to special value,
// fetch version info for CertSrv.exe and ExPolicy.dll, encode as multi-byte
// int, and set as IssuerAltName, marked critical. this should make cert
// unusable.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddSpecialAltNameExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr              = S_OK;
    BSTR    strName         = NULL;
    BSTR    strExtension    = NULL;
    VARIANT varExtension;

    HRSRC   hExeVersion         = NULL;
    HGLOBAL hExeVersionInMem    = NULL;
    LPBYTE  pExeVersion         = NULL;

    // [0] to [3] are ExPolicy version.
    // [4] to [7] are CertServer version.
    WORD    awVersions   [] =
            { rmj, rmn, rmm, rup, 0, 0, 0, 0 };

    ULONG   ndxCertServer   = 4;

    CRYPT_INTEGER_BLOB  intblobVersions = { 0 };

    LPBYTE  pbEncExten  = NULL;
    ULONG   cbEncExten  = 0;

    // fill in version info

    if (NULL == (hExeVersion =
                    FindResource(NULL, MAKEINTRESOURCE(1), RT_VERSION)) ||
        NULL == (hExeVersionInMem = LoadResource(NULL, hExeVersion)) ||
        NULL == (pExeVersion = (LPBYTE) LockResource(hExeVersionInMem)))
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Find/Load/LockResource");
    }

    awVersions[ndxCertServer]       = ((LPWORD)pExeVersion)[25];
    awVersions[ndxCertServer + 1]   = ((LPWORD)pExeVersion)[24];
    awVersions[ndxCertServer + 2]   = ((LPWORD)pExeVersion)[27];
    awVersions[ndxCertServer + 3]   = ((LPWORD)pExeVersion)[26];

    intblobVersions.cbData  = sizeof(awVersions);
    intblobVersions.pbData  = (LPBYTE) awVersions;

    // encode version info

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_MULTI_BYTE_INTEGER,
		    &intblobVersions,
		    NULL,
		    &cbEncExten))
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "CryptEncodeObject");
    }

    pbEncExten = new BYTE [cbEncExten];
    if (NULL == pbEncExten)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new");
    }

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_MULTI_BYTE_INTEGER,
		    &intblobVersions,
		    pbEncExten,
		    &cbEncExten))
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "CryptEncodeObject");
    }

    strName = SysAllocString(TEXT(szOID_ISSUER_ALT_NAME));
    strExtension = SysAllocStringByteLen((char *) pbEncExten, cbEncExten);
    if (NULL == strName || NULL == strExtension)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    // add extension

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			strName,
			PROPTYPE_BINARY,
			EXTENSION_CRITICAL_FLAG,
			&varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension");

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
	SysFreeString(strExtension);
    }
    delete [] pbEncExten;
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddBasicConstraintsExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddBasicConstraintsExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_BASIC_CONSTRAINTS2_INFO bc2i;
    BSTR strName = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;

    bc2i.fCA = FALSE;
    bc2i.fPathLenConstraint = FALSE;
    bc2i.dwPathLenConstraint = 0;

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_BASIC_CONSTRAINTS2,
		    &bc2i,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = GetLastError();
	_JumpError(hr, error, "ceEncodeObject");
    }
    if (!ceConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToBstr");
    }

    strName = SysAllocString(TEXT(szOID_BASIC_CONSTRAINTS2));
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }
    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    strName,
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension");

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddKeyUsageExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddKeyUsageExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strName = NULL;
    ICertEncodeBitString *pBitString = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BYTE KeyUsage = 0;
    BSTR strBitString = NULL;
    BSTR strKeyUsage = NULL;
    BSTR strValue = NULL;

    strKeyUsage = SysAllocString(k_wszKeyUsage);
    if (NULL == strKeyUsage)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

    hr = pServer->GetRequestAttribute(strKeyUsage, &strValue);
    _JumpIfErrorStr(
		hr,
		error,
		CERTSRV_E_PROPERTY_EMPTY == hr?
		    "MISSING ATTRIBUTE -- GetRequestAttribute" :
		    "GetRequestAttribute",
		k_wszKeyUsage);

    if (0 == wcscmp(strValue, k_wszUsageSealing))
    {
	KeyUsage =  CERT_KEY_ENCIPHERMENT_KEY_USAGE;
    }
    else
    if (0 == wcscmp(strValue, k_wszUsageSigning))
    {
	KeyUsage =  CERT_DIGITAL_SIGNATURE_KEY_USAGE |
			CERT_NON_REPUDIATION_KEY_USAGE;
    }
    else
    {
        hr = E_INVALIDARG;
	_JumpError(hr, error, "KeyUsage");
    }

    hr = CoCreateInstance(
		    CLSID_CCertEncodeBitString,
		    NULL,               // pUnkOuter
		    CLSCTX_INPROC_SERVER,
		    IID_ICertEncodeBitString,
		    (VOID **) &pBitString);
    _JumpIfError(hr, error, "CoCreateInstance");

    if (!ceConvertWszToBstr(
		&strBitString,
		(WCHAR const *) &KeyUsage,
		sizeof(KeyUsage)))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToBstr");
    }

    hr = pBitString->Encode(
			sizeof(KeyUsage) * 8,
			strBitString,
			&strExtension);
    _JumpIfError(hr, error, "Encode");

    if (!ceConvertWszToBstr(&strName, TEXT(szOID_KEY_USAGE), -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToBstr");
    }
    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    strName,
			    PROPTYPE_BINARY,
			    EXTENSION_CRITICAL_FLAG,
			    &varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension");

error:
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strBitString)
    {
        SysFreeString(strBitString);
    }
    if (NULL != strKeyUsage)
    {
        SysFreeString(strKeyUsage);
    }
    if (NULL != strValue)
    {
        SysFreeString(strValue);
    }
    if (NULL != pBitString)
    {
        pBitString->Release();
    }
    return(hr);
}

//+--------------------------------------------------------------------------
// CCertPolicyExchange::_AddEnhancedKeyUsageExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicyExchange::_AddEnhancedKeyUsageExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strName = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;

    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CERT_ENHKEY_USAGE ceu;
    LPSTR pszEnhUsage = szOID_PKIX_KP_EMAIL_PROTECTION;

    ceu.cUsageIdentifier        = 1;
    ceu.rgpszUsageIdentifier    = &pszEnhUsage; // array of pszObjId

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ENHANCED_KEY_USAGE,
		    &ceu,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = GetLastError();
	_JumpError(hr, error, "ceEncodeObject");
    }

    if (!ceConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToBstr");
    }

    if (!ceConvertWszToBstr(&strName, TEXT(szOID_ENHANCED_KEY_USAGE), -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToBstr");
    }
    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = pServer->SetCertificateExtension(
			    strName,
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "SetCertificateExtension");

error:
    if (NULL != pbEncoded)
    {
	    LocalFree(pbEncoded);
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::VerifyRequest
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyExchange::VerifyRequest(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG Context,
    /* [in] */ LONG bNewRequest,
    /* [in] */ LONG Flags,
    /* [out, retval] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr;
    ICertServerPolicy *pServer = NULL;

    hr = GetServerCallbackInterface(&pServer, Context);
    _JumpIfError(hr, error, "GetServerCallbackInterface");

    if (fDebug)
    {
        hr = EnumerateAttributes(pServer);
	_JumpIfError(hr, error, "EnumerateAttributes");

        hr = EnumerateExtensions(pServer);
	_JumpIfError(hr, error, "EnumerateExtensions");
    }
    hr = _AddIssuerAltName2Extension(pServer);
    _JumpIfError(hr, error, "_AddIssuerAltName2Extension");

    // also handles 'special' KMS request

    hr = _AddSubjectAltName2Extension(pServer);
    _JumpIfError(hr, error, "_AddSubjectAltName2Extension");

    hr = _AddBasicConstraintsExtension(pServer);
    _JumpIfError(hr, error, "_AddBasicConstraintsExtension");

    hr = _AddRevocationExtension(pServer);
    _JumpIfError(hr, error, "_AddRevocationExtension");

    hr = _AddAuthorityInfoAccessExtension(pServer);
    _JumpIfError(hr, error, "_AddAuthorityInfoAccessExtension");

    hr = _AddKeyUsageExtension(pServer);
    _JumpIfError(hr, error, "_AddKeyUsageExtension");

    hr = _AddEnhancedKeyUsageExtension(pServer);
    _JumpIfError(hr, error, "_AddEnhancedKeyUsageExtension");

    if (fDebug)
    {
        hr = EnumerateExtensions(pServer);
	_JumpIfError(hr, error, "EnumerateExtensions");
    }
    hr = CheckRequestProperties(pServer);
    _JumpIfError(hr, error, "_AddRevocationExtension");

error:
    *pDisposition = S_OK == hr? VR_INSTANT_OK : VR_INSTANT_BAD;
    if (NULL != pServer)
    {
        pServer->Release();
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::GetDescription
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyExchange::GetDescription(
    /* [out, retval] */ BSTR __RPC_FAR *pstrDescription)
{
    HRESULT hr = S_OK;

    *pstrDescription = SysAllocString(g_wszDescription);
    if (NULL == *pstrDescription)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicyExchange::ShutDown
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicyExchange::ShutDown(VOID)
{
    return(S_OK);
}

//+--------------------------------------------------------------------------
// CCertPolicyExchange::GetManageModule
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------
STDMETHODIMP
CCertPolicyExchange::GetManageModule(
    /* [out, retval] */ ICertManageModule **ppManageModule)
{
    HRESULT hr;

    *ppManageModule = NULL;
    hr = CoCreateInstance(
                    CLSID_CCertManagePolicyModuleExchange,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertManageModule,
                    (VOID **) ppManageModule);
    _JumpIfError(hr, error, "CoCreateInstance");

error:
    return(hr);
}


STDMETHODIMP
CCertPolicyExchange::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID *arr[] =
    {
        &IID_ICertPolicy,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i], riid))
        {
            return(S_OK);
        }
    }
    return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\module.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.h
//
// Contents:    CCertManagePolicyModuleSample definition
//
//---------------------------------------------------------------------------

#include "certpsam.h"
#include "resource.h"       // main symbols


class CCertManagePolicyModuleSample: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTPOLICYSAMPLELib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManagePolicyModuleSample, &CLSID_CCertManagePolicyModuleSample>
{
public:
    CCertManagePolicyModuleSample() {}
    ~CCertManagePolicyModuleSample() {}

BEGIN_COM_MAP(CCertManagePolicyModuleSample)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManagePolicyModuleSample) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

// UNDONE UNDONE
DECLARE_REGISTRY(
    CCertManagePolicyModuleSample,
    wszCLASS_CERTMANAGEPOLICYMODULESAMPLE TEXT(".1"),
    wszCLASS_CERTMANAGEPOLICYMODULESAMPLE,
    IDS_CERTMANAGEPOLICYMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:
    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);
        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#include <windows.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>

#define wszCLASS_CERTPOLICYSAMPLEPREFIX TEXT("CertAuthority_Sample") 

#define wszCLASS_CERTPOLICYSAMPLE wszCLASS_CERTPOLICYSAMPLEPREFIX  wszCERTPOLICYMODULE_POSTFIX

#define wszCLASS_CERTMANAGEPOLICYMODULESAMPLE wszCLASS_CERTPOLICYSAMPLEPREFIX wszCERTMANAGEPOLICY_POSTFIX

#define wsz_SAMPLE_NAME           L"Sample/Test Policy Module"
#define wsz_SAMPLE_DESCRIPTION    L"Sample Policy Module"
#define wsz_SAMPLE_COPYRIGHT      L"(c)2000 Microsoft"
#define wsz_SAMPLE_FILEVER        L"v 1.0"
#define wsz_SAMPLE_PRODUCTVER     L"v 5.00"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\module.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "celib.h"
#include "module.h"
#include "policy.h"


STDMETHODIMP
CCertManagePolicyModuleSample::GetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    LPWSTR szStr = NULL;

    if (NULL == pvarProperty)
    {
        return E_POINTER;
    }
    VariantInit(pvarProperty);

    if (strPropertyName == NULL)
        return S_FALSE;

    if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_NAME))
        szStr = wsz_SAMPLE_NAME;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_DESCRIPTION))
        szStr = wsz_SAMPLE_DESCRIPTION;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_COPYRIGHT))
        szStr = wsz_SAMPLE_COPYRIGHT;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_FILEVER))
        szStr = wsz_SAMPLE_FILEVER;
    else if (0 == _wcsicmp(strPropertyName, wszCMM_PROP_PRODUCTVER))
        szStr = wsz_SAMPLE_PRODUCTVER;
    else
        return S_FALSE;  

    pvarProperty->bstrVal = SysAllocString(szStr);
    if (NULL == pvarProperty->bstrVal)
        return E_OUTOFMEMORY;

    pvarProperty->vt = VT_BSTR;

    return S_OK;
}
        
STDMETHODIMP 
CCertManagePolicyModuleSample::SetProperty(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG Flags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty)
{
     // no settable properties supported
     return S_FALSE;
}
        
STDMETHODIMP
CCertManagePolicyModuleSample::Configure( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG Flags)
{
    MessageBox(NULL, L"No Configurable Options", NULL, MB_OK|MB_ICONINFORMATION);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\policy0.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        policy.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "policy.h"
#include "module.h"

BOOL fDebug = DBG_CERTSRV;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\policy0.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       policy.h
//
//--------------------------------------------------------------------------

#include "certpsam.h"
#include "resource.h"

#ifndef wszATTREMAIL1
# define wszATTREMAIL1			TEXT("E")
# define wszATTREMAIL2			TEXT("EMail")
#endif

#ifndef wszCERTTYPE_SUBORDINATE_CA
# define wszCERTTYPE_SUBORDINATE_CA	L"SubCA"
#endif

#ifndef wszCERTTYPE_CROSS_CA
# define wszCERTTYPE_CROSS_CA		L"CrossCA"
#endif

extern BOOL fDebug;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\policy.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        policy.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "policy.h"
#include "module.h"

BOOL fDebug = DBG_CERTSRV;

#ifndef DBG_CERTSRV
#error -- DBG_CERTSRV not defined!
#endif

// worker
HRESULT
polGetServerCallbackInterface(
    OUT ICertServerPolicy **ppServer,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL == ppServer)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "Policy:polGetServerCallbackInterface");
    }

    hr = CoCreateInstance(
                    CLSID_CCertServerPolicy,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
                    IID_ICertServerPolicy,
                    (VOID **) ppServer);
    _JumpIfError(hr, error, "Policy:CoCreateInstance");

    if (NULL == *ppServer)
    {
        hr = E_UNEXPECTED;
	_JumpError(hr, error, "Policy:CoCreateInstance");
    }

    // only set context if nonzero
    if (0 != Context)
    {
        hr = (*ppServer)->SetContext(Context);
        _JumpIfError(hr, error, "Policy:SetContext");
    }

error:
    return hr;
}


HRESULT
polGetProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    IN DWORD PropType,
    OUT VARIANT *pvarOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    VariantInit(pvarOut);
    strName = SysAllocString(pwszPropertyName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    if (fRequest)
    {
	hr = pServer->GetRequestProperty(strName, PropType, pvarOut);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "Policy:GetRequestProperty",
		    pwszPropertyName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }
    else
    {
	hr = pServer->GetCertificateProperty(strName, PropType, pvarOut);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "Policy:GetCertificateProperty",
		    pwszPropertyName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


HRESULT
polGetStringProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);
    if (NULL != *pstrOut)
    {
	SysFreeString(*pstrOut);
	*pstrOut = NULL;
    }
    hr = polGetProperty(
		    pServer,
		    fRequest,
		    pwszPropertyName,
		    PROPTYPE_STRING,
		    &var);
    _JumpIfError2(
	    hr,
	    error,
	    "Policy:polGetProperty",
	    CERTSRV_E_PROPERTY_EMPTY);

    if (VT_BSTR != var.vt || NULL == var.bstrVal || L'\0' == var.bstrVal)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "Policy:polGetProperty");
    }
    *pstrOut = var.bstrVal;
    var.vt = VT_EMPTY;
    hr = S_OK;

error:
    VariantClear(&var);
    return(hr);
}


HRESULT
polGetLongProperty(
    IN ICertServerPolicy *pServer,
    IN BOOL fRequest,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut)
{
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);
    hr = polGetProperty(
		    pServer,
		    fRequest,
		    pwszPropertyName,
		    PROPTYPE_LONG,
		    &var);
    _JumpIfError2(hr, error, "Policy:polGetProperty", CERTSRV_E_PROPERTY_EMPTY);

    if (VT_I4 != var.vt)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "Policy:polGetProperty");
    }
    *plOut = var.lVal;
    hr = S_OK;

error:
    VariantClear(&var);
    return(hr);
}


HRESULT
polGetRequestStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    
    hr = polGetStringProperty(pServer, TRUE, pwszPropertyName, pstrOut);
    _JumpIfError2(hr, error, "polGetStringProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetCertificateStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    
    hr = polGetStringProperty(pServer, FALSE, pwszPropertyName, pstrOut);
    _JumpIfError2(hr, error, "polGetStringProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetRequestLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut)
{
    HRESULT hr;
    
    hr = polGetLongProperty(pServer, TRUE, pwszPropertyName, plOut);
    _JumpIfError2(hr, error, "polGetLongProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetCertificateLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut)
{
    HRESULT hr;
    
    hr = polGetLongProperty(pServer, FALSE, pwszPropertyName, plOut);
    _JumpIfError2(hr, error, "polGetLongProperty", CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


HRESULT
polGetRequestAttribute(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszAttributeName,
    OUT BSTR *pstrOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    strName = SysAllocString(pwszAttributeName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetRequestAttribute(strName, pstrOut);
    _JumpIfErrorStr2(
		hr,
		error,
		"Policy:GetRequestAttribute",
		pwszAttributeName,
		CERTSRV_E_PROPERTY_EMPTY);

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


HRESULT
polGetCertificateExtension(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszExtensionName,
    IN DWORD dwPropType,
    IN OUT VARIANT *pvarOut)
{
    HRESULT hr;
    BSTR strName = NULL;

    strName = SysAllocString(pwszExtensionName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateExtension(strName, dwPropType, pvarOut);
    _JumpIfErrorStr2(
		hr,
		error,
		"Policy:GetCertificateExtension",
		pwszExtensionName,
		CERTSRV_E_PROPERTY_EMPTY);

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


HRESULT
polSetCertificateExtension(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszExtensionName,
    IN DWORD dwPropType,
    IN DWORD dwExtFlags,
    IN VARIANT const *pvarIn)
{
    HRESULT hr;
    BSTR strName = NULL;

    strName = SysAllocString(pwszExtensionName);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->SetCertificateExtension(
				    strName,
				    dwPropType,
				    dwExtFlags,
				    pvarIn);
    _JumpIfErrorStr(
		hr,
		error,
		"Policy:SetCertificateExtension",
		pwszExtensionName);

error:
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::~CCertPolicySample -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertPolicySample::~CCertPolicySample()
{
    _Cleanup();

}


VOID
CCertPolicySample::_FreeStringArray(
    IN OUT DWORD *pcString,
    IN OUT LPWSTR **papwsz)
{
    LPWSTR *apwsz = *papwsz;
    DWORD i;

    if (NULL != apwsz)
    {
        for (i = *pcString; i-- > 0; )
        {
            if (NULL != apwsz[i])
            {
                DBGPRINT((fDebug, "_FreeStringArray[%u]: '%ws'\n", i, apwsz[i]));
                LocalFree(apwsz[i]);
            }
        }
        LocalFree(apwsz);
        *papwsz = NULL;
    }
    *pcString = 0;
}




//+--------------------------------------------------------------------------
// CCertPolicySample::_Cleanup -- free memory associated with this instance
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertPolicySample::_Cleanup()
{
    DWORD i;

    if (m_strDescription)
    {
        SysFreeString(m_strDescription);
        m_strDescription = NULL;
    }

    // RevocationExtension variables:

    if (NULL != m_wszASPRevocationURL)
    {
        LocalFree(m_wszASPRevocationURL);
    	m_wszASPRevocationURL = NULL;
    }


    _FreeStringArray(&m_cEnableRequestExtensions, &m_apwszEnableRequestExtensions);
    _FreeStringArray(&m_cEnableEnrolleeRequestExtensions, &m_apwszEnableEnrolleeRequestExtensions);
    _FreeStringArray(&m_cDisableExtensions, &m_apwszDisableExtensions);

    if (NULL != m_strCAName)
    {
        SysFreeString(m_strCAName);
        m_strCAName = NULL;
    }
    if (NULL != m_strCASanitizedName)
    {
        SysFreeString(m_strCASanitizedName);
        m_strCASanitizedName = NULL;
    }
    if (NULL != m_strCASanitizedDSName)
    {
        SysFreeString(m_strCASanitizedDSName);
        m_strCASanitizedDSName = NULL;
    }
    if (NULL != m_strRegStorageLoc)
    {
        SysFreeString(m_strRegStorageLoc);
        m_strRegStorageLoc = NULL;
    }
    if (NULL != m_pCert)
    {
        CertFreeCertificateContext(m_pCert);
        m_pCert = NULL;
    }
    if (m_strMachineDNSName)
    {
        SysFreeString(m_strMachineDNSName);
        m_strMachineDNSName=NULL;
    }

}


HRESULT
CCertPolicySample::_ReadRegistryString(
    IN HKEY hkey,
    IN BOOL fURL,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszSuffix,
    OUT LPWSTR *ppwszOut)
{
    HRESULT hr;
    WCHAR *pwszRegValue = NULL;
    DWORD cbValue;
    DWORD dwType;

    *ppwszOut = NULL;
    hr = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,           // lpdwReserved
		    &dwType,
		    NULL,
		    &cbValue);
    _JumpIfErrorStr2(
		hr,
		error,
		"Policy:RegQueryValueEx",
		pwszRegName,
		ERROR_FILE_NOT_FOUND);

    if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpErrorStr(hr, error, "Policy:RegQueryValueEx TYPE", pwszRegName);
    }
    if (NULL != pwszSuffix)
    {
	cbValue += wcslen(pwszSuffix) * sizeof(WCHAR);
    }
    pwszRegValue = (WCHAR *) LocalAlloc(LMEM_FIXED, cbValue + sizeof(WCHAR));
    if (NULL == pwszRegValue)
    {
        hr = E_OUTOFMEMORY;
        _JumpErrorStr(hr, error, "Policy:LocalAlloc", pwszRegName);
    }
    hr = RegQueryValueEx(
		    hkey,
		    pwszRegName,
		    NULL,           // lpdwReserved
		    &dwType,
		    (BYTE *) pwszRegValue,
		    &cbValue);
    _JumpIfErrorStr(hr, error, "Policy:RegQueryValueEx", pwszRegName);

    // Handle malformed registry values cleanly:

    pwszRegValue[cbValue / sizeof(WCHAR)] = L'\0';
    if (NULL != pwszSuffix)
    {
	wcscat(pwszRegValue, pwszSuffix);
    }

    hr = ceFormatCertsrvStringArray(
			fURL,			// fURL
			m_strMachineDNSName, 	// pwszServerName_p1_2
			m_strCASanitizedName,	// pwszSanitizedName_p3_7
			m_iCert,		// iCert_p4
			MAXDWORD,		// iCertTarget_p4
			L"",		// pwszDomainDN_p5
			L"",		// pwszConfigDN_p6
			m_iCRL,			// iCRL_p8
			FALSE,			// fDeltaCRL_p9
			TRUE,			// fDSAttrib_p10_11
			1,			// cStrings
			(LPCWSTR *) &pwszRegValue, // apwszStringsIn
			ppwszOut);		// apwszStringsOut
    _JumpIfError(hr, error, "Policy:ceFormatCertsrvStringArray");

error:
    if (NULL != pwszRegValue)
    {
        LocalFree(pwszRegValue);
    }
    return(ceHError(hr));	// Reg routines return Win32 error codes
}


#if DBG_CERTSRV

VOID
CCertPolicySample::_DumpStringArray(
    IN char const *pszType,
    IN DWORD count,
    IN LPWSTR const *apwsz)
{
    DWORD i;
    WCHAR const *pwszName;

    for (i = 0; i < count; i++)
    {
	pwszName = L"";
	if (iswdigit(apwsz[i][0]))
	{
	    pwszName = ceGetOIDName(apwsz[i]);	// Static: do not free!
	}
	DBGPRINT((
		fDebug,
		"%hs[%u]: %ws%hs%ws\n",
		pszType,
		i,
		apwsz[i],
		L'\0' != *pwszName? " -- " : "",
		pwszName));
    }
}
#endif // DBG_CERTSRV


HRESULT
CCertPolicySample::_SetSystemStringProp(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszName,
    OPTIONAL IN WCHAR const *pwszValue)
{
    HRESULT hr;
    BSTR strName = NULL;
    VARIANT varValue;

    varValue.vt = VT_NULL;
    varValue.bstrVal = NULL;

    if (!ceConvertWszToBstr(&strName, pwszName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:ceConvertWszToBstr");
    }

    if (NULL != pwszValue)
    {
        if (!ceConvertWszToBstr(&varValue.bstrVal, pwszValue, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:ceConvertWszToBstr");
	}
	varValue.vt = VT_BSTR;
    }
    
    hr = pServer->SetCertificateProperty(strName, PROPTYPE_STRING, &varValue);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

error:
    VariantClear(&varValue);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(hr);
}


HRESULT
CCertPolicySample::_AddStringArray(
    IN WCHAR const *pwszzValue,
    IN BOOL fURL,
    IN OUT DWORD *pcStrings,
    IN OUT LPWSTR **papwszRegValues)
{
    HRESULT hr;
    DWORD cString = 0;
    WCHAR const *pwsz;
    LPCWSTR *awszFormatStrings = NULL;
    LPWSTR *awszOutputStrings = NULL;

    // Count the number of strings we're adding
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        cString++;
    }
    if (0 == cString)		// no strings
    {
	hr = S_OK;
        goto error;
    }
    awszFormatStrings = (LPCWSTR *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cString * sizeof(LPWSTR));
    if (NULL == awszFormatStrings)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:LocalAlloc");
    }

    cString = 0;
    for (pwsz = pwszzValue; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
        // Skip strings that start with a an unescaped minus sign.
        // Strings with an escaped minus sign (2 minus signs) are not skipped.

        if (L'-' == *pwsz)
        {
	    pwsz++;
	    if (L'-' != *pwsz)
	    {
                continue;
	    }
        }
        awszFormatStrings[cString++] = pwsz;
    }

    // if no strings to add, don't modify
    if (cString > 0)
    {
        awszOutputStrings = (LPWSTR *) LocalAlloc(
			        LMEM_FIXED | LMEM_ZEROINIT,
			        (cString + *pcStrings) * sizeof(LPWSTR));
        if (NULL == awszOutputStrings)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "Policy:LocalAlloc");
        }

        if (0 != *pcStrings)
        {
            assert(NULL != *papwszRegValues);
            CopyMemory(
		awszOutputStrings,
		*papwszRegValues,
		*pcStrings * sizeof(LPWSTR));
        }

        hr = ceFormatCertsrvStringArray(
		fURL,				// fURL
		m_strMachineDNSName,		// pwszServerName_p1_2
		m_strCASanitizedName,		// pwszSanitizedName_p3_7
		m_iCert,			// iCert_p4
		MAXDWORD,			// iCertTarget_p4
		L"",			// pwszDomainDN_p5
		L"",			// pwszConfigDN_p6
		m_iCRL,				// iCRL_p8
		FALSE,				// fDeltaCRL_p9
		TRUE,				// fDSAttrib_p10_11
		cString,			// cStrings
		awszFormatStrings,		// apwszStringsIn
		awszOutputStrings + (*pcStrings)); // apwszStringsOut
	_JumpIfError(hr, error, "Policy:ceFormatCertsrvStringArray");

        *pcStrings = (*pcStrings) + cString;
        if (*papwszRegValues)
        {
            LocalFree(*papwszRegValues);
        }
        *papwszRegValues = awszOutputStrings;
        awszOutputStrings = NULL;
    }
    hr = S_OK;

error:
    if (NULL != awszOutputStrings)
    {
        LocalFree(awszOutputStrings);
    }
    if (NULL != awszFormatStrings)
    {
        LocalFree(awszFormatStrings);
    }
    return(hr);	
}


HRESULT
CCertPolicySample::_ReadRegistryStringArray(
    IN HKEY hkey,
    IN BOOL fURL,
    IN DWORD dwFlags,
    IN DWORD cRegNames,
    IN DWORD *aFlags,
    IN WCHAR const * const *apwszRegNames,
    IN OUT DWORD *pcStrings,
    IN OUT LPWSTR **papwszRegValues)
{
    HRESULT hr;
    DWORD i;
    WCHAR *pwszzValue = NULL;
    DWORD cbValue;
    DWORD dwType;

    for (i = 0; i < cRegNames; i++)
    {
        if (0 == (dwFlags & aFlags[i]))
        {
	    continue;
        }
        if (NULL != pwszzValue)
        {
	    LocalFree(pwszzValue);
	    pwszzValue = NULL;
        }
        hr = RegQueryValueEx(
		        hkey,
		        apwszRegNames[i],
		        NULL,           // lpdwReserved
		        &dwType,
		        NULL,
		        &cbValue);
        if (S_OK != hr)
        {
	    _PrintErrorStr2(
			hr,
			"Policy:RegQueryValueEx",
			apwszRegNames[i],
			ERROR_FILE_NOT_FOUND);
	    continue;
        }
        if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
        {
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _PrintErrorStr(hr, "Policy:RegQueryValueEx TYPE", apwszRegNames[i]);
	    continue;
        }

        // Handle malformed registry values cleanly by adding two WCHAR L'\0's
	// allocate space for 3 WCHARs to allow for unaligned (odd) cbValue;

        pwszzValue = (WCHAR *) LocalAlloc(
				        LMEM_FIXED,
				        cbValue + 3 * sizeof(WCHAR));
        if (NULL == pwszzValue)
        {
	    hr = E_OUTOFMEMORY;
	    _JumpErrorStr(hr, error, "Policy:LocalAlloc", apwszRegNames[i]);
        }
        hr = RegQueryValueEx(
		        hkey,
		        apwszRegNames[i],
		        NULL,           // lpdwReserved
		        &dwType,
		        (BYTE *) pwszzValue,
		        &cbValue);
        if (S_OK != hr)
        {
	    _PrintErrorStr(hr, "Policy:RegQueryValueEx", apwszRegNames[i]);
	    continue;
        }

        // Handle malformed registry values cleanly:

        pwszzValue[cbValue / sizeof(WCHAR)] = L'\0';
        pwszzValue[cbValue / sizeof(WCHAR) + 1] = L'\0';

        hr = _AddStringArray(
			pwszzValue,
			fURL,
			pcStrings,
			papwszRegValues);
        _JumpIfErrorStr(hr, error, "_AddStringArray", apwszRegNames[i]);
    }
    hr = S_OK;

error:
    if (NULL != pwszzValue)
    {
        LocalFree(pwszzValue);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_InitRevocationExtension
//
//+--------------------------------------------------------------------------

VOID
CCertPolicySample::_InitRevocationExtension(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cb;

    cb = sizeof(m_dwRevocationFlags);
    hr = RegQueryValueEx(
                hkey,
                wszREGREVOCATIONTYPE,
                NULL,           // lpdwReserved
                &dwType,
                (BYTE *) &m_dwRevocationFlags,
                &cb);
    if (S_OK != hr ||
	REG_DWORD != dwType ||
	sizeof(m_dwRevocationFlags) != cb)
    {
	m_dwRevocationFlags = 0;
        goto error;
    }
    DBGPRINT((fDebug, "Revocation Flags = %x\n", m_dwRevocationFlags));

    // clean up from previous call

    if (NULL != m_wszASPRevocationURL)
    {
	LocalFree(m_wszASPRevocationURL);
	m_wszASPRevocationURL = NULL;
    }

    if (REVEXT_ASPENABLE & m_dwRevocationFlags)
    {
        hr = _ReadRegistryString(
			    hkey,
			    TRUE,			// fURL
			    wszREGREVOCATIONURL,	// pwszRegName
			    L"?",			// pwszSuffix
			    &m_wszASPRevocationURL);	// pstrRegValue
        _JumpIfErrorStr(hr, error, "_ReadRegistryString", wszREGREVOCATIONURL);
        _DumpStringArray("ASP", 1, &m_wszASPRevocationURL);
    }

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_InitRequestExtensionList
//
//+--------------------------------------------------------------------------

VOID
CCertPolicySample::_InitRequestExtensionList(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD adwFlags[] = {
	EDITF_REQUESTEXTENSIONLIST,
    };
    WCHAR *apwszRegNames[] = {
	wszREGENABLEREQUESTEXTENSIONLIST,
    };
    WCHAR *apwszRegNamesEnrollee[] = {
	wszREGENABLEENROLLEEREQUESTEXTENSIONLIST,
    };

    assert(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));
    assert(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNamesEnrollee));

    // clean up from previous call

    if (NULL != m_apwszEnableRequestExtensions)
    {
        _FreeStringArray(
		    &m_cEnableRequestExtensions,
		    &m_apwszEnableRequestExtensions);
    }
    if (NULL != m_apwszEnableEnrolleeRequestExtensions)
    {
        _FreeStringArray(
		    &m_cEnableEnrolleeRequestExtensions,
		    &m_apwszEnableEnrolleeRequestExtensions);
    }

    hr = _ReadRegistryStringArray(
			hkey,
			FALSE,			// fURL
			m_dwEditFlags,
			ARRAYSIZE(adwFlags),
			adwFlags,
			apwszRegNames,
			&m_cEnableRequestExtensions,
			&m_apwszEnableRequestExtensions);
    _JumpIfError(hr, error, "_ReadRegistryStringArray");

    _DumpStringArray(
		"Request",
		m_cEnableRequestExtensions,
		m_apwszEnableRequestExtensions);

    hr = _ReadRegistryStringArray(
			hkey,
			FALSE,			// fURL
			m_dwEditFlags,
			ARRAYSIZE(adwFlags),
			adwFlags,
			apwszRegNamesEnrollee,
			&m_cEnableEnrolleeRequestExtensions,
			&m_apwszEnableEnrolleeRequestExtensions);
    _JumpIfError(hr, error, "_ReadRegistryStringArray");

    _DumpStringArray(
		"EnrolleeRequest",
		m_cEnableEnrolleeRequestExtensions,
		m_apwszEnableEnrolleeRequestExtensions);

error:
    ;
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_InitDisableExtensionList
//
//+--------------------------------------------------------------------------

VOID
CCertPolicySample::_InitDisableExtensionList(
    IN HKEY hkey)
{
    HRESULT hr;
    DWORD adwFlags[] = {
	EDITF_DISABLEEXTENSIONLIST,
    };
    WCHAR *apwszRegNames[] = {
	wszREGDISABLEEXTENSIONLIST,
    };

    assert(ARRAYSIZE(adwFlags) == ARRAYSIZE(apwszRegNames));

    // clean up from previous call

    if (NULL != m_apwszDisableExtensions)
    {
        _FreeStringArray(&m_cDisableExtensions, &m_apwszDisableExtensions);
    }


    hr = _ReadRegistryStringArray(
			hkey,
			FALSE,			// fURL
			m_dwEditFlags,
			ARRAYSIZE(adwFlags),
			adwFlags,
			apwszRegNames,
			&m_cDisableExtensions,
			&m_apwszDisableExtensions);
    _JumpIfError(hr, error, "_ReadRegistryStringArray");

    _DumpStringArray(
		"Disable",
		m_cDisableExtensions,
		m_apwszDisableExtensions);

error:
    ;
}




//+--------------------------------------------------------------------------
// CCertPolicySample::Initialize
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicySample::Initialize(
    /* [in] */ BSTR const strConfig)
{
    HRESULT hr;
    HKEY hkey = NULL;
    DWORD dwType;
    DWORD dwSize;
    ICertServerPolicy *pServer = NULL;
    BOOL fUpgraded;
    BSTR bstrDescription = NULL;

    CERT_RDN_ATTR rdnAttr = { szOID_COMMON_NAME, CERT_RDN_ANY_TYPE, };

    rdnAttr.Value.pbData = NULL;

    DBGPRINT((fDebug, "Policy:Initialize:\n"));


    __try
    {
	_Cleanup();

	m_strCAName = SysAllocString(strConfig);
	if (NULL == m_strCAName)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "CCertPolicySample::SysAllocString");
	}

	// force loading the description from resources

	hr = GetDescription(&bstrDescription);
	_LeaveIfError(hr, "CCertPolicySample::GetDescription");

	// get server callbacks

	hr = polGetServerCallbackInterface(&pServer, 0);
	_LeaveIfError(hr, "Policy:polGetServerCallbackInterface");

	hr = ReqInitialize(pServer);
	_JumpIfError(hr, error, "ReqInitialize");


	// get storage location
	hr = polGetCertificateStringProperty(
				    pServer,
				    wszPROPMODULEREGLOC,
				    &m_strRegStorageLoc);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPMODULEREGLOC);


	// get CA type

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPCATYPE,
				    (LONG *) &m_CAType);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCATYPE);


	// get sanitized name

	hr = polGetCertificateStringProperty(
				    pServer,
				    wszPROPSANITIZEDCANAME,
				    &m_strCASanitizedName);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPSANITIZEDCANAME);

	// get sanitized name

	hr = polGetCertificateStringProperty(
				    pServer,
				    wszPROPSANITIZEDSHORTNAME,
				    &m_strCASanitizedDSName);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPSANITIZEDSHORTNAME);

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPSERVERUPGRADED,
				    (LONG *) &fUpgraded);
	if (S_OK != hr)
	{
	    fUpgraded = FALSE;
	    _PrintErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPSERVERUPGRADED);
	}

	hr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		m_strRegStorageLoc,
		0,              // dwReserved
		fUpgraded?
		    KEY_ALL_ACCESS :
		    (KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE),
		&hkey);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:Initialize:RegOpenKeyEx",
		    m_strRegStorageLoc);

	// Ignore error codes.

	dwSize = sizeof(m_dwDispositionFlags);
	hr = RegQueryValueEx(
			hkey,
			wszREGREQUESTDISPOSITION,
			0,
			&dwType,
			(BYTE *) &m_dwDispositionFlags,
			&dwSize);
	if (S_OK != hr || REG_DWORD != dwType)
	{
	    m_dwDispositionFlags = REQDISP_PENDINGFIRST | REQDISP_ISSUE;
	}
	DBGPRINT((
	    fDebug,
	    "Disposition Flags = %x\n",
	    m_dwDispositionFlags));

	dwSize = sizeof(m_dwEditFlags);
	hr = RegQueryValueEx(
			hkey,
			wszREGEDITFLAGS,
			0,
			&dwType,
			(BYTE *) &m_dwEditFlags,
			&dwSize);
	if (S_OK != hr || REG_DWORD != dwType)
	{
	    m_dwEditFlags =
		    EDITF_DEFAULT_STANDALONE;
	}
	if (fUpgraded)
	{
	    DBGPRINT((
		fDebug,
		"Initialize: setting EDITF_SERVERUPGRADED\n"));

	    m_dwEditFlags |= EDITF_SERVERUPGRADED;
	    dwSize = sizeof(m_dwEditFlags);
	    hr = RegSetValueEx(
			    hkey,
			    wszREGEDITFLAGS,
			    0,
			    REG_DWORD,
			    (BYTE *) &m_dwEditFlags,
			    dwSize);
	    _PrintIfError(hr, "Policy:RegSetValueEx");
	}
	DBGPRINT((fDebug, "Edit Flags = %x\n", m_dwEditFlags));

	dwSize = sizeof(m_CAPathLength);
	hr = RegQueryValueEx(
			hkey,
			wszREGCAPATHLENGTH,
			0,
			&dwType,
			(BYTE *) &m_CAPathLength,
			&dwSize);
	if (S_OK != hr || REG_DWORD != dwType)
	{
	    m_CAPathLength = CAPATHLENGTH_INFINITE;
	}
	DBGPRINT((fDebug, "CAPathLength = %x\n", m_CAPathLength));


	// Initialize the insertion string array.
	// Machine DNS name (%1)

	hr = polGetCertificateStringProperty(
			    pServer,
			    wszPROPMACHINEDNSNAME,
			    &m_strMachineDNSName);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateStringProperty",
		    wszPROPMACHINEDNSNAME);

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPCERTCOUNT,
				    (LONG *) &m_iCert);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCERTCOUNT);

	if (0 == m_iCert)	// no CA certs?
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _LeaveIfErrorStr(
			hr,
			"Policy:polGetCertificateLongProperty",
			wszPROPCERTCOUNT);
	}
	m_iCert--;

	hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPCRLINDEX,
				    (LONG *) &m_iCRL);
	_LeaveIfErrorStr(
		    hr,
		    "Policy:polGetCertificateLongProperty",
		    wszPROPCRLINDEX);

	_InitRevocationExtension(hkey);
	_InitRequestExtensionList(hkey);
	_InitDisableExtensionList(hkey);

	hr = S_OK;
    }
    __except(hr = ceHError(GetExceptionCode()), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

error:
    if (NULL != bstrDescription)
    {
        SysFreeString(bstrDescription);
    }
    if (NULL != hkey)
    {
	RegCloseKey(hkey);
    }
    if (NULL != pServer)
    {
	pServer->Release();
    }
    return(ceHError(hr));	// Reg routines return Win32 error codes
}


DWORD
polFindObjIdInList(
    IN WCHAR const *pwsz,
    IN DWORD count,
    IN WCHAR const * const *ppwsz)
{
    DWORD i;

    for (i = 0; i < count; i++)
    {
	if (NULL == pwsz || NULL == ppwsz[i])
	{
	    i = count;
	    break;
	}
	if (0 == wcscmp(pwsz, ppwsz[i]))
	{
	    break;
	}
    }
    return(i < count? i : MAXDWORD);
}


HRESULT
CCertPolicySample::_EnumerateExtensions(
    IN ICertServerPolicy *pServer,
    IN LONG bNewRequest,
    IN BOOL fFirstPass,
    IN BOOL fEnableEnrolleeExtensions,
    IN DWORD cCriticalExtensions,
    OPTIONAL IN WCHAR const * const *apwszCriticalExtensions)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strName = NULL;
    LONG ExtFlags;
    VARIANT varValue;
    BOOL fClose = FALSE;
    BOOL fEnable;
    BOOL fDisable;
    BOOL fCritical;

    VariantInit(&varValue);

    hr = pServer->EnumerateExtensionsSetup(0);
    _JumpIfError(hr, error, "Policy:EnumerateExtensionsSetup");

    fClose = TRUE;
    while (TRUE)
    {
        hr = pServer->EnumerateExtensions(&strName);
        if (S_FALSE == hr)
        {
            hr = S_OK;
            break;
        }
        _JumpIfError(hr, error, "Policy:EnumerateExtensions");

        hr = pServer->GetCertificateExtension(
                                        strName,
                                        PROPTYPE_BINARY,
                                        &varValue);
        _JumpIfError(hr, error, "Policy:GetCertificateExtension");

        hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	_JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

	fEnable = FALSE;
	fDisable = FALSE;
	fCritical = FALSE;

        if (fFirstPass)
        {
            if (bNewRequest && (EXTENSION_DISABLE_FLAG & ExtFlags))
            {
                switch (EXTENSION_ORIGIN_MASK & ExtFlags)
                {
                    case EXTENSION_ORIGIN_REQUEST:
                    case EXTENSION_ORIGIN_RENEWALCERT:
                    case EXTENSION_ORIGIN_PKCS7:
                    case EXTENSION_ORIGIN_CMC:
                    if ((EDITF_ENABLEREQUESTEXTENSIONS & m_dwEditFlags) ||
			MAXDWORD != polFindObjIdInList(
				    strName,
				    m_cEnableRequestExtensions,
				    m_apwszEnableRequestExtensions) ||
			(fEnableEnrolleeExtensions &&
			 MAXDWORD != polFindObjIdInList(
				    strName,
				    m_cEnableEnrolleeRequestExtensions,
				    m_apwszEnableEnrolleeRequestExtensions)))
                    {
			ExtFlags &= ~EXTENSION_DISABLE_FLAG;
			fEnable = TRUE;
                    }
                    break;
                }
            }
        }
        else
        {
            if (0 == (EXTENSION_DISABLE_FLAG & ExtFlags) &&
		MAXDWORD != polFindObjIdInList(
				    strName,
				    m_cDisableExtensions,
				    m_apwszDisableExtensions))
            {
                ExtFlags |= EXTENSION_DISABLE_FLAG;
                fDisable = TRUE;
            }
            if (0 == (EXTENSION_CRITICAL_FLAG & ExtFlags) &&
		MAXDWORD != polFindObjIdInList(
				    strName,
				    cCriticalExtensions,
				    apwszCriticalExtensions))
            {
                ExtFlags |= EXTENSION_CRITICAL_FLAG;
                fCritical = TRUE;
            }
        }

        if (fDisable || fEnable)
        {
            hr = pServer->SetCertificateExtension(
			            strName,
			            PROPTYPE_BINARY,
			            ExtFlags,
			            &varValue);
            _JumpIfError(hr, error, "Policy:SetCertificateExtension");
        }

        if (fFirstPass || fDisable || fEnable)
        {
	    DBGPRINT((
		fDebug,
                "Policy:EnumerateExtensions(%ws, Flags=%x, %x bytes)%hs%hs\n",
                strName,
                ExtFlags,
                SysStringByteLen(varValue.bstrVal),
		fDisable? " DISABLING" : (fEnable? " ENABLING" : ""),
		fCritical? " +CRITICAL" : ""));
        }
	if (NULL != strName)
	{
	    SysFreeString(strName);
	    strName = NULL;
	}
        VariantClear(&varValue);
    }

error:
    if (fClose)
    {
        hr2 = pServer->EnumerateExtensionsClose();
        if (S_OK != hr2)
        {
            if (S_OK == hr)
            {
                hr = hr2;
            }
	    _PrintError(hr2, "Policy:EnumerateExtensionsClose");
        }
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    VariantClear(&varValue);
    return(hr);
}


HRESULT
EnumerateAttributes(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strName = NULL;
    BOOL fClose = FALSE;
    BSTR strValue = NULL;

    hr = pServer->EnumerateAttributesSetup(0);
    _JumpIfError(hr, error, "Policy:EnumerateAttributesSetup");

    fClose = TRUE;
    while (TRUE)
    {
        hr = pServer->EnumerateAttributes(&strName);
	if (S_FALSE == hr)
	{
	    hr = S_OK;
	    break;
	}
	_JumpIfError(hr, error, "Policy:EnumerateAttributes");

        hr = pServer->GetRequestAttribute(strName, &strValue);
	_JumpIfError(hr, error, "Policy:GetRequestAttribute");

	DBGPRINT((
		fDebug,
                "Policy:EnumerateAttributes(%ws = %ws)\n",
                strName,
                strValue));
        if (NULL != strName)
        {
            SysFreeString(strName);
            strName = NULL;
        }
        if (NULL != strValue)
        {
            SysFreeString(strValue);
            strValue = NULL;
        }
    }

error:
    if (fClose)
    {
        hr2 = pServer->EnumerateAttributesClose();
        if (S_OK != hr2)
        {
	    _PrintError(hr2, "Policy:EnumerateAttributesClose");
            if (S_OK == hr)
            {
                hr = hr2;
            }
        }
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strValue)
    {
        SysFreeString(strValue);
    }
    return(hr);
}


HRESULT
GetRequestId(
    IN ICertServerPolicy *pServer,
    OUT LONG *plRequestId)
{
    HRESULT hr;

    hr = polGetRequestLongProperty(pServer, wszPROPREQUESTREQUESTID, plRequestId);
    _JumpIfError(hr, error, "Policy:polGetRequestLongProperty");

    DBGPRINT((
	fDebug,
	"Policy:GetRequestId(%ws = %u)\n",
	wszPROPREQUESTREQUESTID,
	*plRequestId));

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_AddRevocationExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_AddRevocationExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BSTR strASPExtension = NULL;
    VARIANT varExtension;

    if (NULL != m_wszASPRevocationURL)
    {
	strASPExtension = SysAllocString(m_wszASPRevocationURL);
	if (NULL == strASPExtension)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}

	varExtension.vt = VT_BSTR;
	varExtension.bstrVal = strASPExtension;
	hr = polSetCertificateExtension(
				pServer,
				TEXT(szOID_NETSCAPE_REVOCATION_URL),
				PROPTYPE_STRING,
				0,
				&varExtension);
	_JumpIfErrorStr(hr, error, "Policy:polSetCertificateExtension", L"ASP");
    }

error:
    if (NULL != strASPExtension)
    {
        SysFreeString(strASPExtension);
    }
    return(hr);
}


#define HIGHBIT(bitno)	(1 << (7 - (bitno)))	// bit counted from high end

#define SSLBIT_CLIENT	((BYTE) HIGHBIT(0))	// certified for client auth
#define SSLBIT_SERVER	((BYTE) HIGHBIT(1))	// certified for server auth
#define SSLBIT_SMIME	((BYTE) HIGHBIT(2))	// certified for S/MIME
#define SSLBIT_SIGN	((BYTE) HIGHBIT(3))	// certified for signing

#define SSLBIT_RESERVED	((BYTE) HIGHBIT(4))	// reserved for future use

#define SSLBIT_CASSL	((BYTE) HIGHBIT(5))	// CA for SSL auth certs
#define SSLBIT_CASMIME	((BYTE) HIGHBIT(6))	// CA for S/MIME certs
#define SSLBIT_CASIGN	((BYTE) HIGHBIT(7))	// CA for signing certs

#define NSCERTTYPE_CLIENT  ((BYTE) SSLBIT_CLIENT)
#define NSCERTTYPE_SERVER  ((BYTE) (SSLBIT_SERVER | SSLBIT_CLIENT))
#define NSCERTTYPE_SMIME   ((BYTE) SSLBIT_SMIME)
#define NSCERTTYPE_CA	   ((BYTE) (SSLBIT_CASSL | SSLBIT_CASMIME | SSLBIT_CASIGN))

//+--------------------------------------------------------------------------
// CCertPolicySample::_AddOldCertTypeExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_AddOldCertTypeExtension(
    IN ICertServerPolicy *pServer,
    IN BOOL fCA)
{
    HRESULT hr = S_OK;
    ICertEncodeBitString *pBitString = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strBitString = NULL;
    BSTR strCertType = NULL;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    VARIANT varConstraints;
    DWORD cb;

    VariantInit(&varConstraints);

    if (EDITF_ADDOLDCERTTYPE & m_dwEditFlags)
    {
	BYTE CertType;

	if (!fCA)
	{
	    hr = polGetCertificateExtension(
				    pServer,
				    TEXT(szOID_BASIC_CONSTRAINTS2),
				    PROPTYPE_BINARY,
				    &varConstraints);
	    if (S_OK == hr)
	    {
		cb = sizeof(Constraints);
		if (!CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_BASIC_CONSTRAINTS2,
				    (BYTE const *) varConstraints.bstrVal,
				    SysStringByteLen(varConstraints.bstrVal),
				    0,
				    &Constraints,
				    &cb))
		{
		    hr = ceHLastError();
		    _JumpError(hr, error, "Policy:CryptDecodeObject");
		}
		fCA = Constraints.fCA;
	    }
	}

	hr = CoCreateInstance(
			CLSID_CCertEncodeBitString,
			NULL,               // pUnkOuter
			CLSCTX_INPROC_SERVER,
			IID_ICertEncodeBitString,
			(VOID **) &pBitString);
	_JumpIfError(hr, error, "Policy:CoCreateInstance");

	CertType = NSCERTTYPE_CLIENT;	// Default to client auth. cert
	if (fCA)
	{
	    CertType = NSCERTTYPE_CA;
	}
	else
	{
	    hr = polGetRequestAttribute(pServer, wszPROPCERTTYPE, &strCertType);
	    if (S_OK == hr)
	    {
		if (0 == celstrcmpiL(strCertType, L"server"))
		{
		    CertType = NSCERTTYPE_SERVER;
		}
	    }
	}

        if (!ceConvertWszToBstr(
		    &strBitString,
		    (WCHAR const *) &CertType,
		    sizeof(CertType)))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:ceConvertWszToBstr");
	}

	hr = pBitString->Encode(
			    sizeof(CertType) * 8,
			    strBitString,
			    &strExtension);
	_JumpIfError(hr, error, "Policy:BitString:Encode");

        varExtension.vt = VT_BSTR;
	varExtension.bstrVal = strExtension;
	hr = polSetCertificateExtension(
				pServer,
				TEXT(szOID_NETSCAPE_CERT_TYPE),
				PROPTYPE_BINARY,
				0,
				&varExtension);
	_JumpIfError(hr, error, "Policy:polSetCertificateExtension");
    }

error:
    VariantClear(&varConstraints);
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strBitString)
    {
        SysFreeString(strBitString);
    }
    if (NULL != strCertType)
    {
        SysFreeString(strCertType);
    }
    if (NULL != pBitString)
    {
        pBitString->Release();
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_AddAuthorityKeyId
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_AddAuthorityKeyId(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr = S_OK;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    VARIANT varExtensionT;
    PCERT_AUTHORITY_KEY_ID2_INFO pInfo = NULL;
    DWORD cbInfo = 0;
    LONG ExtFlags = 0;

    VariantInit(&varExtension);

    // Optimization

    if ((EDITF_ENABLEAKIKEYID |
	 EDITF_ENABLEAKIISSUERNAME |
	 EDITF_ENABLEAKIISSUERSERIAL) ==
	((EDITF_ENABLEAKIKEYID |
	  EDITF_ENABLEAKIISSUERNAME |
	  EDITF_ENABLEAKIISSUERSERIAL |
	  EDITF_ENABLEAKICRITICAL) & m_dwEditFlags))
    {
        goto error;
    }

    hr = polGetCertificateExtension(
			    pServer,
			    TEXT(szOID_AUTHORITY_KEY_IDENTIFIER2),
			    PROPTYPE_BINARY,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:polGetCertificateExtension");

    hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
    _JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

    if (VT_BSTR != varExtension.vt)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Policy:GetCertificateExtension");
    }

    cbInfo = 0;
    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
                    X509_AUTHORITY_KEY_ID2,
                    (BYTE *) varExtension.bstrVal,
                    SysStringByteLen(varExtension.bstrVal),
		    FALSE,
                    (VOID **) &pInfo,
                    &cbInfo))
    {
	hr = ceHLastError();
	_JumpIfError(hr, error, "Policy:ceDecodeObject");
    }

    // Make Any Modifications Here

    if (0 == (EDITF_ENABLEAKIKEYID & m_dwEditFlags))
    {
        pInfo->KeyId.cbData = 0;
        pInfo->KeyId.pbData = NULL;
    }
    if (0 == (EDITF_ENABLEAKIISSUERNAME & m_dwEditFlags))
    {
        pInfo->AuthorityCertIssuer.cAltEntry = 0;
        pInfo->AuthorityCertIssuer.rgAltEntry = NULL;
    }
    if (0 == (EDITF_ENABLEAKIISSUERSERIAL & m_dwEditFlags))
    {
        pInfo->AuthorityCertSerialNumber.cbData = 0;
        pInfo->AuthorityCertSerialNumber.pbData = NULL;
    }
    if (EDITF_ENABLEAKICRITICAL & m_dwEditFlags)
    {
	ExtFlags |= EXTENSION_CRITICAL_FLAG;
    }
    if (0 ==
	((EDITF_ENABLEAKIKEYID |
	  EDITF_ENABLEAKIISSUERNAME |
	  EDITF_ENABLEAKIISSUERSERIAL) & m_dwEditFlags))
    {
	ExtFlags |= EXTENSION_DISABLE_FLAG;
    }

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_AUTHORITY_KEY_ID2,
		    pInfo,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	_JumpError(hr, error, "Policy:ceEncodeObject");
    }
    if (!ceConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:ceConvertWszToBstr");
    }

    varExtensionT.vt = VT_BSTR;
    varExtensionT.bstrVal = strExtension;
    hr = polSetCertificateExtension(
			    pServer,
			    TEXT(szOID_AUTHORITY_KEY_IDENTIFIER2),
			    PROPTYPE_BINARY,
			    ExtFlags,
			    &varExtensionT);
    _JumpIfError(hr, error, "Policy:polSetCertificateExtension(AuthorityKeyId2)");

error:
    VariantClear(&varExtension);
    if (NULL != pInfo)
    {
	LocalFree(pInfo);
    }
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicy::_AddDefaultKeyUsageExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_AddDefaultKeyUsageExtension(
    IN ICertServerPolicy *pServer,
    IN BOOL fCA)
{
    HRESULT hr;
    BSTR strName = NULL;
    ICertEncodeBitString *pBitString = NULL;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    BSTR strBitString = NULL;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    VARIANT varConstraints;
    VARIANT varKeyUsage;
    CRYPT_BIT_BLOB *pKeyUsage = NULL;
    DWORD cb;
    BYTE abKeyUsage[1];
    BYTE *pbKeyUsage;
    DWORD cbKeyUsage;

    VariantInit(&varConstraints);
    VariantInit(&varKeyUsage);

    if (EDITF_ADDOLDKEYUSAGE & m_dwEditFlags)
    {
	BOOL fModified = FALSE;

	if (!fCA)
	{
	    hr = polGetCertificateExtension(
				    pServer,
				    TEXT(szOID_BASIC_CONSTRAINTS2),
				    PROPTYPE_BINARY,
				    &varConstraints);
	    if (S_OK == hr)
	    {
		cb = sizeof(Constraints);
		if (!CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_BASIC_CONSTRAINTS2,
				    (BYTE const *) varConstraints.bstrVal,
				    SysStringByteLen(varConstraints.bstrVal),
				    0,
				    &Constraints,
				    &cb))
		{
		    hr = ceHLastError();
		    _JumpError(hr, error, "Policy:CryptDecodeObject");
		}
		fCA = Constraints.fCA;
	    }
	}

	ZeroMemory(abKeyUsage, sizeof(abKeyUsage));
	pbKeyUsage = abKeyUsage;
	cbKeyUsage = sizeof(abKeyUsage);

	hr = polGetCertificateExtension(
				pServer,
				TEXT(szOID_KEY_USAGE),
				PROPTYPE_BINARY,
				&varKeyUsage);
	if (S_OK == hr)
	{
	    if (!ceDecodeObject(
			    X509_ASN_ENCODING,
			    X509_KEY_USAGE,
			    (BYTE const *) varKeyUsage.bstrVal,
			    SysStringByteLen(varKeyUsage.bstrVal),
			    FALSE,
			    (VOID **) &pKeyUsage,
			    &cb))
	    {
		hr = GetLastError();
		_PrintError(hr, "Policy:ceDecodeObject");
	    }
	    else if (0 != cb && NULL != pKeyUsage && 0 != pKeyUsage->cbData)
	    {
		pbKeyUsage = pKeyUsage->pbData;
		cbKeyUsage = pKeyUsage->cbData;
	    }
	}

	if ((CERT_KEY_ENCIPHERMENT_KEY_USAGE & pbKeyUsage[0]) &&
	    (CERT_KEY_AGREEMENT_KEY_USAGE & pbKeyUsage[0]))
	{
	    pbKeyUsage[0] &= ~CERT_KEY_AGREEMENT_KEY_USAGE;
	    pbKeyUsage[0] |= CERT_DIGITAL_SIGNATURE_KEY_USAGE;
	    fModified = TRUE;
	}
	if (fCA)
	{
	    pbKeyUsage[0] |= ceCASIGN_KEY_USAGE;
	    fModified = TRUE;
	}
	if (fModified)
	{
	    hr = CoCreateInstance(
			    CLSID_CCertEncodeBitString,
			    NULL,               // pUnkOuter
			    CLSCTX_INPROC_SERVER,
			    IID_ICertEncodeBitString,
			    (VOID **) &pBitString);
	    _JumpIfError(hr, error, "Policy:CoCreateInstance");

	    if (!ceConvertWszToBstr(
			&strBitString,
			(WCHAR const *) pbKeyUsage,
			cbKeyUsage))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:ceConvertWszToBstr");
	    }

	    hr = pBitString->Encode(cbKeyUsage * 8, strBitString, &strExtension);
	    _JumpIfError(hr, error, "Policy:Encode");

	    if (!ceConvertWszToBstr(&strName, TEXT(szOID_KEY_USAGE), -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:ceConvertWszToBstr");
	    }
	    varExtension.vt = VT_BSTR;
	    varExtension.bstrVal = strExtension;
	    hr = pServer->SetCertificateExtension(
				    strName,
				    PROPTYPE_BINARY,
				    0,
				    &varExtension);
	    _JumpIfError(hr, error, "Policy:SetCertificateExtension");
	}
    }
    hr = S_OK;

error:
    VariantClear(&varConstraints);
    VariantClear(&varKeyUsage);
    if (NULL != pKeyUsage)
    {
        LocalFree(pKeyUsage);
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != strBitString)
    {
        SysFreeString(strBitString);
    }
    if (NULL != pBitString)
    {
        pBitString->Release();
    }
    return(hr);
}


HRESULT
CCertPolicySample::_AddEnhancedKeyUsageExtension(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    BSTR strUsage = NULL;
    char *pszUsage = NULL;
    char *psz;
    char *pszNext;
    CERT_ENHKEY_USAGE ceu;
    CERT_POLICIES_INFO cpi;
    BYTE *pbKeyUsage = NULL;
    DWORD cbKeyUsage;
    BYTE *pbPolicies = NULL;
    DWORD cbPolicies;
    CERT_POLICY_INFO *pcpi = NULL;
    DWORD i;
    VARIANT varExtension;
    
    ZeroMemory(&ceu, sizeof(ceu));
    ZeroMemory(&cpi, sizeof(cpi));
    VariantInit(&varExtension);

    if (0 == (EDITF_ATTRIBUTEEKU & m_dwEditFlags))
    {
	hr = S_OK;
	goto error;
    }
    hr = polGetRequestAttribute(pServer, wszPROPCERTUSAGE, &strUsage);
    if (S_OK != hr)
    {
	hr = S_OK;
	goto error;
    }
    if (!ceConvertWszToSz(&pszUsage, strUsage, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:ceConvertWszToSz");
    }
    for (psz = pszUsage; '\0' != *psz; psz = pszNext)
    {
	pszNext = &psz[strcspn(psz, ",")];
	if ('\0' != *pszNext)
	{
	    pszNext++;
	}
	ceu.cUsageIdentifier++;
    }
    if (0 == ceu.cUsageIdentifier)
    {
	hr = S_OK;
	goto error;
    }

    ceu.rgpszUsageIdentifier = (char **) LocalAlloc(
		LMEM_FIXED,
		ceu.cUsageIdentifier * sizeof(ceu.rgpszUsageIdentifier[0]));
    if (NULL == ceu.rgpszUsageIdentifier)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:myLocalAlloc");
    }

    // Destructively parse comma separated ObjIds into individual strings

    i = 0;
    for (psz = pszUsage; '\0' != *psz; psz = pszNext)
    {
	char *pszEnd;
	
	assert(i < ceu.cUsageIdentifier);
	pszNext = &psz[strcspn(psz, ",")];
	pszEnd = pszNext;
	if ('\0' != *pszNext)
	{
	    *pszNext++ = '\0';
	}
	while (' ' == *psz)
	{
	    psz++;
	}
	while (pszEnd > psz && ' ' == *--pszEnd)
	{
	    *pszEnd = '\0';
	}
	if ('\0' != *psz)
	{
	    hr = ceVerifyObjIdA(psz);
	    _JumpIfError(hr, error, "Policy:ceVerifyObjIdA");

	    ceu.rgpszUsageIdentifier[i++] = psz;
	}
    }
    ceu.cUsageIdentifier = i;
    if (0 == ceu.cUsageIdentifier)
    {
	hr = S_OK;
	goto error;
    }

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ENHANCED_KEY_USAGE,
		    &ceu,
		    0,
		    FALSE,
		    &pbKeyUsage,
		    &cbKeyUsage))
    {
	hr = ceHLastError();
	_JumpError(hr, error, "Policy:ceEncodeObject");
    }

    varExtension.bstrVal = NULL;
    if (!ceConvertWszToBstr(
			&varExtension.bstrVal,
			(WCHAR const *) pbKeyUsage,
			cbKeyUsage))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:ceConvertWszToBstr");
    }
    varExtension.vt = VT_BSTR;
    hr = polSetCertificateExtension(
			    pServer,
			    TEXT(szOID_ENHANCED_KEY_USAGE),
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:polSetCertificateExtension");

    cpi.cPolicyInfo = ceu.cUsageIdentifier;
    cpi.rgPolicyInfo = (CERT_POLICY_INFO *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cpi.cPolicyInfo * sizeof(cpi.rgPolicyInfo[0]));
    if (NULL == cpi.rgPolicyInfo)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:LocalAlloc");
    }
    for (i = 0; i < cpi.cPolicyInfo; i++)
    {
	cpi.rgPolicyInfo[i].pszPolicyIdentifier = ceu.rgpszUsageIdentifier[i];
    }
    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_POLICIES,
		    &cpi,
		    0,
		    FALSE,
		    &pbPolicies,
		    &cbPolicies))
    {
	hr = ceHLastError();
	_JumpError(hr, error, "Policy:ceEncodeObject");
    }

    if (!ceConvertWszToBstr(
			&varExtension.bstrVal,
			(WCHAR const *) pbPolicies,
			cbPolicies))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:ceConvertWszToBstr");
    }
    hr = polSetCertificateExtension(
			    pServer,
			    TEXT(szOID_APPLICATION_CERT_POLICIES),
			    PROPTYPE_BINARY,
			    0,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:polSetCertificateExtension");

error:
    if (NULL != pcpi)
    {
	LocalFree(pcpi);
    }
    VariantClear(&varExtension);
    if (NULL != ceu.rgpszUsageIdentifier)
    {
	LocalFree(ceu.rgpszUsageIdentifier);
    }
    if (NULL != pbPolicies)
    {
	LocalFree(pbPolicies);
    }
    if (NULL != pbKeyUsage)
    {
	LocalFree(pbKeyUsage);
    }
    if (NULL != pszUsage)
    {
	LocalFree(pszUsage);
    }
    if (NULL != strUsage)
    {
	SysFreeString(strUsage);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicy::_AddDefaultBasicConstraintsExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_AddDefaultBasicConstraintsExtension(
    IN ICertServerPolicy *pServer,
    IN BOOL               fCA)
{
    HRESULT hr;
    VARIANT varExtension;
    LONG ExtFlags;
    CERT_EXTENSION Ext;
    CERT_EXTENSION *pExtension = NULL;
    BSTR strCertType = NULL;

    VariantInit(&varExtension);

    if (EDITF_BASICCONSTRAINTSCA & m_dwEditFlags)
    {
        hr = polGetCertificateExtension(
				pServer,
				TEXT(szOID_BASIC_CONSTRAINTS2),
				PROPTYPE_BINARY,
				&varExtension);
        if (S_OK == hr)
        {
	    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
	    DWORD cb;

	    hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	    if (S_OK == hr)
	    {
                Ext.pszObjId = szOID_BASIC_CONSTRAINTS2;
                Ext.fCritical = FALSE;
                if (EXTENSION_CRITICAL_FLAG & ExtFlags)
                {
                    Ext.fCritical = TRUE;
                }
                Ext.Value.pbData = (BYTE *) varExtension.bstrVal;
                Ext.Value.cbData = SysStringByteLen(varExtension.bstrVal);
		pExtension = &Ext;

		cb = sizeof(Constraints);
		if (!fCA && CryptDecodeObject(
			        X509_ASN_ENCODING,
			        X509_BASIC_CONSTRAINTS2,
			        Ext.Value.pbData,
			        Ext.Value.cbData,
			        0,
			        &Constraints,
			        &cb))
		{
		    fCA = Constraints.fCA;
		}
	    }
	}
    }

    if (EDITF_ATTRIBUTECA & m_dwEditFlags)
    {
        if (!fCA)
        {
	    hr = polGetRequestAttribute(pServer, wszPROPCERTTYPE, &strCertType);
            if (S_OK == hr)
            {
                if (0 == celstrcmpiL(strCertType, L"ca"))
                {
                    fCA = TRUE;
                }
            }
        }
        if (!fCA)
        {
	    hr = polGetRequestAttribute(pServer, wszPROPCERTTEMPLATE, &strCertType);
            if (S_OK == hr)
            {
                if (0 == celstrcmpiL(strCertType, wszCERTTYPE_SUBORDINATE_CA) ||
		    0 == celstrcmpiL(strCertType, wszCERTTYPE_CROSS_CA))
                {
                    fCA = TRUE;
                }
            }
	}
    }

    // For standalone, the extension is only enabled if it's a CA

    hr = AddBasicConstraintsCommon(pServer, pExtension, fCA, fCA);
    _JumpIfError(hr, error, "Policy:AddBasicConstraintsCommon");

error:
    VariantClear(&varExtension);
    if (NULL != strCertType)
    {
        SysFreeString(strCertType);
    }
    return(hr);
}


HRESULT
CCertPolicySample::AddBasicConstraintsCommon(
    IN ICertServerPolicy *pServer,
    IN CERT_EXTENSION const *pExtension,
    IN BOOL fCA,
    IN BOOL fEnableExtension)
{
    HRESULT hr;
    BSTR strExtension = NULL;
    VARIANT varExtension;
    CERT_CONTEXT const *pIssuerCert;
    CERT_EXTENSION *pIssuerExtension;
    LONG ExtFlags = 0;
    BYTE *pbConstraints = NULL;
    CERT_BASIC_CONSTRAINTS2_INFO Constraints;
    CERT_BASIC_CONSTRAINTS2_INFO IssuerConstraints;
    ZeroMemory(&IssuerConstraints, sizeof(IssuerConstraints));

    DWORD cb;

    pIssuerCert = _GetIssuer(pServer);
    if (NULL == pIssuerCert)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "_GetIssuer");
    }

    if (NULL != pExtension)
    {
        cb = sizeof(Constraints);
        if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_BASIC_CONSTRAINTS2,
			pExtension->Value.pbData,
			pExtension->Value.cbData,
			0,
			&Constraints,
			&cb))
        {
	    hr = ceHLastError();
	    _JumpError(hr, error, "Policy:CryptDecodeObject");
        }

        // Cert templates use CAPATHLENGTH_INFINITE to indicate
        // fPathLenConstraint should be FALSE.

        if (CAPATHLENGTH_INFINITE == Constraints.dwPathLenConstraint)
        {

            // NOTE: This is ok as certcli already sets fPathLenConstraint to FALSE
            // for templates in this case.
	    Constraints.fPathLenConstraint = FALSE;

            // NOTE: This is ok as autoenrollment ignores dwPathLenConstraint
            // if fPathLenConstraint is FALSE;
	    Constraints.dwPathLenConstraint = 0;
        }
        if (pExtension->fCritical)
        {
	    ExtFlags = EXTENSION_CRITICAL_FLAG;
        }
    }
    else
    {
	Constraints.fCA = fCA;
	Constraints.fPathLenConstraint = FALSE;
	Constraints.dwPathLenConstraint = 0;
    }
    if (EDITF_BASICCONSTRAINTSCRITICAL & m_dwEditFlags)
    {
        ExtFlags = EXTENSION_CRITICAL_FLAG;
    }

    // Check basic constraints against the issuer's cert.

    pIssuerExtension = CertFindExtension(
				szOID_BASIC_CONSTRAINTS2,
				pIssuerCert->pCertInfo->cExtension,
				pIssuerCert->pCertInfo->rgExtension);
    if (NULL != pIssuerExtension)
    {
        cb = sizeof(IssuerConstraints);
        if (!CryptDecodeObject(
			        X509_ASN_ENCODING,
			        X509_BASIC_CONSTRAINTS2,
			        pIssuerExtension->Value.pbData,
			        pIssuerExtension->Value.cbData,
			        0,
			        &IssuerConstraints,
			        &cb))
        {
            hr = ceHLastError();
            _JumpError(hr, error, "Policy:CryptDecodeObject");
        }
        if (!IssuerConstraints.fCA)
        {
            hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
            _JumpError(hr, error, "Policy:CA cert not a CA cert");
        }
    }

    if (Constraints.fCA)
    {
        if (IssuerConstraints.fPathLenConstraint)
        {
            if (0 == IssuerConstraints.dwPathLenConstraint)
            {
                hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
                _JumpError(hr, error, "Policy:CA cert is a leaf CA cert");
            }
            if (!Constraints.fPathLenConstraint ||
                Constraints.dwPathLenConstraint >
	            IssuerConstraints.dwPathLenConstraint - 1)
            {
                Constraints.fPathLenConstraint = TRUE;
                Constraints.dwPathLenConstraint =
                IssuerConstraints.dwPathLenConstraint - 1;
            }
        }
        if (CAPATHLENGTH_INFINITE != m_CAPathLength)
        {
            if (0 == m_CAPathLength)
            {
                hr = CERTSRV_E_INVALID_CA_CERTIFICATE;
                _JumpError(hr, error, "Policy:Registry says not to issue CA certs");
            }
            if (!Constraints.fPathLenConstraint ||
                Constraints.dwPathLenConstraint > m_CAPathLength - 1)
            {
                Constraints.fPathLenConstraint = TRUE;
                Constraints.dwPathLenConstraint = m_CAPathLength - 1;
            }
        }
    }

    if (!fEnableExtension)
    {
        ExtFlags |= EXTENSION_DISABLE_FLAG;
    }

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
                    X509_BASIC_CONSTRAINTS2,
                    &Constraints,
		    0,
		    FALSE,
                    &pbConstraints,
                    &cb))
    {
        hr = ceHLastError();
        _JumpError(hr, error, "Policy:ceEncodeObject");
    }

    if (!ceConvertWszToBstr(
			&strExtension,
			(WCHAR const *) pbConstraints,
			cb))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:ceConvertWszToBstr");
    }

    varExtension.vt = VT_BSTR;
    varExtension.bstrVal = strExtension;
    hr = polSetCertificateExtension(
			    pServer,
			    TEXT(szOID_BASIC_CONSTRAINTS2),
			    PROPTYPE_BINARY,
			    ExtFlags,
			    &varExtension);
    _JumpIfError(hr, error, "Policy:polSetCertificateExtension");

error:
    if (NULL != pbConstraints)
    {
        LocalFree(pbConstraints);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicy::_SetValidityPeriod
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::_SetValidityPeriod(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    BSTR strPeriodString = NULL;
    BSTR strPeriodCount = NULL;
    BSTR strNameNotBefore = NULL;
    BSTR strNameNotAfter = NULL;
    VARIANT varValue;
    LONG lDelta;
    ENUM_PERIOD enumValidityPeriod;
    BOOL fValidDigitString;

    VariantInit(&varValue);

    if (!(EDITF_ATTRIBUTEENDDATE & m_dwEditFlags))
    {
	hr = S_OK;
	goto error;
    }

    hr = polGetRequestAttribute(
			pServer,
			wszPROPVALIDITYPERIODSTRING,
			&strPeriodString);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		hr,
		"Policy:polGetRequestAttribute",
		wszPROPVALIDITYPERIODSTRING,
		CERTSRV_E_PROPERTY_EMPTY);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    hr = polGetRequestAttribute(
			pServer,
			wszPROPVALIDITYPERIODCOUNT,
			&strPeriodCount);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		hr,
		"Policy:polGetRequestAttribute",
		wszPROPVALIDITYPERIODCOUNT,
		CERTSRV_E_PROPERTY_EMPTY);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    // Swap Count and String BSTRs if backwards -- Windows 2000 had it wrong.

    lDelta = ceWtoI(strPeriodCount, &fValidDigitString);
    if (!fValidDigitString)
    {
	BSTR str = strPeriodCount;

	strPeriodCount = strPeriodString;
	strPeriodString = str;

	lDelta = ceWtoI(strPeriodCount, &fValidDigitString);
	if (!fValidDigitString)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Policy:ceWtoI");
	}
    }

    hr = ceTranslatePeriodUnits(strPeriodString, lDelta, &enumValidityPeriod, &lDelta);
    _JumpIfError(hr, error, "Policy:ceTranslatePeriodUnits");

    strNameNotBefore = SysAllocString(wszPROPCERTIFICATENOTBEFOREDATE);
    if (NULL == strNameNotBefore)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateProperty(
				strNameNotBefore,
				PROPTYPE_DATE,
				&varValue);
    _JumpIfError(hr, error, "Policy:GetCertificateProperty");

    hr = ceMakeExprDate(&varValue.date, lDelta, enumValidityPeriod);
    _JumpIfError(hr, error, "Policy:ceMakeExprDate");

    strNameNotAfter = SysAllocString(wszPROPCERTIFICATENOTAFTERDATE);
    if (NULL == strNameNotAfter)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->SetCertificateProperty(
				strNameNotAfter,
				PROPTYPE_DATE,
				&varValue);
    _JumpIfError(hr, error, "Policy:SetCertificateProperty");

    hr = S_OK;

error:
    VariantClear(&varValue);
    if (NULL != strPeriodString)
    {
	SysFreeString(strPeriodString);
    }
    if (NULL != strPeriodCount)
    {
	SysFreeString(strPeriodCount);
    }
    if (NULL != strNameNotBefore)
    {
        SysFreeString(strNameNotBefore);
    }
    if (NULL != strNameNotAfter)
    {
        SysFreeString(strNameNotAfter);
    }
    return(hr);
}



//+--------------------------------------------------------------------------
// CCertPolicySample::_AddV1TemplateNameExtension
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertPolicySample::AddV1TemplateNameExtension(
    IN ICertServerPolicy *pServer,
    OPTIONAL IN WCHAR const *pwszTemplateName)
{
    HRESULT hr;
    BSTR strName = NULL;
    LONG ExtFlags = 0;
    VARIANT varExtension;
    CERT_NAME_VALUE *pName = NULL;
    CERT_NAME_VALUE NameValue;
    DWORD cbEncoded;
    BYTE *pbEncoded = NULL;
    BOOL fUpdate = TRUE;

    VariantInit(&varExtension);

    strName = SysAllocString(TEXT(szOID_ENROLL_CERTTYPE_EXTENSION));
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }

    hr = pServer->GetCertificateExtension(
				    strName,
				    PROPTYPE_BINARY,
				    &varExtension);
    _PrintIfError2(hr, "Policy:GetCertificateExtension", hr);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	if (NULL == pwszTemplateName)
	{
	    hr = S_OK;
	    goto error;
	}
    }
    else
    {
	_JumpIfError(hr, error, "Policy:GetCertificateExtension");

	hr = pServer->GetCertificateExtensionFlags(&ExtFlags);
	_JumpIfError(hr, error, "Policy:GetCertificateExtensionFlags");

	if (VT_BSTR == varExtension.vt &&
	    0 == (EXTENSION_DISABLE_FLAG & ExtFlags) &&
	    NULL != pwszTemplateName)
	{
	    if (!ceDecodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			(BYTE *) varExtension.bstrVal,
			SysStringByteLen(varExtension.bstrVal),
			FALSE,
			(VOID **) &pName,
			&cbEncoded))
	    {
		hr = ceHLastError();
		_JumpError(hr, error, "Policy:ceDecodeObject");
	    }

	    // case sensitive compare -- be sure to match case of template

	    if (0 == lstrcmp(
			(WCHAR const *) pName->Value.pbData,
			pwszTemplateName))
	    {
		fUpdate = FALSE;
	    }
	}
    }
    if (fUpdate)
    {
	if (NULL == pwszTemplateName)
	{
	    ExtFlags |= EXTENSION_DISABLE_FLAG;
	}
	else
	{
	    VariantClear(&varExtension);
	    varExtension.bstrVal = NULL;

	    NameValue.dwValueType = CERT_RDN_UNICODE_STRING;
	    NameValue.Value.pbData = (BYTE *) pwszTemplateName;
	    NameValue.Value.cbData = 0;

	    if (!ceEncodeObject(
			    X509_ASN_ENCODING,
			    X509_UNICODE_ANY_STRING,
			    &NameValue,
			    0,
			    FALSE,
			    &pbEncoded,
			    &cbEncoded))
	    {
		hr = ceHLastError();
		_JumpError(hr, error, "Policy:ceEncodeObject");
	    }
	    if (!ceConvertWszToBstr(
				&varExtension.bstrVal,
				(WCHAR const *) pbEncoded,
				cbEncoded))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "Policy:ceConvertWszToBstr");
	    }
	    varExtension.vt = VT_BSTR;
	    ExtFlags &= ~EXTENSION_DISABLE_FLAG;
	}
	hr = pServer->SetCertificateExtension(
				strName,
				PROPTYPE_BINARY,
				ExtFlags,
				&varExtension);
	_JumpIfError(hr, error, "Policy:SetCertificateExtension");
    }
    hr = S_OK;

error:
    VariantClear(&varExtension);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    if (NULL != pName)
    {
	LocalFree(pName);
    }
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(hr);
}


STDMETHODIMP
CCertPolicySample::VerifyRequest(
    /* [in] */ BSTR const, // strConfig
    /* [in] */ LONG Context,
    /* [in] */ LONG bNewRequest,
    /* [in] */ LONG, // Flags
    /* [out, retval] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr = E_FAIL;
    ICertServerPolicy *pServer = NULL;
    LONG lRequestId;
    CRequestInstance Request;
    BSTR strDisposition = NULL;
    BOOL fEnableEnrolleeExtensions;
    BOOL fReenroll = FALSE;
    DWORD cCriticalExtensions = 0;
    WCHAR const * const *apwszCriticalExtensions = NULL;

    lRequestId = 0;


    __try
    {
	if (NULL == pDisposition)
	{
	    hr = E_POINTER;
	    _LeaveError(hr, "Policy:pDisposition");
	}
	*pDisposition = VR_INSTANT_BAD;

	hr = polGetServerCallbackInterface(&pServer, Context);
	_LeaveIfError(hr, "Policy:polGetServerCallbackInterface");

	hr = GetRequestId(pServer, &lRequestId);
	_JumpIfError(hr, deny, "Policy:GetRequestId");

	// only need to check user access for original submitter:
	// resubmit can only be called by admins

	if (bNewRequest && (0 == (m_dwEditFlags & EDITF_IGNOREREQUESTERGROUP)))
	{
	    BOOL fRequesterAccess = FALSE;

	    // Is this user allowed to request certs?
	    hr = polGetCertificateLongProperty(
				    pServer,
				    wszPROPREQUESTERCAACCESS,
				    (LONG *) &fRequesterAccess);
	    _PrintIfErrorStr(
			hr,
			"Policy:polGetCertificateLongProperty",
			wszPROPREQUESTERCAACCESS);
	    if (hr != S_OK || !fRequesterAccess)
	    {
		hr = CERTSRV_E_ENROLL_DENIED;
		_JumpError(hr, deny, "Policy:fRequesterAccess");
	    }
	}


	hr = Request.Initialize(
			    this,
			    pServer,
			    &fEnableEnrolleeExtensions);
	_LeaveIfError(hr, "Policy:VerifyRequest:Request.Initialize");


	hr = _EnumerateExtensions(
			    pServer,
			    bNewRequest,
			    TRUE,
			    fEnableEnrolleeExtensions,
			    0,
			    NULL);
	_LeaveIfError(hr, "_EnumerateExtensions");

	{
	    hr = _AddDefaultBasicConstraintsExtension(
						pServer,
						Request.IsCARequest());
	    _LeaveIfError(hr, "_AddDefaultBasicConstraintsExtension");

	    hr = _AddDefaultKeyUsageExtension(pServer, Request.IsCARequest());
	    _LeaveIfError(hr, "_AddDefaultKeyUsageExtension");

	    hr = _AddEnhancedKeyUsageExtension(pServer);
	    _LeaveIfError(hr, "_AddEnhancedKeyUsageExtension");
	}

	hr = _SetValidityPeriod(pServer);
	_LeaveIfError(hr, "_SetValidityPeriod");

	hr = EnumerateAttributes(pServer);
	_LeaveIfError(hr, "Policy:EnumerateAttributes");

	hr = _AddRevocationExtension(pServer);
	_LeaveIfError(hr, "_AddRevocationExtension");

	hr = _AddOldCertTypeExtension(pServer, Request.IsCARequest());
	_LeaveIfError(hr, "_AddOldCertTypeExtension");

	hr = _AddAuthorityKeyId(pServer);
	_LeaveIfError(hr, "_AddAuthorityKeyId");


	// pass hr as Disposition

	if ((EDITF_DISABLEEXTENSIONLIST & m_dwEditFlags) ||
	    NULL != apwszCriticalExtensions)
	{
	    hr = _EnumerateExtensions(
				pServer,
				bNewRequest,
				FALSE,
				FALSE,
				cCriticalExtensions,
				apwszCriticalExtensions);
	    _LeaveIfError(hr, "_EnumerateExtensions");
	}

	if (bNewRequest &&
	    (
	     (REQDISP_PENDINGFIRST & m_dwDispositionFlags)))
	{
	    *pDisposition = VR_PENDING;
	}
	else switch (REQDISP_MASK & m_dwDispositionFlags)
	{
	    default:
	    case REQDISP_PENDING:
		*pDisposition = VR_PENDING;
		break;

	    case REQDISP_ISSUE:
		*pDisposition = VR_INSTANT_OK;
		break;

	    case REQDISP_DENY:
		*pDisposition = VR_INSTANT_BAD;
		break;

	    case REQDISP_USEREQUESTATTRIBUTE:
		*pDisposition = VR_INSTANT_OK;
		hr = polGetRequestAttribute(
				    pServer,
				    wszPROPDISPOSITION,
				    &strDisposition);
		if (S_OK == hr)
		{
		    if (0 == celstrcmpiL(strDisposition, wszPROPDISPOSITIONDENY))
		    {
			*pDisposition = VR_INSTANT_BAD;
		    }
		    if (0 == celstrcmpiL(strDisposition, wszPROPDISPOSITIONPENDING))
		    {
			*pDisposition = VR_PENDING;
		    }
		}
		hr = S_OK;
		break;
	}
deny:
	if (FAILED(hr))
	{
	    *pDisposition = hr;	// pass failed HRESULT back as Disposition
	}
	else if (hr != S_OK)
	{
	    *pDisposition = VR_INSTANT_BAD;
	}
	hr = S_OK;
    }
    __except(hr = ceHError(GetExceptionCode()), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }

    {
	HRESULT hr2 = hr;
#define wszFORMATREQUESTID	L"RequestId=%u"
	WCHAR wszRequestId[ARRAYSIZE(wszFORMATREQUESTID) + cwcDWORDSPRINTF];

	if (S_OK == hr2 && NULL != pDisposition && FAILED(*pDisposition))
	{
	    hr2 = *pDisposition;
	}
	if (S_OK != hr2)
	{
	    wsprintf(wszRequestId, wszFORMATREQUESTID, lRequestId);
	    _PrintErrorStr(hr2, "VerifyRequest", wszRequestId);
	}
    }
    if (NULL != strDisposition)
    {
	SysFreeString(strDisposition);
    }
    if (NULL != pServer)
    {
        pServer->Release();
    }
    //_PrintIfError(hr, "Policy:VerifyRequest(hr)");
    //_PrintError(*pDisposition, "Policy:VerifyRequest(*pDisposition)");
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::GetDescription
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicySample::GetDescription(
    /* [out, retval] */ BSTR __RPC_FAR *pstrDescription)
{
    HRESULT hr = S_OK;
    WCHAR sz[MAX_PATH];

    if(!m_strDescription)
    {
	assert(wcslen(wsz_SAMPLE_DESCRIPTION) < ARRAYSIZE(sz));
	wcsncpy(sz, wsz_SAMPLE_DESCRIPTION, ARRAYSIZE(sz));
	sz[ARRAYSIZE(sz) - 1] = L'\0';

	m_strDescription = SysAllocString(sz);
	if (NULL == m_strDescription)
	{
	    hr = E_OUTOFMEMORY;
	    return hr;
	}
    }

    if (NULL != *pstrDescription)
    {
        SysFreeString(*pstrDescription);
    }

    *pstrDescription = SysAllocString(m_strDescription);
    if (NULL == *pstrDescription)
    {
        hr = E_OUTOFMEMORY;
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::ShutDown
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicySample::ShutDown(VOID)
{
    // called once, as Server unloading policy dll
    _Cleanup();
    return(S_OK);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::GetManageModule
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertPolicySample::GetManageModule(
    /* [out, retval] */ ICertManageModule **ppManageModule)
{
    HRESULT hr;
    
    *ppManageModule = NULL;
    hr = CoCreateInstance(
		    CLSID_CCertManagePolicyModuleSample,
                    NULL,               // pUnkOuter
                    CLSCTX_INPROC_SERVER,
		    IID_ICertManageModule,
                    (VOID **) ppManageModule);
    _JumpIfError(hr, error, "CoCreateInstance");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertPolicySample::_GetIssuer
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

PCCERT_CONTEXT
CCertPolicySample::_GetIssuer(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    VARIANT varValue;
    BSTR strName = NULL;

    VariantInit(&varValue);
    if (NULL != m_pCert)
    {
        hr = S_OK;
	goto error;
    }
    strName = SysAllocString(wszPROPRAWCACERTIFICATE);
    if (NULL == strName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:SysAllocString");
    }
    hr = pServer->GetCertificateProperty(strName, PROPTYPE_BINARY, &varValue);
    _JumpIfError(hr, error, "Policy:GetCertificateProperty");

    m_pCert = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    (BYTE *) varValue.bstrVal,
				    SysStringByteLen(varValue.bstrVal));
    if (NULL == m_pCert)
    {
	hr = ceHLastError();
	_JumpError(hr, error, "Policy:CertCreateCertificateContext");
    }

error:
    VariantClear(&varValue);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    return(m_pCert);
}


STDMETHODIMP
CCertPolicySample::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
        &IID_ICertPolicy,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (IsEqualGUID(*arr[i], riid))
        {
            return(S_OK);
        }
    }
    return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\request0.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        request.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "policy.h"
#include "module.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\policy.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       policy.h
//
//--------------------------------------------------------------------------

#include "certpsam.h"
#include "resource.h"

#ifndef wszATTREMAIL1
# define wszATTREMAIL1			TEXT("E")
# define wszATTREMAIL2			TEXT("EMail")
#endif

#ifndef wszCERTTYPE_SUBORDINATE_CA
# define wszCERTTYPE_SUBORDINATE_CA	L"SubCA"
#endif

#ifndef wszCERTTYPE_CROSS_CA
# define wszCERTTYPE_CROSS_CA		L"CrossCA"
#endif

extern BOOL fDebug;

HRESULT
ReqInitialize(
    IN ICertServerPolicy *pServer);

VOID
ReqCleanup(VOID);


class CRequestInstance;

#ifndef __BSTRC__DEFINED__
#define __BSTRC__DEFINED__
typedef OLECHAR const *BSTRC;
#endif

HRESULT
polGetServerCallbackInterface(
    OUT ICertServerPolicy **ppServer,
    IN LONG Context);

HRESULT
polGetRequestStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut);

HRESULT
polGetCertificateStringProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT BSTR *pstrOut);

HRESULT
polGetRequestLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut);

HRESULT
polGetCertificateLongProperty(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropertyName,
    OUT LONG *plOut);

HRESULT
polGetRequestAttribute(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszAttributeName,
    OUT BSTR *pstrOut);

HRESULT
polGetCertificateExtension(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszExtensionName,
    IN DWORD dwPropType,
    IN OUT VARIANT *pvarOut);

HRESULT
polSetCertificateExtension(
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszExtensionName,
    IN DWORD dwPropType,
    IN DWORD dwExtFlags,
    IN VARIANT const *pvarIn);

DWORD
polFindObjIdInList(
    IN WCHAR const *pwsz,
    IN DWORD count,
    IN WCHAR const * const *ppwsz);

// 
// Class CCertPolicySample
// 
// Actual policy module for a CA Policy
//
//

class CCertPolicySample: 
    public CComDualImpl<ICertPolicy2, &IID_ICertPolicy2, &LIBID_CERTPOLICYSAMPLELib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertPolicySample, &CLSID_CCertPolicySample>
{
public:
    CCertPolicySample()
    {
	m_strDescription = NULL;

        // RevocationExtension variables:

	m_dwRevocationFlags = 0;
	m_wszASPRevocationURL = NULL;

        m_dwDispositionFlags = 0;
        m_dwEditFlags = 0;

	m_cEnableRequestExtensions = 0;
	m_apwszEnableRequestExtensions = NULL;

	m_cEnableEnrolleeRequestExtensions = 0;
	m_apwszEnableEnrolleeRequestExtensions = NULL;

	m_cDisableExtensions = 0;
	m_apwszDisableExtensions = NULL;

	// CA Name
        m_strRegStorageLoc = NULL;

	m_strCAName = NULL;
        m_strCASanitizedName = NULL;
        m_strCASanitizedDSName = NULL;
        m_strMachineDNSName = NULL;

        // CA and cert type info

        m_CAType = ENUM_UNKNOWN_CA;

        m_pCert = NULL;
        m_iCRL = 0;

    }
    ~CCertPolicySample();

BEGIN_COM_MAP(CCertPolicySample)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertPolicy)
    COM_INTERFACE_ENTRY(ICertPolicy2)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertPolicySample) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertPolicySample,
    wszCLASS_CERTPOLICYSAMPLE TEXT(".1"),
    wszCLASS_CERTPOLICYSAMPLE,
    IDS_CERTPOLICY_DESC,
    THREADFLAGS_BOTH)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ICertPolicy
public:
    STDMETHOD(Initialize)( 
		/* [in] */ BSTR const strConfig);

    STDMETHOD(VerifyRequest)( 
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG Context,
		/* [in] */ LONG bNewRequest,
		/* [in] */ LONG Flags,
		/* [out, retval] */ LONG __RPC_FAR *pDisposition);

    STDMETHOD(GetDescription)( 
		/* [out, retval] */ BSTR __RPC_FAR *pstrDescription);

    STDMETHOD(ShutDown)();

// ICertPolicy2
public:
    STDMETHOD(GetManageModule)(
		/* [out, retval] */ ICertManageModule **ppManageModule);

public:
    HRESULT AddBasicConstraintsCommon(
		IN ICertServerPolicy *pServer,
		IN CERT_EXTENSION const *pExtension,
		IN BOOL fCA,
		IN BOOL fEnableExtension);

    BSTRC GetPolicyDescription() { return(m_strDescription); }


    HRESULT AddV1TemplateNameExtension(
		IN ICertServerPolicy *pServer,
		OPTIONAL IN WCHAR const *pwszTemplateName);

private:
    CERT_CONTEXT const *_GetIssuer(
		IN ICertServerPolicy *pServer);

    HRESULT _EnumerateExtensions(
		IN ICertServerPolicy *pServer,
		IN LONG bNewRequest,
		IN BOOL fFirstPass,
		IN BOOL fEnableEnrolleeExtensions,
		IN DWORD cCriticalExtensions,
		IN WCHAR const * const *apwszCriticalExtensions);

#if DBG_CERTSRV
    VOID _DumpStringArray(
		IN char const *pszType,
		IN DWORD count,
		IN LPWSTR const *apwsz);
#else
    #define _DumpStringArray(pszType, count, apwsz)
#endif

    VOID _FreeStringArray(
		IN OUT DWORD *pcString,
		IN OUT LPWSTR **papwsz);

    VOID _Cleanup();


    HRESULT _SetSystemStringProp(
		IN ICertServerPolicy *pServer,
		IN WCHAR const *pwszName,
		OPTIONAL IN WCHAR const *pwszValue);

    HRESULT _AddStringArray(
		IN WCHAR const *pwszzValue,
		IN BOOL fURL,
		IN OUT DWORD *pcStrings,
		IN OUT LPWSTR **papwszRegValues);

    HRESULT _ReadRegistryString(
		IN HKEY hkey,
		IN BOOL fURL,
		IN WCHAR const *pwszRegName,
		IN WCHAR const *pwszSuffix,
		OUT LPWSTR *pwszRegValue);

    HRESULT _ReadRegistryStringArray(
		IN HKEY hkey,
		IN BOOL fURL,
		IN DWORD dwFlags,
		IN DWORD cRegNames,
		IN DWORD *aFlags,
		IN WCHAR const * const *apwszRegNames,
		IN OUT DWORD *pcStrings,
		IN OUT LPWSTR **papwszRegValues);

    VOID _InitRevocationExtension(
		IN HKEY hkey);

    VOID _InitRequestExtensionList(
		IN HKEY hkey);

    VOID _InitDisableExtensionList(
		IN HKEY hkey);

    HRESULT _AddRevocationExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddOldCertTypeExtension(
		IN ICertServerPolicy *pServer,
		IN BOOL fCA);

    HRESULT _AddAuthorityKeyId(
		IN ICertServerPolicy *pServer);

    HRESULT _AddDefaultKeyUsageExtension(
		IN ICertServerPolicy *pServer,
		IN BOOL fCA);

    HRESULT _AddEnhancedKeyUsageExtension(
		IN ICertServerPolicy *pServer);

    HRESULT _AddDefaultBasicConstraintsExtension(
		IN ICertServerPolicy *pServer,
		IN BOOL fCA);

    HRESULT _SetValidityPeriod(
		IN ICertServerPolicy *pServer);


private:
    // RevocationExtension variables:

    CERT_CONTEXT const *m_pCert;

    BSTR m_strDescription;

    DWORD m_dwRevocationFlags;
    LPWSTR m_wszASPRevocationURL;

    DWORD m_dwDispositionFlags;
    DWORD m_dwEditFlags;
    DWORD m_CAPathLength;

    DWORD m_cEnableRequestExtensions;
    LPWSTR *m_apwszEnableRequestExtensions;

    DWORD m_cEnableEnrolleeRequestExtensions;
    LPWSTR *m_apwszEnableEnrolleeRequestExtensions;

    DWORD m_cDisableExtensions;
    LPWSTR *m_apwszDisableExtensions;

    // CertTypeExtension variables:

    BSTR m_strRegStorageLoc;
    BSTR m_strCAName;

    BSTR m_strCASanitizedName;
    BSTR m_strCASanitizedDSName;

    BSTR m_strMachineDNSName;

    // CA and cert type info

    ENUM_CATYPES m_CAType;

    DWORD m_iCert;
    DWORD m_iCRL;

};

// 
// Class CRequestInstance
// 
// Instance data for a certificate that is being created.
//

class CRequestInstance
{

public:
    CRequestInstance()
    {
        m_strTemplateName = NULL;
	m_strTemplateObjId = NULL;
	m_pPolicy = NULL;

    }

    ~CRequestInstance();

    HRESULT Initialize(
		IN CCertPolicySample *pPolicy,
		IN ICertServerPolicy *pServer,
		OUT BOOL *pfEnableEnrolleeExtensions);

    HRESULT SetTemplateName(
		IN ICertServerPolicy *pServer,
		IN OPTIONAL WCHAR const *pwszTemplateName,
		IN OPTIONAL WCHAR const *pwszTemplateObjId);

    BSTRC GetTemplateName() { return(m_strTemplateName); }
    BSTRC GetTemplateObjId() { return(m_strTemplateObjId); }


    BOOL IsCARequest() { return(m_fCA); }

    CCertPolicySample *GetPolicy() { return(m_pPolicy); }

private:

    HRESULT _SetFlagsProperty(
		IN ICertServerPolicy *pServer,
		IN WCHAR const *pwszPropName,
		IN DWORD dwFlags);

    BOOL _TemplateNamesMatch(
		IN WCHAR const *pwszTemplateName1,
		IN WCHAR const *pwszTemplateName2,
		OUT BOOL *pfTemplateMissing);

    VOID _Cleanup();		
private:			
    CCertPolicySample *m_pPolicy;
    BSTR                   m_strTemplateName;	// certificate type requested
    BSTR                   m_strTemplateObjId;	// certificate type requested
    DWORD                  m_dwTemplateMajorVersion;
    DWORD                  m_dwTemplateMinorVersion;
    BOOL                   m_fCA;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\request.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        request.cpp
//
// Contents:    Cert Server Policy Module implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <assert.h>
#include "celib.h"
#include "policy.h"
#include "module.h"


HRESULT
ReqInitialize(
    IN ICertServerPolicy *pServer)
{
    HRESULT hr;
    
    hr = S_OK;

    return(hr);
}


VOID
ReqCleanup()
{
}


CRequestInstance::~CRequestInstance()
{
    _Cleanup();
}


VOID
CRequestInstance::_Cleanup()
{
    if (NULL != m_strTemplateName)
    {
        SysFreeString(m_strTemplateName);
        m_strTemplateName = NULL;
    }
    if (NULL != m_strTemplateObjId)
    {
        SysFreeString(m_strTemplateObjId);
        m_strTemplateObjId = NULL;
    }
}




static WCHAR const *s_apwszCATypes[] =
{
    wszCERTTYPE_SUBORDINATE_CA,
    wszCERTTYPE_CROSS_CA,
};

//+--------------------------------------------------------------------------
// CRequestInstance::Initialize
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::Initialize(
    IN CCertPolicySample *pPolicy,
    IN ICertServerPolicy *pServer,
    OUT BOOL *pfEnableEnrolleeExtensions)
{
    HRESULT hr;
    HRESULT hrTemplate = S_OK;
    CERT_TEMPLATE_EXT *pTemplate = NULL;
    CERT_NAME_VALUE *pName = NULL;
    BSTR strTemplateObjId = NULL;	// from V2 template extension
    BSTR strTemplateName = NULL;	// from V1 template extension
    BSTR strTemplateRA = NULL;		// from request attributes
    WCHAR const *pwszTemplateName;
    WCHAR const *pwszTemplateObjId;
    WCHAR const *pwszV1TemplateClass;
    VARIANT varValue;
    DWORD cbType;
    DWORD i;
    BOOL fConflict;
    BOOL f;
    BOOL fTemplateMissing;
    BOOL fRAObjId = FALSE;

    VariantInit(&varValue);
    *pfEnableEnrolleeExtensions = TRUE 
		    ;

    m_pPolicy = pPolicy;
    m_fCA = FALSE;


    // Retrieve the template ObjId from the V2 cert template info extension

    m_dwTemplateMajorVersion = 0;
    m_dwTemplateMinorVersion = 0;
    hr = polGetCertificateExtension(
			    pServer,
			    TEXT(szOID_CERTIFICATE_TEMPLATE),
			    PROPTYPE_BINARY,
			    &varValue);
    _PrintIfErrorStr2(
		hr,
		"Policy:polGetCertificateExtension",
		TEXT(szOID_CERTIFICATE_TEMPLATE),
		CERTSRV_E_PROPERTY_EMPTY);
    if (S_OK == hr)
    {
        // There was a cert type indicator.
        // varValue points to an encoded string

        if (VT_BSTR != varValue.vt)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:varValue.vt");
	}
        if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERTIFICATE_TEMPLATE,
		    (BYTE *) varValue.bstrVal,
		    SysStringByteLen(varValue.bstrVal),
		    FALSE,
		    (VOID **) &pTemplate,
		    &cbType))
        {
            hr = ceHLastError();
	    _JumpError(hr, error, "Policy:ceDecodeObject");
        }
	if (!ceConvertSzToBstr(&strTemplateObjId, pTemplate->pszObjId, -1))
	{
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:ceConvertSzToBstr");
        }
	m_dwTemplateMajorVersion = pTemplate->dwMajorVersion;
	m_dwTemplateMinorVersion = pTemplate->dwMinorVersion;
	DBGPRINT((
	    fDebug,
	    pTemplate->fMinorVersion?
		"Extension Template Info: %ws V%u.%u\n" :
		"Extension Template Info: %ws V%u%\n",
	    strTemplateObjId,
	    m_dwTemplateMajorVersion,
	    m_dwTemplateMinorVersion));
    }
    VariantClear(&varValue);

    // Retrieve template Name from the V1 cert template name extension

    hr = polGetCertificateExtension(
			    pServer,
			    TEXT(szOID_ENROLL_CERTTYPE_EXTENSION),
			    PROPTYPE_BINARY,
			    &varValue);
    _PrintIfErrorStr2(
		hr,
		"Policy:polGetCertificateExtension",
		TEXT(szOID_ENROLL_CERTTYPE_EXTENSION),
		CERTSRV_E_PROPERTY_EMPTY);
    if (S_OK == hr)
    {
        // There was a cert type indicator.
        // varValue points to an encoded string

        if (VT_BSTR != varValue.vt)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Policy:varValue.vt");
	}
        if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    (BYTE *) varValue.bstrVal,
		    SysStringByteLen(varValue.bstrVal),
		    FALSE,
		    (VOID **) &pName,
		    &cbType))
        {
            hr = ceHLastError();
	    _JumpError(hr, error, "Policy:ceDecodeObject");
        }
        strTemplateName = SysAllocString((WCHAR *) pName->Value.pbData);
        if (NULL == strTemplateName)
        {
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
        }
	DBGPRINT((fDebug, "Extension Template: %ws\n", strTemplateName));
    }

    fConflict = FALSE;
    fTemplateMissing = FALSE;

    // Retrieve the template from the request attributes

    hr = polGetRequestAttribute(pServer, wszPROPCERTTEMPLATE, &strTemplateRA);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		    hr,
		    "Policy:polGetRequestAttribute",
		    wszPROPCERTTEMPLATE,
		    CERTSRV_E_PROPERTY_EMPTY);
	hr = S_OK;


    }
    else
    {
	DBGPRINT((fDebug, "Attribute Template: %ws\n", strTemplateRA));
	if (NULL != strTemplateObjId &&
	    !_TemplateNamesMatch(strTemplateObjId, strTemplateRA, &f))
	{
	    fConflict = TRUE;
	    if (f)
	    {
		fTemplateMissing = TRUE;
	    }
	}
	if (NULL != strTemplateName &&
	    !_TemplateNamesMatch(strTemplateName, strTemplateRA, &f))
	{
	    fConflict = TRUE;
	    if (f)
	    {
		fTemplateMissing = TRUE;
	    }
	}
	hr = ceVerifyObjId(strTemplateRA);
	fRAObjId = S_OK == hr;
    }

    if (NULL != strTemplateObjId &&
	NULL != strTemplateName &&
	!_TemplateNamesMatch(strTemplateObjId, strTemplateName, &f))
    {
	fConflict = TRUE;
	if (f)
	{
	    fTemplateMissing = TRUE;
	}
    }

    if (fConflict)
    {
	hrTemplate = CERTSRV_E_TEMPLATE_CONFLICT;
	if (NULL != strTemplateObjId)
	{
	    _PrintErrorStr(
			hrTemplate,
			"Policy:Extension Template ObjId",
			strTemplateObjId);
	}
	if (NULL != strTemplateName)
	{
	    _PrintErrorStr(
			hrTemplate,
			"Policy:Extension Template Name",
			strTemplateName);
	}
	if (NULL != strTemplateRA)
	{
	    _PrintErrorStr(
			hrTemplate,
			"Policy:Attribute Template",
			strTemplateRA);
	}
    }

    pwszTemplateName = strTemplateName;
    pwszTemplateObjId = strTemplateObjId;
    if (fRAObjId)
    {
	if (NULL == pwszTemplateObjId)
	{
	    pwszTemplateObjId = strTemplateRA;
	}
    }
    else
    {
	if (NULL == pwszTemplateName)
	{
	    pwszTemplateName = strTemplateRA;
	}
    }


    {
	if (NULL != pwszTemplateName)
	{
	    for (i = 0; i < ARRAYSIZE(s_apwszCATypes); i++)
	    {
		if (0 == celstrcmpiL(s_apwszCATypes[i], pwszTemplateName))
		{
		    m_fCA = TRUE;
		    break;
		}
	    }
	}
    }
    hr = SetTemplateName(pServer, pwszTemplateName, pwszTemplateObjId);
    _JumpIfError(hr, error, "Policy:SetTemplateName");

    pwszV1TemplateClass = pwszTemplateName;


    hr = pPolicy->AddV1TemplateNameExtension(pServer, pwszV1TemplateClass);
    _JumpIfError(hr, error, "AddTemplateNameExtension");

error:
    if (S_OK != hrTemplate)
    {
	hr = hrTemplate;	// override secondary errors

    }
    VariantClear(&varValue);

    if (NULL != pName)
    {
        LocalFree(pName);
    }
    if (NULL != pTemplate)
    {
        LocalFree(pTemplate);
    }
    if (NULL != strTemplateObjId)
    {
        SysFreeString(strTemplateObjId);
    }
    if (NULL != strTemplateName)
    {
        SysFreeString(strTemplateName);
    }
    if (NULL != strTemplateRA)
    {
        SysFreeString(strTemplateRA);
    }
    return(hr);
}




BOOL
CRequestInstance::_TemplateNamesMatch(
    IN WCHAR const *pwszTemplateName1,
    IN WCHAR const *pwszTemplateName2,
    OUT BOOL *pfTemplateMissing)
{
    HRESULT hr1;
    HRESULT hr2;
    BOOL fMatch = TRUE;

    *pfTemplateMissing = FALSE;

    if (0 == celstrcmpiL(pwszTemplateName1, pwszTemplateName2))
    {
	goto done;	// identical names
    }

    {
	hr1 = ceVerifyObjId(pwszTemplateName1);
	hr2 = ceVerifyObjId(pwszTemplateName2);
	if ((S_OK == hr1) ^ (S_OK == hr2))
	{
	    goto done;
	}
    }
    fMatch = FALSE;

done:
    return(fMatch);
}


//+--------------------------------------------------------------------------
// CRequestInstance::SetTemplateName
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CRequestInstance::SetTemplateName(
    IN ICertServerPolicy *pServer,
    IN OPTIONAL WCHAR const *pwszTemplateName,
    IN OPTIONAL WCHAR const *pwszTemplateObjId)
{
    HRESULT hr;
    BSTR strProp = NULL;
    BSTR strTemplateName = NULL;

    if (NULL != pwszTemplateName)
    {
	m_strTemplateName = SysAllocString(pwszTemplateName);
	if (NULL == m_strTemplateName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}
	strTemplateName = m_strTemplateName;
    }

    if (NULL != pwszTemplateObjId)
    {
	m_strTemplateObjId = SysAllocString(pwszTemplateObjId);
	if (NULL == m_strTemplateObjId)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}
	strTemplateName = m_strTemplateObjId;
    }

    if (NULL != strTemplateName)
    {
	VARIANT var;

	strProp = SysAllocString(wszPROPCERTIFICATETEMPLATE);
	if (NULL == strProp)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "Policy:SysAllocString");
	}

	var.vt = VT_BSTR;
	var.bstrVal = strTemplateName;

	hr = pServer->SetCertificateProperty(strProp, PROPTYPE_STRING, &var);
	_JumpIfError(hr, error, "Policy:SetCertificateProperty");
    }
    hr = S_OK;

error:
    if (NULL != strProp)
    {
	SysFreeString(strProp);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\policy\sample\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certpsam.rc
//
#define IDS_CERTPOLICY_DESC	1
#define IDS_CERTMANAGEPOLICYMODULE_DESC 2


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\common.h ===
//--------------------------------------------------------------------
// Common - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 8-11-99
//
// Common definitions for the CEP project
//--------------------------------------------------------------
#ifndef CEP_COMMON_H
#define CEP_COMMON_H

#ifdef __cplusplus
extern "C" {
#endif


#define CEP_STORE_NAME                  L"CEP"
#define CEP_DLL_NAME                    L"mscep.dll"
#define	CERTSVC_NAME					L"certsvc"
#define	CEP_DIR_NAME					L"mscep"
#define	IIS_NAME						L"w3svc"
#define ENCODE_TYPE						PKCS_7_ASN_ENCODING | X509_ASN_ENCODING

#define MSCEP_REFRESH_LOCATION          L"Software\\Microsoft\\Cryptography\\MSCEP\\Refresh" 
#define MSCEP_PASSWORD_LOCATION         L"Software\\Microsoft\\Cryptography\\MSCEP\\EnforcePassword" 
#define MSCEP_PASSWORD_MAX_LOCATION     L"Software\\Microsoft\\Cryptography\\MSCEP\\PasswordMax" 
#define MSCEP_PASSWORD_VALIDITY_LOCATION     L"Software\\Microsoft\\Cryptography\\MSCEP\\PasswordValidity" 
#define MSCEP_CACHE_REQUEST_LOCATION    L"Software\\Microsoft\\Cryptography\\MSCEP\\CacheRequest" 
#define MSCEP_CATYPE_LOCATION			L"Software\\Microsoft\\Cryptography\\MSCEP\\CAType"
#define MSCEP_LOCATION					L"Software\\Microsoft\\Cryptography\\MSCEP"

#define MSCEP_KEY_REFRESH               L"RefreshPeriod"
#define MSCEP_KEY_PASSWORD              L"EnforcePassword"
#define MSCEP_KEY_PASSWORD_MAX          L"PasswordMax"
#define MSCEP_KEY_PASSWORD_VALIDITY     L"PasswordValidity"
#define MSCEP_KEY_CACHE_REQUEST			L"CacheRequest"
#define MSCEP_KEY_CATYPE				L"CAType"
#define	MSCEP_KEY_SIG_TEMPLATE			L"SignatureTemplate"
#define	MSCEP_KEY_ENCYPT_TEMPLATE		L"EncryptionTemplate"
#define	MSCEP_KEY_SERVICE_WAIT			L"ServiceWaitPeriod"
#define MSCEP_KEY_ALLOW_ALL             L"AllowAll"

#define MSCEP_EVENT_LOG					L"SCEP Add-on"


#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif  //CEP_COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\mscep\cepasn.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for GlobalDirectives */

#ifndef _CEPASN_Module_H_
#define _CEPASN_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct IssuerAndSerialNumber {
    ASN1open_t issuer;
    ASN1intx_t serialNumber;
} IssuerAndSerialNumber;
#define IssuerAndSerialNumber_PDU 0
#define SIZE_CEPASN_Module_PDU_0 sizeof(IssuerAndSerialNumber)


extern ASN1module_t CEPASN_Module;
extern void ASN1CALL CEPASN_Module_Startup(void);
extern void ASN1CALL CEPASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _CEPASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\mscep\cepasn.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for GlobalDirectives */

#include <windows.h>
#include "cepasn.h"

ASN1module_t CEPASN_Module = NULL;

static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[1] = {
    (ASN1EncFun_t) ASN1Enc_IssuerAndSerialNumber,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[1] = {
    (ASN1DecFun_t) ASN1Dec_IssuerAndSerialNumber,
};
static const ASN1FreeFun_t freefntab[1] = {
    (ASN1FreeFun_t) ASN1Free_IssuerAndSerialNumber,
};
static const ULONG sizetab[1] = {
    SIZE_CEPASN_Module_PDU_0,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL CEPASN_Module_Startup(void)
{
    CEPASN_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 1, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x61706563);
}

void ASN1CALL CEPASN_Module_Cleanup(void)
{
    ASN1_CloseModule(CEPASN_Module);
    CEPASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOpenType(dd, &(val)->issuer))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val)
{
    if (val) {
	ASN1open_free(&(val)->issuer);
	ASN1intx_free(&(val)->serialNumber);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\mscep\cepcache.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       ceppswrd.cpp
//
//  Contents:   Cisco enrollment protocol implementation.  This module
//				implement the request hash table.
//              
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

DWORD							g_dwRequestDuration=0;
CEP_REQUEST_TABLE_INFO			g_CEPRequestTable;

//***************************************************************************
//
//	The following are APIs called internally.
//
//
//***************************************************************************
//--------------------------------------------------------------------------
//
//	CEPRequestFreeRequestEntry
//
//--------------------------------------------------------------------------
void	CEPRequestFreeRequestEntry(CEP_REQUEST_ENTRY *pRequestEntry)
{
	if(pRequestEntry)
	{

		free(pRequestEntry);
	}
}

//--------------------------------------------------------------------------
//
//	CEPRequestFreeValidityEntry
//
//--------------------------------------------------------------------------
void CEPRequestFreeValidityEntry(CEP_REQUEST_VALIDITY_ENTRY	*pValidityEntry, 
								  BOOL							fFreeRequestEntry)
{
	if(pValidityEntry)
	{
		if(fFreeRequestEntry)
			CEPRequestFreeRequestEntry(pValidityEntry->pRequestEntry);

		free(pValidityEntry);
	}
}


//--------------------------------------------------------------------------
//
//	CEPHashRequest
//
//  For any cases that we can not convert the psz, we use index 0.
//--------------------------------------------------------------------------
BOOL CEPHashRequest(BYTE	*pbHash, DWORD	*pdw)
{
	BYTE	byte=0;

	*pdw=0;

	if(!pbHash)
		return FALSE;

	byte=pbHash[0];

	*pdw=(DWORD)byte;

	if(*pdw >= CEP_HASH_TABLE_SIZE)
		*pdw=0;

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPSearchRequest
//  
//--------------------------------------------------------------------------
CEP_REQUEST_ENTRY  *CEPSearchRequest(BYTE	*pbHash, DWORD *pdwIndex)
{
	CEP_REQUEST_ENTRY		*pRequestEntry=NULL;
	DWORD					dwHashIndex=0;

	if(pdwIndex)
		*pdwIndex=0;

	if(NULL==pbHash)
		return NULL;

	//hash based on the 1st byte
	if(!CEPHashRequest(pbHash, &dwHashIndex))
		return NULL;

	for(pRequestEntry=g_CEPRequestTable.rgRequestEntry[dwHashIndex]; NULL != pRequestEntry; pRequestEntry=pRequestEntry->pNext)
	{
		if(0==memcmp(pRequestEntry->pbHash, pbHash, CEP_MD5_HASH_SIZE))
		{
			break;
		}
	}

	if(pRequestEntry)
	{
		if(pdwIndex)
			*pdwIndex=dwHashIndex; 
	}

	return pRequestEntry;
}

//--------------------------------------------------------------------------
//
//	CEPInsertValidityEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPInsertValidityEntry(CEP_REQUEST_VALIDITY_ENTRY *pValidityEntry)
{
	if(!pValidityEntry)
		return FALSE;

	if(g_CEPRequestTable.pTimeNew)
	{
		g_CEPRequestTable.pTimeNew->pNext=pValidityEntry;
		pValidityEntry->pPrevious=g_CEPRequestTable.pTimeNew;
		g_CEPRequestTable.pTimeNew=pValidityEntry;
	}
	else
	{
		//no item in the list yet
		g_CEPRequestTable.pTimeOld=pValidityEntry;
		g_CEPRequestTable.pTimeNew=pValidityEntry;
	}

	return TRUE;
}


//--------------------------------------------------------------------------
//
//	CEPInsertRequestEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPInsertRequestEntry(CEP_REQUEST_ENTRY *pRequestEntry, DWORD dwHashIndex)
{

	if(!pRequestEntry)
		return FALSE;

	if(g_CEPRequestTable.rgRequestEntry[dwHashIndex])
	{
	   g_CEPRequestTable.rgRequestEntry[dwHashIndex]->pPrevious=pRequestEntry;
	   pRequestEntry->pNext=g_CEPRequestTable.rgRequestEntry[dwHashIndex];
	   g_CEPRequestTable.rgRequestEntry[dwHashIndex]=pRequestEntry;
	}
	else
	{
		//1st item
		g_CEPRequestTable.rgRequestEntry[dwHashIndex]=pRequestEntry;
	}

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPRequestRemoveValidityEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPRequestRemoveValidityEntry(CEP_REQUEST_VALIDITY_ENTRY	*pValidityEntry)
{
	BOOL	fResult=FALSE;

	if(!pValidityEntry)
		goto InvalidArgErr;

	if(pValidityEntry->pPrevious)
		pValidityEntry->pPrevious->pNext=pValidityEntry->pNext;
	else
	{
		//1st item
		g_CEPRequestTable.pTimeOld=pValidityEntry->pNext;
	}

	if(pValidityEntry->pNext)
		pValidityEntry->pNext->pPrevious=pValidityEntry->pPrevious;
	else
	{
		//last itme
		g_CEPRequestTable.pTimeNew=pValidityEntry->pPrevious;

	}

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	CEPRequestRemoveRequestEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPRequestRemoveRequestEntry(CEP_REQUEST_ENTRY	*pRequestEntry, DWORD dwIndex)
{
	BOOL	fResult=FALSE;

	if(!pRequestEntry)
		goto InvalidArgErr;


	if(pRequestEntry->pPrevious)
		pRequestEntry->pPrevious->pNext=pRequestEntry->pNext;
	else
		g_CEPRequestTable.rgRequestEntry[dwIndex]=pRequestEntry->pNext;

	if(pRequestEntry->pNext)
		pRequestEntry->pNext->pPrevious=pRequestEntry->pPrevious;

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	CEPRequestRefresh
//
//--------------------------------------------------------------------------
BOOL	CEPRequestRefresh()
{
	BOOL						fResult=FALSE;	
	DWORD						dwHashIndex=0;
	CEP_REQUEST_VALIDITY_ENTRY	*pValidityEntry=NULL;

	while(g_CEPRequestTable.pTimeOld)
	{
		if(!CEPHashIsCurrentTimeEntry(&(g_CEPRequestTable.pTimeOld->TimeStamp), 0, g_dwRequestDuration))
		{  
			if(!CEPHashRequest(g_CEPRequestTable.pTimeOld->pRequestEntry->pbHash, &dwHashIndex))
			{
				g_CEPRequestTable.pTimeOld->pPrevious=NULL;
				goto InvalidArgErr;
			}

			CEPRequestRemoveRequestEntry(g_CEPRequestTable.pTimeOld->pRequestEntry, dwHashIndex);

			CEPRequestFreeRequestEntry(g_CEPRequestTable.pTimeOld->pRequestEntry);

			pValidityEntry=g_CEPRequestTable.pTimeOld;

			g_CEPRequestTable.pTimeOld=g_CEPRequestTable.pTimeOld->pNext;

			CEPRequestFreeValidityEntry(pValidityEntry, FALSE);
		}
		else
		{	
			//we find a new enough entry
			g_CEPRequestTable.pTimeOld->pPrevious=NULL;
			break;
		}
	}

	//we have get rid of all items
	if(NULL == g_CEPRequestTable.pTimeOld)
	{
		g_CEPRequestTable.pTimeNew=NULL;
	}
	
	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//***************************************************************************
//
//	The following are APIs called by the upper (external) layer
//
//
//***************************************************************************

//--------------------------------------------------------------------------
//
//	InitRequestTable
//
//--------------------------------------------------------------------------
BOOL	WINAPI	InitRequestTable()
{
	DWORD				cbData=0;
	DWORD				dwData=0;
	DWORD				dwType=0;

    HKEY                hKey=NULL;

	memset(&g_CEPRequestTable, 0, sizeof(CEP_REQUEST_TABLE_INFO));

	g_dwRequestDuration=CEP_REQUEST_DURATION;

	if(ERROR_SUCCESS == RegOpenKeyExU(
					HKEY_LOCAL_MACHINE,
                    MSCEP_CACHE_REQUEST_LOCATION,
                    0,
                    KEY_READ,
                    &hKey))
    {
        cbData=sizeof(dwData);

        if(ERROR_SUCCESS == RegQueryValueExU(
                        hKey,
                        MSCEP_KEY_CACHE_REQUEST,
                        NULL,
                        &dwType,
                        (BYTE *)&dwData,
                        &cbData))
		{
			if ((dwType == REG_DWORD) ||
                (dwType == REG_BINARY))
			{
				g_dwRequestDuration=dwData;	
			}
		}
	}

    if(hKey)
        RegCloseKey(hKey);

	return TRUE;

}

//--------------------------------------------------------------------------
//
//	ReleaseRequestTable
//
//--------------------------------------------------------------------------
BOOL WINAPI  ReleaseRequestTable()
{

	CEP_REQUEST_VALIDITY_ENTRY	*pValidityEntry=NULL;

	if(g_CEPRequestTable.pTimeOld)
	{
		do{
			pValidityEntry=g_CEPRequestTable.pTimeOld;

			g_CEPRequestTable.pTimeOld = g_CEPRequestTable.pTimeOld->pNext;
			
			CEPRequestFreeValidityEntry(pValidityEntry, TRUE);
		}
		while(g_CEPRequestTable.pTimeOld);
	}
			
	memset(&g_CEPRequestTable, 0, sizeof(CEP_REQUEST_TABLE_INFO));
	

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPRequestRetrieveRequestIDFromHash
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPRequestRetrieveRequestIDFromHash(BYTE			*pbHash, 
													   DWORD	*pdwRequestID)
{
	BOOL					fResult=FALSE;
	CEP_REQUEST_ENTRY		*pRequestEntry=NULL;
	DWORD					dwIndex=0;

	*pdwRequestID=0;
	
	//delete all stale requests
	CEPRequestRefresh();

	if(NULL == (pRequestEntry=CEPSearchRequest(pbHash, &dwIndex)))
		goto InvalidArgErr;

	*pdwRequestID=pRequestEntry->dwRequestID;


	fResult=TRUE;

 
CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	CEPRequestAddHashAndRequestID
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPRequestAddHashAndRequestID(BYTE		*pbHash, 
												DWORD	dwRequestID)
{
	BOOL							fResult=FALSE;
	SYSTEMTIME						SystemTime;	
	DWORD							dwHashIndex=0;


	CEP_REQUEST_ENTRY				*pRequestEntry=NULL;
	CEP_REQUEST_VALIDITY_ENTRY		*pValidityEntry=NULL;

	
	//delete all stale requests
	CEPRequestRefresh();

	if(!CEPHashRequest(pbHash, &dwHashIndex))
		goto InvalidArgErr;

	pRequestEntry=(CEP_REQUEST_ENTRY *)malloc(sizeof(CEP_REQUEST_ENTRY));

	if(!pRequestEntry)
		goto MemoryErr;

	memset(pRequestEntry, 0, sizeof(CEP_REQUEST_ENTRY));
	
	pValidityEntry=(CEP_REQUEST_VALIDITY_ENTRY *)malloc(sizeof(CEP_REQUEST_VALIDITY_ENTRY));

	if(!pValidityEntry)
		goto MemoryErr;

	memset(pValidityEntry, 0, sizeof(CEP_REQUEST_VALIDITY_ENTRY));

	memcpy(pRequestEntry->pbHash, pbHash, CEP_MD5_HASH_SIZE);

	pRequestEntry->dwRequestID=dwRequestID;
	pRequestEntry->pValidityEntry=pValidityEntry;
	pRequestEntry->pNext=NULL;
	pRequestEntry->pPrevious=NULL;

	GetSystemTime(&SystemTime);
	if(!SystemTimeToFileTime(&SystemTime, &(pValidityEntry->TimeStamp)))
		goto TraceErr;

	pValidityEntry->pRequestEntry=pRequestEntry;
	pValidityEntry->pNext=NULL;
	pValidityEntry->pPrevious=NULL;


	CEPInsertValidityEntry(pValidityEntry);

	CEPInsertRequestEntry(pRequestEntry, dwHashIndex);

	fResult=TRUE;
 
CommonReturn:

	return fResult;

ErrorReturn:

	if(pRequestEntry)
		CEPRequestFreeRequestEntry(pRequestEntry);

	if(pValidityEntry)
		CEPRequestFreeValidityEntry(pValidityEntry, FALSE);

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\mscep\cephash.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       cephash.cpp
//
//  Contents:   Cisco enrollment protocal implementation 
//              
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

CEP_HASH_TABLE_INFO			g_CEPHashTable;

//***************************************************************************
//
//	The following are APIs called internally.
//
//
//***************************************************************************

//--------------------------------------------------------------------------
//
//	CEPHashFreeHashEntry
//
//--------------------------------------------------------------------------
void	CEPHashFreeHashEntry(CEP_HASH_ENTRY *pHashEntry)
{
	if(pHashEntry)
	{
		if(pHashEntry->pszTransactionID)
			free(pHashEntry->pszTransactionID);

		free(pHashEntry);
	}
}

//--------------------------------------------------------------------------
//
//	CEPHashFreeTimeEntry
//
//--------------------------------------------------------------------------
void CEPHashFreeTimeEntry(CEP_TIME_ENTRY *pTimeEntry, BOOL fFreeHashEntry)
{
	if(pTimeEntry)
	{
		if(fFreeHashEntry)
			CEPHashFreeHashEntry(pTimeEntry->pHashEntry);

		free(pTimeEntry);
	}
}



//--------------------------------------------------------------------------
//
//	CEPHashByte
//
//  For any cases that we can not convert the psz, we use index 0.
//--------------------------------------------------------------------------
BOOL CEPHashByte(LPSTR psz, DWORD	*pdw)
{
	CHAR	sz[3];

	*pdw=0;

	if(!psz)
		return FALSE;

	if(2 <= strlen(psz))
	{

		memcpy(sz, psz, 2 * sizeof(CHAR));
		sz[2]='\0';

		*pdw=strtoul(sz, NULL, 16);

		if(ULONG_MAX == *pdw)
			*pdw=0;
	}

	if(*pdw >= CEP_HASH_TABLE_SIZE)
		*pdw=0;

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPSearchTransactionID
//  
//--------------------------------------------------------------------------
CEP_HASH_ENTRY  *CEPSearchTransactionID(CERT_BLOB	*pTransactionID, DWORD *pdwIndex)
{
	CEP_HASH_ENTRY		*pHashEntry=NULL;
	DWORD				dwHashIndex=0;

	if(pdwIndex)
		*pdwIndex=0;

	if(NULL==pTransactionID->pbData)
		return NULL;

	//hash based on the 1st and 2nd character
	if(!CEPHashByte((LPSTR)(pTransactionID->pbData), &dwHashIndex))
		return NULL;

	for(pHashEntry=g_CEPHashTable.rgHashEntry[dwHashIndex]; NULL != pHashEntry; pHashEntry=pHashEntry->pNext)
	{
		if(0==strcmp((LPSTR)(pTransactionID->pbData), pHashEntry->pszTransactionID))
		{
			break;
		}
	}

	if(pHashEntry)
	{
		if(pdwIndex)
			*pdwIndex=dwHashIndex; 
	}

	return pHashEntry;
}

//--------------------------------------------------------------------------
//
//	CEPInsertTimeEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPInsertTimeEntry(CEP_TIME_ENTRY *pTimeEntry)
{
	BOOL	fResult=FALSE;

	if(g_CEPHashTable.pTimeNew)
	{
		g_CEPHashTable.pTimeNew->pNext=pTimeEntry;
		pTimeEntry->pPrevious=g_CEPHashTable.pTimeNew;
		g_CEPHashTable.pTimeNew=pTimeEntry;
	}
	else
	{
		//no item in the list yet
		g_CEPHashTable.pTimeOld=pTimeEntry;
		g_CEPHashTable.pTimeNew=pTimeEntry;
	}

	fResult=TRUE;

	return fResult;
}


//--------------------------------------------------------------------------
//
//	CEPInsertHashEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPInsertHashEntry(CEP_HASH_ENTRY *pHashEntry, DWORD dwHashIndex)
{
	BOOL	fResult=FALSE;

	if(g_CEPHashTable.rgHashEntry[dwHashIndex])
	{
	   g_CEPHashTable.rgHashEntry[dwHashIndex]->pPrevious=pHashEntry;
	   pHashEntry->pNext=g_CEPHashTable.rgHashEntry[dwHashIndex];
	   g_CEPHashTable.rgHashEntry[dwHashIndex]=pHashEntry;
	}
	else
	{
		//1st item
		g_CEPHashTable.rgHashEntry[dwHashIndex]=pHashEntry;
	}


	fResult=TRUE;

	return fResult;
}

//--------------------------------------------------------------------------
//
//	CEPHashRemoveTimeEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPHashRemoveTimeEntry(CEP_TIME_ENTRY	*pTimeEntry)
{
	BOOL	fResult=FALSE;

	if(!pTimeEntry)
		goto InvalidArgErr;

	if(pTimeEntry->pPrevious)
		pTimeEntry->pPrevious->pNext=pTimeEntry->pNext;
	else
	{
		//1st item
		g_CEPHashTable.pTimeOld=pTimeEntry->pNext;
	}

	if(pTimeEntry->pNext)
		pTimeEntry->pNext->pPrevious=pTimeEntry->pPrevious;
	else
	{
		//last itme
		g_CEPHashTable.pTimeNew=pTimeEntry->pPrevious;

	}

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	CEPHashRemoveHashEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPHashRemoveHashEntry(CEP_HASH_ENTRY	*pHashEntry, DWORD dwIndex)
{
	BOOL	fResult=FALSE;

	if(!pHashEntry)
		goto InvalidArgErr;


	if(pHashEntry->pPrevious)
		pHashEntry->pPrevious->pNext=pHashEntry->pNext;
	else
		g_CEPHashTable.rgHashEntry[dwIndex]=pHashEntry->pNext;

	if(pHashEntry->pNext)
		pHashEntry->pNext->pPrevious=pHashEntry->pPrevious;

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	CEPHashCheckCurrentTime
//
//	If we are still waiting for the pending results, use the default
//	waiting time, otherwise, use the cach time 
//--------------------------------------------------------------------------
BOOL CEPHashCheckCurrentTime(FILETIME *pTimeStamp, BOOL fFinished, DWORD dwRefreshDays)
{
	DWORD	dwDays=0;
	DWORD	dwMinutes=0;

	if(fFinished)
	{
		dwMinutes=g_dwRequestDuration;
	}
	else
	{
		dwDays=dwRefreshDays;
	}


	return CEPHashIsCurrentTimeEntry(pTimeStamp, dwDays, dwMinutes);

}

//--------------------------------------------------------------------------
//
//	CEPHashIsCurrentTimeEntry
//
//	If anything went wrong, we think the time entry is not current.
//--------------------------------------------------------------------------
BOOL CEPHashIsCurrentTimeEntry(FILETIME *pTimeStamp, DWORD dwRefreshDays, DWORD dwMinutes)
{
	BOOL				fCurrent=FALSE;
	SYSTEMTIME			SystemTime;	
	FILETIME			CurrentTime;
	ULARGE_INTEGER		dwSeconds;
    ULARGE_INTEGER      OldTime;
	FILETIME			UpdatedTimeStamp;

	if(!pTimeStamp)
		goto CLEANUP;

	GetSystemTime(&SystemTime);
	if(!SystemTimeToFileTime(&SystemTime, &(CurrentTime)))
		goto CLEANUP;

	//add the # of seconds
    //// FILETIME is in units of 100 nanoseconds (10**-7)
	if(dwRefreshDays)
		dwSeconds.QuadPart=dwRefreshDays * 24 * 3600;
	else
		dwSeconds.QuadPart=dwMinutes * 60;

    dwSeconds.QuadPart=dwSeconds.QuadPart * 10000000;

    OldTime.LowPart=pTimeStamp->dwLowDateTime;
    OldTime.HighPart=pTimeStamp->dwHighDateTime;

    OldTime.QuadPart = OldTime.QuadPart + dwSeconds.QuadPart;

	UpdatedTimeStamp.dwLowDateTime=OldTime.LowPart;
	UpdatedTimeStamp.dwHighDateTime=OldTime.HighPart;

	//1 means CurrentTime is greater than the UpdatedTimeStamp
	if( 1 == CompareFileTime(&CurrentTime, &UpdatedTimeStamp))
		goto CLEANUP;

	fCurrent=TRUE;

CLEANUP:

	return fCurrent;
}

//--------------------------------------------------------------------------
//
//	CEPHashRefresh
//
//--------------------------------------------------------------------------
BOOL	CEPHashRefresh(DWORD	dwRefreshDays)
{
	BOOL			fResult=FALSE;	
	DWORD			dwHashIndex=0;
	CEP_TIME_ENTRY	*pTimeEntry=NULL;

	while(g_CEPHashTable.pTimeOld)
	{
		if(!CEPHashCheckCurrentTime(&(g_CEPHashTable.pTimeOld->TimeStamp), g_CEPHashTable.pTimeOld->pHashEntry->fFinished, dwRefreshDays))
		{  
			if(!CEPHashByte(g_CEPHashTable.pTimeOld->pHashEntry->pszTransactionID, &dwHashIndex))
			{
				g_CEPHashTable.pTimeOld->pPrevious=NULL;
				goto InvalidArgErr;
			}

			CEPHashRemoveHashEntry(g_CEPHashTable.pTimeOld->pHashEntry, dwHashIndex);

			CEPHashFreeHashEntry(g_CEPHashTable.pTimeOld->pHashEntry);

			pTimeEntry=g_CEPHashTable.pTimeOld;

			g_CEPHashTable.pTimeOld=g_CEPHashTable.pTimeOld->pNext;

			CEPHashFreeTimeEntry(pTimeEntry, FALSE);
		}
		else
		{	
			//we find a new enough entry
			g_CEPHashTable.pTimeOld->pPrevious=NULL;
			break;
		}
	}


	//we have get rid of all items
	if(NULL == g_CEPHashTable.pTimeOld)
		g_CEPHashTable.pTimeNew=NULL;

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//***************************************************************************
//
//	The following are APIs called by the upper (external) layer
//
//
//***************************************************************************

//
// Function called without critical section protection
//
//--------------------------------------------------------------------------
//
//	InitHashTable
//
//--------------------------------------------------------------------------
BOOL InitHashTable()
{
	memset(&g_CEPHashTable, 0, sizeof(CEP_HASH_TABLE_INFO));

	return TRUE;
}



//--------------------------------------------------------------------------
//
//	ReleaseHashTable
//
//--------------------------------------------------------------------------
BOOL ReleaseHashTable()
{

	CEP_TIME_ENTRY	*pTimeEntry=NULL;

	//free the timestamp list and the hash table's doublie linked lists
	if(g_CEPHashTable.pTimeOld)
	{
		do{
			pTimeEntry=g_CEPHashTable.pTimeOld;

			g_CEPHashTable.pTimeOld = g_CEPHashTable.pTimeOld->pNext;
			
			//free both the time entry and the hash entry
			CEPHashFreeTimeEntry(pTimeEntry, TRUE);
		}
		while(g_CEPHashTable.pTimeOld);
	}
			
	memset(&g_CEPHashTable, 0, sizeof(CEP_HASH_TABLE_INFO));
	

	return TRUE;
}


//
// Function called with critical section protection
//
//--------------------------------------------------------------------------
//
//	CEPHashGetRequestID
//  
//  Retriev the MS Cert Server's requestID based on the transaction ID
//--------------------------------------------------------------------------
BOOL CEPHashGetRequestID(	DWORD		dwRefreshDays,
				CERT_BLOB  *pTransactionID, 
						 DWORD		*pdwRequestID)
{
	BOOL			fResult=FALSE;
	CEP_HASH_ENTRY	*pHashEntry=NULL;
	
	*pdwRequestID=0;

	//we refresh the time list so that we only keep most up-to-date entries
	if(0 != dwRefreshDays)
		CEPHashRefresh(dwRefreshDays);


	if(NULL == (pHashEntry=CEPSearchTransactionID(pTransactionID, NULL)))
		goto InvalidArgErr;

	//we do not process the stable items.  They could exit due to the 
	//20 minutes buffer
	if(!CEPHashCheckCurrentTime(&(pHashEntry->pTimeEntry->TimeStamp), 
								pHashEntry->fFinished, 
								dwRefreshDays))
		goto InvalidArgErr;


	*pdwRequestID=pHashEntry->dwRequestID;

	fResult=TRUE;

 
CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	CEPHashRemoveRequestAndTransaction
//
//  
//--------------------------------------------------------------------------
BOOL CEPHashRemoveRequestAndTransaction(DWORD	dwRequestID, CERT_BLOB *pTransactionID)
{
	BOOL			fResult=FALSE;
	CEP_HASH_ENTRY	*pHashEntry=NULL;
	DWORD			dwIndex=0;
	

	if(NULL == (pHashEntry=CEPSearchTransactionID(pTransactionID, &dwIndex)))
		goto InvalidArgErr;

	CEPHashRemoveTimeEntry(pHashEntry->pTimeEntry);

	CEPHashRemoveHashEntry(pHashEntry, dwIndex);

	CEPHashFreeTimeEntry(pHashEntry->pTimeEntry, FALSE);

	CEPHashFreeHashEntry(pHashEntry);

	fResult=TRUE;

 
CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}
//--------------------------------------------------------------------------
//
//	CEPHashMarkTransactionFinished
//
//  
//--------------------------------------------------------------------------
BOOL CEPHashMarkTransactionFinished(DWORD	dwRequestID, CERT_BLOB *pTransactionID)
{
	BOOL			fResult=FALSE;
	CEP_HASH_ENTRY	*pHashEntry=NULL;
	DWORD			dwIndex=0; 
	SYSTEMTIME		SystemTime;	
	

	if(NULL == (pHashEntry=CEPSearchTransactionID(pTransactionID, &dwIndex)))
		goto InvalidArgErr;

	pHashEntry->fFinished=TRUE;

	//re-timestamp the entry since it should last for another 20 minutes for
	//retrial cases
	GetSystemTime(&SystemTime);
	if(!SystemTimeToFileTime(&SystemTime, &(pHashEntry->pTimeEntry->TimeStamp)))
		goto InvalidArgErr;

	fResult=TRUE;

 
CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	AddRequestAndTransaction
//
//  Add a requestID and TransactionID pair
//--------------------------------------------------------------------------
BOOL CEPHashAddRequestAndTransaction(DWORD		dwRefreshDays, 
									 DWORD		dwRequestID, 
									 CERT_BLOB	*pTransactionID)
{	 

	BOOL				fResult=FALSE;
	SYSTEMTIME			SystemTime;	
	DWORD				dwHashIndex=0;


	CEP_HASH_ENTRY		*pHashEntry=NULL;
	CEP_TIME_ENTRY		*pTimeEntry=NULL;
		
	//remove the old requestID/transactionID pair
	CEPHashRemoveRequestAndTransaction(dwRequestID, pTransactionID);


	if(!CEPHashByte((LPSTR)(pTransactionID->pbData), &dwHashIndex))
		goto InvalidArgErr;


	pHashEntry=(CEP_HASH_ENTRY *)malloc(sizeof(CEP_HASH_ENTRY));

	if(!pHashEntry)
		goto MemoryErr;

	memset(pHashEntry, 0, sizeof(CEP_HASH_ENTRY));
	
	pTimeEntry=(CEP_TIME_ENTRY *)malloc(sizeof(CEP_TIME_ENTRY));

	if(!pTimeEntry)
		goto MemoryErr;

	memset(pTimeEntry, 0, sizeof(CEP_TIME_ENTRY));

	pHashEntry->pszTransactionID=(LPSTR)malloc(strlen((LPSTR)(pTransactionID->pbData))+1);
	if(!(pHashEntry->pszTransactionID))
		goto MemoryErr;

	strcpy(pHashEntry->pszTransactionID,(LPSTR)(pTransactionID->pbData));
	pHashEntry->dwRequestID=dwRequestID;
	pHashEntry->fFinished=FALSE;
	pHashEntry->pTimeEntry=pTimeEntry;
	pHashEntry->pNext=NULL;
	pHashEntry->pPrevious=NULL;

	GetSystemTime(&SystemTime);
	if(!SystemTimeToFileTime(&SystemTime, &(pTimeEntry->TimeStamp)))
		goto TraceErr;
	pTimeEntry->pHashEntry=pHashEntry;
	pTimeEntry->pNext=NULL;
	pTimeEntry->pPrevious=NULL;


	CEPInsertTimeEntry(pTimeEntry);

	CEPInsertHashEntry(pHashEntry, dwHashIndex);

	//we refresh the time list so that we only keep most up-to-date entries
	if(0 != dwRefreshDays)
		CEPHashRefresh(dwRefreshDays);

	fResult=TRUE;

 
CommonReturn:

	return fResult;

ErrorReturn:

	if(pHashEntry)
		CEPHashFreeHashEntry(pHashEntry);

	if(pTimeEntry)
		CEPHashFreeTimeEntry(pTimeEntry, FALSE);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//***************************************************************************
//
//	obsolete
//
//
//***************************************************************************
/*

//TODO: Send to database later
//DWORD			g_dwRequestID=0;
//CERT_BLOB		g_TransactionID={0, NULL};


//--------------------------------------------------------------------------
//
//	GetRequestID
//
// TODO: we need to call the database layer in this case
//--------------------------------------------------------------------------
BOOL GetRequestID(CERT_BLOB *pTransactionID, 
				  DWORD		*pdwRequestID)
{
	*pdwRequestID=0;

	if(NULL==pTransactionID->pbData)
		return FALSE;

	//make sure we have the correct transaction ID
	if(0!=strcmp((LPSTR)(pTransactionID->pbData), (LPSTR)(g_TransactionID.pbData)))
		return FALSE;

	*pdwRequestID=g_dwRequestID;

	return TRUE;

}

//--------------------------------------------------------------------------
//
//	DeleteRequestAndTransaction
//
// TODO: we need to call the database layer in this case
//--------------------------------------------------------------------------
BOOL DeleteRequestAndTransaction(DWORD	dwRequestID, CERT_BLOB *pTransactionID)
{
	g_dwRequestID=0;

	if(g_TransactionID.pbData)
		free(g_TransactionID.pbData);

	g_TransactionID.pbData=NULL;
	g_TransactionID.cbData=0;

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CopyRequestAndTransaction
//
// TODO: we need to call the database layer in this case
//--------------------------------------------------------------------------
BOOL CopyRequestAndTransaction(DWORD	dwRequestID, CERT_BLOB *pTransactionID)
{
	//delete the old requestID/transactionID pair
	DeleteRequestAndTransaction(dwRequestID, pTransactionID);

	g_dwRequestID=dwRequestID;

	g_TransactionID.pbData=(BYTE *)malloc(strlen((LPSTR)(pTransactionID->pbData))+1);

	if(NULL == g_TransactionID.pbData)
	{
		SetLastError(E_OUTOFMEMORY);
		return FALSE;
	}

	g_TransactionID.cbData=strlen((LPSTR)(pTransactionID->pbData));

	memcpy(g_TransactionID.pbData, (LPSTR)(pTransactionID->pbData), g_TransactionID.cbData+1);

	return TRUE;
}	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\mscep\ceppswrd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       ceppswrd.cpp
//
//  Contents:   Cisco enrollment protocol implementation.  This module
//				implement the password hash table.
//              
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

DWORD						g_dwPasswordCount=0;
DWORD						g_dwMaxPassword=0;
DWORD						g_dwPasswordValidity=0;
CEP_PASSWORD_TABLE_INFO		g_CEPPasswordTable;

//***************************************************************************
//
//	The following are APIs called internally.
//
//
//***************************************************************************

//--------------------------------------------------------------------------
//
//	CEPPasswordFreePasswordEntry
//
//--------------------------------------------------------------------------
void	CEPPasswordFreePasswordEntry(CEP_PASSWORD_ENTRY *pPasswordEntry)
{
	if(pPasswordEntry)
	{
		if(pPasswordEntry->pwszPassword)
			free(pPasswordEntry->pwszPassword);

		free(pPasswordEntry);
	}
}

//--------------------------------------------------------------------------
//
//	CEPPasswordFreeValidityEntry
//
//--------------------------------------------------------------------------
void CEPPasswordFreeValidityEntry(CEP_PASSWORD_VALIDITY_ENTRY	*pValidityEntry, 
								  BOOL							fFreePasswordEntry)
{
	if(pValidityEntry)
	{
		if(fFreePasswordEntry)
			CEPPasswordFreePasswordEntry(pValidityEntry->pPasswordEntry);

		free(pValidityEntry);
	}
}

//--------------------------------------------------------------------------
//
//	CEPHashPassword
//
//  For any cases that we can not convert the psz, we use index 0.
//--------------------------------------------------------------------------
BOOL CEPHashPassword(LPWSTR pwsz, DWORD	*pdw)
{
	WCHAR	wsz[3];

	*pdw=0;

	if(!pwsz)
		return FALSE;

	if(2 <= wcslen(pwsz))
	{
		memcpy(wsz, pwsz, 2 * sizeof(WCHAR));
		wsz[2]=L'\0';

		*pdw=wcstoul(wsz, NULL, 16);

		if(ULONG_MAX == *pdw)
			*pdw=0;
	}

	if(*pdw >= CEP_HASH_TABLE_SIZE)
		*pdw=0;

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPSearchPassword
//  
//--------------------------------------------------------------------------
CEP_PASSWORD_ENTRY  *CEPSearchPassword(LPWSTR	pwszPassword, DWORD *pdwIndex)
{
	CEP_PASSWORD_ENTRY		*pPasswordEntry=NULL;
	DWORD					dwHashIndex=0;

	if(pdwIndex)
		*pdwIndex=0;

	if(NULL==pwszPassword)
		return NULL;

	//hash based on the 1st and 2nd character
	if(!CEPHashPassword(pwszPassword, &dwHashIndex))
		return NULL;

	for(pPasswordEntry=g_CEPPasswordTable.rgPasswordEntry[dwHashIndex]; NULL != pPasswordEntry; pPasswordEntry=pPasswordEntry->pNext)
	{
		if(0==wcscmp(pwszPassword, pPasswordEntry->pwszPassword))
		{
			break;
		}
	}

	if(pPasswordEntry)
	{
		if(pdwIndex)
			*pdwIndex=dwHashIndex; 
	}

	return pPasswordEntry;
}

//--------------------------------------------------------------------------
//
//	CEPInsertValidityEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPInsertValidityEntry(CEP_PASSWORD_VALIDITY_ENTRY *pValidityEntry)
{
	if(!pValidityEntry)
		return FALSE;

	if(g_CEPPasswordTable.pTimeNew)
	{
		g_CEPPasswordTable.pTimeNew->pNext=pValidityEntry;
		pValidityEntry->pPrevious=g_CEPPasswordTable.pTimeNew;
		g_CEPPasswordTable.pTimeNew=pValidityEntry;
	}
	else
	{
		//no item in the list yet
		g_CEPPasswordTable.pTimeOld=pValidityEntry;
		g_CEPPasswordTable.pTimeNew=pValidityEntry;
	}

	return TRUE;
}


//--------------------------------------------------------------------------
//
//	CEPInsertPasswordEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPInsertPasswordEntry(CEP_PASSWORD_ENTRY *pPasswordEntry, DWORD dwHashIndex)
{

	if(!pPasswordEntry)
		return FALSE;

	if(g_CEPPasswordTable.rgPasswordEntry[dwHashIndex])
	{
	   g_CEPPasswordTable.rgPasswordEntry[dwHashIndex]->pPrevious=pPasswordEntry;
	   pPasswordEntry->pNext=g_CEPPasswordTable.rgPasswordEntry[dwHashIndex];
	   g_CEPPasswordTable.rgPasswordEntry[dwHashIndex]=pPasswordEntry;
	}
	else
	{
		//1st item
		g_CEPPasswordTable.rgPasswordEntry[dwHashIndex]=pPasswordEntry;
	}

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPPasswordRemoveValidityEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPPasswordRemoveValidityEntry(CEP_PASSWORD_VALIDITY_ENTRY	*pValidityEntry)
{
	BOOL	fResult=FALSE;

	if(!pValidityEntry)
		goto InvalidArgErr;

	if(pValidityEntry->pPrevious)
		pValidityEntry->pPrevious->pNext=pValidityEntry->pNext;
	else
	{
		//1st item
		g_CEPPasswordTable.pTimeOld=pValidityEntry->pNext;
	}

	if(pValidityEntry->pNext)
		pValidityEntry->pNext->pPrevious=pValidityEntry->pPrevious;
	else
	{
		//last itme
		g_CEPPasswordTable.pTimeNew=pValidityEntry->pPrevious;

	}

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	CEPPasswordRemovePasswordEntry
//  
//--------------------------------------------------------------------------
BOOL	CEPPasswordRemovePasswordEntry(CEP_PASSWORD_ENTRY	*pPasswordEntry, DWORD dwIndex)
{
	BOOL	fResult=FALSE;

	if(!pPasswordEntry)
		goto InvalidArgErr;


	if(pPasswordEntry->pPrevious)
		pPasswordEntry->pPrevious->pNext=pPasswordEntry->pNext;
	else
		g_CEPPasswordTable.rgPasswordEntry[dwIndex]=pPasswordEntry->pNext;

	if(pPasswordEntry->pNext)
		pPasswordEntry->pNext->pPrevious=pPasswordEntry->pPrevious;

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	CEPPasswordRefresh
//
//--------------------------------------------------------------------------
BOOL	CEPPasswordRefresh()
{
	BOOL						fResult=FALSE;	
	DWORD						dwHashIndex=0;
	CEP_PASSWORD_VALIDITY_ENTRY	*pValidityEntry=NULL;

	while(g_CEPPasswordTable.pTimeOld)
	{
		if(!CEPHashIsCurrentTimeEntry(&(g_CEPPasswordTable.pTimeOld->TimeStamp), 0, g_dwPasswordValidity))
		{  
			if(!CEPHashPassword(g_CEPPasswordTable.pTimeOld->pPasswordEntry->pwszPassword, &dwHashIndex))
			{
				g_CEPPasswordTable.pTimeOld->pPrevious=NULL;
				goto InvalidArgErr;
			}

			CEPPasswordRemovePasswordEntry(g_CEPPasswordTable.pTimeOld->pPasswordEntry, dwHashIndex);

			CEPPasswordFreePasswordEntry(g_CEPPasswordTable.pTimeOld->pPasswordEntry);

			pValidityEntry=g_CEPPasswordTable.pTimeOld;

			g_CEPPasswordTable.pTimeOld=g_CEPPasswordTable.pTimeOld->pNext;

			CEPPasswordFreeValidityEntry(pValidityEntry, FALSE);
		   
			if(g_dwPasswordCount >= 1)
				g_dwPasswordCount--;
		}
		else
		{	
			//we find a new enough entry
			g_CEPPasswordTable.pTimeOld->pPrevious=NULL;
			break;
		}
	}


	//we have get rid of all items
	if(NULL == g_CEPPasswordTable.pTimeOld)
	{
		g_CEPPasswordTable.pTimeNew=NULL;
		g_dwPasswordCount=0;
	}
	

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//***************************************************************************
//
//	The following are APIs called by the upper (external) layer
//
//
//***************************************************************************

//--------------------------------------------------------------------------
//
//	InitPasswordTable
//
//--------------------------------------------------------------------------
BOOL	WINAPI	InitPasswordTable()
{
	DWORD				cbData=0;
	DWORD				dwData=0;
	DWORD				dwType=0;

    HKEY                hKey=NULL;

	memset(&g_CEPPasswordTable, 0, sizeof(CEP_PASSWORD_TABLE_INFO));

	g_dwPasswordCount=0;
	g_dwMaxPassword=CEP_MAX_PASSWORD;
	g_dwPasswordValidity=CEP_PASSWORD_VALIDITY;

	if(ERROR_SUCCESS == RegOpenKeyExU(
					HKEY_LOCAL_MACHINE,
                    MSCEP_PASSWORD_MAX_LOCATION,
                    0,
                    KEY_READ,
                    &hKey))
    {
        cbData=sizeof(dwData);

        if(ERROR_SUCCESS == RegQueryValueExU(
                        hKey,
                        MSCEP_KEY_PASSWORD_MAX,
                        NULL,
                        &dwType,
                        (BYTE *)&dwData,
                        &cbData))
		{
			if ((dwType == REG_DWORD) ||
                (dwType == REG_BINARY))
			{
				g_dwMaxPassword=dwData;	
			}
		}
	}

 	dwType=0;
	dwData=0;
    if(hKey)
        RegCloseKey(hKey);

	hKey=NULL;

	if(ERROR_SUCCESS == RegOpenKeyExU(
					HKEY_LOCAL_MACHINE,
                    MSCEP_PASSWORD_VALIDITY_LOCATION,
                    0,
                    KEY_READ,
                    &hKey))
    {
        cbData=sizeof(dwData);

        if(ERROR_SUCCESS == RegQueryValueExU(
                        hKey,
                        MSCEP_KEY_PASSWORD_VALIDITY,
                        NULL,
                        &dwType,
                        (BYTE *)&dwData,
                        &cbData))
		{
			if ((dwType == REG_DWORD) ||
                (dwType == REG_BINARY))
			{
				g_dwPasswordValidity=dwData;	
			}
		}
	}

    if(hKey)
        RegCloseKey(hKey);

	return TRUE;

}

//--------------------------------------------------------------------------
//
//	ReleasePasswordTable
//
//--------------------------------------------------------------------------
BOOL WINAPI  ReleasePasswordTable()
{

	CEP_PASSWORD_VALIDITY_ENTRY	*pValidityEntry=NULL;

	//free the timestamp list and the password table's doublie linked lists
	if(g_CEPPasswordTable.pTimeOld)
	{
		do{
			pValidityEntry=g_CEPPasswordTable.pTimeOld;

			g_CEPPasswordTable.pTimeOld = g_CEPPasswordTable.pTimeOld->pNext;
			
			CEPPasswordFreeValidityEntry(pValidityEntry, TRUE);
		}
		while(g_CEPPasswordTable.pTimeOld);
	}
			
	memset(&g_CEPPasswordTable, 0, sizeof(CEP_PASSWORD_TABLE_INFO));
	

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPAddPasswordToTable
//
//	Need to be protected by the critical section.
//
//	Last error is set to CRYPT_E_NO_MATCH if the max number of password is 
//	reached.
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPAddPasswordToTable(LPWSTR	pwszPassword)
{
	BOOL							fResult=FALSE;
	SYSTEMTIME						SystemTime;	
	DWORD							dwHashIndex=0;


	CEP_PASSWORD_ENTRY				*pPasswordEntry=NULL;
	CEP_PASSWORD_VALIDITY_ENTRY		*pValidityEntry=NULL;

	EnterCriticalSection(&PasswordCriticalSec);

	if(NULL==pwszPassword)
		goto InvalidArgErr;

	//delete all expired passwords
	CEPPasswordRefresh();

	if(g_dwPasswordCount >= g_dwMaxPassword)
		goto NoMatchErr;

	g_dwPasswordCount++;

	if(!CEPHashPassword(pwszPassword, &dwHashIndex))
		goto InvalidArgErr;


	pPasswordEntry=(CEP_PASSWORD_ENTRY *)malloc(sizeof(CEP_PASSWORD_ENTRY));

	if(!pPasswordEntry)
		goto MemoryErr;

	memset(pPasswordEntry, 0, sizeof(CEP_PASSWORD_ENTRY));
	
	pValidityEntry=(CEP_PASSWORD_VALIDITY_ENTRY *)malloc(sizeof(CEP_PASSWORD_VALIDITY_ENTRY));

	if(!pValidityEntry)
		goto MemoryErr;

	memset(pValidityEntry, 0, sizeof(CEP_PASSWORD_VALIDITY_ENTRY));

	pPasswordEntry->pwszPassword=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszPassword)+1));
	if(!(pPasswordEntry->pwszPassword))
		goto MemoryErr;

	wcscpy(pPasswordEntry->pwszPassword,pwszPassword);

	//no usage has been requested
	pPasswordEntry->dwUsageRequested=0;
	pPasswordEntry->pValidityEntry=pValidityEntry;
	pPasswordEntry->pNext=NULL;
	pPasswordEntry->pPrevious=NULL;

	GetSystemTime(&SystemTime);
	if(!SystemTimeToFileTime(&SystemTime, &(pValidityEntry->TimeStamp)))
		goto TraceErr;

	pValidityEntry->pPasswordEntry=pPasswordEntry;
	pValidityEntry->pNext=NULL;
	pValidityEntry->pPrevious=NULL;


	CEPInsertValidityEntry(pValidityEntry);

	CEPInsertPasswordEntry(pPasswordEntry, dwHashIndex);

	fResult=TRUE;
 
CommonReturn:

 	LeaveCriticalSection(&PasswordCriticalSec);

	return fResult;

ErrorReturn:

	if(pPasswordEntry)
		CEPPasswordFreePasswordEntry(pPasswordEntry);

	if(pValidityEntry)
		CEPPasswordFreeValidityEntry(pValidityEntry, FALSE);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(NoMatchErr, CRYPT_E_NO_MATCH);
TRACE_ERROR(TraceErr);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	CEPVerifyPasswordAndDeleteFromTable
//
//	Need to be protected by the critical section.
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPVerifyPasswordAndDeleteFromTable(LPWSTR	pwszPassword, DWORD dwUsage)
{
	BOOL					fResult=FALSE;
	CEP_PASSWORD_ENTRY		*pPasswordEntry=NULL;
	DWORD					dwIndex=0;
	
	EnterCriticalSection(&PasswordCriticalSec);

	//delete all expired passwords
	CEPPasswordRefresh();

	if(NULL == (pPasswordEntry=CEPSearchPassword(pwszPassword, &dwIndex)))
		goto InvalidArgErr;

	//verify the usage.

	//only one signature and one exchange key per password
	if(0 != ((pPasswordEntry->dwUsageRequested) & dwUsage))
		goto InvalidArgErr;

	pPasswordEntry->dwUsageRequested = (pPasswordEntry->dwUsageRequested) | dwUsage;

	//remove the password only if both signature and exchange key are requested
	if(((pPasswordEntry->dwUsageRequested) & CEP_REQUEST_SIGNATURE) &&
	   ((pPasswordEntry->dwUsageRequested) & CEP_REQUEST_EXCHANGE))
	{

		CEPPasswordRemoveValidityEntry(pPasswordEntry->pValidityEntry);

		CEPPasswordRemovePasswordEntry(pPasswordEntry, dwIndex);

		CEPPasswordFreeValidityEntry(pPasswordEntry->pValidityEntry, FALSE);

		CEPPasswordFreePasswordEntry(pPasswordEntry);

		if(g_dwPasswordCount >= 1)
			g_dwPasswordCount--;
	}

	fResult=TRUE;

 
CommonReturn:

 	LeaveCriticalSection(&PasswordCriticalSec);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\mscep\cepca.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       cepca.cpp
//
//  Contents:   Cisco enrollment protocal implementation.
//				This file has CA specific code.
//
//
//              
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>


//--------------------------------------------------------------------------
//
//	InitCAInformation
//
//--------------------------------------------------------------------------
BOOL	InitCAInformation(CEP_CA_INFO	*pCAInfo)
{
	BOOL			fResult = FALSE;
	long			nCount=0;
	long			nIndex=0;
	WCHAR			wszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD			dwSize=MAX_COMPUTERNAME_LENGTH + 1;
	HRESULT			hr = E_FAIL;
	DWORD			cbData=0;
	DWORD			dwData=0;
	DWORD			dwType=0;
	long			dwErr=0;

	ICertConfig		*pICertConfig=NULL;
	BSTR			bstrFieldName=NULL;
	BSTR			bstrFieldValue=NULL;
    HKEY            hKeyCAType=NULL;
	HKEY			hKeyCEP=NULL;


	memset(pCAInfo, 0, sizeof(CEP_CA_INFO));

	//we should only worry about the NetBois name.  Do not care about the DNS
	//GetComputerNameW in Win2K only returns NetBois name
	if(!GetComputerNameW(wszComputerName, &dwSize))
		goto TraceErr;

	if(S_OK != (hr=CoCreateInstance(CLSID_CCertConfig,
									NULL,
									CLSCTX_INPROC_SERVER,
									IID_ICertConfig,
									(void **)&pICertConfig)))
		goto CertSrvErr;

	if(S_OK != (hr=pICertConfig->Reset(nIndex, &nCount)))
		goto CertSrvErr;

	if(0==nCount)
		goto NoSrvErr;

	if(NULL == (bstrFieldName=SysAllocString(wszCONFIG_SERVER)))
		goto MemoryErr;

	while(nIndex != -1)
	{
		//find the configuration that matches the current machine's name
		if(S_OK != (hr=pICertConfig->GetField(bstrFieldName, &bstrFieldValue)))
			goto CertSrvErr;

		if(0==_wcsnicmp(bstrFieldValue, wszComputerName, wcslen(wszComputerName)))
		{
			if(NULL == ((pCAInfo->bstrCAMachine)=SysAllocString(bstrFieldValue)))
				goto MemoryErr;

			//CA name
			SysFreeString(bstrFieldName);  
			bstrFieldName=NULL;

			if(NULL == (bstrFieldName=SysAllocString(wszCONFIG_AUTHORITY)))
				goto MemoryErr;

			if(S_OK != (hr=pICertConfig->GetField(bstrFieldName, &(pCAInfo->bstrCAName))))
				goto CertSrvErr;

			if(NULL == pCAInfo->bstrCAName)
				goto FailErr;

			//CA config
			SysFreeString(bstrFieldName);  
			bstrFieldName=NULL;

			if(NULL == (bstrFieldName=SysAllocString(wszCONFIG_CONFIG)))
				goto MemoryErr;

			if(S_OK != (hr=pICertConfig->GetField(bstrFieldName, &(pCAInfo->bstrCAConfig))))
				goto CertSrvErr;

			if(NULL == pCAInfo->bstrCAConfig)
				goto FailErr;

			//DSName
			SysFreeString(bstrFieldName);  
			bstrFieldName=NULL;

			if(NULL == (bstrFieldName=SysAllocString(wszCONFIG_SANITIZEDSHORTNAME)))
				goto MemoryErr;

			if(S_OK != (hr=pICertConfig->GetField(bstrFieldName, &(pCAInfo->bstrDSName))))
				goto CertSrvErr;

			if(NULL == pCAInfo->bstrDSName)
				goto FailErr;

			//ICertRequest
			if(S_OK != (hr=CoCreateInstance(CLSID_CCertRequest,
											NULL,
											CLSCTX_INPROC_SERVER,
											IID_ICertRequest,
											(void **)&(pCAInfo->pICertRequest))))
				goto CertSrvErr;

			//success
			break;
		}

		SysFreeString(bstrFieldValue);
		bstrFieldValue=NULL;

		hr = pICertConfig->Next(&nIndex);

		if( (S_OK != hr) && (-1 != nIndex))
			goto CertSrvErr;
	}

	if(-1 == nIndex)
		goto NoSrvErr;

	//get the CA's type from the registry
	cbData=sizeof(dwData);
		
	//we have to have the knowledge of the ca type
	if(ERROR_SUCCESS != (dwErr =  RegOpenKeyExU(
					HKEY_LOCAL_MACHINE,
                    MSCEP_CATYPE_LOCATION,
                    0,
                    KEY_READ,
                    &hKeyCAType)))
		goto RegErr;

    if(ERROR_SUCCESS != (dwErr = RegQueryValueExU(
                    hKeyCAType,
                    MSCEP_KEY_CATYPE,
                    NULL,
                    &dwType,
                    (BYTE *)&dwData,
                    &cbData)))
		goto RegErr;

	if ((dwType != REG_DWORD) &&
        (dwType != REG_BINARY))
		goto RegErr;

	if(0 == dwData)
		pCAInfo->fEnterpriseCA=FALSE;
	else
		pCAInfo->fEnterpriseCA=TRUE;

	if(pCAInfo->fEnterpriseCA)
	{
		//get the template name for key usage requests
		if(ERROR_SUCCESS != (dwErr =  RegOpenKeyExU(
						HKEY_LOCAL_MACHINE,
						MSCEP_LOCATION,
						0,
						KEY_READ,
						&hKeyCEP)))
			goto RegErr;
		

		//signature template
		cbData=0;
		if(ERROR_SUCCESS == (dwErr = RegQueryValueExW(hKeyCEP, MSCEP_KEY_SIG_TEMPLATE, 
								NULL, &dwType, NULL, &cbData)))
		{
			if((REG_SZ == dwType) && (1 < cbData))
			{
				pCAInfo->pwszTemplateSig=(LPWSTR)malloc(cbData);
				if(NULL == pCAInfo->pwszTemplateSig)
					goto MemoryErr;

				if(ERROR_SUCCESS != (dwErr = RegQueryValueExW(hKeyCEP, MSCEP_KEY_SIG_TEMPLATE, 
								NULL, &dwType, (BYTE *)(pCAInfo->pwszTemplateSig), &cbData)))
					goto RegErr;

			}
		}

		//encryption template
		cbData=0;
		if(ERROR_SUCCESS == (dwErr = RegQueryValueExW(hKeyCEP, MSCEP_KEY_ENCYPT_TEMPLATE, 
								NULL, &dwType, NULL, &cbData)))
		{
			if((REG_SZ == dwType) && (1 < cbData))
			{
				pCAInfo->pwszTemplateEnt=(LPWSTR)malloc(cbData);
				if(NULL == pCAInfo->pwszTemplateEnt)
					goto MemoryErr;

				if(ERROR_SUCCESS != (dwErr = RegQueryValueExW(hKeyCEP, MSCEP_KEY_ENCYPT_TEMPLATE, 
								NULL, &dwType, (BYTE *)(pCAInfo->pwszTemplateEnt), &cbData)))
					goto RegErr;

			}

		}

		//make sure both templates are present in the DS
		//make sure the CA does issue the template
		if(pCAInfo->pwszTemplateSig)
		{
			if(S_OK != (hr=CheckACLOnCertTemplate(FALSE, pCAInfo->bstrDSName, pCAInfo->pwszTemplateSig)))
			{
				LogSCEPEvent(0, TRUE, hr, EVENT_MSCEP_NO_ENROLL, 3, g_pwszComputerName, pCAInfo->pwszTemplateSig, pCAInfo->bstrDSName);
				goto CertSrvErr;
			}
		}

		if(pCAInfo->pwszTemplateEnt)
		{
			if(S_OK != (hr=CheckACLOnCertTemplate(FALSE, pCAInfo->bstrDSName, pCAInfo->pwszTemplateEnt)))
			{
				LogSCEPEvent(0, TRUE, hr, EVENT_MSCEP_NO_ENROLL, 3, g_pwszComputerName, pCAInfo->pwszTemplateEnt, pCAInfo->bstrDSName);
				goto CertSrvErr;
			}
		}

		if(S_OK != (hr=CheckACLOnCertTemplate(FALSE, pCAInfo->bstrDSName, wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE)))
		{
			LogSCEPEvent(0, TRUE, hr, EVENT_MSCEP_NO_ENROLL, 3, g_pwszComputerName, wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE, pCAInfo->bstrDSName);
			goto CertSrvErr;
		}
	}

	//get the hProv to generate the random password
	if(!CryptAcquireContextU(&(pCAInfo->hProv),
                NULL,
                MS_DEF_PROV_W,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

    if(hKeyCEP)
        RegCloseKey(hKeyCEP);

    if(hKeyCAType)
        RegCloseKey(hKeyCAType);

	if(bstrFieldName)
		SysFreeString(bstrFieldName);

	if(bstrFieldValue)
		SysFreeString(bstrFieldValue);

	if(pICertConfig)
		pICertConfig->Release();

	return fResult;

ErrorReturn:

	FreeCAInformation(pCAInfo);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR_VAR(CertSrvErr, hr);
SET_ERROR(NoSrvErr, E_FAIL);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(FailErr, E_FAIL);
SET_ERROR_VAR(RegErr, dwErr);
}

//--------------------------------------------------------------------------
//
//	GetCACertFromInfo
//
//--------------------------------------------------------------------------
BOOL	GetCACertFromInfo(CEP_CA_INFO	*pCAInfo, HCERTSTORE *pHCACertStore)
{
	BOOL			fResult = FALSE;
	HRESULT			hr = S_OK;	
	CERT_BLOB		CertBlob;
	DWORD			dwFlags=0;
	PCCERT_CONTEXT	pPreCert=NULL;
	DWORD			cbData=0;
	
	BSTR			bstrCACert=NULL;
	PCCERT_CONTEXT	pCurCert=NULL; 
	BYTE			*pbData=NULL;

	if(NULL == (pCAInfo->pICertRequest))
		goto InvalidArgErr;

	//NT5 SPECIFIC: fExchangeCertificate can only be FALSE
	if(S_OK != (hr=(pCAInfo->pICertRequest)->GetCACertificate(
							FALSE,
							pCAInfo->bstrCAConfig,
							CR_OUT_BINARY | CR_OUT_CHAIN,
							&bstrCACert)))
		goto CAErr;

	if(NULL == bstrCACert)
		goto UnexpectedErr;

	CertBlob.cbData = (DWORD)SysStringByteLen(bstrCACert);
	CertBlob.pbData = (BYTE *)bstrCACert;

	if(NULL == (*pHCACertStore = CertOpenStore(
							CERT_STORE_PROV_PKCS7,
							ENCODE_TYPE,
							NULL,
							0,
							&CertBlob)))
		goto TraceErr;

	//we now need to get the CA's certificate's MD5 hash
	while(pCurCert=CertEnumCertificatesInStore(*pHCACertStore,
												pPreCert))
	{
		dwFlags = CERT_STORE_SIGNATURE_FLAG;
		if(CertVerifySubjectCertificateContext(pCurCert,
												pCurCert,
												&dwFlags) && (0==dwFlags))

			break;

		pPreCert=pCurCert;
	}

	if(NULL==pCurCert)
		goto InvalidArgErr;

	//get the MD5 hash
	if(!CertGetCertificateContextProperty(pCurCert,
										CERT_MD5_HASH_PROP_ID,
										NULL,
										&cbData))
		goto TraceErr;

	pbData=(BYTE *)malloc(cbData);

	if(NULL==pbData)
		goto MemoryErr;

	if(!CertGetCertificateContextProperty(pCurCert,
										CERT_MD5_HASH_PROP_ID,
										pbData,
										&cbData))
		goto TraceErr;


	if(!ConvertByteToWstr(pbData, cbData, &(pCAInfo->pwszCAHash), TRUE))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	if(pbData)
		free(pbData);

	if(pCurCert)
		CertFreeCertificateContext(pCurCert);

	if(bstrCACert)
		SysFreeString(bstrCACert);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(CAErr, hr);		 
TRACE_ERROR(TraceErr);
SET_ERROR(UnexpectedErr, E_UNEXPECTED);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	FreeCAInformation
//
//--------------------------------------------------------------------------
BOOL	FreeCAInformation(CEP_CA_INFO	*pCAInfo)
{
	if(pCAInfo)
	{
		if(pCAInfo->bstrCAMachine)
			SysFreeString(pCAInfo->bstrCAMachine);

		if(pCAInfo->bstrCAName)
			SysFreeString(pCAInfo->bstrCAName);

		if(pCAInfo->bstrCAConfig)
			SysFreeString(pCAInfo->bstrCAConfig);

		if(pCAInfo->bstrDSName)
			SysFreeString(pCAInfo->bstrDSName);

		if(pCAInfo->pwszCAHash)
			free(pCAInfo->pwszCAHash);

		if(pCAInfo->hProv)
			CryptReleaseContext(pCAInfo->hProv, 0);

		if(pCAInfo->pICertRequest)
			(pCAInfo->pICertRequest)->Release();

		if(pCAInfo->pwszTemplateSig)
			free(pCAInfo->pwszTemplateSig);

		if(pCAInfo->pwszTemplateEnt)
			free(pCAInfo->pwszTemplateEnt);

		//reset the data
		memset(pCAInfo, 0, sizeof(CEP_CA_INFO));
	}

	return TRUE;
}


//--------------------------------------------------------------------------
//
//	OperationGetCACert
//
//--------------------------------------------------------------------------
BOOL	OperationGetCACert(HCERTSTORE		hCACertStore,
							LPSTR			szMsg, 
							BYTE			**ppbData, 
							DWORD			*pcbData)
{
	BOOL				fResult = FALSE;
	CERT_BLOB			CertBlob;			

	CertBlob.cbData=0;
	CertBlob.pbData=NULL;

	if(!CertSaveStore(hCACertStore,
						ENCODE_TYPE,
						CERT_STORE_SAVE_AS_PKCS7,
						CERT_STORE_SAVE_TO_MEMORY,
						&CertBlob,
						0))
		goto CertErr;

	CertBlob.pbData = (BYTE *)malloc(CertBlob.cbData);

	if(NULL == CertBlob.pbData)
		goto MemoryErr;

	if(!CertSaveStore(hCACertStore,
						ENCODE_TYPE,
						CERT_STORE_SAVE_AS_PKCS7,
						CERT_STORE_SAVE_TO_MEMORY,
						&CertBlob,
						0))
		goto CertErr;

	//copy the memory
	*ppbData=CertBlob.pbData;
	*pcbData=CertBlob.cbData;
	
	CertBlob.pbData=NULL;

	fResult = TRUE;

CommonReturn:

	if(CertBlob.pbData)
		free(CertBlob.pbData);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(CertErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\mscep\cepra.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       cepca.cpp
//
//  Contents:   Cisco enrollment protocal implementation.
//				This file has the control's (ra) specific code.
//              
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>		


//--------------------------------------------------------------------------
//
//	FreeRAInformation
//
//--------------------------------------------------------------------------
BOOL	FreeRAInformation(CEP_RA_INFO	*pRAInfo)
{
	if(pRAInfo)
	{
		if(pRAInfo->fFree)
		{
			if(pRAInfo->hRAProv)
				CryptReleaseContext(pRAInfo->hRAProv, 0);
		}

		if(pRAInfo->fSignFree)
		{
			if(pRAInfo->hSignProv)
				CryptReleaseContext(pRAInfo->hSignProv, 0);
		}

		if(pRAInfo->pRACert)
			CertFreeCertificateContext(pRAInfo->pRACert);

		if(pRAInfo->pRASign)
			CertFreeCertificateContext(pRAInfo->pRASign);

		memset(pRAInfo, 0, sizeof(CEP_RA_INFO));
	}

	return TRUE;
}

/*
//--------------------------------------------------------------------------
//
//	GetRAInfo
//
//--------------------------------------------------------------------------
BOOL	GetRAInfo(CEP_RA_INFO	*pRAInfo)
{
	BOOL				fResult = FALSE;
	HCERTSTORE			hCEPStore=NULL;
	DWORD				dwSize=0;
	DWORD				dwIndex=0;
	HANDLE				hThread=NULL;	//no need to close
	HANDLE				hToken=NULL;

	HCERTSTORE			hSignStore=NULL;


    CERT_ENHKEY_USAGE   *pKeyUsage = NULL;
   
	memset(pRAInfo, 0, sizeof(CEP_RA_INFO));

    // so we can get access to the local machine's private key
	hThread=GetCurrentThread();
	
	if(NULL != hThread)
	{
		if(OpenThreadToken(hThread,
							TOKEN_IMPERSONATE | TOKEN_QUERY,
							FALSE,
							&hToken))
		{
			if(hToken)
			{
				//no need to check for return here.  If this failed, just go on
				RevertToSelf();
			}
		}
	}


	//sign RA
	if(!(hSignStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							ENCODE_TYPE,
							NULL,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
                            L"CEPSIGN")))
		goto TraceErr;


	if(!(pRAInfo->pRASign=CertEnumCertificatesInStore(
                              hSignStore,
                              NULL)))
		goto TraceErr;

	//the RA cert should have private key and enrollment agent usage
	dwSize=0;

	if(!CertGetCertificateContextProperty(
                pRAInfo->pRASign,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &dwSize) || (0==dwSize))
		goto InvalidArgErr;


	if(!CryptAcquireCertificatePrivateKey(pRAInfo->pRASign,
										CRYPT_ACQUIRE_COMPARE_KEY_FLAG | CRYPT_ACQUIRE_CACHE_FLAG,
										NULL,
										&(pRAInfo->hSignProv),
										&(pRAInfo->dwSignKeySpec),
										&(pRAInfo->fSignFree)))
		goto TraceErr;


	//exchange RA	
	
	if(!(hCEPStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							ENCODE_TYPE,
							NULL,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
                            CEP_STORE_NAME)))
		goto TraceErr;


	if(!(pRAInfo->pRACert=CertEnumCertificatesInStore(
                              hCEPStore,
                              NULL)))
		goto TraceErr;

	//the RA cert should have private key and enrollment agent usage
	dwSize=0;

	if(!CertGetCertificateContextProperty(
                pRAInfo->pRACert,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &dwSize) || (0==dwSize))
		goto InvalidArgErr;


	if(!CryptAcquireCertificatePrivateKey(pRAInfo->pRACert,
										CRYPT_ACQUIRE_COMPARE_KEY_FLAG | CRYPT_ACQUIRE_CACHE_FLAG,
										NULL,
										&(pRAInfo->hRAProv),
										&(pRAInfo->dwKeySpec),
										&(pRAInfo->fFree)))
		goto TraceErr;

    if(!CertGetEnhancedKeyUsage(pRAInfo->pRACert,
                                  CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                  NULL,
                                  &dwSize))
		goto InvalidArgErr;
	

    if(NULL==(pKeyUsage=(CERT_ENHKEY_USAGE *)malloc(dwSize)))
		goto MemoryErr;

    if (!CertGetEnhancedKeyUsage(pRAInfo->pRACert,
                                 CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                 pKeyUsage,
                                 &dwSize))
		goto InvalidArgErr;

	for(dwIndex=0; dwIndex < pKeyUsage->cUsageIdentifier; dwIndex++)
	{
		if(0 == strcmp(pKeyUsage->rgpszUsageIdentifier[dwIndex], szOID_ENROLLMENT_AGENT))
		{
			fResult=TRUE;
			break;
		}

	}

	if(!fResult)
		goto ErrorReturn;	

 
CommonReturn:

	if(hCEPStore)
		CertCloseStore(hCEPStore, 0);

	if(hSignStore)
		CertCloseStore(hSignStore, 0);

	if(pKeyUsage)
		free(pKeyUsage);

	//if hToken is valid, we reverted to ourselves.
	if(hToken)
	{
		SetThreadToken(&hThread, hToken);
		CloseHandle(hToken); 
	}

	return fResult;

ErrorReturn:

	FreeRAInformation(pRAInfo);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}	 */

//--------------------------------------------------------------------------
//
//	SigningCert
//
//--------------------------------------------------------------------------
BOOL WINAPI SigningCert(PCCERT_CONTEXT pCertContext)
{
	BOOL				fSign=FALSE;
	PCERT_EXTENSION		pExt=NULL;
	DWORD				cbSize=0;

	CRYPT_BIT_BLOB		*pKeyUsage=NULL;

	if(!pCertContext)
		goto CLEANUP;


	if(!(pExt=CertFindExtension(
				szOID_KEY_USAGE,
				pCertContext->pCertInfo->cExtension,
				pCertContext->pCertInfo->rgExtension)))
		goto CLEANUP;

	if(!CryptDecodeObject(ENCODE_TYPE,
						X509_KEY_USAGE,
						pExt->Value.pbData,
						pExt->Value.cbData,
						0,
						NULL,
						&cbSize))
		goto CLEANUP;

	pKeyUsage=(CRYPT_BIT_BLOB *)malloc(cbSize);
	if(NULL==pKeyUsage)
		goto CLEANUP;

	if(!CryptDecodeObject(ENCODE_TYPE,
						X509_KEY_USAGE,
						pExt->Value.pbData,
						pExt->Value.cbData,
						0,
						pKeyUsage,
						&cbSize))
		goto CLEANUP;


	 if(CERT_DIGITAL_SIGNATURE_KEY_USAGE & (pKeyUsage->pbData[0]))
		 fSign=TRUE;

CLEANUP:

	if(pKeyUsage)
		free(pKeyUsage);

	return fSign;
}

//--------------------------------------------------------------------------
//
//	GetConfigInfo
//
//--------------------------------------------------------------------------
BOOL WINAPI GetConfigInfo(DWORD *pdwRefreshDays, BOOL *pfPassword)
{
	DWORD				cbData=0;
	DWORD				dwData=0;
	DWORD				dwType=0;
	BOOL				fResult=FALSE;
	long				dwErr=0;

    HKEY                hKeyRefresh=NULL;
    HKEY                hKeyPassword=NULL;	 

	if(!pdwRefreshDays || !pfPassword)
		goto InvalidArgErr;

	//default the refresh days
	*pdwRefreshDays=CEP_REFRESH_DAY;	
	*pfPassword=FALSE;

    if(ERROR_SUCCESS == RegOpenKeyExU(
					HKEY_LOCAL_MACHINE,
                    MSCEP_REFRESH_LOCATION,
                    0,
                    KEY_READ,
                    &hKeyRefresh))
    {
        cbData=sizeof(dwData);

        if(ERROR_SUCCESS == RegQueryValueExU(
                        hKeyRefresh,
                        MSCEP_KEY_REFRESH,
                        NULL,
                        &dwType,
                        (BYTE *)&dwData,
                        &cbData))
		{
			if ((dwType == REG_DWORD) ||
                (dwType == REG_BINARY))
			{
				*pdwRefreshDays=dwData;	
			}
		}
	}

	dwType=0;
	dwData=0;
	cbData=sizeof(dwData);
	
	//we have to have the knowledge of the password policy
	if(ERROR_SUCCESS != (dwErr =  RegOpenKeyExU(
					HKEY_LOCAL_MACHINE,
                    MSCEP_PASSWORD_LOCATION,
                    0,
                    KEY_READ,
                    &hKeyPassword)))
		goto RegErr;

    if(ERROR_SUCCESS != (dwErr = RegQueryValueExU(
                    hKeyPassword,
                    MSCEP_KEY_PASSWORD,
                    NULL,
                    &dwType,
                    (BYTE *)&dwData,
                    &cbData)))
		goto RegErr;

	if ((dwType != REG_DWORD) &&
        (dwType != REG_BINARY))
		goto RegErr;

	if(0 == dwData)
		*pfPassword=FALSE;
	else
		*pfPassword=TRUE;

	fResult=TRUE;

 
CommonReturn:

    if(hKeyRefresh)
        RegCloseKey(hKeyRefresh);

    if(hKeyPassword)
        RegCloseKey(hKeyPassword);

	return fResult;

ErrorReturn:

	if(pdwRefreshDays)
		*pdwRefreshDays=0;

	if(pfPassword)
		*pfPassword=FALSE;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(RegErr, dwErr);
}
//--------------------------------------------------------------------------
//
//	GetRAInfo
//
//	We need to have two RA cert: One for signature cert (also the enrollment
//	agent) and one for the key encipherment.
//--------------------------------------------------------------------------
BOOL	GetRAInfo(CEP_RA_INFO	*pRAInfo)
{
	BOOL				fResult = FALSE; 
	BOOL				fFound = FALSE;
	DWORD				dwSize=0;
	DWORD				dwIndex=0;
	HANDLE				hThread=NULL;	//no need to close
	PCCERT_CONTEXT		pPreCert=NULL;

	HCERTSTORE			hCEPStore=NULL;
    CERT_ENHKEY_USAGE   *pKeyUsage = NULL;
	PCCERT_CONTEXT		pCurCert=NULL;
	HANDLE				hToken=NULL;
   
	memset(pRAInfo, 0, sizeof(CEP_RA_INFO)); 

	if(!GetConfigInfo(&(pRAInfo->dwRefreshDays), &(pRAInfo->fPassword)))
		goto TraceErr;

    // so we can get access to the local machine's private key
	hThread=GetCurrentThread();
	
	if(NULL != hThread)
	{
		if(OpenThreadToken(hThread,
							TOKEN_IMPERSONATE | TOKEN_QUERY,
							FALSE,
							&hToken))
		{
			if(hToken)
			{
				//no need to check for return here.  If this failed, just go on
				RevertToSelf();
			}
		}
	}


	if(!(hCEPStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							ENCODE_TYPE,
							NULL,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
                            CEP_STORE_NAME)))
		goto TraceErr;


	while(pCurCert=CertEnumCertificatesInStore(hCEPStore,
											pPreCert))
	{

		//has to have a private key
		dwSize=0;

		if(!CertGetCertificateContextProperty(
					pCurCert,
					CERT_KEY_PROV_INFO_PROP_ID,
					NULL,
					&dwSize) || (0==dwSize))
			goto InvalidArgErr;


		//decide based on the key usage
		if(SigningCert(pCurCert))
		{
			//one signing RA Only
			if(pRAInfo->pRASign)
				goto InvalidArgErr;
			
			if(!(pRAInfo->pRASign=CertDuplicateCertificateContext(pCurCert)))
				goto TraceErr;

			if(!CryptAcquireCertificatePrivateKey(pRAInfo->pRASign,
												CRYPT_ACQUIRE_COMPARE_KEY_FLAG | CRYPT_ACQUIRE_CACHE_FLAG,
												NULL,
												&(pRAInfo->hSignProv),
												&(pRAInfo->dwSignKeySpec),
												&(pRAInfo->fSignFree)))
				goto TraceErr;

			//has to have the enrollment agent eku
			dwSize=0;

			if(!CertGetEnhancedKeyUsage(pCurCert,
										  CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
										  NULL,
										  &dwSize))
				goto InvalidArgErr;
		

			if(NULL==(pKeyUsage=(CERT_ENHKEY_USAGE *)malloc(dwSize)))
				goto MemoryErr;

			if (!CertGetEnhancedKeyUsage(pCurCert,
										 CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
										 pKeyUsage,
										 &dwSize))
				goto InvalidArgErr;

			fFound=FALSE;

			for(dwIndex=0; dwIndex < pKeyUsage->cUsageIdentifier; dwIndex++)
			{
				if(0 == strcmp(pKeyUsage->rgpszUsageIdentifier[dwIndex], szOID_ENROLLMENT_AGENT))
				{
					fFound=TRUE;
					break;
				}

			}

			if(!fFound)
				goto InvalidArgErr;	
		}
		else
		{
			//one encryption RA only
			if(pRAInfo->pRACert)
				goto InvalidArgErr;

 			if(!(pRAInfo->pRACert=CertDuplicateCertificateContext(pCurCert)))
				goto TraceErr;

			if(!CryptAcquireCertificatePrivateKey(pRAInfo->pRACert,
												CRYPT_ACQUIRE_COMPARE_KEY_FLAG | CRYPT_ACQUIRE_CACHE_FLAG,
												NULL,
												&(pRAInfo->hRAProv),
												&(pRAInfo->dwKeySpec),
												&(pRAInfo->fFree)))
				goto TraceErr;

		}



		if(pKeyUsage)
		{		
			free(pKeyUsage);
			pKeyUsage=NULL;
		}

		pPreCert=pCurCert;
	}
											

	//we have to have both RA certs
	if((NULL == pRAInfo->pRACert) ||
	   (NULL == pRAInfo->pRASign))
	   goto InvalidArgErr;


	fResult=TRUE;

 
CommonReturn:

	if(hCEPStore)
		CertCloseStore(hCEPStore, 0);

	if(pKeyUsage)
		free(pKeyUsage);

	//if hToken is valid, we reverted to ourselves.
	if(hToken)
	{
		SetThreadToken(&hThread, hToken);
		CloseHandle(hToken); 
	}

	if(pCurCert)
		CertFreeCertificateContext(pCurCert);

	return fResult;

ErrorReturn:

	FreeRAInformation(pRAInfo);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}


//--------------------------------------------------------------------------
//
//	OperationGetPKI
//
//--------------------------------------------------------------------------
BOOL	OperationGetPKI(	CEP_RA_INFO		*pRAInfo,
							CEP_CA_INFO		*pCAInfo,
							LPSTR			szMsg, 
							BYTE			**ppbData, 
							DWORD			*pcbData)
{
	BOOL				fResult = FALSE;
	CEP_MESSAGE_INFO	MsgInfo;
	DWORD				cbContent=0;
	DWORD				cbEnvelop=1;
	BYTE				bFoo=0;

	BYTE				*pbContent=NULL;
	BYTE				*pbEnvelop=&bFoo;


	memset(&MsgInfo, 0, sizeof(CEP_MESSAGE_INFO));

	if(!GetReturnInfoAndContent(pRAInfo, pCAInfo, szMsg, &pbContent, &cbContent, &MsgInfo))
		goto TraceErr;

	//envelop the data
	if(MESSAGE_STATUS_SUCCESS == MsgInfo.dwStatus)
	{
		if(!EnvelopData(MsgInfo.pSigningCert, pbContent, cbContent,
						&pbEnvelop, &cbEnvelop))
		{
			LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_TO_ENCRYPT, 1, g_pwszComputerName);
			goto TraceErr;
		}
	}

	//sign the data with authenticated attributes 
	//when the dwStatus is not SUCCESS, the pbEnvelop is NULL and cbEnvelop is 0.

 	if(!SignData(&MsgInfo, pRAInfo, pbEnvelop, cbEnvelop, ppbData, pcbData))
	{
		LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_TO_SIGN, 1, g_pwszComputerName);
		goto TraceErr;
	}

	fResult = TRUE;

CommonReturn:

	if(pbContent)
		free(pbContent);

    	if(&bFoo != pbEnvelop)
		free(pbEnvelop);
	
	FreeMessageInfo(&MsgInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
}

//--------------------------------------------------------------------------
//
//	SignData
//
//  the messageType is always response and the senderNonce should be generated
//	in case the pending and failure, pbEnvelop will be NULL.
//
//	In the initial GetContentFromPKCS7, we retrive MessageType, TransactionID,
//	RecipientNonce, signing Cert serial number.
//
//	In the process, we get the dwStatus and dwErrorInfo when applicable.  
////--------------------------------------------------------------------------
BOOL SignData(CEP_MESSAGE_INFO		*pMsgInfo, 
			  CEP_RA_INFO			*pRAInfo, 
			  BYTE					*pbEnvelop, 
			  DWORD					cbEnvelop, 
			  BYTE					**ppbData, 
			  DWORD					*pcbData)
{
	BOOL						fResult = FALSE;
	CMSG_SIGNER_ENCODE_INFO		SignerInfo;
	CMSG_SIGNED_ENCODE_INFO		SignEncodedInfo;
	CERT_BLOB					CertBlob;
	BOOL						fProvFree=FALSE;
    PCCRYPT_OID_INFO            pOIDInfo=NULL;
	ALG_ID						AlgValue=CALG_MD5;
	DWORD						cAttr=0;
	CRYPT_ATTR_BLOB				rgAttrBlob[CEP_RESPONSE_AUTH_ATTR_COUNT];
	DWORD						dwIndex=0;

	HCRYPTMSG					hMsg=NULL;
 	CRYPT_ATTRIBUTE				rgAttr[CEP_RESPONSE_AUTH_ATTR_COUNT];

	if(!pMsgInfo || !pRAInfo || !ppbData || !pcbData)
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	pMsgInfo->dwMessageType=MESSAGE_TYPE_CERT_RESPONSE;

	if(!GenerateSenderNonce(&(pMsgInfo->SenderNonce)))
		goto TraceErr;

	memset(&SignerInfo, 0, sizeof(SignerInfo));
	memset(&SignEncodedInfo, 0, sizeof(SignEncodedInfo)); 

	SignEncodedInfo.cbSize=sizeof(SignEncodedInfo);
	SignEncodedInfo.cSigners=1;
	SignEncodedInfo.rgSigners=&SignerInfo,
/*	SignEncodedInfo.cCertEncoded=1;		   
	SignEncodedInfo.rgCertEncoded=&CertBlob; */
	SignEncodedInfo.cCertEncoded=0;
	SignEncodedInfo.rgCertEncoded=NULL; 
	SignEncodedInfo.cCrlEncoded=0;
	SignEncodedInfo.rgCrlEncoded=NULL;

	CertBlob.cbData=pRAInfo->pRASign->cbCertEncoded;
	CertBlob.pbData=pRAInfo->pRASign->pbCertEncoded;

	SignerInfo.cbSize=sizeof(SignerInfo);
	SignerInfo.pCertInfo=pRAInfo->pRASign->pCertInfo;

	//specify AlgID
	if(pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_ALGID_KEY,
                            &AlgValue,
                            CRYPT_HASH_ALG_OID_GROUP_ID))
		SignerInfo.HashAlgorithm.pszObjId=(LPSTR)(pOIDInfo->pszOID);
	else
		SignerInfo.HashAlgorithm.pszObjId=szOID_RSA_MD5;


	//get the private key
	SignerInfo.hCryptProv=pRAInfo->hSignProv;
	SignerInfo.dwKeySpec=pRAInfo->dwSignKeySpec;


	//get the autheticated attributes
	//together we should have 6 attributes: TransactionID, MessageType, PkiStatus,
	//ErrorInfo, senderNonce, and recipientNonce
	memset(rgAttr, 0, CEP_RESPONSE_AUTH_ATTR_COUNT * sizeof(CRYPT_ATTRIBUTE));
	memset(rgAttrBlob, 0, CEP_RESPONSE_AUTH_ATTR_COUNT * sizeof(CRYPT_ATTR_BLOB));


	for(dwIndex=0; dwIndex<CEP_RESPONSE_AUTH_ATTR_COUNT; dwIndex++)
	{
		rgAttr[dwIndex].cValue=1;
		rgAttr[dwIndex].rgValue=&(rgAttrBlob[dwIndex]);
	}

	cAttr=0;	
			
	//TransactionID
	rgAttr[cAttr].pszObjId=szOIDVerisign_TransactionID;

	//transactionID internally are stored as a string
	pMsgInfo->TransactionID.cbData=strlen((LPSTR)(pMsgInfo->TransactionID.pbData));

	if(!CEPAllocAndEncodeName(CERT_RDN_PRINTABLE_STRING,
							pMsgInfo->TransactionID.pbData,
							pMsgInfo->TransactionID.cbData,
							&(rgAttr[cAttr].rgValue[0].pbData),
							&(rgAttr[cAttr].rgValue[0].cbData)))
		goto TraceErr;
								
	cAttr++;

	//MessageType
	rgAttr[cAttr].pszObjId=szOIDVerisign_MessageType;

	if(!CEPAllocAndEncodeDword(CERT_RDN_PRINTABLE_STRING,
							pMsgInfo->dwMessageType,
							&(rgAttr[cAttr].rgValue[0].pbData),
							&(rgAttr[cAttr].rgValue[0].cbData)))
		goto TraceErr;

	cAttr++;

	//Status
	rgAttr[cAttr].pszObjId=szOIDVerisign_PkiStatus;

	if(!CEPAllocAndEncodeDword(CERT_RDN_PRINTABLE_STRING,
							pMsgInfo->dwStatus,
							&(rgAttr[cAttr].rgValue[0].pbData),
							&(rgAttr[cAttr].rgValue[0].cbData)))
		goto TraceErr;

	cAttr++;

	//ErrorInfo	only if the error case
	if(MESSAGE_STATUS_FAILURE == pMsgInfo->dwStatus)
	{
		rgAttr[cAttr].pszObjId=szOIDVerisign_FailInfo;

		if(!CEPAllocAndEncodeDword(CERT_RDN_PRINTABLE_STRING,
								pMsgInfo->dwErrorInfo,
								&(rgAttr[cAttr].rgValue[0].pbData),
								&(rgAttr[cAttr].rgValue[0].cbData)))
			goto TraceErr;

		cAttr++;
	}

	//senderNonce
	rgAttr[cAttr].pszObjId=szOIDVerisign_SenderNonce;

	if(!CEPAllocAndEncodeName(CERT_RDN_OCTET_STRING,
							pMsgInfo->SenderNonce.pbData,
							pMsgInfo->SenderNonce.cbData,
							&(rgAttr[cAttr].rgValue[0].pbData),
							&(rgAttr[cAttr].rgValue[0].cbData)))
		goto TraceErr;

	cAttr++;

	//recipientNonce
	rgAttr[cAttr].pszObjId=szOIDVerisign_RecipientNonce;

	if(!CEPAllocAndEncodeName(CERT_RDN_OCTET_STRING,
							pMsgInfo->RecipientNonce.pbData,
							pMsgInfo->RecipientNonce.cbData,
							&(rgAttr[cAttr].rgValue[0].pbData),
							&(rgAttr[cAttr].rgValue[0].cbData)))
		goto TraceErr;	

	cAttr++;

	SignerInfo.cAuthAttr=cAttr;
	SignerInfo.rgAuthAttr=rgAttr;

	//message encoding
	if(NULL==(hMsg=CryptMsgOpenToEncode(ENCODE_TYPE,
								0,
								CMSG_SIGNED,
								&SignEncodedInfo,
								NULL,	//we are encoding as CMSG_DATA(7.1)
								NULL)))
		goto TraceErr;

	if(!CryptMsgUpdate(hMsg,
						pbEnvelop,
						cbEnvelop,
						TRUE))
		goto TraceErr;


	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						NULL,
						pcbData))
		goto TraceErr;

	*ppbData=(BYTE *)malloc(*pcbData);
	if(NULL==(*ppbData))
		goto MemoryErr;

	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						*ppbData,
						pcbData))
		goto TraceErr;


	fResult = TRUE;

CommonReturn:
	
	for(dwIndex=0; dwIndex < cAttr; dwIndex ++)
	{
		if(rgAttrBlob[dwIndex].pbData)
			free(rgAttrBlob[dwIndex].pbData);
	}

	if(hMsg)
		CryptMsgClose(hMsg);


	return fResult;

ErrorReturn:

	if(ppbData)
	{
		if(*ppbData)
		{
			free(*ppbData);
			*ppbData=NULL;
		}
	}

	if(pcbData)
		*pcbData=0;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	CEPAllocAndEncodeDword
//
//	PreCondition: ppbEncoded and pcbEncoded should not be NULL.
//				The dwData is no more than 11
//--------------------------------------------------------------------------
BOOL	CEPAllocAndEncodeDword(DWORD	dwValueType,
							DWORD	dwData,
							BYTE	**ppbEncoded,
							DWORD	*pcbEncoded)
{
	BOOL				fResult = FALSE;
	CHAR				szString[12];
	BYTE				*pbData=NULL;
	DWORD				cbData=0;

	_ltoa(dwData, szString, 10);

	pbData=(BYTE *)szString;
	cbData=strlen(szString);

	return CEPAllocAndEncodeName(dwValueType, pbData, cbData, ppbEncoded, pcbEncoded);
}


//--------------------------------------------------------------------------
//
//	CEPAllocAndEncodeName
//
//	PreCondition: ppbEncoded and pcbEncoded should not be NULL.
//--------------------------------------------------------------------------
BOOL	CEPAllocAndEncodeName(DWORD	dwValueType,
							BYTE	*pbData,
							DWORD	cbData,
							BYTE	**ppbEncoded,
							DWORD	*pcbEncoded)
{
	CERT_NAME_VALUE		CertName;

	*ppbEncoded=NULL;
	*pcbEncoded=0;

	CertName.dwValueType=dwValueType;
	CertName.Value.pbData=pbData;
	CertName.Value.cbData=cbData;

	return CEPAllocAndEncode(X509_ANY_STRING,
							&CertName,
							ppbEncoded,
							pcbEncoded);

}


//--------------------------------------------------------------------------
//
//	GenerateSenderNonce
//
//	We use GUID to generate a random 16 byte number
//
//--------------------------------------------------------------------------
BOOL GenerateSenderNonce(CRYPT_INTEGER_BLOB *pBlob)
{
	BOOL			fResult = FALSE;
	GUID			guid;
	BYTE			*pData=NULL;

	UuidCreate(&guid);

	pBlob->cbData=sizeof(guid.Data1) + sizeof(guid.Data2) +
					sizeof(guid.Data3) + sizeof(guid.Data4);

	pBlob->pbData=(BYTE *)malloc(pBlob->cbData);
	if(NULL==(pBlob->pbData))
		goto MemoryErr;

	pData=pBlob->pbData;

	memcpy(pData, &(guid.Data1), sizeof(guid.Data1));
	pData += sizeof(guid.Data1);

	memcpy(pData, &(guid.Data2), sizeof(guid.Data2));
	pData += sizeof(guid.Data2);

	memcpy(pData, &(guid.Data3), sizeof(guid.Data3));
	pData += sizeof(guid.Data3);

	memcpy(pData, &(guid.Data4), sizeof(guid.Data4));

	fResult = TRUE;

CommonReturn:	 

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	EnvelopData
//
//	In the initial GetContentFromPKCS7, we retrieve pSigningCert for 
//	GetCertInitial, CertReq, and GetCert request.
//
//	In the process,we retrieve pSigningCert for GetCRL request.
//--------------------------------------------------------------------------
BOOL EnvelopData(PCCERT_CONTEXT	pSigningCert, 
				 BYTE			*pbContent, 
				 DWORD			cbContent,
				 BYTE			**ppbEnvelop, 
				 DWORD			*pcbEnvelop)
{
	BOOL						fResult = FALSE;
	CMSG_ENVELOPED_ENCODE_INFO	EnvInfo;

	HCRYPTMSG					hMsg=NULL;

	if(!pSigningCert || !pbContent || !ppbEnvelop || !pcbEnvelop)
		goto InvalidArgErr;

	*ppbEnvelop=NULL;
	*pcbEnvelop=0;

	memset(&EnvInfo, 0, sizeof(CMSG_ENVELOPED_ENCODE_INFO));

	EnvInfo.cbSize=sizeof(CMSG_ENVELOPED_ENCODE_INFO);
    EnvInfo.hCryptProv=NULL;
    EnvInfo.ContentEncryptionAlgorithm.pszObjId=szOID_OIWSEC_desCBC;
    EnvInfo.pvEncryptionAuxInfo=NULL;
    EnvInfo.cRecipients=1;
    EnvInfo.rgpRecipients=(PCERT_INFO *)(&(pSigningCert->pCertInfo));


	if(NULL==(hMsg=CryptMsgOpenToEncode(ENCODE_TYPE,
								0,
								CMSG_ENVELOPED,
								&EnvInfo,
								NULL,	//we are encoding as CMSG_DATA(7.1)
								NULL)))
		goto TraceErr;

	if(!CryptMsgUpdate(hMsg,
						pbContent,
						cbContent,
						TRUE))
		goto TraceErr;


	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						NULL,
						pcbEnvelop))
		goto TraceErr;

	*ppbEnvelop=(BYTE *)malloc(*pcbEnvelop);
	if(NULL==(*ppbEnvelop))
		goto MemoryErr;

	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						*ppbEnvelop,
						pcbEnvelop))
		goto TraceErr;
	
	fResult = TRUE;

CommonReturn:

	if(hMsg)
		CryptMsgClose(hMsg);

	return fResult;

ErrorReturn:

	if(ppbEnvelop)
	{
		if(*ppbEnvelop)
		{
			free(*ppbEnvelop);
			*ppbEnvelop=NULL;
		}
	}

	if(pcbEnvelop)
		*pcbEnvelop=0;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	DecodeCertW
//
//--------------------------------------------------------------------------
HRESULT
DecodeCertW(
    IN void const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    BYTE *pbOut = NULL;
    DWORD cbOut;
    BOOL fRet;

    //init
    *ppbOut = NULL;
    *pcbOut = 0;

    while (TRUE)
    {
        fRet = CryptStringToBinaryW((LPCWSTR)pchIn, cchIn, Flags, pbOut, &cbOut, NULL, NULL);

        if (!fRet)
        {
            hr = GetLastError();
            goto error;
        }
        if (NULL != pbOut)
        {
            break; //done
        }
        pbOut = (BYTE*)LocalAlloc(LMEM_FIXED, cbOut);
        if (NULL == pbOut)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }
    *ppbOut = pbOut;
    pbOut = NULL;
    *pcbOut = cbOut;

    hr = S_OK;
error:
    if (NULL != pbOut)
    {
        LocalFree(pbOut);
    }
    return hr;
}


//--------------------------------------------------------------------------
//
//	GetReturnInfoAndContent
//
//--------------------------------------------------------------------------
BOOL	GetReturnInfoAndContent(CEP_RA_INFO		*pRAInfo,	
							CEP_CA_INFO			*pCAInfo,
							LPSTR				szMsg, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo)
{

	BOOL				fResult = FALSE;
	DWORD				cbBase64Decoded=0;
	DWORD				cbReqEnv=0;
	DWORD				cbReqDecrypt=0;
	DWORD				cbSize=0;
	HRESULT				hr=E_FAIL;
	
	BYTE				*pbBase64Decoded=NULL;
	BYTE				*pbReqEnv=NULL;
	BYTE				*pbReqDecrypt=NULL;
	WCHAR				wszBuffer[INTERNET_MAX_PATH_LENGTH * 2 +1];
	LPWSTR				pwszMsg=NULL;
	LPWSTR				pwszBuffer=NULL;

	//convert sz to wsz
	pwszMsg=MkWStr(szMsg);

	if(NULL==pwszMsg)
		goto MemoryErr;

	//we need to get rid of the escape characters
	if(S_OK != (hr=CoInternetParseUrl(pwszMsg,
				PARSE_UNESCAPE,
				0,
				wszBuffer,
				INTERNET_MAX_PATH_LENGTH*2,
				&cbSize,
				0)))
	{
		//S_FALSE means that the buffer is too small
		if(S_FALSE != hr)
		{
			LogSCEPEvent(0, TRUE, hr, EVENT_MSCEP_FAIL_TO_CONVERT, 1, g_pwszComputerName);
			goto TraceErr;
		}

		if(0==cbSize)
		{
			LogSCEPEvent(0, TRUE, hr, EVENT_MSCEP_FAIL_TO_CONVERT, 1, g_pwszComputerName);
			goto TraceErr;
		}

		//allocate the buffer
		pwszBuffer=(LPWSTR)malloc(cbSize * sizeof(WCHAR));
		if(NULL==pwszBuffer)
			goto MemoryErr;

		*pwszBuffer=L'\0';

		if(S_OK != (hr = CoInternetParseUrl(pwszMsg,
					PARSE_UNESCAPE,
					0,
					pwszBuffer,
					cbSize,
					&cbSize,
					0)))
		{
			LogSCEPEvent(0, TRUE, hr, EVENT_MSCEP_FAIL_TO_CONVERT, 1, g_pwszComputerName);
			goto TraceErr;
		}
	}
	
    if(S_OK != (hr = DecodeCertW(
        pwszBuffer ? pwszBuffer : wszBuffer,
        pwszBuffer ? wcslen(pwszBuffer) : wcslen(wszBuffer),
        CRYPT_STRING_BASE64_ANY, //DECF_BASE64_ANY,
        &pbBase64Decoded,
        &cbBase64Decoded)))
	{
		LogSCEPEvent(0, TRUE, hr, EVENT_MSCEP_FAIL_TO_DECODE, 1, g_pwszComputerName);
		goto FailureStatusReturn;
	}

	//get the message type, transaction ID, recepientNonce, serial number in the 
	//signer_info of the most outer PKCS#7 and inner content
	if(!GetContentFromPKCS7(pbBase64Decoded,
							cbBase64Decoded,
							&pbReqEnv,
							&cbReqEnv,
							pMsgInfo))
	{
		LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_TO_RETRIEVE_INFO, 1, g_pwszComputerName);
		goto FailureStatusReturn;
	}

	//decrypt the inner content
	if(!DecryptMsg(pRAInfo, pbReqEnv, cbReqEnv, &pbReqDecrypt, &cbReqDecrypt))
	{
		LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_TO_DECRYPT_INNER, 1, g_pwszComputerName);
		goto FailureStatusReturn;
	}

	//get the return inner content based on the message type
	switch(pMsgInfo->dwMessageType)
	{

		case	MESSAGE_TYPE_CERT_REQUEST:
				//we use the signing RA cert as the enrollment agent
				if(!ProcessCertRequest( pRAInfo->dwRefreshDays,
										pRAInfo->fPassword, 
									    pRAInfo->pRACert,
										pRAInfo->pRASign, 
										pCAInfo, 
										pbReqDecrypt,
										cbReqDecrypt, 
										ppbData, 
										pcbData,
										pMsgInfo))
				{
					LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_CERT_REQ, 1, g_pwszComputerName);
					goto TraceErr;
				}

			break;
		case	MESSAGE_TYPE_GET_CERT_INITIAL:
				if(!ProcessCertInitial(pRAInfo->dwRefreshDays, pCAInfo, pbReqDecrypt,
										cbReqDecrypt, ppbData, pcbData,
										pMsgInfo))
				{
					LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_GET_CERT_INITIAL, 1, g_pwszComputerName);
					goto TraceErr;
				}

			break;
		case	MESSAGE_TYPE_GET_CERT:
				if(!ProcessGetCert(pCAInfo, pbReqDecrypt,
									cbReqDecrypt, ppbData, pcbData,
									pMsgInfo))
				{					
					LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_GET_CERT, 1, g_pwszComputerName);
					goto TraceErr;
				}
			
			break;
		case	MESSAGE_TYPE_GET_CRL:
				if(!ProcessGetCRL(pCAInfo, pbReqDecrypt,
									cbReqDecrypt, ppbData, pcbData,
									pMsgInfo))
				{
					LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_GET_CRL, 1, g_pwszComputerName);
					goto TraceErr;
				}

			break;
		default:
				LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_BAD_MESSAGE_TYPE, 1, g_pwszComputerName);
				goto InvalidArgErr;
			break;
	}



	fResult = TRUE;

CommonReturn:

	if(pwszBuffer)
		free(pwszBuffer);

	if(pwszMsg)
		FreeWStr(pwszMsg);

	//memory from certcli.dll.  Has to be freed by LocalFree()
	if(pbBase64Decoded)
		LocalFree(pbBase64Decoded);

	if(pbReqEnv)
		free(pbReqEnv);

	if(pbReqDecrypt)
		free(pbReqDecrypt);

	return fResult;

FailureStatusReturn:

	//we set the error status for the return message
	//and consider this http transation a success
	pMsgInfo->dwStatus=MESSAGE_STATUS_FAILURE;
	pMsgInfo->dwErrorInfo=MESSAGE_FAILURE_BAD_MESSAGE_CHECK;
	
	*ppbData=NULL;
	*pcbData=0;

	fResult=TRUE;
	goto CommonReturn; 


ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	RetrieveContextFromSerialNumber
//
//
//--------------------------------------------------------------------------
BOOL WINAPI RetrieveContextFromSerialNumber(CEP_CA_INFO	*pCAInfo, 
										CERT_BLOB		*pSerialNumber, 
										PCCERT_CONTEXT	*ppCertContext)
{
	BOOL		fResult = FALSE;
	DWORD		cb=0;
	long		dwDisposition=0;
	HRESULT		hr=E_FAIL;
	DWORD		cbCert=0;
	BYTE		*pbCert=NULL;

	LPWSTR		pwsz=NULL;
	BSTR		bstrCert=NULL;
	LPWSTR		pwszNewConfig=NULL;
	BSTR		bstrNewConfig=NULL;

	if(S_OK != (hr=MultiByteIntegerToWszBuf(
			FALSE,
			pSerialNumber->cbData,
			pSerialNumber->pbData,
			&cb,
			NULL)))
		goto SetHrErr;

	pwsz=(LPWSTR)malloc(cb);
	if(NULL==pwsz)
		goto MemoryErr;

	if(S_OK != (hr=MultiByteIntegerToWszBuf(
			FALSE,
			pSerialNumber->cbData,
			pSerialNumber->pbData,
			&cb,
			pwsz)))
		goto SetHrErr;

	//contatenate the serialNumber with the config string
	pwszNewConfig=(LPWSTR)malloc(sizeof(WCHAR) * 
				(wcslen(pCAInfo->bstrCAConfig)+wcslen(pwsz)+wcslen(L"\\")+1));
	if(NULL==pwszNewConfig)
		goto MemoryErr;

	//the config string to retrieve the cert based on the 
	//serialNumber is configString\SerialNumber
	//
	wcscpy(pwszNewConfig, pCAInfo->bstrCAConfig);
	wcscat(pwszNewConfig, L"\\");
	wcscat(pwszNewConfig, pwsz);

	bstrNewConfig=SysAllocString(pwszNewConfig);

	if(NULL==bstrNewConfig)
		goto MemoryErr;
	
	if(S_OK != (hr=pCAInfo->pICertRequest->RetrievePending(0,
													bstrNewConfig,
													&dwDisposition)))
		goto SetHrErr;

	if(S_OK != (hr= pCAInfo->pICertRequest->GetCertificate(CR_OUT_BINARY,
									&bstrCert)))
		goto SetHrErr;

	cbCert = (DWORD)SysStringByteLen(bstrCert);
	pbCert = (BYTE *)bstrCert;

	if(!(*ppCertContext=CertCreateCertificateContext(ENCODE_TYPE,
												pbCert,
												cbCert)))
		goto TraceErr;


	fResult = TRUE;

CommonReturn:

	if(pwsz)
		free(pwsz);

	if(bstrCert)
		SysFreeString(bstrCert);

	if(pwszNewConfig)
		free(pwszNewConfig);

	if(bstrNewConfig)
		SysFreeString(bstrNewConfig);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR_VAR(SetHrErr, hr);
TRACE_ERROR(TraceErr);
}
//--------------------------------------------------------------------------
//
//	ProcessGetCRL
//
//
//--------------------------------------------------------------------------
BOOL WINAPI ProcessGetCRL(CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo)
{
	BOOL					fResult = FALSE;
	DWORD					dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
	DWORD					cbUrlArray=0;
	DWORD					dwIndex=0;

	PCCERT_CONTEXT			pCertContext=NULL;
	PCCRL_CONTEXT			pCRLContext=NULL;
	PCRYPT_URL_ARRAY		pUrlArray = NULL;


	if(!pCAInfo || !ppbData || !pcbData || !pMsgInfo)
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	//retrieve the cert context from the serialNumber
	//protected by the critical Section since it uses ICertRequest interface

	if(!RetrieveContextFromSerialNumber(pCAInfo, &(pMsgInfo->SerialNumber), &pCertContext))
	{
		LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_TO_GET_CERT_FROM_NUMBER, 1, g_pwszComputerName);
		goto FailureStatusReturn;
	}


	if(!CryptGetObjectUrl(
			URL_OID_CERTIFICATE_CRL_DIST_POINT,
			(LPVOID)pCertContext,
			CRYPT_GET_URL_FROM_EXTENSION,
			NULL,
			&cbUrlArray,
			NULL,
			NULL,
			NULL))
		goto FailureStatusReturn;

	pUrlArray=(PCRYPT_URL_ARRAY)malloc(cbUrlArray);
	if(NULL == pUrlArray)
		goto FailureStatusReturn;

	if(!CryptGetObjectUrl(
			URL_OID_CERTIFICATE_CRL_DIST_POINT,
			(LPVOID)pCertContext,
			CRYPT_GET_URL_FROM_EXTENSION,
			pUrlArray,
			&cbUrlArray,
			NULL,
			NULL,
			NULL))
		goto FailureStatusReturn;
	
	for(dwIndex=0; dwIndex < pUrlArray->cUrl; dwIndex++)
	{

		if(CryptRetrieveObjectByUrlW (
			pUrlArray->rgwszUrl[dwIndex],
			CONTEXT_OID_CRL,
			CRYPT_WIRE_ONLY_RETRIEVAL,	//we should try to hit the wire
			0,
			(LPVOID *)&pCRLContext,
			NULL,
			NULL,
			NULL,
			NULL))
				break;
	}

	if(NULL==pCRLContext)
		goto FailureStatusReturn;


   	//package the CRL in an empty PKCS7
	if(!PackageBlobToPKCS7(CEP_CONTEXT_CRL, pCRLContext->pbCrlEncoded, 
							pCRLContext->cbCrlEncoded, ppbData, pcbData))
		goto FailureStatusReturn;

	//this is the signing cert to which our response should be encrypted
	if(NULL==(pMsgInfo->pSigningCert=CertDuplicateCertificateContext(pCertContext)))
		goto FailureStatusReturn;

	fResult = TRUE;

CommonReturn:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(pCRLContext)
		CertFreeCRLContext(pCRLContext);

	if(pUrlArray)
		free(pUrlArray);

	return fResult;

FailureStatusReturn:

	//we set the error status for the return message
	//and consider this http transation a success
	pMsgInfo->dwStatus=MESSAGE_STATUS_FAILURE;
	pMsgInfo->dwErrorInfo=dwErrorInfo;
	
	if(ppbData)
	{
		if(*ppbData)
			free(*ppbData);	

		*ppbData=NULL;
	}
	
	if(pcbData)
		*pcbData=0;

	fResult=TRUE;
	goto CommonReturn;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	ProcessGetCert
//
//
//--------------------------------------------------------------------------
BOOL WINAPI ProcessGetCert(CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo)
{
	BOOL					fResult = FALSE;
	DWORD					dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;


	CRYPT_INTEGER_BLOB		SerialNumber;
	PCCERT_CONTEXT			pCertContext=NULL;

	if(!pCAInfo || !pbRequest || !ppbData || !pcbData || !pMsgInfo)
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	memset(&SerialNumber, 0, sizeof(CRYPT_INTEGER_BLOB));

	//get the serialnumber from the request
	if(!GetSerialNumberFromBlob(pbRequest, 
								cbRequest, 
								&SerialNumber))
	{
		LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_NUMBER_FROM_MESSAGE, 1, g_pwszComputerName);
		goto FailureStatusReturn;
	}

	//retrieve the cert context from the serialNumber
	//protected by the critical Section since it uses ICertRequest interface

	if(!RetrieveContextFromSerialNumber(pCAInfo, (CERT_BLOB*)&SerialNumber, &pCertContext))
	{
		LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_TO_GET_CERT_FROM_NUMBER, 1, g_pwszComputerName);
		goto FailureStatusReturn;
	}


   	//package it in an empty PKCS7
	if(!PackageBlobToPKCS7(CEP_CONTEXT_CERT, pCertContext->pbCertEncoded, 
							pCertContext->cbCertEncoded, ppbData, pcbData))
		goto FailureStatusReturn;

	//this is the signing cert to which our response should be encrypted
/*	if(NULL==(pMsgInfo->pSigningCert=CertDuplicateCertificateContext(pCertContext)))
		goto FailureStatusReturn;  */

	fResult = TRUE;

CommonReturn:

	if(SerialNumber.pbData)
		free(SerialNumber.pbData);

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	return fResult;

FailureStatusReturn:

	//we set the error status for the return message
	//and consider this http transation a success
	pMsgInfo->dwStatus=MESSAGE_STATUS_FAILURE;
	pMsgInfo->dwErrorInfo=dwErrorInfo;
	
	if(ppbData)
	{
		if(*ppbData)
			free(*ppbData);	

		*ppbData=NULL;
	}
	
	if(pcbData)
		*pcbData=0;

	fResult=TRUE;
	goto CommonReturn;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	ProcessCertInitial
//
//
//--------------------------------------------------------------------------
BOOL	ProcessCertInitial(	DWORD		dwRefreshDays,
					CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo)
{
	BOOL	fResult = FALSE;
	DWORD	dwRequestID=0;
	DWORD	cbCert=0;
	BYTE	*pbCert=NULL;	
	DWORD	dwErrorInfo=MESSAGE_FAILURE_BAD_CERT_ID;
	long	dwDisposition=0;
	HRESULT	hr=S_OK;

	BSTR	bstrCert=NULL;



	if(!pCAInfo || !pbRequest || !ppbData || !pcbData || !pMsgInfo)
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	//map the trasactionID to the request ID
	if(!CEPHashGetRequestID(dwRefreshDays, &(pMsgInfo->TransactionID), &dwRequestID))
	{
		LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_TO_GET_ID, 1, g_pwszComputerName);
		goto FailureStatusReturn;
	}


	if(S_OK != (hr = pCAInfo->pICertRequest->RetrievePending(dwRequestID,
													pCAInfo->bstrCAConfig,
													&dwDisposition)))
	{
		LogSCEPEvent(0, TRUE, hr, EVENT_MSCEP_FAIL_QUERY_CA, 1, g_pwszComputerName);
		goto FailureStatusReturn;
	}

	switch(dwDisposition)
	{
		case CR_DISP_ISSUED:
				if(S_OK != (hr = pCAInfo->pICertRequest->GetCertificate(CR_OUT_BINARY,
												&bstrCert)))
				{
					LogSCEPEvent(0, TRUE, hr, EVENT_MSCEP_FAIL_QUERY_CERT, 1, g_pwszComputerName);
					goto FailureStatusReturn;
				}

				cbCert = (DWORD)SysStringByteLen(bstrCert);
				pbCert = (BYTE *)bstrCert;

   				//package it in an empty PKCS7
				if(!PackageBlobToPKCS7(CEP_CONTEXT_CERT, pbCert, cbCert, ppbData, pcbData))
					goto FailureStatusReturn;

				pMsgInfo->dwStatus=MESSAGE_STATUS_SUCCESS;

				//mark the finished for RequesetID/TransactionID pair
				CEPHashMarkTransactionFinished(dwRequestID, &(pMsgInfo->TransactionID));

			break;
		case CR_DISP_UNDER_SUBMISSION:
				
				pMsgInfo->dwStatus=MESSAGE_STATUS_PENDING;

			break;
		case CR_DISP_INCOMPLETE:
			                           
		case CR_DISP_ERROR:   
			                           
		case CR_DISP_DENIED:   
			                           
		case CR_DISP_ISSUED_OUT_OF_BAND:	  //we consider it a failure in this case
			                          
		case CR_DISP_REVOKED:

		default:

				//mark the finished for RequesetID/TransactionID pair
				CEPHashMarkTransactionFinished(dwRequestID, &(pMsgInfo->TransactionID));

				dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
				goto FailureStatusReturn;

			break;
	}

	fResult = TRUE;

CommonReturn:

	if(bstrCert)
		SysFreeString(bstrCert);


	return fResult;	   

FailureStatusReturn:

	//we set the error status for the return message
	//and consider this http transation a success
	pMsgInfo->dwStatus=MESSAGE_STATUS_FAILURE;
	pMsgInfo->dwErrorInfo=dwErrorInfo;
	
	*ppbData=NULL;
	*pcbData=0;

	fResult=TRUE;
	goto CommonReturn;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	PackageBlobToPKCS7
//
//	Precondition: ppbData and pcbData is guaranteed not to be NULL
//--------------------------------------------------------------------------
BOOL PackageBlobToPKCS7(DWORD	dwCEP_Context,
						BYTE	*pbEncoded, 
						DWORD	cbEncoded, 
						BYTE	**ppbData, 
						DWORD	*pcbData)
{
	BOOL		fResult=FALSE;

	CERT_BLOB	CertBlob;	
	HCERTSTORE	hCertStore=NULL;


	if((!pbEncoded) || (0==cbEncoded))
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	if(NULL == (hCertStore = CertOpenStore(
							CERT_STORE_PROV_MEMORY,
							ENCODE_TYPE,
							NULL,
							0,
							NULL)))
		goto TraceErr;

	switch(dwCEP_Context)
	{
		case CEP_CONTEXT_CERT:
			if(!CertAddEncodedCertificateToStore(hCertStore,
											ENCODE_TYPE,
											pbEncoded,
											cbEncoded,
											CERT_STORE_ADD_ALWAYS,
											NULL))
				goto TraceErr;

			break;
		case CEP_CONTEXT_CRL:
			if(!CertAddEncodedCRLToStore(hCertStore,
											ENCODE_TYPE,
											pbEncoded,
											cbEncoded,
											CERT_STORE_ADD_ALWAYS,
											NULL))
				goto TraceErr;

			break;
		default:
				goto InvalidArgErr;
			break;

	}	

	CertBlob.cbData=0;
	CertBlob.pbData=NULL;

	if(!CertSaveStore(hCertStore,
						ENCODE_TYPE,
						CERT_STORE_SAVE_AS_PKCS7,
						CERT_STORE_SAVE_TO_MEMORY,
						&CertBlob,
						0))
		goto TraceErr;

	CertBlob.pbData = (BYTE *)malloc(CertBlob.cbData);

	if(NULL == CertBlob.pbData)
		goto MemoryErr;

	if(!CertSaveStore(hCertStore,
						ENCODE_TYPE,
						CERT_STORE_SAVE_AS_PKCS7,
						CERT_STORE_SAVE_TO_MEMORY,
						&CertBlob,
						0))
		goto TraceErr;

	//copy the memory
	*ppbData=CertBlob.pbData;
	*pcbData=CertBlob.cbData;
	
	CertBlob.pbData=NULL;

	fResult = TRUE;

CommonReturn:

	if(CertBlob.pbData)
		free(CertBlob.pbData);

	if(hCertStore)
		CertCloseStore(hCertStore, 0);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	 CEPRetrievePasswordFromRequest
//
//--------------------------------------------------------------------------
BOOL WINAPI	CEPRetrievePasswordFromRequest(BYTE		*pbRequest, 
										   DWORD	cbRequest, 
										   LPWSTR	*ppwszPassword,
										   DWORD	*pdwUsage)
{
	BOOL				fResult=FALSE;
	DWORD				cbData=0;
	DWORD				dwIndex=0;
	DWORD				cbNameValue=0;
	DWORD				dwExt=0;
	DWORD				cbExtensions=0;
	DWORD				cbSize=0;

	CERT_REQUEST_INFO	*pCertRequestInfo=NULL;
	CERT_NAME_VALUE		*pbNameValue=NULL;
	CERT_EXTENSIONS		*pExtensions=NULL;
	CRYPT_BIT_BLOB		*pKeyUsage=NULL;

	*ppwszPassword=NULL;
	*pdwUsage=0;

	if(!CEPAllocAndDecode(X509_CERT_REQUEST_TO_BE_SIGNED,
						  pbRequest,
						  cbRequest,
						  (void **)&pCertRequestInfo,
						  &cbData))
		goto TraceErr;

	//get the key usage
	for(dwIndex=0; dwIndex < pCertRequestInfo->cAttribute; dwIndex++)
	{
		if((0 == strcmp(szOID_RSA_certExtensions, pCertRequestInfo->rgAttribute[dwIndex].pszObjId)) ||
			(0 == strcmp(szOID_CERT_EXTENSIONS, pCertRequestInfo->rgAttribute[dwIndex].pszObjId))
		   )
		{	
			if(CEPAllocAndDecode(X509_EXTENSIONS,
								 pCertRequestInfo->rgAttribute[dwIndex].rgValue[0].pbData,
								 pCertRequestInfo->rgAttribute[dwIndex].rgValue[0].cbData,
								 (void **)&pExtensions,
								 &cbExtensions))
			{
				for(dwExt=0; dwExt < pExtensions->cExtension; dwExt++)
				{
					if(0==strcmp(szOID_KEY_USAGE, pExtensions->rgExtension[dwExt].pszObjId))
					{
						if(CEPAllocAndDecode(X509_KEY_USAGE,
											pExtensions->rgExtension[dwExt].Value.pbData,
											pExtensions->rgExtension[dwExt].Value.cbData,
											(void **)&pKeyUsage,
											&cbSize))
						{
							if(pKeyUsage->pbData)
							{

								if(CERT_DIGITAL_SIGNATURE_KEY_USAGE & (pKeyUsage->pbData[0]))
									(*pdwUsage)	= (*pdwUsage) | CEP_REQUEST_SIGNATURE;

								if(CERT_KEY_ENCIPHERMENT_KEY_USAGE & (pKeyUsage->pbData[0]))
									(*pdwUsage)	= (*pdwUsage) | CEP_REQUEST_EXCHANGE;
							}
						}

						if(pKeyUsage)
							free(pKeyUsage);

						pKeyUsage=NULL;
						cbSize=0;
					}
				}
			}

			if(pExtensions)
				free(pExtensions);

			pExtensions=NULL;
			cbExtensions=0;
		}
	}

	//get the password
	for(dwIndex=0; dwIndex < pCertRequestInfo->cAttribute; dwIndex++)
	{
		if(0 == strcmp(szOID_RSA_challengePwd, 
			pCertRequestInfo->rgAttribute[dwIndex].pszObjId))
			break;
	}

	//the password is not required to be present in this function
	if(dwIndex != pCertRequestInfo->cAttribute)
	{
		if(!CEPAllocAndDecode(X509_UNICODE_ANY_STRING,
							 pCertRequestInfo->rgAttribute[dwIndex].rgValue[0].pbData,
							 pCertRequestInfo->rgAttribute[dwIndex].rgValue[0].cbData,
							 (void **)&pbNameValue,
							 &cbNameValue))
			goto TraceErr;

		if(CERT_RDN_PRINTABLE_STRING != (pbNameValue->dwValueType))
			goto InvalidArgErr;

		cbData=wcslen((LPWSTR)(pbNameValue->Value.pbData));

		*ppwszPassword=(LPWSTR)malloc(sizeof(WCHAR) * (cbData + 1));
		if(NULL==(*ppwszPassword))
			goto MemoryErr;

		wcscpy(*ppwszPassword,(LPWSTR)(pbNameValue->Value.pbData)); 
	}

	fResult=TRUE;

CommonReturn:

	if(pExtensions)
		free(pExtensions);

	if(pKeyUsage)
		free(pKeyUsage);

	if(pbNameValue)
		free(pbNameValue);

	if(pCertRequestInfo)
		free(pCertRequestInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}



//--------------------------------------------------------------------------
//
//	AltNameExist
//
//	Return TRUE is szOID_SUBJECT_ALT_NAME2 is present in the PKCS10
//	FALSE otherwise
//--------------------------------------------------------------------------
BOOL WINAPI AltNameExist(BYTE *pbRequest, DWORD cbRequest)
{
	BOOL				fResult = FALSE;  
	DWORD				cbData=0;
	DWORD				cbExtensions=0;
	DWORD				dwIndex=0; 
	DWORD				dwExt=0;

	CERT_REQUEST_INFO	*pCertRequestInfo=NULL;
	CERT_EXTENSIONS		*pExtensions=NULL;

	if(!CEPAllocAndDecode(X509_CERT_REQUEST_TO_BE_SIGNED,
						  pbRequest,
						  cbRequest,
						  (void **)&pCertRequestInfo,
						  &cbData))
		goto ErrorReturn;

	for(dwIndex=0; dwIndex < pCertRequestInfo->cAttribute; dwIndex++)
	{
		if((0 == strcmp(szOID_RSA_certExtensions, pCertRequestInfo->rgAttribute[dwIndex].pszObjId)) ||
			(0 == strcmp(szOID_CERT_EXTENSIONS, pCertRequestInfo->rgAttribute[dwIndex].pszObjId))
		   )
		{	
			if(CEPAllocAndDecode(X509_EXTENSIONS,
								 pCertRequestInfo->rgAttribute[dwIndex].rgValue[0].pbData,
								 pCertRequestInfo->rgAttribute[dwIndex].rgValue[0].cbData,
								 (void **)&pExtensions,
								 &cbExtensions))
			{
				for(dwExt=0; dwExt < pExtensions->cExtension; dwExt++)
				{
					if(0==strcmp(szOID_SUBJECT_ALT_NAME2, pExtensions->rgExtension[dwExt].pszObjId))
					{
						fResult=TRUE;
						goto CommonReturn;
					}
				}
			}

			if(pExtensions)
				free(pExtensions);

			pExtensions=NULL;
			cbExtensions=0;
		}
	}

CommonReturn:

	if(pExtensions)
		free(pExtensions);

	if(pCertRequestInfo)
		free(pCertRequestInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;
}

//--------------------------------------------------------------------------
//
//	CEPAllocAndEncode
//
//--------------------------------------------------------------------------
BOOL WINAPI CEPAllocAndEncode(LPCSTR lpszStructType,
							void	*pStructInfo,
							BYTE	**ppbEncoded,
							DWORD	*pcbEncoded)
{
	BOOL	fResult=FALSE;

	*pcbEncoded=0;

	if(!CryptEncodeObject(ENCODE_TYPE,
						  lpszStructType,
						  pStructInfo,
						  NULL,
						  pcbEncoded))
		goto TraceErr;

	*ppbEncoded=(BYTE *)malloc(*pcbEncoded);
	if(NULL==(*ppbEncoded))
		goto MemoryErr;

	if(!CryptEncodeObject(ENCODE_TYPE,
						  lpszStructType,
						  pStructInfo,
						  *ppbEncoded,
						  pcbEncoded))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	if(*ppbEncoded)
	{
		free(*ppbEncoded);
		*ppbEncoded=NULL;
	}

	*pcbEncoded=0;

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr); 
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	ConvertIPStringToBinary
//
//	Conver the IP address in the format of "xxx.xx.xx.xx" to an arry of 
//	bytes.  One byte per xxx
//--------------------------------------------------------------------------
BOOL ConvertIPStringToBinary(LPWSTR				pwszIP,
							CRYPT_DATA_BLOB		*pIPAddress)
{
	BOOL	fResult = FALSE;   
	LPWSTR	pwszTok=NULL;
	DWORD	cTok=0;
	DWORD	dwIndex=0;

	if(!pwszIP || !pIPAddress)
		goto InvalidArgErr;

	pIPAddress->pbData=NULL;
	pIPAddress->cbData=0;

	pwszTok=wcstok(pwszIP, L".");
	
	while(NULL != pwszTok)
	{
		cTok++;
		pwszTok=wcstok(NULL, L".");
	}

	pIPAddress->pbData=(BYTE *)malloc(cTok);
	if(NULL==pIPAddress->pbData)
		goto MemoryErr;

	pIPAddress->cbData=cTok;

	pwszTok=pwszIP;

	for(dwIndex=0; dwIndex < cTok; dwIndex++)
	{
		pIPAddress->pbData[dwIndex]=(BYTE)_wtol(pwszTok);		
		pwszTok=pwszTok+wcslen(pwszTok)+1;
	}

	fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	GetAltNameElement
//
//	We create the subject alternative extension based on the PKCS10.
//	unstructedName(DNS name) and unstructedAddress (IP address) are included.
//  At lease one element should be present.
//--------------------------------------------------------------------------
BOOL WINAPI	GetAltNameElement(BYTE				*pb10, 
						   DWORD				cb10, 
						   LPWSTR				*ppwszDNS, 
						   CRYPT_DATA_BLOB		*pIPAddress)
{
	BOOL					fResult = FALSE;
	DWORD					cbRequestInfo=0;
	DWORD					cbNameInfo=0;
	DWORD					dwRDN=0;
	DWORD					dwAttr=0;
	PCERT_RDN_ATTR			pAttr=NULL;
	DWORD					cb=0;

	CERT_REQUEST_INFO		*pRequestInfo=NULL;
	CERT_NAME_INFO			*pNameInfo=NULL;

	if(!pb10 || !ppwszDNS || !pIPAddress)
		goto InvalidArgErr;

	*ppwszDNS=NULL;
	pIPAddress->cbData=0;
	pIPAddress->pbData=NULL;

	if(!CEPAllocAndDecode(X509_CERT_REQUEST_TO_BE_SIGNED,
						  pb10,
						  cb10,
						  (void **)&pRequestInfo,
						  &cbRequestInfo))
		goto TraceErr;

	if(!CEPAllocAndDecode(X509_UNICODE_NAME,
						 pRequestInfo->Subject.pbData,
						 pRequestInfo->Subject.cbData,
						 (void **)&pNameInfo,
						 &cbNameInfo))
		goto TraceErr;

	for(dwRDN=0; dwRDN<pNameInfo->cRDN; dwRDN++)
	{
		for(dwAttr=0; dwAttr<pNameInfo->rgRDN[dwRDN].cRDNAttr; dwAttr++)
		{
			pAttr=&(pNameInfo->rgRDN[dwRDN].rgRDNAttr[dwAttr]);

			//we are happy if we have found both the IPAddress and the fqdn
			if((*ppwszDNS) && (pIPAddress->pbData))
				break;

			if((NULL==*ppwszDNS) && (0 == strcmp(szOID_RSA_unstructName,pAttr->pszObjId)))
			{
				cb=sizeof(WCHAR) * (1+wcslen((LPWSTR)(pAttr->Value.pbData)));

				*ppwszDNS=(LPWSTR)malloc(cb); 

				if(NULL == *ppwszDNS)
					goto MemoryErr;

				wcscpy(*ppwszDNS, (LPWSTR)(pAttr->Value.pbData));
			}
			else
			{
				if((NULL==pIPAddress->pbData) && (0 == strcmp(szOID_RSA_unstructAddr,pAttr->pszObjId)))
				{
					if(!ConvertIPStringToBinary((LPWSTR)(pAttr->Value.pbData),
												pIPAddress))
						goto TraceErr;
				}
			}
		}
	}

	//we need to have some element
	if((NULL == *ppwszDNS) && (NULL==pIPAddress->pbData))
		goto InvalidArgErr;

	fResult = TRUE;

CommonReturn:

	if(pNameInfo)
		free(pNameInfo);

	if(pRequestInfo)
		free(pRequestInfo);

	return fResult;

ErrorReturn:

	if(ppwszDNS)
	{
		if(*ppwszDNS)
		{
			free(*ppwszDNS);
			*ppwszDNS=NULL;
		}
	}

	if(pIPAddress)
	{
		if(pIPAddress->pbData)
		{
			free(pIPAddress->pbData);
			pIPAddress->pbData=NULL;
		}

		pIPAddress->cbData=0;
	}

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	CreateAltNameExtenions
//
//--------------------------------------------------------------------------
BOOL WINAPI	CreateAltNameExtenions(LPWSTR			pwszDNS,
							   CRYPT_DATA_BLOB	*pIPAddress,
							   BYTE				**ppbExt, 
							   DWORD			*pcbExt)
{
	BOOL					fResult = FALSE;
	CERT_ALT_NAME_INFO		AltNameInfo;
	CERT_ALT_NAME_ENTRY		rgAltNameEntry[2];
	DWORD					cAltNameEntry=0;

	//DNS name
	if(pwszDNS)
	{
		rgAltNameEntry[cAltNameEntry].dwAltNameChoice=CERT_ALT_NAME_DNS_NAME;
		rgAltNameEntry[cAltNameEntry].pwszDNSName=pwszDNS;
		cAltNameEntry++;
	}

	//IP address
	if(pIPAddress->pbData)
	{
		rgAltNameEntry[cAltNameEntry].dwAltNameChoice=CERT_ALT_NAME_IP_ADDRESS;
		rgAltNameEntry[cAltNameEntry].IPAddress.cbData=pIPAddress->cbData;
		rgAltNameEntry[cAltNameEntry].IPAddress.pbData=pIPAddress->pbData;
		cAltNameEntry++;
	}


	memset(&AltNameInfo, 0, sizeof(CERT_ALT_NAME_INFO));
	AltNameInfo.cAltEntry=cAltNameEntry;
	AltNameInfo.rgAltEntry=rgAltNameEntry;

	if(!CEPAllocAndEncode(szOID_SUBJECT_ALT_NAME2,
							&AltNameInfo,
							ppbExt,
							pcbExt))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
}


//--------------------------------------------------------------------------
//
//	AddAltNameInRequest
//
//--------------------------------------------------------------------------
BOOL WINAPI AddAltNameInRequest(PCCERT_CONTEXT	pRACert, 
								BYTE			*pb10, 
								DWORD			cb10, 
								LPWSTR			pwszDNS,
								CRYPT_DATA_BLOB	*pIPAddress,
								BYTE			**ppb7, 
								DWORD			*pcb7)
{
	BOOL						fResult = FALSE;
	DWORD						cbExt=0;
	CERT_EXTENSIONS				Exts;
	CERT_EXTENSION				Ext;
	DWORD						cbAllExt=0;
	CRYPT_SIGN_MESSAGE_PARA		signPara;
	CRYPT_ATTRIBUTE				AuthAttr;
    PCCRYPT_OID_INFO            pOIDInfo=NULL;
	ALG_ID						AlgValue=CALG_SHA1;
	CRYPT_ATTR_BLOB				AttrBlob;

	BYTE						*pbExt=NULL;
	BYTE						*pbAllExt=NULL;

	if(!pRACert || !pb10 || !ppb7 || !pcb7)
		goto InvalidArgErr;

	*ppb7=NULL;
	*pcb7=0;

	if(!CreateAltNameExtenions(pwszDNS, pIPAddress, &pbExt, &cbExt))
		goto TraceErr;
	
	Exts.cExtension=1;
	Exts.rgExtension=&Ext;

	Ext.pszObjId=szOID_SUBJECT_ALT_NAME2;
	Ext.fCritical=TRUE;
	Ext.Value.pbData=pbExt;
	Ext.Value.cbData=cbExt;

	if(!CEPAllocAndEncode(X509_EXTENSIONS,
						  &Exts,
						  &pbAllExt,
						  &cbAllExt))
		goto TraceErr;

	AuthAttr.pszObjId=szOID_CERT_EXTENSIONS;
	AuthAttr.cValue=1;
	AuthAttr.rgValue=&AttrBlob;

	AttrBlob.pbData=pbAllExt;
	AttrBlob.cbData=cbAllExt;


	memset(&signPara, 0, sizeof(signPara));

	signPara.cbSize                  = sizeof(CRYPT_SIGN_MESSAGE_PARA);
    signPara.dwMsgEncodingType       = ENCODE_TYPE;
    signPara.pSigningCert            = pRACert;
    signPara.cMsgCert                = 1;
    signPara.rgpMsgCert              = &pRACert;
	signPara.cAuthAttr				= 1;
	signPara.rgAuthAttr				= &AuthAttr; 

	if(pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_ALGID_KEY,
                        &AlgValue,
                        CRYPT_HASH_ALG_OID_GROUP_ID))
		signPara.HashAlgorithm.pszObjId=(LPSTR)(pOIDInfo->pszOID);
	else
		signPara.HashAlgorithm.pszObjId=szOID_OIWSEC_sha1;


	if(!CryptSignMessage(
			&signPara,
			FALSE,
			1,
			(const BYTE **) &pb10,
			&cb10,
			NULL,
			pcb7))
		goto TraceErr;

	*ppb7=(BYTE *)malloc(*pcb7);
	if(NULL==(*ppb7))
		goto MemoryErr;
	
	if(!CryptSignMessage(
			&signPara,
			FALSE,
			1,
			(const BYTE **) &pb10,
			&cb10,
			*ppb7,
			pcb7))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	if(pbAllExt)
		free(pbAllExt);

	if(pbExt)
		free(pbExt);

	return fResult;

ErrorReturn:
	
	if(ppb7)
	{
		if(*ppb7)
		{
			free(*ppb7);
			*ppb7=NULL;
		}
	}

	if(pcb7)
		*pcb7=0;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}
//--------------------------------------------------------------------------
//
//	MakePKCS7Request
//
//--------------------------------------------------------------------------
BOOL WINAPI MakePKCS7Request(PCCERT_CONTEXT	pRACert, 
								BYTE			*pb10, 
								DWORD			cb10, 
								BYTE			**ppb7, 
								DWORD			*pcb7)
{
	BOOL						fResult = FALSE;
	CRYPT_SIGN_MESSAGE_PARA		signPara;
    PCCRYPT_OID_INFO            pOIDInfo=NULL;
	ALG_ID						AlgValue=CALG_SHA1;


	if(!pRACert || !pb10 || !ppb7 || !pcb7)
		goto InvalidArgErr;

	*ppb7=NULL;
	*pcb7=0;


	memset(&signPara, 0, sizeof(signPara));

	signPara.cbSize                  = sizeof(CRYPT_SIGN_MESSAGE_PARA);
    signPara.dwMsgEncodingType       = ENCODE_TYPE;
    signPara.pSigningCert            = pRACert;
    signPara.cMsgCert                = 1;
    signPara.rgpMsgCert              = &pRACert;
	signPara.cAuthAttr				= 0;
	signPara.rgAuthAttr				= NULL; 

	if(pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_ALGID_KEY,
                        &AlgValue,
                        CRYPT_HASH_ALG_OID_GROUP_ID))
		signPara.HashAlgorithm.pszObjId=(LPSTR)(pOIDInfo->pszOID);
	else
		signPara.HashAlgorithm.pszObjId=szOID_OIWSEC_sha1;


	if(!CryptSignMessage(
			&signPara,
			FALSE,
			1,
			(const BYTE **) &pb10,
			&cb10,
			NULL,
			pcb7))
		goto TraceErr;

	*ppb7=(BYTE *)malloc(*pcb7);
	if(NULL==(*ppb7))
		goto MemoryErr;
	
	if(!CryptSignMessage(
			&signPara,
			FALSE,
			1,
			(const BYTE **) &pb10,
			&cb10,
			*ppb7,
			pcb7))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:
	
	if(ppb7)
	{
		if(*ppb7)
		{
			free(*ppb7);
			*ppb7=NULL;
		}
	}

	if(pcb7)
		*pcb7=0;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
}

/*//--------------------------------------------------------------------------
//
//	GetLogonInfoFromValue
//
//	The pwszString can be of format "name;password" or "domain\name;password"
//
//--------------------------------------------------------------------------
BOOL GetLogonInfoFromValue(PCCERT_CONTEXT		pRAEncrypt,
						   LPWSTR				pwszString,
						   LPWSTR				*ppwszDomain,
						   LPWSTR				*ppwszUser,
						   LPWSTR				*ppwszPassword)
{
	BOOL		fResult=FALSE;
	LPWSTR		pwsz=NULL;
	BOOL		fDomain=FALSE;
	BOOL		fPassword=FALSE;
	LPWSTR		pwszPlainText=NULL;

	*ppwszDomain=NULL;
	*ppwszUser=NULL;
	*ppwszPassword=NULL;
						 
	if(NULL==pwszString)
		goto InvalidArgErr;

	if(0 == wcslen(pwszString))
		goto InvalidArgErr;

	for(pwsz=pwszString; *pwsz!=L'\0'; pwsz++)
	{
		if(*pwsz==L'\\')
		{
			if(fDomain)
				goto InvalidArgErr;

			fDomain=TRUE;

			*pwsz='\0';
		}
		else
		{
			if(*pwsz==L';')
			{
				if(fPassword)
					goto InvalidArgErr;

				fPassword=TRUE;

				*pwsz='\0';
			}
		}

	}

	//have to have userName and password.  
	//One and only one ";" should be found
	if(!fPassword)
		goto InvalidArgErr;

	//one or no "\" should be found
	if(fDomain)
	{
		*ppwszDomain=pwszString;
		*ppwszUser=*ppwszDomain + wcslen(*ppwszDomain) + 1;
	}
	else
	{
		*ppwszDomain=NULL;
		*ppwszUser=pwszString;
	}

	*ppwszPassword = *ppwszUser + wcslen(*ppwszUser) + 1;

	if(fDomain)
	{
		if(L'\0'==(**ppwszDomain))
			goto InvalidArgErr;
	}

	if((L'\0'==(**ppwszUser)) || (L'\0'==(**ppwszPassword)))
		goto InvalidArgErr;

	//convert the encrypted password to the plain text form
	if(!CEPDecryptPassword(pRAEncrypt,
						   *ppwszPassword,
						   &pwszPlainText))
		goto TraceErr;

	*ppwszPassword=pwszPlainText;
	
	fResult = TRUE;

CommonReturn:

	return fResult;
	
ErrorReturn:

	*ppwszDomain=NULL;
	*ppwszUser=NULL;
	*ppwszPassword=NULL;	 

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
}  */


/*//--------------------------------------------------------------------------
//
//	CEPGetTokenFromPKCS10
//
//	If fPassword is TRUE, an impersonation has to occur.
//--------------------------------------------------------------------------
BOOL CEPGetTokenFromPKCS10(BOOL					fPassword,
						   PCCERT_CONTEXT		pRAEncrypt,
						   BYTE					*pbRequest, 
						   DWORD				cbRequest, 
						   HANDLE				*phToken)
{
	BOOL				fResult=FALSE;
	DWORD				cbRequestInfo=0;
	DWORD				dwIndex=0;
	CRYPT_ATTRIBUTE		*pAttr=NULL;
	DWORD				cbData=0;
	LPWSTR				pwszDomain=NULL;
	LPWSTR				pwszUserName=NULL;
	LPWSTR				pwszPassword=NULL;

	CERT_REQUEST_INFO	*pRequestInfo=NULL;
	CERT_NAME_VALUE		*pCertNameValue=NULL;

	*phToken=NULL;

	if((!pbRequest) || (0==cbRequest))
		goto InvalidArgErr;

	if(!CEPAllocAndDecode(X509_CERT_REQUEST_TO_BE_SIGNED,
				  pbRequest,
				  cbRequest,
				  (void **)&pRequestInfo,
				  &cbRequestInfo))
		goto TraceErr;

	for(dwIndex=0; dwIndex < pRequestInfo->cAttribute; dwIndex++)
	{
		if(0 == strcmp(szOID_RSA_challengePwd, (pRequestInfo->rgAttribute[dwIndex]).pszObjId))
		{
			pAttr= &(pRequestInfo->rgAttribute[dwIndex]);
			break;
		}
	}

	if(NULL==pAttr)
	{
		if(fPassword)
			goto InvalidArgErr;
		else
		{
			*phToken=NULL;
			fResult=TRUE;
			goto CommonReturn;
		}
	}

	if(CEPAllocAndDecode(X509_UNICODE_ANY_STRING,
				  pAttr->rgValue[0].pbData,
				  pAttr->rgValue[0].cbData,
				  (void **)&pCertNameValue,
				  &cbData))
	{
		if(GetLogonInfoFromValue(pRAEncrypt,
								(LPWSTR)(pCertNameValue->Value.pbData),
								&pwszDomain,
								&pwszUserName,
								&pwszPassword))
		{
			if(!LogonUserW(pwszUserName,
						  pwszDomain,
						  pwszPassword,
						  LOGON32_LOGON_INTERACTIVE,
						  LOGON32_PROVIDER_DEFAULT,
						  phToken))
				*phToken=NULL;
		}
	}

	if(NULL == *phToken)
	{
		if(fPassword)
			goto InvalidArgErr;
	}

	fResult = TRUE;

CommonReturn:

	if(pRequestInfo)
		free(pRequestInfo);

	if(pCertNameValue)
		free(pCertNameValue);

	return fResult;
	
ErrorReturn:
	
	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
} */


//--------------------------------------------------------------------------
//
//	CEPCopyRequestAndRequestID
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPCopyRequestAndRequestID(BYTE		*pbRequest, 
											  DWORD		cbRequest, 
											DWORD		dwRequestID)
{
	BOOL			fResult=FALSE;
	BYTE			pbHash[CEP_MD5_HASH_SIZE];
	DWORD			cbData=0;

	
	cbData=CEP_MD5_HASH_SIZE;

	if(!CryptHashCertificate(
			NULL,
			CALG_MD5,
			0,
			pbRequest,
			cbRequest,
			pbHash,
			&cbData))
		goto TraceErr;


	if(!CEPRequestAddHashAndRequestID(pbHash, dwRequestID))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	return fResult;
	
ErrorReturn:	

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
}

//--------------------------------------------------------------------------
//
//	CEPGetCertFromPKCS10
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPGetCertFromPKCS10(CEP_CA_INFO	*pCAInfo,
							 BYTE			*pbRequest, 
							 DWORD			cbRequest, 
							 BYTE			**ppbData, 
							 DWORD			*pcbData,
							 CEP_MESSAGE_INFO		*pMsgInfo)
{
	BOOL	fResult = FALSE;
	DWORD	dwRequestID=0;
	DWORD	cbCert=0;
	BYTE	*pbCert=NULL;	
	DWORD	dwErrorInfo=MESSAGE_FAILURE_BAD_CERT_ID;
	long	dwDisposition=0;
	BYTE	pbHash[CEP_MD5_HASH_SIZE];
	DWORD	cbData=0;


	BSTR	bstrCert=NULL;


	if(!pCAInfo || !pbRequest || !ppbData || !pcbData || !pMsgInfo)
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	cbData=CEP_MD5_HASH_SIZE;

	if(!CryptHashCertificate(
			NULL,
			CALG_MD5,
			0,
			pbRequest,
			cbRequest,
			pbHash,
			&cbData))
		goto TraceErr;

	if(!CEPRequestRetrieveRequestIDFromHash(pbHash, &dwRequestID))
		goto InvalidArgErr;

	if(S_OK != pCAInfo->pICertRequest->RetrievePending(dwRequestID,
													pCAInfo->bstrCAConfig,
													&dwDisposition))
		goto InvalidArgErr;

	switch(dwDisposition)
	{
		case CR_DISP_ISSUED:
				if(S_OK != pCAInfo->pICertRequest->GetCertificate(CR_OUT_BINARY,
												&bstrCert))
					goto FailureStatusReturn;

				cbCert = (DWORD)SysStringByteLen(bstrCert);
				pbCert = (BYTE *)bstrCert;

   				//package it in an empty PKCS7
				if(!PackageBlobToPKCS7(CEP_CONTEXT_CERT, pbCert, cbCert, ppbData, pcbData))
					goto FailureStatusReturn;

				pMsgInfo->dwStatus=MESSAGE_STATUS_SUCCESS;

			break;
		case CR_DISP_UNDER_SUBMISSION:
				
				pMsgInfo->dwStatus=MESSAGE_STATUS_PENDING;

			break;
		case CR_DISP_INCOMPLETE:
			                           
		case CR_DISP_ERROR:   
			                           
		case CR_DISP_DENIED:   
			                           
		case CR_DISP_ISSUED_OUT_OF_BAND:	  //we consider it a failure in this case
			                          
		case CR_DISP_REVOKED:

		default:

				dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
				goto FailureStatusReturn;

			break;
	}

	fResult = TRUE;

CommonReturn:

	if(bstrCert)
		SysFreeString(bstrCert);

	return fResult;	   

FailureStatusReturn:

	//we set the error status for the return message
	//and consider this http transation a success
	pMsgInfo->dwStatus=MESSAGE_STATUS_FAILURE;
	pMsgInfo->dwErrorInfo=dwErrorInfo;
	
	*ppbData=NULL;
	*pcbData=0;

	fResult=TRUE;
	goto CommonReturn;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
}

//--------------------------------------------------------------------------
//
//	ProcessCertRequest
//
//--------------------------------------------------------------------------
BOOL	ProcessCertRequest(	DWORD				dwRefreshDays,
							BOOL				fPassword,
						    PCCERT_CONTEXT		pRAEncrypt,
						    PCCERT_CONTEXT		pRACert,
							CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo)
{					
	BOOL				fResult = FALSE;
	HRESULT				hr=E_FAIL;
	DWORD				dwFlags=0;
	long				dwDisposition=0;
	DWORD				dwErrorInfo=MESSAGE_FAILURE_BAD_MESSAGE_CHECK;
	DWORD				cbNewRequest=0;
	DWORD				cbCert=0;
	BYTE				*pbCert=NULL;
	DWORD				dwRequestID=0;
	DWORD				dwUsage=0;
	LPWSTR				pwszTemplate=L"IPSECIntermediateOffline";
	
	LPWSTR				pwszAttr=NULL;
	BSTR				bstrRequest=NULL;
	BYTE				*pbNewRequest=NULL;
	BSTR				bstrCert=NULL;
	BSTR				bstrAttr=NULL;
	LPWSTR				pwszDNS=NULL;
	CRYPT_DATA_BLOB		IPAddress={0, NULL};
	LPWSTR				pwszPassword=NULL;


	if(!pCAInfo || !pbRequest || !ppbData || !pcbData || !pMsgInfo)
		goto InvalidArgErr;

	*ppbData=NULL;
	*pcbData=0;

	//check to see if the PKCS10 is in our cached request table
	//if so, we return messages based on the cached requestID
	if(CEPGetCertFromPKCS10(pCAInfo, pbRequest, cbRequest, ppbData, pcbData, pMsgInfo))
	{
		fResult=TRUE;
	}
	else
	{
		//retrieve password and key usage from the request.  The presence of password
		//or key usage is not required
		if(!CEPRetrievePasswordFromRequest(pbRequest, cbRequest, &pwszPassword, &dwUsage))
		{
			LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_NO_KEY_USAGE, 1, g_pwszComputerName);
			dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
			goto FailureStatusReturn;
		}

		if(0 == dwUsage)
		{
			LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_NO_KEY_USAGE, 1, g_pwszComputerName);
			dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
			goto FailureStatusReturn;
		}

		//if the password is required, we need to make sure the password
		//supplied is valid.
		if(fPassword)
		{
			if(NULL == pwszPassword)
			{
				LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_NO_PASSWORD, 1, g_pwszComputerName);
				dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
				goto FailureStatusReturn;
			}

			if(!CEPVerifyPasswordAndDeleteFromTable(pwszPassword, dwUsage))
			{
				LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_INVALID_PASSWORD, 1, g_pwszComputerName);
				dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
				goto FailureStatusReturn;
			}
		}

		//if the altname extention is not in the PKCS10, we need to add it
		//otherwise, just use the PKCS10

		dwFlags = CR_IN_PKCS10;
		pbNewRequest=pbRequest;
		cbNewRequest=cbRequest;

		if(!AltNameExist(pbRequest, cbRequest))
		{
			if(GetAltNameElement(pbRequest, cbRequest, &pwszDNS, &IPAddress))
			{
				if(!AddAltNameInRequest(pRACert, pbRequest, cbRequest, pwszDNS, &IPAddress, &pbNewRequest, &cbNewRequest))
				{
					LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAIL_ADD_ALT, 1, g_pwszComputerName);
					goto TraceErr;
				}

				dwFlags = CR_IN_PKCS7;
			}
		}
        
        //we always want to make a PKCS7 request so that we can work with enterprise CA
        if(CR_IN_PKCS10 == dwFlags)
        {
            if(!MakePKCS7Request(pRACert, pbRequest, cbRequest, &pbNewRequest, &cbNewRequest))
                goto TraceErr;

            dwFlags = CR_IN_PKCS7;
        }

		if(!(bstrRequest=SysAllocStringByteLen((LPCSTR)pbNewRequest, cbNewRequest)))
			goto MemoryErr;

		//we are requesting a IPSEC offline cert template for Standalone CA
		//or general purpose enterprise CA
		if((FALSE == pCAInfo->fEnterpriseCA) ||
			((dwUsage & CEP_REQUEST_SIGNATURE) && (dwUsage & CEP_REQUEST_EXCHANGE))
		   )
		{
			if(!(bstrAttr=SysAllocString(L"CertificateTemplate:IPSECIntermediateOffline\r\n")))
				goto MemoryErr;
		}
		else
		{
			if(dwUsage & CEP_REQUEST_SIGNATURE)
			{
				if(pCAInfo->pwszTemplateSig)
					pwszTemplate=pCAInfo->pwszTemplateSig;
			}
			else
			{
				//the encryption usage must be set
				if( 0 == (dwUsage & CEP_REQUEST_EXCHANGE))
				{
					LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_NO_KEY_USAGE, 1, g_pwszComputerName);
					dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
					goto FailureStatusReturn;
				}

				if(pCAInfo->pwszTemplateEnt)
					pwszTemplate=pCAInfo->pwszTemplateEnt;
			}

			pwszAttr=(LPWSTR)malloc((wcslen(CEP_TEMPLATE_ATTR) + wcslen(pwszTemplate) + 5) * sizeof(WCHAR));
			if(NULL == pwszAttr)
				goto MemoryErr;
			
			wcscpy(pwszAttr, CEP_TEMPLATE_ATTR);
			wcscat(pwszAttr, pwszTemplate);
			wcscat(pwszAttr, L"\r\n");

			if(!(bstrAttr=SysAllocString(pwszAttr)))
				goto MemoryErr;
		}

		if(S_OK != (hr=pCAInfo->pICertRequest->Submit(
								CR_IN_BINARY | dwFlags,
								bstrRequest,
								bstrAttr,
								pCAInfo->bstrCAConfig,
								&dwDisposition)))
		{
			LogSCEPEvent(0, TRUE, hr, EVENT_MSCEP_FAIL_SUBMIT, 1, g_pwszComputerName);
		   goto FailureStatusReturn;
		}

		dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;

		switch(dwDisposition)
		{
			case CR_DISP_ISSUED:

					if(S_OK != (hr = pCAInfo->pICertRequest->GetCertificate(CR_OUT_BINARY,
													&bstrCert)))
					{
						LogSCEPEvent(0, TRUE, hr, EVENT_MSCEP_FAIL_QUERY_CERT, 1, g_pwszComputerName);
						goto FailureStatusReturn;
					}

					cbCert = (DWORD)SysStringByteLen(bstrCert);
					pbCert = (BYTE *)bstrCert;	 

   					//package it in an empty PKCS7
					if(!PackageBlobToPKCS7(CEP_CONTEXT_CERT, pbCert, cbCert, ppbData, pcbData))
						goto FailureStatusReturn;

					pMsgInfo->dwStatus=MESSAGE_STATUS_SUCCESS;

					//copy the PKCS10 to the cached request table
					if(S_OK == (hr=pCAInfo->pICertRequest->GetRequestId((long*)(&dwRequestID))))
					{
						CEPCopyRequestAndRequestID(pbRequest, cbRequest, dwRequestID);
					}

				break;
			case CR_DISP_UNDER_SUBMISSION:

					//copy the transactionID/requestID pair	
					if(S_OK == (hr=pCAInfo->pICertRequest->GetRequestId((long*)(&dwRequestID))))
					{
						if(!CEPHashAddRequestAndTransaction(dwRefreshDays,
														dwRequestID,
														&(pMsgInfo->TransactionID)))
						{

							LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_ADD_ID, 1, g_pwszComputerName);
							goto DatabaseErr;
						}
						
						//also copy the PKCS10 to the cached request table for retrial cases
						CEPCopyRequestAndRequestID(pbRequest, cbRequest, dwRequestID);						
					}
					else
					{
						LogSCEPEvent(0, TRUE, hr, EVENT_MSCEP_GET_REQUEST_ID, 1, g_pwszComputerName);
					}

					pMsgInfo->dwStatus=MESSAGE_STATUS_PENDING;

				break;

			case CR_DISP_INCOMPLETE:
										   
			case CR_DISP_ERROR:   
										   
			case CR_DISP_DENIED:   
										   
			case CR_DISP_ISSUED_OUT_OF_BAND:	  //we consider it a failure in this case
										  
			case CR_DISP_REVOKED:

			default:
					dwErrorInfo=MESSAGE_FAILURE_BAD_REQUEST;
					goto FailureStatusReturn;

				break;
		}
	}

	
	fResult = TRUE;

CommonReturn:

	if(pwszAttr)
		free(pwszAttr);

	if(pwszPassword)
		free(pwszPassword);

	if(bstrCert)
		SysFreeString(bstrCert);

	if(bstrRequest)
		SysFreeString(bstrRequest);

	if(bstrAttr)
		SysFreeString(bstrAttr);

	if(pwszDNS)
		free(pwszDNS);

	if(IPAddress.pbData)
		free(IPAddress.pbData);

	if(dwFlags == CR_IN_PKCS7)
	{
		if(pbNewRequest)
			free(pbNewRequest);
	}	  


	return fResult;

FailureStatusReturn:

	//we set the error status for the return message
	//and consider this http transation a success
	pMsgInfo->dwStatus=MESSAGE_STATUS_FAILURE;
	pMsgInfo->dwErrorInfo=dwErrorInfo;
	
	*ppbData=NULL;
	*pcbData=0;

	fResult=TRUE;
	goto CommonReturn;
	
ErrorReturn:	


	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
TRACE_ERROR(TraceErr);
TRACE_ERROR(DatabaseErr);
}


//--------------------------------------------------------------------------
//
//	DecryptMsg
//
//--------------------------------------------------------------------------
BOOL WINAPI DecryptMsg(CEP_RA_INFO		*pRAInfo, 
					   BYTE				*pbReqEnv, 
					   DWORD			cbReqEnv, 
					   BYTE				**ppbReqDecrypt, 
					   DWORD			*pcbReqDecrypt)
{
	BOOL					fResult = FALSE; 
	CMSG_CTRL_DECRYPT_PARA	DecryptPara;
	BOOL					fProvFree=FALSE;

	HCRYPTMSG				hMsg=NULL;

	if(!pRAInfo || !pbReqEnv || !ppbReqDecrypt || !pcbReqDecrypt)
		goto InvalidArgErr;

	*ppbReqDecrypt=NULL;
	*pcbReqDecrypt=0;

	if(NULL == (hMsg=CryptMsgOpenToDecode(
						ENCODE_TYPE,
						0,
						0,
						NULL,
						NULL,
						NULL)))
		goto TraceErr;

	if(!CryptMsgUpdate(hMsg,
						pbReqEnv,
						cbReqEnv,
						TRUE))
		goto TraceErr;

	//decrypt
	memset(&DecryptPara, 0, sizeof(CMSG_CTRL_DECRYPT_PARA));

	DecryptPara.cbSize=sizeof(CMSG_CTRL_DECRYPT_PARA);
	DecryptPara.dwRecipientIndex=0;
	DecryptPara.hCryptProv=pRAInfo->hRAProv;
	DecryptPara.dwKeySpec=pRAInfo->dwKeySpec;

	if(!CryptMsgControl(hMsg,
						0,
						CMSG_CTRL_DECRYPT,
						&DecryptPara))
		goto TraceErr;

	//get the content
	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						NULL,
						pcbReqDecrypt))
		goto TraceErr;

	*ppbReqDecrypt=(BYTE *)malloc(*pcbReqDecrypt);
	if(NULL==(*ppbReqDecrypt))
		goto MemoryErr;

	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						*ppbReqDecrypt,
						pcbReqDecrypt))
		goto TraceErr;

	fResult = TRUE;

CommonReturn:

	if(hMsg)
		CryptMsgClose(hMsg);	

	return fResult;

ErrorReturn:

	if(ppbReqDecrypt)
	{
		if(*ppbReqDecrypt)
		{
			free(*ppbReqDecrypt);
			*ppbReqDecrypt=NULL;
		}
	}

	if(pcbReqDecrypt)
		*pcbReqDecrypt=0;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}



//--------------------------------------------------------------------------
//
//	GetContentFromPKCS7
//
//--------------------------------------------------------------------------
BOOL	WINAPI	GetContentFromPKCS7(BYTE				*pbMessage,
									DWORD				cbMessage,
									BYTE				**ppbContent,
									DWORD				*pcbContent,
									CEP_MESSAGE_INFO	*pMsgInfo)
{
	BOOL				fResult = FALSE;
	DWORD				cbAuth=0;
	DWORD				dwIndex=0;
	CRYPT_ATTRIBUTE		*pOneAuth=NULL;
	DWORD				cb=0;
	DWORD				cbCertInfo=0;
 	PCCERT_CONTEXT		pCertPre=NULL;


	HCRYPTMSG			hMsg=NULL;
	CRYPT_ATTRIBUTES	*pbAuth=NULL;
	void				*pb=NULL;
	CERT_INFO			*pbCertInfo=NULL;
	HCERTSTORE			hCertStore=NULL; 
	PCCERT_CONTEXT		pCertCur=NULL;

	if(!pMsgInfo || !ppbContent || !pcbContent)
		goto InvalidArgErr;

	*ppbContent=NULL;
	*pcbContent=0;

	memset(pMsgInfo, 0, sizeof(CEP_MESSAGE_INFO));

	if(NULL == (hMsg=CryptMsgOpenToDecode(
						ENCODE_TYPE,
						0,
						0,
						NULL,
						NULL,
						NULL)))
		goto TraceErr;

	if(!CryptMsgUpdate(hMsg,
						pbMessage,
						cbMessage,
						TRUE))
		goto TraceErr;

	//get the content
	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						NULL,
						pcbContent))
		goto TraceErr;

	*ppbContent=(BYTE *)malloc(*pcbContent);
	if(NULL==(*ppbContent))
		goto MemoryErr;

	if(!CryptMsgGetParam(hMsg,
						CMSG_CONTENT_PARAM,
						0,
						*ppbContent,
						pcbContent))
		goto TraceErr;

	//get message type
	if(!CryptMsgGetParam(hMsg,
						CMSG_SIGNER_AUTH_ATTR_PARAM,
						0,
						NULL,
						&cbAuth))
		goto TraceErr;

	pbAuth=(CRYPT_ATTRIBUTES *)malloc(cbAuth);
	if(NULL==pbAuth)
		goto MemoryErr;

	if(!CryptMsgGetParam(hMsg,
						CMSG_SIGNER_AUTH_ATTR_PARAM,
						0,
						pbAuth,
						&cbAuth))
		goto TraceErr;

	for(dwIndex=0; dwIndex < pbAuth->cAttr; dwIndex++)
	{
		pOneAuth=&(pbAuth->rgAttr[dwIndex]);

		if((!(pOneAuth->pszObjId)) || (!(pOneAuth->rgValue)))
			continue;

		if((0==(pOneAuth->rgValue[0].cbData)) || (!(pOneAuth->rgValue[0].pbData)))
			continue;
		
		if(0 == strcmp(pOneAuth->pszObjId, szOIDVerisign_MessageType))
		{	
			
			if(!CEPAllocAndDecode(X509_ANY_STRING,
								  pOneAuth->rgValue[0].pbData,
								  pOneAuth->rgValue[0].cbData,
								  (void **)&pb,
								  &cb))
				goto TraceErr;

			if(CERT_RDN_PRINTABLE_STRING != ((CERT_NAME_VALUE *)pb)->dwValueType)
				goto InvalidArgErr;

			pMsgInfo->dwMessageType = atol((LPSTR)(((CERT_NAME_VALUE *)pb)->Value.pbData));
		}
		else
		{
			if(0 == strcmp(pOneAuth->pszObjId, szOIDVerisign_SenderNonce))
			{
				if(!CEPAllocAndDecode(X509_OCTET_STRING,
									  pOneAuth->rgValue[0].pbData,
									  pOneAuth->rgValue[0].cbData,
									  (void **)&pb,
									  &cb))
					goto TraceErr;

				//the SenderNonce in the request is the recipienNonce in the response
				if(!AllocAndCopyBlob(&(pMsgInfo->RecipientNonce),
								 (CERT_BLOB *)pb))
					goto TraceErr;
								
			}
			else
			{
				if(0 == strcmp(pOneAuth->pszObjId, szOIDVerisign_TransactionID))
				{
					if(!CEPAllocAndDecode(X509_ANY_STRING,
										  pOneAuth->rgValue[0].pbData,
										  pOneAuth->rgValue[0].cbData,
										  (void **)&pb,
										  &cb))
						goto TraceErr;

					if(CERT_RDN_PRINTABLE_STRING != ((CERT_NAME_VALUE *)pb)->dwValueType)
						goto InvalidArgErr;

					if(!AllocAndCopyString(&(pMsgInfo->TransactionID),
							(LPSTR)(((CERT_NAME_VALUE *)pb)->Value.pbData)))
						goto TraceErr;

				}
			}
		}

		if(pb)
			free(pb);

		pb=NULL;
		cb=0;
	}

	//we have to have TrasanctionID and messageType
	if((0 == pMsgInfo->dwMessageType)||(NULL == (pMsgInfo->TransactionID.pbData)))
		goto InvalidArgErr;

	//we get the serial number of the signing certificate
	cbCertInfo=0;
	if(!CryptMsgGetParam(hMsg,
						CMSG_SIGNER_CERT_INFO_PARAM,
						0,
						NULL,
						&cbCertInfo))
		goto TraceErr;

	pbCertInfo=(CERT_INFO *)malloc(cbCertInfo);
	if(NULL==pbCertInfo)
		goto MemoryErr;

	if(!CryptMsgGetParam(hMsg,
						CMSG_SIGNER_CERT_INFO_PARAM,
						0,
						pbCertInfo,
						&cbCertInfo))
		goto TraceErr;

	if(!AllocAndCopyBlob(&(pMsgInfo->SerialNumber), (CERT_BLOB *)(&(pbCertInfo->SerialNumber))))
		goto TraceErr;

	//we get the rounter's CA issued certificate for GetCertInitial message
	if((MESSAGE_TYPE_GET_CERT_INITIAL == pMsgInfo->dwMessageType) ||
		(MESSAGE_TYPE_CERT_REQUEST == pMsgInfo->dwMessageType) ||
		(MESSAGE_TYPE_GET_CERT == pMsgInfo->dwMessageType)
		)
	{
		if(NULL == (hCertStore=CertOpenStore(CERT_STORE_PROV_MSG,
											ENCODE_TYPE,
											NULL,
											0,
											hMsg)))
			goto TraceErr;

		pCertPre=NULL;
		while(pCertCur=CertEnumCertificatesInStore(hCertStore, pCertPre))
		{
			if(SameCert(pCertCur->pCertInfo, pbCertInfo))
			{
				if(NULL==(pMsgInfo->pSigningCert=CertDuplicateCertificateContext(pCertCur)))
					goto TraceErr;

				break;
			}

			pCertPre=pCertCur;
		}

		if(NULL == (pMsgInfo->pSigningCert))
			goto InvalidArgErr; 
	}


	fResult = TRUE;	

CommonReturn:


	if(pCertCur)
		CertFreeCertificateContext(pCertCur);

	if(hCertStore)
		CertCloseStore(hCertStore, 0);

	if(pbCertInfo)
		free(pbCertInfo);

	if(pb)
		free(pb);

	if(pbAuth)
		free(pbAuth);

	if(hMsg)
		CryptMsgClose(hMsg);

	return fResult;


ErrorReturn:

	if(ppbContent)
	{
		if(*ppbContent)
		{
			free(*ppbContent);
			*ppbContent=NULL;
		}
	}

	if(pcbContent)
		*pcbContent=0;
	

	FreeMessageInfo(pMsgInfo);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(TraceErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	SameCert
//
//--------------------------------------------------------------------------
BOOL WINAPI SameCert(CERT_INFO *pCertInfoOne, CERT_INFO *pCertInfoTwo)
{
	if(!pCertInfoOne || !pCertInfoTwo)
		return FALSE;

	if(!SameBlob(&(pCertInfoOne->SerialNumber), &(pCertInfoTwo->SerialNumber)))
		return FALSE;

	if(!SameBlob((CRYPT_INTEGER_BLOB *)(&(pCertInfoOne->Issuer)), 
				 (CRYPT_INTEGER_BLOB *)(&(pCertInfoTwo->Issuer))))
		return FALSE;

	return TRUE;

}


//--------------------------------------------------------------------------
//
//	SameBlob
//
//--------------------------------------------------------------------------
BOOL WINAPI SameBlob(CRYPT_INTEGER_BLOB *pBlobOne, CRYPT_INTEGER_BLOB *pBlobTwo)
{
	if(!pBlobOne || !pBlobTwo)
		return FALSE;

	if(pBlobOne->cbData != pBlobTwo->cbData)
		return FALSE;

	if(0!=(memcmp(pBlobOne->pbData, pBlobTwo->pbData,pBlobTwo->cbData)))
		return FALSE;

	return TRUE;
}

//--------------------------------------------------------------------------
//
//	CEPAllocAndDecode
//
//--------------------------------------------------------------------------
BOOL	WINAPI	CEPAllocAndDecode(	LPCSTR	lpszStructType,
									BYTE	*pbEncoded,
									DWORD	cbEncoded,
									void	**ppb,
									DWORD	*pcb)
{
	BOOL	fResult = FALSE;

	*pcb=0;
	*ppb=NULL;

	if(!CryptDecodeObject(ENCODE_TYPE,
						lpszStructType,
						pbEncoded,
						cbEncoded,
						0,
						NULL,
						pcb))
		goto DecodeErr;

	*ppb=malloc(*pcb);

	if(NULL==(*ppb))
		goto MemoryErr;

	if(!CryptDecodeObject(ENCODE_TYPE,
						lpszStructType,
						pbEncoded,
						cbEncoded,
						0,
						*ppb,
						pcb))
		goto DecodeErr;

	fResult = TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	if(ppb)
	{
		if(*ppb)
		{
			free(*ppb);
			*ppb=NULL;
		}
	}

	if(pcb)
		*pcb=0;

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(DecodeErr);
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	FreeMessageInfo
//
//--------------------------------------------------------------------------
void	WINAPI	FreeMessageInfo(CEP_MESSAGE_INFO		*pMsgInfo)
{
	if(pMsgInfo)
	{
		if(pMsgInfo->TransactionID.pbData)
			free(pMsgInfo->TransactionID.pbData);

		if(pMsgInfo->SenderNonce.pbData)
			free(pMsgInfo->SenderNonce.pbData);

		if(pMsgInfo->RecipientNonce.pbData)
			free(pMsgInfo->RecipientNonce.pbData);

		if(pMsgInfo->SerialNumber.pbData)
			free(pMsgInfo->SerialNumber.pbData);

		if(pMsgInfo->pSigningCert)
			CertFreeCertificateContext(pMsgInfo->pSigningCert);

		memset(pMsgInfo, 0, sizeof(CEP_MESSAGE_INFO));
	}
}


//--------------------------------------------------------------------------
//
//	AllocAndCopyBlob
//
//--------------------------------------------------------------------------
BOOL	WINAPI	AllocAndCopyBlob(CERT_BLOB	*pDestBlob,
							 CERT_BLOB	*pSrcBlob)
{
	memset(pDestBlob, 0, sizeof(CERT_BLOB));

	if(NULL==pSrcBlob->pbData)
	{
		SetLastError(E_INVALIDARG);
		return FALSE;
	}

	pDestBlob->pbData = (BYTE *)malloc(pSrcBlob->cbData);

	if(NULL==(pDestBlob->pbData))
	{
		SetLastError(E_OUTOFMEMORY);
		return FALSE;
	}

	pDestBlob->cbData=pSrcBlob->cbData;
	memcpy(pDestBlob->pbData, pSrcBlob->pbData, pDestBlob->cbData);

	return TRUE;
}


//--------------------------------------------------------------------------
//
//	AllocAndCopyString
//
//--------------------------------------------------------------------------
BOOL WINAPI	AllocAndCopyString(CERT_BLOB	*pDestBlob,
							LPSTR		psz)
{
	if(!psz)
	{
		SetLastError(E_INVALIDARG);
		return FALSE;
	}

	pDestBlob->cbData=0;
	pDestBlob->pbData=NULL;


	pDestBlob->pbData=(BYTE*)malloc(strlen(psz) + 1);
	if(NULL == pDestBlob->pbData)
	{
		SetLastError(E_OUTOFMEMORY);
		return FALSE;
	}

	pDestBlob->cbData=strlen(psz);
	strcpy((LPSTR)pDestBlob->pbData, psz);

	return TRUE;
}




//--------------------------------------------------------------------------
//
//	GetTagValue
//
//--------------------------------------------------------------------------
LPSTR	GetTagValue(LPSTR szString, LPSTR szTag)
{

	LPSTR	pszValue=NULL;
	DWORD	cbString=0;
	DWORD	cbTag=0;

	cbString = strlen(szString);
	cbTag = strlen(szTag);

	for(pszValue=szString; cbString > cbTag; pszValue++, cbString--)
	{
		if((*pszValue) == (*szTag))		
		{
			if(0==_strnicmp(pszValue, szTag, cbTag))
			{
				//skip the tag
				pszValue += cbTag * sizeof(CHAR);
				return pszValue;
			}
		}

	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\mscep\private.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       private.h
//
//  Contents:   The private include file for cryptext.dll.
//
//  History:    May-13-1999	xiaohs	Created
//
//--------------------------------------------------------------
#ifndef CEP_PRIVATE_H
#define CEP_PRIVATE_H


#ifdef __cplusplus
extern "C" {
#endif


#define	GET_TAG_OP				"operation="
#define	GET_TAG_MSG				"&message="
#define	GET_OP_CA				"GetCACert"
#define	GET_OP_PKI				"PKIOperation"
#define	CONTENT_TYPE_CA_RA		"application/x-x509-ca-ra-cert"
#define	CONTENT_TYPE_PKI		"application/x-pki-message"
#define	CONTENT_TYPE_HTML		"text/html"

#define ACCESS_MESSAGE			"401 You do not have permission to enroll for an IPSEC intermediate offline certificate template for SCEP"  

#define	OPERATION_GET_CACERT	1
#define	OPERATION_GET_PKI		2

#define	MESSAGE_TYPE_CERT_RESPONSE		3
#define	MESSAGE_TYPE_CERT_REQUEST		19
#define	MESSAGE_TYPE_GET_CERT_INITIAL	20
#define	MESSAGE_TYPE_GET_CERT			21
#define	MESSAGE_TYPE_GET_CRL			22


#define	MESSAGE_STATUS_SUCCESS			0
#define	MESSAGE_STATUS_FAILURE			2
#define	MESSAGE_STATUS_PENDING			3


#define	MESSAGE_FAILURE_BAD_ALG_ID			0
#define	MESSAGE_FAILURE_BAD_MESSAGE_CHECK	1
#define	MESSAGE_FAILURE_BAD_REQUEST			2
#define	MESSAGE_FAILURE_BAD_TIME			3
#define	MESSAGE_FAILURE_BAD_CERT_ID			4

#define	CEP_CONTEXT_CERT					1
#define	CEP_CONTEXT_CRL						2


//together we should have 6 attributes: TransactionID, MessageType, PkiStatus,
//ErrorInfo, senderNonce, and recipientNonce
#define	CEP_RESPONSE_AUTH_ATTR_COUNT		6
										
#define	szOIDVerisign_MessageType			"2.16.840.1.113733.1.9.2"
#define	szOIDVerisign_PkiStatus				"2.16.840.1.113733.1.9.3"
#define	szOIDVerisign_FailInfo				"2.16.840.1.113733.1.9.4"
#define	szOIDVerisign_SenderNonce			"2.16.840.1.113733.1.9.5"
#define	szOIDVerisign_RecipientNonce		"2.16.840.1.113733.1.9.6"
#define	szOIDVerisign_TransactionID			"2.16.840.1.113733.1.9.7"



#define	MAX_STRING_SIZE						512
#define	PENDING_ALLOC_SIZE					20

#define FILETIME_TICKS_PER_SECOND           10000000
#define OVERLAP_TWO_WEEKS					60*60*24*14
#define OVERLAP_ONE_HOUR					60*60*1


#define	CEP_REQUEST_SIGNATURE				0x01
#define	CEP_REQUEST_EXCHANGE				0x02

#define	CEP_TEMPLATE_ATTR					L"CertificateTemplate:"

//-----------------------------------------------------------------------
//	Externs
//
//------------------------------------------------------------------------
extern CRITICAL_SECTION			CriticalSec;
extern CRITICAL_SECTION			PasswordCriticalSec;

//need for the web page display
extern DWORD					g_dwPasswordValidity;

//needed for the pending retrieval table
extern DWORD					g_dwRequestDuration;

extern LPWSTR					g_pwszComputerName;

//**************************************************************************
//
//  The defines for the transactionID and requestID mapping table
//
struct _CEP_TIME_ENTRY;

//-----------------------------------------------------------------------
//  CEP_HASH_ENTRY
//
//------------------------------------------------------------------------
typedef struct _CEP_HASH_ENTRY
{
	LPSTR				pszTransactionID;
	DWORD				dwRequestID;
	BOOL				fFinished;
	_CEP_TIME_ENTRY		*pTimeEntry;
	_CEP_HASH_ENTRY		*pNext;
	_CEP_HASH_ENTRY		*pPrevious;
}CEP_HASH_ENTRY;


//-----------------------------------------------------------------------
//  CEP_TIME_ENTRY
//
//------------------------------------------------------------------------
typedef struct _CEP_TIME_ENTRY
{
	FILETIME			TimeStamp;
	CEP_HASH_ENTRY		*pHashEntry;
	_CEP_TIME_ENTRY		*pNext;
	_CEP_TIME_ENTRY		*pPrevious;
}CEP_TIME_ENTRY;


//-----------------------------------------------------------------------
//  CEP_HASH_TABLE_INFO
//
//------------------------------------------------------------------------
//we hash based on the 1st byte
#define		CEP_HASH_TABLE_SIZE			256
#define		CEP_REFRESH_DAY				7	
	
typedef struct _CEP_HASH_TABLE_INFO
{
	CEP_HASH_ENTRY	*rgHashEntry[CEP_HASH_TABLE_SIZE];	//the hash table
	CEP_TIME_ENTRY	*pTimeOld;							//the list of hash entry with its timestamp
	CEP_TIME_ENTRY	*pTimeNew;
}CEP_HASH_TABLE_INFO;




//**************************************************************************
//
//  The defines for the password hash table
//
//-----------------------------------------------------------------------
//  CEP_PASSWORD_TABLE
//
//------------------------------------------------------------------------
#define		CEP_PASSWORD_LENGTH				8
#define		CEP_MAX_PASSWORD				1000
#define		CEP_PASSWORD_VALIDITY			60				//in minutes

#define	    UPPER_BITS			            0xF0
#define	    LOWER_BITS			            0x0F


struct _CEP_PASSWORD_VALIDITY_ENTRY;

//-----------------------------------------------------------------------
//  CEP_PASSWORD_ENTRY
//
//------------------------------------------------------------------------
typedef struct _CEP_PASSWORD_ENTRY
{
	LPWSTR							pwszPassword;
	DWORD							dwUsageRequested;
	_CEP_PASSWORD_VALIDITY_ENTRY	*pValidityEntry;
	_CEP_PASSWORD_ENTRY				*pNext;
	_CEP_PASSWORD_ENTRY				*pPrevious;
}CEP_PASSWORD_ENTRY;

//-----------------------------------------------------------------------
//  CEP_PASSWORD_VALIDITY_ENTRY
//
//------------------------------------------------------------------------
typedef struct _CEP_PASSWORD_VALIDITY_ENTRY
{
	FILETIME						TimeStamp;
	CEP_PASSWORD_ENTRY				*pPasswordEntry;
	_CEP_PASSWORD_VALIDITY_ENTRY	*pNext;
	_CEP_PASSWORD_VALIDITY_ENTRY	*pPrevious;
}CEP_PASSWORD_VALIDITY_ENTRY;   

//-----------------------------------------------------------------------
//  CEP_PASSWORD_TABLE_INFO
//
//------------------------------------------------------------------------
	
typedef struct _CEP_PASSWORD_TABLE_INFO
{
	CEP_PASSWORD_ENTRY				*rgPasswordEntry[CEP_HASH_TABLE_SIZE];	//the hash table
	CEP_PASSWORD_VALIDITY_ENTRY		*pTimeOld;								//the list of hash entry with its timestamp
	CEP_PASSWORD_VALIDITY_ENTRY		*pTimeNew;
}CEP_PASSWORD_TABLE_INFO;


//**************************************************************************
//
//  The defines for the request hash table
//

//**************************************************************************
#define		CEP_MD5_HASH_SIZE				16
#define		CEP_REQUEST_DURATION			20

struct _CEP_REQUEST_VALIDITY_ENTRY;

//-----------------------------------------------------------------------
//  CEP_REQUEST_ENTRY
//
//------------------------------------------------------------------------
typedef struct _CEP_REQUEST_ENTRY
{
	BYTE							pbHash[CEP_MD5_HASH_SIZE];
	DWORD							dwRequestID;
	_CEP_REQUEST_VALIDITY_ENTRY		*pValidityEntry;
	_CEP_REQUEST_ENTRY				*pNext;
	_CEP_REQUEST_ENTRY				*pPrevious;
}CEP_REQUEST_ENTRY;

//-----------------------------------------------------------------------
//  CEP_REQUEST_VALIDITY_ENTRY
//
//------------------------------------------------------------------------
typedef struct _CEP_REQUEST_VALIDITY_ENTRY
{
	FILETIME						TimeStamp;
	CEP_REQUEST_ENTRY				*pRequestEntry;
	_CEP_REQUEST_VALIDITY_ENTRY		*pNext;
	_CEP_REQUEST_VALIDITY_ENTRY		*pPrevious;
}CEP_REQUEST_VALIDITY_ENTRY;   



//-----------------------------------------------------------------------
//  CEP_REQUEST_TABLE_INFO
//
//------------------------------------------------------------------------
	
typedef struct _CEP_REQUEST_TABLE_INFO
{
	CEP_REQUEST_ENTRY				*rgRequestEntry[CEP_HASH_TABLE_SIZE];	//the hash table
	CEP_REQUEST_VALIDITY_ENTRY		*pTimeOld;									//the list of hash entry with its timestamp
	CEP_REQUEST_VALIDITY_ENTRY		*pTimeNew;
}CEP_REQUEST_TABLE_INFO;


//
//  The defines for CA and RA message
//

//-----------------------------------------------------------------------
//  CEP_CA_INFO
//
//------------------------------------------------------------------------
typedef struct _CEP_CA_INFO
{
	BSTR			bstrCAMachine;
	BSTR			bstrCAName;
	BSTR			bstrCAConfig;
	BSTR			bstrDSName;
	LPWSTR			pwszCAHash;
	HCRYPTPROV		hProv;
	BOOL			fEnterpriseCA;
	ICertRequest	*pICertRequest;
	LPWSTR			pwszTemplateSig;
	LPWSTR			pwszTemplateEnt;
}CEP_CA_INFO;

//-----------------------------------------------------------------------
//  CEP_RA_INFO
//
//------------------------------------------------------------------------
typedef struct _CEP_RA_INFO
{
	HCRYPTPROV		hRAProv;
	DWORD			dwKeySpec;
	PCCERT_CONTEXT	pRACert;
	PCCERT_CONTEXT	pRASign;
	BOOL			fFree;
	HCRYPTPROV		hSignProv;
	DWORD			dwSignKeySpec;
	BOOL			fSignFree;
	DWORD			dwRefreshDays;
	BOOL			fPassword;
}CEP_RA_INFO;

//-----------------------------------------------------------------------
//  CEP_MESSAGE_INFO
//
//------------------------------------------------------------------------
typedef struct _CEP_MESSAGE_INFO
{
	CERT_BLOB			TransactionID;	 //internally a string
	DWORD				dwMessageType;
	DWORD				dwStatus;
	DWORD				dwErrorInfo;
	CERT_BLOB			SenderNonce;
	CERT_BLOB			RecipientNonce;
	CERT_BLOB			SerialNumber;
	PCCERT_CONTEXT		pSigningCert;
}CEP_MESSAGE_INFO;


//-----------------------------------------------------------------------
//
//  Function prototypes
//
//------------------------------------------------------------------------
BOOL	WINAPI	InitRequestTable();

BOOL	WINAPI  ReleaseRequestTable();

BOOL	WINAPI	CEPRequestRetrieveRequestIDFromHash(BYTE			*pbHash, 
													   DWORD	*pdwRequestID);

BOOL	WINAPI	CEPRequestAddHashAndRequestID(BYTE		*pbHash, 
												DWORD	dwRequestID);

BOOL	WINAPI	InitPasswordTable();

BOOL	WINAPI  ReleasePasswordTable();

BOOL	WINAPI	CEPAddPasswordToTable(LPWSTR	pwszPassword);

BOOL	WINAPI	CEPVerifyPasswordAndDeleteFromTable(LPWSTR	pwszPassword, DWORD dwUsage);

BOOL	InitHashTable();

BOOL	ReleaseHashTable();

BOOL	GetRAInfo(CEP_RA_INFO	*pRAInfo);

BOOL	GetCACertFromInfo(CEP_CA_INFO	*pCAInfo, HCERTSTORE *pHCACertStore);

BOOL	InitCAInformation(CEP_CA_INFO	*pCAInfo);

BOOL	FreeCAInformation(CEP_CA_INFO	*pCAInfo);

BOOL	FreeRAInformation(CEP_RA_INFO	*pRAInfo);

LPSTR	GetTagValue(LPSTR szString, LPSTR szTag);

BOOL	OperationGetCACert(HCERTSTORE		hCACertStore,
							LPSTR			szMsg, 
							BYTE			**ppbData, 
							DWORD			*pcbData);

BOOL	OperationGetPKI(	CEP_RA_INFO		*pRAInfo,
							CEP_CA_INFO		*pCAInfo,
							LPSTR			szMsg, 
							BYTE			**ppbData, 
							DWORD			*pcbData);

BOOL	WINAPI GetSerialNumberFromBlob(BYTE *pbEncoded, 
										DWORD cbEncoded, 
										CRYPT_INTEGER_BLOB *pSerialNumber);

BOOL	GetReturnInfoAndContent(CEP_RA_INFO		*pRAInfo,	
							CEP_CA_INFO			*pCAInfo,
							LPSTR				szMsg, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo);

BOOL WINAPI DecryptMsg(CEP_RA_INFO		*pRAInfo, 
					   BYTE				*pbReqEnv, 
					   DWORD			cbReqEnv, 
					   BYTE				**ppbReqDecrypt, 
					   DWORD			*pcbReqDecrypt);



BOOL	WINAPI	GetContentFromPKCS7(BYTE				*pbMessage,
									DWORD				cbMessage,
									BYTE				**ppbContent,
									DWORD				*pbContent,
									CEP_MESSAGE_INFO	*pMsgInfo);

void	WINAPI	FreeMessageInfo(CEP_MESSAGE_INFO		*pMsgInfo);


BOOL	WINAPI	AllocAndCopyBlob(CERT_BLOB	*pDestBlob,
							 CERT_BLOB	*pSrcBlob);


BOOL	WINAPI	CEPAllocAndDecode(	LPCSTR	lpszStructType,
									BYTE	*pbEncoded,
									DWORD	cbEncoded,
									void	**ppb,
									DWORD	*pcb); 

BOOL WINAPI	CEPRetrievePasswordFromRequest(BYTE		*pbRequest, 
										   DWORD	cbRequest, 
										   LPWSTR	*ppwszPassword,
										   DWORD	*pdwUsage);

BOOL WINAPI AltNameExist(BYTE *pbRequest, DWORD cbRequest);

BOOL WINAPI SameCert(CERT_INFO *pCertInfoOne, CERT_INFO *pCertInfoTwo);

BOOL WINAPI SameBlob(CRYPT_INTEGER_BLOB *pBlobOne, CRYPT_INTEGER_BLOB *pBlobTwo);

BOOL EnvelopData(PCCERT_CONTEXT	pSigningCert, 
				 BYTE			*pbContent, 
				 DWORD			cbContent,
				 BYTE			**ppbEnvelop, 
				 DWORD			*pcbEnvelop);

BOOL CEPHashGetRequestID(	DWORD		dwRefreshDays,
				CERT_BLOB *pTrasactionID, 
				  DWORD		*pdwRequestID);

BOOL CEPHashMarkTransactionFinished(DWORD	dwRequestID, CERT_BLOB *pTransactionID);

BOOL CEPHashAddRequestAndTransaction(DWORD dwRefreshDays, 
									 DWORD	dwRequestID, 
									 CERT_BLOB *pTransactionID);

BOOL CEPHashIsCurrentTimeEntry(FILETIME *pTimeStamp, DWORD dwRefreshDays, DWORD dwMinutes);


BOOL WINAPI ProcessGetCRL(CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo);

BOOL WINAPI ProcessGetCert(CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo);

BOOL	ProcessCertInitial(	DWORD				dwRefreshDays,
						    CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo);

BOOL	ProcessCertRequest(	DWORD				dwRefreshDays,
						    BOOL				fPassword,
						    PCCERT_CONTEXT		pRAEncrypt,
						    PCCERT_CONTEXT		pRACert,
							CEP_CA_INFO			*pCAInfo,
							BYTE				*pbRequest,
							DWORD				cbRequest, 
							BYTE				**ppbData, 
							DWORD				*pcbData,
							CEP_MESSAGE_INFO	*pMsgInfo);



BOOL PackageBlobToPKCS7(DWORD	dwCEP_Context,
						BYTE	*pbEncoded, 
						DWORD	cbEncoded, 
						BYTE	**ppbData, 
						DWORD	*pcbData);


BOOL GenerateSenderNonce(CRYPT_INTEGER_BLOB *pBlob);

BOOL SignData(CEP_MESSAGE_INFO		*pMsgInfo, 
			  CEP_RA_INFO			*pRAInfo, 
			  BYTE					*pbEnvelop, 
			  DWORD					cbEnvelop, 
			  BYTE					**ppbData, 
			  DWORD					*pcbData);

BOOL	CEPAllocAndEncodeName(DWORD	dwValueType,
							BYTE	*pbData,
							DWORD	cbData,
							BYTE	**ppbEncoded,
							DWORD	*pcbEncoded);


BOOL	CEPAllocAndEncodeDword(DWORD	dwValueType,
							DWORD	dwData,
							BYTE	**ppbEncoded,
							DWORD	*pcbEncoded);


BOOL WINAPI CEPAllocAndEncode(LPCSTR lpszStructType,
							void	*pStructInfo,
							BYTE	**ppbEncoded,
							DWORD	*pcbEncoded);


BOOL WINAPI AddAltNameInRequest(PCCERT_CONTEXT	pRACert, 
								BYTE			*pb10, 
								DWORD			cb10, 
								LPWSTR			pwszDNS,
								CRYPT_DATA_BLOB	*pIPAddress,
								BYTE			**ppb7, 
								DWORD			*pcb7);

BOOL WINAPI CreateAltNameExtenions(LPWSTR		pwszDNS,
							   CRYPT_DATA_BLOB	*pIPAddress,
							   BYTE				**pbExt, 
							   DWORD			*pcbExt);

BOOL WINAPI	GetAltNameElement(BYTE				*pb10, 
						   DWORD				cb10, 
						   LPWSTR				*ppwszDNS, 
						   CRYPT_DATA_BLOB		*pIPAddress);

BOOL ConvertIPStringToBinary(LPWSTR				pwszIP,
							CRYPT_DATA_BLOB		*pIPAddress);

BOOL WINAPI	AllocAndCopyString(CERT_BLOB	*pDestBlob,
							LPSTR		psz);

BOOL WINAPI RetrieveContextFromSerialNumber(CEP_CA_INFO	*pCAInfo, 
										CERT_BLOB		*pSerialNumber, 
										PCCERT_CONTEXT	*ppCertContext);

BOOL WINAPI GetConfigInfo(DWORD *pdwRefreshDays, BOOL *pfPassword);

BOOL CEPGetTokenFromPKCS10(BOOL					fPassword,
						   PCCERT_CONTEXT		pRAEncrypt,
						   BYTE					*pbRequest, 
						   DWORD				cbRequest, 
						   HANDLE				*phToken);

BOOL GetLogonInfoFromValue(PCCERT_CONTEXT		pRAEncrypt,
						   LPWSTR				pwszString,
						   LPWSTR				*ppwszDomain,
						   LPWSTR				*ppwszUser,
						   LPWSTR				*ppwszPassword);

BOOL CEPDecryptPassword(PCCERT_CONTEXT		pRAEncrypt,
						LPWSTR				pwszEncrypt,
						LPWSTR				*ppwszDecrypt);


BOOL WINAPI IsAnonymousAccess(EXTENSION_CONTROL_BLOCK	*pECB);

HRESULT WINAPI CheckACLOnCertTemplate(BOOL fSelf, LPWSTR pwszCAName, LPWSTR pwszCertType);

BOOL WINAPI OperationDisplayAccessHTML(BYTE **ppbData, DWORD *pcbData);

BOOL WINAPI OperationGetDisplayInfoForCEP(LPWSTR		pwszCAHash, 
										  HCRYPTPROV	hProv,
										  BOOL			fPassword, 
										  BYTE			**ppbData, 
										  DWORD			*pcbData);
BOOL WINAPI LoadIDToTemplate(UINT				idsMsg, 										  
							BYTE				**ppbData, 
							DWORD				*pcbData);

BOOL WINAPI LoadWZToTemplate(LPWSTR				pwsz, 										  
							BYTE				**ppbData, 
							DWORD				*pcbData);


BOOL WINAPI	FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...);

BOOL WINAPI CopyWZToBuffer(	LPWSTR				pwszData, 										  
							BYTE				**ppbData, 
							DWORD				*pcbData);

BOOL WINAPI LoadIDAndHRToTempalte(UINT			idsMsg, 
								  HRESULT		hr, 
								  BYTE			**ppbData, 
								  DWORD			*pcbData);

BOOL WINAPI	ConvertByteToWstr(BYTE			*pbData, 
							  DWORD			cbData, 
							  LPWSTR		*ppwsz, 
							  BOOL			fSpace);

BOOL	WINAPI	CEPGetCertFromPKCS10(CEP_CA_INFO	*pCAInfo,
							 BYTE				*pbRequest, 
							 DWORD				cbRequest, 
							 BYTE				**ppbData, 
							 DWORD				*pcbData,							 	
							 CEP_MESSAGE_INFO	*pMsgInfo);

void	WINAPI	LogSCEPEvent(IN DWORD    dwLogLevel,
							IN BOOL     fError,
							IN HRESULT  hr,
							IN DWORD    dwEventId,
							IN DWORD    dwParamCount,
							...
							);




#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif  //CEP_PRIVATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\mscep\mscep.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       mscep.cpp
//
//  Contents:   Cisco enrollment protocal implementation 
//              
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

CRITICAL_SECTION			CriticalSec;
CRITICAL_SECTION			PasswordCriticalSec;

static BOOL					g_fInit=FALSE;	
static BOOL					g_fRelease=FALSE;

HCERTSTORE					g_HCACertStore=NULL;
CEP_RA_INFO					g_RAInfo;
CEP_CA_INFO					g_CAInfo={NULL, NULL, NULL, NULL, NULL, FALSE, NULL};

HCRYPTASN1MODULE			ICM_hAsn1Module=NULL;
HMODULE						g_hMSCEPModule=NULL;

HANDLE						g_hEventSource = NULL;  

ULARGE_INTEGER				g_ftRAExpiration;
ULARGE_INTEGER				g_ftRACloseToExpire;
ULARGE_INTEGER				g_ftRAWarn;
LPWSTR						g_pwszComputerName=NULL;


//-----------------------------------------------------------------------------------
//
//	DllMain
//
//------------------------------------------------------------------------------------
BOOL WINAPI DllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{
	BOOL	fResult = TRUE;

	//we use the try{}except here to prevent malicous requests
   __try
   {

        switch(fdwReason) 
	 {

		case DLL_PROCESS_ATTACH:

				g_hMSCEPModule=hInstDLL;

				InitializeCriticalSection(&CriticalSec);

				InitializeCriticalSection(&PasswordCriticalSec);

				CEPASN_Module_Startup();

				if (0 == (ICM_hAsn1Module = I_CryptInstallAsn1Module(
						CEPASN_Module, 0, NULL)))
					fResult = FALSE;

				g_hEventSource = RegisterEventSourceW(NULL, MSCEP_EVENT_LOG);

			break;

		case DLL_PROCESS_DETACH:

				if (g_hEventSource)
					DeregisterEventSource(g_hEventSource);  

				I_CryptUninstallAsn1Module(ICM_hAsn1Module);

				CEPASN_Module_Cleanup();

				DeleteCriticalSection(&PasswordCriticalSec);

				DeleteCriticalSection(&CriticalSec);

			break;
        }
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
      // return failure
      fResult = FALSE;
   }
			  
    return(fResult);
}

//-----------------------------------------------------------------------------------
//
//	DllRegisterServer
//
//------------------------------------------------------------------------------------
STDAPI DllRegisterServer()
{
    HRESULT hr = S_OK;

    return	hr;
}

//-----------------------------------------------------------------------------------
//
//	DllUnregisterServer
//
//------------------------------------------------------------------------------------
STDAPI DllUnregisterServer()
{
    HRESULT hr = S_OK;

    return hr;
}
  
//-----------------------------------------------------------------------------------
//
//	DecodeIssuerAndSerialNumber
//	
//	Decoding routine to decode a IssuerAndSerialNumber blob and return the 
//	SerialNumber 
//
//------------------------------------------------------------------------------------
BOOL WINAPI GetSerialNumberFromBlob(BYTE *pbEncoded, 
									DWORD cbEncoded, 
									CRYPT_INTEGER_BLOB *pSerialNumber)
{
	BOOL					fResult = FALSE;
	ASN1error_e				Asn1Err;
    ASN1decoding_t			pDec;

	IssuerAndSerialNumber   *pisn=NULL;              

	if((!pSerialNumber) || (!pbEncoded))
		goto InvalidArgErr;

	pDec = I_CryptGetAsn1Decoder(ICM_hAsn1Module);

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&pisn,
            IssuerAndSerialNumber_PDU,
            pbEncoded,
            cbEncoded)))
        goto DecodeIssuerAndSerialNumberError;

	//we now reverse the byte
	PkiAsn1ReverseBytes(pisn->serialNumber.value,
						pisn->serialNumber.length);

	pSerialNumber->cbData=pisn->serialNumber.length;
	if(!(pSerialNumber->pbData = (BYTE *)malloc(pSerialNumber->cbData)))
		goto MemoryErr;

	memcpy(pSerialNumber->pbData, pisn->serialNumber.value, pSerialNumber->cbData); 

	fResult = TRUE;

CommonReturn:

	if(pisn)
		PkiAsn1FreeInfo(pDec, IssuerAndSerialNumber_PDU, pisn);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
SET_ERROR_VAR(DecodeIssuerAndSerialNumberError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(MemoryErr, E_OUTOFMEMORY);
}



//-----------------------------------------------------------------------------------
//
//	GetExtensionVersion
//	
//	IIS initialization code
//
//------------------------------------------------------------------------------------
BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO  *pVer)
{
	BOOL			fResult = FALSE;
	HRESULT			hr = S_OK;
	BOOL			fOleInit=FALSE;
	DWORD			dwSize=0;

	//copy the version/description
    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR,
                                         HSE_VERSION_MAJOR );
    lstrcpyn( pVer->lpszExtensionDesc,
              "This is the implementation of cisco enrollment protocol",
               HSE_MAX_EXT_DLL_NAME_LEN);

	if(g_fInit)
	{
		LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_LOADED, 0);
		return TRUE;
	}

	EnterCriticalSection(&CriticalSec);
	
	//retest in the case of lock: the second thread has passed the 1st test 
	//and was waiting for the criticcal section
	if(g_fInit)
	{	
		LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_LOADED, 0);
		LeaveCriticalSection(&CriticalSec);
		return TRUE;
	}

	memset(&g_ftRAExpiration, 0, sizeof(ULARGE_INTEGER));
	memset(&g_ftRACloseToExpire, 0, sizeof(ULARGE_INTEGER));
	memset(&g_ftRAWarn, 0, sizeof(ULARGE_INTEGER));

	//get the computer name
	dwSize=0;

	GetComputerNameExW(ComputerNamePhysicalDnsHostname,
						NULL,
						&dwSize);

	g_pwszComputerName=(LPWSTR)malloc(dwSize * sizeof(WCHAR));

	if(NULL==g_pwszComputerName)
		goto InitErr;
	
	if(!GetComputerNameExW(ComputerNamePhysicalDnsHostname,
						g_pwszComputerName,
						&dwSize))
		goto InitErr;

	//initialize the state information
	if(FAILED(hr=CoInitialize(NULL)))
		goto OleErr;

	fOleInit=TRUE;

	if(!InitCAInformation(&g_CAInfo))
	{
		LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAILED_CA_INFO, 1, g_pwszComputerName);
		goto InitErr;
	}

	if(!GetCACertFromInfo(&g_CAInfo, &g_HCACertStore))
	{
		LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAILED_CA_CERT, 1, g_pwszComputerName);
		goto InitErr;
	}

	if(!GetRAInfo(&g_RAInfo))
	{
		LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAILED_RA_CERT, 1, g_pwszComputerName);
		goto InitErr;
	}

	//we add the RA and CA cert to the g_hCACertStore
	if(!CertAddCertificateContextToStore(g_HCACertStore,
										g_RAInfo.pRACert,
										CERT_STORE_ADD_NEW,
										NULL))
		goto InitErr;
			
	if(!CertAddCertificateContextToStore(g_HCACertStore,
										g_RAInfo.pRASign,
										CERT_STORE_ADD_NEW,
										NULL))
		goto InitErr;

	if(!InitHashTable())
		goto InitErr;

	if(!InitPasswordTable())
		goto InitErr;

	if(!InitRequestTable())
		goto InitErr;

	//copy the time when the RAs will expire
	if( 1 == CompareFileTime(&((g_RAInfo.pRACert->pCertInfo)->NotAfter), &((g_RAInfo.pRASign->pCertInfo)->NotAfter)))
	{
		g_ftRAExpiration.QuadPart=((ULARGE_INTEGER UNALIGNED *)&((g_RAInfo.pRASign->pCertInfo)->NotAfter))->QuadPart;
	}
	else
		g_ftRAExpiration.QuadPart=((ULARGE_INTEGER UNALIGNED *)&((g_RAInfo.pRACert->pCertInfo)->NotAfter))->QuadPart;

	//start to give out warnings two weeks before the RA Certificates expire
	g_ftRACloseToExpire.QuadPart=g_ftRAExpiration.QuadPart-Int32x32To64(FILETIME_TICKS_PER_SECOND, OVERLAP_TWO_WEEKS);

    fResult=TRUE;

CommonReturn:

	g_fInit=fResult;

	if(fResult)
	{
		LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_LOADED, 0);
	}
	else
	{
		LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_FAILED_TO_LOAD, 0);
	}

	LeaveCriticalSection(&CriticalSec);

	return fResult;

ErrorReturn:

	//clean up the global data.
	if(g_HCACertStore)
	{
		CertCloseStore(g_HCACertStore, 0);
		g_HCACertStore=NULL;
	}

	FreeRAInformation(&g_RAInfo);

	FreeCAInformation(&g_CAInfo);

	if(fOleInit)
		CoUninitialize();

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(InitErr);
SET_ERROR_VAR(OleErr, hr);
}


//--------------------------------------------------------------------
//
//  Verify if the user is a member of the BUILTIN\Administrators group
//
//--------------------------------------------------------------------
BOOL  WINAPI IsUserInLocalAdminGroup()
{
    BOOL                        bIsMember=FALSE;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority=SECURITY_NT_AUTHORITY;
    HANDLE		         hThread=NULL;	//no need to close

    SID                         * psidLocalAdmins=NULL;
    HANDLE	                 hToken=NULL;
 
    hThread=GetCurrentThread();

    if(NULL == hThread)
        goto error;

    //we want to check with the impersonation token
    if(!OpenThreadToken(hThread,
                             TOKEN_IMPERSONATE | TOKEN_QUERY,
                             FALSE,
                             &hToken))
        goto error;

     // get the well-known SID
    if (!AllocateAndInitializeSid(&siaNtAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, (void **)&psidLocalAdmins))
        goto error;

    // check for membership
    if (!CheckTokenMembership(hToken, psidLocalAdmins, &bIsMember)) 
    {
        bIsMember=FALSE;
        goto error;
    }

error:

    if(hToken)
    {
        CloseHandle(hToken);         
    }

    if (NULL!=psidLocalAdmins) 
    {
        FreeSid(psidLocalAdmins);
    }

    return bIsMember;
}

//-----------------------------------------------------------------------------------
//
//	CEPPasswordAllowALL
//	
//	Detect if the registry to allow password to everyone is enabled for 
//  standalone CA ONLY.
//
//------------------------------------------------------------------------------------
BOOL  WINAPI   CEPPasswordAllowALL()
{
    BOOL        fAllowALL=FALSE;
    DWORD       cbData=0;
    DWORD	 dwData=0;
    DWORD       dwType=0;

    HKEY        hKey=NULL;

    if(ERROR_SUCCESS == RegOpenKeyExU(
		     HKEY_LOCAL_MACHINE,
                    MSCEP_LOCATION,
                    0,
                    KEY_READ,
                    &hKey))
    {
        cbData=sizeof(dwData);

        if(ERROR_SUCCESS == RegQueryValueExU(
                        hKey,
                        MSCEP_KEY_ALLOW_ALL,
                        NULL,
                        &dwType,
                        (BYTE *)&dwData,
                        &cbData))
        {
            if (REG_DWORD == dwType)
            {
               if(0 != dwData)
               {
                   fAllowALL=TRUE;
               }
            }
        }
    }

    if(hKey)
       RegCloseKey(hKey);

     return fAllowALL;
}


//-----------------------------------------------------------------------------------
//
//	GetExtensionVersion.
//	
//	IIS load/initialization code.
//
//------------------------------------------------------------------------------------
DWORD WINAPI   HttpExtensionProc(EXTENSION_CONTROL_BLOCK	*pECB)
{
	DWORD	dwHttp = HSE_STATUS_ERROR;
	LPSTR	pszTagValue=NULL;
	LPSTR	pszMsgValue=NULL;
	DWORD	dwOpType = 0;
	DWORD	cbData=0;
       DWORD   cbFree=0;
    CHAR    szBuff[1024];
    DWORD   cbBuff;
	LPSTR	pszContentType=NULL;
	DWORD	dwException=0;
	BOOL	f401Response=FALSE;
    ULARGE_INTEGER	ftTime;
	HANDLE	hThread=NULL;	//no need to close

	BYTE	*pbData=NULL;
	HANDLE	hToken=NULL;
	//we use the try{}except here to prevent malicous requests
 __try {

	EnterCriticalSection(&CriticalSec);

	if(NULL==pECB)
		goto InvalidArgErr;

	if(NULL==(pECB->lpszQueryString))
		goto InvalidArgErr;

	//user are asking for the CEP information/password
	if(0 == strlen(pECB->lpszQueryString))
	{
		pszContentType=CONTENT_TYPE_HTML;

		if(g_RAInfo.fPassword)
		{
			if(IsAnonymousAccess(pECB))
			{
				//LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_NO_PASSWORD_ANONYMOUS, 1, g_pwszComputerName);
				f401Response=TRUE;
			}
			else
			{
				if(g_CAInfo.fEnterpriseCA)
				{
                                   //we want to check with the impersonation token
                                   if(S_OK != CheckACLOnCertTemplate(TRUE, g_CAInfo.bstrDSName, wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE))
                                   {
                                       LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_NO_PASSWORD_TEMPLATE, 1, g_pwszComputerName);
                                       //return HTML error messages
                                       if(!OperationDisplayAccessHTML(&pbData, &cbData))
                                               goto OperationErr;

                                       if(NULL == pbData)
                                           goto OperationErr;
                                   }
				}
                               else
                               {
                                   if(!CEPPasswordAllowALL())
                                   {
                                       if(FALSE == IsUserInLocalAdminGroup())
                                       {
                                           LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_NO_PASSWORD_STANDALONE, 1, g_pwszComputerName);
                                           //return HTML error messages
                                           if(!OperationDisplayAccessHTML(&pbData, &cbData))
                                                   goto OperationErr;

                                           if(NULL == pbData)
                                               goto OperationErr;
                                       }
                                   }
                               }
			}
		}
	
		if((FALSE==f401Response) && (NULL==pbData))
		{
			if(!OperationGetDisplayInfoForCEP(g_CAInfo.pwszCAHash,
											  g_CAInfo.hProv,
												g_RAInfo.fPassword, 
												&pbData, 
												&cbData))
				goto OperationErr;
		}
	}
	else
	{

		hThread=GetCurrentThread();
		
		if(NULL != hThread)
		{
			if(OpenThreadToken(hThread,
								TOKEN_IMPERSONATE | TOKEN_QUERY,
								FALSE,
								&hToken))
			{
				if(hToken)
				{
					//no need to check for return here.  If this failed, just go on
					RevertToSelf();
				}
			}
		}

		//get the operation
		if(NULL==(pszTagValue=GetTagValue(pECB->lpszQueryString, GET_TAG_OP)))
		{			
			LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_NO_OPERATION, 1, g_pwszComputerName);
			goto InvalidArgErr;
		}

		if(strlen(pszTagValue) > strlen(GET_OP_CA))
		{
			if(0==_strnicmp(pszTagValue, GET_OP_CA, strlen(GET_OP_CA)))
			{
				dwOpType = OPERATION_GET_CACERT;
				pszTagValue += strlen(GET_OP_CA);
			}
		}

		if( 0 == dwOpType)
		{
			if(strlen(pszTagValue) > strlen(GET_OP_PKI))
			{
				if(0==_strnicmp(pszTagValue, GET_OP_PKI, strlen(GET_OP_PKI)))
				{
					dwOpType = OPERATION_GET_PKI;
					pszTagValue += strlen(GET_OP_PKI);
				}
			}
		}
		
		if(0 == dwOpType)
		{
			LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_NO_OPERATION, 1, g_pwszComputerName);
			goto InvalidArgErr;
		}

		//get the message value
		if(NULL==(pszMsgValue=GetTagValue(pszTagValue, GET_TAG_MSG)))
		{
			LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_NO_MESSAGE, 1, g_pwszComputerName);
			goto InvalidArgErr;
		}


		//check if the RA certificates are close to expire
		GetSystemTimeAsFileTime((LPFILETIME)&ftTime);

		if(ftTime.QuadPart >= g_ftRAExpiration.QuadPart)
		{
			//RA Certificate has expired
			LogSCEPEvent(0, FALSE, S_OK, EVENT_SCEP_RA_EXPIRE, 1, g_pwszComputerName);
		}
		else
		{
			if(ftTime.QuadPart >= g_ftRACloseToExpire.QuadPart)
			{
				if( (0 == g_ftRAWarn.QuadPart) || (ftTime.QuadPart >= g_ftRAWarn.QuadPart))
				{
					//RA Certificate is close to expire
					LogSCEPEvent(0, FALSE, S_OK, EVENT_SCEP_RA_CLOSE_TO_EXPIRE, 1, g_pwszComputerName);

					//only give out an warning once an hour
					g_ftRAWarn.QuadPart = ftTime.QuadPart + Int32x32To64(FILETIME_TICKS_PER_SECOND, OVERLAP_ONE_HOUR);
				}
			}
		}

		//get the return blob
		switch(dwOpType)
		{
			case OPERATION_GET_CACERT:
					
					if(!OperationGetCACert(g_HCACertStore,
											pszMsgValue, 
											&pbData, 
											&cbData))
					{
						LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_MSCEP_GET_CA_CERT_FAILED, 1, g_pwszComputerName);
						goto OperationErr;
					}
	   				
					pszContentType = CONTENT_TYPE_CA_RA;

				break;

			case OPERATION_GET_PKI:

					if(!OperationGetPKI(
										&g_RAInfo,
										&g_CAInfo,
										pszMsgValue, 
										&pbData, 
										&cbData))
						goto OperationErr;

					pszContentType = CONTENT_TYPE_PKI;

				break;

			default:
					goto InvalidArgErr;
				break;
		}
	}

	if(f401Response)
	{
		if(!(pECB->ServerSupportFunction(pECB->ConnID,HSE_REQ_SEND_RESPONSE_HEADER,
							  ACCESS_MESSAGE,  
							  NULL, 
							  NULL)))
		{
			LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_SCEP_SERVER_SUPPORT, 1, g_pwszComputerName);
			goto WriteErr;
		}

		dwHttp = HSE_STATUS_ERROR;
	}
	else
	{

		//write the header and the real data
		pECB->dwHttpStatusCode = 200;

		// write headers
		sprintf(szBuff, "Content-Length: %d\r\nContent-Type: %hs\r\n\r\n", cbData, pszContentType);
		cbBuff = strlen(szBuff);

		if(!(pECB->ServerSupportFunction(pECB->ConnID, HSE_REQ_SEND_RESPONSE_HEADER, NULL, &cbBuff, (LPDWORD)szBuff)))
		{
			LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_SCEP_SERVER_SUPPORT, 1, g_pwszComputerName);
			goto WriteErr;
		}

		// write users data
               cbFree=cbData;

		if(!(pECB->WriteClient(pECB->ConnID, pbData, &cbData, HSE_IO_SYNC)))
		{
			LogSCEPEvent(0, TRUE, HRESULT_FROM_WIN32(GetLastError()), EVENT_SCEP_WRITE_DATA, 1, g_pwszComputerName);
			goto WriteErr;
		}

		dwHttp = HSE_STATUS_SUCCESS;

	}

 } __except(EXCEPTION_EXECUTE_HANDLER)
 {
    dwException = GetExceptionCode();
    goto ExceptionErr;
 }

CommonReturn:

	if(pbData)
       {
           if(cbFree)
           {
               SecureZeroMemory(pbData, cbFree);
           }

           free(pbData);
       }

	if(hToken)
	{
		SetThreadToken(&hThread, hToken);
		CloseHandle(hToken); 
	}

	LeaveCriticalSection(&CriticalSec);

	return dwHttp;

ErrorReturn:

	dwHttp = HSE_STATUS_ERROR;
	goto CommonReturn;

SET_ERROR(InvalidArgErr, E_INVALIDARG);
TRACE_ERROR(OperationErr);
TRACE_ERROR(WriteErr);
SET_ERROR_VAR(ExceptionErr, dwException);
}



//-----------------------------------------------------------------------------------
//
//	TerminateExtension.
//	
//	IIS unload/cleanup code
//
//------------------------------------------------------------------------------------
BOOL  WINAPI   TerminateExtension(DWORD dwFlags)
{
	if(g_fRelease)
	{
		LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_UNLOADED, 0);
		return TRUE;
	}

	EnterCriticalSection(&CriticalSec);
	
	//retest in the case of lock: the second thread has passed the 1st test 
	//and was waiting for the criticcal section
	if(g_fRelease)
	{	
		LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_UNLOADED, 0);
		LeaveCriticalSection(&CriticalSec);
		return TRUE;
	}

	if(g_pwszComputerName)
	{
		free(g_pwszComputerName);
		g_pwszComputerName=NULL;
	}

	ReleaseRequestTable();

	ReleasePasswordTable();

	ReleaseHashTable();

	if(g_HCACertStore)
	{
		CertCloseStore(g_HCACertStore, 0);
		g_HCACertStore=NULL;
	}

	FreeRAInformation(&g_RAInfo);

	FreeCAInformation(&g_CAInfo);

	//only if fInit is TRUE, that we have an outstanding CoInitialize() call
	if(g_fInit)
		CoUninitialize();

	g_fRelease=TRUE;

	LogSCEPEvent(0, FALSE, S_OK, EVENT_MSCEP_UNLOADED, 0);

	LeaveCriticalSection(&CriticalSec);

	//we always allow unload
	return TRUE;
}

//***********************************************************************************
//
//	Helper functions for the password table
//
//***********************************************************************************
//-----------------------------------------------------------------------------------
//
//	CEPObtainPassword
//
//------------------------------------------------------------------------------------
BOOL WINAPI		CEPObtainPassword(HCRYPTPROV	hProv,
								  LPWSTR		*ppwszPassword)
{
	BYTE		pbData[CEP_PASSWORD_LENGTH];
       BOOL            fResult=FALSE;

	memset(pbData, 0, CEP_PASSWORD_LENGTH);

	if(!CryptGenRandom(hProv, CEP_PASSWORD_LENGTH, pbData))
		return FALSE;

	fResult=ConvertByteToWstr(pbData, CEP_PASSWORD_LENGTH, ppwszPassword, FALSE);

       SecureZeroMemory(pbData, CEP_PASSWORD_LENGTH);

       return fResult;
}



//***********************************************************************************
//
//	Helper functions for ISAPI dll entry points
//
//***********************************************************************************
//-----------------------------------------------------------------------------------
//
//	IsAnonymousAccess
//
//------------------------------------------------------------------------------------
BOOL WINAPI IsAnonymousAccess(EXTENSION_CONTROL_BLOCK	*pECB)
{
	BOOL	fAccess=TRUE;
	DWORD	dwSize=0;

	BYTE	*pbData=NULL;
	
	pECB->GetServerVariable(pECB->ConnID,     
					"REMOTE_USER", 
					NULL,    
					&dwSize);

	if(0==dwSize)
		goto CLEANUP;

	pbData=(BYTE *)malloc(dwSize);

	if(NULL==pbData)
		goto CLEANUP;

	if(!(pECB->GetServerVariable(pECB->ConnID,     
					"REMOTE_USER", 
					pbData,    
					&dwSize)))
		goto CLEANUP;

	if(0 == strlen((LPSTR)pbData))
		goto CLEANUP;

	fAccess=FALSE;

CLEANUP:

	if(pbData)
		free(pbData);

	return fAccess;
}


//-----------------------------------------------------------------------------------
//
//	CheckACLOnCertTemplate
//
//------------------------------------------------------------------------------------
HRESULT WINAPI CheckACLOnCertTemplate(BOOL fSelf, LPWSTR pwszCAName, LPWSTR pwszCertType)
{
	HRESULT		hr=S_OK;
	HANDLE		hThread=NULL;	//no need to close
	DWORD		dwIndex=0;

	HCAINFO		hCAInfo=NULL;
	LPWSTR		*ppwszList=NULL;
	HCERTTYPE	hCertType=NULL;
	HANDLE		hToken=NULL;

	if((NULL == pwszCAName) || (NULL == pwszCertType))
		return E_INVALIDARG;

	//first of all, we need to revert to ourselves if
	//we are under impersonation and delegation is not 
	//supported by default, thus we can not access the DS.
	//we are ganranteed to have a thread token under impersonation
	hThread=GetCurrentThread();
	
	if(NULL == hThread)
		return HRESULT_FROM_WIN32(GetLastError());


	if(OpenThreadToken(hThread,
							TOKEN_IMPERSONATE | TOKEN_QUERY,
							FALSE,
							&hToken))
	{
		if(hToken)
		{
			RevertToSelf();
		}
	}

	if(S_OK != (hr=CAFindCertTypeByName(pwszCertType, 
										NULL, 
										CT_ENUM_MACHINE_TYPES | CT_FLAG_NO_CACHE_LOOKUP | CT_FIND_LOCAL_SYSTEM, 
										&hCertType)))
		goto error;

	//fSelf means we want to check with the impersonation token
	if(TRUE == fSelf)
	{
		if(S_OK != (hr=CACertTypeAccessCheck(hCertType, hToken)))
			goto error;
	}
	else
	{
		if(S_OK != (hr=CACertTypeAccessCheck(hCertType, NULL)))
			goto error;
	}

	if(S_OK != (hr=CAFindByName(
					pwszCAName,
					NULL,
					CA_FIND_LOCAL_SYSTEM,
					&hCAInfo)))
		goto error;


	if(S_OK != (hr= CAGetCAProperty(
					hCAInfo,
					CA_PROP_CERT_TYPES,
					&ppwszList)))
		goto error;


	if((NULL == ppwszList) || (NULL == ppwszList[0]))
	{
		hr=E_FAIL;
		goto error;
	}

	while(ppwszList[dwIndex])
	{
		if(0 == _wcsicmp(pwszCertType, ppwszList[dwIndex]))
		{
			break;
		}

		dwIndex++;
	}

	if(NULL == ppwszList[dwIndex])
	{
		hr=E_FAIL;
		goto error;
	}

	hr=S_OK;

error:
	if(ppwszList)
		CAFreeCAProperty(hCAInfo, ppwszList);

	if(hCAInfo)
		CACloseCA(hCAInfo);

	if(hCertType)
		CACloseCertType(hCertType);

	if(hToken)
	{
		SetThreadToken(&hThread, hToken);
		CloseHandle(hToken); 
	}

	return hr;
}

//-----------------------------------------------------------------------------------
//
//	OperationDisplayAccessHTML
//
//------------------------------------------------------------------------------------
BOOL WINAPI OperationDisplayAccessHTML(BYTE **ppbData, DWORD *pcbData)
{

	return LoadIDToTemplate(IDS_ACCESS_DENIED, 										  
							  ppbData, 
							  pcbData);
}

//-----------------------------------------------------------------------------------
//
//	OperationGetDisplayInfoForCEP
//
//------------------------------------------------------------------------------------
BOOL WINAPI OperationGetDisplayInfoForCEP(LPWSTR		pwszCAHash,
										  HCRYPTPROV	hProv,
										  BOOL			fPassword, 
										  BYTE			**ppbData, 
										  DWORD			*pcbData)
{
	BOOL		fResult=FALSE;
	HRESULT		hr=E_FAIL;
	UINT		idsMsg=IDS_TOO_MANY_PASSWORD;

	LPWSTR		pwszPassword=NULL;
	LPWSTR		pwszText=NULL;

	if(fPassword)
	{
		if(!CEPObtainPassword(hProv, &pwszPassword))
		{
			idsMsg=IDS_FAIL_TO_GET_PASSWORD;
			goto InfoWithLastErrorReturn;
		}

		if(!CEPAddPasswordToTable(pwszPassword))
		{
			if(CRYPT_E_NO_MATCH == GetLastError())
			{
				idsMsg=IDS_TOO_MANY_PASSWORD;
				goto InfoWithIDReturn;
			}
			else
			{
				idsMsg=IDS_FAIL_TO_ADD_PASSWORD;
				goto InfoWithLastErrorReturn;
			}
		}

		if(!FormatMessageUnicode(&pwszText, IDS_CEP_INFO_WITH_PASSWORD, pwszCAHash, 
									pwszPassword, g_dwPasswordValidity))
			goto TraceErr;

	}
	else
	{
		if(!FormatMessageUnicode(&pwszText, IDS_CEP_INFO_NO_PASSWORD, pwszCAHash))
			goto TraceErr;
	}

	fResult=LoadWZToTemplate(pwszText, ppbData, pcbData);

CommonReturn:

	if(pwszText)
       {
           SecureZeroMemory(pwszText, sizeof(WCHAR) * wcslen(pwszText));
           LocalFree((HLOCAL)pwszText);
       }

	if(pwszPassword)
       {
           SecureZeroMemory(pwszPassword, sizeof(WCHAR) * wcslen(pwszPassword));
           free(pwszPassword);
       }

	return fResult;

InfoWithIDReturn:

	fResult=LoadIDToTemplate(idsMsg, ppbData, pcbData);

	goto CommonReturn;	

InfoWithLastErrorReturn:

	hr=HRESULT_FROM_WIN32(GetLastError());

	fResult=LoadIDAndHRToTempalte(idsMsg, hr, ppbData, pcbData);

	goto CommonReturn;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(TraceErr);
}


//-----------------------------------------------------------------------------------
//
//	LoadIDToTemplate
//
//------------------------------------------------------------------------------------
BOOL WINAPI LoadIDToTemplate(UINT				idsMsg, 										  
							BYTE				**ppbData, 
							DWORD				*pcbData)
{
	BOOL	fResult=FALSE;
    WCHAR   wsz[MAX_STRING_SIZE];
	
    if(!LoadStringU(g_hMSCEPModule, idsMsg, wsz, MAX_STRING_SIZE))
		return FALSE;

	return LoadWZToTemplate(wsz, ppbData, pcbData);
} 

//-----------------------------------------------------------------------------------
//
//	LoadIDToTemplate
//
//------------------------------------------------------------------------------------
BOOL WINAPI LoadIDAndHRToTempalte(UINT			idsMsg, 
								  HRESULT		hr, 
								  BYTE			**ppbData, 
								  DWORD			*pcbData)
{
	BOOL	fResult=FALSE; 
	WCHAR	wszUnknownError[50];

	LPWSTR	pwszErrorMsg=NULL;
	LPWSTR	pwszText=NULL;


	if(!FAILED(hr))
		hr=E_FAIL;

    //using W version because this is a NT5 only function call
    if(FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                        (LPWSTR) &pwszErrorMsg,
                        0,
                        NULL))
	{

		if(!FormatMessageUnicode(&pwszText, idsMsg, pwszErrorMsg))
			goto TraceErr;
	}
	else
	{
	
		if(!LoadStringU(g_hMSCEPModule, IDS_ERROR_UNKONWN, wszUnknownError, 50))
			goto TraceErr;

		if(!FormatMessageUnicode(&pwszText, idsMsg, wszUnknownError))
			goto TraceErr;
	}

	fResult=LoadWZToTemplate(pwszText, ppbData, pcbData);

CommonReturn:

 	if(pwszText)
		LocalFree((HLOCAL)pwszText);

	if(pwszErrorMsg)
		LocalFree((HLOCAL)pwszErrorMsg);

	return fResult;

ErrorReturn:

	fResult=FALSE;

	goto CommonReturn;

TRACE_ERROR(TraceErr);
}


//-----------------------------------------------------------------------------------
//
//	LoadWZToTemplate
//
//------------------------------------------------------------------------------------
BOOL WINAPI LoadWZToTemplate(LPWSTR				pwsz, 										  
							BYTE				**ppbData, 
							DWORD				*pcbData)
{
	BOOL	fResult=FALSE;
	
	LPWSTR	pwszHTML=NULL;

	if(!FormatMessageUnicode(&pwszHTML, IDS_HTML_TEMPLATE, pwsz))
		goto TraceErr;

	fResult=CopyWZToBuffer(pwszHTML, ppbData, pcbData);

CommonReturn:

	if(pwszHTML)
		LocalFree((HLOCAL)pwszHTML);

	return fResult;

ErrorReturn:

	fResult=FALSE;

	goto CommonReturn;

TRACE_ERROR(TraceErr);
} 


//-----------------------------------------------------------------------------------
//
//	CopyWZToBuffer
//
//------------------------------------------------------------------------------------
BOOL WINAPI CopyWZToBuffer(	LPWSTR				pwszData, 										  
							BYTE				**ppbData, 
							DWORD				*pcbData)
{
	BOOL	fResult=FALSE;
	DWORD	dwSize=0;

	*ppbData=NULL;
	*pcbData=0;

	dwSize=sizeof(WCHAR) * (wcslen(pwszData) + 1);

	*ppbData=(BYTE *)malloc(dwSize);

	if(NULL==ppbData)
		goto MemoryErr;

	memcpy(*ppbData, pwszData, dwSize);

	*pcbData=dwSize;

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
} 

//------------------------------------------------------------------------
//	   Convert the byte to its Hex presentation.
//
//	   Precondition: byte is less than 15
//
//------------------------------------------------------------------------
ULONG	ByteToHex(BYTE	byte,	LPWSTR	wszZero, LPWSTR wszA)
{
	ULONG	uValue=0;

	if(((ULONG)byte)<=9)
	{
		uValue=((ULONG)byte)+ULONG(*wszZero);	
	}
	else
	{
		uValue=(ULONG)byte-10+ULONG(*wszA);

	}

	return uValue;

}

//--------------------------------------------------------------------------
//
//	  ConvertByteToWstr
//
//		If fSpace is TRUE, we add a space every 2 bytes.
//--------------------------------------------------------------------------
BOOL WINAPI	ConvertByteToWstr(BYTE			*pbData, 
							  DWORD			cbData, 
							  LPWSTR		*ppwsz, 
							  BOOL			fSpace)
{
	BOOL	fResult=FALSE;
	DWORD	dwBufferSize=0;
	DWORD	dwBufferIndex=0;
	DWORD	dwEncodedIndex=0;
	LPWSTR	pwszSpace=L" ";
	LPWSTR	pwszZero=L"0";
	LPWSTR	pwszA=L"A";

	if(!pbData || !ppwsz)
		goto InvalidArgErr;

	//calculate the memory needed, in bytes
	//we need 3 wchars per byte, along with the NULL terminator
	dwBufferSize=sizeof(WCHAR)*(cbData*3+1);

	*ppwsz=(LPWSTR)malloc(dwBufferSize);

	if(NULL==(*ppwsz))
		goto MemoryErr;

	dwBufferIndex=0;

	//format the wchar buffer one byte at a time
	for(dwEncodedIndex=0; dwEncodedIndex<cbData; dwEncodedIndex++)
	{
		//copy the space between every four bytes.  Skip for the 1st byte
		if(fSpace)
		{
			if((0!=dwEncodedIndex) && (0==(dwEncodedIndex % 4 )))
			{
				(*ppwsz)[dwBufferIndex]=pwszSpace[0];
				dwBufferIndex++;
			}
		}


		//format the higher 4 bits
		(*ppwsz)[dwBufferIndex]=(WCHAR)ByteToHex(
			 (pbData[dwEncodedIndex]&UPPER_BITS)>>4,
			 pwszZero, pwszA);

		dwBufferIndex++;

		//format the lower 4 bits
		(*ppwsz)[dwBufferIndex]=(WCHAR)ByteToHex(
			 pbData[dwEncodedIndex]&LOWER_BITS,
			 pwszZero, pwszA);

		dwBufferIndex++;

	}

	//add the NULL terminator to the string
	(*ppwsz)[dwBufferIndex]=L'\0';

	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL WINAPI	FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...)
{
    // get format string from resources
    WCHAR		wszFormat[1000];
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(NULL == ppwszFormat)
        goto InvalidArgErr;

    if(!LoadStringU(g_hMSCEPModule, ids, wszFormat, 1000))
		goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    cbMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
		goto FormatMessageError;

	fResult=TRUE;

CommonReturn:
	
	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
// Name:    LogSCEPEvent
//
// Description: This function registers an event in the event log of the
//              local machine.  Takes an optional argument list.
//
//--------------------------------------------------------------------------
void WINAPI	LogSCEPEvent(IN DWORD    dwLogLevel,
                IN BOOL     fError,
                IN HRESULT  hr,
                IN DWORD    dwEventId,
                IN DWORD    dwParamCount,
                ...
                )
{
    WORD        dwEventType = 0;
    LPWSTR      awszStrings[PENDING_ALLOC_SIZE + 2];
    WORD        cStrings = 0;
    LPWSTR      wszString = NULL;
	WCHAR       wszMsg[MAX_STRING_SIZE];
    DWORD       dwIndex=0;

    LPWSTR      wszHR=NULL;

    va_list     ArgList;

	if(NULL == g_hEventSource)
		return;

    //copy the variable strings if present
    va_start(ArgList, dwParamCount);

    for(dwIndex=0; dwIndex < dwParamCount; dwIndex++)
    {
        wszString = va_arg(ArgList, LPWSTR);

		if(wszString)
			awszStrings[cStrings++] = wszString;

        if(cStrings >= PENDING_ALLOC_SIZE)
        {
            break;
        }
    }

    va_end(ArgList);

    //copy the hr error code
    if(fError)
    {
        if(S_OK == hr)
            hr=E_FAIL;

		wsprintfW(wszMsg, L"0x%lx", hr);        
        awszStrings[cStrings++] = wszMsg;


        if(0 != FormatMessageW(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    hr,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (WCHAR *)&wszHR,
                    0,
                    NULL))
        {
            if(wszHR)
			{
                awszStrings[cStrings++] = wszHR;
			}
			else
			{
				awszStrings[cStrings++]=L" ";
			}
        }
		else
		{
			awszStrings[cStrings++]=L" ";
		}
    }

    switch(dwEventId >> 30)
    {
        case 0:
            dwEventType = EVENTLOG_SUCCESS;
        break;

        case 1:
            dwEventType = EVENTLOG_INFORMATION_TYPE;
        break;

        case 2:
            dwEventType = EVENTLOG_WARNING_TYPE;
        break;

        case 3:
            dwEventType = EVENTLOG_ERROR_TYPE;
        break;
    }

    ReportEventW(g_hEventSource,          // handle of event source
                 dwEventType,           // event type
                 0,                     // event category
                 dwEventId,             // event ID
                 NULL,                  // current user's SID
                 cStrings,              // strings in lpszStrings
                 0,                     // no bytes of raw data
                 (LPCWSTR*)awszStrings, // array of error strings
                 NULL                   // no raw data
                 );

    if(wszHR)
        LocalFree(wszHR);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\mscep\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------


//string
#define		IDS_HTML_TEMPLATE						3001
#define		IDS_ACCESS_DENIED						3002
#define		IDS_ERROR_UNKONWN						3003
#define		IDS_TOO_MANY_PASSWORD					3004
#define		IDS_CEP_INFO_WITH_PASSWORD				3005
#define		IDS_CEP_INFO_NO_PASSWORD				3006
#define		IDS_FAIL_TO_GET_PASSWORD				3007
#define		IDS_FAIL_TO_ADD_PASSWORD				3008
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\setup\cepsetup.h ===
//--------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       cepsetup.h
//
//  Contents:   The private include file for cepsetup.exe.
//
//  History:    August-12-1999	xiaohs	Created
//
//--------------------------------------------------------------
#ifndef CEPSETUP_H
#define CEPSETUP_H


#ifdef __cplusplus
extern "C" {
#endif

//-----------------------------------------------------------------------
//
// Constants
//
//-----------------------------------------------------------------------
#define		MAX_STRING_SIZE				512
#define		CEP_PROP_SHEET				7
#define		MAX_TITLE_LENGTH			128
#define		RA_INFO_COUNT				7
#define		CEP_KEY_LENGTH_STRING		15

#define		SCEP_APPLICATION_POOL		L"SCEP"
#define		IIS_WPG						L"IIS_WPG"

#define		SCEP_SERVICE_WAIT_PERIOD	120		//by default we wait for 120 seconds	

//-----------------------------------------------------------------------
//
//  CEP_PAGE_INFO
//
//------------------------------------------------------------------------
typedef struct _CEP_PAGE_INFO
{
    LPCWSTR      pszTemplate;
    DLGPROC     pfnDlgProc;
}CEP_PAGE_INFO;


typedef struct _CEP_ENROLL_INFO
{
	LPWSTR		pwszPreFix;
	DWORD		dwIDC;
}CEP_ENROLL_INFO;


typedef struct _CEP_CSP_INFO
{
	LPWSTR		pwszCSPName;				
	DWORD		dwCSPType;
	BOOL		fSignature;
	BOOL		fEncryption;
	DWORD		dwMaxSign;						//Max key length of signature
	DWORD		dwMinSign;						//Min key length of signature
	DWORD		dwDefaultSign;					//default key length of signature
	DWORD		dwMaxEncrypt;
	DWORD		dwMinEncrypt;
	DWORD		dwDefaultEncrypt;
	DWORD		*pdwSignList;					//the table of possible signing key length
	DWORD		dwSignCount;				    //the count of entries in the table
	DWORD		*pdwEncryptList;
	DWORD		dwEncryptCount;
}CEP_CSP_INFO;


typedef struct _CEP_WIZARD_INFO
{
    HFONT               hBigBold;
    HFONT               hBold;
	BOOL				fEnrollAdv;
	BOOL				fPassword;
	LPWSTR				rgpwszName[RA_INFO_COUNT];
	CEP_CSP_INFO		*rgCSPInfo;
	DWORD				dwCSPCount;
	DWORD				dwSignProvIndex;
	DWORD				dwSignKeyLength;
	DWORD				dwEncryptProvIndex;
	DWORD				dwEncryptKeyLength;
	BOOL				fEnterpriseCA;
	BOOL				fDC;
	LPWSTR				pwszUserName;
	LPWSTR				pwszPassword;
	HANDLE				hAccountToken;
	IDsObjectPicker     *pIDsObjectPicker;
	BOOL				fDomain;
	DWORD				dwServiceWait;
	BOOL				fLocalSystem;
}CEP_WIZARD_INFO;


//-----------------------------------------------------------------------
//
// Function Prototypes
//
//-----------------------------------------------------------------------
BOOL	WINAPI		IsValidInstallation(UINT	*pidsMsg);

int		WINAPI		CEPMessageBox(
							HWND        hWnd,
							UINT        idsText,
							UINT        uType);

int		WINAPI		CEPErrorMessageBox(
							HWND        hWnd,
							UINT        idsReason,
							HRESULT		hr,
							UINT        uType
							);	

int		WINAPI		CEPErrorMessageBoxEx(
							HWND        hWnd,
							UINT        idsReason,
							HRESULT		hr,
							UINT        uType,
							UINT		idsFormat1,
							UINT		idsFormat2
							);
				 

BOOL	WINAPI		FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...);


BOOL    WINAPI		CEPWizardInit();

void	WINAPI		FreeCEPWizardInfo(CEP_WIZARD_INFO *pCEPWizardInfo);

void	WINAPI		SetControlFont(
							IN HFONT    hFont,
							IN HWND     hwnd,
							IN INT      nId
							);

BOOL	WINAPI		SetupFonts(
							IN HINSTANCE    hInstance,
							IN HWND         hwnd,
							IN HFONT        *pBigBoldFont,
							IN HFONT        *pBoldFont
							);

void	WINAPI		DestroyFonts(
							IN HFONT        hBigBoldFont,
							IN HFONT        hBoldFont
							);

BOOL	WINAPI		RemoveRACertificates();

void    WINAPI		DisplayConfirmation(HWND                hwndControl,
										CEP_WIZARD_INFO		*pCEPWizardInfo);


BOOL	WINAPI		UpdateCEPRegistry(BOOL		fPassword, BOOL fEnterpriseCA);


BOOL	WINAPI		EmptyCEPStore();

BOOL	WINAPI		CEPGetCSPInformation(CEP_WIZARD_INFO *pCEPWizardInfo);

BOOL	WINAPI		GetSelectedKeyLength(HWND			hwndDlg,
						  int			idControl,
						  DWORD			*pdwKeyLength);

BOOL	WINAPI		GetSelectedCSP(HWND			hwndDlg,
							int				idControl,
							DWORD			*pdwCSPIndex);

BOOL	WINAPI		RefreshKeyLengthCombo(HWND				hwndDlg, 
								   int					idsList,
								   int					idsCombo, 
								   BOOL					fSign,
								   CEP_WIZARD_INFO		*pCEPWizardInfo);

BOOL	WINAPI		InitCSPList(HWND				hwndDlg,
							int					idControl,
							BOOL				fSign,
							CEP_WIZARD_INFO		*pCEPWizardInfo);

BOOL	WINAPI		I_DoSetupWork(HWND	hWnd, CEP_WIZARD_INFO *pCEPWizardInfo);

HRESULT WINAPI		AddLogSourceToRegistry(LPWSTR   pwszMsgDLL);

LPWSTR	GetAccountDomainName(BOOL fDC);

BOOL CEPGetAccountNameFromPicker(HWND				 hwndParent,
								 IDsObjectPicker     *pDsObjectPicker,
								 LPWSTR              *ppwszSelectedUserSAM);




#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif  //CEPSETUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\setup\errorhandling.h ===
//--------------------------------------------------------------------
// ErrorHandling - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 8-10-99
//
// Macro definitions for CertSrv style error handling
//

#ifndef ERROR_HANDLING_H
#define ERROR_HANDLING_H


#define _Verify(expression, hr, label) \
    if (!(expression)) { \
        wprintf(L"Verify failed: '%ws' is false.\n", L## #expression); \
        hr=E_UNEXPECTED; \
        goto label; \
    }

#define _IgnoreError(hr, errorsource) \
    wprintf(L##errorsource L" failed with 0x%08X, ignored.\n", hr);

#define _JumpError(hr, label, errorsource) \
    wprintf(L##errorsource L" failed with 0x%08X.\n", hr); \
    goto label;

#define _JumpErrorStr(hr, label, errorsource, wstr) \
    wprintf(L##errorsource L"(%ws) failed with 0x%08X.\n", wstr, hr); \
    goto label;

#define _JumpIfError(hr, label, errorsource) \
    if (FAILED(hr)) { \
        wprintf(L##errorsource L" failed with 0x%08X.\n", hr); \
        goto label; \
    }

#define _JumpIfErrorStr(hr, label, errorsource, wstr) \
    if (FAILED(hr)) { \
        wprintf(L##errorsource L"(%ws) failed with 0x%08X.\n", wstr, hr); \
        goto label; \
    }

#define _JumpIfOutOfMemory(hr, label, pointer) \
    if (NULL==(pointer)) { \
        hr=E_OUTOFMEMORY; \
        wprintf(L"Out of memory.\n"); \
        goto label; \
    }

#define _TrapException(hr) \
    __except(hr=myHExceptionCode(GetExceptionInformation()), EXCEPTION_EXECUTE_HANDLER) {}

#define _TeardownError(hr, hr2, errorsource) \
    if (FAILED(hr2)) { \
        wprintf(L##errorsource L" failed with 0x%08X during teardown.\n", hr2); \
        if (!FAILED(hr)) { \
            hr=hr2; \
        } \
    }


#endif ERROR_HANDLING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\setup\cepsetup.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows NT
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       cepsetup.cpp
//
//  Contents:   The setup code for MSCEP
//--------------------------------------------------------------------------

#include	"global.hxx"
#include	<dbgdef.h>	
#include	"objsel.h"	
#include	"setuputil.h"
#include	"cepsetup.h"
#include	"resource.h"
#include	"wincred.h"
#include	"netlib.h"
#include	"dsrole.h"

//-----------------------------------------------------------------------
//
// Global data
//
//-----------------------------------------------------------------------

HMODULE				g_hModule=NULL;
UINT				g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

//-----------------------------------------------------------------------
//CN has to be the 1st item and O the third in the following list and C is the last item.  No other requirements for 
//the order
//-----------------------------------------------------------------------

CEP_ENROLL_INFO		g_rgRAEnrollInfo[RA_INFO_COUNT]=        
		{L"CN=",         	 IDC_ENROLL_NAME,        
         L"E=",           	 IDC_ENROLL_EMAIL,       
         L"O=",				 IDC_ENROLL_COMPANY,     
         L"OU=",			 IDC_ENROLL_DEPARTMENT,  
         L"L=",           	 IDC_ENROLL_CITY,        
		 L"S=",				 IDC_ENROLL_STATE,       
		 L"C=",				 IDC_ENROLL_COUNTRY,     
		};
	

//-----------------------------------------------------------------------
//the key length table
//-----------------------------------------------------------------------
DWORD g_rgdwKeyLength[] =
{
    512,
    1024,
    2048,
    4096,
};

DWORD g_dwKeyLengthCount=sizeof(g_rgdwKeyLength)/sizeof(g_rgdwKeyLength[0]);

DWORD g_rgdwSmallKeyLength[] =
{
    128,
    256,
    512,
    1024,
};

DWORD g_dwSmallKeyLengthCount=sizeof(g_rgdwSmallKeyLength)/sizeof(g_rgdwSmallKeyLength[0]);

//the list of possible default key lenght in the order of preference
DWORD g_rgdwDefaultKey[] =
{
    1024,
    2048,
	512,
	256,
    4096,
	128
};

DWORD g_dwDefaultKeyCount=sizeof(g_rgdwDefaultKey)/sizeof(g_rgdwDefaultKey[0]);

//-----------------------------------------------------------------------
//
//The winProc for each of the setup wizard page
//
//-----------------------------------------------------------------------


//-----------------------------------------------------------------------
//Welcome
//-----------------------------------------------------------------------
INT_PTR APIENTRY CEP_Welcome(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CEP_WIZARD_INFO			*pCEPWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;


	switch (msg)
	{
		case WM_INITDIALOG:
				//set the wizard information so that it can be shared
				pPropSheet = (PROPSHEETPAGE *) lParam;
				pCEPWizardInfo = (CEP_WIZARD_INFO *) (pPropSheet->lParam);
				SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCEPWizardInfo);

				SetControlFont(pCEPWizardInfo->hBigBold, hwndDlg,IDC_BIG_BOLD_TITLE);
			break;

		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//App_ID
//-----------------------------------------------------------------------
INT_PTR APIENTRY CEP_App_ID(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CEP_WIZARD_INFO         *pCEPWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;


	switch (msg)
	{
		case WM_INITDIALOG:
				//set the wizard information so that it can be shared
				pPropSheet = (PROPSHEETPAGE *) lParam;
				pCEPWizardInfo = (CEP_WIZARD_INFO *) (pPropSheet->lParam);

				//make sure pCertWizardInfo is a valid pointer
				if(NULL==pCEPWizardInfo)
					break;

				SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCEPWizardInfo);

				SetControlFont(pCEPWizardInfo->hBold, hwndDlg,IDC_BOLD_TITLE);

				//by default, we use local machine account
                SendMessage(GetDlgItem(hwndDlg, IDC_APP_ID_RADIO1), BM_SETCHECK, BST_CHECKED, 0);
             
                SendMessage(GetDlgItem(hwndDlg, IDC_APP_ID_RADIO2), BM_SETCHECK, BST_UNCHECKED, 0);
			break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
                    switch (LOWORD(wParam))
                    {
                        case    IDC_APP_ID_RADIO1:
                                SendMessage(GetDlgItem(hwndDlg, IDC_APP_ID_RADIO1), BM_SETCHECK, BST_CHECKED, 0);
                                SendMessage(GetDlgItem(hwndDlg, IDC_APP_ID_RADIO2), BM_SETCHECK, BST_UNCHECKED, 0);
                            break;

                        case    IDC_APP_ID_RADIO2:
                                SendMessage(GetDlgItem(hwndDlg, IDC_APP_ID_RADIO1), BM_SETCHECK, BST_UNCHECKED, 0);
                                SendMessage(GetDlgItem(hwndDlg, IDC_APP_ID_RADIO2), BM_SETCHECK, BST_CHECKED, 0);
                            break;

                        default:
                            break;

                    }
                }

			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 							PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //check for the application identity options
                            if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_APP_ID_RADIO1, BM_GETCHECK, 0, 0))
							{
                                pCEPWizardInfo->fLocalSystem=TRUE;

								//skip the account page and goes to the challege page directly
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_CHALLENGE);
							}
                            else
							{
                                pCEPWizardInfo->fLocalSystem=FALSE;
							
							}

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//Account
//-----------------------------------------------------------------------
INT_PTR APIENTRY CEP_Account(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CEP_WIZARD_INFO         *pCEPWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
	WCHAR					wszText[MAX_STRING_SIZE];
	int						idsText=IDS_ACCOUNT_INTRO_STD;
	int						idsErr=0;
	DWORD					dwChar=0;
	DWORD					dwDomainChar=0;
	DWORD					dwWinStatus=0;
	WCHAR					wszUser[CREDUI_MAX_USERNAME_LENGTH+1];
	WCHAR					wszDomain[CREDUI_MAX_USERNAME_LENGTH+1];
	HRESULT					hr=S_OK;
	int						idsHrErr=0;
	BOOL					fMember=FALSE;
	SID_NAME_USE			SidName;
    PRIVILEGE_SET			ps;
    DWORD					dwPSSize=0;
	DWORD					dwSize=0;
    BOOL					fAccessAllowed = FALSE;
    DWORD					grantAccess=0;
    GENERIC_MAPPING			GenericMapping={
							ACTRL_DS_OPEN | ACTRL_DS_LIST | ACTRL_DS_SELF | ACTRL_DS_READ_PROP,
							ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD | ACTRL_DS_WRITE_PROP | ACTRL_DS_DELETE_TREE,
							ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD | ACTRL_DS_WRITE_PROP | ACTRL_DS_DELETE_TREE,
							ACTRL_DS_OPEN | ACTRL_DS_LIST | ACTRL_DS_SELF | ACTRL_DS_READ_PROP | ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD | ACTRL_DS_WRITE_PROP | ACTRL_DS_DELETE_TREE,
							};


	LPWSTR					pwszObjectPicker=NULL;
	LPWSTR					pwszConfirm=NULL;
	LPWSTR					pwszAccount=NULL;
	LPWSTR					pwszIIS=NULL;  //"xiaohs4\IIS_WPG"
	LPWSTR					pwszDomain=NULL;
	LPWSTR					pwszComputerName=NULL;
	PSID					pSidIIS=NULL;
	HCERTTYPE				hCertType=NULL;
	PSECURITY_DESCRIPTOR	pCertTypeSD=NULL;

	switch (msg)
	{
		case WM_INITDIALOG:
				//set the wizard information so that it can be shared
				pPropSheet = (PROPSHEETPAGE *) lParam;
				pCEPWizardInfo = (CEP_WIZARD_INFO *) (pPropSheet->lParam);

				//make sure pCertWizardInfo is a valid pointer
				if(NULL==pCEPWizardInfo)
					break;

				SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCEPWizardInfo);

				SetControlFont(pCEPWizardInfo->hBold, hwndDlg,IDC_BOLD_TITLE);

				//update the intro statement based on the type of the CA
				if(pCEPWizardInfo->fEnterpriseCA)
					idsText=IDS_ACCOUNT_INTRO_ENT;

				if(LoadStringU(g_hModule, idsText, wszText, MAX_STRING_SIZE))
				{
					SetDlgItemTextU(hwndDlg, IDC_ACCOUNT_INTRO, wszText);
				}


			break;

		case WM_COMMAND:
                if(HIWORD(wParam) == BN_CLICKED)
                {
					//user wants to browse for the account name
                    if(LOWORD(wParam) == IDC_ACCOUNT_BROWSE)
                    {

						if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
							break;

						if(CEPGetAccountNameFromPicker(hwndDlg,
													pCEPWizardInfo->pIDsObjectPicker,
													&pwszObjectPicker))
						{
							//set the account name in the edit box
							SetDlgItemTextU(hwndDlg, IDC_ACCOUNT_NAME, pwszObjectPicker);
							free(pwszObjectPicker);
						}
					}
				}
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 							PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                           if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;							

						    //free the information 
							if(pCEPWizardInfo->pwszUserName)
							{
								free(pCEPWizardInfo->pwszUserName);
								pCEPWizardInfo->pwszUserName=NULL;
							}

							if(pCEPWizardInfo->pwszPassword)
							{
                                                               SecureZeroMemory(pCEPWizardInfo->pwszPassword, sizeof(WCHAR) * wcslen(pCEPWizardInfo->pwszPassword));
								free(pCEPWizardInfo->pwszPassword);
								pCEPWizardInfo->pwszPassword=NULL;
							}

							if(pCEPWizardInfo->hAccountToken)
							{
								CloseHandle(pCEPWizardInfo->hAccountToken);
								pCEPWizardInfo->hAccountToken=NULL;
							}

							//get the account name
							if(0==(dwChar=(DWORD)SendDlgItemMessage(hwndDlg, IDC_ACCOUNT_NAME, WM_GETTEXTLENGTH, 0, 0)))
							{
								idsErr=IDS_ACCOUNT_EMPTY;
								goto Account_Done;
							}

							pCEPWizardInfo->pwszUserName=(LPWSTR)malloc(sizeof(WCHAR)*(dwChar+1));

							if(NULL==(pCEPWizardInfo->pwszUserName))
								goto Account_Done;

							GetDlgItemTextU(hwndDlg, IDC_ACCOUNT_NAME, pCEPWizardInfo->pwszUserName, dwChar+1);

							//get the password
							if(0==(dwChar=(DWORD)SendDlgItemMessage(hwndDlg, IDC_ACCOUNT_PASSWORD, WM_GETTEXTLENGTH, 0, 0)))
							{
								idsErr=IDS_PASSWORD_EMPTY;
								goto Account_Done;
							}

							pCEPWizardInfo->pwszPassword=(LPWSTR)malloc(sizeof(WCHAR)*(dwChar+1));

							if(NULL==(pCEPWizardInfo->pwszPassword))
								goto Account_Done;

                                                       *(pCEPWizardInfo->pwszPassword)=L'\0';

							GetDlgItemTextU(hwndDlg, IDC_ACCOUNT_PASSWORD, pCEPWizardInfo->pwszPassword, dwChar+1);

							//get the confirm
							if(0==(dwChar=(DWORD)SendDlgItemMessage(hwndDlg, IDC_ACCOUNT_CONFIRM, WM_GETTEXTLENGTH, 0, 0)))
							{
								idsErr=IDS_PASSWORD_NO_MATCH;
								goto Account_Done;
							}

							pwszConfirm=(LPWSTR)malloc(sizeof(WCHAR)*(dwChar+1));

							if(NULL==pwszConfirm)
								goto Account_Done;

							GetDlgItemTextU(hwndDlg, IDC_ACCOUNT_CONFIRM, pwszConfirm, dwChar+1);

							//Verify the password match
							if(0 != wcscmp(pwszConfirm, pCEPWizardInfo->pwszPassword))
							{	
								idsErr=IDS_PASSWORD_NO_MATCH;
								goto Account_Done;
							}

							//Verify the user name are correctly formatted
							wszDomain[0]=L'\0';

							if(NO_ERROR != CredUIParseUserNameW( 
													pCEPWizardInfo->pwszUserName,
													wszUser,
													sizeof(wszUser)/sizeof(WCHAR),
													wszDomain,
													sizeof(wszDomain)/sizeof(WCHAR)))
							{
								idsErr=IDS_INVALID_NAME;
								goto Account_Done;
							}	

							//Verify the account does exist.  Obtain the account's token
							//Interactive logon is required on a non-dc machine
							if(FALSE == pCEPWizardInfo->fDC)
							{
								if(!LogonUserW(
									  wszUser,				
									  wszDomain,			
									  pCEPWizardInfo->pwszPassword,    
									  LOGON32_LOGON_INTERACTIVE,   
									  LOGON32_PROVIDER_DEFAULT, 
									  &(pCEPWizardInfo->hAccountToken)))         
								{
									idsHrErr=IDS_FAIL_LOGON_USER;
									goto Account_Done;
								}

								//do a network logon to obtain the impersonation handle
								if(pCEPWizardInfo->hAccountToken)
								{
									CloseHandle(pCEPWizardInfo->hAccountToken);
									pCEPWizardInfo->hAccountToken=NULL;
								}
							}

							//network logon to obtain the token
							if(!LogonUserW(
								  wszUser,				
								  wszDomain,			
								  pCEPWizardInfo->pwszPassword,    
								  LOGON32_LOGON_NETWORK,   
								  LOGON32_PROVIDER_DEFAULT, 
								  &(pCEPWizardInfo->hAccountToken)))         
							{
								idsHrErr=IDS_FAIL_LOGON_USER;
								goto Account_Done;
							}

							//build the account name for IIS_WPG group.
							//for a non-DC, it will be localhost\IIS_WPG
							//for a DC, it will be domain\IIS_WPG

							//get the domain or localhost name
							pwszAccount=GetAccountDomainName(pCEPWizardInfo->fDC);

							if(NULL==pwszAccount)
							{
								idsHrErr=IDS_FAIL_FIND_DOMAIN;
								goto Account_Done;
							}

							//build the IIS_WPG account
							pwszIIS=(LPWSTR)malloc((wcslen(pwszAccount) + 1 + wcslen(IIS_WPG) + 1)*sizeof(WCHAR));
							if(NULL==pwszIIS)
								goto Account_Done;

							wcscpy(pwszIIS, pwszAccount);
							wcscat(pwszIIS, L"\\");
							wcscat(pwszIIS, IIS_WPG);


							//Obtain the SID for the IIS_WPG group
							dwChar=0;
							dwDomainChar=0;

							LookupAccountNameW(
								NULL,		//local system
								pwszIIS,  
								NULL,
								&dwChar,
								NULL,
								&dwDomainChar,
								&SidName);

							pSidIIS=(PSID)malloc(dwChar);
							if(NULL==pSidIIS)
								goto Account_Done;

							pwszDomain=(LPWSTR)malloc(dwDomainChar * sizeof(WCHAR));
							if(NULL==pwszDomain)
								goto Account_Done;

							if(!LookupAccountNameW(
								NULL,			//local system
								pwszIIS,  
								pSidIIS,
								&dwChar,
								pwszDomain,
								&dwDomainChar,
								&SidName))
							{
								idsHrErr=IDS_FAIL_LOOK_UP;
								goto Account_Done;
							}

							//Verify the account is part of the local IIS_WPG group
							if(!CheckTokenMembership(
									pCEPWizardInfo->hAccountToken,
									pSidIIS,
									&fMember))
							{
								idsHrErr=IDS_FAIL_CHECK_MEMBER;
								goto Account_Done;
							}

							if(FALSE == fMember)
							{
								idsErr=IDS_NOT_IIS_MEMBER;
								goto Account_Done;
							}

							//on an enterprise CA, verify the account as READ access to the template
							if(pCEPWizardInfo->fEnterpriseCA)
							{								
								//make sure that this is an domain account:
								//DOMAIN_GROUP_RID_USERS
								if(0 != wcslen(wszDomain))
								{
									dwSize=0;

									GetComputerNameExW(ComputerNamePhysicalDnsHostname,
														NULL,
														&dwSize);

									pwszComputerName=(LPWSTR)malloc(dwSize * sizeof(WCHAR));

									if(NULL==pwszComputerName)
										goto Account_Done;

									if(!GetComputerNameExW(ComputerNamePhysicalDnsHostname,
														pwszComputerName,
														&dwSize))
									{
										idsHrErr=IDS_FAIL_GET_COMPUTER_NAME;
										goto Account_Done;
									}


									if(0 == _wcsicmp(wszDomain, pwszComputerName))
									{
										idsErr=IDS_NO_LOCAL_ACCOUNT;
										goto Account_Done;
									}
								 }

								 hr=CAFindCertTypeByName(wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE, NULL, CT_ENUM_MACHINE_TYPES, &hCertType);

								 if(S_OK != hr)
								 {
									idsHrErr=IDS_FAIL_FIND_CERT_TYPE;
									goto Account_Done;
								 }

								 //get the SD for the template
								 hr=CACertTypeGetSecurity(hCertType, &pCertTypeSD);

								 if(S_OK != hr)
								 {
									idsHrErr=IDS_FAIL_FIND_SD_CERT_TYPE;
									goto Account_Done;
								 }

								 //check the DS_READ Access
								 dwPSSize=sizeof(ps);

								 if(!AccessCheck(
									pCertTypeSD,
									pCEPWizardInfo->hAccountToken,									
									ACTRL_DS_LIST | ACTRL_DS_READ_PROP,      
									&GenericMapping,
									&ps,
									&dwPSSize, 
									&grantAccess,   
									&fAccessAllowed))
								 {
									idsHrErr=IDS_FAIL_DETECT_READ_ACCESS;
									goto Account_Done;
								 }

								 //make sure the account has read access to the template
								 if(FALSE == fAccessAllowed)
								 {
									idsErr=IDS_NO_READ_ACCESS_TO_TEMPLATE;
									goto Account_Done;
								 }
							}

							//everything looks good
							idsErr=0;
							idsHrErr=0;

						Account_Done:

							if(pwszComputerName)
							{
								free(pwszComputerName);
							}

							if(pwszConfirm)
							{
								free(pwszConfirm);
							}

							if(pwszAccount) 
							{
								NetApiBufferFree(pwszAccount);
							}

							if(pwszIIS)
							{
								free(pwszIIS);
							}	

							if(pwszDomain)
							{
								free(pwszDomain);
							}

							if(pSidIIS)
							{
								free(pSidIIS);
							}

							if(pCertTypeSD)
							{
								LocalFree(pCertTypeSD);
							}

							if(hCertType)
							{
								CACloseCertType(hCertType);
							}
	
							if(0 != idsErr)
							{
								CEPMessageBox(hwndDlg, idsErr, MB_ICONERROR|MB_OK|MB_APPLMODAL);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
							}
							else
							{
								if(0 != idsHrErr)
								{
									if(S_OK == hr)
									{
										hr=HRESULT_FROM_WIN32(GetLastError());
									}

									CEPErrorMessageBoxEx(hwndDlg, idsHrErr, hr, MB_ICONERROR|MB_OK|MB_APPLMODAL, IDS_GEN_ERROR_MSG_HR, IDS_GEN_ERROR_MSG);
									SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
								}
							}

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
//Chanllenge
//-----------------------------------------------------------------------
INT_PTR APIENTRY CEP_Challenge(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CEP_WIZARD_INFO         *pCEPWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;


	switch (msg)
	{
		case WM_INITDIALOG:
				//set the wizard information so that it can be shared
				pPropSheet = (PROPSHEETPAGE *) lParam;
				pCEPWizardInfo = (CEP_WIZARD_INFO *) (pPropSheet->lParam);

				//make sure pCertWizardInfo is a valid pointer
				if(NULL==pCEPWizardInfo)
					break;

				SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCEPWizardInfo);

				SetControlFont(pCEPWizardInfo->hBold, hwndDlg,IDC_BOLD_TITLE);

				//by default, we should use Challenge password
				SendMessage(GetDlgItem(hwndDlg, IDC_CHALLENGE_CHECK), BM_SETCHECK, BST_CHECKED, 0);  
			break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 							PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

							if(TRUE == (pCEPWizardInfo->fLocalSystem))
							{
								//skip the account page and goes to the application identity page
                                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_APP_ID);
							}

                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //check for the Challenge password options
                            if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_CHALLENGE_CHECK, BM_GETCHECK, 0, 0))
                                pCEPWizardInfo->fPassword=TRUE;
                            else
                                pCEPWizardInfo->fPassword=FALSE;


                            //warn users about the implication of not using a password
                            if(FALSE == pCEPWizardInfo->fPassword)
                            {
                               if(IDNO==CEPMessageBox(hwndDlg, IDS_NO_CHALLENGE_PASSWORD, MB_ICONWARNING|MB_YESNO|MB_APPLMODAL))
                               {
                                   SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
                                   break;
                               }
                            }

                           if(!EmptyCEPStore())
                           {
                               CEPMessageBox(hwndDlg, IDS_EXISTING_RA, MB_ICONINFORMATION|MB_OK|MB_APPLMODAL);

                               if(IDNO==CEPMessageBox(hwndDlg, IDS_PROCESS_PENDING, MB_ICONQUESTION|MB_YESNO|MB_APPLMODAL))
                               {
                                   SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
                                   break;
                               }
                           }
							
                        break;

                   default:
                        return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}


//-----------------------------------------------------------------------
// Enroll
//-----------------------------------------------------------------------
INT_PTR APIENTRY CEP_Enroll(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CEP_WIZARD_INFO         *pCEPWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;

	DWORD					dwIndex=0;
	DWORD					dwChar=0;


	switch (msg)
	{
		case WM_INITDIALOG:
				//set the wizard information so that it can be shared
				pPropSheet = (PROPSHEETPAGE *) lParam;
				pCEPWizardInfo = (CEP_WIZARD_INFO *) (pPropSheet->lParam);

				//make sure pCertWizardInfo is a valid pointer
				if(NULL==pCEPWizardInfo)
					break;

				SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCEPWizardInfo);

				SetControlFont(pCEPWizardInfo->hBold, hwndDlg,IDC_BOLD_TITLE);
			   
				//by default, we do not use the advanced enrollment options
				SendMessage(GetDlgItem(hwndDlg, IDC_ENORLL_ADV_CHECK), BM_SETCHECK, BST_UNCHECKED, 0);  
				
				//preset the country string since we only allow 2 characters
                SetDlgItemTextU(hwndDlg, IDC_ENROLL_COUNTRY, L"US");

			break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 							PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //if the adv selection is made, it has to stay selected
                            if(pCEPWizardInfo->fEnrollAdv)
                                EnableWindow(GetDlgItem(hwndDlg, IDC_ENORLL_ADV_CHECK), FALSE);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

							//gather RA subject informaton
							for(dwIndex=0; dwIndex < RA_INFO_COUNT; dwIndex++)
							{
								if(pCEPWizardInfo->rgpwszName[dwIndex])
								{
									free(pCEPWizardInfo->rgpwszName[dwIndex]);
									pCEPWizardInfo->rgpwszName[dwIndex]=NULL;

								}

								if(0!=(dwChar=(DWORD)SendDlgItemMessage(hwndDlg,
													   g_rgRAEnrollInfo[dwIndex].dwIDC,
													   WM_GETTEXTLENGTH, 0, 0)))
								{
									pCEPWizardInfo->rgpwszName[dwIndex]=(LPWSTR)malloc(sizeof(WCHAR)*(dwChar+1));

									if(NULL!=(pCEPWizardInfo->rgpwszName[dwIndex]))
									{
										GetDlgItemTextU(hwndDlg, g_rgRAEnrollInfo[dwIndex].dwIDC,
														pCEPWizardInfo->rgpwszName[dwIndex],
														dwChar+1);

									}
								}
							}
							
							//we require name and company
							if((NULL==(pCEPWizardInfo->rgpwszName[0])) ||
							   (NULL==(pCEPWizardInfo->rgpwszName[2]))
							  )
							{
								CEPMessageBox(hwndDlg, IDS_ENROLL_REQUIRE_NAME, MB_ICONERROR|MB_OK|MB_APPLMODAL);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
								break;
							}


							//we only allow 2 characeters for the country
							if(NULL	!=(pCEPWizardInfo->rgpwszName[RA_INFO_COUNT -1]))
							{
								if(2 < wcslen(pCEPWizardInfo->rgpwszName[RA_INFO_COUNT -1]))
								{
									CEPMessageBox(hwndDlg, IDS_ENROLL_COUNTRY_TOO_LARGE, MB_ICONERROR|MB_OK|MB_APPLMODAL);
									SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
									break;
								}
							}

                            //check for the advanced options
                            if(BST_CHECKED==SendDlgItemMessage(hwndDlg,IDC_ENORLL_ADV_CHECK, BM_GETCHECK, 0, 0))
                                pCEPWizardInfo->fEnrollAdv=TRUE;
                            else
                                pCEPWizardInfo->fEnrollAdv=FALSE;


							//If the advanced is selected, skip the CSP Page
                            if(FALSE== pCEPWizardInfo->fEnrollAdv)
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_COMPLETION);
							
                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
// CSP
//-----------------------------------------------------------------------
INT_PTR APIENTRY CEP_CSP(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CEP_WIZARD_INFO         *pCEPWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
	NM_LISTVIEW FAR *       pnmv=NULL;	  
	BOOL					fSign=FALSE;
	int						idCombo=0;


	switch (msg)
	{
		case WM_INITDIALOG:
				//set the wizard information so that it can be shared
				pPropSheet = (PROPSHEETPAGE *) lParam;
				pCEPWizardInfo = (CEP_WIZARD_INFO *) (pPropSheet->lParam);

				//make sure pCertWizardInfo is a valid pointer
				if(NULL==pCEPWizardInfo)
					break;

				SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCEPWizardInfo);

				SetControlFont(pCEPWizardInfo->hBold, hwndDlg,IDC_BOLD_TITLE);

				//populate the CSP list and key length combo box
				InitCSPList(hwndDlg, IDC_CSP_SIGN_LIST, TRUE,
							pCEPWizardInfo);

				InitCSPList(hwndDlg, IDC_CSP_ENCRYPT_LIST, FALSE,
							pCEPWizardInfo);

				RefreshKeyLengthCombo(hwndDlg, 
								  IDC_CSP_SIGN_LIST,
								  IDC_CSP_SIGN_COMBO, 
								  TRUE,
								  pCEPWizardInfo);

				RefreshKeyLengthCombo(hwndDlg, 
								  IDC_CSP_ENCRYPT_LIST,
								  IDC_CSP_ENCRYPT_COMBO, 
								  FALSE,
								  pCEPWizardInfo);

			break;

		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

                    case LVN_ITEMCHANGED:

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            pnmv = (LPNMLISTVIEW) lParam;

                            if(NULL==pnmv)
                                break;

                            if (pnmv->uNewState & LVIS_SELECTED)
                            {

								if(IDC_CSP_SIGN_LIST == (pnmv->hdr).idFrom)
								{
									fSign=TRUE;
									idCombo=IDC_CSP_SIGN_COMBO;
								}
								else
								{
									if(IDC_CSP_ENCRYPT_LIST != (pnmv->hdr).idFrom)
										break;

									fSign=FALSE;
									idCombo=IDC_CSP_ENCRYPT_COMBO;
								}

								RefreshKeyLengthCombo(
								   hwndDlg, 
								   (int)((pnmv->hdr).idFrom),
								   idCombo, 
								   fSign,
								   pCEPWizardInfo);
							}

							break;

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 							PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT|PSWIZB_BACK);
					    break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

							//get the select CSP and key length
							if(!GetSelectedCSP(hwndDlg,
									IDC_CSP_SIGN_LIST,
									&(pCEPWizardInfo->dwSignProvIndex)))
							{
								CEPMessageBox(hwndDlg, IDS_SELECT_SIGN_CSP, MB_ICONERROR|MB_OK|MB_APPLMODAL);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
								break;
							}

							if(!GetSelectedCSP(hwndDlg,
									IDC_CSP_ENCRYPT_LIST,
									&(pCEPWizardInfo->dwEncryptProvIndex)))
							{
								CEPMessageBox(hwndDlg, IDS_SELECT_ENCRYPT_CSP, MB_ICONERROR|MB_OK|MB_APPLMODAL);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
								break;
							}

							if(!GetSelectedKeyLength(hwndDlg,
									IDC_CSP_SIGN_COMBO,
									&(pCEPWizardInfo->dwSignKeyLength)))
							{
								CEPMessageBox(hwndDlg, IDS_SELECT_SIGN_KEY_LENGTH, MB_ICONERROR|MB_OK|MB_APPLMODAL);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
								break;
							}

							if(!GetSelectedKeyLength(hwndDlg,
									IDC_CSP_ENCRYPT_COMBO,
									&(pCEPWizardInfo->dwEncryptKeyLength)))
							{
								CEPMessageBox(hwndDlg, IDS_SELECT_ENCRYPT_KEY_LENGTH, MB_ICONERROR|MB_OK|MB_APPLMODAL);
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
								break;
							}

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//Completion
//-----------------------------------------------------------------------
INT_PTR APIENTRY CEP_Completion(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CEP_WIZARD_INFO			*pCEPWizardInfo=NULL;
    PROPSHEETPAGE           *pPropSheet=NULL;
    HWND                    hwndControl=NULL;
    LV_COLUMNW              lvC;
    HCURSOR                 hPreCursor=NULL;
    HCURSOR                 hWinPreCursor=NULL;

	switch (msg)
	{
		case WM_INITDIALOG:
            //set the wizard information so that it can be shared
            pPropSheet = (PROPSHEETPAGE *) lParam;
            pCEPWizardInfo = (CEP_WIZARD_INFO *) (pPropSheet->lParam);
            //make sure pCertWizardInfo is a valid pointer
            if(NULL==pCEPWizardInfo)
                break;
                
            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pCEPWizardInfo);

            SetControlFont(pCEPWizardInfo->hBigBold, hwndDlg,IDC_BIG_BOLD_TITLE);

            //insert two columns
            hwndControl=GetDlgItem(hwndDlg, IDC_COMPLETION_LIST);

            memset(&lvC, 0, sizeof(LV_COLUMNW));

            lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt = LVCFMT_LEFT;		// Left-align the column.
            lvC.cx = 20;				// Width of the column, in pixels.
            lvC.pszText = L"";			// The text for the column.
            lvC.iSubItem=0;

            if (ListView_InsertColumnU(hwndControl, 0, &lvC) == -1)
                break;

            //2nd column is the content
            memset(&lvC, 0, sizeof(LV_COLUMNW));

            lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvC.fmt = LVCFMT_LEFT;		// Left-align the column.
            lvC.cx = 10;				//(dwMaxSize+2)*7;          // Width of the column, in pixels.
            lvC.pszText = L"";			// The text for the column.
            lvC.iSubItem= 1;

            if (ListView_InsertColumnU(hwndControl, 1, &lvC) == -1)
                break;


           break;
		case WM_COMMAND:
			break;	
						
		case WM_NOTIFY:
    		    switch (((NMHDR FAR *) lParam)->code)
    		    {

  				    case PSN_KILLACTIVE:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					        return TRUE;

                        break;

				    case PSN_RESET:
                            SetWindowLongPtr(hwndDlg,	DWLP_MSGRESULT, FALSE);
					    break;

 				    case PSN_SETACTIVE:
 					        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK|PSWIZB_FINISH);

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            if(hwndControl=GetDlgItem(hwndDlg, IDC_COMPLETION_LIST))
                                DisplayConfirmation(hwndControl, pCEPWizardInfo);
					    break;

                    case PSN_WIZBACK:
                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

							//skip CSP page if adv is not selected
							if(FALSE == pCEPWizardInfo->fEnrollAdv)
								SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_ENROLL);

                        break;

                    case PSN_WIZFINISH:

                            if(NULL==(pCEPWizardInfo=(CEP_WIZARD_INFO *)GetWindowLongPtr(hwndDlg, DWLP_USER)))
                                break;

                            //overwrite the cursor for this window class
                            hWinPreCursor=(HCURSOR)SetClassLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)NULL);
                            hPreCursor=SetCursor(LoadCursor(NULL, IDC_WAIT));

							//do the real setup work
							I_DoSetupWork(hwndDlg, pCEPWizardInfo);

                            //set the cursor back
                            SetCursor(hPreCursor);
                            SetWindowLongPtr(hwndDlg, GCLP_HCURSOR, (LONG_PTR)hWinPreCursor);

                        break;

				    default:
					    return FALSE;

    	        }
		    break;

		default:

			    return FALSE;
	}

	return TRUE;
}


//--------------------------------------------------------------------------
//
//	  Helper Functions for the wizard pages
//
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//	 CEPGetAccountNameFromPicker
//
//--------------------------------------------------------------------------
BOOL CEPGetAccountNameFromPicker(HWND				 hwndParent,
								 IDsObjectPicker     *pIDsObjectPicker,
								 LPWSTR              *ppwszSelectedUserSAM)
{
	BOOL							fResult=FALSE;
    BOOL                            fGotStgMedium = FALSE;
    LPWSTR                          pwszPath=NULL;
    DWORD                           dwIndex =0 ;
    DWORD                           dwCount=0;
    WCHAR                           wszWinNT[]=L"WinNT://";
	DWORD							dwSize=0;
	LPWSTR							pwsz=NULL;
	DWORD							cCount=0;

    IDataObject                     *pdo = NULL;
    PDS_SELECTION_LIST              pDsSelList=NULL;
	LPWSTR							pwszComputerName=NULL;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    //input check
    if((NULL == pIDsObjectPicker) || (NULL == ppwszSelectedUserSAM))
        goto CLEANUP;

    *ppwszSelectedUserSAM = NULL;


    if(S_OK != pIDsObjectPicker->InvokeDialog(hwndParent, &pdo))
        goto CLEANUP;

    if(S_OK != pdo->GetData(&formatetc, &stgmedium))
        goto CLEANUP;

    fGotStgMedium = TRUE;

    pDsSelList = (PDS_SELECTION_LIST)GlobalLock(stgmedium.hGlobal);

    if(!pDsSelList)
        goto CLEANUP;

	//detect if this is a domain account
	//local account will be in the format of Winnt://workgroup/machine/foo

	//Get the SAM name
	if((pDsSelList->aDsSelection[0]).pwzADsPath == NULL)
		goto CLEANUP;

	//the ADsPath is in the form of "WinNT://" 
	if(wcslen((pDsSelList->aDsSelection[0]).pwzADsPath) <= wcslen(wszWinNT))
		goto CLEANUP;

	if( 0 != _wcsnicmp((pDsSelList->aDsSelection[0]).pwzADsPath, wszWinNT, wcslen(wszWinNT)))
		goto CLEANUP;

	pwsz = ((pDsSelList->aDsSelection[0]).pwzADsPath) + wcslen(wszWinNT);

	while(L'\0' != (*pwsz))
	{
		if(L'/' == (*pwsz))
		{
			cCount++;
		}

		pwsz++;
	}

	if(1 == cCount)
	{
		//domain\administrator have no UPN
		//if((pDsSelList->aDsSelection[0]).pwzUPN != NULL)
        //if(0 != _wcsicmp(L"",(pDsSelList->aDsSelection[0]).pwzUPN))
		pwszPath = ((pDsSelList->aDsSelection[0]).pwzADsPath) + wcslen(wszWinNT);

		*ppwszSelectedUserSAM=(LPWSTR)malloc((wcslen(pwszPath) + 1) * sizeof(WCHAR));

		if(NULL == (*ppwszSelectedUserSAM))
			goto CLEANUP;

		wcscpy(*ppwszSelectedUserSAM, pwszPath);

		//search for the "/" and make it "\".  Since the ADsPath is in the form
		//of "WinNT://domain/name".  We need the SAM name in the form of 
		//domain\name
		dwCount = wcslen(*ppwszSelectedUserSAM);

		for(dwIndex = 0; dwIndex < dwCount; dwIndex++)
		{
			if((*ppwszSelectedUserSAM)[dwIndex] == L'/')
			{
				(*ppwszSelectedUserSAM)[dwIndex] = L'\\';
				break;
			}
		}
	}

	//use the format of localMachine\\account for local account
	if(NULL == (*ppwszSelectedUserSAM))
	{
		if(NULL == (pDsSelList->aDsSelection[0]).pwzName)
			goto CLEANUP;

		//Get the computer name
		dwSize=0;

		GetComputerNameExW(ComputerNamePhysicalDnsHostname,
							NULL,
							&dwSize);

		pwszComputerName=(LPWSTR)malloc(dwSize * sizeof(WCHAR));

		if(NULL==pwszComputerName)
			goto CLEANUP;

	
		if(!GetComputerNameExW(ComputerNamePhysicalDnsHostname,
							pwszComputerName,
							&dwSize))
			goto CLEANUP;


		*ppwszSelectedUserSAM=(LPWSTR)malloc((wcslen(pwszComputerName) + wcslen((pDsSelList->aDsSelection[0]).pwzName) + wcslen(L"\\") + 1) * sizeof(WCHAR));

		if(NULL == (*ppwszSelectedUserSAM))
			goto CLEANUP;
	
		wcscpy(*ppwszSelectedUserSAM, pwszComputerName);
		wcscat(*ppwszSelectedUserSAM, L"\\");
		wcscat(*ppwszSelectedUserSAM, (pDsSelList->aDsSelection[0]).pwzName);
	}

    fResult=TRUE;

CLEANUP:

	if(pwszComputerName)
		free(pwszComputerName);

    if(pDsSelList)
        GlobalUnlock(stgmedium.hGlobal);

    if (TRUE == fGotStgMedium)
        ReleaseStgMedium(&stgmedium);

    if(pdo)
        pdo->Release();

	return fResult;

}

//--------------------------------------------------------------------------
//
//	 RefreshKeyLengthCombo
//
//--------------------------------------------------------------------------
BOOL	WINAPI	RefreshKeyLengthCombo(HWND				hwndDlg, 
								   int					idsList,
								   int					idsCombo, 
								   BOOL					fSign,
								   CEP_WIZARD_INFO		*pCEPWizardInfo)
{
	BOOL			fResult=FALSE;
	DWORD			dwDefaultKeyLength=0;
	DWORD			*pdwList=NULL;
	DWORD			dwListCount=0;
	DWORD			dwMax=0;
	DWORD			dwMin=0;
	DWORD			dwIndex=0;
	DWORD			dwCSPIndex=0;
	CEP_CSP_INFO	*pCSPInfo=NULL;
	int				iInsertedIndex=0;
	WCHAR			wszKeyLength[CEP_KEY_LENGTH_STRING];
	BOOL			fSelected=FALSE;

	//get the selected list view item 
	if(!GetSelectedCSP(hwndDlg,idsList,&dwCSPIndex))
		goto CLEANUP;

	pCSPInfo= &(pCEPWizardInfo->rgCSPInfo[dwCSPIndex]);

	if(fSign)
	{
		dwDefaultKeyLength=pCSPInfo->dwDefaultSign;
		pdwList=pCSPInfo->pdwSignList;
		dwListCount=	pCSPInfo->dwSignCount;
		dwMax=pCSPInfo->dwMaxSign;
		dwMin=pCSPInfo->dwMinSign;
	}
	else
	{
		dwDefaultKeyLength=pCSPInfo->dwDefaultEncrypt;
		pdwList=pCSPInfo->pdwEncryptList;
		dwListCount=pCSPInfo->dwEncryptCount;
		dwMax=pCSPInfo->dwMaxEncrypt;
		dwMin=pCSPInfo->dwMinEncrypt;
	}

	//clear out the combo box
	SendDlgItemMessageU(hwndDlg, idsCombo, CB_RESETCONTENT, 0, 0);	


	for(dwIndex=0; dwIndex < dwListCount; dwIndex++)
	{
		if((pdwList[dwIndex] >= dwMin) && (pdwList[dwIndex] <= dwMax))
		{
			_ltow(pdwList[dwIndex], wszKeyLength, 10);

                        // 64 bit- will never insert more than 1B entries, so INT is fine
			iInsertedIndex=(int)SendDlgItemMessageU(hwndDlg, idsCombo, CB_ADDSTRING,
				0, (LPARAM)wszKeyLength);

			if((iInsertedIndex != CB_ERR) && (iInsertedIndex != CB_ERRSPACE))
			{
				SendDlgItemMessage(hwndDlg, idsCombo, CB_SETITEMDATA, 
									(WPARAM)iInsertedIndex, (LPARAM)pdwList[dwIndex]);
				
				if(dwDefaultKeyLength==pdwList[dwIndex])
				{
					SendDlgItemMessageU(hwndDlg, idsCombo, CB_SETCURSEL, iInsertedIndex, 0);
					fSelected=TRUE;
				}
			}
		}

	}

	if(fSelected==FALSE)
		SendDlgItemMessageU(hwndDlg, idsCombo, CB_SETCURSEL, 0, 0);

	fResult=TRUE;

CLEANUP:

	return fResult;
}


//--------------------------------------------------------------------------
//
//	 InitCSPList
//
//--------------------------------------------------------------------------
BOOL	WINAPI	InitCSPList(HWND				hwndDlg,
							int					idControl,
							BOOL				fSign,
							CEP_WIZARD_INFO		*pCEPWizardInfo)
{
	BOOL				fResult=FALSE;
	DWORD				dwIndex=0;
	CEP_CSP_INFO		*pCSPInfo=NULL;
	int					iInsertedIndex=0;
	HWND				hwndList=NULL;
    LV_ITEMW			lvItem;
    LV_COLUMNW          lvC;
	BOOL				fSelected=FALSE;

    if(NULL==(hwndList=GetDlgItem(hwndDlg, idControl)))
        goto CLEANUP;

    //insert a column into the list view
    memset(&lvC, 0, sizeof(LV_COLUMNW));

    lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt = LVCFMT_LEFT;  // Left-align the column.
    lvC.cx = 20; //(dwMaxSize+2)*7;            // Width of the column, in pixels.
    lvC.pszText = L"";   // The text for the column.
    lvC.iSubItem=0;

    if (-1 == ListView_InsertColumnU(hwndList, 0, &lvC))
		goto CLEANUP;

     // set up the fields in the list view item struct that don't change from item to item
	memset(&lvItem, 0, sizeof(LV_ITEMW));
    lvItem.mask = LVIF_TEXT | LVIF_STATE |LVIF_PARAM ;

	for(dwIndex=0; dwIndex < pCEPWizardInfo->dwCSPCount; dwIndex++)
	{
		fSelected=FALSE;

		pCSPInfo= &(pCEPWizardInfo->rgCSPInfo[dwIndex]);

		if(fSign)
		{
			if(!(pCSPInfo->fSignature))
				continue;

			if(dwIndex==pCEPWizardInfo->dwSignProvIndex)
				fSelected=TRUE;
		}
		else
		{
			if(!(pCSPInfo->fEncryption))
				continue;

			if(dwIndex==pCEPWizardInfo->dwEncryptProvIndex)
				fSelected=TRUE;
		}
	
		lvItem.iItem=dwIndex;
		lvItem.lParam = (LPARAM)dwIndex;
		lvItem.pszText=pCSPInfo->pwszCSPName;

        iInsertedIndex=ListView_InsertItemU(hwndList, &lvItem);

		if(fSelected)
		{
            ListView_SetItemState(
                            hwndList,
                            iInsertedIndex,
                            LVIS_SELECTED,
                            LVIS_SELECTED);
		}

	}  

    //make the column autosize
    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);

	fResult=TRUE;

CLEANUP:

	return fResult;
}


//--------------------------------------------------------------------------
//
//	 GetSelectedCSP
//
//--------------------------------------------------------------------------
BOOL WINAPI	GetSelectedCSP(HWND			hwndDlg,
					int				idControl,
					DWORD			*pdwCSPIndex)
{
	BOOL				fResult=FALSE;
	HWND				hwndControl=NULL;
    LV_ITEM				lvItem;
	int					iIndex=0;

    //get the window handle of the list view
    if(NULL==(hwndControl=GetDlgItem(hwndDlg, idControl)))
        goto CLEANUP;

     //now, mark the one that is selected
	if(-1 == (iIndex= ListView_GetNextItem(
            hwndControl, 		
            -1, 		
            LVNI_SELECTED		
        )))	
		goto CLEANUP;


	memset(&lvItem, 0, sizeof(LV_ITEM));
    lvItem.mask=LVIF_PARAM;
    lvItem.iItem=iIndex;

    if(!ListView_GetItem(hwndControl, &lvItem))
		goto CLEANUP;

        // will never have more than 1B CSPs, so this is fine
	*pdwCSPIndex=(DWORD)(lvItem.lParam);
	
	fResult=TRUE;

CLEANUP:

	return fResult;

}
//--------------------------------------------------------------------------
//
//	 GetSelectedKeyLength
//
//--------------------------------------------------------------------------
BOOL  WINAPI GetSelectedKeyLength(HWND			hwndDlg,
								int			idControl,
								DWORD			*pdwKeyLength)
{

	int				iIndex=0; 
	BOOL			fResult=FALSE;

    iIndex=(int)SendDlgItemMessage(hwndDlg, idControl, CB_GETCURSEL, 0, 0);

	if(CB_ERR==iIndex)
		goto CLEANUP;

        // will never be > 1B bits long, so this is ok
	*pdwKeyLength=(DWORD)SendDlgItemMessage(hwndDlg, idControl, CB_GETITEMDATA, iIndex, 0);
    
	fResult=TRUE;

CLEANUP:

	return fResult;

}

//--------------------------------------------------------------------------
//
//	  FormatMessageStr
//
//--------------------------------------------------------------------------
int ListView_InsertItemU_IDS(HWND       hwndList,
                         LV_ITEMW       *plvItem,
                         UINT           idsString,
                         LPWSTR         pwszText)
{
    WCHAR   wszText[MAX_STRING_SIZE];


    if(pwszText)
        plvItem->pszText=pwszText;
    else
    {
        if(!LoadStringU(g_hModule, idsString, wszText, MAX_STRING_SIZE))
		    return -1;

        plvItem->pszText=wszText;
    }

    return ListView_InsertItemU(hwndList, plvItem);
}

//-------------------------------------------------------------------------
//
//	populate the wizards's confirmation page in the order of Challenge,
//	RA informaton, and CSPs
//
//-------------------------------------------------------------------------
void    WINAPI	DisplayConfirmation(HWND                hwndControl,
									CEP_WIZARD_INFO		*pCEPWizardInfo)
{
    WCHAR				wszYes[MAX_TITLE_LENGTH];
    DWORD				dwIndex=0;
    UINT				ids=0;
	BOOL				fNewItem=FALSE;
	WCHAR				wszLength[CEP_KEY_LENGTH_STRING];

    LV_COLUMNW			lvC;
    LV_ITEMW			lvItem;

    //delete all the old items in the listView
    ListView_DeleteAllItems(hwndControl);

    //insert row by row
    memset(&lvItem, 0, sizeof(LV_ITEMW));

    // set up the fields in the list view item struct that don't change from item to item
    lvItem.mask = LVIF_TEXT | LVIF_STATE ;
    lvItem.state = 0;
    lvItem.stateMask = 0;

    //*******************************************************************
	//account information
    lvItem.iItem=0;
    lvItem.iSubItem=0;

    ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_ACCOUNT_INFORMATION, NULL);

    //content
    (lvItem.iSubItem)++;

	if(FALSE == (pCEPWizardInfo->fLocalSystem))
	{
		ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, pCEPWizardInfo->pwszUserName);
	}
	else
	{
		if(LoadStringU(g_hModule, IDS_LOCAL_SYSTEM, wszYes, MAX_TITLE_LENGTH))
			ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, wszYes);
	}


    //*******************************************************************
	//challenge
    lvItem.iItem++;
    lvItem.iSubItem=0;

    ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_CHALLENGE_PHRASE, NULL);

    //content
    (lvItem.iSubItem)++;

	if(pCEPWizardInfo->fPassword) 
		ids=IDS_YES;
	else
		ids=IDS_NO;

    if(LoadStringU(g_hModule, ids, wszYes, MAX_TITLE_LENGTH))
        ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,wszYes);

	//***************************************************************************
	// RA credentials

    lvItem.iItem++;
    lvItem.iSubItem=0;

    ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_RA_CREDENTIAL, NULL);

	//content
	for(dwIndex=0; dwIndex<RA_INFO_COUNT; dwIndex++)
	{
		if(pCEPWizardInfo->rgpwszName[dwIndex])
		{
            if(TRUE==fNewItem)
            {
                //increase the row
                lvItem.iItem++;
                lvItem.pszText=L"";
                lvItem.iSubItem=0;

                ListView_InsertItemU(hwndControl, &lvItem);
            }
            else
                fNewItem=TRUE;

			lvItem.iSubItem++;
			ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, pCEPWizardInfo->rgpwszName[dwIndex]);
		}
	}

	//***************************************************************************
	//CSPInfo
	if(pCEPWizardInfo->fEnrollAdv)
	{
		//signature CSP Name
		lvItem.iItem++;
		lvItem.iSubItem=0;

		ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_CSP, NULL);

		lvItem.iSubItem++;

		ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
				pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwSignProvIndex].pwszCSPName);


		//signaure key length
		lvItem.iItem++;
		lvItem.iSubItem=0;

		ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_SIGN_KEY_LENGTH, NULL);

		lvItem.iSubItem++;

		_ltow(pCEPWizardInfo->dwSignKeyLength, wszLength, 10);

		ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, wszLength);

		//encryption CSP name
		lvItem.iItem++;
		lvItem.iSubItem=0;

		ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_ENCRYPT_CSP, NULL);

		lvItem.iSubItem++;

		ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem,
				pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwEncryptProvIndex].pwszCSPName);

		//encryption key length
		lvItem.iItem++;
		lvItem.iSubItem=0;

		ListView_InsertItemU_IDS(hwndControl, &lvItem, IDS_ENCRYPT_KEY_LENGTH, NULL);

		lvItem.iSubItem++;

		_ltow(pCEPWizardInfo->dwEncryptKeyLength, wszLength, 10);

		ListView_SetItemTextU(hwndControl, lvItem.iItem, lvItem.iSubItem, wszLength);
	}

    //autosize the columns
    ListView_SetColumnWidth(hwndControl, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hwndControl, 1, LVSCW_AUTOSIZE);


    return;
}

//--------------------------------------------------------------------
//
//	GetServiceWaitPeriod 
//
//		Obtain the value from the registry
//
//--------------------------------------------------------------------------
void GetServiceWaitPeriod(DWORD *pdwServiceWait)
{
	DWORD			cbData=0;
	DWORD			dwData=0;
	DWORD			dwType=0;

	HKEY			hKeyCEP=NULL;

	//set the default value
	*pdwServiceWait=SCEP_SERVICE_WAIT_PERIOD;

	//get the CA's type from the registry
	cbData=sizeof(dwData);
		
	//we have to have the knowledge of the ca type
	if(ERROR_SUCCESS == RegOpenKeyExU(
						HKEY_LOCAL_MACHINE,
						MSCEP_LOCATION,
						0,
						KEY_READ,
						&hKeyCEP))
	{
		if(ERROR_SUCCESS == RegQueryValueExU(
						hKeyCEP,
						MSCEP_KEY_SERVICE_WAIT,
						NULL,
						&dwType,
						(BYTE *)&dwData,
						&cbData))
		{
			if ((dwType == REG_DWORD) || (dwType == REG_BINARY))
			{
				*pdwServiceWait=dwData;
			}
		}
	}

    if(hKeyCEP)
        RegCloseKey(hKeyCEP);

	return;
}


//--------------------------------------------------------------------
//
//	Main Function
//
//--------------------------------------------------------------------------
extern "C" int _cdecl wmain(int nArgs, WCHAR ** rgwszArgs) 
{
	BOOL					fResult=FALSE;
	UINT					idsMsg=IDS_FAIL_INIT_WIZARD;		
	HRESULT					hr=E_FAIL;
    PROPSHEETPAGEW          rgCEPSheet[CEP_PROP_SHEET];
    PROPSHEETHEADERW        cepHeader;
    CEP_PAGE_INFO			rgCEPPageInfo[CEP_PROP_SHEET]=
        {(LPCWSTR)MAKEINTRESOURCE(IDD_WELCOME),                 CEP_Welcome,
         (LPCWSTR)MAKEINTRESOURCE(IDD_APP_ID),                  CEP_App_ID,
         (LPCWSTR)MAKEINTRESOURCE(IDD_ACCOUNT),                 CEP_Account,
         (LPCWSTR)MAKEINTRESOURCE(IDD_CHALLENGE),               CEP_Challenge,
         (LPCWSTR)MAKEINTRESOURCE(IDD_ENROLL),					CEP_Enroll,
         (LPCWSTR)MAKEINTRESOURCE(IDD_CSP),						CEP_CSP,
         (LPCWSTR)MAKEINTRESOURCE(IDD_COMPLETION),              CEP_Completion,
		};
	DWORD					dwIndex=0;
    WCHAR                   wszTitle[MAX_TITLE_LENGTH];	  
	INT_PTR					iReturn=-1;
    ENUM_CATYPES			catype;
	DWORD					dwWaitCounter=0;
	BOOL					fEnterpriseCA=FALSE;
    DSOP_SCOPE_INIT_INFO    ScopeInit;
    DSOP_INIT_INFO          InitInfo;
	DWORD					dwServiceWait=SCEP_SERVICE_WAIT_PERIOD;
	OSVERSIONINFOEXW		versionInfo;


	CEP_WIZARD_INFO						CEPWizardInfo;
	DSROLE_PRIMARY_DOMAIN_INFO_BASIC	*pDomainInfo=NULL;

    memset(rgCEPSheet,		0,	sizeof(PROPSHEETPAGEW)*CEP_PROP_SHEET);
    memset(&cepHeader,		0,	sizeof(PROPSHEETHEADERW));
	memset(&CEPWizardInfo,	0,	sizeof(CEP_WIZARD_INFO));

	if(FAILED(CoInitialize(NULL)))
		return FALSE;

	if(NULL==(g_hModule=GetModuleHandle(NULL)))
		goto CommonReturn;   

	if(!IsValidInstallation(&idsMsg))
		goto ErrorReturn;

	//get the wait period for start/stop service account
	GetServiceWaitPeriod(&dwServiceWait);

	if(!IsCaRunning())
	{
		if(S_OK != (hr=CepStartService(CERTSVC_NAME)))
		{
			idsMsg=IDS_NO_CA_RUNNING;
			goto ErrorWithHResultReturn;
		}
	}

	//make sure the CA is up running
    for (dwWaitCounter=0; dwWaitCounter < dwServiceWait; dwWaitCounter++) 
	{
        if (!IsCaRunning()) 
            Sleep(1000);
		else 
            break;
    }


    if (dwServiceWait == dwWaitCounter) 
	{
        idsMsg=IDS_CAN_NOT_START_CA;
		goto ErrorWithHResultReturn;
    }


	//make sure we have the correct admin rights based on the CA type
	if(S_OK != (hr=GetCaType(&catype)))
	{
		idsMsg=IDS_FAIL_GET_CA_TYPE;
		goto ErrorWithHResultReturn;
	}

	//some cisco routers only work with root CA
	if((ENUM_ENTERPRISE_ROOTCA != catype) && (ENUM_STANDALONE_ROOTCA != catype))
	{
		if(IDNO==CEPMessageBox(NULL, IDS_CAN_NOT_ROOT_CA, MB_ICONWARNING|MB_YESNO|MB_APPLMODAL))
		{
			fResult=FALSE;
			goto CommonReturn;
		}
	}

	//for either Enteprise CA or Standalone CA, the user has to be the local machine admin
	// check for machine admin
	if(!IsUserInAdminGroup(FALSE))
	{
		idsMsg=IDS_NOT_MACHINE_ADMIN;
		goto ErrorReturn;
	}


	if (ENUM_ENTERPRISE_ROOTCA==catype || ENUM_ENTERPRISE_SUBCA==catype) 
	{
		fEnterpriseCA=TRUE;

		// check for enterprise admin
		if(!IsUserInAdminGroup(TRUE))
		{
			idsMsg=IDS_NOT_ENT_ADMIN;
			goto ErrorReturn;
		}
	} 

	//everything looks good.  We start the wizard page
	if(!CEPWizardInit())
		goto ErrorWithWin32Return;

	CEPWizardInfo.fEnrollAdv=FALSE;
	CEPWizardInfo.fPassword=FALSE;
	CEPWizardInfo.fEnterpriseCA=fEnterpriseCA;
	CEPWizardInfo.fDC=FALSE;
	CEPWizardInfo.fDomain=TRUE;		//defeult to assume the machine is on a domain
	CEPWizardInfo.dwServiceWait=dwServiceWait;

	//detect if the machine is a DC
	versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);

	if(GetVersionEx(reinterpret_cast<OSVERSIONINFOW *>(&versionInfo)))
	{
		CEPWizardInfo.fDC = (versionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER);
	}


	//detect if the machine is on a domain
	if(ERROR_SUCCESS != DsRoleGetPrimaryDomainInformation(
			NULL, 
			DsRolePrimaryDomainInfoBasic, 
			(PBYTE*)&pDomainInfo))
	{
		idsMsg=IDS_FAIL_DOMAIN_INFO;
		goto ErrorReturn;
	}

	if((DsRole_RoleStandaloneWorkstation == (pDomainInfo->MachineRole)) ||
	   (DsRole_RoleStandaloneServer == (pDomainInfo->MachineRole))
	  )
	{
		CEPWizardInfo.fDomain=FALSE;
	}

	//initialize the object picker object
    //init for the user selection dialogue
    memset(&ScopeInit, 0, sizeof(DSOP_SCOPE_INIT_INFO));
    memset(&InitInfo,  0, sizeof(InitInfo));

    ScopeInit.cbSize = sizeof(DSOP_SCOPE_INIT_INFO);

	//only domain account for enterprise CA
	if(fEnterpriseCA)
	{
		ScopeInit.flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN|DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
	}
	else
	{
		ScopeInit.flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN|DSOP_SCOPE_TYPE_GLOBAL_CATALOG|DSOP_SCOPE_TYPE_TARGET_COMPUTER;
	}

    ScopeInit.flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;            //this will give us the SAM name for the user
    ScopeInit.FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    ScopeInit.FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = 1;
    InitInfo.aDsScopeInfos = &ScopeInit;
    InitInfo.flOptions = 0;             //we are doing single select

    //create the COM object
     if(S_OK != (hr=CoCreateInstance
					 (CLSID_DsObjectPicker,
					  NULL,
					  CLSCTX_INPROC_SERVER,
					  IID_IDsObjectPicker,
					  (void **) &(CEPWizardInfo.pIDsObjectPicker))))
     {
		idsMsg=IDS_FAIL_GET_OBJECT_PICKER;
		goto ErrorWithHResultReturn;

     }

	 if(S_OK != (hr=CEPWizardInfo.pIDsObjectPicker->Initialize(&InitInfo)))
     {
		idsMsg=IDS_FAIL_GET_OBJECT_PICKER;
		goto ErrorWithHResultReturn;
     }

	//initialize the CSP information
	if(!CEPGetCSPInformation(&CEPWizardInfo))
	{
		idsMsg=IDS_FAIL_GET_CSP_INFO;
		goto ErrorWithWin32Return;
	}

	for(dwIndex=0; dwIndex<RA_INFO_COUNT; dwIndex++)
	{
		CEPWizardInfo.rgpwszName[dwIndex]=NULL;
	}

	if(!SetupFonts(
		g_hModule,
		NULL,
		&(CEPWizardInfo.hBigBold),
		&(CEPWizardInfo.hBold)))
		goto ErrorReturn;


    for(dwIndex=0; dwIndex<CEP_PROP_SHEET; dwIndex++)
	{
        rgCEPSheet[dwIndex].dwSize=sizeof(rgCEPSheet[dwIndex]);

        rgCEPSheet[dwIndex].hInstance=g_hModule;

        rgCEPSheet[dwIndex].pszTemplate=rgCEPPageInfo[dwIndex].pszTemplate;

        rgCEPSheet[dwIndex].pfnDlgProc=rgCEPPageInfo[dwIndex].pfnDlgProc;

        rgCEPSheet[dwIndex].lParam=(LPARAM)&CEPWizardInfo;
	}

    //set up the header information
    cepHeader.dwSize=sizeof(cepHeader);
    cepHeader.dwFlags=PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
    cepHeader.hwndParent=NULL;
    cepHeader.hInstance=g_hModule;

	if(LoadStringU(g_hModule, IDS_WIZARD_CAPTION, wszTitle, sizeof(wszTitle)/sizeof(wszTitle[0])))
		cepHeader.pszCaption=wszTitle;

    cepHeader.nPages=CEP_PROP_SHEET;
    cepHeader.nStartPage=0;
    cepHeader.ppsp=rgCEPSheet;

    //create the wizard
    iReturn = PropertySheetU(&cepHeader);

	if(-1 == iReturn)
        goto ErrorWithWin32Return;

    if(0 == iReturn)
    {
        //cancel button is pushed.  We return FALSE so that 
		//the reboot will not happen.
        fResult=FALSE;
		goto CommonReturn;
    }

	fResult=TRUE;

CommonReturn:

	if(pDomainInfo)
	{
		DsRoleFreeMemory(pDomainInfo);
	}

	FreeCEPWizardInfo(&CEPWizardInfo);

	CoUninitialize();

	return fResult;

ErrorReturn:

	fResult=FALSE;

	CEPMessageBox(NULL, idsMsg, MB_ICONERROR|MB_OK|MB_APPLMODAL);

	goto CommonReturn;

ErrorWithHResultReturn:

	fResult=FALSE;

	CEPErrorMessageBox(NULL, idsMsg, hr, MB_ICONERROR|MB_OK|MB_APPLMODAL);

	goto CommonReturn;

ErrorWithWin32Return:

	fResult=FALSE;

	hr=HRESULT_FROM_WIN32(GetLastError());

	CEPErrorMessageBox(NULL, idsMsg, hr, MB_ICONERROR|MB_OK|MB_APPLMODAL);

	goto CommonReturn;
}

//**********************************************************************
//
//	Helper functions
//
//**********************************************************************
//-----------------------------------------------------------------------
//
//	 I_DoSetupWork
//
//	we are ready to do the real work
//-----------------------------------------------------------------------
BOOL	WINAPI	I_DoSetupWork(HWND	hWnd, CEP_WIZARD_INFO *pCEPWizardInfo)
{
	BOOL					fResult=FALSE;
	UINT					idsMsg=IDS_FAIL_INIT_WIZARD;		
	HRESULT					hr=E_FAIL;
	DWORD					dwWaitCounter=0;
	DWORD					dwIndex=0;
	BOOL					bStart=FALSE;
	DWORD					dwSize=0;
    WCHAR                   wszTitle[MAX_TITLE_LENGTH];	  
    DWORD					cbUserInfo = 0;

    PTOKEN_USER				pUserInfo = NULL;
	LPWSTR					pwszRADN=NULL;
	LPWSTR					pwszComputerName=NULL;
	LPWSTR					pwszText=NULL;

	//************************************************************************************
	//delete all existing CEP certificates
	if(!RemoveRACertificates())
	{	
		idsMsg=IDS_FAIL_DELETE_RA;
		goto ErrorWithWin32Return;
	}

	//************************************************************************************
	//CEP policy registry
	if(!UpdateCEPRegistry(pCEPWizardInfo->fPassword,
						  pCEPWizardInfo->fEnterpriseCA))
	{
		idsMsg=IDS_FAIL_UPDATE_REGISTRY;
		goto ErrorWithWin32Return;
	}
	
	//************************************************************************************
	// Add the virtual root    
    if(S_OK != (hr=AddVDir(pCEPWizardInfo->fDC, CEP_DIR_NAME, SCEP_APPLICATION_POOL, pCEPWizardInfo->fLocalSystem, pCEPWizardInfo->pwszUserName, pCEPWizardInfo->pwszPassword)))
	{
		idsMsg=IDS_FAIL_ADD_VROOT;
		goto ErrorWithHResultReturn;
	}		  

	//************************************************************************************
	// Stop and Start W3SVC service for the change to take effect
	CepStopService(pCEPWizardInfo->dwServiceWait,IIS_NAME, &bStart);

    if(S_OK != (hr=CepStartService(IIS_NAME)))
	{
		idsMsg=IDS_FAIL_START_IIS;
		goto ErrorWithHResultReturn;
	}

	//make sure the w3svc is up running
    for (dwWaitCounter=0; dwWaitCounter < pCEPWizardInfo->dwServiceWait; dwWaitCounter++) 
	{
        if (!IsServiceRunning(IIS_NAME)) 
            Sleep(1000);
		else 
            break;
    }

    if (pCEPWizardInfo->dwServiceWait == dwWaitCounter) 
	{
        idsMsg=IDS_FAIL_START_IIS;
		goto ErrorWithHResultReturn;
    }
	
 	//************************************************************************************
	//Get the security ID for the account
	//get the account's SID
	if(FALSE == (pCEPWizardInfo->fLocalSystem))
	{
		if(NULL == pCEPWizardInfo->hAccountToken)
		{
			idsMsg=IDS_FAIL_SID_FROM_ACCOUNT;
			hr=E_INVALIDARG;
			goto ErrorWithHResultReturn;
		}

		GetTokenInformation(pCEPWizardInfo->hAccountToken, TokenUser, NULL, 0, &cbUserInfo);
		if(cbUserInfo == 0)
		{
			idsMsg=IDS_FAIL_SID_FROM_ACCOUNT;
			goto ErrorWithWin32Return;
		}

		pUserInfo = (PTOKEN_USER)LocalAlloc(LPTR, cbUserInfo);
		if(pUserInfo == NULL)
		{
			idsMsg=IDS_FAIL_SID_FROM_ACCOUNT;
			hr=E_OUTOFMEMORY;
			goto ErrorWithHResultReturn;
		}

		if(!GetTokenInformation(pCEPWizardInfo->hAccountToken, TokenUser, pUserInfo, cbUserInfo, &cbUserInfo))
		{
			idsMsg=IDS_FAIL_SID_FROM_ACCOUNT;
			goto ErrorWithWin32Return;
		}
	}

 	//************************************************************************************
	//Update the certificate template and its ACLs for enterprise CA
	if (pCEPWizardInfo->fEnterpriseCA) 
	{
		// get the templates and permisisons right
		if(S_OK != (hr=DoCertSrvEnterpriseChanges(pCEPWizardInfo->fLocalSystem ? NULL : (SID *)((pUserInfo->User).Sid))))
		{
			idsMsg=IDS_FAIL_ADD_TEMPLATE;
			goto ErrorWithHResultReturn;
		}
	} 


 	//************************************************************************************
	//Enroll for the RA certificate
	
	//build the name in the form of L"C=US;S=Washington;CN=TestSetupUtil"
	pwszRADN=(LPWSTR)malloc(sizeof(WCHAR));
	if(NULL==pwszRADN)
	{
		idsMsg=IDS_NO_MEMORY;
		goto ErrorReturn;
	}
	*pwszRADN=L'\0';

	for(dwIndex=0; dwIndex<RA_INFO_COUNT; dwIndex++)
	{
		if((pCEPWizardInfo->rgpwszName)[dwIndex])
		{
			if(0 != wcslen(pwszRADN))
				wcscat(pwszRADN, L";");

			pwszRADN=(LPWSTR)realloc(pwszRADN,
					sizeof(WCHAR) * (wcslen(pwszRADN) +
									wcslen((pCEPWizardInfo->rgpwszName)[dwIndex]) + 
									wcslen(L";") + 
									wcslen(g_rgRAEnrollInfo[dwIndex].pwszPreFix) +
									1));

			if(NULL==pwszRADN)
			{
				idsMsg=IDS_NO_MEMORY;
				goto ErrorReturn;
			}

 			wcscat(pwszRADN,g_rgRAEnrollInfo[dwIndex].pwszPreFix);
 			wcscat(pwszRADN,(pCEPWizardInfo->rgpwszName)[dwIndex]);
		}
	}

	if(S_OK != (hr=EnrollForRACertificates(
					pwszRADN,							
					(pCEPWizardInfo->rgCSPInfo)[pCEPWizardInfo->dwSignProvIndex].pwszCSPName, 
					(pCEPWizardInfo->rgCSPInfo)[pCEPWizardInfo->dwSignProvIndex].dwCSPType, 
					pCEPWizardInfo->dwSignKeyLength,
					(pCEPWizardInfo->rgCSPInfo)[pCEPWizardInfo->dwEncryptProvIndex].pwszCSPName, 
					(pCEPWizardInfo->rgCSPInfo)[pCEPWizardInfo->dwEncryptProvIndex].dwCSPType, 
					pCEPWizardInfo->dwEncryptKeyLength,
					pCEPWizardInfo->fLocalSystem ? NULL : (SID *)((pUserInfo->User).Sid))))
	{
		idsMsg=IDS_FAIL_ENROLL_RA_CERT;
		goto ErrorWithHResultReturn;
	}

 	//************************************************************************************
	//CA policy registry

	CepStopService(pCEPWizardInfo->dwServiceWait, CERTSVC_NAME, &bStart);

    if(S_OK != (hr=DoCertSrvRegChanges(FALSE)))
	{
		idsMsg=IDS_FAIL_UPDATE_CERTSVC;
		goto ErrorWithHResultReturn;
	}	  

    if(S_OK != (hr=CepStartService(CERTSVC_NAME)))
	{
		idsMsg=IDS_FAIL_START_CERTSVC;
		goto ErrorWithHResultReturn;
	}

	//make sure the CA is up running
    for (dwWaitCounter=0; dwWaitCounter < pCEPWizardInfo->dwServiceWait; dwWaitCounter++) 
	{
        if (!IsCaRunning()) 
            Sleep(1000);
		else 
            break;
    }

    if (pCEPWizardInfo->dwServiceWait == dwWaitCounter) 
	{
        idsMsg=IDS_CAN_NOT_START_CA;
		goto ErrorWithHResultReturn;
    }

	//************************************************************************************
	//Add the EventLog Source
	if(S_OK != AddLogSourceToRegistry(L"%SystemRoot%\\System32\\Certsrv\\Mscep\\mscep.dll"))
	{
		idsMsg=IDS_FAIL_REG_EVENT_LOG;
		goto ErrorWithHResultReturn;
	}


 	//************************************************************************************
	//success
	//inform the user of the password location and URL
	dwSize=0;

	GetComputerNameExW(ComputerNamePhysicalDnsHostname,
						NULL,
						&dwSize);

	pwszComputerName=(LPWSTR)malloc(dwSize * sizeof(WCHAR));

	if(NULL==pwszComputerName)
	{
		idsMsg=IDS_NO_MEMORY;
		goto ErrorReturn;
	}

	
	if(!GetComputerNameExW(ComputerNamePhysicalDnsHostname,
						pwszComputerName,
						&dwSize))
	{
		idsMsg=IDS_FAIL_GET_COMPUTER_NAME;
		goto ErrorWithWin32Return;
	}

	if(!FormatMessageUnicode(&pwszText, IDS_CEP_SUCCESS_INFO, pwszComputerName, CEP_DIR_NAME, CEP_DLL_NAME))
	{
		idsMsg=IDS_NO_MEMORY;
		goto ErrorWithWin32Return;
	}

	wszTitle[0]=L'\0';

	LoadStringU(g_hModule, IDS_WIZARD_CAPTION, wszTitle, sizeof(wszTitle)/sizeof(wszTitle[0]));
	
	MessageBoxU(hWnd, pwszText, wszTitle, MB_OK | MB_APPLMODAL);

	fResult=TRUE;

CommonReturn:

    if(pUserInfo) 
	{
        LocalFree(pUserInfo);
    }

	if(pwszText)
		LocalFree((HLOCAL)pwszText);

	if(pwszComputerName)
		free(pwszComputerName);

	if(pwszRADN)
		free(pwszRADN);

	return fResult;

ErrorReturn:

	fResult=FALSE;

	CEPMessageBox(hWnd, idsMsg, MB_ICONERROR|MB_OK|MB_APPLMODAL);

	goto CommonReturn;

ErrorWithHResultReturn:

	fResult=FALSE;

	CEPErrorMessageBox(hWnd, idsMsg, hr, MB_ICONERROR|MB_OK|MB_APPLMODAL);

	goto CommonReturn;

ErrorWithWin32Return:

	fResult=FALSE;

	hr=HRESULT_FROM_WIN32(GetLastError());

	CEPErrorMessageBox(hWnd, idsMsg, hr, MB_ICONERROR|MB_OK|MB_APPLMODAL);

	goto CommonReturn;
}

//-----------------------------------------------------------------------
//
//   CEPGetCSPInformation
//
//		We initialize the following members of CEP_WIZARD_INFO:
//
//	CEP_CSP_INFO		*rgCSPInfo;
//	DWORD				dwCSPCount;
//	DWORD				dwSignProvIndex;
//	DWORD				dwSignKeySize;
//	DWORD				dwEncryptProvIndex;
//	DWORD				dwEncryptKeySize;
//
//
// typedef struct _CEP_CSP_INFO
//{
//	LPWSTR		pwszCSPName;				
//	DWORD		dwCSPType;
//	BOOL		fSignature;
//	BOOL		fExchange;
//	DWORD		dwMaxSign;						//Max key length of signature
//	DWORD		dwMinSign;						//Min key length of signature
//	DWORD		dwDefaultSign;					//default key length of signature
//	DWORD		dwMaxEncrypt;
//	DWORD		dwMinEncrypt;
//	DWORD		dwDefaultEncrypt;
//	DWORD		*pdwSignList;					//the table of possible signing key length
//	DWORD		dwSignCount;				    //the count of entries in the table
//	DWORD		*pdwEncryptList;
//	DWORD		dwEncryptCount;
//}CEP_CSP_INFO;
//
//
//------------------------------------------------------------------------
BOOL WINAPI CEPGetCSPInformation(CEP_WIZARD_INFO *pCEPWizardInfo)
{
	BOOL				fResult=FALSE;
    DWORD				dwCSPIndex=0;	
	DWORD				dwProviderType=0;
	DWORD				cbSize=0;
	DWORD				dwFlags=0;
	DWORD				dwIndex=0;
	int					iDefaultSignature=-1;
	int					iDefaultEncryption=-1;
    PROV_ENUMALGS_EX	paramData;

	CEP_CSP_INFO		*pCSPInfo=NULL;
	HCRYPTPROV			hProv = NULL;

    //enum all the providers on the system
   while(CryptEnumProvidersU(
                            dwCSPIndex,
                            NULL,
                            0,
                            &dwProviderType,
                            NULL,
                            &cbSize))
   {

		pCSPInfo=(CEP_CSP_INFO	*)malloc(sizeof(CEP_CSP_INFO));

		if(NULL == pCSPInfo)
			goto MemoryErr;

		memset(pCSPInfo, 0, sizeof(CEP_CSP_INFO));

        pCSPInfo->pwszCSPName=(LPWSTR)malloc(cbSize);

		if(NULL==(pCSPInfo->pwszCSPName))
			goto MemoryErr;

        //get the CSP name and the type
        if(!CryptEnumProvidersU(
                            dwCSPIndex,
                            NULL,
                            0,
                            &(pCSPInfo->dwCSPType),
                            pCSPInfo->pwszCSPName,
                            &cbSize))
            goto TryNext;

		if(!CryptAcquireContextU(&hProv,
                NULL,
                pCSPInfo->pwszCSPName,
                pCSPInfo->dwCSPType,
                CRYPT_VERIFYCONTEXT))
			goto TryNext;

		//get the max/min of key length for both signature and encryption
		dwFlags=CRYPT_FIRST;
		cbSize=sizeof(paramData);
		memset(&paramData, 0, sizeof(PROV_ENUMALGS_EX));

		while(CryptGetProvParam(
                hProv,
                PP_ENUMALGS_EX,
                (BYTE *) &paramData,
                &cbSize,
                dwFlags))
        {
			if (ALG_CLASS_SIGNATURE == GET_ALG_CLASS(paramData.aiAlgid))
			{
				pCSPInfo->fSignature=TRUE;
				pCSPInfo->dwMaxSign = paramData.dwMaxLen;
				pCSPInfo->dwMinSign = paramData.dwMinLen;
			}

			if (ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS(paramData.aiAlgid))
			{
				pCSPInfo->fEncryption=TRUE;
				pCSPInfo->dwMaxEncrypt = paramData.dwMaxLen;
				pCSPInfo->dwMinEncrypt = paramData.dwMinLen;
			}

			dwFlags=0;
			cbSize=sizeof(paramData);
			memset(&paramData, 0, sizeof(PROV_ENUMALGS_EX));
		}

		//the min/max has to within the limit
		if(pCSPInfo->fSignature)
		{
			if(pCSPInfo->dwMaxSign < g_rgdwSmallKeyLength[0])
				pCSPInfo->fSignature=FALSE;

			if(pCSPInfo->dwMinSign > g_rgdwKeyLength[g_dwKeyLengthCount-1])
				pCSPInfo->fSignature=FALSE;

		}

		if(pCSPInfo->fEncryption)
		{
			if(pCSPInfo->dwMaxEncrypt < g_rgdwSmallKeyLength[0])
				pCSPInfo->fEncryption=FALSE;

			if(pCSPInfo->dwMinEncrypt > g_rgdwKeyLength[g_dwKeyLengthCount-1])
				pCSPInfo->fEncryption=FALSE;
		}

		if((FALSE == pCSPInfo->fEncryption) && (FALSE==pCSPInfo->fSignature))
			goto TryNext;

		//decide the default key length
		for(dwIndex=0; dwIndex<g_dwDefaultKeyCount; dwIndex++)
		{	
			if((pCSPInfo->fSignature) && (0==pCSPInfo->dwDefaultSign))
			{
				if((g_rgdwDefaultKey[dwIndex] >= pCSPInfo->dwMinSign) &&
				   (g_rgdwDefaultKey[dwIndex] <= pCSPInfo->dwMaxSign)
				  )
				  pCSPInfo->dwDefaultSign=g_rgdwDefaultKey[dwIndex];
			}

			if((pCSPInfo->fEncryption) && (0==pCSPInfo->dwDefaultEncrypt))
			{
				if((g_rgdwDefaultKey[dwIndex] >= pCSPInfo->dwMinEncrypt) &&
				   (g_rgdwDefaultKey[dwIndex] <= pCSPInfo->dwMaxEncrypt)
				  )
				  pCSPInfo->dwDefaultEncrypt=g_rgdwDefaultKey[dwIndex];
			}
		}

		//make sure that we have find a default
		if((pCSPInfo->fSignature) && (0==pCSPInfo->dwDefaultSign))
			goto TryNext;

		if((pCSPInfo->fEncryption) && (0==pCSPInfo->dwDefaultEncrypt))
			goto TryNext;

		//decide the display list
		if(pCSPInfo->fSignature)
		{
			if(pCSPInfo->dwMaxSign <= g_rgdwSmallKeyLength[g_dwSmallKeyLengthCount-1])
			{
				pCSPInfo->pdwSignList=g_rgdwSmallKeyLength;
				pCSPInfo->dwSignCount=g_dwSmallKeyLengthCount;
			}
			else
			{
				pCSPInfo->pdwSignList=g_rgdwKeyLength;
				pCSPInfo->dwSignCount=g_dwKeyLengthCount;
			}
		}


		if(pCSPInfo->fEncryption)
		{
			if(pCSPInfo->dwMaxEncrypt <= g_rgdwSmallKeyLength[g_dwSmallKeyLengthCount-1])
			{
				pCSPInfo->pdwEncryptList=g_rgdwSmallKeyLength;
				pCSPInfo->dwEncryptCount=g_dwSmallKeyLengthCount;
			}
			else
			{
				pCSPInfo->pdwEncryptList=g_rgdwKeyLength;
				pCSPInfo->dwEncryptCount=g_dwKeyLengthCount;
			}
		}


		//the CSP looks good
		(pCEPWizardInfo->dwCSPCount)++;

		//realloc to mapped to LocalRealloc which does not take NULL
		if(1 == pCEPWizardInfo->dwCSPCount)
			pCEPWizardInfo->rgCSPInfo=(CEP_CSP_INFO	*)malloc(sizeof(CEP_CSP_INFO));
		else
			pCEPWizardInfo->rgCSPInfo=(CEP_CSP_INFO	*)realloc(pCEPWizardInfo->rgCSPInfo,
			(pCEPWizardInfo->dwCSPCount) * sizeof(CEP_CSP_INFO));

		if(NULL==pCEPWizardInfo->rgCSPInfo)
		{
			pCEPWizardInfo->dwCSPCount=0;
			goto MemoryErr;	
		}

		memcpy(&(pCEPWizardInfo->rgCSPInfo[(pCEPWizardInfo->dwCSPCount)-1]),
			pCSPInfo, sizeof(CEP_CSP_INFO));

		free(pCSPInfo);

		pCSPInfo=NULL;
		
		//we default to use RSA_FULL
		if(0 == _wcsicmp(pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwCSPCount-1].pwszCSPName,
						MS_DEF_PROV_W))
		{
			if(pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwCSPCount-1].fSignature)
			{
				iDefaultSignature=pCEPWizardInfo->dwCSPCount-1;
			}

			if(pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwCSPCount-1].fEncryption)
			{
				iDefaultEncryption=pCEPWizardInfo->dwCSPCount-1;
			}
		}


TryNext:
		cbSize=0;

		dwCSPIndex++;

		if(pCSPInfo)
		{
			if(pCSPInfo->pwszCSPName)
				free(pCSPInfo->pwszCSPName);

			free(pCSPInfo);
		}

		pCSPInfo=NULL;

		if(hProv)
			CryptReleaseContext(hProv, 0);

		hProv=NULL;
	}

	
	//we need to have some valid data
	if((0==pCEPWizardInfo->dwCSPCount) || (NULL==pCEPWizardInfo->rgCSPInfo))
		goto InvalidArgErr;

	//get the default CSP selection
	if(-1 != iDefaultSignature)
		pCEPWizardInfo->dwSignProvIndex=iDefaultSignature;
	else
	{
		//find the 1st signature CSP 
		for(dwIndex=0; dwIndex < pCEPWizardInfo->dwCSPCount; dwIndex++)
		{
			if(pCEPWizardInfo->rgCSPInfo[dwIndex].fSignature)
			{
				pCEPWizardInfo->dwSignProvIndex=dwIndex;
				break;
			}

			//we do no have signature CSPs
			if(dwIndex == pCEPWizardInfo->dwCSPCount)
				goto InvalidArgErr;

		}
	}

	pCEPWizardInfo->dwSignKeyLength=pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwSignProvIndex].dwDefaultSign;

	if(-1 != iDefaultEncryption)
		pCEPWizardInfo->dwEncryptProvIndex=iDefaultEncryption;
	else
	{
		//find the 1st exchange CSP
		for(dwIndex=0; dwIndex < pCEPWizardInfo->dwCSPCount; dwIndex++)
		{
			if(pCEPWizardInfo->rgCSPInfo[dwIndex].fEncryption)
			{
				pCEPWizardInfo->dwEncryptProvIndex=dwIndex;
				break;
			}

			//we do no have encryption CSPs
			if(dwIndex == pCEPWizardInfo->dwCSPCount)
				goto InvalidArgErr;
		}
	}

	pCEPWizardInfo->dwEncryptKeyLength=pCEPWizardInfo->rgCSPInfo[pCEPWizardInfo->dwEncryptProvIndex].dwDefaultEncrypt;


	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

	if(pCSPInfo)
	{
		if(pCSPInfo->pwszCSPName)
			free(pCSPInfo->pwszCSPName);

		free(pCSPInfo);
	}

	if(hProv)
		CryptReleaseContext(hProv, 0);

	if(pCEPWizardInfo->rgCSPInfo)
	{
		for(dwIndex=0; dwIndex < pCEPWizardInfo->dwCSPCount; dwIndex++)
		{
			if(pCEPWizardInfo->rgCSPInfo[dwIndex].pwszCSPName)
				free(pCEPWizardInfo->rgCSPInfo[dwIndex].pwszCSPName);
		}

		free(pCEPWizardInfo->rgCSPInfo);
	}

	pCEPWizardInfo->dwCSPCount=0;

	pCEPWizardInfo->rgCSPInfo=NULL;

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MemoryErr, E_OUTOFMEMORY);   
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//-----------------------------------------------------------------------
//
//    UpdateCEPRegistry
//
//------------------------------------------------------------------------
BOOL WINAPI UpdateCEPRegistry(BOOL		fPassword, BOOL fEnterpriseCA)
{
	BOOL				fResult=FALSE;
	DWORD				dwDisposition=0;
	LPWSTR				pwszReg[]={MSCEP_REFRESH_LOCATION,          
								   MSCEP_PASSWORD_LOCATION,         
								   MSCEP_PASSWORD_MAX_LOCATION,     
								   MSCEP_PASSWORD_VALIDITY_LOCATION,
								   MSCEP_CACHE_REQUEST_LOCATION,    
								   MSCEP_CATYPE_LOCATION};
	DWORD			    dwRegCount=0;
	DWORD				dwRegIndex=0;


	HKEY				hKey=NULL;	


	//we delete all existing CEP related registry keys
	dwRegCount=sizeof(pwszReg)/sizeof(pwszReg[0]);

	for(dwRegIndex=0; dwRegIndex < dwRegCount; dwRegIndex++)
	{
		RegDeleteKeyU(HKEY_LOCAL_MACHINE, pwszReg[dwRegIndex]);
	}

	//password
	if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_LOCAL_MACHINE,
                        MSCEP_PASSWORD_LOCATION,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
		goto RegErr;

	if(fPassword)
		dwDisposition=1;
	else
		dwDisposition=0;

    if(ERROR_SUCCESS !=  RegSetValueExU(
                hKey, 
                MSCEP_KEY_PASSWORD,
                0,
                REG_DWORD,
                (BYTE *)&dwDisposition,
                sizeof(dwDisposition)))
		goto RegErr;

	if(hKey)
		RegCloseKey(hKey);

	hKey=NULL;

	//caType
	dwDisposition=0;

	if (ERROR_SUCCESS != RegCreateKeyExU(
                        HKEY_LOCAL_MACHINE,
                        MSCEP_CATYPE_LOCATION,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE, 
                        KEY_WRITE, 
                        NULL,
                        &hKey, 
                        &dwDisposition))
		goto RegErr;

	if(fEnterpriseCA)
		dwDisposition=1;
	else
		dwDisposition=0;

    if(ERROR_SUCCESS !=  RegSetValueExU(
                hKey, 
                MSCEP_KEY_CATYPE,
                0,
                REG_DWORD,
                (BYTE *)&dwDisposition,
                sizeof(dwDisposition)))
		goto RegErr;

	fResult=TRUE;

CommonReturn:

	if(hKey)
		RegCloseKey(hKey);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(RegErr);   
}

//-----------------------------------------------------------------------
//
//    EmptyCEPStore
//
//------------------------------------------------------------------------
BOOL WINAPI EmptyCEPStore()
{
	BOOL				fResult=TRUE;
	
	HCERTSTORE			hCEPStore=NULL;
	PCCERT_CONTEXT		pCurCert=NULL;

	if(NULL == (hCEPStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							ENCODE_TYPE,
							NULL,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG | CERT_STORE_OPEN_EXISTING_FLAG,
                            CEP_STORE_NAME)))
		return TRUE;


	if(NULL != (pCurCert=CertEnumCertificatesInStore(hCEPStore, NULL)))
	{
		CertFreeCertificateContext(pCurCert);
		fResult=FALSE;
	}

	CertCloseStore(hCEPStore, 0);

	return fResult;
}

//-----------------------------------------------------------------------
//
//    RemoveRACertificates
//
//------------------------------------------------------------------------
BOOL WINAPI RemoveRACertificates()
{
	PCCERT_CONTEXT		pCurCert=NULL;
	PCCERT_CONTEXT		pPreCert=NULL;
	PCCERT_CONTEXT		pDupCert=NULL;
	BOOL				fResult=TRUE;
	
	HCERTSTORE			hCEPStore=NULL;


	if(hCEPStore=CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
							ENCODE_TYPE,
							NULL,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_OPEN_EXISTING_FLAG,
                            CEP_STORE_NAME))
	{
		while(pCurCert=CertEnumCertificatesInStore(hCEPStore,
												pPreCert))
		{

			if(pDupCert=CertDuplicateCertificateContext(pCurCert))
			{
				if(!CertDeleteCertificateFromStore(pDupCert))
				{
					fResult=FALSE;	
				}

				pDupCert=NULL;
			}
			else
				fResult=FALSE;
			
			pPreCert=pCurCert;
		}

		CertCloseStore(hCEPStore, 0);
	}

	return fResult;
}


//-----------------------------------------------------------------------
//
//     FreeCEPWizardInfo
//
//------------------------------------------------------------------------
void	WINAPI FreeCEPWizardInfo(CEP_WIZARD_INFO *pCEPWizardInfo)
{
	DWORD	dwIndex=0;

	if(pCEPWizardInfo)
	{
		DestroyFonts(pCEPWizardInfo->hBigBold,
					 pCEPWizardInfo->hBold);

		for(dwIndex=0; dwIndex<RA_INFO_COUNT; dwIndex++)
		{
			if(pCEPWizardInfo->rgpwszName[dwIndex])
				free(pCEPWizardInfo->rgpwszName[dwIndex]);
		}

		if(pCEPWizardInfo->rgCSPInfo)
		{
			for(dwIndex=0; dwIndex < pCEPWizardInfo->dwCSPCount; dwIndex++)
			{
				if(pCEPWizardInfo->rgCSPInfo[dwIndex].pwszCSPName)
					free(pCEPWizardInfo->rgCSPInfo[dwIndex].pwszCSPName);
			}

			free(pCEPWizardInfo->rgCSPInfo);
		}

		if(pCEPWizardInfo->pwszUserName)
		{
			free(pCEPWizardInfo->pwszUserName);
		}

		if(pCEPWizardInfo->pwszPassword)
		{
                    SecureZeroMemory(pCEPWizardInfo->pwszPassword, sizeof(WCHAR) * wcslen(pCEPWizardInfo->pwszPassword));
                    free(pCEPWizardInfo->pwszPassword);
		}

		if(pCEPWizardInfo->hAccountToken)
		{
			CloseHandle(pCEPWizardInfo->hAccountToken);
		}

		if(pCEPWizardInfo->pIDsObjectPicker)
		{
			(pCEPWizardInfo->pIDsObjectPicker)->Release();
		}

		memset(pCEPWizardInfo, 0, sizeof(CEP_WIZARD_INFO));
	}
}


//-----------------------------------------------------------------------
//
//     CEPWizardInit
//
//------------------------------------------------------------------------
BOOL    WINAPI CEPWizardInit()
{
    INITCOMMONCONTROLSEX        initcomm = {
        sizeof(initcomm), ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES
    };

    return InitCommonControlsEx(&initcomm);
}

//-----------------------------------------------------------------------
//
// IsValidInstallation
//
//------------------------------------------------------------------------
BOOL WINAPI	IsValidInstallation(UINT	*pidsMsg)
{
	if(!IsNT5())
	{
		*pidsMsg=IDS_NO_NT5;
		return FALSE;
	}

	if(!IsIISInstalled())
	{
		*pidsMsg=IDS_NO_IIS;
		return FALSE;
	}

	if(!IsGoodCaInstalled())
	{
		*pidsMsg=IDS_NO_GOOD_CA;
		return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------
//
// CEPErrorMessageBox
//
//------------------------------------------------------------------------
int WINAPI CEPErrorMessageBox(
    HWND        hWnd,
    UINT        idsReason,
	HRESULT		hr,
    UINT        uType
)
{
	return CEPErrorMessageBoxEx(hWnd,
								idsReason,
								hr,
								uType,
								IDS_CEP_ERROR_MSG_HR,
								IDS_CEP_ERROR_MSG);
}

//-----------------------------------------------------------------------
//
// CEPErrorMessageBoxEx
//
//------------------------------------------------------------------------
int WINAPI CEPErrorMessageBoxEx(
    HWND        hWnd,
    UINT        idsReason,
	HRESULT		hr,
    UINT        uType,
	UINT		idsFormat1,
	UINT		idsFormat2
)
{

    WCHAR   wszReason[MAX_STRING_SIZE];
    WCHAR   wszCaption[MAX_STRING_SIZE];
    UINT    intReturn=0;

	LPWSTR	pwszText=NULL;
	LPWSTR	pwszErrorMsg=NULL;

    if(!LoadStringU(g_hModule, IDS_MEG_CAPTION, wszCaption, sizeof(wszCaption)/sizeof(WCHAR)))
         goto CLEANUP;

	if(!LoadStringU(g_hModule, idsReason, wszReason, sizeof(wszReason)/sizeof(WCHAR)))
         goto CLEANUP;

	if(!FAILED(hr))
		hr=E_FAIL;

    //using W version because this is a NT5 only function call
    if(FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        hr,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                        (LPWSTR) &pwszErrorMsg,
                        0,
                        NULL))
	{

		if(!FormatMessageUnicode(&pwszText, idsFormat1, wszReason, pwszErrorMsg))
			goto CLEANUP;

	}
	else
	{
		if(!FormatMessageUnicode(&pwszText, idsFormat2, wszReason))
			goto CLEANUP;
	}

	intReturn=MessageBoxU(hWnd, pwszText, wszCaption, uType);

	
CLEANUP:
	
	if(pwszText)
		LocalFree((HLOCAL)pwszText);

	if(pwszErrorMsg)
		LocalFree((HLOCAL)pwszErrorMsg);

    return intReturn;
}


//-----------------------------------------------------------------------
//
// CEPMessageBox
//
//------------------------------------------------------------------------
int WINAPI CEPMessageBox(
    HWND        hWnd,
    UINT        idsText,
    UINT        uType
)
{

    WCHAR   wszText[MAX_STRING_SIZE];
    WCHAR   wszCaption[MAX_STRING_SIZE];
    UINT    intReturn=0;

    if(!LoadStringU(g_hModule, IDS_MEG_CAPTION, wszCaption, sizeof(wszCaption)/sizeof(WCHAR)))
         return 0;

    if(!LoadStringU(g_hModule, idsText, wszText, sizeof(wszText)/sizeof(WCHAR)))
        return 0;

	intReturn=MessageBoxU(hWnd, wszText, wszCaption, uType);

    return intReturn;
}

//--------------------------------------------------------------------------
//
//	 SetControlFont
//
//--------------------------------------------------------------------------
void WINAPI SetControlFont(
    IN HFONT    hFont,
    IN HWND     hwnd,
    IN INT      nId
    )
{
	if( hFont )
    {
    	HWND hwndControl = GetDlgItem(hwnd, nId);

    	if( hwndControl )
        {
        	SetWindowFont(hwndControl, hFont, TRUE);
        }
    }
}


//--------------------------------------------------------------------------
//
//	  SetupFonts
//
//--------------------------------------------------------------------------
BOOL WINAPI SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont
    )
{
    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof(ncm);
	
    if(!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0))
        return FALSE;

	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
	LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
	BoldLogFont.lfWeight      = FW_BOLD;

    INT BigBoldFontSize = 12;

	HDC hdc = GetDC( hwnd );

    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * BigBoldFontSize / 72);

        *pBigBoldFont = CreateFontIndirect(&BigBoldLogFont);
		*pBoldFont    = CreateFontIndirect(&BoldLogFont);

        ReleaseDC(hwnd,hdc);

        if(*pBigBoldFont && *pBoldFont)
            return TRUE;
        else
        {
            if( *pBigBoldFont )
            {
                DeleteObject(*pBigBoldFont);
                *pBigBoldFont=NULL;
            }

            if( *pBoldFont )
            {
                DeleteObject(*pBoldFont);
                *pBoldFont=NULL;
            }
            return FALSE;
        }
    }

    return FALSE;
}


//--------------------------------------------------------------------------
//
//	  DestroyFonts
//
//--------------------------------------------------------------------------
void WINAPI DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont
    )
{
    if( hBigBoldFont )
    {
        DeleteObject( hBigBoldFont );
    }

    if( hBoldFont )
    {
        DeleteObject( hBoldFont );
    }
}



//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL WINAPI	FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...)
{
    // get format string from resources
    WCHAR		wszFormat[1000];
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(NULL == ppwszFormat)
        goto InvalidArgErr;

    if(!LoadStringU(g_hModule, ids, wszFormat, sizeof(wszFormat)/sizeof(WCHAR)))
		goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    cbMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
		goto FormatMessageError;

	fResult=TRUE;

CommonReturn:
	
	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}


//--------------------------------------------------------------------------
//
//	  AddLogSourceToRegistry
//
//--------------------------------------------------------------------------
HRESULT WINAPI	AddLogSourceToRegistry(LPWSTR   pwszMsgDLL)
{
    DWORD		dwError=ERROR_SUCCESS;
    DWORD       dwData=0;
    WCHAR       const *pwszRegPath = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";
    WCHAR       NameBuf[MAX_STRING_SIZE];

    HKEY        hkey = NULL;


    wcscpy(NameBuf, pwszRegPath);
    wcscat(NameBuf, MSCEP_EVENT_LOG);

    // Create a new key for our application
    if(ERROR_SUCCESS  != RegOpenKey(HKEY_LOCAL_MACHINE, NameBuf, &hkey))
    {
        if(ERROR_SUCCESS != (dwError = RegCreateKey(HKEY_LOCAL_MACHINE, NameBuf, &hkey)))
			goto CLEANUP;
    }

    // Add the Event-ID message-file name to the subkey

    dwError = RegSetValueEx(
                    hkey,
                    L"EventMessageFile",
                    0,
                    REG_EXPAND_SZ,
                    (const BYTE *) pwszMsgDLL,
                    (wcslen(pwszMsgDLL) + 1) * sizeof(WCHAR));
    
	if(ERROR_SUCCESS != dwError)
		goto CLEANUP;

    // Set the supported types flags and add it to the subkey

    dwData = EVENTLOG_ERROR_TYPE |
                EVENTLOG_WARNING_TYPE |
                EVENTLOG_INFORMATION_TYPE;

    dwError = RegSetValueEx(
                    hkey,
                    L"TypesSupported",
                    0,
                    REG_DWORD,
                    (LPBYTE) &dwData,
                    sizeof(DWORD));
	if(ERROR_SUCCESS != dwError)
		goto CLEANUP;

	dwError=ERROR_SUCCESS;

CLEANUP:

    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    return(HRESULT_FROM_WIN32(dwError));
}


LPWSTR
GetAccountDomainName(BOOL fDC)
/*++

Routine Description:

    Returns the name of the account domain for this machine.

    For workstatations, the account domain is the netbios computer name.
    For DCs, the account domain is the netbios domain name.

Arguments:

    None.

Return Values:

    Returns a pointer to the name.  The name should be free using NetApiBufferFree.

    NULL - on error.

--*/
{
    DWORD WinStatus;

    LPWSTR AllocatedName = NULL;


    //
    // If this machine is a domain controller,
    //  get the domain name.
    //

    if ( fDC ) 
	{

        WinStatus = NetpGetDomainName( &AllocatedName );

        if ( WinStatus != NO_ERROR ) 
		{
			SetLastError(WinStatus);
            return NULL;
        }

    //
    // Otherwise, the 'account domain' is the computername
    //

    }
	else 
	{

        WinStatus = NetpGetComputerName( &AllocatedName );

        if ( WinStatus != NO_ERROR ) 
		{
			SetLastError(WinStatus);
            return NULL;
        }

    }

    return AllocatedName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\setup\setuputil.cpp ===
//--------------------------------------------------------------------
// SetupUtil - implementation
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 8-10-99
//
// Functions needed to set up CEP
//

//--------------------------------------------------------------------
// includes
#include "global.hxx"
#include <xenroll.h>
#include <dbgdef.h>
#include "ErrorHandling.h"
#include "SetupUtil.h"

//--------------------------------------------------------------------
// Constants
static const WCHAR gc_wszRegKeyServices[]=L"System\\CurrentControlSet\\Services";
static const WCHAR gc_wszCertSrvDir[]=L"CertSrv";

// from <wincrypt.h>
static const WCHAR gc_wszEnrollmentAgentOid[]=L"1.3.6.1.4.1.311.20.2.1"; //szOID_ENROLLMENT_AGENT

// from ca\include\certlib.h; ca\certlib\acl.cpp
const GUID GUID_ENROLL={0x0e10c968, 0x78fb, 0x11d2, {0x90, 0xd4, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55}};


//--------------------------------------------------------------------
// IIS magic
#undef DEFINE_GUID
#define INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#include <iwamreg.h>
#include <iadmw.h>
#include <iiscnfg.h>


//--------------------------------------------------------------------
// constants
#include "..\common.h"
#define MAX_METABASE_ATTEMPTS           10      // Times to bang head on wall
#define METABASE_PAUSE                  500     // Time to pause in msec
static const WCHAR gc_wszBaseRoot[]=L"/LM/W3svc/1/ROOT";
static const WCHAR gc_wszCepDllName[]=CEP_DLL_NAME;
static const WCHAR gc_wszCepStoreName[]=CEP_STORE_NAME;
static const WCHAR gc_wszAppPoolBase[]=L"/LM/W3svc/APPPOOLS";

//---------------------------------------------------------------------
// function prototypes

HRESULT
EnableISAPIExtension(
    IN LPCWSTR pcwszExtension,
    OUT BOOL *pfEnabledASP);

HRESULT IsISAPIExtensionEnabled(
    LPCWSTR pcwszExtension,
    bool& rfEnabled);


//####################################################################
// module local functions

//--------------------------------------------------------------------
static HRESULT myHExceptionCode(EXCEPTION_POINTERS * pep)
{
    HRESULT hr=pep->ExceptionRecord->ExceptionCode;
    if (!FAILED(hr)) {
        hr=HRESULT_FROM_WIN32(hr);
    }
    return hr;
}

//--------------------------------------------------------------------
static HRESULT
vrOpenRoot(
    IN IMSAdminBase *pIMeta,
    IN BOOL fReadOnly,
	IN const WCHAR * wszBaseRoot,
    OUT METADATA_HANDLE *phMetaRoot)
{
    HRESULT hr;
    unsigned int nAttempts;

    // Re-try a few times to see if we can get past the block
    nAttempts=0;
    do {

        // Pause on retry
        if (0!=nAttempts) {
            Sleep(METABASE_PAUSE);
        }

        // Make an attempt to open the root
        __try {
            hr=pIMeta->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                wszBaseRoot,
                fReadOnly?
                    METADATA_PERMISSION_READ :
                    (METADATA_PERMISSION_READ |
                     METADATA_PERMISSION_WRITE),
                1000,
                phMetaRoot);
        } _TrapException(hr);

        nAttempts++;

    } while (HRESULT_FROM_WIN32(ERROR_PATH_BUSY)==hr && nAttempts<MAX_METABASE_ATTEMPTS);

    _JumpIfError(hr, error, "OpenKey"); 

error:
    return hr;
}

//--------------------------------------------------------------------
static HRESULT GetRegString(IN HKEY hKey, IN const WCHAR * wszValue, OUT WCHAR ** pwszString)
{
    HRESULT hr;
    DWORD dwDataSize;
    DWORD dwType;
    DWORD dwError;

    // must be cleaned up
    WCHAR * wszString=NULL;

    // init out params
    *pwszString=NULL;

    // get value
    dwDataSize=0;
    dwError=RegQueryValueExW(hKey, wszValue, NULL, &dwType, NULL, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszValue);
    }
    _Verify(REG_SZ==dwType, hr, error);
    wszString=(WCHAR *)LocalAlloc(LPTR, dwDataSize);
    _JumpIfOutOfMemory(hr, error, pwszString);
    dwError=RegQueryValueExW(hKey, wszValue, NULL, &dwType, (BYTE *)wszString, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszValue);
    }
    _Verify(REG_SZ==dwType, hr, error);

    // it worked
    hr=S_OK;
    *pwszString=wszString;
    wszString=NULL;

error:
    if (NULL!=wszString) {
        LocalFree(wszString);
    }
    return hr;
}

//--------------------------------------------------------------------
static HRESULT OpenCertSrvConfig(HKEY * phkey)
{
    HRESULT hr;
    DWORD dwError;
    DWORD dwType;
    DWORD dwDataSize;

    // must be cleaned up
    HKEY hServices=NULL;
    HKEY hCertSvc=NULL;
    HKEY hConfig=NULL;

    // initialize out params
    *phkey=NULL;

    // Open HKLM\System\CurrentControlSet\Services
    dwError=RegOpenKeyExW(HKEY_LOCAL_MACHINE, gc_wszRegKeyServices, 0, KEY_READ, &hServices);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", gc_wszRegKeyServices);
    }

    // open CertSvc\Configuration
    dwError=RegOpenKeyExW(hServices, wszSERVICE_NAME, 0, KEY_READ, &hCertSvc);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszSERVICE_NAME);
    }
    dwError=RegOpenKeyExW(hCertSvc, wszREGKEYCONFIG, 0, KEY_READ, &hConfig);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszREGKEYCONFIG);
    }

    // we were successfull
    hr=S_OK;
    *phkey=hConfig;
    hConfig=0;

error:
    if (NULL!=hConfig) {
        RegCloseKey(hConfig);
    }
    if (NULL!=hCertSvc) {
        RegCloseKey(hCertSvc);
    }
    if (NULL!=hServices) {
        RegCloseKey(hServices);
    }
    return hr;
}

//--------------------------------------------------------------------
static HRESULT OpenCurrentCAConfig(HKEY * phkey)
{
    HRESULT hr;
    DWORD dwError;
    DWORD dwType;
    DWORD dwDataSize;

    // must be cleaned up
    HKEY hConfig=NULL;
    HKEY hCurConfig=NULL;
    WCHAR * wszActiveConfig=NULL;

    // initialize out params
    *phkey=NULL;

    // Open HKLM\System\CurrentControlSet\Services\CertSvc\Configuration
    hr=OpenCertSrvConfig(&hConfig);
    _JumpIfError(hr, error, "OpenCertSrvConfig");

    // get value "active"
    hr=GetRegString(hConfig, wszREGACTIVE, &wszActiveConfig);
    _JumpIfErrorStr(hr, error, "GetRegString", wszREGACTIVE);

    // and open <active>
    dwError=RegOpenKeyExW(hConfig, wszActiveConfig, 0, KEY_ALL_ACCESS, &hCurConfig);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegOpenKeyEx", wszActiveConfig);
    }

    // we were successfull
    hr=S_OK;
    *phkey=hCurConfig;
    hCurConfig=0;

error:
    if (NULL!=hCurConfig) {
        RegCloseKey(hCurConfig);
    }
    if (NULL!=wszActiveConfig) {
        LocalFree(wszActiveConfig);
    }
    if (NULL!=hConfig) {
        RegCloseKey(hConfig);
    }
    return hr;
}


//--------------------------------------------------------------------
// stolen from certlib.cpp. use this until Pete fixes the api.
static HRESULT GetCADsName(OUT WCHAR **pwszName)
{
#define cwcCNMAX        64              // 64 chars max for CN
#define cwcCHOPHASHMAX  (1+5)           // "-%05hu" decimal USHORT hash digits
#define cwcSUFFIXMAX    (1 + 5 + 1)     // five decimal digits plus parentheses
#define cwcCHOPBASE     (cwcCNMAX-(cwcCHOPHASHMAX+cwcSUFFIXMAX))

    HRESULT hr;
    DWORD cwc;
    DWORD cwcCopy;
    WCHAR wszDSName[cwcCHOPBASE+cwcCHOPHASHMAX+1];

    // must be cleaned up
    HKEY hConfig=NULL;
    WCHAR * wszSanitizedName=NULL;

    // initialize out params
    *pwszName=NULL;

    // Open HKLM\System\CurrentControlSet\Services\CertSvc\Configuration
    hr=OpenCertSrvConfig(&hConfig);
    _JumpIfError(hr, error, "OpenCertSrvConfig");

    // get value "active" - this is the sanitized name
    hr=GetRegString(hConfig, wszREGACTIVE, &wszSanitizedName);
    _JumpIfErrorStr(hr, error, "GetRegString", wszREGACTIVE);


    // ----- begin stolen code -----
    cwc = wcslen(wszSanitizedName);
    cwcCopy = cwc;
    if (cwcCHOPBASE < cwcCopy)
    {
        cwcCopy = cwcCHOPBASE;
    }
    CopyMemory(wszDSName, wszSanitizedName, cwcCopy * sizeof(WCHAR));
    wszDSName[cwcCopy] = L'\0';

    if (cwcCHOPBASE < cwc)
    {
        // Hash the rest of the name into a USHORT
        USHORT usHash = 0;
        DWORD i;
        WCHAR *pwsz;

        // Truncate an incomplete sanitized Unicode character
        
        pwsz = wcsrchr(wszDSName, L'!');
        if (NULL != pwsz && wcslen(pwsz) < 5)
        {
            cwcCopy -= wcslen(pwsz);
            *pwsz = L'\0';
        }

        for (i = cwcCopy; i < cwc; i++)
        {
            USHORT usLowBit = (0x8000 & usHash)? 1 : 0;

            usHash = ((usHash << 1) | usLowBit) + wszSanitizedName[i];
        }
        wsprintf(&wszDSName[cwcCopy], L"-%05hu", usHash);
        //CSASSERT(wcslen(wszDSName) < ARRAYSIZE(wszDSName));
    }
    // ----- end stolen code -----

    *pwszName=(WCHAR *)LocalAlloc(LPTR, (wcslen(wszDSName)+1)*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, *pwszName);
    wcscpy(*pwszName, wszDSName);

    hr=S_OK;
error:
    if (NULL!=wszSanitizedName) {
        LocalFree(wszSanitizedName);
    }
    if (NULL!=hConfig) {
        RegCloseKey(hConfig);
    }
    return hr;
}



//--------------------------------------------------------------------
HRESULT	SetSDOnCEPCertificate(BSTR bstrCertificate, SID * psidAccount)
{
	HRESULT					hr=E_FAIL;
	DWORD					dwKeySpec=0;
	BOOL					fFreeProv=FALSE;
	CERT_BLOB				blobCert;
	DWORD					dwSD=0;
    PACL					pAcl=NULL;
    BOOL					fDacl = TRUE;
    BOOL					fDef = FALSE;
    ACL_SIZE_INFORMATION	AclInfo;
	DWORD					dwAccess=ACTRL_FILE_READ | ACTRL_FILE_READ_PROP | ACTRL_FILE_READ_ATTRIB;
	ACE_HEADER				*pFirstAce=NULL;

    PSECURITY_DESCRIPTOR	pNewSD = NULL;
    PACL					pNewAcl = NULL;
	PSECURITY_DESCRIPTOR	pSID=NULL;
	HCERTSTORE				hCEPStore=NULL;
	PCERT_CONTEXT			pCertContext=NULL;
	PCCERT_CONTEXT			pCEPCert=NULL;
	HCRYPTPROV				hProv=NULL;

	//open the CEP store
	if(NULL == (hCEPStore=CertOpenStore(
							CERT_STORE_PROV_SYSTEM_W,
							ENCODE_TYPE,
							NULL,
                            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
                            CEP_STORE_NAME)))
	{
		hr=E_UNEXPECTED;
		_JumpError(hr, error, "CertOpenStore");
	}

	//get the certificate context
	memset(&blobCert, 0, sizeof(blobCert));
	blobCert.cbData = (DWORD)SysStringByteLen(bstrCertificate);
	blobCert.pbData = (BYTE *)bstrCertificate;

	if(!CryptQueryObject(
		  CERT_QUERY_OBJECT_BLOB,
		  &blobCert,
		  CERT_QUERY_CONTENT_FLAG_CERT,
		  CERT_QUERY_FORMAT_FLAG_ALL,
		  0,
		  NULL,
		  NULL,
		  NULL,
		  NULL,
		  NULL,
		  (const void **)&pCertContext))
	{
		hr=HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "CryptQueryObject");
	}

	if(NULL == pCertContext)
	{
		hr=E_UNEXPECTED;
		_JumpError(hr, error, "CryptQueryObject");
	}

	//find the certificate in CEP store
	if(NULL == (pCEPCert=CertFindCertificateInStore(
				hCEPStore,
                X509_ASN_ENCODING,
                0,
                CERT_FIND_EXISTING,
                pCertContext,
                NULL)))
	{
		hr=E_UNEXPECTED;
		_JumpError(hr, error, "CertFindCertificateInStore");
	}

	//set the SD on the private key
	if(!CryptAcquireCertificatePrivateKey(pCEPCert,
										  CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
										  NULL,
										  &hProv,
										  &dwKeySpec,
										  &fFreeProv))
	{
		hr=HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "CryptAcquireCertificatePrivateKey");
	}

	if(!CryptGetProvParam(
                hProv,
                PP_KEYSET_SEC_DESCR,
                NULL,
                &dwSD,
                DACL_SECURITY_INFORMATION))
	{
		hr=HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "CryptAcquireCertificatePrivateKey");
	}

	pSID = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSD);
    if (NULL == pSID)
    {
        hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
    }

	if(!CryptGetProvParam(
                hProv,
                PP_KEYSET_SEC_DESCR,
                (BYTE *)pSID,
                &dwSD,
                DACL_SECURITY_INFORMATION))
	{
		hr=HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "CryptGetProvParam");
	}

    //get acl from sd
    if(!GetSecurityDescriptorDacl(
            pSID,
            &fDacl,
            &pAcl,
            &fDef))
    {
		hr=HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "GetSecurityDescriptorDacl");
    }

	//if no dacl or everyone access, quit
    if((NULL==pAcl) || (FALSE == fDacl))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "GetSecurityDescriptorDacl");
    }

    //get acl info
    if(!GetAclInformation(
            pAcl,
            &AclInfo,
            sizeof(AclInfo),
            AclSizeInformation))
    {
		hr=HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "GetAclInformation");
    }

    //allocate enough for new dacl since we might add a new ACE
	dwSD=AclInfo.AclBytesInUse		
		+sizeof(ACCESS_ALLOWED_ACE) 
		-sizeof(DWORD) //ACCESS_ALLOWED_ACE::SidStart
		+GetLengthSid(psidAccount);

    pNewAcl = (PACL)LocalAlloc(LPTR, dwSD);
    if(NULL == pNewAcl)
    {
        hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
    }

    if(!InitializeAcl(pNewAcl, dwSD, ACL_REVISION_DS))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "InitializeAcl");
    }

    // find the first ace in the dacl
    if (!GetAce(pAcl, 0, (void **)&pFirstAce)) 
	{
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "GetAce");
    }

    // add all the old aces
    if (!AddAce(pNewAcl, ACL_REVISION_DS, 0, pFirstAce, AclInfo.AclBytesInUse-sizeof(ACL))) 
	{
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "AddAce");
    }

	//add the access allowed ACE
	if(!AddAccessAllowedAce(pNewAcl, ACL_REVISION, dwAccess,  psidAccount))
	{
		hr=HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "AddAccessAllowedAce");
	}

    // initialize a security descriptor.  
    pNewSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pNewSD == NULL)
    { 
        hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
    } 
 
    if(!InitializeSecurityDescriptor(pNewSD, SECURITY_DESCRIPTOR_REVISION))
    {  
        hr = HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "InitializeSecurityDescriptor");
    } 
 
    // add the ACL to the security descriptor. 
    if(!SetSecurityDescriptorDacl(
            pNewSD, 
            TRUE,     // fDaclPresent flag   
            pNewAcl, 
            FALSE))   // not a default DACL 
    {  
        hr = HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "SetSecurityDescriptorDacl");
    } 

    //set sd to be protected
    if(!SetSecurityDescriptorControl(
            pNewSD,
            SE_DACL_PROTECTED,
            SE_DACL_PROTECTED))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "SetSecurityDescriptorControl");
    }

    if(!IsValidSecurityDescriptor(pNewSD))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "IsValidSecurityDescriptor");
    }

    //we just set it back to the privaet key
    if(!CryptSetProvParam(
            hProv,
            PP_KEYSET_SEC_DESCR,
            (BYTE*)pNewSD,
            DACL_SECURITY_INFORMATION))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
		_JumpError(hr, error, "CryptSetProvParam");
    }


    hr=S_OK;

error:

    if(pNewSD) 
    {
        LocalFree(pNewSD);
    }

	if(pSID)
	{
		LocalFree(pSID);
	}

    if(pNewAcl) 
    {
        LocalFree(pNewAcl);
    }

	if(fFreeProv)
	{
		if(hProv)
			CryptReleaseContext(hProv, 0);
	}

	if(pCEPCert)
	{
		CertFreeCertificateContext(pCEPCert);
	}

	if(pCertContext)
	{
		CertFreeCertificateContext(pCertContext);
	}

	if(hCEPStore)
	{
		CertCloseStore(hCEPStore, 0);
	}

	return hr;
}

//--------------------------------------------------------------------
static HRESULT EnrollForRACert(
            IN const WCHAR * wszDistinguishedName,
            IN const WCHAR * wszCSPName,
            IN DWORD dwCSPType,
            IN DWORD dwKeySize,
            IN DWORD dwKeySpec,
            IN const WCHAR * wszTemplate,
			IN SID   *psidAccount
            )
{
    HRESULT hr;
    LONG nDisposition;
    LONG nRequestID;

    // must be cleaned up
    ICEnroll3 * pXEnroll=NULL;
    BSTR bszConfigString=NULL;
    BSTR bszRequest=NULL;
	ICertConfig  * pICertConfig=NULL;
    ICertRequest * pICertRequest=NULL;
    ICertAdmin * pICertAdmin=NULL;
    BSTR bszCertificate=NULL;

    // get the config string
    hr=CoCreateInstance(
        CLSID_CCertConfig,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ICertConfig,
        (void **)&pICertConfig);
    _JumpIfError(hr, error, "CoCreateInstance(CLSID_CCertConfig)");

	hr = pICertConfig->GetConfig(CC_LOCALCONFIG, &bszConfigString);
    _JumpIfError(hr, error, "GetConfig");


    // create XEnroll
    hr=CoCreateInstance(
        CLSID_CEnroll,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ICEnroll3,
        (void **)&pXEnroll);
    _JumpIfError(hr, error, "CoCreateInstance(CLSID_CEnroll)");

    // build the Offline enrollment agent cert.

    hr=pXEnroll->put_ProviderName((WCHAR *)wszCSPName);
    _JumpIfError(hr, error, "put_ProviderName");
    hr=pXEnroll->put_ProviderType(dwCSPType);
    _JumpIfError(hr, error, "put_ProviderType");
    hr=pXEnroll->put_ProviderFlags(CRYPT_MACHINE_KEYSET); // used in CryptAcquireContext
    _JumpIfError(hr, error, "put_ProviderFlags");
    hr=pXEnroll->put_GenKeyFlags(dwKeySize<<16);
    _JumpIfError(hr, error, "put_GenKeyFlags");
    hr=pXEnroll->put_KeySpec(dwKeySpec);
    _JumpIfError(hr, error, "put_KeySpec");
    hr=pXEnroll->put_LimitExchangeKeyToEncipherment(AT_KEYEXCHANGE==dwKeySpec);
    _JumpIfError(hr, error, "put_LimitExchangeKeyToEncipherment");
    hr=pXEnroll->put_UseExistingKeySet(FALSE);
    _JumpIfError(hr, error, "put_UseExistingKeySet");
    hr=pXEnroll->put_RequestStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE); // the keys attached to the dummy request cert go in the local machine store
    _JumpIfError(hr, error, "put_RequestStoreFlags");
    hr=pXEnroll->addCertTypeToRequest((WCHAR *)wszTemplate);
    _JumpIfErrorStr(hr, error, "addCertTypeToRequest", wszTemplate);

    hr=pXEnroll->createPKCS10((WCHAR *)wszDistinguishedName, (WCHAR *)gc_wszEnrollmentAgentOid, &bszRequest);
    _JumpIfError(hr, error, "CreatePKCS10");

    // create ICertRequest
    hr=CoCreateInstance(
        CLSID_CCertRequest,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ICertRequest,
        (void **)&pICertRequest);
    _JumpIfError(hr, error, "CoCreateInstance(CLSID_CCertRequest)");

    // request the cert
    hr=pICertRequest->Submit(CR_IN_BASE64, bszRequest, NULL, bszConfigString, &nDisposition);
    _JumpIfError(hr, error, "Submit");

    // did we get it?
    if (CR_DISP_UNDER_SUBMISSION==nDisposition) {
        // we need to approve it. No problem!
        hr=pICertRequest->GetRequestId(&nRequestID);
        _JumpIfError(hr, error, "GetRequestId");

        // create ICertAdmin
        hr=CoCreateInstance(
            CLSID_CCertAdmin,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_ICertAdmin,
            (void **)&pICertAdmin);
        _JumpIfError(hr, error, "CoCreateInstance(CLSID_CCertAdmin)");

        // resubmit it
        hr=pICertAdmin->ResubmitRequest(bszConfigString, nRequestID, &nDisposition);
        _JumpIfError(hr, error, "ResubmitRequest");
        // This should have worked, but we're going to ignore the 
        //   returned disposition and use the one from the next call.

        // now, get the cert that we just approved
        hr=pICertRequest->RetrievePending(nRequestID, bszConfigString, &nDisposition);
        _JumpIfError(hr, error, "RetrievePending");
    }

    // We should have it by now.
    _Verify(CR_DISP_ISSUED==nDisposition, hr, error);

    // grab the cert from the CA
    hr=pICertRequest->GetCertificate(CR_OUT_BASE64, &bszCertificate);
    _JumpIfError(hr, error, "GetCertificate");


    // install the cert

    
    hr=pXEnroll->put_MyStoreName((WCHAR *)gc_wszCepStoreName); // We have to use our special store
    _JumpIfError(hr, error, "put_MyStoreName");
    hr=pXEnroll->put_MyStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE); // the keys attached to the final cert also go in the local machine store
    _JumpIfError(hr, error, "put_MyStoreFlags");
    hr=pXEnroll->put_RootStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE);
    _JumpIfError(hr, error, "put_RootStoreFlags");
    hr=pXEnroll->put_CAStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE);
    _JumpIfError(hr, error, "put_CAStoreFlags");
    hr=pXEnroll->put_SPCFileName(L"");
    _JumpIfError(hr, error, "put_MyStoreName");

    hr=pXEnroll->acceptPKCS7(bszCertificate);
    _JumpIfError(hr, error, "acceptPKCS7");

	//set the SD on the private key of the enrolled certificate
	if(psidAccount)
	{
		hr=SetSDOnCEPCertificate(bszCertificate, psidAccount);
		_JumpIfError(hr, error, "acceptPKCS7");
	}

    // all done
    hr=S_OK;
error:
	if(NULL!=pICertConfig){
		pICertConfig->Release();
	}

    if (NULL!=bszCertificate) {
        SysFreeString(bszCertificate);
    }
    if (NULL!=pICertAdmin) {
        pICertAdmin->Release();
    }
    if (NULL!=pICertRequest) {
        pICertRequest->Release();
    }
    if (NULL!=bszRequest) {
        SysFreeString(bszRequest);
    }
    if (NULL!=bszConfigString) {
        SysFreeString(bszConfigString);
    }
    if (NULL!=pXEnroll) {
        pXEnroll->Release();
    }

    return hr;
}

//--------------------------------------------------------------------
// DEBUG, not used
static BOOL DumpTokenGroups(void)
{
#define MAX_NAME 256
    DWORD i, dwSize = 0, dwResult = 0;
    HANDLE hToken;
    PTOKEN_GROUPS pGroupInfo;
    SID_NAME_USE SidType;
    char lpName[MAX_NAME];
    char lpDomain[MAX_NAME];
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
   
    // Open a handle to the access token for the calling process.

    if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken )) {
        wprintf( L"OpenProcessToken Error %u\n", GetLastError() );
        return FALSE;
    }

    // Call GetTokenInformation to get the buffer size.

    if(!GetTokenInformation(hToken, TokenGroups, NULL, dwSize, &dwSize)) {
        dwResult = GetLastError();
        if( dwResult != ERROR_INSUFFICIENT_BUFFER ) {
            wprintf( L"GetTokenInformation Error %u\n", dwResult );
            return FALSE;
        }
    }

    // Allocate the buffer.

    pGroupInfo = (PTOKEN_GROUPS) GlobalAlloc( GPTR, dwSize );

    // Call GetTokenInformation again to get the group information.

    if(! GetTokenInformation(hToken, TokenGroups, pGroupInfo, 
                            dwSize, &dwSize ) ) {
        wprintf( L"GetTokenInformation Error %u\n", GetLastError() );
        return FALSE;
       }


    // Loop through the group SIDs looking for the administrator SID.
    for(i=0; i<pGroupInfo->GroupCount; i++) {

        // Lookup the account name and print it.

        dwSize = MAX_NAME;
        if( !LookupAccountSidA( NULL, pGroupInfo->Groups[i].Sid,
                              lpName, &dwSize, lpDomain, 
                              &dwSize, &SidType ) ) {
            dwResult = GetLastError();
            if( dwResult == ERROR_NONE_MAPPED )
                strcpy( lpName, "NONE_MAPPED" );
            else {
                wprintf(L"LookupAccountSid Error %u\n", GetLastError());
                return FALSE;
            }
        }

        char * szSid=NULL;
        if (!ConvertSidToStringSidA(pGroupInfo->Groups[i].Sid, &szSid)) {
            wprintf(L"ConvertSidToStringSid Error %u\n", GetLastError());
            return FALSE;
        }
 
        // Find out if the SID is enabled in the token
        char * szEnable;
        if (pGroupInfo->Groups[i].Attributes & SE_GROUP_ENABLED) {
            szEnable="enabled";
        } else if (pGroupInfo->Groups[i].Attributes & SE_GROUP_USE_FOR_DENY_ONLY) {
            szEnable="deny-only";
        } else {
            szEnable="not enabled";
        }

        wprintf( L"Member of %hs\\%hs (%hs) (%hs)\n", 
                lpDomain, lpName, szSid, szEnable );

        LocalFree(szSid);
    }

    if ( pGroupInfo )
        GlobalFree( pGroupInfo );
    return TRUE;
}

//--------------------------------------------------------------------
// DEBUG, not used
static void DumpAcl(PACL pAcl, ACL_SIZE_INFORMATION aclsizeinfo)
{
    HRESULT hr;
    unsigned int nIndex;
    DWORD dwError;

    wprintf(L"/-- begin ACL ---\n");
    for (nIndex=0; nIndex<aclsizeinfo.AceCount; nIndex++) {
        ACE_HEADER * pAceHeader;
        PSID pSid=NULL;
        wprintf(L"| ");
        if (!GetAce(pAcl, nIndex, (void**)&pAceHeader)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            wprintf(L" (GetAce failed:0x%08X)\n", hr);
            continue;
        }
        wprintf(L"[");
        if (ACCESS_ALLOWED_ACE_TYPE==pAceHeader->AceType) {
            wprintf(L"aA_");
            pSid=&((ACCESS_ALLOWED_ACE *)pAceHeader)->SidStart;
        } else if (ACCESS_DENIED_ACE_TYPE==pAceHeader->AceType) {
            wprintf(L"aD_");
            pSid=&((ACCESS_DENIED_ACE *)pAceHeader)->SidStart;
        } else if (ACCESS_ALLOWED_OBJECT_ACE_TYPE==pAceHeader->AceType) {
            wprintf(L"aAo");
            pSid=&((ACCESS_ALLOWED_OBJECT_ACE *)pAceHeader)->SidStart;
            if (((ACCESS_ALLOWED_OBJECT_ACE *)pAceHeader)->Flags!=(ACE_OBJECT_TYPE_PRESENT|ACE_INHERITED_OBJECT_TYPE_PRESENT)) {
                pSid=((BYTE *)pSid)-sizeof(GUID);
            }
        } else if (ACCESS_DENIED_OBJECT_ACE_TYPE==pAceHeader->AceType) {
            wprintf(L"aDo");
            pSid=&((ACCESS_DENIED_OBJECT_ACE *)pAceHeader)->SidStart;
            if (((ACCESS_DENIED_OBJECT_ACE *)pAceHeader)->Flags!=(ACE_OBJECT_TYPE_PRESENT|ACE_INHERITED_OBJECT_TYPE_PRESENT)) {
                pSid=((BYTE *)pSid)-sizeof(GUID);
            }
        } else {
            wprintf(L"sa?");
        }

        wprintf(L"] ");
        if (NULL!=pSid) {
            // print the sid
            {
                WCHAR wszName[MAX_NAME];
                WCHAR wszDomain[MAX_NAME];
                DWORD dwSize=MAX_NAME;
                SID_NAME_USE SidType;
                if(!LookupAccountSidW(
                        NULL, pSid,
                        wszName, &dwSize, wszDomain, 
                        &dwSize, &SidType))
                {
                    dwError=GetLastError();
                    if (dwError==ERROR_NONE_MAPPED) {
                        wprintf(L"(Unknown)");
                    } else {
                        hr=HRESULT_FROM_WIN32(dwError);
                        wprintf(L"(Error 0x%08X)", hr);
                    }
                } else {
                    wprintf(L"%ws\\%ws", wszDomain, wszName);
                }
            }
            { 
                WCHAR * wszSid=NULL;
                if (!ConvertSidToStringSidW(pSid, &wszSid)) {
                    hr=HRESULT_FROM_WIN32(GetLastError());
                    wprintf(L"(Error 0x%08X)", hr);
                } else {
                    wprintf(L" %ws", wszSid);
                    LocalFree(wszSid);
                }
            }
        }
        wprintf(L"\n");
    
    }
    wprintf(L"\\-- end ACL ---\n");
}

//--------------------------------------------------------------------
static HRESULT GetRootDomEntitySid(SID ** ppSid, DWORD dwEntityRid)
{
    HRESULT hr;
    NET_API_STATUS nasError;
    unsigned int nSubAuthorities;
    unsigned int nSubAuthIndex;

    // must be cleaned up
    SID * psidRootDomEntity=NULL;
    USER_MODALS_INFO_2 * pumi2=NULL;
    DOMAIN_CONTROLLER_INFOW * pdci=NULL;
    DOMAIN_CONTROLLER_INFOW * pdciForest=NULL;

    // initialize out params
    *ppSid=NULL;


    // get the forest name
    nasError=DsGetDcNameW(NULL, NULL, NULL, NULL, 0, &pdciForest);
    if (NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        _JumpError(hr, error, "DsGetDcNameW");
    }

    // get the top level DC name
    nasError=DsGetDcNameW(NULL, pdciForest->DnsForestName, NULL, NULL, 0, &pdci);
    if (NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        _JumpError(hr, error, "DsGetDcNameW");
    }

    // get the domain Sid on the top level DC.
    nasError=NetUserModalsGet(pdci->DomainControllerName, 2, (LPBYTE *)&pumi2);
    if(NERR_Success!=nasError) {
        hr=HRESULT_FROM_WIN32(nasError);
        _JumpError(hr, error, "NetUserModalsGet");
    }

    nSubAuthorities=*GetSidSubAuthorityCount(pumi2->usrmod2_domain_id);

    // allocate storage for new Sid. account domain Sid + account Rid
    psidRootDomEntity=(SID *)LocalAlloc(LPTR, GetSidLengthRequired((UCHAR)(nSubAuthorities+1)));
    _JumpIfOutOfMemory(hr, error, psidRootDomEntity);

    // copy the first few peices into the SID
    if (!InitializeSid(psidRootDomEntity, 
            GetSidIdentifierAuthority(pumi2->usrmod2_domain_id), 
            (BYTE)(nSubAuthorities+1)))
    {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "InitializeSid");
    }

    // copy existing subauthorities from account domain Sid into new Sid
    for (nSubAuthIndex=0; nSubAuthIndex < nSubAuthorities ; nSubAuthIndex++) {
        *GetSidSubAuthority(psidRootDomEntity, nSubAuthIndex)=
            *GetSidSubAuthority(pumi2->usrmod2_domain_id, nSubAuthIndex);
    }

    // append Rid to new Sid
    *GetSidSubAuthority(psidRootDomEntity, nSubAuthorities)=dwEntityRid;

    *ppSid=psidRootDomEntity;
    psidRootDomEntity=NULL;
    hr=S_OK;

error:
    if (NULL!=psidRootDomEntity) {
        LocalFree(psidRootDomEntity);
    }
    if (NULL!=pdci) {
        NetApiBufferFree(pdci);
    }
    if (NULL!=pdci) {
        NetApiBufferFree(pdciForest);
    }
    if (NULL!=pumi2) {
        NetApiBufferFree(pumi2);
    }

    return hr;
}

//--------------------------------------------------------------------
static HRESULT GetEntAdminSid(SID ** ppSid)
{
    return GetRootDomEntitySid(ppSid, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS);
}

//--------------------------------------------------------------------
static HRESULT GetRootDomAdminSid(SID ** ppSid)
{
    return GetRootDomEntitySid(ppSid, DOMAIN_GROUP_RID_ADMINS);
}

//--------------------------------------------------------------------
static HRESULT GetThisComputerSid(SID ** ppSid)
{
    HRESULT hr;
    DWORD cchSize;
    DWORD dwSidSize;
    DWORD dwDomainSize;
    SID_NAME_USE snu;

    // must be cleaned up
    SID * psidThisComputer=NULL;
    WCHAR * wszName=NULL;
    WCHAR * wszDomain=NULL;

    // initialize out params
    *ppSid=NULL;

    // get the size of the computer's name
    cchSize=0;
    _Verify(!GetComputerObjectNameW(NameSamCompatible, NULL, &cchSize), hr, error);
    if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "GetComputerObjectNameW");
    }

	// bug in GetComputerObjectNameW
	cchSize++;

    // allocate memory
    wszName=(WCHAR *)LocalAlloc(LPTR, cchSize*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszName);

    // get the computer's name
    if (!GetComputerObjectNameW(NameSamCompatible, wszName, &cchSize)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "GetComputerObjectNameW");
    }

    // get the size of the sid
    dwSidSize=0;
    dwDomainSize=0;
    _Verify(!LookupAccountNameW(NULL, wszName, NULL, &dwSidSize, NULL, &dwDomainSize, &snu), hr, error);
    if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "LookupAccountNameW");
    }

    // allocate memory
    wszDomain=(WCHAR *)LocalAlloc(LPTR, dwDomainSize*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszDomain);
    psidThisComputer=(SID *)LocalAlloc(LPTR, dwSidSize);
    _JumpIfOutOfMemory(hr, error, psidThisComputer);
    
    // get the sid
    if (!LookupAccountNameW(NULL, wszName, psidThisComputer, &dwSidSize, wszDomain, &dwDomainSize, &snu)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "LookupAccountNameW");
    }

    // success!
    *ppSid=psidThisComputer;
    psidThisComputer=NULL;
    hr=S_OK;

error:
    if (NULL!=psidThisComputer) {
        LocalFree(psidThisComputer);
    }
    if (NULL!=wszName) {
        LocalFree(wszName);
    }
    if (NULL!=wszDomain) {
        LocalFree(wszDomain);
    }

    return hr;

}


//--------------------------------------------------------------------
static HRESULT ConfirmAccess(PSECURITY_DESCRIPTOR * ppSD, SID * pTrustworthySid, BOOL * pbSDChanged)
{
    //define ENROLL_ACCESS_MASK (0x130)
    HRESULT hr;
    PACL pAcl;
    BOOL bAclPresent;
    BOOL bDefaultAcl;
    unsigned int nIndex;
    ACL_SIZE_INFORMATION aclsizeinfo;
    bool bSidInAcl;

    // must be cleaned up
    PSECURITY_DESCRIPTOR pAbsSD=NULL;
    ACL * pAbsDacl=NULL;
    ACL * pAbsSacl=NULL;
    SID * pAbsOwner=NULL;
    SID * pAbsPriGrp=NULL;
    ACL * pNewDacl=NULL;
    PSECURITY_DESCRIPTOR pNewSD=NULL;

    // initialize out params
    *pbSDChanged=FALSE;

    // get the (D)ACL from the security descriptor
    if (!GetSecurityDescriptorDacl(*ppSD, &bAclPresent, &pAcl, &bDefaultAcl)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }
    _Verify(bAclPresent, hr, error);
    if (NULL==pAcl) {
        hr=E_FAIL;
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }

    // find out how many ACEs
    if (!GetAclInformation(pAcl, &aclsizeinfo, sizeof(aclsizeinfo), AclSizeInformation)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "GetAclInformation");
    }

    //DumpAcl(pAcl,aclsizeinfo);

    // find our sid in the acl
    bSidInAcl=false;
    for (nIndex=0; nIndex<aclsizeinfo.AceCount; nIndex++) {
        ACE_HEADER * pAceHeader;
        ACCESS_ALLOWED_OBJECT_ACE * pAccessAce;
        PSID pSid=NULL;
        if (!GetAce(pAcl, nIndex, (void**)&pAceHeader)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "GetAce");
        }

        // find the sid for this ACE
        if (ACCESS_ALLOWED_OBJECT_ACE_TYPE!=pAceHeader->AceType && ACCESS_DENIED_OBJECT_ACE_TYPE!=pAceHeader->AceType) {
            // we are only interested in OBJECT ace types
            continue;
        }

        // note that ACCESS_ALLOWED_OBJECT_ACE and ACCESS_DENIED_OBJECT_ACE are the same structurally.
        pAccessAce=(ACCESS_ALLOWED_OBJECT_ACE *)pAceHeader;
        _Verify(ACE_OBJECT_TYPE_PRESENT==pAccessAce->Flags, hr, error);
        pSid=((BYTE *)&pAccessAce->SidStart)-sizeof(GUID);

        // confirm the GUID
        if (!IsEqualGUID(pAccessAce->ObjectType, GUID_ENROLL)) {
            continue;
        }

        // make sure this is the sid we are looking for
        if (!EqualSid(pSid, pTrustworthySid)) {
            continue;
        }

        // Was this a denial?
        if (ACCESS_DENIED_OBJECT_ACE_TYPE==pAceHeader->AceType) {
            // It's not anymore!
            pAceHeader->AceType=ACCESS_ALLOWED_OBJECT_ACE_TYPE;
            *pbSDChanged=TRUE;
        }

        // is the mask wrong?
        if (0==(pAccessAce->Mask&ACTRL_DS_CONTROL_ACCESS)) {
            // It's not anymore!
            pAccessAce->Mask|=ACTRL_DS_CONTROL_ACCESS;
            *pbSDChanged=TRUE;
        }

        // The sid is now in the acl and set to allow access.
        bSidInAcl=true;
        break;
    }

    // Was the sid in the acl?
    if (false==bSidInAcl) {
        SECURITY_DESCRIPTOR_CONTROL sdcon;
        DWORD dwRevision;
        DWORD dwNewAclSize;
        DWORD dwAbsSDSize=0;
        DWORD dwDaclSize=0;
        DWORD dwSaclSize=0;
        DWORD dwOwnerSize=0;
        DWORD dwPriGrpSize=0;
        ACE_HEADER * pFirstAce;
        DWORD dwRelSDSize=0;

        // we have to be self-relative
        if (!GetSecurityDescriptorControl(*ppSD, &sdcon, &dwRevision)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "GetSecurityDescriptorControl");
        }
        _Verify(sdcon&SE_SELF_RELATIVE, hr, error);

        // get the sizes
        _Verify(!MakeAbsoluteSD(*ppSD, NULL, &dwAbsSDSize, NULL, &dwDaclSize, NULL, &dwSaclSize, NULL,  &dwOwnerSize, NULL, &dwPriGrpSize), hr, error);
        if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "MakeAbsoluteSD");
        }

        // allocate memory
        pAbsSD=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwAbsSDSize);
        _JumpIfOutOfMemory(hr, error, pAbsSD);
        pAbsDacl=(ACL * )LocalAlloc(LPTR, dwDaclSize);
        _JumpIfOutOfMemory(hr, error, pAbsDacl);
        pAbsSacl=(ACL * )LocalAlloc(LPTR, dwSaclSize);
        _JumpIfOutOfMemory(hr, error, pAbsSacl);
        pAbsOwner=(SID *)LocalAlloc(LPTR, dwOwnerSize);
        _JumpIfOutOfMemory(hr, error, pAbsOwner);
        pAbsPriGrp=(SID *)LocalAlloc(LPTR, dwPriGrpSize);
        _JumpIfOutOfMemory(hr, error, pAbsPriGrp);

        // copy the SD to the memory buffers
        if (!MakeAbsoluteSD(*ppSD, pAbsSD, &dwAbsSDSize, pAbsDacl, &dwDaclSize, pAbsSacl, &dwSaclSize, pAbsOwner,  &dwOwnerSize, pAbsPriGrp, &dwPriGrpSize)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "MakeAbsoluteSD");
        }
        
        // get the current size info for the dacl
        if (!GetAclInformation(pAbsDacl, &aclsizeinfo, sizeof(aclsizeinfo), AclSizeInformation)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "GetAclInformation");
        }

        // figure out the new size
        dwNewAclSize=aclsizeinfo.AclBytesInUse+sizeof(_ACCESS_ALLOWED_OBJECT_ACE)
            -sizeof(GUID) //ACCESS_ALLOWED_OBJECT_ACE::InheritedObjectType
            -sizeof(DWORD) //ACCESS_ALLOWED_OBJECT_ACE::SidStart
            +GetLengthSid(pTrustworthySid);
    
        // allocate memory
        pNewDacl=(ACL *)LocalAlloc(LPTR, dwNewAclSize);
        _JumpIfOutOfMemory(hr, error, pNewDacl);
    
        // init the header
        if (!InitializeAcl(pNewDacl, dwNewAclSize, ACL_REVISION_DS)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "InitializeAcl");
        }

        // find the first ace in the dacl
        if (!GetAce(pAbsDacl, 0, (void **)&pFirstAce)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "GetAce");
        }

        // add all the old aces
        if (!AddAce(pNewDacl, ACL_REVISION_DS, 0, pFirstAce, aclsizeinfo.AclBytesInUse-sizeof(ACL))) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "AddAce");
        }

        // finally, add the new acl
        if (!AddAccessAllowedObjectAce(pNewDacl, ACL_REVISION_DS, OBJECT_INHERIT_ACE, ACTRL_DS_CONTROL_ACCESS, (GUID *)&GUID_ENROLL, NULL, pTrustworthySid)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "AddAccessAllowedObjectAce");
        }

        // stick the new dacl in the sd
        if (!SetSecurityDescriptorDacl(pAbsSD, TRUE, pNewDacl, FALSE)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "SetSecurityDescriptorDacl");
        }

        // compact everything back together
        // get the size
        _Verify(!MakeSelfRelativeSD(pAbsSD, NULL, &dwRelSDSize), hr, error);
        if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "MakeSelfRelativeSD");
        }

        // allocate memory
        pNewSD=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwRelSDSize);
        _JumpIfOutOfMemory(hr, error, pNewSD);

        // copy the SD to the new memory buffer
        if (!MakeSelfRelativeSD(pAbsSD, pNewSD, &dwRelSDSize)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "MakeSelfRelativeSD");
        }

        // Whew! We made it!
        LocalFree(*ppSD);
        *ppSD=pNewSD;
        pNewSD=NULL;
        *pbSDChanged=TRUE;

    } // <- end if sid not in acl

    _Verify(IsValidSecurityDescriptor(*ppSD), hr, error);

    hr=S_OK;

error:
    if (NULL!=pNewSD) {
        LocalFree(pNewSD);
    }
    if (NULL!=pNewDacl) {
        LocalFree(pNewDacl);
    }
    if (NULL!=pAbsSD) {
        LocalFree(pAbsSD);
    }
    if (NULL!=pAbsDacl) {
        LocalFree(pAbsDacl);
    }
    if (NULL!=pAbsSacl) {
        LocalFree(pAbsSacl);
    }
    if (NULL!=pAbsOwner) {
        LocalFree(pAbsOwner);
    }
    if (NULL!=pAbsPriGrp) {
        LocalFree(pAbsPriGrp);
    }
    return hr;
}

//####################################################################
// public functions

//--------------------------------------------------------------------
BOOL IsNT5(void)
{
    HRESULT hr;
    OSVERSIONINFO ovi;
    static BOOL s_fDone=FALSE;
    static BOOL s_fNT5=FALSE;

    if (!s_fDone) {

        s_fDone=TRUE;

        // get and confirm platform info
        ovi.dwOSVersionInfoSize = sizeof(ovi);
        if (!GetVersionEx(&ovi)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "GetVersionEx");
        }
        if (VER_PLATFORM_WIN32_NT!=ovi.dwPlatformId) {
            hr=ERROR_CANCELLED;
            _JumpError(hr, error, "Not a supported OS");
        }
        if ((5 <= ovi.dwMajorVersion) && (1 <= ovi.dwMinorVersion)){
            s_fNT5=TRUE;
        }
    }

error:
    return s_fNT5;
}

//--------------------------------------------------------------------
BOOL IsIISInstalled(void)
{
    HRESULT hr;

    // must be cleaned up
    IMSAdminBase * pIMeta=NULL;

    hr=CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (VOID **) &pIMeta);
    if (FAILED(hr)) {
        _IgnoreError(hr, "CoCreateInstance(CLSID_MSAdminBase)");
    }

//error:
    if (NULL!=pIMeta) {
        pIMeta->Release();
    }

    return (S_OK==hr);
}

//--------------------------------------------------------------------
HRESULT CEPUpdateApplicationPool(BOOL fDC, const WCHAR * pwszApplicationPool, BOOL  fLocalSystem, const WCHAR * pwszUserName, const WCHAR * pwszPassword)
{
    HRESULT				hr=E_FAIL;
    METADATA_RECORD		mr;
	DWORD				dwLogonMethod=MD_LOGON_INTERACTIVE;
	DWORD				dwAppPoolID=MD_APPPOOL_IDENTITY_TYPE_SPECIFICUSER;	
	DWORD				dwTimeout=0;

    // must be cleaned up
    WCHAR *				wszFullAppPath=NULL;  // "/lm/w3svc/apppools/SCEP"
    IMSAdminBase *		pIMeta=NULL;
    METADATA_HANDLE		hMetaRoot=NULL;
    METADATA_HANDLE		hMetaKey=NULL;
   

	//check input parameter
	if(NULL==pwszApplicationPool)
	{
		hr=E_INVALIDARG;
		_JumpIfError(hr, error, "paramCheck");
	}

	//change the logon type to network logon on the DC so that the domain account does not have
	//to have the local logon provilege to the DC; NETWORK logon does not have the correct token
	//to validate user on the network; since we are running the DC, we should be validate locally
	//and everything should just work.
	if(fDC)
		dwLogonMethod=MD_LOGON_NETWORK;

	if(fLocalSystem)
	{
		dwAppPoolID=MD_APPPOOL_IDENTITY_TYPE_LOCALSYSTEM;
	}
	else
	{
		dwAppPoolID=MD_APPPOOL_IDENTITY_TYPE_SPECIFICUSER;	

		if((NULL==pwszUserName) || (NULL==pwszPassword))
		{
			hr=E_INVALIDARG;
			_JumpIfError(hr, error, "paramCheck");
		}

	}

    wszFullAppPath=(WCHAR *)LocalAlloc(LPTR, (wcslen(gc_wszAppPoolBase)+1+wcslen(pwszApplicationPool)+1)*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszFullAppPath);
    wcscpy(wszFullAppPath, gc_wszAppPoolBase);
    wcscat(wszFullAppPath, L"/");
    wcscat(wszFullAppPath, pwszApplicationPool);

    // Create an instance of the metabase object
    hr=CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance(CLSID_MSAdminBase)");

    // open the top level
    hr=vrOpenRoot(pIMeta, FALSE, gc_wszAppPoolBase, &hMetaRoot);
    _JumpIfError(hr, error, "vrOpenRoot");

    // Add new VDir called "SCEP"
	hr=pIMeta->AddKey(hMetaRoot, pwszApplicationPool);

    if(HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)==hr) 
	{
        // That's fine.
        _IgnoreError(hr, "AddKey");
    } 
	else 
	{
        _JumpIfErrorStr(hr, error, "AddKey", pwszApplicationPool);
    }

    // close the root key
	hr=pIMeta->CloseKey(hMetaRoot);
    hMetaRoot=NULL;
    _JumpIfError(hr, error, "CloseKey");


    // Open the new VDir at /lm/w3svc/apppools/SCEP
	hr=pIMeta->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            wszFullAppPath,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            1000,
            &hMetaKey);

    _JumpIfErrorStr(hr, error, "OpenKey", wszFullAppPath);

	//set properties on this application 

	if(FALSE == fLocalSystem)
	{
		//set the UserName
		memset(&mr, 0, sizeof(METADATA_RECORD));
		mr.dwMDIdentifier=MD_WAM_USER_NAME;
		mr.dwMDAttributes=METADATA_INHERIT;
		mr.dwMDUserType=IIS_MD_UT_FILE;
		mr.dwMDDataType=STRING_METADATA;
		mr.dwMDDataLen=(wcslen(pwszUserName)+1)*sizeof(WCHAR);
		mr.pbMDData=(BYTE *)(pwszUserName);

		hr=pIMeta->SetData(hMetaKey, L"", &mr);
		_JumpIfError(hr, error, "SetData");

		//set the password
 		memset(&mr, 0, sizeof(METADATA_RECORD));
		mr.dwMDIdentifier=MD_WAM_PWD;
		mr.dwMDAttributes=METADATA_INHERIT | METADATA_SECURE;
		mr.dwMDUserType=IIS_MD_UT_FILE;
		mr.dwMDDataType=STRING_METADATA;
		mr.dwMDDataLen=(wcslen(pwszPassword)+1)*sizeof(WCHAR);
		mr.pbMDData=(BYTE *)(pwszPassword);

		hr=pIMeta->SetData(hMetaKey, L"", &mr);
		_JumpIfError(hr, error, "SetData");

		//set the logon method
 		memset(&mr, 0, sizeof(METADATA_RECORD));
		mr.dwMDIdentifier=MD_LOGON_METHOD;
		mr.dwMDAttributes=METADATA_INHERIT;
		mr.dwMDUserType=IIS_MD_UT_FILE;
		mr.dwMDDataType=DWORD_METADATA;
		mr.dwMDDataLen=sizeof(dwLogonMethod);
		mr.pbMDData=(BYTE *)(&dwLogonMethod);

		hr=pIMeta->SetData(hMetaKey, L"", &mr);
		_JumpIfError(hr, error, "SetData");
	}

 	//set the application identity
 	memset(&mr, 0, sizeof(METADATA_RECORD));
    mr.dwMDIdentifier=MD_APPPOOL_IDENTITY_TYPE;
    mr.dwMDAttributes=METADATA_INHERIT;
    mr.dwMDUserType=IIS_MD_UT_SERVER;
    mr.dwMDDataType=DWORD_METADATA;
    mr.dwMDDataLen=sizeof(dwAppPoolID);
    mr.pbMDData=(BYTE *)(&dwAppPoolID);

	hr=pIMeta->SetData(hMetaKey, L"", &mr);
    _JumpIfError(hr, error, "SetData");

#ifdef MD_APPPOOL_FRIENDLY_NAME
	//set the application pool friendly name
 	memset(&mr, 0, sizeof(METADATA_RECORD));
    mr.dwMDIdentifier=MD_APPPOOL_FRIENDLY_NAME;
    mr.dwMDAttributes=METADATA_NO_ATTRIBUTES;
    mr.dwMDUserType=IIS_MD_UT_SERVER;
    mr.dwMDDataType=STRING_METADATA;
    mr.dwMDDataLen=(wcslen(pwszApplicationPool)+1)*sizeof(WCHAR);
    mr.pbMDData=(BYTE *)(pwszApplicationPool);

	hr=pIMeta->SetData(hMetaKey, L"", &mr);
	_JumpIfError(hr, error, "SetData");
#endif

	//set the PeriodicRestartTime to 0
 	memset(&mr, 0, sizeof(METADATA_RECORD));
    mr.dwMDIdentifier=MD_APPPOOL_PERIODIC_RESTART_TIME;
    mr.dwMDAttributes=METADATA_INHERIT;
    mr.dwMDUserType=IIS_MD_UT_SERVER;
    mr.dwMDDataType=DWORD_METADATA;
    mr.dwMDDataLen=sizeof(dwTimeout);
    mr.pbMDData=(BYTE *)(&dwTimeout);

	hr=pIMeta->SetData(hMetaKey, L"", &mr);
	_JumpIfError(hr, error, "SetData");

	//set the IDleTimeOut to 0
 	memset(&mr, 0, sizeof(METADATA_RECORD));
    mr.dwMDIdentifier=MD_APPPOOL_IDLE_TIMEOUT;
    mr.dwMDAttributes=METADATA_INHERIT;
    mr.dwMDUserType=IIS_MD_UT_SERVER;
    mr.dwMDDataType=DWORD_METADATA;
    mr.dwMDDataLen=sizeof(dwTimeout);
    mr.pbMDData=(BYTE *)(&dwTimeout);

	hr=pIMeta->SetData(hMetaKey, L"", &mr);
	_JumpIfError(hr, error, "SetData");

   // done with this key.
	hr=pIMeta->CloseKey(hMetaKey);
    hMetaKey=NULL;
    _JumpIfError(hr, error, "CloseKey");
    
    // Flush out the changes and close
	pIMeta->SaveData();

	hr=S_OK;

error:

    if (NULL!=wszFullAppPath) 
	{
        LocalFree(wszFullAppPath);
    }

    if (NULL!=hMetaKey) 
	{
		pIMeta->CloseKey(hMetaKey);
    }

    if (NULL!=hMetaRoot) 
	{
        pIMeta->CloseKey(hMetaRoot);
    }

    if (NULL!=pIMeta) 
	{
        pIMeta->Release();
    }

    return hr;

}

//--------------------------------------------------------------------
HRESULT AddVDir(IN BOOL fDC,
				IN const WCHAR * wszDirectory,
				IN const WCHAR * wszApplicationPool,
				IN BOOL  fLocalSystem,
				IN const WCHAR * wszUserName,
				IN const WCHAR * wszPassword)
{

    HRESULT hr;
    METADATA_RECORD mr;
    DWORD dwAccessPerms;
    DWORD dwAuthenticationType;
    const WCHAR * wszKeyType=IIS_CLASS_WEB_VDIR_W;
    WCHAR wszSysDirBuf[MAX_PATH + 2];
	bool  fISAPIEnabled=false;
	BOOL  fEnabled=FALSE;

    // must be cleaned up
    IMSAdminBase * pIMeta=NULL;
    IWamAdmin * pIWam=NULL;
	IIISApplicationAdmin *pIIISAppAdmin=NULL;
    METADATA_HANDLE hMetaRoot=NULL;
    METADATA_HANDLE hMetaKey=NULL;
    WCHAR * wszPhysicalPath=NULL;           // "c:\winnt\system32\certsrv\mscep"
    WCHAR * wszRelativeVirtualPath=NULL;    // "certsrv/mscep"
    WCHAR * wszFullVirtualPath=NULL;        // "/LM/W3svc/1/ROOT/certsrv/mscep"
    WCHAR * wszFullPhysicalPath=NULL;       // "c:\winnt\system32\certsrv\mscep\mscep.dll"
   
    // build the directories
    if (FALSE==GetSystemDirectoryW(wszSysDirBuf, MAX_PATH + 2)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "GetSystemDirectory");
    }

    wszPhysicalPath=(WCHAR *)LocalAlloc(LPTR, (wcslen(wszSysDirBuf)+1+wcslen(gc_wszCertSrvDir)+1+wcslen(wszDirectory)+1)*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszPhysicalPath);
    wcscpy(wszPhysicalPath, wszSysDirBuf);
    wcscat(wszPhysicalPath, L"\\");
    wcscat(wszPhysicalPath, gc_wszCertSrvDir);
    wcscat(wszPhysicalPath, L"\\");
    wcscat(wszPhysicalPath, wszDirectory);

    wszRelativeVirtualPath=(WCHAR *)LocalAlloc(LPTR, (wcslen(gc_wszCertSrvDir)+1+wcslen(wszDirectory)+1)*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszRelativeVirtualPath);
    wcscpy(wszRelativeVirtualPath, gc_wszCertSrvDir);
    wcscat(wszRelativeVirtualPath, L"/");
    wcscat(wszRelativeVirtualPath, wszDirectory);

    wszFullVirtualPath=(WCHAR *)LocalAlloc(LPTR, (wcslen(gc_wszBaseRoot)+1+wcslen(wszRelativeVirtualPath)+1)*sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszFullVirtualPath);
    wcscpy(wszFullVirtualPath, gc_wszBaseRoot);
    wcscat(wszFullVirtualPath, L"/");
    wcscat(wszFullVirtualPath, wszRelativeVirtualPath);

	wszFullPhysicalPath=(WCHAR *)LocalAlloc(LPTR, (wcslen(wszPhysicalPath)+1+wcslen(L"\\")+wcslen(CEP_DLL_NAME)) * sizeof(WCHAR));
    _JumpIfOutOfMemory(hr, error, wszFullPhysicalPath);
	wcscpy(wszFullPhysicalPath, wszPhysicalPath);
	wcscat(wszFullPhysicalPath, L"\\");
	wcscat(wszFullPhysicalPath, CEP_DLL_NAME);

	//enable the ISAPI Extension on IIS
	hr=IsISAPIExtensionEnabled(wszFullPhysicalPath, fISAPIEnabled);

	//do not respond to error for backward compatibility of previous IDS build
	if((S_OK == hr) && (!fISAPIEnabled))
	{
		hr=EnableISAPIExtension(wszFullPhysicalPath, &fEnabled);
		_JumpIfError(hr, error, "EnableISAPIExtension");
	}

    // Create an instance of the metabase object
    hr=CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance(CLSID_MSAdminBase)");

    // open the top level
    hr=vrOpenRoot(pIMeta, FALSE/*not read-only*/, gc_wszBaseRoot, &hMetaRoot);
    _JumpIfError(hr, error, "vrOpenRoot");

    // Add new VDir called gc_wszVRootName
    __try {
        hr=pIMeta->AddKey(hMetaRoot, wszRelativeVirtualPath);
    } _TrapException(hr);
    if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)==hr) {
        // That's fine.
        _IgnoreError(hr, "AddKey");
    } else {
        _JumpIfErrorStr(hr, error, "AddKey", wszRelativeVirtualPath);
    }

    // close the root key
    __try {
        hr=pIMeta->CloseKey(hMetaRoot);
    } _TrapException(hr);
    hMetaRoot=NULL;
    _JumpIfError(hr, error, "CloseKey");


    // Open the new VDir
    __try {
        hr=pIMeta->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            wszFullVirtualPath,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            1000,
            &hMetaKey);
    } _TrapException(hr);
    _JumpIfErrorStr(hr, error, "OpenKey", wszFullVirtualPath);

    // Set the physical path for this VDir

    // virtual root path
    mr.dwMDIdentifier=MD_VR_PATH;
    mr.dwMDAttributes=METADATA_INHERIT;
    mr.dwMDUserType=IIS_MD_UT_FILE;
    mr.dwMDDataType=STRING_METADATA;
    mr.dwMDDataLen=(wcslen(wszPhysicalPath)+1)*sizeof(WCHAR);
    mr.pbMDData=(BYTE *)(wszPhysicalPath);
    __try {
        hr=pIMeta->SetData(hMetaKey, L"", &mr);
    } _TrapException(hr);
    _JumpIfError(hr, error, "SetData");
    
    // access permissions on VRoots: read & execute
    dwAccessPerms=MD_ACCESS_EXECUTE | MD_ACCESS_READ;
    mr.dwMDIdentifier=MD_ACCESS_PERM;
    mr.dwMDAttributes=METADATA_INHERIT;
    mr.dwMDUserType=IIS_MD_UT_FILE;
    mr.dwMDDataType=DWORD_METADATA;
    mr.dwMDDataLen=sizeof(dwAccessPerms);
    mr.pbMDData=(BYTE *)(&dwAccessPerms);
    __try {
        hr=pIMeta->SetData(hMetaKey, L"", &mr);
    } _TrapException(hr);
    _JumpIfError(hr, error, "SetData");

    // indicate that what we created is a vroot - set the key type 
    mr.dwMDIdentifier=MD_KEY_TYPE;
    mr.dwMDAttributes=METADATA_NO_ATTRIBUTES;
    mr.dwMDUserType=IIS_MD_UT_SERVER;
    mr.dwMDDataType=STRING_METADATA;
    mr.dwMDDataLen=(wcslen(wszKeyType)+1)*sizeof(WCHAR);
    mr.pbMDData=(BYTE *)(wszKeyType);
    __try {
        hr=pIMeta->SetData(hMetaKey, L"", &mr);
    } _TrapException(hr);
    _JumpIfError(hr, error, "SetData");

    // set authentication to be anonymous or NTLM
    dwAuthenticationType=MD_AUTH_ANONYMOUS|MD_AUTH_NT;
    mr.dwMDIdentifier=MD_AUTHORIZATION;
    mr.dwMDAttributes=METADATA_INHERIT;
    mr.dwMDUserType=IIS_MD_UT_FILE;
    mr.dwMDDataType=DWORD_METADATA;
    mr.dwMDDataLen=sizeof(dwAuthenticationType);
    mr.pbMDData=reinterpret_cast<BYTE *>(&dwAuthenticationType);
    __try {
        hr=pIMeta->SetData(hMetaKey, L"", &mr);
    } _TrapException(hr);
    _JumpIfError(hr, error, "SetData");

    // set the default document
    mr.dwMDIdentifier=MD_DEFAULT_LOAD_FILE;
    mr.dwMDAttributes=METADATA_NO_ATTRIBUTES;
    mr.dwMDUserType=IIS_MD_UT_FILE;
    mr.dwMDDataType=STRING_METADATA;
    mr.dwMDDataLen=(wcslen(gc_wszCepDllName)+1)*sizeof(WCHAR);
    mr.pbMDData=(BYTE *)(gc_wszCepDllName);
    __try {
        hr=pIMeta->SetData(hMetaKey, L"", &mr);
    } _TrapException(hr);
    _JumpIfError(hr, error, "SetData");

    // done with this key.
    __try {
        hr=pIMeta->CloseKey(hMetaKey);
    } _TrapException(hr);
    hMetaKey=NULL;
    _JumpIfError(hr, error, "CloseKey");
    
    // Flush out the changes and close
    __try {
        hr=pIMeta->SaveData();
    } _TrapException(hr);
    // _JumpIfError(hr, "SaveData");
    if (FAILED(hr)) {
        _IgnoreError(hr, "SaveData");
    }
    hr=S_OK;
    
    // Create a 'web application' so that scrdenrl.dll runs in-process
    // Create an instance of the metabase object
    hr=CoCreateInstance(
        CLSID_WamAdmin,
        NULL,
        CLSCTX_ALL,
        IID_IWamAdmin,
        (void **) &pIWam);
    _JumpIfError(hr, error, "CoCreateInstance(CLSID_WamAdmin)");

    // Create the application running in-process
    __try {
        hr=pIWam->AppCreate(wszFullVirtualPath, TRUE);
    } _TrapException(hr);
    _JumpIfError(hr, error, "AppCreate");

	//create an application pool
    hr=CoCreateInstance(
        CLSID_WamAdmin,
        NULL,
        CLSCTX_ALL,
        IID_IIISApplicationAdmin,
        (void **) &pIIISAppAdmin);
    _JumpIfError(hr, error, "CoCreateInstance(IID_IIISApplicationAdmin)");

	hr=pIIISAppAdmin->CreateApplication(wszFullVirtualPath, eAppRunInProc, wszApplicationPool, TRUE);

    if(hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) 
	{
        // That's fine since installation can be run multiple times
        _IgnoreError(hr, "CreateApplication");
    } 
	else 
	{
        _JumpIfErrorStr(hr, error, "CreateApplication", wszFullVirtualPath);
    }

	//update an application pool
	hr=CEPUpdateApplicationPool(fDC, wszApplicationPool, fLocalSystem, wszUserName, wszPassword);
    _JumpIfError(hr, error, "CEPCreateApplicationPool");

	hr=S_OK;

error:
    if (NULL!=wszFullVirtualPath) {
        LocalFree(wszFullVirtualPath);
    }
    if (NULL!=wszRelativeVirtualPath) {
        LocalFree(wszRelativeVirtualPath);
    }
    if (NULL!=wszPhysicalPath) {
        LocalFree(wszPhysicalPath);
    }

	if (NULL!=wszFullPhysicalPath)
	{
		LocalFree(wszFullPhysicalPath);
	}

    if (NULL!=hMetaKey) {
        HRESULT hr2;
        __try {
            hr2=pIMeta->CloseKey(hMetaKey);
        } _TrapException(hr2);
        _TeardownError(hr, hr2, "CloseKey");
    }
    if (NULL!=hMetaRoot) {
        HRESULT hr2;
        __try {
            hr2=pIMeta->CloseKey(hMetaRoot);
        } _TrapException(hr2);
        _TeardownError(hr, hr2, "CloseKey");
    }
    if (NULL!=pIIISAppAdmin) {
        pIIISAppAdmin->Release();
    }
    if (NULL!=pIWam) {
        pIWam->Release();
    }
    if (NULL!=pIMeta) {
        pIMeta->Release();
    }
    return hr;
}


//--------------------------------------------------------------------
HRESULT CepStopService(IN DWORD dwServicePeriod, const WCHAR * wszServiceName, BOOL * pbWasRunning)
{
    HRESULT hr;
    SERVICE_STATUS ss;
    unsigned int nAttempts;

    // must be cleaned up
    SC_HANDLE hSCManager=NULL;
    SC_HANDLE hService=NULL;

    // initialize out parameters
    *pbWasRunning=FALSE;

    // talk to the service manager
    hSCManager=OpenSCManagerW(NULL/*machine*/, NULL/*db*/, SC_MANAGER_ALL_ACCESS);
    if (NULL==hSCManager) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "OpenSCManager");
    }

    // get to the service
    hService=OpenServiceW(hSCManager, wszServiceName, SERVICE_ALL_ACCESS);
    if (NULL==hService) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpErrorStr(hr, error, "OpenService", wszServiceName);
    }

    // see if the service is running
    if (FALSE==QueryServiceStatus(hService, &ss)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpErrorStr(hr, error, "QueryServiceStatus", wszServiceName);
    }
    if (SERVICE_STOPPED!=ss.dwCurrentState && SERVICE_STOP_PENDING!=ss.dwCurrentState) {
        *pbWasRunning=TRUE;
    }

    // begin the service stopping loop
    for (nAttempts=0; SERVICE_STOPPED!=ss.dwCurrentState && nAttempts<dwServicePeriod; nAttempts++) {

        // service is running, must stop it.
        if (SERVICE_STOP_PENDING!=ss.dwCurrentState) {
            if (!ControlService(hService, SERVICE_CONTROL_STOP, &ss)) {
                hr=HRESULT_FROM_WIN32(GetLastError());
                _JumpErrorStr(hr, error, "ControlService(Stop)", wszServiceName);
            }
        }

        // wait a little while
        Sleep(1000);

        // see if the service is running
        if (FALSE==QueryServiceStatus(hService, &ss)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpErrorStr(hr, error, "QueryServiceStatus", wszServiceName);
        }
    }

    if (nAttempts>=dwServicePeriod) {
        // it never stopped
        hr=HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT);
        _JumpErrorStr(hr, error, "Stopping service", wszServiceName);
    }

    hr=S_OK;

error:
    if (NULL!=hService) {
        CloseServiceHandle(hService);
    }
    if (NULL!=hSCManager) {
        CloseServiceHandle(hSCManager);
    }

    return hr;
}

//--------------------------------------------------------------------
HRESULT CepStartService(const WCHAR * wszServiceName)
{
    HRESULT hr;
    SERVICE_STATUS ss;

    // must be cleaned up
    SC_HANDLE hSCManager=NULL;
    SC_HANDLE hService=NULL;

    // talk to the service manager
    hSCManager=OpenSCManagerW(NULL/*machine*/, NULL/*db*/, SC_MANAGER_ALL_ACCESS);
    if (NULL==hSCManager) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "OpenSCManager");
    }

    // get to the service
    hService=OpenServiceW(hSCManager, wszServiceName, SERVICE_ALL_ACCESS);
    if (NULL==hService) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpErrorStr(hr, error, "OpenService", wszServiceName);
    }

    // now, start the service.
    if (FALSE==StartServiceW(hService, 0 /*num args*/, NULL /*args*/)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "OpenSCManager");
    }

    hr=S_OK;

error:
    if (NULL!=hService) {
        CloseServiceHandle(hService);
    }
    if (NULL!=hSCManager) {
        CloseServiceHandle(hSCManager);
    }

    return hr;
}

//--------------------------------------------------------------------
BOOL IsGoodCaInstalled(void)
{
    HRESULT hr;
    DWORD dwError;
    DWORD dwType;
    DWORD dwDataSize;
    DWORD dwSetupStatus;
    BOOL bResult=FALSE;
    DWORD dwCAType;

    // must be cleaned up
    HKEY hCurConfig=NULL;

    // get the current configuration
    hr=OpenCurrentCAConfig(&hCurConfig);
    _JumpIfError(hr, error, "OpenCurrentCAConfig");

    //  get value SetupStatus
    dwDataSize=sizeof(dwSetupStatus);
    dwError=RegQueryValueExW(hCurConfig, wszREGSETUPSTATUS, NULL, &dwType, (BYTE *)&dwSetupStatus, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszREGSETUPSTATUS);
    }
    _Verify(REG_DWORD==dwType, hr, error);
    _Verify(sizeof(dwSetupStatus)==dwDataSize, hr, error);

    // make sure we have all the needed components set up
    _Verify(0!=(dwSetupStatus&SETUP_SERVER_FLAG), hr, error);
    _Verify(0!=(dwSetupStatus&SETUP_CLIENT_FLAG), hr, error);
    _Verify(0==(dwSetupStatus&SETUP_SUSPEND_FLAG), hr, error);

    // Check the CA Type too
    dwDataSize=sizeof(dwCAType);
    dwError=RegQueryValueExW(hCurConfig, wszREGCATYPE, NULL, &dwType, (BYTE *)&dwCAType, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszREGCATYPE);
    }
    _Verify(REG_DWORD==dwType, hr, error);
    _Verify(sizeof(dwCAType)==dwDataSize, hr, error);

    _Verify(dwCAType<=ENUM_UNKNOWN_CA, hr, error);

    
    bResult=TRUE;
error:
    if (NULL!=hCurConfig) {
        RegCloseKey(hCurConfig);
    }
    return bResult;
}

//--------------------------------------------------------------------
BOOL IsServiceRunning(IN const WCHAR * wszServiceName)
{
    HRESULT hr;
    SERVICE_STATUS ss;
    BOOL bResult=FALSE;

    // must be cleaned up
    SC_HANDLE hSCManager=NULL;
    SC_HANDLE hService=NULL;

    // talk to the service manager
    hSCManager=OpenSCManagerW(NULL/*machine*/, NULL/*db*/, SC_MANAGER_ALL_ACCESS);
    if (NULL==hSCManager) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "OpenSCManager");
    }

    // get to the service
    hService=OpenServiceW(hSCManager, wszServiceName, SERVICE_ALL_ACCESS);
    if (NULL==hService) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpErrorStr(hr, error, "OpenService", wszSERVICE_NAME);
    }

    // see if the service is running
    if (FALSE==QueryServiceStatus(hService, &ss)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpErrorStr(hr, error, "QueryServiceStatus", wszSERVICE_NAME);
    }
    _Verify(SERVICE_RUNNING==ss.dwCurrentState, hr, error)
    _Verify(0!=(SERVICE_ACCEPT_PAUSE_CONTINUE&ss.dwControlsAccepted), hr, error);

    // looks like it is
    bResult=TRUE;

error:
    if (NULL!=hService) {
        CloseServiceHandle(hService);
    }
    if (NULL!=hSCManager) {
        CloseServiceHandle(hSCManager);
    }

    return bResult;

}
//--------------------------------------------------------------------
BOOL IsCaRunning(void)
{
	return IsServiceRunning(wszSERVICE_NAME);
}

//--------------------------------------------------------------------
HRESULT EnrollForRACertificates(
            IN const WCHAR * wszDistinguishedName,
            IN const WCHAR * wszSignCSPName,
            IN DWORD dwSignCSPType,
            IN DWORD dwSignKeySize,
            IN const WCHAR * wszEncryptCSPName,
            IN DWORD dwEncryptCSPType,
            IN DWORD dwEncryptKeySize,
			IN SID	 *psidAccount)
{
    HRESULT hr;

    hr=EnrollForRACert(
        wszDistinguishedName,
        wszSignCSPName,
        dwSignCSPType,
        dwSignKeySize,
        AT_SIGNATURE,
        wszCERTTYPE_ENROLLMENT_AGENT_OFFLINE,
		psidAccount);
    _JumpIfError(hr, error, "EnrollForRACert(OfflineEnrollmentAgent)");

    hr=EnrollForRACert(
        wszDistinguishedName,
        wszEncryptCSPName,
        dwEncryptCSPType,
        dwEncryptKeySize,
        AT_KEYEXCHANGE,
        wszCERTTYPE_CEP_ENCRYPTION,
		psidAccount);
    _JumpIfError(hr, error, "EnrollForRACert(CepEncryption)");

    // all done
    hr=S_OK;
error:

    return hr;
}

//--------------------------------------------------------------------
HRESULT DoCertSrvRegChanges(IN BOOL bDisablePendingFirst)
{
    HRESULT hr;
    DWORD dwDataSize;
    DWORD dwType;
    DWORD dwError;
    WCHAR * wszTravel;
    DWORD dwNewDataSize;
    DWORD dwRequestDisposition;

    bool bSubjectTemplateAlreadyModified=false;

    // must be cleaned up
    HKEY hCaConfig=NULL;
    WCHAR * mwszSubjectTemplate=NULL;
    HKEY hPolicyModules=NULL;
    HKEY hCurPolicy=NULL;
    WCHAR * wszCurPolicy=NULL;

    // get the current CA config key
    hr=OpenCurrentCAConfig(&hCaConfig);
    _JumpIfError(hr, error, "OpenCurrentCAConfig");

    //
    // add strings to the SubjectTemplate value
    //

    // get the size of the Multi_SZ
    dwDataSize=0;
    dwError=RegQueryValueExW(hCaConfig, wszREGSUBJECTTEMPLATE, NULL, &dwType, NULL, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszREGSUBJECTTEMPLATE);
    }
    _Verify(REG_MULTI_SZ==dwType, hr, error);

    // add exra space for the strings we want to add
    dwDataSize+=(wcslen(wszPROPUNSTRUCTUREDNAME)+1)*sizeof(WCHAR);
    dwDataSize+=(wcslen(wszPROPUNSTRUCTUREDADDRESS)+1)*sizeof(WCHAR);
    dwDataSize+=(wcslen(wszPROPDEVICESERIALNUMBER)+1)*sizeof(WCHAR);
    dwNewDataSize=dwDataSize;
    mwszSubjectTemplate=(WCHAR *)LocalAlloc(LPTR, dwDataSize);
    _JumpIfOutOfMemory(hr, error, mwszSubjectTemplate);

    // get the Multi_SZ
    dwError=RegQueryValueExW(hCaConfig, wszREGSUBJECTTEMPLATE, NULL, &dwType, (BYTE *)mwszSubjectTemplate, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszREGSUBJECTTEMPLATE);
    }
    _Verify(REG_MULTI_SZ==dwType, hr, error);

    // walk to the end
    for (wszTravel=mwszSubjectTemplate; 0!=wcslen(wszTravel); wszTravel+=wcslen(wszTravel)+1) {
        // while walking, make sure we haven't added these strings already
        if (0==wcscmp(wszTravel, wszPROPUNSTRUCTUREDNAME)) {
            bSubjectTemplateAlreadyModified=true;
            break;
        }
    }
    // we are now pointing at the last '\0' in the string, which we will overwrite

    // did we do this already? If so, don't do it again.
    if (false==bSubjectTemplateAlreadyModified) {

        // add the strings
        wcscpy(wszTravel, wszPROPUNSTRUCTUREDNAME);
        wszTravel+=wcslen(wszTravel)+1;
        wcscpy(wszTravel, wszPROPUNSTRUCTUREDADDRESS);
        wszTravel+=wcslen(wszTravel)+1;
        wcscpy(wszTravel, wszPROPDEVICESERIALNUMBER);
        wszTravel+=wcslen(wszTravel)+1;
        // add extra terminator
        wszTravel[0]='\0';

        // save the Multi_SZ
        dwError=RegSetValueExW(hCaConfig, wszREGSUBJECTTEMPLATE, NULL, dwType, (BYTE *)mwszSubjectTemplate, dwNewDataSize);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegSetValueExW", wszREGSUBJECTTEMPLATE);
        }
    }

    //
    // remove the Pending First flag from the current policy settings
    //

    if (FALSE!=bDisablePendingFirst) {

        // open the current policy
        dwError=RegOpenKeyExW(hCaConfig, wszREGKEYPOLICYMODULES, NULL, KEY_READ, &hPolicyModules);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegOpenKeyExW", wszREGKEYPOLICYMODULES);
        }

        hr=GetRegString(hPolicyModules, wszREGACTIVE, &wszCurPolicy);
        _JumpIfErrorStr(hr, error, "GetRegString", wszREGACTIVE);

        dwError=RegOpenKeyExW(hPolicyModules, wszCurPolicy, NULL, KEY_ALL_ACCESS, &hCurPolicy);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegOpenKeyExW", wszCurPolicy);
        }

        // read the value
        dwDataSize=sizeof(dwRequestDisposition);
        dwError=RegQueryValueExW(hCurPolicy, wszREGREQUESTDISPOSITION, NULL, &dwType, (BYTE *)&dwRequestDisposition, &dwDataSize);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegQueryValueExW", wszREGREQUESTDISPOSITION);
        }
        _Verify(REG_DWORD==dwType, hr, error);
        _Verify(sizeof(dwRequestDisposition)==dwDataSize, hr, error);

        // clear the pending-first flag
        dwRequestDisposition&=~REQDISP_PENDINGFIRST;

        // save the vale
        dwError=RegSetValueExW(hCurPolicy, wszREGREQUESTDISPOSITION, NULL, dwType, (BYTE *)&dwRequestDisposition, dwDataSize);
        if (ERROR_SUCCESS!=dwError) {
            hr=HRESULT_FROM_WIN32(dwError);
            _JumpErrorStr(hr, error, "RegSetValueExW", wszREGREQUESTDISPOSITION);
        }
    }

    // all done
    hr=S_OK;
error:
    if (NULL!=wszCurPolicy) {
        LocalFree(wszCurPolicy);
    }
    if (NULL!=hCurPolicy) {
        RegCloseKey(hCurPolicy);
    }
    if (NULL!=hPolicyModules) {
        RegCloseKey(hPolicyModules);
    }
    if (NULL!=mwszSubjectTemplate) {
        LocalFree(mwszSubjectTemplate);
    }
    if (NULL!=hCaConfig) {
        RegCloseKey(hCaConfig);
    }
    return hr;
}

//--------------------------------------------------------------------
HRESULT GetCaType(OUT ENUM_CATYPES * pCAType)
{
    HRESULT hr;
    DWORD dwDataSize;
    DWORD dwCAType;
    DWORD dwType;
    DWORD dwError;

    // must be cleaned up
    HKEY hCaConfig=NULL;

    // init out params
    *pCAType=ENUM_UNKNOWN_CA;

    // get the current CA config key
    hr=OpenCurrentCAConfig(&hCaConfig);
    _JumpIfError(hr, error, "OpenCurrentCAConfig");

    // read the CA Type
    dwDataSize=sizeof(dwCAType);
    dwError=RegQueryValueExW(hCaConfig, wszREGCATYPE, NULL, &dwType, (BYTE *)&dwCAType, &dwDataSize);
    if (ERROR_SUCCESS!=dwError) {
        hr=HRESULT_FROM_WIN32(dwError);
        _JumpErrorStr(hr, error, "RegQueryValueExW", wszREGCATYPE);
    }
    _Verify(REG_DWORD==dwType, hr, error);
    _Verify(sizeof(dwCAType)==dwDataSize, hr, error);

    _Verify(dwCAType<=ENUM_UNKNOWN_CA, hr, error);

    // all done
    hr=S_OK;
    *pCAType=(ENUM_CATYPES)dwCAType;

error:
    if (NULL!=hCaConfig) {
        RegCloseKey(hCaConfig);
    }
    return hr;
}


//--------------------------------------------------------------------
BOOL IsUserInAdminGroup(IN BOOL bEnterprise)
{
    BOOL bIsMember=FALSE;
    HRESULT hr;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority=SECURITY_NT_AUTHORITY;

    // must be cleaned up
    HANDLE hAccessToken=NULL;
    HANDLE hDupToken=NULL;
    SID * psidLocalAdmins=NULL;
    SID * psidEntAdmins=NULL;
    SID * psidRootDomAdmins=NULL;

    // Get the access token for this process
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hAccessToken)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "OpenProcessToken");
    }

    // CheckTokenMembership must operate on impersonation token, so make one
    if (!DuplicateToken(hAccessToken, SecurityIdentification, &hDupToken)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        _JumpError(hr, error, "DuplicateToken");
    }

    if (bEnterprise) {
        // see if the user is a member of the [domain]\Enmterprised Administrators group
        BOOL bIsEntAdmin=FALSE;
        BOOL bIsRootDomAdmin=FALSE;

        // get the Enterpise Admin SID
        hr=GetEntAdminSid(&psidEntAdmins);
        _JumpIfError(hr, error, "GetEntAdminSid");

        // check for membership
        if (!CheckTokenMembership(hDupToken, psidEntAdmins, &bIsEntAdmin)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "CheckTokenMembership");
        }

        // get the root Domain Admin SID
        hr=GetRootDomAdminSid(&psidRootDomAdmins);
        _JumpIfError(hr, error, "GetRootDomAdminSid");

        // check for membership
        if (!CheckTokenMembership(hDupToken, psidRootDomAdmins, &bIsRootDomAdmin)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "CheckTokenMembership");
        }

        // either one will do
        bIsMember=(bIsEntAdmin || bIsRootDomAdmin);

    } else {
        // see if the user is a member of the BUILTIN\Administrators group

        // get the well-known SID
        if (!AllocateAndInitializeSid(&siaNtAuthority, 2, 
                SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0, (void **)&psidLocalAdmins))
        {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "AllocateAndInitializeSid");
        }

        // check for membership
        if (!CheckTokenMembership(hDupToken, psidLocalAdmins, &bIsMember)) {
            hr=HRESULT_FROM_WIN32(GetLastError());
            _JumpError(hr, error, "CheckTokenMembership");
        }
    }


error:
    if (NULL!=hAccessToken) {
        CloseHandle(hAccessToken);
    }

    if (NULL!=hDupToken) {
        CloseHandle(hDupToken);
    }

    if (NULL!=psidLocalAdmins) {
        FreeSid(psidLocalAdmins);
    }

    if (NULL!=psidEntAdmins) {
        LocalFree(psidEntAdmins);
    }

    if (NULL!=psidRootDomAdmins) {
        LocalFree(psidRootDomAdmins);
    }

    return bIsMember;
}


//--------------------------------------------------------------------
HRESULT DoCertSrvEnterpriseChanges(SID * psidAccount)
{
    HRESULT hr;
    DWORD dwFlags;
    BOOL bSDChanged1;
    BOOL bSDChanged2;
    BOOL bSDChanged3;
	BOOL bSDChanged4;

    // must be cleaned up
    HCERTTYPE hEAOTemplate=NULL;
    HCERTTYPE hCETemplate=NULL;
    HCERTTYPE hIIOTemplate=NULL;
    PSECURITY_DESCRIPTOR pSD=NULL;
    WCHAR * wszCAName=NULL;
    HCAINFO hCA=NULL;
    SID * psidEntAdmins=NULL;
    SID * psidRootDomAdmins=NULL;
    SID * psidThisComputer=NULL;

    //
    // first, make sure the CA will issue the cert templates we want
    //

    // get the sanitized CA name
    hr=GetCADsName(&wszCAName);
    _JumpIfError(hr, error, "GetCADsName");

    // get the CA (in the DS)
    hr=CAFindByName(wszCAName, NULL, 0, &hCA);
    _JumpIfErrorStr(hr, error, "CAFindCaByName", wszCAName);

    // check the flags to confirm it supports templates
    hr=CAGetCAFlags(hCA, &dwFlags);
    _JumpIfError(hr, error, "CAGetCAFlags");
    _Verify(0==(dwFlags&CA_FLAG_NO_TEMPLATE_SUPPORT), hr, error);

    // get the enrollment agent offline template
    hr=CAFindCertTypeByName(wszCERTTYPE_ENROLLMENT_AGENT_OFFLINE, NULL, CT_ENUM_USER_TYPES, &hEAOTemplate);
    _JumpIfErrorStr(hr, error, "CAFindCertTypeByName", wszCERTTYPE_ENROLLMENT_AGENT_OFFLINE);
    // make sure that the CA will issue this template
    hr=CAAddCACertificateType(hCA, hEAOTemplate);
    _JumpIfErrorStr(hr, error, "CAAddCACertificateType", wszCERTTYPE_ENROLLMENT_AGENT_OFFLINE);

    // get the CEP encryption template
    hr=CAFindCertTypeByName(wszCERTTYPE_CEP_ENCRYPTION, NULL, CT_ENUM_MACHINE_TYPES, &hCETemplate);
    _JumpIfErrorStr(hr, error, "CAFindCertTypeByName", wszCERTTYPE_CEP_ENCRYPTION);
    // make sure that the CA will issue this template
    hr=CAAddCACertificateType(hCA, hCETemplate);
    _JumpIfErrorStr(hr, error, "CAAddCACertificateType", wszCERTTYPE_CEP_ENCRYPTION);

    // get the IPSEC Intermediate offline template
    hr=CAFindCertTypeByName(wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE, NULL, CT_ENUM_MACHINE_TYPES, &hIIOTemplate);
    _JumpIfErrorStr(hr, error, "CAFindCertTypeByName", wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE);
    // make sure that the CA will issue this template
    hr=CAAddCACertificateType(hCA, hIIOTemplate);
    _JumpIfErrorStr(hr, error, "CAAddCACertificateType", wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE);

    // make sure that all gets written.
    hr=CAUpdateCA(hCA);
    _JumpIfError(hr, error, "CAUpdateCA");



    //
    // now, check the ACLs
    //

    // get the Enterpise Admin SID
    hr=GetEntAdminSid(&psidEntAdmins);
    _JumpIfError(hr, error, "GetEntAdminSid");

    // get the root Domain Admin SID
    hr=GetRootDomAdminSid(&psidRootDomAdmins);
    _JumpIfError(hr, error, "GetRootDomAdminSid");

    // get this computer's SID
    hr=GetThisComputerSid(&psidThisComputer);
    _JumpIfError(hr, error, "GetThisComputerSid");



    // enrollment agent offline template needs Enterprise Admins and root Domain Admins
    hr=CACertTypeGetSecurity(hEAOTemplate, &pSD);
    _JumpIfError(hr, error, "CACertTypeGetSecurity");

    hr=ConfirmAccess(&pSD, psidEntAdmins, &bSDChanged1);
    _JumpIfError(hr, error, "ConfirmAccess");

    hr=ConfirmAccess(&pSD, psidRootDomAdmins, &bSDChanged2);
    _JumpIfError(hr, error, "ConfirmAccess");

    if (bSDChanged1 || bSDChanged2) {
        hr=CACertTypeSetSecurity(hEAOTemplate, pSD);
        _JumpIfError(hr, error, "CACertTypeSetSecurity");

        hr=CAUpdateCertType(hEAOTemplate);
        _JumpIfError(hr, error, "CAUpdateCertType");
    }

    LocalFree(pSD);
    pSD=NULL;

    
    // CEP encryption template needs Enterprise Admins and root Domain Admins
    hr=CACertTypeGetSecurity(hCETemplate, &pSD);
    _JumpIfError(hr, error, "CACertTypeGetSecurity");

    hr=ConfirmAccess(&pSD, psidEntAdmins, &bSDChanged1);
    _JumpIfError(hr, error, "ConfirmAccess");

    hr=ConfirmAccess(&pSD, psidRootDomAdmins, &bSDChanged2);
    _JumpIfError(hr, error, "ConfirmAccess");

    if (bSDChanged1 || bSDChanged2) {
        hr=CACertTypeSetSecurity(hCETemplate, pSD);
        _JumpIfError(hr, error, "CACertTypeSetSecurity");

        hr=CAUpdateCertType(hCETemplate);
        _JumpIfError(hr, error, "CAUpdateCertType");
    }

    LocalFree(pSD);
    pSD=NULL;


    // IPSEC Intermediate offline template needs Enterprise Admins and root Domain Admins and the current machine
    hr=CACertTypeGetSecurity(hIIOTemplate, &pSD);
    _JumpIfError(hr, error, "CACertTypeGetSecurity");

    hr=ConfirmAccess(&pSD, psidEntAdmins, &bSDChanged1);
    _JumpIfError(hr, error, "ConfirmAccess");

    hr=ConfirmAccess(&pSD, psidRootDomAdmins, &bSDChanged2);
    _JumpIfError(hr, error, "ConfirmAccess");

    hr=ConfirmAccess(&pSD, psidThisComputer, &bSDChanged3);
    _JumpIfError(hr, error, "ConfirmAccess");

	//if a service account if used, add the account to the template
	if(psidAccount)
	{
		hr=ConfirmAccess(&pSD, psidAccount, &bSDChanged4);
		_JumpIfError(hr, error, "ConfirmAccess");
	}
	else
	{
		bSDChanged4=FALSE;
	}

    if (bSDChanged1 || bSDChanged2 || bSDChanged3 || bSDChanged4) {
        hr=CACertTypeSetSecurity(hIIOTemplate, pSD);
        _JumpIfError(hr, error, "CACertTypeSetSecurity");

        hr=CAUpdateCertType(hIIOTemplate);
        _JumpIfError(hr, error, "CAUpdateCertType");
    }

    hr=S_OK;
error:
    if (NULL!=psidThisComputer) {
        LocalFree(psidThisComputer);
    }
    if (NULL!=psidEntAdmins) {
        LocalFree(psidEntAdmins);
    }
    if (NULL!=psidRootDomAdmins) {
        LocalFree(psidRootDomAdmins);
    }
    if (NULL!=pSD) {
        LocalFree(pSD);
    }
    if (NULL!=hEAOTemplate) {
        CACloseCertType(hEAOTemplate);
    }
    if (NULL!=hCETemplate) {
        CACloseCertType(hCETemplate);
    }
    if (NULL!=hIIOTemplate) {
        CACloseCertType(hIIOTemplate);
    }
    if (NULL!=wszCAName) {
        LocalFree(wszCAName);
    }
    if (NULL!=hCA) {
        CACloseCA(hCA);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\setup\setuputil.h ===
//--------------------------------------------------------------------
// SetupUtil - header
// Copyright (C) Microsoft Corporation, 1999
//
// Created by: Louis Thomas (louisth), 8-10-99
//
// Functions needed to set up CEP
//

#ifndef SETUP_UTIL_H
#define SETUP_UTIL_H

//--------------------------------------------------------------------
// prototypes
// Note: caller must call CoInitialize() first

BOOL IsNT5(void);
BOOL IsIISInstalled(void);
BOOL IsGoodCaInstalled(void);
BOOL IsCaRunning(void);
BOOL IsServiceRunning(IN const WCHAR * wszServiceName);
BOOL IsUserInAdminGroup(IN BOOL bEnterprise);
HRESULT AddVDir(IN BOOL fDC,
				IN const WCHAR * wszDirectory,
				IN const WCHAR * wszApplicationPool,
				IN BOOL  fLocalSystem,
				IN const WCHAR * wszUserName,
				IN const WCHAR * wszPassword);
HRESULT CepStopService(IN DWORD dwServicePeriod, IN const WCHAR * wszServiceName, OUT BOOL * pbWasRunning);
HRESULT CepStartService(IN const WCHAR * wszServiceName);
HRESULT EnrollForRACertificates(
            IN const WCHAR * wszDistinguishedName,
            IN const WCHAR * wszSignCSPName,
            IN DWORD dwSignCSPType,
            IN DWORD dwSignKeySize,
            IN const WCHAR * wszEncryptCSPName,
            IN DWORD dwEncryptCSPType,
            IN DWORD dwEncryptKeySize,
			IN SID	 *psidAccount);
HRESULT DoCertSrvRegChanges(IN BOOL bDisablePendingFirst);
HRESULT GetCaType(OUT ENUM_CATYPES * pCAType);
HRESULT DoCertSrvEnterpriseChanges(SID *psidAccount);

#endif //SETUP_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certlog\csfile2.h ===
_SYMENTRY(__dwFILE_OCMSETUP_BROWSEDI_CPP__),
_SYMENTRY(__dwFILE_OCMSETUP_CONFIG_CPP__),
_SYMENTRY(__dwFILE_OCMSETUP_CRYPTFIX_CPP__),
_SYMENTRY(__dwFILE_OCMSETUP_CSOCM_CPP__),
_SYMENTRY(__dwFILE_OCMSETUP_CSPENUM_CPP__),
_SYMENTRY(__dwFILE_OCMSETUP_DSSETUP_CPP__),
_SYMENTRY(__dwFILE_OCMSETUP_PFXIMPT_CPP__),
_SYMENTRY(__dwFILE_OCMSETUP_REGD_CPP__),
_SYMENTRY(__dwFILE_OCMSETUP_SETUPUT_CPP__),
_SYMENTRY(__dwFILE_OCMSETUP_UNATTEND_CPP__),
_SYMENTRY(__dwFILE_OCMSETUP_USECERT_CPP__),
_SYMENTRY(__dwFILE_OCMSETUP_WIZPAGE_CPP__),
_SYMENTRY(__dwFILE_OCMSETUP_REG_CPP__),
_SYMENTRY(__dwFILE_INITLIB_CERTHIER_CPP__),
_SYMENTRY(__dwFILE_INITLIB_INITLIB_CPP__),
_SYMENTRY(__dwFILE_INITLIB_KEYENUM_CPP__),
_SYMENTRY(__dwFILE_INITLIB_LOG_CPP__),
_SYMENTRY(__dwFILE_INITLIB_CERTMSG_CPP__),
_SYMENTRY(__dwFILE_INITLIB_CERTUI_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_CERTUTIL_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_ADMIN_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_BACKUP_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_DB2_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_DBCNVT_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_DBCORE_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_DS_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_DUMP_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_INFO_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_MISC_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_ODBC_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_REG_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_STORE_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_TCAINFO_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_VERIFY_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_VIEW_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_SCINFO_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_EPF_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_URL_CPP__),
_SYMENTRY(__dwFILE_CERTUTIL_CACHE_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_INF_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_LOG_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CERTMSG_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_ACL_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_ADMIN_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_ADVAPI32_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_BACKUP_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_BASE64_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CASD_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CERTLIB_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CERTPICK_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CERTSD_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CHECK7F_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CIEXIT_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CIPOLICY_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CNFGSTG_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CONFIG_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CRFILE_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CRYPT_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CSCSP_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CSLISTVW_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CSPELOG_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CSW97PPG_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CSW97SHT_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_DCOM_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_DISPATCH_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_HEX_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_KEYGEN2_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_LDAP_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_MANAGE_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_MAPI_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_OFFICER_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_PKIFMT_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_PROGRESS_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_PROP2_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_PRVLG_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_REG_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_REQUEST_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_STRING_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_TFC_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_TFCPROP_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_TMPLLIST_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_VIEW_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_VIEWATTR_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_VIEWCOL_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_VIEWEXT_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_VIEWROW_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_ADMIN_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_CALLBACK_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_CERTSRV_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_CERTSRVD_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_CIENUM_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_COM_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_COMTEST_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_CORE_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_CRL_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_DB3_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_ELOG_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_EVENT_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_PKCS_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_PROP_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_REQUEST_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_RPC_CPP__),
_SYMENTRY(__dwFILE_CERTSRV_SERVICE_CPP__),
_SYMENTRY(__dwFILE_CERTADM_ADMIN_CPP__),
_SYMENTRY(__dwFILE_CERTADM_ATL_CPP__),
_SYMENTRY(__dwFILE_CERTADM_BACKUP_CPP__),
_SYMENTRY(__dwFILE_CERTADM_CERTADM_CPP__),
_SYMENTRY(__dwFILE_CERTADM_MANAGE_CPP__),
_SYMENTRY(__dwFILE_CERTADM_RESTORE_CPP__),
_SYMENTRY(__dwFILE_CERTCLI_ATL_CPP__),
_SYMENTRY(__dwFILE_CERTCLI_CERTCLI_CPP__),
_SYMENTRY(__dwFILE_CERTCLI_COLUMN_CPP__),
_SYMENTRY(__dwFILE_CERTCLI_CONFIG_CPP__),
_SYMENTRY(__dwFILE_CERTCLI_CONFIGP_CPP__),
_SYMENTRY(__dwFILE_CERTCLI_CRYPT_CPP__),
_SYMENTRY(__dwFILE_CERTCLI_GETCONF_CPP__),
_SYMENTRY(__dwFILE_CERTCLI_REQUEST_CPP__),
_SYMENTRY(__dwFILE_CERTCLI_UWBASE64_CPP__),
_SYMENTRY(__dwFILE_CERTCLI_VROOT_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_ALLOC_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_ASSERT_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_AUTOENRL_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_CAINFO_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_CAINFOC_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_CAINFOP_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_CERTDEC_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_CERTTYPE_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_CTNOTIFY_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_DEBUG_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_DEFTYPES_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_DSTEST_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_ERROR_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_LOGON_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_OIDMGR_CPP__),
_SYMENTRY(__dwFILE_CERTCLIB_SERIAL_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_ABOUT_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_BROWSEDI_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_CASEC_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_CERTIF_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_CERTWRAP_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_CHOOSER_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_COMPDATA_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_CSNAPIN_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_DATAOBJ_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_EVENTS_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_FOLDERS_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_GENPAGE_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_KRAPAGE_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_MISC_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_OFFICER_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_SNAPIN_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_URLS_CPP__),
_SYMENTRY(__dwFILE_CERTMMC_UUIDS_CPP__),
_SYMENTRY(__dwFILE_POLICY_DEFAULT_ATL_CPP__),
_SYMENTRY(__dwFILE_POLICY_DEFAULT_CERTPDEF_CPP__),
_SYMENTRY(__dwFILE_POLICY_DEFAULT_MODULE_CPP__),
_SYMENTRY(__dwFILE_POLICY_DEFAULT_POLICY_CPP__),
_SYMENTRY(__dwFILE_POLICY_DEFAULT_REQUEST_CPP__),
_SYMENTRY(__dwFILE_POLICY_DEFAULT_TEMPLATE_CPP__),
_SYMENTRY(__dwFILE_CERTDB_ATL_CPP__),
_SYMENTRY(__dwFILE_CERTDB_BACKUP_CPP__),
_SYMENTRY(__dwFILE_CERTDB_CERTDB_CPP__),
_SYMENTRY(__dwFILE_CERTDB_COLUMN_CPP__),
_SYMENTRY(__dwFILE_CERTDB_DB_CPP__),
_SYMENTRY(__dwFILE_CERTDB_DBTABLE_CPP__),
_SYMENTRY(__dwFILE_CERTDB_DBW_CPP__),
_SYMENTRY(__dwFILE_CERTDB_ENUM_CPP__),
_SYMENTRY(__dwFILE_CERTDB_PCH_CPP__),
_SYMENTRY(__dwFILE_CERTDB_RESTORE_CPP__),
_SYMENTRY(__dwFILE_CERTDB_ROW_CPP__),
_SYMENTRY(__dwFILE_CERTDB_VIEW_CPP__),
_SYMENTRY(__dwFILE_CERTVIEW_ATTRIB_CPP__),
_SYMENTRY(__dwFILE_CERTVIEW_CERTVIEW_CPP__),
_SYMENTRY(__dwFILE_CERTVIEW_COLUMN_CPP__),
_SYMENTRY(__dwFILE_CERTVIEW_EXT_CPP__),
_SYMENTRY(__dwFILE_CERTVIEW_PCH_CPP__),
_SYMENTRY(__dwFILE_CERTVIEW_ROW_CPP__),
_SYMENTRY(__dwFILE_CERTVIEW_VIEW_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_POLDISP_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_EXITDISP_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_MULTISZ_CPP__),
_SYMENTRY(__dwFILE_CERTLIB_CSTRING_CPP__),
_SYMENTRY(__dwFILE_CERTIF_CIEXIT_CPP__),
_SYMENTRY(__dwFILE_CERTIF_CIPOLICY_CPP__),
_SYMENTRY(__dwFILE_CERTREQ_CERTREQ_CPP__),
_SYMENTRY(__dwFILE_CAPESNPN_ABOUT_CPP__),
_SYMENTRY(__dwFILE_CAPESNPN_COMPDATA_CPP__),
_SYMENTRY(__dwFILE_CAPESNPN_CSNAPIN_CPP__),
_SYMENTRY(__dwFILE_CAPESNPN_CTSHLEXT_CPP__),
_SYMENTRY(__dwFILE_CAPESNPN_DATAOBJ_CPP__),
_SYMENTRY(__dwFILE_CAPESNPN_EVENTS_CPP__),
_SYMENTRY(__dwFILE_CAPESNPN_GENPAGE_CPP__),
_SYMENTRY(__dwFILE_CAPESNPN_MISC_CPP__),
_SYMENTRY(__dwFILE_CAPESNPN_SERVICE_CPP__),
_SYMENTRY(__dwFILE_CAPESNPN_SNAPIN_CPP__),
_SYMENTRY(__dwFILE_CAPESNPN_UUIDS_CPP__),
_SYMENTRY(__dwFILE_EXIT_DEFAULT_ATL_CPP__),
_SYMENTRY(__dwFILE_EXIT_DEFAULT_CERTXDS_CPP__),
_SYMENTRY(__dwFILE_EXIT_DEFAULT_EXIT_CPP__),
_SYMENTRY(__dwFILE_EXIT_DEFAULT_MODULE_CPP__),
_SYMENTRY(__dwFILE_CERTLOG_CERTLOG_CPP__),
_SYMENTRY(__dwFILE_INCLUDE_CSPROP2_CPP__),
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certlog\certlog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certutil.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <locale.h>
#include <io.h>
#include <fcntl.h>
#include "clibres.h"
#include "setupids.h"
#include "res.h"
#include "csresstr.h"

#define __dwFILE__	__dwFILE_CERTLOG_CERTLOG_CPP__

#define WM_DOCERTLOGMAIN		WM_USER+0

WCHAR const wszAppName[] = L"CertLogApp";
WCHAR const *g_pwszProg = L"CertLog";

HINSTANCE g_hInstance;

#define _SYMENTRY(def)	{ #def, def }
typedef struct _SYMENTRY
{
    char const  *pszSymbol;
    DWORD	 symno;
} SYMENTRY;

SYMENTRY g_fnmap[] = {
#include "csfile2.h"
};


SYMENTRY g_resmap[] = {
#include "csres2.h"
};

char s_szFilePrefix[] = "__dwFILE_";


DWORD
GetNumber(
    IN WCHAR wcTerm,
    IN OUT WCHAR **ppwsz)
{
    WCHAR *pwsz = *ppwsz;
    DWORD dw = _wtoi(pwsz);
    DWORD dwRet = MAXDWORD;

    if (iswdigit(*pwsz))
    {
	while (iswdigit(*pwsz))
	{
	    pwsz++;
	}
	if (wcTerm == *pwsz)
	{
	    dwRet = dw;
	    *ppwsz = &pwsz[1];
	}
    }
    return(dwRet);
}


// Turn "__dwFILE_CERTLOG_CERTLOG_CPP__" into "certlog\certlog.cpp"

char *
FormatFileName(
    IN char const *pszFileIn)
{
    HRESULT hr;
    char *pszFileOut = NULL;
    char *pch;

    if (0 == _strnicmp(pszFileIn, s_szFilePrefix, SZARRAYSIZE(s_szFilePrefix)))
    {
	pszFileIn += SZARRAYSIZE(s_szFilePrefix);
    }
    hr = myDupStringA(pszFileIn, &pszFileOut);
    _JumpIfError(hr, error, "myDupStringA");

    pch = &pszFileOut[strlen(pszFileOut)];
    while (--pch >= pszFileOut && *pch == '_')
    {
	*pch = '\0';
    }
    pch = strrchr(pszFileOut, '_');
    *pch = '.';

    while (TRUE)
    {
	pch = strchr(pszFileOut, '_');
	if (NULL == pch)
	{
	    break;
	}
	*pch = '\\';
    }
    _strlwr(pszFileOut);

error:
    return(pszFileOut);
}


SYMENTRY const *
FindSymbol(
    IN DWORD symno,
    IN SYMENTRY const *psym,
    IN DWORD csym)
{
    SYMENTRY const *psymEnd = &psym[csym];

    for ( ; psym < psymEnd; psym++)
    {
	if (psym->symno == symno)
	{
	    return(psym);
	}
    }
    return(NULL);
}



VOID
ProcessLine(
    IN char const *pszLine)
{
    HRESULT hr;
    WCHAR *pwszLine = NULL;
    char *pszFile = NULL;
    DWORD fileno;
    DWORD lineno;
    DWORD resno;
    SYMENTRY const *psym;
    WCHAR *pwsz;

    if (!myConvertSzToWsz(&pwszLine, pszLine, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertSzToWsz");
    }

    pwsz = pwszLine;
    fileno = GetNumber(L'.', &pwsz);
    lineno = GetNumber(L'.', &pwsz);
    resno = GetNumber(L':', &pwsz);
    if (MAXDWORD != fileno && MAXDWORD != lineno && MAXDWORD != resno)
    {
	while (L' ' == *pwsz)
	{
	    pwsz++;
	}
	if (0 == fileno)
	{
	    // "0.resno.resno: "

	    psym = FindSymbol(lineno, g_resmap, ARRAYSIZE(g_resmap));
	    if (NULL != psym)
	    {
		wprintf(L"%hs: ", psym->pszSymbol);
	    }
	    else
	    {
		pwsz = pwszLine;	// give up
	    }
	}
	else
	{
	    // "fileno.lineno.resno: "

	    psym = FindSymbol(fileno, g_fnmap, ARRAYSIZE(g_fnmap));
	    if (NULL != psym)
	    {
		pszFile = FormatFileName(psym->pszSymbol);
		wprintf(
		    L"%hs(%u): ",
		    NULL != pszFile?
			pszFile : &psym->pszSymbol[SZARRAYSIZE(s_szFilePrefix)],
		    lineno);
	    }
	    else
	    {
		pwsz = pwszLine;	// give up
	    }
	}
    }
    else
    {
	pwsz = pwszLine;
    }
    if (pwsz > pwszLine && 0 != resno)
    {
	psym = FindSymbol(resno, g_resmap, ARRAYSIZE(g_resmap));
	psym = FindSymbol(resno, g_resmap, ARRAYSIZE(g_resmap));
	if (NULL != psym)
	{
	    wprintf(L"%hs: ", psym->pszSymbol);
	}
	else
	{
	    wprintf(L"%u: ", resno);
	}
    }
    wprintf(L"%ws\n", pwsz);

error:
    if (NULL != pszFile)
    {
	LocalFree(pszFile);
    }
    if (NULL != pwszLine)
    {
	LocalFree(pwszLine);
    }
}


#define ISNEWLINECHAR(ch)	('\r' == (ch) || '\n' == (ch))

char *
myfgets(
    OUT char *buf,
    IN DWORD cch,
    IN FILE *pf)
{
    char *psz = fgets(buf, cch, pf);
    if (NULL != psz)
    {
	char *pch = &psz[strlen(psz)];

	while (--pch >= psz && ISNEWLINECHAR(*pch))
	{
	    *pch = '\0';
	}
    }
    return(psz);
}


char *g_apszColumn[150];
char *g_apszColumnDisplay[150];
DWORD g_cColumn = 0;


HRESULT
SaveColumnNames(
    IN char const *psz)
{
    HRESULT hr;
    char const *pszStart;
    char const *pszEnd;
    char *pszAlloc;
    DWORD cch;

    while (' ' == *psz)
    {
	psz++;
    }
    pszStart = psz;
    while ('\0' != *psz && ' ' != *psz)
    {
	psz++;
    }
    cch = SAFE_SUBTRACT_POINTERS(psz, pszStart);

    pszAlloc = (char *) LocalAlloc(LMEM_FIXED, cch + 1);
    if (NULL == pszAlloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    g_apszColumn[g_cColumn] = pszAlloc;
    CopyMemory(pszAlloc, pszStart, cch);
    pszAlloc[cch] = '\0';

    while (' ' == *psz)
    {
	psz++;
    }
    pszEnd = strstr(psz, "  ");
    if (NULL == pszEnd)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "strstr");
    }
    while (psz < pszEnd && ' ' == *pszEnd)
    {
	pszEnd--;
    }
    cch = SAFE_SUBTRACT_POINTERS(pszEnd, psz) + 1;

    pszAlloc = (char *) LocalAlloc(LMEM_FIXED, cch + 1);
    if (NULL == pszAlloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    g_apszColumnDisplay[g_cColumn] = pszAlloc;
    CopyMemory(pszAlloc, psz, cch);
    pszAlloc[cch] = '\0';

    //wprintf(L"Col[%u] = %hs '%hs'\n", g_cColumn, g_apszColumn[g_cColumn], g_apszColumnDisplay[g_cColumn]);
    g_cColumn++;
    hr = S_OK;

error:
    return(hr);
}


BOOL
ConvertHexToDecimal(
    IN char const *psz,
    OUT char *pch,
    OUT DWORD cch)
{
    HRESULT hr;
    BOOL fValid = FALSE;
    WCHAR *pwsz = NULL;
    WCHAR *pwszDecimal;
    int i;
    int j;
    
    if ('0' == psz[0] && 'x' == psz[1])
    {
	if (!myConvertSzToWsz(&pwsz, psz, -1))
	{
	    hr = E_OUTOFMEMORY;
	     _JumpError(hr, error, "myConvertSzToWsz");
	}
	pwszDecimal = wcschr(pwsz, L' ');
	if (NULL != pwszDecimal)
	{
	    *pwszDecimal++ = L'\0';
	}
	i = myWtoI(pwsz, &fValid);
	if (fValid)
	{
	    if (-1 == _snprintf(pch, cch, "%u", i))
	    {
		fValid = FALSE;
	    }
	    else if (NULL != pwszDecimal)
	    {
		fValid = FALSE;
		if (wcLPAREN == *pwszDecimal)
		{
		    WCHAR *pwc;

		    pwszDecimal++;
		    pwc = wcschr(pwszDecimal, wcRPAREN);
		    if (NULL != pwc && L'\0' == pwc[1])
		    {
			*pwc = L'\0';
			j = myWtoI(pwszDecimal, &fValid);
			if (i != j)
			{
			    fValid = FALSE;
			}
		    }
		}
	    }
	}
    }

error:
    if (NULL != pwsz)
    {
	LocalFree(pwsz);
    }
    return(fValid);
}


HRESULT
ReformatView(
    IN WCHAR const *pwszfn)
{
    HRESULT hr;
    char buf[1024];
    FILE *pf = NULL;
    DWORD i;
    char *pszRowPrefix = NULL;
    DWORD cchRowPrefix;
    BOOL fFirstLine;

    pf = _wfopen(pwszfn, L"r");
    if (NULL == pf)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "fopen");
    }

    fFirstLine = TRUE;
    while (TRUE)
    {
	WCHAR *pwszSchema = NULL;

	if (NULL == myfgets(buf, sizeof(buf), pf))
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "myfgets(Schema:)");
	}
	if (!myConvertSzToWsz(&pwszSchema, buf, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myConvertSzToWsz");
	}
	if (0 == LSTRCMPIS(pwszSchema, L"Schema:"))
	{
	    LocalFree(pwszSchema);
	    break;
	}
	LocalFree(pwszSchema);
	pwszSchema = NULL;
	if (fFirstLine)
	{
	    char const *psz;
	
	    psz = strchr(buf, ':');
	    if (NULL != psz && '\0' == psz[1])
	    {
		break;
	    }
	}
	fFirstLine = FALSE;
    }
    if (NULL == myfgets(buf, sizeof(buf), pf) ||
	NULL == myfgets(buf, sizeof(buf), pf) ||
	NULL == strstr(buf, "-----------------"))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "myfgets(schema header)");
    }
    while (NULL != myfgets(buf, sizeof(buf), pf))
    {
	if (L'\0' == buf[0])
	{
	    break;
	}
	hr = SaveColumnNames(buf);
	_JumpIfError(hr, error, "SaveColumnNames");
    }
    wprintf(L"Row");
    for (i = 0; i < g_cColumn; i++)
    {
	wprintf(L"\t%hs", g_apszColumn[i]);
    }
    wprintf(L"\n");

    while (TRUE)
    {
	BOOL fEOF = FALSE;
	static char s_BlankPrefix[] = "  ";
	static char s_Begin[] = "-----BEGIN ";
	static char s_End[] = "-----END ";

	while (TRUE)
	{
	    if (NULL == myfgets(buf, sizeof(buf), pf))
	    {
		fEOF = TRUE;
		break;
	    }
	    if (NULL == pszRowPrefix)
	    {
		char *psz;
		
		psz = strchr(buf, ' ');
		if (NULL == psz || psz == buf || !isdigit(psz[1]))
		{
		    continue;
		}
		psz++;
		cchRowPrefix = SAFE_SUBTRACT_POINTERS(psz, buf);
		pszRowPrefix = (char *) LocalAlloc(LMEM_FIXED, cchRowPrefix + 1);
		if (NULL == pszRowPrefix)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		CopyMemory(pszRowPrefix, buf, cchRowPrefix);
		pszRowPrefix[cchRowPrefix] = '\0';
	    }
	    if (0 == _strnicmp(pszRowPrefix, buf, cchRowPrefix) &&
		isdigit(buf[cchRowPrefix]))
	    {
		wprintf(L"%u", atoi(&buf[cchRowPrefix]));
		break;
	    }
	}
	if (fEOF)
	{
	    break;
	}
	for (i = 0; i < g_cColumn; i++)
	{
	    DWORD cch;
	    char const *psz;
	    char ach[cwcDWORDSPRINTF];
	    BOOL fSkipRead = 0 != i;

	    cch = strlen(g_apszColumnDisplay[i]);
	    while (TRUE)
	    {
		if (!fSkipRead && NULL == myfgets(buf, sizeof(buf), pf))
		{
		    fEOF = TRUE;
		    break;
		}
		psz = &buf[SZARRAYSIZE(s_BlankPrefix)];
		if (0 == strncmp(
			    s_BlankPrefix,
			    buf,
			    SZARRAYSIZE(s_BlankPrefix)) &&
		    0 == _strnicmp(g_apszColumnDisplay[i], psz, cch) &&
		    ':' == psz[cch])
		{
		    break;
		}
		fSkipRead = FALSE;
	    }
	    psz += cch + 1;
	    while (' ' == *psz)
	    {
		psz++;
	    }
	    if ('\0' == *psz)
	    {
		psz = "???";
	    }
	    if (ConvertHexToDecimal(psz, ach, ARRAYSIZE(ach)))
	    {
		psz = ach;
	    }
	    wprintf(L"\t%hs", psz);
	    if ('"' == *psz && NULL == strchr(&psz[1], '"'))
	    {
		while (TRUE)
		{
		    if (NULL == myfgets(buf, sizeof(buf), pf))
		    {
			break;
		    }
		    wprintf(L" %hs", buf);
		    if (NULL != strchr(buf, '"'))
		    {
			break;
		    }
		}
	    }
	    else
	    {
		BOOL fBase64 = FALSE;

		while (TRUE)
		{
		    if (NULL == myfgets(buf, sizeof(buf), pf))
		    {
			break;
		    }
		    if ('\0' == buf[0])
		    {
			break;
		    }
		    if (i + 1 < g_cColumn)
		    {
			psz = &buf[SZARRAYSIZE(s_BlankPrefix)];
			cch = strlen(g_apszColumnDisplay[i + 1]);

			if (0 == strncmp(
				    s_BlankPrefix,
				    buf,
				    SZARRAYSIZE(s_BlankPrefix)) &&
			    0 == _strnicmp(
				    g_apszColumnDisplay[i + 1],
				    psz,
				    cch) &&
			    ':' == psz[cch])
			{
			    break;
			}
		    }
		    if (!fBase64 && 
			0 == _strnicmp(s_Begin, buf, SZARRAYSIZE(s_Begin)))
		    {
			fBase64 = TRUE;
		    }
		    else if (fBase64 &&
			     0 == _strnicmp(s_End, buf, SZARRAYSIZE(s_End)))
		    {
			fBase64 = FALSE;
			continue;
		    }
		    if (!fBase64)
		    {
			psz = buf;
			while (' ' == *psz)
			{
			    psz++;
			}
			wprintf(L" %hs", psz);
		    }
		}
	    }
	}
	wprintf(L"\n");
    }
    if (ferror(pf))
    {
	hr = STG_E_READFAULT;
	_JumpError(hr, error, "ferror");
    }
    hr = S_OK;

error:
    if (NULL != pf)
    {
	fclose(pf);
    }
    for (i = 0; i < g_cColumn; i++)
    {
	if (NULL != g_apszColumn[i])
	{
	    LocalFree(g_apszColumn[i]);
	}
	if (NULL != g_apszColumnDisplay[i])
	{
	    LocalFree(g_apszColumnDisplay[i]);
	}
    }
    if (NULL != pszRowPrefix)
    {
	LocalFree(pszRowPrefix);
    }
    return(hr);
}


HRESULT
ReformatLog(
    IN WCHAR const *pwszfn)
{
    HRESULT hr;
    char buf[1024];
    FILE *pf = NULL;

    if (0 == lstrcmpi(pwszfn, L"-"))
    {
	pf = stdout;
    }
    else
    {
	pf = _wfopen(pwszfn, L"r");
	if (NULL == pf)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpError(hr, error, "fopen");
	}
    }
    while (NULL != myfgets(buf, sizeof(buf), pf))
    {
	ProcessLine(buf);
    }
    if (ferror(pf))
    {
	hr = STG_E_READFAULT;
	_JumpError(hr, error, "ferror");
    }
    hr = S_OK;

error:
    if (NULL != pf && stdout != pf)
    {
	fclose(pf);
    }
    return(hr);
}


HRESULT
ArgvMain(
    int argc,
    WCHAR *argv[],
    HWND hWndOwner)
{
    HRESULT hr;
    BOOL fView = FALSE;

    if (1 < argc &&
	myIsSwitchChar(argv[1][0]) &&
	0 == LSTRCMPIS(&argv[1][1], L"view"))
    {
	fView = TRUE;
    }
    
    if ((!fView && 2 != argc) || (fView && 3 != argc))
    {
	wprintf(L"Usage: CertLog [-view] <LogFile>\n");
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Usage");
    }
    if (fView)
    {
	hr = ReformatView(argv[2]);
	_JumpIfError(hr, error, "ReformatView");
    }
    else
    {
	hr = ReformatLog(argv[1]);
	_JumpIfError(hr, error, "ReformatLog");
    }

error:
    return(hr);
}


//**************************************************************************
//  FUNCTION:	CertLogPreMain
//  NOTES:	Based on MkRootMain function; takes an LPSTR command line and
//		chews it up into argc/argv form so that it can be passed on to
//		a traditional C style main.
//**************************************************************************

#define ISBLANK(wc)	(L' ' == (wc) || L'\t' == (wc))

HRESULT 
CertLogPreMain(
    WCHAR const *pwszCmdLine,
    HWND hWndOwner)
{
    HRESULT hr;
    WCHAR *pbuf;
    WCHAR *apszArg[20];
    int cArg = 0;
    WCHAR *p;
    WCHAR const *pchQuote;
    WCHAR **prgpwszExeName = NULL;
    int carg;

    pbuf = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszCmdLine) + 1) * sizeof(WCHAR));
    if (NULL == pbuf)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    p = pbuf;

    apszArg[cArg++] = TEXT("CertLog");
    while (*pwszCmdLine != TEXT('\0'))
    {
	while (ISBLANK(*pwszCmdLine))
	{
	    pwszCmdLine++;
	}
	if (*pwszCmdLine != TEXT('\0'))
	{
	    apszArg[cArg++] = p;
	    if (sizeof(apszArg)/sizeof(apszArg[0]) <= cArg)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Too many args");
	    }
	    pchQuote = NULL;
	    while (*pwszCmdLine != L'\0')
	    {
		if (NULL != pchQuote)
		{
		    if (*pwszCmdLine == *pchQuote)
		    {
			pwszCmdLine++;
			pchQuote = NULL;
			continue;
		    }
		}
		else
		{
		    if (ISBLANK(*pwszCmdLine))
		    {
			break;
		    }
		    if (L'"' == *pwszCmdLine)
		    {
			pchQuote = pwszCmdLine++;
			continue;
		    }
		}
		*p++ = *pwszCmdLine++;
	    }
	    *p++ = TEXT('\0');
	    if (*pwszCmdLine != TEXT('\0'))
	    {
		pwszCmdLine++;	// skip whitespace or quote character
	    }
	}
    }
    apszArg[cArg] = NULL;

    hr = ArgvMain(cArg, apszArg, hWndOwner);
    _JumpIfError(hr, error, "ArgvMain");

error:
    if (NULL != prgpwszExeName)
    {
	GlobalFree(prgpwszExeName);
    }
    if (NULL != pbuf)
    {
	LocalFree(pbuf);
    }
    return(hr);
}


//**************************************************************************
//  FUNCTION:	MainWndProc(...)
//  ARGUMENTS:
//**************************************************************************

LRESULT APIENTRY
MainWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int nWCharsRequired;
    WCHAR *pwszCmdLine = NULL;
    CHAR const *pszCmdLine;
    HRESULT hr;
    LRESULT lr = 0;

    switch (msg)
    {
        case WM_CREATE:
        case WM_SIZE:
	    break;

        case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

        case WM_DOCERTLOGMAIN:
	    pwszCmdLine = (WCHAR*)lParam;
	    hr = CertLogPreMain(pwszCmdLine, hWnd);

	    PostQuitMessage(hr);
	    break;

        default:
	    lr = DefWindowProc(hWnd, msg, wParam, lParam);
	    break;
    }
    return(lr);
}


//+------------------------------------------------------------------------
//
//  Function:	wWinMain()
//
//  Synopsis:	Entry Point
//
//  Arguments:	[hInstance]	--	Instance handle
//		[hPrevInstance] --	Obsolete
//		[pwszCmdLine]	--	App command line
//		[nCmdShow]	--	Starting show state
//
//  History:	12/07/96	JerryK	Added this Comment
//
//-------------------------------------------------------------------------

extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR pwszCmdLine,
    int nCmdShow)
{
    MSG msg;
    WNDCLASS wcApp;
    HWND hWndMain;

    _setmode(_fileno(stdout), _O_TEXT);
    _wsetlocale(LC_ALL, L".OCP");
    mySetThreadUILanguage(0);

    // Save the current instance
    g_hInstance = hInstance;

    // Set up the application's window class
    wcApp.style		= 0;
    wcApp.lpfnWndProc	= MainWndProc;
    wcApp.cbClsExtra	= 0;
    wcApp.cbWndExtra	= 0;
    wcApp.hInstance	= hInstance;
    wcApp.hIcon		= LoadIcon(NULL,IDI_APPLICATION);
    wcApp.hCursor	= LoadCursor(NULL,IDC_ARROW);
    wcApp.hbrBackground	= (HBRUSH)GetStockObject(WHITE_BRUSH);
    wcApp.lpszMenuName	= NULL;
    wcApp.lpszClassName	= wszAppName;

    if (!RegisterClass(&wcApp))
    {
	return(FALSE);
    }

    // Create Main Window
    hWndMain = CreateWindow(
			wszAppName,
			L"CertLog Application",
			WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT, CW_USEDEFAULT,
			CW_USEDEFAULT, CW_USEDEFAULT,
			NULL,
			NULL,
			hInstance,
			NULL);
    if (NULL == hWndMain)
    {
	return(FALSE);
    }

    // Make window visible
    // ShowWindow(hWndMain, nCmdShow);

    // Update window client area
    UpdateWindow(hWndMain);

    // Send off the message to get things started
    PostMessage(hWndMain, WM_DOCERTLOGMAIN, 0, (LPARAM) pwszCmdLine);

    // Message Loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    }
    myRegisterMemDump();
    return((int) msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\cep\setup\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------


//icon
#define IDI_MAINFRAME                   200			


//bitmap
#define IDB_WIN2K                       300

//dialogue
#define IDD_WELCOME						120
#define IDD_CHALLENGE					121
#define IDD_ENROLL						122
#define IDD_CSP							123
#define IDD_COMPLETION					124
#define	IDD_ACCOUNT						125
#define IDD_APP_ID						126


//control
#define	IDC_BIG_BOLD_TITLE				1003
#define	IDC_BOLD_TITLE					1004
#define	IDC_CHALLENGE_CHECK				1005
#define	IDC_COMPLETION_LIST				1006
#define IDC_ENROLL_NAME                 1007
#define IDC_ENROLL_EMAIL                1008
#define IDC_ENROLL_COMPANY              1009
#define IDC_ENROLL_DEPARTMENT           1010
#define IDC_ENROLL_CITY                 1011
#define IDC_ENROLL_STATE                1012
#define IDC_ENROLL_COUNTRY              1013
#define	IDC_ENORLL_ADV_CHECK			1014
#define	IDC_CSP_SIGN_LIST				1015
#define	IDC_CSP_ENCRYPT_LIST			1016
#define	IDC_CSP_SIGN_COMBO				1017
#define	IDC_CSP_ENCRYPT_COMBO			1018
#define IDC_ACCOUNT_INTRO				1019
#define IDC_ACCOUNT_NAME				1020
#define	IDC_ACCOUNT_PASSWORD			1021
#define IDC_ACCOUNT_CONFIRM				1022
#define IDC_ACCOUNT_BROWSE				1023
#define	IDC_APP_ID_RADIO1				1024
#define	IDC_APP_ID_RADIO2				1025


#define IDC_WIZARD_STATIC               -1

//string
#define IDS_MEG_CAPTION					3000
#define	IDS_NO_NT5						3001
#define	IDS_NO_IIS						3002
#define	IDS_NO_GOOD_CA					3003
#define	IDS_NO_CA_RUNNING				3004
#define	IDS_CEP_ERROR_MSG_HR			3005	
#define	IDS_CEP_ERROR_MSG				3006
#define	IDS_WIZARD_CAPTION				3007
#define	IDS_FAIL_INIT_WIZARD			3008
#define	IDS_FAIL_DELETE_RA				3009
#define	IDS_ENROLL_REQUIRE_NAME			3010
#define	IDS_CHALLENGE_PHRASE			3011
#define	IDS_YES							3012
#define	IDS_NO							3013
#define	IDS_RA_CREDENTIAL				3014
#define	IDS_FAIL_UPDATE_REGISTRY		3015
#define	IDS_FAIL_ADD_VROOT				3016
#define	IDS_FAIL_START_IIS				3017
#define	IDS_FAIL_UPDATE_CERTSVC			3018
#define	IDS_FAIL_START_CERTSVC			3019
#define	IDS_FAIL_ENROLL_RA_CERT			3020
#define	IDS_NO_MEMORY					3021
#define	IDS_EXISTING_RA					3022
#define	IDS_PROCESS_PENDING				3023
#define	IDS_CEP_SUCCESS_INFO			3024
#define	IDS_FAIL_GET_COMPUTER_NAME		3025
#define	IDS_ENROLL_COUNTRY_TOO_LARGE	3026
#define	IDS_FAIL_GET_CSP_INFO			3027
#define	IDS_SIGN_CSP					3028			
#define	IDS_SIGN_KEY_LENGTH				3029
#define	IDS_ENCRYPT_CSP					3030
#define	IDS_ENCRYPT_KEY_LENGTH			3031
#define	IDS_SELECT_SIGN_CSP				3032
#define	IDS_SELECT_ENCRYPT_CSP			3033
#define	IDS_SELECT_SIGN_KEY_LENGTH		3034
#define	IDS_SELECT_ENCRYPT_KEY_LENGTH	3035	
#define	IDS_FAIL_GET_CA_TYPE			3036	
#define	IDS_NOT_ENT_ADMIN				3037
#define	IDS_NOT_MACHINE_ADMIN			3038
#define	IDS_FAIL_ADD_TEMPLATE			3039
#define	IDS_CAN_NOT_START_CA			3040
#define	IDS_CAN_NOT_ROOT_CA				3041
#define	IDS_FAIL_REG_EVENT_LOG			3042
#define	IDS_ACCOUNT_INTRO_ENT			3043
#define	IDS_ACCOUNT_INTRO_STD			3044
#define	IDS_ACCOUNT_EMPTY				3045
#define	IDS_PASSWORD_EMPTY				3046
#define	IDS_PASSWORD_NO_MATCH			3047
#define	IDS_INVALID_NAME				3048
#define	IDS_FAIL_LOGON_USER				3049
#define	IDS_GEN_ERROR_MSG_HR			3050
#define	IDS_GEN_ERROR_MSG				3051
#define	IDS_FAIL_CHECK_MEMBER			3052
#define	IDS_NOT_IIS_MEMBER				3053
#define	IDS_FAIL_LOOK_UP				3054
#define	IDS_FAIL_FIND_CERT_TYPE			3055
#define	IDS_FAIL_FIND_DOMAIN			3056
#define	IDS_ACCOUNT_INFORMATION			3057
#define	IDS_FAIL_FIND_SD_CERT_TYPE		3058
#define	IDS_FAIL_DETECT_READ_ACCESS		3059
#define	IDS_NO_READ_ACCESS_TO_TEMPLATE	3060
#define	IDS_FAIL_GET_OBJECT_PICKER		3061
#define	IDS_FAIL_SID_FROM_ACCOUNT		3062
#define	IDS_NO_LOCAL_ACCOUNT			3063
#define	IDS_FAIL_DOMAIN_INFO			3064
#define	IDS_LOCAL_SYSTEM				3065
#define	IDS_NO_CHALLENGE_PASSWORD       3066
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certlog\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certlog\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"certut"

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
//#include <wincrypt.h>

//#include "certsrv.h"

#include "certlib.h"
//#include "csdisp.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certie3\certie3.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certie3.cpp
//
//--------------------------------------------------------------------------

#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <stdio.h>
#include "wincrypt.h"

int ln = 0;

// This has to be big enough to hold a registry value's data.
char szStr[5000];

#define DISPLAY(sz)	printf("%hs\n", sz)


void __cdecl
main(
    int argc,
    char **argv)
{
    char szRegPath[MAX_PATH] = "SOFTWARE\\Microsoft\\Cryptography\\";
    char sourceloc[MAX_PATH];
    char *pszFileOut;
    char *pszRegKey;
    HKEY hKeyBase;
    BOOL fAuth = FALSE;

    fAuth = argc > 1 && argv[1][0] == '-';
	
    if (fAuth)
    {
	pszFileOut = "ClientAuth.dat";
	strcpy(sourceloc, "HKEY_CURRENT_USER");
	pszRegKey = "PersonalCertificates\\ClientAuth\\Certificates";
	hKeyBase = HKEY_CURRENT_USER;
    }
    else
    {
	pszFileOut = "CertStore.dat";
	strcpy(sourceloc, "HKEY_LOCAL_MACHINE");
	pszRegKey = "CertificateStore\\Certificates";
	hKeyBase = HKEY_LOCAL_MACHINE;
    }

    ln = 0;
    strcat(szRegPath, pszRegKey);

    strcat(sourceloc, "\\");
    strcat(sourceloc, szRegPath);
    strcpy(szStr, "Collect information from Registry");
    DISPLAY(szStr);

    ln++;
    strcpy(szStr, "Registry location: ");
    strcat(szStr, sourceloc);
    DISPLAY(szStr);

    ln++;
    strcpy(szStr, "Target destination for registry dump: ");
    strcat(szStr, pszFileOut);
    DISPLAY(szStr);
		  

    // Declarations for the output file related stuff

    HCRYPTPROV hProv = NULL;
    HCERTSTORE hCertStore = NULL;
    CERT_INFO certinfo;
    CERT_CONTEXT const *pPrevCertContext = NULL;
    CERT_CONTEXT const *pCertContext = NULL;
    DWORD dwErr;

    if (!CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, 0))
    {
	dwErr = GetLastError();

	if (dwErr == NTE_BAD_KEYSET)
	{
	    strcpy(szStr, "NTE_BAD_KEYSET error on call CryptAcquireContext");
	    DISPLAY(szStr);
	    hProv = NULL;
	    if (!CryptAcquireContext(
				&hProv,
				NULL,
				NULL,
				PROV_RSA_FULL,
				CRYPT_NEWKEYSET))
	    {
		strcpy(szStr, "CryptAcquireContext - call failed");
		DISPLAY(szStr);
		exit(6);
	    }  
	}
    }

    HANDLE hFile = NULL;

    hFile = CreateFile(
		    pszFileOut,
		    GENERIC_WRITE,
		    0,
		    NULL,
		    CREATE_ALWAYS,
		    FILE_ATTRIBUTE_NORMAL,
		    NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
	printf("Couldn't open output file\n");
	exit(5);
    }

    hCertStore = CertOpenStore(
			CERT_STORE_PROV_MEMORY,
			X509_ASN_ENCODING,
			NULL,			// hProv
			CERT_STORE_NO_CRYPT_RELEASE_FLAG,
			NULL);
    if (NULL == hCertStore)
    {
	exit(8);
    }

    // Declarations for the registry stuff

    HKEY hkMain;
    HRESULT hr;

    hr = RegOpenKeyEx(
		    hKeyBase,
		    szRegPath, 
		    0,
		    KEY_QUERY_VALUE,
		    &hkMain);

    if (hr != S_OK)
    {
	exit(3);
    }

    // Use the RegQueryInfoKey function to determine the maximum size of the
    // name and data buffers, 

    CHAR ClassName[MAX_PATH] = "";	// Buffer for class name.
    DWORD dwcClassLen = MAX_PATH;	// Length of class string.
    DWORD dwcSubKeys;			// Number of sub keys.
    DWORD dwcMaxSubKey;			// Longest sub key size.
    DWORD dwcMaxClass;			// Longest class string.
    DWORD dwcValues;			// Number of values for this key.
    DWORD dwcMaxValueName;		// Longest Value name.
    DWORD dwcMaxValueData;		// Longest Value data.
    DWORD dwcSecDesc;			// Security descriptor.
    FILETIME ftLastWriteTime;		// Last write time.

    RegQueryInfoKey(
		hkMain,			// Key handle.
		ClassName,		// Buffer for class name.
		&dwcClassLen,		// Length of class string.
		NULL,			// Reserved.
		&dwcSubKeys,		// Number of sub keys.
		&dwcMaxSubKey,		// Longest sub key size.
		&dwcMaxClass,		// Longest class string.
		&dwcValues,		// Number of values for this key.
		&dwcMaxValueName,	// Longest Value name.
		&dwcMaxValueData,	// Longest Value data.
		&dwcSecDesc,		// Security descriptor.
		&ftLastWriteTime);	// Last write time

    DWORD i;
    CHAR ValueName[MAX_PATH];
    DWORD dwcValueName;

    // address of buffer for type code (this is returned by RegEnumValue)
    DWORD pType;

    // address of buffer for value data 
    unsigned char *pData = new unsigned char[dwcMaxValueData + 1];

    DWORD pcbData;		// address for size of data buffer 

    for (i = 0; i < dwcValues; i++)
    {
	ValueName[0] = '\0';
	dwcValueName = sizeof(ValueName)/sizeof(ValueName[0]);
	pcbData = dwcMaxValueData + 1;

	hr = RegEnumValue(
			hkMain, 
			i,		// index of value to query
			ValueName,	// address of buffer for value string
			&dwcValueName,	// address for size of value string buf
			NULL,		// reserved
			&pType,		// &pType
			pData,		// pData
			&pcbData);	// &pcbData

	hr = myHError(hr);
	if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
	{
	    break;
	}
	if (S_OK != hr)
	{
	    exit(2);
	}

	// Display the value name

	ln++;
	strcpy(szStr, ValueName);
	DISPLAY(szStr);

	if (pType == REG_BINARY)
	{                
	    // Write the data which is pointed to by pData, 
	    // count of bytes is gotten from pcbData

	    CertAddEncodedCertificateToStore(
					hCertStore,
					X509_ASN_ENCODING,
					pData,
					pcbData,
					CERT_STORE_ADD_USE_EXISTING,
					NULL);
	}
    }

    // Save

    CertSaveStore(
        hCertStore,
        0,                          // dwEncodingType,
        CERT_STORE_SAVE_AS_STORE,
        CERT_STORE_SAVE_TO_FILE,
        (void *) hFile,
        0                           // dwFlags
        );

    // Close memory store

    CertCloseStore(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
    if (!CryptReleaseContext(hProv, 0))
    {
	exit(7);
    }
    RegCloseKey(hkMain);
    ln++;
    strcpy(szStr, "CertIE3.exe completed successfully");
    DISPLAY(szStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certlog\csres2.h ===
_SYMENTRY(IDS_CERTTYPE_USER),
_SYMENTRY(IDS_CERTTYPE_USER_AS),
_SYMENTRY(IDS_CERTTYPE_USER_SMARTCARD_LOGON),
_SYMENTRY(IDS_CERTTYPE_EFS),
_SYMENTRY(IDS_CERTTYPE_ADMIN),
_SYMENTRY(IDS_CERTTYPE_EFS_RECOVERY),
_SYMENTRY(IDS_CERTTYPE_CODE_SIGNING),
_SYMENTRY(IDS_CERTTYPE_CTL_SIGNING),
_SYMENTRY(IDS_CERTTYPE_MACHINE),
_SYMENTRY(IDS_CERTTYPE_DC),
_SYMENTRY(IDS_CERTTYPE_WEBSERVER),
_SYMENTRY(IDS_CERTTYPE_KDC),
_SYMENTRY(IDS_CERTTYPE_ROOT_CA),
_SYMENTRY(IDS_CERTTYPE_SUBORDINATE_CA),
_SYMENTRY(IDS_CERTTYPE_ENROLLMENT_AGENT),
_SYMENTRY(IDS_CERTTYPE_SMARTCARD_USER),
_SYMENTRY(IDS_CERTTYPE_USER_SIGNATURE),
_SYMENTRY(IDS_ILOG_BAD_NUMERICFIELD),
_SYMENTRY(IDS_CERTTYPE_IPSEC_INTERMEDIATE_ONLINE),
_SYMENTRY(IDS_ILOG_BAD_VALIDITY_COUNT),
_SYMENTRY(IDS_CERTTYPE_IPSEC_INTERMEDIATE_OFFLINE),
_SYMENTRY(IDS_ILOG_BAD_VALIDITY_STRING),
_SYMENTRY(IDS_CERTTYPE_ROUTER_OFFLINE),
_SYMENTRY(IDS_REQUEST_FILE_DEFEXT),
_SYMENTRY(IDS_REQUEST_OPEN_TITLE),
_SYMENTRY(IDS_REQUEST_FILE_FILTER),
_SYMENTRY(IDS_WRN_COMPUTERNAME_EMPTY),
_SYMENTRY(IDS_WRN_CANAME_EMPTY),
_SYMENTRY(IDS_WRN_CANAME_NOT_MATCH),
_SYMENTRY(IDS_WRN_PINGCA_FAIL),
_SYMENTRY(IDS_CERTTYPE_ENROLLMENT_AGENT_OFFLINE),
_SYMENTRY(IDS_CERTTYPE_EXCHANGE_USER),
_SYMENTRY(IDS_CERTTYPE_EXCHANGE_USER_SIGNATURE),
_SYMENTRY(IDS_WRN_CALIST_EMPTY),
_SYMENTRY(IDS_CERTTYPE_MACHINE_ENROLLMENT_AGENT),
_SYMENTRY(IDS_REQUEST_SAVE_TITLE),
_SYMENTRY(IDS_CERTTYPE_CEP_ENCRYPTION),
_SYMENTRY(IDS_ILOG_CAPOLICY_BUILD),
_SYMENTRY(IDS_ILOG_CAPOLICY_ELEMENT),
_SYMENTRY(IDS_ILOG_CAPOLICY_EXTENSION),
_SYMENTRY(IDS_ILOG_CAPOLICY_NOKEY),
_SYMENTRY(IDS_ILOG_CAPOLICY_OPEN),
_SYMENTRY(IDS_ILOG_CAPOLICY_OPEN_FAILED),
_SYMENTRY(IDS_ILOG_BEGIN),
_SYMENTRY(IDS_ILOG_END),
_SYMENTRY(IDS_ACTRL_CAADMIN),
_SYMENTRY(IDS_ACTRL_OFFICER),
_SYMENTRY(IDS_ACTRL_AUDITOR),
_SYMENTRY(IDS_ACTRL_OPERATOR),
_SYMENTRY(IDS_ACTRL_CAREAD),
_SYMENTRY(IDS_ACTRL_ENROLL),
_SYMENTRY(IDS_ILOG_CAPOLICY_CLOSE),
_SYMENTRY(IDS_ILOG_MESSAGEBOX),
_SYMENTRY(IDS_ILOG_BAD_VALIDITY_STRING_UNATTEND),
_SYMENTRY(IDS_CERTTYPE_KEY_RECOVERY_AGENT),
_SYMENTRY(IDS_CERTTYPE_CA_EXCHANGE),
_SYMENTRY(IDS_EMPTY_FRIENDLY_NAME),
_SYMENTRY(IDS_CERTTYPE_CROSS_CA),
_SYMENTRY(IDS_CERTTYPE_DC_AUTH),
_SYMENTRY(IDS_CERTTYPE_DS_EMAIL_REPLICATION),
_SYMENTRY(IDS_WARN_ENTERPRISE_REQUIREMENTS),
_SYMENTRY(IDS_WRN_OLD_CA),
_SYMENTRY(IDS_ILOG_BAD_BOOLEAN),
_SYMENTRY(IDS_CERTTYPE_WORKSTATION),
_SYMENTRY(IDS_CERTTYPE_RASIASSERVER),
_SYMENTRY(IDS_LOW_ASSURANCE_DISPLAY_NAME),
_SYMENTRY(IDS_MEDIUM_ASSURANCE_DISPLAY_NAME),
_SYMENTRY(IDS_HIGH_ASSURANCE_DISPLAY_NAME),
_SYMENTRY(IDS_KRA_DESCRIPTION),
_SYMENTRY(IDS_EMAIL_REPLICATION_DESCRIPTION),
_SYMENTRY(IDS_CROSS_CA_DESCRIPTION),
_SYMENTRY(IDS_CA_DESCRIPTION),
_SYMENTRY(IDS_MACHINE_DESCRIPTION),
_SYMENTRY(IDS_END_USER_DESCRIPTION),
_SYMENTRY(IDS_UNKNOWN_DESCRIPTION),
_SYMENTRY(IDS_STORENAME_DS_KRA),
_SYMENTRY(IDS_STORENAME_DS_AIA),
_SYMENTRY(IDS_CAHIER_CERTFILE_FILTER),
_SYMENTRY(IDS_CAHIER_INSTALL_TITLE),
_SYMENTRY(IDS_ILOG_MISSING_PROVIDER),
_SYMENTRY(IDS_ERR_INCOMPLETECHAIN),
_SYMENTRY(IDS_ERR_INVALIDCHAIN),
_SYMENTRY(IDS_ERR_RETRIEVE_PENDING),
_SYMENTRY(IDS_ILOG_GETCANAME),
_SYMENTRY(IDS_ILOG_SELECTCA),
_SYMENTRY(IDS_ILOG_SAVECERTANDKEYS),
_SYMENTRY(IDS_ILOG_RETRIEVECERT),
_SYMENTRY(IDS_ILOG_FINISHSUSPENDEDSETUP),
_SYMENTRY(IDS_ERR_NOTCACERT),
_SYMENTRY(IDS_ILOG_SETUPCOMPLETE),
_SYMENTRY(IDS_ILOG_RETRIEVEPENDING),
_SYMENTRY(IDS_ILOG_KEYINDEX),
_SYMENTRY(IDS_ILOG_LOADOLDCERT),
_SYMENTRY(IDS_ILOG_CLONECERT),
_SYMENTRY(IDS_ILOG_BUILDREQUEST),
_SYMENTRY(IDS_ILOG_RENEWOLDKEY),
_SYMENTRY(IDS_ILOG_INSTALLCERT),
_SYMENTRY(IDS_ILOG_RENEWNEWKEY),
_SYMENTRY(IDS_ILOG_BUILDCERT),
_SYMENTRY(IDS_ILOG_SAVECHAINANDKEYS),
_SYMENTRY(IDS_REQUEST_HELPTEXT),
_SYMENTRY(IDS_ILOG_CREATECDP),
_SYMENTRY(IDS_ILOG_CREATENTAUTHTRUST),
_SYMENTRY(IDS_ILOG_CREATEROOTTRUST),
_SYMENTRY(IDS_ILOG_PUBLISHCA),
_SYMENTRY(IDS_ILOG_SUBMITREQUEST),
_SYMENTRY(IDS_ERR_BADCSP),
_SYMENTRY(IDS_ERR_BAD_CA_CERT_7F),
_SYMENTRY(IDS_ERR_RENEWEDCERTCAVERSION),
_SYMENTRY(IDS_ERR_UNTRUSTEDROOT),
_SYMENTRY(IDS_ERR_CERTADDCERTIFICATECONTEXTTOSTORE),
_SYMENTRY(IDS_ERR_CERTCREATECERTIFICATECONTEXT),
_SYMENTRY(IDS_ILOG_UNREFERENCEDINFSECTIONS),
_SYMENTRY(IDS_ILOG_SETSECURITY),
_SYMENTRY(IDS_ERR_CREATEFILE),
_SYMENTRY(IDS_ERR_DELETEKEY),
_SYMENTRY(IDS_ERR_ENCODEKEYATTR),
_SYMENTRY(IDS_ERR_ENCODETOBESIGNED),
_SYMENTRY(IDS_ERR_ENV_NOT_SET),
_SYMENTRY(IDS_ERR_FULL_TOKEN),
_SYMENTRY(IDS_ERR_GENKEYFAIL),
_SYMENTRY(IDS_ERR_GETCOMPUTERNAME),
_SYMENTRY(IDS_ERR_KEYSECURITY),
_SYMENTRY(IDS_ERR_MYDECODENAME),
_SYMENTRY(IDS_ERR_NOT_ENTERPRISE_USER),
_SYMENTRY(IDS_ERR_NOT_MATCH_COMMONNAME),
_SYMENTRY(IDS_ILOG_GENERATEKEYS),
_SYMENTRY(IDS_ERR_REPEATWIZPREFIX),
_SYMENTRY(IDS_ERR_REQUEST_DENIED),
_SYMENTRY(IDS_ERR_REQUEST_ERROR),
_SYMENTRY(IDS_ERR_REQUEST_INCOMPLETE),
_SYMENTRY(IDS_ERR_REQUEST_OUTOFBAND),
_SYMENTRY(IDS_ERR_REQUEST_PENDING),
_SYMENTRY(IDS_ERR_REQUEST_REVOKED),
_SYMENTRY(IDS_ERR_SETKEYPROVIDER),
_SYMENTRY(IDS_ERR_SUBMIT_REQUEST),
_SYMENTRY(IDS_ERR_SUBMIT_REQUEST_FAIL),
_SYMENTRY(IDS_ERR_NOT_MATCH_BINARYNAME),
_SYMENTRY(IDS_ERR_NOT_MATCH_KEY),
_SYMENTRY(IDS_CAHIER_INSTALL_MISIINGCERT_TITLE),
_SYMENTRY(IDS_ERR_WRITEDERTOFILE),
_SYMENTRY(IDS_ERR_WRITEFILE),
_SYMENTRY(IDS_ILOG_INFERROR),
_SYMENTRY(IDS_ILOG_SETKEYSECURITY),
_SYMENTRY(IDS_MSG_PARENTCA_CONFIG),
_SYMENTRY(IDS_MSG_REQUEST_ID),
_SYMENTRY(IDS_MSG_TITLE),
_SYMENTRY(IDS_ILOG_SETADMINONLYFOLDERSECURITY),
_SYMENTRY(IDS_ERR_NO_KEY_ACCESS),
_SYMENTRY(IDS_CA_PICKER_TITLE),
_SYMENTRY(IDS_CA_PICKER_PROMPT),
_SYMENTRY(IDS_STARTMENU_CERTHIER_LINKNAME),
_SYMENTRY(IDS_STARTMENU_CERTREQ_LINKNAME),
_SYMENTRY(IDS_STARTMENU_CERTSERVER),
_SYMENTRY(IDS_STARTMENU_NEWCRL_LINKNAME),
_SYMENTRY(IDS_ADVANCE_INVALIDKEYLENGTH),
_SYMENTRY(IDS_ADVANCE_KEYLENGTHOUTOFRANGE),
_SYMENTRY(IDS_ADVANCE_NEGATIVEKEYLENGTH),
_SYMENTRY(IDS_ADVANCE_SUBTITLE),
_SYMENTRY(IDS_ADVANCE_TITLE),
_SYMENTRY(IDS_ASK_CREATE_DIRECTORY),
_SYMENTRY(IDS_CALENSTRERR),
_SYMENTRY(IDS_CANULLSTRERR),
_SYMENTRY(IDS_CAREQUEST_SUBTITLE),
_SYMENTRY(IDS_CAREQUEST_TITLE),
_SYMENTRY(IDS_CATYPE_DES_ENTERPRISE_ROOTCA),
_SYMENTRY(IDS_CATYPE_DES_ENTERPRISE_SUBCA),
_SYMENTRY(IDS_CATYPE_DES_STANDALONE_ROOTCA),
_SYMENTRY(IDS_CATYPE_DES_STANDALONE_SUBCA),
_SYMENTRY(IDS_CATYPE_SUBTITLE),
_SYMENTRY(IDS_CATYPE_TITLE),
_SYMENTRY(IDS_CA_SERVICEDESCRIPTION),
_SYMENTRY(IDS_CA_SERVICEDISPLAYNAME),
_SYMENTRY(IDS_CERTCONFIG_FOLDERDESCR),
_SYMENTRY(IDS_CLIENT_NOCA),
_SYMENTRY(IDS_CLIENT_NOCOMPUTER),
_SYMENTRY(IDS_CLIENT_SUBTITLE),
_SYMENTRY(IDS_CLIENT_TITLE),
_SYMENTRY(IDS_COMPUTERLENSTRERR),
_SYMENTRY(IDS_COMPUTERNULLSTRERR),
_SYMENTRY(IDS_CONFIG_PICKER_PROMPT),
_SYMENTRY(IDS_CONFIG_PICKER_TITLE),
_SYMENTRY(IDS_ERR_ADDSOURCETOREGISTRY),
_SYMENTRY(IDS_ERR_ANALYSIS_CA),
_SYMENTRY(IDS_ERR_BUILDCERT),
_SYMENTRY(IDS_ERR_BUILDCERTREQUEST),
_SYMENTRY(IDS_FINAL_ERROR_TEXT),
_SYMENTRY(IDS_ERR_CERTSRV_SETUP_FAIL),
_SYMENTRY(IDS_ERR_CREATECERTSRVFILE),
_SYMENTRY(IDS_ERR_CREATELINK),
_SYMENTRY(IDS_ERR_CREATESERVICE),
_SYMENTRY(IDS_ERR_DELETESERVICE),
_SYMENTRY(IDS_ERR_DLLFUNCTION_CALL),
_SYMENTRY(IDS_ERR_EMPTYCANAME),
_SYMENTRY(IDS_ERR_EMPTYPFXFILE),
_SYMENTRY(IDS_ERR_FATAL_GENKEY),
_SYMENTRY(IDS_ERR_IMPORTPFX),
_SYMENTRY(IDS_ERR_INVALIDHASH),
_SYMENTRY(IDS_ERR_LOADICERTCONFIG),
_SYMENTRY(IDS_ERR_NETUSERMODALSGET),
_SYMENTRY(IDS_ERR_NOT_ADM),
_SYMENTRY(IDS_ERR_UNSUPPORTEDHASH),
_SYMENTRY(IDS_ERR_WRITECONFIGFILE),
_SYMENTRY(IDS_IDINFO_CAEXISTINDS),
_SYMENTRY(IDS_IDINFO_DESCRIPTIONLENSTRERR),
_SYMENTRY(IDS_IDINFO_COUNTRYLENSTRERR),
_SYMENTRY(IDS_IDINFO_DETERMINEDBYPCA),
_SYMENTRY(IDS_IDINFO_EMAILLENSTRERR),
_SYMENTRY(IDS_IDINFO_INVALID_COUNTRYCODE),
_SYMENTRY(IDS_IDINFO_INVALID_COUNTRYCODE_LEN),
_SYMENTRY(IDS_IDINFO_INVALID_VALIDITY),
_SYMENTRY(IDS_IDINFO_LOCALITYLENSTRERR),
_SYMENTRY(IDS_IDINFO_NAMELENSTRERR),
_SYMENTRY(IDS_IDINFO_NAMENULLSTRERR),
_SYMENTRY(IDS_IDINFO_ORGLENSTRERR),
_SYMENTRY(IDS_IDINFO_ORGUNITLENSTRERR),
_SYMENTRY(IDS_IDINFO_STATELENSTRERR),
_SYMENTRY(IDS_IDINFO_SUBTITLE),
_SYMENTRY(IDS_IDINFO_TITLE),
_SYMENTRY(IDS_IDINFO_VALIDITYNULLSTRERR),
_SYMENTRY(IDS_IMPORT_PFX_TITLE),
_SYMENTRY(IDS_INCOMPLETE_REQUEST),
_SYMENTRY(IDS_KEYGEN_GENERATING),
_SYMENTRY(IDS_KEYGEN_PROTECTING),
_SYMENTRY(IDS_KEYGEN_SUBTITLE),
_SYMENTRY(IDS_KEYGEN_TESTINGHASHANDKEY),
_SYMENTRY(IDS_KEYGEN_TITLE),
_SYMENTRY(IDS_KEY_INVALID),
_SYMENTRY(IDS_PATH_TOO_LONG_CANAME),
_SYMENTRY(IDS_PFX_FILE_FILTER),
_SYMENTRY(IDS_PFX_FILE_NOT_FOUND),
_SYMENTRY(IDS_PFX_INVALID_PASSWORD),
_SYMENTRY(IDS_PFX_KEYANDCERTEXIST),
_SYMENTRY(IDS_PFX_PATH_INVALID),
_SYMENTRY(IDS_REQUESTFILELENSTRERR),
_SYMENTRY(IDS_REQUESTFILENULLSTRERR),
_SYMENTRY(IDS_STOP_W3SVC),
_SYMENTRY(IDS_STORELOC_PARENTDIRMUSTEXIST),
_SYMENTRY(IDS_STORELOC_PATHTOOLONG),
_SYMENTRY(IDS_STORELOC_UNCMUSTEXIST),
_SYMENTRY(IDS_STORE_SUBTITLE),
_SYMENTRY(IDS_STORE_TITLE),
_SYMENTRY(IDS_TODO_TITLE),
_SYMENTRY(IDS_VALIDITY_DAY),
_SYMENTRY(IDS_VALIDITY_MONTH),
_SYMENTRY(IDS_VALIDITY_WEEK),
_SYMENTRY(IDS_VALIDITY_YEAR),
_SYMENTRY(IDS_WRN_DBFILEINUSE),
_SYMENTRY(IDS_WRN_OVERWRITEEXISTINGKEY),
_SYMENTRY(IDS_WRN_STORELOC_DB_FULLPATH),
_SYMENTRY(IDS_WRN_STORELOC_EXISTINGDB),
_SYMENTRY(IDS_WRN_STORELOC_LOG_FULLPATH),
_SYMENTRY(IDS_WRN_STORELOC_SHAREDFOLDER_FULLPATH),
_SYMENTRY(IDS_WRN_UNICODESTRINGENCODING),
_SYMENTRY(IDS_LOG_BEGIN),
_SYMENTRY(IDS_LOG_END),
_SYMENTRY(IDS_LOG_WAS_ENABLED),
_SYMENTRY(IDS_LOG_IS_ENABLED),
_SYMENTRY(IDS_LOG_INSTALL_STATE),
_SYMENTRY(IDS_LOG_CREATE_REQUEST),
_SYMENTRY(IDS_LOG_CREATE_CERTIFICATE),
_SYMENTRY(IDS_LOG_START_SERVICE),
_SYMENTRY(IDS_LOG_WEB_INCLUDE),
_SYMENTRY(IDS_LOG_INSTALL_CLIENT),
_SYMENTRY(IDS_LOG_INSTALL_SERVER),
_SYMENTRY(IDS_LOG_UPGRADE_TYPE),
_SYMENTRY(IDS_LOG_UPGRADE_CERT_STORE),
_SYMENTRY(IDS_LOG_UPGRADE_KEY_SECURITY),
_SYMENTRY(IDS_LOG_UPGRADE_SERVER),
_SYMENTRY(IDS_LOG_UPGRADE_CLIENT),
_SYMENTRY(IDS_LOG_SERVICE_STOPPED),
_SYMENTRY(IDS_LOG_SERVICE_STARTED),
_SYMENTRY(IDS_LOG_CREATE_CLIENT_REG),
_SYMENTRY(IDS_LOG_CREATE_SERVER_REG),
_SYMENTRY(IDS_LOG_UPGRADE_SERVER_REG),
_SYMENTRY(IDS_LOG_DLLS_UNREGISTERED),
_SYMENTRY(IDS_LOG_DLLS_REGISTERED),
_SYMENTRY(IDS_LOG_PROGRAM_GROUPS),
_SYMENTRY(IDS_LOG_CREATE_SERVICE),
_SYMENTRY(IDS_LOG_CANCEL_INSTALL),
_SYMENTRY(IDS_LOG_FUNCTION),
_SYMENTRY(IDS_LOG_UNATTENDED_ATTRIBUTE),
_SYMENTRY(IDS_LOG_CLIENT_UNATTENDED_ATTRIBUTES),
_SYMENTRY(IDS_LOG_SERVER_UNATTENDED_ATTRIBUTES),
_SYMENTRY(IDS_LOG_OPERATIONFLAGS),
_SYMENTRY(IDS_LOG_TODOLIST),
_SYMENTRY(IDS_LOG_POSTBASE),
_SYMENTRY(IDS_LOG_UNATTENDED),
_SYMENTRY(IDS_LOG_REGSTATE),
_SYMENTRY(IDS_LOG_SELECTIONSTATE),
_SYMENTRY(IDS_WELCOME_TITLE),
_SYMENTRY(IDS_FINAL_TITLE),
_SYMENTRY(IDS_LOG_IMPORTPFX),
_SYMENTRY(IDS_ERR_CREATE_DIR),
_SYMENTRY(IDS_WRN_UNINSTALL_BOTH),
_SYMENTRY(IDS_WRN_UNINSTALL_CLIENT),
_SYMENTRY(IDS_PFX_WRONG_SELFSIGN_TYPE),
_SYMENTRY(IDS_CAREQUEST_REQUESTFILEPATH_MUSTEXIST),
_SYMENTRY(IDS_LOG_IGNORE_KEYLENGTH),
_SYMENTRY(IDS_CAREQUEST_REQUESTFILEPATH_DIREXISTS),
_SYMENTRY(IDS_PFX_FILE_OR_PASSWORD_TOO_LONG),
_SYMENTRY(IDS_ERR_UPGRADE_NOT_SUPPORTED),
_SYMENTRY(IDS_WRN_SERVER_ONLY),
_SYMENTRY(IDS_IDINFO_VALIDITYLENSTRERR),
_SYMENTRY(IDS_WRN_IDINFO_INVALIDDN),
_SYMENTRY(IDS_HTML_CERTWEBDAT),
_SYMENTRY(IDS_HTML_NSREV),
_SYMENTRY(IDS_IDINFO_DELETECERTIFICATES),
_SYMENTRY(IDS_LOG_CANAME),
_SYMENTRY(IDS_LOG_ORG),
_SYMENTRY(IDS_LOG_ORGUNIT),
_SYMENTRY(IDS_LOG_LOCALITY),
_SYMENTRY(IDS_LOG_STATE),
_SYMENTRY(IDS_LOG_EMAIL),
_SYMENTRY(IDS_LOG_COUNTRY),
_SYMENTRY(IDS_LOG_DESCRIPTION),
_SYMENTRY(IDS_LOG_SHAREDFOLDER),
_SYMENTRY(IDS_LOG_DBDIR),
_SYMENTRY(IDS_LOG_DBLOGDIR),
_SYMENTRY(IDS_LOG_COMPUTER),
_SYMENTRY(IDS_LOG_REQUESTFILE),
_SYMENTRY(IDS_LOG_VALIDITY),
_SYMENTRY(IDS_LOG_CATYPE),
_SYMENTRY(IDS_LOG_KEYNAME),
_SYMENTRY(IDS_ERR_NONIA5DNSNAME),
_SYMENTRY(IDS_WRN_DBSPECIALCHARACTERS),
_SYMENTRY(IDS_WRN_NONAMECHANGE),
_SYMENTRY(IDS_WRN_KEYNAMETOOLONG),
_SYMENTRY(IDS_LOG_QUERYCHANGESELSTATE),
_SYMENTRY(IDS_PATH_TOO_LONG_DIRECTORY),
_SYMENTRY(IDS_LOG_BAD_CATYPE),
_SYMENTRY(IDS_LOG_BAD_OR_MISSING_CANAME),
_SYMENTRY(IDS_LOG_BAD_VALIDITY_PERIOD_STRING),
_SYMENTRY(IDS_LOG_CA_MACHINE_REQUIRED),
_SYMENTRY(IDS_LOG_CA_NAME_REQUIRED),
_SYMENTRY(IDS_LOG_PING_PARENT_FAIL),
_SYMENTRY(IDS_LOG_EMPTY_UNATTENDED_ATTRIBUTE),
_SYMENTRY(IDS_LOG_PATH_CAFILE_BUILD_FAIL),
_SYMENTRY(IDS_LOG_ENTERPRISE_NO_DS),
_SYMENTRY(IDS_LOG_BAD_COUNTRY_LENGTH),
_SYMENTRY(IDS_LOG_NO_CERT),
_SYMENTRY(IDS_LOG_REUSE_CERT_NO_REUSE_KEY),
_SYMENTRY(IDS_LOG_REUSE_DB_WITHOUT_REUSE_CERT),
_SYMENTRY(IDS_LOG_BAD_VALIDITY_PERIOD_COUNT),
_SYMENTRY(IDS_LOG_REQUEST_FILE_TOO_LONG),
_SYMENTRY(IDS_LOG_CANAME_TOO_LONG),
_SYMENTRY(IDS_LOG_PATH_TOO_LONG_CANAME),
_SYMENTRY(IDS_LOG_BAD_COUNTRY_CODE),
_SYMENTRY(IDS_LOG_KEY_NOT_FOUND_IN_LIST),
_SYMENTRY(IDS_LOG_DISABLE_WIZ_PAGE),
_SYMENTRY(IDS_LOG_WIZ_PAGE_ERROR),
_SYMENTRY(IDS_LOG_UPGRADE_UNSUPPORTED),
_SYMENTRY(IDS_LOG_UPGRADE_WIN2000),
_SYMENTRY(IDS_LOG_UPGRADE_B2B),
_SYMENTRY(IDS_LARGEFONTSIZE),
_SYMENTRY(IDS_LARGEFONTNAME),
_SYMENTRY(IDS_ILOG_SANITIZEDNAME),
_SYMENTRY(IDS_ILOG_KEYCONTAINERNAME),
_SYMENTRY(IDS_WRN_CANNOT_ADD_CA_TO_CERTPUBLISHERS),
_SYMENTRY(IDS_WRN_CANNOT_ADD_CA_TO_PREWIN2K),
_SYMENTRY(IDS_WRN_ASP_NOT_ENABLED),
_SYMENTRY(IDS_WRN_IIS_NOT_INSTALLED),
_SYMENTRY(IDS_WRN_OLD_DS_VERSION),
_SYMENTRY(IDS_ENTERPRISE_UNAVAIL_REASON),
_SYMENTRY(IDS_HELP_EXECUTE),
_SYMENTRY(IDS_SHARE_VERIFY_ERROR),
_SYMENTRY(IDS_LOG_SHARE_DISP),
_SYMENTRY(IDS_LOG_VROOT_DISP),
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certreqd\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDI_APP                         		201

//#define IDS_DUMP_DESCRIPTION				301
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certlog\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDI_APP                         		201

//#define IDS_UNUSED					301
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\admin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       admin.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <setupapi.h>
#include <ocmanage.h>
#include "initcert.h"
#include "cscsp.h"

#define __dwFILE__	__dwFILE_CERTUTIL_ADMIN_CPP__

#define wszV1SUFFIX	L"-v1"
#define wszP12SUFFIX	L".p12"
#define wszRECSUFFIX	L".rec"
#define wszEPFSUFFIX	L".epf"


HRESULT
verbDenyRequest(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRequestId,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    LONG RequestId;
    BOOL fMustRelease = FALSE;

    hr = myGetLong(pwszRequestId, &RequestId);
    _JumpIfError(hr, error, "RequestId must be a number");

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    hr = Admin_DenyRequest(&diAdmin, g_pwszConfig, RequestId);
    _JumpIfError(hr, error, "Admin_DenyRequest");

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    return(hr);
}


WCHAR const *
wszFromSubmitDisposition(
    LONG Disposition)
{
    DWORD idMsg;

    switch (Disposition)
    {
	case CR_DISP_INCOMPLETE: idMsg = IDS_CR_DISP_INCOMPLETE; break;
	case CR_DISP_ERROR:      idMsg = IDS_CR_DISP_ERROR;      break;
	case CR_DISP_DENIED:     idMsg = IDS_CR_DISP_DENIED;     break;
	case CR_DISP_ISSUED:     idMsg = IDS_CR_DISP_ISSUED;     break;
	case CR_DISP_ISSUED_OUT_OF_BAND:
				 idMsg = IDS_CR_DISP_ISSUED_OUT_OF_BAND; break;
	case CR_DISP_UNDER_SUBMISSION:
				 idMsg = IDS_CR_DISP_UNDER_SUBMISSION; break;
	case CR_DISP_REVOKED:    idMsg = IDS_CR_DISP_REVOKED;    break;
	    
	default:                 idMsg = IDS_UNKNOWN;            break;
    }
    return(myLoadResourceString(idMsg));
}


HRESULT
verbResubmitRequest(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRequestId,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    LONG RequestId;
    LONG Disposition;
    BOOL fMustRelease = FALSE;

    hr = myGetLong(pwszRequestId, &RequestId);
    _JumpIfError(hr, error, "RequestId must be a number");

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    hr = Admin_ResubmitRequest(&diAdmin, g_pwszConfig, RequestId, &Disposition);
    _JumpIfError(hr, error, "Admin_ResubmitRequest");

    if (CR_DISP_UNDER_SUBMISSION == Disposition)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_PENDING_REQUESTID), // "Certificate request is pending: RequestId: %u"
	    RequestId);
	wprintf(wszNewLine);
    }
    else if (CR_DISP_ISSUED == Disposition)
    {
	wprintf(myLoadResourceString(IDS_CERT_ISSUED)); // "Certificate issued."
	wprintf(wszNewLine);
    }
    else
    {
	if (FAILED(Disposition))
	{
	    hr = Disposition;
	    Disposition = CR_DISP_DENIED;
	}
	wprintf(
	    myLoadResourceString(IDS_CERT_NOT_ISSUED_DISPOSITION), // "Certificate has not been issued: Disposition: %d -- %ws"
	    Disposition,
	    wszFromSubmitDisposition(Disposition));
	wprintf(wszNewLine);
	if (S_OK != hr)
	{
	    WCHAR const *pwszMessage;

	    pwszMessage = myGetErrorMessageText(hr, FALSE);
	    if (NULL != pwszMessage)
	    {
		wprintf(L"%ws\n", pwszMessage);
		LocalFree(const_cast<WCHAR *>(pwszMessage));
	    }
	}
    }

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    return(hr);
}


typedef struct _cuCRLREASON
{
    WCHAR *pwszReason;
    LONG   lReason;
    int    idReason;
} cuCRLREASON;

#define cuREASON(r, id)		{ L#r, (r), (id) }

cuCRLREASON g_cuReason[] =
{
  cuREASON(CRL_REASON_UNSPECIFIED,	IDS_CRL_REASON_UNSPECIFIED),
  cuREASON(CRL_REASON_KEY_COMPROMISE,	IDS_CRL_REASON_KEY_COMPROMISE),
  cuREASON(CRL_REASON_CA_COMPROMISE,	IDS_CRL_REASON_CA_COMPROMISE),
  cuREASON(CRL_REASON_AFFILIATION_CHANGED, IDS_CRL_REASON_AFFILIATION_CHANGED),
  cuREASON(CRL_REASON_SUPERSEDED,	IDS_CRL_REASON_SUPERSEDED),
  cuREASON(CRL_REASON_CESSATION_OF_OPERATION,
					IDS_CRL_REASON_CESSATION_OF_OPERATION),
  cuREASON(CRL_REASON_CERTIFICATE_HOLD, IDS_CRL_REASON_CERTIFICATE_HOLD),
  cuREASON(CRL_REASON_REMOVE_FROM_CRL,	IDS_CRL_REASON_REMOVE_FROM_CRL),
  { L"Unrevoke", MAXDWORD,		IDS_CRL_REASON_UNREVOKE },
  { NULL,	 MAXDWORD,		IDS_CRL_REASON_UNRECOGNIZED },
};

#define wszCRLPREFIX	L"CRL_REASON_"

HRESULT
cuParseReason(
    IN WCHAR const *pwszReason,
    OUT LONG *plReason)
{
    HRESULT hr;
    
    hr = myGetSignedLong(pwszReason, plReason);
    if (S_OK != hr)
    {
	cuCRLREASON const *pr;
	
	for (pr = g_cuReason; ; pr++)
	{
	    if (NULL == pr->pwszReason)
	    {
		hr = E_INVALIDARG;
		_JumpIfError(hr, error, "Invalid Reason string");
	    }
	    if (0 == mylstrcmpiS(pr->pwszReason, pwszReason))
	    {
		break;
	    }
	    if (wcslen(pr->pwszReason) > WSZARRAYSIZE(wszCRLPREFIX) &&
		0 == memcmp(
			pr->pwszReason,
			wszCRLPREFIX,
			WSZARRAYSIZE(wszCRLPREFIX) * sizeof(WCHAR)) &&
		0 == LSTRCMPIS(
			    pwszReason,
			    &pr->pwszReason[WSZARRAYSIZE(wszCRLPREFIX)]))
	    {
		break;
	    }
	}
	*plReason = pr->lReason;
	hr = S_OK;
    }
    CSASSERT(S_OK == hr);

error:
    return(hr);
}


int
cuidCRLReason(
    IN LONG Reason)
{
    cuCRLREASON const *pr;
    
    for (pr = g_cuReason; NULL != pr->pwszReason; pr++)
    {
	if (pr->lReason == Reason)
	{
	    break;
	}
    }
    return(pr->idReason);
}


WCHAR const *
wszCRLReason(
    IN LONG Reason)
{
    return(myLoadResourceString(cuidCRLReason(Reason)));
}


HRESULT
verbRevokeCertificate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszSerialNumberList,
    IN WCHAR const *pwszReason,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hr2;
    DISPATCHINTERFACE diAdmin;
    WCHAR **ppwszSerialList = NULL;
    BSTR strSerialNumber = NULL;
    LONG Reason = CRL_REASON_UNSPECIFIED;
    SYSTEMTIME st;
    FILETIME ft;
    DATE Date;
    BOOL fMustRelease = FALSE;

    GetSystemTime(&st);
    if (!SystemTimeToFileTime(&st, &ft))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "SystemTimeToFileTime");
    }
    hr = myFileTimeToDate(&ft, &Date);
    _JumpIfError(hr, error, "myFileTimeToDate");

    //Date -= 1.0;		// Revoke effective yesterday

    if (NULL != pwszReason)
    {
	hr = cuParseReason(pwszReason, &Reason);
	_JumpIfError(hr, error, "Invalid Reason");
    }

    hr = cuParseStrings(
		pwszSerialNumberList,
		FALSE,
		NULL,
		NULL,
		&ppwszSerialList,
		NULL);
    _JumpIfError(hr, error, "cuParseStrings");

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    if (NULL != ppwszSerialList)
    {
	DWORD i;

	for (i = 0; NULL != ppwszSerialList[i]; i++)
	{
	    hr2 = myMakeSerialBstr(ppwszSerialList[i], &strSerialNumber);
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	    _JumpIfError(hr2, error, "myMakeSerialBstr");

	    wprintf(myLoadResourceString(IDS_REVOKING), strSerialNumber); // "Revoking "%ws""
	    wprintf(L" -- %ws", wszCRLReason(Reason));	// "Reason: xxxx"
	    wprintf(wszNewLine);

	    hr2 = Admin_RevokeCertificate(
				&diAdmin,
				g_pwszConfig,
				strSerialNumber,
				Reason,
				Date);
	    if (S_OK != hr2)
	    {
		cuPrintAPIError(L"ICertAdmin::RevokeCertificate", hr2);
		_PrintError(hr2, "Admin_RevokeCertificate");
		if (S_OK == hr)
		{
		    hr = hr2;
		}
	    }
	    SysFreeString(strSerialNumber);
	    strSerialNumber = NULL;
	}
    }
    _JumpIfError(hr, error, "Admin_RevokeCertificate");

error:
    cuFreeStringArray(ppwszSerialList);
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


HRESULT
cuParseDaysHours(
    IN WCHAR const *pwszDaysHours,
    OUT FILETIME *pft)
{
    HRESULT hr;
    WCHAR *pwszDays = NULL;
    WCHAR *pwszHours;
    DWORD dwDays;
    DWORD dwHours;
    BOOL fValid;
    LONGLONG delta;

    hr = myDupString(pwszDaysHours, &pwszDays);
    _JumpIfError(hr, error, "myDupString");

    hr = E_INVALIDARG;
    pwszHours = wcschr(pwszDays, L':');
    if (NULL == pwszHours)
    {
	_JumpError(hr, error, "missing colon");
    }
    *pwszHours++ = L'\0';
    dwDays = myWtoI(pwszDays, &fValid);
    if (!fValid)
    {
	_JumpError(hr, error, "bad day count");
    }
    dwHours = myWtoI(pwszHours, &fValid);
    if (!fValid)
    {
	_JumpError(hr, error, "bad hour count");
    }
    if (0 == dwDays && 0 == dwHours)
    {
	_JumpError(hr, error, "zero day+hour counts");
    }
    GetSystemTimeAsFileTime(pft);

    // add specified days and hours to compute expiration date

    delta = dwDays * CVT_DAYS;
    delta += dwHours * CVT_HOURS;
    myAddToFileTime(pft, delta * CVT_BASE);
    hr = S_OK;

error:
    if (NULL != pwszDays)
    {
	LocalFree(pwszDays);
    }
    return(hr);
}


HRESULT
verbPublishCRL(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszDaysHours,
    OPTIONAL IN WCHAR const *pwszDelta,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    BOOL fMustRelease = FALSE;
    DATE Date;
    DWORD Flags = 0;

    if (NULL != pwszDaysHours && 0 == LSTRCMPIS(pwszDaysHours, L"delta"))
    {
	WCHAR const *pwsz = pwszDaysHours;

	pwszDaysHours = pwszDelta;
	pwszDelta = pwsz;
    }
    Date = 0.0;
    if (NULL != pwszDaysHours)
    {
	if (0 == LSTRCMPIS(pwszDaysHours, L"republish"))
	{
	    Flags |= CA_CRL_REPUBLISH;
	}
	else
	{
	    FILETIME ft;
	    
	    hr = cuParseDaysHours(pwszDaysHours, &ft);
	    _JumpIfError(hr, error, "cuParseDaysHours");

	    hr = myFileTimeToDate(&ft, &Date);
	    _JumpIfError(hr, error, "myFileTimeToDate");
	}
    }
    if (NULL != pwszDelta)
    {
	if (0 != LSTRCMPIS(pwszDelta, L"delta"))
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad delta arg");
	}
	Flags |= CA_CRL_DELTA;
    }
    if (0 == (CA_CRL_DELTA & Flags))
    {
	Flags |= CA_CRL_BASE;
    }

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    if ((CA_CRL_DELTA | CA_CRL_REPUBLISH) & Flags)
    {
	hr = Admin2_PublishCRLs(&diAdmin, g_pwszConfig, Date, Flags);
	_JumpIfError(hr, error, "Admin2_PublishCRLs");
    }
    else
    {
	BOOL fV1 = g_fV1Interface;

	if (!fV1)
	{
	    hr = Admin2_PublishCRLs(&diAdmin, g_pwszConfig, Date, Flags);
	    if (E_NOTIMPL != hr && RPC_E_VERSION_MISMATCH != hr)
	    {
		_JumpIfError(hr, error, "Admin2_PublishCRLs");
	    }
	    else
	    {
		_PrintError(hr, "Admin2_PublishCRLs down level server");
		fV1 = TRUE;
	    }
	}
	if (fV1)
	{
	    hr = Admin_PublishCRL(&diAdmin, g_pwszConfig, Date);
	    _JumpIfError(hr, error, "Admin_PublishCRL");
	}
    }

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    return(hr);
}


HRESULT
verbGetCRL(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszDelta,
    OPTIONAL IN WCHAR const *pwszIndex,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    BOOL fMustRelease = FALSE;
    BOOL fDelta = FALSE;
    DWORD Index = MAXDWORD;	// default to latest CRL
    BSTR strCRL = NULL;

    if (NULL != pwszDelta && 0 != LSTRCMPIS(pwszDelta, L"delta"))
    {
	WCHAR const *pwsz = pwszIndex;

	pwszIndex = pwszDelta;
	pwszDelta = pwsz;
    }
    if (NULL != pwszDelta && 0 == LSTRCMPIS(pwszDelta, L"delta"))
    {
	fDelta = TRUE;
    }
    if (NULL != pwszIndex)
    {
	hr = myGetSignedLong(pwszIndex, (LONG *) &Index);
	_JumpIfErrorStr(hr, error, "Cert index not a number", pwszIndex);
    }
    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    if (fDelta)
    {
	hr = Admin2_GetCAProperty(
			    &diAdmin,
			    g_pwszConfig,
			    CR_PROP_DELTACRL,
			    Index,
			    PROPTYPE_BINARY,
			    CR_OUT_BINARY,
			    &strCRL);
	_JumpIfError(hr, error, "Admin2_GetCAProperty");
    }
    else
    {
	BOOL fV1 = g_fV1Interface;

	if (!fV1)
	{
	    hr = Admin2_GetCAProperty(
				&diAdmin,
				g_pwszConfig,
				CR_PROP_BASECRL,
				Index,
				PROPTYPE_BINARY,
				CR_OUT_BINARY,
				&strCRL);

	    if (E_NOTIMPL != hr && RPC_E_VERSION_MISMATCH != hr)
	    {
		_JumpIfError(hr, error, "Admin2_GetCAProperty");
	    }
	    else
	    {
		_PrintError(hr, "Admin2_CAProperty down level server");
		fV1 = TRUE;
	    }
	}
	if (fV1)
	{
	    if (NULL != pwszIndex)
	    {
		hr = cuGetCAInfo(
			    pwszOption,
			    pwszfnOut,
			    g_wszCAInfoCRL,
			    pwszIndex);
		_JumpIfError(hr, error, "cuGetCAInfo");
	    }
	    else
	    {
		hr = Admin_GetCRL(
			    &diAdmin,
			    g_pwszConfig,
			    CR_OUT_BINARY,
			    &strCRL);
		_JumpIfError(hr, error, "Admin_GetCRL");
	    }
	}
    }

    // if not already saved by cuGetCAInfo

    if (NULL != strCRL)
    {
	hr = EncodeToFileW(
		    pwszfnOut,
		    (BYTE const *) strCRL,
		    SysStringByteLen(strCRL),
		    CRYPT_STRING_BINARY | g_EncodeFlags);
	_JumpIfError(hr, error, "EncodeToFileW");
    }

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != strCRL)
    {
	SysFreeString(strCRL);
    }
    return(hr);
}


HRESULT
BuildDummyCert(
    IN CERT_CONTEXT const *pCert,
    IN WCHAR const *pwszSerialNumber,
    IN CHAR const *pszObjId,
    OUT BYTE **ppbCert,
    OUT DWORD *pcbCert)
{
    HRESULT hr;
    CERT_INFO CertInfoOut;
    CERT_INFO const *pCertInfo;
    BYTE *pbUnsigned = NULL;
    DWORD cbUnsigned;
    CERT_CONTEXT CertContext;
    WCHAR *pwszContainer = NULL;
    HCRYPTPROV hProv = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cbPubKey;
    CERT_EXTENSION extSKI = {szOID_SUBJECT_KEY_IDENTIFIER, FALSE, 0, NULL};
    CERT_EXTENSION extAKI = {szOID_AUTHORITY_KEY_IDENTIFIER2, FALSE, 0, NULL};
    CERT_EXTENSION aExt[2];
    CERT_EXTENSION *pExt;
    CRYPT_DATA_BLOB *pBlob = NULL;
    DWORD cb;

    *ppbCert = NULL;
    
    ZeroMemory(&CertInfoOut, sizeof(CertInfoOut));
    pCertInfo = pCert->pCertInfo;
    CertInfoOut.Issuer = pCertInfo->Issuer;
    CertInfoOut.NotBefore = pCertInfo->NotBefore;
    CertInfoOut.NotAfter = pCertInfo->NotAfter;

    CertInfoOut.SignatureAlgorithm.pszObjId = const_cast<CHAR *>(pszObjId);
    hr = WszToMultiByteInteger(
			    FALSE,
			    pwszSerialNumber,
			    &CertInfoOut.SerialNumber.cbData,
			    &CertInfoOut.SerialNumber.pbData);
    _JumpIfError(hr, error, "WszToMultiByteInteger");

    hr = myCertStrToName(
		    X509_ASN_ENCODING,
		    L"CN=Dummy",		// pszX500
		    CERT_NAME_STR_REVERSE_FLAG,
		    NULL,			// pvReserved
		    &CertInfoOut.Subject.pbData,
		    &CertInfoOut.Subject.cbData,
		    NULL);			// ppszError
    _JumpIfError(hr, error, "myCertStrToName");

    ZeroMemory(&CertContext, sizeof(CertContext));
    CertContext.dwCertEncodingType = X509_ASN_ENCODING;
    CertContext.pCertInfo = &CertInfoOut;

    hr = cuGenerateKeyContainerName(&CertContext, &pwszContainer);
    _JumpIfError(hr, error, "cuGenerateKeyContainerName");

    hr = myGenerateKeys(
		pwszContainer,
		NULL,		// pwszProvName
		0,		// dwFlags
		FALSE,		// fMachineKeySet
		AT_SIGNATURE,
		PROV_RSA_FULL,
		0,		// dwKeySize (use default)
		&hProv);
    _JumpIfError(hr, error, "myGenerateKeys");

    if (!myCryptExportPublicKeyInfo(
				hProv,
				AT_SIGNATURE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKey,
				&cbPubKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }
    CertInfoOut.SubjectPublicKeyInfo = *pPubKey; // Structure assignment

    // Subject Key Identifier extension:

    hr = myCreateSubjectKeyIdentifierExtension(
				    pPubKey,
				    &extSKI.Value.pbData,
				    &extSKI.Value.cbData);
    _JumpIfError(hr, error, "myCreateSubjectKeyIdentifierExtension");

    CertInfoOut.rgExtension = aExt;
    aExt[CertInfoOut.cExtension] = extSKI;
    CertInfoOut.cExtension++;

    //AKI extension?

    pExt = CertFindExtension(
			szOID_SUBJECT_KEY_IDENTIFIER,
			pCertInfo->cExtension,
			pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	CERT_AUTHORITY_KEY_ID2_INFO AKI;

	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			pExt->Value.pbData,
			pExt->Value.cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pBlob,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}
	ZeroMemory(&AKI, sizeof(AKI));
	AKI.KeyId = *pBlob;

	if (!myEncodeKeyAuthority2(
			    X509_ASN_ENCODING,
			    &AKI,
			    CERTLIB_USE_LOCALALLOC,
			    &extAKI.Value.pbData,
			    &extAKI.Value.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeKeyAuthority2");
	}

	aExt[CertInfoOut.cExtension] = extAKI;
	CertInfoOut.cExtension++;
    }

    CertInfoOut.dwVersion = CERT_V3;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_TO_BE_SIGNED,
		    &CertInfoOut,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbUnsigned,               // pbEncoded
		    &cbUnsigned))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    *ppbCert = pbUnsigned;
    pbUnsigned = NULL;
    *pcbCert = cbUnsigned;
    hr = S_OK;

error:
    if (NULL != pbUnsigned)
    {
	LocalFree(pbUnsigned);
    }
    if (NULL != pBlob)
    {
	LocalFree(pBlob);
    }
    if (NULL != extSKI.Value.pbData)
    {
	LocalFree(extSKI.Value.pbData);
    }
    if (NULL != extAKI.Value.pbData)
    {
	LocalFree(extAKI.Value.pbData);
    }
    if (NULL != CertInfoOut.SerialNumber.pbData)
    {
	LocalFree(CertInfoOut.SerialNumber.pbData);
    }
    if (NULL != CertInfoOut.Subject.pbData)
    {
	LocalFree(CertInfoOut.Subject.pbData);
    }
    if (NULL != pPubKey)
    {
        LocalFree(pPubKey);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
	if (NULL != pwszContainer)
	{
	    CryptAcquireContext(
			    &hProv,
			    pwszContainer,
			    NULL,	// pwszProvName
			    PROV_RSA_FULL,
			    CRYPT_DELETEKEYSET);
	}
    }
    if (NULL != pwszContainer)
    {
	LocalFree(pwszContainer);
    }
    return(hr);
}


HRESULT
FindCertAndSign(
    OPTIONAL IN CERT_EXTENSION const *pExtKeyId,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OPTIONAL IN BYTE const *pbUnsigned,
    IN DWORD cbUnsigned,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CERT_AUTHORITY_KEY_ID2_INFO *pKeyId = NULL;
    DWORD cbKeyId;
    BSTR strKeyId = NULL;
    CERT_CONTEXT const *pCert = NULL;
    HCRYPTPROV hProv = NULL;
    DWORD dwKeySpec;
    BOOL fCallerFreeProv;
    CHAR *pszObjId = NULL;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    
    *ppbOut = NULL;
    CSASSERT(NULL != pbUnsigned || NULL != pwszSerialNumber);
    if (NULL == pbHash && NULL != pExtKeyId)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_AUTHORITY_KEY_ID2,
			pExtKeyId->Value.pbData,
			pExtKeyId->Value.cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pKeyId,
			&cbKeyId))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}
	pbHash = pKeyId->KeyId.pbData;
	cbHash = pKeyId->KeyId.cbData;
    }
    if (0 != cbHash && NULL != pbHash)
    {
	hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strKeyId);
	_JumpIfError(hr, error, "MultiByteIntegerToBstr");
    }

    // Find CA cert by KeyId from the szOID_AUTHORITY_KEY_IDENTIFIER2 extension.
    // Look in HKLM and HKCU My and CA stores.

    hr = myGetCertificateFromPicker(
			    g_hInstance,
			    NULL,		// hwndParent
			    IDS_GETCERT_TITLE,
			    IDS_GETCERT_SUBTITLE,

			    // dwFlags: HKLM+HKCU My store
			    CUCS_MYSTORE |
				CUCS_MACHINESTORE |
				CUCS_USERSTORE |
				CUCS_PRIVATEKEYREQUIRED |
				CUCS_ARCHIVED |
				(g_fCryptSilent? CUCS_SILENT : 0),
			    strKeyId,
			    0,
			    NULL,
			    0,		// cpszObjId
			    NULL,	// apszObjId
			    &pCert);
    _JumpIfError(hr, error, "myGetCertificateFromPicker");

    if (NULL == pCert)
    {
	hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	_JumpError(hr, error, "no cert");
    }

    hr = cuDisplayCertName(
		    TRUE,
		    NULL,
		    myLoadResourceString(IDS_SIGNINGSUBJECT), // "Signing certificate Subject"
		    g_wszPad4,
		    &pCert->pCertInfo->Subject,
		    pCert->pCertInfo);
    _JumpIfError(hr, error, "cuDisplayCertName(Subject)");

    // Search for and load the cryptographic provider and private key. 

    hr = myLoadPrivateKey(
		    &pCert->pCertInfo->SubjectPublicKeyInfo,
		    CUCS_MACHINESTORE | CUCS_USERSTORE | CUCS_MYSTORE | CUCS_ARCHIVED,
		    &hProv,
		    &dwKeySpec,
		    &fCallerFreeProv);
    _JumpIfError(hr, error, "myLoadPrivateKey");

    if (AT_SIGNATURE != dwKeySpec)
    {
	hr = NTE_BAD_KEY_STATE;
	DBGPRINT((DBG_SS_CERTUTIL, "dwKeySpec = %u\n", dwKeySpec));
	_JumpError(hr, error, "dwKeySpec");
    }

    // The CA cert's private key is available -- use it to sign the data.
    // Sign the Cert or CRL and encode the signed info.

    hr = myGetSigningOID(hProv, NULL, 0, CALG_SHA1, &pszObjId);
    _JumpIfError(hr, error, "myGetSigningOID");

    if (NULL != pwszSerialNumber)
    {
	hr = BuildDummyCert(
			pCert,
			pwszSerialNumber,
			pszObjId,
			&pbCert,
			&cbCert);
	_JumpIfError(hr, error, "BuildDummyCert");

	pbUnsigned = pbCert;
	cbUnsigned = cbCert;
    }

    hr = myEncodeSignedContent(
			hProv,
			X509_ASN_ENCODING,
			pszObjId,
			const_cast<BYTE *>(pbUnsigned),
			cbUnsigned,
			CERTLIB_USE_LOCALALLOC,
			ppbOut,
			pcbOut);
    _JumpIfError(hr, error, "myEncodeSignedContent");

error:
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    if (NULL != pKeyId)
    {
	LocalFree(pKeyId);
    }
    if (NULL != strKeyId)
    {
	SysFreeString(strKeyId);
    }
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    if (NULL != hProv && fCallerFreeProv) 
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


VOID
SetExpiration(
    OPTIONAL IN FILETIME const *pftNotAfterNew,
    IN OUT FILETIME *pftNotBefore,
    OPTIONAL IN OUT FILETIME *pftNotAfter)
{
    if (NULL == pftNotAfterNew ||
	0 != pftNotAfterNew->dwLowDateTime ||
	0 != pftNotAfterNew->dwHighDateTime)
    {
	LLFILETIME llftNotBefore;
	LLFILETIME llft;
	LLFILETIME llftDelta;

	llftNotBefore.ft = *pftNotBefore;	// Save orignal value

	// current time - clock skew

	GetSystemTimeAsFileTime(&llft.ft);
	llftDelta.ll = CCLOCKSKEWMINUTESDEFAULT * CVT_MINUTES;
	llftDelta.ll *= CVT_BASE;
	llft.ll -= llftDelta.ll;

	// NotBeforeOut = oldest of NotBefore, (CurrentTime - skew)

	if (llftNotBefore.ll > llft.ll)
	{
	    *pftNotBefore = llft.ft;
	}
	if (NULL != pftNotAfter)
	{
	    LLFILETIME llftNotAfter;

	    llftNotAfter.ft = *pftNotAfter;	// Save orignal value
	    if (NULL != pftNotAfterNew)
	    {
		*pftNotAfter = *pftNotAfterNew;
	    }
	    else
	    {
		// NotAfterOut = (CurrentTime - skew) + (NotAfter - NotBefore);

		llft.ll += llftNotAfter.ll;
		llft.ll -= llftNotBefore.ll;
		*pftNotAfter = llft.ft;
	    }
	}
    }
}


HRESULT
RemoveExtensions(
    IN WCHAR const * const *ppwszObjIdList,
    IN BOOL fValidate,
    IN DWORD cExtensionIn,
    IN CERT_EXTENSION *rgExtensionIn,
    OUT DWORD *pcExtensionOut,
    OUT CERT_EXTENSION **prgExtensionOut)
{
    HRESULT hr;
    DWORD cExtension = cExtensionIn;
    CERT_EXTENSION *rgExtension = NULL;

    *prgExtensionOut = NULL;
    rgExtension = (CERT_EXTENSION *) LocalAlloc(
					LMEM_FIXED, 
					cExtension * sizeof(rgExtension[0]));
    if (NULL == rgExtension)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(
	    rgExtension,
	    rgExtensionIn,
	    cExtension * sizeof(rgExtension[0]));

    if (NULL != ppwszObjIdList)
    {
	DWORD i;

	for (i = 0; NULL != ppwszObjIdList[i]; i++)
	{
	    WCHAR const *pwszObjId = ppwszObjIdList[i];
	    char *pszObjId;
	    CERT_EXTENSION *pExt;
	    
	    hr = myVerifyObjId(pwszObjId);
	    if (S_OK != hr)
	    {
		if (fValidate)
		{
		    _JumpError(hr, error, "myVerifyObjId");
		}
		continue;
	    }

	    if (!myConvertWszToSz(&pszObjId, pwszObjId, -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "myConvertWszToSz");
	    }
	    pExt = CertFindExtension(pszObjId, cExtension, rgExtension);
	    if (NULL != pExt)
	    {
		DWORD iDel = SAFE_SUBTRACT_POINTERS(pExt, rgExtension);

		// wprintf(L"iDel=%u cExt=%u\n", iDel, cExtension);
		if (iDel < cExtension)
		{
		    // wprintf(L"copy %u to %u, len=%u\n", iDel + 1, iDel, cExtension - iDel - 1);
		    MoveMemory(
			&rgExtension[iDel], 
			&rgExtension[iDel + 1], 
			(cExtension - iDel - 1) * sizeof(rgExtension[iDel]));
		}
		cExtension--;
	    }
	    LocalFree(pszObjId);
	}
    }
    *pcExtensionOut = cExtension;
    *prgExtensionOut = rgExtension;
    rgExtension = NULL;
    hr = S_OK;

error:
    if (NULL != rgExtension)
    {
	LocalFree(rgExtension);
    }
    return(hr);
}


CRL_ENTRY *
FindCRLEntry(
    IN DWORD cbSerial,
    IN BYTE const *pbSerial,
    IN DWORD cCRLEntry,
    IN CRL_ENTRY *rgCRLEntry)
{
    CRL_ENTRY *pCRLEntry = NULL;
    CRL_ENTRY *rgCRLEntryEnd = &rgCRLEntry[cCRLEntry];

    for ( ; rgCRLEntry < rgCRLEntryEnd; rgCRLEntry++)
    {
	if (cbSerial == rgCRLEntry->SerialNumber.cbData &&
	    0 == memcmp(pbSerial, rgCRLEntry->SerialNumber.pbData, cbSerial))
	{
	    pCRLEntry = rgCRLEntry;
	    break;
	}
    }
    return(pCRLEntry);
}


HRESULT
AddRemoveSerial(
    IN WCHAR const * const *ppwszSerialList,
    IN BOOL fAdd,
    IN DWORD cCRLEntryIn,
    IN CRL_ENTRY *rgCRLEntryIn,
    OUT DWORD *pcCRLEntryOut,
    OUT CRL_ENTRY **prgCRLEntryOut,
    OUT DWORD *pcSerialNew,
    OUT BYTE ***prgpbSerialNew)
{
    HRESULT hr;
    DWORD cCRLEntry = cCRLEntryIn;
    CRL_ENTRY *rgCRLEntry = NULL;
    DWORD cAdd;
    BYTE **rgpbSerialNew = NULL;
    DWORD cSerialNew;
    FILETIME ftCurrent;

    *prgCRLEntryOut = NULL;
    *prgpbSerialNew = NULL;
    cAdd = 0;
    if (fAdd)
    {
	for (cAdd = 0; NULL != ppwszSerialList[cAdd]; cAdd++)
	    ;
	cSerialNew = 0;
	rgpbSerialNew = (BYTE **) LocalAlloc(
					LMEM_FIXED,
					cAdd * sizeof(rgpbSerialNew[0]));
	if (NULL == rgpbSerialNew)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	GetSystemTimeAsFileTime(&ftCurrent);
    }

    rgCRLEntry = (CRL_ENTRY *) LocalAlloc(
				LMEM_FIXED, 
				(cCRLEntry + cAdd) * sizeof(rgCRLEntry[0]));
    if (NULL == rgCRLEntry)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(
	    rgCRLEntry,
	    rgCRLEntryIn,
	    cCRLEntry * sizeof(rgCRLEntry[0]));

    if (NULL != ppwszSerialList)
    {
	DWORD i;

	for (i = 0; NULL != ppwszSerialList[i]; i++)
	{
	    WCHAR const *pwszSerial = ppwszSerialList[i];
	    CRL_ENTRY *pCRLEntry;
	    DWORD cbSerial;
	    BYTE *pbSerial;
	    
	    hr = myVerifyObjId(pwszSerial);
	    if (S_OK == hr)
	    {
		continue;	// skip OIDs
	    }
	    hr = WszToMultiByteInteger(
				FALSE,
				pwszSerial,
				&cbSerial,
				&pbSerial);
	    _JumpIfErrorStr(hr, error, "WszToMultiByteInteger", pwszSerial);

	    pCRLEntry = FindCRLEntry(
				cbSerial,
				pbSerial,
				cCRLEntry,
				rgCRLEntry);
	    if (fAdd)
	    {
		if (NULL == pCRLEntry)
		{
		    pCRLEntry = &rgCRLEntry[cCRLEntry];
		    ZeroMemory(pCRLEntry, sizeof(*pCRLEntry));
		    pCRLEntry->SerialNumber.pbData = pbSerial;
		    pCRLEntry->SerialNumber.cbData = cbSerial;
		    pCRLEntry->RevocationDate = ftCurrent;

		    cCRLEntry++;
		    rgpbSerialNew[cSerialNew++] = pbSerial;
		    pbSerial = NULL;
		}
	    }
	    else
	    {
		if (NULL != pCRLEntry)
		{
		    DWORD iDel = SAFE_SUBTRACT_POINTERS(pCRLEntry, rgCRLEntry);

		    if (iDel < cCRLEntry)
		    {
			MoveMemory(
			    &rgCRLEntry[iDel], 
			    &rgCRLEntry[iDel + 1], 
			    (cCRLEntry - iDel - 1) * sizeof(rgCRLEntry[iDel]));
		    }
		    cCRLEntry--;
		}
	    }
	    if (NULL != pbSerial)
	    {
		LocalFree(pbSerial);
	    }
	}
    }
    *pcCRLEntryOut = cCRLEntry;
    *prgCRLEntryOut = rgCRLEntry;
    rgCRLEntry = NULL;
    *pcSerialNew = cSerialNew;
    *prgpbSerialNew = rgpbSerialNew;
    rgpbSerialNew = NULL;
    hr = S_OK;

error:
    if (NULL != rgCRLEntry)
    {
	LocalFree(rgCRLEntry);
    }
    if (NULL != rgpbSerialNew)
    {
	DWORD i;

	for (i = 0; i < cSerialNew; i++)
	{
	    if (NULL != rgpbSerialNew[i])
	    {
		LocalFree(rgpbSerialNew[i]);
	    }
	}
	LocalFree(rgpbSerialNew);
    }
    return(hr);
}


HRESULT
SignCRL(
    IN CRL_CONTEXT const *pCRLContext,
    OPTIONAL IN FILETIME const *pftNextUpdate,
    IN BOOL fAdd,
    IN WCHAR const * const *ppwszSerialList,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CRL_INFO const *pCRLInfo;
    CRL_INFO CRLInfoOut;
    BYTE *pbUnsigned = NULL;
    DWORD cbUnsigned;
    CERT_EXTENSION *pExtKeyId;
    CERT_EXTENSION *rgExtension = NULL;
    CRL_ENTRY *rgCRLEntry = NULL;
    DWORD cSerialNew;
    BYTE **rgpbSerialNew = NULL;

    ZeroMemory(&CRLInfoOut, sizeof(CRLInfoOut));

    *ppbOut = NULL;

    // CRL extensions to strip out of the re-signed CRL:

    static WCHAR const * const apwszObjIdFilter[] = {
	TEXT(szOID_CRL_NEXT_PUBLISH),
	NULL
    };
    static WCHAR const * const apwszObjIdFilterNull[] = {
	NULL
    };

    pCRLInfo = pCRLContext->pCrlInfo;
    CRLInfoOut = *pCRLInfo;

    SetExpiration(
	    pftNextUpdate,
	    &CRLInfoOut.ThisUpdate,
	    (0 != CRLInfoOut.NextUpdate.dwLowDateTime ||
	     0 != CRLInfoOut.NextUpdate.dwHighDateTime)?
		&CRLInfoOut.NextUpdate : NULL);

    hr = cuDumpFileTime(IDS_THISUPDATE, NULL, &CRLInfoOut.ThisUpdate);
    _JumpIfError(hr, error, "cuDumpFileTime");

    hr = cuDumpFileTime(IDS_NEXTUPDATE, NULL, &CRLInfoOut.NextUpdate);
    _JumpIfError(hr, error, "cuDumpFileTime");

    wprintf(myLoadResourceString(IDS_CRLENTRIES)); // "CRL Entries:"
    wprintf(L" %u\n", pCRLInfo->cCRLEntry);

    wprintf(wszNewLine);

    pExtKeyId = CertFindExtension(
			szOID_AUTHORITY_KEY_IDENTIFIER2, 
			pCRLInfo->cExtension,
			pCRLInfo->rgExtension);

    hr = RemoveExtensions(
		    (NULL == pftNextUpdate ||
		     0 != pftNextUpdate->dwLowDateTime ||
		     0 != pftNextUpdate->dwHighDateTime)?
			apwszObjIdFilter : apwszObjIdFilterNull,
		    TRUE,
		    CRLInfoOut.cExtension,
		    CRLInfoOut.rgExtension,
		    &CRLInfoOut.cExtension,
		    &rgExtension);
    _JumpIfError(hr, error, "RemoveExtensions");

    CRLInfoOut.rgExtension = rgExtension;

    if (!fAdd)
    {
	CERT_EXTENSION *rgExtension2 = rgExtension;

	hr = RemoveExtensions(
		    ppwszSerialList,
		    FALSE,
		    CRLInfoOut.cExtension,
		    CRLInfoOut.rgExtension,
		    &CRLInfoOut.cExtension,
		    &rgExtension);
	_JumpIfError(hr, error, "RemoveExtensions");

	if (NULL != rgExtension2)
	{
	    LocalFree(rgExtension2);
	}
	CRLInfoOut.rgExtension = rgExtension;
    }

    hr = AddRemoveSerial(
		    ppwszSerialList,
		    fAdd,
		    CRLInfoOut.cCRLEntry,
		    CRLInfoOut.rgCRLEntry,
		    &CRLInfoOut.cCRLEntry,
		    &rgCRLEntry,
		    &cSerialNew,
		    &rgpbSerialNew);
    _JumpIfError(hr, error, "AddRemoveSerial");

    CRLInfoOut.rgCRLEntry = rgCRLEntry;

    if (!myEncodeObject(
                    X509_ASN_ENCODING,
                    X509_CERT_CRL_TO_BE_SIGNED,
                    &CRLInfoOut,
                    0,
                    CERTLIB_USE_LOCALALLOC,
                    &pbUnsigned,               // pbEncoded
                    &cbUnsigned))
    {
        hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    hr = FindCertAndSign(
		    pExtKeyId,
		    NULL,
		    0,
		    pbUnsigned,
		    cbUnsigned,
		    NULL,	// pwszSerialNumber
		    ppbOut,
		    pcbOut);
    _JumpIfError(hr, error, "FindCertAndSign");

error:
    if (NULL != rgpbSerialNew)
    {
	DWORD i;

	for (i = 0; i < cSerialNew; i++)
	{
	    if (NULL != rgpbSerialNew[i])
	    {
		LocalFree(rgpbSerialNew[i]);
	    }
	}
	LocalFree(rgpbSerialNew);
    }
    if (NULL != rgCRLEntry)
    {
	LocalFree(rgCRLEntry);
    }
    if (NULL != rgExtension)
    {
	LocalFree(rgExtension);
    }
    if (NULL != pbUnsigned)
    {
	LocalFree(pbUnsigned);
    }
    return(hr);
}


HRESULT
SignCert(
    IN CERT_CONTEXT const *pCertContext,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OPTIONAL IN FILETIME const *pftNotAfter,
    OPTIONAL IN WCHAR const * const *ppwszObjIdList,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CERT_INFO const *pCertInfo;
    BYTE *pbUnsigned = NULL;
    DWORD cbUnsigned;
    BYTE const *pbHash;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    CERT_EXTENSION *pExtKeyId;
    CERT_EXTENSION *rgExtension = NULL;

    *ppbOut = NULL;

    pExtKeyId = NULL;
    if (NULL != pCertContext)
    {
	CERT_INFO CertInfoOut;

	ZeroMemory(&CertInfoOut, sizeof(CertInfoOut));

	pCertInfo = pCertContext->pCertInfo;
	CertInfoOut = *pCertInfo;

	SetExpiration(pftNotAfter, &CertInfoOut.NotBefore, &CertInfoOut.NotAfter);

	hr = cuDumpFileTime(IDS_NOTBEFORE, NULL, &CertInfoOut.NotBefore);
	_JumpIfError(hr, error, "cuDumpFileTime");

	hr = cuDumpFileTime(IDS_NOTAFTER, NULL, &CertInfoOut.NotAfter);
	_JumpIfError(hr, error, "cuDumpFileTime");

	wprintf(wszNewLine);

	pbHash = NULL;
	pExtKeyId = CertFindExtension(
			    szOID_AUTHORITY_KEY_IDENTIFIER2, 
			    pCertInfo->cExtension,
			    pCertInfo->rgExtension);
	if (NULL == pExtKeyId)
	{
	    hr = cuVerifySignature(
			    pCertContext->pbCertEncoded,
			    pCertContext->cbCertEncoded,
			    &pCertContext->pCertInfo->SubjectPublicKeyInfo,
			    FALSE,
			    TRUE);
	    if (S_OK == hr)
	    {
		if (CertGetCertificateContextProperty(
						pCertContext,
						CERT_KEY_IDENTIFIER_PROP_ID,
						abHash,
						&cbHash))
		{
		    pbHash = abHash;
		}
	    }
	}
	hr = RemoveExtensions(
		    ppwszObjIdList,
		    TRUE,
		    CertInfoOut.cExtension,
		    CertInfoOut.rgExtension,
		    &CertInfoOut.cExtension,
		    &rgExtension);
	_JumpIfError(hr, error, "RemoveExtensions");

	CertInfoOut.rgExtension = rgExtension;

	if (0 == CertInfoOut.cExtension)
	{
	    CertInfoOut.dwVersion = CERT_V1;
	}
	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_CERT_TO_BE_SIGNED,
			&CertInfoOut,
			0,
			CERTLIB_USE_LOCALALLOC,
			&pbUnsigned,               // pbEncoded
			&cbUnsigned))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
    }
    hr = FindCertAndSign(
		    pExtKeyId,
		    pbHash,
		    cbHash,
		    pbUnsigned,
		    cbUnsigned,
		    pwszSerialNumber,
		    ppbOut,
		    pcbOut);
    _JumpIfError(hr, error, "FindCertAndSign");

error:
    if (NULL != rgExtension)
    {
	LocalFree(rgExtension);
    }
    if (NULL != pbUnsigned)
    {
	LocalFree(pbUnsigned);
    }
    return(hr);
}


HRESULT
verbSign(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnIn,
    IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszDaysHours,
    OPTIONAL IN WCHAR const *pwszChangeList)
{
    HRESULT hr;
    FILETIME ftNextUpdate;
    FILETIME *pftNextUpdate;
    CRL_CONTEXT const *pCRLContext = NULL;
    CERT_CONTEXT const *pCertContext = NULL;
    BYTE *pbOut = NULL;
    DWORD cbOut;
    BOOL fAdd = FALSE;
    WCHAR **ppwszList = NULL;
    BSTR strSerialNumber = NULL;

    pftNextUpdate = NULL;
    if (NULL != pwszDaysHours &&
	(myIsMinusSign(*pwszDaysHours) || L'+' == *pwszDaysHours))
    {
	WCHAR const *pwsz = pwszDaysHours;

	pwszDaysHours = pwszChangeList;
	pwszChangeList = pwsz;
    }
    if (NULL != pwszChangeList)
    {
	if (!myIsMinusSign(*pwszChangeList) && L'+' != *pwszChangeList)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "missing +/-");
	}
	fAdd = L'+' == *pwszChangeList++;
	hr = cuParseStrings(
		    pwszChangeList,
		    FALSE,
		    NULL,
		    NULL,
		    &ppwszList,
		    NULL);
	_JumpIfError(hr, error, "cuParseStrings");
    }
    if (NULL != pwszDaysHours)
    {
	if (0 == lstrcmp(L"0", pwszDaysHours))
	{
	    ZeroMemory(&ftNextUpdate, sizeof(ftNextUpdate));
	}
	else
	{
	    hr = cuParseDaysHours(pwszDaysHours, &ftNextUpdate);
	    _JumpIfError(hr, error, "cuParseDaysHours");
	}
	pftNextUpdate = &ftNextUpdate;
    }

    if (NULL == pwszDaysHours &&
	NULL == pwszChangeList &&
	!myDoesFileExist(pwszfnIn))
    {
	hr = myMakeSerialBstr(pwszfnIn, &strSerialNumber);
	_JumpIfError(hr, error, "myMakeSerialBstr");

	hr = SignCert(
		NULL,		// pCertContext
		strSerialNumber,
		pftNextUpdate,
		NULL,		// ppwszObjIdList
		&pbOut,
		&cbOut);
	_JumpIfError(hr, error, "SignCert");
    }
    else
    {
	// Load and decode CRL and certificate

	hr = cuLoadCRL(pwszfnIn, &pCRLContext);
	if (S_OK == hr)
	{
	    hr = SignCRL(
		    pCRLContext,
		    pftNextUpdate,
		    fAdd,
		    ppwszList,
		    &pbOut,
		    &cbOut);
	    _JumpIfError(hr, error, "SignCRL");
	}
	else
	{
	    hr = cuLoadCert(pwszfnIn, &pCertContext);
	    if (S_OK == hr)
	    {
		if (fAdd)
		{
		    hr = E_INVALIDARG;
		    _JumpError(hr, error, "cannot add extensions to cert");
		}
		hr = SignCert(
			pCertContext,
			NULL,		// pwszSerialNumber
			pftNextUpdate,
			ppwszList,
			&pbOut,
			&cbOut);
		_JumpIfError(hr, error, "SignCert");
	    }
	    else
	    {
		cuPrintError(IDS_FORMAT_LOADTESTCRL, hr);
		goto error;
	    }
	}
    }

    // Write encoded & signed CRL or Cert to file

    hr = EncodeToFileW(
		pwszfnOut,
		pbOut,
		cbOut,
		CRYPT_STRING_BINARY | g_EncodeFlags);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_ENCODETOFILE, hr);
	goto error;
    }
    wprintf(
	myLoadResourceString(IDS_FORMAT_OUTPUT_LENGTH), // "Output Length = %d"
	cuFileSize(pwszfnOut));
    wprintf(wszNewLine);

    hr = S_OK;

error:
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    cuFreeStringArray(ppwszList);
    if (NULL != pbOut)
    {
	LocalFree(pbOut);
    }
    cuUnloadCRL(&pCRLContext);
    cuUnloadCert(&pCertContext);
    return(hr);
}


HRESULT
verbShutDownServer(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = CertSrvServerControl(g_pwszConfig, CSCONTROL_SHUTDOWN, NULL, NULL);
    _JumpIfError(hr, error, "CertSrvServerControl");

error:
    if (E_ACCESSDENIED == hr)
    {
        g_uiExtraErrorInfo = IDS_ERROR_ACCESSDENIED_CAUSE;
    }
    return(hr);
}


HRESULT
verbIsValidCertificate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszSerialNumber,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    BSTR strSerialNumber = NULL;
    LONG Reason = CRL_REASON_KEY_COMPROMISE;
    BOOL fMustRelease = FALSE;
    LONG Disposition;

    hr = myMakeSerialBstr(pwszSerialNumber, &strSerialNumber);
    _JumpIfError(hr, error, "myMakeSerialBstr");

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    hr = Admin_IsValidCertificate(
			&diAdmin,
			g_pwszConfig,
			strSerialNumber,
			&Disposition);
    _JumpIfError(hr, error, "Admin_IsValidCertificate");

    switch (Disposition)
    {
	case CA_DISP_INVALID:
	    wprintf(myLoadResourceString(IDS_CERT_DISPOSITION_INVALID), strSerialNumber); // "Certificate disposition for "%ws" is invalid"
	    wprintf(wszNewLine);
	    break;

	case CA_DISP_VALID:
	    wprintf(myLoadResourceString(IDS_CERT_DISPOSITION_VALID), strSerialNumber); // "Certificate disposition for "%ws" is valid"
	    wprintf(wszNewLine);
	    break;

	case CA_DISP_UNDER_SUBMISSION:
	    wprintf(myLoadResourceString(IDS_CERT_DISPOSITION_PENDING), strSerialNumber); // "Certificate request for "%ws" is pending"
	    wprintf(wszNewLine);
	    break;

	case CA_DISP_REVOKED:
	    hr = Admin_GetRevocationReason(&diAdmin, &Reason);
	    if (S_OK != hr)
	    {
		_PrintIfError(hr, "Admin_GetRevocationReason");
		Reason = CRL_REASON_UNSPECIFIED;
	    }
	    wprintf(
		myLoadResourceString(IDS_CERT_DISPOSITION_REVOKED), // "Certificate disposition for "%ws" is revoked (%ws)"
		strSerialNumber,
		wszCRLReason(Reason));
	    wprintf(wszNewLine);
	    break;
    }

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


#define wszREQUEST	L"Request"
#define wszCERT		L"Cert"

HRESULT
verbDeleteRow(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRowIdOrDate,
    OPTIONAL IN WCHAR const *pwszTable,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszLocalTime = NULL;
    DISPATCHINTERFACE diAdmin;
    BOOL fMustRelease = FALSE;
    DWORD Flags;
    LONG RowId;
    DATE date;
    LONG Table;
    LONG Count;

    hr = myGetLong(pwszRowIdOrDate, &RowId);
    if (S_OK != hr)
    {
	FILETIME ftCurrent;
	FILETIME ftQuery;
	
	RowId = 0;

	hr = myWszLocalTimeToGMTDate(pwszRowIdOrDate, &date);
	_JumpIfError(hr, error, "invalid RowId or date");

	hr = myGMTDateToWszLocalTime(&date, g_fSeconds, &pwszLocalTime);
	_JumpIfError(hr, error, "myGMTDateToWszLocalTime");

	GetSystemTimeAsFileTime(&ftCurrent);

	hr = myDateToFileTime(&date, &ftQuery);
	_JumpIfError(hr, error, "myDateToFileTime");

	if (0 > CompareFileTime(&ftCurrent, &ftQuery))
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_DATE_IN_FUTURE), // "The date specified is in the future: %ws"
		pwszLocalTime);
	    wprintf(wszNewLine);
	    if (!g_fForce)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "date in future");
	    }
	}
	if (g_fVerbose)
	{
	    wprintf(pwszLocalTime);
	    wprintf(wszNewLine);
	}
    }
    else
    {
	if (0 == RowId)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "zero RowId");
	}
	date = 0.0;
    }

    hr = E_INVALIDARG;
    Table = CVRC_TABLE_REQCERT;
    Flags = 0;
    if (NULL == pwszTable)
    {
	if (0 == RowId)
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_DATE_REQUIRES_TABLE), // "One of the following tables must be specified when deleting rows older than %ws:"
		pwszLocalTime);
	    wprintf(wszNewLine);
	    wprintf(L"  %ws\n", wszREQUEST);
	    wprintf(L"  %ws\n", wszCERT);
	    wprintf(L"  %ws\n", g_wszCRL);
	    _JumpError(hr, error, "date requires table");
	}
    }
    else
    if (0 == LSTRCMPIS(pwszTable, wszREQUEST))
    {
	Flags = CDR_REQUEST_LAST_CHANGED; // assume date query
    }
    else
    if (0 == LSTRCMPIS(pwszTable, wszCERT))
    {
	Flags = CDR_EXPIRED;		// assume date query
    }
    else
    if (0 == mylstrcmpiS(pwszTable, g_wszExt))
    {
	Table = CVRC_TABLE_EXTENSIONS;
	if (0 == RowId)
	{
	    _JumpError(hr, error, "no date in Extension table");
	}
    }
    else
    if (0 == mylstrcmpiS(pwszTable, g_wszAttrib))
    {
	Table = CVRC_TABLE_ATTRIBUTES;
	if (0 == RowId)
	{
	    _JumpError(hr, error, "no date in Request Attribute table");
	}
    }
    else
    if (0 == mylstrcmpiS(pwszTable, g_wszCRL))
    {
	Table = CVRC_TABLE_CRL;		// assume date query
    }
    else
    {
	_JumpError(hr, error, "bad table name");
    }
    if (0 != RowId)
    {
	Flags = 0;			// not a date query
 
    }
    else if (g_fVerbose)
    {
	wprintf(L"%ws\n", pwszLocalTime);
    }

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    Count = 0;
    hr = Admin2_DeleteRow(
			&diAdmin,
			g_pwszConfig,
			Flags,
			date,
			Table,
			RowId,
			&Count);
    wprintf(myLoadResourceString(IDS_FORMAT_DELETED_ROW_COUNT), Count);
    wprintf(wszNewLine);
    _JumpIfError(hr, error, "Admin2_DeleteRow");

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != pwszLocalTime)
    {
	LocalFree(pwszLocalTime);
    }
    return(hr);
}


HRESULT
verbSetAttributes(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRequestId,
    IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    LONG RequestId;
    BSTR strAttributes = NULL;
    WCHAR *pwsz;
    BOOL fMustRelease = FALSE;

    if (!ConvertWszToBstr(&strAttributes, pwszAttributes, MAXDWORD))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    for (pwsz = strAttributes; L'\0' != *pwsz; pwsz++)
    {
	switch (*pwsz)
	{
	    case L';':
		*pwsz = L'\n';
		break;

	    case L'\\':
		if (L'n' == pwsz[1])
		{
		    *pwsz++ = L'\r';
		    *pwsz = L'\n';
		}
		break;
	}
    }

    hr = myGetLong(pwszRequestId, &RequestId);
    _JumpIfError(hr, error, "RequestId must be a number");

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fMustRelease = TRUE;

    hr = Admin_SetRequestAttributes(
			    &diAdmin,
			    g_pwszConfig,
			    RequestId,
			    strAttributes);
    _JumpIfError(hr, error, "Admin_SetAttributes");

error:
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != strAttributes)
    {
	SysFreeString(strAttributes);
    }
    return(hr);
}


HRESULT
verbSetExtension(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRequestId,
    IN WCHAR const *pwszExtensionName,
    IN WCHAR const *pwszFlags,
    IN WCHAR const *pwszValue)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    LONG RequestId;
    LONG Flags;
    BSTR strExtensionName = NULL;
    BSTR strValue = NULL;
    LONG PropType;
    VARIANT var;
    BOOL fMustRelease = FALSE;
    BYTE *pbValue = NULL;
    DWORD cbValue;

    hr = myGetLong(pwszRequestId, &RequestId);
    _JumpIfError(hr, error, "RequestId must be a number");

    if (!ConvertWszToBstr(&strExtensionName, pwszExtensionName, MAXDWORD))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    hr = myGetLong(pwszFlags, &Flags);
    _JumpIfError(hr, error, "Flags must be a number");

    if (~EXTENSION_POLICY_MASK & Flags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Flags must be <= 0xffff");
    }
    if (L'@' == *pwszValue)
    {
	pwszValue++;

	// Read in and decode the extension from a file.
	// Try Hex-Ascii, Base64 with and without a header, then binary.
	hr = DecodeFileW(pwszValue, &pbValue, &cbValue, CRYPT_STRING_HEX_ANY);
	if (S_OK != hr)
	{
	    hr = DecodeFileW(pwszValue, &pbValue, &cbValue, CRYPT_STRING_ANY);
	    _JumpIfError(hr, error, "DecodeFileW");
	}

	CSASSERT(NULL != pbValue && 0 != cbValue);

	var.vt = VT_BSTR;
	PropType = PROPTYPE_BINARY;

	DumpHex(0, pbValue, cbValue);
	if (!ConvertWszToBstr(&strValue, (WCHAR const *) pbValue, cbValue))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToBstr");
	}
	var.bstrVal = strValue;
    }
    else
    {
	hr = myGetLong(pwszValue, &var.lVal);
	if (S_OK == hr)
	{
	    var.vt = VT_I4;
	    PropType = PROPTYPE_LONG;
	}
	else
	{
	    hr = myWszLocalTimeToGMTDate(pwszValue, &var.date);
	    if (S_OK == hr)
	    {
		var.vt = VT_DATE;
		PropType = PROPTYPE_DATE;
	    }
	    else
	    {
		PropType = PROPTYPE_STRING;
		if (!ConvertWszToBstr(&strValue, pwszValue, MAXDWORD))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToBstr");
		}
		var.vt = VT_BSTR;
		var.bstrVal = strValue;
	    }
	}
    }

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    if (S_OK != hr)
    {
	_JumpError(hr, error, "Admin_Init");
    }
    fMustRelease = TRUE;

    hr = Admin_SetCertificateExtension(
			&diAdmin,
			g_pwszConfig,
			RequestId,
			strExtensionName,
			PropType,
			Flags,
			&var);
    _JumpIfError(hr, error, "Admin_SetExtension");

error:
    if (NULL != pbValue)
    {
	LocalFree(pbValue);
    }
    if (fMustRelease)
    {
	Admin_Release(&diAdmin);
    }
    if (NULL != strExtensionName)
    {
	SysFreeString(strExtensionName);
    }
    if (NULL != strValue)
    {
	SysFreeString(strValue);
    }
    return(hr);
}


HRESULT
verbImportCertificate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszCertificateFile,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    LONG dwReqID;
    CERT_CONTEXT const *pCertContext = NULL;
    DISPATCHINTERFACE diAdmin;
    BOOL fRelease = FALSE;
    
    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fRelease = TRUE;

    hr = cuLoadCert(pwszCertificateFile, &pCertContext);
    _JumpIfError(hr, error, "cuLoadCert");

    hr = Admin_ImportCertificate(
			    &diAdmin,
			    g_pwszConfig,
			    (WCHAR const *) pCertContext->pbCertEncoded,
			    pCertContext->cbCertEncoded,
			    (g_fForce? ICF_ALLOWFOREIGN : 0) | CR_IN_BINARY,
			    &dwReqID);
    _JumpIfError(hr, error, "Admin_ImportCertificate");

    wprintf(myLoadResourceString(IDS_FORMAT_IMPORTCERT), dwReqID);
    wprintf(wszNewLine);

error:
    cuUnloadCert(&pCertContext);
    if (fRelease)
    {
        Admin_Release(&diAdmin);
    }
    return(hr);
}


HRESULT
DumpKeyRecipientInfo(
    IN BYTE const *pbRecoveryBlob,
    IN DWORD cbRecoveryBlob)
{
    HRESULT hr;
    BYTE *pbEncryptedKey = NULL;
    DWORD cbEncryptedKey;
    DWORD cRecipient;
    HCERTSTORE hStore = NULL;
    HCRYPTMSG hMsg = NULL;
    DWORD dwMsgType;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];

    hr = myDecodePKCS7(
		    pbRecoveryBlob,
		    cbRecoveryBlob,
		    &pbEncryptedKey,
		    &cbEncryptedKey,
		    &dwMsgType,
		    NULL,	// ppszInnerContentObjId
		    NULL,	// pcSigner
		    NULL,	// pcRecipient
		    &hStore,
		    NULL);	// phMsg
    _JumpIfError(hr, error, "myDecodePKCS7");

    if (NULL == pbEncryptedKey)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "No Content");
    }
    if (CMSG_SIGNED != dwMsgType)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Not Signed");
    }
    hr = myDecodePKCS7(
		    pbEncryptedKey,
		    cbEncryptedKey,
		    NULL,	// ppbContent
		    NULL,	// pcbContent
		    &dwMsgType,
		    NULL,	// ppszInnerContentObjId
		    NULL,	// pcSigner
		    &cRecipient,
		    NULL,	// phStore
		    &hMsg);
    _JumpIfError(hr, error, "myDecodePKCS7");

    if (CMSG_ENVELOPED != dwMsgType)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Not Encrypted");
    }
    if (NULL == hMsg || 0 == cRecipient)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "No Msg or Recipients");
    }
    hr = cuDumpRecipients(hMsg, hStore, cRecipient, TRUE);
    _JumpIfError(hr, error, "cuDumpRecipients");

error:
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pbEncryptedKey)
    {
	LocalFree(pbEncryptedKey);
    }
    return(hr);
}


HRESULT
GetArchivedKey(
    IN WCHAR const *pwszConfig,
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszfnRecoveryBlob)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    BOOL fRelease = FALSE;
    BSTR strKey = NULL;
    WCHAR *pwszT = NULL;

    hr = Admin_Init(g_DispatchFlags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    fRelease = TRUE;

    hr = Admin2_GetArchivedKey(
			&diAdmin,
			pwszConfig,
			RequestId,
			CR_OUT_BINARY,
			&strKey);
    _JumpIfError(hr, error, "Admin_GetArchivedKey");

    if (NULL == pwszfnRecoveryBlob)
    {
	hr = myCryptBinaryToString(
			    (BYTE const *) strKey,
			    SysStringByteLen(strKey),
			    CRYPT_STRING_BASE64HEADER,
			    &pwszT);
	_JumpIfError(hr, error, "myCryptBinaryToString");

	cuPrintCRLFString(NULL, pwszT);
    }
    else
    {
	hr = EncodeToFileW(
		    pwszfnRecoveryBlob,
		    (BYTE const *) strKey,
		    SysStringByteLen(strKey),
		    CRYPT_STRING_BINARY | g_EncodeFlags);
	_JumpIfError(hr, error, "EncodeToFileW");
    }
    hr = DumpKeyRecipientInfo((BYTE const *) strKey, SysStringByteLen(strKey));
    _PrintIfError(hr, "DumpKeyRecipientInfo");

    hr = S_OK;

error:
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    if (NULL != strKey)
    {
	SysFreeString(strKey);
    }
    if (fRelease)
    {
        Admin_Release(&diAdmin);
    }
    return(hr);
}


typedef struct _GETKEYSERIAL {
    struct _GETKEYSERIAL *Next;
    DWORD		  dwVersion;
    BSTR                  strConfig;
    LONG		  RequestId;
    BSTR                  strSerialNumber;
    BSTR                  strCommonName;
    BSTR                  strUPN;
    BSTR                  strHash;
    BSTR                  strCert;
} GETKEYSERIAL;


VOID
FreeKeySerialEntry(
    IN OUT GETKEYSERIAL *pks)
{
    if (NULL != pks->strConfig)
    {
	SysFreeString(pks->strConfig);
    }
    if (NULL != pks->strSerialNumber)
    {
	SysFreeString(pks->strSerialNumber);
    }
    if (NULL != pks->strCommonName)
    {
	SysFreeString(pks->strCommonName);
    }
    if (NULL != pks->strUPN)
    {
	SysFreeString(pks->strUPN);
    }
    if (NULL != pks->strHash)
    {
	SysFreeString(pks->strHash);
    }
    if (NULL != pks->strCert)
    {
	SysFreeString(pks->strCert);
    }
    LocalFree(pks);
}


HRESULT
AddKeySerialList(
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszSerialNumber,
    IN WCHAR const *pwszCommonName,
    IN WCHAR const *pwszUPN,
    IN WCHAR const *pwszHash,
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN OUT GETKEYSERIAL **ppksList)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    GETKEYSERIAL *pksNew = NULL;
    GETKEYSERIAL *pksT;
    GETKEYSERIAL *pksPrev;
    BOOL fNewConfig = TRUE;

    pcc = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCert);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    pksNew = (GETKEYSERIAL *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    sizeof(*pksNew));
    if (NULL == pksNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pksNew->RequestId = RequestId;
    pksNew->dwVersion = pcc->pCertInfo->dwVersion;

    pksNew->strConfig = SysAllocString(pwszConfig);
    pksNew->strSerialNumber = SysAllocString(pwszSerialNumber);
    pksNew->strCommonName = SysAllocString(pwszCommonName);
    pksNew->strUPN = SysAllocString(pwszUPN);
    pksNew->strHash = SysAllocString(pwszHash);
    pksNew->strCert = SysAllocStringByteLen((char const *) pbCert, cbCert);
    if (NULL == pksNew->strConfig ||
	NULL == pksNew->strSerialNumber ||
	(NULL != pwszCommonName && NULL == pksNew->strCommonName) ||
	(NULL != pwszUPN && NULL == pksNew->strUPN) ||
	NULL == pksNew->strHash ||
	NULL == pksNew->strCert)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pksPrev = NULL;
    for (pksT = *ppksList; NULL != pksT; pksT = pksT->Next)
    {
	if (NULL != pksT->strConfig)
	{
	    fNewConfig = 0 != lstrcmp(pksT->strConfig, pksNew->strConfig);
	}
	pksPrev = pksT;
    }
    if (NULL == pksPrev)
    {
	*ppksList = pksNew;
    }
    else
    {
	pksPrev->Next = pksNew;
    }
    if (!fNewConfig)
    {
	SysFreeString(pksNew->strConfig);
	pksNew->strConfig = NULL;
    }
    pksNew = NULL;
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != pksNew)
    {
	FreeKeySerialEntry(pksNew);
    }
    return(hr);
}


HRESULT
cuViewQueryWorker(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszColumn,
    IN WCHAR const *pwszValue1,
    OPTIONAL IN WCHAR const *pwszValue2,
    IN OUT GETKEYSERIAL **ppksList,
    OUT BOOL *pfConnectionFailed)
{
    HRESULT hr;
    DWORD cwc;
    DISPATCHINTERFACE diView;
    DISPATCHINTERFACE diViewRow;
    DISPATCHINTERFACE diViewColumn;
    BOOL fMustRelease = FALSE;
    BOOL fMustReleaseRow = FALSE;
    BOOL fMustReleaseColumn = FALSE;
    LONG ColIndex;
    LONG RowIndex;
    DWORD cRow;
    VARIANT var;
    LONG RequestId;
    DWORD i;
    static WCHAR *apwszCol[] =
    {
#define IV_REQUESTID	0
	wszPROPCERTIFICATEREQUESTID,

#define IV_SERIALNUMBER	1
	wszPROPCERTIFICATESERIALNUMBER,

#define IV_COMMONNAME	2
	wszPROPCOMMONNAME,

#define IV_ARCHIVEDKEY	3
	wszPROPREQUESTRAWARCHIVEDKEY,

#define IV_HASH		4
	wszPROPCERTIFICATEHASH,

#define IV_CERT		5
	wszPROPRAWCERTIFICATE,

#define IV_UPN		6
	wszPROPCERTIFICATEUPN,
    };
    static LONG altype[] =
    {
	PROPTYPE_LONG,
	PROPTYPE_STRING,
	PROPTYPE_STRING,
	PROPTYPE_BINARY,
	PROPTYPE_STRING,
	PROPTYPE_BINARY,
	PROPTYPE_STRING,
    };
    BSTR astrValue[ARRAYSIZE(apwszCol)];

    ZeroMemory(astrValue, sizeof(astrValue));
    VariantInit(&var);
    *pfConnectionFailed = TRUE;
    
    DBGPRINT((
	DBG_SS_CERTUTILI,
	"Query(%ws, %ws == %ws + %ws)\n",
	pwszConfig,
	pwszColumn,
	pwszValue1,
	pwszValue2));

    hr = View_Init(g_DispatchFlags, &diView);
    _JumpIfError(hr, error, "View_Init");

    fMustRelease = TRUE;

    hr = View_OpenConnection(&diView, pwszConfig);
    _JumpIfError(hr, error, "View_OpenConnection");

    *pfConnectionFailed = FALSE;

    hr = View_GetColumnIndex(
			&diView,
			CVRC_COLUMN_SCHEMA,
			pwszColumn,
			&ColIndex);
    _JumpIfErrorStr(hr, error, "View_GetColumnIndex", pwszColumn);

    cwc = wcslen(pwszValue1);
    if (NULL != pwszValue2)
    {
	cwc += wcslen(pwszValue2);
    }
    var.bstrVal = SysAllocStringLen(NULL, cwc);
    if (NULL == var.bstrVal)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "SysAllocString");
    }
    var.vt = VT_BSTR;
    wcscpy(var.bstrVal, pwszValue1);
    if (NULL != pwszValue2)
    {
	wcscat(var.bstrVal, pwszValue2);
    }

    hr = View_SetRestriction(
			&diView,
			ColIndex,		// Restriction ColumnIndex
			CVR_SEEK_EQ,
			CVR_SORT_ASCEND,
			&var);			// pvarValue
    _JumpIfError(hr, error, "View_SetRestriction");

    hr = View_SetResultColumnCount(&diView, ARRAYSIZE(apwszCol));
    _JumpIfError(hr, error, "View_SetResultColumnCount");

    for (i = 0; i < ARRAYSIZE(apwszCol); i++)
    {
	hr = View_GetColumnIndex(
			    &diView,
			    CVRC_COLUMN_SCHEMA,
			    apwszCol[i],
			    &ColIndex);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "View_GetColumnIndex",
		    apwszCol[i]);

	hr = View_SetResultColumn(&diView, ColIndex);
	_JumpIfError(hr, error, "View_SetResultColumn");
    }

    hr = View_OpenView(&diView, &diViewRow);
    _JumpIfError(hr, error, "View_OpenView");

    fMustReleaseRow = TRUE;

    for (cRow = 0; ; cRow++)
    {
	hr = ViewRow_Next(&diViewRow, &RowIndex);
	if (S_FALSE == hr || (S_OK == hr && -1 == RowIndex))
	{
	    break;
	}
	_JumpIfError(hr, error, "ViewRow_Next");

	if (fMustReleaseColumn)
	{
	    ViewColumn_Release(&diViewColumn);
	    fMustReleaseColumn = FALSE;
	}
	hr = ViewRow_EnumCertViewColumn(&diViewRow, &diViewColumn);
	_JumpIfError(hr, error, "ViewRow_EnumCertViewColumn");

	fMustReleaseColumn = TRUE;

	for (i = 0; i < ARRAYSIZE(apwszCol); i++)
	{
	    VOID *pv;
	    
	    hr = ViewColumn_Next(&diViewColumn, &ColIndex);
	    if (S_FALSE == hr || (S_OK == hr && -1 == ColIndex))
	    {
		break;
	    }
	    _JumpIfError(hr, error, "ViewColumn_Next");

	    pv = &RequestId;
	    if (PROPTYPE_LONG != altype[i])
	    {
		pv = &astrValue[i];
	    }

	    hr = ViewColumn_GetValue(
				&diViewColumn,
				CV_OUT_BINARY,
				altype[i],
				pv);
	    if (S_OK != hr)
	    {
		_PrintErrorStr2(
			hr,
			"ViewColumn_GetValue",
			apwszCol[i],
			CERTSRV_E_PROPERTY_EMPTY);
		if (CERTSRV_E_PROPERTY_EMPTY != hr)
		{
		    goto error;
		}
	    }
	}

	DBGPRINT((
	    DBG_SS_CERTUTILI,
	    "RequestId=%u  Serial=%ws  CN=%ws  UPN=%ws  Key=%u\n",
	    RequestId,
	    astrValue[IV_SERIALNUMBER],
	    astrValue[IV_COMMONNAME],
	    astrValue[IV_UPN],
	    NULL != astrValue[IV_ARCHIVEDKEY]));

	if (NULL != astrValue[IV_SERIALNUMBER] &&
	    NULL != astrValue[IV_HASH] &&
	    NULL != astrValue[IV_CERT] &&
	    (g_fForce || NULL != astrValue[IV_ARCHIVEDKEY]))
	{
	    hr = AddKeySerialList(
			    pwszConfig,
			    RequestId,
			    astrValue[IV_SERIALNUMBER],
			    astrValue[IV_COMMONNAME],
			    astrValue[IV_UPN],
			    astrValue[IV_HASH],
			    (BYTE const *) astrValue[IV_CERT],
			    SysStringByteLen(astrValue[IV_CERT]),
			    ppksList);
	    _JumpIfError(hr, error, "AddKeySerialList");
	}

	for (i = 0; i < ARRAYSIZE(astrValue); i++)
	{
	    if (NULL != astrValue[i])
	    {
		SysFreeString(astrValue[i]);
		astrValue[i] = NULL;
	    }
	}
    }
    hr = S_OK;

error:
    if (fMustReleaseColumn)
    {
	ViewColumn_Release(&diViewColumn);
    }
    if (fMustReleaseRow)
    {
	ViewRow_Release(&diViewRow);
    }
    if (fMustRelease)
    {
	View_Release(&diView);
    }
    for (i = 0; i < ARRAYSIZE(astrValue); i++)
    {
	if (NULL != astrValue[i])
	{
	    SysFreeString(astrValue[i]);
	}
    }
    VariantClear(&var);
    return(hr);
}


// Print the string, except for the newline at the start or end of the string.

VOID
PutStringStripNL(
    IN WCHAR const *pwszValue)
{
    DWORD cwc;
    
    cwc = wcslen(pwszValue);
    if (L'\n' == *pwszValue)
    {
	pwszValue++;
	cwc--;
    }
    else if (NULL != wcschr(pwszValue, L'\n'))
    {
	cwc--;
	CSASSERT('\n' == pwszValue[cwc]);
    }
    wprintf(L"%.*ws", cwc, pwszValue);
}


HRESULT
cuViewQuery(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszColumn,
    IN WCHAR const *pwszValue1,
    OPTIONAL IN WCHAR const *pwszValue2,
    IN OUT GETKEYSERIAL **ppksList,
    OUT BOOL *pfConnectionFailed)
{
    HRESULT hr;
    
    if (!g_fQuiet)
    {
	if (g_fVerbose)
	{
	    wprintf(L"  %ws: ", pwszColumn);
	    PutStringStripNL(pwszValue1);
	    if (NULL != pwszValue2)
	    {
		wprintf(L" + ");
		PutStringStripNL(pwszValue2);
	    }
	    wprintf(wszNewLine);
	}
	else
	{
	    wprintf(L"...");
	}
    }
    hr = cuViewQueryWorker(
		pwszConfig,
		pwszColumn,
		pwszValue1,
		pwszValue2,
		ppksList,
		pfConnectionFailed);
    _JumpIfError(hr, error, "cuViewQueryWorker");

error:
    return(hr);
}


#define wszCOMPUTERS	L"Computers"
#define wszUSERS	L"Users"
#define wszRECIPIENTS	L"recipients"

#define wszCOMPUTERSNL	wszCOMPUTERS L"\n"
#define wszUSERSNL	wszUSERS L"\n"
#define wszRECIPIENTSNL	wszRECIPIENTS L"\n"
#define wszNLRECIPIENTS	L"\n" wszRECIPIENTS

HRESULT
GetKey(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszCommonName,
    OPTIONAL IN WCHAR const *pwszRequesterName,
    OPTIONAL IN WCHAR const *pwszUPN,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OPTIONAL IN WCHAR const *pwszHash,
    IN OUT GETKEYSERIAL **ppksList)
{
    HRESULT hr;
    BOOL fConnectionFailed;

    if (!g_fQuiet)
    {
	wprintf(myLoadResourceString(IDS_FORMAT_QUERYING), pwszConfig);
	if (g_fVerbose)
	{
	    wprintf(wszNewLine);
	}
    }

    hr = cuViewQuery(
		pwszConfig,
		wszPROPCOMMONNAME,
		pwszCommonName,
		NULL,
		ppksList,
		&fConnectionFailed);
    _PrintIfErrorStr(hr, "cuViewQuery", wszPROPSUBJECTCOMMONNAME);
    if (S_OK != hr)
    {
	if (fConnectionFailed)
	{
	    goto error;
	}
    }

    if (NULL == wcschr(pwszCommonName, L'\n'))
    {
	hr = cuViewQuery(
		    pwszConfig,
		    wszPROPCOMMONNAME,
		    wszCOMPUTERSNL,
		    pwszCommonName,
		    ppksList,
		    &fConnectionFailed);
	_PrintIfErrorStr(hr, "cuViewQuery", wszCOMPUTERS L"+" wszPROPSUBJECTCOMMONNAME );

	hr = cuViewQuery(
		    pwszConfig,
		    wszPROPCOMMONNAME,
		    wszUSERSNL,
		    pwszCommonName,
		    ppksList,
		    &fConnectionFailed);
	_PrintIfErrorStr(hr, "cuViewQuery", wszUSERS L"+" wszPROPSUBJECTCOMMONNAME );

	hr = cuViewQuery(
		    pwszConfig,
		    wszPROPCOMMONNAME,
		    wszRECIPIENTSNL,
		    pwszCommonName,
		    ppksList,
		    &fConnectionFailed);
	_PrintIfErrorStr(hr, "cuViewQuery", wszRECIPIENTS L"+" wszPROPSUBJECTCOMMONNAME);

	hr = cuViewQuery(
		    pwszConfig,
		    wszPROPCOMMONNAME,
		    pwszCommonName,
		    wszNLRECIPIENTS,
		    ppksList,
		    &fConnectionFailed);
	_PrintIfErrorStr(hr, "cuViewQuery", wszPROPSUBJECTCOMMONNAME L"+" wszRECIPIENTS);
    }

    if (NULL != pwszSerialNumber)
    {
	hr = cuViewQuery(
		    pwszConfig,
		    wszPROPCERTIFICATESERIALNUMBER,
		    pwszSerialNumber,
		    NULL,
		    ppksList,
		    &fConnectionFailed);
	_PrintIfErrorStr(hr, "cuViewQuery", wszPROPCERTIFICATESERIALNUMBER);
    }
    if (NULL != pwszHash)
    {
	hr = cuViewQuery(
		    pwszConfig,
		    wszPROPCERTIFICATEHASH,
		    pwszHash,
		    NULL,
		    ppksList,
		    &fConnectionFailed);
	_PrintIfErrorStr(hr, "cuViewQuery", wszPROPCERTIFICATEHASH);
    }
    if (NULL != pwszRequesterName)
    {
	hr = cuViewQuery(
		    pwszConfig,
		    wszPROPREQUESTERNAME,
		    pwszRequesterName,
		    NULL,
		    ppksList,
		    &fConnectionFailed);
	_PrintIfErrorStr(hr, "cuViewQuery", wszPROPREQUESTERNAME);
    }

    if (NULL != pwszUPN)
    {
	hr = cuViewQuery(
		    pwszConfig,
		    wszPROPCERTIFICATEUPN,
		    pwszUPN,
		    NULL,
		    ppksList,
		    &fConnectionFailed);
	_PrintIfErrorStr(hr, "cuViewQuery", wszPROPCERTIFICATEUPN);
    }

    if (!g_fQuiet)
    {
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    return(hr);
}


VOID
cuConvertEscapeSequences(
    IN OUT WCHAR *pwsz)
{
    WCHAR *pwszSrc = pwsz;
    WCHAR *pwszDst = pwsz;

    while (L'\0' != *pwszSrc)
    {
	WCHAR wc = *pwszSrc++;

	if (L'\\' == wc)
	{
	    switch (*pwszSrc)
	    {
		case 'n':
		    wc = L'\n';
		    pwszSrc++;
		    break;

		case 'r':
		    wc = L'\r';
		    pwszSrc++;
		    break;

		case 't':
		    wc = L'\t';
		    pwszSrc++;
		    break;

		default:
		    break;
	    }
	}
	*pwszDst++ = wc;
    }
    *pwszDst = L'\0';
}


WCHAR *
SplitToken(
    IN OUT WCHAR **ppwszIn,
    IN WCHAR *pwcSeparator)
{
    WCHAR *pwszOut = NULL;
    WCHAR *pwszNext = NULL;
    WCHAR *pwszIn;
    WCHAR *pwsz;

    pwszIn = *ppwszIn;
    if (NULL != pwszIn)
    {
	pwszOut = pwszIn;
	pwsz = wcschr(pwszIn, *pwcSeparator);
	if (NULL != pwsz)
	{
	    *pwsz++ = L'\0';
	    pwszNext = pwsz;
	}
    }
    *ppwszIn = pwszNext;
    return(pwszOut);
}


HRESULT
SimplifyCommonName(
    OPTIONAL IN WCHAR const *pwszCommonName,
    OUT WCHAR **ppwszSimpleName)
{
    HRESULT hr;
    WCHAR *pwszDup = NULL;
    WCHAR *pwszRemain;
    WCHAR const *pwszToken;

    *ppwszSimpleName = NULL;

    if (NULL == pwszCommonName)
    {
	pwszCommonName = L"EmptyCN";
    }
    hr = myDupString(pwszCommonName, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    pwszRemain = pwszDup;
    while (TRUE)
    {
	pwszToken = SplitToken(&pwszRemain, wszNAMESEPARATORDEFAULT);
	if (NULL == pwszToken)
	{
	    pwszToken = pwszCommonName;
	    break;
	}
	if (0 != LSTRCMPIS(pwszToken, wszUSERS) &&
	    0 != LSTRCMPIS(pwszToken, wszRECIPIENTS))
	{
	    break;
	}
    }
    hr = mySanitizeName(pwszToken, ppwszSimpleName);
    _JumpIfError(hr, error, "mySanitizeName");

error:
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(hr);
}


WCHAR const *
wszBatchPassword(
    IN DWORD Index,
    OPTIONAL IN WCHAR const *pwszPassword)
{
    static WCHAR wsz0[2 * cwcAUTOPASSWORDMAX + 1];
    static WCHAR wsz1[2 * cwcAUTOPASSWORDMAX + 1];
    WCHAR const *pwszRet;
    WCHAR *pwsz = 0 == Index? wsz0 : wsz1;

    CSASSERT(0 == Index || 1 == Index);
    CSASSERT(ARRAYSIZE(wsz0) == ARRAYSIZE(wsz1));

    if (NULL == pwszPassword)
    {
	SecureZeroMemory(pwsz, sizeof(wsz0));	// password data
	pwszRet = NULL;
    }
    else
    {
	CSASSERT(ARRAYSIZE(wsz0) / 2 >= wcslen(pwszPassword));
	if (NULL == wcschr(pwszPassword, L'%'))
	{
	    pwszRet = pwszPassword;
	}
	else
	{
	    WCHAR const *pwszIn;
	    WCHAR *pwszEnd;

	    pwszIn = pwszPassword;
	    pwszEnd = &pwsz[ARRAYSIZE(wsz0)];
	    pwszRet = pwsz;
	    while (pwsz < pwszEnd && L'\0' != (*pwsz = *pwszIn++))
	    {
		if (L'%' == *pwsz++)
		{
		    *pwsz++ =  L'%';
		}
	    }
	    if (L'\0' != *pwsz)
	    {
		pwszRet = pwszPassword;
	    }
	}
    }
    return(pwszRet);
}


HRESULT
DumpGetRecoverMergeCommandLine(
    OPTIONAL IN BSTR const strConfig,	// NULL -> -RecoverKey command line
    IN BOOL fRecoverKey,
    IN GETKEYSERIAL const *pks,
    OPTIONAL IN WCHAR const *pwszPassword,
    OPTIONAL IN WCHAR const *pwszSuffix,
    OPTIONAL OUT WCHAR **ppwszSimpleName)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    CERT_INFO *pCertInfo;
    BSTR strSerialNumber = NULL;
    WCHAR *pwszSimpleName = NULL;

    if (NULL != ppwszSimpleName)
    {
	*ppwszSimpleName = NULL;
    }
    pcc = CertCreateCertificateContext(
			    X509_ASN_ENCODING,
			    (BYTE const *) pks->strCert,
			    SysStringByteLen(pks->strCert));
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    pCertInfo = pcc->pCertInfo;

    // Convert serial number to string

    hr = MultiByteIntegerToBstr(
			FALSE,
			pCertInfo->SerialNumber.cbData,
			pCertInfo->SerialNumber.pbData,
			&strSerialNumber);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    hr = SimplifyCommonName(pks->strCommonName, &pwszSimpleName);
    _JumpIfError(hr, error, "SimplifyCommonName");

    if (NULL != strConfig)
    {
	wprintf(
	    L"%ws -config \"%ws\" -getkey %ws \"%ws-%ws%ws\"\n\n",
	    g_pwszProg,
	    strConfig,
	    strSerialNumber,
	    pwszSimpleName,
	    strSerialNumber,
	    wszRECSUFFIX);
    }
    else if (fRecoverKey)
    {
	wprintf(
	    L"%ws -p \"%ws\" -recoverkey -user \"%ws-%ws%ws\" \"%ws-%ws%ws\"\n\n",
	    g_pwszProg,
	    wszBatchPassword(0, pwszPassword),
	    pwszSimpleName,
	    strSerialNumber,
	    wszRECSUFFIX,
	    pwszSimpleName,
	    strSerialNumber,
	    wszP12SUFFIX);
	wszBatchPassword(0, NULL);	// password data
    }
    else	// else just print the filename (for -MergePFX or delete)
    {
	wprintf(
	    L"\"%ws-%ws%ws\"",
	    pwszSimpleName,
	    strSerialNumber,
	    pwszSuffix);
    }
    if (NULL != ppwszSimpleName)
    {
	*ppwszSimpleName = pwszSimpleName;
	pwszSimpleName = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != strSerialNumber)
    {
        SysFreeString(strSerialNumber);
    }
    if (NULL != pwszSimpleName)
    {
        LocalFree(pwszSimpleName);
    }
    return(hr);
}


HRESULT
DumpRecoveryCandidate(
    IN GETKEYSERIAL const *pks)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    CERT_INFO *pCertInfo;

    pcc = CertCreateCertificateContext(
			    X509_ASN_ENCODING,
			    (BYTE const *) pks->strCert,
			    SysStringByteLen(pks->strCert));
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    pCertInfo = pcc->pCertInfo;

    hr = cuDumpSerial(g_wszPad2, IDS_SERIAL, &pCertInfo->SerialNumber);
    _JumpIfError(hr, error, "cuDumpSerial");

    hr = cuDisplayCertName(
			FALSE,		// fMultiLine
			g_wszPad2,
			myLoadResourceString(IDS_SUBJECT), // "Subject"
			g_wszPad2,
			&pCertInfo->Subject,
			pCertInfo);
    _JumpIfError(hr, error, "cuDisplayCertName(Subject)");

    if (NULL != pks->strUPN)
    {
	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_UPN_COLON));	// "UPN:"
	wprintf(L"%ws\n", pks->strUPN);
    }

    wprintf(g_wszPad2);
    hr = cuDumpFileTime(IDS_NOTBEFORE, NULL, &pCertInfo->NotBefore);
    _JumpIfError(hr, error, "cuDumpFileTime");

    wprintf(g_wszPad2);
    hr = cuDumpFileTime(IDS_NOTAFTER, NULL, &pCertInfo->NotAfter);
    _JumpIfError(hr, error, "cuDumpFileTime");

    hr = cuDumpCertType(g_wszPad2, pCertInfo);
    _PrintIfError(hr, "cuDumpCertType");

    wprintf(g_wszPad2);
    wprintf(
	myLoadResourceString(IDS_FORMAT_VERSION),	// "Version: %u"
	1 + pks->dwVersion);
    wprintf(wszNewLine);

    wprintf(g_wszPad2);
    hr = cuDisplayHash(NULL, pcc, NULL, CERT_SHA1_HASH_PROP_ID, L"sha1");
    _JumpIfError(hr, error, "cuDisplayHash");

error:
    wprintf(wszNewLine);
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


VOID
DumpRecoveryCommandLines(
    IN GETKEYSERIAL const *pksList,
    IN DWORD dwVersion,
    IN DWORD cCandidate,
    IN WCHAR const *pwszPasswordIntermediate,
    IN WCHAR const *pwszPasswordFinal)
{
    GETKEYSERIAL const *pksT;
    BSTR strConfigT;
    DWORD cPFX;
    WCHAR *pwszSimpleName = NULL;

    strConfigT = NULL;
    wprintf(L"\n@echo ");
    wprintf(
	myLoadResourceString(IDS_FORMAT_RECOVER_VERSIONX_KEYS_COLON), // "Version %u certificates and keys:"
	1 + dwVersion);
    wprintf(wszNewLine);

    // generate certutil -getkey commands:

    for (pksT = pksList; NULL != pksT; pksT = pksT->Next)
    {
	if (NULL != pksT->strConfig)
	{
	    strConfigT = pksT->strConfig;
	}
	if ((CERT_V1 == dwVersion && CERT_V1 == pksT->dwVersion) ||
	    (CERT_V1 != dwVersion && CERT_V1 != pksT->dwVersion))
	{
	    DumpGetRecoverMergeCommandLine(
				strConfigT,
				FALSE,		// fRecoverKey
				pksT,
				NULL,		// pwszPassword
				NULL,		// pwszSuffix
				NULL);		// ppwszSimpleName
	}
    }

    // generate certutil -recoverkey commands:

    for (pksT = pksList; NULL != pksT; pksT = pksT->Next)
    {
	if ((CERT_V1 == dwVersion && CERT_V1 == pksT->dwVersion) ||
	    (CERT_V1 != dwVersion && CERT_V1 != pksT->dwVersion))
	{
	    DumpGetRecoverMergeCommandLine(
				NULL,		// strConfig
				TRUE,		// fRecoverKey
				pksT,
				pwszPasswordIntermediate,
				NULL,		// pwszSuffix
				NULL);		// ppwszSimpleName
	}
    }

    // generate certutil -MergePFX command:

    cPFX = 0;
    wprintf(
	L"%ws -p \"%ws\",\"%ws\" -MergePFX -user ",
	g_pwszProg,
	wszBatchPassword(0, pwszPasswordIntermediate),
	wszBatchPassword(1, CERT_V1 == dwVersion? pwszPasswordIntermediate : pwszPasswordFinal));
    wszBatchPassword(0, NULL);	// password data
    wszBatchPassword(1, NULL);	// password data
    for (pksT = pksList; NULL != pksT; pksT = pksT->Next)
    {
	if ((CERT_V1 == dwVersion && CERT_V1 == pksT->dwVersion) ||
	    (CERT_V1 != dwVersion && CERT_V1 != pksT->dwVersion))
	{
	    if (0 != cPFX)
	    {
		wprintf(L",");
	    }
	    DumpGetRecoverMergeCommandLine(
				NULL,		// strConfig
				FALSE,		// fRecoverKey
				pksT,
				NULL,		// pwszPassword
				wszP12SUFFIX,
				0 == cPFX? &pwszSimpleName : NULL);
	    cPFX++;
	}
    }
    CSASSERT(cCandidate == cPFX);
    wprintf(
	L" \"%ws%ws%ws\"\n\n",
	pwszSimpleName,
	CERT_V1 == dwVersion? wszV1SUFFIX : L"",
	wszP12SUFFIX);

    // generate intermediate file delete commands:

    for (pksT = pksList; NULL != pksT; pksT = pksT->Next)
    {
	if ((CERT_V1 == dwVersion && CERT_V1 == pksT->dwVersion) ||
	    (CERT_V1 != dwVersion && CERT_V1 != pksT->dwVersion))
	{
	    wprintf(L"@del ");
	    DumpGetRecoverMergeCommandLine(
				    NULL,		// strConfig
				    FALSE,		// fRecoverKey
				    pksT,
				    NULL,		// pwszPassword
				    wszRECSUFFIX,
				    NULL);		// ppwszSimpleName
	    wprintf(wszNewLine);
	    wprintf(L"@del ");
	    DumpGetRecoverMergeCommandLine(
				    NULL,		// strConfig
				    FALSE,		// fRecoverKey
				    pksT,
				    NULL,		// pwszPassword
				    wszP12SUFFIX,
				    NULL);		// ppwszSimpleName
	    wprintf(wszNewLine);
	}
    }

    if (CERT_V1 == dwVersion)
    {
	// generate certutil -ConvertEPF command:

	wprintf(
	    L"%ws -p \"%ws,%ws\" -ConvertEPF \"%ws%ws%ws\" \"%ws%ws\"\n",
	    g_pwszProg,
	    wszBatchPassword(0, pwszPasswordIntermediate),
	    wszBatchPassword(1, pwszPasswordFinal),
	    pwszSimpleName,
	    wszV1SUFFIX,
	    wszP12SUFFIX,
	    pwszSimpleName,
	    wszEPFSUFFIX);
	wszBatchPassword(0, NULL);	// password data
	wszBatchPassword(1, NULL);	// password data

	// generate V1 intermediate PFX file delete command:

	wprintf(L"@del ");
	wprintf(
	    L"@delete \"%ws%ws%ws\"\n",
	    pwszSimpleName,
	    wszV1SUFFIX,
	    wszP12SUFFIX);
    }

//error:
    if (NULL != pwszSimpleName)
    {
	LocalFree(pwszSimpleName);
    }
}


HRESULT
cuGenerateOutFilePassword(
    OUT WCHAR **ppwszPassword)
{
    HRESULT hr;
    WCHAR wszPassword[MAX_PATH];

    *ppwszPassword = NULL;
    hr = cuGeneratePassword(
		    1,		// cwcMax (use default length)
		    wszPassword,
		    ARRAYSIZE(wszPassword));
    hr = myDupString(wszPassword, ppwszPassword);
    _JumpIfError(hr, error, "myDupString");

error:
    SecureZeroMemory(wszPassword, sizeof(wszPassword));	// password data
    return(hr);
}


HRESULT
verbGetKey(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszUserNameOrSerialNumber,
    OPTIONAL IN WCHAR const *pwszfnRecoveryBlob,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DISPATCHINTERFACE diConfig;
    BOOL fMustRelease = FALSE;
    WCHAR *pwszCommonName = NULL;
    WCHAR const *pwszRequesterName = NULL;
    WCHAR const *pwszUPN = NULL;
    BSTR strConfig = NULL;
    BSTR strSerialNumber = NULL;
    BYTE *pbHash = NULL;
    DWORD cbHash;
    BSTR strHash = NULL;
    GETKEYSERIAL *pksList = NULL;
    GETKEYSERIAL *pksT;
    DWORD cCandidate;
    DWORD cCandidateV1;
    DWORD cCandidateV3;
    WCHAR *pwszPasswordIntermediate = NULL;
    WCHAR *pwszPasswordFinal = NULL;

    if (NULL == pwszfnRecoveryBlob)
    {
	wprintf(L"\n@goto start\n");
    }
    hr = myMakeSerialBstr(pwszUserNameOrSerialNumber, &strSerialNumber);
    CSASSERT((S_OK != hr) ^ (NULL != strSerialNumber));

    hr = WszToMultiByteInteger(
			    TRUE,
			    pwszUserNameOrSerialNumber,
			    &cbHash,
			    &pbHash);
    _PrintIfError2(hr, "WszToMultiByteInteger", hr);
    if (S_OK == hr)
    {
	hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strHash);
	_JumpIfError(hr, error, "MultiByteIntegerToBstr");
    }
    hr = myDupString(pwszUserNameOrSerialNumber, &pwszCommonName);
    _JumpIfError(hr, error, "myDupString");

    cuConvertEscapeSequences(pwszCommonName);

    if (NULL != wcschr(pwszUserNameOrSerialNumber, L'\\'))
    {
	pwszRequesterName = pwszUserNameOrSerialNumber;
    }
    if (NULL != wcschr(pwszUserNameOrSerialNumber, L'@'))
    {
	pwszUPN = pwszUserNameOrSerialNumber;
    }

    if (NULL == g_pwszConfig)
    {
	LONG i;
	LONG count;
	LONG Index;
	
	hr = Config_Init(g_DispatchFlags, &diConfig);
	_JumpIfError(hr, error, "Config_Init");

	fMustRelease = TRUE;

	hr = Config_Reset(&diConfig, 0, &count);
	_JumpIfError(hr, error, "Config_Reset");

	Index = 0;
	for (i = 0; i < count; i++)
	{
	    hr = Config_Next(&diConfig, &Index);
	    if (S_OK != hr && S_FALSE != hr)
	    {
		_JumpError(hr, error, "Config_Next");
	    }
	    hr = S_OK;
	    if (-1 == Index)
	    {
		break;
	    }

	    hr = Config_GetField(&diConfig, wszCONFIG_CONFIG, &strConfig);
	    _JumpIfError(hr, error, "Config_GetField");

	    hr = GetKey(
		    strConfig,
		    pwszCommonName,
		    pwszRequesterName,
		    pwszUPN,
		    strSerialNumber,
		    strHash,
		    &pksList);
	    _PrintIfError(hr, "GetKey");	// Ignore connection failures
	}
    }
    else
    {
	hr = GetKey(
		g_pwszConfig,
		pwszCommonName,
		pwszRequesterName,
		pwszUPN,
		strSerialNumber,
		strHash,
		&pksList);
	_JumpIfError(hr, error, "GetKey");
    }

    cCandidateV1 = 0;
    cCandidateV3 = 0;
    for (pksT = pksList; NULL != pksT; pksT = pksT->Next)
    {
	if (NULL != pksT->strConfig)
	{
	    wprintf(L"\n\"%ws\"\n", pksT->strConfig);
	}
	hr = DumpRecoveryCandidate(pksT);
	_JumpIfError(hr, error, "DumpRecoveryCandidate");

	if (CERT_V1 == pksT->dwVersion)
	{
	    cCandidateV1++;
	}
	else
	{
	    cCandidateV3++;
	}
    }
    cCandidate = cCandidateV1 + cCandidateV3;
    if (NULL == pwszfnRecoveryBlob && 0 != cCandidate)
    {
	hr = cuGenerateOutFilePassword(&pwszPasswordIntermediate);
	_JumpIfError(hr, error, "cuGenerateOutFilePassword");

	hr = cuGenerateOutFilePassword(&pwszPasswordFinal);
	_JumpIfError(hr, error, "cuGenerateOutFilePassword");

	wprintf(L"\n:start\n");
	if (0 != cCandidateV1)
	{
	    DumpRecoveryCommandLines(
				pksList,
				CERT_V1,
				cCandidateV1,
				pwszPasswordIntermediate,
				pwszPasswordFinal);
	}
	if (0 != cCandidateV3)
	{
	    DumpRecoveryCommandLines(
				pksList,
				CERT_V3,
				cCandidateV3,
				pwszPasswordIntermediate,
				pwszPasswordFinal);
	}
	wprintf(L"@echo PASSWORD: \"%ws\"\n", wszBatchPassword(0, pwszPasswordFinal));
	wszBatchPassword(0, NULL);	// password data
	wprintf(L"\n@goto exit\n");
    }
    if (1 != cCandidate)
    {
	hr = 0 == cCandidate? CRYPT_E_NOT_FOUND : TYPE_E_AMBIGUOUSNAME;
	_JumpError(hr, error, "GetKey");
    }
    hr = GetArchivedKey(
		    pksList->strConfig,
		    pksList->RequestId,
		    pwszfnRecoveryBlob);
    _JumpIfError(hr, error, "GetArchivedKey");

error:
    while (NULL != pksList)
    {
	pksT = pksList;
	pksList = pksList->Next;
	FreeKeySerialEntry(pksT);
    }
    if (fMustRelease)
    {
	Config_Release(&diConfig);
    }
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != pwszPasswordIntermediate)
    {
	myZeroDataString(pwszPasswordIntermediate);	// password data
	LocalFree(pwszPasswordIntermediate);
    }
    if (NULL != pwszPasswordFinal)
    {
	myZeroDataString(pwszPasswordFinal);	// password data
	LocalFree(pwszPasswordFinal);
    }
    if (NULL != pwszCommonName)
    {
	LocalFree(pwszCommonName);
    }
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


VOID
DeleteKey(
    IN CRYPT_KEY_PROV_INFO const *pkpi)
{
    HCRYPTPROV hProv;

    CryptAcquireContext(
		    &hProv,
		    pkpi->pwszContainerName,
		    pkpi->pwszProvName,
		    pkpi->dwProvType,
		    CRYPT_DELETEKEYSET | pkpi->dwFlags);
}


HRESULT
SaveRecoveredKey(
    IN CERT_CONTEXT const *pccUser,
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    OPTIONAL IN WCHAR const *pwszfnPFX,
    OPTIONAL IN WCHAR const *pwszPassword)
{
    HRESULT hr;
    HCERTSTORE hStoreMemory = NULL;
    BOOL fMatchingKey;
    WCHAR wszPassword[MAX_PATH];
    CRYPT_KEY_PROV_INFO kpi;
    CRYPT_DATA_BLOB pfx;
    BOOL fSigningKey;

    pfx.pbData = NULL;
    ZeroMemory(&kpi, sizeof(kpi));

    hr = myValidateKeyBlob(
		    pbKey,
		    cbKey,
		    &pccUser->pCertInfo->SubjectPublicKeyInfo,
		    CERT_V1 == pccUser->pCertInfo->dwVersion,
		    &fSigningKey,
		    &kpi);
    _JumpIfError(hr, error, "myValidateKeyBlob");

    if (!CertSetCertificateContextProperty(
				    pccUser,
				    CERT_KEY_PROV_INFO_PROP_ID,
				    0,
				    &kpi))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertSetCertificateContextProperty");
    }

    hStoreMemory = CertOpenStore(
			    CERT_STORE_PROV_MEMORY,
			    X509_ASN_ENCODING,
			    NULL,
			    0,
			    NULL);
    if (NULL == hStoreMemory)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    // Begin Chain Building

    hr = myAddChainToMemoryStore(hStoreMemory, pccUser, g_dwmsTimeout);
    _JumpIfError(hr, error, "myAddChainToMemoryStore");

    // End Chain Building

    if (NULL != pwszfnPFX)
    {
	hr = cuGetPassword(
			0,		// idsPrompt
			NULL,		// pwszfn
			pwszPassword,
			TRUE,		// fVerify
			wszPassword,
			ARRAYSIZE(wszPassword),
			&pwszPassword);
	_JumpIfError(hr, error, "cuGetPassword");
    }
    hr = myPFXExportCertStore(
		hStoreMemory,
		&pfx,
		pwszPassword,
		!g_fWeakPFX,
		EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY);
    _JumpIfError(hr, error, "myPFXExportCertStore");

    if (NULL != pwszfnPFX)
    {
	hr = EncodeToFileW(
		pwszfnPFX,
		pfx.pbData,
		pfx.cbData,
		CRYPT_STRING_BINARY | (g_fForce? DECF_FORCEOVERWRITE : 0));
	_JumpIfError(hr, error, "EncodeToFileW");
    }

error:
    SecureZeroMemory(wszPassword, sizeof(wszPassword));	// password data
    if (NULL != hStoreMemory)
    {
	CertCloseStore(hStoreMemory, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != kpi.pwszContainerName)
    {
	DeleteKey(&kpi);
	LocalFree(kpi.pwszContainerName);
    }
    if (NULL != pfx.pbData)
    {
	LocalFree(pfx.pbData);
    }
    return(hr);
}


#if DBG_CERTSRV
#define CDWMS	6

VOID
DumpRecoverTime(
    IN char const *pszPrefix,
    IN DWORD *rgdwms,
    IN DWORD idwms)
{
    CSASSERT(0 < idwms);
    CSASSERT(CDWMS > idwms);
    rgdwms[idwms] = GetTickCount();
    DBGPRINT((
	g_fVerbose? DBG_SS_CERTUTIL : DBG_SS_CERTUTILI,
	"RecoverKey[%u]: %hs: %ums/%ums\n",
	idwms,
	pszPrefix,
	rgdwms[idwms] - rgdwms[idwms - 1],
	rgdwms[idwms] - rgdwms[0]));
}
#endif

HRESULT
verbRecoverKey(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnRecoveryBlob,
    OPTIONAL IN WCHAR const *pwszfnPFX,
    OPTIONAL IN WCHAR const *pwszRecipientIndex,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    BYTE *pbIn = NULL;
    DWORD cbIn;
    BYTE *pbEncryptedPKCS7 = NULL;
    DWORD cbEncryptedPKCS7;
    DWORD cSigner;
    DWORD cRecipient;
    DWORD dwMsgType;
    char *pszInnerContentObjId = NULL;
    HCERTSTORE hStore = NULL;
    HCRYPTMSG hMsg = NULL;
    CERT_CONTEXT const *pccUser = NULL;
    BYTE abHashUserCert[CBMAX_CRYPT_HASH_LEN];
    CRYPT_HASH_BLOB BlobHash;
    BYTE *pbKey = NULL;
    DWORD cbKey;
    DWORD RecipientIndex = MAXDWORD;
    DBGCODE(DWORD adwms[CDWMS]);
    DBGCODE(adwms[0] = GetTickCount());

    if (NULL != pwszRecipientIndex)
    {
	hr = myGetLong(pwszRecipientIndex, (LONG *) &RecipientIndex);
	_JumpIfError(hr, error, "RecipientIndex must be a number");
    }

    hr = DecodeFileW(pwszfnRecoveryBlob, &pbIn, &cbIn, CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }

    // Decode outer PKCS 7 signed message, which contains all of the certs.

    hr = myDecodePKCS7(
		    pbIn,
		    cbIn,
		    &pbEncryptedPKCS7,
		    &cbEncryptedPKCS7,
		    &dwMsgType,
		    &pszInnerContentObjId,
		    &cSigner,
		    &cRecipient,
		    &hStore,
		    &hMsg);
    _JumpIfError(hr, error, "myDecodePKCS7(outer)");

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    if (CMSG_SIGNED != dwMsgType)
    {
	_JumpError(hr, error, "dwMsgType(outer)");
    }
    if (0 == cSigner)
    {
	_JumpError(hr, error, "cSigner(outer)");
    }
    if (0 != cRecipient)
    {
	_JumpError(hr, error, "cRecipient(outer)");
    }
    if (NULL == pszInnerContentObjId ||
	0 != strcmp(szOID_RSA_data, pszInnerContentObjId))
    {
	_JumpError(hr, error, "pszInnerContentObjId(outer)");
    }
    CSASSERT(NULL != hMsg);
    ZeroMemory(abHashUserCert, sizeof(abHashUserCert));
    BlobHash.cbData = sizeof(abHashUserCert);
    BlobHash.pbData = abHashUserCert;
    hr = cuDumpSigners(
		    hMsg,
		    pszInnerContentObjId,
		    hStore,
		    cSigner,
		    NULL == pbEncryptedPKCS7,	// fContentEmpty
		    TRUE,			// fVerifyOnly
		    BlobHash.pbData,
		    &BlobHash.cbData);
    _JumpIfError(hr, error, "cuDumpSigners(outer)");

    pccUser = CertFindCertificateInStore(
			hStore,
			X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			0,			// dwFindFlags
			CERT_FIND_HASH,
			&BlobHash,
			NULL);
    if (NULL == pccUser)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertFindCertificateInStore");
    }
    LocalFree(pszInnerContentObjId);
    pszInnerContentObjId = NULL;

    CryptMsgClose(hMsg);
    hMsg = NULL;

    // Decode inner PKCS 7 encrypted message, which contains the private key.

    DBGCODE(DumpRecoverTime("Outer PKCS 7", adwms, 1));

    hr = myDecodePKCS7(
		    pbEncryptedPKCS7,
		    cbEncryptedPKCS7,
		    NULL,			// ppbContents
		    NULL,			// pcbContents
		    &dwMsgType,
		    &pszInnerContentObjId,
		    &cSigner,
		    &cRecipient,
		    NULL,			// phStore
		    &hMsg);
    _JumpIfError(hr, error, "myDecodePKCS7(inner)");

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    if (CMSG_ENVELOPED != dwMsgType)
    {
	_JumpError(hr, error, "dwMsgType(inner)");
    }
    if (0 != cSigner)
    {
	_JumpError(hr, error, "cSigner(inner)");
    }
    if (0 == cRecipient)
    {
	_JumpError(hr, error, "cRecipient(inner)");
    }
    if (NULL == pszInnerContentObjId ||
	0 != strcmp(szOID_RSA_data, pszInnerContentObjId))
    {
	_JumpError(hr, error, "pszInnerContentObjId(inner)");
    }
    CSASSERT(NULL != hMsg);
    if (MAXDWORD != RecipientIndex && cRecipient <= RecipientIndex)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "RecipientIndex too large");
    }

    DBGCODE(DumpRecoverTime("Inner PKCS 7", adwms, 2));
    hr = cuDumpEncryptedAsnBinary(
			    hMsg,
			    cRecipient,
			    RecipientIndex,
			    hStore,
			    NULL,
			    pbEncryptedPKCS7,
			    cbEncryptedPKCS7,
			    TRUE,
			    &pbKey,
			    &cbKey);
    {
	HRESULT hr2;

	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_USER_CERT)); // "User Certificate:"
	wprintf(wszNewLine);

	hr2 = cuDumpIssuerSerialAndSubject(
			    &pccUser->pCertInfo->Issuer,
			    &pccUser->pCertInfo->SerialNumber,
			    &pccUser->pCertInfo->Subject,
			    NULL);		// hStore
	_PrintIfError(hr2, "cuDumpIssuerSerialAndSubject(user)");

	hr2 = cuDisplayHash(
			g_wszPad4,
			pccUser,
			NULL,
			CERT_SHA1_HASH_PROP_ID,
			L"sha1");
	_PrintIfError(hr2, "cuDisplayHash");
    }

    DBGCODE(DumpRecoverTime("Decrypt key", adwms, 3));
    if (CRYPT_E_NO_DECRYPT_CERT != hr)
    {
	_JumpIfError(hr, error, "cuDumpEncryptedAsnBinary");

	if (g_fVerbose)
	{
	    wprintf(wszNewLine);
	    hr = cuDumpPrivateKeyBlob(pbKey, cbKey, FALSE);
	    _JumpIfError(hr, error, "cuDumpPrivateKeyBlob");
	}

	// Verify the key matches the cert, then save in a PFX

	hr = SaveRecoveredKey(
			pccUser,
			pbKey,
			cbKey,
			pwszfnPFX,
			g_pwszPassword);
	_JumpIfError(hr, error, "SaveRecoveredKey");

	DBGCODE(DumpRecoverTime("Save key", adwms, 4));
    }
    else
    {
	// Can't decrypt the private key, list Recipient cert info.

	wprintf(myLoadResourceString(IDS_CANT_DECRYPT)); // "Cannot decrypt message content."
	wprintf(wszNewLine);
	DBGCODE(DumpRecoverTime("nop", adwms, 4));
    }
    if (CRYPT_E_NO_DECRYPT_CERT == hr || NULL == pwszfnPFX)
    {
	HRESULT hrDecrypt = hr;

	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_NEED_RECOVERY_CERT)); // "Key recovery requires one of the following certificates and its private key:"
	wprintf(wszNewLine);

	hr = cuDumpRecipients(hMsg, hStore, cRecipient, TRUE);
	_JumpIfError(hr, error, "cuDumpRecipients");

	hr = hrDecrypt;
	_JumpIfError(hr, error, "Cannot decrypt");
    }
    DBGCODE(DumpRecoverTime("Done", adwms, 5));
    hr = S_OK;

error:
    if (NULL != pccUser)
    {
	CertFreeCertificateContext(pccUser);
    }
    if (NULL != pbKey)
    {
        LocalFree(pbKey);
    }
    if (NULL != pbIn)
    {
        LocalFree(pbIn);
    }
    if (NULL != pbEncryptedPKCS7)
    {
        LocalFree(pbEncryptedPKCS7);
    }
    if (NULL != pszInnerContentObjId)
    {
        LocalFree(pszInnerContentObjId);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\backup.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       backup.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certbcli.h"

#define __dwFILE__	__dwFILE_CERTUTIL_BACKUP_CPP__


HRESULT
verbDynamicFileList(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hr2;
    BOOL fServerOnline;
    HCSBC hcsbc;
    BOOL fBegin = FALSE;
    WCHAR *pwszzFileList = NULL;
    DWORD cbList;
    WCHAR const *pwsz;
    BOOL fImpersonating = FALSE;

    if (!ImpersonateSelf(SecurityImpersonation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ImpersonateSelf");
    }
    fImpersonating = TRUE;

    hr = myEnablePrivilege(SE_BACKUP_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    hr = CertSrvIsServerOnline(g_pwszConfig, &fServerOnline);
    _JumpIfError(hr, error, "CertSrvIsServerOnline");

    //wprintf(L"Cert Server Online -> %d\n", fServerOnline);

    if (!fServerOnline)
    {
	hr = HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
	_JumpError(hr, error, "CertSrvIsServerOnline");
    }

    hr = CertSrvRestorePrepare(g_pwszConfig, 0, &hcsbc);
    _JumpIfError(hr, error, "CertSrvRestorePrepare");

    fBegin = TRUE;

    hr = CertSrvBackupGetDynamicFileList(hcsbc, &pwszzFileList, &cbList);
    _JumpIfError(hr, error, "CertSrvBackupGetDynamicFileList");

    for (pwsz = pwszzFileList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	wprintf(
	    L"%x: %ws\n",
	    SAFE_SUBTRACT_POINTERS((BYTE *) pwsz, (BYTE *) pwszzFileList),
	    pwsz);
    }
    wprintf(L"%x\n", cbList);

error:
    if (fBegin)
    {
	hr2 = CertSrvRestoreEnd(hcsbc);
	_PrintIfError(hr, "CertSrvRestoreEnd");
    }
    if (NULL != pwszzFileList)
    {
	CertSrvBackupFree(pwszzFileList);
    }
    if (fImpersonating)
    {
        myEnablePrivilege(SE_BACKUP_NAME, FALSE);
        RevertToSelf();
    }
    return(hr);
}


HRESULT
verbDatabaseLocations(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hr2;
    BOOL fServerOnline;
    HCSBC hcsbc;
    BOOL fBegin = FALSE;
    WCHAR *pwszzFileList = NULL;
    DWORD cbList;
    WCHAR const *pwsz;
    BOOL fImpersonating = FALSE;

    if (!ImpersonateSelf(SecurityImpersonation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ImpersonateSelf");
    }
    fImpersonating = TRUE;

    hr = myEnablePrivilege(SE_BACKUP_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    hr = CertSrvIsServerOnline(g_pwszConfig, &fServerOnline);
    _JumpIfError(hr, error, "CertSrvIsServerOnline");

    //wprintf(L"Cert Server Online -> %d\n", fServerOnline);

    if (!fServerOnline)
    {
	hr = HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
	_JumpError(hr, error, "CertSrvIsServerOnline");
    }

    hr = CertSrvBackupPrepare(g_pwszConfig, 0, CSBACKUP_TYPE_FULL, &hcsbc);
    _JumpIfError(hr, error, "CertSrvBackupPrepare");

    fBegin = TRUE;

    hr = CertSrvRestoreGetDatabaseLocations(hcsbc, &pwszzFileList, &cbList);
    _JumpIfError(hr, error, "CertSrvRestoreGetDatabaseLocations");

    for (pwsz = pwszzFileList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	wprintf(
	    L"%x: %02x %ws\n",
	    SAFE_SUBTRACT_POINTERS((BYTE *) pwsz, (BYTE *) pwszzFileList),
	    *pwsz,
	    &pwsz[1]);
    }
    wprintf(L"%x\n", cbList);

error:
    if (fBegin)
    {
	hr2 = CertSrvBackupEnd(hcsbc);
	_PrintIfError(hr, "CertSrvBackupEnd");
    }
    if (NULL != pwszzFileList)
    {
	CertSrvBackupFree(pwszzFileList);
    }
    if (fImpersonating)
    {
        myEnablePrivilege(SE_BACKUP_NAME, FALSE);
        RevertToSelf();
    }
    return(hr);
}


DWORD
DBSetFlags(
    IN WCHAR const *pwszType,
    IN OUT DWORD *pFlags)
{
    HRESULT hr;
    
    if (NULL != pwszType)
    {
	if (0 == LSTRCMPIS(pwszType, L"Incremental"))
	{
	    *pFlags |= CDBBACKUP_INCREMENTAL;
	}
	else
	if (0 == LSTRCMPIS(pwszType, L"KeepLog"))
	{
	    *pFlags |= CDBBACKUP_KEEPOLDLOGS;
	}
	else
	{
	    hr = E_INVALIDARG;
	    _JumpError2(hr, error, "bad type", hr);
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
verbBackup(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszType1,
    IN WCHAR const *pwszType2,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD Flags = 0;

    hr = verbBackupPFX(pwszOption, pwszBackupDir, NULL, NULL, NULL);
    _JumpIfError(hr, error, "verbBackupPFX");

    hr = verbBackupDB(pwszOption, pwszBackupDir, pwszType1, pwszType2, NULL);
    _JumpIfError(hr, error, "verbBackupDB");

error:
    return(hr);
}


typedef struct _CUBACKUP
{
    IN DWORD Flags;
    IN WCHAR const *pwszBackupDir;
    OUT DBBACKUPPROGRESS *pdbp;
} CUBACKUP;


DWORD
cuBackupThread(
    OPTIONAL IN OUT VOID *pvparms)
{
    HRESULT hr;
    CUBACKUP *pparms = (CUBACKUP *) pvparms;

    CSASSERT(NULL != pparms);
    hr = myBackupDB(
		g_pwszConfig,
		pparms->Flags,
		pparms->pwszBackupDir,
		pparms->pdbp);
    _JumpIfError(hr, error, "myBackupDB");

error:
    return(hr);
}


DWORD
cuRestoreThread(
    OPTIONAL IN OUT VOID *pvparms)
{
    HRESULT hr;
    CUBACKUP *pparms = (CUBACKUP *) pvparms;

    CSASSERT(NULL != pparms);
    hr = myRestoreDB(
		g_pwszConfig,
		pparms->Flags,
		pparms->pwszBackupDir,
		NULL,
		NULL,
		NULL,
		pparms->pdbp);
    _JumpIfError(hr, error, "myRestoreDB");

error:
    return(hr);
}


VOID
cuBackupRestoreProgress(
    IN BOOL fRestore,
    IN BOOL fIncremental,
    IN BOOL fKeepLogs,
    OPTIONAL IN DBBACKUPPROGRESS const *pdbp)
{
    DWORD id;
    DWORD dw;
    static DWORD s_LastValue;
    static DWORD s_LastState;
    static DWORD s_State;
    static DWORD s_EndState;
    static BOOL s_fDone;

    if (NULL == pdbp)
    {
	s_State = fIncremental? 1 : 0;	// Incremental starts with log files
	s_LastState = s_State - 1;
	s_LastValue = MAXDWORD;

	    // Restore or KeepLogs ends with log files
	s_EndState = (fRestore || fKeepLogs)? 1 : 2;
	s_fDone = FALSE;
    }
    else
    {
	BOOL fPrint;

	switch (s_State)
	{
	    case 0:
		dw = pdbp->dwDBPercentComplete;
		id = fRestore?
		    IDS_RESTOREPROGRESSDB :	// "Restoring Database files"
		    IDS_BACKUPPROGRESSDB;	// "Backing up Database files"
		break;

	    case 1:
		dw = pdbp->dwLogPercentComplete;
		id = fRestore?
		    IDS_RESTOREPROGRESSLOG :	// "Restoring Log files"
		    IDS_BACKUPPROGRESSLOG;	// "Backing up Log files"
		break;

	    default:
		dw = pdbp->dwTruncateLogPercentComplete;
		CSASSERT(!fRestore);
		id = IDS_BACKUPPROGRESSTRUNCATELOG;	// "Truncating Logs"
		break;
	}

	fPrint = s_LastState != s_State || s_LastValue != dw;
#if 0
	if (g_fVerbose)
	{
	    wprintf(
		L"\n%ws %d %3u%% -- %d %3u%% -- %3u %3u %3u%ws",
		fPrint? L"+" : L"-",
		s_LastState,
		s_LastValue,
		s_State,
		dw,
		pdbp->dwDBPercentComplete,
		pdbp->dwLogPercentComplete,
		pdbp->dwTruncateLogPercentComplete,
		fPrint? L"\n" : L"");
	}
#endif
	if (fPrint)
	{
	    wprintf(L"\r%ws: %u%%", myLoadResourceString(id), dw);
	}
	s_LastState = s_State;
	s_LastValue = dw;
	if (!s_fDone && 100 <= dw)
	{
	    wprintf(wszNewLine);
	    if (s_EndState == s_State)
	    {
		s_fDone = TRUE;
	    }
	    else if (s_EndState > s_State)
	    {
		s_State++;
		cuBackupRestoreProgress(
				    fRestore,
				    fIncremental,
				    fKeepLogs,
				    pdbp);
	    }
	}
    }
}


DWORD
cuBackupRestoreDB(
    IN BOOL fRestore,
    IN DWORD Flags,
    IN WCHAR const *pwszBackupDir)
{
    HRESULT hr = S_OK;
    DBBACKUPPROGRESS dbp;
    CUBACKUP parms;
    HANDLE hThread = NULL;
    DWORD ThreadId;
    BOOL fIncremental = 0 != (CDBBACKUP_INCREMENTAL & Flags);
    BOOL fKeepLogs = 0 != (CDBBACKUP_KEEPOLDLOGS & Flags);

    parms.Flags = Flags;
    parms.pwszBackupDir = pwszBackupDir;
    parms.pdbp = &dbp;
    ZeroMemory(&dbp, sizeof(dbp));

    hThread = CreateThread(
			NULL,		// lpThreadAttributes (Security Attr)
			0,		// dwStackSize
			fRestore? cuRestoreThread : cuBackupThread,
			&parms,		// lpParameter
			0,		// dwCreationFlags
			&ThreadId);
    if (NULL == hThread)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CreateThread");
    }

    DBGPRINT((DBG_SS_CERTUTILI, "Backup Thread = %x\n", ThreadId));

    // Wait for the backup thread to return.

    cuBackupRestoreProgress(fRestore, fIncremental, fKeepLogs, NULL);
    while (TRUE)
    {
	hr = WaitForSingleObject(hThread, 500);
	DBGPRINT((DBG_SS_CERTUTILI, "Wait for backup returns %x\n", hr));

	cuBackupRestoreProgress(fRestore, fIncremental, fKeepLogs, &dbp);

	if ((HRESULT) WAIT_OBJECT_0 == hr)
	{
	    // Backup thread returned.

	    if (!GetExitCodeThread(hThread, (DWORD *) &hr))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "GetExitCodeThread");
	    }
	    DBGPRINT((DBG_SS_CERTUTILI, "Backup thread exit: %x\n", hr));
	    _JumpIfError(hr, error, "cuBackupThread");

	    break;	// Backup Thread terminated successfully
	}

	// Wait failed.  Why?

	if ((HRESULT) WAIT_TIMEOUT != hr)
	{
	    _JumpError(hr, error, "WaitForSingleObject");
	}

	// Worker thread still busy.  Wait again...
    }

error:
    DBGPRINT((DBG_SS_CERTUTILI, "cuBackupThread returns %x\n", hr));
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }
    return(hr);
}


HRESULT
verbBackupDB(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszType1,
    IN WCHAR const *pwszType2,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD Flags = 0;

    hr = DBSetFlags(pwszType1, &Flags);
    _JumpIfError(hr, error, "DBSetFlags");

    hr = DBSetFlags(pwszType2, &Flags);
    _JumpIfError(hr, error, "DBSetFlags");

    if (g_fForce)
    {
	Flags |= CDBBACKUP_OVERWRITE;
    }

    wprintf(
	myLoadResourceString(
	    (CDBBACKUP_INCREMENTAL & Flags)?
	     IDS_FORMAT_BACKEDUPDBNOFULL : // "Incremental database backup for %ws."
	     IDS_FORMAT_BACKEDUPDBFULL),   // "Full database backup for %ws."
	    g_pwszConfig);
    wprintf(wszNewLine);

    hr = myBackupDB(g_pwszConfig, (Flags|CDBBACKUP_VERIFYONLY), pwszBackupDir, NULL);
    if (S_OK != hr)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_INVALIDBACKUPDIR), // "Not a valid backup target directory: %ws."
	    pwszBackupDir);
	wprintf(wszNewLine);
	_JumpError(hr, error, "myBackupDB");
    }

    // Perfom the actual backup:

    hr = cuBackupRestoreDB(FALSE, Flags, pwszBackupDir);
    _JumpIfError(hr, error, "cuBackupRestoreDB");


    Flags &= ~CDBBACKUP_OVERWRITE;
    Flags |= CDBBACKUP_VERIFYONLY;

    hr = myRestoreDB(
		g_pwszConfig,
		Flags,
		pwszBackupDir,
		NULL,
		NULL,
		NULL,
		NULL);
    if (S_OK != hr)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_BADBACKUPRESULTS), // "Backup content verification failed: %ws."
	    pwszBackupDir);
	wprintf(wszNewLine);
	_JumpError(hr, error, "myRestoreDB");
    }

    wprintf(
	myLoadResourceString(IDS_FORMAT_BACKEDUPDB), // "Backed up database to %ws."
	pwszBackupDir);
    wprintf(wszNewLine);
    wprintf(
	myLoadResourceString(
	    (CDBBACKUP_KEEPOLDLOGS & Flags)?
	     IDS_FORMAT_BACKEDUPDBKEEP :    // "Database logs were preserved."
	     IDS_FORMAT_BACKEDUPDBNOKEEP)); // "Database logs successfully truncated."
    wprintf(wszNewLine);

error:
    return(hr);
}


// Leave out quotes, commas, backslash

#define wszPASSWORDCHARSETPUNCT \
    L"!#$%&()*+-./:;<=>?@[]^_{|}~"

WCHAR const s_awcPasswordCharSet[] =
    L"0123456789"
    L"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    L"abcdefghijklmnopqrstuvwxyz"
    wszPASSWORDCHARSETPUNCT;

#define cwcPASSWORDCHARSET		WSZARRAYSIZE(s_awcPasswordCharSet)
#define cwcPASSWORDCHARSETALPHANUM	(cwcPASSWORDCHARSET - WSZARRAYSIZE(wszPASSWORDCHARSETPUNCT))

HRESULT
cuGeneratePassword(
    IN DWORD cwcMax,
    OUT WCHAR *pwszPassword,
    IN DWORD cwcPassword)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    BYTE abPassword[cwcAUTOPASSWORDMAX];
    BYTE abIndex[sizeof(abPassword)];
    DWORD i;
    DWORD cwcPunctuation;
    DWORD cwcCharSet;

    if (!CryptAcquireContext(
			&hProv,
			NULL,		// pwszContainer
			NULL,		// pwszProvName
			PROV_RSA_FULL,
			CRYPT_VERIFYCONTEXT))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }
    if (1 == cwcMax || sizeof(abPassword) < cwcMax)
    {
	cwcMax = sizeof(abPassword);
    }
    CSASSERT(sizeof(abPassword) < cwcPassword);
    if (cwcMax > cwcPassword)
    {
	cwcMax = cwcPassword;
    }
    if (!CryptGenRandom(hProv, cwcMax, abPassword))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGenRandom");
    }
    if (!CryptGenRandom(hProv, cwcMax, abIndex))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGenRandom");
    }

    // Generate at most min(1, cwcMax / 8) punctuation characters.

    cwcCharSet = cwcPASSWORDCHARSET;
    cwcPunctuation = cwcMax / 8;
    ZeroMemory(pwszPassword, sizeof(WCHAR) * (1 + cwcMax));  // initialization, not clearing it out
    for (i = 0; i < cwcMax; i++)
    {
	DWORD iwc = abPassword[i] % cwcCharSet;
	DWORD itgt = abIndex[i] % cwcMax;

	CSASSERT(wcslen(pwszPassword) < cwcMax);
	while (L'\0' != pwszPassword[itgt])
	{
	    if (++itgt == cwcMax)
	    {
		itgt = 0;
	    }
	}

	pwszPassword[itgt] = s_awcPasswordCharSet[iwc];
	if (cwcPASSWORDCHARSETALPHANUM <= iwc)
	{
	    if (0 < cwcPunctuation)
	    {
		cwcPunctuation--;
	    }
	    if (0 == cwcPunctuation)
	    {
		cwcCharSet = cwcPASSWORDCHARSETALPHANUM;
	    }
	}
    }
    hr = S_OK;

error:
    SecureZeroMemory(abPassword, sizeof(abPassword));	// password data
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
cuGetPasswordString(
    IN LONG idMsg,
    OUT WCHAR *pwszPassword,
    IN DWORD cwcPassword)
{
    HRESULT hr;
    WCHAR *pwsz;
    WCHAR *pwszLast;
    LONG wc;
    HANDLE hConsole;
    DWORD InputMode = FILE_TYPE_UNKNOWN;
    DWORD ConsoleMode;

    // Prompt for password, making sure password isn't echoed.
    // If the stdin is redirected, don't bother querying/changing console mode.

    wprintf(L"%ws ", myLoadResourceString(idMsg));
    fflush(stdout);

    hConsole = GetStdHandle(STD_INPUT_HANDLE);
    if (INVALID_HANDLE_VALUE != hConsole)
    {
	InputMode = GetFileType(hConsole);
	if (FILE_TYPE_CHAR == InputMode)
	{
	    GetConsoleMode(hConsole, &ConsoleMode);
	    SetConsoleMode(
		    hConsole,
		    ~ENABLE_ECHO_INPUT & ConsoleMode);
		    //~(ENABLE_ECHO_INPUT | ENABLE_LINE_INPUT) & ConsoleMode);
	}
    }

    pwsz = pwszPassword;
    pwszLast = &pwsz[cwcPassword - 1];

    while (TRUE)
    {
	wc = _fgetwchar();

	if (WEOF == wc || L'\r' == wc || L'\n' == wc)
	{
	    break;
	}
	if (L'\b' == wc)
	{
	    if (pwsz == pwszPassword)
	    {
		continue;	// don't backup buffer or console display
	    }
	    pwsz--;
	}
	else
	{
	    if (pwsz >= pwszLast)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
		goto error;
	    }
	    *pwsz++ = (WCHAR) wc;
	    wc = L'*';
	}
	//_fputwchar((WCHAR) wc);
	//fflush(stdout);
    }
    CSASSERT(&pwszPassword[cwcPassword] > pwsz);
    *pwsz = L'\0';
    hr = S_OK;

error:
    if (FILE_TYPE_CHAR == InputMode)
    {
	SetConsoleMode(hConsole, ConsoleMode);
    }
    wprintf(wszNewLine);
    return(hr);
}


HRESULT
cuGetPassword(
    OPTIONAL IN UINT idsPrompt,
    OPTIONAL IN WCHAR const *pwszfn,
    OPTIONAL IN WCHAR const *pwszPasswordIn,
    IN BOOL fVerify,
    OUT WCHAR *pwszPasswordBuf,
    IN DWORD cwcPasswordBuf,
    OUT WCHAR const **ppwszPasswordOut)
{
    HRESULT hr;
    WCHAR wszPassword2[MAX_PATH];

    CSASSERT(ARRAYSIZE(wszPassword2) == cwcPasswordBuf);
    if (NULL != pwszPasswordIn && 0 != wcscmp(L"*", pwszPasswordIn))
    {
	if (fVerify &&
	    L'?' == *pwszPasswordIn &&
	    L'\0' == pwszPasswordIn[wcsspn(pwszPasswordIn, L"?")])
	{
	    hr = cuGeneratePassword(
				wcslen(pwszPasswordIn),
				pwszPasswordBuf,
				cwcPasswordBuf);
	    _JumpIfError(hr, error, "cuGeneratePassword");

	    wprintf(L"PASSWORD: \"%ws\"\n", pwszPasswordBuf);
	    *ppwszPasswordOut = pwszPasswordBuf;
	}
	else
	{
	    *ppwszPasswordOut = pwszPasswordIn;
	}
    }
    else
    {
	if (0 != idsPrompt)
	{
	    wprintf(myLoadResourceString(idsPrompt), pwszfn);
	    wprintf(wszNewLine);
	}
	while (TRUE)
	{
	    hr = cuGetPasswordString(
			    fVerify? IDS_NEWPASSWORDPROMPT : IDS_PASSWORDPROMPT,
			    pwszPasswordBuf,
			    cwcPasswordBuf);
	    _JumpIfError(hr, error, "cuGetPasswordString");

	    if (!fVerify)
	    {
		break;
	    }

	    hr = cuGetPasswordString(
			    IDS_CONFIRMPASSWORDPROMPT,
			    wszPassword2,
			    ARRAYSIZE(wszPassword2));
	    _JumpIfError(hr, error, "cuGetPasswordString");

	    if (0 == wcscmp(pwszPasswordBuf, wszPassword2))
	    {
		break;
	    }
	    wprintf(myLoadResourceString(IDS_NOCONFIRMPASSWORD));
	    wprintf(wszNewLine);
	}
	*ppwszPasswordOut = pwszPasswordBuf;
    }
    hr = S_OK;

error:
    SecureZeroMemory(wszPassword2, sizeof(wszPassword2));	// password data
    return(hr);
}


HRESULT
cuGetLocalCANameFromConfig(
    OPTIONAL OUT WCHAR **ppwszMachine,
    OPTIONAL OUT WCHAR **ppwszCA)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwsz;
    WCHAR *pwszMachine = NULL;
    WCHAR *pwszCA = NULL;

    if (NULL != ppwszCA)
    {
	*ppwszCA = NULL;
    }

    pwsz = wcschr(g_pwszConfig, L'\\');
    if (NULL == pwsz)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad config string");
    }

    cwc = SAFE_SUBTRACT_POINTERS(pwsz, g_pwszConfig);
    pwszMachine = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszMachine)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    CopyMemory(pwszMachine, g_pwszConfig, cwc * sizeof(WCHAR));
    pwszMachine[cwc] = L'\0';
    if (0 != mylstrcmpiL(pwszMachine, g_pwszDnsName) &&
	0 != mylstrcmpiL(pwszMachine, g_pwszOldName))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "config string not local");
    }
    pwsz++;
    cwc = wcslen(pwsz);

    if (NULL != ppwszCA)
    {
	pwszCA = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszCA)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwszCA, pwsz);
    }

    if (NULL != ppwszMachine)
    {
	*ppwszMachine = pwszMachine;
	pwszMachine = NULL;
    }
    if (NULL != ppwszCA)
    {
	*ppwszCA = pwszCA;
	pwszCA = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszMachine)
    {
    	LocalFree(pwszMachine);
    }
    if (NULL != pwszCA)
    {
	LocalFree(pwszCA);
    }
    return(hr);
}


HRESULT
verbBackupPFX(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR const *pwszPassword;
    WCHAR wszPassword[MAX_PATH];
    WCHAR *pwszMachine = NULL;
    WCHAR *pwszCA = NULL;
    WCHAR *pwszPFXFileOut = NULL;

    hr = cuGetLocalCANameFromConfig(&pwszMachine, &pwszCA);
    _JumpIfError(hr, error, "cuGetLocalCANameFromConfig");

    hr = cuGetPassword(
		    0,			// idsPrompt
		    NULL,		// pwszfn
		    g_pwszPassword,
		    TRUE,		// fVerify
		    wszPassword,
		    ARRAYSIZE(wszPassword),
		    &pwszPassword);
    _JumpIfError(hr, error, "cuGetPassword");

    hr = myCertServerExportPFX(
			pwszCA,
			pwszBackupDir,
			pwszPassword,
			!g_fWeakPFX,	// fEnhancedStrength
			g_fForce,	// fForceOverWrite
                        TRUE, 		// fMustExportPrivateKeys
			g_dwmsTimeout,
			&pwszPFXFileOut);
    _JumpIfError(hr, error, "myCertServerExportPFX");

    wprintf(
	myLoadResourceString(IDS_FORMAT_BACKEDUP), // "Backed up keys and certificates for %ws\\%ws to %ws."
	pwszMachine,
	pwszCA,
	pwszPFXFileOut);
    wprintf(wszNewLine);

error:
    SecureZeroMemory(wszPassword, sizeof(wszPassword));	// password data
    if (NULL != pwszPFXFileOut)
    {
	LocalFree(pwszPFXFileOut);
    }
    if (NULL != pwszMachine)
    {
	LocalFree(pwszMachine);
    }
    if (NULL != pwszCA)
    {
	LocalFree(pwszCA);
    }
    return(hr);
}


HRESULT
verbRestore(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = verbRestorePFX(pwszOption, pwszBackupDir, NULL, NULL, NULL);
    _JumpIfError(hr, error, "verbRestorePFX");

    hr = verbRestoreDB(pwszOption, pwszBackupDir, NULL, NULL, NULL);
    _JumpIfError(hr, error, "verbRestoreDB");

error:
    return(hr);
}


HRESULT
verbRestoreDB(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD Flags;

    hr = cuGetLocalCANameFromConfig(NULL, NULL);
    _JumpIfError(hr, error, "cuGetLocalCANameFromConfig");

    wprintf(
	myLoadResourceString(IDS_FORMAT_RESTOREDB), // "Restoring database for %ws."
	g_pwszConfig);
    wprintf(wszNewLine);

    Flags = CDBBACKUP_VERIFYONLY;
    if (g_fForce)
    {
	Flags |= CDBBACKUP_OVERWRITE;
    }
    while (TRUE)
    {
	hr = myRestoreDB(
		    g_pwszConfig,
		    Flags,
		    pwszBackupDir,
		    NULL,
		    NULL,
		    NULL,
		    NULL);
	if (S_OK == hr)
	{
	    break;
	}
	if (!(CDBBACKUP_INCREMENTAL & Flags))
	{
	    Flags |= CDBBACKUP_INCREMENTAL;
	    continue;
	}
	wprintf(
	    myLoadResourceString(IDS_FORMAT_INVALIDRESTOREDIR), // "Not a valid backup directory: %ws."
	    pwszBackupDir);
	wprintf(wszNewLine);
	_JumpError(hr, error, "myRestoreDB");
    }

    Flags &= ~CDBBACKUP_VERIFYONLY;


    // Perfom the actual restore:

    hr = cuBackupRestoreDB(TRUE, Flags, pwszBackupDir);
    _JumpIfError(hr, error, "cuBackupRestoreDB");


    wprintf(
	myLoadResourceString(
	    (CDBBACKUP_INCREMENTAL & Flags)?
	     IDS_FORMAT_RESTOREDDBNOFULL : // "Incremental database restore for %ws."
	     IDS_FORMAT_RESTOREDDBFULL),   // "Full database restore for %ws."
	    g_pwszConfig);
    wprintf(wszNewLine);

    wprintf(
	myLoadResourceString(IDS_FORMAT_RESTORE_NEEDS_RESTART), // "Stop and Start the Certificate Server to complete database restore from %ws."
	pwszBackupDir);
    wprintf(wszNewLine);

error:
    return(hr);
}


HRESULT
verbRestorePFX(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupDirOrPFXFile,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR const *pwszPassword;
    WCHAR wszPassword[MAX_PATH];
    WCHAR *pwszCommonName = NULL;
    WCHAR *pwszPFXFile = NULL;

    hr = cuGetPassword(
		    0,			// idsPrompt
		    NULL,		// pwszfn
		    g_pwszPassword,
		    FALSE,		// fVerify
		    wszPassword,
		    ARRAYSIZE(wszPassword),
		    &pwszPassword);
    _JumpIfError(hr, error, "cuGetPassword");

    hr = myCertServerImportPFX(
			    pwszBackupDirOrPFXFile,
			    pwszPassword,
			    g_fForce,
			    &pwszCommonName,
			    &pwszPFXFile,
			    NULL);
    if (!g_fForce && HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_USE_FORCE), // "Certificate or key exists.  Use the %ws option to overwrite."
	    L"-f");
	wprintf(wszNewLine);
    }
    _JumpIfError(hr, error, "myCertServerImportPFX");

    wprintf(
	myLoadResourceString(IDS_FORMAT_RESTORED), // "Restored keys and certificates for %ws\\%ws from %ws."
	g_pwszDnsName,
	pwszCommonName,
	pwszPFXFile);
    wprintf(wszNewLine);

error:
    SecureZeroMemory(wszPassword, sizeof(wszPassword));	// password data
    if (NULL != pwszPFXFile)
    {
	LocalFree(pwszPFXFile);
    }
    if (NULL != pwszCommonName)
    {
	LocalFree(pwszCommonName);
    }
    return(hr);
}


// #define DO_VECTOR_TEST

HRESULT
verbMACFile(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszBackupFile,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    CAutoLPWSTR pwszMAC;

    hr = myComputeMAC(pwszBackupFile, &pwszMAC);
    _JumpIfError(hr, error, "myComputeMAC");

    wprintf(
	myLoadResourceString(IDS_FORMAT_HASHFILEOUTPUT), // "SHA-1 hash of file %ws:"
	pwszBackupFile);
    wprintf(wszNewLine);
    wprintf(L"%ws\n", pwszMAC);

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certreqd\certreqd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 2001
//
//  File:       certreqd.cpp
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <stdio.h>

#include <certsrv.h>
#include <certreqd.h>

#include <locale.h>
#include <io.h>
#include <fcntl.h>

EXTERN_C const CLSID CLSID_CCertRequestD;

#define WM_DOCERTREQDMAIN		WM_USER+0

WCHAR const wszAppName[] = L"CertReqDApp";
WCHAR const *g_pwszProg = L"CertReqD";
HINSTANCE g_hInstance;

#define cmdNONE			MAXDWORD
#define cmdPING			0

#define _PrintIfError(hr, pszFunc) \
    if (S_OK != (hr)) wprintf(L"certreqd.cpp(%u): %hs: 0x%x\n", __LINE__, (pszFunc), (hr))


HRESULT
OpenDComConnection(
    IN WCHAR const *pwszConfig,
    IN CLSID const *pclsid,
    IN IID const *piid,
    OUT WCHAR const **ppwszAuthority,
    OUT IUnknown **ppUnknown)
{
    HRESULT hr;
    WCHAR *pwsz;
    WCHAR *pwszServerName = NULL;
    DWORD cwc;
    COSERVERINFO ComponentInfo;
    MULTI_QI mq;
    WCHAR *pwcDot = NULL;

    mq.pItf = NULL;
    if (NULL == pwszConfig ||
	NULL == pclsid ||
	NULL == piid ||
	NULL == ppwszAuthority ||
	NULL == ppUnknown)
    {
	hr = E_POINTER;
	_PrintIfError(hr, "NULL parm");
	goto error;
    }
    *ppwszAuthority = NULL;
    *ppUnknown = NULL;

    // Allow UNC-style config strings: \\server\CaName

    while (L'\\' == *pwszConfig)
    {
	pwszConfig++;
    }
    pwsz = wcschr(pwszConfig, L'\\');
    if (NULL == pwsz)
    {
        cwc = wcslen(pwszConfig);
	*ppwszAuthority = &pwszConfig[cwc];
    }
    else
    {
        cwc = (DWORD) (ULONG_PTR) (pwsz - pwszConfig);
	*ppwszAuthority = &pwsz[1];
    }
    pwszServerName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszServerName)
    {
	hr = E_OUTOFMEMORY;
	_PrintIfError(hr, "LocalAlloc");
	goto error;
    }
    CopyMemory(pwszServerName, pwszConfig, cwc * sizeof(WCHAR));
    pwszServerName[cwc] = L'\0';

    if (0 < cwc && L'.' == pwszServerName[cwc - 1])
    {
        pwszServerName[cwc - 1] = L'\0';
        cwc--;
    }

    ZeroMemory(&ComponentInfo, sizeof(COSERVERINFO));
    ComponentInfo.pwszName = pwszServerName;
    //ComponentInfo.pAuthInfo = NULL;

    mq.pIID = piid;
    mq.pItf = NULL;
    mq.hr = S_OK;

    while (TRUE)
    {
	hr = CoCreateInstanceEx(
			    *pclsid,
			    NULL,
			    CLSCTX_SERVER,
			    &ComponentInfo,
			    1,
			    &mq);
	_PrintIfError(hr, "CoCreateInstanceEx");

	if (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr &&
	    0 < cwc &&
	    L'.' == pwszServerName[cwc - 1])
	{
	    pwcDot = &pwszServerName[cwc - 1];
	    *pwcDot = L'\0';
	    continue;
	}
	break;
    }
    if (NULL != pwcDot)
    {
	*pwcDot = L'.';
    }
    _PrintIfError(hr, "CoCreateInstanceEx");
    if (S_OK != hr)
    {
	goto error;
    }

    hr = CoSetProxyBlanket(
		mq.pItf,
		RPC_C_AUTHN_DEFAULT,    // use NT default security
		RPC_C_AUTHZ_DEFAULT,    // use NT default authentication
		COLE_DEFAULT_PRINCIPAL,
		RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, // call
		RPC_C_IMP_LEVEL_IMPERSONATE,
		NULL,
		EOAC_STATIC_CLOAKING);
    _PrintIfError(hr, "CoSetProxyBlanket");
    if (S_OK != hr)
    {
	goto error;
    }
    *ppUnknown = mq.pItf;
    mq.pItf = NULL;
    hr = S_OK;

error:
    if (NULL != pwszServerName)
    {
	LocalFree(pwszServerName);
    }
    if (NULL != mq.pItf)
    {
        mq.pItf->Release();
    }
    return(hr);
}
 

HRESULT
OpenRequestDComConnection(
    IN WCHAR const *pwszConfig,
    OUT WCHAR const **ppwszAuthority,
    OUT ICertRequestD2 **ppICertRequestD)
{
    HRESULT hr;

    hr = OpenDComConnection(
			pwszConfig,
			&CLSID_CCertRequestD,
			&IID_ICertRequestD2,
			ppwszAuthority,
			(IUnknown **) ppICertRequestD);
    _PrintIfError(hr, "OpenDComConnection");

//error:
    return(hr);
}


HRESULT
PingCA(
    IN WCHAR const *pwszConfig)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    ICertRequestD2 *pICertRequestD = NULL;
    CERTTRANSBLOB ctbCAAuthName;
    CERTTRANSBLOB ctbCADNS;
    CERTTRANSBLOB ctbCAInfo;
    CAINFO CAInfo;
    DWORD cb;

    ctbCAAuthName.pb = NULL;
    ctbCADNS.pb = NULL;
    ctbCAInfo.pb = NULL;

    hr = OpenRequestDComConnection(pwszConfig, &pwszAuthority, &pICertRequestD);
    _PrintIfError(hr, "OpenRequestDComConnection");
    if (S_OK != hr)
    {
	goto error;
    }

    __try
    {
	hr = pICertRequestD->Ping(pwszAuthority);
    }
    __except(
	hr = (GetExceptionInformation())->ExceptionRecord->ExceptionCode,
	EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _PrintIfError(hr, "Ping");
    if (S_OK != hr)
    {
	goto error;
    }
    wprintf(L"CA is responding\n");


    __try
    {
	hr = pICertRequestD->GetCAProperty(
				    pwszAuthority,
				    CR_PROP_CANAME,
				    0,		// PropIndex
				    PROPTYPE_STRING,
				    &ctbCAAuthName);
    }
    __except(
	hr = (GetExceptionInformation())->ExceptionRecord->ExceptionCode,
	EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _PrintIfError(hr, "GetCAProperty");
    if (S_OK != hr)
    {
	goto error;
    }
    pwszAuthority = (WCHAR const *) ctbCAAuthName.pb;
    wprintf(L"CA name = %ws\n", pwszAuthority);


    __try
    {
	hr = pICertRequestD->GetCAProperty(
				    pwszAuthority,
				    CR_PROP_DNSNAME,
				    0,		// PropIndex
				    PROPTYPE_STRING,
				    &ctbCADNS);
    }
    __except(
	hr = (GetExceptionInformation())->ExceptionRecord->ExceptionCode,
	EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _PrintIfError(hr, "GetCAProperty");
    if (S_OK != hr)
    {
	goto error;
    }
    wprintf(L"DNS name = %ws\n", (WCHAR const *) ctbCADNS.pb);


    __try
    {
	hr = pICertRequestD->GetCAProperty(
				    pwszAuthority,
				    CR_PROP_CATYPE,
				    0,		// PropIndex
				    PROPTYPE_LONG,
				    &ctbCAInfo);
    }
    __except(
	hr = (GetExceptionInformation())->ExceptionRecord->ExceptionCode,
	EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _PrintIfError(hr, "GetCAProperty");
    if (S_OK != hr)
    {
	goto error;
    }
    wprintf(L"Fetched CAInfo\n");

    ZeroMemory(&CAInfo, sizeof(CAInfo));
    cb = sizeof(CAInfo);
    if (cb > ctbCAInfo.cb)
    {
	cb = ctbCAInfo.cb;
    }
    CopyMemory(&CAInfo, ctbCAInfo.pb, cb);
    wprintf(L"CAType = %u\n", CAInfo.CAType);
    wprintf(L"cCASignatureCerts = %u\n", CAInfo.cCASignatureCerts);
    wprintf(L"cCAExchangeCerts = %u\n", CAInfo.cCAExchangeCerts);
    wprintf(L"cExitModules = %u\n", CAInfo.cExitModules);
    wprintf(L"lPropIdMax = %u\n", CAInfo.lPropIdMax);
    wprintf(L"lRoleSeparationEnabled = %u\n", CAInfo.lRoleSeparationEnabled);
    wprintf(L"cKRACertUsedCount = %u\n", CAInfo.cKRACertUsedCount);
    wprintf(L"cKRACertCount = %u\n", CAInfo.cKRACertCount);
    wprintf(L"fAdvancedServer = %u\n", CAInfo.fAdvancedServer);   
    hr = S_OK;

error:
    if (NULL != ctbCAAuthName.pb)
    {
        CoTaskMemFree(ctbCAAuthName.pb);
    }
    if (NULL != ctbCADNS.pb)
    {
        CoTaskMemFree(ctbCADNS.pb);
    }
    if (NULL != ctbCAInfo.pb)
    {
        CoTaskMemFree(ctbCAInfo.pb);
    }
    if (NULL != pICertRequestD)
    {
        pICertRequestD->Release();
    }
    return(hr);
}


HRESULT
PrintErrorMessageText(
    IN HRESULT hrMsg)
{
    HRESULT hr;
    ICertRequest2 *pReq = NULL;
    BSTR strError = NULL;

    hr = CoCreateInstance(
                CLSID_CCertRequest,
                NULL,               // pUnkOuter
                CLSCTX_INPROC_SERVER,
                IID_ICertRequest2,
                (VOID **) &pReq);
    _PrintIfError(hr, "CoCreateInstance");
    if (S_OK != hr)
    {
	goto error;
    }

    hr = pReq->GetErrorMessageText(
			    hrMsg,
			    S_OK == hr? 0 : CR_GEMT_HRESULT_STRING,
			    &strError);
    _PrintIfError(hr, "GetErrorMessageText");
    if (S_OK == hr)
    {
	wprintf(L"%ws: %ws\n", g_pwszProg, strError);
    }

error:
    if (NULL != strError)
    {
	SysFreeString(strError);
    }
    if (NULL != pReq)
    {
	pReq->Release();
    }
    return(hr);
}


HRESULT
ArgvMain(
    int argc,
    WCHAR *argv[],
    HWND hWndOwner)
{
    HRESULT hr;
    DWORD cmd = cmdNONE;
    DWORD cArgAllowed = 0;
	
    while (1 < argc &&
	(L'-' == argv[1][0] || L'/' == argv[1][0]) &&
	L'\0' != argv[1][1])
    {
	if (0 == _wcsicmp(&argv[1][1], L"ping"))
	{
	    cmd = cmdPING;
	    cArgAllowed = 1;
	}
	else
	{
	    //Usage(NULL);
	    hr = E_INVALIDARG;
	    _PrintIfError(hr, "bad command");
	    goto error;
	}
	argc--;
	argv++;
    }
    if (argc != cArgAllowed + 1)
    {
	hr = E_INVALIDARG;
	_PrintIfError(hr, "arg count");
	goto error;
    }

    switch (cmd)
    {
	case cmdPING:
	    hr = PingCA(argv[1]);
	    _PrintIfError(hr, "PingCA");
	    break;

	default:
	    hr = E_INVALIDARG;
	    _PrintIfError(hr, "missing command");
	    break;
    }

error:
    return(hr);
}


//**************************************************************************
//  FUNCTION:	CertReqDPreMain
//  NOTES:	Takes an LPSTR command line and chews it up into argc/argv form
//		so that it can be passed on to a traditional C style main.
//**************************************************************************

#define ISBLANK(wc)	(L' ' == (wc) || L'\t' == (wc))

HRESULT 
CertReqDPreMain(
    IN WCHAR const *pwszCmdLine,
    IN HWND hWndOwner)
{
    HRESULT hr;
    BOOL fCoInit = FALSE;
    WCHAR *pbuf = NULL;
    WCHAR *apszArg[20];
    int cArg = 0;
    WCHAR *p;
    WCHAR const *pchQuote;
    int carg;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
	_PrintIfError(hr, "CoInitialize");
	goto error;
    }
    fCoInit = TRUE;

    pbuf = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszCmdLine) + 1) * sizeof(WCHAR));
    if (NULL == pbuf)
    {
	hr = E_OUTOFMEMORY;
	_PrintIfError(hr, "LocalAlloc");
	goto error;
    }
    p = pbuf;

    apszArg[cArg++] = TEXT("CertReqD");
    while (*pwszCmdLine != TEXT('\0'))
    {
	while (ISBLANK(*pwszCmdLine))
	{
	    pwszCmdLine++;
	}
	if (*pwszCmdLine != TEXT('\0'))
	{
	    apszArg[cArg++] = p;
	    if (sizeof(apszArg)/sizeof(apszArg[0]) <= cArg)
	    {
		hr = E_INVALIDARG;
		_PrintIfError(hr, "too many args");
		goto error;
	    }
	    pchQuote = NULL;
	    while (*pwszCmdLine != L'\0')
	    {
		if (NULL != pchQuote)
		{
		    if (*pwszCmdLine == *pchQuote)
		    {
			pwszCmdLine++;
			pchQuote = NULL;
			continue;
		    }
		}
		else
		{
		    if (ISBLANK(*pwszCmdLine))
		    {
			break;
		    }
		    if (L'"' == *pwszCmdLine)
		    {
			pchQuote = pwszCmdLine++;
			continue;
		    }
		}
		*p++ = *pwszCmdLine++;
	    }
	    *p++ = TEXT('\0');
	    if (*pwszCmdLine != TEXT('\0'))
	    {
		pwszCmdLine++;	// skip whitespace or quote character
	    }
	}
    }
    apszArg[cArg] = NULL;

    hr = ArgvMain(cArg, apszArg, hWndOwner);
    _PrintIfError(hr, "ArgvMain");
    goto error;

error:
    PrintErrorMessageText(hr);
    if (NULL != pbuf)
    {
	LocalFree(pbuf);
    }
    if (fCoInit)
    {
	CoUninitialize();
    }
    return(hr);
}


//**************************************************************************
//  FUNCTION:	MainWndProc(...)
//  ARGUMENTS:
//**************************************************************************

LRESULT APIENTRY
MainWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    LRESULT lr = 0;
    WCHAR *pwszCmdLine;

    switch (msg)
    {
        case WM_CREATE:
        case WM_SIZE:
	    break;

        case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

        case WM_DOCERTREQDMAIN:
	    pwszCmdLine = (WCHAR *) lParam;
	    hr = CertReqDPreMain(pwszCmdLine, hWnd);
	    PostQuitMessage(hr);
	    break;

        default:
	    lr = DefWindowProc(hWnd, msg, wParam, lParam);
	    break;
    }
    return(lr);
}


//+------------------------------------------------------------------------
//
//  Function:	wWinMain()
//
//  Synopsis:	Entry Point
//
//  Arguments:	[hInstance]	--	Instance handle
//		[hPrevInstance] --	Obsolete
//		[pwszCmdLine]	--	App command line
//		[nCmdShow]	--	Starting show state
//
//  History:	12/07/96	JerryK	Added this Comment
//
//-------------------------------------------------------------------------

extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR pwszCmdLine,
    int nCmdShow)
{
    MSG msg;
    WNDCLASS wcApp;
    HWND hWndMain;

    _setmode(_fileno(stdout), _O_TEXT);
    _wsetlocale(LC_ALL, L".OCP");

    // Save the current instance
    g_hInstance = hInstance;

    // Set up the application's window class
    wcApp.style		= 0;
    wcApp.lpfnWndProc	= MainWndProc;
    wcApp.cbClsExtra	= 0;
    wcApp.cbWndExtra	= 0;
    wcApp.hInstance	= hInstance;
    wcApp.hIcon		= LoadIcon(NULL, IDI_APPLICATION);
    wcApp.hCursor	= LoadCursor(NULL, IDC_ARROW);
    wcApp.hbrBackground	= (HBRUSH)GetStockObject(WHITE_BRUSH);
    wcApp.lpszMenuName	= NULL;
    wcApp.lpszClassName	= wszAppName;

    if (!RegisterClass(&wcApp))
    {
	return(FALSE);
    }

    // Create Main Window
    hWndMain = CreateWindow(
			wszAppName,
			L"CertReqD Application",
			WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT, CW_USEDEFAULT,
			CW_USEDEFAULT, CW_USEDEFAULT,
			NULL,
			NULL,
			hInstance,
			NULL);
    if (NULL == hWndMain)
    {
	return(FALSE);
    }

    // Make window visible
    // ShowWindow(hWndMain, nCmdShow);

    // Update window client area
    UpdateWindow(hWndMain);

    // Send off the message to get things started
    PostMessage(hWndMain, WM_DOCERTREQDMAIN, 0, (LPARAM) pwszCmdLine);

    // Message Loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    }
    return((int) msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\cast3.h ===
/******************************************************************************
 *			C A S T 3   S Y M M E T R I C   C I P H E R
 *		Copyright (c) 1995 Northern Telecom Ltd. All rights reserved.
 ******************************************************************************
 *
 * FILE:		cast3.h
 *
 * AUTHOR(S):	R.T.Lockhart, Dept. 9C42, BNR Ltd.
 *				C. Adams, Dept 9C21, BNR Ltd.
 *
 * DESCRIPTION:	CAST3 header file. This file defines the interface for the
 *   CAST3 symmetric-key encryption/decryption code. This code supports key
 *   lengths from 8 to 64 bits in multiples of 8.
 *
 * To use this CAST3 code:
 * Allocate a CAST3_CTX context structure, then set up a key schedule using
 * CAST3SetKeySchedule. Then do encryption, decryption or MAC calculations
 * using that same context. When finished, you may optionally call CAST3Cleanup
 * which zeroizes the context so as not to leave security-critical data in
 * memory.
 *
 * To encrypt/decrypt in Cipher Block Chaining (CBC) mode:
 * Call CAST3StartEncryptCBC, passing in a pointer to the 8-byte Initialization
 * Vector (IV). Then call CAST3UpdateEncryptCBC to encrypt your data. You may
 * call CAST3UpdateEncryptCBC any number of times to encrypt successive chunks
 * of data. When done, call CAST3EndEncryptCBC which applies data padding and
 * outputs any remaining ciphertext. To decrypt, follow a similar procedure
 * using CAST3StartDecryptCBC, CAST3UpdateDecryptCBC, and CAST3EndEncryptCBC.
 *
 * To calculate a MAC:
 * Call CAST3StartMAC, passing in a pointer to the 8-byte Initialization
 * Vector (IV). Then call CAST3UpdateMAC to update the MAC calculation session.
 * You may call CAST3UpdateMAC any number of times to process successive chunks
 * of data. When done, call CAST3EndMAC to end the session. At this point, the
 * MAC resides in the CAST3_CTX.cbcBuffer.asBYTE array.
 *
 * Error handling:
 * Most functions return an int that indicates the success or failure of the
 * operation. See the C3E #defines for a list of error conditions.
 *	
 * Data size assumptions: 	BYTE	- unsigned 8 bits
 *				UINT32	- unsigned 32 bits
 *
 *****************************************************************************/
 
#ifndef CAST3_H
#define CAST3_H

#include <skconfig.h>	/* Algorithm configuration */

/* Define this at compile time to use assembly optimization where possible */
#define CAST3_ASSEMBLY_LANGUAGE

/* Misc defs */
#define	CAST3_BLK_SIZE		 8			/* Basic block size, in bytes */
#define CAST3_MAX_KEY_NBITS	 64			/* Maximum key length, in bits */
#define CAST3_MAX_KEY_NBYTES (CAST3_MAX_KEY_NBITS / 8)
#define CAST3_NUM_ROUNDS	 12			/* Number of rounds */
#define CAST3_LEN_DELTA		 8			/* Output data space = input + this */

/* CAST3 return codes. Negative denotes error. */
#define	C3E_OK				 0			/* No error */
#define	C3E_DEPAD_FAILURE	-1			/* The de-padding operation failed */
#define C3E_BAD_KEYLEN		-2			/* Key length not supported */
#define C3E_SELFTEST_FAILED	-3			/* Self-test failed */
#define C3E_NOT_SUPPORTED	-4			/* Function not supported */

/*******************************************************************************
 *						D A T A   D E F I N I T I O N S
 ******************************************************************************/
 
/* CAST3 Block
 * Forces block to be 32-bit aligned but allows both 32-bit and byte access.
 */
typedef union {
	BYTE	asBYTE[CAST3_BLK_SIZE];
	UINT32	as32[2];
} CAST3_BLOCK;

/* CAST3 Context
 * Stores context information for encryption, decryption, and MACs.
 */
typedef struct {
	UINT32		 schedule[CAST3_NUM_ROUNDS * 2];/* Key schedule (subkeys) */
	CAST3_BLOCK	 inBuffer;						/* Input buffer */
	unsigned int inBufferCount;					/* Number of bytes in inBuffer */
	CAST3_BLOCK	 lastDecBlock;					/* Last decrypted block */
	BOOL		 lastBlockValid;				/* TRUE if lastDecBlock has valid data */
	CAST3_BLOCK	 cbcBuffer;						/* Cipher Block Chaining buffer & MAC */
} CAST3_CTX;

/*******************************************************************************
 *					F U N C T I O N   P R O T O T Y P E S
 ******************************************************************************/
 
extern "C" {
/* Sets up CAST3 key schedules, given a variable length key. Key length must
 * be a multiple of 8 bits, from 8 to CAST3_MAX_KEY_NBITS.
 */
int CAST3SetKeySchedule(
	CAST3_CTX	* context,		/* Out: CAST3 context */
	const BYTE	* key,			/* In: CAST3 key */
	unsigned int  keyNumBits	/* Key length in bits */
);

/* Encrypts one 8-byte block in ECB mode and produces one 8-byte block
 * of ciphertext.
 */
int CAST3EncryptOneBlock(
	const CAST3_CTX	* context,	/* In: CAST3 context */
	const BYTE		* inData,	/* In: 8-byte input block to encrypt */
	BYTE			* outData	/* Out: 8-byte output block */
);

/* Decrypts one 8-byte block in ECB mode and produces one 8-byte block
 * of plaintext.
 */
void CAST3DecryptOneBlock(
	const CAST3_CTX	* context,	/* In: CAST3 context */
	const BYTE		* inData,	/* In: 8-byte input block to decrypt */
	BYTE			* outData	/* Out: 8-byte output block */
);

/* Starts an encryption session in CBC mode with the given IV.
 */
int CAST3StartEncryptCBC(
	CAST3_CTX		* context,	/* In/out: CAST3 context */
	const BYTE		* iv		/* In: 8-byte CBC IV */
);

/* Encrypts a variable amount of data in CBC mode and outputs the corresponding
 * ciphertext. Set len equal to the length of inData. If the input is a multiple
 * of the blocksize (8), then the output will be equal to the size of the input;
 * otherwise it will be the closest multiple of 8, either higher or lower than
 * the input size, depending on leftovers from the last pass. To be safe, supply
 * a ptr to an output buffer of size at least (inData length + CAST3_LEN_DELTA).
 * Upon return, len is set to the actual length of output data, but may wrap if
 * inData length > UINT_MAX - CAST3_LEN_DELTA.
 */

int CAST3UpdateEncryptCBC(
	CAST3_CTX	* context,	/* In/out: CAST3 context */
	const BYTE	* inData,	/* In: Data to encrypt */
	BYTE		* outData,	/* Out: Encrypted data */
	unsigned int	* len		/* In/out: Data length, in bytes */
);

/* Ends an encryption session in CBC mode. Applies RFC1423 data padding and
 * outputs a final buffer of ciphertext. Supply a ptr to an output buffer at
 * least CAST3_LEN_DELTA bytes long. Upon return, len is set to the actual length
 * of output data (currently, this is always 8).
 */
int CAST3EndEncryptCBC(
	CAST3_CTX		* context,	/* In/out: CAST3 context */
	BYTE			* outData,	/* Out: Final encrypted data */
	unsigned int	* len		/* Out: Length of outData, in bytes */
);

/* Starts a decryption session in CBC mode with the given IV.
 */
void CAST3StartDecryptCBC(
	CAST3_CTX		* context,	/* In/out: CAST3 context */
	const BYTE		* iv		/* In: 8-byte CBC IV */
);

/* Decrypts a variable amount of data in CBC mode and outputs the corresponding
 * plaintext. Set len equal to the length of inData. Supply a ptr to an output
 * buffer of at least (inData length + CAST3_LEN_DELTA) bytes. Upon return, len
 * is set to the actual length of output data.
 */
void CAST3UpdateDecryptCBC(
	CAST3_CTX	* context,	/* In/out: CAST3 context */
	const BYTE	* inData,	/* In: Data to decrypt */
#ifdef FOR_CSP
        BOOL              fLastBlock,   /* In: Is this the last block? */
#endif // FOR_CSP
	BYTE		* outData,	/* Out: Decrypted data */
	unsigned int	* len		/* In/out: Data length, in bytes */
);

/* Ends a decryption session in CBC mode. Removes RFC1423 data padding and
 * outputs a final buffer of plaintext. Supply a ptr to an output buffer at least
 * CAST3_LEN_DELTA bytes long. Upon return, len is set to the actual length of
 * output data.
 */
int CAST3EndDecryptCBC(
	CAST3_CTX		* context,	/* In/out: CAST3 context */
	BYTE			* outData,	/* Out: Final decrypted data */
	unsigned int	* len		/* Out: Length of outData */
);

/* Starts a MAC calculation session using the given IV.
 */
int CAST3StartMAC(
	CAST3_CTX		* context,	/* In/out: CAST3 context */
	const BYTE		* iv		/* In: 8-byte CBC IV */
);

/* Updates a MAC calculation session for the supplied data.
 */
int CAST3UpdateMAC(
	CAST3_CTX		* context,	/* In/out: CAST3 context */
	const BYTE		* inData,	/* In: Data to calculate MAC on */
	unsigned int	  len		/* Input data length, in bytes */
);

/* Ends a MAC calculation session. Upon return, the CAST3_CTX.cbcBuffer array
 * contains the MAC. An N-byte MAC is the first N bytes of this array.
 */
int CAST3EndMAC(
	CAST3_CTX		* context	/* In/out: CAST3 context */
);

/* Zeroizes the CAST3_CTX so as not to leave sensitive security parameters
 * around in memory.
 */
void CAST3Cleanup(
	CAST3_CTX		* context	/* Out: CAST3 context to cleanup */
);

/* Runs a known-answer self-test on CAST3. Returns C3E_OK if the test passes
 * or C3E_SELFTEST_FAILED if it fails.
 */
int CAST3SelfTest( void );

/* Checks the specified key length for a valid value. Returns C3E_OK if it is
 * valid or C3E_BAD_KEYLEN if not.
 */
int CAST3CheckKeyLen( unsigned int keyNumBits );

}

#endif /* CAST3_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\certdb2.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certdb2.h
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define _JET_RED_

#ifdef _JET_RED_
# define JETREDSELECT(jetbluearg, jetredarg)	jetredarg
# define JETREDPARM(jetredarg)			jetredarg,
#endif // _JET_RED_

// from old certdb.h
#define	TABLE_NAMES	( 0 )
#define	TABLE_REQUESTS	( 1 )
#define	TABLE_CERTIFICATES	( 2 )
#define	TABLE_REQUEST_ATTRIBS	( 3 )
#define	TABLE_EXTENSIONS	( 4 )
#define	MAX_EXTENSION_NAME	( 50 )

#define	DBTF_POLICYWRITEABLE	( 0x1 )
#define	DBTF_INDEXPRIMARY	( 0x2 )
#define	DBTF_INDEXREQUESTID	( 0x4 )


// stolen from misc .h files
#define szREGDBDSN		"DBDSN"
#define szREGDBUSER		"DBUser"
#define szREGDBPASSWORD		"DBPassword"

#define wszREGDBDSN		TEXT(szREGDBDSN)
#define wszREGDBUSER		TEXT(szREGDBUSER)
#define wszREGDBPASSWORD	TEXT(szREGDBPASSWORD)

//======================================================================
// Full path to "CertSvc\Queries":
#define wszREGKEYQUERIES	wszREGKEYCERTSVCPATH TEXT("\\Queries")


//======================================================================
// Values Under "CertSvc\Queries\<QueryNumber>":
#define szREGDBSQL		"SQL"

#define wszREGDBSQL		TEXT(szREGDBSQL)

#define wszREGKEYDEFAULTCONFIG     TEXT("DefaultConfiguration")
#define wszREGKEYDIRECTORY TEXT("ConfigurationDirectory")
#define wszREGKEYENABLED   TEXT("Enabled")
#define wszREGCONTAINERNAME     TEXT("KeySetName")


#define CR_FLG_NOTELETEX       0x00000000
#define CR_FLG_FORCETELETEX    0x00000001
#define CR_FLG_RENEWAL         0x00000002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\crcutil.cpp ===
#include <pch.cpp>

#pragma hdrstop

/*
 * $Header:   /entproj/all/base/etfile/crcutil.c_v   1.3   Wed Dec 07 15:05:18 1994   markbc  $
 * $Log:   /entproj/all/base/etfile/crcutil.c_v  $
 * 
 *    Rev 1.3   Wed Dec 07 15:05:18 1994   markbc
 * Alpha port checkin
 * 
 *    Rev 1.2   19 Oct 1994 15:44:26   chucker
 * Synced up headers with the code.
 * 
 *    Rev 1.1   18 Aug 1994 15:09:00   DILKIE
 * 
 *    Rev 1.0   11 Aug 1994 10:11:36    JackK
 * Initial file check in
 */

/***********************************************************************
* CRC utility routines for general 16 and 32 bit CRCs.
*
* 1990  Gary P. Mussar
* This code is released to the public domain. There are no restrictions,
* however, acknowledging the author by keeping this comment around
* would be appreciated.
***********************************************************************/
//#include "strcore.h"
#include <crcutil.h>

/***********************************************************************
* Utilities for fast CRC using table lookup
*
* CRC calculations are performed one byte at a time using a table lookup
* mechanism.  Two routines are provided: one to initialize the CRC table;
* and one to perform the CRC calculation over an array of bytes.
*
* A CRC is the remainder produced by dividing a generator polynomial into
* a data polynomial using binary arthimetic (XORs). The data polynomial
* is formed by using each bit of the data as a coefficient of a term in
* the polynomial. These utilities assume the data communications ordering
* of bits for the data polynomial, ie. the LSB of the first byte of data
* is the coefficient of the highest term of the polynomial, etc..
*
* I_CRCxx  -  Initialize the 256 entry CRC lookup table based on the
*             specified generator polynomial.
* Input:
*    Table[256]     - Lookup table
*    *GenPolynomial - Pointer to generator polynomial
*
* F_CRCxx  -  Calculate CRC over an array of characters using fast
*             table lookup.
* Input:
*    Table[256]    - Lookup table
*    *CRC          - Pointer to the variable containing the result of
*                    CRC calculations of previous characters. The CRC
*                    variable must be initialized to a known value
*                    before the first call to this routine.
*    *dataptr      - Pointer to array of characters to be included in
*                    the CRC calculation.
*    count         - Number of characters in the array.
***********************************************************************/

void I_CRC16(	CRC16 Table[256],
		CRC16 *GenPolynomial )
{
   int i;
   CRC16 crc, poly;

   for (poly=*GenPolynomial, i=0; i<256; i++) {
       crc = (CRC16) i;
       crc = (CRC16) ((crc >> 1) ^ ((crc & 1) ? poly : 0));
       crc = (CRC16) ((crc >> 1) ^ ((crc & 1) ? poly : 0));
       crc = (CRC16) ((crc >> 1) ^ ((crc & 1) ? poly : 0));
       crc = (CRC16) ((crc >> 1) ^ ((crc & 1) ? poly : 0));
       crc = (CRC16) ((crc >> 1) ^ ((crc & 1) ? poly : 0));
       crc = (CRC16) ((crc >> 1) ^ ((crc & 1) ? poly : 0));
       crc = (CRC16) ((crc >> 1) ^ ((crc & 1) ? poly : 0));
       crc = (CRC16) ((crc >> 1) ^ ((crc & 1) ? poly : 0));

       Table[i] = crc;
   }
}

void I_CRC32(	CRC32 Table[256],
		CRC32 *GenPolynomial )
{
   int i;
   CRC32 crc, poly;

   for (poly=*GenPolynomial, i=0; i<256; i++)
   {
      crc = (CRC32) i;
      crc = (crc >> 1) ^ ((crc & 1) ? poly : 0);
      crc = (crc >> 1) ^ ((crc & 1) ? poly : 0);
      crc = (crc >> 1) ^ ((crc & 1) ? poly : 0);
      crc = (crc >> 1) ^ ((crc & 1) ? poly : 0);
      crc = (crc >> 1) ^ ((crc & 1) ? poly : 0);
      crc = (crc >> 1) ^ ((crc & 1) ? poly : 0);
      crc = (crc >> 1) ^ ((crc & 1) ? poly : 0);
      crc = (crc >> 1) ^ ((crc & 1) ? poly : 0);

      Table[i] = crc;
   }
}

void F_CRC16(	CRC16 Table[256],
		CRC16 *CRC,
		const void *dataptr,
		unsigned int count   )
{
   CRC16 temp_crc;
   unsigned char *p;

   p = (unsigned char *)dataptr;

   for (temp_crc = *CRC; count; count--) {
       temp_crc = (CRC16) ((temp_crc >> 8) ^ Table[(temp_crc & 0xff) ^ *p++]);
   }

   *CRC = temp_crc;
}

void F_CRC32(	CRC32 Table[256],
		CRC32 *CRC,
		const void  *dataptr,
		unsigned int count    )
{
   CRC32 temp_crc;
   unsigned char *p;

   p = (unsigned char *)dataptr;

   for (temp_crc = *CRC; count; count--)
   {
      temp_crc = (temp_crc >> 8) ^ Table[(temp_crc & 0xff) ^ *p++];
   }

   *CRC = temp_crc;
}

/***********************************************************************
* Utility CRC using slower, smaller non-table lookup method
*
* S_CRCxx  -  Calculate CRC over an array of characters using slower but
*             smaller non-table lookup method.
* Input:
*    GenPolynomial - Generator polynomial
*    *CRC          - Pointer to the variable containing the result of
*                    CRC calculations of previous characters. The CRC
*                    variable must be initialized to a known value
*                    before the first call to this routine.
*    *dataptr      - Pointer to array of characters to be included in
*                    the CRC calculation.
*    count         - Number of characters in the array.
***********************************************************************/
void S_CRC16(	CRC16 *GenPolynomial,
		CRC16 *CRC,
		const void *dataptr,
		unsigned int count   )
{
   int i;
   CRC16 temp_crc, poly;
   unsigned char *p;

   p = (unsigned char *)dataptr;

   for (poly=*GenPolynomial, temp_crc = *CRC; count; count--)
   {
      temp_crc ^= *p++;
      for (i=0; i<8; i++) {
         temp_crc = (CRC16) ((temp_crc >> 1) ^ ((temp_crc & 1) ? poly : 0));
      }
   }

   *CRC = temp_crc;
}

void S_CRC32(	CRC32 *GenPolynomial,
		CRC32 *CRC,
		const void *dataptr,
		unsigned int count   )
{
   int i;
   CRC32 temp_crc, poly;
   unsigned char *p;

   p = (unsigned char *)dataptr;

   for (poly=*GenPolynomial, temp_crc = *CRC; count; count--)
   {
	  temp_crc ^= *p++;
      for (i=0; i<8; i++)
      {
         temp_crc = (temp_crc >> 1) ^ ((temp_crc & 1) ? poly : 0);
      }
   }

   *CRC = temp_crc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\certutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certutil.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <setupapi.h>
#include <locale.h>
#include <io.h>
#include <fcntl.h>
#include <ntverp.h>
#include <common.ver>
#include "ocmanage.h"
#include "initcert.h"
#include <winldap.h>
#include "csldap.h"
#include "setupids.h"
#include "clibres.h"
#include "csresstr.h"

#define __dwFILE__	__dwFILE_CERTUTIL_CERTUTIL_CPP__

#define WM_DOCERTUTILMAIN		WM_USER+0

WCHAR const wszAppName[] = L"CertUtilApp";
WCHAR const *g_pwszProg = L"CertUtil";
HINSTANCE g_hInstance;

BOOL g_fIDispatch = FALSE;
BOOL g_fEnterpriseRegistry = FALSE;
BOOL g_fUserRegistry = FALSE;
BOOL g_fUserTemplates = FALSE;
BOOL g_fMachineTemplates = FALSE;
BOOL g_fNoCR = FALSE;
BOOL g_fFullUsage = FALSE;
BOOL g_fReverse = FALSE;
BOOL g_fForce = FALSE;
BOOL g_fVerbose = FALSE;
BOOL g_fGMT = FALSE;
BOOL g_fSeconds = FALSE;
DWORD g_DispatchFlags;
BOOL g_fQuiet = FALSE;
BOOL g_fCryptSilent = FALSE;
BOOL g_fV1Interface = FALSE;
BOOL g_fSplitASN = FALSE;
BOOL g_fAdminInterface = FALSE;
BOOL g_fProtect = FALSE;
BOOL g_fWeakPFX = FALSE;
BOOL g_fURLFetch = FALSE;
DWORD g_EncodeFlags;
DWORD g_CryptEncodeFlags;

DWORD g_dwmsTimeout = 0;

WCHAR *g_pwszConfig = NULL;		// Don't free this one!
WCHAR *g_pwszConfigAlloc = NULL;	// Free this one instead!
WCHAR *g_pwszDC = NULL;
WCHAR *g_pwszOut = NULL;
WCHAR *g_pwszPassword = NULL;
WCHAR *g_pwszCSP = NULL;
WCHAR *g_pwszRestrict = NULL;
WCHAR *g_pwszDnsName = NULL;
WCHAR *g_pwszOldName = NULL;
WCHAR *g_pwszmsTimeout = NULL;

WCHAR const g_wszEmpty[] = L"";
WCHAR const g_wszPad2[] = L"  ";
WCHAR const g_wszPad4[] = L"    ";
WCHAR const g_wszPad6[] = L"      ";
WCHAR const g_wszPad8[] = L"        ";
WCHAR const wszNewLine[] = L"\n";

UINT g_uiExtraErrorInfo = 0;

CRITICAL_SECTION g_DBCriticalSection;

#define CCOL_VERB	16
#define CCOL_OPTIONBARE	16
#define CCOL_OPTIONARG	24

#define AF_ZERO			0
#define AF_NEEDCOINIT		0x00000001
#define AF_ACTIVECONFIG		0x00000002	// CA must be running
#define AF_PRIVATE		0x00000004	// Undocumented, untested
#define AF_OPTIONALCONFIG	0x00000008
#define AF_RESTARTSERVER	0x00000010
#define AF_STOPATMINUSSIGNARG	0x00000020	// no more '-xxx' args
#define AF_STOPATMINUSSIGN	0x00000040	// no more '-' args

#define AF_OPTION_TIMEOUT	0x00000080
#define AF_OPTION_URLFETCH	0x00000100
#define AF_OPTION_CSP		0x00000200
#define AF_OPTION_PROTECT	0x00000400
#define AF_OPTION_WEAKPFX	0x00000800
#define AF_OPTION_DC		0x00001000
#define AF_OPTION_PASSWORD	0x00002000
#define AF_OPTION_ADMIN		0x00004000
#define AF_OPTION_CONFIG	0x00008000
#define AF_OPTION_ENTERPRISE	0x00010000
#define AF_OPTION_FORCE		0x00020000
#define AF_OPTION_GMT		0x00040000
#define AF_OPTION_IDISPATCH	0x00080000
#define AF_OPTION_MT		0x00100000
#define AF_OPTION_NOCR		0x00200000
#define AF_OPTION_OUT		0x00400000
#define AF_OPTION_RESTRICT	0x00800000
#define AF_OPTION_REVERSE	0x01000000
#define AF_OPTION_SECONDS	0x02000000
#define AF_OPTION_SILENT	0x04000000
#define AF_OPTION_SPLIT		0x08000000
#define AF_OPTION_USER		0x10000000
#define AF_OPTION_UT		0x20000000
#define AF_OPTION_V1		0x40000000
#define AF_OPTION_VERBOSE	0x80000000

#define AF_OPTION_GENERIC	(AF_OPTION_SECONDS | AF_OPTION_GMT | AF_OPTION_VERBOSE)
#define AF_OPTION_MASK		0xffffff80

typedef struct _ARG
{
    WCHAR const *pwszArg;
    int		 idsDescription;
    int		 idsUsage;
    int		 idsArgDescription;
    int          cArgMin;
    int          cArgMax;
    DWORD	 Flags;
    BOOL        *pBool;
    WCHAR      **ppString;
    FNVERB      *pfnVerb;
    WCHAR const	* const *papwszUsageConstants;
    WCHAR const	*pwszUsage;
    WCHAR const	*pwszDescription;
} ARG;

WCHAR const g_wszCACert[] = L"ca.cert";
WCHAR const g_wszCAChain[] = L"ca.chain";
WCHAR const g_wszGetCRL[] = L"GetCRL";
WCHAR const g_wszCAInfo[] = L"CAInfo";

WCHAR const g_wszSchema[] = L"schema";
WCHAR const g_wszEncode[] = L"encode";
WCHAR const g_wszEncodeHex[] = L"encodehex";
WCHAR const g_wszViewDelStore[] = L"viewdelstore";

WCHAR const *g_papwszUsageDeleteRow[] =
    { L"Request", L"Cert", L"Ext", L"Attrib", L"CRL", NULL };

WCHAR const *g_papwszUsageCRL[] = { L"republish", L"delta", NULL };
WCHAR const *g_papwszUsageGetCRL[] = { L"delta", NULL };
WCHAR const *g_papwszUsageSchema[] = { L"Ext", L"Attrib", L"CRL", NULL };
WCHAR const *g_papwszUsageView[] =
 { L"Queue", L"Log", L"LogFail", L"Revoked", L"Ext", L"Attrib", L"CRL", NULL };

WCHAR const *g_papwszUsageBackup[] = { L"Incremental", L"KeepLog", NULL };
WCHAR const *g_papwszUsageDSPublish[] =
    { L"NTAuthCA", L"RootCA", L"SubCA", L"CrossCA", L"KRA", L"User", L"Machine", L"-f", NULL };

WCHAR const *g_papwszUsageDCInfo[] =
    { L"Verify", L"DeleteBad", L"DeleteAll", NULL };

WCHAR const *g_papwszUsageGetCert[] = { L"ERA", L"KRA", NULL };
WCHAR const *g_papwszUsageDelete[] = { L"delete", NULL };

WCHAR const *g_papwszUsageURLCache[] =
    { L"CRL", L"*", L"delete", L"-f", NULL };

WCHAR const *g_papwszUsageGetSetReg[] =
    { L"ca", L"restore", L"policy", L"exit", L"template", L"ProgId", NULL };

WCHAR g_wszDefaultLangId[cwcDWORDSPRINTF];
WCHAR const *g_papwszUsageOIDName[] =
    { L"delete", g_wszDefaultLangId, L"-f", NULL };

WCHAR const *g_papwszUsageConvertEPF[] = { L"cast", L"cast-", NULL };

WCHAR const *g_papwszUsageRevokeCertificate[] =
{
     L"CRL_REASON_UNSPECIFIED",
     L"CRL_REASON_KEY_COMPROMISE",
     L"CRL_REASON_CA_COMPROMISE",
     L"CRL_REASON_AFFILIATION_CHANGED",
     L"CRL_REASON_SUPERSEDED",
     L"CRL_REASON_CESSATION_OF_OPERATION",
     L"CRL_REASON_CERTIFICATE_HOLD",
     L"CRL_REASON_REMOVE_FROM_CRL",
     L"Unrevoke",
     NULL
};

WCHAR const *g_papwszUsageMinusf[] = { L"-f", NULL };

WCHAR const *g_papwszUsageRenew[] = { L"ReuseKeys", L"-f", NULL };


WCHAR const *g_papwszUsageStore[] = {
    /* %1 */	L"My",
    /* %2 */	L"CA",
    /* %3 */	L"Root",
    /* %4 */	L"-enterprise",
    /* %5 */	L"-user",
    /* %6 */	L"-enterprise NTAuth",
    /* %7 */	L"-enterprise Root 37",
    /* %8 */	L"-user My 26e0aaaf000000000004",
    /* %9 */	L"CA .11",
    /* %10 */	g_wszEmpty,	// View Root Certificates URL
    /* %11 */	g_wszEmpty,	// Modify Root Certificates URL
    /* %12 */	g_wszEmpty,	// View CRLs
    /* %13 */	g_wszEmpty,	// Enterprise CA Certificates URL
    		NULL
};


typedef struct _CUURLTEMPLATE {
    WCHAR const *pwszFmtPrefix;
    WCHAR const *pwszAttribute;
    WCHAR const **ppwszUsageLocation;
} CUURLTEMPLATE;

CUURLTEMPLATE g_aURLTemplates[] = {
    {
	L"ldap:///CN=Certification Authorities",
	wszDSSEARCHAIACERTATTRIBUTE,
	&g_papwszUsageStore[10 - 1],
    },
    {
	L"ldap:///CN=%ws,CN=Certification Authorities",
	wszDSSEARCHCACERTATTRIBUTE,
	&g_papwszUsageStore[11 - 1],
    },
    {
	L"ldap:///CN=%ws,CN=%ws,CN=CDP",
	wszDSSEARCHBASECRLATTRIBUTE,
	&g_papwszUsageStore[12 - 1],
    },
    {
	L"ldap:///CN=NTAuthCertificates",
	L"",
	&g_papwszUsageStore[13 - 1],
    },
};


VOID
PatchStoreArgDescription()
{
    HRESULT hr;
    DWORD i;
    WCHAR const *pwszCAName = myLoadResourceString(IDS_CANAME);
    WCHAR const *pwszMachineName = myLoadResourceString(IDS_MACHINENAME);
    WCHAR const *pwszDCName = L"DC=...";
    WCHAR const wszFmtURL[] = L"%ws,CN=Public Key Services,CN=Services,CN=Configuration,%ws%ws";
    WCHAR *pwszPrefix = NULL;
    BSTR strDomainDN = NULL;
    LDAP *pld = NULL;
    static BOOL fFirst = TRUE;

    if (fFirst)
    {
	fFirst = FALSE;

	hr = myLdapOpen(NULL, 0, &pld, &strDomainDN, NULL);
	_PrintIfError2(hr, "myLdapOpen", hr);
	if (S_OK == hr && NULL != strDomainDN)
	{
	    pwszDCName = strDomainDN;
	}

	for (i = 0; i < ARRAYSIZE(g_aURLTemplates); i++)
	{
	    DWORD cwc;
	    WCHAR *pwsz = NULL;

	    if (NULL != pwszPrefix)
	    {
		LocalFree(pwszPrefix);
		pwszPrefix = NULL;
	    }
	    cwc = wcslen(g_aURLTemplates[i].pwszFmtPrefix) +
		wcslen(pwszCAName) +
		wcslen(pwszMachineName);

	    pwszPrefix = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwc + 1) * sizeof(WCHAR));
	    if (NULL == pwszPrefix)
	    {
		_PrintError(E_OUTOFMEMORY, "LocalAlloc");
		continue;
	    }
	    
	    _snwprintf(
		    pwszPrefix,
		    cwc,
		    g_aURLTemplates[i].pwszFmtPrefix,
		    pwszCAName,
		    pwszMachineName);
	    pwszPrefix[cwc] = L'\0';

	    cwc += ARRAYSIZE(wszFmtURL) +
		wcslen(pwszDCName) +
		wcslen(g_aURLTemplates[i].pwszAttribute);

	    pwsz = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwc + 1) * sizeof(WCHAR));
	    if (NULL == pwsz)
	    {
		_PrintError(E_OUTOFMEMORY, "LocalAlloc");
	    }

	    _snwprintf(
		    pwsz,
		    cwc,
		    wszFmtURL,
		    pwszPrefix,
		    pwszDCName,
		    g_aURLTemplates[i].pwszAttribute);
	    pwsz[cwc] = L'\0';

	    *g_aURLTemplates[i].ppwszUsageLocation = pwsz;
	}
	if (NULL != pwszPrefix)
	{
	    LocalFree(pwszPrefix);
	}
	myLdapClose(pld, strDomainDN, NULL);
    }
}


VOID
FreeStoreArgDescription()
{
    DWORD i;

    for (i = 0; i < ARRAYSIZE(g_aURLTemplates); i++)
    {
	if (NULL != *g_aURLTemplates[i].ppwszUsageLocation &&
	    g_wszEmpty != *g_aURLTemplates[i].ppwszUsageLocation)
	{
	    LocalFree(const_cast<WCHAR *>(*g_aURLTemplates[i].ppwszUsageLocation));
	}
    }
}


#define pargDEFAULT	(&aarg[0])	// Default to first entry
ARG aarg[] =
{
    {				// In first position to be the default
	L"dump",		// pwszArg
	IDS_DUMP_DESCRIPTION,	// "dump configuration information or files"
	IDS_DUMP_USAGEARGS,	// "[File]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_TIMEOUT | AF_OPTION_PASSWORD | AF_OPTION_SPLIT | AF_OPTION_IDISPATCH | AF_OPTION_FORCE | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDump,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"decodehex",		// pwszArg
	IDS_DECODEHEX_DESCRIPTION, // "Decode hexadecimal-encoded file"
	IDS_INFILEOUTFILE_USAGEARGS, // "InFile OutFile"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_FORCE,	// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbHexTranslate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	g_wszEncodeHex,		// pwszArg
	IDS_ENCODEHEX_DESCRIPTION, // "Encode file in hexadecimal"
	IDS_ENCODEHEX_USAGEARGS, // "InFile OutFile [type]"
	0,			// idsArgDescription
	2,			// cArgMin
	3,			// cArgMax
	AF_OPTION_NOCR | AF_OPTION_FORCE | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbHexTranslate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"decode",		// pwszArg
	IDS_DECODE_DESCRIPTION,	// "Decode Base64-encoded file"
	IDS_INFILEOUTFILE_USAGEARGS, // "InFile OutFile"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_FORCE,	// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbBase64Translate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	g_wszEncode,		// pwszArg
	IDS_ENCODE_DESCRIPTION,	// "Encode file to Base64"
	IDS_INFILEOUTFILE_USAGEARGS, // "InFile OutFile"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_NOCR | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbBase64Translate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"deny",		// pwszArg
	IDS_DENY_DESCRIPTION,	// "Deny pending request"
	IDS_DENY_USAGEARGS,	// "RequestId"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDenyRequest,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"resubmit",		// pwszArg
	IDS_RESUBMIT_DESCRIPTION, // "Resubmit pending request"
	IDS_RESUBMIT_USAGEARGS,	// "RequestId"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbResubmitRequest,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"setattributes",	 // pwszArg
	IDS_SETATTRIBUTES_DESCRIPTION, // "Set attributes for pending request"
	IDS_SETATTRIBUTES_USAGEARGS, // "RequestId AttributeString"
	IDS_SETATTRIBUTES_ARGDESCRIPTION, // idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSetAttributes,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"setextension",	// pwszArg
	IDS_SETEXTENSION_DESCRIPTION, // "Set extension for pending request"
	IDS_SETEXTENSION_USAGEARGS, // "RequestId ExtensionName Flags {Long | Date | String | @InFile}"
	IDS_SETEXTENSION_ARGDESCRIPTION, // idsArgDescription
	4,			// cArgMin
	4,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSetExtension,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"revoke",		// pwszArg
	IDS_REVOKE_DESCRIPTION,	// "Revoke certificate"
	IDS_REVOKE_USAGEARGS,	// "SerialNumber"
	IDS_REVOKE_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRevokeCertificate,	// pfnVerb
	g_papwszUsageRevokeCertificate,	// papwszUsageConstants
    },
    {
	L"isvalid",		// pwszArg
	IDS_ISVALID_DESCRIPTION, // "Display current certificate disposition"
	IDS_ISVALID_USAGEARGS,	// "SerialNumber | CertHash"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbIsValidCertificate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"getconfig",		// pwszArg
	IDS_GETCONFIG_DESCRIPTION, // "get default configuration string"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetConfig,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"getconfig2",		// pwszArg
	IDS_GETCONFIG2_DESCRIPTION, // "get default configuration string via ICertGetConfig"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_IDISPATCH | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetConfig2,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"getconfig3",		// pwszArg
	IDS_GETCONFIG3_DESCRIPTION, // "get configuration via ICertConfig"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_IDISPATCH | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetConfig3,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"ping",		// pwszArg
	IDS_PING_DESCRIPTION,	// "Ping Certificate Server"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbPing,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"pingadmin",		// pwszArg
	IDS_PINGADMIN_DESCRIPTION, // "Ping Certificate Server Admin interface"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbPingAdmin,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	g_wszCAInfo,		// pwszArg
	IDS_CAINFO_DESCRIPTION,	// "Display CA Information"
	IDS_CAINFO_USAGEARGS,	// "[InfoName [Index | ErrorCode]]"
	IDS_CAINFO_ARGDESCRIPTION, // idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_V1 | AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_OPTION_ADMIN | AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetCAInfo,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"CAPropInfo",		// pwszArg
	IDS_CAPROPINFO_DESCRIPTION,// "Display CA Property Type Information"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_V1 | AF_OPTION_IDISPATCH | AF_OPTION_ADMIN | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetCAPropInfo,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	g_wszCACert,		// pwszArg
	IDS_CACERT_DESCRIPTION,	// "Retrieve the CA's certificate"
	IDS_CACERT_USAGEARGS,	// "OutCACertFile [Index]"
	IDS_CACERT_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_V1 | AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_OPTION_ADMIN | AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetCACertificate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	g_wszCAChain,		// pwszArg
	IDS_CACHAIN_DESCRIPTION,// "Retrieve the CA's certificate chain"
	IDS_CACHAIN_USAGEARGS,	// "OutCACertChainFile [Index]"
	IDS_CACHAIN_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_V1 | AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_OPTION_ADMIN | AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetCACertificate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	g_wszGetCRL,		// pwszArg
	IDS_GETCRL_DESCRIPTION,	// "Get CRL"
	IDS_GETCRL_USAGEARGS,	// "OutFile [Index] [%1]"
	IDS_GETCRL_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	3,			// cArgMax
	AF_OPTION_V1 | AF_OPTION_SPLIT | AF_OPTION_IDISPATCH | AF_OPTION_FORCE | AF_OPTION_ADMIN | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetCRL,              // pfnVerb
	g_papwszUsageGetCRL,	// papwszUsageConstants
    },
    {
	L"CRL",			// pwszArg
	IDS_CRL_DESCRIPTION,	// "Publish new CRL [optionally delta CRL only]"
	IDS_CRL_USAGEARGS,	// "[dd:hh | %1] [%2]"
	IDS_CRL_ARGDESCRIPTION,	// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_V1 | AF_OPTION_SPLIT | AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbPublishCRL,		// pfnVerb
	g_papwszUsageCRL,	// papwszUsageConstants
    },
    {
	L"shutdown",		// pwszArg
	IDS_SHUTDOWN_DESCRIPTION, // "Shutdown Certificate Server"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbShutDownServer,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"installCert",		// pwszArg
	IDS_INSTALLCERT_DESCRIPTION, // "Install Certification Authority certificate"
	IDS_INSTALLCERT_USAGEARGS, // "CACertFile"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_SILENT | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbInstallCACert,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"renewCert",		// pwszArg
	IDS_RENEWCERT_DESCRIPTION, // "Renew Certification Authority certificate"
	IDS_RENEWCERT_USAGEARGS, // "[%1] [Machine\\ParemtCAName]"
	IDS_RENEWCERT_ARGDESCRIPTION, // idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_SILENT | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRenewCACert,	// pfnVerb
	g_papwszUsageRenew,	// papwszUsageConstants
    },
    { L"", },
    {
	g_wszSchema,		// pwszArg
	IDS_SCHEMA_DESCRIPTION,	// "Dump certificate schema"
	IDS_SCHEMA_USAGE,	// "[%1 | %2 | %3]"
	IDS_SCHEMA_ARGDESCRIPTION, // idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_SPLIT | AF_OPTION_CONFIG | AF_OPTION_IDISPATCH | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbViewDump,		// pfnVerb
	g_papwszUsageSchema,	// papwszUsageConstants
    },
    {
	L"view",		// pwszArg
	IDS_VIEW_DESCRIPTION,	// "Dump certificate view"
	IDS_VIEW_USAGE,		// "[%1 | %2 | %3 | %4 | %5 | %6 | %7]"
	IDS_VIEW_ARGDESCRIPTION, // idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_SILENT | AF_OPTION_SPLIT | AF_OPTION_REVERSE | AF_OPTION_IDISPATCH | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT | AF_OPTION_OUT | AF_OPTION_RESTRICT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbViewDump,		// pfnVerb
	g_papwszUsageView,	// papwszUsageConstants
    },
    {
	L"db",			// pwszArg
	IDS_DB_DESCRIPTION,	// "Dump Raw Database"
	IDS_VIEW_USAGE,		// "[%1 | %2 | %3 | %4 | %5 | %6 | %7]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_SILENT | AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_OPTION_OUT | AF_OPTION_RESTRICT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDBDump,		// pfnVerb
	g_papwszUsageView,	// papwszUsageConstants
    },
    {
	L"deleterow",		// pwszArg
	IDS_DELETEROW_DESCRIPTION, // "Delete server database row"
	IDS_DELETEROW_USAGEARGS, // "RowId | Date [%1 | %2 | %3 | %4 | %5]"
	IDS_DELETEROW_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDeleteRow,		// pfnVerb
	g_papwszUsageDeleteRow,	// papwszUsageConstants
    },
    { L"", },
    {
	L"backup",		// pwszArg
	IDS_BACKUP_DESCRIPTION,	// "backup certificate server"
	IDS_BACKUP_USAGEARGS,	// "BackupDirectory [%1] [%2]"
	IDS_BACKUP_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	3,			// cArgMax
	AF_OPTION_WEAKPFX | AF_OPTION_PASSWORD | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbBackup,		// pfnVerb
	g_papwszUsageBackup,	// papwszUsageConstants
    },
    {
	L"backupDB",		// pwszArg
	IDS_BACKUPDB_DESCRIPTION, // "backup certificate server data base"
	IDS_BACKUPDB_USAGEARGS,	// "BackupDirectory [%1] [%2]"
	IDS_BACKUPDB_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	3,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbBackupDB,		// pfnVerb
	g_papwszUsageBackup,	// papwszUsageConstants
    },
    {
	L"backupKey",		// pwszArg
	IDS_BACKUPPFX_DESCRIPTION, // "backup certificate server certificate and private key"
	IDS_BACKUPPFX_USAGEARGS, // "BackupDirectory"
	IDS_BACKUPPFX_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_TIMEOUT | AF_OPTION_WEAKPFX | AF_OPTION_PASSWORD | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbBackupPFX,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"restore",		// pwszArg
	IDS_RESTORE_DESCRIPTION, // "restore certificate server"
	IDS_RESTORE_USAGEARGS,	// "BackupDirectory"
	IDS_RESTORE_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_PASSWORD | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRestore,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"restoreDB",		// pwszArg
	IDS_RESTOREDB_DESCRIPTION, // "restore certificate server data base"
	IDS_RESTOREDB_USAGEARGS, // "BackupDirectory"
	IDS_RESTOREDB_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRestoreDB,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"restoreKey",		// pwszArg
	IDS_RESTOREPFX_DESCRIPTION, // "restore certificate server certificate and private key"
	IDS_RESTOREPFX_USAGEARGS, // "BackupDirectory | PFXFile"
	IDS_RESTOREPFX_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_PASSWORD | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_ACTIVECONFIG | AF_NEEDCOINIT | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRestorePFX,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"exportPVK",		// pwszArg
	IDS_EXPORTPVK_DESCRIPTION, // "export certificate and private key for code signing"
	IDS_EXPORTPVK_USAGEARGS, // "CertId PVKFileBaseName"
	0,			// idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_PASSWORD | AF_OPTION_USER | AF_OPTION_SPLIT | AF_OPTION_ENTERPRISE | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbExportPVK,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"exportPFX",		// pwszArg
	IDS_EXPORTPFX_DESCRIPTION, // "export certificate and private key"
	IDS_EXPORTPFX_USAGEARGS, // "CertId PFXFile"
	IDS_EXPORTPFX_ARGDESCRIPTION, // idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_TIMEOUT | AF_OPTION_WEAKPFX | AF_OPTION_PASSWORD | AF_OPTION_USER | AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbExportPFX,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"importPFX",		// pwszArg
	IDS_IMPORTPFX_DESCRIPTION, // "import certificate and private key"
	IDS_IMPORTPFX_USAGEARGS, // "PFXFile"
	IDS_IMPORTPFX_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_CSP | AF_OPTION_PROTECT | AF_OPTION_PASSWORD | AF_OPTION_USER | AF_OPTION_FORCE | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbImportPFX,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dynamicfilelist",
	IDS_DYNAMICFILES_DESCRIPTION, // "Display Dynamic File List"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDynamicFileList,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"databaselocations",
	IDS_DATABASELOCATIONS_DESCRIPTION, // "Display Database Locations"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDatabaseLocations,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"hashfile",		// pwszArg
	IDS_HASHFILE_DESCRIPTION, // "Generates and displays cryptographic hash over a file"
	IDS_HASHFILE_USAGEARGS,	// "InFile"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_ZERO,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbMACFile,		// pfnVerb
	NULL,			// papwszUsageConstants
    },  
    { L"", },
    {
	L"store",		// pwszArg
	IDS_STORE_DESCRIPTION,	// "dump certificate store"
	IDS_STORE_USAGEARGS,	// "[CertificateStoreName [CertId [OutputFile]]]"
	IDS_STORE_ARGDESCRIPTION, // idsArgDescription
	0,			// cArgMin
	3,			// cArgMax
	AF_OPTION_DC | AF_OPTION_USER | AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbStore,		// pfnVerb
	g_papwszUsageStore,	// papwszUsageConstants
    },
    {
	L"addstore",		// pwszArg
	IDS_ADDSTORE_DESCRIPTION, // "add certificate to store"
	IDS_ADDSTORE_USAGEARGS,	// "CertificateStoreName InFile"
	IDS_ADDSTORE_ARGDESCRIPTION, // idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_DC | AF_OPTION_USER | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbAddStore,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"delstore",		// pwszArg
	IDS_DELSTORE_DESCRIPTION, // "delete certificate from store"
	IDS_DELSTORE_USAGEARGS,	// "CertificateStoreName CertId"
	IDS_DELSTORE_ARGDESCRIPTION, // idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_DC | AF_OPTION_USER | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDelStore,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"verifystore",		// pwszArg
	IDS_VERIFYSTORE_DESCRIPTION, // "verify certificate in store"
	IDS_VERIFYSTORE_USAGEARGS, // "CertificateStoreName [CertId]"
	IDS_DELSTORE_ARGDESCRIPTION, // idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_TIMEOUT | AF_OPTION_DC | AF_OPTION_USER | AF_OPTION_SPLIT | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbVerifyStore,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"repairstore",		// pwszArg
	IDS_REPAIRSTORE_DESCRIPTION, // "repair certificate KeyPprovInfo in store"
	IDS_REPAIRSTORE_USAGEARGS, // "CertificateStoreName CertId"
	IDS_DELSTORE_ARGDESCRIPTION, // idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_CSP | AF_OPTION_USER | AF_OPTION_SILENT | AF_OPTION_SPLIT | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRepairStore,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"viewstore",		// pwszArg
	IDS_STORE_DESCRIPTION,	// "view certificate store"
	IDS_STORE_USAGEARGS,	// "[CertificateStoreName [CertId [OutputFile]]]"
	IDS_STORE_ARGDESCRIPTION, // idsArgDescription
	0,			// cArgMin
	3,			// cArgMax
	AF_OPTION_DC | AF_OPTION_USER | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbViewOrDeleteStore,	// pfnVerb
	g_papwszUsageStore,	// papwszUsageConstants
    },
    {
	g_wszViewDelStore,	// pwszArg
	IDS_DELSTORE_DESCRIPTION, // "delete certificate from store"
	IDS_STORE_USAGEARGS,	// "[CertificateStoreName [CertId [OutputFile]]]"
	IDS_STORE_ARGDESCRIPTION, // idsArgDescription
	0,			// cArgMin
	3,			// cArgMax
	AF_OPTION_DC | AF_OPTION_USER | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbViewOrDeleteStore,	// pfnVerb
	g_papwszUsageStore,	// papwszUsageConstants
    },
    {
	L"getcert",		// pwszArg
	IDS_GETCERT_DESCRIPTION,// "select a certificate from a selection UI"
	IDS_GETCERT_USAGEARGS,  // "[ObjectId | %1 | %2 [CommonName]]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_SPLIT | AF_OPTION_SILENT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetCertFromUI,	// pfnVerb
	g_papwszUsageGetCert,	// papwszUsageConstants
    },
    { L"", },
    {
	L"ds",			// pwszArg
	IDS_DS_DESCRIPTION,	// "Display DS DNs"
	IDS_DS_USAGEARGS,	// "[CN]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_DC | AF_OPTION_SPLIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDS,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dsDel",		// pwszArg
	IDS_DSDEL_DESCRIPTION,	// "Delete DS DNs"
	IDS_DSDEL_USAGEARGS,	// "CN"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_DC | AF_OPTION_SPLIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSDel,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dsPublish",		// pwszArg
	IDS_DSPUBLISH_DESCRIPTION, // "Publish Certificate or CRL to DS"
	IDS_DSPUBLISH_USAGEARGS, // "CertFile [%1 | %2 | %3 | %4 | %5 | %6 | %7]\nCRLFile [DSCDPContainer [DSCDPCN]]"
	IDS_DSPUBLISH_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	3,			// cArgMax
	AF_OPTION_DC | AF_OPTION_USER | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSPublish,		// pfnVerb
	g_papwszUsageDSPublish,	// papwszUsageConstants
    },
    {
	L"dsCert",		// pwszArg
	IDS_DSCERT_DESCRIPTION,	// "Display DS Certificates"
	IDS_DSCERT_USAGEARGS,	// "[CertId [OutFile]]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_DC | AF_OPTION_USER | AF_OPTION_ENTERPRISE | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSCert,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dsCRL",		// pwszArg
	IDS_DSCRL_DESCRIPTION,	// "Display DS CRLs"
	IDS_DSCRL_USAGEARGS,	// "[CRLIndex [OutFile]]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_DC | AF_OPTION_USER | AF_OPTION_IDISPATCH | AF_OPTION_ENTERPRISE | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSCRL,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dsDeltaCRL",		// pwszArg
	IDS_DSDELTACRL_DESCRIPTION, // "Display DS Delta CRLs"
	IDS_DSDELTACRL_USAGEARGS,   // "[CRLIndex [OutFile]]"
	0,			// idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_DC | AF_OPTION_USER | AF_OPTION_ENTERPRISE | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSDeltaCRL,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dsTemplate",		// pwszArg
	IDS_DSTEMPLATE_DESCRIPTION, // "Display DS Template Attributes"
	IDS_DSTEMPLATE_USAGEARGS,   // "[Template]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_SILENT | AF_OPTION_DC | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSTemplate,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dsAddTemplate",	// pwszArg
	IDS_DSADDTEMPLATE_DESCRIPTION, // "Add DS Templates"
	IDS_DSADDTEMPLATE_USAGEARGS,   // "TemplateInfFile"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_DC | AF_PRIVATE | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDSAddTemplate,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"Template",		// pwszArg
	IDS_TEMPLATE_DESCRIPTION, // "Display Templates"
	IDS_TEMPLATE_USAGEARGS,   // "[Template]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_USER | AF_OPTION_UT | AF_OPTION_MT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbTemplate,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"TemplateCAs",		// pwszArg
	IDS_TEMPLATECAS_DESCRIPTION, // "Display CAs for Template"
	IDS_TEMPLATECAS_USAGEARGS,   // "Template"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_DC | AF_OPTION_USER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbTemplateCAs,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"CATemplates",		// pwszArg
	IDS_CATEMPLATES_DESCRIPTION, // "Display Templates for CA"
	IDS_CATEMPLATES_USAGEARGS,   // "[Template]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_DC | AF_OPTION_USER | AF_OPTION_UT | AF_OPTION_MT | AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbCATemplates,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"SetCATemplates",		// pwszArg
	IDS_SETCATEMPLATES_DESCRIPTION, // "Set Templates for CA"
	IDS_SETCATEMPLATES_USAGEARGS, // "[+ | -]TemplateList"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_STOPATMINUSSIGNARG | AF_OPTION_FORCE | AF_OPTION_DC | AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSetCATemplates,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"URL",			// pwszArg
	IDS_URL_DESCRIPTION,	// "Verify Certificate or CRL URLs"
	IDS_URL_USAGEARGS,	// "InFile | URL"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_SPLIT | AF_OPTION_FORCE | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbURL,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"URLCache",		// pwszArg
	IDS_URLCACHE_DESCRIPTION, // "Display or delete URL Cache entries"
	IDS_URLCACHE_USAGEARGS,	// "[URL [%1]]"
	IDS_URLCACHE_ARGDESCRIPTION, // idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_SPLIT | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbURLCache,		// pfnVerb
	g_papwszUsageURLCache,	// papwszUsageConstants
    },
    {
	L"pulse",		// pwszArg
	IDS_PULSE_DESCRIPTION,	// "Pulse autoenrollment events"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_ZERO,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbPulse,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"MachineInfo",		// pwszArg
	IDS_MACHINEINFO_DESCRIPTION, // "Display DS machine object information"
	IDS_MACHINEINFO_USAGEARGS,   // "DomainName\\MachineName$"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_ZERO,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbMachineInfo,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"DCInfo",		// pwszArg
	IDS_DCINFO_DESCRIPTION,	// "Display DC information"
	IDS_DCINFO_USAGEARGS,	// "[%1 | %2 | %3]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_TIMEOUT | AF_OPTION_URLFETCH | AF_OPTION_USER | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDCInfo,		// pfnVerb
	g_papwszUsageDCInfo,	// papwszUsageConstants
    },
    {
	L"EntInfo",		// pwszArg
	IDS_ENTINFO_DESCRIPTION, // "Display Enterprise information"
	IDS_ENTINFO_USAGEARGS,	// "DomainName\\MachineName$"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_USER | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbEntInfo,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"TCAInfo",		// pwszArg
	IDS_TCAINFO_DESCRIPTION, // "Display CA information"
	IDS_TCAINFO_USAGEARGS,	// "[DomainDN | -]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_TIMEOUT | AF_OPTION_URLFETCH | AF_STOPATMINUSSIGN | AF_OPTION_DC | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE | AF_OPTION_USER | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbTCAInfo,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"SCInfo",		// pwszArg
	IDS_SCINFO_DESCRIPTION,	// "Display Smart Card information"
	IDS_SCINFO_USAGEARGS,	// "[Reader Name]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_TIMEOUT | AF_OPTION_URLFETCH | AF_OPTION_SPLIT | AF_OPTION_SILENT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSCInfo,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"key",			// pwszArg
	IDS_KEY_DESCRIPTION,	// "list key containers"
	IDS_KEY_USAGEARGS,	// "[KeyContainerName | -]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_CSP | AF_OPTION_USER | AF_OPTION_SILENT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbKey,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"delkey",		// pwszArg
	IDS_DELKEY_DESCRIPTION, // "delete named key container"
	IDS_DELKEY_USAGEARGS,	// "KeyContainerName"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_CSP | AF_OPTION_USER | AF_OPTION_SILENT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDelKey,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"verifykeys",		// pwszArg
	IDS_VERIFYKEYS_DESCRIPTION, // "Verify public/private key set"
	IDS_VERIFYKEYS_USAGEARGS, // "[KeyContainerName CACertFile]"
	IDS_VERIFYKEYS_ARGDESCRIPTION, // idsArgDescription
	0,			// cArgMin
	2,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_USER | AF_OPTION_SILENT | AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbVerifyKeys,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"verify",		// pwszArg
	IDS_VERIFY_DESCRIPTION,	// "Verify certificate or chain"
	IDS_VERIFY_USAGEARGS,	// "CertFile [CACertFile [CrossedCACertFile]]"
	IDS_VERIFY_ARGSDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	3,			// cArgMax
	AF_OPTION_TIMEOUT | AF_OPTION_URLFETCH | AF_OPTION_SPLIT | AF_OPTION_USER | AF_OPTION_SILENT | AF_OPTION_FORCE | AF_OPTION_ENTERPRISE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbVerifyCert,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"csplist",		// pwszArg
	IDS_CSPLIST_DESCRIPTION,// "list all CSPs installed on this machine"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_USER | AF_OPTION_SILENT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbCSPList,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"csptest",		// pwszArg
	IDS_CSPTEST_DESCRIPTION,// "test one or all CSPs installed on this machine"
	IDS_CSPTEST_USAGEARGS,	// "[KeyContainerName]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_CSP | AF_OPTION_USER | AF_OPTION_SILENT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbCSPTest,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"sign",		// pwszArg
	IDS_SIGN_DESCRIPTION,	// "Re-sign CRL or Certificate"
	IDS_SIGN_USAGEARGS,	// "InFile OutFile [dd:hh] [+SerialNumberList | -SerialNumberList | -ObjectIdList]"
	IDS_SIGN_ARGDESCRIPTION, // idsArgDescription
	2,			// cArgMin
	4,			// cArgMax
	AF_OPTION_SILENT | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSign,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"vroot",		// pwszArg
	IDS_VROOT_DESCRIPTION,	// "Create/Delete Web Virtual Roots and File Share"
	IDS_VROOT_USAGEARGS,	// "[%1]"
	0,			// idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_ZERO,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbCreateVRoots,	// pfnVerb
	g_papwszUsageDelete,	// papwszUsageConstants
    },
    {
	L"7f",			// pwszArg
	IDS_7F_DESCRIPTION,	// "Check certificate for 0x7f length encodings"
	IDS_7F_USAGEARGS,	// "CertFile"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_PRIVATE,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbCheck7f,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"oid",			// pwszArg
	IDS_OIDNAME_DESCRIPTION,// "Display or set ObjectId display name"
	IDS_OIDNAME_USAGEARGS,	// "ObjectId [DisplayName | delete [LanguageId [Type]]]"
	IDS_OIDNAME_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	4,			// cArgMax
	AF_OPTION_FORCE,	// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbOIDName,		// pfnVerb
	g_papwszUsageOIDName,	// papwszUsageConstants
    },
    {
	L"error",		// pwszArg
	IDS_ERRCODE_DESCRIPTION,// "Display error code message text"
	IDS_ERRCODE_USAGEARGS,	// "ErrorCode"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_STOPATMINUSSIGNARG,	// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbErrorDump,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"getsmtpinfo",		// pwszArg
	IDS_GETMAPI_DESCRIPTION,// "get SMTP info"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetMapiInfo,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"setsmtpinfo",		// pwszArg
	IDS_SETMAPI_DESCRIPTION, // "set SMTP info"
	IDS_SETMAPI_USAGEARGS,	// "LogonName"
	0,			// idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_PASSWORD | AF_OPTION_CONFIG | AF_NEEDCOINIT | AF_PRIVATE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSetMapiInfo,	// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"getreg",
	IDS_GETREG_DESCRIPTION,	// "Display registry value"
	IDS_GETREG_USAGEARGS,	// "[{%1|%2|%3|%4|%5}\\[%6\\]][RegistryValueName]"
	IDS_SETREG_ARGDESCRIPTION, // idsArgDescription
	0,			// cArgMin
	1,			// cArgMax
	AF_OPTION_USER | AF_NEEDCOINIT | AF_OPTIONALCONFIG, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetReg,		// pfnVerb
	g_papwszUsageGetSetReg,	// papwszUsageConstants
    },
    {
	L"setreg",
	IDS_SETREG_DESCRIPTION,	// "Set registry value"
	IDS_SETREG_USAGEARGS,	// "[{%1|%2|%3|%4|%5}\\[%6\\]]RegistryValueName Value"
	IDS_SETREG_ARGDESCRIPTION, // idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_USER | AF_NEEDCOINIT | AF_OPTIONALCONFIG | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbSetReg,		// pfnVerb
	g_papwszUsageGetSetReg,	// papwszUsageConstants
    },
    {
	L"delreg",
	IDS_DELREG_DESCRIPTION,	// "Delete registry value"
	IDS_GETREG_USAGEARGS,	// "[{%1|%2|%3|%4|%5}\\[%6\\]RegistryValueName]"
	IDS_SETREG_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	1,			// cArgMax
	AF_OPTION_FORCE | AF_OPTION_USER | AF_NEEDCOINIT | AF_OPTIONALCONFIG | AF_RESTARTSERVER, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbDelReg,		// pfnVerb
	g_papwszUsageGetSetReg,	// papwszUsageConstants
    },
    { L"", },
    {
	L"ImportKMS",		// pwszArg
	IDS_IMPORTKMS_DESCRIPTION, // "import user keys and certificates into server database for key archival"
	IDS_IMPORTKMS_USAGEARGS, // "UserKeyAndCertFile [CertId]"
	IDS_IMPORTKMS_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_PASSWORD | AF_OPTION_SPLIT | AF_OPTION_SILENT | AF_OPTION_IDISPATCH | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbImportKMS,		// pfnVerb
	g_papwszUsageMinusf,	// papwszUsageConstants
    },
    {
	L"ImportCert",
	IDS_IMPORTCERT_DESCRIPTION, // "Import a certificate file into the database"
	IDS_IMPORTCERT_USAGEARGS, // "Certfile"
	IDS_IMPORTCERT_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_FORCE | AF_OPTION_CONFIG | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbImportCertificate,	// pfnVerb
	g_papwszUsageMinusf,	// papwszUsageConstants
    },
    {
	L"GetKey",
	IDS_GETKEY_DESCRIPTION,	// "Retrieve archived private key recovery blob"
	IDS_GETKEY_USAGEARGS,	// "SearchToken [RecoveryBlobOutFile]"
	IDS_GETKEY_ARGDESCRIPTION, // idsArgDescription
	1,			// cArgMin
	2,			// cArgMax
	AF_OPTION_IDISPATCH | AF_OPTION_FORCE | AF_NEEDCOINIT | AF_OPTIONALCONFIG, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbGetKey,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"RecoverKey",
	IDS_RECOVERKEY_DESCRIPTION, // "Recover archived private key"
	IDS_RECOVERKEY_USAGEARGS,   // "RecoveryBlobInFile [PFXOutFile [RecipientIndex]]"
	0,			// idsArgDescription
	1,			// cArgMin
	3,			// cArgMax
	AF_OPTION_TIMEOUT | AF_OPTION_WEAKPFX | AF_OPTION_USER | AF_OPTION_SPLIT | AF_OPTION_PASSWORD | AF_OPTION_FORCE | AF_NEEDCOINIT, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbRecoverKey,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"MergePFX",
	IDS_MERGEPFX_DESCRIPTION, // "Merge PFX files"
	IDS_MERGEPFX_USAGEARGS,	// "PFXInFileList PFXOutFile"
	IDS_MERGEPFX_ARGDESCRIPTION, // idsArgDescription
	2,			// cArgMin
	2,			// cArgMax
	AF_OPTION_CSP | AF_OPTION_WEAKPFX | AF_OPTION_USER | AF_OPTION_SPLIT | AF_OPTION_PASSWORD | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbMergePFX,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"ConvertEPF",
	IDS_CONVERTEPF_DESCRIPTION, // "Convert PFX files to EPF file"
	IDS_CONVERTEPF_USAGEARGS, // "PFXInFileList EPFOutFile [%1 | %2] [V3CACertId][,Salt]"
	IDS_CONVERTPFX_ARGDESCRIPTION, // idsArgDescription
	2,			// cArgMin
	4,			// cArgMax
	AF_OPTION_CSP | AF_OPTION_SPLIT | AF_OPTION_DC | AF_OPTION_SILENT | AF_OPTION_PASSWORD | AF_OPTION_FORCE, // Flags
	NULL,			// pBool
	NULL,			// ppString
	verbConvertEPF,		// pfnVerb
	g_papwszUsageConvertEPF, // papwszUsageConstants
    },
    {
	L"?",			// pwszArg
	IDS_USAGE_DESCRIPTION,	// "Display this usage message"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_ZERO,		// Flags
	NULL,			// pBool
	NULL,			// ppString
	verbUsage,		// pfnVerb
	NULL,			// papwszUsageConstants
    },
    { L"", },
    {
	L"f",			// pwszArg
	IDS_FORCE_DESCRIPTION,	// "Force overwrite"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_FORCE,	// Flags
	&g_fForce,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"idispatch",		// pwszArg
	IDS_IDISPATCH_DESCRIPTION, // "Use IDispatch instead of COM"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_PRIVATE | AF_OPTION_IDISPATCH, // Flags
	&g_fIDispatch,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"enterprise",		// pwszArg
	IDS_ENTERPRISE_DESCRIPTION, // "Use Enterprise certificate store"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_ENTERPRISE,	// Flags
	&g_fEnterpriseRegistry,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"user",		// pwszArg
	IDS_USER_DESCRIPTION,	// "Use HKEY_CURRENT_USER certificate store"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_USER,		// Flags
	&g_fUserRegistry,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"ut",			// pwszArg
	IDS_UT_DESCRIPTION,	// "Display user templates"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_UT,		// Flags
	&g_fUserTemplates,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"mt",			// pwszArg
	IDS_MT_DESCRIPTION,	// "Display machine templates"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_MT,		// Flags
	&g_fMachineTemplates,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"nocr",		// pwszArg
	IDS_NOCR_DESCRIPTION,	// "Encode text without CR characters"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_PRIVATE | AF_OPTION_NOCR, // Flags
	&g_fNoCR,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"gmt",			// pwszArg
	IDS_GMT_DESCRIPTION,	// "Display times as GMT"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_GMT,		// Flags
	&g_fGMT,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"seconds",		// pwszArg
	IDS_SECONDS_DESCRIPTION,// "Display times with seconds and milliseconds"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_SECONDS,	// Flags
	&g_fSeconds,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"silent",		// pwszArg
	IDS_SILENT_DESCRIPTION,	// "Use silent flag to acquire crypt context"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_SILENT,	// Flags
	&g_fCryptSilent,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"split",		// pwszArg
	IDS_SPLIT_DESCRIPTION,	// "Split embedded ASN.1 elements, and save to files"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_SPLIT,	// Flags
	&g_fSplitASN,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"v",			// pwszArg
	IDS_VERBOSE_DESCRIPTION, // "Verbose operation"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_VERBOSE,	// Flags
	&g_fVerbose,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"v1",			// pwszArg
	IDS_V1_DESCRIPTION,	// "Use V1 COM interfaces"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_PRIVATE | AF_OPTION_V1, // Flags
	&g_fV1Interface,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"protect",		// pwszArg
	IDS_PROTECT_DESCRIPTION, // "Protect keys with password"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_PRIVATE | AF_OPTION_PROTECT, // Flags
	&g_fProtect,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"oldpfx",		// pwszArg
	IDS_WEAKPFX_DESCRIPTION, // "Use old PFX encryption"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_PRIVATE | AF_OPTION_WEAKPFX, // Flags
	&g_fWeakPFX,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"urlfetch",		// pwszArg
	IDS_URLFETCH_DESCRIPTION, // "Retrieve and verify AIA Certs and CDP CRLs"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_URLFETCH, // Flags
	&g_fURLFetch,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"reverse",		// pwszArg
	IDS_REVERSE_DESCRIPTION, // "Reverse Log and Queue columns"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_PRIVATE | AF_OPTION_REVERSE, // Flags
	&g_fReverse,		// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"admin",		// pwszArg
	IDS_ADMIN_DESCRIPTION,	// "Use ICertAdmin2 for CA Properties"
	0,			// idsUsage
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_PRIVATE | AF_OPTION_ADMIN, // Flags
	&g_fAdminInterface,	// pBool
	NULL,			// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"config",		// pwszArg
	IDS_CONFIG_DESCRIPTION,	// "CA and Machine name string"
	IDS_CONFIG_USAGE,	// "Machine\\CAName"
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTIONALCONFIG | AF_OPTION_CONFIG, // Flags
	NULL,			// pBool
	&g_pwszConfig,		// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"dc",			// pwszArg
	IDS_DC_DESCRIPTION,	// "Target a specific Domain Controller"
	IDS_DC_USAGE,		// "DCName"
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_DC,		// Flags
	NULL,			// pBool
	&g_pwszDC,		// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"restrict",		// pwszArg
	IDS_RESTRICT_DESCRIPTION, // "Comma separated Restriction List"
	IDS_RESTRICT_USAGE,	// "RestrictionList"
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_RESTRICT,	// Flags
	NULL,			// pBool
	&g_pwszRestrict,	// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"out",			// pwszArg
	IDS_OUT_DESCRIPTION,	// "Comma separated Column List"
	IDS_OUT_USAGE,		// "ColumnList"
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_OUT,		// Flags
	NULL,			// pBool
	&g_pwszOut,		// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"p",			// pwszArg
	IDS_PASSWORD_DESCRIPTION, // "password"
	IDS_PASSWORD_DESCRIPTION, // "password"
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_PASSWORD,	// Flags
	NULL,			// pBool
	&g_pwszPassword,	// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"csp",			// pwszArg
	IDS_CSP_DESCRIPTION,	// "Provider"
	IDS_CSP_DESCRIPTION,	// "Provider"
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_CSP,		// Flags
	NULL,			// pBool
	&g_pwszCSP,		// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
    {
	L"t",			// pwszArg
	IDS_TIMEOUT_DESCRIPTION, // "URL fetch timeout in milliseconds"
	IDS_TIMEOUT_USAGE,	// "Timeout"
	0,			// idsArgDescription
	0,			// cArgMin
	0,			// cArgMax
	AF_OPTION_TIMEOUT,	// Flags
	NULL,			// pBool
	&g_pwszmsTimeout,	// ppString
	NULL,			// pfnVerb
	NULL,			// papwszUsageConstants
    },
};


VOID
cuPrintErrorAndString(
    OPTIONAL IN WCHAR const *pwszProc,
    IN DWORD idmsg,
    IN HRESULT hr,
    OPTIONAL IN WCHAR const *pwszString)
{
    WCHAR const *pwsz;
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszError = NULL;

    if (NULL != pwszProc)
    {
	wprintf(L"%ws: ", pwszProc);
    }
    if (0 != idmsg)
    {
	pwsz = myLoadResourceString(idmsg);	// "??? returned %ws"
	if (NULL == pwsz)
	{
	    pwsz =  L"error %ws";
	}
    }
    else
    {
	pwsz =  L"%ws";
    }
    pwszError = myGetErrorMessageText(hr, TRUE);
    if (NULL == pwszError)
    {
	pwszError = myHResultToString(awchr, hr);
    }
    wprintf(pwsz, pwszError);
    if (NULL != pwszString)
    {
	wprintf(L" -- %ws", pwszString);
    }
    wprintf(wszNewLine);
    if (NULL != pwszError && awchr != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
}


VOID
cuPrintError(
    IN DWORD idmsg,
    IN HRESULT hr)
{
    cuPrintErrorAndString(NULL, idmsg, hr, NULL);
}


VOID
cuPrintAPIError(
    IN WCHAR const *pwszAPIName,
    IN HRESULT hr)
{
    cuPrintErrorAndString(pwszAPIName, 0, hr, NULL);
}


VOID
cuPrintErrorMessageText(
    IN HRESULT hr)
{
    WCHAR const *pwszMessage;

    pwszMessage = myGetErrorMessageText(hr, FALSE);
    if (NULL != pwszMessage)
    {
	wprintf(L"%ws: %ws\n", g_pwszProg, pwszMessage);
	LocalFree(const_cast<WCHAR *>(pwszMessage));
    }
}


VOID
LoadUsage(
    IN OUT ARG *parg)
{
    HRESULT hr;

    if (0 != parg->idsUsage && NULL == parg->pwszUsage)
    {
	WCHAR const *pwszUsage = myLoadResourceString(parg->idsUsage);

	if (NULL != pwszUsage)
	{
	    if (NULL == parg->papwszUsageConstants)
	    {
		parg->pwszUsage = pwszUsage;
	    }
	    else
	    {
		if (0 == FormatMessage(
				FORMAT_MESSAGE_ALLOCATE_BUFFER |
				    FORMAT_MESSAGE_FROM_STRING |
				    FORMAT_MESSAGE_ARGUMENT_ARRAY,
				(VOID *) pwszUsage,
				0,              // dwMessageID
				0,              // dwLanguageID
				(LPWSTR) &parg->pwszUsage,
				0,
				(va_list *) parg->papwszUsageConstants))
		{
		    hr = myHLastError();
		    _PrintError(hr, "FormatMessage");
		}
	    }
	}
    }
}


VOID
FreeUsage(
    IN OUT ARG *parg)
{
    if (NULL != parg->pwszUsage)
    {
	if (NULL != parg->papwszUsageConstants)
	{
	    LocalFree(const_cast<WCHAR *>(parg->pwszUsage));
	}
	parg->pwszUsage = NULL;
    }
}


BOOL
DumpArgOptions(
    IN DWORD dwOptionFlags)
{
    ARG *parg;
    BOOL fDisplayed = FALSE;
    WCHAR const *pwszPrefix = g_wszPad4;

    dwOptionFlags |= AF_OPTION_GENERIC;
    dwOptionFlags &= AF_OPTION_MASK | AF_OPTIONALCONFIG;
    for (parg = aarg ; parg < &aarg[ARRAYSIZE(aarg)]; parg++)
    {
	if (NULL != parg->pfnVerb)
	{
	    continue;
	}
	if (!g_fFullUsage && (AF_PRIVATE & parg->Flags))
	{
	    continue;
	}
	if (L'\0' == parg->pwszArg[0])
	{
	    continue;
	}
	if (1 >= g_fVerbose && (AF_OPTION_GENERIC & parg->Flags))
	{
	    continue;
	}
	if (dwOptionFlags & parg->Flags)
	{
	    wprintf(
		L"%ws%ws-%ws",
		pwszPrefix,
		wszLBRACKET,
		parg->pwszArg);
	    if (0 != parg->idsUsage)
	    {
		LoadUsage(parg);
		wprintf(L" %ws", parg->pwszUsage);
	    }
	    wprintf(wszRBRACKET);
	    pwszPrefix = L" ";
	    fDisplayed = TRUE;
	}
    }
    if (fDisplayed)
    {
	wprintf(wszNewLine);
    }
    return(fDisplayed);
}


VOID
DumpArgUsage(
    IN ARG *parg)
{
    WCHAR const *pwsz;
    int *paidsUsage;
    
    if (0 != parg->idsUsage)
    {
	LoadUsage(parg);
    }
    pwsz = parg->pwszUsage;
    while (TRUE)
    {
	wprintf(
	    L"  %ws [%ws] %ws-%ws%ws",
	    g_pwszProg,
	    myLoadResourceString(IDS_USAGE_OPTIONS),
	    pargDEFAULT	== parg? wszLBRACKET : L"",
	    parg->pwszArg,
	    pargDEFAULT	== parg? wszRBRACKET : L"");
	if (NULL != pwsz)
	{
	    DWORD cwc = 0;

	    cwc = wcscspn(pwsz, L"\r\n");
	    if (0 != cwc)
	    {
		wprintf(L" %.*ws", cwc, pwsz);
		pwsz += cwc;
	    }
	    while ('\r' == *pwsz || '\n' == *pwsz)
	    {
		pwsz++;
	    }
	}
	wprintf(wszNewLine);
	if (NULL == pwsz || L'\0' == *pwsz)
	{
	    break;
	}
    }
    if (0 != parg->idsDescription && NULL == parg->pwszDescription)
    {
	parg->pwszDescription = myLoadResourceString(
					    parg->idsDescription);
    }
    if (NULL != parg->pwszDescription)
    {
	wprintf(L"  %ws\n", parg->pwszDescription);
    }
    if (0 != parg->idsArgDescription)
    {
	HRESULT hr;
	WCHAR const *pwszArg = myLoadResourceString(parg->idsArgDescription);
	WCHAR *pwszArgFormatted = NULL;

	if (NULL != pwszArg && L'\0' != *pwszArg)
	{
	    if (IDS_STORE_ARGDESCRIPTION == parg->idsArgDescription)
	    {
		PatchStoreArgDescription();
	    }
	    if (0 == FormatMessage(
			    FORMAT_MESSAGE_ALLOCATE_BUFFER |
				FORMAT_MESSAGE_FROM_STRING |
				FORMAT_MESSAGE_ARGUMENT_ARRAY,
			    (VOID *) pwszArg,
			    0,              // dwMessageID
			    0,              // dwLanguageID
			    (LPWSTR) &pwszArgFormatted,
			    wcslen(pwszArg),
			    (va_list *) parg->papwszUsageConstants))
	    {
		hr = myHLastError();
		_PrintError(hr, "FormatMessage");
	    }
	    pwsz = NULL != pwszArgFormatted? pwszArgFormatted : pwszArg;
	    while (L'\0' != *pwsz)
	    {
		DWORD cwc = 0;

		cwc = wcscspn(pwsz, L"\r\n");
		if (0 != cwc)
		{
		    wprintf(L"    %.*ws", cwc, pwsz);
		    pwsz += cwc;
		}
		wprintf(wszNewLine);
		if ('\r' == *pwsz)
		{
		    pwsz++;
		}
		if ('\n' == *pwsz)
		{
		    pwsz++;
		}
	    }
	    if (NULL != pwszArgFormatted)
	    {
		LocalFree(pwszArgFormatted);
	    }
	}
    }
}


VOID
Usage(
    IN DWORD msgid,
    OPTIONAL WCHAR const *pwszMsg,
    IN DWORD dwOption,
    OPTIONAL IN ARG *pargVerb)
{
    ARG *parg;
    DWORD dwFlags = AF_OPTION_GENERIC;
    WCHAR const *pwszArg;
    DWORD i;
    DWORD adwids[] =
    {
	IDS_USAGE_LIST_VERBS,		// "display verb list (command list)"
	IDS_FORMAT_USAGE_ONE_HELP,	// "display help for the %ws verb"
	IDS_USAGE_ALL_HELP,		// "display help for all verbs"
    };
    WCHAR const *apwszCommandLine[] =
    {
	L"%ws -?",	// IDS_USAGE_LIST_VERBS
	L"%ws -%ws -?",	// IDS_FORMAT_USAGE_ONE_HELP
	L"%ws -v -?",	// IDS_USAGE_ALL_HELP
    };
    wsprintf(g_wszDefaultLangId, L"%u", GetSystemDefaultLangID());

    // Display the error message for the detected usage error.  If the error
    // message requires it, point at the optional arg string to be displayed
    // along with the error message.

    if (0 != msgid)
    {
	if (NULL == pwszMsg && 0 != dwOption)
	{
	    for (parg = aarg ; parg < &aarg[ARRAYSIZE(aarg)]; parg++)
	    {
		if (NULL != parg->pfnVerb)
		{
		    continue;
		}
		if (dwOption & parg->Flags)
		{
		    pwszMsg = parg->pwszArg;
		    break;
		}
	    }
	}

	// Display a command line usage error message.

	wprintf(L"%ws: ", g_pwszProg);
	wprintf(myLoadResourceString(msgid), pwszMsg);
	wprintf(L"\n\n");
    }
    else
    {
	// if no error and no verb selected, display all verbs & descriptions

	if (NULL == pargVerb)
	{
	    wprintf(L"\n%ws\n", myLoadResourceString(IDS_USAGE_VERBS));
	    for (parg = aarg ; parg < &aarg[ARRAYSIZE(aarg)]; parg++)
	    {
		if (!g_fFullUsage && (AF_PRIVATE & parg->Flags))
		{
		    continue;
		}
		if (L'\0' == parg->pwszArg[0])
		{
		    wprintf(wszNewLine);
		    continue;
		}
		if (NULL != parg->pfnVerb)
		{
		    dwFlags |= parg->Flags;
		    if (0 != parg->idsDescription &&
			NULL == parg->pwszDescription)
		    {
			parg->pwszDescription = myLoadResourceString(
							    parg->idsDescription);
		    }
		    wprintf(L"  -");
		    myConsolePrintString(CCOL_VERB, parg->pwszArg);
		    wprintf(L" -- %ws\n", parg->pwszDescription);
		}
	    }
	}
    }

    // if in verbose mode, display full usage for all verbs.
    // if verb was specified, display usage for one verb.

    if ((0 == msgid && g_fVerbose) || NULL != pargVerb)
    {
	ARG *pargStart;
	ARG *pargEnd;

	wprintf(L"%ws\n", myLoadResourceString(IDS_USAGE_HEADER));

	if (NULL != pargVerb)
	{
	    pargStart = pargVerb;	// display one verb
	    pargEnd = &pargVerb[1];
	}
	else
	{
	    pargStart = aarg;		// display all verbs
	    pargEnd = &aarg[ARRAYSIZE(aarg)];
	}

	for (parg = pargStart ; parg < pargEnd; parg++)
	{
	    if (!g_fFullUsage &&
		(AF_PRIVATE & parg->Flags) &&
		parg != pargVerb)
	    {
		continue;		// skip private verbs unless specified
	    }
	    if (L'\0' == parg->pwszArg[0])
	    {
		continue;		// skip newline separator entries
	    }
	    if (NULL != parg->pfnVerb)	// if it's a verb (not an option entry)
	    {
		dwFlags |= parg->Flags;
		DumpArgUsage(parg);
		if (g_fVerbose)
		{
		    DumpArgOptions(parg->Flags);
		}

		// Special case for CAInfo verb:

		if (IDS_CAINFO_USAGEARGS == parg->idsUsage &&
		    (g_fFullUsage ||
		     (0 == msgid && g_fVerbose) ||
		     parg == pargVerb))
		{
		    cuCAInfoUsage();
		}
		wprintf(wszNewLine);
	    }
	}

	// display options and descriptions for displayed verbs

	wprintf(L"%ws\n", myLoadResourceString(IDS_OPTIONS_USAGEARGS));
	for (parg = aarg ; parg < &aarg[ARRAYSIZE(aarg)]; parg++)
	{
	    if (L'\0' == parg->pwszArg[0])
	    {
		continue;
	    }
	    if (NULL != parg->pfnVerb)
	    {
		continue;
	    }
	    if (!g_fFullUsage && (AF_PRIVATE & parg->Flags))
	    {
		continue;
	    }

	    // skip options for undisplayed verbs,
	    // unless in verbose mode and no verb was specified

	    if ((!g_fVerbose || NULL != pargVerb) &&
		0 == ((AF_OPTION_MASK | AF_OPTIONALCONFIG) & dwFlags & parg->Flags))
	    {
		continue;
	    }
	    wprintf(L"  -");
	    if (0 != parg->idsUsage)
	    {
		LONG ccol;
		LONG ccolOption = NULL != parg->ppString?
				    CCOL_OPTIONARG : CCOL_OPTIONBARE;
		
		LoadUsage(parg);
		ccol = myConsolePrintString(0, parg->pwszArg);
		wprintf(L" ");
		ccol++;
		myConsolePrintString(
				ccolOption <= ccol? 0 : ccolOption - ccol,
				parg->pwszUsage);
	    }
	    else
	    {
		myConsolePrintString(CCOL_OPTIONBARE, parg->pwszArg);
	    }
	    if (0 != parg->idsDescription && NULL == parg->pwszDescription)
	    {
		parg->pwszDescription = myLoadResourceString(
							parg->idsDescription);
	    }
	    wprintf(L" -- %ws\n", parg->pwszDescription);
	}

	for (parg = aarg ; parg < &aarg[ARRAYSIZE(aarg)]; parg++)
	{
	    FreeUsage(parg);
	}
    }

    pwszArg = (NULL != pargVerb && NULL != pargVerb->pwszArg)?
		pargVerb->pwszArg : pargDEFAULT->pwszArg;

    wprintf(wszNewLine);
    for (i = 0; i < ARRAYSIZE(adwids); i++)
    {
	LONG ccol;
	WCHAR wsz[128];
	
	_snwprintf(
		wsz,
		ARRAYSIZE(wsz) - 1,
		apwszCommandLine[i],
		g_pwszProg,
		pwszArg);
	wsz[ARRAYSIZE(wsz) - 1] = L'\0';
	myConsolePrintString(CCOL_OPTIONARG, wsz);
	wprintf(L" -- ");
	wprintf(myLoadResourceString(adwids[i]), pwszArg);
	wprintf(wszNewLine);
    }
    wprintf(wszNewLine);
}


HRESULT
verbUsage(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszError,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    Usage(0, NULL, 0, NULL);
    return(S_OK);
}


VOID
cuUnloadCert(
    IN OUT CERT_CONTEXT const **ppCertContext)
{
    if (NULL != *ppCertContext)
    {
	CertFreeCertificateContext(*ppCertContext);
	*ppCertContext = NULL;
    }
}


HRESULT
cuLoadCert(
    IN WCHAR const *pwszfnCert,
    OUT CERT_CONTEXT const **ppCertContext)
{
    HRESULT hr;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    CERT_INFO *pCertInfo = NULL;
    DWORD cbCertInfo;

    *ppCertContext = NULL;

    hr = DecodeFileW(pwszfnCert, &pbCert, &cbCert, CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }

    // Decode certificate

    cbCertInfo = 0;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_TO_BE_SIGNED,
		    pbCert,
		    cbCert,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pCertInfo,
		    &cbCertInfo))
    {
	hr = myHLastError();
	_JumpError2(hr, error, "myDecodeObject", CRYPT_E_ASN1_BADTAG);
    }

    *ppCertContext = CertCreateCertificateContext(
				X509_ASN_ENCODING,
				pbCert,
				cbCert);
    if (NULL == *ppCertContext)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }

error:
    if (NULL != pCertInfo)
    {
	LocalFree(pCertInfo);
    }
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    return(hr);
}


VOID
cuUnloadCRL(
    IN OUT CRL_CONTEXT const **ppCRLContext)
{
    if (NULL != *ppCRLContext)
    {
	CertFreeCRLContext(*ppCRLContext);
	*ppCRLContext = NULL;
    }
}


HRESULT
cuLoadCRL(
    IN WCHAR const *pwszfnCRL,
    OUT CRL_CONTEXT const **ppCRLContext)
{
    HRESULT hr;
    BYTE *pbCRL = NULL;
    DWORD cbCRL;
    CRL_INFO *pCRLInfo = NULL;
    DWORD cbCRLInfo;

    *ppCRLContext = NULL;

    hr = DecodeFileW(pwszfnCRL, &pbCRL, &cbCRL, CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }

    // Decode CRL

    cbCRLInfo = 0;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_CRL_TO_BE_SIGNED,
		    pbCRL,
		    cbCRL,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pCRLInfo,
		    &cbCRLInfo))
    {
	hr = myHLastError();
	_JumpError2(hr, error, "myDecodeObject", CRYPT_E_ASN1_BADTAG);
    }

    *ppCRLContext = CertCreateCRLContext(
				X509_ASN_ENCODING,
				pbCRL,
				cbCRL);
    if (NULL == *ppCRLContext)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCRLContext");
    }

error:
    if (NULL != pCRLInfo)
    {
	LocalFree(pCRLInfo);
    }
    if (NULL != pbCRL)
    {
	LocalFree(pbCRL);
    }
    return(hr);
}


HRESULT
cuSetConfig()
{
    HRESULT hr;

    if (NULL == g_pwszConfig)
    {
	hr = myGetConfig(CC_LOCALCONFIG, &g_pwszConfigAlloc);
	if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
	{
	    wprintf(
		myLoadResourceString(IDS_ERR_FORMAT_NO_LOCAL_CONFIG), // "%ws: No local Certification Authority; use -config option"
		g_pwszProg);
	    wprintf(wszNewLine);
	    
	}
	_JumpIfError(hr, error, "myGetConfig");
    }
    else if (myIsMinusSignString(g_pwszConfig))
    {
	hr = myGetConfig(CC_UIPICKCONFIG, &g_pwszConfigAlloc);
	if (S_OK != hr)
	{
	    cuPrintError(IDS_ERR_CONFIGGETCONFIG, hr);
	    goto error;
	}
    }
    if (NULL != g_pwszConfigAlloc)
    {
	g_pwszConfig = g_pwszConfigAlloc;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
ArgvMain(
    int argc,
    WCHAR *argv[],
    HWND hWndOwner)
{
    WCHAR const *pwszArg1 = NULL;
    WCHAR const *pwszArg2 = NULL;
    WCHAR const *pwszArg3 = NULL;
    WCHAR const *pwszArg4 = NULL;
    BOOL fDlgResult;
    ARG *pargVerb = NULL;
    DWORD dwOptionFlags = 0;
    DWORD dwExtraOptions;
    ARG *parg;
    HRESULT hr;
    BOOL fCoInit = FALSE;
    DWORD VerbFlags = 0;
    BOOL fInitCS = FALSE;
	
    __try
    {
	InitializeCriticalSection(&g_DBCriticalSection);
	fInitCS = TRUE;
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "InitializeCriticalSection");

    myVerifyResourceStrings(g_hInstance);

#ifdef TESTUUENCODE
    RunTests();
#endif

    while (1 < argc && myIsSwitchChar(argv[1][0]))
    {
	if (0 == LSTRCMPIS(&argv[1][1], L"stdio"))
	{
	    myConsolePrintfDisable(TRUE);
	}
	else if (0 == lstrcmp(&argv[1][1], L"uSAGE"))
	{
	    g_fFullUsage = TRUE;
	    Usage(0, NULL, 0, pargVerb);
	    hr = S_OK;
	    goto error;
	}
	else
	{
	    if (myIsMinusSign(argv[1][0]) &&
		(((AF_STOPATMINUSSIGN & VerbFlags) &&
		  L'\0' == argv[1][1]) ||
		 ((AF_STOPATMINUSSIGNARG & VerbFlags) &&
		  L'\0' != argv[1][1] &&
		  0 != LSTRCMPIS(&argv[1][1], L"?"))))
	    {
		break;
	    }
	    for (parg = aarg; ; parg++)
	    {
		if (parg >= &aarg[ARRAYSIZE(aarg)])
		{
		    Usage(
			IDS_FORMAT_USAGE_UNKNOWNARG,	// "Unknown arg: %ws"
			argv[1],
			0,
			pargVerb);
		    hr = S_FALSE;
		    goto error;
		}
		if (0 == mylstrcmpiS(&argv[1][1], parg->pwszArg))
		{
		    break;
		}
	    }
	    if (NULL != parg->pBool)
	    {
		(*parg->pBool)++;
		dwOptionFlags |= parg->Flags;
	    }
	    if (NULL != parg->ppString)
	    {
		if (2 >= argc)
		{
		    Usage(IDS_FORMAT_USAGE_MISSINGNAMEDARG, parg->pwszArg, 0, pargVerb); // "Missing %ws argument"
		    hr = S_FALSE;
		    goto error;
		}
		if (NULL != *parg->ppString)
		{
		    Usage(IDS_FORMAT_USAGE_REPEATEDNAMEDARG, parg->pwszArg, 0, pargVerb); // "Repeated %ws option"
		    hr = S_FALSE;
		    goto error;
		}
		*parg->ppString = argv[2];
		dwOptionFlags |= parg->Flags;
		argc--;
		argv++;
	    }
	    if (NULL != parg->pfnVerb)
	    {
		if (NULL != pargVerb)
		{
		    Usage(
			verbUsage == parg->pfnVerb?
			    0 :
			    IDS_FORMAT_USAGE_MULTIPLEVERBARGS, // "Multiple verb args: %ws"
			argv[1],
			0,
			pargVerb);
		    hr = S_FALSE;
		    goto error;
		}
		pargVerb = parg;
		VerbFlags = pargVerb->Flags;
	    }
	}
	argc--;
	argv++;
    }
    if (NULL == pargVerb)
    {
	pargVerb = pargDEFAULT;
    }
    if (pargVerb->cArgMin > argc - 1)
    {
	wprintf(
	    myLoadResourceString(IDS_ERR_FORMAT_SHOW_TOO_FEW_ARGS), // "Expected at least %u args, received %u"
	    pargVerb->cArgMin,
	    argc - 1);
	wprintf(wszNewLine);

	Usage(IDS_USAGE_MISSINGARG, NULL, 0, pargVerb); // "missing argument"
	hr = S_FALSE;
	goto error;
    }
    if (pargVerb->cArgMax < argc - 1)
    {
	wprintf(
	    myLoadResourceString(IDS_ERR_FORMAT_SHOW_TOO_MANY_ARGS), // "Expected no more than %u args, received %u"
	    pargVerb->cArgMax,
	    argc - 1);

	wprintf(wszNewLine);

	Usage(IDS_USAGE_TOOMANYARGS, NULL, 0, pargVerb); // "too many arguments"
	hr = S_FALSE;
	goto error;
    }

    g_DispatchFlags = DISPSETUP_COM;
    if (g_fIDispatch)
    {
	g_DispatchFlags = DISPSETUP_IDISPATCH;
	if (1 < g_fIDispatch)
	{
	    g_DispatchFlags = DISPSETUP_COMFIRST;
	}
    }
    if (g_fForce)
    {
	g_EncodeFlags = DECF_FORCEOVERWRITE;
    }
    if (g_fNoCR)
    {
	g_CryptEncodeFlags = CRYPT_STRING_NOCR;
    }
    if (NULL != g_pwszmsTimeout)
    {
	hr = myGetLong(g_pwszmsTimeout, (LONG *) &g_dwmsTimeout);
	_JumpIfError(hr, error, "Timeout must be a number");

	// zero implies a 15 second timeout in CAPI.
	// If the timeut was explicitly set to 0, get as close as we can (1ms).

	if (0 == g_dwmsTimeout)
	{
	    g_dwmsTimeout = 1;
	}
    }
#if 0
    wprintf(
	L"-%ws: %ws %ws carg=%u-%u Flags=%x pfn=%x\n",
	pargVerb->pwszArg,
	pargVerb->pwszUsage,
	pargVerb->pwszDescription,
	pargVerb->cArgMin,
	pargVerb->cArgMax,
	pargVerb->Flags,
	pargVerb->pfnVerb);
#endif

    hr = myGetComputerNames(&g_pwszDnsName, &g_pwszOldName);
    _JumpIfError(hr, error, "myGetComputerNames");

    if (AF_NEEDCOINIT & pargVerb->Flags)
    {
	hr = CoInitialize(NULL);
	if (S_OK != hr && S_FALSE != hr)
	{
	    _JumpError(hr, error, "CoInitialize");
	}
	fCoInit = TRUE;
    }

    if (AF_OPTION_CONFIG & pargVerb->Flags)
    {
	if (0 == (AF_NEEDCOINIT & pargVerb->Flags))
	{
	    Usage(IDS_USAGE_INTERNALVERBTABLEERROR, NULL, 0, pargVerb); // "Missing fCoInit flag"
	    hr = S_FALSE;
	    goto error;
	}
	hr = cuSetConfig();
	_JumpIfError(hr, error, "cuSetConfig");
    }
    else if (0 == (AF_OPTIONALCONFIG & pargVerb->Flags))
    {
	if (NULL != g_pwszConfig)
	{
	    Usage(IDS_FORMAT_USAGE_EXTRAOPTION, NULL, AF_OPTION_CONFIG, pargVerb); // "Unexpected -%ws"
	    hr = S_FALSE;
	    goto error;
	}
    }
    if (NULL != g_pwszOut && 0 == (AF_OPTION_OUT & pargVerb->Flags))
    {
	Usage(IDS_FORMAT_USAGE_EXTRAOPTION, NULL, AF_OPTION_OUT, pargVerb); // "Unexpected %ws option"
	hr = S_FALSE;
	goto error;
    }
    if (NULL != g_pwszRestrict && 0 == (AF_OPTION_RESTRICT & pargVerb->Flags))
    {
	Usage(IDS_FORMAT_USAGE_EXTRAOPTION, NULL, AF_OPTION_RESTRICT, pargVerb); // "Unexpected %ws option"
	hr = S_FALSE;
	goto error;
    }
    dwExtraOptions = AF_OPTION_MASK &
			~AF_OPTION_GENERIC &
			dwOptionFlags &
			~pargVerb->Flags;

    if ((AF_OPTION_CONFIG & dwExtraOptions) &&
	(AF_OPTIONALCONFIG & pargVerb->Flags))
    {
	dwExtraOptions &= ~AF_OPTION_CONFIG;
    }
    if (0 != dwExtraOptions)
    {
	DBGPRINT((
	    DBG_SS_CERTUTIL,
	    "Extra options: 0x%x\n",
	    dwExtraOptions));
	Usage(IDS_FORMAT_USAGE_EXTRAOPTION, NULL, dwExtraOptions, pargVerb); // "Unexpected %ws option"
	hr = S_FALSE;
	goto error;
    }

    if (1 < argc)
    {
	pwszArg1 = argv[1];
	if (2 < argc)
	{
	    pwszArg2 = argv[2];
	    if (3 < argc)
	    {
		pwszArg3 = argv[3];
		if (4 < argc)
		{
		    pwszArg4 = argv[4];
		}
	    }
	}
    }

    __try
    {
	hr = (*pargVerb->pfnVerb)(
			    pargVerb->pwszArg,
			    pwszArg1,
			    pwszArg2,
			    pwszArg3,
			    pwszArg4);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    if (S_OK != hr)
    {
	WCHAR awchr[cwcHRESULTSTRING];

	wprintf(
	    myLoadResourceString(IDS_ERR_FORMAT_COMMAND_FAILED), // "%ws: -%ws command FAILED: %ws"
	    g_pwszProg,
	    pargVerb->pwszArg,
	    myHResultToString(awchr, hr));
	wprintf(wszNewLine);
	goto error;
    }
    if (!g_fCryptSilent)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_COMMAND_SUCCEEDED), // "%ws: -%ws command completed successfully."
	    g_pwszProg,
	    pargVerb->pwszArg);
	wprintf(wszNewLine);
	if (AF_RESTARTSERVER & pargVerb->Flags)
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_RESTART_SERVER), // "The %ws service may need to be restarted for changes to take effect."
		wszSERVICE_NAME);
	    wprintf(wszNewLine);
	}
    }
	
error:
    if (S_OK != hr && S_FALSE != hr)
    {
	cuPrintErrorMessageText(hr);
        if (0 != g_uiExtraErrorInfo)
        {
            wprintf(myLoadResourceString(g_uiExtraErrorInfo));
            wprintf(wszNewLine);
        }
	if (NULL != g_pwszPassword)
	{
	    myZeroDataString(g_pwszPassword);	// password data
	}
    }
    if (fCoInit)
    {
	CoUninitialize();
    }
    if (fInitCS)
    {
	DeleteCriticalSection(&g_DBCriticalSection);
    }
    return(hr);
}


//**************************************************************************
//  FUNCTION:	CertUtilPreMain
//  NOTES:	Based on vich's MkRootMain function; takes an LPSTR command
//		line and chews it up into argc/argv form so that it can be
//		passed on to a traditional C style main.
//**************************************************************************

#define ISBLANK(wc)	(L' ' == (wc) || L'\t' == (wc))

HRESULT 
CertUtilPreMain(
    IN WCHAR const *pwszCmdLine,
    IN HWND hWndOwner)
{
    HRESULT hr;
    WCHAR const *pwszCmdLineT;
    WCHAR *pbuf;
    WCHAR *apwszArg[20];
    DWORD i;
    DWORD cwc;
    DWORD cArg = 0;
    WCHAR *p;
    WCHAR const *pchQuote;
    WCHAR *pwszLog = NULL;
    int carg;
    BOOL fMainCompleted = FALSE;
    UINT idsError = 0;
    WCHAR wcQuote;

    pbuf = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszCmdLine) + 1) * sizeof(WCHAR));
    if (NULL == pbuf)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    p = pbuf;

    apwszArg[cArg++] = TEXT("CertUtil");
    pwszCmdLineT = pwszCmdLine;
    while (*pwszCmdLineT != TEXT('\0'))
    {
	while (ISBLANK(*pwszCmdLineT))
	{
	    pwszCmdLineT++;
	}
	if (*pwszCmdLineT != TEXT('\0'))
	{
	    apwszArg[cArg++] = p;
	    if (sizeof(apwszArg)/sizeof(apwszArg[0]) <= cArg)
	    {
		idsError = IDS_USAGE_TOOMANYARGS;
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Too many args");
	    }
	    pchQuote = NULL;
	    while (*pwszCmdLineT != L'\0')
	    {
		if (NULL != pchQuote)
		{
		    if (*pwszCmdLineT == *pchQuote)
		    {
			pwszCmdLineT++;
			pchQuote = NULL;
			continue;
		    }
		}
		else
		{
		    if (ISBLANK(*pwszCmdLineT))
		    {
			break;
		    }
		    if (L'"' == *pwszCmdLineT)
		    {
			pchQuote = pwszCmdLineT++;
			continue;
		    }
#define wcLENQUOTE	(WCHAR) 0x201c
#define wcRENQUOTE	(WCHAR) 0x201d
		    else if (wcLENQUOTE == *pwszCmdLineT)
		    {
			pwszCmdLineT++;
			wcQuote = wcRENQUOTE;
			pchQuote = &wcQuote;
			continue;
		    }
		}
		*p++ = *pwszCmdLineT++;
	    }
	    *p++ = TEXT('\0');
	    if (*pwszCmdLineT != TEXT('\0'))
	    {
		pwszCmdLineT++;	// skip whitespace or quote character
	    }
	}
    }
    apwszArg[cArg] = NULL;

    // Don't log passwords!

    cwc = 0;
    for (i = 0; i < cArg; i++)
    {
	cwc += 1 + wcslen(apwszArg[i]);
	if (NULL != wcschr(apwszArg[i], L' '))
	{
	    cwc += 2;
	}
    }
    pwszLog = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszLog)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *pwszLog = L'\0';
    for (i = 0; i < cArg; i++)
    {
	BOOL fQuote = NULL != wcschr(apwszArg[i], L' ');
	if (0 != i)
	{
	    wcscat(pwszLog, L" ");
	}
	if (0 == i ||
	    !myIsSwitchChar(apwszArg[i - 1][0]) ||
	    0 != LSTRCMPIS(&apwszArg[i - 1][1], L"p"))
	{
	    if (fQuote)
	    {
		wcscat(pwszLog, L"\"");
	    }
	    wcscat(pwszLog, apwszArg[i]);
	    if (fQuote)
	    {
		wcscat(pwszLog, L"\"");
	    }
	}
	else
	{
	    WCHAR const *pwc = apwszArg[i];
	    
	    while (TRUE)
	    {
		WCHAR const *pwszCat = L"-";
		
		switch (*pwc)
		{
		    case L'*':
			if (L'\0' == pwc[1])
			{
			    pwszCat = L"*";
			}
			break;

		    case L',':
			pwszCat = L"";	// avoid buffer overflow
			break;
		}
		wcscat(pwszLog, pwszCat);
		pwc = wcschr(pwc, L',');
		if (NULL == pwc)
		{
		    break;
		}
		pwc++;
		wcscat(pwszLog, L",");
	    }
	}
    }
    CSASSERT(wcslen(pwszLog) <= cwc);

    CSILOG(S_OK, IDS_LOG_COMMANDLINE, pwszLog, NULL, NULL);

    hr = ArgvMain(cArg, apwszArg, hWndOwner);
    fMainCompleted = TRUE;
    _JumpIfError2(hr, error, "ArgvMain", S_FALSE);

error:
    if (S_OK != hr && !fMainCompleted)
    {
	cuPrintErrorAndString(L"CertUtil", idsError, hr, pwszCmdLine);
    }
    if (NULL != pwszLog)
    {
	LocalFree(pwszLog);
    }
    if (NULL != pbuf)
    {
	LocalFree(pbuf);
    }
    CSILOG(hr, S_OK != hr? IDS_LOG_STATUS : IDS_LOG_STATUSOK, NULL, NULL, NULL);
    return(hr);
}


//**************************************************************************
//  FUNCTION:	MainWndProc(...)
//  ARGUMENTS:
//**************************************************************************

LRESULT APIENTRY
MainWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    LRESULT lr = 0;
    WCHAR *pwszCmdLine;

    switch (msg)
    {
        case WM_CREATE:
        case WM_SIZE:
	    break;

        case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

        case WM_DOCERTUTILMAIN:
	    pwszCmdLine = (WCHAR*)lParam;
	    hr = CertUtilPreMain(pwszCmdLine, hWnd);

	    PostQuitMessage(hr);
	    break;

        default:
	    lr = DefWindowProc(hWnd, msg, wParam, lParam);
	    break;
    }
    return(lr);
}


//+------------------------------------------------------------------------
//
//  Function:	wWinMain()
//
//  Synopsis:	Entry Point
//
//  Arguments:	[hInstance]	--	Instance handle
//		[hPrevInstance] --	Obsolete
//		[pwszCmdLine]	--	App command line
//		[nCmdShow]	--	Starting show state
//
//  History:	12/07/96	JerryK	Added this Comment
//
//-------------------------------------------------------------------------

extern "C" int APIENTRY
wWinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPWSTR pwszCmdLine,
    int nCmdShow)
{
    int ret;
    MSG msg;
    WNDCLASS wcApp;
    HWND hWndMain;

    _setmode(_fileno(stdout), _O_TEXT);
    _wsetlocale(LC_ALL, L".OCP");
    mySetThreadUILanguage(0);

    // Save the current instance
    g_hInstance = hInstance;

    csiLogOpen("+certutil.log");
    CSILOGFILEVERSION(0, L"certutil.exe", szCSVER_STR);

    // Set up the application's window class
    wcApp.style		= 0;
    wcApp.lpfnWndProc	= MainWndProc;
    wcApp.cbClsExtra	= 0;
    wcApp.cbWndExtra	= 0;
    wcApp.hInstance	= hInstance;
    wcApp.hIcon		= LoadIcon(NULL,IDI_APPLICATION);
    wcApp.hCursor	= LoadCursor(NULL,IDC_ARROW);
    wcApp.hbrBackground	= (HBRUSH)GetStockObject(WHITE_BRUSH);
    wcApp.lpszMenuName	= NULL;
    wcApp.lpszClassName	= wszAppName;

    if (!RegisterClass(&wcApp))
    {
	ret = GetLastError();
	goto error;
    }

    // Create Main Window
    hWndMain = CreateWindow(
			wszAppName,
			L"CertUtil Application",
			WS_OVERLAPPEDWINDOW,
			CW_USEDEFAULT, CW_USEDEFAULT,
			CW_USEDEFAULT, CW_USEDEFAULT,
			NULL,
			NULL,
			hInstance,
			NULL);
    if (NULL == hWndMain)
    {
	ret = GetLastError();
	goto error;
    }

    // Make window visible
    // ShowWindow(hWndMain, nCmdShow);

    // Update window client area
    UpdateWindow(hWndMain);

    // Send off the message to get things started
    PostMessage(hWndMain, WM_DOCERTUTILMAIN, 0, (LPARAM) pwszCmdLine);

    // Message Loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    }
    ret = (int) msg.wParam;

error:
    if (NULL != g_pwszDnsName)
    {
	LocalFree(g_pwszDnsName);
    }
    if (NULL != g_pwszOldName)
    {
	LocalFree(g_pwszOldName);
    }
    if (NULL != g_pwszConfigAlloc)
    {
	LocalFree(g_pwszConfigAlloc);
    }
    FreeStoreArgDescription();
    myFreeResourceStrings("certutil.exe");
    myFreeColumnDisplayNames();
    myRegisterMemDump();
    csiLogClose();
    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\certutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certut.h
//
//--------------------------------------------------------------------------

#include "resource.h"

const DWORD KMS_LOCKBOX_TAG      = 1;
const DWORD KMS_SIGNING_CERT_TAG = 2;
const DWORD KMS_SIGNATURE_TAG    = 3;
const DWORD KMS_USER_RECORD_TAG  = 4;

typedef struct _TagHeader {
    DWORD   tag;
    DWORD   cbSize;
} TagHeader;


typedef DWORD CERTFLAGS;
const CERTFLAGS CERTFLAGS_ALL           = 0xFFFFFFFF;
const CERTFLAGS CERTFLAGS_UNKNOWN       = 0x00000000;
        // nibble reserved for version number   V
const CERTFLAGS CERTFLAGS_REVOKED       = 0x00000001;
const CERTFLAGS CERTFLAGS_NOT_EXPIRED   = 0x00000002;
const CERTFLAGS CERTFLAGS_SIGNING       = 0x00000004;
const CERTFLAGS CERTFLAGS_SEALING       = 0x00000008;
const CERTFLAGS CERTFLAGS_CURRENT       = 0x00000010;
const CERTFLAGS CERTFLAGS_IMPORTED      = 0x00000100;

// these are broken V1 certs, not standard version 1
const CERTFLAGS CERTFLAGS_VERSION_1     = 0x00001000;

// KMServer does not use version 2 certs
// const CERTFLAGS CERTFLAGS_VERSION_2  = 0x00002000;

// these are proper version 3 certs
const CERTFLAGS CERTFLAGS_VERSION_3     = 0x00003000;

#define wszKMSCERTSTATUS	L"KMS.status"

#define cwcAUTOPASSWORDMAX	16

#define wszCUREGDSTEMPLATEFLAGS	L"DSTemplateFlags"
#define wszCUREGDSCAFLAGS	L"DSCAFlags"
#define wszCUREGDSOIDFLAGS	L"DSOIDFlags"

#define wszREQUESTCLIENTID	L"RequestClientId"

extern WCHAR const g_wszAppName[];
extern WCHAR const *g_pwszProg;
extern HINSTANCE g_hInstance;

extern WCHAR const g_wszAttrib[];
extern WCHAR const g_wszExt[];
extern WCHAR const g_wszCRL[];

extern BOOL g_fIDispatch;
extern BOOL g_fEnterpriseRegistry;
extern BOOL g_fUserRegistry;
extern BOOL g_fUserTemplates;
extern BOOL g_fMachineTemplates;
extern BOOL g_fFullUsage;
extern BOOL g_fReverse;
extern BOOL g_fForce;
extern BOOL g_fVerbose;
extern BOOL g_fGMT;
extern BOOL g_fSeconds;
extern BOOL g_fDispatch;
extern DWORD g_DispatchFlags;
extern BOOL g_fQuiet;
extern DWORD g_EncodeFlags;
extern DWORD g_CryptEncodeFlags;
extern BOOL g_fCryptSilent;
extern BOOL g_fV1Interface;
extern BOOL g_fSplitASN;
extern BOOL g_fAdminInterface;
extern BOOL g_fProtect;
extern BOOL g_fWeakPFX;
extern BOOL g_fURLFetch;

extern DWORD g_dwmsTimeout;

extern WCHAR *g_pwszConfig;
extern WCHAR *g_pwszDC;
extern WCHAR *g_pwszOut;
extern WCHAR *g_pwszPassword;
extern WCHAR *g_pwszCSP;
extern WCHAR *g_pwszRestrict;
extern WCHAR *g_pwszDnsName;
extern WCHAR *g_pwszOldName;

extern WCHAR const g_wszEmpty[];
extern WCHAR const g_wszPad2[];
extern WCHAR const g_wszPad4[];
extern WCHAR const g_wszPad6[];
extern WCHAR const g_wszPad8[];
extern WCHAR const wszNewLine[];

extern UINT g_uiExtraErrorInfo;

extern WCHAR const g_wszSchema[];
extern WCHAR const g_wszEncode[];
extern WCHAR const g_wszEncodeHex[];
extern WCHAR const g_wszViewDelStore[];

extern WCHAR const g_wszCACert[];
extern WCHAR const g_wszCAChain[];
extern WCHAR const g_wszGetCRL[];
extern WCHAR const g_wszCAInfo[];

extern WCHAR const g_wszCAInfoCRL[];

extern CRITICAL_SECTION g_DBCriticalSection;

typedef HRESULT (FNVERB)(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4);

FNVERB verbUsage, verbDump, verbGetConfig,
    verbGetConfig2, verbGetCACertificate, verbVerifyKeys, verbVerifyCert,
    verbCheck7f, verbHexTranslate, verbBase64Translate, verbDenyRequest,
    verbResubmitRequest, verbRevokeCertificate, verbSetAttributes,
    verbSetExtension, verbPublishCRL, verbGetCRL, verbIsValidCertificate,
    verbViewDump, verbDBDump, verbPing, verbPingAdmin, verbShutDownServer,
    verbBackupPFX, verbRestorePFX, verbStore, verbBackupDB, verbRestoreDB,
    verbCSPList, verbCSPTest, verbBackup, verbRestore, verbAddStore,
    verbDelStore, verbVerifyStore, verbOIDName, verbImportCertificate,
    verbDynamicFileList, verbDatabaseLocations, verbGetReg, verbSetReg,
    verbErrorDump, verbCreateVRoots, verbConvertMDB, verbGetConfig3,
    verbSetMapiInfo, verbGetMapiInfo, verbInstallCACert, verbRenewCACert,
    verbKey, verbDelKey, verbExtractMDB, verbDS, verbDSDel, verbDSPublish,
    verbDSCert, verbDSCRL, verbDSDeltaCRL, verbGetCAInfo, verbGetCAPropInfo,
    verbGetCertFromUI, verbMACFile, verbGetKey, verbRecoverKey,
    verbRepairStore, verbDelReg, verbExportPVK, verbExportPFX, verbImportPFX,
    verbDSTemplate, verbDSAddTemplate, verbTemplate, verbTemplateCAs,
    verbCATemplates, verbImportKMS, verbURLCache, verbSign, verbDeleteRow,
    verbPulse, verbMachineInfo, verbDCInfo, verbEntInfo, verbTCAInfo,
    verbViewOrDeleteStore, verbSCInfo, verbMergePFX, verbURL, verbConvertEPF,
    verbSetCATemplates;

HRESULT
cuGetCAInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszInfoName,
    OPTIONAL IN WCHAR const *pwszNumber);

HRESULT
cuGetLocalCANameFromConfig(
    OPTIONAL OUT WCHAR **ppwszMachine,
    OPTIONAL OUT WCHAR **ppwszCA);

HRESULT
cuSetConfig();

HRESULT
cuSanitizeNameWithSuffix(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut);

HRESULT
cuGenerateKeyContainerName(
    IN CERT_CONTEXT const *pcc,
    OUT WCHAR **ppwszKeyContainerName);

VOID
cuPrintError(
    IN DWORD idmsg,
    IN HRESULT hr);

VOID
cuPrintAPIError(
    IN WCHAR const *pwszAPIName,
    IN HRESULT hr);

VOID
cuPrintErrorAndString(
    OPTIONAL IN WCHAR const *pwszProc,
    IN DWORD idmsg,
    IN HRESULT hr,
    OPTIONAL IN WCHAR const *pwszString);

VOID
cuPrintErrorMessageText(
    IN HRESULT hr);

BOOL
cuParseDecimal(
    IN OUT WCHAR const **ppwc,
    IN OUT DWORD *pcwc,
    OUT DWORD *pdw);

HRESULT
cuParseStrings(
    IN WCHAR const *pwszStrings,
    IN BOOL fMatchPrefix,
    OPTIONAL IN WCHAR const *pwszPrefix,
    OPTIONAL IN WCHAR const * const *apwszAllowedPrefixes,
    OUT WCHAR ***papwszStrings,
    OPTIONAL OUT BOOL *pfAllFields);

VOID
cuFreeStringArray(
    IN OUT WCHAR **apwsz);

VOID
cuFreeStringArrayA(
    IN OUT char **apsz);

VOID
cuConvertEscapeSequences(
    IN OUT WCHAR *pwsz);

HRESULT
cuGeneratePassword(
    IN DWORD cwcMax,
    OUT WCHAR *pwszPassword,
    IN DWORD cwcPassword);

HRESULT
cuGetPassword(
    OPTIONAL IN UINT idsPrompt,
    OPTIONAL IN WCHAR const *pwszfn,
    OPTIONAL IN WCHAR const *pwszPasswordIn,
    IN BOOL fVerify,
    OUT WCHAR *pwszPassword,
    IN DWORD cwcPassword,
    OUT WCHAR const **ppwszPasswordOut);

HRESULT
cuDumpFileTimePeriod(
    IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszQuote,
    IN FILETIME const *pftGMT);

HRESULT
cuDumpFileTime(
    IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszQuote,
    IN FILETIME const *pftGMT);

HRESULT
cuDumpFileTimeOrPeriod(
    IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszQuote,
    IN FILETIME const *pftGMT);

HRESULT
cuDumpDate(
    IN DATE const *pDate);

VOID
cuDumpSignature(
    OPTIONAL IN CERT_SIGNED_CONTENT_INFO const *pcsci);

HRESULT
cuDumpFormattedProperty(
    IN DWORD dwPropId,
    OPTIONAL IN char const *pszObjId,
    IN BYTE const *pb,
    IN DWORD cb);

HRESULT
cuDecodeObjId(
    IN BYTE const *pbData,
    IN DWORD cbData,
    char **ppszObjId);

HRESULT
cuEncodeObjId(
    IN char const *pszObjId,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData);

HRESULT
cuDecodeSequence(
    IN BYTE const *pbSeq,
    IN DWORD cbSeq,
    IN DWORD cSeq,
    OUT CRYPT_SEQUENCE_OF_ANY **ppSeq);

VOID
cuDumpAlgorithm(
    IN DWORD idMessage,
    IN CRYPT_ALGORITHM_IDENTIFIER const *pAlg);

BOOL
cuDumpFormattedExtension(
    IN WCHAR const *pwszName,
    IN BYTE const *pbObject,
    IN DWORD cbObject);

HRESULT
cuDumpExtensionArray(
    IN DWORD idMessage,
    IN DWORD cExtension,
    IN CERT_EXTENSION const *rgExtension);

HRESULT
cuDumpSerial(
    OPTIONAL IN WCHAR const *pwszPrefix,
    IN DWORD idMessage,
    IN CRYPT_INTEGER_BLOB const *pSerial);

HRESULT
cuDumpPrivateKey(
    IN CERT_CONTEXT const *pCert,
    OPTIONAL OUT BOOL *pfSigningKey,
    OPTIONAL OUT BOOL *pfMatchingKey);

VOID
cuDumpPublicKey(
    IN CERT_PUBLIC_KEY_INFO const *pKey);

VOID
cuDumpAlgid(
    IN DWORD Algid);

VOID
cuDumpVersion(
    IN DWORD dwVersion);

HRESULT
cuDumpPrivateKeyBlob(
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    IN BOOL fQuiet);

HRESULT
cuDumpCertKeyProviderInfo(
    IN WCHAR const *pwszPrefix,
    OPTIONAL IN CERT_CONTEXT const *pCert,
    OPTIONAL IN CRYPT_KEY_PROV_INFO *pkpi,
    OPTIONAL OUT CRYPT_KEY_PROV_INFO **ppkpi);

HRESULT
EPFFileDump(
    IN WCHAR const *pwszfn,
    OPTIONAL IN WCHAR const *pwszPassword,
    OPTIONAL IN OUT HCERTSTORE hStore);


#define EPFALG_DEFAULT		0
#define EPFALG_CASTEXPORT	1
#define EPFALG_CAST		2

HRESULT
EPFSaveCertStoreToFile(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszPassword,
    IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszV3CACertId,
    IN DWORD dwEPFAlg,
    OPTIONAL IN WCHAR const *pwszSalt);

HRESULT
myVerifyKMSKey(
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    IN DWORD dwKeySpec,
    IN BOOL fQuiet);

#define BLOB_ROUND(cb) \
	(((cb) + sizeof(CRYPT_DATA_BLOB) - 1) / sizeof(CRYPT_DATA_BLOB))

HRESULT
myDecodeKMSRSAKey(
    IN BYTE const *pbKMSRSAKey,
    IN DWORD cbKMSRSAKey,
    IN ALG_ID aiKeyAlg,
    OUT BYTE **ppbKey,
    OUT DWORD *pcbKey);

HRESULT
myEncodeKMSRSAKey(
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    OUT BYTE **ppbKMSRSAKey,
    OUT DWORD *pcbKMSRSAKey);

HRESULT
cuDumpAsnBinary(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD iElement);

HRESULT
cuDumpAsnBinaryQuiet(
    IN BYTE const *pb,
    IN DWORD cb,
    IN DWORD iElement);

HRESULT
cuSaveAsnToFile(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN int imajor,
    IN int ilevel,
    IN DWORD iElement,
    IN WCHAR const *pwszExtension);


#define DVNS_DUMP		0x000000000
#define DVNS_VERIFYCERT		0x000000001
#define DVNS_REPAIRKPI		0x000000002
#define DVNS_CASTORE		0x000000004
#define DVNS_DUMPKEYS		0x000000008
#define DVNS_DUMPPROPERTIES	0x000000010
#define DVNS_SAVECERT		0x000000100
#define DVNS_SAVECRL		0x000000200
#define DVNS_SAVECTL		0x000000400
#define DVNS_SAVEPFX		0x000000800
#define DVNS_SAVEPVK		0x000001000
#define DVNS_WRITESTORE		0x000002000
#define DVNS_DSSTORE		0x000004000


HRESULT
cuOpenCertStore(
    IN WCHAR const *pwszStoreName,
    IN OUT DWORD *pMode,
    OPTIONAL OUT WCHAR **ppwszStoreNameOut,
    OUT HCERTSTORE *phStore);

HRESULT
cuDumpAndVerifyStore(
    IN HCERTSTORE hStore,
    IN DWORD Mode,
    OPTIONAL IN WCHAR const *pwszCertName,
    IN DWORD iCertSave,
    IN DWORD iCRLSave,
    IN DWORD iCTLSave,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszPassword);

VOID
cuDumpOIDAndDescriptionA(
    IN char const *pszObjId);

VOID
cuDumpOIDAndDescription(
    IN WCHAR const *pwszObjId);

WCHAR const *
cuwszFromExtFlags(
    IN DWORD ExtFlags);

WCHAR const *
cuwszPropType(
   IN LONG PropType);


BOOL
cuRegPrintDwordValue(
    IN BOOL fPrintNameAndValue,
    IN WCHAR const *pwszLookupName,
    IN WCHAR const *pwszDisplayName,
    IN DWORD dwValue);

VOID
cuRegPrintAwszValue(
    IN WCHAR const *pwszName,
    OPTIONAL IN WCHAR const * const *prgpwszValues);

VOID
cuPrintSchemaEntry(
    OPTIONAL IN WCHAR const *pwszName,
    IN WCHAR const *pwszDisplayName,
    IN LONG Type,
    IN LONG cbMax);

VOID
cuUnloadCert(
    IN OUT CERT_CONTEXT const **ppCertContext);

HRESULT
cuLoadCert(
    IN WCHAR const *pwszfnCert,
    OUT CERT_CONTEXT const **ppCertContext);

VOID
cuUnloadCRL(
    IN OUT CRL_CONTEXT const **ppCRLContext);

HRESULT
cuLoadCRL(
    IN WCHAR const *pwszfnCRL,
    OUT CRL_CONTEXT const **ppCRLContext);

HRESULT
cuVerifySignature(
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERT_PUBLIC_KEY_INFO const *pcpki,
    IN BOOL fSuppressSuccess,
    IN BOOL fSuppressError);

HRESULT
cuDumpIssuerSerialAndSubject(
    IN CERT_NAME_BLOB const *pIssuer,
    IN CRYPT_INTEGER_BLOB const *pSerialNumber,
    OPTIONAL IN CERT_NAME_BLOB const *pSubject,
    OPTIONAL IN HCERTSTORE hStore);

HRESULT
cuDumpSigners(
    IN HCRYPTMSG hMsg,
    IN CHAR const *pszInnerContentObjId,
    IN HCERTSTORE hStore,
    IN DWORD cSigner,
    IN BOOL fContentEmpty,
    IN BOOL fVerifyOnly,
    OPTIONAL OUT BYTE *pbHashUserCert,
    OPTIONAL IN OUT DWORD *pcbHashUserCert);

HRESULT
cuDumpRecipients(
    IN HCRYPTMSG hMsg,
    IN HCERTSTORE hStoreWrapper,
    IN DWORD cRecipient,
    IN BOOL fQuiet);

HRESULT
cuDumpEncryptedAsnBinary(
    IN HCRYPTMSG hMsg,
    IN DWORD cRecipient,
    IN DWORD RecipientIndex,
    OPTIONAL IN HCERTSTORE hStoreWrapper,
    IN HCERTSTORE hStorePKCS7,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BOOL fQuiet,
    OPTIONAL OUT BYTE **ppbDecrypted,
    OPTIONAL OUT DWORD *pcbDecrypted);


#define VS_OTHERERROR		0x00000001
#define VS_EXPIRED		0x00000002
#define VS_REVOKED		0x00000004
#define VS_UNTRUSTEDROOT	0x00000008
#define VS_INCOMPLETECHAIN	0x00000010
#define VS_NOREVOCATIONCHECK	0x00000020
#define VS_REVOCATIONOFFLINE	0x00000040

#define VS_ROOT			0x40000000
#define VS_ROOTSIGOK		0x80000000
#define VS_ERRORMASK		(VS_OTHERERROR | \
				 VS_EXPIRED | \
				 VS_REVOKED | \
				 VS_UNTRUSTEDROOT | \
				 VS_INCOMPLETECHAIN)

HRESULT
cuVerifyCertContext(
    IN CERT_CONTEXT const *pCert,
    OPTIONAL IN HCERTSTORE hStoreCA,
    IN DWORD cApplicationPolicies,
    OPTIONAL IN char const * const *apszApplicationPolicies,
    IN DWORD cIssuancePolicies,
    OPTIONAL IN char const * const *apszIssuancePolicies,
    IN BOOL fNTAuth,
    OUT DWORD *pVerifyState);

VOID
cuDisplayCDPUrlsFromCertOrCRL(
    OPTIONAL IN CERT_CONTEXT const *pCert,
    OPTIONAL IN CRL_CONTEXT const *pCRL);

VOID
cuDisplayAIAUrlsFromCert(
    IN CERT_CONTEXT const *pCert);

HRESULT
cuDisplayCertName(
    IN BOOL fMultiLine,
    OPTIONAL IN WCHAR const *pwszNamePrefix,
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszPad,
    IN CERT_NAME_BLOB const *pNameBlob,
    OPTIONAL IN CERT_INFO const *pCertInfo);

HRESULT
cuDisplayCertNames(
    IN BOOL fMultiLine,
    OPTIONAL IN WCHAR const *pwszNamePrefix,
    IN CERT_INFO const *pCertInfo);

HRESULT
cuDisplayKeyId(
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN DWORD cExtension,
    OPTIONAL IN CERT_EXTENSION const *rgExtension);

HRESULT
cuDisplayHash(
    OPTIONAL IN WCHAR const *pwszPrefix,
    OPTIONAL IN CERT_CONTEXT const *pCertContext,
    OPTIONAL IN CRL_CONTEXT const *pCRLContext,
    IN DWORD dwPropId,
    IN WCHAR const *pwszHashName);

VOID
cuDisplayCAType(
    IN LONG CAType);

HRESULT
cuGetCertType(
    IN CERT_INFO const *pCertInfo,
    OPTIONAL OUT WCHAR **ppwszCertTypeNameV1,
    OPTIONAL OUT WCHAR **ppwszDisplayNameV1,
    OPTIONAL OUT WCHAR **ppwszCertTypeObjId,
    OPTIONAL OUT WCHAR **ppwszCertTypeName,
    OPTIONAL OUT WCHAR **ppwszDisplayName);

HRESULT
cuGetGroupMembership(
    IN WCHAR const *pwszSamName);

HRESULT
cuDumpCertType(
    OPTIONAL IN WCHAR const *pwszPrefix,
    IN CERT_INFO const *pCertInfo);

HRESULT
cuGetTemplateNames(
    IN WCHAR const *pwszTemplate,
    OUT WCHAR **ppwszCN,
    OUT WCHAR **ppwszDisplayName);

VOID
cuPrintCRLFString(
    IN WCHAR const *pwszPrefix,
    IN WCHAR const *pwszIn);

int
cuidCRLReason(
    IN LONG Reason);

WCHAR const *
cuGetOIDNameA(
    IN char const *pszObjId);

WCHAR const *
cuGetOIDName(
    IN WCHAR const *pwszObjId);

VOID
cuPrintPossibleObjectIdName(
    IN WCHAR const *pwszObjId);

HRESULT
cuLoadKeys(
    OPTIONAL IN WCHAR const *pwszProvName,
    IN OUT DWORD *pdwProvType,
    IN WCHAR const *pwszKeyContainerName,
    IN BOOL fMachineKeyset,
    IN BOOL fSoftFail,
    OPTIONAL OUT HCRYPTPROV *phProv,
    OPTIONAL OUT CERT_PUBLIC_KEY_INFO **ppPubKeyInfo,
    OPTIONAL OUT CERT_PUBLIC_KEY_INFO **ppPubKeyInfoXchg);

VOID
cuCAInfoUsage(VOID);

DWORD
cuFileSize(
    IN WCHAR const *pwszfn);

HRESULT
cuPingCertSrv(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT CAINFO **ppCAInfo);

DWORD
cuGetSystemStoreFlags();

HRESULT
cuVerifyKeyAuthority(
    IN CERT_NAME_BLOB const *pIssuer,
    IN CERT_INFO const *pCertInfoCA,
    IN BYTE const *pbData,
    IN DWORD cbData,
    IN BOOL fQuiet,
    OUT BOOL *pfKeyAuthorityMatch);

BOOL
cuVerifyMinimumBaseCRL(
    IN CRL_CONTEXT const *pCRLBase,
    IN CRL_CONTEXT const *pCRLDelta);

BOOL
cuVerifyIDP(
    IN CERT_CONTEXT const *pCertSubject,
    IN CRL_CONTEXT const *pCRL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\crcutil.h ===
/*
 * $Header:   /entproj/all/base/etfile/crcutil.h_v   1.3   Wed Dec 07 15:05:30 1994   markbc  $
 * $Log:   /entproj/all/base/etfile/crcutil.h_v  $
 * 
 *    Rev 1.3   Wed Dec 07 15:05:30 1994   markbc
 * Alpha port checkin
 * 
 *    Rev 1.2   19 Oct 1994 15:44:08   chucker
 * Synced up headers with the code.
 * 
 *    Rev 1.1   18 Aug 1994 11:33:46   dilkie
 * Protected INIFILE stuff
 * 
 *    Rev 1.0   11 Aug 1994 17:22:46    JackK
 * Initial file check in
 */

/***********************************************************************
* Prototypes and typedefs for the CRC utility routines.
*
* Author: Gary P. Mussar
* This code is released to the public domain. There are no restrictions,
* however, acknowledging the author by keeping this comment around
* would be appreciated.
***********************************************************************/

//#include <os_spec.h>

/***********************************************************************
* If we can handle ANSI prototyping, lets do it.
***********************************************************************/
//#ifdef __cplusplus
//extern "C" {            /* Assume C declarations for C++ */
//#endif	/* __cplusplus */


//#ifdef NEEDPROTOS
#define PARMS(x) x
//#else
//#define PARMS(x) ()
//#endif

/***********************************************************************
* The following #defines are used to define the types of variables
* used to hold or manipulate CRCs. The 16 bit CRCs require a data
* type with at least 16 bits. The 32 bit CRCs require a data type
* with at least 32 bits. In addition, the data bits reserved for the
* CRC must be manipulated in an unsigned fashion. It is possible to
* define a data type which is larger than required to hold the CRC,
* however, this is an inefficient use of memory and usually results
* in less efficient code when manipulating the CRCs.
***********************************************************************/

#define CRC16 unsigned short int
#define CRC32 UINT32

/***********************************************************************
* Utilities for fast CRC using table lookup
*
* I_CRCxx  -  Initialize the 256 entry CRC lookup table based on the
*             specified generator polynomial.
* Input:
*    Table[256]     - Lookup table
*    *GenPolynomial - Pointer to generator polynomial
*
* F_CRCxx  -  Calculate CRC over an array of characters using fast
*             table lookup.
* Input:
*    Table[256]    - Lookup table
*    *CRC          - Pointer to the variable containing the result of
*                    CRC calculations of previous characters. The CRC
*                    variable must be initialized to a known value
*                    before the first call to this routine.
*    *dataptr      - Pointer to array of characters to be included in
*                    the CRC calculation.
*    count         - Number of characters in the array.
*
* S_CRCxx  -  Calculate CRC over an array of characters using slower but
*             smaller non-table lookup method.
* Input:
*    *GenPolynomial - Pointer to generator polynomial
*    *CRC           - Pointer to the variable containing the result of
*                     CRC calculations of previous characters. The CRC
*                     variable must be initialized to a known value
*                     before the first call to this routine.
*    *dataptr       - Pointer to array of characters to be included in
*                     the CRC calculation.
*    count          - Number of characters in the array.
***********************************************************************/
extern void I_CRC16 PARMS((CRC16 Table[256],         \
					CRC16 *GenPolynomial));

extern void F_CRC16 PARMS((CRC16 Table[256],         \
					CRC16 *CRC,                      \
					const void *dataptr,                   \
					unsigned int count));

extern void S_CRC16 PARMS((CRC16 *GenPolynomial,     \
					CRC16 *CRC,                      \
					const void *dataptr,             \
					unsigned int count));

extern void I_CRC32 PARMS((CRC32 Table[256],         \
					CRC32 *GenPolynomial));

extern void F_CRC32 PARMS((CRC32 Table[256],         \
					CRC32 *CRC,                      \
					const void *dataptr,             \
					unsigned int count));

extern void S_CRC32 PARMS((CRC32 *GenPolynomial,     \
					CRC32 *CRC,                      \
					const void *dataptr,             \
					unsigned int count));
//#ifdef __cplusplus
//}            /* Assume C declarations for C++ */
//#endif	/* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\csprop2.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csprop2.h
//
// Contents:    Cert Server Property interfaces
//
//---------------------------------------------------------------------------

#ifndef __CSPROP2_H__
#define __CSPROP2_H__

#ifndef _JET_RED_
#include <certdb.h>
#endif // _JET_RED_

// begin_certsrv

//+--------------------------------------------------------------------------
// Name properties:

#define wszPROPDISTINGUISHEDNAME TEXT("DistinguishedName")
#define wszPROPRAWNAME           TEXT("RawName")
#define wszPROPNAMETYPE          TEXT("NameType")
#define wszPROPCOUNTRY           TEXT("Country")
#define wszPROPORGANIZATION      TEXT("Organization")
#define wszPROPORGUNIT           TEXT("OrgUnit")
#define wszPROPCOMMONNAME        TEXT("CommonName")
#define wszPROPLOCALITY          TEXT("Locality")
#define wszPROPSTATE             TEXT("State")
#define wszPROPTITLE             TEXT("Title")
#define wszPROPGIVENNAME         TEXT("GivenName")
#define wszPROPINITIALS          TEXT("Initials")
#define wszPROPSURNAME           TEXT("SurName")
#define wszPROPDOMAINCOMPONENT   TEXT("DomainComponent")
#define wszPROPEMAIL             TEXT("EMail")
#define wszPROPSTREETADDRESS     TEXT("StreetAddress")

//+--------------------------------------------------------------------------
// Subject Name properties:

#define wszPROPSUBJECTDOT	    TEXT("Subject.")
#define wszPROPSUBJECTDISTINGUISHEDNAME \
				    wszPROPSUBJECTDOT wszPROPDISTINGUISHEDNAME
#define wszPROPSUBJECTRAWNAME       wszPROPSUBJECTDOT wszPROPRAWNAME
#define wszPROPSUBJECTNAMETYPE      wszPROPSUBJECTDOT wszPROPNAMETYPE

#define wszPROPSUBJECTCOUNTRY       wszPROPSUBJECTDOT wszPROPCOUNTRY
#define wszPROPSUBJECTORGANIZATION  wszPROPSUBJECTDOT wszPROPORGANIZATION
#define wszPROPSUBJECTORGUNIT       wszPROPSUBJECTDOT wszPROPORGUNIT
#define wszPROPSUBJECTCOMMONNAME    wszPROPSUBJECTDOT wszPROPCOMMONNAME
#define wszPROPSUBJECTLOCALITY      wszPROPSUBJECTDOT wszPROPLOCALITY
#define wszPROPSUBJECTSTATE         wszPROPSUBJECTDOT wszPROPSTATE
#define wszPROPSUBJECTTITLE	    wszPROPSUBJECTDOT wszPROPTITLE
#define wszPROPSUBJECTGIVENNAME	    wszPROPSUBJECTDOT wszPROPGIVENNAME
#define wszPROPSUBJECTINITIALS	    wszPROPSUBJECTDOT wszPROPINITIALS
#define wszPROPSUBJECTSURNAME	    wszPROPSUBJECTDOT wszPROPSURNAME
#define wszPROPSUBJECTDOMAINCOMPONENT wszPROPSUBJECTDOT wszPROPDOMAINCOMPONENT
#define wszPROPSUBJECTEMAIL	    wszPROPSUBJECTDOT wszPROPEMAIL
#define wszPROPSUBJECTSTREETADDRESS wszPROPSUBJECTDOT wszPROPSTREETADDRESS

// end_certsrv

//+--------------------------------------------------------------------------
// Issuer Name properties:

#define wszPROPISSUERDOT	    TEXT("Issuer.")
#define wszPROPISSUERDISTINGUISHEDNAME \
				    wszPROPISSUERDOT wszPROPDISTINGUISHEDNAME
#define wszPROPISSUERRAWNAME        wszPROPISSUERDOT wszPROPRAWNAME
#define wszPROPISSUERNAMETYPE       wszPROPISSUERDOT wszPROPNAMETYPE

#define wszPROPISSUERCOUNTRY        wszPROPISSUERDOT wszPROPCOUNTRY
#define wszPROPISSUERORGANIZATION   wszPROPISSUERDOT wszPROPORGANIZATION
#define wszPROPISSUERORGUNIT        wszPROPISSUERDOT wszPROPORGUNIT
#define wszPROPISSUERCOMMONNAME     wszPROPISSUERDOT wszPROPCOMMONNAME
#define wszPROPISSUERLOCALITY       wszPROPISSUERDOT wszPROPLOCALITY
#define wszPROPISSUERSTATE          wszPROPISSUERDOT wszPROPSTATE
#define wszPROPISSUERTITLE	    wszPROPISSUERDOT wszPROPTITLE
#define wszPROPISSUERGIVENNAME	    wszPROPISSUERDOT wszPROPGIVENNAME
#define wszPROPISSUERINITIALS	    wszPROPISSUERDOT wszPROPINITIALS
#define wszPROPISSUERSURNAME	    wszPROPISSUERDOT wszPROPSURNAME
#define wszPROPISSUERDOMAINCOMPONENT wszPROPISSUERDOT wszPROPDOMAINCOMPONENT
#define wszPROPISSUEREMAIL	    wszPROPISSUERDOT wszPROPEMAIL
#define wszPROPISSUERSTREETADDRESS  wszPROPSUBJECTDOT wszPROPSTREETADDRESS

#define wszPROPISSUERCOUNTRYOBJID \
    wszPROPISSUERDOT TEXT(szOID_COUNTRY_NAME)

#define wszPROPISSUERORGANIZATIONOBJID \
    wszPROPISSUERDOT TEXT(szOID_ORGANIZATION_NAME)

#define wszPROPISSUERORGUNITOBJID \
    wszPROPISSUERDOT TEXT(szOID_ORGANIZATIONAL_UNIT_NAME)

#define wszPROPISSUERCOMMONNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_COMMON_NAME)

#define wszPROPISSUERLOCALITYOBJID \
    wszPROPISSUERDOT TEXT(szOID_LOCALITY_NAME)

#define wszPROPISSUERSTATEOBJID \
    wszPROPISSUERDOT TEXT(szOID_STATE_OR_PROVINCE_NAME)

#define wszPROPISSUERTITLEOBJID \
    wszPROPISSUERDOT TEXT(szOID_TITLE)

#define wszPROPISSUERGIVENNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_GIVEN_NAME)

#define wszPROPISSUERINITIALSOBJID \
    wszPROPISSUERDOT TEXT(szOID_INITIALS)

#define wszPROPISSUERSURNAMEOBJID \
    wszPROPISSUERDOT TEXT(szOID_SUR_NAME)

#define wszPROPISSUERDOMAINCOMPONENTOBJID \
    wszPROPISSUERDOT TEXT(szOID_DOMAIN_COMPONENT)

#define wszPROPISSUEREMAILOBJID \
    wszPROPISSUERDOT TEXT(szOID_RSA_emailAddr)

#define wszPROPISSUERSTREETADDRESSOBJID \
    wszPROPISSUERDOT TEXT(szOID_STREET_ADDRESS)


//+--------------------------------------------------------------------------
// For mapping request attribute names to internal property names:

// Map to wszPROPSUBJECTCOUNTRY:
#define wszATTRCOUNTRY1			TEXT("C")
#define wszATTRCOUNTRY2			TEXT("Country")

// Map to wszPROPSUBJECTORGANIZATION:
#define wszATTRORG1			TEXT("O")
#define wszATTRORG2			TEXT("Org")
#define wszATTRORG3			TEXT("Organization")

// Map to wszPROPSUBJECTORGUNIT:
#define wszATTRORGUNIT1			TEXT("OU")
#define wszATTRORGUNIT2			TEXT("OrgUnit")
#define wszATTRORGUNIT3			TEXT("OrganizationUnit")
#define wszATTRORGUNIT4			TEXT("OrganizationalUnit")

// Map to wszPROPSUBJECTCOMMONNAME:
#define wszATTRCOMMONNAME1		TEXT("CN")
#define wszATTRCOMMONNAME2		TEXT("CommonName")

// Map to wszPROPSUBJECTLOCALITY:
#define wszATTRLOCALITY1		TEXT("L")
#define wszATTRLOCALITY2		TEXT("Locality")

// Map to wszPROPSUBJECTSTATE:
#define wszATTRSTATE1			TEXT("S")
#define wszATTRSTATE2			TEXT("ST")
#define wszATTRSTATE3			TEXT("State")

// Map to wszPROPSUBJECTTITLE:
#define wszATTRTITLE1			TEXT("T")
#define wszATTRTITLE2			TEXT("Title")

// Map to wszPROPSUBJECTGIVENNAME:
#define wszATTRGIVENNAME1		TEXT("G")
#define wszATTRGIVENNAME2		TEXT("GivenName")

// Map to wszPROPSUBJECTINITIALS:
#define wszATTRINITIALS1		TEXT("I")
#define wszATTRINITIALS2		TEXT("Initials")

// Map to wszPROPSUBJECTSURNAME:
#define wszATTRSURNAME1			TEXT("SN")
#define wszATTRSURNAME2			TEXT("SurName")

// Map to wszPROPSUBJECTDOMAINCOMPONENT:
#define wszATTRDOMAINCOMPONENT1		TEXT("DC")
#define wszATTRDOMAINCOMPONENT2		TEXT("DomainComponent")

// Map to wszPROPSUBJECTEMAIL:
#define wszATTREMAIL1			TEXT("E")
#define wszATTREMAIL2			TEXT("EMail")

// Map to wszPROPSUBJECTSTREETADDRESS:
#define wszATTRSTREETADDRESS1		TEXT("Street")


// begin_certsrv

//+--------------------------------------------------------------------------
// Request properties:

#define wszPROPREQUESTREQUESTID		    TEXT("RequestID")
#define wszPROPREQUESTRAWREQUEST	    TEXT("RawRequest")
#define wszPROPREQUESTATTRIBUTES	    TEXT("RequestAttributes")
#define wszPROPREQUESTTYPE		    TEXT("RequestType")
#define wszPROPREQUESTFLAGS		    TEXT("RequestFlags")
#define wszPROPREQUESTSTATUS		    TEXT("Status")
#define wszPROPREQUESTSTATUSCODE	    TEXT("StatusCode")
#define wszPROPREQUESTDISPOSITION	    TEXT("Disposition")
#define wszPROPREQUESTDISPOSITIONMESSAGE    TEXT("DispositionMessage")
#define wszPROPREQUESTSUBMITTEDWHEN	    TEXT("SubmittedWhen")
#define wszPROPREQUESTRESOLVEDWHEN	    TEXT("ResolvedWhen")
#define wszPROPREQUESTREVOKEDWHEN	    TEXT("RevokedWhen")
#define wszPROPREQUESTREVOKEDEFFECTIVEWHEN  TEXT("RevokedEffectiveWhen")
#define wszPROPREQUESTREVOKEDREASON  	    TEXT("RevokedReason")
#define wszPROPREQUESTSUBJECTNAMEID	    TEXT("SubjectNameID") // no_certsrv
#define wszPROPREQUESTERNAME		    TEXT("RequesterName")
#define wszPROPREQUESTERADDRESS		    TEXT("RequesterAddress") // no_certsrv


//+--------------------------------------------------------------------------
// Request attribute properties:

#define wszPROPCHALLENGE		TEXT("Challenge")
#define wszPROPEXPECTEDCHALLENGE	TEXT("ExpectedChallenge")


//+--------------------------------------------------------------------------
// Certificate properties:

#define wszPROPCERTIFICATEREQUESTID	    TEXT("RequestID")
#define wszPROPRAWCERTIFICATE		    TEXT("RawCertificate")
#define wszPROPCERTIFICATEHASH		    TEXT("CertificateHash")
#define wszPROPCERTIFICATETYPE		    TEXT("CertificateType")
#define wszPROPCERTIFICATESERIALNUMBER	    TEXT("SerialNumber")
#define wszPROPCERTIFICATEISSUERNAMEID	    TEXT("IssuerNameID") // no_certsrv
#define wszPROPCERTIFICATESUBJECTNAMEID	    TEXT("SubjectNameID") // no_certsrv
#define wszPROPCERTIFICATENOTBEFOREDATE	    TEXT("NotBefore")
#define wszPROPCERTIFICATENOTAFTERDATE	    TEXT("NotAfter")
#define wszPROPCERTIFICATERAWPUBLICKEY	    TEXT("RawPublicKey")
#define wszPROPCERTIFICATEPUBLICKEYALGORITHM TEXT("PublicKeyAlgorithm")
#define wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS \
    TEXT("RawPublicKeyAlgorithmParameters")

//+--------------------------------------------------------------------------
// Certificate extension properties:

#define EXTENSION_CRITICAL_FLAG	 0x00000001
#define EXTENSION_DISABLE_FLAG	 0x00000002
#define EXTENSION_POLICY_MASK	 0x0000ffff	// Settable by admin+policy

#define EXTENSION_ORIGIN_REQUEST 0x00010000
#define EXTENSION_ORIGIN_POLICY	 0x00020000
#define EXTENSION_ORIGIN_ADMIN	 0x00030000
#define EXTENSION_ORIGIN_SERVER	 0x00040000
#define EXTENSION_ORIGIN_MASK	 0x000f0000

//+--------------------------------------------------------------------------
// GetProperty/SetProperty Flags:
//
// Choose one Type

#define PROPTYPE_LONG		 0x00000001	// Signed long
#define PROPTYPE_DATE		 0x00000002	// Date+Time
#define PROPTYPE_BINARY		 0x00000003	// Binary data
#define PROPTYPE_STRING		 0x00000004	// Unicode String
#define PROPTYPE_ANSI		 0x00000005	// Ansi String	no_certsrv
#define PROPTYPE_MASK		 0x000000ff
// end_certsrv

// Choose one Caller:

#define PROPCALLER_SERVER	 0x00000100
#define PROPCALLER_POLICY	 0x00000200
#define PROPCALLER_EXIT		 0x00000300
#define PROPCALLER_ADMIN	 0x00000400
#define PROPCALLER_REQUEST	 0x00000500
#define PROPCALLER_MASK		 0x00000f00

// Choose one Table:

#define PROPTABLE_REQUEST	 0x00001000
#define PROPTABLE_CERTIFICATE	 0x00002000
#define PROPTABLE_EXTENSION      0x00003000
#define PROPTABLE_ATTRIBUTE      0x00004000
#define PROPTABLE_MASK		 0x0000f000
#define PROPTABLE_EXTENSIONFLAGS 0x00010000
#define PROPTABLE_EXTENSIONVALUE 0x00020000


#define _254	254	// arbirtrary length
#define _64	64	// arbirtrary length

#define cchATTRIBUTESMAX		_254
#define cchATTRIBUTEVALUEMAX		_64
#define cchATTRIBUTENAMEMAX		_64

#define cchREQUESTDISPOSITIONMESSAGE    _64
#define cchREQUESTERNAMEMAX		_64
#define cchREQUESTERADDRESSMAX		_64

#define cchHASHMAX			_64
#define cchSERIALNUMBERMAX		_64

#define cchOBJECTIDMAX			31
#define cchPROPVALUEMAX			_64

#define cchDISTINGUISHEDNAMEMAX		254
#define cchCOUNTRYNAMEMAX		2
#define cchORGANIZATIONNAMEMAX		_64
#define cchORGANIZATIONALUNITNAMEMAX	_64
#define cchCOMMONNAMEMAX		_64
#define cchLOCALITYMANAMEMAX		_64
#define cchSTATEORPROVINCENAMEMAX	_64
#define cchTITLEMAX			_64
#define cchGIVENNAMEMAX			_64
#define cchINITIALSMAX			_64
#define cchSURNAMEMAX			_64
#define cchDOMAINCOMPONENTMAX		_64
#define cchEMAILMAX			_64
#define cchSTREETADDRESSMAX		_64


// begin_certsrv

// Request Status property values:

#define REQSTATUS_ACTIVE	1
#define REQSTATUS_ACCEPTED	2
#define REQSTATUS_DENIED	3
#define REQSTATUS_PENDING	4
#define REQSTATUS_ERROR		5

// end_certsrv


HRESULT
PropParseRequest(
#ifdef _JET_RED_
    IN DWORD ReqId,
#else // _JET_RED_
    IN ICertDBRow *prow,
#endif // _JET_RED_
    IN DWORD dwFlags,
    IN DWORD cbRequest,
    IN BYTE const *pbRequest);

HRESULT
PropSetRequestTimeProperty(
#ifdef _JET_RED_
    IN DWORD ReqId,
#else // _JET_RED_
    IN ICertDBRow *prow,
#endif // _JET_RED_
    IN WCHAR const *pwszProp);

HRESULT
PropGetExtension(
#ifdef _JET_RED_
    IN DWORD ReqId,
#else // _JET_RED_
    IN ICertDBRow *prow,
#endif // _JET_RED_
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT DWORD *pcbValue,
    OUT BYTE **ppbValue);

HRESULT
PropSetExtension(
#ifdef _JET_RED_
    IN DWORD ReqId,
#else // _JET_RED_
    IN ICertDBRow *prow,
#endif // _JET_RED_
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN DWORD cbValue,
    IN BYTE const *pbValue);


// CertIF property callback support:

typedef HRESULT (WINAPI FNCIGETPROPERTY)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    OUT VARIANT *pvarPropertyValue);

FNCIGETPROPERTY PropCIGetProperty;


typedef HRESULT (WINAPI FNCISETPROPERTY)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszPropertyName,
    IN VARIANT const *pvarPropertyValue);

FNCISETPROPERTY PropCISetProperty;


typedef HRESULT (WINAPI FNCIGETEXTENSION)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    OUT DWORD *pdwExtFlags,
    OUT VARIANT *pvarValue);

FNCIGETEXTENSION PropCIGetExtension;


typedef HRESULT (WINAPI FNCISETEXTENSION)(
    IN LONG Context,
    IN DWORD Flags,
    IN WCHAR const *pwszExtensionName,
    IN DWORD ExtFlags,
    IN VARIANT const *pvarValue);

FNCISETEXTENSION PropCISetExtension;



// CertIF property enumeration callback support:

#define CIE_OBJECTID	     0x00000001	// return object ids for names

#define CIE_TABLE_EXTENSIONS 0x00000010
#define CIE_TABLE_ATTRIBUTES 0x00000020
#define CIE_TABLE_MASK       0x000000f0



class CIENUM {
public:
    CIENUM() { m_penum = NULL; }

    HRESULT EnumSetup(IN LONG Context, IN DWORD Flags);
    HRESULT EnumNext(OUT BSTR *pstrPropertyName);
    HRESULT EnumClose();

private:
#ifdef _JET_RED_
    LONG   m_Flags;
    HANDLE m_penum;
#else // _JET_RED_
    IEnumCERTDBNAME *m_penum;
#endif // _JET_RED_
};

typedef HRESULT (WINAPI FNCIENUMSETUP)(
    IN LONG Context,
    IN DWORD Flags,
    IN OUT CIENUM *pciEnum);

FNCIENUMSETUP PropCIEnumSetup;


typedef HRESULT (WINAPI FNCIENUMNEXT)(
    IN OUT CIENUM *pciEnum,
    OUT BSTR *pstrPropertyName);

FNCIENUMNEXT PropCIEnumNext;


typedef HRESULT (WINAPI FNCIENUMCLOSE)(
    IN OUT CIENUM *pciEnum);

FNCIENUMCLOSE PropCIEnumClose;


#ifdef _JET_RED_

#define wszPROPCERTIFICATEEXTENSIONFLAGS	TEXT("Flags")
#define wszPROPCERTIFICATEEXTENSIONVALUE	TEXT("Value")


DWORD			// ERROR_*
PropCreateRequest(
    IN OUT DWORD *pReqId);

DWORD			// ERROR_*
PropTerminateRequest(
    IN DWORD ReqId);

DWORD			// ERROR_*
PropGetProperty(
    IN DWORD ReqId,
    IN WCHAR const *pwszPropName,
    IN DWORD Flags,
    IN OUT DWORD *pcbProp,
    OPTIONAL OUT BYTE *pbProp);

DWORD			// ERROR_*
PropGetPropertyA(
    IN DWORD ReqId,
    IN WCHAR const *pwszPropName,
    IN DWORD Flags,
    IN OUT DWORD *pcbProp,
    OPTIONAL OUT BYTE *pbProp);

DWORD			// ERROR_*
PropSetProperty(
    IN DWORD ReqId,
    IN WCHAR const *pwszPropName,
    IN DWORD Flags,
    IN DWORD cbProp,
    IN BYTE const *pbProp);

#endif // _JET_RED_


#endif // __CSPROP2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\cache.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       ds.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <wininet.h>
#include <winineti.h>	// for MAX_CACHE_ENTRY_INFO_SIZE

#include "cryptnet.h"

#define __dwFILE__	__dwFILE_CERTUTIL_CACHE_CPP__


typedef struct _QUERY_INFO
{
    WCHAR const *pwszInfo;
    DWORD        dwInfo;
} QUERY_INFO;


QUERY_INFO g_rgQueryInfo[] = {
#if 0
    L"HTTP_QUERY_MIME_VERSION-Req",
        HTTP_QUERY_MIME_VERSION | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    L"HTTP_QUERY_CONTENT_TYPE-Req",
        HTTP_QUERY_CONTENT_TYPE | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    L"HTTP_QUERY_CONTENT_TRANSFER_ENCODING-Req",
        HTTP_QUERY_CONTENT_TRANSFER_ENCODING | HTTP_QUERY_FLAG_REQUEST_HEADERS,
    L"HTTP_QUERY_CONTENT_LENGTH-Req",
        HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_REQUEST_HEADERS,
#endif

    L"HTTP_QUERY_MIME_VERSION", HTTP_QUERY_MIME_VERSION,
    L"HTTP_QUERY_CONTENT_TYPE", HTTP_QUERY_CONTENT_TYPE,
    L"HTTP_QUERY_CONTENT_TRANSFER_ENCODING",
	HTTP_QUERY_CONTENT_TRANSFER_ENCODING,

    L"HTTP_QUERY_CONTENT_LENGTH",
        HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER,

    L"HTTP_QUERY_VERSION", HTTP_QUERY_VERSION, 
    L"HTTP_QUERY_STATUS_CODE", HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
    L"HTTP_QUERY_STATUS_TEXT", HTTP_QUERY_STATUS_TEXT, 
    L"HTTP_QUERY_RAW_HEADERS", HTTP_QUERY_RAW_HEADERS, 
    L"HTTP_QUERY_RAW_HEADERS_CRLF", HTTP_QUERY_RAW_HEADERS_CRLF, 
    L"HTTP_QUERY_CONTENT_ENCODING", HTTP_QUERY_CONTENT_ENCODING, 
    L"HTTP_QUERY_LOCATION", HTTP_QUERY_LOCATION, 
    L"HTTP_QUERY_ORIG_URI", HTTP_QUERY_ORIG_URI, 
    L"HTTP_QUERY_REQUEST_METHOD", HTTP_QUERY_REQUEST_METHOD, 
    L"HTTP_QUERY_DATE", HTTP_QUERY_DATE | HTTP_QUERY_FLAG_SYSTEMTIME,
    L"HTTP_QUERY_EXPIRES", HTTP_QUERY_EXPIRES | HTTP_QUERY_FLAG_SYSTEMTIME,
    L"HTTP_QUERY_LAST_MODIFIED",
        HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME,
};


HRESULT
DisplayQueryInfo(
    IN HINTERNET hInternetFile)
{
    HRESULT hr;
    DWORD i;

    for (i = 0; i < ARRAYSIZE(g_rgQueryInfo); i++)
    {
	QUERY_INFO *pQuery = &g_rgQueryInfo[i];
        DWORD dwIndex;
        BOOL fFirst;

        fFirst = TRUE;
        dwIndex = 0;
        while (TRUE)
	{
            BYTE rgbBuf[MAX_CACHE_ENTRY_INFO_SIZE];
            DWORD cbBuf;
            DWORD dwThisIndex = dwIndex;
            BOOL fResult;
            DWORD dwValue;
            SYSTEMTIME st;
    
            if (HTTP_QUERY_FLAG_NUMBER & pQuery->dwInfo)
	    {
                cbBuf = sizeof(dwValue);
                fResult = HttpQueryInfo(
				hInternetFile,
				pQuery->dwInfo,
				&dwValue,
				&cbBuf,
				&dwIndex);
            }
	    else
	    if (HTTP_QUERY_FLAG_SYSTEMTIME & pQuery->dwInfo)
	    {
                cbBuf = sizeof(st);
                fResult = HttpQueryInfo(
				hInternetFile,
				pQuery->dwInfo,
				&st,
				&cbBuf,
				&dwIndex);
            }
            else
	    {
		ZeroMemory(rgbBuf, sizeof(rgbBuf));
		cbBuf = sizeof(rgbBuf);

                fResult = HttpQueryInfo(
				hInternetFile,
				pQuery->dwInfo,
				rgbBuf,
				&cbBuf,
				&dwIndex);
	    }
            if (!fResult)
	    {
                hr = myHLastError();
		_PrintErrorStr3(
			hr,
			"HttpQueryInfo",
			pQuery->pwszInfo,
			HRESULT_FROM_WIN32(ERROR_HTTP_HEADER_NOT_FOUND),
			HRESULT_FROM_WIN32(ERROR_HTTP_INVALID_QUERY_REQUEST));
		break;
            }

	    if (HTTP_QUERY_FLAG_NUMBER & pQuery->dwInfo)
	    {
                wprintf(
		    L"%ws[%d] = %x (%d)\n",
                    pQuery->pwszInfo,
		    dwThisIndex,
		    dwValue,
		    dwValue);
            }
	    else
	    if (HTTP_QUERY_FLAG_SYSTEMTIME & pQuery->dwInfo)
	    {
                FILETIME ft;

                if (!SystemTimeToFileTime(&st, &ft))
		{
                    hr = myHLastError();
		    _JumpErrorStr(
			    hr,
			    error,
			    "SystemTimeToFileTime",
			    pQuery->pwszInfo);
                }
		else
		{
                    wprintf(L"%ws[%d] =", pQuery->pwszInfo, dwThisIndex);
		    hr = cuDumpFileTime(0, NULL, &ft);
		    wprintf(wszNewLine);
		    _PrintIfError(hr, "cuDumpFileTime");
		}
            }
	    else
	    {
                wprintf(
		    L"%ws[%d] = \"%.*ws\"\n",
		    pQuery->pwszInfo,
		    dwThisIndex,
		    cbBuf / sizeof(WCHAR),
		    rgbBuf);
		if (1 < g_fVerbose)
		{
		    DumpHex(0, (BYTE const *) rgbBuf, cbBuf);
		}
            }
            fFirst = FALSE;
            if (dwThisIndex == dwIndex)
	    {
#if 0
                wprintf(
		    L"HttpQueryInfo(%ws) dwIndex not advanced\n",
                    pQuery->pwszInfo);
#endif
                break;
            }
        }
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DisplayCacheEntryInfo(
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    DWORD cbCachEntryInfo;
    BYTE rgbCachEntryInfo[MAX_CACHE_ENTRY_INFO_SIZE];
    INTERNET_CACHE_ENTRY_INFO *pCacheEntryInfo =
        (INTERNET_CACHE_ENTRY_INFO *) &rgbCachEntryInfo[0];

    cbCachEntryInfo = sizeof(rgbCachEntryInfo);
    if (!GetUrlCacheEntryInfo(pwszURL, pCacheEntryInfo, &cbCachEntryInfo))
    {
	hr = myHLastError();
	wprintf(L"%ws\n", pwszURL);
	_JumpError(hr, error, "GetUrlCacheEntryInfo");
    }
    wprintf(
	L"%ws %d %ws\n",
	myLoadResourceString(IDS_WININET_CACHE_ENTRY_COLON),
	cbCachEntryInfo,
	myLoadResourceString(IDS_BYTES));

    if (0 != cbCachEntryInfo)
    {
	wprintf(
	    L"  %ws \"%ws\"\n",
	    myLoadResourceString(IDS_FORMAT_SOURCE_URL),
	    pCacheEntryInfo->lpszSourceUrlName);
        
	wprintf(
	    L"  %ws \"%ws\"\n",
	    myLoadResourceString(IDS_FORMAT_LOCAL_FILENAME),
	    pCacheEntryInfo->lpszLocalFileName);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_USE_COUNT), pCacheEntryInfo->dwUseCount);
	wprintf(wszNewLine);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_HIT_RATE), pCacheEntryInfo->dwHitRate);
	wprintf(wszNewLine);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_FILE_SIZE), pCacheEntryInfo->dwSizeLow);
	wprintf(wszNewLine);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_LAST_MOD_TIME_COLON));
	cuDumpFileTime(0, NULL, &pCacheEntryInfo->LastModifiedTime);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_EXPIRE_TIME_COLON));
	cuDumpFileTime(0, NULL, &pCacheEntryInfo->ExpireTime);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_LAST_ACCESS_TIME_COLON));
	cuDumpFileTime(0, NULL, &pCacheEntryInfo->LastAccessTime);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_LAST_SYNC_TIME_COLON));
	cuDumpFileTime(0, NULL, &pCacheEntryInfo->LastSyncTime);
    }
    hr = S_OK;

error:
    return(hr);
}



typedef struct _DATABLOCK {
    struct _DATABLOCK *pNext;
    DWORD	       cbData;
    BYTE	       abData[1];
} DATABLOCK;


HRESULT
AddDataBlock(
    IN BYTE *pb,
    IN DWORD cb,
    IN OUT DATABLOCK **ppData)
{
    HRESULT hr;
    DATABLOCK *pData = NULL;

    pData = (DATABLOCK *) LocalAlloc(LMEM_FIXED, sizeof(*pData) + cb);
    if (NULL == pData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pData->pNext = *ppData;
    pData->cbData = cb;
    CopyMemory(pData->abData, pb, cb);
    *ppData = pData;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
ReadURL(
    OPTIONAL IN HINTERNET hInternetFile,
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;
    BYTE *pb = NULL;
    BYTE *pb2;
    DWORD cb;
    DWORD cbRead;
    DATABLOCK *pData = NULL;
    DATABLOCK *pData2;

    if (NULL == hInternetFile)
    {
	if (!CryptRetrieveObjectByUrl(
				pwszURL,
				CONTEXT_OID_CAPI2_ANY,
				CRYPT_RETRIEVE_MULTIPLE_OBJECTS |
				    (g_fForce?
					CRYPT_WIRE_ONLY_RETRIEVAL :
					CRYPT_CACHE_ONLY_RETRIEVAL),
				0,
				(VOID **) &hStore,
				NULL,
				NULL,
				NULL,
				NULL))
	{
	    hr = myHLastError();
	    _JumpErrorStr2(hr, error, "CryptRetrieveObjectByUrl", pwszURL, hr);
	}
	hr = cuDumpAndVerifyStore(
			    hStore,
			    DVNS_DUMP,
			    NULL, 	// pwszCertName
			    MAXDWORD,	// iCertSave
			    MAXDWORD,	// iCRLSave
			    MAXDWORD,	// iCTLSave
			    NULL,	// pwszfnOut
			    NULL);	// pwszPassword
	_JumpIfError(hr, error, "cuDumpAndVerifyStore");
    }
    else
    {
	cb = 0;
	if (!InternetQueryDataAvailable(
				    hInternetFile,
				    &cb,
				    0,	// dwFlags
				    0))	// dwContext
	{
	    hr = myHLastError();
	    _PrintError(hr, "InternetQueryDataAvailable");
	}

	cb = 0;
	while (TRUE)
	{
	    BYTE ab[4096];

	    if (!InternetReadFile(hInternetFile, ab, sizeof(ab), &cbRead))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "InternetReadFile");
	    }
	    if (0 == cbRead)
	    {
		break;
	    }
	    hr = AddDataBlock(ab, cbRead, &pData);
	    _JumpIfError(hr, error, "AddDataBlock");

	    cb += cbRead;
	}

	pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == pb)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	pb2 = &pb[cb];
	for (pData2 = pData; NULL != pData2; pData2 = pData2->pNext)
	{
	    pb2 -= pData2->cbData;
	    CSASSERT(pb2 >= pb);
	    CopyMemory(pb2, pData2->abData, pData2->cbData);
	}
	CSASSERT(pb2 == pb);

	hr = cuDumpAsnBinary(pb, cb, MAXDWORD);
	if (S_OK != hr)
	{
	    _PrintError(hr, "cuDumpAsnBinary");
	    DumpHex(0, pb, cb);
	}
    }
    hr = S_OK;

error:
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    while (NULL != pData)
    {
	pData2 = pData;
	pData = pData->pNext;
	LocalFree(pData2);
    }
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
DeleteCacheGroups()
{
    HRESULT hr;
    HRESULT hr2;
    HANDLE hFind = NULL;
    GROUPID GroupId;
    DWORD cDelete = 0;
    
    hFind = FindFirstUrlCacheGroup(
			    0,				// dwFlags
			    CACHEGROUP_SEARCH_ALL,	// dwFilter
			    NULL,			// lpSearchCondition
			    0,				// dwSearchCondition
			    &GroupId,
			    NULL);			// lpReserved
    if (NULL == hFind)
    {
	hr = myHLastError();
	_JumpError(hr, error, "FindFirstUrlCacheGroup");
    }

    while (TRUE)
    {
	//wprintf(L"GROUPID: %I64u (0x%I64x)\n", GroupId, GroupId);
	if (!DeleteUrlCacheGroup(
		GroupId,
		CACHEGROUP_FLAG_FLUSHURL_ONDELETE,	// dwFlags
		NULL))					// lpReserved
	{
	    hr = myHLastError();
	    _PrintError(hr, "DeleteUrlCacheGroup");
	}
	else
	{
	    cDelete++;
	}

	if (!FindNextUrlCacheGroup(hFind, &GroupId, NULL))
	{
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
	    {
		break;
	    }
	    _JumpError(hr, error, "FindNextUrlCacheGroup");
	}
    }
    //wprintf(L"Deleted %u groups\n", cDelete);
    hr = S_OK;

error:
    if (NULL != hFind)
    {
	if (!FindCloseUrlCache(hFind))
	{
	    hr2 = myHLastError();
	    _PrintError(hr2, "FindCloseUrlCache");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }
    return(hr);
}


HANDLE
myFindFirstUrlCacheEntry(
    OPTIONAL IN WCHAR const *pwszPattern,
    OUT INTERNET_CACHE_ENTRY_INFO **ppcei,
    OUT DWORD *pcb)
{
    HRESULT hr;
    HANDLE hFind = NULL;
    INTERNET_CACHE_ENTRY_INFO *pcei = NULL;
    DWORD cb;
    BOOL fRetried;

    *ppcei = NULL;
    cb = MAX_CACHE_ENTRY_INFO_SIZE;
    fRetried = FALSE;
    while (TRUE)
    {
	pcei = (INTERNET_CACHE_ENTRY_INFO *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == pcei)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	hFind = FindFirstUrlCacheEntry(pwszPattern, pcei, &cb);
	if (NULL != hFind)
	{
	    break;
	}
	hr = myHLastError();
	if (!fRetried || HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
	{
	    _JumpError(hr, error, "FindFirstUrlCacheEntry");
	}
	LocalFree(pcei);
	pcei = NULL;
	fRetried = TRUE;
    }
    *pcb = cb;
    *ppcei = pcei;
    pcei = NULL;
    hr = S_OK;

error:
    if (NULL != pcei)
    {
	LocalFree(pcei);
    }
    if (NULL == hFind)
    {
	CSASSERT(FAILED(hr));
	SetLastError(hr);
    }
    else
    {
	CSASSERT(S_OK == hr);
    }
    return(hFind);
}


BOOL
myFindNextUrlCacheEntry(
    HANDLE hFind,
    OUT INTERNET_CACHE_ENTRY_INFO **ppcei,
    OUT DWORD *pcb)
{
    HRESULT hr;
    BOOL fRet;
    INTERNET_CACHE_ENTRY_INFO *pcei = NULL;
    DWORD cb;
    BOOL fRetried;

    *ppcei = NULL;
    cb = MAX_CACHE_ENTRY_INFO_SIZE;
    fRet = FALSE;
    fRetried = FALSE;
    while (TRUE)
    {
	pcei = (INTERNET_CACHE_ENTRY_INFO *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == pcei)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	fRet = FindNextUrlCacheEntry(hFind, pcei, &cb);
	if (fRet)
	{
	    break;
	}
	hr = myHLastError();
	if (!fRetried || HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
	{
	    _JumpError2(
		    hr,
		    error,
		    "FindNextUrlCacheEntry",
		    HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
	}
	LocalFree(pcei);
	pcei = NULL;
	fRetried = TRUE;
    }
    *pcb = cb;
    *ppcei = pcei;
    pcei = NULL;
    hr = S_OK;

error:
    if (!fRet)
    {
	CSASSERT(FAILED(hr));
	SetLastError(hr);
    }
    else
    {
	CSASSERT(S_OK == hr);
    }
    return(fRet);
}


BOOL
CachedURLIsCRL(
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;
    BOOL fIsCRL = FALSE;
    CRL_CONTEXT const *pCRL = NULL;
    
    if (!CryptRetrieveObjectByUrl(
			    pwszURL,
			    CONTEXT_OID_CRL,
			    CRYPT_CACHE_ONLY_RETRIEVAL |
				CRYPT_RETRIEVE_MULTIPLE_OBJECTS,
			    0,
			    (VOID **) &hStore,
			    NULL,
			    NULL,
			    NULL,
			    NULL))
    {
	hr = myHLastError();
	_JumpErrorStr2(hr, error, "CryptRetrieveObjectByUrl", pwszURL, hr);
    }

    pCRL = CertEnumCRLsInStore(hStore, NULL);
    if (NULL == pCRL)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertEnumCRLsInStore");
	
    }
    fIsCRL = TRUE;
    hr = S_OK;

error:
    if (NULL != pCRL)
    {
	CertFreeCRLContext(pCRL);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(fIsCRL);
}


HRESULT
EnumWinINetCache(
    IN BOOL fDelete,
    IN BOOL fCRLsOnly)
{
    HRESULT hr;
    HRESULT hr2;
    HANDLE hFind = NULL;
    DWORD cDelete = 0;
    DWORD cEntries = 0;
    INTERNET_CACHE_ENTRY_INFO *pcei = NULL;
    DWORD cb;
    
    hFind = myFindFirstUrlCacheEntry(
			NULL,	// lpszUrlSearchPattern
			&pcei,
			&cb);
    if (NULL == hFind)
    {
	hr = myHLastError();
	_JumpError(hr, error, "myFindFirstUrlCacheEntry");
    }

    while (TRUE)
    {
	if (!fCRLsOnly || CachedURLIsCRL(pcei->lpszSourceUrlName))
	{
	    if (g_fVerbose)
	    {
		hr = DisplayCacheEntryInfo(pcei->lpszSourceUrlName);
		_PrintIfError(hr, "DisplayCacheEntryInfo");

		if (1 < g_fVerbose)
		{
		    BOOL fVerbose = g_fVerbose;
		    
		    g_fVerbose -= 2;
		    hr = ReadURL(NULL, pcei->lpszSourceUrlName);
		    _PrintIfError(hr, "ReadURL");
		    g_fVerbose = fVerbose;
		}
	    }
	    else
	    {
		wprintf(L"%ws\n", pcei->lpszSourceUrlName);
	    }
	    wprintf(wszNewLine);
	    cEntries++;

	    if (fDelete)
	    {
		if (!DeleteUrlCacheEntry(pcei->lpszSourceUrlName))
		{
		    hr = myHLastError();
		    _PrintError(hr, "DeleteUrlCacheEntry");
		}
		else
		{
		    cDelete++;
		}
	    }
	}

	LocalFree(pcei);
	pcei = NULL;

	if (!myFindNextUrlCacheEntry(hFind, &pcei, &cb))
	{
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
	    {
		break;
	    }
	    _JumpError(hr, error, "myFindNextUrlCacheEntry");
	}
    }
    if (fDelete)
    {
	wprintf(myLoadResourceString(IDS_FORMAT_DELETED_WININETCACHE), cDelete);
    }
    else
    {
	wprintf(myLoadResourceString(IDS_FORMAT_WININETCACHE), cEntries);
    }
    wprintf(wszNewLine);
    wprintf(wszNewLine);
    hr = S_OK;

error:
    if (NULL != hFind)
    {
	if (!FindCloseUrlCache(hFind))
	{
	    hr2 = myHLastError();
	    _PrintError(hr2, "FindCloseUrlCache");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }
    if (NULL != pcei)
    {
	LocalFree(pcei);
    }
    return(hr);
}


HRESULT
DisplayWinINetURL(
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    HRESULT hr2;
    HINTERNET hInternetSession = NULL;
    HINTERNET hInternetFile = NULL;
    
    wprintf(
	L"****  %ws  ****\n",
	myLoadResourceString(g_fForce? IDS_ONLINE : IDS_OFFLINE));

    hInternetSession = InternetOpen(
			L"CertUtil URL Agent",	  // lpszAgent
			INTERNET_OPEN_TYPE_PRECONFIG, // dwAccessType
			NULL,			  // lpszProxy
			NULL,			  // lpszProxyBypass
			g_fForce? 0 : INTERNET_FLAG_FROM_CACHE);
    if (NULL == hInternetSession)
    {
	hr = myHLastError();
	_JumpError(hr, error, "InternetOpen");
    }

    hInternetFile = InternetOpenUrl(
			hInternetSession,
			pwszURL,
			L"Accept: */*\r\n",		// lpszHeaders
			MAXDWORD,			// dwHeadersLength
			INTERNET_FLAG_IGNORE_CERT_CN_INVALID |
			    (g_fForce? INTERNET_FLAG_RELOAD : 0),
			0);				// dwContext
    if (NULL == hInternetFile)
    {
	hr = myHLastError();
	_PrintErrorStr2(
		hr,
		"InternetOpenUrl",
		pwszURL,
		HRESULT_FROM_WIN32(ERROR_INTERNET_UNRECOGNIZED_SCHEME));
    }

    if (g_fForce)
    {
	if (g_fVerbose)
	{
	    hr = DisplayCacheEntryInfo(pwszURL);
	    _PrintIfError(hr, "DisplayCacheEntryInfo");
	}
    }
    else
    {
	if (g_fVerbose && NULL != hInternetFile)
	{
	    hr = DisplayQueryInfo(hInternetFile);
	    _PrintIfError(hr, "DisplayQueryInfo");
	}
    }
    hr = ReadURL(hInternetFile, pwszURL);
    _PrintIfError(hr, "ReadURL");

    if (!g_fForce && g_fVerbose)
    {
	hr = DisplayCacheEntryInfo(pwszURL);
	_PrintIfError(hr, "DisplayCacheEntryInfo");
    }
    hr = S_OK;

error:
    if (NULL != hInternetFile)
    {
	if (!InternetCloseHandle(hInternetFile))
	{
	    hr2 = myHLastError();
	    _PrintError(hr2, "InternetCloseHandle");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }
    if (NULL != hInternetSession)
    {
	if (!InternetCloseHandle(hInternetSession))
	{
	    hr2 = myHLastError();
	    _PrintError(hr2, "InternetCloseHandle(Session)");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }
    return(hr);
}


HRESULT
DeleteWinINetCachedURL(
    IN WCHAR const *pwszURL)
{
    HRESULT hr;

    if (!DeleteUrlCacheEntry(pwszURL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "DeleteUrlCacheEntry");
    }
    hr = S_OK;

error:
    return(hr);
}


typedef BOOL (WINAPI FNCRYPTNETENUMURLCACHEENTRY)(
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    IN LPVOID pvArg,
    IN PFN_CRYPTNET_ENUM_URL_CACHE_ENTRY_CALLBACK pfnEnumCallback);

FNCRYPTNETENUMURLCACHEENTRY *g_pfnCryptNetEnumUrlCacheEntry = NULL;

HRESULT
LoadWinINetCacheFunction()
{
    HRESULT hr;
    HMODULE hModule;
    
    hModule = GetModuleHandle(TEXT("cryptnet.dll"));
    if (NULL == hModule)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "GetModuleHandle", L"cryptnet.dll");
    }

	// load system function
    g_pfnCryptNetEnumUrlCacheEntry = (FNCRYPTNETENUMURLCACHEENTRY *)
			GetProcAddress(hModule, "I_CryptNetEnumUrlCacheEntry");

    if (NULL == g_pfnCryptNetEnumUrlCacheEntry)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "GetProcAddress", L"I_CryptNetEnumUrlCacheEntry");
    }
    hr = S_OK;

error:
    return(hr);
}


typedef struct _ENUM_ARG
{
    WCHAR const *pwszUrlSubString;	// NULL implies display/delete all
    BOOL         fDelete;
    BOOL         fCRLsOnly;
    DWORD        cUrl;
    DWORD        cUrlDeleted;
} ENUM_ARG;


BOOL
IsURLMatch(
    WCHAR const *pwszCacheUrl,
    WCHAR const *pwszUrlSubString)
{
    BOOL fMatch = FALSE;

    if (NULL == pwszUrlSubString)
    {
        fMatch = TRUE;
    }
    else
    {
	// Do case sensitive substring matching

	if (0 == lstrcmpi(pwszCacheUrl, pwszUrlSubString) ||
	    wcsstr(pwszCacheUrl, pwszUrlSubString))
	{
	    fMatch = TRUE;
	}
    }
    return(fMatch);
}


BOOL
WINAPI
WinHttpCacheEntryWorker(
    IN CRYPTNET_URL_CACHE_ENTRY const *pUrlCacheEntry,
    IN DWORD dwFlags,
    IN VOID *pvReserved,
    IN VOID *pvArg)
{
    HRESULT hr;
    ENUM_ARG *pArg = (ENUM_ARG *) pvArg;
    DWORD cbBlob;
    DWORD i;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    BYTE *pb;

    if (!IsURLMatch(pUrlCacheEntry->pwszUrl, pArg->pwszUrlSubString))
    {
	goto error;		// skip non-matching URLs
    }

    cbBlob = 0;
    for (i = 0; i < pUrlCacheEntry->cBlob; i++)
    {
        cbBlob += pUrlCacheEntry->pcbBlob[i];
    }

    if (g_fVerbose || pArg->fCRLsOnly)
    {
	hr = DecodeFileW(
		    pUrlCacheEntry->pwszContentFileName,
		    &pbContent,
		    &cbContent,
		    CRYPT_STRING_ANY);
	_PrintIfError(hr, "DecodeFileW");

	if (NULL != pbContent && cbBlob != cbContent)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _PrintError(hr, "cuDumpFileTime");
            if (cbBlob > cbContent)
	    {
                LocalFree(pbContent);	// invalid content
                pbContent = NULL;
	    }
        }
	if (NULL != pbContent && pArg->fCRLsOnly)
	{
	    BOOL fCRL = FALSE;

	    pb = pbContent;
	    for (i = 0; i < pUrlCacheEntry->cBlob; i++)
	    {
		CRL_CONTEXT const *pCRL;
		
		pCRL = CertCreateCRLContext(
				    X509_ASN_ENCODING,
				    pb,
				    pUrlCacheEntry->pcbBlob[i]);
		if (NULL != pCRL)
		{
		    CertFreeCRLContext(pCRL);
		    fCRL = TRUE;
		    break;
		}
		pb += pUrlCacheEntry->pcbBlob[i];
	    }
	    if (!fCRL)
	    {
		goto error;	// skip non-CRLS
	    }
	}
    }

    if (!g_fVerbose)
    {
	wprintf(L"%ws\n", pUrlCacheEntry->pwszUrl);
    }
    else
    {
	wprintf(
	    L"%ws %d %ws\n",
	    myLoadResourceString(IDS_WINHTTP_CACHE_ENTRY_COLON),
	    pUrlCacheEntry->cbSize,
	    myLoadResourceString(IDS_BYTES));

	wprintf(
	    L"  %ws \"%ws\"\n",
	    myLoadResourceString(IDS_FORMAT_SOURCE_URL),
	    pUrlCacheEntry->pwszUrl);
	wprintf(wszNewLine);

	wprintf(
	    L"  %ws \"%ws\"\n",
	    myLoadResourceString(IDS_FORMAT_LOCAL_FILENAME),
	    pUrlCacheEntry->pwszContentFileName);
	wprintf(wszNewLine);

	wprintf(
	    L"  %ws \"%ws\"\n",
	    myLoadResourceString(IDS_FORMAT_META_FILENAME),
	    pUrlCacheEntry->pwszMetaDataFileName);
	wprintf(wszNewLine);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_FILE_SIZE), cbBlob);
	wprintf(wszNewLine);

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_FORMAT_LAST_SYNC_TIME_COLON));
	cuDumpFileTime(0, NULL, &pUrlCacheEntry->LastSyncTime);

	if (NULL != pbContent && 1 < g_fVerbose)
	{
	    BOOL fVerbose = g_fVerbose;
	    
	    g_fVerbose -= 2;

	    pb = pbContent;
	    for (i = 0; i < pUrlCacheEntry->cBlob; i++)
	    {
		hr = cuDumpAsnBinary(pb, pUrlCacheEntry->pcbBlob[i], i);
		if (S_OK != hr || 1 < g_fVerbose)
		{
		    _PrintIfError(hr, "cuDumpAsnBinary");
		    DumpHex(0, pb, pUrlCacheEntry->pcbBlob[i]);
		}
		pb += pUrlCacheEntry->pcbBlob[i];
	    }
	    g_fVerbose = fVerbose;
	}
    }
    if (pArg->fDelete)
    {
	hr = S_OK;
	if (!DeleteFile(pUrlCacheEntry->pwszContentFileName))
	{
	    hr = myHLastError();
	    _PrintErrorStr(hr, "DeleteFile", pUrlCacheEntry->pwszContentFileName);
	}
	if (!DeleteFile(pUrlCacheEntry->pwszMetaDataFileName))
	{
	    hr = myHLastError();
	    _PrintErrorStr(hr, "DeleteFile", pUrlCacheEntry->pwszMetaDataFileName);
	}
	if (S_OK == hr)
	{
	    pArg->cUrlDeleted++;
	}
    }
    wprintf(wszNewLine);
    pArg->cUrl++;

error:
    if (NULL != pbContent)
    {
	LocalFree(pbContent);
    }
    return(TRUE);
}


HRESULT
EnumWinHttpCache(
    OPTIONAL IN WCHAR const *pwszURL,
    IN BOOL fDelete,
    IN BOOL fCRLsOnly)
{
    HRESULT hr;

    if (NULL != g_pfnCryptNetEnumUrlCacheEntry)
    {
	ENUM_ARG EnumArg;

	memset(&EnumArg, 0, sizeof(EnumArg));
	EnumArg.pwszUrlSubString = pwszURL;
	EnumArg.fDelete = fDelete;
	EnumArg.fCRLsOnly = fCRLsOnly;

	if (!(*g_pfnCryptNetEnumUrlCacheEntry)(
				    0,          // dwFlags
				    NULL,       // pvReserved
				    &EnumArg,
				    WinHttpCacheEntryWorker))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "I_CryptNetEnumUrlCacheEntry");
	}
	if (fDelete)
	{
	    wprintf(myLoadResourceString(IDS_FORMAT_DELETED_WINHTTPCACHE), EnumArg.cUrlDeleted);
	}
	else
	{
	    wprintf(myLoadResourceString(IDS_FORMAT_WINHTTPCACHE), EnumArg.cUrl);
	}
	wprintf(wszNewLine);
	wprintf(wszNewLine);
    }
    hr = S_OK;
    
error:
    return(hr);
}


HRESULT
DisplayWinHttpURL(
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    
    hr = EnumWinHttpCache(pwszURL, FALSE, FALSE);
    _JumpIfError(hr, error, "EnumWinHttpCache");
    
error:
    return(hr);
}


HRESULT
DeleteWinHttpCachedURL(
    IN WCHAR const *pwszURL)
{
    HRESULT hr;

    hr = EnumWinHttpCache(pwszURL, TRUE, FALSE);
    _JumpIfError(hr, error, "EnumWinHttpCache");
    
error:
    return(hr);
}


HRESULT
CacheSelectHResult(
    IN HRESULT hr1,
    IN HRESULT hr2)
{
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr1 ||
	(S_OK != hr2 && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr2))
    {
	hr1 = hr2;
    }
    return(hr1);
}


HRESULT
EnumURLCache(
    IN BOOL fDelete,
    IN BOOL fCRLsOnly)
{
    HRESULT hr;
    HRESULT hr2;

    hr = EnumWinINetCache(fDelete, fCRLsOnly);
    _PrintIfError(hr, "EnumWinINetCache");

    hr2 = EnumWinHttpCache(NULL, fDelete, fCRLsOnly);
    _PrintIfError(hr2, "EnumWinHttpCache");

    hr = CacheSelectHResult(hr, hr2);
    _JumpIfError(hr, error, "EnumURLCache");

error:
    return(hr);
}


HRESULT
DisplayURL(
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    HRESULT hr2;
    
    hr = DisplayWinINetURL(pwszURL);
    _PrintIfError(hr, "DisplayWinINetURL");

    hr2 = DisplayWinHttpURL(pwszURL);
    _PrintIfError(hr2, "DisplayWinHttpURL");

    hr = CacheSelectHResult(hr, hr2);
    _JumpIfError(hr, error, "DisplayURL");

error:
    return(hr);
}


HRESULT
DeleteCachedURL(
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    HRESULT hr2;

    hr = DeleteWinINetCachedURL(pwszURL);
    _PrintIfError(hr, "DeleteWinINetCachedURL");

    hr2 = DeleteWinHttpCachedURL(pwszURL);
    _PrintIfError(hr2, "DeleteWinHttpCachedURL");

    hr = CacheSelectHResult(hr, hr2);
    _JumpIfError(hr, error, "DeleteCachedURL");

error:
    return(hr);
}


HRESULT
verbURLCache(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszURL,
    IN WCHAR const *pwszDelete,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = LoadWinINetCacheFunction();
    _PrintIfError(hr, "LoadWinINetCacheFunction");

    if (NULL != pwszDelete)
    {
	if (0 != LSTRCMPIS(pwszDelete, L"Delete"))
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad delete arg");
	}
	if (0 == lstrcmp(L"*", pwszURL))
	{
	    hr = EnumURLCache(TRUE, FALSE); // fDelete, fCRLsOnly (delete all)
	    _JumpIfError(hr, error, "EnumURLCache(Delete all)");

	    hr = DeleteCacheGroups();
	    _JumpIfError(hr, error, "DeleteCacheGroups");
	}
	else if (0 == LSTRCMPIS(pwszURL, L"crl"))
	{
	    hr = EnumURLCache(TRUE, TRUE);	// fDelete, fCRLsOnly (delete CRLs)
	    _JumpIfError(hr, error, "EnumURLCache(Delete CRLs)");
	}
	else
	{
	    hr = DeleteCachedURL(pwszURL);		// delete single URL
	    _JumpIfError(hr, error, "DeleteCachedURL");
	}
    }
    else if (NULL == pwszURL || 0 == lstrcmp(L"*", pwszURL))
    {
	hr = EnumURLCache(FALSE, FALSE);	// fDelete, fCRLsOnly (display all)
	_JumpIfError(hr, error, "EnumURLCache");
    }
    else if (0 == LSTRCMPIS(pwszURL, L"crl"))
    {
	hr = EnumURLCache(FALSE, TRUE);	// fDelete, fCRLsOnly (display CRLs)
	_JumpIfError(hr, error, "EnumURLCache(CRLs)");
    }
    else
    {
	hr = DisplayURL(pwszURL);
	_JumpIfError(hr, error, "DisplayURL");
    }
    hr = S_OK;

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\epf.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       epf.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <winldap.h>

#define EXPORT_CONTROL DOMESTIC

#include "csber.h"
#include "csldap.h"
#include "cainfop.h"
#include "crcutil.h"
#include "cast3.h"

#define __dwFILE__	__dwFILE_CERTUTIL_EPF_CPP__

#define CBTOKEN		8

CRC16 g_CrcTable[256];


typedef struct {
   DWORD dwAlgId;
#define EPFALG_CAST_MD5 0x10
#define EPFALG_RC2_SHA  0x20
#define EPFALG_3DES  	0x40

   // if EPFALG_RC2_SHA, this will be the key
   HCRYPTKEY hKey;

   // if EPFALG_CAST_MD5, we'll have a CAST context ready
   CAST3_CTX sCastContext;

} EPF_SYM_KEY_STRUCT;

#define wszSIGNING	L"Signing"
#define wszEXCHANGE	L"Exchange"

#if 0
   Entrust - CAST3 return codes

#define	C3E_OK			 0	// No error
#define	C3E_DEPAD_FAILURE	-1	// The de-padding operation failed
#define C3E_BAD_KEYLEN		-2	// Key length not supported
#define C3E_SELFTEST_FAILED	-3	// Self-test failed
#define C3E_NOT_SUPPORTED	-4	// Function not supported

#endif

#define EPFALG_EXPORT	0
#define EPFALG_DOMESTIC	0x01000000

static const WCHAR s_wszHeader[] = L"================================================================\n";


VOID
InitCrcTable()
{
    static BOOL s_fInit = FALSE;

    if (!s_fInit)
    {
	USHORT ccitt_crc_poly = 0x8404;		// CCITT crc16 polynominal

	I_CRC16(g_CrcTable, &ccitt_crc_poly);	// initialize CRC generator
	s_fInit = TRUE;
    }
}


HRESULT
IterateHash(
    IN DWORD dwSymAlgId,
    IN HCRYPTPROV hProv,
    IN int iIterations,
    IN BYTE const *rgbHash,
    IN DWORD cbBufferSize,
    IN DWORD cbInternalHashBuffer)
{
    HRESULT hr;
    HCRYPTHASH hIterativeHash = NULL;
    BYTE *pbBufferExtension = NULL;
    DWORD cbBufferExtension;
    DWORD cbHash = cbBufferSize;
    int i;

	// use later to extend internal buffer during hash iteration

    if (cbInternalHashBuffer > cbHash)
    {
	pbBufferExtension = (BYTE *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					cbInternalHashBuffer - cbHash);
	if (NULL == pbBufferExtension)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

    // iterate to get output
    // 99 more times -- we've already done one hash

    for (i = 1; i < iIterations; i++)
    {
	if (!CryptCreateHash(
			hProv,
			EPFALG_CAST_MD5 == dwSymAlgId? CALG_MD5 : CALG_SHA1,
			0,
			0,
			&hIterativeHash))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptCreateHash");
	}

	// hash the intermediate result

	if (!CryptHashData(hIterativeHash, rgbHash, cbHash, 0))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptHashData");
	}

	if (cbInternalHashBuffer > cbHash)
	{
	    // If hash buffer param is larger than hash length, do something
	    // about it.  Fill a buffer with the iteration count & tack it on
	    // the end of the hash.

	    memset(pbBufferExtension, i, cbInternalHashBuffer-cbHash);

	    if (!CryptHashData(
			hIterativeHash,
			pbBufferExtension,
			cbInternalHashBuffer - cbHash,
			0))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptHashData");
	    }
	}

	// done with this round, continue to the next

	cbHash = cbBufferSize;
	if (!CryptGetHashParam(
			hIterativeHash,
			HP_HASHVAL,
			const_cast<BYTE *>(rgbHash),
			&cbHash,
			0))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptGetHashParam");
	}

	CryptDestroyHash(hIterativeHash);
	hIterativeHash = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pbBufferExtension)
    {
	LocalFree(pbBufferExtension);
    }

    if (NULL != hIterativeHash)
    {
        CryptDestroyHash(hIterativeHash);
    }
#if 0
    wprintf(L"FinalHash output\n");
    DumpHex(DH_NOTABPREFIX | DH_PRIVATEDATA | 4, rgbHash, cbBufferSize);
    wprintf(wszNewLine);
#endif
    return(hr);
}

// derive sym encr key

HRESULT
EPFDeriveKey(
    IN DWORD dwAlgId,
    IN DWORD dwKeyLen,
    IN HCRYPTPROV hProv,
    IN WCHAR const *pwszPassword,
    IN WCHAR const *pwszSaltValue,
    IN BYTE const *pbSaltValue,
    IN DWORD cbSaltValue,
    IN DWORD cbHashSize,
    IN OUT EPF_SYM_KEY_STRUCT *psKey)
{
    HRESULT hr;
    char *pszPassword = NULL;
    char *pszSaltValue = NULL;
    HCRYPTHASH hHash = NULL;
    HCRYPTHASH hIVHash = NULL;
    BYTE rgbHash[20];	// hash output
    DWORD cbHash;
    BYTE rgbIV[8];		// IV
    BYTE rgbKeyBlob[sizeof(BLOBHEADER) + sizeof(DWORD) + 16];	// 128 bit key
    BYTE *pbWritePtr;
    DWORD cbPwdBuf;
    BYTE *pbPwdBuf = NULL;

    switch (dwAlgId)
    {
	case EPFALG_CAST_MD5:
	case EPFALG_RC2_SHA:
	case EPFALG_3DES:
	    break;

	default:
	   hr = E_UNEXPECTED;
	   _JumpError(hr, error, "dwAlgId");
    }
    if (NULL == pwszPassword || NULL == pwszSaltValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "SaltValue");
    }
    if (!myConvertWszToSz(&pszPassword, pwszPassword, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToSz");
    }
    if (!myConvertWszToSz(&pszSaltValue, pwszSaltValue, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToSz");
    }
    //wprintf(L"password=\"%hs\", salt=\"%hs\"\n", pszPassword, pszSaltValue);

    cbPwdBuf = strlen(pszPassword) + strlen(pszSaltValue) + 1;
    pbPwdBuf = (BYTE *) LocalAlloc(LMEM_FIXED, cbPwdBuf);
    if (pbPwdBuf == NULL)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "pbPwdBuf");
    }
    strcpy((char *) pbPwdBuf, pszPassword);
    strcat((char *) pbPwdBuf, pszSaltValue);	// pszPassword + pszSaltValue

    if (!CryptCreateHash(
		    hProv,
		    EPFALG_CAST_MD5 == dwAlgId? CALG_MD5 : CALG_SHA1,
		    0,
		    0,
		    &hHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptCreateHash");
    }

    // hash pwd | salt

    if (!CryptHashData(hHash, pbPwdBuf, cbPwdBuf - 1, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptHashData");
    }

    // wprintf(L"\npbPwdBuf: %hs, len: %d\n", (char const *) pbPwdBuf, cbPwdBuf - 1);

    cbHash = sizeof(rgbHash);
    if (!CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &cbHash, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetHashParam");
    }

#if 0
    wprintf(L"=====KEY======\n");
    wprintf(L"FirstHash output\n");
    DumpHex(DH_NOTABPREFIX | DH_PRIVATEDATA | 4, rgbHash, cbHash);
    wprintf(wszNewLine);
#endif

    hr = IterateHash(dwAlgId, hProv, 100, rgbHash, cbHash, cbHashSize);
    _JumpIfError(hr, error, "IterateHash");

    // now rgbHash[0..15] is raw key

    psKey->dwAlgId = dwAlgId;
    if (EPFALG_RC2_SHA == dwAlgId)
    {
        // set up rgbKeyBlob as a contiguous, plaintext blob
        
        pbWritePtr = rgbKeyBlob + sizeof(BLOBHEADER);
        ((BLOBHEADER *) rgbKeyBlob)->bType = PLAINTEXTKEYBLOB;
        ((BLOBHEADER *) rgbKeyBlob)->bVersion = 2;
        ((BLOBHEADER *) rgbKeyBlob)->reserved = 0;
        ((BLOBHEADER *) rgbKeyBlob)->aiKeyAlg = CALG_RC2;
        
        // size
        
        *(DWORD *) pbWritePtr = 16;
        pbWritePtr += sizeof(DWORD);
        
        // data
        
        CopyMemory(pbWritePtr, rgbHash, 16); // 128 bit key
        
        // save last 4 bytes for the first half of the IV
        
        CopyMemory(rgbIV, &rgbHash[16], 4);
        
        // PLAINTEXTKEYBLOB
        
        if (!CryptImportKey(
			hProv,
			rgbKeyBlob,
			sizeof(rgbKeyBlob),
			0,	// no wrapper key
			0,
			&psKey->hKey))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptImportKey");
        }
        {
            DWORD cbEffectiveLen = 128;
            
            if (!CryptSetKeyParam(
			    psKey->hKey,
			    KP_EFFECTIVE_KEYLEN,
			    (BYTE *) &cbEffectiveLen,
			    0))
            {
                hr = myHLastError();
                _JumpError(hr, error, "CryptSetKeyParam(eff keylen)");
            }
        }
        {
            DWORD cbMode = CRYPT_MODE_CBC;
            
            if (!CryptSetKeyParam(psKey->hKey, KP_MODE, (BYTE *) &cbMode, 0))
            {
                hr = myHLastError();
                _JumpError(hr, error, "CryptSetKeyParam(mode)");
            }
        }
    }
    else // gen CAST context
    {
	if (g_fVerbose)
	{
	    wprintf(
		L"CAST KeyMatl: 0x%02x 0x%02x 0x%02x 0x%02x  0x%02x 0x%02x 0x%02x 0x%02x\n",
		rgbHash[0],
		rgbHash[1],
		rgbHash[2],
		rgbHash[3],
		rgbHash[4],
		rgbHash[5],
		rgbHash[6],
		rgbHash[7]);
	}

        // Set up key schedule. No errors since SetNumBits already checked length
        hr = CAST3SetKeySchedule(&psKey->sCastContext, rgbHash, 64); // 64 bit for now
        _JumpIfError(hr, error, "CAST3SetKeySchedule");
    }

    // compute IV

    if (EPFALG_RC2_SHA == dwAlgId)
    {
        // now, generate IV. Start with new hash, hash in (pwd buf | 0x1)
        if (!CryptCreateHash(
			hProv,
			EPFALG_CAST_MD5 == dwAlgId? CALG_MD5 : CALG_SHA1,
			0,
			0,
			&hIVHash))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptCreateHash");
        }
        
        // hash pwd | salt
        if (!CryptHashData(hIVHash, pbPwdBuf, cbPwdBuf - 1, 0))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptHashData");
        }
        
        // hash 0x1 this time (internally, this is 2nd iteration for
	// ExtendedHash)
        
        BYTE bAppendage = 0x1;
        if (!CryptHashData(hIVHash, &bAppendage, sizeof(bAppendage), 0))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptHashData");
        }
        
        if (!CryptGetHashParam(hIVHash, HP_HASHVAL, rgbHash, &cbHash, 0))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptGetHashParam");
        }
        
        hr = IterateHash(dwAlgId, hProv, 100, rgbHash, cbHash, cbHashSize);
        _JumpIfError(hr, error, "IterateHash");

        
        // DONE! previous rgbHash[16..20] and rgbHash[0..4] is IV
        
        CopyMemory(&rgbIV[4], rgbHash, 4);
        if (!CryptSetKeyParam(psKey->hKey, KP_IV, rgbIV, 0))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptSetKeyParam(iv)");
        }
    }
    else  
    {
        // DONE! rgbHash[0..8] is IV 

	if (g_fVerbose)
	{
	    wprintf(
		L"IV: 0x%02x 0x%02x 0x%02x 0x%02x  0x%02x 0x%02x 0x%02x 0x%02x\n",
		rgbHash[8],
		rgbHash[9],
		rgbHash[10],
		rgbHash[11],
		rgbHash[12],
		rgbHash[13],
		rgbHash[14],
		rgbHash[15]);
	}

        // Start CAST in CBC mode w/ IV

        hr = CAST3StartEncryptCBC(&psKey->sCastContext, &rgbHash[8]);
        _JumpIfError(hr, error, "CAST3SetKeySchedule");
    }

    hr = S_OK;

error:
    SecureZeroMemory(rgbHash, cbHash);	// Key material
    SecureZeroMemory(rgbKeyBlob, sizeof(rgbKeyBlob));	// Key material
    if (NULL != pszPassword)
    {
	myZeroDataStringA(pszPassword);	// password data
        LocalFree(pszPassword);
    }
    if (NULL != pszSaltValue)
    {
        LocalFree(pszSaltValue);
    }
    if (NULL != pbPwdBuf)
    {
	SecureZeroMemory(pbPwdBuf, cbPwdBuf);	// password data
	LocalFree(pbPwdBuf);
    }
    if (NULL != hHash)
    {
	CryptDestroyHash(hHash);
    }
    if (NULL != hIVHash)
    {
	CryptDestroyHash(hIVHash);
    }
    return(hr);
}


// generate token from password-dependent key

HRESULT
EPFGenerateKeyToken(
    IN EPF_SYM_KEY_STRUCT const *psKey,
    OUT BYTE *pbToken,
    IN DWORD cbToken)
{
    HRESULT hr;
    HCRYPTKEY hLocalKey = NULL;

    if (CBTOKEN != cbToken)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "cbToken");
    }

    if (EPFALG_RC2_SHA == psKey->dwAlgId)
    {
        if (!CryptDuplicateKey(psKey->hKey, NULL, 0, &hLocalKey))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptDuplicateKey");
        }
        
        // We have the key already set up.
        // Just CBC encrypt one block of zeros as the token.
        
        ZeroMemory(pbToken, CBTOKEN);
        if (!CryptEncrypt(hLocalKey, 0, FALSE, 0, pbToken, &cbToken, CBTOKEN))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptEncrypt");
        }
        
        // and one block of 8s as padding...
        
        memset(pbToken, 8, CBTOKEN);
        cbToken = CBTOKEN;
        if (!CryptEncrypt(hLocalKey, 0, FALSE, 0, pbToken, &cbToken, CBTOKEN))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptEncrypt");
        }
    }
    else // generate CAST token
    {
        // duplicate key state

        CAST3_CTX sLocalKey;
        CopyMemory(&sLocalKey, (BYTE *) &psKey->sCastContext, sizeof(sLocalKey));

        // We have the key already set up.
        // Just CBC encrypt one block of zeros as the token.

        ZeroMemory(pbToken, CBTOKEN);

        // MAC 0

        hr = CAST3UpdateMAC(&sLocalKey, (BYTE *) pbToken, CBTOKEN);
	_JumpIfError(hr, error, "CAST3UpdateEncryptCBC");

        hr = CAST3EndMAC(&sLocalKey);
	_JumpIfError(hr, error, "CAST3UpdateEncryptCBC");

        // and copy intermediate out

        CopyMemory(pbToken, sLocalKey.cbcBuffer.asBYTE, CBTOKEN);

        CAST3Cleanup(&sLocalKey);
    }
    hr = S_OK;

error:
    if (NULL != hLocalKey)
    {
	CryptDestroyKey(hLocalKey);
    }
    return(hr);
}


// check pwd via token

HRESULT
EPFVerifyKeyToken(
    IN EPF_SYM_KEY_STRUCT const *psKey,
    IN BYTE const *pbToken,
    IN DWORD cbToken)
{
    HRESULT hr;
    BYTE rgbComputedToken[CBTOKEN];

    hr = EPFGenerateKeyToken(psKey, rgbComputedToken, sizeof(rgbComputedToken));
    _JumpIfError(hr, error, "EPFGenerateKeyToken");

    if (sizeof(rgbComputedToken) != cbToken ||
	0 != memcmp(pbToken, rgbComputedToken, sizeof(rgbComputedToken)))
    {
	wprintf(L"pbToken\n");
	DumpHex(DH_NOTABPREFIX | 4, pbToken, cbToken);
	wprintf(wszNewLine);

	wprintf(L"rgbComputedToken\n");
	DumpHex(DH_NOTABPREFIX | 4, rgbComputedToken, sizeof(rgbComputedToken));
	wprintf(wszNewLine);

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD);
        _JumpError(hr, error, "bad password");
    }
    if (g_fVerbose)
    {
	wprintf(myLoadResourceString(IDS_TOKENMATCH));	// "Token match"
	wprintf(wszNewLine);
	DumpHex(DH_NOTABPREFIX | 4, pbToken, cbToken);
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    return(hr);
}


// decrypt a section

HRESULT
EPFDecryptSection(
    IN EPF_SYM_KEY_STRUCT const *psKey,
    IN BYTE const *pbSection,
    IN DWORD cbSection,
    OUT BYTE **ppbDecrypted,
    OUT DWORD *pcbDecrypted)
{
    HRESULT hr;
    HCRYPTKEY hLocalKey = NULL;

    switch (psKey->dwAlgId)
    {
	case EPFALG_CAST_MD5:
	case EPFALG_RC2_SHA:
	    break;

	case EPFALG_3DES:
	    DumpHex(DH_NOTABPREFIX | 4, pbSection, cbSection);
	    wprintf(wszNewLine);
	    // FALLTHROUGH

	default:
	   hr = E_UNEXPECTED;
	   _JumpError(hr, error, "dwAlgId");
    }

    // add extra block just in case

    *ppbDecrypted = (BYTE *) LocalAlloc(LMEM_FIXED, cbSection + 8);
    if (NULL == *ppbDecrypted)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "*ppbDecrypted");
    }
    *pcbDecrypted = cbSection; // input len

    // copy into working area

    CopyMemory(*ppbDecrypted, pbSection, cbSection);

    if (EPFALG_RC2_SHA == psKey->dwAlgId)
    {
        if (!CryptDuplicateKey(psKey->hKey, NULL, 0, &hLocalKey))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptDuplicateKey");
        }
        
        // We have the key already set up

        if (!CryptDecrypt(
		    hLocalKey,
		    0,
		    TRUE,
		    0, // flags
		    *ppbDecrypted,
		    pcbDecrypted))
	{
            hr = myHLastError();
            _JumpError(hr, error, "CryptDecrypt");
        }
    }
    else // CAST MD5
    {
        // duplicate key state

        CAST3_CTX sLocalKey;

        CopyMemory(
		&sLocalKey,
		(BYTE *) &psKey->sCastContext,
		sizeof(sLocalKey));

        // We have the key already set up.

        CAST3UpdateDecryptCBC(
			&sLocalKey,
			pbSection,
			*ppbDecrypted,
			(UINT *) pcbDecrypted);

        // decrypt call is a void return
        // _JumpIfError(hr, error, "CAST3UpdateDecryptCBC");

        // handle anything still left in the cipher state

        BYTE *pbTmp = *ppbDecrypted + *pcbDecrypted; // point to known end
        DWORD cbTmp = 0;

        hr = CAST3EndDecryptCBC(
			&sLocalKey,
			pbTmp,
			(UINT *) &cbTmp); // tack any extra on the end
        _JumpIfError(hr, error, "CAST3EndDecryptCBC");

        *pcbDecrypted += cbTmp;

        CAST3Cleanup(&sLocalKey);
    }
#if 0
    wprintf(L"pbDecrypted Data\n");
    DumpHex(DH_NOTABPREFIX | DH_PRIVATEDATA | 4, *ppbDecrypted, *pcbDecrypted);
    wprintf(wszNewLine);
#endif
    hr = S_OK;

error:
    if (NULL != hLocalKey)
    {
        CryptDestroyKey(hLocalKey);
    }
    if (S_OK != hr && NULL != *ppbDecrypted)
    {
       LocalFree(*ppbDecrypted);
       *ppbDecrypted = NULL;
    }
    return(hr);
}


// Encrypt a section

HRESULT
EPFEncryptSection(
    IN EPF_SYM_KEY_STRUCT const *psKey,
    IN BYTE const *pbToBeEncrypted,
    IN DWORD cbToBeEncrypted,
    OUT BYTE **ppbEncrypted,
    OUT DWORD *pcbEncrypted)
{
    HRESULT hr;
    HCRYPTKEY hLocalKey = NULL;

    *ppbEncrypted = NULL;
    *pcbEncrypted = cbToBeEncrypted;

    if (EPFALG_CAST_MD5 != psKey->dwAlgId && EPFALG_RC2_SHA != psKey->dwAlgId)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "dwAlgId");
    }
    if (EPFALG_RC2_SHA == psKey->dwAlgId)
    {
        if (!CryptDuplicateKey(psKey->hKey, NULL, 0, &hLocalKey))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptDuplicateKey");
        }
        
        // We have the key already set up.  Just CBC encrypt one block of zeros
        // as the token.
        
        if (!CryptEncrypt(
		    hLocalKey,
		    0,
		    TRUE,
		    0, // flags
		    NULL,
		    pcbEncrypted,
		    0))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptDecrypt");
        }
        
        *ppbEncrypted = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbEncrypted);
        if (NULL == *ppbEncrypted)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "*ppbEncrypted");
        }
        
        // copy data into slightly larger buffer

        CopyMemory(*ppbEncrypted, pbToBeEncrypted, cbToBeEncrypted);
        
        if (!CryptEncrypt(
		    hLocalKey,
		    0,
		    TRUE,
		    0, // flags
		    *ppbEncrypted,
		    &cbToBeEncrypted,
		    *pcbEncrypted))
	{
            hr = myHLastError();
            _JumpError(hr, error, "CryptDecrypt");
        }
    }
    else // CAST & SHA
    {
        // duplicate key state

        CAST3_CTX sLocalKey;

        CopyMemory(
		&sLocalKey,
		(BYTE *) &psKey->sCastContext,
		sizeof(sLocalKey));

	// allow for final block to run over

        *ppbEncrypted = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbEncrypted + 8);
        if (NULL == *ppbEncrypted)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "*ppbEncrypted");
        }

        // We have the key already set up.

        hr = CAST3UpdateEncryptCBC(
			    &sLocalKey,
			    pbToBeEncrypted,
			    *ppbEncrypted,
			    (UINT *) pcbEncrypted);
	_JumpIfError(hr, error, "CAST3UpdateEncryptCBC");

        // handle anything still left in the cipher state

        BYTE *pbTmp = *ppbEncrypted + *pcbEncrypted; // point to known end
        DWORD cbTmp = 0;

        hr = CAST3EndEncryptCBC(
			&sLocalKey,
			pbTmp,
			(UINT *) &cbTmp); // tack any extra on the end
        _JumpIfError(hr, error, "CAST3EndEncryptCBC");

        *pcbEncrypted += cbTmp;

        CAST3Cleanup(&sLocalKey);
    }
    hr = S_OK;

error:
    if (NULL != hLocalKey)
    {
        CryptDestroyKey(hLocalKey);
    }
    if (S_OK != hr && NULL != *ppbEncrypted)
    {
       LocalFree(*ppbEncrypted);
       *ppbEncrypted = NULL;
    }
    return(hr);
}


// char section and key name strings:

#define szINFSECTION_PASSWORDTOKEN	"Password Token"
#define szINFKEY_PROTECTION		"Protection"
#define szINFKEY_PROFILEVERSION		"Profile Version"
#define szINFKEY_CAST			"CAST"
#define szINFKEY_TOKEN			"Token"
#define szINFKEY_SALTVALUE		"SaltValue"
#define szINFKEY_HASHSIZE		"HashSize"

// 3DES keys:
#define szINFKEY_MACALGORITHM		"MAC Algorithm"
#define szINFKEY_HASHCOUNT		"HashCount"
#define szINFKEY_CRC			"CRC"
#define szINFKEY_OPTIONSMAC		"Options MAC"
#define szINFKEY_USERX500NAMEMAC	"User X.500 Name MAC"

// 3DES section:
#define szINFSECTION_PROTECTED		"Protected"
#define szINFKEY_RANDOMSEED		"randomSeed"
#define szINFKEY_PWHISTORY		"pwHistory"

// 3DES section:
#define szINFSECTION_OPTIONS		"Options"
#define szINFKEY_PROFILETYPE		"ProfileType"
#define szINFKEY_CERTPUBLICATIONPENDING	"CertificatePublicationPending"
#define szINFKEY_USESMIME		"UseSMIME"
#define szINFKEY_ENCRYPTWITH		"EncryptWith"
#define szINFKEY_SMIMEENCRYPTWITH	"SMIMEEncryptWith"
#define szINFKEY_DELETEAFTERDECRYPT	"DeleteAfterDecrypt"
#define szINFKEY_DELETEAFTERENCRYPT	"DeleteAfterEncrypt"

// 3DES section:
#define szINFSECTION_CACERTIFICATES	"CA Certificates"
//#define szINFKEY_CERTIFICATE		"Certificate"

#define szINFSECTION_USERX500NAME	"User X.500 Name"
#define szINFKEY_X500NAME		"X500Name"

#define szINFSECTION_DIGITALSIGNATURE	"Digital Signature"
#define szINFKEY_CERTIFICATE		"Certificate"
#define szINFKEY_KEY			"Key"

#define szINFSECTION_PRIVATEKEYS	"Private Keys"
#define szINFKEY_KEY_FORMAT		"Key%u"
//#define szINFKEY_KEYCOUNT		"KeyCount"

#define szINFSECTION_CERTIFICATEHISTORY	"Certificate History"
#define szINFKEY_NAME_FORMAT		"Name%u"

#define szINFSECTION_USERCERTIFICATE	"User Certificate"
#define szINFKEY_CERTIFICATE		"Certificate"

#define szINFSECTION_CA			"CA"
//#define szINFKEY_CERTIFICATE		"Certificate"

// 40 bit only:
#define szINFSECTION_MANAGER		"Manager"
//#define szINFKEY_CERTIFICATE		"Certificate"

#define szINFSECTION_MICROSOFTEXCHANGE	"Microsoft Exchange"
#define szINFKEY_FRIENDLYNAME		"FriendlyName"
#define szINFKEY_KEYALGID		"KeyAlgId"

// 40 bit only:
#define szINFSECTION_REVOKATIONINFORMATION "Revokation Information"
#define szINFKEY_CRL			"CRL"
#define szINFKEY_CRL1			"CRL1"

#define szINFSECTION_SMIME		"S/MIME"
#define szINFKEY_SIGNINGCERTIFICATE	"Signing Certificate"
#define szINFKEY_SIGNINGKEY		"Signing Key"
#define szINFKEY_PRIVATEKEYS		"Private Keys"
#define szINFKEY_KEYCOUNT		"KeyCount"
#define szINFKEY_ISSUINGCERTIFICATES	"Issuing Certificates"
#define szINFKEY_TRUSTLISTCERTIFICATE	"Trust List Certificate"

#define szINFSECTION_FULLCERTIFICATEHISTORY "Full Certificate History"
//#define szINFKEY_NAME_FORMAT		"Name%u"
#define szINFKEY_SMIME_FORMAT		"SMIME_%u"


// WCHAR section and key name strings:

#define wszINFSECTION_PASSWORDTOKEN	TEXT(szINFSECTION_PASSWORDTOKEN)
#define wszINFKEY_PROTECTION		TEXT(szINFKEY_PROTECTION)
#define wszINFKEY_PROFILEVERSION	TEXT(szINFKEY_PROFILEVERSION)
#define wszINFKEY_CAST			TEXT(szINFKEY_CAST)
#define wszINFKEY_TOKEN			TEXT(szINFKEY_TOKEN)
#define wszINFKEY_SALTVALUE		TEXT(szINFKEY_SALTVALUE)
#define wszINFKEY_HASHSIZE		TEXT(szINFKEY_HASHSIZE)

// 3DES keys:
#define wszINFKEY_MACALGORITHM		TEXT(szINFKEY_MACALGORITHM)
#define wszINFKEY_HASHCOUNT		TEXT(szINFKEY_HASHCOUNT)
#define wszINFKEY_CRC			TEXT(szINFKEY_CRC)
#define wszINFKEY_OPTIONSMAC		TEXT(szINFKEY_OPTIONSMAC)
#define wszINFKEY_USERX500NAMEMAC	TEXT(szINFKEY_USERX500NAMEMAC)

// 3DES section:
#define wszINFSECTION_PROTECTED		TEXT(szINFSECTION_PROTECTED)
#define wszINFKEY_RANDOMSEED		TEXT(szINFKEY_RANDOMSEED)
#define wszINFKEY_PWHISTORY		TEXT(szINFKEY_PWHISTORY)

// 3DES section:
#define wszINFSECTION_OPTIONS		TEXT(szINFSECTION_OPTIONS)
#define wszINFKEY_PROFILETYPE		TEXT(szINFKEY_PROFILETYPE)
#define wszINFKEY_CERTPUBLICATIONPENDING TEXT(szINFKEY_CERTPUBLICATIONPENDING)
#define wszINFKEY_USESMIME		TEXT(szINFKEY_USESMIME)
#define wszINFKEY_ENCRYPTWITH		TEXT(szINFKEY_ENCRYPTWITH)
#define wszINFKEY_SMIMEENCRYPTWITH	TEXT(szINFKEY_SMIMEENCRYPTWITH)
#define wszINFKEY_DELETEAFTERDECRYPT	TEXT(szINFKEY_DELETEAFTERDECRYPT)
#define wszINFKEY_DELETEAFTERENCRYPT	TEXT(szINFKEY_DELETEAFTERENCRYPT)

// 3DES section:
#define wszINFSECTION_CACERTIFICATES	TEXT(szINFSECTION_CACERTIFICATES)
//#define wszINFKEY_CERTIFICATE		TEXT(szINFKEY_CERTIFICATE)

#define wszINFSECTION_USERX500NAME	TEXT(szINFSECTION_USERX500NAME)
#define wszINFKEY_X500NAME		TEXT(szINFKEY_X500NAME)

#define wszINFSECTION_DIGITALSIGNATURE	TEXT(szINFSECTION_DIGITALSIGNATURE)
#define wszINFKEY_CERTIFICATE		TEXT(szINFKEY_CERTIFICATE)
#define wszINFKEY_KEY			TEXT(szINFKEY_KEY)

#define wszINFSECTION_PRIVATEKEYS	TEXT(szINFSECTION_PRIVATEKEYS)
#define wszINFKEY_KEY_FORMAT		TEXT(szINFKEY_KEY_FORMAT)
//#define wszINFKEY_KEYCOUNT		TEXT(szINFKEY_KEYCOUNT)

#define wszINFSECTION_CERTIFICATEHISTORY TEXT(szINFSECTION_CERTIFICATEHISTORY)
#define wszINFKEY_NAME_FORMAT		TEXT(szINFKEY_NAME_FORMAT)

#define wszINFSECTION_USERCERTIFICATE	TEXT(szINFSECTION_USERCERTIFICATE)
#define wszINFKEY_CERTIFICATE		TEXT(szINFKEY_CERTIFICATE)

#define wszINFSECTION_CA		TEXT(szINFSECTION_CA)
//#define wszINFKEY_CERTIFICATE		TEXT(szINFKEY_CERTIFICATE)

// 40 bit only:
#define wszINFSECTION_MANAGER		TEXT(szINFSECTION_MANAGER)
//#define szINFKEY_CERTIFICATE		TEXT(szINFKEY_CERTIFICATE)

#define wszINFSECTION_MICROSOFTEXCHANGE	TEXT(szINFSECTION_MICROSOFTEXCHANGE)
#define wszINFKEY_FRIENDLYNAME		TEXT(szINFKEY_FRIENDLYNAME)
#define wszINFKEY_KEYALGID		TEXT(szINFKEY_KEYALGID)

// 40 bit only:
#define wszINFSECTION_REVOKATIONINFORMATION TEXT(szINFSECTION_REVOKATIONINFORMATION)
#define wszINFKEY_CRL			TEXT(szINFKEY_CRL)
#define wszINFKEY_CRL1			TEXT(szINFKEY_CRL1)

#define wszINFSECTION_SMIME		TEXT(szINFSECTION_SMIME)
#define wszINFKEY_SIGNINGCERTIFICATE	TEXT(szINFKEY_SIGNINGCERTIFICATE)
#define wszINFKEY_SIGNINGKEY		TEXT(szINFKEY_SIGNINGKEY)
#define wszINFKEY_PRIVATEKEYS		TEXT(szINFKEY_PRIVATEKEYS)
#define wszINFKEY_KEYCOUNT		TEXT(szINFKEY_KEYCOUNT)
#define wszINFKEY_ISSUINGCERTIFICATES	TEXT(szINFKEY_ISSUINGCERTIFICATES)
#define wszINFKEY_TRUSTLISTCERTIFICATE	TEXT(szINFKEY_TRUSTLISTCERTIFICATE)

#define wszINFSECTION_FULLCERTIFICATEHISTORY TEXT(szINFSECTION_FULLCERTIFICATEHISTORY)
//#define wszINFKEY_NAME_FORMAT		TEXT(szINFKEY_NAME_FORMAT)
#define wszINFKEY_SMIME_FORMAT		TEXT(szINFKEY_SMIME_FORMAT)


// fixed maximum buffer lengths

#define cwcINFKEY_KEY_FORMATTED \
	(ARRAYSIZE(wszINFKEY_KEY_FORMAT) + cwcDWORDSPRINTF)

#define cwcINFKEY_NAME_FORMATTED \
	(ARRAYSIZE(wszINFKEY_NAME_FORMAT) + cwcDWORDSPRINTF)

#define cwcINFKEY_SMIME_FORMATTED \
	(ARRAYSIZE(wszINFKEY_SMIME_FORMAT) + cwcDWORDSPRINTF)

#define wszSECTION_KEY(Alg, wszSECTION, wszKEY) \
    (EPFALG_3DES == (Alg)? \
	wszLBRACKET wszSECTION wszRBRACKET L" &" wszKEY : \
	wszLBRACKET wszSECTION wszRBRACKET L" @" wszKEY)
	

const WCHAR g_wszCACertCN[] = L"Certificate Authority";


HRESULT
cuPatchEPFFile(
    IN WCHAR const *pwszfnIn,
    OUT WCHAR **ppwszfnOut)
{
    HRESULT hr;
    char *pszfnIn = NULL;
    char *pszfnOut = NULL;
    FILE *pfIn = NULL;
    FILE *pfOut = NULL;
    char *psz;
    char achLine[1024];
    WCHAR awcTempDir[MAX_PATH];
    WCHAR awcfnOut[MAX_PATH];
    BOOL fDeleteTempFile = FALSE;
    DWORD cwc;

    *ppwszfnOut = NULL;
    if (!myConvertWszToSz(&pszfnIn, pwszfnIn, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToSz");
    }
    pfIn = fopen(pszfnIn, "r");
    if (NULL == pfIn)
    {
	DWORD dwFileAttr;

	// Ansi conversion lost characters & the ansi file cannot be found?

	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	dwFileAttr = GetFileAttributes(pwszfnIn);
	if (MAXDWORD != dwFileAttr)
	{
	    hr = S_FALSE;
	}
	_JumpError2(hr, error, "fopen", S_FALSE);
    }
    hr = S_FALSE;
    if (NULL == fgets(achLine, ARRAYSIZE(achLine), pfIn))
    {
	_JumpError2(hr, error, "fgets", hr);
    }
    psz = strchr(achLine, chLBRACKET);
    if (NULL == psz ||
	NULL == strstr(psz, szINFSECTION_PASSWORDTOKEN) ||
	NULL == strchr(psz, chRBRACKET))
    {
	_JumpError2(hr, error, "[]", hr);
    }

    cwc = GetEnvironmentVariable(L"temp", awcTempDir, ARRAYSIZE(awcTempDir));
    if (0 == cwc)
    {
	cwc = GetEnvironmentVariable(L"tmp", awcTempDir, ARRAYSIZE(awcTempDir));
    }
    if (0 == cwc || ARRAYSIZE(awcTempDir) <= cwc)
    {
	hr = myHLastError();
	_PrintError(hr, "GetEnvironmentVariable");
	wcscpy(awcTempDir, L".");
    }
    if (!GetTempFileName(
		awcTempDir,		// directory name
		L"epf",			// lpPrefixString
		0,			// uUnique
		awcfnOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetTempFileName");
    }
    fDeleteTempFile = TRUE;

    if (!myConvertWszToSz(&pszfnOut, awcfnOut, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToSz");
    }
    pfOut = fopen(pszfnOut, "w");
    if (NULL == pfOut)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "fopen");
    }

    fputs("[Version]\nSignature=\"$Windows NT$\"\n\n", pfOut);
    if (fseek(pfIn, 0L, SEEK_SET))
    {
	hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
	_JumpError(hr, error, "fseek");
    }

    while (NULL != fgets(achLine, ARRAYSIZE(achLine), pfIn))
    {
	char *pszPrint;
	char *pszToken;
	BOOL fQuote;

	psz = strchr(achLine, '\n');
	if (NULL == psz)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Line overflow");
	}
	*psz = '\0';

	fQuote = FALSE;
	pszPrint = achLine;
	pszToken = achLine;
	while (' ' == *pszToken)
	{
	    pszToken++;
	}
	psz = strchr(achLine, '=');
	if (';' != *pszToken && NULL != psz)
	{
	    pszPrint = psz + 1;
	    *psz = '\0';
	    while (achLine < psz && ' ' == *--psz)
	    {
		*psz = '\0';
	    }
	    fQuote = NULL != strchr(pszToken, ' ');
	    if (fQuote)
	    {
		fputs("\"", pfOut);
	    }
	    fputs(pszToken, pfOut);
	    if (fQuote)
	    {
		fputs("\"", pfOut);
	    }
	    fputs(" = ", pfOut);

	    while (' ' == *pszPrint)
	    {
		pszPrint++;
	    }
	    psz = &pszPrint[strlen(pszPrint)];
	    while (pszPrint < psz && ' ' == *--psz)
	    {
		*psz = '\0';
	    }
	    fQuote = '\0' != pszPrint[strcspn(pszPrint, " =")];
	}
	if (fQuote)
	{
	    fputs("\"", pfOut);

	    // if there's no equal sign after a comma, then we need to quote
	    // only the first value, and leave the rest of the line alone.

	    psz = strchr(pszPrint, ',');
	    if (NULL != psz && NULL == strchr(psz, '='))
	    {
		pszToken = psz + 1;
		while (' ' == *pszToken)
		{
		    pszToken++;
		}
		*psz = '\0';
		while (pszPrint < psz && ' ' == *--psz)
		{
		    *psz = '\0';
		}
		fputs(pszPrint, pfOut);
		fputs("\"", pfOut);
		fputs(",", pfOut);
		pszPrint = pszToken;
		fQuote = FALSE;
	    }
	}
	fputs(pszPrint, pfOut);
	if (fQuote)
	{
	    fputs("\"", pfOut);
	}
	fputs("\n", pfOut);
    }
    fflush(pfOut);
    if (ferror(pfOut))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "I/O error");
    }

    hr = myDupString(awcfnOut, ppwszfnOut);
    _JumpIfError(hr, error, "myDupString");

    fDeleteTempFile = FALSE;

error:
    if (NULL != pfIn)
    {
	fclose(pfIn);
    }
    if (NULL != pfOut)
    {
	fclose(pfOut);
    }
    if (fDeleteTempFile)
    {
	DeleteFile(awcfnOut);
    }
    if (NULL != pszfnIn)
    {
	LocalFree(pszfnIn);
    }
    if (NULL != pszfnOut)
    {
	LocalFree(pszfnOut);
    }
    return(hr);
}


HRESULT
BuildProtectedKey(
    IN WCHAR const *pwszKey,
    IN DWORD dwAlgId,
    OUT WCHAR **ppwszProtectedKey)
{
    HRESULT hr;
    WCHAR *pwsz;
    
    *ppwszProtectedKey = NULL;
    pwsz = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (1 + wcslen(pwszKey) + 1) * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pwsz[0] = EPFALG_3DES == dwAlgId? L'&' : L'@';
    wcscpy(&pwsz[1], pwszKey);
    *ppwszProtectedKey = pwsz;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
BuildProtectedHeader(
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    OUT BYTE **ppbHeader,
    OUT DWORD *pcbHeader)
{
    HRESULT hr;
    WCHAR *pwszHeader = NULL;
    char *pszHeader = NULL;

    *ppbHeader = NULL;
    pwszHeader = (WCHAR *) LocalAlloc(
		LMEM_FIXED,
		(wcslen(pwszSection) + wcslen(pwszKey) + 1) * sizeof(WCHAR));
    if (NULL == pwszHeader)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszHeader, pwszSection);
    wcscat(pwszHeader, pwszKey);

    if (!myConvertWszToSz(&pszHeader, pwszHeader, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToSz");
    }
    *ppbHeader = (BYTE *) pszHeader;
    *pcbHeader = strlen(pszHeader);
    hr = S_OK;

error:
    if (NULL != pwszHeader)
    {
	LocalFree(pwszHeader);
    }
    return(hr);
}


VOID
cuInfDisplayError()
{
    WCHAR *pwszError = myInfGetError();

    if (NULL != pwszError)
    {
	wprintf(L"%ws\n", pwszError);
	LocalFree(pwszError);
    }
}


HRESULT
cuInfDumpValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN DWORD Index,
    IN BOOL fLastValue,
    IN HRESULT hrQuiet,
    OPTIONAL OUT BYTE **ppbOut,	// if non NULL, caller must call LocalFree
    OPTIONAL OUT DWORD *pcbOut)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    BYTE *pbValue = NULL;
    DWORD cbValue;

    hr = myInfGetKeyValue(
		    hInf,
		    TRUE,	// fLog
		    pwszSection,
		    pwszKey,
		    Index,
		    fLastValue,
		    &pwszValue);
    if (S_OK != hr)
    {
	cuInfDisplayError();
	_PrintErrorStr2(hr, "myInfGetKeyValue", pwszSection, hrQuiet);
	_JumpErrorStr2(hr, error, "myInfGetKeyValue", pwszKey, hrQuiet);
    }

    if (g_fVerbose)
    {
	wprintf(L"[%ws] %ws = %ws\n", pwszSection, pwszKey, pwszValue);
    }
    hr = myCryptStringToBinary(
			pwszValue,
			0,
			CRYPT_STRING_BASE64,
			&pbValue,
			&cbValue,
			NULL,
			NULL);
    _JumpIfError(hr, error, "myCryptStringToBinary");

    if (g_fVerbose)
    {
	DumpHex(DH_PRIVATEDATA, pbValue, cbValue);
    }
    if (NULL != ppbOut && NULL != pcbOut)
    {
	*pcbOut = cbValue;
	*ppbOut = pbValue;
	pbValue = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    if (NULL != pbValue)
    {
        LocalFree(pbValue);
    }
    return(hr);
}


HRESULT
cuInfDumpProtectedValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN EPF_SYM_KEY_STRUCT const *psKey,
    IN HRESULT hrQuiet,
    OPTIONAL OUT BYTE **ppbOut,	// if non NULL, caller must call LocalFree
    OPTIONAL OUT DWORD *pcbOut)
{
    HRESULT hr;
    WCHAR *pwszProtectedKey = NULL;
    BYTE *pbHeader = NULL;
    DWORD cbHeader;
    BYTE *pbEncrypted = NULL;
    DWORD cbEncrypted;
    BYTE *pbDecrypted = NULL;
    DWORD cbDecrypted;
    DWORD cbData;
    CRC16 CrcRead;
    CRC16 CrcComputed;

    if (NULL != ppbOut)
    {
	*ppbOut = NULL;
    }

    hr = BuildProtectedKey(pwszKey, psKey->dwAlgId, &pwszProtectedKey);
    _JumpIfError(hr, error, "BuildProtectedKey");

    hr = BuildProtectedHeader(pwszSection, pwszKey, &pbHeader, &cbHeader);
    _JumpIfError(hr, error, "BuildProtectedHeader");

    hr = cuInfDumpValue(
		    hInf,
		    pwszSection,
		    pwszProtectedKey,
		    1,		// Index
		    TRUE,	// fLastValue
		    hrQuiet,
		    &pbEncrypted,
		    &cbEncrypted);
    _JumpIfError2(hr, error, "cuInfDumpValue", hrQuiet);

    hr = EPFDecryptSection(
		    psKey,
		    pbEncrypted,
		    cbEncrypted,
		    &pbDecrypted,
		    &cbDecrypted);
    _JumpIfError(hr, error, "EPFDecryptSection");

    if (g_fVerbose)
    {
	wprintf(wszNewLine);
	DumpHex(DH_MULTIADDRESS | DH_NOTABPREFIX | DH_PRIVATEDATA | 4, pbDecrypted, cbDecrypted);
    }

    if (sizeof(CrcRead) + cbHeader > cbDecrypted ||
	0 != memcmp(&pbDecrypted[sizeof(CrcRead)], pbHeader, cbHeader))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad header");
    }

    // Calculate the CRC

    CrcComputed = 0xffff;
    F_CRC16(
	g_CrcTable,
	&CrcComputed,
	&pbDecrypted[sizeof(CrcRead)],
	cbDecrypted - sizeof(CrcRead));
    _swab((char *) pbDecrypted, (char *) &CrcRead, sizeof(CrcRead));

    DBGPRINT((
	CrcRead == CrcComputed? DBG_SS_CERTUTILI : DBG_SS_ERROR,
	"[%ws] %ws: crc: Read=%x, Computed=%x\n",
	pwszSection,
	pwszProtectedKey,
	CrcRead,
	CrcComputed));

    if (CrcRead != CrcComputed)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad crc");
    }
    if (NULL != ppbOut && NULL != pcbOut)
    {
	cbData = cbDecrypted - (sizeof(CrcRead) + cbHeader);
	if (0 != cbData)
	{
	    *ppbOut = (BYTE *) LocalAlloc(LMEM_FIXED, cbData);
	    if (NULL == *ppbOut)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(
		    *ppbOut,
		    &pbDecrypted[sizeof(CrcRead) + cbHeader],
		    cbData);
	}
	*pcbOut = cbData;
    }

error:
    if (NULL != pwszProtectedKey)
    {
	LocalFree(pwszProtectedKey);
    }
    if (NULL != pbHeader)
    {
	LocalFree(pbHeader);
    }
    if (NULL != pbEncrypted)
    {
        LocalFree(pbEncrypted);
    }
    if (NULL != pbDecrypted)
    {
	LocalFree(pbDecrypted);
    }
    return(hr);
}


HRESULT
cuInfDumpNumericKeyValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN DWORD Index,
    IN BOOL fLastValue,
    IN BOOL fDump,
    IN HRESULT hrQuiet,
    OUT DWORD *pdw)
{
    HRESULT hr;
    DWORD dw;

    hr = myInfGetNumericKeyValue(
			    hInf,
			    TRUE,	// fLog
			    pwszSection,
			    pwszKey,
			    Index,
			    fLastValue,
			    &dw);
    if (S_OK != hr)
    {
	if (hrQuiet != hr)
	{
	    cuInfDisplayError();
	}
	_JumpErrorStr2(hr, error, "myInfGetNumericKeyValue", pwszKey, hrQuiet);
    }

    if (fDump)
    {
	wprintf(L"[%ws] %ws = %u", pwszSection, pwszKey, dw);
	if (9 < dw)
	{
	    wprintf(L" (0x%x)", dw);
	}
	wprintf(wszNewLine);
    }
    *pdw = dw;

error:
    return(hr);
}


HRESULT
cuInfDumpStringKeyValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN BOOL fDump,
    IN HRESULT hrQuiet,
    OPTIONAL OUT WCHAR **ppwszValue)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;

    hr = myInfGetKeyValue(
		    hInf,
		    TRUE,	// fLog
		    pwszSection,
		    pwszKey,
		    1,		// Index
		    TRUE,	// fLastValue
		    &pwszValue);
    if (S_OK != hr)
    {
	if (hrQuiet != hr)
	{
	    cuInfDisplayError();
	}
	_JumpErrorStr2(hr, error, "myInfGetKeyValue", pwszKey, hrQuiet);
    }

    if (fDump)
    {
	wprintf(L"[%ws] %ws = %ws\n", pwszSection, pwszKey, pwszValue);
    }
    if (NULL != ppwszValue)
    {
	*ppwszValue = pwszValue;
	pwszValue = NULL;
    }

error:
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


HRESULT
cuInfDumpDNKeyValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN BOOL fDump)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    WCHAR *pwszName = NULL;
    CERT_NAME_BLOB Name;

    Name.pbData = NULL;

    hr = myInfGetKeyValue(
		    hInf,
		    TRUE,	// fLog
		    pwszSection,
		    pwszKey,
		    1,		// Index
		    TRUE,	// fLastValue
		    &pwszValue);
    if (S_OK != hr)
    {
	cuInfDisplayError();
	_JumpErrorStr(hr, error, "myInfGetKeyValue", pwszKey);
    }

    //wprintf(L"[%ws] %ws = %ws\n", pwszSection, pwszKey, pwszValue);

    hr = myCertStrToName(
		X509_ASN_ENCODING,
		pwszValue,		// pszX500
		0,			// CERT_NAME_STR_REVERSE_FLAG
		NULL,			// pvReserved
		&Name.pbData,
		&Name.cbData,
		NULL);			// ppszError
    _JumpIfErrorStr(hr, error, "myCertStrToName", pwszValue);

    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		&Name,
		CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		&pwszName);
    _JumpIfError(hr, error, "myCertNameToStr");

    if (fDump)
    {
	wprintf(L"[%ws] %ws = ", pwszSection, pwszKey);
    }
    wprintf(L"%ws\n", pwszName);

error:
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != Name.pbData)
    {
	LocalFree(Name.pbData);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


HRESULT
cuInfDumpBinaryNameKeyValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN DWORD Index,
    IN BOOL fLastValue,
    IN BOOL fDump,
    IN HRESULT hrQuiet)
{
    HRESULT hr;
    WCHAR *pwszName = NULL;
    CERT_NAME_BLOB Name;

    Name.pbData = NULL;

    hr = cuInfDumpValue(
		    hInf,
		    pwszSection,
		    pwszKey,
		    Index,
		    fLastValue,
		    hrQuiet,
		    &Name.pbData,
		    &Name.cbData);
    _JumpIfErrorStr(hr, error, "cuInfDumpValue", pwszKey);

    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		&Name,
		CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		&pwszName);
    _JumpIfError(hr, error, "myCertNameToStr");

    if (fDump)
    {
	wprintf(L"[%ws] %ws = ", pwszSection, pwszKey);
    }
    wprintf(L"%ws\n", pwszName);

error:
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != Name.pbData)
    {
	LocalFree(Name.pbData);
    }
    return(hr);
}


HRESULT
cuInfDumpProtectedStringValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN EPF_SYM_KEY_STRUCT const *psKey,
    IN BOOL fDump,
    IN HRESULT hrQuiet,
    OUT WCHAR **ppwszValue)
{
    HRESULT hr;
    BYTE *pbValue = NULL;
    DWORD cbValue;

    *ppwszValue = NULL;
    hr = cuInfDumpProtectedValue(
			hInf,
			pwszSection,
			pwszKey,
			psKey,
			hrQuiet,
			&pbValue,
			&cbValue);
    _JumpIfError(hr, error, "cuInfDumpProtectedValue");

    if (!myConvertSzToWsz(ppwszValue, (char const *) pbValue, cbValue))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertSzToWsz");
    }
    hr = S_OK;

error:
    if (NULL != pbValue)
    {
	LocalFree(pbValue);
    }
    return(hr);
}


HRESULT
cuInfDumpProtectedDwordValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN EPF_SYM_KEY_STRUCT const *psKey,
    IN BOOL fDump,
    IN HRESULT hrQuiet,
    OUT DWORD *pdwValue)
{
    HRESULT hr;
    BYTE *pbValue = NULL;
    DWORD cbValue;

    *pdwValue = 0;
    hr = cuInfDumpProtectedValue(
			hInf,
			pwszSection,
			pwszKey,
			psKey,
			hrQuiet,
			&pbValue,
			&cbValue);
    _JumpIfError(hr, error, "cuInfDumpProtectedValue");

    if (sizeof(*pdwValue) != cbValue)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "cbValue");
    }
    CopyMemory(pdwValue, pbValue, sizeof(*pdwValue));
    hr = S_OK;

error:
    if (NULL != pbValue)
    {
	LocalFree(pbValue);
    }
    return(hr);
}


HRESULT
cuInfDumpHexKeyValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN BOOL fDump,
    OPTIONAL OUT BYTE **ppbOut,
    OPTIONAL OUT DWORD *pcbOut)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    BYTE *pbOut = NULL;
    DWORD cbOut;

    hr = myInfGetKeyValue(
		    hInf,
		    TRUE,	// fLog
		    pwszSection,
		    pwszKey,
		    1,		// Index
		    TRUE,	// fLastValue
		    &pwszValue);
    if (S_OK != hr)
    {
	cuInfDisplayError();
	_JumpErrorStr(hr, error, "myInfGetKeyValue", pwszKey);
    }

    if (fDump)
    {
	wprintf(L"[%ws] %ws = %ws\n", pwszSection, pwszKey, pwszValue);
    }
    hr = WszToMultiByteInteger(TRUE, pwszValue, &cbOut, &pbOut);
    _JumpIfErrorStr(hr, error, "WszToMultiByteInteger", pwszValue);

    if (g_fVerbose)
    {
	DumpHex(DH_PRIVATEDATA, pbOut, cbOut);
    }
    if (NULL != ppbOut && NULL != pcbOut)
    {
       *ppbOut = pbOut;
       *pcbOut = cbOut;
        pbOut = NULL;
    }

error:
    if (NULL != pbOut)
    {
	LocalFree(pbOut);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


VOID
ExtraAsnBytes(
    IN BYTE const *pbCert,
    IN DWORD cbCert)
{
    DWORD cbAsn = MAXDWORD;

    if (6 < cbCert && BER_SEQUENCE == pbCert[0])
    {
	if (0x80 & pbCert[1])
	{
	    switch (0x7f & pbCert[1])
	    {
		case 1:
		    cbAsn = pbCert[2];
		    cbAsn += 3;
		    break;

		case 2:
		    cbAsn = (pbCert[2] << 8) | pbCert[3];
		    cbAsn += 4;
		    break;

		case 3:
		    cbAsn = (pbCert[2] << 16) | (pbCert[3] << 8) | pbCert[4];
		    cbAsn += 5;
		    break;

		case 4:
		    cbAsn = (pbCert[2] << 24) | (pbCert[3] << 16) | (pbCert[4] << 8) | pbCert[5];
		    cbAsn += 6;
		    break;
	    }
	}
	else
	{
	    cbAsn = pbCert[1];
	    cbAsn += 2;
	}
    }
    if (MAXDWORD == cbAsn)
    {
	DumpHex(0, pbCert, min(6, cbCert));
	wprintf(myLoadResourceString(IDS_BAD_ASN_LENGTH));	// "Bad Asn length encoding"
	wprintf(wszNewLine);
    }
    else
    {
	if (cbCert != cbAsn)
	{
	    wprintf(L"cbCert=%x cbAsn=%x\n", cbCert, cbAsn);
	    wprintf(
		myLoadResourceString(IDS_FORMAT_ASN_EXTRA), // "Asn encoding: %x extra bytes"
		cbCert - cbAsn);
	    wprintf(wszNewLine);
	}
    }
}


HRESULT
AddCertAndKeyToStore(
    IN OUT HCERTSTORE hStore,
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    IN DWORD dwKeySpec)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    GUID guid;
    WCHAR *pwszKeyContainerName = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    CRYPT_KEY_PROV_INFO kpi;

    if (!CertAddEncodedCertificateToStore(
				hStore,
				X509_ASN_ENCODING,
				pbCert,
				cbCert,
				CERT_STORE_ADD_REPLACE_EXISTING,
				&pcc))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddEncodedCertificateToStore");
    }

    // Use standard GUID key container names so they get cleaned up properly

    myUuidCreate(&guid);
    hr = StringFromCLSID(guid, &pwszKeyContainerName);
    _JumpIfError(hr, error, "StringFromCLSID");

    ZeroMemory(&kpi, sizeof(kpi));
    kpi.pwszContainerName = pwszKeyContainerName;
    kpi.pwszProvName = MS_STRONG_PROV;
    kpi.dwProvType = PROV_RSA_FULL;
    kpi.dwFlags = g_fUserRegistry? 0 : CRYPT_MACHINE_KEYSET;
    kpi.dwKeySpec = dwKeySpec;

    if (!CryptAcquireContext(
			&hProv,
			kpi.pwszContainerName,
			kpi.pwszProvName,
			kpi.dwProvType,
			CRYPT_NEWKEYSET | kpi.dwFlags))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }
    if (!CryptImportKey(hProv, pbKey, cbKey, NULL, CRYPT_EXPORTABLE, &hKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptImportKey");
    }
    if (!CertSetCertificateContextProperty(
				    pcc,
				    CERT_KEY_PROV_INFO_PROP_ID,
				    0,
				    &kpi))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertSetCertificateContextProperty");
    }
    hr = S_OK;

error:
    if (NULL != hKey)
    {
	CryptDestroyKey(hKey);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != pwszKeyContainerName)
    {
	CoTaskMemFree(pwszKeyContainerName);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


// Define a structure to hold all of the private Key Exchange key material
// Commented out the pointer elements to match the binary data image.

typedef struct {
    DWORD           dwKeySpec;
    DWORD           cbPrivKey;
    union {
        //LPBYTE    pbPrivKey;
        DWORD       obPrivKey;
    };
    DWORD           cbPubKey;
    union {
        //LPBYTE    pbPubKey;
        DWORD       obPubKey;
    };
} OneKeyBlob;


#if 0
typedef struct {
    DWORD       dwSize;
    DWORD       cKeys;
    OneKeyBlob  rgKeyBlobs[0];
} ExchangeKeyBlob_Old;
#endif

typedef struct {
    DWORD               dwSize;
    DWORD               cKeys;
    DWORD               dwKeyAlg;
    //OneKeyBlob        rgKeyBlobs[0];
} ExchangeKeyBlobEx;

#define CBEKB	CCSIZEOF_STRUCT(ExchangeKeyBlobEx, dwKeyAlg)

#define dwKEYSPEC_V1ENCRYPTION_BASE	1000
#define dwKEYSPEC_V1SIGNATURE		1500
#define dwKEYSPEC_V3ENCRYPTION_BASE	2000
#define dwKEYSPEC_V3SIGNATURE		2500


HRESULT
VerifyAndSaveCertAndKey(
    OPTIONAL IN OUT HCERTSTORE hStore,
    IN BOOL fDump,
    IN WCHAR const *pwszKeyType,
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN BYTE const *pbEPFKey,
    IN DWORD cbEPFKey,
    IN DWORD cKey,
    IN ALG_ID aiKeyAlg,
    IN DWORD dwKeySpec)
{
    HRESULT hr;
    BYTE *pbKey = NULL;
    DWORD cbKey;
    ExchangeKeyBlobEx ekb;
    BYTE const *pb;
    DWORD cb;
    OneKeyBlob okb;
    DWORD i;

    pb = pbEPFKey;
    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    if (CBEKB > cbEPFKey)
    {
	_JumpError(hr, error, "ExchangeKeyBlobEx size");
    }
    //DumpHex(DH_NOTABPREFIX | DH_PRIVATEDATA | 4, pbEPFKey, CBEKB);

    CopyMemory(&ekb, pbEPFKey, CBEKB);
    if (aiKeyAlg != ekb.dwKeyAlg)
    {
	_JumpError(hr, error, "unexpected AlgId");
    }
    pb += CBEKB;

    if (CBEKB != ekb.dwSize)
    {
	_JumpError(hr, error, "ExchangeKeyBlobEx.dwSize");
    }
    cb = CBEKB + sizeof(OneKeyBlob) * ekb.cKeys;
    if (cb > cbEPFKey)
    {
	_JumpError(hr, error, "ExchangeKeyBlobEx size");
    }
    if (cKey != ekb.cKeys)
    {
	_JumpError(hr, error, "ExchangeKeyBlobEx.cKeys");
    }
    for (i = 0; i < ekb.cKeys; i++)
    {
	CopyMemory(&okb, &pb[sizeof(OneKeyBlob) * i], sizeof(okb));
	if (cb != okb.obPrivKey)
	{
	    _JumpError(hr, error, "OneKeyBlob.obPrivKey");
	}
	cb += okb.cbPrivKey;
	if (cb > cbEPFKey)
	{
	    _JumpError(hr, error, "OneKeyBlob.cbPrivKey");
	}
	if (0 != okb.obPubKey || 0 != okb.cbPubKey)
	{
	    if (cb != okb.obPubKey)
	    {
		_JumpError(hr, error, "OneKeyBlob.obPubKey");
	    }
	    cb += okb.cbPubKey;
	    if (cb > cbEPFKey)
	    {
		_JumpError(hr, error, "OneKeyBlob.cbPubKey");
	    }
	}
    }
    if (cb != cbEPFKey)
    {
	_JumpError(hr, error, "cbEPFKey");
    }
    for (i = 0; i < ekb.cKeys; i++)
    {
	CopyMemory(&okb, &pb[sizeof(OneKeyBlob) * i], sizeof(okb));

	//DumpHex(DH_NOTABPREFIX | DH_PRIVATEDATA | 4, &pbEPFKey[okb.obPrivKey], okb.cbPrivKey);
	if (NULL != pbKey)
	{
	    SecureZeroMemory(pbKey, cbKey);	// Key material
	    LocalFree(pbKey);
	    pbKey = NULL;
	}
	hr = myDecodeKMSRSAKey(
			&pbEPFKey[okb.obPrivKey],
			okb.cbPrivKey,
			aiKeyAlg,
			&pbKey,
			&cbKey);
	_JumpIfError(hr, error, "myDecodeKMSRSAKey");

	hr = myVerifyKMSKey(pbCert, cbCert, pbKey, cbKey, dwKeySpec, TRUE);
	_PrintIfError2(hr, "myVerifyKMSKey", HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

	if (S_OK == hr)
	{
	    if (fDump)
	    {
		wprintf(L"  dwKeySpec = %u\n", okb.dwKeySpec);

		hr = cuDumpPrivateKeyBlob(pbKey, cbKey, FALSE);
		_PrintIfError(hr, "cuDumpPrivateKeyBlob");
	    }
	    wprintf(
		myLoadResourceString(IDS_FORMAT_VERIFIES_AGAINST_CERT), // "%ws key verifies against certificate"
		pwszKeyType);
	    wprintf(wszNewLine);

	    if (fDump && 0 != okb.obPubKey && 0 != okb.cbPubKey)
	    {
		wprintf(myLoadResourceString(IDS_PUBLIC_KEY_COLON)); // "Public key:"
		wprintf(wszNewLine);
		DumpHex(
		    DH_NOTABPREFIX | 4,
		    &pbEPFKey[okb.obPubKey],
		    okb.cbPubKey);
	    }
	    if (NULL != hStore)
	    {
		hr = AddCertAndKeyToStore(
				    hStore,
				    pbCert,
				    cbCert,
				    pbKey,
				    cbKey,
				    dwKeySpec);
		_JumpIfError(hr, error, "AddCertAndKeyToStore");
	    }
	    break;	// success!
	}
    }

error:
    if (S_OK != hr)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_NO_MATCH_CERT), // "%ws key does not match certifcate"
	    pwszKeyType);
	wprintf(L": %x\n", hr);
	wprintf(wszNewLine);
    }
    if (NULL != pbKey)
    {
	SecureZeroMemory(pbKey, cbKey);	// Key material
	LocalFree(pbKey);
    }
    return(hr);
}


HRESULT
VerifyAndSaveOneCertAndKey(
    OPTIONAL IN OUT HCERTSTORE hStore,
    IN BOOL fDump,
    IN WCHAR const *pwszKeyType,
    IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN BYTE const *pbKMSKey,
    IN DWORD cbKMSKey,
    IN ALG_ID aiKeyAlg,
    IN DWORD dwKeySpec)
{
    HRESULT hr;
    BYTE *pbKey = NULL;
    DWORD cbKey;
    BOOL fMatch;

    hr = myDecodeKMSRSAKey(pbKMSKey, cbKMSKey, aiKeyAlg, &pbKey, &cbKey);
    _JumpIfError(hr, error, "myDecodeKMSRSAKey");

    hr = myVerifyKMSKey(pbCert, cbCert, pbKey, cbKey, dwKeySpec, TRUE);
    if (S_OK != hr)
    {
	_PrintError(hr, "myVerifyKMSKey");
	if (!g_fForce)
	{
	    goto error;		// -f ignores this error
	}
    }
    fMatch = S_OK == hr;

    if (fDump)
    {
	wprintf(L"  dwKeySpec = %u\n", dwKeySpec);

	hr = cuDumpPrivateKeyBlob(pbKey, cbKey, FALSE);
	_PrintIfError(hr, "cuDumpPrivateKeyBlob");
    }
    wprintf(
	myLoadResourceString(
	    fMatch?
		IDS_FORMAT_VERIFIES_AGAINST_CERT : // "%ws key verifies against certificate"
		IDS_FORMAT_NO_MATCH_CERT), // "%ws key does not match certificate"
	pwszKeyType);
    wprintf(wszNewLine);

    if (NULL != hStore)
    {
	hr = AddCertAndKeyToStore(
			    hStore,
			    pbCert,
			    cbCert,
			    pbKey,
			    cbKey,
			    dwKeySpec);
	_JumpIfError(hr, error, "AddCertAndKeyToStore");
    }

error:
    if (NULL != pbKey)
    {
	SecureZeroMemory(pbKey, cbKey);	// Key material
	LocalFree(pbKey);
    }
    return(hr);
}


HRESULT
AddCACertToStore(
    IN BYTE const *pbCertCA,
    IN DWORD cbCertCA)
{
    HRESULT hr;
    CERT_CONTEXT const *pccCA = NULL;
    HCERTSTORE hStore = NULL;

    pccCA = CertCreateCertificateContext(X509_ASN_ENCODING, pbCertCA, cbCertCA);
    if (NULL == pccCA)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    hStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_REGISTRY_W,
			X509_ASN_ENCODING,
			NULL,		// hProv
			CERT_STORE_OPEN_EXISTING_FLAG |
			    CERT_STORE_ENUM_ARCHIVED_FLAG |
			    CERT_SYSTEM_STORE_LOCAL_MACHINE,
			wszCA_CERTSTORE);
    if (NULL == hStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }
    if (!CertAddCertificateContextToStore(
			hStore,
			pccCA,
			CERT_STORE_ADD_USE_EXISTING,
			NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddCertificateContextToStore");
    }
    hr = S_OK;

error:
    if (NULL != pccCA)
    {
	CertFreeCertificateContext(pccCA);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
DumpSerializedCertStore(
    IN BYTE const *pbStore,
    IN DWORD cbStore)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;
    CRYPT_DATA_BLOB Blob;

    Blob.pbData = const_cast<BYTE *>(pbStore);
    Blob.cbData = cbStore;

    hStore = CertOpenStore(
		CERT_STORE_PROV_SERIALIZED,
		X509_ASN_ENCODING,
		NULL,	// hCryptProv
		CERT_STORE_NO_CRYPT_RELEASE_FLAG |
		    CERT_STORE_ENUM_ARCHIVED_FLAG,
		&Blob);
    if (NULL == hStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertOpenStore");
    }
    hr = cuDumpAndVerifyStore(
			hStore,
			DVNS_DUMP |
			    DVNS_DUMPKEYS |
			    DVNS_DUMPPROPERTIES,
			NULL,		// pwszCertName
			MAXDWORD,	// iCertSave
			MAXDWORD,	// iCRLSave
			MAXDWORD,	// iCTLSave
			NULL,		// pwszfnOut
			NULL);		// pwszPassword
    _JumpIfError(hr, error, "cuDumpAndVerifyStore");

error:
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
GenerateV1Keys(
    IN BOOL fRoot,
    OUT HCRYPTPROV *phProv)
{
    HRESULT hr;
    HCRYPTKEY hKey = NULL;

    *phProv = NULL;

    // create verify container

    if (!CryptAcquireContext(
			phProv,
			NULL,		// pwszContainer
			NULL,		// pwszProvName
			PROV_RSA_FULL,
			CRYPT_VERIFYCONTEXT))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }

    // create signature keys 

    if (!CryptGenKey(
		*phProv,
		AT_SIGNATURE,
		(512 << 16) | CRYPT_EXPORTABLE,
		&hKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGenKey");
    }
    hr = S_OK;

error:
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    return(hr);
}



// valid decrypted non-PKCS1 signature (512 bits/64 bytes):
// 1) Byte reversed hash
// 2) length of hash (0x10 bytes)
// 3) Octet string tag (BER_OCTET_STRING)
// 4) 0x00 byte
// 5) 0xff pad (as many bytes as necessary)
// 6) 0x01 pad byte
// 7) 0x00 pad byte
//
// 6e e3 f9 e8 83 e6 b1 a0-ff 63 96 df 2e 30 bb fe
// 10 04 00 ff ff ff ff ff-ff ff ff ff ff ff ff ff
// ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
// ff ff ff ff ff ff ff ff-ff ff ff ff ff ff 01 00

HRESULT
mySignMD5HashOnly(
    IN HCRYPTPROV hProv,
    IN char const *pszAlgId,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    OUT BYTE **ppbSigned,
    OUT DWORD *pcbSigned)
{
    HRESULT hr;
    HCRYPTHASH hHash = NULL;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    BYTE abSig[64];
    DWORD cbSig;
    DWORD i;
    HCRYPTKEY hKey = NULL;
#if 0
#else
    BYTE *pbKey = NULL;
    DWORD cbKey;
    HCRYPTKEY hKeySig = NULL;
#endif
    static BYTE abSigPrefix[] =
    {
	BER_SEQUENCE, 9,
	    BER_OBJECT_ID, 5, 0x2b, 0x0e, 0x03, 0x02, 0x03,
	    BER_NULL, 0,
	BER_BIT_STRING, sizeof(abSig) + 1,
	    0,	// Unused bits
	    // encryted signature (sizeof(abSig))
    };
    BYTE abSigSequence[sizeof(abSigPrefix) + sizeof(abSig)];
    CRYPT_SEQUENCE_OF_ANY Seq;
    CRYPT_DER_BLOB rgBlob[2];

    *ppbSigned = NULL;
    if (!CryptCreateHash(hProv, CALG_MD5, 0, 0, &hHash))
    {
	hHash = NULL;
	hr = myHLastError();
	_JumpError(hr, error, "CryptCreateHash");
    }
    if (!CryptHashData(hHash, pbEncoded, cbEncoded, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptHashData");
    }
    cbHash = sizeof(abHash);
    if (!CryptGetHashParam(hHash, HP_HASHVAL, abHash, &cbHash, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetHashParam");
    }
#if 0
    wprintf(L"\nV1 Cert to-be-signed:\n");
    DumpHex(DH_NOTABPREFIX | DH_NOASCIIHEX | 4, pbEncoded, cbEncoded);
    wprintf(L"\nV1 Cert to-be-signed Hash:\n");
    DumpHex(DH_NOTABPREFIX | DH_NOASCIIHEX | 4, abHash, cbHash);
#endif

    memset(abSig, (BYTE) 0xff, sizeof(abSig));
    for (i = 0; i < cbHash; i++)
    {
	abSig[i] = abHash[cbHash - i - 1];
    }
    abSig[cbHash] = (BYTE) cbHash;
    abSig[cbHash + 1] = (BYTE) BER_OCTET_STRING;
    abSig[cbHash + 2] = (BYTE) 0x00;
    abSig[sizeof(abSig) - 2] = (BYTE) 0x01;
    abSig[sizeof(abSig) - 1] = (BYTE) 0x00;

#if 0
    wprintf(L"\nV1 clear text signature (padded hash):\n");
    DumpHex(DH_NOTABPREFIX | DH_NOASCIIHEX | 4, abSig, sizeof(abSig));
#endif

#if 0
    if (!CryptGetUserKey(hProv, AT_SIGNATURE, &hKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetUserKey");
    }
#else
    if (!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hKey))
    {
	hr = myHLastError();
	if (hr != NTE_NO_KEY)
	{
	    _JumpError(hr, error, "CryptGetUserKey");
	}

	if (!CryptGetUserKey(hProv, AT_SIGNATURE, &hKeySig))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptGetUserKey - sig");
	}

	// UGH! migrate from AT_SIGNATURE container!

	cbKey = 0;
	hr = myCryptExportKey(
			hKeySig,	// hKey
			NULL,		// hKeyExp
			PRIVATEKEYBLOB,	// dwBlobType
			0,		// dwFlags
			&pbKey,
			&cbKey);
	_JumpIfError(hr, error, "myCryptExportKey");

	// UGH! fix up the algid to signature...

	((PUBLICKEYSTRUC *) pbKey)->aiKeyAlg = CALG_RSA_KEYX;
	
	// and re-import it

	if (!CryptImportKey(
			hProv,
			pbKey,
			cbKey,
			NULL,
			CRYPT_EXPORTABLE,
			&hKey))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptImportKey");
	}
    }
#endif

//#define RSAENH_NOT_FIXED	// should no longer be necessary...
#ifdef RSAENH_NOT_FIXED
    BYTE abSig2[64 + 8];
    ZeroMemory(abSig2, sizeof(abSig2));
    CopyMemory(abSig2, abSig, sizeof(abSig));
#endif

    cbSig = sizeof(abSig);
    if (!CryptDecrypt(
		hKey,
		NULL,		// hHash
		TRUE,		// Final
		CRYPT_DECRYPT_RSA_NO_PADDING_CHECK, // dwFlags
#ifdef RSAENH_NOT_FIXED
		abSig2,
#else
		abSig,
#endif
		&cbSig))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptDecrypt");
    }
#ifdef RSAENH_NOT_FIXED
    CopyMemory(abSig, abSig2, sizeof(abSig));
#endif
#if 0
    wprintf(L"\nV1 encrypted signature:\n");
    DumpHex(DH_NOTABPREFIX | DH_NOASCIIHEX | 4, abSig, cbSig);
#endif

    // Append signature goop to cert.

    CopyMemory(abSigSequence, abSigPrefix, sizeof(abSigPrefix));
    //CopyMemory(&abSigSequence[sizeof(abSigPrefix)], abSig, sizeof(abSig));
    for (i = 0; i < cbSig; i++)
    {
	abSigSequence[sizeof(abSigPrefix) + i] = abSig[cbSig - i - 1];
    }

    rgBlob[0].pbData = const_cast<BYTE *>(pbEncoded);
    rgBlob[0].cbData = cbEncoded;
    rgBlob[1].pbData = abSigSequence;
    rgBlob[1].cbData = sizeof(abSigSequence);
    Seq.cValue = ARRAYSIZE(rgBlob);
    Seq.rgValue = rgBlob;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    &Seq,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbSigned,
		    pcbSigned))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
#if 0
    wprintf(L"\nV1 Cert:\n");
    DumpHex(DH_NOTABPREFIX | DH_NOASCIIHEX | 4, *ppbSigned, *pcbSigned);
#endif
    hr = S_OK;

error:
    if (NULL != hKey)
    {
	CryptDestroyKey(hKey);
    }
    if (NULL != hHash)
    {
	CryptDestroyHash(hHash);
    }
#if 0
#else
    if (NULL != pbKey)
    {
        LocalFree(pbKey); 
    }
    if (NULL != hKeySig)
    {
	CryptDestroyKey(hKeySig);
    }
#endif
    return(hr);
}


HRESULT
epfEncodeCertAndSign(
    IN HCRYPTPROV hProvSigner,
    IN CERT_PUBLIC_KEY_INFO *pSubjectPublicKeyInfoSigner,
    IN CERT_INFO *pCert,
    IN char const *pszAlgId,
    OUT BYTE **ppbSigned,
    OUT DWORD *pcbSigned)
{
    HRESULT hr;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    
    *ppbSigned = NULL;
    if (!myEncodeToBeSigned(
		    X509_ASN_ENCODING,
		    pCert,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
        hr = myHLastError();
	_JumpError(hr, error, "myEncodeToBeSigned");
    }

    // Try to use the new rsaenc.dll to generate a Nortel-compliant signature.
    // The enrypted signature will not contain the algorithm OID or parameters.

    hr = mySignMD5HashOnly(
		    hProvSigner,
		    pszAlgId,
		    pbEncoded,
		    cbEncoded,
		    ppbSigned,
		    pcbSigned);
    _PrintIfError(hr, "mySignMD5HashOnly");
    if (S_OK == hr)
    {
	if (CryptVerifyCertificateSignature(
			    NULL,
			    X509_ASN_ENCODING,
			    *ppbSigned,
			    *pcbSigned,
			    pSubjectPublicKeyInfoSigner))
	{
	    wprintf(myLoadResourceString(IDS_CERT_SIG_OK)); // "Cert signature is valid"
	    wprintf(wszNewLine);
	}
	else
	{
	    hr = myHLastError();
	    _PrintError(hr, "CryptVerifyCertificateSignature");
	    LocalFree(*ppbSigned);
	    *ppbSigned = NULL;
	}
    }
    if (S_OK != hr && 1 < g_fForce)
    {
	// Must be running on an old rsaenh.dll that only supports PKCS1
	// signatures.  Just generate a standard PKCS1 signature.
	
	hr = myEncodeSignedContent(
			hProvSigner,
			X509_ASN_ENCODING,
			pszAlgId,
			pbEncoded,
			cbEncoded,
			CERTLIB_USE_LOCALALLOC,
			ppbSigned,
			pcbSigned);
	_JumpIfError(hr, error, "myEncodeSignedContent");
    }
    _JumpIfError(hr, error, "mySignMD5HashOnly");

error:
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    return(hr);
}


HRESULT
GenerateV1SerialNumber(
    IN HCRYPTPROV hProv,
    IN CRYPT_INTEGER_BLOB const *pSerialNumberOld,
    OUT DWORD *pdwV1SerialNumber)
{
    HRESULT hr;
    BYTE *pb;
    DWORD cb;

    pb = (BYTE *) pdwV1SerialNumber;
    cb = sizeof(*pdwV1SerialNumber);

    if (!CryptGenRandom(hProv, cb, pb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGenRandom");
    }

    pb += sizeof(*pdwV1SerialNumber) - 1;
    if (sizeof(*pdwV1SerialNumber) == pSerialNumberOld->cbData &&
	NULL != pSerialNumberOld->pbData)
    {
	*pb = pSerialNumberOld->pbData[pSerialNumberOld->cbData - 1];
    }

    // make sure the last byte is never zero

    if (0 == *pb)
    {
	*pb = 0x3a;
    }

    // Some clients can't handle negative serial numbers:

    *pb &= 0x7f;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
AddExtraByteToKey(
    IN OUT BYTE **ppbKey,
    IN OUT DWORD *pcbKey)
{
    HRESULT hr;
    BYTE *pbKey;

    pbKey = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbKey + 1);
    if (NULL == pbKey)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pbKey, *ppbKey, *pcbKey);
    pbKey[*pcbKey] = 0x01;
    (*pcbKey)++;
    LocalFree(*ppbKey);
    *ppbKey = pbKey;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
epfEncodeV1Cert(
    OPTIONAL IN HCRYPTPROV hProvSigner,
    OPTIONAL CERT_CONTEXT const *pccSigner,
    IN CRYPT_INTEGER_BLOB const *pSerialNumberOld,
    IN CERT_NAME_BLOB const *pIssuer,
    IN CERT_NAME_BLOB const *pSubject,
    OUT HCRYPTPROV *phProv,
    OUT CERT_CONTEXT const **ppCert)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKey = NULL;
    DWORD cbPubKey;
    BYTE *pbPubKeyNew = NULL;
    CERT_INFO Cert;
    //char *pszAlgId = szOID_RSA_MD5RSA;
    char *pszAlgId = szOID_OIWSEC_md5RSA;
    DWORD dwV1SerialNumber;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    SYSTEMTIME st;
    SYSTEMTIME st2;

    *phProv = NULL;
    *ppCert = NULL;

    hr = GenerateV1Keys(NULL == hProvSigner, &hProv);
    _JumpIfError(hr, error, "GenerateV1Keys");

    if (!myCryptExportPublicKeyInfo(
				hProv,
				AT_SIGNATURE,
				CERTLIB_USE_LOCALALLOC,
				&pPubKey,
				&cbPubKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }
#if 0
    wprintf(L"\nCERT_PUBLIC_KEY_INFO:\n");
    DumpHex(
	DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	(BYTE const *) pPubKey,
	cbPubKey);
    wprintf(L"\nBefore mySqueezePublicKey:\n");
    wprintf(L"cUnusedBits=%u\n", pPubKey->PublicKey.cUnusedBits);
    DumpHex(
	DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	pPubKey->PublicKey.pbData,
	pPubKey->PublicKey.cbData);
#endif

    hr = mySqueezePublicKey(
		    pPubKey->PublicKey.pbData,
		    pPubKey->PublicKey.cbData,
		    &pbPubKeyNew,
		    &pPubKey->PublicKey.cbData);
    _JumpIfError(hr, error, "mySqueezePublicKey");

    hr = AddExtraByteToKey(&pbPubKeyNew, &pPubKey->PublicKey.cbData);
    _JumpIfError(hr, error, "AddExtraByteToKey");

    pPubKey->PublicKey.pbData = pbPubKeyNew;
#if 0
    //wprintf(L"cUnusedBits=%u\n", pPubKey->PublicKey.cUnusedBits);
    wprintf(L"\nAfter mySqueezePublicKey:\n");
    DumpHex(
	DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	pPubKey->PublicKey.pbData,
	pPubKey->PublicKey.cbData);
#endif

    // CERT:

    ZeroMemory(&Cert, sizeof(Cert));
    Cert.dwVersion = CERT_V1;

    // Use a DWORD for the V1 serial number

    GenerateV1SerialNumber(hProv, pSerialNumberOld, &dwV1SerialNumber);
    Cert.SerialNumber.pbData = (BYTE *) &dwV1SerialNumber;
    Cert.SerialNumber.cbData = sizeof(dwV1SerialNumber);
    Cert.SignatureAlgorithm.pszObjId = pszAlgId;

    // ISSUER:

    Cert.Issuer = *pIssuer;			// Structure assignment

    // Start with an arbitrary constant date in the past 12 months.
    // Choose January 1st or June 1st: whichever will result in at least
    // several months remaining until we hit the date again.
    // From Feb 1st to June 30th, pick Jan 1st.
    // From July 1st to Jan 31st, pick Jun 1st.

    GetSystemTime(&st);
    ZeroMemory(&st2, sizeof(st2));
    st2.wYear = st.wYear;
    st2.wDay = 1;	// Jan or Jun 1st
    st2.wHour = 12;	// at Noon

    if (2 <= st.wMonth && 6 >= st.wMonth)
    {
	st2.wMonth = 1;		// January
    }
    else
    {
	st2.wMonth = 6;		// June
    }
    CSASSERT(st2.wMonth != st.wMonth);
    if (st2.wMonth > st.wMonth)
    {
	st2.wYear--;
    }
    if (!SystemTimeToFileTime(&st2, &Cert.NotBefore))
    {
	hr = myHLastError();
	_JumpError(hr, error, "SystemTimeToFileTime");
    }
    Cert.NotAfter = Cert.NotBefore;

    if (NULL == hProvSigner)
    {
	// Generate 20 year V1 root CA cert, centered over an arbitrary date
	// in the past 12 months.

	myMakeExprDateTime(&Cert.NotBefore, -10, ENUM_PERIOD_YEARS);
	myMakeExprDateTime(&Cert.NotAfter, +10, ENUM_PERIOD_YEARS);
    }
    else
    {
	// Generate 1 year V1 user cert, that expired at least a year ago

	myMakeExprDateTime(&Cert.NotBefore, -2, ENUM_PERIOD_YEARS);
	myMakeExprDateTime(&Cert.NotAfter, -1, ENUM_PERIOD_YEARS);
    }

    // SUBJECT:

    Cert.Subject = *pSubject;			// Structure assignment
    Cert.SubjectPublicKeyInfo = *pPubKey;	// Structure assignment

    hr = epfEncodeCertAndSign(
		    NULL != hProvSigner? hProvSigner : hProv,
		    NULL != pccSigner?
			&pccSigner->pCertInfo->SubjectPublicKeyInfo :
			&Cert.SubjectPublicKeyInfo,
		    &Cert,
		    pszAlgId,
		    &pbEncoded,
		    &cbEncoded);
    _JumpIfError(hr, error, "EncodeCertAndSign");

    CSASSERT(NULL != pbEncoded);
    *ppCert = CertCreateCertificateContext(
				    X509_ASN_ENCODING,
				    pbEncoded,
				    cbEncoded);
    if (NULL == *ppCert)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    *phProv = hProv;
    hProv = NULL;

error:
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    if (NULL != pPubKey)
    {
        LocalFree(pPubKey);
    }
    if (NULL != pbPubKeyNew)
    {
        LocalFree(pbPubKeyNew);
    }
    return(hr);
}


HRESULT
epfBuildV1Certs(
    IN CERT_CONTEXT const *pccUserV1,
    OUT CERT_CONTEXT const **ppccSigV1,
    OUT HCRYPTPROV *phProvSigV1,
    OUT CERT_CONTEXT const **ppccCAV1)
{
    HRESULT hr;
    CERT_CONTEXT const *pccCAV1 = NULL;
    CERT_CONTEXT const *pccSigV1 = NULL;
    HCRYPTPROV hProvCA = NULL;
    HCRYPTPROV hProvSig = NULL;

    *ppccSigV1 = NULL;
    *phProvSigV1 = NULL;
    *ppccCAV1 = NULL;

    hr = epfEncodeV1Cert(
		NULL,		// hProvSigner
		NULL,		// pccSigner
		&pccUserV1->pCertInfo->SerialNumber,
		&pccUserV1->pCertInfo->Issuer,
		&pccUserV1->pCertInfo->Issuer,
		&hProvCA,
		&pccCAV1);
    _JumpIfError(hr, error, "epfEncodeV1Cert");

    hr = epfEncodeV1Cert(
		hProvCA,
		pccCAV1,	// pccSigner
		&pccUserV1->pCertInfo->SerialNumber,
		&pccUserV1->pCertInfo->Issuer,
		&pccUserV1->pCertInfo->Subject,
		&hProvSig,
		&pccSigV1);
    _JumpIfError(hr, error, "epfEncodeV1Cert");

    CSASSERT(NULL != hProvSig);
    CSASSERT(NULL != pccSigV1);
    CSASSERT(NULL != pccCAV1);
    *phProvSigV1 = hProvSig;
    hProvSig = NULL;
    *ppccSigV1 = pccSigV1;
    pccSigV1 = NULL;
    *ppccCAV1 = pccCAV1;
    pccCAV1 = NULL;

error:
    if (NULL != hProvCA)
    {
	CryptReleaseContext(hProvCA, 0);
    }
    if (NULL != hProvSig)
    {
	CryptReleaseContext(hProvSig, 0);
    }
    if (NULL != pccCAV1)
    {
	CertFreeCertificateContext(pccCAV1);
    }
    if (NULL != pccSigV1)
    {
	CertFreeCertificateContext(pccSigV1);
    }
    return(hr);
}


WCHAR const *
epfLoadResource(
    IN UINT ids,
    IN WCHAR const *pwszStatic)
{
    WCHAR const *pwsz = myLoadResourceString(ids);

    if (NULL == pwsz)
    {
	pwsz = pwszStatic;
    }
    return(pwsz);
}


HRESULT
cuInfDumpProtectedStoreValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN WCHAR const *pwszSectionAndKey,
    IN BOOL fDump,
    OPTIONAL IN EPF_SYM_KEY_STRUCT const *psKey,
    IN HRESULT hrQuiet)
{
    HRESULT hr;
    BYTE *pbStore = NULL;
    DWORD cbStore;

    if (NULL == psKey)
    {
	hr = cuInfDumpValue(
			hInf,
			pwszSection,
			pwszKey,
			1,		// Index
			TRUE,		// fLastValue
			hrQuiet,
			&pbStore,
			&cbStore);
	_PrintIfErrorStr(hr, "cuInfDumpValue", pwszSectionAndKey);
    }
    else
    {
	hr = cuInfDumpProtectedValue(
			    hInf,
			    pwszSection,
			    pwszKey,
			    psKey,
			    hrQuiet,
			    &pbStore,
			    &cbStore);
	_PrintIfErrorStr(hr, "cuInfDumpProtectedValue", pwszSectionAndKey);
    }

    wprintf(wszNewLine);
    if (fDump)
    {
	wprintf(s_wszHeader);
	wprintf(L"[%ws] ", pwszSection);
    }
    wprintf(L"%ws:\n", pwszKey);

    if (NULL != pbStore)
    {
	if (1 < g_fVerbose)
	{
	    DumpHex(DH_NOTABPREFIX | 4, pbStore, cbStore);
	}
	DumpHex(
	    DH_NOTABPREFIX | 4,
	    pbStore,
	    cbStore);
	hr = DumpSerializedCertStore(pbStore, cbStore);
	_JumpIfError(hr, error, "DumpSerializedCertStore");
    }
    hr = S_OK;

error:
    if (NULL != pbStore)
    {
	LocalFree(pbStore);
    }
    return(hr);
}


HRESULT
cuDumpAsnAlgorithm(
    IN BYTE const *pbIn,
    IN DWORD cbIn)
{
    HRESULT hr;
    CRYPT_SEQUENCE_OF_ANY *pSeqAlg = NULL;
    char *pszObjId = NULL;
    DWORD cb;
    CRYPT_ALGORITHM_IDENTIFIER Alg;

    hr = cuDecodeSequence(pbIn, cbIn, 2, &pSeqAlg);
    _JumpIfError(hr, error, "cuDecodeSequence");

    hr = cuDecodeObjId(
		pSeqAlg->rgValue[0].pbData,
		pSeqAlg->rgValue[0].cbData,
		&pszObjId);
    _JumpIfError(hr, error, "cuDecodeObjId");

    Alg.pszObjId = pszObjId;
    Alg.Parameters = pSeqAlg->rgValue[1];
    cuDumpAlgorithm(IDS_SIGNATURE_ALGORITHM, &Alg);

error:
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    if (NULL != pSeqAlg)
    {
	LocalFree(pSeqAlg);
    }
    return(hr);
}


HRESULT
cuDumpAsnTime(
    IN BYTE const *pbIn,
    IN DWORD cbIn)
{
    HRESULT hr;
    FILETIME ft;
    DWORD cb;

    cb = sizeof(FILETIME);
    if (!CryptDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CHOICE_OF_TIME,
		    pbIn,
		    cbIn,
		    0,
		    &ft,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptDecodeObject");
    }
    hr = cuDumpFileTime(0, NULL, &ft);
    _JumpIfError(hr, error, "cuDumpFileTime");

error:
    return(hr);
}


HRESULT
epfDumpCRLValue(
    IN BYTE const *pbIn,
    IN DWORD cbIn)
{
    HRESULT hr;
    CRYPT_SEQUENCE_OF_ANY *pSeqOuter = NULL;
    CRYPT_SEQUENCE_OF_ANY *pSeqInner = NULL;
    CRYPT_SEQUENCE_OF_ANY *pSeq04 = NULL;
    CRYPT_SEQUENCE_OF_ANY *pSeq040 = NULL;
    CERT_SIGNED_CONTENT_INFO *pcsci = NULL;
    DWORD cb;
    DWORD dwVersion;

    if (SZARRAYSIZE(szPROPASNTAG) < cbIn &&
	0 == _strnicmp(
		    (char const *) pbIn,
		    szPROPASNTAG,
		    SZARRAYSIZE(szPROPASNTAG)))
    {
	pbIn += SZARRAYSIZE(szPROPASNTAG);
	cbIn -= SZARRAYSIZE(szPROPASNTAG);
    }
    if (1 < g_fVerbose)
    {
	DumpHex(DH_MULTIADDRESS | DH_NOTABPREFIX | 4, pbIn, cbIn);
    }

    // 3 SEQUENCES

    hr = cuDecodeSequence(pbIn, cbIn, 3, &pSeqOuter);
    _JumpIfError(hr, error, "cuDecodeSequence");

    // Sequence 0:
    // SEQUENCE { 5 SEQUENCES }

    hr = cuDecodeSequence(
		pSeqOuter->rgValue[0].pbData,
		pSeqOuter->rgValue[0].cbData,
		5,
		&pSeqInner);
    _JumpIfError(hr, error, "cuDecodeSequence");

    // Sequence 0.0:
    // NAME

    hr = cuDisplayCertName(
			TRUE,
			g_wszEmpty,
			myLoadResourceString(IDS_ISSUER), // "Issuer"
			g_wszPad4,
			&pSeqInner->rgValue[0],
			NULL);
    _JumpIfError(hr, error, "cuDisplayCertName(Subject)");

    // Sequence 0.1:
    // DATE

    cuDumpAsnTime(
	pSeqInner->rgValue[1].pbData,
	pSeqInner->rgValue[1].cbData);

    // Sequence 0.2:
    // DATE

    cuDumpAsnTime(
	pSeqInner->rgValue[2].pbData,
	pSeqInner->rgValue[2].cbData);

    // Sequence 0.3:
    // SEQUENCE { OID, NULL }

    cuDumpAsnAlgorithm(
	pSeqInner->rgValue[3].pbData,
	pSeqInner->rgValue[3].cbData);

    // Sequence 0.4:
    // SEQUENCE { SEQUENCE { INTEGER, DATE } }

    hr = cuDecodeSequence(
		pSeqInner->rgValue[4].pbData,
		pSeqInner->rgValue[4].cbData,
		1,
		&pSeq04);
    _JumpIfError(hr, error, "cuDecodeSequence");

    // Sequence 0.4.0:
    // SEQUENCE { INTEGER, DATE }

    hr = cuDecodeSequence(
		pSeq04->rgValue[0].pbData,
		pSeq04->rgValue[0].cbData,
		2,
		&pSeq040);
    _JumpIfError(hr, error, "cuDecodeSequence");

    // Sequence 0.4.0.0.0:
    // INTEGER

    cb = sizeof(dwVersion);
    if (!CryptDecodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    pSeq040->rgValue[0].pbData,
		    pSeq040->rgValue[0].cbData,
		    0,
		    &dwVersion,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptDecodeObject");
    }
    cuDumpVersion(dwVersion + 1);

    // Sequence 0.4.0.0.1:
    // DATE

    cuDumpAsnTime(
	pSeqInner->rgValue[2].pbData,
	pSeqInner->rgValue[2].cbData);

    // Sequence 1:
    // SEQUENCE { OID, NULL } (part of signature)
    // cuDumpAsnAlgorithm(
	// pSeqOuter->rgValue[1].pbData,
	// pSeqOuter->rgValue[1].cbData);

    // Sequence 2:
    // BITSTRING (part of signature)
    // pSeqOuter->rgValue[2].pbData
    // pSeqOuter->rgValue[2].cbData

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcsci,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    cuDumpSignature(pcsci);
    hr = S_OK;

error:
    if (NULL != pcsci)
    {
	LocalFree(pcsci);
    }
    if (NULL != pSeq04)
    {
	LocalFree(pSeq04);
    }
    if (NULL != pSeq040)
    {
	LocalFree(pSeq040);
    }
    if (NULL != pSeqInner)
    {
	LocalFree(pSeqInner);
    }
    if (NULL != pSeqOuter)
    {
	LocalFree(pSeqOuter);
    }
    return(hr);
}


HRESULT
cuInfDumpCRLValue(
    IN HINF hInf)
{
    HRESULT hr;
    BYTE *pbCRL0 = NULL;
    DWORD cbCRL0;
    BYTE *pbCRL1 = NULL;
    DWORD cbCRL1;
    BYTE *pbCRL = NULL;

    wprintf(wszNewLine);
    wprintf(
	L"[%ws] %ws\n",
	wszINFSECTION_REVOKATIONINFORMATION,
	wszINFKEY_CRL);

    hr = cuInfDumpValue(
		    hInf,
		    wszINFSECTION_REVOKATIONINFORMATION,
		    wszINFKEY_CRL,
		    1,
		    TRUE,
		    S_OK,
		    &pbCRL0,
		    &cbCRL0);
    _JumpIfErrorStr(hr, error, "cuInfDumpValue", wszINFKEY_CRL);

    wprintf(
	L"[%ws] %ws\n",
	wszINFSECTION_REVOKATIONINFORMATION,
	wszINFKEY_CRL1);

    hr = cuInfDumpValue(
		    hInf,
		    wszINFSECTION_REVOKATIONINFORMATION,
		    wszINFKEY_CRL1,
		    1,
		    TRUE,
		    S_OK,
		    &pbCRL1,
		    &cbCRL1);
    _JumpIfErrorStr(hr, error, "cuInfDumpValue", wszINFKEY_CRL1);

    pbCRL = (BYTE *) LocalAlloc(LMEM_FIXED, cbCRL0 + cbCRL1);
    if (NULL == pbCRL)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pbCRL, pbCRL0, cbCRL0);
    CopyMemory(&pbCRL[cbCRL0], pbCRL1, cbCRL1);

    hr = epfDumpCRLValue(pbCRL, cbCRL0 + cbCRL1);
    _JumpIfError(hr, error, "epfDumpCRLValue");

error:
    if (NULL != pbCRL0)
    {
	LocalFree(pbCRL0);
    }
    if (NULL != pbCRL1)
    {
	LocalFree(pbCRL1);
    }
    if (NULL != pbCRL)
    {
	LocalFree(pbCRL);
    }
    return(hr);
}


HRESULT
EPFFileDump(
    IN WCHAR const *pwszFileName,
    OPTIONAL IN WCHAR const *pwszPassword,
    OPTIONAL IN OUT HCERTSTORE hStore)
{
    HRESULT hr;
    HRESULT hrQuiet;
    WCHAR *pwszTempFile = NULL;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;
    WCHAR wszPassword[MAX_PATH];
    WCHAR *pwszSaltValue = NULL;
    BYTE *pbToken = NULL;
    DWORD cbToken;
    DWORD dw;
    DWORD dwVersion;
    DWORD dwKeyCountV2;
    DWORD dwKeyCount;
    DWORD dwHashCount;
    DWORD iKey;
    BOOL fDump = g_fVerbose || NULL == hStore;
    HCRYPTPROV hProv = NULL;
    EPF_SYM_KEY_STRUCT sKey;
    BYTE *pbCertV1Signing = NULL;
    DWORD cbCertV1Signing;
    BYTE *pbKeyV1Signing = NULL;
    DWORD cbKeyV1Signing;
    BYTE *pbKeyV1Exchange = NULL;
    DWORD cbKeyV1Exchange;
    BYTE *pbCertUser = NULL;
    DWORD cbCertUser;
    BYTE *pbCertCA = NULL;
    DWORD cbCertCA;
    BYTE *pbCertManager = NULL;
    DWORD cbCertManager;
    BYTE *pbCertV1Exchange = NULL;
    DWORD cbCertV1Exchange;
    BYTE *pbCertSigning = NULL;
    DWORD cbCertSigning;
    BYTE *pbKeySigning = NULL;
    DWORD cbKeySigning;
    BYTE *pbCertHistory = NULL;
    DWORD cbCertHistory;
    BYTE *pbrgKeyPrivate = NULL;
    DWORD cbrgKeyPrivate;
    BYTE *pbCertTrustList = NULL;
    DWORD cbCertTrustList;
    BYTE *pbSaltValue = NULL;
    DWORD cbSaltValue;
    DWORD dwEPFAlg;
    DWORD dwSymKeyLen;
    BOOL f40bit;
    WCHAR *pwszFriendlyName = NULL;
    BOOL fQuietOld = g_fQuiet;

    ZeroMemory(&sKey, sizeof(sKey));
    hrQuiet = S_OK;

    hr = cuPatchEPFFile(pwszFileName, &pwszTempFile);
    _JumpIfError2(hr, error, "cuPatchEPFFile", S_FALSE);

    hr = cuGetPassword(
		    0,			// idsPrompt
		    NULL,		// pwszfn
		    pwszPassword,
		    FALSE,		// fVerify
		    wszPassword,
		    ARRAYSIZE(wszPassword),
		    &pwszPassword);
    _JumpIfError(hr, error, "cuGetPassword");

    hr = myInfOpenFile(pwszTempFile, &hInf, &ErrorLine);
    _JumpIfError(hr, error, "myInfOpenFile");

    if (!CryptAcquireContext(
		    &hProv,
		    NULL,	// container name
		    MS_STRONG_PROV,
		    PROV_RSA_FULL,
		    CRYPT_VERIFYCONTEXT))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }

    //================================================================
    // wszINFSECTION_USERX500NAME:

    hr = cuInfDumpDNKeyValue(
			hInf,
			wszINFSECTION_USERX500NAME,
			wszINFKEY_X500NAME,
			fDump);
    _JumpIfError(hr, error, "cuInfDumpDNKeyValue");

    //================================================================
    // wszINFSECTION_PASSWORDTOKEN:

    hr = cuInfDumpNumericKeyValue(
			hInf,
			wszINFSECTION_PASSWORDTOKEN,
			wszINFKEY_PROTECTION,
			1,	// Index
			TRUE, 	// fLastValue
			fDump,
			hrQuiet,
			&dwSymKeyLen);
    _JumpIfError(hr, error, "cuInfDumpNumericKeyValue");

    hr = cuInfDumpNumericKeyValue(
			hInf,
			wszINFSECTION_PASSWORDTOKEN,
			wszINFKEY_PROFILEVERSION,
			1,	// Index
			TRUE, 	// fLastValue
			fDump,
			hrQuiet,
			&dwVersion);
    _JumpIfError(hr, error, "cuInfDumpNumericKeyValue");

    f40bit = FALSE;
    switch (dwVersion)
    {
	case 2:
	    dwEPFAlg = EPFALG_CAST_MD5;
	    if (40 == dwSymKeyLen)
	    {
		f40bit = TRUE;
	    }
	    else if (64 == dwSymKeyLen)
	    {
	    }
	    else
	    {
		wprintf(
		    L"%ws %ws=40 | %ws=64!\n",
		    myLoadResourceString(IDS_EXPECTED), // "Expected"
		    wszINFKEY_PROTECTION,
		    wszINFKEY_PROTECTION);
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "cuInfDumpNumericKeyValue");
	    }
	    break;

	case 3:
	    dwEPFAlg = EPFALG_RC2_SHA;
	    if (128 != dwSymKeyLen)
	    {
		wprintf(
		    L"%ws %ws=128!\n",
		    myLoadResourceString(IDS_EXPECTED), // "Expected"
		    wszINFKEY_PROTECTION);
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "cuInfDumpNumericKeyValue");
	    }
	    hr = cuInfDumpNumericKeyValue(
				hInf,
				wszINFSECTION_PASSWORDTOKEN,
				wszINFKEY_HASHCOUNT,
				1,	// Index
				TRUE, 	// fLastValue
				fDump,
				ERROR_LINE_NOT_FOUND,	// hrQuiet
				&dwHashCount);
	    _PrintIfError2(hr, "cuInfDumpNumericKeyValue", hr);
	    if (S_OK == hr)
	    {
		dwEPFAlg = EPFALG_3DES;
	    }
	    break;

	default:
	    wprintf(
		L"%ws %ws=2 | %ws=3!\n",
		myLoadResourceString(IDS_EXPECTED), // "Expected"
		wszINFKEY_PROFILEVERSION,
		wszINFKEY_PROFILEVERSION);
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "cuInfDumpNumericKeyValue");
    }

    if (EPFALG_CAST_MD5 == dwEPFAlg)
    {
        hr = cuInfDumpNumericKeyValue(
			hInf,
			wszINFSECTION_PASSWORDTOKEN,
			wszINFKEY_CAST,
			1,	// Index
			TRUE, 	// fLastValue
			fDump,
			hrQuiet,
			&dw);
	_JumpIfError(hr, error, "cuInfDumpNumericKeyValue");

        if (3 != dw)
        {
            wprintf(
		L"%ws CAST=3!\n",
		myLoadResourceString(IDS_EXPECTED)); // "Expected"
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            _JumpError(hr, error, "cuInfDumpNumericKeyValue");
        }
    }

    hr = cuInfDumpHexKeyValue(
			hInf,
			wszINFSECTION_PASSWORDTOKEN,
			wszINFKEY_TOKEN,
			fDump,
			&pbToken,
			&cbToken);
    _JumpIfError(hr, error, "cuInfDumpHexKeyValue");

    hr = cuInfDumpStringKeyValue(
			hInf,
			wszINFSECTION_PASSWORDTOKEN,
			wszINFKEY_SALTVALUE,
			fDump,
			hrQuiet,
			&pwszSaltValue);
    _JumpIfError(hr, error, "cuInfDumpStringKeyValue");

    hr = cuInfDumpNumericKeyValue(
			hInf,
			wszINFSECTION_PASSWORDTOKEN,
			wszINFKEY_HASHSIZE,
			1,	// Index
			TRUE, 	// fLastValue
			fDump,
			hrQuiet,
			&dw);
    _PrintIfError(hr, "cuInfDumpNumericKeyValue");

    //================================================================
    // Now we have password, SALT & token -- derive & verify proper type key.
    // In most cases, cbHashSize is ZERO.  Should pull from inf above, though.
    
    pbSaltValue = NULL;
    cbSaltValue = 0;

    hr = EPFDeriveKey(
		dwEPFAlg,
		dwSymKeyLen,
		hProv,
		pwszPassword,
		pwszSaltValue,
		pbSaltValue,
		cbSaltValue,
		0,		// cbHashSize
		&sKey);
    _JumpIfError(hr, error, "EPFDeriveKey");

    // check pwd via token

    hr = EPFVerifyKeyToken(&sKey, pbToken, cbToken);
    if (S_OK != hr)
    {
	_PrintError(hr, "EPFVerifyKeyToken");
	if (2 > g_fForce || EPFALG_3DES != dwEPFAlg)
	{
	    goto error;
	}
    }

    //================================================================
    // password looks good.  Decrypt the EPF file data.

    if (!g_fVerbose && !fDump)
    {
	g_fQuiet = TRUE;
    }
    InitCrcTable();

    if (2 == dwVersion || EPFALG_3DES == dwEPFAlg)
    {
	DWORD dwKeyAlgId;
	WCHAR const *pwszCertSection;

	//================================================================
	// wszINFSECTION_DIGITALSIGNATURE:

	hr = cuInfDumpProtectedValue(
			    hInf,
			    wszINFSECTION_DIGITALSIGNATURE,
			    wszINFKEY_CERTIFICATE,
			    &sKey,
			    ERROR_LINE_NOT_FOUND,	// hrQuiet
			    &pbCertV1Signing,
			    &cbCertV1Signing);
	_PrintIfErrorStr(
		    hr,
		    "cuInfDumpProtectedValue",
		    wszSECTION_KEY(
			dwEPFAlg,
			wszINFSECTION_DIGITALSIGNATURE,
			wszINFKEY_CERTIFICATE));

	wprintf(wszNewLine);
	if (fDump)
	{
	    wprintf(s_wszHeader);
	    wprintf(L"[%ws] ", wszINFSECTION_DIGITALSIGNATURE);
	}
	wprintf(L"%ws:\n", wszINFKEY_CERTIFICATE);

	if (NULL != pbCertV1Signing)
	{
	    ExtraAsnBytes(pbCertV1Signing, cbCertV1Signing);
	    hr = cuDumpAsnBinary(pbCertV1Signing, cbCertV1Signing, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");

	    wprintf(wszNewLine);
	}

	hr = cuInfDumpProtectedValue(
			hInf,
			wszINFSECTION_DIGITALSIGNATURE,
			wszINFKEY_KEY,
			&sKey,
			NULL == pbCertV1Signing? ERROR_LINE_NOT_FOUND : S_OK,
			&pbKeyV1Signing,
			&cbKeyV1Signing);
	_PrintIfErrorStr(
		hr,
		"cuInfDumpProtectedValue",
		wszSECTION_KEY(
			dwEPFAlg,
			wszINFSECTION_DIGITALSIGNATURE,
			wszINFKEY_KEY));

	if (fDump)
	{
	    wprintf(
		L"[%ws] %ws:\n",
		wszINFSECTION_DIGITALSIGNATURE,
		wszINFKEY_KEY);
	}
	// DumpHex(DH_NOTABPREFIX | DH_PRIVATEDATA | 4, pbKeyV1Signing, cbKeyV1Signing);

	if (NULL != pbCertV1Signing && NULL != pbKeyV1Signing)
	{
	    hr = VerifyAndSaveOneCertAndKey(
				hStore,
				fDump,
				epfLoadResource(IDS_SIGNING, wszSIGNING),
				pbCertV1Signing,
				cbCertV1Signing,
				pbKeyV1Signing,
				cbKeyV1Signing,
				CALG_RSA_SIGN,
				AT_SIGNATURE);
	    _JumpIfError(hr, error, "VerifyAndSaveOneCertAndKey");
	}

	//================================================================
	// wszINFSECTION_PRIVATEKEYS:

	hr = cuInfDumpNumericKeyValue(
			    hInf,
			    wszINFSECTION_PRIVATEKEYS,
			    wszINFKEY_KEYCOUNT,
			    1,		// Index
			    TRUE, 	// fLastValue
			    fDump,
			    hrQuiet,
			    &dwKeyCountV2);
	_JumpIfError(hr, error, "cuInfDumpNumericKeyValue");

	pwszCertSection  = f40bit? wszINFSECTION_USERCERTIFICATE :
			    (2 == dwVersion?
				wszINFSECTION_FULLCERTIFICATEHISTORY :
				wszINFSECTION_CERTIFICATEHISTORY);
	for (iKey = 0; iKey < dwKeyCountV2; iKey++)
	{
	    WCHAR wszKey[cwcINFKEY_KEY_FORMATTED];
	    WCHAR wszName[cwcINFKEY_NAME_FORMATTED];
	    DWORD dwSerial;
	    WCHAR const *pwszCertKey;

	    pwszCertKey = f40bit? wszINFKEY_CERTIFICATE : wszName;
	    if (NULL != pbCertV1Exchange)
	    {
		LocalFree(pbCertV1Exchange);
		pbCertV1Exchange = NULL;
	    }
	    if (NULL != pbKeyV1Exchange)
	    {
		LocalFree(pbKeyV1Exchange);
		pbKeyV1Exchange = NULL;
	    }

	    // wszINFSECTION_FULLCERTIFICATEHISTORY (cast) or
	    // wszINFSECTION_CERTIFICATEHISTORY (3des)

	    wsprintf(wszName, wszINFKEY_NAME_FORMAT, iKey + 1);
	    hr = cuInfDumpProtectedValue(
				hInf,
				pwszCertSection,
				pwszCertKey,
				&sKey,
				hrQuiet,
				&pbCertV1Exchange,
				&cbCertV1Exchange);
	    _JumpIfError(hr, error, "cuInfDumpProtectedValue");

	    wprintf(wszNewLine);
	    if (fDump)
	    {
		wprintf(s_wszHeader);
	    }
	    wprintf(
		L"[%ws] %ws:\n",
		pwszCertSection,
		pwszCertKey);

	    ExtraAsnBytes(pbCertV1Exchange, cbCertV1Exchange);
	    hr = cuDumpAsnBinary(
			    pbCertV1Exchange,
			    cbCertV1Exchange,
			    MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");

	    wsprintf(wszKey, wszINFKEY_KEY_FORMAT, iKey + 1);
	    hr = cuInfDumpProtectedValue(
				hInf,
				wszINFSECTION_PRIVATEKEYS,
				wszKey,
				&sKey,
				hrQuiet,
				&pbKeyV1Exchange,
				&cbKeyV1Exchange);
	    _JumpIfError(hr, error, "cuInfDumpProtectedValue");

	    wprintf(wszNewLine);
	    if (fDump)
	    {
		wprintf(L"[%ws] %ws:\n", wszINFSECTION_PRIVATEKEYS, wszKey);
	    }
	    if (g_fVerbose)
	    {
		DumpHex(DH_NOTABPREFIX | DH_PRIVATEDATA | 4, pbKeyV1Exchange, cbKeyV1Exchange);
	    }
	    hr = VerifyAndSaveOneCertAndKey(
				hStore,
				fDump,
				epfLoadResource(IDS_EXCHANGE, wszEXCHANGE),
				pbCertV1Exchange,
				cbCertV1Exchange,
				pbKeyV1Exchange,
				cbKeyV1Exchange,
				CALG_RSA_KEYX,
				AT_KEYEXCHANGE);
	    _JumpIfError(hr, error, "VerifyAndSaveOneCertAndKey");

	    //================================================================
	    // wszINFSECTION_CERTIFICATEHISTORY:

	    wsprintf(wszName, wszINFKEY_NAME_FORMAT, iKey + 1);

	    hr = cuInfDumpBinaryNameKeyValue(
				hInf,
				wszINFSECTION_CERTIFICATEHISTORY,
				wszName,
				1,	// Index
				FALSE, 	// fLastValue
				fDump,
				hrQuiet);
	    _JumpIfError(hr, error, "cuInfDumpBinaryNameKeyValue");

	    hr = cuInfDumpNumericKeyValue(
				hInf,
				wszINFSECTION_CERTIFICATEHISTORY,
				wszName,
				2,	// Index
				TRUE, 	// fLastValue
				fDump,
				hrQuiet,
				&dwSerial);
	    _JumpIfError(hr, error, "cuInfDumpNumericKeyValue");
	}

	//================================================================
	// wszINFSECTION_USERCERTIFICATE:

	if (!f40bit)
	{
	    hr = cuInfDumpProtectedValue(
				hInf,
				wszINFSECTION_USERCERTIFICATE,
				wszINFKEY_CERTIFICATE,
				&sKey,
				hrQuiet,
				&pbCertUser,
				&cbCertUser);
	    _JumpIfError(hr, error, "cuInfDumpProtectedValue");

	    wprintf(wszNewLine);
	    if (fDump)
	    {
		wprintf(s_wszHeader);
	    }
	    wprintf(
		L"[%ws] %ws:\n",
		wszINFSECTION_USERCERTIFICATE,
		wszINFKEY_CERTIFICATE);

	    ExtraAsnBytes(pbCertUser, cbCertUser);
	    hr = cuDumpAsnBinary(pbCertUser, cbCertUser, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");
	}

	//================================================================
	// wszINFSECTION_CA:

	hr = cuInfDumpProtectedValue(
			    hInf,
			    wszINFSECTION_CA,
			    wszINFKEY_CERTIFICATE,
			    &sKey,
			    hrQuiet,
			    &pbCertCA,
			    &cbCertCA);
	_JumpIfError(hr, error, "cuInfDumpProtectedValue");

	wprintf(wszNewLine);
	if (fDump)
	{
	    wprintf(s_wszHeader);
	}
	wprintf(
	    L"[%ws] %ws:\n",
	    wszINFSECTION_CA,
	    wszINFKEY_CERTIFICATE);

	ExtraAsnBytes(pbCertCA, cbCertCA);
	hr = cuDumpAsnBinary(pbCertCA, cbCertCA, MAXDWORD);
	_JumpIfError(hr, error, "cuDumpAsnBinary");

	hr = AddCACertToStore(pbCertCA, cbCertCA);
	_PrintIfError(hr, "AddCACertToStore");

	//================================================================
	// wszINFSECTION_MANAGER:

	if (f40bit)
	{
	    hr = cuInfDumpProtectedValue(
				hInf,
				wszINFSECTION_MANAGER,
				wszINFKEY_CERTIFICATE,
				&sKey,
				hrQuiet,
				&pbCertManager,
				&cbCertManager);
	    _JumpIfError(hr, error, "cuInfDumpProtectedValue");

	    wprintf(wszNewLine);
	    if (fDump)
	    {
		wprintf(s_wszHeader);
	    }
	    wprintf(
		L"[%ws] %ws:\n",
		wszINFSECTION_MANAGER,
		wszINFKEY_CERTIFICATE);

	    ExtraAsnBytes(pbCertManager, cbCertManager);
	    hr = cuDumpAsnBinary(pbCertManager, cbCertManager, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");

	    hr = AddCACertToStore(pbCertManager, cbCertManager);
	    _PrintIfError(hr, "AddCACertToStore");
	}

	//================================================================
	// wszINFSECTION_MICROSOFTEXCHANGE:

	hr = cuInfDumpProtectedStringValue(
			    hInf,
			    wszINFSECTION_MICROSOFTEXCHANGE,
			    wszINFKEY_FRIENDLYNAME,
			    &sKey,
			    fDump,
			    hrQuiet,
			    &pwszFriendlyName);
	_JumpIfError(hr, error, "cuInfDumpProtectedStringValue");

	wprintf(
	    L"[%ws] %ws = %ws\n",
	    wszINFSECTION_MICROSOFTEXCHANGE,
	    wszINFKEY_FRIENDLYNAME,
	    pwszFriendlyName);

	hr = cuInfDumpProtectedDwordValue(
			    hInf,
			    wszINFSECTION_MICROSOFTEXCHANGE,
			    wszINFKEY_KEYALGID,
			    &sKey,
			    fDump,
			    hrQuiet,
			    &dwKeyAlgId);
	_JumpIfError(hr, error, "cuInfDumpProtectedDwordValue");

	wprintf(
	    L"[%ws] %ws = 0x%x\n",
	    wszINFSECTION_MICROSOFTEXCHANGE,
	    wszINFKEY_KEYALGID,
	    dwKeyAlgId);
    }
    if (f40bit)
    {
	if (fDump)
	{
	    hr = cuInfDumpCRLValue(hInf);
	    _PrintIfError(hr, "cuInfDumpCRLValue");
	}
    }
    else
    {
	//================================================================
	// wszINFSECTION_SMIME:

	hr = cuInfDumpNumericKeyValue(
			    hInf,
			    wszINFSECTION_SMIME,
			    wszINFKEY_KEYCOUNT,
			    1,			// Index
			    TRUE, 			// fLastValue
			    fDump,
			    ERROR_LINE_NOT_FOUND,	// hrQuiet
			    &dwKeyCount);
	if (S_OK != hr)
	{
	    dwKeyCount = 0;
	    hrQuiet = ERROR_LINE_NOT_FOUND;
	    _PrintErrorStr(
		    hr,
		    "cuInfDumpProtectedValue",
		    wszSECTION_KEY(
			    dwEPFAlg,
			    wszINFSECTION_SMIME,
			    wszINFKEY_KEYCOUNT));
	}
	hr = cuInfDumpProtectedValue(
			    hInf,
			    wszINFSECTION_SMIME,
			    wszINFKEY_SIGNINGCERTIFICATE,
			    &sKey,
			    ERROR_LINE_NOT_FOUND,	// hrQuiet
			    &pbCertSigning,
			    &cbCertSigning);
	_PrintIfErrorStr(
		hr,
		"cuInfDumpProtectedValue",
		wszSECTION_KEY(
			dwEPFAlg,
			wszINFSECTION_SMIME,
			wszINFKEY_SIGNINGCERTIFICATE));

	wprintf(wszNewLine);
	if (fDump)
	{
	    wprintf(s_wszHeader);
	    wprintf(L"[%ws] ", wszINFSECTION_SMIME);
	}
	wprintf(L"%ws:\n", wszINFKEY_SIGNINGCERTIFICATE);

	if (NULL != pbCertSigning)
	{
	    ExtraAsnBytes(pbCertSigning, cbCertSigning);
	    hr = cuDumpAsnBinary(pbCertSigning, cbCertSigning, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");

	    hr = cuInfDumpProtectedValue(
				hInf,
				wszINFSECTION_SMIME,
				wszINFKEY_SIGNINGKEY,
				&sKey,
				hrQuiet,
				&pbKeySigning,
				&cbKeySigning);
	    _JumpIfError(hr, error, "cuInfDumpProtectedValue");

	    if (fDump)
	    {
		wprintf(L"[%ws] %ws:\n", wszINFSECTION_SMIME, wszINFKEY_SIGNINGKEY);
	    }
	    hr = VerifyAndSaveCertAndKey(
			    hStore,
			    fDump,
			    epfLoadResource(IDS_SIGNING, wszSIGNING),
			    pbCertSigning,
			    cbCertSigning,
			    pbKeySigning,
			    cbKeySigning,
			    1,		// cKey
			    CALG_RSA_SIGN,
			    AT_SIGNATURE);
	    if (S_OK != hr)
	    {
		_PrintErrorStr(
			hr,
			"VerifyAndSaveCertAndKey",
			wszSECTION_KEY(
				dwEPFAlg,
				wszINFSECTION_SMIME,
				wszINFKEY_SIGNINGKEY));
		if (NULL != hStore)
		{
		    goto error;
		}
	    }
	}

	if (fDump)
	{
	    wprintf(L"[%ws] %ws:\n", wszINFSECTION_SMIME, wszINFKEY_PRIVATEKEYS);
	}
	hr = cuInfDumpProtectedValue(
			    hInf,
			    wszINFSECTION_SMIME,
			    wszINFKEY_PRIVATEKEYS,
			    &sKey,
			    hrQuiet,
			    &pbrgKeyPrivate,
			    &cbrgKeyPrivate);
	if (0 != dwKeyCount)
	{
	    _JumpIfError(hr, error, "cuInfDumpProtectedValue");
	}

	//================================================================
	// wszINFSECTION_FULLCERTIFICATEHISTORY:

	for (iKey = 0; iKey < dwKeyCount; iKey++)
	{
	    WCHAR wszSMIME[cwcINFKEY_SMIME_FORMATTED];

	    wsprintf(wszSMIME, wszINFKEY_SMIME_FORMAT, iKey + 1);
	    hr = cuInfDumpProtectedValue(
				hInf,
				wszINFSECTION_FULLCERTIFICATEHISTORY,
				wszSMIME,
				&sKey,
				hrQuiet,
				&pbCertHistory,
				&cbCertHistory);
	    _JumpIfError(hr, error, "cuInfDumpProtectedValue");

	    wprintf(wszNewLine);
	    if (fDump)
	    {
		wprintf(s_wszHeader);
	    }
	    wprintf(
		L"[%ws] %ws:\n",
		wszINFSECTION_FULLCERTIFICATEHISTORY,
		wszSMIME);

	    ExtraAsnBytes(pbCertHistory, cbCertHistory);
	    hr = cuDumpAsnBinary(pbCertHistory, cbCertHistory, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");

	    hr = VerifyAndSaveCertAndKey(
			    hStore,
			    fDump,
			    epfLoadResource(IDS_EXCHANGE, wszEXCHANGE),
			    pbCertHistory,
			    cbCertHistory,
			    pbrgKeyPrivate,
			    cbrgKeyPrivate,
			    dwKeyCount,
			    CALG_RSA_KEYX,
			    AT_KEYEXCHANGE);
	    if (S_OK != hr)
	    {
		_PrintErrorStr(
		    hr,
		    "VerifyAndSaveCertAndKey",
		    wszSECTION_KEY(
			    dwEPFAlg,
			    wszINFSECTION_SMIME,
			    wszINFKEY_PRIVATEKEYS));
		if (NULL != hStore)
		{
		    goto error;
		}
	    }
	    LocalFree(pbCertHistory);
	    pbCertHistory = NULL;
	}

	hr = cuInfDumpProtectedStoreValue(
			    hInf,
			    wszINFSECTION_SMIME,
			    wszINFKEY_ISSUINGCERTIFICATES,
			    wszSECTION_KEY(
				    dwEPFAlg,
				    wszINFSECTION_SMIME,
				    wszINFKEY_ISSUINGCERTIFICATES),
			    fDump,
			    &sKey,
			    hrQuiet);
	_PrintIfErrorStr(
	    hr,
	    "cuInfDumpProtectedStoreValue",
	    wszSECTION_KEY(
		    dwEPFAlg,
		    wszINFSECTION_SMIME,
		    wszINFKEY_ISSUINGCERTIFICATES));

	hr = cuInfDumpProtectedValue(
			    hInf,
			    wszINFSECTION_SMIME,
			    wszINFKEY_TRUSTLISTCERTIFICATE,
			    &sKey,
			    hrQuiet,
			    &pbCertTrustList,
			    &cbCertTrustList);
	_PrintIfErrorStr(
	    hr,
	    "cuInfDumpProtectedValue",
	    wszSECTION_KEY(
		    dwEPFAlg,
		    wszINFSECTION_SMIME,
		    wszINFKEY_TRUSTLISTCERTIFICATE));

	wprintf(wszNewLine);
	if (fDump)
	{
	    wprintf(s_wszHeader);
	    wprintf(L"[%ws] ", wszINFSECTION_SMIME);
	}
	wprintf(L"%ws:\n", wszINFKEY_TRUSTLISTCERTIFICATE);

	if (NULL != pbCertTrustList)
	{
	    ExtraAsnBytes(pbCertTrustList, cbCertTrustList);
	    hr = cuDumpAsnBinary(pbCertTrustList, cbCertTrustList, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");

	    hr = AddCACertToStore(pbCertTrustList, cbCertTrustList);
	    _PrintIfError(hr, "AddCACertToStore");
	}
    }

    wprintf(wszNewLine);
    hr = S_OK;

error:
    SecureZeroMemory(wszPassword, sizeof(wszPassword));	// password data
    if (NULL != pwszSaltValue)
    {
        LocalFree(pwszSaltValue);
    }
    if (NULL != pbCertV1Signing)
    {
	LocalFree(pbCertV1Signing);
    }
    if (NULL != pbKeyV1Exchange)
    {
	SecureZeroMemory(pbKeyV1Exchange, cbKeyV1Exchange);	// Key material
	LocalFree(pbKeyV1Exchange);
    }
    if (NULL != pbKeyV1Signing)
    {
	SecureZeroMemory(pbKeyV1Signing, cbKeyV1Signing);	// Key material
	LocalFree(pbKeyV1Signing);
    }
    if (NULL != pbCertUser)
    {
	LocalFree(pbCertUser);
    }
    if (NULL != pbCertCA)
    {
	LocalFree(pbCertCA);
    }
    if (NULL != pbCertManager)
    {
	LocalFree(pbCertManager);
    }
    if (NULL != pbCertV1Exchange)
    {
	LocalFree(pbCertV1Exchange);
    }
    if (NULL != pbCertSigning)
    {
	LocalFree(pbCertSigning);
    }
    if (NULL != pbKeySigning)
    {
	SecureZeroMemory(pbKeySigning, cbKeySigning);	// Key material
	LocalFree(pbKeySigning);
    }
    if (NULL != pbCertHistory)
    {
	LocalFree(pbCertHistory);
    }
    if (NULL != pbrgKeyPrivate)
    {
	SecureZeroMemory(pbrgKeyPrivate, cbrgKeyPrivate);	// Key material
	LocalFree(pbrgKeyPrivate);
    }
    if (NULL != pbCertTrustList)
    {
	LocalFree(pbCertTrustList);
    }
    if (NULL != pwszFriendlyName)
    {
        LocalFree(pwszFriendlyName);
    }
    if (NULL != pbToken)
    {
        LocalFree(pbToken);
    }
    if (NULL != pbSaltValue)
    {
        LocalFree(pbSaltValue);
    }
    if (NULL != sKey.hKey)
    {
	CryptDestroyKey(sKey.hKey);
    }
    CAST3Cleanup(&sKey.sCastContext);

    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (INVALID_HANDLE_VALUE != hInf)
    {
	myInfCloseFile(hInf);
    }
    if (NULL != pwszTempFile)
    {
	if (!g_fSplitASN)
	{
	    DeleteFile(pwszTempFile);
	}
	LocalFree(pwszTempFile);
    }
    g_fQuiet = fQuietOld;
    return(hr);
}


VOID
FreeCertList(
    IN CERT_CONTEXT const **ppcc,
    IN DWORD ccc)
{
    DWORD i;
    
    if (NULL != ppcc)
    {
	for (i = 0; i < ccc; i++)
	{
	    if (NULL != ppcc[i])
	    {
		CertFreeCertificateContext(ppcc[i]);
	    }
	}
	LocalFree(ppcc);
    }
}


int _cdecl
fnEPFCertSort(
    IN VOID const *pvpcc1,
    IN VOID const *pvpcc2)
{
    CERT_CONTEXT const *pcc1 = *(CERT_CONTEXT const **) pvpcc1;
    CERT_CONTEXT const *pcc2 = *(CERT_CONTEXT const **) pvpcc2;
    BYTE abHash1[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash1;
    BYTE abHash2[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash2;
    int r = 0;
#define IHASH	5

    cbHash1 = sizeof(abHash1);
    if (CertGetCertificateContextProperty(
				pcc1,
				CERT_SHA1_HASH_PROP_ID,
				abHash1,
				&cbHash1) &&
	CertGetCertificateContextProperty(
				pcc2,
				CERT_SHA1_HASH_PROP_ID,
				abHash2,
				&cbHash2))
    {
	r = abHash1[5] - abHash2[5];
    }
    if (0 == r)
    {
	r = CompareFileTime(
			&pcc1->pCertInfo->NotBefore,
			&pcc2->pCertInfo->NotBefore);
    }
    return(r);
}


#define ICC_V1SIGNING		0
#define ICC_V1ENCRYPTION	1
#define ICC_V3SIGNING		2
#define ICC_V3ENCRYPTION	3
#define ICC_MAX			4

HRESULT
GetCertListFromStore(
    IN HCERTSTORE hStore,
    IN DWORD icc,
    OUT CERT_CONTEXT const ***pppcc,
    OUT DWORD *pccc)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    DWORD ccc;
    DWORD i;
    CERT_CONTEXT const **ppcc = NULL;
    DWORD dwKeySpec = (ICC_V1SIGNING == icc || ICC_V3SIGNING == icc)?
			AT_SIGNATURE : AT_KEYEXCHANGE;
    BOOL fV1 = ICC_V1SIGNING == icc || ICC_V1ENCRYPTION == icc;
    
    *pppcc = NULL;

    ccc = 0;
    while (TRUE)
    {
	if (NULL != pkpi)
	{
	    LocalFree(pkpi);
	    pkpi = NULL;
	}
	pcc = CertEnumCertificatesInStore(hStore, pcc);
	if (NULL == pcc)
	{
	    break;
	}
	if ((CERT_V1 == pcc->pCertInfo->dwVersion) ^ !fV1)
	{
	    hr = myCertGetKeyProviderInfo(pcc, &pkpi);
	    _PrintIfError2(hr, "myCertGetKeyProviderInfo", CRYPT_E_NOT_FOUND);
	    if (S_OK == hr && pkpi->dwKeySpec == dwKeySpec)
	    {
		ccc++;
	    }
	}
    }
    if (0 == ccc)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError2(hr, error, "no certs", hr);
    }
    ppcc = (CERT_CONTEXT const **) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					ccc * sizeof(*ppcc));
    if (NULL == ppcc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    i = 0;
    while (TRUE)
    {
	if (NULL != pkpi)
	{
	    LocalFree(pkpi);
	    pkpi = NULL;
	}
	pcc = CertEnumCertificatesInStore(hStore, pcc);
	if (NULL == pcc)
	{
	    break;
	}
	if ((CERT_V1 == pcc->pCertInfo->dwVersion) ^ !fV1)
	{
	    hr = myCertGetKeyProviderInfo(pcc, &pkpi);
	    _PrintIfError2(hr, "myCertGetKeyProviderInfo", CRYPT_E_NOT_FOUND);
	    if (S_OK == hr && pkpi->dwKeySpec == dwKeySpec)
	    {
		ppcc[i] = CertDuplicateCertificateContext(pcc);
		if (NULL == ppcc[i])
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CertDuplicateCertificateContext");
		}
		i++;
	    }
	}
    }
    CSASSERT(i == ccc);

    qsort(ppcc, ccc, sizeof(ppcc[0]), fnEPFCertSort);

    *pppcc = ppcc;
    ppcc = NULL;
    *pccc = ccc;

error:
    FreeCertList(ppcc, ccc);
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    return(hr);
}


HRESULT
GetLowerCaseDNAndCN(
    IN CERT_CONTEXT const *pcc,
    OUT CHAR **ppszDN,
    OUT WCHAR **ppwszCN)
{
    HRESULT hr;
    WCHAR *pwszDN = NULL;
    char *pszDN = NULL;
    DWORD Flags = CERT_X500_NAME_STR;

    *ppszDN = NULL;
    *ppwszCN = NULL;

    if (CERT_V1 == pcc->pCertInfo->dwVersion)
    {
	Flags |= CERT_NAME_STR_REVERSE_FLAG;
    }
    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		&pcc->pCertInfo->Subject,
		Flags,
		&pwszDN);
    _JumpIfError(hr, error, "myCertNameToStr");

    if (!myConvertWszToSz(&pszDN, pwszDN, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToSz");
    }
    _strlwr(pszDN);

    hr = myCertGetNameString(pcc, CERT_NAME_SIMPLE_DISPLAY_TYPE, ppwszCN);
    _JumpIfError(hr, error, "myCertGetNameString");

    *ppszDN = pszDN;
    pszDN = NULL;

error:
    if (NULL != pwszDN)
    {
	LocalFree(pwszDN);
    }
    if (NULL != pszDN)
    {
	LocalFree(pszDN);
    }
    return(hr);
}


HRESULT
EPFCryptBinaryToBase64(
    IN BYTE const *pbData,
    IN DWORD cbData,
    OUT WCHAR **ppwszBase64)
{
    HRESULT hr;
    WCHAR *pwszSrc;
    WCHAR *pwszDst;
    
    *ppwszBase64 = NULL;

    hr = myCryptBinaryToString(
		    pbData,
		    cbData,
		    CRYPT_STRING_BASE64 | CRYPT_STRING_NOCR,
		    ppwszBase64);
    _JumpIfError(hr, error, "myCryptBinaryToString");

    for (pwszSrc = pwszDst = *ppwszBase64; L'\0' != *pwszSrc; pwszSrc++)
    {
	switch (*pwszSrc)
	{
	    case L'\r':
	    case L'\n':
	    case L'\t':
	    case L' ':
		break;	// skip all whitespace

	    default:
		*pwszDst++ = *pwszSrc;	// copy the rest
		break;
	}
    }
    *pwszDst = L'\0';
    hr = S_OK;

error:
    return(hr);
}


HRESULT
WriteBase64Value(
    IN FILE *pf,
    IN WCHAR const *pwszKey,
    IN WCHAR const *pwszBase64Value,
    OPTIONAL IN WCHAR const *pwsz2ndValue)
{
    HRESULT hr;
    WCHAR const *pwszRemain = pwszBase64Value;
    DWORD cwcRemain = wcslen(pwszBase64Value);

    CSASSERT(0 != cwcRemain);
    while (0 != cwcRemain)
    {
	DWORD cwcLine;
	DWORD cwc;
	WCHAR const *pwsz1 = g_wszEmpty;
	WCHAR const *pwsz2 = g_wszEmpty;

	fprintf(pf, "%ws=", pwszKey);
	cwcLine = 256 - (wcslen(pwszKey) + 1);
	cwc = min(cwcLine, cwcRemain);
	if (cwc == cwcRemain && NULL != pwsz2ndValue)
	{
	    pwsz1 = L",";
	    pwsz2 = pwsz2ndValue;
	}
	fprintf(
	    pf,
	    "%.*ws%ws%ws\n",
	    cwc,
	    pwszRemain,
	    pwsz1,
	    pwsz2);
	cwcRemain -= cwc;
	pwszRemain += cwc;
	pwszKey = L"_continue_";
    }
    hr = S_OK;
    return(hr);
}


HRESULT
WriteIssuerNameAndSerialValue(
    IN FILE *pf,
    IN WCHAR const *pwszKey,
    OPTIONAL IN CERT_CONTEXT const *pccCA,
    IN CERT_CONTEXT const *pccUser)
{
    HRESULT hr;
    CERT_NAME_BLOB const *pName;
    WCHAR *pwszBase64 = NULL;
    DWORD dwSerial;
    WCHAR wszSerial[cwcDWORDSPRINTF];
    DWORD cb;
    DWORD cwc;

    if (NULL != pccCA)
    {
	pName = &pccCA->pCertInfo->Subject;
    }
    else
    {
	pName = &pccUser->pCertInfo->Issuer;
    }

    hr = EPFCryptBinaryToBase64(pName->pbData, pName->cbData, &pwszBase64);
    _JumpIfError(hr, error, "EPFCryptBinaryToBase64");

    dwSerial = 0;
    cb = pccUser->pCertInfo->SerialNumber.cbData;
    if (cb > sizeof(dwSerial))
    {
	cb = sizeof(dwSerial);
    }
    CopyMemory(&dwSerial, pccUser->pCertInfo->SerialNumber.pbData, cb);
    wsprintf(wszSerial, L"%u", dwSerial);

    hr = WriteBase64Value(pf, pwszKey, pwszBase64, wszSerial);
    _JumpIfError(hr, error, "WriteBase64Value");

error:
    if (NULL != pwszBase64)
    {
	LocalFree(pwszBase64);
    }
    return(hr);
}


HRESULT
WriteProtectedValue(
    IN FILE *pf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN EPF_SYM_KEY_STRUCT const *psKey,
    IN BYTE const *pbData,
    IN DWORD cbData)
{
    HRESULT hr;
    DWORD i;
    CRC16 Crc;
    WCHAR *pwszProtectedKey = NULL;
    BYTE *pbHeader = NULL;
    DWORD cbHeader;
    BYTE *pbValue = NULL;
    DWORD cbValue;
    BYTE *pbEncrypted = NULL;
    DWORD cbEncrypted;
    WCHAR *pwszBase64 = NULL;
    
    hr = BuildProtectedKey(pwszKey, psKey->dwAlgId, &pwszProtectedKey);
    _JumpIfError(hr, error, "BuildProtectedKey");

    hr = BuildProtectedHeader(pwszSection, pwszKey, &pbHeader, &cbHeader);
    _JumpIfError(hr, error, "BuildProtectedHeader");

    cbValue = sizeof(Crc) + cbHeader + cbData;
    pbValue = (BYTE *) LocalAlloc(LMEM_FIXED, cbValue);
    if (NULL == pbValue)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToSz");
    }
    CopyMemory(&pbValue[sizeof(Crc)], pbHeader, cbHeader);
    CopyMemory(&pbValue[sizeof(Crc) + cbHeader], pbData, cbData);

    // Calculate the CRC

    Crc = 0xffff;
    F_CRC16(g_CrcTable, &Crc, &pbValue[sizeof(Crc)], cbHeader + cbData);
    _swab((char *) &Crc, (char *) pbValue, sizeof(Crc));

    hr = EPFEncryptSection(
		    psKey,
		    pbValue,
		    cbValue,
		    &pbEncrypted,
		    &cbEncrypted);
    _JumpIfError(hr, error, "EPFEncryptSection");

    hr = EPFCryptBinaryToBase64(pbEncrypted, cbEncrypted, &pwszBase64);
    _JumpIfError(hr, error, "EPFCryptBinaryToBase64");

    hr = WriteBase64Value(pf, pwszProtectedKey, pwszBase64, NULL);
    _JumpIfError(hr, error, "WriteBase64Value");

error:
    if (NULL != pwszProtectedKey)
    {
	LocalFree(pwszProtectedKey);
    }
    if (NULL != pbHeader)
    {
	SecureZeroMemory(pbValue, cbValue);	// possible private key material
	LocalFree(pbHeader);
    }
    if (NULL != pbValue)
    {
	LocalFree(pbValue);
    }
    if (NULL != pbEncrypted)
    {
	LocalFree(pbEncrypted);
    }
    if (NULL != pwszBase64)
    {
	LocalFree(pwszBase64);
    }
    return(hr);
}


HRESULT
WriteProtectedStringValue(
    IN FILE *pf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN EPF_SYM_KEY_STRUCT const *psKey,
    IN WCHAR const *pwszValue)
{
    HRESULT hr;
    char *pszValue = NULL;

    if (!myConvertWszToSz(&pszValue, pwszValue, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToSz");
    }
    hr = WriteProtectedValue(
			pf,
			pwszSection,
			pwszKey,
			psKey,
			(BYTE const *) pszValue,
			strlen(pszValue));
    _JumpIfError(hr, error, "WriteProtectedValue");

error:
    if (NULL != pszValue)
    {
	LocalFree(pszValue);
    }
    return(hr);
}


HRESULT
WriteProtectedDwordValue(
    IN FILE *pf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN EPF_SYM_KEY_STRUCT const *psKey,
    IN DWORD dwValue)
{
    HRESULT hr;

    hr = WriteProtectedValue(
			pf,
			pwszSection,
			pwszKey,
			psKey,
			(BYTE const *) &dwValue,
			sizeof(dwValue));
    _JumpIfError(hr, error, "WriteProtectedValue");

error:
    return(hr);
}


HRESULT
LoadKMSRSAKeyFromCert(
    IN CERT_CONTEXT const *pcc,
    OPTIONAL IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec,
    OUT BYTE **ppbKey,
    OUT DWORD *pcbKey,
    OPTIONAL OUT CERT_PUBLIC_KEY_INFO **ppPublicKeyInfo)
{
    HRESULT hr;
    HCRYPTPROV hProvT = NULL;
    HCRYPTKEY hKeyPrivate = NULL;
    CRYPT_BIT_BLOB PrivateKey;
    CERT_PUBLIC_KEY_INFO *pPublicKeyInfo = NULL;
    DWORD cb;

    ZeroMemory(&PrivateKey, sizeof(PrivateKey));
    *ppbKey = NULL;
    if (NULL != ppPublicKeyInfo)
    {
	*ppPublicKeyInfo = NULL;
    }
    if (NULL == hProv)
    {
	DWORD dwKeySpecT;

	if (!CryptAcquireCertificatePrivateKey(
					pcc,
					0,		// dwFlags
					NULL,	// pvReserved
					&hProvT,
					&dwKeySpecT,
					NULL))	// pfCallerFreeProv
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptAcquireCertificatePrivateKey");
	}
	if (dwKeySpec != dwKeySpecT)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "dwKeySpec mismatch");
	}
	hProv = hProvT;
    }
    if (!CryptGetUserKey(hProv, dwKeySpec, &hKeyPrivate))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetUserKey");
    }
    hr = myCryptExportPrivateKey(
		    hKeyPrivate,
		    &PrivateKey.pbData,
		    &PrivateKey.cbData);
    _JumpIfError(hr, error, "myCryptExportPrivateKey");

    if (!myCryptExportPublicKeyInfo(
				hProv,
				dwKeySpec,
				CERTLIB_USE_LOCALALLOC,
				&pPublicKeyInfo,
				&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    if (!myCertComparePublicKeyInfo(
			    X509_ASN_ENCODING,
			    CERT_V1 == pcc->pCertInfo->dwVersion,
			    pPublicKeyInfo,
			    &pcc->pCertInfo->SubjectPublicKeyInfo))
    {
	// by design, (my)CertComparePublicKeyInfo doesn't set last error!

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "public key mismatch");
    }
    hr = myEncodeKMSRSAKey(
		    PrivateKey.pbData,
		    PrivateKey.cbData,
		    ppbKey,
		    pcbKey);
    _JumpIfError(hr, error, "myEncodeKMSRSAKey");

    if (NULL != ppPublicKeyInfo)
    {
	*ppPublicKeyInfo = pPublicKeyInfo;
	pPublicKeyInfo = NULL;
    }

error:
    if (NULL != PrivateKey.pbData)
    {
	SecureZeroMemory(PrivateKey.pbData, PrivateKey.cbData); // Key material
	LocalFree(PrivateKey.pbData);
    }
    if (NULL != pPublicKeyInfo)
    {
	LocalFree(pPublicKeyInfo);
    }
    if (NULL != hKeyPrivate)
    {
	CryptDestroyKey(hKeyPrivate);
    }
    if (NULL != hProvT)
    {
	CryptReleaseContext(hProvT, 0);
    }
    return(hr);
}


HRESULT
WriteSingleEPFKeyValue(
    IN FILE *pf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN EPF_SYM_KEY_STRUCT const *psKey,
    IN CERT_CONTEXT const *pcc,
    IN ALG_ID aiKeyAlg,
    IN DWORD dwKeySpec,
    IN DWORD dwKMSKeySpec)
{
    HRESULT hr;
    CERT_PUBLIC_KEY_INFO *pPublicKeyInfo = NULL;
    BYTE *pbKMSRSAKey = NULL;
    DWORD cbKMSRSAKey;
    BYTE *pbPubKey = NULL;
    DWORD cbPubKey;
    BYTE *pbEPFKey = NULL;
    DWORD cbEPFKey;
    ExchangeKeyBlobEx ekb;
    OneKeyBlob okb;

    hr = LoadKMSRSAKeyFromCert(
		    pcc,
		    NULL,		// hProv
		    dwKeySpec,
		    &pbKMSRSAKey,
		    &cbKMSRSAKey,
		    &pPublicKeyInfo);
    _JumpIfError(hr, error, "LoadKMSRSAKeyFromCert");

    ekb.dwSize = CBEKB;
    ekb.cKeys = 1;
    ekb.dwKeyAlg = aiKeyAlg;

    ZeroMemory(&okb, sizeof(okb));
    okb.dwKeySpec = dwKMSKeySpec;
    okb.cbPrivKey = cbKMSRSAKey;
    okb.obPrivKey = CBEKB + sizeof(okb);
    if (AT_SIGNATURE == dwKeySpec)
    {
	// If this is a valid public key with a proper leading zero byte before
	// the sign bit set in the next public key byte, remove the zero byte
	// and decrement the lengths.  This conforms with the old incorrect V1
	// public key encoding used in EPF files.

	hr = mySqueezePublicKey(
			pPublicKeyInfo->PublicKey.pbData,
			pPublicKeyInfo->PublicKey.cbData,
			&pbPubKey,
			&cbPubKey);
	_JumpIfError(hr, error, "mySqueezePublicKey");

	okb.cbPubKey = cbPubKey;
	okb.obPubKey = okb.obPrivKey + cbKMSRSAKey;
    }

    cbEPFKey = okb.obPrivKey + okb.cbPrivKey + okb.cbPubKey;
    pbEPFKey = (BYTE *) LocalAlloc(LMEM_FIXED, cbEPFKey);
    if (NULL == pbEPFKey)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pbEPFKey, &ekb, CBEKB);
    CopyMemory(&pbEPFKey[CBEKB], &okb, sizeof(okb));
    CopyMemory(&pbEPFKey[okb.obPrivKey], pbKMSRSAKey, cbKMSRSAKey);
    if (0 != okb.cbPubKey)
    {
	CopyMemory(&pbEPFKey[okb.obPubKey], pbPubKey, okb.cbPubKey);

	if (g_fVerbose)
	{
	    wprintf(myLoadResourceString(IDS_CERT_PUBLIC_KEY_COLON)); // "Cert Public key:"
	    wprintf(wszNewLine);
	    DumpHex(
		DH_NOTABPREFIX | 4,
		pcc->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
		pcc->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);

	    wprintf(myLoadResourceString(IDS_PUBLIC_KEY_COLON)); // "Public key:"
	    wprintf(wszNewLine);
	    DumpHex(
		DH_NOTABPREFIX | 4,
		&pbEPFKey[okb.obPubKey],
		okb.cbPubKey);
	}
    }

    hr = WriteProtectedValue(
			pf,
			pwszSection,
			pwszKey,
			psKey,
			pbEPFKey,
			cbEPFKey);
    _JumpIfError(hr, error, "WriteProtectedValue");

error:
    if (NULL != pbEPFKey)
    {
	SecureZeroMemory(pbEPFKey, cbEPFKey);		// Key material
	LocalFree(pbEPFKey);
    }
    if (NULL != pbPubKey)
    {
	LocalFree(pbPubKey);
    }
    if (NULL != pbKMSRSAKey)
    {
	SecureZeroMemory(pbKMSRSAKey, cbKMSRSAKey);	// Key material
	LocalFree(pbKMSRSAKey);
    }
    if (NULL != pPublicKeyInfo)
    {
	LocalFree(pPublicKeyInfo);
    }
    return(hr);
}


HRESULT
WriteSingleKMSRSAKeyValue(
    IN FILE *pf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN EPF_SYM_KEY_STRUCT const *psKey,
    IN CERT_CONTEXT const *pcc,
    OPTIONAL IN HCRYPTPROV hProv,
    IN ALG_ID aiKeyAlg,
    IN DWORD dwKeySpec,
    IN DWORD dwKMSKeySpec)
{
    HRESULT hr;
    CERT_PUBLIC_KEY_INFO *pPublicKeyInfo = NULL;
    BYTE *pbKMSRSAKey = NULL;
    DWORD cbKMSRSAKey;

    hr = LoadKMSRSAKeyFromCert(
			pcc,
			hProv,
			dwKeySpec,
			&pbKMSRSAKey,
			&cbKMSRSAKey,
			&pPublicKeyInfo);
    _JumpIfError(hr, error, "LoadKMSRSAKeyFromCert");

    hr = WriteProtectedValue(
			pf,
			pwszSection,
			pwszKey,
			psKey,
			pbKMSRSAKey,
			cbKMSRSAKey);
    _JumpIfError(hr, error, "WriteProtectedValue");

error:
    if (NULL != pbKMSRSAKey)
    {
	SecureZeroMemory(pbKMSRSAKey, cbKMSRSAKey);	// Key material
	LocalFree(pbKMSRSAKey);
    }
    if (NULL != pPublicKeyInfo)
    {
	LocalFree(pPublicKeyInfo);
    }
    return(hr);
}


HRESULT
WriteEncryptionKeysValue(
    IN FILE *pf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN EPF_SYM_KEY_STRUCT const *psKey,
    IN DWORD cccV1,
    IN CERT_CONTEXT const **rgpccV1,
    IN DWORD cccV3,
    IN CERT_CONTEXT const **rgpccV3)
{
    HRESULT hr;
    DWORD i;
    DWORD iKey;
    ExchangeKeyBlobEx ekb;
    BYTE *pbKeyData = NULL;
    DWORD cbKeyData;
    BYTE *pb;
    OneKeyBlob okb;
    CRYPT_DATA_BLOB *prgBlob = NULL;

    ekb.dwSize = CBEKB;
    ekb.cKeys = cccV1 + cccV3;
    ekb.dwKeyAlg = CALG_RSA_KEYX;
    if (0 != ekb.cKeys)
    {
	prgBlob = (CRYPT_DATA_BLOB *) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    ekb.cKeys * sizeof(*prgBlob));
	if (NULL == prgBlob)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	iKey = 0;
	for (i = 0; i < cccV1; i++)
	{
	    hr = LoadKMSRSAKeyFromCert(
			    rgpccV1[i],
			    NULL,		// hProv
			    AT_KEYEXCHANGE,
			    &prgBlob[iKey].pbData,
			    &prgBlob[iKey].cbData,
			    NULL);
	    _JumpIfError(hr, error, "LoadKMSRSAKeyFromCert");

	    iKey++;
	}
	for (i = 0; i < cccV3; i++)
	{
	    hr = LoadKMSRSAKeyFromCert(
			    rgpccV3[i],
			    NULL,		// hProv
			    AT_KEYEXCHANGE,
			    &prgBlob[iKey].pbData,
			    &prgBlob[iKey].cbData,
			    NULL);
	    _JumpIfError(hr, error, "LoadKMSRSAKeyFromCert");

	    iKey++;
	}

	cbKeyData = CBEKB + ekb.cKeys * sizeof(okb);
	for (iKey = 0; iKey < ekb.cKeys; iKey++)
	{
	    cbKeyData += prgBlob[iKey].cbData;
	}
	pbKeyData = (BYTE *) LocalAlloc(LMEM_FIXED, cbKeyData);
	if (NULL == pbKeyData)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	pb = pbKeyData;

	CopyMemory(pb, &ekb, CBEKB);
	pb += CBEKB;

	ZeroMemory(&okb, sizeof(okb));
	okb.dwKeySpec = dwKEYSPEC_V1ENCRYPTION_BASE;
	okb.obPrivKey = CBEKB + ekb.cKeys * sizeof(okb);
	for (iKey = 0; iKey < ekb.cKeys; iKey++)
	{
	    if (iKey == cccV1)
	    {
		okb.dwKeySpec = dwKEYSPEC_V3ENCRYPTION_BASE;
	    }
	    okb.cbPrivKey = prgBlob[iKey].cbData;
	    CopyMemory(pb, &okb, sizeof(okb));
	    CopyMemory(
		    &pbKeyData[okb.obPrivKey],
		    prgBlob[iKey].pbData,
		    okb.cbPrivKey);

	    pb += sizeof(okb);
	    okb.dwKeySpec++;
	    okb.obPrivKey += okb.cbPrivKey;
	}
	CSASSERT(pb == &pbKeyData[CBEKB + ekb.cKeys * sizeof(okb)]);
	CSASSERT(okb.obPrivKey == cbKeyData);

	hr = WriteProtectedValue(
			    pf,
			    pwszSection,
			    pwszKey,
			    psKey,
			    pbKeyData,
			    cbKeyData);
	_JumpIfError(hr, error, "WriteProtectedValue");
    }
    hr = S_OK;

error:
    if (NULL != prgBlob)
    {
	for (iKey = 0; iKey < ekb.cKeys; iKey++)
	{
	    if (NULL != prgBlob[iKey].pbData)
	    {
		SecureZeroMemory(prgBlob[iKey].pbData, prgBlob[iKey].cbData); // Key material
		LocalFree(prgBlob[iKey].pbData);
	    }
	}
	LocalFree(prgBlob);
    }
    if (NULL != pbKeyData)
    {
	SecureZeroMemory(pbKeyData, cbKeyData);	// Key material
	LocalFree(pbKeyData);
    }
    return(hr);
}


#define wszDSKCCSTATUSATTRIBUTE	L"kCCStatus"

WCHAR *s_apwszAttrs[] =
{
    wszDSDNATTRIBUTE,			// full DS DN
    wszDSOBJECTCLASSATTRIBUTE,		// object Class
    CERTTYPE_PROP_CN,			// DS CN
    wszDSBASECRLATTRIBUTE,		// rearranged CRL
    wszDSCROSSCERTPAIRATTRIBUTE,	// CTL certs?
    L"teletexTerminalIdentifier",	// proper CRL
    wszDSKCCSTATUSATTRIBUTE,		// CTL?
    NULL
};

BOOL s_afString[] =
{
    TRUE,
    TRUE,
    TRUE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
};


#define ISEMPTYATTR(pberval)	\
    (0 == (pberval)->bv_len || \
     (1 == (pberval)->bv_len && 0 == *(BYTE const *) (pberval)->bv_val))

HRESULT
epfParseCTL(
    IN BYTE const *pbCTL,
    IN DWORD cbCTL,
    IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT CTL_CONTEXT const **ppCTL)
{
    HRESULT hr;
    CTL_CONTEXT const *pCTL = NULL;
    DWORD i;

    *ppCTL = NULL;
    if (g_fSplitASN)
    {
	hr = cuDumpAsnBinary(pbCTL, cbCTL, MAXDWORD);
	_JumpIfError(hr, error, "cuDumpAsnBinary");
    }
    pCTL = CertCreateCTLContext(X509_ASN_ENCODING, pbCTL, cbCTL);
    if (NULL == pCTL)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCTLContext");
    }
    hr = CRYPT_E_NOT_FOUND;
    for (i = 0; i < pCTL->pCtlInfo->cCTLEntry; i++)
    {
	CTL_ENTRY const *pCTLEntry = &pCTL->pCtlInfo->rgCTLEntry[i];

	if (cbHash == pCTLEntry->SubjectIdentifier.cbData &&
	    0 == memcmp(
		    pbHash,
		    pCTLEntry->SubjectIdentifier.pbData,
		    cbHash))
	{
	    hr = S_OK;
	    *ppCTL = pCTL;
	    pCTL = NULL;
	    break;
	}
    }
    _JumpIfError(hr, error, "memcmp");

error:
    if (NULL != pCTL)
    {
	CertFreeCTLContext(pCTL);
    }
    return(hr);
}


HRESULT
epfGetOneKMSDSCTL(
    IN WCHAR const *pwszDN,
    IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT CTL_CONTEXT const **ppCTL);


HRESULT
epfGetCTLFromSearchResult(
    IN LDAP *pld,
    IN LDAPMessage *pSearchResult,
    IN BOOL fGC,
    IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT CTL_CONTEXT const **ppCTL)
{
    HRESULT hr;
    DWORD cres;
    LDAPMessage *pres;
    WCHAR **ppwszValues = NULL;
    DWORD ires;
    BOOL fIssuerFound = FALSE;

    *ppCTL = NULL;
    cres = ldap_count_entries(pld, pSearchResult);
    if (0 == cres)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT);
	_JumpError(hr, error, "ldap_count_entries");
    }
    for (ires = 0, pres = ldap_first_entry(pld, pSearchResult); 
	 NULL != pres;
	 ires++, pres = ldap_next_entry(pld, pres))
    {
	DWORD iAttr;

	wprintf(s_wszHeader);
	//wprintf(L"Result[%u]:\n", ires);
	for (iAttr = 0; NULL != s_apwszAttrs[iAttr]; iAttr++)
	{
	    DWORD iVal;

	    if (s_afString[iAttr])
	    {
		WCHAR **rgpwszval = NULL;

		rgpwszval = ldap_get_values(pld, pres, s_apwszAttrs[iAttr]);
		if (NULL != rgpwszval)
		{
		    //wprintf(L"%ws:\n", s_apwszAttrs[iAttr]);

		    for (iVal = 0; NULL != rgpwszval[iVal]; iVal++)
		    {
			if (0 == LSTRCMPIS(
				    s_apwszAttrs[iAttr],
				    wszDSDNATTRIBUTE))
			{
			    wprintf(L"  %ws\n", rgpwszval[iVal]);
			    if (fGC)
			    {
				hr = epfGetOneKMSDSCTL(
						    rgpwszval[iVal],
						    pbHash,
						    cbHash,
						    ppCTL);
				_PrintIfError(hr, "epfGetOneKMSDSCTL");
			    }
			}
		    }
		    if (NULL != rgpwszval)
		    {
			ldap_value_free(rgpwszval);
		    }
		    //wprintf(wszNewLine);
		}
		else
		{
		    //wprintf(L"%ws: EMPTY string value\n", s_apwszAttrs[iAttr]);
		}
	    }
	    else
	    {
		berval **rgpberval;

		rgpberval = ldap_get_values_len(pld, pres, s_apwszAttrs[iAttr]);
		if (NULL != rgpberval)
		{
		    if (g_fVerbose)
		    {
			wprintf(L"%ws:\n", s_apwszAttrs[iAttr]);
		    }
		    for (iVal = 0; NULL != rgpberval[iVal]; iVal++)
		    {
			BOOL fEmpty = ISEMPTYATTR(rgpberval[iVal]);
			BYTE const *pb = (BYTE const *) rgpberval[iVal]->bv_val;
			DWORD cb = rgpberval[iVal]->bv_len;

#if 0
			wprintf(
			    L"  %ws[%u]: pb=%x cb=%x\n",
			    s_apwszAttrs[iAttr],
			    iVal,
			    pb,
			    cb);
#endif
			if (g_fVerbose)
			{
			    hr = cuDumpAsnBinary(pb, cb, iVal);
			    _PrintIfError(hr, "cuDumpAsnBinary");
			}
			//DumpHex(DH_NOTABPREFIX | 4, pb, cb);
			if (!fIssuerFound &&
			    0 == LSTRCMPIS(
				    s_apwszAttrs[iAttr],
				    wszDSKCCSTATUSATTRIBUTE))
			{
			    //wprintf(L"epfParseCTL(%ws)\n", s_apwszAttrs[iAttr]);
			    //DumpHex(DH_NOTABPREFIX | 4, pb, cb);
			    hr = epfParseCTL(
					pb,
					cb,
					pbHash,
					cbHash,
					ppCTL);
			    _PrintIfError(hr, "epfAddAsnBlobToStore");
			    fIssuerFound = S_OK == hr;
			}
		    }
		    if (NULL != rgpberval)
		    {
			ldap_value_free_len(rgpberval);
		    }
		    //wprintf(wszNewLine);
		}
		else
		{
		    //wprintf(L"%ws: EMPTY binary value\n", s_apwszAttrs[iAttr]);
		}
	    }
	}
    }
    hr = fIssuerFound? S_OK : S_FALSE;

error:
    return(hr);
}


HRESULT
epfGetOneKMSDSCTL(
    IN WCHAR const *pwszDN,
    IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT CTL_CONTEXT const **ppCTL)
{
    HRESULT hr;
    ULONG ldaperr;
    LDAP *pld = NULL;
    struct l_timeval timeout;
    BSTR strConfigDN = NULL;
    LDAPMessage *pSearchResult = NULL;

    *ppCTL = NULL;
    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    hr = myLdapOpen(
		g_pwszDC,	// pwszDomainName
		0,		// dwFlags
		&pld,
		NULL,		// pstrDomainDN
		&strConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    wprintf(L"==> %ws\n", strConfigDN);

    ldaperr = ldap_search_ext_s(
			pld,
			const_cast<WCHAR *>(pwszDN),
			LDAP_SCOPE_BASE,
			L"(objectCategory=msExchKeyManagementServer)",
			s_apwszAttrs,
			0,
			NULL,
			NULL,
			&timeout,
			10000,		// size limit (number of entries)
			&pSearchResult);
    if (LDAP_SUCCESS != ldaperr)
    {
	hr = myHLdapError(pld, ldaperr, NULL);
	_JumpError(hr, error, "ldap_search_ext_s");
    }
    hr = epfGetCTLFromSearchResult(
			    pld,
			    pSearchResult,
			    FALSE,
			    pbHash,
			    cbHash,
			    ppCTL);
    _JumpIfError(hr, error, "epfGetCTLFromSearchResult");

error:
    if (NULL != pSearchResult)
    {
	ldap_msgfree(pSearchResult);
    }
    myLdapClose(pld, NULL, strConfigDN);
    return(hr);
}


HRESULT
epfGetV3CACTLFromHash(
    IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT CTL_CONTEXT const **ppCTL)
{
    HRESULT hr;
    ULONG ldaperr;
    struct l_timeval timeout;
    LDAP *pldGC = NULL;
    LDAPMessage *pSearchResult = NULL;
    BSTR strConfigDN = NULL;
    BOOL fGCFirst = FALSE;

    *ppCTL = NULL;
    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    hr = myLdapOpen(
		g_pwszDC,	// pwszDomainName
		fGCFirst? RLBF_REQUIRE_GC : 0, // dwFlags
		&pldGC,
		NULL,		// pstrDomainDN
		&strConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    wprintf(L"%ws\n", strConfigDN);

    ldaperr = ldap_search_ext_s(
			pldGC,
			strConfigDN,
			LDAP_SCOPE_SUBTREE,
			L"(objectCategory=msExchKeyManagementServer)",
			s_apwszAttrs,
			0,
			NULL,
			NULL,
			&timeout,
			10000,		// size limit (number of entries)
			&pSearchResult);
    if (LDAP_SUCCESS != ldaperr)
    {
	hr = myHLdapError(pldGC, ldaperr, NULL);
	_JumpError(hr, error, "ldap_search_ext_s");
    }
    hr = epfGetCTLFromSearchResult(
			    pldGC,
			    pSearchResult,
			    fGCFirst,
			    pbHash,
			    cbHash,
			    ppCTL);
    _JumpIfError(hr, error, "epfGetCTLFromSearchResult");

error:
    if (NULL != pSearchResult)
    {
	ldap_msgfree(pSearchResult);
    }
    myLdapClose(pldGC, NULL, strConfigDN);
    return(hr);
}


HRESULT
epfGetMSCARootHash(
    IN CERT_CONTEXT const *pccUser,
    OUT BYTE *pbHash,
    IN OUT DWORD *pcbHash)
{
    HRESULT hr;
    CERT_CHAIN_PARA ChainParams;
    CERT_CHAIN_CONTEXT const *pChainContext = NULL;
    CERT_CHAIN_ELEMENT const *pElement;

    ZeroMemory(&ChainParams, sizeof(ChainParams));
    ChainParams.cbSize = sizeof(ChainParams);

    DBGPRINT((DBG_SS_CERTUTIL, "Calling CertGetCertificateChain...\n"));

    // Get the chain and verify the cert:

    if (!CertGetCertificateChain(
		    g_fUserRegistry? HCCE_CURRENT_USER : HCCE_LOCAL_MACHINE,
		    pccUser,		// pCertContext
		    NULL,		// pTime
		    NULL,		// hAdditionalStore
		    &ChainParams,	// pChainPara
		    0,			// dwFlags
		    NULL,		// pvReserved
		    &pChainContext))	// ppChainContext
    {
        hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateChain");
    }
    DBGPRINT((DBG_SS_CERTUTIL, "CertGetCertificateChain done\n"));

    myDumpChain(
	    S_OK,
	    CA_VERIFY_FLAGS_DUMP_CHAIN |
		(g_fSplitASN? CA_VERIFY_FLAGS_SAVE_CHAIN : 0),
	    pccUser,
	    NULL,	// pfnCallback
	    NULL,	// pwszMissingIssuer
	    pChainContext);

    hr = CRYPT_E_NOT_FOUND;
    if (1 > pChainContext->cChain ||
	2 > pChainContext->rgpChain[0]->cElement)
    {
	_JumpError(hr, error, "no chain");
    }
    pElement = pChainContext->rgpChain[0]->rgpElement[
				pChainContext->rgpChain[0]->cElement - 1];
    if (0 == (CERT_TRUST_IS_SELF_SIGNED & pElement->TrustStatus.dwInfoStatus))
    {
	_JumpError(hr, error, "incomplete chain");
    }

    if (!CertGetCertificateContextProperty(
				pElement->pCertContext,
				CERT_SHA1_HASH_PROP_ID,
				pbHash,
				pcbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    hr = S_OK;

error:
    if (NULL != pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }
    return(hr);
}


HRESULT
epfGetV3CACTLFromChain(
    IN CERT_CONTEXT const *pccUserV3,
    OUT CTL_CONTEXT const **ppCTL)
{
    HRESULT hr;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;

    *ppCTL = NULL;

    cbHash = sizeof(abHash);
    hr = epfGetMSCARootHash(pccUserV3, abHash, &cbHash);
    if (S_OK != hr)
    {
	_PrintError(hr, "epfGetMSCARootHash");
	if (1 >= g_fForce)
	{
	    goto error;
	}
	cbHash = sizeof(abHash);
	ZeroMemory(abHash, sizeof(abHash));
    }

    hr = epfGetV3CACTLFromHash(abHash, cbHash, ppCTL);
    _JumpIfError(hr, error, "epfGetV3CACTLFromHash");

error:
    return(hr);
}


HRESULT
GetCACertFromStore(
    IN CERT_NAME_BLOB const *pIssuer,
    OPTIONAL IN CRYPT_INTEGER_BLOB const *pSerialNumber,
    OPTIONAL IN CERT_CONTEXT const *pccUserV1,
    IN BOOL fV1CA,
    IN WCHAR const *pwszStore,
    IN BOOL fUserStore,
    OUT CERT_CONTEXT const **ppccCA)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pcc = NULL;
    WCHAR *pwszIssuer = NULL;

    *ppccCA = NULL;
    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		pIssuer,
		CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		&pwszIssuer);
    _JumpIfError(hr, error, "myCertNameToStr");

    DBGPRINT((
	DBG_SS_CERTUTILI,
	"fV1=%x, fUser=%u, %ws '%ws'\n",
	fV1CA,
	fUserStore,
	pwszStore,
	pwszIssuer));

    hStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING,
			NULL,		// hProv
			CERT_STORE_OPEN_EXISTING_FLAG |
			    CERT_STORE_ENUM_ARCHIVED_FLAG |
			    CERT_STORE_READONLY_FLAG |
			    (fUserStore? 0 : CERT_SYSTEM_STORE_LOCAL_MACHINE),
			pwszStore);
    if (NULL == hStore)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CertOpenStore", pwszStore);
    }

    while (TRUE)
    {
	pcc = CertFindCertificateInStore(
				hStore,
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				0,	// dwFindFlags
				CERT_FIND_SUBJECT_NAME,
				pIssuer,
				pcc);
	if (NULL == pcc)
	{
	    hr = myHLastError();
	    DBGPRINT((
		DBG_SS_ERROR,
		"fV1=%x, fUser=%u, %ws\n",
		fV1CA,
		fUserStore,
		pwszStore));
	    _JumpErrorStr(hr, error, "CertFindCertificateInStore", pwszIssuer);
	}
	if (fV1CA ^ (CERT_V1 != pcc->pCertInfo->dwVersion))
	{
	    // The V1 CA should have been used to sign the V1 user cert.
	    
	    if (fV1CA &&
		NULL != pccUserV1 &&
		!CryptVerifyCertificateSignature(
					NULL,
					X509_ASN_ENCODING,
					pccUserV1->pbCertEncoded,
					pccUserV1->cbCertEncoded,
					&pcc->pCertInfo->SubjectPublicKeyInfo))
	    {
		hr = myHLastError();
		_PrintError(hr, "CryptVerifyCertificateSignature");
	    }
	    // The V1 signature check fails, so ignore the error and use the
	    // cert anyway.  The binary Issuer name match will have to suffice.
	    //else
	    {
		*ppccCA = pcc;
		pcc = NULL;
		break;
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszIssuer)
    {
        LocalFree(pwszIssuer);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}

typedef struct _STORELIST
{
    WCHAR const *pwszStoreName;
    BOOL         fUserStore;
} STORELIST;

STORELIST g_aCAStoreList[] =
{
    { wszCA_CERTSTORE, FALSE },
    { wszCA_CERTSTORE, TRUE },
    { wszROOT_CERTSTORE, FALSE },
    { wszROOT_CERTSTORE, TRUE },
    { wszMY_CERTSTORE, FALSE },
    { wszMY_CERTSTORE, TRUE },
};


HRESULT
GetCACert(
    OPTIONAL IN CERT_CONTEXT const *pccUserV1,
    OPTIONAL IN CERT_CONTEXT const *pccUserV3,
    IN BOOL fV1CA,
    OPTIONAL IN WCHAR const *pwszCACertId,
    OUT CERT_CONTEXT const **ppccCA)
{
    HRESULT hr;
    WCHAR *pwszSimpleName = NULL;
    CTL_CONTEXT const *pCTL = NULL;
    CMSG_CMS_SIGNER_INFO *pcsi = NULL;
    BSTR strSerialNumber = NULL;
    CERT_NAME_BLOB const *pIssuer = NULL;
    CRYPT_INTEGER_BLOB const *pSerialNumber = NULL;

    *ppccCA = NULL;

    hr = CRYPT_E_NOT_FOUND;
    if (NULL == pwszCACertId && NULL != pccUserV3)
    {
	hr = epfGetV3CACTLFromChain(pccUserV3, &pCTL);
	_PrintIfError(hr, "epfGetV3CACTLFromChain");
	if (S_OK == hr && NULL != pCTL)
	{
	    DWORD cb;

	    hr = myCryptMsgGetParam(
				pCTL->hCryptMsg,
				CMSG_CMS_SIGNER_INFO_PARAM,
				0,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pcsi,
				&cb);
	    _JumpIfError(hr, error, "myCryptMsgGetParam");

	    if (CERT_ID_ISSUER_SERIAL_NUMBER == pcsi->SignerId.dwIdChoice)
	    {
		hr = MultiByteIntegerToBstr(
			FALSE,
			pcsi->SignerId.IssuerSerialNumber.SerialNumber.cbData,
			pcsi->SignerId.IssuerSerialNumber.SerialNumber.pbData,
			&strSerialNumber);
		_JumpIfError(hr, error, "MultiByteIntegerToBstr");

		pwszCACertId = strSerialNumber;
		pSerialNumber = &pcsi->SignerId.IssuerSerialNumber.SerialNumber;
		pIssuer = &pcsi->SignerId.IssuerSerialNumber.Issuer;
	    }
	}
    }
    if (NULL != pccUserV1 || NULL != pIssuer)
    {
	DWORD i;

	if (NULL == pIssuer)
	{
	    pIssuer = &pccUserV1->pCertInfo->Issuer;
	}
	for (i = 0; i < ARRAYSIZE(g_aCAStoreList); i++)
	{
	    hr = GetCACertFromStore(
				pIssuer,
				pSerialNumber,
				pccUserV1,
				fV1CA,
				g_aCAStoreList[i].pwszStoreName,
				g_aCAStoreList[i].fUserStore,
				ppccCA);
	    if (S_OK == hr)
	    {
		break;
	    }
	    _PrintErrorStr(
		    hr,
		    fV1CA? "GetCACertFromStore:V1" : "GetCACertFromStore:V3",
		    g_aCAStoreList[i].pwszStoreName);
	}
    }
    if (NULL == *ppccCA)
    {
	hr = myGetCertificateFromPicker(
			    g_hInstance,
			    NULL,		// hwndParent
			    fV1CA?
				IDS_GETKMSV1CACERT_TITLE :
				IDS_GETKMSCACERT_TITLE,
			    fV1CA?
				IDS_GETKMSV1CACERT_SUBTITLE :
				IDS_GETKMSCACERT_SUBTITLE,

			    // dwFlags: HKLM+HKCU My store
			    CUCS_MYSTORE |
				CUCS_CASTORE |
				CUCS_ROOTSTORE |

				CUCS_MACHINESTORE |
				CUCS_USERSTORE |
				(g_fCryptSilent? CUCS_SILENT : 0) |
				(fV1CA? CUCS_V1ONLY : CUCS_V3ONLY),
			    NULL != pwszCACertId? pwszCACertId : g_wszCACertCN,
			    0,			// cStore
			    NULL,		// rghStore
			    0,			// cpszObjId
			    NULL,		// apszObjId
			    ppccCA);
	_JumpIfError(hr, error, "myGetCertificateFromPicker");
    }
    if (NULL != *ppccCA)
    {
	hr = myCertGetNameString(
			    *ppccCA,
			    CERT_NAME_SIMPLE_DISPLAY_TYPE,
			    &pwszSimpleName);
	if (S_OK != hr || 0 != lstrcmp(g_wszCACertCN, pwszSimpleName))
	{
	    _PrintIfError(hr, "myCertGetNameString");
	    CertFreeCertificateContext(*ppccCA);
	    *ppccCA = NULL;
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpErrorStr(
		    hr,
		    error,
		    "bad CA CommonName",
		    pwszSimpleName);
	}
	if (NULL != pCTL)
	{
	    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA cvse;

	    ZeroMemory(&cvse, sizeof(cvse));
	    cvse.cbSize = sizeof(cvse);
	    cvse.dwSignerType = CMSG_VERIFY_SIGNER_PUBKEY;
	    cvse.pvSigner = &(*ppccCA)->pCertInfo->SubjectPublicKeyInfo;

	    if (!CryptMsgControl(
			    pCTL->hCryptMsg,
			    0,		// dwFlags
			    CMSG_CTRL_VERIFY_SIGNATURE_EX,
			    &cvse))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptMsgControl(VerifySig)");
	    }
	}
	hr = S_OK;
    }

error:

    // myGetCertificateFromPicker cancel returns S_OK & NULL

    if (S_OK != hr || NULL == *ppccCA)
    {
	wprintf(
	    L"%ws\n",
	    myLoadResourceString(IDS_CANNOT_FIND_EPF_CA_CERT));
    }
    if (NULL != pCTL)
    {
	CertFreeCTLContext(pCTL);
    }
    if (NULL != pcsi)
    {
	LocalFree(pcsi);
    }
    if (NULL != strSerialNumber)
    {
        SysFreeString(strSerialNumber);
    }
    if (NULL != pwszSimpleName)
    {
        LocalFree(pwszSimpleName);
    }
    return(hr);
}


// [Password Token]
// Protection=128
// Profile Version=3
// Token=4BA715FC963A9B50
// SaltValue=J0+bHju332R+5Ia4dP52HvLav04=
// HashSize=0
//
// [User X.500 Name]
// X500Name=o=pki-kms-test, ou=dcross, cn=recipients, cn=user1
//
// [S/MIME]
// @Signing Certificate=FQLn5nUsYfhZZnmb5Zid8NIzJeXpKatACMsiXHsLzx...
// _continue_=...
// ...
// @Signing Key=ot7snTvKNUM2BSFwKXxyrLnDK5qmAcnpreL9MD84wXY4pW2...
// _continue_=...
// ...
// @Private Keys=E6oly3MbeMk6VCJuZ6UgUhX3npQCUFBmbEvw9L+...
// _continue_=...
// ...
// KeyCount=1
// @Issuing Certificates=bWQQmVuPjFkWSL...
// @Trust List Certificate=25irS5M5LL...
// _continue_=...
// ...
//
// [Full Certificate History]
// @SMIME_1=y3OPoks2yR6EAag5IiBsx+MzWeF3a3xy9Zj...
// _continue_=...
// @SMIME_2=NB5HNJNXp4IVu5cvNyZFS+MzWeF3a3xy9Zj...
// _continue_=...
// ...
//
// EPF file cert and key contents:
//   [S/MIME] @Signing Certificate: Single signing cert.
//   [S/MIME] @Signing Key: Single signing key.
//
//   [S/MIME] KeyCount: count of encryption certs and keys
//   [S/MIME] @Private Keys: encryption keys
//   [Full Certificate History] SMIME_1: encryption cert
//   [Full Certificate History] SMIME_2: encryption cert
//
//   [S/MIME] @Trust List Certificate: Single root cert; not issuing CA cert!
//
//   [S/MIME] @Issuing Certificates: serialized CAPI cert store
//   0000  00 00 00 00 43 45 52 54  00 00 00 00 00 00 00 00   ....CERT........
//   0010  00 00 00 00                                        ....
//

HRESULT
EPFSaveCertStoreToFile(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszPassword,
    IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszV3CACertId,
    IN DWORD dwEPFAlg,
    OPTIONAL IN WCHAR const *pwszSalt)
{
    HRESULT hr;
    FILE *pf = NULL;
    char *pszfnOut = NULL;
    WCHAR *pwszSaltValue = NULL;
    char *pszDN = NULL;
    char *pszDNT = NULL;
    WCHAR *pwszCN = NULL;
    WCHAR *pwszCNT = NULL;
    DWORD i;
    DWORD iCertHistory;
    CERT_CONTEXT const **appcc[ICC_MAX];
    DWORD accc[ICC_MAX];
    HCRYPTPROV hProvV1Signing = NULL;
    DWORD ccert;
    HCERTSTORE hStoreMem = NULL;
    CRYPT_DATA_BLOB BlobStore;
    HCRYPTPROV hProv = NULL;
    EPF_SYM_KEY_STRUCT sKey;
    BYTE abSaltValue[CBMAX_CRYPT_HASH_LEN];
    BYTE abToken[CBTOKEN];
    BYTE *pbSalt = NULL;
    DWORD cbSalt;
    CERT_CONTEXT const *pccCAV1 = NULL;
    CERT_CONTEXT const *pccCAV3 = NULL;
    WCHAR wszSMIME[cwcINFKEY_SMIME_FORMATTED];
    CERT_CONTEXT const *pccUserV1;
    CERT_CONTEXT const *pccUserV3;
    CERT_CONTEXT const *pccT;
    BOOL fQuietOld = g_fQuiet;

    ZeroMemory(&sKey, sizeof(sKey));
    ZeroMemory(appcc, sizeof(appcc));
    ZeroMemory(accc, sizeof(accc));
    BlobStore.pbData = NULL;

    ccert = 0;
    for (i = 0; i < ARRAYSIZE(appcc); i++)
    {
	hr = GetCertListFromStore(hStore, i, &appcc[i], &accc[i]);
	_PrintIfError2(hr, "GetCertListFromStore", CRYPT_E_NOT_FOUND);

	ccert += accc[i];
	if (0 != accc[i])
	{
	    wprintf(
		L"V%u %ws %ws: %u\n",
		(ICC_V1SIGNING == i || ICC_V1ENCRYPTION == i)? 1 : 3,
		(ICC_V1SIGNING == i || ICC_V3SIGNING == i)?
		    epfLoadResource(IDS_SIGNING, wszSIGNING) :
		    epfLoadResource(IDS_EXCHANGE, wszEXCHANGE),
		myLoadResourceString(IDS_CERTS), // "certs"
		accc[i]);
	}
    }
    if (0 == ccert)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "no certs");
    }

    for (i = 0; i < ARRAYSIZE(appcc); i++)
    {
	if (0 != accc[i])
	{
	    DWORD j;

	    for (j = 0; j < accc[i]; j++)
	    {
		int r;

		if (NULL != pszDNT)
		{
		    LocalFree(pszDNT);
		    pszDNT = NULL;
		}
		if (NULL != pwszCNT)
		{
		    LocalFree(pwszCNT);
		    pwszCNT = NULL;
		}
		hr = GetLowerCaseDNAndCN(appcc[i][j], &pszDNT, &pwszCNT);
		_JumpIfError(hr, error, "GetLowerCaseDNAndCN");

		if (g_fVerbose)
		{
		    wprintf(L"DN[%u][%u] = %hs\n", i, j, pszDNT);
		    wprintf(L"CN[%u][%u] = %ws\n", i, j, pwszCNT);
		}
		if (NULL == pszDN)
		{
		    pszDN = pszDNT;
		    pszDNT = NULL;
		}
		if (NULL == pwszCN)
		{
		    pwszCN = pwszCNT;
		    pwszCNT = NULL;
		    continue;
		}
		r = lstrcmp(pwszCN, pwszCNT);
		if (0 != r)
		{
		    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		    _PrintErrorStr(hr, "bad subject CN", pwszCNT);
		    _JumpErrorStr(hr, error, "expected subject CN", pwszCN);
		}
	    }
	}
    }

    if (!myConvertWszToSz(&pszfnOut, pwszfnOut, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToSz");
    }

    if (!CryptAcquireContext(
		    &hProv,
		    NULL,	// container name
		    MS_STRONG_PROV,
		    PROV_RSA_FULL,
		    CRYPT_VERIFYCONTEXT))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }

    if (NULL != pwszSalt)
    {
	hr = myCryptStringToBinary(
			pwszSalt,
			0,
			CRYPT_STRING_BASE64,
			&pbSalt,
			&cbSalt,
			NULL,
			NULL);
	_JumpIfError(hr, error, "myCryptStringToBinary");

	if (sizeof(abSaltValue) != cbSalt)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "cbSalt");
	}
    }
    else
    {
	if (!CryptGenRandom(hProv, sizeof(abSaltValue), abSaltValue))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptGenRandom");
	}
	hr = EPFCryptBinaryToBase64(
			abSaltValue,
			sizeof(abSaltValue),
			&pwszSaltValue);
	_JumpIfError(hr, error, "EPFCryptBinaryToBase64");

	pwszSalt = pwszSaltValue;
    }

    pccUserV1 = NULL;
    if (0 != accc[ICC_V1SIGNING])
    {
	pccUserV1 = appcc[ICC_V1SIGNING][accc[ICC_V1SIGNING] - 1];
    }
    else if (0 != accc[ICC_V1ENCRYPTION])
    {
	pccUserV1 = appcc[ICC_V1ENCRYPTION][accc[ICC_V1ENCRYPTION] - 1];
    }
    if (NULL != pccUserV1 && EPFALG_DEFAULT == dwEPFAlg)
    {
	dwEPFAlg = EPFALG_CAST;
    }

    hr = EPFDeriveKey(
		EPFALG_DEFAULT == dwEPFAlg? EPFALG_RC2_SHA : EPFALG_CAST_MD5,
		EPFALG_DEFAULT == dwEPFAlg? 128 : 64,
		hProv,
		pwszPassword,
		pwszSalt,
		pbSalt,
		cbSalt,
		0,		// cbHashSize
		&sKey);
    _JumpIfError(hr, error, "EPFDeriveKey");

    hr = EPFGenerateKeyToken(&sKey, abToken, sizeof(abToken));
    _JumpIfError(hr, error, "EPFGenerateKeyToken");

    if (!g_fForce)
    {
	pf = fopen(pszfnOut, "r");
	if (NULL != pf)
	{
            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
	    _JumpError(hr, error, "fopen");
	}
    }
    pf = fopen(pszfnOut, "w");
    if (NULL == pf)
    {
	hr = CO_E_FAILEDTOCREATEFILE;
	_JumpError(hr, error, "fopen");
    }

    fprintf(pf, "[" szINFSECTION_PASSWORDTOKEN "]\n");
    fprintf(pf, szINFKEY_PROTECTION "=%u\n", EPFALG_DEFAULT == dwEPFAlg? 128 : 64);
    fprintf(pf, szINFKEY_PROFILEVERSION "=%u\n", EPFALG_DEFAULT == dwEPFAlg? 3 : 2);
    if (EPFALG_DEFAULT != dwEPFAlg)
    {
	fprintf(pf, szINFKEY_CAST "=3\n");
    }
    fprintf(pf, szINFKEY_TOKEN "=");
    for (i = 0; i < sizeof(abToken); i++)
    {
	fprintf(pf, "%02X", abToken[i]);
    }
    fprintf(pf, "\n");

    fprintf(pf, szINFKEY_SALTVALUE "=%ws\n", pwszSalt);
    fprintf(pf, szINFKEY_HASHSIZE "=0\n");

    fprintf(pf, "\n[" szINFSECTION_USERX500NAME "]\n");
    fprintf(pf, szINFKEY_X500NAME "=%hs\n", pszDN);

    InitCrcTable();
    if (!g_fVerbose)
    {
	g_fQuiet = TRUE;
    }

    if (EPFALG_DEFAULT != dwEPFAlg)
    {
	if (0 == accc[ICC_V1SIGNING] && NULL != pccUserV1)
	{
	    appcc[ICC_V1SIGNING] = (CERT_CONTEXT const **) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					sizeof(appcc[ICC_V1SIGNING][0]));
	    if (NULL == appcc[ICC_V1SIGNING])
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    hr = epfBuildV1Certs(
			    pccUserV1,
			    &appcc[ICC_V1SIGNING][0],
			    &hProvV1Signing,
			    &pccCAV1);
	    _JumpIfError(hr, error, "epfBuildV1Certs");

	    accc[ICC_V1SIGNING] = 1;
	}
	if (0 != accc[ICC_V1SIGNING])
	{
	    pccT = appcc[ICC_V1SIGNING][accc[ICC_V1SIGNING] - 1];

	    fprintf(pf, "\n[" szINFSECTION_DIGITALSIGNATURE "]\n");
	    hr = WriteProtectedValue(
				pf,
				wszINFSECTION_DIGITALSIGNATURE,
				wszINFKEY_CERTIFICATE,
				&sKey,
				pccT->pbCertEncoded,
				pccT->cbCertEncoded);
	    _JumpIfError(hr, error, "WriteProtectedValue");

	    hr = cuDumpAsnBinary(pccT->pbCertEncoded, pccT->cbCertEncoded, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");

	    // szINFKEY_KEY

	    hr = WriteSingleKMSRSAKeyValue(
				pf,
				wszINFSECTION_DIGITALSIGNATURE,
				wszINFKEY_KEY,
				&sKey,
				pccT,
				hProvV1Signing,
				CALG_RSA_SIGN,
				AT_SIGNATURE,
				dwKEYSPEC_V1SIGNATURE);
	    _JumpIfError(hr, error, "WriteSingleKMSRSAKeyValue");
	}

	if (NULL == pccCAV1)
	{
	    hr = GetCACert(pccUserV1, NULL, TRUE, NULL, &pccCAV1);
	    _JumpIfError(hr, error, "GetCACert");
	}

	if (0 != accc[ICC_V1ENCRYPTION])
	{
	    WCHAR wszName[cwcINFKEY_NAME_FORMATTED];

	    fprintf(pf, "\n[" szINFSECTION_PRIVATEKEYS "]\n");
	    for (i = 0; i < accc[ICC_V1ENCRYPTION]; i++)
	    {
		WCHAR wszKey[cwcINFKEY_KEY_FORMATTED];

		pccT = appcc[ICC_V1ENCRYPTION][i];
		wsprintf(wszKey, wszINFKEY_KEY_FORMAT, i + 1);

		hr = WriteSingleKMSRSAKeyValue(
				    pf,
				    wszINFSECTION_PRIVATEKEYS,
				    wszKey,
				    &sKey,
				    pccT,
				    NULL,	// hProv
				    CALG_RSA_KEYX,
				    AT_KEYEXCHANGE,
				    dwKEYSPEC_V1ENCRYPTION_BASE + i);
		_JumpIfError(hr, error, "WriteSingleKMSRSAKeyValue");
	    }
	    fprintf(pf, szINFKEY_KEYCOUNT "=%u\n", accc[ICC_V1ENCRYPTION]);

	    fprintf(pf, "\n[" szINFSECTION_CERTIFICATEHISTORY "]\n");
	    for (i = 0; i < accc[ICC_V1ENCRYPTION]; i++)
	    {
		pccT = appcc[ICC_V1ENCRYPTION][i];
		wsprintf(wszName, wszINFKEY_NAME_FORMAT, i + 1);

		hr = WriteIssuerNameAndSerialValue(pf, wszName, pccCAV1, pccT);
		_JumpIfError(hr, error, "WriteIssuerNameAndSerialValue");
	    }

	    fprintf(pf, "\n[" szINFSECTION_FULLCERTIFICATEHISTORY "]\n");

	    // szINFKEY_NAME_FORMAT: Name%u -- V1 Encryption certs

	    for (i = 0; i < accc[ICC_V1ENCRYPTION]; i++)
	    {
		pccT = appcc[ICC_V1ENCRYPTION][i];

		wsprintf(wszName, wszINFKEY_NAME_FORMAT, i + 1);
		hr = WriteProtectedValue(
				    pf,
				    wszINFSECTION_FULLCERTIFICATEHISTORY,
				    wszName,
				    &sKey,
				    pccT->pbCertEncoded,
				    pccT->cbCertEncoded);
		_JumpIfError(hr, error, "WriteProtectedValue");

		hr = cuDumpAsnBinary(pccT->pbCertEncoded, pccT->cbCertEncoded, MAXDWORD);
		_JumpIfError(hr, error, "cuDumpAsnBinary");
	    }

	    // szINFKEY_SMIME_FORMAT: SMIME_%u -- V3 Encryption certs

	    for (i = 0; i < accc[ICC_V3ENCRYPTION]; i++)
	    {
		pccT = appcc[ICC_V3ENCRYPTION][i];

		wsprintf(wszSMIME, wszINFKEY_SMIME_FORMAT, i + 1);
		hr = WriteProtectedValue(
				    pf,
				    wszINFSECTION_FULLCERTIFICATEHISTORY,
				    wszSMIME,
				    &sKey,
				    pccT->pbCertEncoded,
				    pccT->cbCertEncoded);
		_JumpIfError(hr, error, "WriteProtectedValue");

		hr = cuDumpAsnBinary(pccT->pbCertEncoded, pccT->cbCertEncoded, MAXDWORD);
		_JumpIfError(hr, error, "cuDumpAsnBinary");
	    }

	    fprintf(pf, "\n[" szINFSECTION_USERCERTIFICATE "]\n");

	    pccT = appcc[ICC_V1ENCRYPTION][accc[ICC_V1ENCRYPTION] - 1];
	    hr = WriteProtectedValue(
				pf,
				wszINFSECTION_USERCERTIFICATE,
				wszINFKEY_CERTIFICATE,
				&sKey,
				pccT->pbCertEncoded,
				pccT->cbCertEncoded);
	    _JumpIfError(hr, error, "WriteProtectedValue");

	    hr = cuDumpAsnBinary(pccT->pbCertEncoded, pccT->cbCertEncoded, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");
	}

	fprintf(pf, "\n[" szINFSECTION_CA "]\n");

	hr = WriteProtectedValue(
			    pf,
			    wszINFSECTION_CA,
			    wszINFKEY_CERTIFICATE,
			    &sKey,
			    NULL != pccCAV1? pccCAV1->pbCertEncoded : NULL,
			    NULL != pccCAV1? pccCAV1->cbCertEncoded : 0);
	_JumpIfError(hr, error, "WriteProtectedValue");

	hr = cuDumpAsnBinary(pccT->pbCertEncoded, pccT->cbCertEncoded, MAXDWORD);
	_JumpIfError(hr, error, "cuDumpAsnBinary");

	fprintf(pf, "\n[" szINFSECTION_MICROSOFTEXCHANGE "]\n");

	hr = WriteProtectedStringValue(
			    pf,
			    wszINFSECTION_MICROSOFTEXCHANGE,
			    wszINFKEY_FRIENDLYNAME,
			    &sKey,
			    L"SzNull");
	_JumpIfError(hr, error, "WriteProtectedStringValue");

	hr = WriteProtectedDwordValue(
			    pf,
			    wszINFSECTION_MICROSOFTEXCHANGE,
			    wszINFKEY_KEYALGID,
			    &sKey,
			    EPFALG_CASTEXPORT == dwEPFAlg?
				EPFALG_EXPORT :
				EPFALG_DOMESTIC);
	_JumpIfError(hr, error, "WriteProtectedDwordValue");
    }

    if (0 != accc[ICC_V3SIGNING] || 0 != accc[ICC_V3ENCRYPTION])
    {
	fprintf(pf, "\n[" szINFSECTION_SMIME "]\n");

	// szINFKEY_SIGNINGCERTIFICATE

	if (0 != accc[ICC_V3SIGNING])
	{
	    pccT = appcc[ICC_V3SIGNING][accc[ICC_V3SIGNING] - 1];

	    hr = WriteProtectedValue(
				pf,
				wszINFSECTION_SMIME,
				wszINFKEY_SIGNINGCERTIFICATE,
				&sKey,
				pccT->pbCertEncoded,
				pccT->cbCertEncoded);
	    _JumpIfError(hr, error, "WriteProtectedValue");

	    hr = cuDumpAsnBinary(pccT->pbCertEncoded, pccT->cbCertEncoded, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");

	    // szINFKEY_SIGNINGKEY

	    hr = WriteSingleEPFKeyValue(
				pf,
				wszINFSECTION_SMIME,
				wszINFKEY_SIGNINGKEY,
				&sKey,
				pccT,
				CALG_RSA_SIGN,
				AT_SIGNATURE,
				dwKEYSPEC_V3SIGNATURE);
	    _JumpIfError(hr, error, "WriteSingleEPFKeyValue");
	}

	// szINFKEY_PRIVATEKEYS

	if (0 != accc[ICC_V3ENCRYPTION])
	{
	    hr = WriteEncryptionKeysValue(
				pf,
				wszINFSECTION_SMIME,
				wszINFKEY_PRIVATEKEYS,
				&sKey,
				0, // V3 keys only? accc[ICC_V1ENCRYPTION],
				appcc[ICC_V1ENCRYPTION],
				accc[ICC_V3ENCRYPTION],
				appcc[ICC_V3ENCRYPTION]);
	    _JumpIfError(hr, error, "WriteEncryptionKeys");
	}

	fprintf(pf, szINFKEY_KEYCOUNT "=%u\n", accc[ICC_V3ENCRYPTION]);

	// szINFKEY_ISSUINGCERTIFICATES -- empty serialized cert store

	hStoreMem = CertOpenStore(
			    CERT_STORE_PROV_MEMORY,
			    X509_ASN_ENCODING,
			    NULL,
			    CERT_STORE_NO_CRYPT_RELEASE_FLAG |
				CERT_STORE_ENUM_ARCHIVED_FLAG,
			    NULL);
	if (NULL == hStoreMem)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
	}
	while (TRUE)
	{
	    if (!CertSaveStore(
			hStoreMem,
			X509_ASN_ENCODING,
			CERT_STORE_SAVE_AS_STORE,
			CERT_STORE_SAVE_TO_MEMORY,
			&BlobStore,
			0))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertSaveStore");
	    }
	    if (NULL != BlobStore.pbData)
	    {
		break;
	    }
	    BlobStore.pbData = (BYTE *) LocalAlloc(LMEM_FIXED, BlobStore.cbData);
	    if (NULL == BlobStore.pbData)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	}
	hr = WriteProtectedValue(
			    pf,
			    wszINFSECTION_SMIME,
			    wszINFKEY_ISSUINGCERTIFICATES,
			    &sKey,
			    BlobStore.pbData,
			    BlobStore.cbData);
	_JumpIfError(hr, error, "WriteProtectedValue");

	// szINFKEY_TRUSTLISTCERTIFICATE -- root cert

	pccUserV3 = NULL;
	if (0 != accc[ICC_V3SIGNING])
	{
	    pccUserV3 = appcc[ICC_V3SIGNING][accc[ICC_V3SIGNING] - 1];
	}
	else if (0 != accc[ICC_V3ENCRYPTION])
	{
	    pccUserV3 = appcc[ICC_V3ENCRYPTION][accc[ICC_V3ENCRYPTION] - 1];
	}
	hr = GetCACert(pccUserV1, pccUserV3, FALSE, pwszV3CACertId, &pccCAV3);
	_JumpIfError(hr, error, "GetCACert");

	hr = WriteProtectedValue(
			    pf,
			    wszINFSECTION_SMIME,
			    wszINFKEY_TRUSTLISTCERTIFICATE,
			    &sKey,
			    NULL != pccCAV3? pccCAV3->pbCertEncoded : NULL,
			    NULL != pccCAV3? pccCAV3->cbCertEncoded : 0);
	_JumpIfError(hr, error, "WriteProtectedValue");
    }

    if (EPFALG_DEFAULT == dwEPFAlg)
    {
	fprintf(pf, "\n[" szINFSECTION_FULLCERTIFICATEHISTORY "]\n");

	// szINFKEY_SMIME_FORMAT: SMIME_%u -- V3 Encryption certs

	for (i = 0; i < accc[ICC_V3ENCRYPTION]; i++)
	{
	    pccT = appcc[ICC_V3ENCRYPTION][i];

	    wsprintf(wszSMIME, wszINFKEY_SMIME_FORMAT, i + 1);
	    hr = WriteProtectedValue(
				pf,
				wszINFSECTION_FULLCERTIFICATEHISTORY,
				wszSMIME,
				&sKey,
				pccT->pbCertEncoded,
				pccT->cbCertEncoded);
	    _JumpIfError(hr, error, "WriteProtectedValue");

	    hr = cuDumpAsnBinary(
			    pccT->pbCertEncoded,
			    pccT->cbCertEncoded,
			    MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");
	}
    }
    fprintf(pf, "\n");
    fflush(pf);
    if (ferror(pf))
    {
	hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
	_JumpError(hr, error, "write error");
    }
    hr = S_OK;

error:
    if (NULL != hStoreMem)
    {
	CertCloseStore(hStoreMem, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    for (i = 0; i < ARRAYSIZE(appcc); i++)
    {
	FreeCertList(appcc[i], accc[i]);
    }
    if (NULL != pccCAV1)
    {
	CertFreeCertificateContext(pccCAV1);
    }
    if (NULL != pccCAV3)
    {
	CertFreeCertificateContext(pccCAV3);
    }
    if (NULL != pf)
    {
	fclose(pf);
    }
    if (NULL != pszDNT)
    {
	LocalFree(pszDNT);
    }
    if (NULL != pszDN)
    {
	LocalFree(pszDN);
    }
    if (NULL != pwszCNT)
    {
	LocalFree(pwszCNT);
    }
    if (NULL != pwszCN)
    {
	LocalFree(pwszCN);
    }
    if (NULL != pbSalt)
    {
	LocalFree(pbSalt);
    }
    if (NULL != pwszSaltValue)
    {
	LocalFree(pwszSaltValue);
    }
    if (NULL != pszfnOut)
    {
	LocalFree(pszfnOut);
    }
    if (NULL != BlobStore.pbData)
    {
	LocalFree(BlobStore.pbData);
    }
    if (NULL != sKey.hKey)
    {
	CryptDestroyKey(sKey.hKey);
    }
    if (NULL != hProvV1Signing)
    {
	CryptReleaseContext(hProvV1Signing, 0);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    g_fQuiet = fQuietOld;
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\dump.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       dump.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "cscsp.h"
#include "csber.h"

#define __dwFILE__	__dwFILE_CERTUTIL_DUMP_CPP__


#if DBG
#define wszCERTUTIL	L"(certutil)"
#else
#define wszCERTUTIL	L""
#endif

WCHAR const g_wszCertUtil[] = wszCERTUTIL;

DWORD s_DbgSsRecoveryTrace = DBG_SS_CERTUTILI;


HRESULT
DumpAttributes(
    IN CRYPT_ATTRIBUTE const *rgAttr,
    IN DWORD cAttr,
    IN BOOL fQuiet,
    IN DWORD Type,		// FOT_*
    OPTIONAL IN HCERTSTORE hStore,
    OPTIONAL OUT BYTE *pbHashUserCert,
    OPTIONAL IN OUT DWORD *pcbHashUserCert,
    OPTIONAL IN OUT CERT_EXTENSIONS **ppExtInfo);


WCHAR const *
wszRDNValueType(
    IN DWORD dwValueType)
{
    WCHAR const *pwsz;

    switch (CERT_RDN_TYPE_MASK & dwValueType)
    {
	case CERT_RDN_ANY_TYPE:
	    pwsz = L"CERT_RDN_ANY_TYPE";
	    break;

	case CERT_RDN_ENCODED_BLOB:
	    pwsz = L"CERT_RDN_ENCODED_BLOB";
	    break;

	case CERT_RDN_OCTET_STRING:
	    pwsz = L"CERT_RDN_OCTET_STRING";
	    break;

	case CERT_RDN_NUMERIC_STRING:
	    pwsz = L"CERT_RDN_NUMERIC_STRING";
	    break;

	case CERT_RDN_PRINTABLE_STRING:
	    pwsz = L"CERT_RDN_PRINTABLE_STRING";
	    break;

	case CERT_RDN_TELETEX_STRING:
	    pwsz = L"CERT_RDN_TELETEX_STRING";
	    break;

	//case CERT_RDN_T61_STRING:
	    //pwsz = L"CERT_RDN_T61_STRING";
	    //break;

	case CERT_RDN_VIDEOTEX_STRING:
	    pwsz = L"CERT_RDN_VIDEOTEX_STRING";
	    break;

	case CERT_RDN_IA5_STRING:
	    pwsz = L"CERT_RDN_IA5_STRING";
	    break;

	case CERT_RDN_GRAPHIC_STRING:
	    pwsz = L"CERT_RDN_GRAPHIC_STRING";
	    break;

	//case CERT_RDN_VISIBLE_STRING:
	    //pwsz = L"CERT_RDN_VISIBLE_STRING";
	    //break;

	case CERT_RDN_ISO646_STRING:
	    pwsz = L"CERT_RDN_ISO646_STRING";
	    break;

	case CERT_RDN_GENERAL_STRING:
	    pwsz = L"CERT_RDN_GENERAL_STRING";
	    break;

	case CERT_RDN_UNIVERSAL_STRING:
	    pwsz = L"CERT_RDN_UNIVERSAL_STRING";
	    break;

	//case CERT_RDN_INT4_STRING:
	    //pwsz = L"CERT_RDN_INT4_STRING";
	    //break;

	//case CERT_RDN_BMP_STRING:
	    //pwsz = L"CERT_RDN_BMP_STRING";
	    //break;

	case CERT_RDN_UNICODE_STRING:
	    pwsz = L"CERT_RDN_UNICODE_STRING";
	    break;

	case CERT_RDN_UTF8_STRING:
	    pwsz = L"CERT_RDN_UTF8_STRING";
	    break;

	default:
	    pwsz = myLoadResourceString(IDS_QUESTIONMARKS); // "???"
	    break;
    }
    return(pwsz);
}


VOID
cuPrintCRLFString(
    IN WCHAR const *pwszPrefix,
    IN WCHAR const *pwszIn)
{
    if (NULL == pwszPrefix)
    {
	pwszPrefix = g_wszEmpty;
    }
    while (L'\0' != *pwszIn)
    {
	DWORD i;
	WCHAR const *pwc;

	pwc = pwszIn++;
	i = wcscspn(pwszIn, L"\r\n");

	wprintf(
	    L"%.1ws%ws%.*ws",
	    pwc,
	    L'\n' == *pwc? pwszPrefix : g_wszEmpty,
	    i,
	    pwszIn);
	pwszIn += i;

	if (L'\r' == *pwszIn)
	{
	    pwszIn++;
	}
    }
}


VOID
cuPrintPossibleObjectIdName(
    IN WCHAR const *pwszObjId)
{
    HRESULT hr;
	
    if (iswdigit(*pwszObjId))
    {
	hr = myVerifyObjId(pwszObjId);
	if (S_OK == hr)
	{
	    WCHAR const *pwszName = cuGetOIDName(pwszObjId);

	    if (NULL != pwszName && L'\0' != *pwszName)
	    {
		wprintf(L" %ws", pwszName);
	    }
	}
    }
}


WCHAR const *
cuGetOIDNameA(
    IN char const *pszObjId)
{
    HRESULT hr;
    WCHAR const *pwszName1 = g_wszEmpty;
    WCHAR const *pwszName2;
    char *pszT = NULL;
    static WCHAR s_wszName[512];

    pszT = (char *) LocalAlloc(LMEM_FIXED, 1 + strlen(pszObjId) + 1);
    if (NULL == pszT)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    strcpy(&pszT[1], pszObjId);

    *pszT = '+';
    pwszName1 = myGetOIDNameA(pszT);	// Group OID lookup

    *pszT = '-';
    pwszName2 = myGetOIDNameA(pszT);	// Generic OID lookup

    if (0 == mylstrcmpiL(pwszName1, pwszName2))
    {
	pwszName2 = g_wszEmpty;		// display only one if they're the same
    }
    if (L'\0' == *pwszName1)
    {
	pwszName1 = pwszName2;
	pwszName2 = g_wszEmpty;
    }

    if (L'\0' != *pwszName2 &&
	ARRAYSIZE(s_wszName) > wcslen(pwszName1) + wcslen(pwszName2) + 3)
    {
	wcscpy(s_wszName, pwszName1);
	wcscat(s_wszName, L" " wszLPAREN);
	wcscat(s_wszName, pwszName2);
	wcscat(s_wszName, wszRPAREN);
	pwszName1 = s_wszName;
    }

error:
    if (NULL != pszT)
    {
	LocalFree(pszT);
    }
    return(pwszName1);
}


WCHAR const *
cuGetOIDName(
    IN WCHAR const *pwszObjId)
{
    HRESULT hr;
    char *pszObjId = NULL;
    WCHAR const *pwszName = g_wszEmpty;

    if (!myConvertWszToSz(&pszObjId, pwszObjId, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToSz");
    }
    pwszName = cuGetOIDNameA(pszObjId);

error:
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    return(pwszName);
}


VOID
cuDumpOIDAndDescriptionA(
    IN char const *pszObjId)
{
    WCHAR const *pwsz;

    wprintf(L"%hs", pszObjId);
    pwsz = cuGetOIDNameA(pszObjId);
    if (NULL != pwsz && L'\0' != *pwsz)
    {
	wprintf(L" %ws", pwsz);
    }
}


VOID
cuDumpOIDAndDescription(
    IN WCHAR const *pwszObjId)
{
    WCHAR const *pwsz;

    wprintf(L"%ws", pwszObjId);
    pwsz = cuGetOIDName(pwszObjId);
    if (NULL != pwsz && L'\0' != *pwsz)
    {
	wprintf(L" %ws", pwsz);
    }
}


HRESULT
cuCertNameToStr(
    IN BOOL fMultiLine,
    IN CERT_NAME_BLOB const *pNameBlob,
    OUT WCHAR **ppwszCertName)
{
    HRESULT hr;
    DWORD Flags = CERT_X500_NAME_STR |
		    CERT_NAME_STR_REVERSE_FLAG |
		    CERT_NAME_STR_NO_QUOTING_FLAG;

    *ppwszCertName = NULL;
    if (fMultiLine)
    {
	Flags |= CERT_NAME_STR_CRLF_FLAG;
    }
    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		pNameBlob,
		Flags,
		ppwszCertName);
    _JumpIfError(hr, error, "myCertNameToStr");

error:
    return(hr);
}


typedef struct _RDNTABLE
{
    CHAR const *pszObjId;
    DWORD       cchMax;
} RDNTABLE;

RDNTABLE const g_RdnTable[] =
{
    { szOID_COUNTRY_NAME,		cchCOUNTRYNAMEMAX },
    { szOID_ORGANIZATION_NAME,		cchORGANIZATIONNAMEMAX },
    { szOID_ORGANIZATIONAL_UNIT_NAME,	cchORGANIZATIONALUNITNAMEMAX },
    { szOID_COMMON_NAME,		cchCOMMONNAMEMAX },
    { szOID_LOCALITY_NAME,		cchLOCALITYMANAMEMAX },
    { szOID_STATE_OR_PROVINCE_NAME,	cchSTATEORPROVINCENAMEMAX },
    { szOID_TITLE,			cchTITLEMAX },
    { szOID_GIVEN_NAME,			cchGIVENNAMEMAX },
    { szOID_INITIALS,			cchINITIALSMAX },
    { szOID_SUR_NAME,			cchSURNAMEMAX },
    { szOID_DOMAIN_COMPONENT,		cchDOMAINCOMPONENTMAX },
    { szOID_RSA_emailAddr,		cchEMAILMAX },
    { szOID_STREET_ADDRESS,		cchSTREETADDRESSMAX },
    { szOID_RSA_unstructName,		cchUNSTRUCTUREDNAMEMAX },
    { szOID_RSA_unstructAddr,		cchUNSTRUCTUREDADDRESSMAX },
    { szOID_DEVICE_SERIAL_NUMBER,	cchDEVICESERIALNUMBERMAX },
    { NULL,				0 },
};


DWORD
cwcRDNMax(
    IN char const *pszObjId)
{
    RDNTABLE const *pRdnTable;
    DWORD cwcMax = MAXDWORD;

    for (pRdnTable = g_RdnTable; NULL != pRdnTable->pszObjId; pRdnTable++)
    {
	if (0 == strcmp(pszObjId, pRdnTable->pszObjId))
	{
	    cwcMax = pRdnTable->cchMax;
	    break;
	}
    }
    return(cwcMax);
}


HRESULT
cuDisplayCertNameValue(
    OPTIONAL IN char const *pszObjId,
    OPTIONAL IN WCHAR const *pwszChoice,
    IN DWORD dwValueType,
    IN CRYPT_DATA_BLOB const *pValueW,
    IN CRYPT_DATA_BLOB const *pValueA)
{
    HRESULT hr;
    DWORD cwc;
    DWORD cwcMax = MAXDWORD;
    CRYPT_DATA_BLOB ValueUTF8;

    ValueUTF8.pbData = NULL;
    cwc = pValueW->cbData / sizeof(WCHAR);
    if (NULL != pszObjId)
    {
	cwcMax = cwcRDNMax(pszObjId);
    }

    if (CERT_RDN_UTF8_STRING == dwValueType)
    {
	if (myConvertWszToUTF8(
		(char **) &ValueUTF8.pbData,
		(WCHAR const *) pValueW->pbData,
		pValueW->cbData / sizeof(WCHAR)))
	{
	    ValueUTF8.cbData = strlen((CHAR const *) ValueUTF8.pbData);
	    pValueA = &ValueUTF8;
	}
    }

    wprintf(
	L"%ws, %ws = %u",
	wszRDNValueType(dwValueType),
	myLoadResourceString(IDS_LENGTH), // "Length"
	pValueA->cbData);

    if (MAXDWORD != cwcMax || CERT_RDN_OCTET_STRING != dwValueType)
    {
	wprintf(
	    L" " wszLPAREN L"%ws%ws%u",
	    cwc <= cwcMax? g_wszEmpty : myLoadResourceString(IDS_OVERFLOW), // "OVERFLOW:"
	    cwc <= cwcMax? g_wszEmpty : L" ",
	    cwc);
	if (NULL != pszObjId && MAXDWORD != cwcMax)
	{
	    wprintf(L"/%u", cwcMax);
	}
	wprintf(
	    L" %ws" wszRPAREN,
	    myLoadResourceString(IDS_CHARS)); // "Characters"
    }
    wprintf(wszNewLine);

    wprintf(g_wszPad8);
    if (NULL != pszObjId)
    {
	cuDumpOIDAndDescriptionA(pszObjId);
	wprintf(L"=");
    }
    else if (NULL != pwszChoice)
    {
	wprintf(L"%ws=", pwszChoice);
    }
    if (CERT_RDN_OCTET_STRING != dwValueType)
    {
	wprintf(L"\"%ws\"\n", pValueW->pbData);
    }
    wprintf(wszNewLine);

    DumpHex(
	DH_NOADDRESS | DH_NOTABPREFIX | 8,
	pValueA->pbData,
	pValueA->cbData);

    if (pValueA->cbData != pValueW->cbData ||
	0 != memcmp(pValueA->pbData, pValueW->pbData, pValueW->cbData))
    {
	wprintf(wszNewLine);
	DumpHex(
	    DH_NOADDRESS | DH_NOTABPREFIX | 8,
	    pValueW->pbData,
	    pValueW->cbData);
    }
    hr = S_OK;

//error:
    if (NULL != ValueUTF8.pbData)
    {
	LocalFree(ValueUTF8.pbData);
    }
    return(hr);
}


HRESULT
cuDisplayCertName(
    IN BOOL fMultiLine,
    OPTIONAL IN WCHAR const *pwszNamePrefix,
    OPTIONAL IN WCHAR const *pwszName,
    IN WCHAR const *pwszPad,
    IN CERT_NAME_BLOB const *pNameBlob,
    OPTIONAL IN CERT_INFO const *pCertInfo)
{
    WCHAR *pwszCertName = NULL;
    DWORD i;
    HRESULT hr = S_OK;
    CERT_NAME_INFO *pNameInfoA = NULL;
    CERT_NAME_INFO *pNameInfoW = NULL;
    WCHAR *pwszAltName = NULL;
    DWORD cb;

    hr = cuCertNameToStr(fMultiLine, pNameBlob, &pwszCertName);
    _JumpIfError(hr, error, "cuCertNameToStr");

    if (NULL != pwszNamePrefix)
    {
	wprintf(pwszNamePrefix);
    }
    if (NULL != pwszName)
    {
	wprintf(L"%ws:", pwszName);
    }
    wprintf(fMultiLine? L"\n%ws" : L" ", pwszPad);
    cuPrintCRLFString(pwszPad, pwszCertName);
    if (L'\0' == *pwszCertName)
    {
	wprintf(L"%ws", myLoadResourceString(IDS_PROP_EMPTY)); // "EMPTY"
	if (NULL != pCertInfo)
	{
	    CERT_EXTENSION const *pExt;

	    pExt = CertFindExtension(
			    szOID_SUBJECT_ALT_NAME2,
			    pCertInfo->cExtension,
			    pCertInfo->rgExtension);
	    if (NULL != pExt)
	    {
		if (!CryptFormatObject(
				X509_ASN_ENCODING,
				0,
				CRYPT_FORMAT_STR_NO_HEX,
				NULL,
				pExt->pszObjId,
				pExt->Value.pbData,
				pExt->Value.cbData,
				NULL,
				&cb))
		{
		    hr = myHLastError();
		    _PrintError(hr, "CryptFormatObject");
		    if (S_OK == hr)
		    {
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		    }
		}
		else
		{
		    pwszAltName = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
		    if (NULL == pwszAltName)
		    {
			hr = E_OUTOFMEMORY;
			_JumpError(hr, error, "LocalAlloc");
		    }
		    if (!CryptFormatObject(
				X509_ASN_ENCODING,
				0,
				CRYPT_FORMAT_STR_NO_HEX,
				NULL,
				pExt->pszObjId,
				pExt->Value.pbData,
				pExt->Value.cbData,
				pwszAltName,
				&cb))
		    {
			hr = myHLastError();
			_JumpError(hr, error, "CryptFormatObject");
		    }
		    wprintf(L" (%ws)", pwszAltName);
		}
	    }
	}
    }
    wprintf(wszNewLine);

    if (1 < g_fVerbose)
    {
	DumpHex(
	    DH_NOTABPREFIX | 4,
	    pNameBlob->pbData,
	    pNameBlob->cbData);
	wprintf(wszNewLine);
    }

    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_UNICODE_NAME,
		pNameBlob->pbData,
		pNameBlob->cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfoW,
		&cb))
    {

	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_NAME,
		pNameBlob->pbData,
		pNameBlob->cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfoA,
		&cb))
    {

	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    if (g_fVerbose)
    {
	for (i = 0; i < pNameInfoW->cRDN; i++)
	{
	    CERT_RDN const *prdnA;
	    CERT_RDN const *prdnW;
	    DWORD j;

	    prdnA = &pNameInfoA->rgRDN[i];
	    prdnW = &pNameInfoW->rgRDN[i];

	    for (j = 0; j < prdnW->cRDNAttr; j++)
	    {
		CERT_RDN_ATTR const *prdnaA;
		CERT_RDN_ATTR const *prdnaW;

		prdnaA = &prdnA->rgRDNAttr[j];
		prdnaW = &prdnW->rgRDNAttr[j];

		wprintf(L"    [%u,%u]: ", i, j);
		hr = cuDisplayCertNameValue(
					prdnaW->pszObjId,
					NULL,
					prdnaW->dwValueType,
					&prdnaW->Value,
					&prdnaA->Value);
		_PrintIfError(hr, "cuDisplayCertNameValue");
		wprintf(wszNewLine);
	    }
	}
    }

error:
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    if (NULL != pwszAltName)
    {
	LocalFree(pwszAltName);
    }
    if (NULL != pNameInfoW)
    {
	LocalFree(pNameInfoW);
    }
    if (NULL != pNameInfoA)
    {
	LocalFree(pNameInfoA);
    }
    return(hr);
}


HRESULT
cuDisplayCertNames(
    IN BOOL fMultiLine,
    OPTIONAL IN WCHAR const *pwszNamePrefix,
    IN CERT_INFO const *pCertInfo)
{
    HRESULT hr;

    hr = cuDisplayCertName(
			fMultiLine,
			pwszNamePrefix,
			myLoadResourceString(IDS_ISSUER), // "Issuer"
			g_wszPad4,
			&pCertInfo->Issuer,
			NULL);
    _JumpIfError(hr, error, "cuDisplayCertName(Issuer)");

    hr = cuDisplayCertName(
			fMultiLine,
			pwszNamePrefix,
			myLoadResourceString(IDS_SUBJECT), // "Subject"
			g_wszPad4,
			&pCertInfo->Subject,
			pCertInfo);
    _JumpIfError(hr, error, "cuDisplayCertName(Subject)");

error:
    return(hr);
}


#define POLICY_MASK \
  (EXTENSION_POLICY_MASK & ~(EXTENSION_CRITICAL_FLAG | EXTENSION_DISABLE_FLAG))

#define EXTRA_MASK	(~(EXTENSION_POLICY_MASK | EXTENSION_ORIGIN_MASK))

WCHAR const *
cuwszFromExtFlags(
    DWORD ExtFlags)
{
    static WCHAR awc[MAX_PATH];
    WCHAR const *pwszComma;
    WCHAR const *pwszSep = wszLPAREN;
    DWORD msgid;
    WCHAR const *pwszT;

    awc[0] = L'\0';
    pwszComma = myLoadResourceString(IDS_SEPARATOR); // ", "
    if (NULL == pwszComma)
    {
	pwszComma = L", ";
    }
    if (EXTENSION_CRITICAL_FLAG & ExtFlags)
    {
	wcscat(awc, pwszSep);
	pwszSep = pwszComma;
	pwszT = myLoadResourceString(IDS_CRITICAL); // "Critical"
	if (NULL != pwszT)
	{
	    wcscat(awc, pwszT);
	}
    }
    if (~EXTENSION_CRITICAL_FLAG & ExtFlags)
    {
	if (EXTENSION_DISABLE_FLAG & ExtFlags)
	{
	    wcscat(awc, pwszSep);
	    pwszSep = pwszComma;
	    pwszT = myLoadResourceString(IDS_DISABLED); // "Disabled"
	    if (NULL != pwszT)
	    {
		wcscat(awc, pwszT);
	    }
	}
	if (POLICY_MASK & ExtFlags)
	{
	    wcscat(awc, pwszSep);
	    pwszSep = pwszComma;
	    pwszT = myLoadResourceString(IDS_FORMAT_POLICYFLAGS); // "PolicyFlags=%x"
	    if (NULL == pwszT)
	    {
		pwszT = L"PolicyFlags=%x";
	    }
	    wsprintf(&awc[wcslen(awc)], pwszT, POLICY_MASK & ExtFlags);
	}
	switch (EXTENSION_ORIGIN_MASK & ExtFlags)
	{
	    case EXTENSION_ORIGIN_REQUEST:
		msgid = IDS_REQUEST;	// "Request"
		break;

	    case EXTENSION_ORIGIN_POLICY:
		msgid = IDS_POLICY;		// "Policy"
		break;

	    case EXTENSION_ORIGIN_ADMIN:
		msgid = IDS_ADMIN;		// "Admin"
		break;

	    case EXTENSION_ORIGIN_SERVER:
		msgid = IDS_SERVER;		// "Server"
		break;

	    case EXTENSION_ORIGIN_RENEWALCERT:
		msgid = IDS_RENEWALCERT;	// "Renewal Cert"
		break;

	    case EXTENSION_ORIGIN_IMPORTEDCERT:
		msgid = IDS_IMPORTEDCERT;	// "Imported Cert"
		break;

	    case EXTENSION_ORIGIN_PKCS7:
		msgid = IDS_PKCS7ATTRIBUTE;	// "PKCS7 Attribute"
		break;

	    case EXTENSION_ORIGIN_CMC:
		msgid = IDS_CMCATTRIBUTE;	// "CMC Attribute"
		break;

	    case EXTENSION_ORIGIN_CACERT:
		msgid = IDS_CACERTEXT;		// "CA Cert"
		break;

	    default:
		msgid = IDS_UNKNOWN;	// "UNKNOWN"
		break;
	}
	wcscat(awc, pwszSep);
	pwszSep = pwszComma;
	pwszT = myLoadResourceString(IDS_FORMAT_ORIGIN); // "Origin=%ws"
	if (NULL == pwszT)
	{
	    pwszT = L"Origin=%ws";
	}
	wsprintf(&awc[wcslen(awc)], pwszT, myLoadResourceString(msgid));

	if (EXTRA_MASK & ExtFlags)
	{
	    wcscat(awc, pwszSep);
	    pwszT = myLoadResourceString(IDS_FORMAT_UNKNOWN_HEX); // "???=%x"
	    if (NULL == pwszT)
	    {
		pwszT = L"???=%x";
	    }
	    wsprintf(&awc[wcslen(awc)], pwszT, EXTRA_MASK & ExtFlags);
	}
    }
    if (L'\0' != awc[0])
    {
	wcscat(awc, wszRPAREN);
    }
    return(awc);
}


VOID
PrintStringWithPrefix(
    IN WCHAR const *pwszPrefix,
    IN WCHAR const *pwszIn)
{
    while (L'\0' != *pwszIn)
    {
	DWORD i;
	DWORD j;
	WCHAR const *pwszNewLine;

	pwszNewLine = g_wszEmpty;
	j = 0;
	i = wcscspn(pwszIn, L"\n");
	if (L'\n' == pwszIn[i])
	{
	    pwszNewLine = L"\n";
	    j++;
	    if (0 < i && L'\r' == pwszIn[i - 1])
	    {
		i--;
		j++;
	    }
	}
	wprintf(L"%ws%.*ws%ws", pwszPrefix, i, pwszIn, pwszNewLine);
	pwszIn += i + j;
    }
}


WCHAR const *
wszAltNameChoice(
    IN LONG Choice)
{
    WCHAR const *pwsz;

    switch (Choice)
    {
	case CERT_ALT_NAME_OTHER_NAME:
	    pwsz = L"CERT_ALT_NAME_OTHER_NAME";
	    break;

	case CERT_ALT_NAME_RFC822_NAME:
	    pwsz = L"CERT_ALT_NAME_RFC822_NAME";
	    break;

	case CERT_ALT_NAME_DNS_NAME:
	    pwsz = L"CERT_ALT_NAME_DNS_NAME";
	    break;

	case CERT_ALT_NAME_X400_ADDRESS:
	    pwsz = L"CERT_ALT_NAME_X400_ADDRESS";
	    break;

	case CERT_ALT_NAME_DIRECTORY_NAME:
	    pwsz = L"CERT_ALT_NAME_DIRECTORY_NAME";
	    break;

	case CERT_ALT_NAME_EDI_PARTY_NAME:
	    pwsz = L"CERT_ALT_NAME_EDI_PARTY_NAME";
	    break;

	case CERT_ALT_NAME_URL:
	    pwsz = L"CERT_ALT_NAME_URL";
	    break;

	case CERT_ALT_NAME_IP_ADDRESS:
	    pwsz = L"CERT_ALT_NAME_IP_ADDRESS";
	    break;

	case CERT_ALT_NAME_REGISTERED_ID:
	    pwsz = L"CERT_ALT_NAME_REGISTERED_ID";
	    break;

	default:
	    pwsz = myLoadResourceString(IDS_QUESTIONMARKS); // "???"
	    break;
    }
    return(pwsz);
}


HRESULT
DumpIPAddress(
    IN WCHAR const *pwszPad,
    IN UINT idsMsg,
    IN BYTE const *pb,
    IN DWORD cb)
{
    HRESULT hr;
    
    if (CB_IPV6ADDRESS != cb && CB_IPV4ADDRESS != cb)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "IPAddress size");
    }
    wprintf(L"%ws  %ws = ", pwszPad, myLoadResourceString(idsMsg));
    if (CB_IPV6ADDRESS == cb)
    {
	BYTE abZero[CB_IPV6ADDRESS - CB_IPV4ADDRESS];
	
	ZeroMemory(abZero, sizeof(abZero));
	if (0 == memcmp(abZero, pb, sizeof(abZero)))
	{
	    wprintf(L"::");
	    pb += sizeof(abZero);
	    cb = CB_IPV4ADDRESS;
	    CSASSERT(CB_IPV6ADDRESS - sizeof(abZero) == cb);
	}
	else
	{
	    DWORD j;
	    WCHAR const *pwsz = L"";
	    BOOL fZeroSeen = FALSE;
	    BOOL fZero = FALSE;

	    for (j = 0; j < cb / sizeof(USHORT); j++)
	    {
		USHORT us =
		    (pb[sizeof(USHORT) * j] << 8) |
		    pb[sizeof(USHORT) * j + 1];

		if (0 == us && (fZero || !fZeroSeen))
		{
		    fZero = TRUE;
		    fZeroSeen = TRUE;
		    pwsz = L"::";
		}
		else
		{
		    wprintf(L"%ws%04x", pwsz, us);
		    pwsz =  L":";
		    fZero = FALSE;
		}
	    }
	    if (fZero)
	    {
		wprintf(L"%ws", pwsz);
		CSASSERT(0 == lstrcmp(pwsz, L"::"));
	    }
	}
    }
    if (CB_IPV4ADDRESS == cb)
    {
	wprintf(
	    L"%u.%u.%u.%u",
	    pb[0],
	    pb[1],
	    pb[2],
	    pb[3]);
    }
    wprintf(wszNewLine);
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DumpAltName(
    IN WCHAR const *pwszPad,
    IN DWORD dwSubtreeIndex,
    IN BYTE const *pbExtension,
    IN DWORD cbExtension)
{
    HRESULT hr;
    BSTR strExtension = NULL;
    BSTR strObjId = NULL;
    BSTR strName = NULL;
    ICertEncodeAltName *pAltName = NULL;
    CRYPT_DATA_BLOB *pBlob = NULL;
    LONG Count;
    LONG Choice;
    LONG i;
    DWORD cb;

    hr = CoCreateInstance(
		    CLSID_CCertEncodeAltName,
		    NULL,               // pUnkOuter
		    CLSCTX_INPROC_SERVER,
		    IID_ICertEncodeAltName,
		    (VOID **) &pAltName);
    _JumpIfError(hr, error, "CoCreateInstance");

    if (!ConvertWszToBstr(
		    &strExtension,
		    (WCHAR const *) pbExtension,
		    cbExtension))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    hr = pAltName->Decode(strExtension);
    _JumpIfError(hr, error, "Decode");

    hr = pAltName->GetNameCount(&Count);
    _JumpIfError(hr, error, "GetNameCount");

    if (MAXDWORD == dwSubtreeIndex)
    {
	wprintf(pwszPad);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_ALTNAMECOUNT), // "AltName: %u entries:"
	    Count);
	wprintf(wszNewLine);
    }

    for (i = 0; i < Count; i++)
    {
	BOOL fHex = FALSE;
	BOOL fNameBlob = FALSE;

	hr = pAltName->GetNameChoice(i, &Choice);
	_JumpIfError(hr, error, "GetNameChoice");

	if (NULL != strName)
	{
	    SysFreeString(strName);
	    strName = NULL;
	}
	hr = pAltName->GetName(i, &strName);
	_JumpIfError(hr, error, "GetName");

	myRegisterMemAlloc(strName, -1, CSM_SYSALLOC);

	wprintf(pwszPad);
	if (MAXDWORD == dwSubtreeIndex)
	{
	    wprintf(
		L"%ws[%u] ",
		myLoadResourceString(IDS_ALTNAME),	// "AltName"
		i);
	}
	wprintf(L"%ws:", wszAltNameChoice(Choice));
	if (CERT_ALT_NAME_DIRECTORY_NAME == Choice)
	{
	    fNameBlob = TRUE;		// Name is encoded as a blob
	}
	else if (CERT_ALT_NAME_IP_ADDRESS == Choice)
	{
	    BYTE const *pb = (BYTE const *) strName;

	    cb = SysStringByteLen(strName);

	    wprintf(wszNewLine);
	    if (2 * CB_IPV6ADDRESS == cb || 2 * CB_IPV4ADDRESS == cb)
	    {
		DumpIPAddress(pwszPad, IDS_IPADDRESS, pb, cb / 2);
		DumpIPAddress(pwszPad, IDS_MASK, &pb[cb / 2], cb / 2);
	    }
	    else
	    {
		fHex = TRUE;
	    }
	}
	else if (CERT_ALT_NAME_OTHER_NAME == Choice)
	{
	    if (NULL != strObjId)
	    {
		SysFreeString(strObjId);
		strObjId = NULL;
	    }
	    hr = pAltName->GetName(EAN_NAMEOBJECTID | i, &strObjId);
	    _JumpIfError(hr, error, "GetName");

	    myRegisterMemAlloc(strObjId, -1, CSM_SYSALLOC);

	    wprintf(L" ");
	    cuDumpOIDAndDescription(strObjId);
	    wprintf(L": ");

	    if (0 == lstrcmp(TEXT(szOID_NT_PRINCIPAL_NAME), strObjId) ||
		BER_UTF8_STRING == *(BYTE const *) strName ||
		BER_UNICODE_STRING == *(BYTE const *) strName)
	    {
		CERT_NAME_VALUE *pNameValueA = NULL;
		CERT_NAME_VALUE *pNameValueW = NULL;

		if (!myDecodeObject(
				X509_ASN_ENCODING,
				X509_ANY_STRING,
				(BYTE *) strName,
				SysStringByteLen(strName),
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pNameValueA,
				&cb))
		{
		    hr = myHLastError();
		    _PrintError(hr, "myDecodeObject");
		    CSASSERT(NULL == pNameValueA);
		}

		if (!myDecodeObject(
				X509_ASN_ENCODING,
				X509_UNICODE_ANY_STRING,
				(BYTE *) strName,
				SysStringByteLen(strName),
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pNameValueW,
				&cb))
		{
		    hr = myHLastError();
		    _PrintError(hr, "myDecodeObject");
		    CSASSERT(NULL == pNameValueW);
		}

		if (NULL != pNameValueA && NULL != pNameValueW)
		{
		    wprintf(wszNewLine);
		    wprintf(L"%ws  ", pwszPad);
		    hr = cuDisplayCertNameValue(
					NULL,
					NULL, // wszAltNameChoice(Choice),
					pNameValueW->dwValueType,
					&pNameValueW->Value,
					&pNameValueA->Value);
		    _PrintIfError(hr, "cuDisplayCertNameValue");
		    wprintf(wszNewLine);
		}
		if (NULL != pNameValueA)
		{
		    LocalFree(pNameValueA);
		}
		if (NULL != pNameValueW)
		{
		    LocalFree(pNameValueW);
		}
	    }
	    else
	    if (0 == lstrcmp(TEXT(szOID_NTDS_REPLICATION), strObjId) ||
		BER_OCTET_STRING == *(BYTE const *) strName)
	    {
		fHex = TRUE;
		if (myDecodeObject(
				X509_ASN_ENCODING,
				X509_OCTET_STRING,
				(BYTE const *) strName,
				SysStringByteLen(strName),
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pBlob,
				&cb))
		{
		    if (0 == lstrcmp(TEXT(szOID_NTDS_REPLICATION), strObjId) &&
			pBlob->cbData == sizeof(GUID))
		    {
			WCHAR *pwsz;

			hr = myCLSIDToWsz((CLSID const *) pBlob->pbData, &pwsz);
			if (S_OK == hr)
			{
			    wprintf(L"\n%ws  %ws\n", pwszPad, pwsz);
			    LocalFree(pwsz);
			    fHex = FALSE;
			}
		    }
		    if (fHex)
		    {
			wprintf(wszNewLine);
			DumpHex(
			    DH_NOTABPREFIX | 8,
			    pBlob->pbData,
			    pBlob->cbData);
			wprintf(wszNewLine);
			fHex = FALSE;
		    }
		}
	    }
	    else
	    {
		fHex = TRUE;
	    }
	}
	else
	{
	    wprintf(L" \"%ws\"\n", strName);
	}
	if (fNameBlob)
	{
	    CERT_NAME_BLOB Name;

	    Name.pbData = (BYTE *) strName;
	    Name.cbData = SysStringByteLen(strName);

	    hr = cuDisplayCertName(
			    TRUE,
			    NULL,
			    NULL,	// wszAltNameChoice(Choice)
			    g_wszPad8,
			    &Name,
			    NULL);
	    _PrintIfError(hr, "cuDisplayCertName(DirectoryName)");
	    if (S_OK != hr)
	    {
		fHex = TRUE;
	    }
	}
	if (fHex)
	{
	    wprintf(wszNewLine);
	    DumpHex(
		DH_NOTABPREFIX | 8,
		(BYTE *) strName,
		SysStringByteLen(strName));
	    wprintf(wszNewLine);
	}
    }

error:
    if (NULL != pBlob)
    {
        LocalFree(pBlob);
    }
    if (NULL != strObjId)
    {
        SysFreeString(strObjId);
    }
    if (NULL != strName)
    {
        SysFreeString(strName);
    }
    if (NULL != strExtension)
    {
        SysFreeString(strExtension);
    }
    if (NULL != pAltName)
    {
        pAltName->Release();
    }
    return(hr);
}


HRESULT
DumpGeneralSubTree(
    IN UINT idsMsg,
    IN DWORD cSubtree,
    IN CERT_GENERAL_SUBTREE const *rgSubtree)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD i;
    CERT_ALT_NAME_INFO cani;
    BYTE *pb = NULL;
    DWORD cb;
    
    wprintf(L"  %ws:\n", myLoadResourceString(idsMsg));
    hr = S_OK;
    for (i = 0; i < cSubtree; i++)
    {
	wprintf(
	    L"    %ws[%u]: " wszLPAREN L"%u...",
	    myLoadResourceString(IDS_SUBTREE),
	    i,
	    rgSubtree[i].dwMinimum);
	wprintf(
	    rgSubtree[i].fMaximum? L"%u" : L"Max",
	    rgSubtree[i].dwMaximum);
	wprintf(wszRPAREN L"\n");

	cani.cAltEntry = 1;
	cani.rgAltEntry = const_cast<CERT_ALT_NAME_ENTRY *>(&rgSubtree[i].Base);

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_ALTERNATE_NAME,
			&cani,
			0,
			CERTLIB_USE_LOCALALLOC,
			&pb,               // pbEncoded
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
	hr2 = DumpAltName(g_wszPad6, i, pb, cb);
	_PrintIfError(hr2, "DumpAltName");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
	LocalFree(pb);
	pb = NULL;
    }
    _JumpIfError(hr, error, "DumpAltName");

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
DumpNameConstraints(
    IN BYTE const *pbExtension,
    IN DWORD cbExtension)
{
    HRESULT hr;
    HRESULT hr2;
    CERT_NAME_CONSTRAINTS_INFO *pnci = NULL;
    DWORD cb;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_NAME_CONSTRAINTS,
		    pbExtension,
		    cbExtension,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pnci,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    hr = DumpGeneralSubTree(
			IDS_PERMITTED,
			pnci->cPermittedSubtree,
			pnci->rgPermittedSubtree);
    _PrintIfError(hr, "DumpGeneralSubTree");

    hr2 = DumpGeneralSubTree(
			IDS_EXCLUDED,
			pnci->cExcludedSubtree,
			pnci->rgExcludedSubtree);
    _PrintIfError(hr2, "DumpGeneralSubTree");
    if (S_OK == hr)
    {
	hr = hr2;
    }
    _JumpIfError(hr, error, "DumpGeneralSubTree");

error:
    if (NULL != pnci)
    {
	LocalFree(pnci);
    }
    return(hr);
}


HRESULT
DumpOctetHash(
    IN WCHAR const *pwszPad,
    IN UINT idsDescription,
    OPTIONAL IN WCHAR const *pwszCertutil,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OPTIONAL OUT BYTE *pbOut,
    OPTIONAL IN OUT DWORD *pcbOut)
{
    HRESULT hr;
    CRYPT_DATA_BLOB aBlob[1 + BLOB_ROUND(CBMAX_CRYPT_HASH_LEN)];
    DWORD cb;
    BSTR strHash = NULL;

    cb = sizeof(aBlob);
    if (CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			pbIn,
			cbIn,
			0,
			aBlob,
			&cb))
    {
	if (NULL == pbOut)
	{
	    wprintf(
		L"%ws%ws%ws:\n",
		pwszPad,
		0 != idsDescription?
		    myLoadResourceString(idsDescription) : g_wszEmpty,
		NULL != pwszCertutil? pwszCertutil : g_wszEmpty);

	    hr = MultiByteIntegerToBstr(
				TRUE,
				aBlob[0].cbData,
				aBlob[0].pbData,
				&strHash);
	    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

	    wprintf(L"        %ws\n", strHash);
	}
	else
	{
	    if (NULL == pcbOut)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "NULL parm");
	    }
	    cb = *pcbOut;
	    *pcbOut = aBlob[0].cbData;
	    CopyMemory(pbOut, aBlob[0].pbData, min(cb, aBlob[0].cbData));

	    if (cb < aBlob[0].cbData)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
		_JumpError(hr, error, "buffer too small");
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != strHash)
    {
        SysFreeString(strHash);
    }
    return(hr);
}


HRESULT
DumpHash(
    OPTIONAL IN WCHAR const *pwszPrefix,
    OPTIONAL IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszHashNamePrefix,
    IN WCHAR const *pwszHashName,
    IN BYTE const *pbHash,
    IN DWORD cbHash)
{
    HRESULT hr;
    BSTR strHash = NULL;
    WCHAR *pwsz = NULL;
    

    if (NULL != pbHash)
    {
	hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strHash);
	_JumpIfError(hr, error, "MultiByteIntegerToBstr");

	if (NULL != pwszPrefix)
	{
	    wprintf(pwszPrefix);
	}
	if (0 != idMessage)
	{
	    if (NULL != pwszHashNamePrefix)
	    {
		DWORD cwc;
		
		cwc = wcslen(pwszHashNamePrefix) + 1 + wcslen(pwszHashName);
		pwsz = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwc + 1) * sizeof(WCHAR));
		if (NULL == pwsz)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		wcscpy(pwsz, pwszHashNamePrefix);
		wcscat(pwsz, L" ");
		wcscat(pwsz, pwszHashName);
		CSASSERT(wcslen(pwsz) == cwc);
		pwszHashName = pwsz;
	    }
	    wprintf(myLoadResourceString(idMessage), pwszHashName, strHash);
	}
	else
	{
	    wprintf(strHash);
	}
	wprintf(wszNewLine);

	if (1 < g_fVerbose)
	{
	    DumpHex(DH_NOTABPREFIX | 4, pbHash, cbHash);
	    wprintf(wszNewLine);
	}
    }
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    if (NULL != strHash)
    {
        SysFreeString(strHash);
    }
    return(hr);
}


#define FOT_EXTENSION	0
#define FOT_ATTRIBUTE	1
#define FOT_PROPERTY	2


BOOL
DumpFormattedObject(
    IN char const *pszObjId,
    IN DWORD Type,		// FOT_*
    IN BYTE const *pbObject,
    IN DWORD cbObject)
{
    HRESULT hr;
    BOOL fDisplayed = FALSE;
    WCHAR *pwszFormatted = NULL;
    DWORD cbFormatted;
    CRYPT_DATA_BLOB *pBlobProp = NULL;
    DWORD cbBlobProp;
    WCHAR const *pwszPrefix0 = g_wszPad4;
    WCHAR const *pwszPrefix1 = g_wszPad8;
    WCHAR const *pwszDescriptiveName;

    // format the object using the installed formatting function

    hr = S_OK;
    if (!CryptFormatObject(
		    X509_ASN_ENCODING,
		    0,
		    CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
		    NULL,
		    pszObjId,
		    pbObject,
		    cbObject,
		    NULL,
		    &cbFormatted))
    {
	hr = myHLastError();
	_PrintErrorStr2(hr, pszObjId, L"CryptFormatObject", hr);
	if (S_OK == hr)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}
    }

    if (S_OK != hr)
    {
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr &&
	    CRYPT_E_ASN1_BADTAG != hr &&
	    CRYPT_E_ASN1_CORRUPT != hr)
	{
	    _JumpError(hr, error, "CryptFormatObject");
	}
	if (FOT_PROPERTY == Type)
	{
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_OCTET_STRING,
			    pbObject,
			    cbObject,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pBlobProp,
			    &cbBlobProp))
	    {
		hr = myHLastError();
		_PrintError(hr, "myDecodeObject");
	    }
	    else
	    {
		hr = cuDumpFormattedProperty(
				    MAXDWORD,
				    pszObjId,
				    pBlobProp->pbData,
				    pBlobProp->cbData);
		_PrintIfError(hr, "cuDumpFormattedProperty");
		if (S_OK == hr)
		{
		    fDisplayed = TRUE;
		}
	    }
	}
	if (S_OK != hr && !g_fQuiet)
	{
	    PrintStringWithPrefix(
		pwszPrefix0,
		myLoadResourceString(FOT_ATTRIBUTE == Type?
		    IDS_UNKNOWN_ATTRIBUTE : // "Unknown Attribute type"
		    (FOT_EXTENSION == Type?
			IDS_UNKNOWN_EXTENSION : // "Unknown Extension type"
			IDS_UNKNOWN_PROPERTY))); // "Unknown Property"
	    wprintf(wszNewLine);
	}
    }
    else
    {
	pwszFormatted = (WCHAR *) LocalAlloc(LMEM_FIXED, cbFormatted);
	if (NULL == pwszFormatted)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	if (!CryptFormatObject(
			X509_ASN_ENCODING,
			0,
			CRYPT_FORMAT_STR_MULTI_LINE | CRYPT_FORMAT_STR_NO_HEX,
			NULL,
			pszObjId,
			pbObject,
			cbObject,
			pwszFormatted,
			&cbFormatted))
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, pszObjId, L"CryptFormatObject");
	}
	PrintStringWithPrefix(g_fQuiet? g_wszEmpty : pwszPrefix1, pwszFormatted);
	fDisplayed = TRUE;
    }

    if (g_fVerbose)
    {
	if (0 == strcmp(szOID_SUBJECT_ALT_NAME, pszObjId) ||
	    0 == strcmp(szOID_SUBJECT_ALT_NAME2, pszObjId) ||
	    0 == strcmp(szOID_ISSUER_ALT_NAME, pszObjId) ||
	    0 == strcmp(szOID_ISSUER_ALT_NAME2, pszObjId))
	{
	    DumpAltName(g_wszPad4, MAXDWORD, pbObject, cbObject);
	}
	else
	if (0 == strcmp(szOID_NAME_CONSTRAINTS, pszObjId))
	{
	    DumpNameConstraints(pbObject, cbObject);
	}
    }

error:
    if (NULL != pBlobProp)
    {
	LocalFree(pBlobProp);
    }
    if (NULL != pwszFormatted)
    {
	LocalFree(pwszFormatted);
    }
    return(fDisplayed);
}


HRESULT
cuDumpUsage(
    OPTIONAL IN WCHAR const *pwszPrefix,
    IN DWORD idMessage,
    IN CTL_USAGE const *pUsage)
{
    HRESULT hr;
    DWORD i;

    if (NULL == pwszPrefix)
    {
	pwszPrefix = L"";
    }
    wprintf(L"%ws", pwszPrefix);
    wprintf(myLoadResourceString(idMessage));
    wprintf(L" %u\n", pUsage->cUsageIdentifier);
    for (i = 0; i < pUsage->cUsageIdentifier; i++)
    {
	wprintf(
	    L"%ws%ws[%d] ",
	    pwszPrefix,
	    g_wszPad2,
	    i);
	cuDumpOIDAndDescriptionA(pUsage->rgpszUsageIdentifier[i]);
	wprintf(wszNewLine);
    }
    hr = S_OK;

//error:
    return(hr);
}

#ifndef XENROLL_PASS_THRU_PROP_ID
#define XENROLL_PASS_THRU_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x100)
#endif

#ifndef XENROLL_RENEWAL_CERTIFICATE_PROP_ID
#define XENROLL_RENEWAL_CERTIFICATE_PROP_ID (CERT_FIRST_USER_PROP_ID + 0x101)
#endif


typedef struct _DUMPPROP
{
    DWORD dwPropId;
    WCHAR const *pwszDescription;
} DUMPPROP;

#define _DFPROP(def)		{ (def), L#def }

DUMPPROP s_apwszPropIds[] = {
    _DFPROP(CERT_KEY_PROV_HANDLE_PROP_ID),
    _DFPROP(CERT_KEY_PROV_INFO_PROP_ID),
    _DFPROP(CERT_SHA1_HASH_PROP_ID),
    _DFPROP(CERT_MD5_HASH_PROP_ID),
    _DFPROP(CERT_KEY_CONTEXT_PROP_ID),
    _DFPROP(CERT_KEY_SPEC_PROP_ID),
    _DFPROP(CERT_IE30_RESERVED_PROP_ID),
    _DFPROP(CERT_PUBKEY_HASH_RESERVED_PROP_ID),
    _DFPROP(CERT_ENHKEY_USAGE_PROP_ID),
    _DFPROP(CERT_NEXT_UPDATE_LOCATION_PROP_ID),
    _DFPROP(CERT_FRIENDLY_NAME_PROP_ID),
    _DFPROP(CERT_PVK_FILE_PROP_ID),
    _DFPROP(CERT_DESCRIPTION_PROP_ID),
    _DFPROP(CERT_ACCESS_STATE_PROP_ID),
    _DFPROP(CERT_SIGNATURE_HASH_PROP_ID),
    _DFPROP(CERT_SMART_CARD_DATA_PROP_ID),
    _DFPROP(CERT_EFS_PROP_ID),
    _DFPROP(CERT_FORTEZZA_DATA_PROP_ID),
    _DFPROP(CERT_ARCHIVED_PROP_ID),
    _DFPROP(CERT_KEY_IDENTIFIER_PROP_ID),
    _DFPROP(CERT_AUTO_ENROLL_PROP_ID),
    _DFPROP(CERT_PUBKEY_ALG_PARA_PROP_ID),
    _DFPROP(CERT_CROSS_CERT_DIST_POINTS_PROP_ID),
    _DFPROP(CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID),
    _DFPROP(CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID),
    _DFPROP(CERT_ENROLLMENT_PROP_ID),
    _DFPROP(CERT_DATE_STAMP_PROP_ID),
    _DFPROP(CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID),
    _DFPROP(CERT_SUBJECT_NAME_MD5_HASH_PROP_ID),
    _DFPROP(CERT_EXTENDED_ERROR_INFO_PROP_ID),
    _DFPROP(XENROLL_PASS_THRU_PROP_ID),
    _DFPROP(XENROLL_RENEWAL_CERTIFICATE_PROP_ID),
};


HRESULT
cuDecodeBool(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BOOL *pfWriteToDS)
{
    HRESULT hr;

    hr = E_INVALIDARG;
    if (3 == cbIn && BER_BOOL == pbIn[0] && 1 == pbIn[1])
    {
	*pfWriteToDS = FALSE;
	if (0 != pbIn[2])
	{
	    if (0xff != pbIn[2])
	    {
		_PrintError(hr, "BER_BOOL");
	    }
	    *pfWriteToDS = TRUE;
	}
	hr = S_OK;
    }
    return(hr);
}


HRESULT
DecodeRequestFlags(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BOOL *pfWriteToCSP,
    OUT BOOL *pfWriteToDS,
    OUT DWORD *popenFlags)
{
    HRESULT hr;
    CRYPT_SEQUENCE_OF_ANY *pSeq = NULL;
    DWORD cb;

    hr = cuDecodeSequence(pbIn, cbIn, 3, &pSeq);
    _JumpIfError(hr, error, "cuDecodeSequence");

    hr = cuDecodeBool(
		pSeq->rgValue[0].pbData,
		pSeq->rgValue[0].cbData,
		pfWriteToCSP);
    _JumpIfError(hr, error, "cuDecodeBool");

    hr = cuDecodeBool(
		pSeq->rgValue[1].pbData,
		pSeq->rgValue[1].cbData,
		pfWriteToDS);
    _JumpIfError(hr, error, "cuDecodeBool");

    cb = sizeof(*popenFlags);
    *popenFlags = 0;
    if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			pSeq->rgValue[2].pbData,
			pSeq->rgValue[2].cbData,
			0,
			popenFlags,
			&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptDecodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pSeq)
    {
	LocalFree(pSeq);
    }
    return(hr);
}


HRESULT
cuDumpFormattedProperty(
    IN DWORD dwPropId,
    OPTIONAL IN char const *pszObjId,
    IN BYTE const *pb,
    IN DWORD cb)
{
    HRESULT hr;
    char szObjId[sizeof(szOID_CERT_PROP_ID_PREFIX) + 20];
    WCHAR const *pwszDescriptiveName;
    BOOL fDisplayed;
    DWORD i;

    CSASSERT(NULL == pszObjId || MAXDWORD == dwPropId);

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    if (NULL != pszObjId)
    {
	char const *psz;
	
	if (0 != strncmp(
		    szOID_CERT_PROP_ID_PREFIX,
		    pszObjId,
		    ARRAYSIZE(szOID_CERT_PROP_ID_PREFIX) - 1))
	{
	    _JumpError(hr, error, "Not a property ObjId");
	}
	psz = &pszObjId[ARRAYSIZE(szOID_CERT_PROP_ID_PREFIX) - 1];
	dwPropId = atol(psz);
	while ('\0' != *psz)
	{
	    if (!isdigit(*psz))
	    {
		_JumpError(hr, error, "Bad property ObjId suffix");
	    }
	    psz++;
	}
    }

    wprintf(wszNewLine);
    for (i = 0; ; i++)
    {
	if (i >= ARRAYSIZE(s_apwszPropIds))
	{
	    pwszDescriptiveName = myLoadResourceString(IDS_UNKNOWN_PROPERTY); // "Unknown Property"
	    break;
	}
	if (s_apwszPropIds[i].dwPropId == dwPropId)
	{
	    pwszDescriptiveName = s_apwszPropIds[i].pwszDescription;
	    break;
	}
    }
    wprintf(L"  %ws", pwszDescriptiveName);
    if (NULL != pszObjId)
    {
	wprintf(L"(%hs)", pszObjId);
    }
    else
    {
	wprintf(L"(%u)", dwPropId);
    }

    sprintf(szObjId, "%hs%u", szOID_CERT_PROP_ID_PREFIX, dwPropId);
    pwszDescriptiveName = cuGetOIDNameA(szObjId);
    if (NULL != pwszDescriptiveName && L'\0' != *pwszDescriptiveName)
    {
	wprintf(L" %ws", pwszDescriptiveName);
    }
    wprintf(L":\n");
#if 0
    fDisplayed = DumpFormattedObject(szObjId, FOT_PROPERTY, pb, cb);
#else
    fDisplayed = FALSE;
#endif

    if (!fDisplayed)
    {
	if (IS_CERT_HASH_PROP_ID(dwPropId) ||
	    IS_PUBKEY_HASH_PROP_ID(dwPropId) ||
	    IS_CHAIN_HASH_PROP_ID(dwPropId) ||
	    CERT_KEY_IDENTIFIER_PROP_ID == dwPropId)
	{
	    wprintf(g_wszPad4);

	    hr = DumpHash(NULL, 0, NULL, g_wszEmpty, pb, cb);
	    _JumpIfError(hr, error, "DumpHash");

	    fDisplayed = TRUE;
	}
	else
	if (CERT_FRIENDLY_NAME_PROP_ID == dwPropId ||
	    CERT_DESCRIPTION_PROP_ID == dwPropId)
	{
	    wprintf(L"%ws%ws\n", g_wszPad4, pb);
	    fDisplayed = TRUE;
	}
	else
	if (CERT_KEY_PROV_INFO_PROP_ID == dwPropId)
	{
	    hr = cuDumpCertKeyProviderInfo(
				    g_wszPad4,
				    NULL,
				    (CRYPT_KEY_PROV_INFO *) pb,
				    NULL);
	    _JumpIfError(hr, error, "cuDumpCertKeyProviderInfo");

	    fDisplayed = TRUE;
	}
	else
	if (CERT_AUTO_ENROLL_PROP_ID == dwPropId)
	{
            wprintf(
		L"%ws%ws = %.*ws\n",
		g_wszPad4,
		myLoadResourceString(IDS_PROP_AUTOENROLL), // "AutoEnroll Property"
		cb / sizeof(WCHAR),
		pb);
	    fDisplayed = TRUE;
	}
        else
        if (CERT_ENROLLMENT_PROP_ID == dwPropId)
        {
            BYTE const *pbTmp = pb;
            DWORD cbTmp = cb;
	    DWORD cwc;

	    if (sizeof(LONG) <= cbTmp)
	    {
		// RequestId:

		wprintf(
		    L"%ws%ws = %u\n",
		    g_wszPad4,
		    myLoadResourceString(IDS_REQUESTID), // "RequestId"
		    *(LONG *) pbTmp);
		pbTmp += sizeof(LONG);
		cbTmp -= sizeof(LONG);

		if (sizeof(cwc) <= cbTmp)
		{
		    // CA DNS name:

		    cwc = *(DWORD *) pbTmp;
		    pbTmp += sizeof(cwc); // skip count of next field
		    cbTmp -= sizeof(cwc);

		    wprintf(
			L"%ws%ws = %.*ws\\",
			g_wszPad4,
			myLoadResourceString(IDS_CADNSNAME), // "Authority"
			min(cwc, cbTmp / sizeof(WCHAR)),
			pbTmp);
		    pbTmp += cwc * sizeof(WCHAR);
		    cbTmp -= cwc * sizeof(WCHAR);
     
		    if (sizeof(cwc) <= cbTmp)
		    {
			// CA name:

			cwc = *(DWORD UNALIGNED *) pbTmp;
			pbTmp += sizeof(cwc); // skip count of next field
			cbTmp -= sizeof(cwc);

			wprintf(
			    L"%.*ws\n",
			    min(cwc, cbTmp / sizeof(WCHAR)),
			    pbTmp);
			pbTmp += cwc * sizeof(WCHAR);
			cbTmp -= cwc * sizeof(WCHAR);

			if (sizeof(cwc) <= cbTmp)
			{
			    // friendly name:

			    cwc = *(DWORD UNALIGNED *) pbTmp;
			    pbTmp += sizeof(cwc); // skip count of next field
			    cbTmp -= sizeof(cwc);

			    wprintf(
				L"%ws%ws = %.*ws\n",
				g_wszPad4,
				myLoadResourceString(IDS_FRIENDLYNAME), // "Friendly Name"
				min(cwc, cbTmp / sizeof(WCHAR)),
				pbTmp);
			    pbTmp += cwc * sizeof(WCHAR);
			    cbTmp -= cwc * sizeof(WCHAR);
		     
			    fDisplayed = TRUE;
			}
		    }
		}
	    }
        }        

	else
	if (CERT_CTL_USAGE_PROP_ID == dwPropId)
	{
	    CTL_USAGE *pUsage;

	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_ENHANCED_KEY_USAGE,
			    pb,
			    cb,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pUsage,
			    &cb))
	    {
		hr = myHLastError();
		_PrintError(hr, "myDecodeObject");
	    }
	    else
	    {
		hr = cuDumpUsage(g_wszPad2, IDS_USAGEENTRIES, pUsage);
		_JumpIfError(hr, error, "cuDumpUsage");

		fDisplayed = TRUE;
	    }
	}
	else
	if (CERT_PUBKEY_ALG_PARA_PROP_ID == dwPropId)
	{
	    CERT_DSS_PARAMETERS *pDssParms;

	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_DSS_PARAMETERS,
			    pb,
			    cb,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pDssParms,
			    &cb))
	    {
		hr = myHLastError();
		_PrintError(hr, "myDecodeObject");
	    }
	    else
	    {

		wprintf(
		    myLoadResourceString(IDS_FORMAT_DSSKEY_LENGTH), // "DSS Key Length: %u bits"
		    pDssParms->p.cbData * 8);

		wprintf(L"  DSS P:\n");
		DumpHex(
		    DH_NOADDRESS | DH_NOTABPREFIX | 4,
		    pDssParms->p.pbData,
		    pDssParms->p.cbData);

		wprintf(L"  DSS Q:\n");
		DumpHex(
		    DH_NOADDRESS | DH_NOTABPREFIX | 4,
		    pDssParms->q.pbData,
		    pDssParms->q.cbData);

		wprintf(L"  DSS G:\n");
		DumpHex(
		    DH_NOADDRESS | DH_NOTABPREFIX | 4,
		    pDssParms->g.pbData,
		    pDssParms->g.cbData);

		LocalFree(pDssParms);
		fDisplayed = TRUE;
	    }
	}
        else
        if (XENROLL_PASS_THRU_PROP_ID == dwPropId)
        {
	    BOOL fWriteToCSP;
	    BOOL fWriteToDS;
	    DWORD openFlags;
	    hr = DecodeRequestFlags(
				pb,
				cb,
				&fWriteToCSP,
				&fWriteToDS,
				&openFlags);
	    _PrintIfError(hr, "DecodeRequestFlags");
	    if (S_OK == hr)
	    {
		wprintf(L"    fWriteToCSP: %u\n", fWriteToCSP);
		wprintf(L"    fWriteToDS: %u\n", fWriteToDS);
		wprintf(L"    openFlags: 0x%x\n", openFlags);
		fDisplayed = TRUE;
	    }
	}
        else
	if (XENROLL_RENEWAL_CERTIFICATE_PROP_ID == dwPropId)
        {
	    wprintf(myLoadResourceString(IDS_RENEWAL_CERT)); // "Renewal Certificate:"
	    wprintf(wszNewLine);

	    hr = cuDumpAsnBinary(pb, cb, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");
	}
    }
    if (!fDisplayed || g_fVerbose)
    {
	DumpHex(DH_NOADDRESS | DH_NOTABPREFIX | 4, pb, cb);
    }
    hr = S_OK;

error:
    return(hr);
}


//+-------------------------------------------------------------------------
// cuDecodeObjId -- decode an ASN.1 encoded ObjectId
//
// Construct an ASN.1 encoded PKCS_ATTRIBUTE with an array of empty values,
// to trick CryptDecodeObject into decoding the passed in encoded Object Id.
//--------------------------------------------------------------------------

HRESULT
cuDecodeObjId(
    IN BYTE const *pbData,
    IN DWORD cbData,
    OUT char **ppszObjId)
{
    HRESULT hr;
    CRYPT_ATTRIBUTE *pAttr = NULL;
    BYTE *pbAlloc = NULL;
    DWORD cbAlloc;
    BYTE *pb;
    DWORD cb;

    //DumpHex(DH_NOTABPREFIX | 2, pbData, cbData);
    cbAlloc = 2 + cbData + 2;
    pbAlloc = (BYTE *) LocalAlloc(LMEM_FIXED, cbAlloc);
    if (NULL == pbAlloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pb = pbAlloc;
    *pb++ = BER_SEQUENCE;		// PKCS_ATTRIBUTE sequence
    CSASSERT(0x7f >= cbData + 2);
    *pb++ = (BYTE ) (cbData + 2);	// overall length
    CopyMemory(pb, pbData, cbData);	// copy encoded Object Id
    pb += cbData;
    *pb++ = BER_SET;			// empty array of attribute values
    *pb = 0;				// zero length array of values

    //DumpHex(DH_NOTABPREFIX | 2, pbAlloc, cbAlloc);

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    PKCS_ATTRIBUTE,
		    pbAlloc,
		    cbAlloc,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pAttr,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    hr = myDupStringA(pAttr->pszObjId, ppszObjId);
    _JumpIfError(hr, error, "myDupStringA");

error:
    if (NULL != pbAlloc)
    {
	LocalFree(pbAlloc);
    }
    if (NULL != pAttr)
    {
	LocalFree(pAttr);
    }
    return(hr);
}


//+-------------------------------------------------------------------------
// cuEncodeObjId -- decode an ASN.1 encoded ObjectId
//
// Construct an ASN.1 encoded PKCS_ATTRIBUTE with an array of empty values,
// to trick CryptEncodeObject into decoding the passed in encoded Object Id.
//--------------------------------------------------------------------------

HRESULT
cuEncodeObjId(
    IN char const *pszObjId,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    CRYPT_ATTRIBUTE Attr;
    BYTE *pbAttr = NULL;
    DWORD cbAttr;

    *ppbData = NULL;

    ZeroMemory(&Attr, sizeof(Attr));
    Attr.pszObjId = const_cast<char *>(pszObjId);

    if (!myEncodeObject(
                    X509_ASN_ENCODING,
                    PKCS_ATTRIBUTE,
                    &Attr,
                    0,
                    CERTLIB_USE_LOCALALLOC,
                    &pbAttr,               // pbEncoded
                    &cbAttr))
    {
        hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    if (cbAttr <= 2 + 2 + 2 ||
	BER_SEQUENCE != pbAttr[0] ||
	cbAttr != pbAttr[1] + 2 ||
	BER_OBJECT_ID != pbAttr[2] ||
	cbAttr != pbAttr[3] + 2 + 2 + 2 ||
	BER_SET != pbAttr[cbAttr - 2] ||
	0 != pbAttr[cbAttr - 1])
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad Attr");
    }

    *pcbData = cbAttr - 4;
    *ppbData = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbData);
    if (NULL == *ppbData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppbData, &pbAttr[2], *pcbData);
    hr = S_OK;

error:
    if (NULL != pbAttr)
    {
	LocalFree(pbAttr);
    }
    return(hr);
}


// UnicodeDecode()
//
// This function is responsible for decoding unicode crypt data blobs from
// various certificate fields.  The returned WCHAR * must be freed by LocalFree
//
// Params:
//
// pBlob - IN CRYPT_DATA_BLOB to be decoded, expected UNICODE
//
// Returns:
//
// WCHAR * to decoded string, to be freed using LocalFree


HRESULT
UnicodeDecode(
    IN CRYPT_DATA_BLOB const *pBlob,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    CERT_NAME_VALUE *pName = NULL;
    DWORD cb;

    *ppwszOut = NULL;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    pBlob->pbData,
		    pBlob->cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pName,
		    &cb))
    {
	CSASSERT(NULL == pName);
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    hr = myDupString((WCHAR const *) pName->Value.pbData, ppwszOut);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pName)
    {
	LocalFree(pName);
    }
    return(hr);
}


BOOL
cuDumpFormattedExtension(
    IN WCHAR const *pwszName,
    IN BYTE const *pbObject,
    IN DWORD cbObject)
{
    HRESULT hr;
    BOOL fDisplayed = FALSE;
    char *pszObjId = NULL;
    BSTR strHash = NULL;
    WCHAR const *pwszDescriptiveName;
    DWORD cb;
    WCHAR const *pwszPad = g_fQuiet? g_wszEmpty : g_wszPad4;

    if (!ConvertWszToSz(&pszObjId, pwszName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz");
    }
    pwszDescriptiveName = cuGetOIDName(pwszName);
    if (NULL != pwszDescriptiveName && L'\0' != *pwszDescriptiveName)
    {
	PrintStringWithPrefix(pwszPad, pwszDescriptiveName);
	if (g_fQuiet)
	{
	    wprintf(L": ");
	}
	else
	{
	    wprintf(wszNewLine);
	}
    }
    if (0 == cbObject)
    {
	if (!g_fQuiet)
	{
	    wprintf(
		L"%ws%ws\n",
		g_wszPad8,
		myLoadResourceString(IDS_PROP_EMPTY)); // "EMPTY"
	}
	fDisplayed = TRUE;
    }
    else
    {
	fDisplayed = DumpFormattedObject(
				    pszObjId,
				    FOT_EXTENSION,
				    pbObject,
				    cbObject);
	if (!fDisplayed)
	{
	    if (0 == strcmp(pszObjId, szOID_CERTSRV_CA_VERSION))
	    {
		DWORD NameId;

		cb = sizeof(NameId);
		NameId = 0;
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_INTEGER,
				    pbObject,
				    cbObject,
				    0,
				    &NameId,
				    &cb))
		{
		    wprintf(
			L"%ws%ws%ws: %u.%u\n",
			pwszPad,
			myLoadResourceString(IDS_CAVERSION),
			g_wszCertUtil,
			CANAMEIDTOICERT(NameId),
			CANAMEIDTOIKEY(NameId));
		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_CERTSRV_CROSSCA_VERSION))
	    {
		DWORD CrossCAVersion;

		cb = sizeof(CrossCAVersion);
		CrossCAVersion = 0;
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_INTEGER,
				    pbObject,
				    cbObject,
				    0,
				    &CrossCAVersion,
				    &cb))
		{
		    wprintf(
			L"%ws%ws%ws: (%u-%u)\n",
			pwszPad,
			myLoadResourceString(IDS_CAVERSION),
			g_wszCertUtil,
			CROSSCAVERSIONTOSOURCE(CrossCAVersion),
			CROSSCAVERSIONTOTARGET(CrossCAVersion));
		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_CERTSRV_PREVIOUS_CERT_HASH))
	    {
		hr = DumpOctetHash(
			    pwszPad,
			    IDS_PREVIOUS_CA_CERT_HASH,
			    g_wszCertUtil,
			    pbObject,
			    cbObject,
			    NULL,
			    NULL);
		if (S_OK == hr)
		{
		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_CRL_NUMBER))
	    {
		DWORD CRLNumber;

		cb = sizeof(CRLNumber);
		CRLNumber = 0;
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_INTEGER,
				    pbObject,
				    cbObject,
				    0,
				    &CRLNumber,
				    &cb))
		{
		    wprintf(
			L"%ws%ws%ws: %u\n",
			pwszPad,
			myLoadResourceString(IDS_CRL_NUMBER),
			g_wszCertUtil,
			CRLNumber);
		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_DELTA_CRL_INDICATOR))
	    {
		DWORD CRLNumber;

		cb = sizeof(CRLNumber);
		CRLNumber = 0;
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_INTEGER,
				    pbObject,
				    cbObject,
				    0,
				    &CRLNumber,
				    &cb))
		{
		    wprintf(
			L"%ws%ws%ws: %u\n",
			pwszPad,
			myLoadResourceString(IDS_MINIMUM_BASE_CRL_NUMBER),
			g_wszCertUtil,
			CRLNumber);
		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_CRL_VIRTUAL_BASE))
	    {
		DWORD CRLNumber;

		cb = sizeof(CRLNumber);
		CRLNumber = 0;
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_INTEGER,
				    pbObject,
				    cbObject,
				    0,
				    &CRLNumber,
				    &cb))
		{
		    wprintf(
			L"%ws%ws%ws: %u\n",
			pwszPad,
			myLoadResourceString(IDS_VIRTUAL_BASE_CRL_NUMBER),
			g_wszCertUtil,
			CRLNumber);
		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_CRL_NEXT_PUBLISH) ||
		0 == strcmp(pszObjId, szOID_RSA_signingTime))
	    {
		FILETIME ft;

		cb = sizeof(ft);
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_CHOICE_OF_TIME,
				    pbObject,
				    cbObject,
				    0,
				    &ft,
				    &cb))
		{
		    wprintf(
			L"%ws%ws%ws: ",
			pwszPad,
			myLoadResourceString(
			    0 == strcmp(pszObjId, szOID_CRL_NEXT_PUBLISH)?
				IDS_CRL_NEXT_PUBLISH : IDS_SIGNING_TIME),
			g_wszCertUtil);
		    hr = cuDumpFileTime(0, NULL, &ft);
		    _JumpIfError(hr, error, "cuDumpFileTime");

		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_FRESHEST_CRL))
	    {
		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    myLoadResourceString(IDS_FRESHEST_CRL_CDP),
		    g_wszCertUtil);
		cuDumpFormattedExtension(
				TEXT(szOID_CRL_DIST_POINTS),
				pbObject,
				cbObject);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_CRL_SELF_CDP))
	    {
		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    myLoadResourceString(IDS_CRL_SELF_CDP),
		    g_wszCertUtil);
		cuDumpFormattedExtension(
				TEXT(szOID_CRL_DIST_POINTS),
				pbObject,
				cbObject);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_PKIX ".2"))
	    {
		// Exchange policy module intended to use szOID_PKIX_CA_ISSUERS,
		// but the ".48.2" suffix was instead written as ".2".
		//
		// szOID_PKIX_CA_ISSUERS was wrong anyway -- it should have
		// used szOID_AUTHORITY_INFO_ACCESS instead.

		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    myLoadResourceString(IDS_EXCHANGEAIA), // "Exchange Authority Information Access"
		    g_wszCertUtil);
		cuDumpFormattedExtension(
				TEXT(szOID_AUTHORITY_INFO_ACCESS),
				pbObject,
				cbObject);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_ISSUER_ALT_NAME))
	    {
		// Exchange policy module overloaded this OID and stored the
		// file version information for expolicy.dll and certsrv.exe.

		typedef struct _CUVER {
		    USHORT usMajor;
		    USHORT usMinor;
		    USHORT usBuild;
		    USHORT usBuildMinor;
		} CUVER;

		CUVER const *pVer;
		CRYPT_INTEGER_BLOB aBlob[1 + BLOB_ROUND(2 * sizeof(*pVer))];

		cb = sizeof(aBlob);
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_MULTI_BYTE_INTEGER,
				    pbObject,
				    cbObject,
				    0,
				    aBlob,
				    &cb))
		{
		    if (2 * sizeof(*pVer) == aBlob[0].cbData)
		    {
			wprintf(
			    L"%ws%ws%ws:\n",
			    pwszPad,
			    myLoadResourceString(IDS_EXCHANGEVERSION), // "Exchange Version"
			    g_wszCertUtil);

			pVer = (CUVER const *) aBlob[0].pbData;
			wprintf(
			    L"        expolicy.dll: %u.%u:%u.%u\n",
			    pVer->usMajor,
			    pVer->usMinor,
			    pVer->usBuild,
			    pVer->usBuildMinor);

			pVer++;
			wprintf(
			    L"        certsrv.exe: %u.%u:%u.%u\n",
			    pVer->usMajor,
			    pVer->usMinor,
			    pVer->usBuild,
			    pVer->usBuildMinor);
			fDisplayed = TRUE;
		    }
		}
		else
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptDecodeObject");
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_APPLICATION_CERT_POLICIES))
	    {
		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    myLoadResourceString(IDS_APPLICATION_CERT_POLICIES),
		    g_wszCertUtil);
		cuDumpFormattedExtension(
				TEXT(szOID_CERT_POLICIES),
				pbObject,
				cbObject);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_APPLICATION_POLICY_MAPPINGS))
	    {
		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    myLoadResourceString(IDS_APPLICATION_POLICY_MAPPINGS),
		    g_wszCertUtil);
		cuDumpFormattedExtension(
				TEXT(szOID_POLICY_MAPPINGS),
				pbObject,
				cbObject);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_APPLICATION_POLICY_CONSTRAINTS))
	    {
		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    myLoadResourceString(IDS_APPLICATION_POLICY_CONSTRAINTS),
		    g_wszCertUtil);
		cuDumpFormattedExtension(
				TEXT(szOID_POLICY_CONSTRAINTS),
				pbObject,
				cbObject);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_POLICY_MAPPINGS))
	    {
		CERT_POLICY_MAPPINGS_INFO *pPolicyMappings = NULL;
		DWORD i;

		if (!myDecodeObject(
				X509_ASN_ENCODING,
				X509_POLICY_MAPPINGS,
				pbObject,
				cbObject,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pPolicyMappings,
				&cb))
		{
		    hr = myHLastError();
		    CSASSERT(NULL == pPolicyMappings);
		    _JumpIfError(hr, error, "myDecodeObject");
		}

		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    myLoadResourceString(IDS_POLICY_MAPPINGS),
		    g_wszCertUtil);

		for (i = 0; i < pPolicyMappings->cPolicyMapping; i++)
		{
		    wprintf(g_wszPad4);
		    wprintf(myLoadResourceString(IDS_FORMAT_MAP_ARRAY_COLON), i);
		    wprintf(wszNewLine);

		    wprintf(g_wszPad8);
		    wprintf(myLoadResourceString(IDS_ISSUER_DOMAIN_POLICY));

		    cuDumpOIDAndDescriptionA(
			pPolicyMappings->rgPolicyMapping[i].pszIssuerDomainPolicy);
		    wprintf(wszNewLine);

		    wprintf(g_wszPad8);
		    wprintf(myLoadResourceString(IDS_SUBJECT_DOMAIN_POLICY));

		    cuDumpOIDAndDescriptionA(
			pPolicyMappings->rgPolicyMapping[i].pszSubjectDomainPolicy);
		    wprintf(wszNewLine);
		}

		LocalFree(pPolicyMappings);
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_POLICY_CONSTRAINTS))
	    {
		CERT_POLICY_CONSTRAINTS_INFO Constraints;

		cb = sizeof(Constraints);
		if (!CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_POLICY_CONSTRAINTS,
				    pbObject,
				    cbObject,
				    0,
				    &Constraints,
				    &cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CryptDecodeObject");
		}
		wprintf(
		    L"%ws%ws%ws:\n",
		    pwszPad,
		    myLoadResourceString(IDS_POLICY_CONSTRAINTS),
		    g_wszCertUtil);
		if (Constraints.fRequireExplicitPolicy)
		{
		    wprintf(
			L"        dwRequireExplicitPolicySkipCerts: %u\n",
			Constraints.dwRequireExplicitPolicySkipCerts);
		}
		if (Constraints.fInhibitPolicyMapping)
		{
		    wprintf(
			L"        dwInhibitPolicyMappingSkipCerts: %u\n",
			Constraints.dwInhibitPolicyMappingSkipCerts);
		}
		fDisplayed = TRUE;
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_REASON_CODE_HOLD))
	    {
		char *pszObjIdT;

		hr = cuDecodeObjId(pbObject, cbObject, &pszObjIdT);
		if (S_OK == hr)
		{
		    wprintf(pwszPad);
		    cuDumpOIDAndDescriptionA(pszObjIdT);
		    wprintf(wszNewLine);
		    LocalFree(pszObjIdT);

		    fDisplayed = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(pszObjId, szOID_VERISIGN_ONSITE_JURISDICTION_HASH))
	    {
		CRYPT_DATA_BLOB Value;
		WCHAR *pwsz;

		Value.pbData = const_cast<BYTE *>(pbObject);
		Value.cbData = cbObject;
		hr = UnicodeDecode(&Value, &pwsz);
		if (S_OK == hr)
		{
		    wprintf(L"%ws%ws\n", pwszPad, pwsz);
		    LocalFree(pwsz);
		    fDisplayed = TRUE;
		}
	    }
	}
    }

error:
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    return(fDisplayed);
}


WCHAR const * const g_apwszFieldNames[] = {
    wszCONFIG_COMMONNAME,
    wszCONFIG_ORGUNIT,
    wszCONFIG_ORGANIZATION,
    wszCONFIG_LOCALITY,
    wszCONFIG_STATE,
    wszCONFIG_COUNTRY,
    wszCONFIG_CONFIG,
    wszCONFIG_EXCHANGECERTIFICATE,
    wszCONFIG_SIGNATURECERTIFICATE,
    wszCONFIG_DESCRIPTION,
    wszCONFIG_SERVER,
    wszCONFIG_AUTHORITY,
    wszCONFIG_SANITIZEDNAME,
    wszCONFIG_SHORTNAME,
    wszCONFIG_SANITIZEDSHORTNAME,
    wszCONFIG_FLAGS,
};
#define CSTRING (sizeof(g_apwszFieldNames)/sizeof(g_apwszFieldNames[0]))

WCHAR const *g_apwszDisplayNames[CSTRING];

LONG g_amsgidDisplayNames[CSTRING] = {
    IDS_CONFIGDISPLAY_COMMONNAME_COLON,
    IDS_CONFIGDISPLAY_ORGUNIT_COLON,
    IDS_CONFIGDISPLAY_ORG_COLON,
    IDS_CONFIGDISPLAY_LOCALITY_COLON,
    IDS_CONFIGDISPLAY_STATE_COLON,
    IDS_CONFIGDISPLAY_COUNTRY_COLON,
    IDS_CONFIGDISPLAY_CONFIG_COLON,
    IDS_CONFIGDISPLAY_EXCHANGECERT_COLON,
    IDS_CONFIGDISPLAY_SIGCERT_COLON,
    IDS_CONFIGDISPLAY_DESCRIPTION_COLON,
    IDS_CONFIGDISPLAY_SERVER_COLON,
    IDS_CONFIGDISPLAY_AUTHORITY_COLON,
    IDS_CONFIGDISPLAY_SANITIZEDNAME_COLON,
    IDS_CONFIGDISPLAY_SHORTNAME_COLON,
    IDS_CONFIGDISPLAY_SANITIZEDSHORTNAME_COLON,
    IDS_CONFIGDISPLAY_FLAGS_COLON,
};


HRESULT
cuConfigDump(VOID)
{
    HRESULT hr;
    DWORD i;

    for (i = 0; i < CSTRING; i++)
    {
	g_apwszDisplayNames[i] = myLoadResourceString(g_amsgidDisplayNames[i]);
    }

    hr = ConfigDumpSetDisplayNames(
				g_apwszFieldNames,
				g_apwszDisplayNames,
				CSTRING);
    _JumpIfError(hr, error, "ConfigDumpSetDisplayNames");

    hr = ConfigDump(
		g_DispatchFlags,
		myLoadResourceString(IDS_CONFIGDISPLAY_ENTRY), // "Entry"
		myLoadResourceString(IDS_CONFIGDISPLAY_LOCAL), // "(Local)"
		g_pwszDnsName,
		g_pwszOldName);
    _JumpIfError(hr, error, "ConfigDump");

error:
    return(hr);
}


typedef HRESULT (FNDUMP)(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci);

FNDUMP dumpCert, dumpCRL, dumpRequest, dumpCMCRequest, dumpCMCResponse,
    dumpKeyGenRequest, dumpCertSequence, dumpCTL;

typedef struct _ASNFORMATS
{
    char const  *pszFormat;
    FNDUMP      *pfnDump;
    DWORD        idMessage;
    WCHAR const *pwszExtension;
} ASNFORMATS;


ASNFORMATS g_aasn[] = {
    {
	X509_CERT_TO_BE_SIGNED,
	dumpCert,
	IDS_DUMP_CERT,
	L".crt",
    },
    {
	X509_CERT_CRL_TO_BE_SIGNED,
	dumpCRL,
	IDS_DUMP_CRL,
	L".crl",
    },
    {
	X509_CERT_REQUEST_TO_BE_SIGNED,
	dumpRequest,
	IDS_DUMP_REQUEST,
	L".p10",
    },
    {
	CMC_DATA,
	dumpCMCRequest,
	IDS_DUMP_CMC,
	L".cmc",
    },
    {
	CMC_RESPONSE,
	dumpCMCResponse,
	IDS_DUMP_CMCRESPONSE,
	L".res",
    },
    {
	X509_KEYGEN_REQUEST_TO_BE_SIGNED,
	dumpKeyGenRequest,
	IDS_DUMP_KEYGEN,
	L".req",
    },
    {
	PKCS_CONTENT_INFO_SEQUENCE_OF_ANY,
	dumpCertSequence,
	IDS_DUMP_CERTSEQ,
	L".seq",
    },
    {
	PKCS_CTL,
	dumpCTL,
	IDS_DUMP_CTL,
	L".stl",
    },
};
#define CASNFORMATS (sizeof(g_aasn)/sizeof(g_aasn[0]))


HRESULT
dumpPKCS7(
    OPTIONAL IN HCERTSTORE hStoreWrapper,
    IN BYTE const *pbIn,
    IN DWORD cbIn);


typedef struct _DUMPALGID
{
    ALG_ID Algid;
    WCHAR const *pwszDescription;
} DUMPALGID;

#define _DFALGID(algid)		{ (algid), L#algid }


DUMPALGID g_adfAlgids[] =
{
    _DFALGID(CALG_MD2),
    _DFALGID(CALG_MD4),
    _DFALGID(CALG_MD5),
    //_DFALGID(CALG_SHA),	same as CALG_SHA1
    _DFALGID(CALG_SHA1),
    _DFALGID(CALG_MAC),
    _DFALGID(CALG_RSA_SIGN),
    _DFALGID(CALG_DSS_SIGN),
    _DFALGID(CALG_NO_SIGN),
    _DFALGID(CALG_RSA_KEYX),
    _DFALGID(CALG_DES),
    _DFALGID(CALG_3DES_112),
    _DFALGID(CALG_3DES),
    _DFALGID(CALG_DESX),
    _DFALGID(CALG_RC2),
    _DFALGID(CALG_RC4),
    _DFALGID(CALG_SEAL),
    _DFALGID(CALG_DH_SF),
    _DFALGID(CALG_DH_EPHEM),
    _DFALGID(CALG_AGREEDKEY_ANY),
    _DFALGID(CALG_KEA_KEYX),
    _DFALGID(CALG_HUGHES_MD5),
    _DFALGID(CALG_SKIPJACK),
    _DFALGID(CALG_TEK),
    _DFALGID(CALG_CYLINK_MEK),
    _DFALGID(CALG_SSL3_SHAMD5),
    _DFALGID(CALG_SSL3_MASTER),
    _DFALGID(CALG_SCHANNEL_MASTER_HASH),
    _DFALGID(CALG_SCHANNEL_MAC_KEY),
    _DFALGID(CALG_SCHANNEL_ENC_KEY),
    _DFALGID(CALG_PCT1_MASTER),
    _DFALGID(CALG_SSL2_MASTER),
    _DFALGID(CALG_TLS1_MASTER),
    _DFALGID(CALG_RC5),
    _DFALGID(CALG_HMAC),
    _DFALGID(CALG_TLS1PRF),
    _DFALGID(CALG_HASH_REPLACE_OWF),
    _DFALGID(CALG_AES_128),
    _DFALGID(CALG_AES_192),
    _DFALGID(CALG_AES_256),
    _DFALGID(CALG_AES),
};


DUMPALGID g_adfClass[] =
{
    _DFALGID(ALG_CLASS_ANY),
    _DFALGID(ALG_CLASS_SIGNATURE),
    _DFALGID(ALG_CLASS_MSG_ENCRYPT),
    _DFALGID(ALG_CLASS_DATA_ENCRYPT),
    _DFALGID(ALG_CLASS_HASH),
    _DFALGID(ALG_CLASS_KEY_EXCHANGE),
};


DUMPALGID g_adfType[] =
{
    _DFALGID(ALG_TYPE_ANY),
    _DFALGID(ALG_TYPE_DSS),
    _DFALGID(ALG_TYPE_RSA),
    _DFALGID(ALG_TYPE_BLOCK),
    _DFALGID(ALG_TYPE_STREAM),
    _DFALGID(ALG_TYPE_DH),
    _DFALGID(ALG_TYPE_SECURECHANNEL),
};


// Generic sub-ids

DUMPALGID g_adfSubIdAny[] =
{
    _DFALGID(ALG_SID_ANY),
};


// Some DSS sub-ids

DUMPALGID g_adfSubIdDSS[] =
{
    _DFALGID(ALG_SID_DSS_ANY),
    _DFALGID(ALG_SID_DSS_PKCS),
    _DFALGID(ALG_SID_DSS_DMS),
};


// Some RSA sub-ids

DUMPALGID g_adfSubIdRSA[] =
{
    _DFALGID(ALG_SID_RSA_ANY),
    _DFALGID(ALG_SID_RSA_PKCS),
    _DFALGID(ALG_SID_RSA_MSATWORK),
    _DFALGID(ALG_SID_RSA_ENTRUST),
    _DFALGID(ALG_SID_RSA_PGP),
};


// Block cipher sub ids

DUMPALGID g_adfSubIdBlock[] =
{
    // RC2 sub-ids

    _DFALGID(ALG_SID_RC2),

    // DES sub_ids

    _DFALGID(ALG_SID_DES),
    _DFALGID(ALG_SID_3DES),
    _DFALGID(ALG_SID_DESX),
    _DFALGID(ALG_SID_IDEA),
    _DFALGID(ALG_SID_CAST),
    _DFALGID(ALG_SID_SAFERSK64),
    _DFALGID(ALG_SID_SAFERSK128),
    _DFALGID(ALG_SID_3DES_112),
    _DFALGID(ALG_SID_CYLINK_MEK),
    _DFALGID(ALG_SID_RC5),
    _DFALGID(ALG_SID_AES_128),
    _DFALGID(ALG_SID_AES_192),
    _DFALGID(ALG_SID_AES_256),
    _DFALGID(ALG_SID_AES),

    // Fortezza sub-ids

    _DFALGID(ALG_SID_SKIPJACK),
    _DFALGID(ALG_SID_TEK),
};


// Stream cipher sub-ids

DUMPALGID g_adfSubIdStream[] =
{
    _DFALGID(ALG_SID_RC4),
    _DFALGID(ALG_SID_SEAL),
};


// Diffie-Hellman sub-ids

DUMPALGID g_adfSubIdDH[] =
{
    _DFALGID(ALG_SID_DH_SANDF),
    _DFALGID(ALG_SID_DH_EPHEM),
    _DFALGID(ALG_SID_AGREED_KEY_ANY),
    _DFALGID(ALG_SID_KEA),
};


// secure channel sub ids

DUMPALGID g_adfSubIdSecureChannel[] =
{
    _DFALGID(ALG_SID_SSL3_MASTER),
    _DFALGID(ALG_SID_SCHANNEL_MASTER_HASH),
    _DFALGID(ALG_SID_SCHANNEL_MAC_KEY),
    _DFALGID(ALG_SID_PCT1_MASTER),
    _DFALGID(ALG_SID_SSL2_MASTER),
    _DFALGID(ALG_SID_TLS1_MASTER),
    _DFALGID(ALG_SID_SCHANNEL_ENC_KEY),
};


// Hash sub ids

DUMPALGID g_adfSubIdHash[] =
{
    _DFALGID(ALG_SID_MD2),
    _DFALGID(ALG_SID_MD4),
    _DFALGID(ALG_SID_MD5),
    _DFALGID(ALG_SID_SHA1),
    _DFALGID(ALG_SID_MAC),
    _DFALGID(ALG_SID_RIPEMD),
    _DFALGID(ALG_SID_RIPEMD160),
    _DFALGID(ALG_SID_SSL3SHAMD5),
    _DFALGID(ALG_SID_HMAC),
    _DFALGID(ALG_SID_TLS1PRF),
    _DFALGID(ALG_SID_HASH_REPLACE_OWF),
};


#if 0
// KP_MODE
#define CRYPT_MODE_CBCI                 6       // ANSI CBC Interleaved
#define CRYPT_MODE_CFBP                 7       // ANSI CFB Pipelined
#define CRYPT_MODE_OFBP                 8       // ANSI OFB Pipelined
#define CRYPT_MODE_CBCOFM               9       // ANSI CBC + OF Masking
#define CRYPT_MODE_CBCOFMI              10      // ANSI CBC + OFM Interleaved
#endif


typedef struct _DUMPSUBIDMAP
{
    DWORD      dwAlgType;
    DUMPALGID *adfSubId;
    DWORD      cdfSubId;
} DUMPSUBIDMAP;

#define _DFARRAYANDSIZE(adf)	(adf), ARRAYSIZE(adf)


DUMPSUBIDMAP g_adfSubIdMap[] =
{
    { ALG_TYPE_ANY,		_DFARRAYANDSIZE(g_adfSubIdAny) },
    { ALG_TYPE_DSS,		_DFARRAYANDSIZE(g_adfSubIdDSS) },
    { ALG_TYPE_RSA,		_DFARRAYANDSIZE(g_adfSubIdRSA) },
    { ALG_TYPE_BLOCK,		_DFARRAYANDSIZE(g_adfSubIdBlock) },
    { ALG_TYPE_STREAM,		_DFARRAYANDSIZE(g_adfSubIdStream) },
    { ALG_TYPE_DH,		_DFARRAYANDSIZE(g_adfSubIdDH) },
    { ALG_TYPE_SECURECHANNEL,	_DFARRAYANDSIZE(g_adfSubIdSecureChannel) },
};


VOID
cuDumpAlgid(
    IN DWORD Algid)
{
    WCHAR const *pwsz;
    WCHAR const *pwszQuestionMarks;
    DUMPALGID *pda;
    DUMPALGID *pdaSubId;
    DWORD cdaSubId;
    DUMPSUBIDMAP *pdsm;
    DWORD AlgClass;
    DWORD AlgType;
    DWORD AlgSubId;

    pwszQuestionMarks = myLoadResourceString(IDS_QUESTIONMARKS); // "???"

    for (pda = g_adfAlgids; pda < &g_adfAlgids[ARRAYSIZE(g_adfAlgids)]; pda++)
    {
	if (Algid == pda->Algid)
	{
	    wprintf(L"    %ws\n", pda->pwszDescription);
	    break;
	}
    }

    AlgClass = GET_ALG_CLASS(Algid);
    pwsz = pwszQuestionMarks;
    for (pda = g_adfClass; pda < &g_adfClass[ARRAYSIZE(g_adfClass)]; pda++)
    {
	if (AlgClass == pda->Algid)
	{
	    pwsz = pda->pwszDescription;
	    break;
	}
    }
    wprintf(
	L"    %ws: 0x%x(%u) %ws\n",
	myLoadResourceString(IDS_ALGORITHM_CLASS),	// "Algorithm Class"
	AlgClass,
	AlgClass >> 13,
	pwsz);

    AlgType = GET_ALG_TYPE(Algid);
    pwsz = pwszQuestionMarks;
    for (pda = g_adfType; pda < &g_adfType[ARRAYSIZE(g_adfType)]; pda++)
    {
	if (AlgType == pda->Algid)
	{
	    pwsz = pda->pwszDescription;
	    break;
	}
    }
    wprintf(
	L"    %ws: 0x%x(%u) %ws\n",
	myLoadResourceString(IDS_ALGORITHM_TYPE),	// "Algorithm Type"
	AlgType,
	AlgType >> 9,
	pwsz);

    pdaSubId = g_adfSubIdAny;
    cdaSubId = ARRAYSIZE(g_adfSubIdAny);
    for (pdsm = g_adfSubIdMap; pdsm < &g_adfSubIdMap[ARRAYSIZE(g_adfSubIdMap)]; pdsm++)
    {
	if (AlgType == pdsm->dwAlgType)
	{
	    pdaSubId = pdsm->adfSubId;
	    cdaSubId = pdsm->cdfSubId;
	    break;
	}
    }
    if (ALG_CLASS_HASH == AlgClass && pdaSubId == g_adfSubIdAny)
    {
	pdaSubId = g_adfSubIdHash;
	cdaSubId = ARRAYSIZE(g_adfSubIdHash);
    }
    pwsz = pwszQuestionMarks;
    AlgSubId = GET_ALG_SID(Algid);
    for (pda = pdaSubId; pda < &pdaSubId[cdaSubId]; pda++)
    {
	if (AlgSubId == pda->Algid)
	{
	    pwsz = pda->pwszDescription;
	    break;
	}
    }
    wprintf(
	L"    %ws: 0x%x(%u) %ws\n",
	myLoadResourceString(IDS_ALGORITHM_SUBID),	// "Algorithm Sub-id"
	AlgSubId,
	AlgSubId >> 0,
	pwsz);
}


HRESULT
cuDumpPrivateKeyBlob(
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    IN BOOL fQuiet)
{
    HRESULT hr;
    PUBLICKEYSTRUC const *pkey = (PUBLICKEYSTRUC const *) pbKey;
    WCHAR const *pwszType;

    if (sizeof(*pkey) >= cbKey)
    {
	//DumpHex(DH_NOTABPREFIX | DH_PRIVATEDATA | 2, pbKey, cbKey);
	hr = CRYPT_E_ASN1_BADTAG;
	_JumpError2(hr, error, "key check", hr);
    }
    switch (pkey->bType)
    {
	case SIMPLEBLOB:	   pwszType = L"SIMPLEBLOB";	   break;
	case PUBLICKEYBLOB:	   pwszType = L"PUBLICKEYBLOB";	   break;
	case PRIVATEKEYBLOB:	   pwszType = L"PRIVATEKEYBLOB";   break;
	case PLAINTEXTKEYBLOB:	   pwszType = L"PLAINTEXTKEYBLOB"; break;
	case OPAQUEKEYBLOB:	   pwszType = L"OPAQUEKEYBLOB";	   break;
	case PUBLICKEYBLOBEX:	   pwszType = L"PUBLICKEYBLOBEX";  break;
	case SYMMETRICWRAPKEYBLOB: pwszType = L"SYMMETRICWRAPKEYBLOB"; break;
	default:
	    //DumpHex(DH_NOTABPREFIX | DH_PRIVATEDATA | 2, pbKey, cbKey);
	    hr = CRYPT_E_ASN1_BADTAG;
	    _JumpError2(hr, error, "key check", hr);
    }
    if (fQuiet)
    {
	hr = S_OK;
	goto error;
    }
    wprintf(myLoadResourceString(IDS_PRIVATEKEY));
    wprintf(wszNewLine);

    wprintf(L"  %ws\n", pwszType);

    wprintf(g_wszPad2);
    wprintf(
	myLoadResourceString(IDS_FORMAT_VERSION),	// "Version: %u"
	pkey->bVersion);
    wprintf(wszNewLine);

    wprintf(L"  aiKeyAlg: 0x%x\n", pkey->aiKeyAlg);
    cuDumpAlgid(pkey->aiKeyAlg);

    DumpHex(
	DH_NOTABPREFIX | DH_PRIVATEDATA | 2,
	(BYTE const *) &pkey[1],
	cbKey - sizeof(*pkey));
    hr = S_OK;

error:
    return(hr);
}


HRESULT DisplayUniqueContainer(IN HCRYPTPROV hProv);

HRESULT
cuDumpPrivateKey(
    IN CERT_CONTEXT const *pCert,
    OPTIONAL OUT BOOL *pfSigningKey,
    OPTIONAL OUT BOOL *pfMatchingKey)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    DWORD dwKeySpec;
    DWORD cb;
    CRYPT_BIT_BLOB PrivateKey;
    CERT_PUBLIC_KEY_INFO *pPublicKeyInfo = NULL;

    ZeroMemory(&PrivateKey, sizeof(PrivateKey));
    if (NULL != pfSigningKey)
    {
	*pfSigningKey = FALSE;
    }
    if (NULL != pfMatchingKey)
    {
	*pfMatchingKey = FALSE;
    }
    if (!CryptAcquireCertificatePrivateKey(
				    pCert,
				    0,		// dwFlags
				    NULL,	// pvReserved
				    &hProv,
				    &dwKeySpec,
				    NULL))	// pfCallerFreeProv
    {
	hr = myHLastError();
	if (CRYPT_E_NO_KEY_PROPERTY == hr)
	{
	    wprintf(myLoadResourceString(IDS_NO_KEY_PROPERTY)); // "No stored keyset property"
	    wprintf(wszNewLine);
	    hr = S_OK;

	    _JumpError2(
		    CRYPT_E_NO_KEY_PROPERTY,
		    error,
		    "CryptAcquireCertificatePrivateKey",
		    CRYPT_E_NO_KEY_PROPERTY);
	}
	if (NTE_BAD_KEYSET == hr)
	{
	    wprintf(myLoadResourceString(IDS_NO_KEY));	// "Missing stored keyset"
	    wprintf(wszNewLine);
	    hr = S_OK;

	    _JumpError2(
		    NTE_BAD_KEYSET,
		    error,
		    "CryptAcquireCertificatePrivateKey",
		    NTE_BAD_KEYSET);
	}
	_JumpError(hr, error, "CryptAcquireCertificatePrivateKey");
    }
    if (!g_fQuiet)
    {
	DisplayUniqueContainer(hProv);
    }
    if (NULL != pfSigningKey)
    {
	*pfSigningKey = AT_SIGNATURE == dwKeySpec;
    }

    if (!CryptGetUserKey(hProv, dwKeySpec, &hKey))
    {
	hr = myHLastError();
	_PrintError(hr, "CryptGetUserKey");
	cuPrintError(IDS_ERR_FORMAT_LOADKEY, hr);
	goto error;
    }
    hr = myCryptExportPrivateKey(
		    hKey,
		    &PrivateKey.pbData,
		    &PrivateKey.cbData);
    if (NTE_BAD_TYPE == hr || NTE_BAD_KEY_STATE == hr || NTE_PERM == hr)
    {
        wprintf(myLoadResourceString(IDS_PRIVATE_KEY_NOT_EXPORTABLE)); // "Private key is NOT exportable"
	wprintf(wszNewLine);
    }
    else
    {
	_JumpIfError(hr, error, "myCryptExportPrivateKey");
    }

    if (!myCryptExportPublicKeyInfo(
				hProv,
				dwKeySpec,
				CERTLIB_USE_LOCALALLOC,
				&pPublicKeyInfo,
				&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    if (!myCertComparePublicKeyInfo(
			    X509_ASN_ENCODING,
			    CERT_V1 == pCert->pCertInfo->dwVersion,
			    pPublicKeyInfo,
			    &pCert->pCertInfo->SubjectPublicKeyInfo))
    {
	// by design, (my)CertComparePublicKeyInfo doesn't set last error!

	wprintf(myLoadResourceString(IDS_ERR_PUBLICKEY_MISMATCH)); // "ERROR: Certificate public key does NOT match stored keyset"
	wprintf(wszNewLine);
    }
    else
    {
	if (AT_SIGNATURE == dwKeySpec)
	{
	    hr = myValidateKeyForSigning(
				    hProv,
				    &pCert->pCertInfo->SubjectPublicKeyInfo,
				    CALG_SHA1);
	    _PrintIfError(hr, "myValidateKeyForSigning");
	}
	else
	{
	    hr = myValidateKeyForEncrypting(
				    hProv,
				    &pCert->pCertInfo->SubjectPublicKeyInfo,
				    CALG_RC4);
	    _PrintIfError(hr, "myValidateKeyForEncrypting");
	}
	if (S_OK != hr)
	{
	    wprintf(myLoadResourceString(IDS_ERR_PRIVATEKEY_MISMATCH)); // "ERROR: Certificate public key does NOT match private key"
	    wprintf(wszNewLine);
	    hr = S_OK;
	}
	else if (NULL != pfMatchingKey)
	{
	    *pfMatchingKey = TRUE;
	}
	if (!g_fQuiet && NULL != PrivateKey.pbData)
	{
	    wprintf(wszNewLine);
	    hr = cuDumpPrivateKeyBlob(
				PrivateKey.pbData,
				PrivateKey.cbData,
				FALSE);
	    _JumpIfError(hr, error, "cuDumpPrivateKeyBlob");
	}
    }

error:
    if (NULL != PrivateKey.pbData)
    {
	SecureZeroMemory(PrivateKey.pbData, PrivateKey.cbData); // Key material
	LocalFree(PrivateKey.pbData);
    }
    if (NULL != pPublicKeyInfo)
    {
	LocalFree(pPublicKeyInfo);
    }
    if (NULL != hKey)
    {
	CryptDestroyKey(hKey);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
cuDumpCertKeyProviderInfo(
    IN WCHAR const *pwszPrefix,
    OPTIONAL IN CERT_CONTEXT const *pCert,
    OPTIONAL IN CRYPT_KEY_PROV_INFO *pkpi,
    OPTIONAL OUT CRYPT_KEY_PROV_INFO **ppkpi)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pkpiT = NULL;
    DWORD i;

    if (NULL != ppkpi)
    {
	*ppkpi = NULL;
    }
    CSASSERT((NULL == pCert) ^ (NULL == pkpi));

    if (NULL != pCert)
    {
	CSASSERT(NULL == pkpi);
	hr = myCertGetKeyProviderInfo(pCert, &pkpiT);
	if (S_OK != hr)
	{
	    _PrintIfError2(hr, "myCertGetKeyProviderInfo", CRYPT_E_NOT_FOUND);
	    if (CRYPT_E_NOT_FOUND != hr)
	    {
		_JumpError(hr, error, "myCertGetKeyProviderInfo");
	    }

	    // Ignore missing property if we're just dumping the key provider info

	    wprintf(myLoadResourceString(IDS_NO_KEY_PROVIDER_INFO)); // "No key provider information"
	    wprintf(wszNewLine);
	    CSASSERT(NULL == pkpiT);
	    hr = S_OK;
	    goto error;
	}
	pkpi = pkpiT;
    }
    else
    {
	CSASSERT(NULL != pkpi);
    }
    wprintf(pwszPrefix);
    wprintf(
	myLoadResourceString(IDS_FORMAT_KEY_CONTAINER),
	pkpi->pwszContainerName);
    wprintf(wszNewLine);

    wprintf(pwszPrefix);
    wprintf(
	myLoadResourceString(IDS_FORMAT_PROVIDER_NAME),
	pkpi->pwszProvName);
    wprintf(wszNewLine);

    if (!g_fQuiet)
    {
	wprintf(pwszPrefix);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_PROVIDER_TYPE),
	    pkpi->dwProvType);
	wprintf(wszNewLine);
    }

    if (!g_fQuiet)
    {
	wprintf(pwszPrefix);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_FLAGS),
	    pkpi->dwFlags);
	wprintf(wszNewLine);

	if (NULL != pkpi->rgProvParam)
	{
	    for (i = 0; i < pkpi->cProvParam; i++)
	    {
		wprintf(pwszPrefix);
		wprintf(
		    myLoadResourceString(IDS_FORMAT_PROVPARM),
		    pkpi->rgProvParam[i].dwParam);
		wprintf(wszNewLine);

		DumpHex(
		    DH_MULTIADDRESS | DH_NOTABPREFIX | 4,
		    pkpi->rgProvParam[i].pbData,
		    pkpi->rgProvParam[i].cbData);

		wprintf(pwszPrefix);
		wprintf(
		    myLoadResourceString(IDS_FORMAT_PROVPARMFLAGS),
		    pkpi->rgProvParam[i].dwFlags);
		wprintf(wszNewLine);
	    }
	}
	wprintf(pwszPrefix);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_KEYSPEC),
	    pkpi->dwKeySpec);
	wprintf(wszNewLine);
    }
    if (NULL != pkpiT && NULL != ppkpi)
    {
	*ppkpi = pkpiT;
	pkpiT = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pkpiT)
    {
	LocalFree(pkpiT);
    }
    return(hr);
}


VOID
cuDumpAlgorithm(
    IN DWORD idMessage,
    IN CRYPT_ALGORITHM_IDENTIFIER const *pAlg)
{
    wprintf(myLoadResourceString(idMessage));
    wprintf(wszNewLine);

    wprintf(g_wszPad4);
    wprintf(myLoadResourceString(IDS_ALG_OID)); // "Algorithm ObjectId"
    wprintf(L": ");
    cuDumpOIDAndDescriptionA(pAlg->pszObjId);
    wprintf(wszNewLine);

    wprintf(g_wszPad4);
    wprintf(myLoadResourceString(IDS_ALG_PARAMETERS_COLON)); // "Algorithm Parameters:"
    if (NULL != pAlg->Parameters.pbData)
    {
	wprintf(wszNewLine);
	DumpHex(
	    DH_MULTIADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	    pAlg->Parameters.pbData,
	    pAlg->Parameters.cbData);
    }
    else
    {
	wprintf(L" %ws\n", myLoadResourceString(IDS_NULL)); // "NULL"
    }
}


VOID
cuDumpPublicKey(
    IN CERT_PUBLIC_KEY_INFO const *pKey)
{
    cuDumpAlgorithm(IDS_PUBLICKEY_ALGORITHM, &pKey->Algorithm);

    wprintf(
	myLoadResourceString(IDS_FORMAT_PUBLICKEY_LENGTH), // "Public Key Length: %u bits"
	CertGetPublicKeyLength(
			X509_ASN_ENCODING,
			const_cast<CERT_PUBLIC_KEY_INFO *>(pKey)));
    wprintf(wszNewLine);

    wprintf(
	myLoadResourceString(IDS_FORMAT_PUBLICKEY_UNUSEDBITS), // "Public Key: UnusedBits=%u"
	pKey->PublicKey.cUnusedBits);

    wprintf(wszNewLine);
    DumpHex(
	DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	pKey->PublicKey.pbData,
	pKey->PublicKey.cbData);
}


VOID
cuDumpSignature(
    OPTIONAL IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    if (NULL == pcsci)
    {
	wprintf(myLoadResourceString(IDS_NO_SIGNATURE));
	wprintf(wszNewLine);
	goto error;
    }
    if (1 < g_fVerbose)
    {
	DumpHex(
	    DH_NOTABPREFIX | 4,
	    pcsci->ToBeSigned.pbData,
	    pcsci->ToBeSigned.cbData);
    }
    cuDumpAlgorithm(IDS_SIGNATURE_ALGORITHM, &pcsci->SignatureAlgorithm);

    wprintf(
	myLoadResourceString(IDS_FORMAT_SIGNATURE_UNUSEDBITS), // "Signature: UnusedBits=%u"
	pcsci->Signature.cUnusedBits);
    wprintf(wszNewLine);

    DumpHex(
	DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	pcsci->Signature.pbData,
	pcsci->Signature.cbData);

error:
    ;
}


HRESULT
cuSaveAsnToFile(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN int imajor,
    IN int ilevel,
    IN DWORD iElement,
    IN WCHAR const *pwszExtension)
{
    HRESULT hr;
    WCHAR awc[MAX_PATH];

    CSASSERT(0 < imajor);
    CSASSERT(0 < ilevel);

    wsprintf(
	awc,
	MAXDWORD == iElement? L"Blob%d_%d" : L"Blob%d_%d_%d",
	imajor - 1,
	ilevel - 1,
	iElement);
    if (wcslen(awc) + wcslen(pwszExtension) >= ARRAYSIZE(awc))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "awc", pwszExtension);
    }
    wcscat(awc, pwszExtension);

    if (g_fSplitASN)
    {
	//wprintf(L"cuSaveAsnToFile: %d %d %d: %ws\n", imajor - 1, ilevel - 1, iElement, awc);
	hr = EncodeToFileW(awc, pbIn, cbIn, CRYPT_STRING_BINARY | g_EncodeFlags);
	_JumpIfError(hr, error, "EncodeToFileW");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DumpAsnBlob(
    OPTIONAL IN HCERTSTORE hStoreWrapper,
    IN BOOL fQuiet,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD iElement)
{
    HRESULT hr;
    HRESULT hr2;
    ASNFORMATS *pasn;
    ASNFORMATS *pasnEnd;
    DWORD cbDecoded;
    BYTE *pbDecoded = NULL;
    HCERTSTORE hStorePFX = NULL;
    CERT_CONTEXT const *pCert = NULL;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    CERT_SIGNED_CONTENT_INFO *pcsci = NULL;
    DWORD cbcsci;
    static int s_major = 0;
    static int s_level = 0;
    BOOL fSaved = FALSE;
    WCHAR wszPassword[MAX_PATH];

    if (0 == s_level)
    {
	s_major++;
    }
    s_level++;
    if (1 < s_level)
    {
	wprintf(myLoadResourceString(IDS_FORMAT_DUMP_LEVEL_START), s_level - 1);
	wprintf(wszNewLine);
    }
    if (MAXDWORD != iElement)
    {
	wprintf(myLoadResourceString(IDS_FORMAT_ELEMENT), iElement);
	wprintf(wszNewLine);
    }

    if (1 < g_fVerbose)
    {
	wprintf(myLoadResourceString(IDS_FORMAT_ELEMENT_DUMP)); // "Embedded ASN.1 Element:"
	wprintf(wszNewLine);
	DumpHex(0, pbIn, cbIn);
    }

    pasnEnd = &g_aasn[CASNFORMATS];
    for (pasn = g_aasn; pasn < pasnEnd; pasn++)
    {
	CSASSERT(NULL == pbDecoded);
	if (myDecodeObject(
			X509_ASN_ENCODING,
			pasn->pszFormat,
			pbIn,
			cbIn,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbDecoded,
			&cbDecoded))
	{
	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_CERT,
			    pbIn,
			    cbIn,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pcsci,
			    &cbcsci))
	    {
		hr = myHLastError();
		_PrintError3(
			hr,
			"myDecodeObject",
			CRYPT_E_ASN1_BADTAG,
			CRYPT_E_ASN1_EOD);
	    }

	    hr = (*pasn->pfnDump)(
			    pasn->idMessage,
			    pbIn,
			    cbIn,
			    pbDecoded,
			    cbDecoded,
			    pcsci);
	    if (S_OK != hr && dumpCertSequence == pasn->pfnDump)
	    {
		LocalFree(pbDecoded);
		pbDecoded = NULL;
		CSASSERT(NULL == pcsci);
		continue;
	    }
	    hr2 = cuSaveAsnToFile(
			    pbIn,
			    cbIn,
			    s_major,
			    s_level,
			    iElement,
			    pasn->pwszExtension);
	    _PrintIfError(hr2, "cuSaveAsnToFile");
	    fSaved = TRUE;
	    _JumpIfError(hr, error, "(*pfnDump)");

	    break;
	}
	hr = myHLastError();
	_PrintError2(hr, "myDecodeObject", hr);
	CSASSERT(S_OK != hr);
    }
    if (pasn >= pasnEnd)
    {
	CRYPT_DATA_BLOB pfx;

	CSASSERT(S_OK != hr);

	pfx.pbData = const_cast<BYTE *>(pbIn);
	pfx.cbData = cbIn;

	if (PFXIsPFXBlob(&pfx))
	{
	    DWORD dwKeySpec;
	    DWORD dwFlags;
	    WCHAR const *pwszPassword;
	    DWORD iCert;

	    hr = cuGetPassword(
			    0,			// idsPrompt
			    NULL,		// pwszfn
			    g_pwszPassword,
			    FALSE,		// fVerify
			    wszPassword,
			    ARRAYSIZE(wszPassword),
			    &pwszPassword);
	    _JumpIfError(hr, error, "cuGetPassword");

	    hStorePFX = myPFXImportCertStore(
					&pfx,
					pwszPassword,
					CRYPT_EXPORTABLE);
	    if (NULL == hStorePFX)
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myPFXImportCertStore");
	    }
	    hr = cuSaveAsnToFile(pbIn, cbIn, s_major, s_level, iElement, L".p12");
	    _PrintIfError(hr, "cuSaveAsnToFile");
	    fSaved = TRUE;

	    for (iCert = 0; ; iCert++)
	    {
		BOOL fSigningKey;
		BOOL fMatchingKey;
		BOOL fRepaired = FALSE;

		pCert = CertEnumCertificatesInStore(hStorePFX, pCert);
		if (NULL == pCert)
		{
		    break;
		}
		hr = cuDumpAsnBinary(
				pCert->pbCertEncoded,
				pCert->cbCertEncoded,
				iCert);
		_JumpIfError(hr, error, "cuDumpAsnBinary");

		while (TRUE)
		{
		    if (NULL != pkpi)
		    {
			LocalFree(pkpi);
			pkpi = NULL;
		    }
		    hr = cuDumpCertKeyProviderInfo(
					    g_wszPad2,
					    pCert,
					    NULL,
					    &pkpi);
		    if (S_OK != hr)
		    {
			if (CRYPT_E_NOT_FOUND != hr)
			{
			    _JumpError(hr, error, "cuDumpCertKeyProviderInfo");
			}
		    }
		    else
		    if (NULL != pkpi)
		    {
			// NT4 PFXImportCertStore doesn't set machine keyset

			hr = cuDumpPrivateKey(
					pCert,
					&fSigningKey,
					&fMatchingKey);
			_PrintIfError2(
				    hr,
				    "cuDumpPrivateKey",
				    CRYPT_E_NO_KEY_PROPERTY);
			if (S_OK == hr &&
			    !fMatchingKey &&
			    !fRepaired &&
			    0 == (CRYPT_MACHINE_KEYSET & pkpi->dwFlags))
			{
			    LocalFree(pkpi);
			    pkpi = NULL;
			    hr = myRepairCertKeyProviderInfo(pCert, TRUE, NULL);
			    _JumpIfError(hr, error, "myRepairCertKeyProviderInfo");
			    fRepaired = TRUE;
			    continue;
			}
		    }
		    break;
		}
	    }
	    hr = S_OK;
	}
	else
	{
	    hr = dumpPKCS7(hStoreWrapper, pbIn, cbIn);
	    if (S_OK == hr)
	    {
		hr = cuSaveAsnToFile(
			    pbIn,
			    cbIn,
			    s_major,
			    s_level,
			    iElement,
			    L".p7b");
		_PrintIfError(hr, "cuSaveAsnToFile");
		fSaved = TRUE;
	    }
	    else
	    {
		hr = cuDumpPrivateKeyBlob(pbIn, cbIn, fQuiet);
		if (S_OK == hr)
		{
		    hr = cuSaveAsnToFile(
				pbIn,
				cbIn,
				s_major,
				s_level,
				iElement,
				L".key");
		    _PrintIfError(hr, "cuSaveAsnToFile");
		    fSaved = TRUE;
		}
		else
		{
		    _PrintError2(hr, "dumpPKCS7", CRYPT_E_ASN1_BADTAG);
		    if (!fQuiet)
		    {
			DumpHex(DH_MULTIADDRESS | DH_NOTABPREFIX | 4, pbIn, cbIn);
		    }
		}
		hr = S_OK;
	    }
	}
    }

error:
    SecureZeroMemory(wszPassword, sizeof(wszPassword));	// password data
    if (!fSaved)
    {
	hr2 = cuSaveAsnToFile(pbIn, cbIn, s_major, s_level, iElement, L".bin");
	_PrintIfError(hr2, "cuSaveAsnToFile");
    }
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != hStorePFX)
    {
        myDeleteGuidKeys(hStorePFX, FALSE);
	CertCloseStore(hStorePFX, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pcsci)
    {
	LocalFree(pcsci);
    }
    if (NULL != pbDecoded)
    {
	LocalFree(pbDecoded);
    }
    if (1 < s_level)
    {
	wprintf(myLoadResourceString(IDS_FORMAT_DUMP_LEVEL_END), s_level - 1);
	wprintf(wszNewLine);
    }
    s_level--;
    return(hr);
}


HRESULT
cuDumpAsnBinary(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD iElement)
{
    return(DumpAsnBlob(NULL, FALSE, pbIn, cbIn, iElement));
}


HRESULT
cuDumpExtensionArray(
    IN DWORD idMessage,
    IN DWORD cExtension,
    IN CERT_EXTENSION const *rgExtension)
{
    HRESULT hr;
    DWORD i;
    WCHAR *pwszName = NULL;
    WCHAR const *pwszExtensionFormat;

    if (!g_fQuiet)
    {
	wprintf(myLoadResourceString(idMessage));
	wprintf(L" %u\n", cExtension);
    }

    pwszExtensionFormat = myLoadResourceString(IDS_FORMAT_EXTENSION); // "%ws: Flags = %x%ws, Length = %x"

    for (i = 0; i < cExtension; i++)
    {
	CERT_EXTENSION const *pce;

	if (NULL != pwszName)
	{
	    LocalFree(pwszName);
	    pwszName = NULL;
	}
	pce = &rgExtension[i];
	if (g_fQuiet &&
	    0 != strcmp(pce->pszObjId, szOID_CERTSRV_CA_VERSION) &&
	    0 != strcmp(pce->pszObjId, szOID_ENROLL_CERTTYPE_EXTENSION) &&
	    0 != strcmp(pce->pszObjId, szOID_CRL_NUMBER) &&
	    0 != strcmp(pce->pszObjId, szOID_CRL_VIRTUAL_BASE) &&
	    0 != strcmp(pce->pszObjId, szOID_DELTA_CRL_INDICATOR))
	{
	    continue;
	}
	if (!ConvertSzToWsz(&pwszName, pce->pszObjId, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertSzToWsz");
	}

	if (!g_fQuiet)
	{
	    wprintf(g_wszPad4);
	    wprintf(
		pwszExtensionFormat,
		pwszName,
		pce->fCritical,
		cuwszFromExtFlags(pce->fCritical),
		pce->Value.cbData);
	    wprintf(wszNewLine);
	}
	if (!cuDumpFormattedExtension(
			    pwszName,
			    pce->Value.pbData,
			    pce->Value.cbData) ||
	    g_fVerbose)
	{
	    wprintf(wszNewLine);
	    DumpHex(DH_NOTABPREFIX | 4, pce->Value.pbData, pce->Value.cbData);
	}
	if (!g_fQuiet)
	{
	    wprintf(wszNewLine);
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    return(hr);
}


VOID
cuDumpVersion(
    IN DWORD dwVersion)
{
    wprintf(
	myLoadResourceString(IDS_FORMAT_VERSION), // "Version: %u"
	dwVersion);
    wprintf(wszNewLine);
}


HRESULT
cuDumpCMSSignerInfo(
    IN CMSG_CMS_SIGNER_INFO const *pcsi,
    IN DWORD iElement,
    IN BOOL fQuiet,
    DWORD idVerify,
    OPTIONAL IN HCERTSTORE hStore,
    OPTIONAL OUT BYTE *pbHashUserCert,
    OPTIONAL IN OUT DWORD *pcbHashUserCert)
{
    HRESULT hr;
    WCHAR const *pwszFmt = MAXDWORD == iElement? L"%ws:\n" : L"%ws[%u]:\n";

    if (!fQuiet || g_fVerbose)
    {
	if (!fQuiet)
	{
	    wprintf(wszNewLine);
	}
	wprintf(
	    pwszFmt,
	    myLoadResourceString(IDS_SIGNER_INFO), // "Signer Info"
	    iElement);
	if (!fQuiet)
	{
	    WCHAR const *pwszVersion = NULL;
	    
	    if (0 != idVerify)
	    {
		wprintf(myLoadResourceString(idVerify));
		wprintf(wszNewLine);
	    }
	    switch (pcsi->dwVersion)
	    {
		case CMSG_SIGNER_INFO_PKCS_1_5_VERSION:
		    pwszVersion = L"CMSG_SIGNER_INFO_PKCS_1_5_VERSION";
		    break;

		case CMSG_SIGNER_INFO_CMS_VERSION:
		    pwszVersion = L"CMSG_SIGNER_INFO_CMS_VERSION";
		    break;
	    }
	    if (NULL == pwszVersion)
	    {
		cuDumpVersion(pcsi->dwVersion);
	    }
	    else
	    {
		wprintf(L"%ws(%u)\n", pwszVersion, pcsi->dwVersion);
	    }
	}
	switch (pcsi->SignerId.dwIdChoice)
	{
	    case CERT_ID_ISSUER_SERIAL_NUMBER:
		wprintf(
		    L"%ws(%u)\n",
		    L"CERT_ID_ISSUER_SERIAL_NUMBER",
		    pcsi->SignerId.dwIdChoice);
		hr = cuDumpIssuerSerialAndSubject(
			    &pcsi->SignerId.IssuerSerialNumber.Issuer,
			    &pcsi->SignerId.IssuerSerialNumber.SerialNumber,
			    NULL,	// pSubject
			    hStore);
		_JumpIfError(hr, error, "cuDumpIssuerSerialAndSubject(Signer)");

		break;

	    case CERT_ID_KEY_IDENTIFIER:
		wprintf(
		    L"%ws(%u)\n",
		    L"CERT_ID_KEY_IDENTIFIER",
		    pcsi->SignerId.dwIdChoice);
		DumpHex(
		    DH_MULTIADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
		    pcsi->SignerId.KeyId.pbData,
		    pcsi->SignerId.KeyId.cbData);
		break;

	    case CERT_ID_SHA1_HASH:
		wprintf(
		    L"%ws(%u)\n",
		    L"CERT_ID_SHA1_HASH",
		    pcsi->SignerId.dwIdChoice);
		DumpHex(
		    DH_MULTIADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
		    pcsi->SignerId.HashId.pbData,
		    pcsi->SignerId.HashId.cbData);
		break;

	    default:
		wprintf(
		    L"%ws(%u)\n",
		    myLoadResourceString(IDS_QUESTIONMARKS), // "???"
		    pcsi->SignerId.dwIdChoice);
		break;
	}
    }

    if (!fQuiet)
    {
	cuDumpAlgorithm(IDS_HASH_ALGORITHM, &pcsi->HashAlgorithm);
	cuDumpAlgorithm(IDS_HASH_ENCRYPTION_ALGORITHM, &pcsi->HashEncryptionAlgorithm);
	wprintf(myLoadResourceString(IDS_FORMAT_ENCRYPTEDHASH_COLON)); // "Encrypted Hash:"
	wprintf(wszNewLine);

	DumpHex(
	    DH_MULTIADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	    pcsi->EncryptedHash.pbData,
	    pcsi->EncryptedHash.cbData);

	wprintf(wszNewLine);
	wprintf(
	    pwszFmt,
	    myLoadResourceString(IDS_DUMP_PKCS7_ATTRIBUTES),
	    iElement);
    }

    if (!fQuiet || NULL != pbHashUserCert)
    {
	hr = DumpAttributes(
			pcsi->AuthAttrs.rgAttr,
			pcsi->AuthAttrs.cAttr,
			fQuiet,
			FOT_ATTRIBUTE,
			hStore,
			pbHashUserCert,
			pcbHashUserCert,
			NULL);
	_JumpIfError(hr, error, "DumpAttributes");
    }

    if (!fQuiet)
    {
	wprintf(wszNewLine);
	wprintf(
	    pwszFmt,
	    myLoadResourceString(IDS_DUMP_PKCS7_UNAUTHATTRIBUTES),
	    iElement);

	hr = DumpAttributes(
			pcsi->UnauthAttrs.rgAttr,
			pcsi->UnauthAttrs.cAttr,
			fQuiet,
			FOT_ATTRIBUTE,
			hStore,
			NULL,
			NULL,
			NULL);
	_JumpIfError(hr, error, "DumpAttributes");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
cuDumpSignerInfo(
    IN CMSG_SIGNER_INFO const *psi,
    IN DWORD iElement,
    IN BOOL fQuiet,
    DWORD idVerify,
    OPTIONAL IN HCERTSTORE hStore,
    OPTIONAL OUT BYTE *pbHashUserCert,
    OPTIONAL IN OUT DWORD *pcbHashUserCert)
{
    HRESULT hr;
    CMSG_CMS_SIGNER_INFO csi;

    ZeroMemory(&csi, sizeof(csi));

    csi.dwVersion = psi->dwVersion;
    csi.SignerId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
    csi.SignerId.IssuerSerialNumber.Issuer = psi->Issuer;
    csi.SignerId.IssuerSerialNumber.SerialNumber = psi->SerialNumber;
    csi.HashAlgorithm = psi->HashAlgorithm;
    csi.HashEncryptionAlgorithm = psi->HashEncryptionAlgorithm;
    csi.EncryptedHash = psi->EncryptedHash;
    csi.AuthAttrs = psi->AuthAttrs;
    csi.UnauthAttrs = psi->UnauthAttrs;

    hr = cuDumpCMSSignerInfo(
		    &csi,
		    iElement,
		    fQuiet,
		    idVerify,
		    hStore,
		    pbHashUserCert,
		    pcbHashUserCert);
    _JumpIfError(hr, error, "cuDumpCMSSignerInfo");

error:
    return(hr);
}




HRESULT
DumpAttributes(
    IN CRYPT_ATTRIBUTE const *rgAttr,
    IN DWORD cAttr,
    IN BOOL fQuiet,
    IN DWORD Type,		// FOT_*
    OPTIONAL IN HCERTSTORE hStore,
    OPTIONAL OUT BYTE *pbHashUserCert,
    OPTIONAL IN OUT DWORD *pcbHashUserCert,
    OPTIONAL IN OUT CERT_EXTENSIONS **ppExtInfo)
{
    HRESULT hr;
    CRYPT_ATTRIBUTE const *pAttr;
    CRYPT_ATTRIBUTE const *pAttrEnd;
    CRYPT_ENROLLMENT_NAME_VALUE_PAIR *pNamePair = NULL;
    CERT_EXTENSIONS *pExtInfo = NULL;
    CERT_NAME_VALUE *pNameInfo = NULL;
    DWORD cb;
    DWORD iv;

    if (NULL != ppExtInfo)
    {
	*ppExtInfo = NULL;
    }
    if (!fQuiet && FOT_PROPERTY != Type)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_PKCS7_ATTRIBUTE_COUNT),	// "  %d attributes:"
	    cAttr);
	wprintf(wszNewLine);
    }

    pAttrEnd = &rgAttr[cAttr];
    for (pAttr = rgAttr; pAttr < pAttrEnd; pAttr++)
    {
	WCHAR const *pwszOID = cuGetOIDNameA(pAttr->pszObjId);

	if (!fQuiet && FOT_PROPERTY != Type)
	{
	    wprintf(wszNewLine);
	    wprintf(
		L"  %ws[%u]: %hs%ws%ws%ws\n",
		myLoadResourceString(IDS_ATTRIBUTE),	// "Attribute"
		pAttr - rgAttr,
		pAttr->pszObjId,
		L'\0' != *pwszOID? L" " wszLPAREN : g_wszEmpty,
		pwszOID,
		L'\0' != *pwszOID? wszRPAREN : g_wszEmpty);
	}

	for (iv = 0; iv < pAttr->cValue; iv++)
	{
	    CRYPT_ATTR_BLOB const *pval = &pAttr->rgValue[iv];

	    if (fQuiet)
	    {
		if (0 == strcmp(pAttr->pszObjId, szOID_ARCHIVED_KEY_CERT_HASH))
		{
		    hr = DumpOctetHash(
				g_wszEmpty,
				0,
				g_wszEmpty,
				pval->pbData,
				pval->cbData,
				pbHashUserCert,
				pcbHashUserCert);
		    _JumpIfError(hr, error, "DumpOctetHash");
		}
	    }
	    else
	    {
		if (FOT_PROPERTY != Type)
		{
		    wprintf(
			myLoadResourceString(IDS_FORMAT_PKCS7_ATTRIBUTE_VALUE),	// "    Value[%d][%d]:"
			pAttr - rgAttr,
			iv);
		    wprintf(wszNewLine);
		}

		if (!DumpFormattedObject(
				    pAttr->pszObjId,
				    Type,		// FOT_*
				    pval->pbData,
				    pval->cbData))
		{
		    BOOL fDumpHex = FALSE;

		    if (0 == strcmp(pAttr->pszObjId, szOID_ENROLLMENT_NAME_VALUE_PAIR))
		    {
			if (g_fVerbose)
			{
			    DumpHex(0, pval->pbData, pval->cbData);
			}
			if (NULL != pNamePair)
			{
			    LocalFree(pNamePair);
			    pNamePair = NULL;
			}
			if (!myDecodeNameValuePair(
						X509_ASN_ENCODING,
						pval->pbData,
						pval->cbData,
						CERTLIB_USE_LOCALALLOC,
						&pNamePair,
						&cb))
			{
			    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			    _JumpError(hr, error, "myDecodeNameValuePair");

			    // if attribute name & value are both non-empty ...
			}
			wprintf(
			    L"      %ws%ws = %ws\n",
			    pNamePair->pwszName,
			    g_wszCertUtil,
			    pNamePair->pwszValue);
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_CERT_EXTENSIONS) ||
			0 == strcmp(pAttr->pszObjId, szOID_RSA_certExtensions))
		    {
			if (NULL != pNameInfo)
			{
			    LocalFree(pNameInfo);
			    pNameInfo = NULL;
			}
			while (TRUE)
			{
			    if (NULL != pExtInfo)
			    {
				LocalFree(pExtInfo);
				pExtInfo = NULL;
			    }
			    if (myDecodeObject(
					    X509_ASN_ENCODING,
					    X509_EXTENSIONS,
					    pval->pbData,
					    pval->cbData,
					    CERTLIB_USE_LOCALALLOC,
					    (VOID **) &pExtInfo,
					    &cb))
			    {
				break;	// success
			    }
			    hr = myHLastError();

			    // if we already decoded the attribute as a T61
			    // string, or if it's not a PKCS 9.14 attribute,
			    // just hex dump the attribute -- we don't know
			    // what it contains.

			    if (NULL != pNameInfo ||
				0 != strcmp(
					pAttr->pszObjId,
					szOID_RSA_certExtensions))
			    {
				//_JumpError(hr, error, "myDecodeObject");
				_PrintError(hr, "myDecodeObject");
				fDumpHex = TRUE;
				break;
			    }

			    // decode the attribute as a T61 string.  Some
			    // implementations wrap the PKCS 9.14 extension
			    // array in an extra level of encoding as a Teletex
			    // string.

			    if (!myDecodeObject(
					    X509_ASN_ENCODING,
					    X509_ANY_STRING,
					    pval->pbData,
					    pval->cbData,
					    CERTLIB_USE_LOCALALLOC,
					    (VOID **) &pNameInfo,
					    &cb))
			    {
				hr = myHLastError();
				//_JumpError(hr, error, "myDecodeObject");
				_PrintError(hr, "myDecodeObject");
				fDumpHex = TRUE;
				break;
			    }

			    // Now loop again and try to decode the raw name
			    // blob as X509_EXTENSIONS.

			    pval = &pNameInfo->Value;
			    wprintf(myLoadResourceString(IDS_TELETEX_EXTENSIONS)); // "Decoded extra Extension Array encoding layer (Teletex string)"
			    wprintf(wszNewLine);
			}
			if (!fDumpHex)
			{
			    hr = cuDumpExtensionArray(
						IDS_CERTIFICATE_EXTENSIONS,
						pExtInfo->cExtension,
						pExtInfo->rgExtension);
			    _JumpIfError(hr, error, "cuDumpExtensionArray");
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_RENEWAL_CERTIFICATE) ||
			0 == strcmp(pAttr->pszObjId, szOID_RSA_SMIMECapabilities))
		    {
			wprintf(myLoadResourceString(
				0 == strcmp(
					pAttr->pszObjId,
					szOID_RENEWAL_CERTIFICATE)?
				IDS_RENEWAL_CERT :	      // "Renewal Certificate:"
				IDS_SMIME_CAPABILITIES)); // "SMIME Capabilities:"
			wprintf(wszNewLine);

			hr = cuDumpAsnBinary(pval->pbData, pval->cbData, MAXDWORD);
			_JumpIfError(hr, error, "cuDumpAsnBinary");
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_RSA_contentType))
		    {
			char *pszObjId;

			hr = cuDecodeObjId(pval->pbData, pval->cbData, &pszObjId);
			if (S_OK != hr)
			{
			    fDumpHex = TRUE;
			}
			else
			{
			    wprintf(g_wszPad4);
			    cuDumpOIDAndDescriptionA(pszObjId);
			    wprintf(wszNewLine);
			    LocalFree(pszObjId);
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_RSA_messageDigest))
		    {
			hr = DumpOctetHash(
				    g_wszPad4,
				    IDS_MESSAGE_DIGEST,
				    g_wszCertUtil,
				    pval->pbData,
				    pval->cbData,
				    NULL,
				    NULL);
			if (S_OK != hr)
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_ARCHIVED_KEY_ATTR))
		    {
			hr = cuDumpAsnBinary(pval->pbData, pval->cbData, MAXDWORD);
			if (S_OK != hr)
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_ARCHIVED_KEY_CERT_HASH))
		    {
			hr = DumpOctetHash(
				    g_wszPad4,
				    IDS_ARCHIVED_KEY_CERT_HASH,
				    g_wszCertUtil,
				    pval->pbData,
				    pval->cbData,
				    pbHashUserCert,
				    pcbHashUserCert);
			if (S_OK != hr)
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_ISSUED_CERT_HASH))
		    {
			hr = DumpOctetHash(
				    g_wszPad4,
				    IDS_ISSUED_CERT_HASH,
				    g_wszCertUtil,
				    pval->pbData,
				    pval->cbData,
				    pbHashUserCert,
				    pcbHashUserCert);
			if (S_OK != hr)
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_ENCRYPTED_KEY_HASH))
		    {
			hr = DumpOctetHash(
				    g_wszPad4,
				    IDS_ENCRYPTED_KEY_HASH,
				    g_wszCertUtil,
				    pval->pbData,
				    pval->cbData,
				    NULL,
				    NULL);
			if (S_OK != hr)
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_ENROLLMENT_CSP_PROVIDER))
		    {
			CRYPT_CSP_PROVIDER *pccp;

			hr = myDecodeCSPProviderAttribute(
					    pval->pbData,
					    pval->cbData,
					    &pccp);
			if (S_OK == hr)
			{
			    wprintf(g_wszPad4);
			    wprintf(
				myLoadResourceString(IDS_CSP_PROVIDER_INFO));
			    wprintf(wszNewLine);

			    wprintf(g_wszPad4);
			    wprintf(
				myLoadResourceString(IDS_FORMAT_KEYSPEC),
				pccp->dwKeySpec);
			    wprintf(wszNewLine);

			    wprintf(g_wszPad4);
			    wprintf(
				myLoadResourceString(IDS_FORMAT_PROVIDER_NAME),
				NULL == pccp->pwszProviderName?
				    myLoadResourceString(IDS_PROP_EMPTY) :
				    pccp->pwszProviderName);
			    wprintf(wszNewLine);

			    wprintf(g_wszPad4);
			    wprintf(
				myLoadResourceString(IDS_FORMAT_SIGNATURE_UNUSEDBITS), // "Signature: UnusedBits=%u"
				pccp->Signature.cUnusedBits);
			    wprintf(wszNewLine);

			    DumpHex(
				DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
				pccp->Signature.pbData,
				pccp->Signature.cbData);

			    LocalFree(pccp);
			}
			else
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_RSA_signingTime))
		    {
			FILETIME ft;

			cb = sizeof(ft);
			if (CryptDecodeObject(
					    X509_ASN_ENCODING,
					    X509_CHOICE_OF_TIME,
					    pval->pbData,
					    pval->cbData,
					    0,
					    &ft,
					    &cb))
			{
			    wprintf(
				L"%ws%ws%ws: ",
				g_wszPad4,
				myLoadResourceString(IDS_SIGNING_TIME),
				g_wszCertUtil);

			    hr = cuDumpFileTime(0, NULL, &ft);
			    _JumpIfError(hr, error, "cuDumpFileTime");
			}
			else
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_REQUEST_CLIENT_INFO))
		    {
			CRYPT_REQUEST_CLIENT_INFO *pcrci = NULL;

			hr = myDecodeRequestClientAttribute(
					    pval->pbData,
					    pval->cbData,
					    &pcrci);
			if (S_OK == hr)
			{
			    wprintf(g_wszPad2);
			    cuRegPrintDwordValue(
					    TRUE,
					    wszREQUESTCLIENTID,
					    myLoadResourceString(IDS_CLIENTID),
					    pcrci->dwClientId);
			    wprintf(
				L"%ws%ws %ws\n",
				g_wszPad4,
				myLoadResourceString(IDS_USERCOLON),
				pcrci->pwszUser);

			    wprintf(
				L"%ws%ws %ws\n",
				g_wszPad4,
				myLoadResourceString(IDS_MACHINECOLON),
				pcrci->pwszMachine);

			    wprintf(
				L"%ws%ws %ws\n",
				g_wszPad4,
				myLoadResourceString(IDS_PROCESSCOLON),
				pcrci->pwszProcess);

			    LocalFree(pcrci);
			}
			else
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_RSA_counterSign))
		    {
			CMSG_SIGNER_INFO *psi = NULL;

			if (!myDecodeObject(
					X509_ASN_ENCODING,
					PKCS7_SIGNER_INFO,
					pval->pbData,
					pval->cbData,
					CERTLIB_USE_LOCALALLOC,
					(VOID **) &psi,
					&cb))
			{
			    CSASSERT(NULL == psi);
			    hr = myHLastError();
			    _PrintError(hr, "myDecodeObject");
			    fDumpHex = TRUE;
			}
			else
			{
			    wprintf(
				L"%ws%ws%ws: ",
				g_wszPad4,
				myLoadResourceString(IDS_COUNTER_SIGNATURE),
				g_wszCertUtil);

			    hr = cuDumpSignerInfo(
					    psi,
					    MAXDWORD,	// iElement
					    fQuiet,
					    0,
					    hStore,
					    pbHashUserCert,
					    pcbHashUserCert);
			    _PrintIfError(hr, "cuDumpSignerInfo");
			    if (S_OK != hr)
			    {
				fDumpHex = TRUE;
			    }
			}
			if (NULL != psi)
			{
			    LocalFree(psi);
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_RSA_challengePwd))
		    {
			CRYPT_DATA_BLOB Value;
			WCHAR *pwsz;

			Value.pbData = pval->pbData;
			Value.cbData = pval->cbData;
			hr = UnicodeDecode(&Value, &pwsz);
			if (S_OK == hr)
			{
			    wprintf(L"%ws%ws\n", g_wszPad4, pwsz);
			    LocalFree(pwsz);
			}
			else
			{
			    fDumpHex = TRUE;
			}
		    }
		    else
		    if (0 == strcmp(pAttr->pszObjId, szOID_YESNO_TRUST_ATTR))
		    {
			DWORD Bool;

			cb = sizeof(Bool);
			Bool = 0;
			if (CryptDecodeObject(
					    X509_ASN_ENCODING,
					    X509_INTEGER,
					    pval->pbData,
					    pval->cbData,
					    0,
					    &Bool,
					    &cb))
			{
			    wprintf(
				L"%ws%x\n",
				g_wszPad4,
				Bool);
			}
			else
			{
			    fDumpHex = TRUE;
			}
		    }
		    if (fDumpHex)
		    {
			DumpHex(
			    DH_NOTABPREFIX | 4,
			    pval->pbData,
			    pval->cbData);
		    }
		}
	    }
	}
    }
    if (NULL != ppExtInfo)
    {
	*ppExtInfo = pExtInfo;
	pExtInfo = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pNamePair)
    {
	LocalFree(pNamePair);
    }
    if (NULL != pExtInfo)
    {
	LocalFree(pExtInfo);
    }
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    return(hr);
}


HRESULT
FindCertStoreIndex(
    IN HCERTSTORE hStore,
    IN CERT_CONTEXT const *pCertSigner,
    OUT DWORD *piElement)
{
    HRESULT hr;
    DWORD iElement;
    CERT_CONTEXT const *pcc = NULL;

    *piElement = -1;
    for (iElement = 0; ; iElement++)
    {
	pcc = CertEnumCertificatesInStore(hStore, pcc);
	if (NULL == pcc)
	{
	    hr = CRYPT_E_NOT_FOUND;
	    _JumpError(hr, error, "CertEnumCertificatesInStore");
	}
	if (pCertSigner->cbCertEncoded == pcc->cbCertEncoded &&
	    0 == memcmp(
		    pCertSigner->pbCertEncoded,
		    pcc->pbCertEncoded,
		    pcc->cbCertEncoded))
	{
	    break;
	}
    }
    *piElement = iElement;
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
cuDumpIssuerSerialAndSubject(
    IN CERT_NAME_BLOB const *pIssuer,
    IN CRYPT_INTEGER_BLOB const *pSerialNumber,
    OPTIONAL IN CERT_NAME_BLOB const *pSubject,
    OPTIONAL IN HCERTSTORE hStore)
{
    HRESULT hr;
    BOOL fVerbose = g_fVerbose;
    CERT_ID CertId;
    CERT_CONTEXT const *pcc = NULL;
    BOOL fMultiLine = NULL == pSerialNumber || g_fVerbose;

    if (g_fVerbose)
    {
	g_fVerbose--;
    }
    hr = cuDumpSerial(g_wszPad4, IDS_SERIAL, pSerialNumber);
    _JumpIfError(hr, error, "cuDumpSerial");

    hr = cuDisplayCertName(
		    fMultiLine,
		    g_wszPad4,
		    myLoadResourceString(IDS_ISSUER), // "Issuer"
		    g_wszPad8,
		    pIssuer,
		    NULL);
    _JumpIfError(hr, error, "cuDisplayCertName(Issuer)");

    ZeroMemory(&CertId, sizeof(CertId));
    CertId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
    CertId.IssuerSerialNumber.Issuer = *pIssuer;
    if (NULL != pSerialNumber)
    {
	CertId.IssuerSerialNumber.SerialNumber = *pSerialNumber;
    }

    if (NULL == pSubject && NULL != hStore)
    {
	pcc = CertFindCertificateInStore(
				    hStore,
				    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				    0,			// dwFindFlags
				    CERT_FIND_CERT_ID,
				    &CertId,
				    NULL);
	if (NULL == pcc)
	{
	    hr = myHLastError();
	    _PrintError2(hr, "CertFindCertificateInStore", hr);
	}
	else
	{
	    pSubject = &pcc->pCertInfo->Subject;
	}
    }
    if (NULL != pSubject)
    {
	hr = cuDisplayCertName(
			fMultiLine,
			g_wszPad4,
			myLoadResourceString(IDS_SUBJECT), // "Subject"
			g_wszPad8,
			pSubject,
			NULL);
	_JumpIfError(hr, error, "cuDisplayCertName(Issuer)");
    }
    hr = S_OK;

error:
    g_fVerbose = fVerbose;
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
cuDumpSigners(
    IN HCRYPTMSG hMsg,
    IN CHAR const *pszInnerContentObjId,
    IN HCERTSTORE hStore,
    IN DWORD cSigner,
    IN BOOL fContentEmpty,
    IN BOOL fQuiet,
    OPTIONAL OUT BYTE *pbHashUserCert,
    OPTIONAL IN OUT DWORD *pcbHashUserCert)
{
    HRESULT hr;
    DWORD i;
    CMSG_CMS_SIGNER_INFO *pcsi = NULL;
    DWORD cb;
    CERT_CONTEXT const *pcc = NULL;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD iElement;
    DWORD VerifyState;
    BOOL fVerbose = g_fVerbose;
    CERT_REQUEST_INFO *pRequest = NULL;

    if (!fQuiet)
    {
	if (0 == cSigner)
	{
	    wprintf(myLoadResourceString(IDS_DUMP_PKCS7_NO_SIGNER));
	    wprintf(wszNewLine);
	}
	else
	{
	    wprintf(
		L"%ws: %d\n",
		myLoadResourceString(IDS_DUMP_PKCS7_SIGNER_COUNT),
		cSigner);
	}
    }
    for (i = 0; i < cSigner; i++)
    {
	DWORD idVerify = 0;
	
	if (NULL != pcsi)
	{
	    LocalFree(pcsi);
	    pcsi = NULL;
	}
	hr = myCryptMsgGetParam(
			    hMsg,
			    CMSG_CMS_SIGNER_INFO_PARAM,
			    i,
                            CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pcsi,
			    &cb);
	_JumpIfError(hr, error, "myCryptMsgGetParam");

	if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice ||
	    (NULL != pcsi->HashEncryptionAlgorithm.pszObjId &&
	     0 == strcmp(
		    szOID_PKIX_NO_SIGNATURE,
		    pcsi->HashEncryptionAlgorithm.pszObjId)))
	{
	    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA cvse;

	    ZeroMemory(&cvse, sizeof(cvse));
	    cvse.cbSize = sizeof(cvse);
	    cvse.dwSignerIndex = i;

	    if (CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice)
	    {
		if (NULL == pRequest)
		{
		    hr = myGetInnerPKCS10(
				    hMsg,
				    pszInnerContentObjId,
				    &pRequest);
		    _JumpIfError(hr, error, "myGetInnerPKCS10");
		}
		cvse.dwSignerType = CMSG_VERIFY_SIGNER_PUBKEY;
		cvse.pvSigner = &pRequest->SubjectPublicKeyInfo;
	    }
	    else
	    {
		cvse.dwSignerType = CMSG_VERIFY_SIGNER_NULL;
	    }

	    if (!CryptMsgControl(
			    hMsg,
			    0,		// dwFlags
			    CMSG_CTRL_VERIFY_SIGNATURE_EX,
			    &cvse))
	    {
		hr = myHLastError();
		_PrintError(hr, "CryptMsgControl");
		cuPrintError(0, hr);
	    }
	    else
	    {
		idVerify = CERT_ID_KEY_IDENTIFIER == pcsi->SignerId.dwIdChoice?
		    IDS_REQUEST_SIGNATUREMATCHES : // "Signature matches request Public Key"
		    IDS_NULL_SIGNATUREMATCHES;	// "NULL signature verifies"
	    }
	}
	else
	{
	    DWORD dwFlags;

	    dwFlags = CMSG_USE_SIGNER_INDEX_FLAG;
	    while (TRUE)
	    {
		iElement = i;
		if (CryptMsgGetAndVerifySigner(
				    hMsg,
				    0,		// cSignerStore
				    NULL,	// rghSignerStore
				    dwFlags,
				    &pcc,
				    &iElement))
		{
		    hr = S_OK;
		    break;
		}
		hr = myHLastError();
		_PrintError(hr, "CryptMsgGetAndVerifySigner");

		if (CMSG_SIGNER_ONLY_FLAG & dwFlags)
		{
		    cuPrintError(0, hr);
		    break;
		}
		cuPrintError(
			(fContentEmpty && NTE_BAD_SIGNATURE == hr)?
			    IDS_DETACHED_SIGNATURE : // "Cannot verify detached signature"
			    0,
			    hr);
		dwFlags |= CMSG_SIGNER_ONLY_FLAG;
	    }
	    if (S_OK == hr)
	    {
		idVerify = IDS_SIGNATUREMATCHES; // "Signature matches Public Key"
		hr = FindCertStoreIndex(hStore, pcc, &iElement);
		_JumpIfError(hr, error, "FindCertStoreIndex");

		if (!fQuiet)
		{
		    wprintf(
			L"%ws: %u\n",
			myLoadResourceString(IDS_DUMP_PKCS7_SIGNCERT), // "Signing Certificate Index"
			iElement);
		}
		hr = cuVerifyCertContext(
				    pcc,
				    hStore,
    				    0,		// cApplicationPolicies
    				    NULL,	// apszApplicationPolicies
    				    0,		// cIssuancePolicies
    				    NULL,	// apszIssuancePolicies
				    FALSE,	// fNTAuth
				    &VerifyState);
		_PrintIfError(hr, "cuVerifyCertContext");

		CertFreeCertificateContext(pcc);
		pcc = NULL;
	    }
	}

	hr = cuDumpCMSSignerInfo(
			pcsi,
			i,
			fQuiet,
			idVerify,
			hStore,
			pbHashUserCert,
			pcbHashUserCert);
	_PrintIfError(hr, "cuDumpCMSSignerInfo");

	cb = sizeof(abHash);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_COMPUTED_HASH_PARAM,
			0,
			abHash,
			&cb))
	{
	    hr = myHLastError();
	    _PrintError(hr, "CryptMsgGetParam(computed hash)");
	}
	else
	{
	    wprintf(wszNewLine);
	    hr = DumpHash(
		    NULL,
		    IDS_FORMAT_COMPUTED_HASH_COLON,	// "Computed Hash%ws: %ws"
		    NULL,
		    g_wszEmpty,
		    abHash,
		    cb);
	    _JumpIfError(hr, error, "DumpHash");
	}
    }
    hr = S_OK;

error:
    if (NULL != pRequest)
    {
	LocalFree(pRequest);
    }
    if (NULL != pcsi)
    {
	LocalFree(pcsi);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
cuDumpRecipientCertHash(
    IN CERT_INFO const *pci,
    IN HCERTSTORE hStore)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    CERT_ID CertId;

    CSASSERT(NULL != hStore);

    CertId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
    CertId.IssuerSerialNumber.Issuer = pci->Issuer;
    CertId.IssuerSerialNumber.SerialNumber = pci->SerialNumber;

    pcc = CertFindCertificateInStore(
			    hStore,
			    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			    0,	// dwFindFlags
			    CERT_FIND_CERT_ID,
			    &CertId,
			    NULL);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertFindCertificateInStore");
    }
    hr = cuDisplayHash(g_wszPad4, pcc, NULL, CERT_SHA1_HASH_PROP_ID, L"sha1");
    _JumpIfError(hr, error, "cuDisplayHash");

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
cuDumpRecipients(
    IN HCRYPTMSG hMsg,
    OPTIONAL IN HCERTSTORE hStoreWrapper,
    IN DWORD cRecipient,
    IN BOOL fQuiet)
{
    HRESULT hr;
    DWORD i;
    CERT_INFO *pci = NULL;
    DWORD cb;

    if (!fQuiet)
    {
	if (0 == cRecipient)
	{
	    wprintf(myLoadResourceString(IDS_DUMP_PKCS7_NO_RECIPIENT));
	    wprintf(wszNewLine);
	}
	else
	{
	    wprintf(
		L"%ws: %d\n",
		myLoadResourceString(IDS_DUMP_PKCS7_RECIPIENT_COUNT),
		cRecipient);
	}
    }
    for (i = 0; i < cRecipient; i++)
    {
	if (NULL != pci)
	{
	    LocalFree(pci);
	    pci = NULL;
	}
	hr = myCryptMsgGetParam(
			    hMsg,
			    CMSG_RECIPIENT_INFO_PARAM,
			    i,
                            CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pci,
			    &cb);
	_JumpIfError(hr, error, "myCryptMsgGetParam");

	wprintf(wszNewLine);
	wprintf(
	    L"%ws[%u]:\n",
	    myLoadResourceString(IDS_RECIPIENT_INFO), // "Recipient Info"
	    i);

	hr = cuDumpIssuerSerialAndSubject(
			    &pci->Issuer,
			    &pci->SerialNumber,
			    NULL,	// pSubject
			    hStoreWrapper);
	_JumpIfError(hr, error, "cuDumpIssuerSerialAndSubject(Recipient)");

	if (NULL != hStoreWrapper)
	{
	    hr = cuDumpRecipientCertHash(pci, hStoreWrapper);
	    _PrintIfError(hr, "cuDumpRecipientCertHash");
	}
    }
    hr = S_OK;

error:
    if (NULL != pci)
    {
	LocalFree(pci);
    }
    return(hr);
}


HRESULT
OpenCAXchgMemoryStore(
    OUT HCERTSTORE *phStore)
{
    HRESULT hr;
    WCHAR const *pwszConfig = g_pwszConfig;
    BSTR strConfig = NULL;
    DISPATCHINTERFACE diRequest;
    BSTR strCert = NULL;
    HCERTSTORE hStore = NULL;
    
    if (NULL == pwszConfig)
    {
	hr = ConfigGetConfig(g_DispatchFlags, CC_LOCALACTIVECONFIG, &strConfig);
	_JumpIfError(hr, error, "ConfigGetConfig");

	pwszConfig = strConfig;
    }

    hr = Request_Init(g_DispatchFlags, &diRequest);
    _JumpIfError(hr, error, "Request_Init");

    hr = Request2_GetCAProperty(
			&diRequest,
			pwszConfig,
			CR_PROP_CAXCHGCERT,
			MAXDWORD,		// PropIndex
			PROPTYPE_BINARY,
			CR_OUT_BINARY,
			&strCert);
    _JumpIfError(hr, error, "Request2_GetCAProperty");

    hStore = CertOpenStore(
		    CERT_STORE_PROV_MEMORY,
		    X509_ASN_ENCODING,
		    NULL,
		    0,
		    NULL);
    if (NULL == hStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    // Add as encoded blob to avoid all properties, key prov info, etc.

    if (!CertAddEncodedCertificateToStore(
		    hStore,
		    X509_ASN_ENCODING,
		    (BYTE *) strCert,
		    SysStringByteLen(strCert),
		    CERT_STORE_ADD_REPLACE_EXISTING,
		    NULL))			// ppCertContext
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertAddEncodedCertificateToStore");
    }
    *phStore = hStore;
    hStore = NULL;
    hr = S_OK;

error:
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != strCert)
    {
	SysFreeString(strCert);
    }
    Request_Release(&diRequest);
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);

}


HRESULT
OpenNamedStore(
    IN BOOL fUserStore,
    IN WCHAR const *pwszStoreName,
    OUT HCERTSTORE *phStore)
{
    HRESULT hr;

    *phStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_W,
                    X509_ASN_ENCODING,
                    NULL,		// hProv
                    CERT_STORE_OPEN_EXISTING_FLAG |
			CERT_STORE_READONLY_FLAG |
			CERT_STORE_ENUM_ARCHIVED_FLAG |
			(fUserStore?
			    CERT_SYSTEM_STORE_CURRENT_USER :
			    CERT_SYSTEM_STORE_LOCAL_MACHINE),
		    pwszStoreName);
    if (NULL == *phStore)
    {
        hr = myHLastError();
        _JumpErrorStr2(
		hr,
		error,
		"CertOpenStore",
		pwszStoreName,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
cuCryptDecryptMessageFromCert(
    IN CERT_CONTEXT const *pcc,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT DWORD *pdwKeySpecFound,
    OUT BYTE **ppbDecrypted,
    OUT DWORD *pcbDecrypted)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pccStore = NULL;
    CERT_KEY_CONTEXT ckc;
    HCRYPTPROV hProv = NULL;
    DWORD dwKeySpec;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    DWORD dwTickCount = GetTickCount();

    *pdwKeySpecFound = 0;
    hStore = CertOpenStore(
		    CERT_STORE_PROV_MEMORY,
		    X509_ASN_ENCODING,
		    NULL,
		    0,
		    NULL);
    if (NULL == hStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    // Add as encoded blob to avoid all properties, key prov info, etc.

    if (!CertAddEncodedCertificateToStore(
		    hStore,
		    X509_ASN_ENCODING,
		    pcc->pbCertEncoded,
		    pcc->cbCertEncoded,
		    CERT_STORE_ADD_REPLACE_EXISTING,
		    &pccStore))			// ppCertContext
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertAddEncodedCertificateToStore");
    }
    hr = myCertGetKeyProviderInfo(pcc, &pkpi);
    _PrintIfError2(hr, "myCertGetKeyProviderInfo", CRYPT_E_NOT_FOUND);
    if (S_OK == hr)
    {
	DBGPRINT((
	    s_DbgSsRecoveryTrace,
	    "Original KeyProvInfo: container=%ws, type=%x, prov=%ws, KeySpec=%x, f=%x\n",
	    pkpi->pwszContainerName,
	    pkpi->dwProvType,
	    pkpi->pwszProvName,
	    pkpi->dwKeySpec,
	    pkpi->dwFlags));
    }
    else if (!g_fForce)
    {
	_JumpError2(hr, error, "myCertGetKeyProviderInfo", CRYPT_E_NOT_FOUND);
    }
    DBGPRINT((
	s_DbgSsRecoveryTrace,
	"Before CryptAcquireCertificatePrivateKey: Ticks=%u\n",
	GetTickCount() - dwTickCount));

    if (!CryptAcquireCertificatePrivateKey(
				    pcc,
				    0,		// dwFlags
				    NULL,	// pvReserved
				    &hProv,
				    &dwKeySpec,
				    NULL))	// pfCallerFreeProv
    {
	hr = myHLastError();
	_PrintError2(
		hr,
		"CryptAcquireCertificatePrivateKey",
		CRYPT_E_NO_KEY_PROPERTY);

	DBGPRINT((
	    s_DbgSsRecoveryTrace,
	    "Before CryptFindCertificateKeyProvInfo: Ticks=%u\n",
	    GetTickCount() - dwTickCount));

	if (!CryptFindCertificateKeyProvInfo(pcc, 0, NULL))
	{
	    hr = myHLastError();
	    _JumpError2(
		    hr,
		    error,
		    "CryptFindCertificateKeyProvInfo",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
	}
	if (NULL != pkpi)
	{
	    LocalFree(pkpi);
	    pkpi = NULL;
	}

	hr = myCertGetKeyProviderInfo(pcc, &pkpi);
	_JumpIfError(hr, error, "myCertGetKeyProviderInfo");

	DBGPRINT((
	    s_DbgSsRecoveryTrace,
	    "Constructed KeyProvInfo: container=%ws, type=%x, prov=%ws, KeySpec=%x, f=%x\n",
	    pkpi->pwszContainerName,
	    pkpi->dwProvType,
	    pkpi->pwszProvName,
	    pkpi->dwKeySpec,
	    pkpi->dwFlags));
	dwKeySpec = pkpi->dwKeySpec;

	DBGPRINT((
	    s_DbgSsRecoveryTrace,
	    "Before CryptAcquireContext: Ticks=%u\n",
	    GetTickCount() - dwTickCount));

	if (!CryptAcquireContext(
			    &hProv,
			    pkpi->pwszContainerName,
			    pkpi->pwszProvName,
			    pkpi->dwProvType,
			    pkpi->dwFlags))
	{
	    hr = myHLastError();
	    _JumpErrorStr(
		    hr,
		    error,
		    "CryptAcquireContext",
		    pkpi->pwszContainerName);
	}
    }
    ZeroMemory(&ckc, sizeof(ckc));
    ckc.cbSize = sizeof(ckc);
    ckc.dwKeySpec = dwKeySpec;
    ckc.hCryptProv = hProv;

    *pdwKeySpecFound = dwKeySpec;

    DBGPRINT((
	s_DbgSsRecoveryTrace,
	"Before CertSetCertificateContextProperty: Ticks=%u\n",
	GetTickCount() - dwTickCount));

    if (!CertSetCertificateContextProperty(
				    pccStore,
				    CERT_KEY_CONTEXT_PROP_ID,
				    CERT_STORE_NO_CRYPT_RELEASE_FLAG,
				    &ckc))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertSetCertificateContextProperty");
    }

    DBGPRINT((
	s_DbgSsRecoveryTrace,
	"Before myCryptDecryptMessage: Ticks=%u\n",
	GetTickCount() - dwTickCount));

    hr = myCryptDecryptMessage(
			hStore,
			pbIn,
			cbIn,
			CERTLIB_USE_LOCALALLOC,
			ppbDecrypted,
			pcbDecrypted);
    _JumpIfError(hr, error, "myCryptDecryptMessage");

    DBGPRINT((
	s_DbgSsRecoveryTrace,
	"After myCryptDecryptMessage: Ticks=%u\n",
	GetTickCount() - dwTickCount));

error:
    if (S_OK != hr)
    {
	DBGPRINT((
	    s_DbgSsRecoveryTrace,
	    "Skipped myCryptDecryptMessage(%x): Ticks=%u\n",
	    hr,
	    GetTickCount() - dwTickCount));
    }

    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pccStore)
    {
	CertFreeCertificateContext(pccStore);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


// Attempt to find any one recipient cert with a usable private key in the
// following locations:
//  - the next outer PKCS7 store (hStoreWrapper parameter)
//  - the PKCS7 store (hStorePKCS7 parameter)
//  - the local machine's current CA Exchange cert
//  - the HKLM KRA store
//  - the HKLM MY store
//  - the HKCU MY store

HRESULT
cuDumpEncryptedAsnBinary(
    IN HCRYPTMSG hMsg,
    IN DWORD cRecipient,
    IN DWORD RecipientIndex,
    OPTIONAL IN HCERTSTORE hStoreWrapper,
    IN HCERTSTORE hStorePKCS7,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BOOL fQuiet,
    OPTIONAL OUT BYTE **ppbDecrypted,
    OPTIONAL OUT DWORD *pcbDecrypted)
{
    HRESULT hr;
    HCERTSTORE ahStore[6];
    WCHAR *apwszStore[6];
    DWORD cStore = 0;
    DWORD iRecipient;
    DWORD iStore;
    DWORD cb;
    CERT_INFO *pci = NULL;
    CERT_CONTEXT const *pcc = NULL;
    BOOL fDecrypted = FALSE;
    BYTE *pbDecrypted = NULL;
    DWORD cbDecrypted;
    DWORD dwKeySpecFound;
    BOOL fSignatureKey = FALSE;
    BOOL fExchangeKey = FALSE;
    DWORD dwTickCount = GetTickCount();

    if (NULL != ppbDecrypted)
    {
	*ppbDecrypted = NULL;
    }
    if (NULL != pcbDecrypted)
    {
	*pcbDecrypted = 0;
    }
    s_DbgSsRecoveryTrace = g_fVerbose? DBG_SS_CERTUTIL : DBG_SS_CERTUTILI;
    hr = OpenNamedStore(TRUE, wszMY_CERTSTORE, &ahStore[cStore]);
    if (S_OK == hr)
    {
	apwszStore[cStore] = L"HKCU MY";
	cStore++;
    }
    hr = OpenNamedStore(FALSE, wszMY_CERTSTORE, &ahStore[cStore]);
    if (S_OK == hr)
    {
	apwszStore[cStore] = L"HKLM MY";
	cStore++;
    }
    if (NULL != hStoreWrapper)
    {
	apwszStore[cStore] = L"PKCS7 Wrapper";
	ahStore[cStore++] = hStoreWrapper;
    }
    if (NULL != hStorePKCS7)
    {
	apwszStore[cStore] = L"PKCS7";
	ahStore[cStore++] = hStorePKCS7;
    }
    hr = OpenCAXchgMemoryStore(&ahStore[cStore]);
    if (S_OK == hr)
    {
	apwszStore[cStore] = L"CAXchgMemory";
	cStore++;
    }
    hr = OpenNamedStore(FALSE, wszKRA_CERTSTORE, &ahStore[cStore]);
    if (S_OK == hr)
    {
	apwszStore[cStore] = L"HKLM KRA";
	cStore++;
    }

    for (iRecipient = 0; !fDecrypted && iRecipient < cRecipient; iRecipient++)
    {
	CERT_ID CertId;

	if (MAXDWORD != RecipientIndex && iRecipient != RecipientIndex)
	{
	    continue;
	}
	if (NULL != pci)
	{
	    LocalFree(pci);
	    pci = NULL;
	}
	hr = myCryptMsgGetParam(
			    hMsg,
			    CMSG_RECIPIENT_INFO_PARAM,
			    iRecipient,
                            CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pci,
			    &cb);
	_JumpIfError(hr, error, "myCryptMsgGetParam");

	CertId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
	CertId.IssuerSerialNumber.Issuer = pci->Issuer;
	CertId.IssuerSerialNumber.SerialNumber = pci->SerialNumber;

	for (iStore = 0; !fDecrypted && iStore < cStore; iStore++)
	{
	    if (NULL != pcc)
	    {
		CertFreeCertificateContext(pcc);
		pcc = NULL;
	    }
	    while (TRUE)
	    {
		pcc = CertFindCertificateInStore(
				    ahStore[iStore],
				    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				    0,			// dwFindFlags
				    CERT_FIND_CERT_ID,
				    &CertId,
				    pcc);
		if (NULL == pcc)
		{
		    hr = myHLastError();
		    _PrintError2(hr, "CertFindCertificateInStore", hr);
		    break;
		}
		{
		    WCHAR *pwsz;

		    pwsz = NULL;
		    hr = myCertNameToStr(
				X509_ASN_ENCODING,
				&pcc->pCertInfo->Subject,
				CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
				&pwsz);
		    _PrintIfError(hr, "myCertNameToStr");
		    DBGPRINT((
			s_DbgSsRecoveryTrace,
			"================================================\n"));

		    DBGPRINT((
			s_DbgSsRecoveryTrace,
			"Found Recipient[%u] in %ws -- ahStore[%u of %u]: %ws\n",
			iRecipient,
			apwszStore[iStore],
			iStore,
			cStore,
			pwsz));
		    if (NULL != pwsz)
		    {
			LocalFree(pwsz);
		    }
		}
		if (g_fVerbose)
		{
		    wprintf(wszNewLine);
		    wprintf(
			L"%ws[%u]:\n",
			myLoadResourceString(IDS_RECIPIENT_INFO), // "Recipient Info"
			iRecipient);
		    hr = cuDumpIssuerSerialAndSubject(
					&pci->Issuer,
					&pci->SerialNumber,
					&pcc->pCertInfo->Subject,
					NULL);		// hStore
		    _JumpIfError(hr, error, "cuDumpIssuerSerialAndSubject(Recipient)");
		}

		hr = cuCryptDecryptMessageFromCert(
				pcc,
				pbIn,
				cbIn,
				&dwKeySpecFound,
				&pbDecrypted,
				&cbDecrypted);
		_PrintIfError2(
			hr,
			"cuCryptDecryptMessageFromCert",
			HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
		{
		    DBGPRINT((
			s_DbgSsRecoveryTrace,
			"cuCryptDecryptMessageFromCert(Recipient[%u]): %x\n",
			iRecipient,
			hr));
		}

		if (AT_SIGNATURE == dwKeySpecFound)
		{
		    fSignatureKey = TRUE;
		}
		else if (AT_KEYEXCHANGE == dwKeySpecFound)
		{
		    fExchangeKey = TRUE;
		}
		if (S_OK != hr)
		{
		    DBGPRINT((
			s_DbgSsRecoveryTrace,
			"cuDumpEncryptedAsnBinary failed(%x): Ticks=%u\n",
			hr,
			GetTickCount() - dwTickCount));
		    continue;
		}
		wprintf(myLoadResourceString(IDS_DUMP_DECRYPTED)); // "Decrypted PKCS7 Content"
		wprintf(wszNewLine);
		hr = DumpAsnBlob(
			    NULL,
			    fQuiet,
			    pbDecrypted,
			    cbDecrypted,
			    MAXDWORD);
		_PrintIfError(hr, "DumpAsnBlob(decrypted content)");
		if (S_OK == hr)
		{
		    fDecrypted = TRUE;
		    if (NULL != ppbDecrypted)
		    {
			*ppbDecrypted = pbDecrypted;
			pbDecrypted = NULL;
		    }
		    if (NULL != pcbDecrypted)
		    {
			*pcbDecrypted = cbDecrypted;
		    }
		}
		break;
	    }
	}
    }
    DBGPRINT((
	s_DbgSsRecoveryTrace,
	"cuDumpEncryptedAsnBinary end(fDecrypted=%d): Ticks=%u\n",
	fDecrypted,
	GetTickCount() - dwTickCount));
    if (!fDecrypted)
    {
	if (fSignatureKey && !fExchangeKey)
	{
	    wprintf(myLoadResourceString(IDS_SIGNATURE_NOTKEYEXCHANGE)); // "Found AT_SIGNATURE key but no AT_KEYEXCHANGE key"
	    wprintf(wszNewLine);
	}
	hr = CRYPT_E_NO_DECRYPT_CERT;
	_JumpError(hr, error, "No decryption key");
    }
    hr = S_OK;

error:
    if (NULL != pbDecrypted)
    {
	LocalFree(pbDecrypted);
    }
    if (NULL != pci)
    {
	LocalFree(pci);
    }
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    for (iStore = 0; iStore < cStore; iStore++)
    {
	if (NULL != ahStore[iStore] &&
	    hStoreWrapper != ahStore[iStore] &&
	    hStorePKCS7 != ahStore[iStore])
	{
	    CertCloseStore(ahStore[iStore], CERT_CLOSE_STORE_CHECK_FLAG);
	}
    }
    return(hr);
}


HRESULT
dumpPKCS7(
    OPTIONAL IN HCERTSTORE hStoreWrapper,
    IN BYTE const *pbIn,
    IN DWORD cbIn)
{
    HRESULT hr;
    BYTE *pbContents = NULL;
    DWORD cbContents;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pCert = NULL;
    CRL_CONTEXT const *pCRL = NULL;
    HCRYPTMSG hMsg = NULL;
    CRYPT_ATTRIBUTES *pAttrib = NULL;
    BOOL fDisplayed;
    DWORD iElement;
    DWORD cSigner;
    DWORD cRecipient;
    DWORD cb;
    DWORD dwMsgType;
    DWORD dwMsgVersion;
    char *pszInnerContentObjId = NULL;
    WCHAR const *pwsz;
    WCHAR const *pwszVersion;
    UINT idsType = IDS_DUMP_PKCS7;

    hr = myDecodePKCS7(
		    pbIn,
		    cbIn,
		    &pbContents,
		    &cbContents,
		    &dwMsgType,
		    &pszInnerContentObjId,
		    &cSigner,
		    &cRecipient,
		    &hStore,
		    &hMsg);
    _JumpIfError2(hr, error, "myDecodePKCS7", CRYPT_E_ASN1_BADTAG);

    cb = sizeof(dwMsgVersion);
    if (!CryptMsgGetParam(
		    hMsg,
		    CMSG_VERSION_PARAM,
		    0,
		    &dwMsgVersion,
		    &cb))
    {
	hr = myHLastError();
	_PrintError(hr, "CryptMsgGetParam(version)");
	dwMsgVersion = MAXDWORD;
    }

    pwszVersion = NULL;
    switch (dwMsgType)
    {
	case CMSG_DATA:
	    pwsz = L"CMSG_DATA";
	    break;

	case CMSG_ENVELOPED:
	    pwsz = L"CMSG_ENVELOPED";
	    switch (dwMsgVersion)
	    {
		case CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION:
		    pwszVersion = L"CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION";
		    break;

		case CMSG_ENVELOPED_DATA_CMS_VERSION:
		    pwszVersion = L"CMSG_ENVELOPED_DATA_CMS_VERSION";
		    idsType = IDS_DUMP_PKCS7CMS;
		    break;
	    }
	    break;

	case CMSG_HASHED:
	    pwsz = L"CMSG_HASHED";
	    switch (dwMsgVersion)
	    {
		case CMSG_HASHED_DATA_PKCS_1_5_VERSION:
		    pwszVersion = L"CMSG_HASHED_DATA_PKCS_1_5_VERSION";
		    break;

		case CMSG_HASHED_DATA_CMS_VERSION:
		    pwszVersion = L"CMSG_HASHED_DATA_CMS_VERSION";
		    idsType = IDS_DUMP_PKCS7CMS;
		    break;
	    }
	    break;

	case CMSG_SIGNED:
	    pwsz = L"CMSG_SIGNED";
	    switch (dwMsgVersion)
	    {
		case CMSG_SIGNED_DATA_PKCS_1_5_VERSION:
		    pwszVersion = L"CMSG_SIGNED_DATA_PKCS_1_5_VERSION";
		    break;

		case CMSG_SIGNED_DATA_CMS_VERSION:
		    pwszVersion = L"CMSG_SIGNED_DATA_CMS_VERSION";
		    idsType = IDS_DUMP_PKCS7CMS;
		    break;
	    }
	    break;

	case CMSG_SIGNED_AND_ENVELOPED:
	    pwsz = L"CMSG_SIGNED_AND_ENVELOPED";
	    break;

	default:
	    pwsz = myLoadResourceString(IDS_QUESTIONMARKS); // "???"
	    break;
    }

    wprintf(myLoadResourceString(idsType));
    wprintf(wszNewLine);

    wprintf(L"  %ws(%u)\n", pwsz, dwMsgType);
    if (NULL != pwszVersion)
    {
	wprintf(L"  %ws(%u)\n", pwszVersion, dwMsgVersion);
    }
    if (NULL != pszInnerContentObjId)
    {
	wprintf(
	    L"  %ws: ",
	    myLoadResourceString(IDS_DUMP_PKCS7_CONTENT_TYPE));
	cuDumpOIDAndDescriptionA(pszInnerContentObjId);
	wprintf(wszNewLine);
    }
    wprintf(wszNewLine);

    if (NULL == pbContents)
    {
	wprintf(myLoadResourceString(IDS_DUMP_PKCS7_NO_CONTENT));
	wprintf(wszNewLine);
    }
    else
    {
	wprintf(myLoadResourceString(IDS_DUMP_PKCS7_CONTENTS));	// "PKCS7 Message Content:"
	wprintf(wszNewLine);

	fDisplayed = FALSE;
	if (CMSG_ENVELOPED != dwMsgType)
	{
	    hr = DumpAsnBlob(hStore, FALSE, pbContents, cbContents, MAXDWORD);
	    _PrintIfError(hr, "DumpAsnBlob(content)");
	    fDisplayed = TRUE;
	}
	else if (NULL != hMsg && 0 != cRecipient)
	{
	    hr = cuDumpEncryptedAsnBinary(
				    hMsg,
				    cRecipient,
				    MAXDWORD,	// RecipientIndex
				    hStoreWrapper,
				    hStore,
				    pbIn,
				    cbIn,
				    FALSE,
				    NULL,
				    NULL);
	    _PrintIfError(hr, "cuDumpEncryptedAsnBinary");
	    if (S_OK == hr)
	    {
		fDisplayed = TRUE;
	    }
	}
	if (!fDisplayed)
	{
	    DumpHex(0, pbContents, cbContents);
	}
    }
    wprintf(wszNewLine);

    if (NULL != hMsg)
    {
	BYTE abHash[CBMAX_CRYPT_HASH_LEN];

	hr = cuDumpSigners(
		    hMsg,
		    pszInnerContentObjId,
		    hStore,
		    cSigner,
		    NULL == pbContents,	// fContentEmpty
		    FALSE,		// fVerifyOnly
		    NULL,		// pbHashUserCert
		    NULL);		// pcbHashUserCert
	_JumpIfError(hr, error, "cuDumpSigners");

	hr = cuDumpRecipients(hMsg, hStoreWrapper, cRecipient, FALSE);
	_JumpIfError(hr, error, "cuDumpRecipients");

	cb = sizeof(abHash);
	if (!CryptMsgGetParam(
			hMsg,
			CMSG_HASH_DATA_PARAM,
			0,
			abHash,
			&cb))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "CryptMsgGetParam(stored hash)", CRYPT_E_INVALID_MSG_TYPE);
	}
	else
	{
	    hr = DumpHash(
		    NULL,
		    IDS_FORMAT_STORED_HASH_COLON,	// "Stored Hash%ws: %ws"
		    NULL,
		    g_wszEmpty,
		    abHash,
		    cb);
	    _JumpIfError(hr, error, "DumpHash");
	}
	wprintf(wszNewLine);
    }

    fDisplayed = FALSE;
    if (NULL != hStore)
    {
	CSASSERT(NULL == pCert);
	for (iElement = 0; ; iElement++)
	{
	    pCert = CertEnumCertificatesInStore(hStore, pCert);
	    if (NULL == pCert)
	    {
		break;
	    }
	    if (!fDisplayed)
	    {
		wprintf(myLoadResourceString(IDS_DUMP_PKCS7_CERTIFICATES));
		wprintf(wszNewLine);
		fDisplayed = TRUE;
	    }
	    hr = cuDumpAsnBinary(
			    pCert->pbCertEncoded,
			    pCert->cbCertEncoded,
			    iElement);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");
	}
    }
    if (!fDisplayed)
    {
	wprintf(myLoadResourceString(IDS_DUMP_PKCS7_NO_CERTIFICATES));
	wprintf(wszNewLine);
    }

    fDisplayed = FALSE;
    if (NULL != hStore)
    {
	CSASSERT(NULL == pCRL);
	for (iElement = 0; ; iElement++)
	{
	    pCRL = CertEnumCRLsInStore(hStore, pCRL);
	    if (NULL == pCRL)
	    {
		break;
	    }
	    if (!fDisplayed)
	    {
		wprintf(myLoadResourceString(IDS_DUMP_PKCS7_CRLS));
		wprintf(wszNewLine);
		fDisplayed = TRUE;
	    }
	    hr = cuDumpAsnBinary(
			    pCRL->pbCrlEncoded,
			    pCRL->cbCrlEncoded,
			    iElement);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");
	}
    }
    if (!fDisplayed)
    {
	wprintf(myLoadResourceString(IDS_DUMP_PKCS7_NO_CRLS));
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    if (NULL != pszInnerContentObjId)
    {
	LocalFree(pszInnerContentObjId);
    }
    if (NULL != pAttrib)
    {
	LocalFree(pAttrib);
    }
    if (NULL != hMsg)
    {
	CryptMsgClose(hMsg);
    }
    if (NULL != pCRL)
    {
	CertFreeCRLContext(pCRL);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pbContents)
    {
	LocalFree(pbContents);
    }
    return(hr);
}


HRESULT
GetVersionStuff(
    IN WCHAR const *pwszFileName,
    OUT DWORD *pdwLangRet,
    OUT VS_FIXEDFILEINFO *pvsRet)
{
    HRESULT hr;
    VOID *pvData = NULL;
    DWORD cbData;
    DWORD dwHandle;
    DWORD *pdwTranslation;
    UINT uLen;
    DWORD dwDefLang = 0x409;
    VS_FIXEDFILEINFO *pvs;

    cbData = GetFileVersionInfoSize(
			    const_cast<WCHAR *>(pwszFileName),
			    &dwHandle);
    if (0 == cbData)
    {
        hr = GetLastError();
        if (S_OK == hr)
	{
	    hr = ERROR_RESOURCE_DATA_NOT_FOUND;
	}
        goto error;
    }

    pvData = LocalAlloc(LMEM_FIXED, cbData);
    if (NULL == pvData)
    {
        hr = GetLastError();
        goto error;
    }

    if (!GetFileVersionInfo(
			const_cast<WCHAR *>(pwszFileName),
			0,
			cbData,
			pvData))
    {
        hr = GetLastError();
        goto error;
    }

    if (!VerQueryValue(pvData, L"\\VarFileInfo\\Translation", (VOID **) &pdwTranslation, &uLen))
    {
        pdwTranslation = &dwDefLang;
        uLen = sizeof(DWORD);
    }

    *pdwLangRet = *pdwTranslation;

    if (!VerQueryValue(pvData, L"\\", (VOID **) &pvs, &uLen))
    {
        hr = GetLastError();
        goto error;
    }
    *pvsRet = *pvs;
    hr = S_OK;

error:
    if (NULL != pvData)
    {
        LocalFree(pvData);
    }
    return(hr);
}


HRESULT
FileVersionDump(
    IN WCHAR const *pwszFileName)
{
    HRESULT hr;
    DWORD dwLang;
    VS_FIXEDFILEINFO vs;

    hr = GetVersionStuff(pwszFileName, &dwLang, &vs);
    if (S_OK == hr)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_LANG), // "%ws: Lang %08x (%d.%d)"
	    pwszFileName,
	    dwLang,
	    HIWORD(dwLang),
	    LOWORD(dwLang));

	wprintf(
	    myLoadResourceString(IDS_FORMAT_FILE), // "  File %d.%d:%d.%d"
	    HIWORD(vs.dwFileVersionMS),
	    LOWORD(vs.dwFileVersionMS),
	    HIWORD(vs.dwFileVersionLS),
	    LOWORD(vs.dwFileVersionLS));

	wprintf(
	    myLoadResourceString(IDS_FORMAT_PRODUCT), // "  Product %d.%d:%d.%d\n"
	    HIWORD(vs.dwProductVersionMS),
	    LOWORD(vs.dwProductVersionMS),
	    HIWORD(vs.dwProductVersionLS),
	    LOWORD(vs.dwProductVersionLS));
    }
    return(hr);
}


HRESULT
cuFileDump(
    IN WCHAR const *pwszfn)
{
    HRESULT hr;
    BYTE *pbIn = NULL;
    DWORD cbIn;

    hr = FileVersionDump(pwszfn);
    if (S_OK == hr)
    {
	goto error;
    }
    hr = EPFFileDump(pwszfn, g_pwszPassword, NULL);
    if (S_FALSE != hr)
    {
	_PrintIfError(hr, "EPFFileDump");
	goto error;
    }
    hr = DecodeFileW(pwszfn, &pbIn, &cbIn, CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }
    CSASSERT(NULL != pbIn);

    hr = cuDumpAsnBinary(pbIn, cbIn, MAXDWORD);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_CANNOT_DECODE, hr);
	goto error;
    }

error:
    if (NULL != pbIn)
    {
        LocalFree(pbIn);
    }
    return(hr);
}


HRESULT
cuDumpSerial(
    OPTIONAL IN WCHAR const *pwszPrefix,
    IN DWORD idMessage,
    IN CRYPT_INTEGER_BLOB const *pSerial)
{
    HRESULT hr;
    BSTR strSerial = NULL;

    hr = MultiByteIntegerToBstr(
			    FALSE,
			    pSerial->cbData,
			    pSerial->pbData,
			    &strSerial);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    if (NULL != pwszPrefix)
    {
	wprintf(pwszPrefix);
    }
    wprintf(myLoadResourceString(idMessage));
    wprintf(L" %ws\n", strSerial);

    if (g_fVerbose)
    {
	DumpHex(
	    DH_MULTIADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 4,
	    pSerial->pbData,
	    pSerial->cbData);
    }

error:
    if (NULL != strSerial)
    {
	SysFreeString(strSerial);
    }
    return(hr);
}


HRESULT
cuDumpFileTimePeriod(
    IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszQuote,
    IN FILETIME const *pftGMT)
{
    HRESULT hr;
    WCHAR *pwszTimePeriod;
    
    hr = myFileTimePeriodToWszTimePeriod(pftGMT, g_fSeconds, &pwszTimePeriod);
    _JumpIfError(hr, error, "myFileTimePeriodToWszTimePeriod");

    if (NULL == pwszQuote)
    {
	pwszQuote = g_wszEmpty;
    }
    wprintf(L" %ws%ws%ws\n", pwszQuote, pwszTimePeriod, pwszQuote);
    hr = S_OK;

error:
    if (NULL != pwszTimePeriod)
    {
	LocalFree(pwszTimePeriod);
    }
    return(hr);
}


HRESULT
cuDumpFileTime(
    IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszQuote,
    IN FILETIME const *pftGMT)
{
    HRESULT hr;
    WCHAR *pwszDate = NULL;
    WCHAR const *pwszResource = NULL;

    if (0 != idMessage)
    {
	pwszResource = myLoadResourceString(idMessage);
    }
    if (NULL == pwszResource)
    {
	pwszResource = g_wszEmpty;
    }
    if (NULL == pwszQuote)
    {
	pwszQuote = g_wszEmpty;
    }
    if (0 == pftGMT->dwLowDateTime &&
	0 == pftGMT->dwHighDateTime)
    {
	wprintf(
	    L"%ws %ws\n",
	    pwszResource,
	    myLoadResourceString(IDS_PROP_EMPTY)); // "EMPTY"
    }
    else
    {
	if (g_fGMT)
	{
	    hr = myFileTimeToWszTime(pftGMT, g_fSeconds, &pwszDate);
	    _JumpIfError(hr, error, "myFileTimeToWszTime");
	}
	else
	{
	    hr = myGMTFileTimeToWszLocalTime(pftGMT, g_fSeconds, &pwszDate);
	    _JumpIfError(hr, error, "myGMTFileTimeToWszLocalTime");
	}
	wprintf(
	    L"%ws %ws%ws%ws%ws%ws\n",
	    pwszResource,
	    pwszQuote,
	    pwszDate,
	    g_fGMT? L" " : g_wszEmpty,
	    g_fGMT? myLoadResourceString(IDS_GMT_SUFFIX) : g_wszEmpty,
	    pwszQuote);
    }
    hr = S_OK;

error:
    if (NULL != pwszDate)
    {
	LocalFree(pwszDate);
    }
    return(hr);
}


HRESULT
cuDumpFileTimeOrPeriod(
    IN DWORD idMessage,
    OPTIONAL IN WCHAR const *pwszQuote,
    IN FILETIME const *pftGMT)
{
    HRESULT hr;
    
    if (0 <= (LONG) pftGMT->dwHighDateTime)
    {
	hr = cuDumpFileTime(idMessage, pwszQuote, pftGMT);
	_JumpIfError(hr, error, "cuDumpFileTime");
    }
    else
    {
	hr = cuDumpFileTimePeriod(idMessage, pwszQuote, pftGMT);
	_JumpIfError(hr, error, "cuDumpFileTimePeriod");
    }

error:
    return(hr);
}


HRESULT
cuDumpDate(
    IN DATE const *pDate)
{
    HRESULT hr;
    FILETIME ft;

    if (0.0 == *pDate)
    {
	ft.dwLowDateTime = 0;
	ft.dwHighDateTime = 0;
    }
    else
    {
	hr = myDateToFileTime(pDate, &ft);
	_JumpIfError(hr, error, "myDateToFileTime");
    }
    hr = cuDumpFileTime(0, NULL, &ft);
    _JumpIfError(hr, error, "cuDumpFileTime");

error:
    return(hr);
}


VOID
DumpBlob(
    IN DWORD idMessage,
    IN CRYPT_BIT_BLOB const *pBlob)
{
    if (NULL != pBlob->pbData)
    {
	wprintf(myLoadResourceString(idMessage));
	wprintf(wszNewLine);
	DumpHex(DH_NOTABPREFIX | 4, pBlob->pbData, pBlob->cbData);
    }
}


HRESULT
cuDisplayKeyIdFromExtension(
    IN DWORD cExtension,
    OPTIONAL IN CERT_EXTENSION const *rgExtension,
    BYTE const *pbHash,
    DWORD cbHash)
{
    HRESULT hr;

    hr = S_FALSE;
    if (0 != cExtension && NULL != rgExtension)
    {
	CERT_EXTENSION const *pExt;
	DWORD cb;
	CRYPT_DATA_BLOB aBlob[1 + BLOB_ROUND(CBMAX_CRYPT_HASH_LEN)];

	pExt = CertFindExtension(
			szOID_SUBJECT_KEY_IDENTIFIER,
			cExtension,
			const_cast<CERT_EXTENSION *>(rgExtension));
	if (NULL != pExt)
	{
	    cb = sizeof(aBlob);
	    if (!CryptDecodeObject(
				X509_ASN_ENCODING,
				X509_OCTET_STRING,
				pExt->Value.pbData,
				pExt->Value.cbData,
				0,
				aBlob,
				&cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptDecodeObject");
	    }
	    if (cbHash != aBlob[0].cbData ||
		0 != memcmp(pbHash, aBlob[0].pbData, aBlob[0].cbData))
	    {
		hr = DumpHash(
			NULL,
			IDS_FORMAT_SUBJECTKEYID_COLON, // "Subject Key Id (%ws): %ws"
			NULL,
			myLoadResourceString(IDS_PRECOMPUTED), // "precomputed"
			aBlob[0].pbData,
			aBlob[0].cbData);
		_JumpIfError(hr, error, "DumpHash");
	    }
	}
	hr = S_OK;
    }

error:
    return(hr);
}


HRESULT
cuDisplayKeyIdCanonicalized(
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo)
{
    HRESULT hr;
    CERT_PUBLIC_KEY_INFO PublicKeyInfo;
    BYTE *pbKey = NULL;
    DWORD cbKey;
    DWORD cbHash;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];

#if 0
    DumpHex(
	DH_NOTABPREFIX | 4,
	pPublicKeyInfo->PublicKey.pbData,
	pPublicKeyInfo->PublicKey.cbData);
#endif

    hr = myCanonicalizePublicKey(
		    pPublicKeyInfo->PublicKey.pbData,
		    pPublicKeyInfo->PublicKey.cbData,
		    &pbKey,
		    &cbKey);
    _JumpIfError2(hr, error, "myCanonicalizePublicKey", hr);

    PublicKeyInfo = *pPublicKeyInfo;
    PublicKeyInfo.PublicKey.pbData = pbKey;
    PublicKeyInfo.PublicKey.cbData = cbKey;

#if 0
    DumpHex(
	DH_NOTABPREFIX | 4,
	PublicKeyInfo.PublicKey.pbData,
	PublicKeyInfo.PublicKey.cbData);
#endif

    cbHash = sizeof(abHash);
    if (!CryptHashPublicKeyInfo(
			NULL,		// hCryptProv
			CALG_SHA1,
			0,		// dwFlags,
			X509_ASN_ENCODING,
			&PublicKeyInfo,
			abHash,
			&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptHashPublicKeyInfo");
    }
    hr = DumpHash(
	    NULL,
	    IDS_FORMAT_KEYIDHASH_COLON,	// "Public Key Hash(%ws): %ws"
	    myLoadResourceString(IDS_CANONICALIZED), // "canonicalized"
	    L"sha1",
	    abHash,
	    cbHash);
    _JumpIfError(hr, error, "DumpHash");

error:
    if (NULL != pbKey)
    {
	LocalFree(pbKey);
    }
    return(hr);
}


HRESULT
cuDisplayKeyId(
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN DWORD cExtension,
    OPTIONAL IN CERT_EXTENSION const *rgExtension)
{
    HRESULT hr;
    DWORD cbHash;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];

    cbHash = sizeof(abHash);
    if (!CryptHashPublicKeyInfo(
			NULL,		// hCryptProv
			CALG_SHA1,
			0,		// dwFlags,
			X509_ASN_ENCODING,
			const_cast<CERT_PUBLIC_KEY_INFO *>(pPublicKeyInfo),
			abHash,
			&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptHashPublicKeyInfo");
    }
    hr = DumpHash(
	    NULL,
	    IDS_FORMAT_KEYIDHASH_COLON,	// "Public Key Hash(%ws): %ws"
	    NULL,
	    L"sha1",
	    abHash,
	    cbHash);
    _JumpIfError(hr, error, "DumpHash");

    hr = cuDisplayKeyIdFromExtension(
			cExtension,
			rgExtension,
			abHash,
			cbHash);
    _PrintIfError2(hr, "cuDisplayKeyIdFromExtension", hr);

    hr = cuDisplayKeyIdCanonicalized(pPublicKeyInfo);
    _PrintIfError2(hr, "cuDisplayKeyIdCanonicalized", hr);

    hr = S_OK;

error:
    return(hr);
}


HRESULT
cuDisplayHash(
    OPTIONAL IN WCHAR const *pwszPrefix,
    OPTIONAL IN CERT_CONTEXT const *pCertContext,
    OPTIONAL IN CRL_CONTEXT const *pCRLContext,
    IN DWORD dwPropId,
    IN WCHAR const *pwszHashName)
{
    HRESULT hr;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    UINT idMsg;

    cbHash = sizeof(abHash);
    if (NULL != pCertContext)
    {
	if (!CertGetCertificateContextProperty(
				    pCertContext,
				    dwPropId,
				    abHash,
				    &cbHash))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateContextProperty");
	}
	idMsg = IDS_FORMAT_CERTHASH_COLON;	// "Cert Hash(%ws): %ws"
    }
    else
    {
	CSASSERT(NULL != pCRLContext);
	if (!CertGetCRLContextProperty(pCRLContext, dwPropId, abHash, &cbHash))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCRLContextProperty");
	}
	idMsg = IDS_FORMAT_CRLHASH_COLON;	// "CRL Hash(%ws): %ws"
    }
    hr = DumpHash(pwszPrefix, idMsg, NULL, pwszHashName, abHash, cbHash);
    _JumpIfError(hr, error, "DumpHash");

error:
    return(hr);
}


HRESULT
cuGetCertType(
    IN CERT_INFO const *pCertInfo,
    OPTIONAL OUT WCHAR **ppwszCertTypeNameV1,
    OPTIONAL OUT WCHAR **ppwszDisplayNameV1,
    OPTIONAL OUT WCHAR **ppwszCertTypeObjId,
    OPTIONAL OUT WCHAR **ppwszCertTypeName,
    OPTIONAL OUT WCHAR **ppwszDisplayName)
{
    HRESULT hr;
    CERT_EXTENSION *pExt;
    WCHAR *pwszCertTypeNameV1 = NULL;
    WCHAR *pwszCNV1 = NULL;
    WCHAR *pwszDisplayNameV1 = NULL;
    WCHAR *pwszCertTypeObjId = NULL;
    WCHAR *pwszCN = NULL;
    WCHAR *pwszDisplayName = NULL;
    CERT_TEMPLATE_EXT *pTemplate = NULL;

    if (NULL != ppwszCertTypeNameV1)
    {
	*ppwszCertTypeNameV1 = NULL;
    }
    if (NULL != ppwszDisplayNameV1)
    {
	*ppwszDisplayNameV1 = NULL;
    }
    if (NULL != ppwszCertTypeObjId)
    {
	*ppwszCertTypeObjId = NULL;
    }
    if (NULL != ppwszCertTypeName)
    {
	*ppwszCertTypeName = NULL;
    }
    if (NULL != ppwszDisplayName)
    {
	*ppwszDisplayName = NULL;
    }

    // Look for the V1 cert type extension first

    pExt = CertFindExtension(
		    szOID_ENROLL_CERTTYPE_EXTENSION,
		    pCertInfo->cExtension,
		    pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	hr = UnicodeDecode(&pExt->Value, &pwszCertTypeNameV1);
	_JumpIfError(hr, error, "UnicodeDecode");

	hr = cuGetTemplateNames(
			pwszCertTypeNameV1,
			&pwszCNV1,
			&pwszDisplayNameV1);
	_PrintIfErrorStr2(hr, "cuGetTemplateNames", pwszCertTypeNameV1, hr);
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	{
	    _JumpIfErrorStr(hr, error, "cuGetTemplateNames", pwszCertTypeNameV1);
	}
    }

    pExt = CertFindExtension(
		    szOID_CERTIFICATE_TEMPLATE,
		    pCertInfo->cExtension,
		    pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	DWORD cb;

	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_CERTIFICATE_TEMPLATE,
			pExt->Value.pbData,
			pExt->Value.cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pTemplate,
			&cb))
	{
	    CSASSERT(NULL == pTemplate);
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}
	if (!ConvertSzToWsz(&pwszCertTypeObjId, pTemplate->pszObjId, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertSzToWsz");
	}
	hr = cuGetTemplateNames(pwszCertTypeObjId, &pwszCN, &pwszDisplayName);
	_PrintIfErrorStr2(hr, "cuGetTemplateNames", pwszCertTypeObjId, hr);
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	{
	    _JumpIfErrorStr(hr, error, "cuGetTemplateNames", pwszCertTypeObjId);
	}

    }
    if (NULL == pwszCertTypeNameV1 && NULL == pwszCertTypeObjId)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError2(hr, error, "CertFindExtension", CRYPT_E_NOT_FOUND);
    }
    if (NULL != ppwszCertTypeNameV1)
    {
	if (NULL != pwszCNV1)
	{
	    *ppwszCertTypeNameV1 = pwszCNV1;
	    pwszCNV1 = NULL;
	}
	else
	{
	    *ppwszCertTypeNameV1 = pwszCertTypeNameV1;
	    pwszCertTypeNameV1 = NULL;
	}
    }
    if (NULL != ppwszDisplayNameV1)
    {
	*ppwszDisplayNameV1 = pwszDisplayNameV1;
	pwszDisplayNameV1 = NULL;
    }
    if (NULL != ppwszCertTypeObjId)
    {
	*ppwszCertTypeObjId = pwszCertTypeObjId;
	pwszCertTypeObjId = NULL;
    }
    if (NULL != ppwszCertTypeName)
    {
	*ppwszCertTypeName = pwszCN;
	pwszCN = NULL;
    }
    if (NULL != ppwszDisplayName)
    {
	*ppwszDisplayName = pwszDisplayName;
	pwszDisplayName = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszCertTypeNameV1)
    {
        LocalFree(pwszCertTypeNameV1);
    }
    if (NULL != pwszCNV1)
    {
        LocalFree(pwszCNV1);
    }
    if (NULL != pwszDisplayNameV1)
    {
        LocalFree(pwszDisplayNameV1);
    }
    if (NULL != pwszCertTypeObjId)
    {
        LocalFree(pwszCertTypeObjId);
    }
    if (NULL != pwszCN)
    {
        LocalFree(pwszCN);
    }
    if (NULL != pwszDisplayName)
    {
        LocalFree(pwszDisplayName);
    }
    if (NULL != pTemplate)
    {
        LocalFree(pTemplate);
    }
    return(hr);
}


HRESULT
cuDumpCertType(
    OPTIONAL IN WCHAR const *pwszPrefix,
    IN CERT_INFO const *pCertInfo)
{
    HRESULT hr;
    WCHAR *apwsz[6];
    DWORD i;
    DWORD j;
    BOOL fFirst;

    ZeroMemory(apwsz, sizeof(apwsz));

    hr = cuGetCertType(
		pCertInfo,
		&apwsz[0],		// ppwszCertTypeNameV1
		&apwsz[1],		// ppwszDisplayNameV1
		&apwsz[2],		// ppwszCertTypeObjId
		&apwsz[3],		// ppwszCertTypeName
		&apwsz[4]);		// ppwszDisplayName
    _JumpIfError2(hr, error, "cuGetCertType", CRYPT_E_NOT_FOUND);

    if (NULL != apwsz[2])	// pwszCertTypeObjId
    {
	WCHAR const *pwszFriendlyName;

	pwszFriendlyName = cuGetOIDName(apwsz[2]);
	if (NULL != pwszFriendlyName && L'\0' != *pwszFriendlyName)
	{
	    hr = myDupString(pwszFriendlyName, &apwsz[5]);
	    _JumpIfError(hr, error, "myDupString");
	}
    }

    wprintf(
	L"%ws%ws: ",
	NULL != pwszPrefix? pwszPrefix : L"",
	myLoadResourceString(IDS_TEMPLATE_NAME));	// "Template"

    // Suppress the long, ugly ObjId, unless they really want to see it:

    if (!g_fVerbose &&
	NULL != apwsz[2] &&
	(NULL != apwsz[0] || NULL != apwsz[3]))
    {
	LocalFree(apwsz[2]);
	apwsz[2] = NULL;
    }

    fFirst = TRUE;
    for (i = 0; i < ARRAYSIZE(apwsz); i++)
    {
	if (NULL != apwsz[i])
	{
	    BOOL fDup = FALSE;
	    
	    for (j = 0; j < i; j++)
	    {
		if (NULL != apwsz[j] && 0 == lstrcmp(apwsz[i], apwsz[j]))
		{
		    fDup = TRUE;
		    break;
		}
	    }
	    if (!fDup)
	    {
		if (!fFirst)
		{
		    wprintf(L", ");
		}
		wprintf(L"%ws", apwsz[i]);
		fFirst = FALSE;
	    }
	}
    }
    wprintf(wszNewLine);

error:
    for (i = 0; i < ARRAYSIZE(apwsz); i++)
    {
	if (NULL != apwsz[i])
	{
	    LocalFree(apwsz[i]);
	}
    }
    return(hr);
}


HRESULT
dumpCert(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CERT_CONTEXT const *pCertContext = NULL;
    CERT_INFO *pCertInfo;
    BOOL fIssuerMatches;
    DWORD id;

    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING, pbIn, cbIn);
    if (NULL == pCertContext)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    pCertInfo = pCertContext->pCertInfo;

    if (!g_fQuiet)
    {
	wprintf(myLoadResourceString(idMessage));
	wprintf(wszNewLine);

	cuDumpVersion(pCertInfo->dwVersion + 1);
    }

    hr = cuDumpSerial(NULL, IDS_SERIAL, &pCertInfo->SerialNumber);
    _JumpIfError(hr, error, "cuDumpSerial");

    if (!g_fQuiet)
    {
	cuDumpAlgorithm(IDS_SIGNATURE_ALGORITHM, &pCertInfo->SignatureAlgorithm);
    }

    hr = cuDisplayCertName(
		    !g_fQuiet,
		    NULL,
		    myLoadResourceString(IDS_ISSUER), // "Issuer"
		    g_wszPad4,
		    &pCertInfo->Issuer,
		    NULL);
    _JumpIfError(hr, error, "cuDisplayCertName(Issuer)");

    if (!g_fQuiet)
    {
	wprintf(wszNewLine);
	hr = cuDumpFileTime(IDS_NOTBEFORE, NULL, &pCertInfo->NotBefore);
	_JumpIfError(hr, error, "cuDumpFileTime");

	hr = cuDumpFileTime(IDS_NOTAFTER, NULL, &pCertInfo->NotAfter);
	_JumpIfError(hr, error, "cuDumpFileTime");

	wprintf(wszNewLine);
    }
    hr = cuDisplayCertName(
		    !g_fQuiet,
		    NULL,
		    myLoadResourceString(IDS_SUBJECT), // "Subject"
		    g_wszPad4,
		    &pCertInfo->Subject,
		    pCertInfo);
    _JumpIfError(hr, error, "cuDisplayCertName(Subject)");

    if (!g_fQuiet)
    {
	wprintf(wszNewLine);
	cuDumpPublicKey(&pCertInfo->SubjectPublicKeyInfo);
	DumpBlob(IDS_ISSUERUNIQUEID, &pCertInfo->IssuerUniqueId);
	DumpBlob(IDS_SUBJECTUNIQUEID, &pCertInfo->SubjectUniqueId);
    }

    hr = cuDumpExtensionArray(
			IDS_CERTIFICATE_EXTENSIONS,
			pCertInfo->cExtension,
			pCertInfo->rgExtension);
    _JumpIfError(hr, error, "cuDumpExtensionArray");

    if (!g_fQuiet)
    {
	cuDumpSignature(pcsci);
    }

    if (!CertCompareCertificateName(
			    X509_ASN_ENCODING,
			    &pCertInfo->Issuer,
			    &pCertInfo->Subject))
    {
	fIssuerMatches = FALSE;
    }
    else
    {
	fIssuerMatches = TRUE;
    }

    hr = cuVerifySignature(pbIn, cbIn, &pCertInfo->SubjectPublicKeyInfo, FALSE, TRUE);
    if (S_OK != hr)
    {
	if (fIssuerMatches)
	{
	    id = IDS_ERR_FORMAT_ROOT_CERT_BAD_SIG;	// "Possible Root Certificate: Subject matches Issuer, but Signature check fails: %x"
	}
	else
	{
	    id = IDS_NO_ROOT_CERT;	// "Non-root Certificate"
	}
    }
    else
    {
	if (fIssuerMatches)
	{
	    id = IDS_ROOT_CERT;	// "Root Certificate: Subject matches Issuer"
	}
	else
	{
	    id = IDS_NO_ROOT_CERT_GOOD_SIG;	// "Non-root Certificate uses same Public Key as Issuer"
	}
    }
    wprintf(myLoadResourceString(id), hr);
    wprintf(wszNewLine);

    if (g_fQuiet)
    {
	hr = cuDumpCertType(NULL, pCertContext->pCertInfo);
	_PrintIfError2(hr, "cuDumpCertType", CRYPT_E_NOT_FOUND);
    }
    else
    {
	cuDisplayKeyId(
		&pCertContext->pCertInfo->SubjectPublicKeyInfo,
		pCertContext->pCertInfo->cExtension,
		pCertContext->pCertInfo->rgExtension);
	hr = cuDisplayHash(
			NULL,
			pCertContext,
			NULL,
			CERT_MD5_HASH_PROP_ID,
			L"md5");
	_JumpIfError(hr, error, "cuDisplayHash");
    }
    hr = cuDisplayHash(
		    NULL,
		    pCertContext,
		    NULL,
		    CERT_SHA1_HASH_PROP_ID,
		    L"sha1");
    _JumpIfError(hr, error, "cuDisplayHash");

error:
    if (NULL != pCertContext)
    {
	CertFreeCertificateContext(pCertContext);
    }
    return(hr);
}


HRESULT
dumpCertSequence(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD iCert;
    CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY const *pSeq;

    pSeq = (CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY const *) pbDecoded;

    if (0 != strcmp(szOID_NETSCAPE_CERT_SEQUENCE, pSeq->pszObjId))
    {
	hr = CRYPT_E_ASN1_ERROR;
	_JumpError2(hr, error, "not a cert sequence", hr);
    }

    wprintf(myLoadResourceString(idMessage));
    wprintf(wszNewLine);

    hr = S_OK;
    for (iCert = 0; iCert < pSeq->cValue; iCert++)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_DUMP_CERT_INDEX),  // "================ Certificate %d ================"
	    iCert);
	wprintf(wszNewLine);

	hr2 = cuDumpAsnBinary(
			pSeq->rgValue[iCert].pbData,
			pSeq->rgValue[iCert].cbData,
			iCert);
	if (S_OK != hr2)
	{
	    cuPrintError(IDS_ERR_FORMAT_CANNOT_DECODE, hr2);
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }

error:
    return(hr);
}


HRESULT
dumpCRL(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CRL_CONTEXT const *pCRLContext = NULL;
    CRL_INFO const *pCRLInfo;
    DWORD i;
    CRL_ENTRY *pCRLEntry;

    CSASSERT(NULL != pbIn && 0 != cbIn);
    CSASSERT(NULL != pbDecoded && 0 != cbDecoded);

    pCRLContext = CertCreateCRLContext(X509_ASN_ENCODING, pbIn, cbIn);
    if (NULL == pCRLContext)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCRLContext");
    }
    pCRLInfo = pCRLContext->pCrlInfo;

    if (!g_fQuiet)
    {
	wprintf(myLoadResourceString(idMessage));
	wprintf(wszNewLine);

	cuDumpVersion(pCRLInfo->dwVersion + 1);
	cuDumpAlgorithm(IDS_SIGNATURE_ALGORITHM, &pCRLInfo->SignatureAlgorithm);
    }

    hr = cuDisplayCertName(
		    TRUE,
		    NULL,
		    myLoadResourceString(IDS_ISSUER), // "Issuer"
		    g_wszPad4,
		    &pCRLInfo->Issuer,
		    NULL);
    _JumpIfError(hr, error, "cuDisplayCertName(Issuer)");

    if (!g_fQuiet)
    {
	wprintf(wszNewLine);

	hr = cuDumpFileTime(IDS_THISUPDATE, NULL, &pCRLInfo->ThisUpdate);
	_JumpIfError(hr, error, "cuDumpFileTime");

	hr = cuDumpFileTime(IDS_NEXTUPDATE, NULL, &pCRLInfo->NextUpdate);
	_JumpIfError(hr, error, "cuDumpFileTime");

	wprintf(myLoadResourceString(IDS_CRLENTRIES)); // "CRL Entries:"
	wprintf(L" %u\n", pCRLInfo->cCRLEntry);

	for (i = 0; i < pCRLInfo->cCRLEntry; i++)
	{
	    pCRLEntry = &pCRLInfo->rgCRLEntry[i];

	    wprintf(g_wszPad2);
	    hr = cuDumpSerial(NULL, IDS_SERIAL, &pCRLEntry->SerialNumber);
	    _JumpIfError(hr, error, "cuDumpSerial");

	    wprintf(g_wszPad2);
	    hr = cuDumpFileTime(
			IDS_REVOCATIONDATE,
			NULL,
			&pCRLEntry->RevocationDate);
	    _JumpIfError(hr, error, "cuDumpFileTime");

	    if (0 != pCRLEntry->cExtension)
	    {
		wprintf(g_wszPad2);
		hr = cuDumpExtensionArray(
				    IDS_EXTENSIONS,
				    pCRLEntry->cExtension,
				    pCRLEntry->rgExtension);
		_JumpIfError(hr, error, "cuDumpExtensionArray");
	    }
	    wprintf(wszNewLine);
	}
    }
    if (0 != pCRLInfo->cExtension)
    {
	hr = cuDumpExtensionArray(
			    IDS_CRLEXTENSIONS,
			    pCRLInfo->cExtension,
			    pCRLInfo->rgExtension);
	_JumpIfError(hr, error, "cuDumpExtensionArray");
    }
    if (!g_fQuiet)
    {
	cuDumpSignature(pcsci);
	hr = cuDisplayHash(
			NULL,
			NULL,
			pCRLContext,
			CERT_MD5_HASH_PROP_ID,
			L"md5");
	_JumpIfError(hr, error, "cuDisplayHash");
    }
    hr = cuDisplayHash(
		    NULL,
		    NULL,
		    pCRLContext,
		    CERT_SHA1_HASH_PROP_ID,
		    L"sha1");
    _JumpIfError(hr, error, "cuDisplayHash");

error:
    return(hr);
}


HRESULT
dumpRequest(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CERT_REQUEST_INFO const *pRequest;
    CERT_EXTENSIONS *pExtInfo = NULL;

    CSASSERT(NULL != pbIn && 0 != cbIn);
    CSASSERT(NULL != pbDecoded && 0 != cbDecoded);

    wprintf(myLoadResourceString(idMessage));
    wprintf(wszNewLine);

    pRequest = (CERT_REQUEST_INFO const *) pbDecoded;

    cuDumpVersion(pRequest->dwVersion + 1);

    hr = cuDisplayCertName(
		    TRUE,
		    NULL,
		    myLoadResourceString(IDS_SUBJECT), // "Subject"
		    g_wszPad4,
		    &pRequest->Subject,
		    NULL);
    _JumpIfError(hr, error, "cuDisplayCertName(Subject)");

    wprintf(wszNewLine);
    cuDumpPublicKey(&pRequest->SubjectPublicKeyInfo);

    wprintf(myLoadResourceString(IDS_REQUEST_ATTRIBUTES)); // "Request Attributes:"
    wprintf(L" %u\n", pRequest->cAttribute);

    // Dump attributes and certificate extensions

    hr = DumpAttributes(
		    pRequest->rgAttribute,
		    pRequest->cAttribute,
		    FALSE,
		    FOT_ATTRIBUTE,
		    NULL,	// hStore
		    NULL,
		    NULL,
		    &pExtInfo);
    _JumpIfError(hr, error, "DumpAttributes");

    cuDumpSignature(pcsci);

    if (NULL != pcsci)
    {
	hr = cuVerifySignature(
			pbIn,
			cbIn,
			&pRequest->SubjectPublicKeyInfo,
			FALSE,
			FALSE);
	_JumpIfError(hr, error, "cuVerifySignature");
    }

    hr = cuDisplayKeyId(
		    &pRequest->SubjectPublicKeyInfo,
		    NULL == pExtInfo? 0 : pExtInfo->cExtension,
		    NULL == pExtInfo? NULL : pExtInfo->rgExtension);
    _JumpIfError(hr, error, "cuDisplayKeyId");

    hr = S_OK;

error:
    if (NULL != pExtInfo)
    {
	LocalFree(pExtInfo);
    }
    return(hr);
}


VOID
DumpCMCDataReference(
    IN DWORD dwCmcDataReference,
    IN DWORD cCertReference,
    IN DWORD const *rgdwCertReference)
{
    DWORD i;

    wprintf(
	L"    %ws: %u\n",
	myLoadResourceString(IDS_DATA_REFERENCE),
	dwCmcDataReference);

    for (i = 0; i < cCertReference; i++)
    {
	wprintf(
	    L"    %ws[%u]: %u\n",
	    myLoadResourceString(IDS_CERT_REFERENCE),
	    i,
	    rgdwCertReference[i]);
    }
}


HRESULT
DumpCMCStatus(
    IN CMC_STATUS_INFO const *pcmcStatus)
{
    HRESULT hr;
    WCHAR const *pwsz;
    DWORD i;

    switch (pcmcStatus->dwStatus)
    {
	case CMC_STATUS_SUCCESS:
	    pwsz = L"CMC_STATUS_SUCCESS";
	    break;

	case CMC_STATUS_FAILED:
	    pwsz = L"CMC_STATUS_FAILED";
	    break;

	case CMC_STATUS_PENDING:
	    pwsz = L"CMC_STATUS_PENDING";
	    break;

	case CMC_STATUS_NO_SUPPORT:
	    pwsz = L"CMC_STATUS_NO_SUPPORT";
	    break;

	case CMC_STATUS_CONFIRM_REQUIRED:
	    pwsz = L"CMC_STATUS_CONFIRM_REQUIRED";
	    break;

	default:
	    pwsz = g_wszEmpty;
	    break;
    }
    wprintf(
	L"    %ws: %ws(%u)\n",
	myLoadResourceString(IDS_CMC_STATUS),
	pwsz,
	pcmcStatus->dwStatus);

    for (i = 0; i < pcmcStatus->cBodyList; i++)
    {
	wprintf(
	    L"    %ws[%u]: %u\n",
	    myLoadResourceString(IDS_BODY_REFERENCE),
	    i,
	    pcmcStatus->rgdwBodyList[i]);
    }
    if (NULL != pcmcStatus->pwszStatusString)
    {
	wprintf(
	    L"    %ws: %ws\n",
	    myLoadResourceString(IDS_CMC_STATUSSTRING),
	    pcmcStatus->pwszStatusString);
    }
    switch (pcmcStatus->dwOtherInfoChoice)
    {
	case CMC_OTHER_INFO_NO_CHOICE:
	    pwsz = L"CMC_OTHER_INFO_NO_CHOICE";
	    break;

	case CMC_OTHER_INFO_FAIL_CHOICE:
	    pwsz = L"CMC_OTHER_INFO_FAIL_CHOICE";
	    break;

	case CMC_OTHER_INFO_PEND_CHOICE:
	    pwsz = L"CMC_OTHER_INFO_PEND_CHOICE";
	    break;

	default:
	    pwsz = g_wszEmpty;
	    break;
    }
    wprintf(
	L"    %ws: %ws(%u)\n",
	myLoadResourceString(IDS_CMC_OTHERCHOICE),
	pwsz,
	pcmcStatus->dwOtherInfoChoice);

    switch (pcmcStatus->dwOtherInfoChoice)
    {
	case CMC_OTHER_INFO_FAIL_CHOICE:
	    switch (pcmcStatus->dwFailInfo)
	    {
		case CMC_FAIL_BAD_ALG:
		    pwsz = L"CMC_FAIL_BAD_ALG";
		    break;

		case CMC_FAIL_BAD_MESSAGE_CHECK:
		    pwsz = L"CMC_FAIL_BAD_MESSAGE_CHECK";
		    break;

		case CMC_FAIL_BAD_REQUEST:
		    pwsz = L"CMC_FAIL_BAD_REQUEST";
		    break;

		case CMC_FAIL_BAD_TIME:
		    pwsz = L"CMC_FAIL_BAD_TIME";
		    break;

		case CMC_FAIL_BAD_CERT_ID:
		    pwsz = L"CMC_FAIL_BAD_CERT_ID";
		    break;

		case CMC_FAIL_UNSUPORTED_EXT:
		    pwsz = L"CMC_FAIL_UNSUPORTED_EXT";
		    break;

		case CMC_FAIL_MUST_ARCHIVE_KEYS:
		    pwsz = L"CMC_FAIL_MUST_ARCHIVE_KEYS";
		    break;

		case CMC_FAIL_BAD_IDENTITY:
		    pwsz = L"CMC_FAIL_BAD_IDENTITY";
		    break;

		case CMC_FAIL_POP_REQUIRED:
		    pwsz = L"CMC_FAIL_POP_REQUIRED";
		    break;

		case CMC_FAIL_POP_FAILED:
		    pwsz = L"CMC_FAIL_POP_FAILED";
		    break;

		case CMC_FAIL_NO_KEY_REUSE:
		    pwsz = L"CMC_FAIL_NO_KEY_REUSE";
		    break;

		case CMC_FAIL_INTERNAL_CA_ERROR:
		    pwsz = L"CMC_FAIL_INTERNAL_CA_ERROR";
		    break;

		case CMC_FAIL_TRY_LATER:
		    pwsz = L"CMC_FAIL_TRY_LATER";
		    break;

		default:
		    pwsz = g_wszEmpty;
		    break;
	    }
	    wprintf(
		L"    %ws: %ws(%u)\n",
		myLoadResourceString(IDS_CMC_FAILINFO),
		pwsz,
		pcmcStatus->dwFailInfo);
	    break;

	case CMC_OTHER_INFO_PEND_CHOICE:

	    wprintf(myLoadResourceString(IDS_PENDTOKEN)); //"Pend Token:"
	    DumpHex(
		DH_NOTABPREFIX | 4,
		pcmcStatus->pPendInfo->PendToken.pbData,
		pcmcStatus->pPendInfo->PendToken.cbData);

	    wprintf(g_wszPad4);
	    hr = cuDumpFileTime(
			IDS_PENDTIME,
			NULL,
			&pcmcStatus->pPendInfo->PendTime);
	    _JumpIfError(hr, error, "cuDumpFileTime");

	    break;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DumpCMCRegInfo(
    IN BYTE const *pbData,
    IN DWORD cbData)
{
    HRESULT hr;
    WCHAR *pwszDup = NULL;
    WCHAR *pwszBuf;
    WCHAR const *pwszName;
    WCHAR const *pwszValue;
    WCHAR *pwszNameAlloc = NULL;
    WCHAR *pwszValueAlloc = NULL;

    if (NULL == pbData || 0 == cbData)
    {
	hr = S_OK;
        goto error;		// silently ignore empty string
    }

    hr = myDecodeCMCRegInfo(pbData, cbData, &pwszDup);
    _JumpIfError(hr, error, "myDecodeCMCRegInfo");

    if (NULL != pwszDup)
    {
	pwszBuf = pwszDup;

	while (TRUE)
	{
	    hr = myParseNextAttribute(&pwszBuf, TRUE, &pwszName, &pwszValue);
	    if (S_FALSE == hr)
	    {
		break;
	    }
	    _JumpIfError(hr, error, "myParseNextAttribute");

	    if (NULL != pwszNameAlloc)
	    {
		LocalFree(pwszNameAlloc);
		pwszNameAlloc = NULL;
	    }
	    if (NULL != pwszValueAlloc)
	    {
		LocalFree(pwszValueAlloc);
		pwszValueAlloc = NULL;
	    }
	    hr = myUncanonicalizeURLParm(pwszName, &pwszNameAlloc);
	    _JumpIfError(hr, error, "myUncanonicalizeURLParm");

	    hr = myUncanonicalizeURLParm(pwszValue, &pwszValueAlloc);
	    _JumpIfError(hr, error, "myUncanonicalizeURLParm");

	    wprintf(L"%ws%ws: %ws\n", g_wszPad4, pwszNameAlloc, pwszValueAlloc);
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszNameAlloc)
    {
	LocalFree(pwszNameAlloc);
    }
    if (NULL != pwszValueAlloc)
    {
	LocalFree(pwszValueAlloc);
    }
    if (NULL != pwszDup)
    {
        LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
DumpTaggedAttributes(
    IN DWORD cTaggedAttribute,
    IN CMC_TAGGED_ATTRIBUTE const *rgTaggedAttribute)
{
    HRESULT hr;
    DWORD i;
    DWORD cb;
    CMC_ADD_EXTENSIONS_INFO *pcmcExt = NULL;
    CMC_ADD_ATTRIBUTES_INFO *pcmcAttrib = NULL;
    CMC_STATUS_INFO *pcmcStatus = NULL;

    wprintf(myLoadResourceString(IDS_TAGGED_ATTRIBUTES)); //"Tagged Attributes:"
    wprintf(L" %u\n", cTaggedAttribute);
    wprintf(wszNewLine);

    for (i = 0; i < cTaggedAttribute; i++)
    {
	CMC_TAGGED_ATTRIBUTE const *pTaggedAttribute = &rgTaggedAttribute[i];
	CRYPT_ATTRIBUTE const *pAttribute = &pTaggedAttribute->Attribute;
	DWORD j;

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_BODY_PART_ID)); // "Body Part Id:"
	wprintf(L" %u\n", pTaggedAttribute->dwBodyPartID);

	wprintf(g_wszPad2);
	cuDumpOIDAndDescriptionA(pAttribute->pszObjId);
	wprintf(wszNewLine);

	for (j = 0; j < pAttribute->cValue; j++)
	{
	    BOOL fUnknown = FALSE;

	    wprintf(L"  %ws[%u]:\n", myLoadResourceString(IDS_VALUE), j);

	    if (0 == strcmp(szOID_CMC_ADD_EXTENSIONS, pAttribute->pszObjId))
	    {
		// Decode CMC_ADD_EXTENSIONS_INFO from Attribute Blob

		CSASSERT(NULL == pcmcExt);
		if (!myDecodeObject(
				X509_ASN_ENCODING,
				CMC_ADD_EXTENSIONS,
				pAttribute->rgValue[j].pbData,
				pAttribute->rgValue[j].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pcmcExt,
				&cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}
		DumpCMCDataReference(
				pcmcExt->dwCmcDataReference,
				pcmcExt->cCertReference,
				pcmcExt->rgdwCertReference);

		wprintf(g_wszPad2);
		hr = cuDumpExtensionArray(
				IDS_EXTENSIONS,
				pcmcExt->cExtension,
				pcmcExt->rgExtension);
		_JumpIfError(hr, error, "cuDumpExtensionArray");

		LocalFree(pcmcExt);
		pcmcExt = NULL;
	    }
	    else
	    if (0 == strcmp(szOID_CMC_ADD_ATTRIBUTES, pAttribute->pszObjId))
	    {
		// Decode CMC_ADD_ATTRIBUTES_INFO from Attribute Blob

		CSASSERT(NULL == pcmcAttrib);
		if (!myDecodeObject(
				X509_ASN_ENCODING,
				CMC_ADD_ATTRIBUTES,
				pAttribute->rgValue[j].pbData,
				pAttribute->rgValue[j].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pcmcAttrib,
				&cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}
		DumpCMCDataReference(
				pcmcAttrib->dwCmcDataReference,
				pcmcAttrib->cCertReference,
				pcmcAttrib->rgdwCertReference);

		hr = DumpAttributes(
			    pcmcAttrib->rgAttribute,
			    pcmcAttrib->cAttribute,
			    FALSE,
			    FOT_ATTRIBUTE,
			    NULL,	// hStore
			    NULL,
			    NULL,
			    NULL);
		_JumpIfError(hr, error, "DumpAttributes");

		wprintf(wszNewLine);
		LocalFree(pcmcAttrib);
		pcmcAttrib = NULL;
	    }
	    else
	    if (0 == strcmp(szOID_CMC_STATUS_INFO, pAttribute->pszObjId))
	    {
		// Decode CMC_STATUS_INFO from Attribute Blob

		CSASSERT(NULL == pcmcStatus);
		if (!myDecodeObject(
				X509_ASN_ENCODING,
				CMC_STATUS,
				pAttribute->rgValue[j].pbData,
				pAttribute->rgValue[j].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pcmcStatus,
				&cb))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "myDecodeObject");
		}

		hr = DumpCMCStatus(pcmcStatus);
		_JumpIfError(hr, error, "DumpStatus");

		wprintf(wszNewLine);
		LocalFree(pcmcStatus);
		pcmcStatus = NULL;
	    }
	    else
	    if (0 == strcmp(szOID_CMC_TRANSACTION_ID, pAttribute->pszObjId))
	    {
		DWORD XactId;

		cb = sizeof(XactId);
		XactId = 0;
		if (CryptDecodeObject(
				    X509_ASN_ENCODING,
				    X509_INTEGER,
				    pAttribute->rgValue[j].pbData,
				    pAttribute->rgValue[j].cbData,
				    0,
				    &XactId,
				    &cb))
		{
		    wprintf(
			L"%ws%x(%u)\n\n",
			g_wszPad4,
			XactId,
			XactId);
		}
		else
		{
		    fUnknown = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(szOID_CMC_REG_INFO, pAttribute->pszObjId))
	    {
		hr = DumpCMCRegInfo(
			    pAttribute->rgValue[j].pbData,
			    pAttribute->rgValue[j].cbData);
		if (S_OK != hr)
		{
		    fUnknown = TRUE;
		}
	    }
	    else
	    if (0 == strcmp(szOID_CMC_QUERY_PENDING, pAttribute->pszObjId) ||
		0 == strcmp(szOID_CMC_SENDER_NONCE, pAttribute->pszObjId) ||
		0 == strcmp(szOID_CMC_RECIPIENT_NONCE, pAttribute->pszObjId))
	    {
		CRYPT_DATA_BLOB *pBlob;
		DWORD cbBlob;

		if (myDecodeObject(
				X509_ASN_ENCODING,
				X509_OCTET_STRING,
				pAttribute->rgValue[j].pbData,
				pAttribute->rgValue[j].cbData,
				CERTLIB_USE_LOCALALLOC,
				(VOID **) &pBlob,
				&cbBlob))
		{
		    DumpHex(
			DH_NOTABPREFIX | 4,
			pBlob->pbData,
			pBlob->cbData);
		    wprintf(wszNewLine);
		    LocalFree(pBlob);
		}
		else
		{
		    fUnknown = TRUE;
		}
	    }
	    else
	    {
		fUnknown = TRUE;
	    }
	    if (fUnknown)
	    {
		wprintf(myLoadResourceString(IDS_UNKNOWN_TAGGED_ATTRIBUTE)); // "UNKNOWN Tagged Attribute"
		wprintf(wszNewLine);
		DumpHex(
		    DH_NOTABPREFIX | 4,
		    pAttribute->rgValue[j].pbData,
		    pAttribute->rgValue[j].cbData);
		wprintf(wszNewLine);
	    }
	}
    }
    if (0 < i)
    {
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    if (NULL != pcmcExt)
    {
	LocalFree(pcmcExt);
    }
    if (NULL != pcmcAttrib)
    {
	LocalFree(pcmcAttrib);
    }
    if (NULL != pcmcStatus)
    {
	LocalFree(pcmcStatus);
    }
    return(hr);
}


HRESULT
DumpTaggedRequests(
    IN DWORD cTaggedRequest,
    IN CMC_TAGGED_REQUEST const *rgTaggedRequest)
{
    HRESULT hr;
    DWORD i;

    wprintf(myLoadResourceString(IDS_TAGGED_REQUESTS)); // "Tagged Requests:"
    wprintf(L" %u\n", cTaggedRequest);

    for (i = 0; i < cTaggedRequest; i++)
    {
	CMC_TAGGED_REQUEST const *pTaggedRequest = &rgTaggedRequest[i];
	CMC_TAGGED_CERT_REQUEST const *pTaggedCertRequest;

	switch (pTaggedRequest->dwTaggedRequestChoice)
	{
	    case CMC_TAGGED_CERT_REQUEST_CHOICE:
		pTaggedCertRequest = pTaggedRequest->pTaggedCertRequest;
		wprintf(L"  CMC_TAGGED_CERT_REQUEST_CHOICE:\n");
		wprintf(g_wszPad2);
		wprintf(myLoadResourceString(IDS_BODY_PART_ID)); // "Body Part Id:"
		wprintf(L" %u\n", pTaggedCertRequest->dwBodyPartID);

		hr = cuDumpAsnBinary(
			    pTaggedCertRequest->SignedCertRequest.pbData,
			    pTaggedCertRequest->SignedCertRequest.cbData,
			    i);
		_JumpIfError(hr, error, "cuDumpAsnBinary");
		break;

	    default:
		wprintf(myLoadResourceString(IDS_UNKNOWN_REQUEST_CHOICE)); // "UNKNOWN Request Choice"
		wprintf(wszNewLine);
		break;
	}
    }
    if (0 < i)
    {
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DumpTaggedContent(
    IN DWORD cTaggedContentInfo,
    IN CMC_TAGGED_CONTENT_INFO const *rgTaggedContentInfo)
{
    HRESULT hr;
    DWORD i;

    wprintf(myLoadResourceString(IDS_TAGGED_CONTENTINFO)); // "Tagged Content Info:"
    wprintf(L" %u\n", cTaggedContentInfo);

    for (i = 0; i < cTaggedContentInfo; i++)
    {
	CMC_TAGGED_CONTENT_INFO const *pTaggedContentInfo = &rgTaggedContentInfo[i];

	wprintf(g_wszPad2);
	wprintf(myLoadResourceString(IDS_BODY_PART_ID)); // "Body Part Id:"
	wprintf(L" %u\n", pTaggedContentInfo->dwBodyPartID);

	hr = cuDumpAsnBinary(
		    pTaggedContentInfo->EncodedContentInfo.pbData,
		    pTaggedContentInfo->EncodedContentInfo.cbData,
		    i);
	_JumpIfError(hr, error, "cuDumpAsnBinary");
    }
    if (0 < i)
    {
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DumpTaggedOther(
    IN DWORD cTaggedOtherMsg,
    IN CMC_TAGGED_OTHER_MSG const *rgTaggedOtherMsg)
{
    HRESULT hr;
    DWORD i;

    wprintf(myLoadResourceString(IDS_TAGGED_OTHERMESSAGES)); // "Tagged Other Messages:"
    wprintf(L" %u\n", cTaggedOtherMsg);

    for (i = 0; i < cTaggedOtherMsg; i++)
    {
	CMC_TAGGED_OTHER_MSG const *pTaggedOtherMsg = &rgTaggedOtherMsg[i];

	wprintf(L"  TaggedOtherMessage[%u]\n", i);
	wprintf(g_wszPad2);
	cuDumpOIDAndDescriptionA(pTaggedOtherMsg->pszObjId);

	wprintf(L"  %ws[%u]:\n", myLoadResourceString(IDS_VALUE), i);
	DumpHex(
	    DH_NOADDRESS | DH_NOTABPREFIX | 4,
	    pTaggedOtherMsg->Value.pbData,
	    pTaggedOtherMsg->Value.cbData);
    }
    if (0 < i)
    {
	wprintf(wszNewLine);
    }
    hr = S_OK;

//error:
    return(hr);
}


HRESULT
dumpCMCRequest(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CMC_DATA_INFO const *pcmcData;

    CSASSERT(NULL != pbIn && 0 != cbIn);
    CSASSERT(NULL != pbDecoded && 0 != cbDecoded);

    wprintf(myLoadResourceString(idMessage));
    wprintf(wszNewLine);

    pcmcData = (CMC_DATA_INFO const *) pbDecoded;

    hr = DumpTaggedAttributes(
			pcmcData->cTaggedAttribute,
			pcmcData->rgTaggedAttribute);
    _JumpIfError(hr, error, "DumpTaggedAttributes");

    hr = DumpTaggedRequests(
			pcmcData->cTaggedRequest,
			pcmcData->rgTaggedRequest);
    _JumpIfError(hr, error, "DumpTaggedRequests");

    hr = DumpTaggedContent(
			pcmcData->cTaggedContentInfo,
			pcmcData->rgTaggedContentInfo);
    _JumpIfError(hr, error, "DumpTaggedContent");

    hr = DumpTaggedOther(
			pcmcData->cTaggedOtherMsg,
			pcmcData->rgTaggedOtherMsg);
    _JumpIfError(hr, error, "DumpTaggedOther");

error:
    return(hr);
}


HRESULT
dumpCMCResponse(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CMC_RESPONSE_INFO const *pcmcResponse;

    CSASSERT(NULL != pbIn && 0 != cbIn);
    CSASSERT(NULL != pbDecoded && 0 != cbDecoded);

    wprintf(myLoadResourceString(idMessage));
    wprintf(wszNewLine);

    pcmcResponse = (CMC_RESPONSE_INFO const *) pbDecoded;

    hr = DumpTaggedAttributes(
			pcmcResponse->cTaggedAttribute,
			pcmcResponse->rgTaggedAttribute);
    _JumpIfError(hr, error, "DumpTaggedAttributes");

    hr = DumpTaggedContent(
			pcmcResponse->cTaggedContentInfo,
			pcmcResponse->rgTaggedContentInfo);
    _JumpIfError(hr, error, "DumpTaggedContent");

    hr = DumpTaggedOther(
			pcmcResponse->cTaggedOtherMsg,
			pcmcResponse->rgTaggedOtherMsg);
    _JumpIfError(hr, error, "DumpTaggedOther");

error:
    return(hr);
}


HRESULT
dumpKeyGenRequest(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CERT_KEYGEN_REQUEST_INFO const *pKeyGenRequest;

    CSASSERT(NULL != pbIn && 0 != cbIn);
    CSASSERT(NULL != pbDecoded && 0 != cbDecoded);

    wprintf(myLoadResourceString(idMessage));
    wprintf(wszNewLine);

    pKeyGenRequest = (CERT_KEYGEN_REQUEST_INFO const *) pbDecoded;

    cuDumpPublicKey(&pKeyGenRequest->SubjectPublicKeyInfo);

    wprintf(
	myLoadResourceString(IDS_FORMAT_CHALLENGE_STRING), // "ChallengeString: ""%ws"""
	pKeyGenRequest->pwszChallengeString);
    wprintf(wszNewLine);

    cuDumpSignature(pcsci);

    hr = cuVerifySignature(
		    pbIn,
		    cbIn,
		    &pKeyGenRequest->SubjectPublicKeyInfo,
		    FALSE,
		    FALSE);
    _JumpIfError(hr, error, "cuVerifySignature");

    hr = S_OK;

error:
    return(hr);
}


HRESULT
dumpCTL(
    IN DWORD idMessage,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN BYTE const *pbDecoded,
    IN DWORD cbDecoded,
    IN CERT_SIGNED_CONTENT_INFO const *pcsci)
{
    HRESULT hr;
    CTL_INFO const *pCTLInfo;
    CTL_CONTEXT const *pCTLContext = NULL;
    BOOL fIssuerMatches;
    DWORD id;
    DWORD i;

    pCTLInfo = (CTL_INFO const *) pbDecoded;

    //if (!g_fQuiet)
    {
	wprintf(myLoadResourceString(idMessage));
	wprintf(wszNewLine);

	cuDumpVersion(pCTLInfo->dwVersion + 1);
    }
    hr = cuDumpUsage(NULL, IDS_USAGEENTRIES, &pCTLInfo->SubjectUsage);
    _JumpIfError(hr, error, "cuDumpUsage");

    if (0 != pCTLInfo->ListIdentifier.cbData)
    {
	hr = cuDumpSerial(NULL, IDS_LISTID, &pCTLInfo->ListIdentifier);
	_JumpIfError(hr, error, "cuDumpSerial");
    }
    if (0 != pCTLInfo->SequenceNumber.cbData)
    {
	hr = cuDumpSerial(NULL, IDS_SEQUENCENO, &pCTLInfo->SequenceNumber);
	_JumpIfError(hr, error, "cuDumpSerial");
    }

    hr = cuDumpFileTime(IDS_THISUPDATE, NULL, &pCTLInfo->ThisUpdate);
    _JumpIfError(hr, error, "cuDumpFileTime");

    hr = cuDumpFileTime(IDS_NEXTUPDATE, NULL, &pCTLInfo->NextUpdate);
    _JumpIfError(hr, error, "cuDumpFileTime");

    cuDumpAlgorithm(IDS_SUBJECT_ALGORITHM, &pCTLInfo->SubjectAlgorithm);

    wprintf(myLoadResourceString(IDS_CTLENTRIES)); // "CTL Entries:"
    wprintf(L" %u\n", pCTLInfo->cCTLEntry);

    for (i = 0; i < pCTLInfo->cCTLEntry; i++)
    {
	CTL_ENTRY const *pCTLEntry = &pCTLInfo->rgCTLEntry[i];

	wprintf(wszNewLine);

	hr = DumpHash(
		g_wszEmpty,
		IDS_FORMAT_SUBJECTID_COLON,
		NULL,
		g_wszEmpty,
		pCTLEntry->SubjectIdentifier.pbData,
		pCTLEntry->SubjectIdentifier.cbData);
	_JumpIfError(hr, error, "DumpHash");

	hr = DumpAttributes(
			pCTLEntry->rgAttribute,
			pCTLEntry->cAttribute,
			g_fQuiet,
			FOT_ATTRIBUTE,
			NULL,		// hStore
			NULL,		// pbHashUserCert
			NULL,		// pcbHashUserCert
			NULL);		// ppExtInfo
	_JumpIfError(hr, error, "DumpAttributes");
    }
    hr = cuDumpExtensionArray(
		    IDS_EXTENSIONS,
		    pCTLInfo->cExtension,
		    pCTLInfo->rgExtension);
    _JumpIfError(hr, error, "cuDumpExtensionArray");

    hr = S_OK;

error:
    if (NULL != pCTLContext)
    {
	CertFreeCTLContext(pCTLContext);
    }
    return(hr);
}


HRESULT
verbDump(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfn,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    if (NULL == pwszfn)
    {
	hr = cuConfigDump();
	_JumpIfError(hr, error, "cuConfigDump");
    }
    else
    {
	hr = cuFileDump(pwszfn);
	_JumpIfErrorStr(hr, error, "cuFileDump", pwszfn);
    }

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\info.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       info.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop


#include <certca.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lmerr.h>
#include <lmaccess.h>
#include <lmapibuf.h>

#define __dwFILE__	__dwFILE_CERTUTIL_INFO_CPP__


#define DC_DELBAD	0x00000001
#define DC_DELALL	0x00000002
#define DC_VERIFY	0x00000004

// If you invoke DSSTORE with DC=mydc,DC=rd,DC=com  DSSTORE calls
// DsGetDcName(NULL, L"mydc", NULL, NULL, DS_RETURN_DNS_NAME, &pDCInfo);
//
// I suspect changing the code to pass L"mydc.rd.com" instead of L"mydc" would
// solve the problem.  I will look into this for the port of the code to
// certutil.exe.
//
// -----Original Message-----
// From: Christophe Lapeyre (Intl Vendor)
// Sent: Tuesday, January 09, 2001 3:30 AM
// To: Certificate Server Discussion Alias
// Subject: DSSTORE error 1355 (DsGetDCName failed)
//
//
// Hi all,
//
// I encountered the following problem with the DSSTORE tool:
//
// DSSTORE DC=mydc,DC=rd,DC=com -display
// DsGetDCName failed! - rc=1355 GLE - 3e5
// DsGetDCName failed! - rc=1355 GLE - 3e5
//
// Nltest /dsgetdc:mydc.rd.com just run ok.
//
// My Netbios domain name is different from my DNS domain name.
//
//
//
// There is a preview Kb article numbered Q280122, but I haven't been able to
// find a fix for this.




HRESULT
ExtractCertSubject(
    IN CERT_CONTEXT const *pcc,
    IN DWORD dwType,
    IN DWORD dwFlags,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    DWORD cwc;
    DWORD cwcBuf;
    WCHAR *pwszOut = NULL;

    *ppwszOut = NULL;
    cwcBuf = 0;
    while (TRUE)
    {
	cwc = CertGetNameString(
			pcc,
			dwType,
			dwFlags,
			NULL,		// pvTypePara
			pwszOut,
			cwcBuf);
	if (1 == cwc)
	{
	    hr = CRYPT_E_NOT_FOUND;
	    _JumpError(hr, error, "CertGetNameString");
	}
	if (NULL != pwszOut)
	{
	    break;
	}
	pwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwszOut)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	cwcBuf = cwc;
    }
    *ppwszOut = pwszOut;
    pwszOut = NULL;
    hr = S_OK;

error:
    if (NULL != pwszOut)
    {
	LocalFree(pwszOut);
    }
    return(hr);
}

static WCHAR *s_apwszKDCTemplates[] = {
    wszCERTTYPE_DC_AUTH,
    wszCERTTYPE_DS_EMAIL_REPLICATION,
    wszCERTTYPE_DC,
};

HRESULT
CheckForKDCCertificate(
    IN WCHAR const *pwszDC,
    IN DWORD dwFlags)
{
    HRESULT hr;
    HCERTSTORE hStoreRemote = NULL;
    WCHAR wszStorePath[512];
    WCHAR *apwszCertType[2] = { NULL, NULL };
    DWORD cCert = 0;
    DWORD dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    CERT_CONTEXT const *pcc = NULL;
    CERT_CONTEXT const *pccPrev = NULL;
    BOOL fDelete;
    BOOL fNewLine;
    DWORD i;
    DWORD j;
    CERT_ENHKEY_USAGE *pUsage = NULL;

    // If not doing delete operations, open "ReadOnly"

    if (0 == ((DC_DELALL | DC_DELBAD) & dwFlags))
    {
        dwOpenFlags |= CERT_STORE_READONLY_FLAG;
    }

    swprintf(wszStorePath, L"\\\\%ws\\" wszMY_CERTSTORE, pwszDC);
    hStoreRemote = CertOpenStore(
			    CERT_STORE_PROV_SYSTEM_W,
			    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			    NULL,
			    dwOpenFlags,
			    (VOID *) wszStorePath);
    if (NULL == hStoreRemote)
    {
        hr = myHLastError();
        _JumpError2(hr, error, "CertOpenStore", E_ACCESSDENIED);
    }

    wprintf(
	myLoadResourceString(IDS_FORMAT_KDCCERTS), // "** KDC Certificates for DC %ws"
	pwszDC);
    wprintf(wszNewLine);


    // Look for KDC certs

    fNewLine = FALSE;
    while (TRUE)
    {
        BOOL fKDCCert;

	for (i = 0; i < ARRAYSIZE(apwszCertType); i++)
	{
	    if (NULL != apwszCertType[i])
	    {
		LocalFree(apwszCertType[i]);
		apwszCertType[i] = NULL;
	    }
	}

	pcc = CertEnumCertificatesInStore(hStoreRemote, pccPrev);
	if (NULL == pcc)
	{
	    hr = myHLastError();
	    _PrintError2(hr, "CertEnumCertificatesInStore", CRYPT_E_NOT_FOUND);
	    break;
	}
        pccPrev = pcc;

        fKDCCert = FALSE;
	hr = cuGetCertType(
		    pcc->pCertInfo,
		    &apwszCertType[0],	// ppwszCertTypeNameV1
		    NULL,		// ppwszDisplayNameV1
		    NULL,		// ppwszCertTypeObjId
		    &apwszCertType[1],	// ppwszCertTypeName
		    NULL);		// ppwszDisplayName
	if (S_OK != hr)
	{
	    _PrintError(hr, "cuGetCertType");
	}
	else
	{
	    for (i = 0; i < ARRAYSIZE(apwszCertType); i++)
	    {
		if (NULL != apwszCertType[i])
		{
		    for (j = 0; j < ARRAYSIZE(s_apwszKDCTemplates); j++)
		    {
			if (0 == mylstrcmpiS(
				    apwszCertType[i],
				    s_apwszKDCTemplates[j]))
			{
			    fKDCCert = TRUE;

			}
		    }
		}
	    }
	}
	if (!fKDCCert)
	{
	    WCHAR const *pwsz = apwszCertType[0];
	    
	    if (NULL == apwszCertType[0])
	    {
		pwsz = apwszCertType[1];
	    }
	    if (g_fVerbose)
	    {
		wprintf(
		    myLoadResourceString(IDS_FORMAT_CERT_TYPE_NOT_DC),
		    pwsz);
		wprintf(wszNewLine);
	    }
	}

	if (NULL != pUsage)
	{
	    LocalFree(pUsage);
	    pUsage = NULL;
	}
	hr = myCertGetEnhancedKeyUsage(
				pcc,
				CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
				&pUsage);
	if (S_OK != hr)
	{
	    _PrintError2(hr, "myCertGetEnhancedKeyUsage", CRYPT_E_NOT_FOUND);
	}
	else
	{
	    for (i = 0; i < pUsage->cUsageIdentifier; i++)
	    {
		if (0 == strcmp(
			    szOID_KP_SMARTCARD_LOGON,
			    pUsage->rgpszUsageIdentifier[i]))
		{
		    fKDCCert = TRUE;
		    break;
		}
	    }
	}
	if (!fKDCCert)
	{
	    if (g_fVerbose)
	    {
		wprintf(
		    myLoadResourceString(IDS_FORMAT_CERT_USAGE_MISSING),
		    L"szOID_KP_SMARTCARD_LOGON");
		wprintf(wszNewLine);
	    }
	    if (!g_fForce || fDelete)
	    {
		continue;
	    }
	}

        // Cert passed test, dump issuer and subject

	wprintf(myLoadResourceString(IDS_FORMAT_CERT_COLON), cCert);
	wprintf(wszNewLine);

	hr = cuDumpAsnBinaryQuiet(
		    pcc->pbCertEncoded,
		    pcc->cbCertEncoded,
		    MAXDWORD);
	_PrintIfError(hr, "cuDumpAsnBinaryQuiet");

	wprintf(wszNewLine);
        cCert++;

        // perform operations on certificatess

	fDelete = 0 != (DC_DELALL & dwFlags);
        if ((DC_VERIFY | DC_DELBAD) & dwFlags)
	{
	    char *apszUsage[] =
	    {
		szOID_PKIX_KP_SERVER_AUTH,
		szOID_KP_SMARTCARD_LOGON,
	    };
	    DWORD VerifyState;

	    hr = cuVerifyCertContext(
				pcc,
				NULL,
				ARRAYSIZE(apszUsage),
				apszUsage,
				0,		// cIssuancePolicies
				NULL,		// apszIssuancePolicies
				TRUE,			// fNTAuth
				&VerifyState);
	    if (S_OK != hr)
	    {
		_PrintError(hr, "cuVerifyCertContext");
		if (CRYPT_E_REVOCATION_OFFLINE != hr)
		{
		    fDelete = 0 != (DC_DELBAD & dwFlags);
		}
	    }
        }
	if (fDelete)
	{
            CERT_CONTEXT const *pccDel;

            pccDel = CertDuplicateCertificateContext(pcc);
            if (!CertDeleteCertificateFromStore(pccDel))
	    {
                hr = myHLastError();
                wprintf(myLoadResourceString(IDS_FORMAT_DELETE_CERT_FROM_STORE_FAILED), hr);
		        wprintf(wszNewLine);
            }
	    else
	    {
                wprintf(myLoadResourceString(IDS_FORMAT_DELETE_DC_CERT));
		        wprintf(wszNewLine);
            }
        }
    }

    swprintf(wszStorePath, myLoadResourceString(IDS_FORMAT_KDC_PATH), cCert, pwszDC);
    wprintf(wszStorePath);
    wprintf(wszNewLine);
    if (0 == cCert)
    {
        wprintf(myLoadResourceString(IDS_NO_KDC_MY_STORE));
	wprintf(wszNewLine);
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "cCert");
    }
    hr = S_OK;

error:
    if (NULL != pUsage)
    {
	LocalFree(pUsage);
    }
    for (i = 0; i < ARRAYSIZE(apwszCertType); i++)
    {
	if (NULL != apwszCertType[i])
	{
	    LocalFree(apwszCertType[i]);
	}
    }
    if (NULL != hStoreRemote)
    {
        CertCloseStore(hStoreRemote, 0);
    }
    return(hr);
}


// This function queries the access token specified by the hToken parameter,
// and returns an allocated copy of the TokenUser information on success.
//
// The access token specified by hToken must be opened for TOKEN_QUERY access.
//
// On success, the return value is TRUE.  The caller is responsible for freeing
// the resultant UserSid via LocalFree.
//
// On failure, the caller does not need to free any buffer.

HRESULT
GetTokenUserSid(
    IN HANDLE hToken,		// token to query
    IN OUT PSID *ppUserSid)	// resultant user sid
{
    HRESULT hr;
    BYTE FastBuffer[256];
    BYTE *SlowBuffer = NULL;
    TOKEN_USER *ptgUser;
    DWORD cbBuffer;
    DWORD cbSid;

    *ppUserSid = NULL;

    // try querying based on a fast stack based buffer first.

    ptgUser = (TOKEN_USER *) FastBuffer;
    cbBuffer = sizeof(FastBuffer);

    if (!GetTokenInformation(
			hToken,		// identifies access token
			TokenUser,	// TokenUser info type
			ptgUser,	// retrieved info buffer
			cbBuffer,	// size of buffer passed-in
			&cbBuffer))	// required buffer size
    {
	hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
	{
	    _JumpError(hr, error, "GetTokenInformation");
	}

	// try again with the specified buffer size

	SlowBuffer = (BYTE *) LocalAlloc(LMEM_FIXED, cbBuffer);
	if (NULL == SlowBuffer)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	ptgUser = (TOKEN_USER *) SlowBuffer;

	if (!GetTokenInformation(
			    hToken,		// identifies access token
			    TokenUser,	// TokenUser info type
			    ptgUser,	// retrieved info buffer
			    cbBuffer,	// size of buffer passed-in
			    &cbBuffer))	// required buffer size
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetTokenInformation");
	}
    }

    // if we got the token info, copy the relevant element for the caller.

    cbSid = GetLengthSid(ptgUser->User.Sid);
    *ppUserSid = LocalAlloc(LMEM_FIXED, cbSid);
    if (NULL == *ppUserSid)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!CopySid(cbSid, *ppUserSid, ptgUser->User.Sid))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CopySid");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
        if (NULL != *ppUserSid)
	{
            LocalFree(*ppUserSid);
            *ppUserSid = NULL;
        }
    }
    if (NULL != SlowBuffer)
    {
        LocalFree(SlowBuffer);
    }
    return(hr);
}


// This routine obtains a domain controller computer name associated with
// the account related to the hToken access token.
//
// hToken should be opened for TOKEN_QUERY access.
// pwszDomain should be of size (UNCLEN+1)

HRESULT
GetDomainControllers(
    OPTIONAL IN WCHAR const *pwszDomain,
    IN HANDLE hToken,
    OUT DS_DOMAIN_CONTROLLER_INFO_1 **ppDCInfoOut,
    OUT DWORD *pcDC)
{
    HRESULT hr;
    PSID pSidUser = NULL;   // sid of client user.
    WCHAR wszUserName[UNLEN + 1];
    DWORD cwcUserName;
    WCHAR wszDomainName[DNLEN + 1]; // domain we want a controller for.
    DWORD cwcDomainName;
    SID_NAME_USE snu;
    DOMAIN_CONTROLLER_INFO *pDomainInfo = NULL;
    DS_DOMAIN_CONTROLLER_INFO_1 *pDcInfo = NULL;
    HANDLE hDS = INVALID_HANDLE_VALUE;
    BOOL fSuccess = FALSE;

    *ppDCInfoOut = NULL;
    if (NULL == pwszDomain)
    {
        // first, get the user sid associated with the specified access token.

        hr = GetTokenUserSid(hToken, &pSidUser);
        _JumpIfError(hr, error, "GetTokenUserSid");

        // next, lookup the domain name associated with the specified account.

	cwcUserName = ARRAYSIZE(wszUserName);
	cwcDomainName = ARRAYSIZE(wszDomainName);
        if (!LookupAccountSid(
			NULL,
			pSidUser,
			wszUserName,
			&cwcUserName,
			wszDomainName,
			&cwcDomainName,
			&snu))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "LookupAccountSid");
        }
    }
    else
    {
        wcscpy(wszDomainName, pwszDomain);
    }

    hr = DsGetDcName(
		NULL,
		wszDomainName,
		NULL,
		NULL,
		DS_RETURN_DNS_NAME,
		&pDomainInfo);
    _JumpIfError(hr, error, "DsGetDcName");

    // Get a handle to the DS on that machine

    hr = DsBind(pDomainInfo->DomainControllerName, NULL, &hDS);
    _JumpIfError(hr, error, "DsBind");

    // Use the handle to enumerate all of the DCs

    hr = DsGetDomainControllerInfo(
			    hDS,
			    pDomainInfo->DomainName,
			    1,		// info level
			    pcDC,
			    (VOID **) ppDCInfoOut);
    _JumpIfError(hr, error, "DsGetDomainControllerInfo");

error:
    if (INVALID_HANDLE_VALUE != hDS)
    {
        DsUnBind(&hDS);
    }
    if (NULL != pDomainInfo)
    {
        NetApiBufferFree(pDomainInfo);
    }
    if (NULL != pSidUser)
    {
        LocalFree(pSidUser);
    }
    return(hr);
}


HRESULT
OpenRemoteEnterpriseRoot(
    IN WCHAR const *pwszDC)
{
    HRESULT hr;
    HCERTSTORE hStoreRemote = NULL;
    WCHAR wszStorePath[512];
    DWORD cCert = 0;
    CERT_CONTEXT const *pcc = NULL;
    CERT_CONTEXT const *pccPrev;

    swprintf(wszStorePath, L"\\\\%ws\\" wszROOT_CERTSTORE, pwszDC);
    hStoreRemote = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			NULL,
			CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE |
			    CERT_STORE_READONLY_FLAG,
			(VOID *) wszStorePath);
    if (NULL == hStoreRemote)
    {
        hr = myHLastError();
        _JumpError2(hr, error, "CertOpenStore", E_ACCESSDENIED);
    }

    wprintf(
	myLoadResourceString(IDS_FORMAT_DCROOTCERTS), // "** Enterprise Root Certificates for DC %ws"
	pwszDC);
    wprintf(wszNewLine);

    // Dump issuer of enterprise roots.

    pccPrev = NULL;
    while (TRUE)
    {
	pcc = CertEnumCertificatesInStore(hStoreRemote, pccPrev);
	if (NULL == pcc)
	{
	    hr = myHLastError();
	    _PrintError2(hr, "CertEnumCertificatesInStore", CRYPT_E_NOT_FOUND);
	    break;
	}

	wprintf(myLoadResourceString(IDS_FORMAT_CERT_COLON), cCert);
	wprintf(wszNewLine);

	hr = cuDumpAsnBinaryQuiet(
		    pcc->pbCertEncoded,
		    pcc->cbCertEncoded,
		    MAXDWORD);
	_PrintIfError(hr, "cuDumpAsnBinaryQuiet");

	wprintf(wszNewLine);
        cCert++;
        pccPrev = pcc;
    }
    if (0 == cCert)
    {
        wprintf(myLoadResourceString(IDS_NO_KDC_ENT_STORE));
	    wprintf(wszNewLine);
	    hr = CRYPT_E_NOT_FOUND;
    }
    hr = S_OK;

error:
    if (NULL != hStoreRemote)
    {
        CertCloseStore(hStoreRemote, 0);
    }
    return(hr);
}


HRESULT
verbDCInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszFlags,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hrSave;
    HANDLE hToken = NULL;
    DS_DOMAIN_CONTROLLER_INFO_1 *pDcInfo = NULL;
    DWORD cDC = 0;
    DWORD dwFlags;
    DWORD i;
    WCHAR *pwszDomain = NULL;

    dwFlags = 0;
    if (NULL != pwszFlags)
    {
	if (0 == LSTRCMPIS(pwszFlags, L"DeleteAll"))
	{
	    dwFlags = DC_DELALL;
	}
	else
	if (0 == LSTRCMPIS(pwszFlags, L"DeleteBad"))
	{
	    dwFlags = DC_DELBAD | DC_VERIFY;
	}
	else
	if (0 == LSTRCMPIS(pwszFlags, L"Verify"))
	{
	    dwFlags = DC_VERIFY;
	}
	else
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad Flags");
	}
    }

    // Grovel the process token for user identity.  Used in determining
    // target domain

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken))
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenProcessToken");
    }

    // Use DS APIs to get all of the DCs in our domain

    hr = GetDomainControllers(pwszDomain, hToken, &pDcInfo, &cDC);
    _JumpIfError(hr, error, "GetDomainControllers");

    for (i = 0; i < cDC; i++)
    {
        wprintf(L"%u: %ws\n", i, pDcInfo[i].NetbiosName);
    }
    hrSave = S_OK;
    for (i = 0; i < cDC; i++)
    {
        WCHAR wszBuffer[512];

	wprintf(wszNewLine);
        wprintf(
	    myLoadResourceString(IDS_FORMAT_TESTINGDC), // "*** Testing DC[%u]: %ws"
	    i,
	    pDcInfo[i].NetbiosName);
	wprintf(wszNewLine);

        // Is DC available ?

        wsprintf(wszBuffer, L"\\\\%ws\\netlogon", pDcInfo[i].NetbiosName);

        if (MAXDWORD == GetFileAttributes(wszBuffer))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "GetFileAttributes", hr);
	    cuPrintError(IDS_DCUNAVAILABLE, hr);
	    if (S_OK == hrSave)
	    {
		hrSave = hr;
	    }
            continue;
        }

        // Open the enterprise root store, and make sure it's got the
        // NTDEV ROOT CERTIFICATE (subject #defined above)

        hr = OpenRemoteEnterpriseRoot(pDcInfo[i].NetbiosName);
	if (S_OK != hr)
	{
	    _PrintError2(hr, "OpenRemoteEnterpriseRoot", hr);
	    cuPrintError(IDS_REMOTEENTROOT, hr);
	    if (S_OK == hrSave)
	    {
		hrSave = hr;
	    }
	}

        // Make sure the machine has a *valid* KDC certificate

        hr = CheckForKDCCertificate(
				pDcInfo[i].NetbiosName,
				dwFlags);
	if (S_OK != hr)
	{
	    _PrintError2(hr, "CheckForKDCCertificate", hr);
	    cuPrintError(IDS_REMOTEKDCCERT, hr);
	    if (S_OK == hrSave)
	    {
		hrSave = hr;
	    }
	}
    }
    wprintf(wszNewLine);
    hr = hrSave;
    _JumpIfError2(hr, error, "verbDCInfo", hr);

error:
    if (NULL != pDcInfo)
    {
       DsFreeDomainControllerInfo(1, cDC, pDcInfo);
    }
    return(hr);
}


BOOL
IsAutoenrolledCert(
    IN CERT_CONTEXT const *pcc,
    OPTIONAL IN WCHAR const *pwszzTemplates)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    WCHAR *pwszTemplate = NULL;
    WCHAR const *pwsz;

    hr = cuGetCertType(pcc->pCertInfo, &pwszTemplate, NULL, NULL, NULL, NULL);
    if (S_OK != hr)
    {
	_PrintError(hr, "cuGetCertType");
	if (CRYPT_E_NOT_FOUND == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }

    pwsz = pwszzTemplates;
    if (NULL != pwsz)
    {
	for ( ; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    if (0 == mylstrcmpiL(pwsz, pwszTemplate))
	    {
		fMatch = TRUE;
		break;
	    }
	}
    }
    if (!fMatch)
    {
	DWORD i;
	
	for (i = 0; i < ARRAYSIZE(s_apwszKDCTemplates); i++)
	{
	    if (0 == mylstrcmpiS(pwszTemplate, s_apwszKDCTemplates[i]))
	    {
		fMatch = TRUE;
	    }
	}
    }

error:
    if (NULL != pwszTemplate)
    {
	LocalFree(pwszTemplate);
    }
    return(fMatch);
}


//
// Check for autoenrolled certificate
//

HRESULT
CheckForV1AutoenrolledCertificate(
    IN WCHAR const *pwszDC,
    OPTIONAL IN WCHAR const *pwszzTemplates)
{
    HRESULT hr;
    HCERTSTORE hStoreRemote = NULL;
    WCHAR wszStorePath[512];
    DWORD cCert;
    DWORD cCertArchived;
    DWORD dwArchiveBit;
    CERT_CONTEXT const *pcc;

    swprintf(wszStorePath, L"\\\\%ws\\" wszMY_CERTSTORE, pwszDC);

    hStoreRemote = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			NULL,
			CERT_STORE_READONLY_FLAG |
			    CERT_SYSTEM_STORE_LOCAL_MACHINE |
			    CERT_STORE_ENUM_ARCHIVED_FLAG,
			(VOID *) wszStorePath);
    if (NULL == hStoreRemote)
    {
        hr = myHLastError();
        wprintf(myLoadResourceString(IDS_FORMAT_OPEN_REMOTE_MY_FAILED), hr);
	wprintf(wszNewLine);
        goto error;
    }

    cCert = 0;
    cCertArchived = 0;
    pcc = NULL;
    while (TRUE)
    {
	pcc = CertEnumCertificatesInStore(hStoreRemote, pcc);
	if (NULL == pcc)
	{
	    break;
	}
	if (!IsAutoenrolledCert(pcc, pwszzTemplates) && 1 >= g_fForce)
	{
	    continue;
	}

        // Cert passed test, dump issuer and subject

	wprintf(myLoadResourceString(IDS_FORMAT_CERT_COLON), cCert);
	wprintf(wszNewLine);

        if (!CertGetCertificateContextProperty(
					pcc,
					CERT_ARCHIVED_PROP_ID,
					NULL,
					&dwArchiveBit))
	{
            hr = myHLastError();
            if (hr != CRYPT_E_NOT_FOUND)
	    {
                wprintf(myLoadResourceString(IDS_FORMAT_ERROR_GET_ARCHIVE_PROP), hr);
		wprintf(wszNewLine);
            }
        }
	else
	{
            wprintf(myLoadResourceString(IDS_LIST_ARCHIVED_CERT));
	    wprintf(wszNewLine);
            cCertArchived++;
        }

	hr = cuDumpSerial(g_wszPad2, IDS_SERIAL, &pcc->pCertInfo->SerialNumber);
	_PrintIfError(hr, "cuDumpSerial");

	hr = cuDisplayCertNames(FALSE, g_wszPad2, pcc->pCertInfo);
	_PrintIfError(hr, "cuDisplayCertNames");

	hr = cuDumpCertType(g_wszPad2, pcc->pCertInfo);
	_PrintIfError2(hr, "cuDumpCertType", CRYPT_E_NOT_FOUND);

	hr = cuDisplayHash(
		    g_wszPad2,
		    pcc,
		    NULL,
		    CERT_SHA1_HASH_PROP_ID,
		    L"sha1");
	_PrintIfError(hr, "cuDisplayHash");

	wprintf(wszNewLine);

        cCert++;
    }
    if (0 == cCert)
    {
        wprintf(myLoadResourceString(IDS_NO_AUTOENROLLED_CERT));
	wprintf(wszNewLine);
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "no AE certs");
    }
    wprintf(
	myLoadResourceString(IDS_FORMAT_MACHINE_AND_ARCHIVED_CERTS),
	cCert,
	cCertArchived);
    wprintf(L" ");
    wprintf(myLoadResourceString(IDS_FORMAT_FOR_DC), pwszDC);
    wprintf(wszNewLine);
    hr = S_OK;

error:
    if (NULL != hStoreRemote)
    {
        CertCloseStore(hStoreRemote, 0);
    }
    return(hr);
}


HRESULT
CheckForV1AutoenrollmentObject(
    IN WCHAR const *pwszDC,
    OUT WCHAR **ppwszzTemplates)
{
    HRESULT hr;
    HCERTSTORE hStoreRemote = NULL;
    WCHAR wszStorePath[512];
    DWORD cAE;
    CTL_CONTEXT const *pCTL;
    DWORD cwc;
    WCHAR *pwsz;

    *ppwszzTemplates = NULL;
    swprintf(wszStorePath, L"\\\\%ws\\" wszACRS_CERTSTORE, pwszDC);

    hStoreRemote = CertOpenStore(
			    CERT_STORE_PROV_SYSTEM,
			    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			    NULL,
			    CERT_SYSTEM_STORE_LOCAL_MACHINE |
				CERT_STORE_READONLY_FLAG,
			    (VOID *) wszStorePath);
    if (NULL == hStoreRemote)
    {
        hr = myHLastError();
        wprintf(myLoadResourceString(IDS_FORMAT_OPEN_STORE_REMOTE_ENT_FAILED), hr);
	wprintf(wszNewLine);
        goto error;
    }

    cwc = 1;
    cAE = 0;
    pCTL = NULL;
    while (TRUE)
    {
	pCTL = CertEnumCTLsInStore(hStoreRemote, pCTL);
	if (NULL == pCTL)
	{
	    break;
	}
	cwc += wcslen((WCHAR const *) pCTL->pCtlInfo->ListIdentifier.pbData) + 1;
        cAE++;
    }
    if (0 == cAE)
    {
        wprintf(myLoadResourceString(IDS_NO_AUTOENROLL_OBJECT));
        wprintf(wszNewLine);
    }
    else
    {
	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	*ppwszzTemplates = pwsz;

        wprintf(myLoadResourceString(IDS_V1_AUTOENROLLMENT_OBJECTS_COLON));
	while (TRUE)
	{
	    pCTL = CertEnumCTLsInStore(hStoreRemote, pCTL);
	    if (NULL == pCTL)
	    {
		break;
	    }
	    wprintf(L"  %ws\n", pCTL->pCtlInfo->ListIdentifier.pbData);
	    wcscpy(pwsz, (WCHAR const *) pCTL->pCtlInfo->ListIdentifier.pbData);
	    pwsz += wcslen(pwsz) + 1;
	    cAE++;
	}
	*pwsz++ = L'\0';
	CSASSERT(cwc == SAFE_SUBTRACT_POINTERS(pwsz, *ppwszzTemplates));
    }
    wprintf(wszNewLine);
    hr = S_OK;

error:
    if (NULL != hStoreRemote)
    {
        CertCloseStore(hStoreRemote, 0);
    }
    return(hr);
}


//
// This function takes a Marc Jacobs supplied text file (results from SSOLogon
// scripts) and runs through entmon for each machine in the list
//

HRESULT
verbEntInfo(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszSamMachine,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hrSave;
    WCHAR *pwszDomain = NULL;
    WCHAR *pwszMachine = NULL;
    WCHAR *pwszMachineName = NULL;
    WCHAR *pwszzTemplates = NULL;

    hr = mySplitConfigString(pwszSamMachine, &pwszDomain, &pwszMachine);
    _JumpIfError(hr, error, "mySplitConfigString");

    if (NULL == pwszMachine || NULL == wcschr(pwszMachine, L'$'))
    {
        wprintf(myLoadResourceString(IDS_ERROR_CHECK_MACHINE_NAME));
        wprintf(wszNewLine);
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad machine name");
    }

    // knock off trailing $
    hr = myDupString(pwszMachine, &pwszMachineName);
    _JumpIfError(hr, error, "myDupString");

    pwszMachineName[wcslen(pwszMachineName)-1] = L'\0';

    // assume for now that we're only interested in opening remote root store

    wprintf(myLoadResourceString(IDS_FORMAT_MACHINE_LIST), pwszMachine);
    wprintf(wszNewLine);


    // Cert store functions, if first fails, bail.

    hrSave = S_OK;
    hr = OpenRemoteEnterpriseRoot(pwszMachineName);
    if (S_OK != hr)
    {
	cuPrintError(IDS_REMOTEENTROOT, hr);
	_PrintError2(hr, "OpenRemoteEnterpriseRoot", hr);
	hrSave = hr;
    }
    else
    {
	hr = CheckForV1AutoenrollmentObject(pwszMachineName, &pwszzTemplates);
	_PrintIfError(hr, "CheckForV1AutoenrollmentObject");
	hrSave = hr;

	hr = CheckForV1AutoenrolledCertificate(pwszMachineName, pwszzTemplates);
	_PrintIfError(hr, "CheckForV1AutoenrolledCertificate");
	if (S_OK == hrSave && CRYPT_E_NOT_FOUND != hr)
	{
	    hrSave = hr;
	}
    }
    hr = cuGetGroupMembership(pwszSamMachine);
    _PrintIfError(hr, "cuGetGroupMembership");

    hr = hrSave;
    _JumpIfError2(hr, error, "RunEntmon", hr);

    wprintf(wszNewLine);

error:
    if (NULL != pwszzTemplates)
    {
	LocalFree(pwszzTemplates);
    }
    if (NULL != pwszDomain)
    {
	LocalFree(pwszDomain);
    }
    if (NULL != pwszMachine)
    {
	LocalFree(pwszMachine);
    }
    if (NULL != pwszMachineName)
    {
	LocalFree(pwszMachineName);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"certut"

#include <windows.h>
#include <stdlib.h>
#include <wincrypt.h>

#include "certsrv.h"

#include "certlib.h"
#include "csdisp.h"

#include "certutil.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\ds.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       ds.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop


#include <winldap.h>
#include <autoenr.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lmaccess.h>
#include <lmapibuf.h>

#include "csldap.h"
#include "certtype.h"
#include "csber.h"
#include "tmpllist.h"

#define __dwFILE__	__dwFILE_CERTUTIL_DS_CPP__


HRESULT
cuGetTemplateNames(
    IN WCHAR const *pwszTemplate,
    OUT WCHAR **ppwszCN,
    OUT WCHAR **ppwszDisplayName)
{
    HRESULT hr;
    WCHAR *pwszCN = NULL;
    WCHAR *pwszDisplayName = NULL;
    HCERTTYPE hCertType = NULL;
    DWORD dwFlags;
    WCHAR **apwszCertTypeName = NULL;
    WCHAR **apwszCertTypeCN = NULL;

    *ppwszCN = NULL;
    *ppwszDisplayName = NULL;

    dwFlags = CT_ENUM_USER_TYPES | CT_ENUM_MACHINE_TYPES;
    if (!g_fUserRegistry)
    {
	dwFlags |= CT_FIND_LOCAL_SYSTEM;
    }
    if (g_fForce)
    {
	dwFlags |= CT_FLAG_NO_CACHE_LOOKUP;
    }

    hr = CAFindCertTypeByName(pwszTemplate, NULL, dwFlags, &hCertType);
    if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
    {
	hr = CAFindCertTypeByName(
			    pwszTemplate,
			    NULL,
			    CT_FIND_BY_OID | dwFlags,
			    &hCertType);
    }
    _JumpIfErrorStr(hr, error, "CAFindCertTypeByName", pwszTemplate);

    hr = CAGetCertTypeProperty(
			hCertType,
			CERTTYPE_PROP_CN,
			&apwszCertTypeCN);
    _JumpIfError(hr, error, "CAGetCertTypeProperty");

    if (NULL != apwszCertTypeCN && NULL != apwszCertTypeCN[0])
    {
	hr = myDupString(apwszCertTypeCN[0], &pwszCN);
	_JumpIfError(hr, error, "myDupString");
    }

    hr = CAGetCertTypeProperty(
			hCertType,
			CERTTYPE_PROP_FRIENDLY_NAME,
			&apwszCertTypeName);
    _JumpIfError(hr, error, "CAGetCertTypeProperty");

    if (NULL != apwszCertTypeName && NULL != apwszCertTypeName[0])
    {
	hr = myDupString(apwszCertTypeName[0], &pwszDisplayName);
	_JumpIfError(hr, error, "myDupString");
    }

    if (NULL != pwszCN)
    {
	*ppwszCN = pwszCN;
        pwszCN = NULL;
    }
    if (NULL != pwszDisplayName)
    {
	*ppwszDisplayName = pwszDisplayName;
        pwszDisplayName = NULL;
    }
    hr = S_OK;

error:
    if (NULL != hCertType)
    {
	if (NULL != apwszCertTypeName)
	{
	    CAFreeCertTypeProperty(hCertType, apwszCertTypeName);
	}
	if (NULL != apwszCertTypeCN)
	{
	    CAFreeCertTypeProperty(hCertType, apwszCertTypeCN);
	}
	CACloseCertType(hCertType);
    }
    if (NULL != pwszCN)
    {
        LocalFree(pwszCN);
    }
    if (NULL != pwszDisplayName)
    {
        LocalFree(pwszDisplayName);
    }
    return(hr);
}


HRESULT
DumpDSStore(
    OPTIONAL IN WCHAR const *pwszDN,
    IN BOOL fCRL,
    IN BOOL fDeltaCRL,
    IN DWORD iCert,
    IN DWORD iCRL,
    OPTIONAL IN WCHAR const *pwszfnOut)
{
    HRESULT hr;
    HCERTSTORE hStoreDS = NULL;
    WCHAR *pwszServer = NULL;
    WCHAR *pwszCAName = NULL;
    WCHAR *pwszSanitizedName = NULL;
    WCHAR *pwszURL = NULL;
    WCHAR *pwszTemplateAlloc = NULL;
    WCHAR const *pwszTemplate;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    LDAP *pld = NULL;
    DWORD Mode;

    //if (NULL != pwszDN) wprintf(L"pwszDN = \"%ws\"\n", pwszDN);

    // Get the object name and open its cert or CRL store

    if (NULL == pwszDN)
    {
	if (NULL == g_pwszConfig)
	{
	    hr = cuSetConfig();
	    _JumpIfError(hr, error, "cuSetConfig");
	}
	pwszTemplate = fCRL?
	    g_wszzLDAPRevocationURLTemplate : g_wszzLDAPIssuerCertURLTemplate;

	hr = mySplitConfigString(g_pwszConfig, &pwszServer, &pwszCAName);
	_JumpIfError(hr, error, "mySplitConfigString");

	hr = mySanitizeName(pwszCAName, &pwszSanitizedName);
	_JumpIfError(hr, error, "mySanitizeName");

	hr = myLdapOpen(g_pwszDC, 0, &pld, &strDomainDN, &strConfigDN);
	_JumpIfError(hr, error, "myLdapOpen");
    }
    else
    {
	pwszTemplate = fCRL?
			wszFCSAPARM_DSCRLATTRIBUTE : 
			(g_fEnterpriseRegistry?
			    wszFCSAPARM_DSCROSSCERTPAIRATTRIBUTE :
			    (g_fUserRegistry?
				wszFCSAPARM_DSUSERCERTATTRIBUTE :
				wszFCSAPARM_DSCACERTATTRIBUTE));

	pwszTemplateAlloc = (WCHAR *) LocalAlloc(
		LMEM_FIXED,
		(wcslen(pwszDN) +
		 wcslen(pwszTemplate) + 1) * sizeof(WCHAR));
	if (NULL == pwszTemplateAlloc)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwszTemplateAlloc, pwszDN);
	wcscat(pwszTemplateAlloc, pwszTemplate);
	pwszTemplate = pwszTemplateAlloc;
    }

    hr = myFormatCertsrvStringArray(
	FALSE,						// fURL
	NULL != pwszServer? pwszServer : g_wszEmpty,	// pwszServerName_p1_2
	NULL != pwszSanitizedName? pwszSanitizedName : g_wszEmpty,
						      // pwszSanitizedName_p3_7
	0,						// iCert_p4
	MAXDWORD,					// iCertTarget_p4
	NULL != strDomainDN? strDomainDN : g_wszEmpty,	// pwszDomainDN_p5
	NULL != strConfigDN? strConfigDN : g_wszEmpty,	// pwszConfigDN_p6
	iCRL,						// iCRL_p8
	fDeltaCRL,					// fDeltaCRL_p9
	TRUE,						// fDSAttrib_p10_11
	1,						// cStrings
	&pwszTemplate,					// apwszStringsIn
	&pwszURL);					// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

    wprintf(L"\n%ws:\n", pwszURL);

    Mode = DVNS_DUMP;

    hr = cuOpenCertStore(pwszURL, &Mode, NULL, &hStoreDS);
    _JumpIfError(hr, error, "cuOpenCertStore");

    if (fCRL)
    {
	iCRL = MAXDWORD;
	if (NULL != pwszfnOut)
	{
	    iCRL = 0;
	}
    }
    hr = cuDumpAndVerifyStore(
			hStoreDS,
			DVNS_VERIFYCERT | DVNS_CASTORE | DVNS_DUMPPROPERTIES,
			NULL,		// pwszCertName
			iCert,
			iCRL,
			MAXDWORD,	// iCTL
			pwszfnOut,
			NULL);
    _JumpIfError(hr, error, "cuDumpAndVerifyStore");

error:
    if (NULL != pwszTemplateAlloc)
    {
	LocalFree(pwszTemplateAlloc);
    }
    if (NULL != pwszSanitizedName)
    {
	LocalFree(pwszSanitizedName);
    }
    if (NULL != pwszServer)
    {
	LocalFree(pwszServer);
    }
    if (NULL != pwszCAName)
    {
	LocalFree(pwszCAName);
    }
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    if (NULL != hStoreDS)
    {
	CertCloseStore(hStoreDS, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


HRESULT
verbDSCert(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszCertIndex,
    OPTIONAL IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD iCert = MAXDWORD;
    WCHAR const *pwszDN = NULL;

    if (NULL != pwszCertIndex)
    {
	hr = myGetLong(pwszCertIndex, (LONG *) &iCert);
	if (S_OK != hr)
	{
	    if (NULL != pwszfnOut)
	    {
		_JumpError(hr, error, "CertIndex must be a number");
	    }
	    pwszDN = pwszCertIndex;
	    iCert = MAXDWORD;
	}
    }
    hr = DumpDSStore(pwszDN, FALSE, FALSE, iCert, MAXDWORD, pwszfnOut);
    _JumpIfError(hr, error, "DumpDSStore");

error:
    return(hr);
}


HRESULT
GetCACertCount(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT DWORD *pcCACerts)
{
    HRESULT hr;
    BSTR str = NULL;
    DWORD cwc;
    WCHAR const *pwc;
    CAINFO CAInfo;

    hr = Request_GetCACertificate(
				pdiRequest,
				GETCERT_CAINFO,	// fExchangeCertificate
				g_pwszConfig,
				CR_OUT_BINARY,
				&str);
    _JumpIfError(hr, error, "Request_GetCACertificate(CAInfo)");

    cwc = wcslen(str);
    pwc = str;
		
    if (!cuParseDecimal(&pwc, &cwc, (DWORD *) &CAInfo.CAType) ||
	!cuParseDecimal(&pwc, &cwc, &CAInfo.cCASignatureCerts))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "cuParseDecimal");
    }
    *pcCACerts = CAInfo.cCASignatureCerts;

error:
    if (NULL != str)
    {
	SysFreeString(str);
    }
    return(hr);
}


HRESULT
GetCRLState(
    IN DISPATCHINTERFACE *pdiRequest,
    IN DWORD iCRL,
    OUT DWORD *pState)
{
    HRESULT hr;
    BSTR str = NULL;
    DWORD cwc;
    WCHAR const *pwc;

    hr = Request_GetCACertificate(
			pdiRequest,
			GETCERT_CRLSTATEBYINDEX | iCRL,	// fExchangeCertificate
			g_pwszConfig,
			CR_OUT_BINARY,
			&str);
    _JumpIfError(hr, error, "Request_GetCACertificate");

    cwc = wcslen(str);
    pwc = str;
		
    if (!cuParseDecimal(&pwc, &cwc, pState))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "cuParseDecimal");
    }

error:
    if (NULL != str)
    {
	SysFreeString(str);
    }
    return(hr);
}


HRESULT
DSCRLSub(
    IN BOOL fDeltaCRL,
    OPTIONAL IN WCHAR const *pwszCRLIndex,
    OPTIONAL IN WCHAR const *pwszfnOut)
{
    HRESULT hr;
    DWORD iCRL = MAXDWORD;
    DISPATCHINTERFACE diRequest;
    BOOL fMustRelease = FALSE;
    WCHAR const *pwszDN = NULL;

    if (NULL != pwszCRLIndex)
    {
	hr = myGetLong(pwszCRLIndex, (LONG *) &iCRL);
	if (S_OK != hr)
	{
	    if (NULL != pwszfnOut)
	    {
		_JumpError(hr, error, "CRLIndex must be a number");
	    }
	    pwszDN = pwszCRLIndex;
	    iCRL = MAXDWORD;
	}
    }
    if (NULL == pwszDN)
    {
	hr = cuSetConfig();
	_JumpIfError(hr, error, "cuSetConfig");
    }
    if (MAXDWORD == iCRL && NULL == pwszDN)
    {
	DWORD cCACerts;
	DWORD State;

	hr = Request_Init(g_DispatchFlags, &diRequest);
	_JumpIfError(hr, error, "Request_Init");

	fMustRelease = TRUE;

	hr = GetCACertCount(&diRequest, &cCACerts);
	_JumpIfError(hr, error, "GetCACertCount");

	for (iCRL = 0; iCRL < cCACerts; iCRL++)
	{
	    hr = GetCRLState(&diRequest, iCRL, &State);
	    _JumpIfError(hr, error, "GetCRLState");

	    if (CA_DISP_VALID != State)
	    {
		//wprintf(L"Skipping CRL.%u\n", iCRL);
		continue;
	    }
	    hr = DumpDSStore(NULL, TRUE, fDeltaCRL, MAXDWORD, iCRL, NULL);
	    _JumpIfError(hr, error, "DumpDSStore");
	}
    }
    else
    {
	hr = DumpDSStore(pwszDN, TRUE, fDeltaCRL, MAXDWORD, iCRL, pwszfnOut);
	_JumpIfError(hr, error, "DumpDSStore");
    }

error:
    if (fMustRelease)
    {
	Request_Release(&diRequest);
    }
    return(hr);
}


HRESULT
verbDSCRL(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszCRLIndex,
    OPTIONAL IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = DSCRLSub(FALSE, pwszCRLIndex, pwszfnOut);
    _JumpIfError(hr, error, "DSCRLSub");

error:
    return(hr);
}


HRESULT
verbDSDeltaCRL(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszCRLIndex,
    OPTIONAL IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = DSCRLSub(TRUE, pwszCRLIndex, pwszfnOut);
    _JumpIfError(hr, error, "DSCRLSub");

error:
    return(hr);
}


#define wszCOMMA	L","
#define wszCNEQUALS	L"CN="

DWORD
dsGetNumericSuffix(
    IN WCHAR const *pwszName)
{
    HRESULT hr;
    DWORD cwcPrefix;
    BOOL fDigit;
    WCHAR const *pwsz;

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    cwcPrefix = MAXDWORD;
    if (NULL == pwszName || L'\0' == *pwszName)
    {
	_JumpError2(hr, error, "empty", hr);
    }
    pwsz = &pwszName[wcslen(pwszName) - 1];
    if (wcRPAREN == *pwsz)
    {
	pwsz--;
	fDigit = FALSE;
	while (pwsz > pwszName && iswdigit(*pwsz))
	{
	    fDigit = TRUE;
	    pwsz--;
	}
	if (!fDigit || pwsz <= pwszName || wcLPAREN != *pwsz)
	{
	    _JumpError2(hr, error, "fDigit or wcLPAREN", hr);
	}
	cwcPrefix = SAFE_SUBTRACT_POINTERS(pwsz, pwszName);
    }

error:
    return(cwcPrefix);
}


BOOL
CACNBaseNameMatch(
    IN WCHAR const *pwszCNMatch,
    IN WCHAR const *pwszCN)
{
    HRESULT hr;
    WCHAR *pwszDup = NULL;
    BOOL fMatch = FALSE;
    DWORD iSuffix;
    WCHAR *pwsz;

    hr = myDupString(pwszCN, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    iSuffix = dsGetNumericSuffix(pwszDup);
    if (MAXDWORD != iSuffix)
    {
	pwszDup[iSuffix] = L'\0';	// truncate trailing "(#)"
    }
    pwsz = &pwszDup[wcslen(pwszDup) - WSZARRAYSIZE(L"-CDP") + 1];
    if (pwsz > pwszDup && 0 == LSTRCMPIS(pwsz, L"-CDP"))
    {
	*pwsz = '\0';			// truncate trailing L"-CDP"
    }
    if (0 != mylstrcmpiL(pwszCNMatch, pwszDup))	// compare base name
    {
	_JumpError2(hr, error, "no base name match", hr);
    }
    fMatch = TRUE;

error:
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(fMatch);
}


BOOL
CACNMatches(
    OPTIONAL IN WCHAR const *pwszCNMatch, 
    OPTIONAL IN WCHAR const *pwszOIDCN,
    IN WCHAR const *pwszRevertCN, 
    IN WCHAR const *pwszSanitizedCN,
    OPTIONAL IN WCHAR const *pwszDisplayName,
    OPTIONAL IN WCHAR const *pwszAlternateCN)
{
    BOOL fMatch = TRUE;
    
    // If no match criteria, match everything
    
    if (NULL == pwszCNMatch)
    {
	goto match;
    }

    // Check against the Desanitized short name or Sanitized short name.
    
    if (0 == mylstrcmpiL(pwszCNMatch, pwszRevertCN) ||
	0 == mylstrcmpiL(pwszCNMatch, pwszSanitizedCN))
    {
	goto match;
    }

    // Check against the displayName
    
    if (NULL != pwszDisplayName && 0 == mylstrcmpiL(pwszCNMatch, pwszDisplayName))
    {
	goto match;
    }

    // Check against the alternate CN (msPKI-Cert-Template-OID)
    
    if (NULL != pwszAlternateCN && 0 == mylstrcmpiL(pwszCNMatch, pwszAlternateCN))
    {
	goto match;
    }

    // Check against the OID converted to a CN
    
    if (NULL != pwszOIDCN &&
	0 == mylstrcmpiL(pwszOIDCN, pwszRevertCN))
    {
	goto match;
    }

    // Check against the Desanitized short name or Sanitized short name,
    // stripped of the key index and CDP tags.
    
    if (CACNBaseNameMatch(pwszCNMatch, pwszRevertCN) ||
	CACNBaseNameMatch(pwszCNMatch, pwszSanitizedCN))
    {
	goto match;
    }
    fMatch = FALSE;	// can't say we didn't try...

match:
    return(fMatch);
}


HRESULT
BuildDN(
    IN WCHAR const *pwszRDN,
    IN WCHAR const *pwszContainer,
    IN BOOL fAddCNEquals,
    OUT WCHAR **ppwszDN)
{
    HRESULT hr;
    WCHAR *pwszDN = NULL;
    DWORD cwc;

    *ppwszDN = NULL;
    cwc = wcslen(pwszRDN) + 1 + wcslen(pwszContainer) + 1;
    if (fAddCNEquals)
    {
	cwc += WSZARRAYSIZE(wszCNEQUALS);
    }
    pwszDN = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszDN)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *pwszDN = L'\0';
    if (fAddCNEquals)
    {
	wcscpy(pwszDN, wszCNEQUALS);
    }
    wcscat(pwszDN, pwszRDN);
    wcscat(pwszDN, wszCOMMA);
    wcscat(pwszDN, pwszContainer);
    *ppwszDN = pwszDN;
    pwszDN = NULL;
    hr = S_OK;

error:
    if (NULL != pwszDN)
    {
	LocalFree(pwszDN);
    }
    return(hr);
}


HRESULT
DeleteDN(
    IN LDAP *pld,
    OPTIONAL IN WCHAR const *pwszRDN,
    IN WCHAR const *pwszContainer)
{
    WCHAR *pwszDNAlloc = NULL;
    WCHAR const *pwszDN;
    HRESULT hr;

    pwszDN = pwszContainer;
    if (NULL != pwszRDN)
    {
	hr = BuildDN(pwszRDN, pwszContainer, TRUE, &pwszDNAlloc);
	_JumpIfError(hr, error, "BuildDN");

	pwszDN = pwszDNAlloc;
    }

    hr = ldap_delete_s(pld, const_cast<WCHAR *>(pwszDN));
    if (S_OK != hr)
    {
	hr = myHLdapError(pld, hr, NULL);
	_JumpErrorStr(hr, error, "ldap_delete_s", pwszDN);
    }

error:
    if (NULL != pwszDNAlloc)
    {
	LocalFree(pwszDNAlloc);
    }
    return(hr);
}



#define DSAF_STRING		0x00000001
#define DSAF_FLAGS		0x00000002
#define DSAF_BINARY		0x00000003
#define DSAF_GUID		0x00000004
#define DSAF_ASNDATE		0x00000005
#define DSAF_ASN		0x00000006
#define DSAF_FILETIME		0x00000007
#define DSAF_EXTENSION		0x00000008	// see pszObjId

typedef struct _EXTTEMPLATE
{
    WCHAR const *pwszObjId;	// wszOID_*
    BYTE const  *pbTemplate;	// Template
    DWORD        cbTemplate;	// Template length
    DWORD        cbAdd;		// Additional encoded length
} EXTTEMPLATE;


typedef struct _DSATTR
{
    WCHAR const *pwszName;	// Attribute name
    DWORD        Flags;		// DSAF_*
    UINT         idMsg;		// IDS_FORMAT_*
    EXTTEMPLATE *pExtension;
} DSATTR;



BYTE s_abTemplateKeyUsage[] = { BER_BIT_STRING, 0x00, 0x00 };

EXTTEMPLATE s_ExtKeyUsage =
{
    TEXT(szOID_KEY_USAGE),
    s_abTemplateKeyUsage,
    sizeof(s_abTemplateKeyUsage),
    1
};


DSATTR s_DSAttrBinary =
{
    L"",
    DSAF_BINARY,
    0,
    NULL,
};

DSATTR s_DSAttrString =
{
    L"",
    DSAF_STRING,
    0,
    NULL,
};

DSATTR s_aDSAttr[] =
{
  { wszDSUSERCERTATTRIBUTE,	  DSAF_ASN, IDS_FORMAT_DUMP_CERT_INDEX, NULL, },
  { wszDSCACERTATTRIBUTE,	  DSAF_ASN, IDS_FORMAT_DUMP_CERT_INDEX, NULL, },
  { wszDSCROSSCERTPAIRATTRIBUTE,  DSAF_ASN, IDS_FORMAT_DUMP_CERT_INDEX, NULL, },
  { wszDSAUTHORITYCRLATTRIBUTE,   DSAF_ASN, IDS_FORMAT_DUMP_CRL_INDEX,  NULL, },
  { wszDSBASECRLATTRIBUTE,	  DSAF_ASN, IDS_FORMAT_DUMP_CRL_INDEX,  NULL, },
  { wszDSDELTACRLATTRIBUTE,	  DSAF_ASN, IDS_FORMAT_DUMP_CRL_INDEX,  NULL, },
  { L"teletexTerminalIdentifier",        DSAF_ASN,       0, NULL, },
  { L"kCCStatus",		         DSAF_ASN,       0, NULL, },
  { CERTTYPE_PROP_CN,		         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_DN,		         DSAF_STRING,    0, NULL, },
  { L"name",			         DSAF_STRING,    0, NULL, },
  { L"showInAdvancedViewOnly",	         DSAF_STRING,    0, NULL, },
  { L"memberOf",			 DSAF_STRING,    0, NULL, },
  { L"operatingSystem",			 DSAF_STRING,    0, NULL, },
  { L"operatingSystemVersion",		 DSAF_STRING,    0, NULL, },
  { L"servicePrincipalName",		 DSAF_STRING,    0, NULL, },
  { L"sAMAccountName",			 DSAF_STRING,    0, NULL, },
  { L"description",			 DSAF_STRING,    0, NULL, },
  { L"isCriticalSystemObject",	         DSAF_STRING,    0, NULL, },
//{ L"uSNChanged",		         DSAF_STRING,    0, NULL, },
//{ L"uSNCreated",		         DSAF_STRING,    0, NULL, },
//{ L"instanceType",		         DSAF_STRING,    0, NULL, },
  { L"objectCategory",		         DSAF_STRING,    0, NULL, },
  { wszDSOBJECTCLASSATTRIBUTE,	         DSAF_STRING,    0, NULL, },
  { L"objectGUID",		         DSAF_GUID,      0, NULL, },
  { L"whenChanged",		         DSAF_ASNDATE,   0, NULL, },
  { L"whenCreated",		         DSAF_ASNDATE,   0, NULL, },
  { L"dSCorePropagationData",	         DSAF_ASNDATE,   0, NULL, },
  { CA_PROP_CERT_DN,		         DSAF_STRING,    0, NULL, },
  { CA_PROP_CERT_TYPES,		         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_FRIENDLY_NAME,         DSAF_STRING,    0, NULL, },
  { CA_PROP_DNSNAME,		         DSAF_STRING,    0, NULL, },
  { OID_PROP_LOCALIZED_NAME,	         DSAF_STRING,    0, NULL, },
  { OID_PROP_CPS,		         DSAF_STRING,    0, NULL, },
  { L"legacyExchangeDN",		 DSAF_STRING,    0, NULL, },
  { L"msExchADCGlobalNames",		 DSAF_STRING,    0, NULL, },
  { L"domainDefAltRecip",		 DSAF_STRING,    0, NULL, },
  { L"dXAAdminForward",			 DSAF_STRING,    0, NULL, },
  { L"kMServer",			 DSAF_STRING,    0, NULL, },
  { L"sendEMailMessage",		 DSAF_STRING,    0, NULL, },
  { L"serverReferenceBL",		 DSAF_STRING,    0, NULL, },
  { L"rIDSetReferences",		 DSAF_STRING,    0, NULL, },
  { L"frsComputerReferenceBL",		 DSAF_STRING,    0, NULL, },
  { L"serverReference",			 DSAF_STRING,    0, NULL, },
  { L"mailAddress",			 DSAF_STRING,    0, NULL, },
  { L"msDS-HasInstantiatedNCs",		 DSAF_STRING,	 0, NULL, },
  { L"msDS-HasDomainNCs",		 DSAF_STRING,	 0, NULL, },
  { L"msDS-hasMasterNCs",		 DSAF_STRING,	 0, NULL, },
  { L"hasMasterNCs",		 	 DSAF_STRING,	 0, NULL, },
  { L"dMDLocation",		 	 DSAF_STRING,	 0, NULL, },
  { L"userPrincipalName",	 	 DSAF_STRING,	 0, NULL, },
  { L"mail",			 	 DSAF_STRING,	 0, NULL, },
  { L"givenName",		 	 DSAF_STRING,	 0, NULL, },
  { L"sn",			 	 DSAF_STRING,	 0, NULL, },
// Template Schema Version 1 properties:
  { CERTTYPE_PROP_FLAGS,	         DSAF_FLAGS,     0, NULL, },
  { CERTTYPE_PROP_CSP_LIST,	         DSAF_STRING,    0, NULL, },
//{ CERTTYPE_PROP_DEFAULT_KEYSPEC,       DSAF_STRING,    0, NULL, },
//{ CERTTYPE_PROP_EXTENDED_KEY_USAGE,    DSAF_STRING,    0, NULL, },
//{ CERTTYPE_PROP_CRITICAL_EXTENSIONS,   DSAF_STRING,    0, NULL, },
//{ CERTTYPE_PROP_MAX_DEPTH,	         DSAF_STRING,    0, NULL, },
//{ CERTTYPE_PROP_REVISION,	         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_EXPIRATION,	         DSAF_FILETIME,  0, NULL, },
  { CERTTYPE_PROP_OVERLAP,	         DSAF_FILETIME,  0, NULL, },
  { CERTTYPE_PROP_KU,		         DSAF_EXTENSION, 0, &s_ExtKeyUsage, },
// Template Schema Version 2 properties:
  { CERTTYPE_RPOP_ENROLLMENT_FLAG,       DSAF_FLAGS,     0, NULL, },
  { CERTTYPE_PROP_NAME_FLAG,	         DSAF_FLAGS,     0, NULL, },
  { CERTTYPE_PROP_PRIVATE_KEY_FLAG,      DSAF_FLAGS,     0, NULL, },
  { CERTTYPE_PROP_SCHEMA_VERSION,        DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_MINOR_REVISION,        DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_RA_SIGNATURE,	         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_MIN_KEY_SIZE,	         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_OID,		         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_SUPERSEDE,	         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_RA_POLICY,	         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_RA_APPLICATION_POLICY, DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_POLICY,	         DSAF_STRING,    0, NULL, },
  { CERTTYPE_PROP_APPLICATION_POLICY,    DSAF_STRING,    0, NULL, },
};

#define ISEMPTYATTR(pberval)	\
    (0 == (pberval)->bv_len || \
     (1 == (pberval)->bv_len && 0 == *(BYTE const *) (pberval)->bv_val))


WCHAR const s_wszPad0[] = L"    ";
WCHAR const s_wszPad1[] = L"\t";


#define wszPUBLICKEYSERVICESCONTAINER \
    L"CN=Public Key Services," \
    L"CN=Services"

WCHAR const g_wszCNAuthoritiesOld[] =
    L"CN=Certification Authorities";

WCHAR const g_wszCNAuthorities[] =
    L"CN=Certification Authorities,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszEnterpriseCAs[] =
    //L"CN=NTAuthCertificates,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszCNKRA[] =
    L"CN=KRA,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszCNEnrollment[] =
    L"CN=Enrollment Services,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszCNAIA[] =
    L"CN=AIA,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszCNOID[] =
    L"CN=OID,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszCNCDP[] =
    L"CN=CDP,"
    wszPUBLICKEYSERVICESCONTAINER;

WCHAR const g_wszCNTemplates[] =
    L"CN=Certificate Templates,"
    wszPUBLICKEYSERVICESCONTAINER;


typedef struct _DSDN
{
    DWORD Flags;
    WCHAR const *pwszCN;
    WCHAR const *pwszChild;
    WCHAR const *pwszAlternateCNAttribute;
} DSDN;

#define DSDF_ADDCNEQUALS	0x00000001
#define DSDF_RECURSEONELEVEL	0x00000002
#define DSDF_DELETE		0x00000004
#define DSDF_INFDUMP		0x00000008
#define DSDF_DOMAINDN		0x00000010
#define DSDF_BASE		0x00000020

#define DSDF_CA			0x00000100
#define DSDF_TEMPLATE		0x00000200
#define DSDF_OID		0x00000400

#define DSDF_TYPEMASK		0x00000700

DSDN s_aDSDN[] =
{
 { 0,		  wszPUBLICKEYSERVICESCONTAINER, L"NTAuthCertificates", NULL },
 { DSDF_CA | DSDF_DOMAINDN,	   g_wszCNAuthoritiesOld, NULL, NULL },
 { DSDF_CA,			   g_wszCNAuthorities, NULL, NULL },
 { 0,				   g_wszCNKRA,	      NULL, NULL },
 { DSDF_CA,			   g_wszCNEnrollment, NULL, NULL },
 { DSDF_CA,			   g_wszCNAIA,	      NULL, NULL },
 { DSDF_CA | DSDF_RECURSEONELEVEL, g_wszCNCDP,	      NULL, NULL },
 { DSDF_OID,			   g_wszCNOID,	      NULL, OID_PROP_OID },
 { DSDF_TEMPLATE,		   g_wszCNTemplates,  NULL, CERTTYPE_PROP_OID },
};


HRESULT
dumpDSStringAttribute(
    IN LDAP *pld,
    IN LDAPMessage *pres,
    IN DWORD dwFlags,
    IN WCHAR const *pwszAttrName,
    IN DSATTR const *pdsa)
{
    HRESULT hr;
    WCHAR **rgpwszval = NULL;
    BOOL fInfDump = 0 != (DSDF_INFDUMP & dwFlags);

    rgpwszval = ldap_get_values(pld, pres, (WCHAR * const) pwszAttrName);
    if (NULL != rgpwszval)
    {
	LONG lVal;
	BOOL fValidNumber;
	WCHAR const *pwszVal;
	BOOL fCompact;
	DWORD i;
	WCHAR const *pwszSep;
	
	fCompact = fInfDump ||
	    (1 >= g_fVerbose && (NULL == rgpwszval[0] || NULL == rgpwszval[1]));
	if (!fCompact)
	{
	    wprintf(L"%ws%ws\n", s_wszPad0, pwszAttrName);
	}
	for (i = 0; NULL != (pwszVal = rgpwszval[i]); i++)
	{
	    pwszSep = L"";
	    if (fCompact)
	    {
		if (0 == i)
		{
		    wprintf(L"%ws%ws =", s_wszPad0, pwszAttrName);
		}
		else
		{
		    pwszSep = L",";
		}
	    }
	    else
	    {
		wprintf(s_wszPad1);
		wprintf(
		    myLoadResourceString(IDS_FORMAT_ELEMENT), // "Element %u:"
		    i);
	    }
	    wprintf(L"%ws \"%ws\"", pwszSep, pwszVal);

	    if (iswdigit(pwszVal[0]) || L'-' == pwszVal[0])
	    {
		if (L'-' == pwszVal[0])
		{
		    lVal = myWtoI(&pwszVal[1], &fValidNumber);
		    lVal = -lVal;
		}
		else
		{
		    lVal = myWtoI(pwszVal, &fValidNumber);
		}
		if (!fInfDump || g_fVerbose)
		{
		    if (fValidNumber)
		    {
			if (0 > lVal || 9 < lVal)
			{
			    wprintf(L" 0x%x", lVal);
			}
			if (DSAF_FLAGS == pdsa->Flags)
			{
			    WCHAR const *pwsz;

			    pwsz = pdsa->pwszName;
			    if (0 == LSTRCMPIS(pwsz, CERTTYPE_PROP_FLAGS))
			    {
				if (DSDF_CA & dwFlags)
				{
				    pwsz = wszCUREGDSCAFLAGS;
				}
				else if (DSDF_TEMPLATE & dwFlags)
				{
				    pwsz = wszCUREGDSTEMPLATEFLAGS;
				}
				else if (DSDF_OID & dwFlags)
				{
				    pwsz = wszCUREGDSOIDFLAGS;
				}
			    }
			    wprintf(wszNewLine);
			    cuRegPrintDwordValue(FALSE, pwsz, pwsz, lVal);
			}
		    }
		    else
		    {
			cuPrintPossibleObjectIdName(pwszVal);
		    }
		}
	    }
	    if (DSAF_ASNDATE == pdsa->Flags)
	    {
		WCHAR const *pwszT;
		FILETIME ft;
		DWORD cbft;
		DWORD cb;
		BYTE ab[MAX_PATH];

		cb = 0;
		ab[cb++] = BER_GENERALIZED_TIME;
		ab[cb++] = (BYTE) wcslen(pwszVal);

		for (pwszT = pwszVal; L'\0' != *pwszT; pwszT++)
		{
		    ab[cb++] = (BYTE) *pwszT;
		}
		cbft = sizeof(FILETIME);
		if (!CryptDecodeObject(
				X509_ASN_ENCODING,
				X509_CHOICE_OF_TIME,
				ab,
				cb,
				0,
				&ft,
				&cbft))
		{
		    wprintf(L"\n");
		    hr = myHLastError();
		    _PrintIfError(hr, "CryptDecodeObject");
		}
		else if (!fInfDump || g_fVerbose)
		{
		    cuDumpFileTime(0, NULL, &ft);
		}
	    }
	    else if (!fInfDump)
	    {
		wprintf(L"\n");
	    }
	    if (1 < g_fVerbose)
	    {
		DumpHex(
		    DH_NOADDRESS | DH_NOTABPREFIX | 12,
		    (BYTE const *) pwszVal,
		    wcslen(pwszVal) * sizeof(WCHAR));
	    }
	}
	if (fInfDump)
	{
	    wprintf(L"\n");
	}
    }
    hr = S_OK;

//error:
    if (NULL != rgpwszval)
    {
	ldap_value_free(rgpwszval);
    }
    return(hr);
}


BOOL
isStringAttribute(
    berval **rgpberval)
{
    BOOL fString = FALSE;
    DWORD i;
    DWORD cbTotal = 0;

    for (i = 0; NULL != rgpberval[i]; i++)
    {
	BYTE const *pb = (BYTE const *) rgpberval[i]->bv_val;
	DWORD cb = rgpberval[i]->bv_len;

	cbTotal += cb;
	if (0 < cb && '-' == *pb)
	{
	    pb++;
	    cb--;
	}
	while (0 < cb--)
	{
	    if (('0' > *pb || '9' < *pb) && '.' != *pb)
	    {
		goto error;
	    }
	    pb++;
	}
    }
    if (0 < cbTotal)
    {
	fString = TRUE;
    }

error:
    return(fString);
}


HRESULT
dumpDSBinaryAttribute(
    IN LDAP *pld,
    IN LDAPMessage *pres,
    IN DWORD dwFlags,
    IN WCHAR const *pwszAttrName,
    IN DSATTR const *pdsa)
{
    HRESULT hr;
    berval **rgpberval = NULL;
    BOOL fNewLine = FALSE;
    BOOL fInfDump = 0 != (DSDF_INFDUMP & dwFlags);

    rgpberval = ldap_get_values_len(pld, pres, (WCHAR * const) pwszAttrName);
    if (NULL != rgpberval)
    {
	BOOL fCompact;
	DWORD i;
	WCHAR const *pwszInfQuote = fInfDump? L"\"" : L"";

	if (&s_DSAttrBinary == pdsa && isStringAttribute(rgpberval))
	{
	    hr = dumpDSStringAttribute(
				pld,
				pres,
				dwFlags,
				pwszAttrName,
				&s_DSAttrString);
	    _PrintIfError(hr, "dumpDSStringAttribute");
	    goto error;
	}

	fCompact = fInfDump ||
	    (1 >= g_fVerbose && (NULL == rgpberval[0] || NULL == rgpberval[1]));
	if (!fCompact)
	{
	    wprintf(L"%ws%ws\n", s_wszPad0, pwszAttrName);
	}
	for (i = 0; NULL != rgpberval[i]; i++)
	{
	    BOOL fEmpty = ISEMPTYATTR(rgpberval[i]);
	    WCHAR const *pwszSep;

	    if (fCompact)
	    {
		wprintf(L"%ws%ws", s_wszPad0, pwszAttrName);
		pwszSep = L" = ";
	    }
	    else
	    {
		wprintf(s_wszPad1);
		wprintf(
		    myLoadResourceString(IDS_FORMAT_ELEMENT), // "Element %u:"
		    i);
		wprintf(
		    L" %u %ws",
		    rgpberval[i]->bv_len,
		    myLoadResourceString(IDS_BYTES)); // "Bytes"
		pwszSep = L" ";
	    }
	    if (fEmpty)
	    {
		wprintf(
		    L"%ws%ws\n",
		    pwszSep,
		    fInfDump?
			L"\"\"" :
			myLoadResourceString(IDS_PROP_EMPTY)); // "EMPTY"
	    }
	    else
	    {
		BOOL fHex = TRUE;
		
		if (DSAF_ASN == pdsa->Flags)
		{
		    if (!fInfDump)
		    {
			BOOL fVerboseOld = g_fVerbose;
			BYTE const *pb;
			DWORD cb;

			wprintf(wszNewLine);

			CSASSERT(g_fVerbose);
			g_fVerbose--;
			g_fQuiet = !g_fVerbose;
			if (g_fVerbose)
			{
			    g_fVerbose--;
			}
			if (0 != pdsa->idMsg)
			{
			    wprintf(
				myLoadResourceString(pdsa->idMsg),
				i);
			    wprintf(wszNewLine);
			}
			cb = rgpberval[i]->bv_len;
			pb = (BYTE const *) rgpberval[i]->bv_val;

			if (0 == cb ||
			    (1 == cb && (0 == *pb || ' ' == *pb)))
			{
			    hr = S_FALSE;
			}
			else
			{
			    if (SZARRAYSIZE(szPROPASNTAG) < cb &&
				0 == _strnicmp(
					    (char const *) pb,
					    szPROPASNTAG,
					    SZARRAYSIZE(szPROPASNTAG)))
			    {
				pb += SZARRAYSIZE(szPROPASNTAG);
				cb -= SZARRAYSIZE(szPROPASNTAG);
			    }
			    
			    hr = cuDumpAsnBinary(pb, cb, MAXDWORD);
			    _PrintIfError(hr, "cuDumpAsnBinary");
			}
			if (S_OK == hr)
			{
			    fHex = FALSE;
			}
			g_fVerbose = fVerboseOld;
			fNewLine = TRUE;
		    }
		}
		else if (DSAF_FILETIME == pdsa->Flags)
		{
		    FILETIME ft;
			
		    if (sizeof(ft) == rgpberval[i]->bv_len)
		    {
			wprintf(pwszSep);
			CopyMemory(&ft, rgpberval[i]->bv_val, sizeof(ft));
			hr = cuDumpFileTimeOrPeriod(0, pwszInfQuote, &ft);
			if (S_OK == hr)
			{
			    fHex = FALSE;
			}
		    }
		}
		else if (DSAF_EXTENSION == pdsa->Flags)
		{
		    if (!fInfDump)
		    {
			BOOL fQuietOld = g_fQuiet;
			DWORD cb;
			BYTE ab[MAX_PATH];

			cb = pdsa->pExtension->cbTemplate;
			CopyMemory(
				ab,
				pdsa->pExtension->pbTemplate,
				cb);
			CopyMemory(
				&ab[cb],
				rgpberval[i]->bv_val,
				rgpberval[i]->bv_len);
			ab[1] = (BYTE) (pdsa->pExtension->cbAdd + rgpberval[i]->bv_len);
			cb += rgpberval[i]->bv_len;

			wprintf(pwszSep);
			g_fQuiet = TRUE;
			if (!cuDumpFormattedExtension(
					pdsa->pExtension->pwszObjId,
					ab,
					cb))
			{
			    hr = myHLastError();
			    _PrintError(hr, "cuDumpFormattedExtension");
			}
			else
			{
			    fHex = FALSE;
			}
			g_fQuiet = fQuietOld;
			wprintf(wszNewLine);
		    }
		}
		else if (DSAF_GUID == pdsa->Flags)
		{
		    if (sizeof(GUID) == rgpberval[i]->bv_len)
		    {
			WCHAR *pwszGUID;
		    
			hr = myCLSIDToWsz(
				(GUID *) rgpberval[i]->bv_val,
				&pwszGUID);
			_PrintIfError(hr, "myCLSIDToWsz");
			if (S_OK == hr)
			{
			    wprintf(
				L"%ws%ws%ws%ws",
				pwszSep,
				pwszInfQuote,
				pwszGUID,
				pwszInfQuote);
			    LocalFree(pwszGUID);
			    fHex = FALSE;
			}
		    }
		    wprintf(wszNewLine);
		}
		else
		{
		    wprintf(wszNewLine);
		}
		if (fHex || 1 < g_fVerbose)
		{
		    if (fInfDump)
		    {
			BSTR strHex = NULL;
			
			hr = MultiByteIntegerToBstr(
					    TRUE,
					    rgpberval[i]->bv_len,
					    (BYTE const *) rgpberval[i]->bv_val,
					    &strHex);
			_JumpIfError(hr, error, "MultiByteIntegerToBstr");

			wprintf(L"%ws\"%ws\"\n", pwszSep, strHex);
			SysFreeString(strHex);
		    }
		    else
		    {
			DumpHex(
			    DH_NOADDRESS | DH_NOTABPREFIX | 12,
			    (BYTE const *) rgpberval[i]->bv_val,
			    rgpberval[i]->bv_len);
		    }
		}
	    }
	}
    }
    if (fNewLine)
    {
	wprintf(wszNewLine);
    }
    hr = S_OK;

error:
    if (NULL != rgpberval)
    {
	ldap_value_free_len(rgpberval);
    }
    return(hr);
}


HRESULT
dumpDSAttributes(
    IN LDAP *pld,
    IN LDAPMessage *pres,
    IN DWORD dwFlags)
{
    HRESULT hr;
    WCHAR *pwszAttrName;
    BerElement *pber = NULL;
    
    for (pwszAttrName = ldap_first_attribute(pld, pres, &pber); 
	 pwszAttrName != NULL; 
	 pwszAttrName = ldap_next_attribute(pld, pres, pber))
    {
	DSATTR const *pdsa;
		    
	for (pdsa = s_aDSAttr; ; pdsa++)
	{
	    if (pdsa >= &s_aDSAttr[ARRAYSIZE(s_aDSAttr)])
	    {
		pdsa = &s_DSAttrBinary;	// Unknown attribute
		break;
	    }
	    if (0 == mylstrcmpiS(pwszAttrName, pdsa->pwszName))
	    {
		break;
	    }
	}

	switch (pdsa->Flags)
	{
	    case DSAF_ASNDATE:
	    case DSAF_STRING:
	    case DSAF_FLAGS:
		hr = dumpDSStringAttribute(
					pld,
					pres,
					dwFlags,
					pwszAttrName,
					pdsa);
		_PrintIfError(hr, "dumpDSStringAttribute");
		break;

	    case DSAF_GUID:
	    case DSAF_FILETIME:
	    case DSAF_EXTENSION:
	    case DSAF_BINARY:
	    case DSAF_ASN:
		hr = dumpDSBinaryAttribute(
					pld,
					pres,
					dwFlags,
					pwszAttrName,
					pdsa);
		_PrintIfError(hr, "dumpDSBinaryAttribute");
		break;

	    default:
		CSASSERT(FALSE && pdsa->Flags);
		break;
	}
	ldap_memfree(pwszAttrName);
	pwszAttrName = NULL;
    }
    wprintf(L"\n");
    hr = S_OK;

//error:
    if (NULL != pber)
    {
	//ber_free(pber, 0);
    }
    return(hr);
}


HRESULT
AddCNList(
    IN WCHAR const *pwszCN,
    IN OUT WCHAR ***pppwsz)
{
    HRESULT hr;
    DWORD cpwsz = 0;
    WCHAR **ppwsz = *pppwsz;
    WCHAR **ppwszAlloc = NULL;
    WCHAR *pwszDup = NULL;

    hr = myDupString(pwszCN, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    if (NULL != ppwsz)
    {
	for ( ; NULL != ppwsz[cpwsz]; cpwsz++)
	    ;
    }
    if (NULL == ppwsz)
    {
	ppwszAlloc = (WCHAR **) LocalAlloc(
					LMEM_FIXED,
					2 * sizeof(*ppwszAlloc));
    }
    else
    {
	ppwszAlloc = (WCHAR **) LocalReAlloc(
					ppwsz,
					(cpwsz + 2) * sizeof(*ppwszAlloc),
					LMEM_MOVEABLE | LMEM_ZEROINIT);
    }
    if (NULL == ppwszAlloc)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(
		hr,
		error,
		NULL == ppwsz? "LocalAlloc" : "LocalReAlloc");
    }
    ppwszAlloc[cpwsz] = pwszDup;
    ppwszAlloc[cpwsz + 1] = NULL;
    pwszDup = NULL;
    *pppwsz = ppwszAlloc;
    hr = S_OK;

error:
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
dumpDSDNs(
    IN LDAP *pld,
    IN DWORD dwFlags,
    IN WCHAR const *pwszAlternateCNAttribute,
    IN WCHAR const *pwszCNMatch,
    IN WCHAR const *pwszRDN,
    OPTIONAL IN WCHAR const *pwszContainer,
    OPTIONAL OUT WCHAR ***pppwsz)
{
    HRESULT hr;
    WCHAR *pwszDNAlloc = NULL;
    WCHAR const *pwszDN;
    DWORD cwc;
    DWORD cres;
    LDAP_TIMEVAL timeval;
    LDAPMessage *pmsg = NULL;
    LDAPMessage *pres;
    WCHAR *pwszOIDCN = NULL;
    WCHAR *pwszAlternateCN = NULL;
    WCHAR *pwszDisplayName = NULL;
    WCHAR *pwszRevertCN = NULL;
    BOOL fFirst = TRUE;
    WCHAR **ppwszLdapVal = NULL;

    if (NULL != pppwsz)
    {
	*pppwsz = NULL;
    }
    if (NULL == pwszContainer)
    {
	pwszDN = pwszRDN;
    }
    else
    {
	hr = BuildDN(
		pwszRDN,
		pwszContainer,
		0 != (DSDF_ADDCNEQUALS & dwFlags),
		&pwszDNAlloc);
	_JumpIfError(hr, error, "BuildDN");

	pwszDN = pwszDNAlloc;
    }
    if (NULL != pwszCNMatch && iswdigit(*pwszCNMatch))
    {
	hr = myOIDHashOIDToString(pwszCNMatch, &pwszOIDCN);
	//_PrintIfError2(hr, "myOIDHashOIDToString", hr);
	_PrintIfError2(hr, "myOIDHashOIDToString", E_INVALIDARG);
    }

    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;
    hr = ldap_search_st(
		pld,				// ld
		const_cast<WCHAR *>(pwszDN),	// base
		(DSDF_BASE & dwFlags)? LDAP_SCOPE_BASE : LDAP_SCOPE_ONELEVEL,
		NULL,				// filter
		NULL,				// attrs
		FALSE,				// attrsonly
		&timeval,			// timeout
		&pmsg);				// res
    if (S_OK != hr)
    {
	hr = myHLdapError2(pld, hr, LDAP_NO_SUCH_OBJECT, NULL);
	_JumpErrorStr2(
		hr,
		error,
		"ldap_search_st",
		pwszDN,
		HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND));
    }
    cres = ldap_count_entries(pld, pmsg);
    if (0 == cres)
    {
	// No entries were found.

	goto error;
    }

    for (pres = ldap_first_entry(pld, pmsg); 
	 NULL != pres;
	 pres = ldap_next_entry(pld, pres))
    {
	if (NULL != pwszDisplayName)
	{
	    LocalFree(pwszDisplayName);
	    pwszDisplayName = NULL;
	}
	if (NULL != pwszAlternateCN)
	{
	    LocalFree(pwszAlternateCN);
	    pwszAlternateCN = NULL;
	}
	if (NULL != pwszRevertCN)
	{
	    LocalFree(pwszRevertCN);
	    pwszRevertCN = NULL;
	}

	CSASSERT(NULL == ppwszLdapVal);
	ppwszLdapVal = ldap_get_values(pld, pres, CA_PROP_DISPLAY_NAME);
	if (NULL != ppwszLdapVal)
	{
	    if (NULL != ppwszLdapVal[0])
	    {
		hr = myDupString(ppwszLdapVal[0], &pwszDisplayName);
		_JumpIfError(hr, error, "myDupString");
	    }
	    ldap_value_free(ppwszLdapVal);
	    ppwszLdapVal = NULL;
	}

	CSASSERT(NULL == ppwszLdapVal);
	if (NULL != pwszAlternateCNAttribute)
	{
	    ppwszLdapVal = ldap_get_values(
				pld,
				pres,
				const_cast<WCHAR *>(pwszAlternateCNAttribute));
	    if (NULL != ppwszLdapVal)
	    {
		if (NULL != ppwszLdapVal[0])
		{
		    hr = myDupString(ppwszLdapVal[0], &pwszAlternateCN);
		    _JumpIfError(hr, error, "myDupString");
		}
		ldap_value_free(ppwszLdapVal);
		ppwszLdapVal = NULL;
	    }
	}

	CSASSERT(NULL == ppwszLdapVal);
	ppwszLdapVal = ldap_get_values(pld, pres, CERTTYPE_PROP_CN);
	if (NULL != ppwszLdapVal)
	{
	    if (NULL != ppwszLdapVal[0])
	    {
		hr = myRevertSanitizeName(ppwszLdapVal[0], &pwszRevertCN);
		_JumpIfError(hr, error, "myRevertSanitizeName");

		if (CACNMatches(
			    pwszCNMatch,
			    pwszOIDCN,
			    pwszRevertCN,
			    ppwszLdapVal[0],
			    pwszDisplayName,
			    pwszAlternateCN))
		{
		    if (NULL != pppwsz)
		    {
			hr = AddCNList(ppwszLdapVal[0], pppwsz);
			_JumpIfError(hr, error, "AddCNList");
		    }
		    if (DSDF_INFDUMP & dwFlags)
		    {
			wprintf(L"\n[%ws]\n", ppwszLdapVal[0]);
		    }
		    else
		    {
			if (fFirst)
			{
			    wprintf(L"%ws:\n", pwszDN);
			}
			wprintf(
			    L"  %ws%ws%ws",
			    (DSDF_DELETE & dwFlags)?
				myLoadResourceString(IDS_DELETING) : // "Deleting"
				L"",
			    (DSDF_DELETE & dwFlags)? L" " : L"",
			    pwszRevertCN);
			if (0 != mylstrcmpiL(pwszRevertCN, ppwszLdapVal[0]))
			{
			    wprintf(L" -- %ws", ppwszLdapVal[0]);
			}
			wprintf(L"\n");
			if (!g_fVerbose &&
			    NULL != pwszAlternateCN &&
			    0 != mylstrcmpiL(pwszRevertCN, pwszAlternateCN))
			{
			    wprintf(L"    %ws\n", pwszAlternateCN);
			}
			if (!g_fVerbose &&
			    NULL != pwszDisplayName &&
			    0 != mylstrcmpiL(pwszRevertCN, pwszDisplayName))
			{
			    wprintf(L"    %ws\n", pwszDisplayName);
			}
		    }

		    if (DSDF_DELETE & dwFlags)
		    {
			DeleteDN(
			    pld,
			    (DSDF_BASE & dwFlags)? NULL : ppwszLdapVal[0],
			    pwszDN);
		    }
		    else if (g_fVerbose || (DSDF_INFDUMP & dwFlags))
		    {
			dumpDSAttributes(pld, pres, dwFlags);
		    }
		    fFirst = FALSE;
		}
	    }
	    ldap_value_free(ppwszLdapVal);
	    ppwszLdapVal = NULL;
	}
    }
    if (!fFirst)
    {
	wprintf(wszNewLine);
    }

    if (DSDF_RECURSEONELEVEL & dwFlags)
    {
	for (pres = ldap_first_entry(pld, pmsg); 
	     NULL != pres;
	     pres = ldap_next_entry(pld, pres))
	{
	    CSASSERT(NULL == ppwszLdapVal);
	    ppwszLdapVal = ldap_get_values(pld, pres, CERTTYPE_PROP_CN);
	    if (NULL != ppwszLdapVal)
	    {
		if (NULL != ppwszLdapVal[0])
		{
		    hr = dumpDSDNs(
				pld,
				DSDF_ADDCNEQUALS |
				    (~DSDF_RECURSEONELEVEL & dwFlags),
				pwszAlternateCNAttribute,
				pwszCNMatch,
				ppwszLdapVal[0],
				pwszDN,
				NULL);
		    _PrintIfError(hr, "dumpDSDNs");
		}
		ldap_value_free(ppwszLdapVal);
		ppwszLdapVal = NULL;
	    }
	}
    }

error:
    if (NULL != ppwszLdapVal)
    {
	ldap_value_free(ppwszLdapVal);
    }
    if (NULL != pmsg)
    {
	ldap_msgfree(pmsg);
    }
    if (NULL != pwszOIDCN)
    {
	LocalFree(pwszOIDCN);
    }
    if (NULL != pwszDisplayName)
    {
	LocalFree(pwszDisplayName);
    }
    if (NULL != pwszAlternateCN)
    {
	LocalFree(pwszAlternateCN);
    }
    if (NULL != pwszRevertCN)
    {
	LocalFree(pwszRevertCN);
    }
    if (NULL != pwszDNAlloc)
    {
	LocalFree(pwszDNAlloc);
    }
    return(hr);
}


HRESULT
DumpOrDeleteFromDS(
    OPTIONAL IN WCHAR const *pwszCN,
    IN BOOL fDelete)
{
    HRESULT hr;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    LDAP *pld = NULL;
    DSDN *pDSDN;
    BOOL fFullDN = FALSE;
    WCHAR awcType[4];	// for "CN=\0"

    hr = myLdapOpen(g_pwszDC, 0, &pld, &strDomainDN, &strConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    if (NULL != pwszCN && ARRAYSIZE(awcType) - 1 <= wcslen(pwszCN))
    {
	CopyMemory(awcType, pwszCN, sizeof(awcType) - sizeof(WCHAR));
	awcType[ARRAYSIZE(awcType) - 1] = L'\0';
	if (0 == LSTRCMPIS(awcType, L"CN="))
	{
	    dumpDSDNs(
		pld,
		DSDF_BASE | (fDelete? DSDF_DELETE : 0),
		NULL,
		NULL,
		pwszCN,
		NULL,
		NULL);
	    fFullDN = TRUE;
	}
    }
    if (!fFullDN)
    {
	for (pDSDN = s_aDSDN; pDSDN < &s_aDSDN[ARRAYSIZE(s_aDSDN)]; pDSDN++)
	{
	    DWORD dwFlags = (DSDF_TYPEMASK | DSDF_RECURSEONELEVEL) & pDSDN->Flags;
	    if (fDelete)
	    {
		dwFlags |= DSDF_DELETE;
	    }
	    if (NULL == pDSDN->pwszChild || !fDelete)
	    {
		dumpDSDNs(
		    pld,
		    dwFlags,
		    pDSDN->pwszAlternateCNAttribute,
		    NULL != pwszCN? pwszCN : pDSDN->pwszChild,
		    pDSDN->pwszCN,
		    (DSDF_DOMAINDN & pDSDN->Flags)? strDomainDN : strConfigDN,
		    NULL);
	    }
	}
    }

error:
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


HRESULT
verbDS(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszCN,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = DumpOrDeleteFromDS(pwszCN, FALSE);
    _JumpIfError(hr, error, "DumpOrDeleteFromDS");

error:
    return(hr);
}


HRESULT
verbDSDel(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszCN,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    CSASSERT(NULL != pwszCN);

    hr = DumpOrDeleteFromDS(pwszCN, TRUE);
    _JumpIfError(hr, error, "DumpOrDeleteFromDS");

error:
    return(hr);
}


#define wszINFSECTION_TEMPLATELIST	L"TemplateList"
#define wszINFKEY_TEMPLATE		L"Template"

HRESULT
verbDSTemplate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszTemplate,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    LDAP *pld = NULL;
    WCHAR **ppwszTemplates = NULL;
    WCHAR **ppwsz;

    hr = myLdapOpen(g_pwszDC, 0, &pld, &strDomainDN, &strConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    wprintf(
	L"[Version]\n"
	L"Signature = \"$Windows NT$\"\n"
	L"\n");

    dumpDSDNs(
	    pld,
	    DSDF_TEMPLATE | DSDF_INFDUMP,
	    CERTTYPE_PROP_OID,
	    pwszTemplate,
	    g_wszCNTemplates,
	    strConfigDN,
	    &ppwszTemplates);

    if (NULL != ppwszTemplates)
    {
	wprintf(L"[%ws]\n", wszINFSECTION_TEMPLATELIST);
	for (ppwsz = ppwszTemplates; NULL != *ppwsz; ppwsz++)
	{
	    wprintf(L"    %ws = \"%ws\"\n", wszINFKEY_TEMPLATE, *ppwsz);
	}
    }

error:
    if (NULL != ppwszTemplates)
    {
	for (ppwsz = ppwszTemplates; NULL != *ppwsz; ppwsz++)
	{
	    LocalFree(*ppwsz);
	}
	LocalFree(ppwszTemplates);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


typedef struct _CTFLAGS {
    DWORD dwOption;
    WCHAR const *pwszLookupName;
    WCHAR const *pwszPropName;
} CTFLAGS;

// The last entry has a prefix added to distinguish the name enough to display
// the correct symbolic names for its bit fields.  "flags" is too generic.

CTFLAGS g_actf[] = {
    {
	CERTTYPE_ENROLLMENT_FLAG,
	CERTTYPE_RPOP_ENROLLMENT_FLAG,
	CERTTYPE_RPOP_ENROLLMENT_FLAG,
    },
    {
	CERTTYPE_SUBJECT_NAME_FLAG,
	CERTTYPE_PROP_NAME_FLAG,
	CERTTYPE_PROP_NAME_FLAG,
    },
    {
	CERTTYPE_PRIVATE_KEY_FLAG,
	CERTTYPE_PROP_PRIVATE_KEY_FLAG,
	CERTTYPE_PROP_PRIVATE_KEY_FLAG,
    },
    {
	CERTTYPE_GENERAL_FLAG,
	wszCUREGDSTEMPLATEFLAGS,
	CERTTYPE_PROP_FLAGS,
    },
};


typedef struct _CTPROP {
    BOOL         fString;
    WCHAR const *pwszPropName;
} CTPROP;

CTPROP g_actProp[] = {
    { TRUE,  CERTTYPE_PROP_CN, },
    { TRUE,  CERTTYPE_PROP_DN, },
    { TRUE,  CERTTYPE_PROP_FRIENDLY_NAME, },
    { TRUE,  CERTTYPE_PROP_EXTENDED_KEY_USAGE, },
    { TRUE,  CERTTYPE_PROP_CSP_LIST, },
    { TRUE,  CERTTYPE_PROP_CRITICAL_EXTENSIONS, },
    { FALSE, CERTTYPE_PROP_REVISION, },
    { FALSE, CERTTYPE_PROP_SCHEMA_VERSION, },
    { FALSE, CERTTYPE_PROP_MINOR_REVISION, },
    { FALSE, CERTTYPE_PROP_RA_SIGNATURE, },
    { FALSE, CERTTYPE_PROP_MIN_KEY_SIZE, },
    { TRUE,  CERTTYPE_PROP_OID, },
    { TRUE,  CERTTYPE_PROP_SUPERSEDE, },
    { TRUE,  CERTTYPE_PROP_RA_POLICY, },
    { TRUE,  CERTTYPE_PROP_RA_APPLICATION_POLICY, },
    { TRUE,  CERTTYPE_PROP_POLICY, },
    { TRUE,  CERTTYPE_PROP_APPLICATION_POLICY, },
};


# if 0
BYTE ab0[sizeof(FILETIME)] =
{ 0x00, 0x80, 0x37, 0xae, 0xff, 0xf4, 0xff, 0xff }; // 2 Weeks


BYTE ab1[sizeof(FILETIME)] =
{ 0x00, 0x40, 0x39, 0x87, 0x2e, 0xe1, 0xfe, 0xff }; // 1 Years


BYTE ab2[sizeof(FILETIME)] =
{ 0x00, 0x80, 0x72, 0x0e, 0x5d, 0xc2, 0xfd, 0xff }; // 2 Years


BYTE ab3[sizeof(FILETIME)] =
{ 0x00, 0x40, 0x1e, 0xa4, 0xe8, 0x65, 0xfa, 0xff }; // 5 Years


void
dumpConstantValidityPeriod(
    FILETIME const *pft)
{
    if (1 < g_fVerbose)
    {
	wprintf(wszNewLine);
	cuDumpFileTimeOrPeriod(0, NULL, pft);
	DumpHex(
	    DH_NOADDRESS | DH_NOASCIIHEX | DH_NOTABPREFIX | 4,
	    (BYTE const *) pft,
	    sizeof(*pft));
	wprintf(wszNewLine);
    }
}

void
dumpConstantValidityPeriods()
{
    dumpConstantValidityPeriod((FILETIME const *) ab0);
    dumpConstantValidityPeriod((FILETIME const *) ab1);
    dumpConstantValidityPeriod((FILETIME const *) ab2);
    dumpConstantValidityPeriod((FILETIME const *) ab3);
}
#endif


HRESULT
dsDumpTemplateInfo(
    IN HCERTTYPE hCertType)
{
    HRESULT hr;
    DWORD i;
    DWORD j;
    DWORD dwValue;
    DWORD dwKeySpec;
    FILETIME ftExpiration;
    FILETIME ftOverlap;
    CERT_EXTENSIONS *pCertExtensions;

    for (i = 0; i < ARRAYSIZE(g_actf); i++)
    {
	hr = CAGetCertTypeFlagsEx(hCertType, g_actf[i].dwOption, &dwValue);
	if (S_OK != hr)
	{
	    _PrintError(hr, "CAGetCertTypeFlagsEx");
	}
	else
	{
	    cuRegPrintDwordValue(
			    TRUE,
			    g_actf[i].pwszLookupName,
			    g_actf[i].pwszPropName,
			    dwValue);
	}
    }
    for (i = 0; i < ARRAYSIZE(g_actProp); i++)
    {
	WCHAR **rgpwszPropValues;

	hr = CAGetCertTypePropertyEx(
			    hCertType,
			    g_actProp[i].pwszPropName,
			    g_actProp[i].fString?
				(VOID *) &rgpwszPropValues : &dwValue);
	if (S_OK != hr)
	{
	    _PrintError(hr, "CAGetCertTypePropertyEx");
	}
	else
	{
	    if (g_actProp[i].fString)
	    {
		cuRegPrintAwszValue(
			    g_actProp[i].pwszPropName,
			    rgpwszPropValues);

		CAFreeCertTypeProperty(hCertType, rgpwszPropValues);
	    }
	    else
	    {
		cuRegPrintDwordValue(
				TRUE,
				g_actProp[i].pwszPropName,
				g_actProp[i].pwszPropName,
				dwValue);
	    }
	}
    }
    hr = CAGetCertTypeKeySpec(hCertType, &dwKeySpec);
    if (S_OK != hr)
    {
	_PrintError(hr, "CAGetCertTypeKeySpec");
    }
    else
    {
	WCHAR const *pwsz = NULL;

	switch (dwKeySpec)
	{
	    case AT_SIGNATURE:   pwsz = L"AT_SIGNATURE";   break;
	    case AT_KEYEXCHANGE: pwsz = L"AT_KEYEXCHANGE"; break;
	}
	if (NULL != pwsz)
	{
	    wprintf(L"  dwKeySpec = %ws\n", pwsz);
	}
    }

    hr = CAGetCertTypeExpiration(hCertType, &ftExpiration, &ftOverlap);
    if (S_OK != hr)
    {
	_PrintError(hr, "CAGetCertTypeExpiration");
    }
    else
    {
	wprintf(L"  " CERTTYPE_PROP_EXPIRATION L" = ");
	cuDumpFileTimeOrPeriod(0, NULL, &ftExpiration);
	if (g_fVerbose)
	{
	    DumpHex(
		DH_NOADDRESS | DH_NOASCIIHEX | DH_NOTABPREFIX | 8,
		(BYTE const *) &ftExpiration,
		sizeof(ftExpiration));
	}

	wprintf(L"  " CERTTYPE_PROP_OVERLAP L" = ");
	cuDumpFileTimeOrPeriod(0, NULL, &ftOverlap);
	if (g_fVerbose)
	{
	    DumpHex(
		DH_NOADDRESS | DH_NOASCIIHEX | DH_NOTABPREFIX | 8,
		(BYTE const *) &ftOverlap,
		sizeof(ftOverlap));
	}
    }

    hr = CAGetCertTypeExtensions(hCertType, &pCertExtensions);
    if (S_OK != hr)
    {
	_PrintError(hr, "CAGetCertTypeExtensions");
    }
    else
    {
	wprintf(wszNewLine);
	hr = cuDumpExtensionArray(
			IDS_TEMPLATE_EXTENSIONS,
			pCertExtensions->cExtension,
			pCertExtensions->rgExtension);
	_PrintIfError(hr, "cuDumpExtensionArray");

	CAFreeCertTypeExtensions(hCertType, pCertExtensions);
    }
    hr = S_OK;

//error:
    return(hr);
}


HRESULT
dsDumpTemplate(
    OPTIONAL IN HCAINFO hCAInfo,
    OPTIONAL IN WCHAR const *pwszTemplate,
    OPTIONAL OUT WCHAR **ppwszTemplate)
{
    HRESULT hr;
    BOOL fFound = FALSE;
    WCHAR const *pwszDisplayName = NULL;
    HCERTTYPE hCertType = NULL;
    DWORD dwFlags = 0;
    WCHAR **apwszCertTypeName = NULL;
    WCHAR **apwszCertTypeCN = NULL;

    if (NULL != ppwszTemplate)
    {
	*ppwszTemplate = NULL;
    }
    if (!g_fUserTemplates && !g_fMachineTemplates)
    {
	g_fUserTemplates = TRUE;
	g_fMachineTemplates = TRUE;
    }
    if (g_fUserTemplates)
    {
	dwFlags |= CT_ENUM_USER_TYPES;
    }
    if (g_fMachineTemplates)
    {
	dwFlags |= CT_ENUM_MACHINE_TYPES;
    }
    if (!g_fUserRegistry)
    {
	dwFlags |= CT_FIND_LOCAL_SYSTEM;
    }
    if (g_fForce)
    {
	dwFlags |= CT_FLAG_NO_CACHE_LOOKUP;
    }

    if (NULL != pwszTemplate)
    {
	hr = CAFindCertTypeByName(pwszTemplate, hCAInfo, dwFlags, &hCertType);
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
	{
	    hr = CAFindCertTypeByName(
				pwszTemplate,
				hCAInfo,
				CT_FIND_BY_OID | dwFlags,
				&hCertType);
	}
	if (S_OK != hr)
	{
	    _PrintErrorStr2(
			hr,
			"CAFindCertTypeByName",
			pwszTemplate,
			HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
	    pwszDisplayName = pwszTemplate;
	}
	else
	{
	    fFound = TRUE;
	}
    }
    if (NULL == pwszTemplate || NULL != pwszDisplayName)
    {
	if (NULL != hCAInfo)
	{
	    hr = CAEnumCertTypesForCA(hCAInfo, dwFlags, &hCertType);
	    _JumpIfError(hr, error, "CAEnumCertTypesForCA");

	    if (NULL == hCertType)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
		_JumpError(hr, error, "CAEnumCertTypesForCA");
	    }
	}
	else
	{
	    hr = CAEnumCertTypes(dwFlags, &hCertType);
	    _JumpIfError(hr, error, "CAEnumCertTypes");

	    if (NULL == hCertType)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
		_JumpError(hr, error, "CAEnumCertTypes");
	    }
	}
    }
    while (TRUE)
    {
	HCERTTYPE hCertTypeNext;
	WCHAR const *pwszError = NULL;

        hr = CAGetCertTypeProperty(
			    hCertType,
			    CERTTYPE_PROP_FRIENDLY_NAME,
			    &apwszCertTypeName);
	_JumpIfError(hr, error, "CAGetCertTypeProperty");

	hr = CAGetCertTypeProperty(
			    hCertType,
			    CERTTYPE_PROP_CN,
			    &apwszCertTypeCN);
	_JumpIfError(hr, error, "CAGetCertTypeProperty");

	if (NULL != pwszDisplayName &&
	    (0 == mylstrcmpiL(pwszDisplayName, apwszCertTypeName[0]) ||
	     0 == mylstrcmpiL(pwszDisplayName, apwszCertTypeCN[0])))
	{
	    fFound = TRUE;
	    if (NULL != ppwszTemplate)
	    {
		hr = myDupString(apwszCertTypeCN[0], ppwszTemplate);
		_JumpIfError(hr, error, "myDupString");

		break;
	    }
	}
        if (NULL == ppwszTemplate && (fFound || NULL == pwszDisplayName))
	{
	    hr = CACertTypeAccessCheck(hCertType, NULL);
	    if (S_OK != hr)
	    {
		pwszError = myGetErrorMessageText(hr, FALSE);
	    }
	    wprintf(L"%ws: %ws", apwszCertTypeCN[0], apwszCertTypeName[0]);
	    if (NULL != pwszError)
	    {
		wprintf(L" -- %ws", pwszError);
		LocalFree(const_cast<WCHAR *>(pwszError));
	    }
	    wprintf(wszNewLine);
	    if (g_fVerbose)
	    {
		BOOL fVerboseOld = g_fVerbose;

		g_fVerbose--;
		dsDumpTemplateInfo(hCertType);
		g_fVerbose = fVerboseOld;
	    }
	}
        CAFreeCertTypeProperty(hCertType, apwszCertTypeName);
        apwszCertTypeName = NULL;

        CAFreeCertTypeProperty(hCertType, apwszCertTypeCN);
        apwszCertTypeCN = NULL;

	if (fFound)
	{
	    break;
	}
	hr = CAEnumNextCertType(hCertType, &hCertTypeNext);
	_JumpIfError(hr, error, "CAEnumNextCertType");

	CACloseCertType(hCertType);
	hCertType = hCertTypeNext;
	if (NULL == hCertType)
	{
	    break;
	}
    }
    hr = S_OK;

error:
    if (NULL != hCertType)
    {
	if (NULL != apwszCertTypeName)
	{
	    CAFreeCertTypeProperty(hCertType, apwszCertTypeName);
	}
	if (NULL != apwszCertTypeCN)
	{
	    CAFreeCertTypeProperty(hCertType, apwszCertTypeCN);
	}
	CACloseCertType(hCertType);
    }
    return(hr);
}


HRESULT
verbTemplate(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszTemplate,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = dsDumpTemplate(NULL, pwszTemplate, NULL);
    _JumpIfError(hr, error, "dsDumpTemplate");

error:
    return(hr);
}


int
dsCompareMachineNames(
    IN WCHAR const *pwszServer,
    IN WCHAR const *pwszDnsName)
{
    HRESULT hr;
    WCHAR const *pwsz;
    WCHAR *pwszMachine = NULL;
    int rc;

    rc = mylstrcmpiL(pwszServer, pwszDnsName);
    if (0 != rc)
    {
	pwsz = wcschr(pwszDnsName, '.');
	if (NULL != pwsz)
	{
	    DWORD cb;

	    cb = SAFE_SUBTRACT_POINTERS(pwsz, pwszDnsName) * sizeof(WCHAR);

	    pwszMachine = (WCHAR *) LocalAlloc(LMEM_FIXED, cb + sizeof(WCHAR));
	    if (NULL == pwszMachine)
	    {
		_PrintError(E_OUTOFMEMORY, "LocalAlloc");
		goto error;
	    }
	    CopyMemory(pwszMachine, pwszDnsName, cb);
	    pwszMachine[cb / sizeof(WCHAR)] = L'\0';

	    rc = mylstrcmpiL(pwszServer, pwszMachine);
	}
    }

error:
    if (NULL != pwszMachine)
    {
	LocalFree(pwszMachine);
    }
    return(rc);
}


// Enumerate matching CAs
typedef HRESULT (FNENUMCA)(
    IN HCAINFO hCAInfo,
    IN OUT VOID *pvArgs);

HRESULT
dsEnumCA(
    IN FNENUMCA *pfnEnumCA,
    IN VOID *pvArgs)
{
    HRESULT hr;
    WCHAR *pwszCAName = NULL;
    WCHAR *pwszServer = NULL;
    WCHAR *pwszCANameRevert = NULL;
    WCHAR *pwszCANameSanitized = NULL;
    WCHAR *pwszCANameSanitizedDS = NULL;
    HCAINFO hCAInfo = NULL;
    DWORD dwFlags = CA_FIND_INCLUDE_NON_TEMPLATE_CA | CA_FIND_INCLUDE_UNTRUSTED;
    WCHAR **apwszMachine = NULL;
    BOOL fFound = FALSE;

    hr = mySplitConfigString(g_pwszConfig, &pwszServer, &pwszCAName);
    _JumpIfError(hr, error, "mySplitConfigString");

    hr = myRevertSanitizeName(pwszCAName, &pwszCANameRevert);
    _JumpIfError(hr, error, "myRevertSanitizeName");

    hr = mySanitizeName(pwszCANameRevert, &pwszCANameSanitized);
    _JumpIfError(hr, error, "mySanitizeName");

    hr = mySanitizedNameToDSName(pwszCANameSanitized, &pwszCANameSanitizedDS);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    if (!g_fUserRegistry)
    {
	dwFlags |= CA_FIND_LOCAL_SYSTEM;
    }
    if (NULL != g_pwszDC)
    {
	dwFlags |= CA_FLAG_SCOPE_DNS;
    }
    if (g_fForce)
    {
	dwFlags |= CT_FLAG_NO_CACHE_LOOKUP;
    }

    hr = CAFindByName(
		pwszCANameSanitizedDS,
		g_pwszDC,	// wszScope
		dwFlags,
		&hCAInfo);
    _JumpIfErrorStr(hr, error, "CAFindByName", pwszCAName);

    while (TRUE)
    {
	HCAINFO hCAInfoNext;

	hr = CAGetCAProperty(hCAInfo, CA_PROP_DNSNAME, &apwszMachine);
	_JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_DNSNAME)");

	if (0 == dsCompareMachineNames(pwszServer, apwszMachine[0]))
	{
	    fFound = TRUE;

	    hr = (*pfnEnumCA)(hCAInfo, pvArgs);
	    _JumpIfError(hr, error, "*pfnEnumCA");
	}

	CAFreeCAProperty(hCAInfo, apwszMachine);
	apwszMachine = NULL;

	hr = CAEnumNextCA(hCAInfo, &hCAInfoNext);
	_JumpIfError(hr, error, "CAEnumNextCA");

	CACloseCA(hCAInfo);
	hCAInfo = hCAInfoNext;
	if (NULL == hCAInfo)
	{
	    break;
	}
    }
    if (!fFound)
    {
	hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	_JumpError(hr, error, "CAEnumNextCA");
    }
    hr = S_OK;

error:
    if (NULL != apwszMachine)
    {
	CAFreeCAProperty(hCAInfo, apwszMachine);
    }
    if (NULL != hCAInfo)
    {
	CACloseCA(hCAInfo);
    }
    if (NULL != pwszServer)
    {
	LocalFree(pwszServer);
    }
    if (NULL != pwszCAName)
    {
	LocalFree(pwszCAName);
    }
    if (NULL != pwszCANameRevert)
    {
	LocalFree(pwszCANameRevert);
    }
    if (NULL != pwszCANameSanitized)
    {
	LocalFree(pwszCANameSanitized);
    }
    if (NULL != pwszCANameSanitizedDS)
    {
	LocalFree(pwszCANameSanitizedDS);
    }
    return(hr);
}


// Display Templates for specified CA

typedef struct _CATEMPLATESARGS {
    OPTIONAL IN WCHAR const *pwszTemplate;
} CATEMPLATESARGS;


HRESULT
dsEnumCADumpTemplate(
    IN HCAINFO hCAInfo,
    IN OUT VOID *pvArgs)
{
    HRESULT hr;
    CATEMPLATESARGS *pArgs = (CATEMPLATESARGS *) pvArgs;

    hr = dsDumpTemplate(hCAInfo, pArgs->pwszTemplate, NULL);
    _JumpIfError(hr, error, "dsDumpTemplate");

error:
    return(hr);
}


HRESULT
verbCATemplates(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszTemplate,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    CATEMPLATESARGS Args;

    Args.pwszTemplate = pwszTemplate;

    hr = dsEnumCA(dsEnumCADumpTemplate, &Args);
    _JumpIfError(hr, error, "dsEnumCA");

error:
    return(hr);
}


// Set Templates for specified CA

typedef struct _CASETTEMPLATESARGS {
    IN WCHAR const *pwszTemplateList;
} CASETTEMPLATESARGS;

#define SCTOP_SET	0
#define SCTOP_ADD	1
#define SCTOP_REMOVE	2

HRESULT
dsAddCATemplates(
    IN HCAINFO hCAInfo,
    IN DWORD Op,
    IN WCHAR const * const *ppwszList)
{
    HRESULT hr;
    CTemplateList CATemplateList;
    CTemplateListEnum CATemplateListEnum(CATemplateList);
    BOOL fSkipCache = g_fForce;
    BOOL fChanged = FALSE;
    WCHAR const * const *ppwsz;
    HCERTTYPE hCertType = NULL;
    HCERTTYPE hCertTypeT;
    WCHAR **apwszCertTypeCN = NULL;
    WCHAR *pwszT = NULL;
    
    hr = myRetrieveCATemplateList(hCAInfo, TRUE, CATemplateList);
    _JumpIfError(hr, error, "myRetrieveCATemplateList");

    CATemplateListEnum.Reset();

    while (TRUE)
    {
	CTemplateInfo *pTemplateInfo;

	pTemplateInfo = CATemplateListEnum.Next();
        if (NULL == pTemplateInfo)
	{
	    break;
	}
        hCertTypeT = pTemplateInfo->GetCertType();
        if (NULL == hCertTypeT)
        {
            CSASSERT(NULL != pTemplateInfo->GetName());
            hr = CAFindCertTypeByName(
                    pTemplateInfo->GetName(), 
                    NULL, 
                    CT_ENUM_MACHINE_TYPES |
			CT_ENUM_USER_TYPES |
			(fSkipCache? CT_FLAG_NO_CACHE_LOOKUP : 0),
                    &hCertType);
	    hCertTypeT = hCertType;
            
	    // continue on errors

	    _PrintIfErrorStr(
		    hr,
		    "CAFindCertTypeByName",
		    NULL != pTemplateInfo->GetName()?
			pTemplateInfo->GetName() : pTemplateInfo->GetOID());

            if (S_OK == hr)
	    {
		fSkipCache = FALSE;
	    }
        }
        if (NULL != hCertTypeT)
        {
	    if (SCTOP_SET == Op)
	    {
		BOOL fFound;
		
		fFound = FALSE;
		for (ppwsz = ppwszList; NULL != *ppwsz; ppwsz++)
		{
		    if (0 == mylstrcmpiL(*ppwsz, pTemplateInfo->GetName()) ||
			0 == lstrcmp(*ppwsz, pTemplateInfo->GetOID()))
		    {
			fFound = TRUE;
			break;
		    }
		}
		if (!fFound)
		{
		    // can't reference pTemplateInfo after it's been removed
		    
		    hr = myDupString(
				NULL != pTemplateInfo->GetName()?
				    pTemplateInfo->GetName() :
				    pTemplateInfo->GetOID(),
				&pwszT);
		    _JumpIfError(hr, error, "myDupString");

		    pTemplateInfo = NULL;

		    hr = myRemoveFromCATemplateList(
					    hCAInfo,
					    CATemplateList,
					    hCertTypeT);
		    _JumpIfError(hr, error, "myRemoveFromCATemplateList");

		    fChanged = TRUE;
		    wprintf(
			L"%ws: %ws\n",
			pwszT,
			myLoadResourceString(IDS_REMOVING)); // "Removing"
		    LocalFree(pwszT);
		    pwszT = NULL;
		    CATemplateListEnum.Reset();	// start over to avoid faulting
		}
	    }
	    if (NULL != hCertType)
	    {
		CACloseCertType(hCertType);
		hCertType = NULL;
	    }
        }
    }
    if (fChanged)
    {
	wprintf(wszNewLine);
    }
    for (ppwsz = ppwszList; NULL != *ppwsz; ppwsz++)
    {
	UINT idmsg;

	hr = CAFindCertTypeByName(
		*ppwsz,
		NULL, 
		CT_ENUM_MACHINE_TYPES |
		    CT_ENUM_USER_TYPES |
		    (fSkipCache? CT_FLAG_NO_CACHE_LOOKUP : 0),
		&hCertType);
	if (S_OK != hr)
	{
	    _PrintErrorStr2(hr, "CAFindCertTypeByName", *ppwsz, hr);

	    hr = CAFindCertTypeByName(
		    *ppwsz,
		    NULL, 
		    CT_ENUM_MACHINE_TYPES |
			CT_ENUM_USER_TYPES |
			CT_FIND_BY_OID |
			(fSkipCache? CT_FLAG_NO_CACHE_LOOKUP : 0),
		    &hCertType);
	    if (S_OK != hr)
	    {
		cuPrintAPIError(*ppwsz, hr);
		_JumpErrorStr(hr, error, "CAFindCertTypeByName", *ppwsz);
	    }
	}
	fSkipCache = FALSE;
	hCertTypeT = hCertType;
	hr = CAGetCertTypeProperty(
			    hCertTypeT,
			    CERTTYPE_PROP_CN,
			    &apwszCertTypeCN);
	_JumpIfErrorStr(hr, error, "CAGetCertTypeProperty", *ppwsz);
	
	idmsg = 0;
	if (SCTOP_REMOVE == Op)
	{
	    if (CATemplateList.TemplateExistsOID(*ppwsz) ||
		CATemplateList.TemplateExistsName(*ppwsz))
	    {
		idmsg = IDS_REMOVING; // "Removing"
		hr = myRemoveFromCATemplateList(
					hCAInfo,
					CATemplateList,
					hCertTypeT);
		_JumpIfError(hr, error, "myRemoveFromCATemplateList");

		fChanged = TRUE;
	    }
	    else
	    {
		idmsg = IDS_NOTPRESENT; // "Not present"
	    }
	}
	else
	{
	    if (!CATemplateList.TemplateExistsOID(*ppwsz) &&
		!CATemplateList.TemplateExistsName(*ppwsz))
	    {
		idmsg = IDS_ADDING; // "Adding"
		hr = myAddToCATemplateList(
					hCAInfo,
					CATemplateList,
					hCertTypeT,
					TRUE);
		_JumpIfError(hr, error, "myAddToCATemplateList");

		fChanged = TRUE;
	    }
	    else
	    {
		idmsg = IDS_ALREADYPRESENT; // 	"Already present"
	    }
	}
	if (0 != idmsg)
	{
	    hr = myVerifyObjId(*ppwsz);
	    if (S_OK == hr &&
		NULL != apwszCertTypeCN &&
		NULL != apwszCertTypeCN[0])
	    {
		wprintf(L"%ws: ", apwszCertTypeCN[0]);
	    }
	    wprintf(L"%ws: %ws\n", *ppwsz, myLoadResourceString(idmsg));
	}
	if (NULL != apwszCertTypeCN)
	{
	    CAFreeCertTypeProperty(hCertType, apwszCertTypeCN);
	    apwszCertTypeCN = NULL;
	}
	if (NULL != hCertType)
	{
	    CACloseCertType(hCertType);
	    hCertType = NULL;
	}
    }
    if (fChanged || g_fForce)
    {
	hr = myUpdateCATemplateListToCA(hCAInfo, CATemplateList);
	_PrintIfError2(hr, "myUpdateCATemplateListToCA", hr);
	if (S_OK != hr && g_fForce)
	{
	    // if failed to update through the CA for any reason, try writing
	    // directly to DS

	    hr = myUpdateCATemplateListToDS(hCAInfo);
	    _JumpIfError(hr, error, "myUpdateCATemplateListToDS");
	}
	_JumpIfError(hr, error, "myUpdateCATemplateListToCA");
    }
    hr = S_OK;

error:
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    if (NULL != hCertType)
    {
	if (NULL != apwszCertTypeCN)
	{
	    CAFreeCertTypeProperty(hCertType, apwszCertTypeCN);
	}
	CACloseCertType(hCertType);
    }
    return(hr);
}


HRESULT
dsEnumCASetTemplates(
    IN HCAINFO hCAInfo,
    IN OUT VOID *pvArgs)
{
    HRESULT hr;
    CASETTEMPLATESARGS *pArgs = (CASETTEMPLATESARGS *) pvArgs;
    DWORD Op = SCTOP_SET;
    WCHAR const *pwszList;
    WCHAR **ppwszList = NULL;

    pwszList = pArgs->pwszTemplateList;
    if (myIsMinusSign(*pwszList))
    {
	pwszList++;
	Op = SCTOP_REMOVE;
    }
    else if (L'+' == *pwszList)
    {
	pwszList++;
	Op = SCTOP_ADD;
    }
    hr = cuParseStrings(pwszList, FALSE, NULL, NULL, &ppwszList, NULL);
    _JumpIfError(hr, error, "cuParseStrings");

    hr = dsAddCATemplates(hCAInfo, Op, ppwszList);
    _JumpIfError(hr, error, "dsAddCATemplates");

error:
    cuFreeStringArray(ppwszList);
    return(hr);
}


HRESULT
verbSetCATemplates(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszTemplateList,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    CASETTEMPLATESARGS Args;

    Args.pwszTemplateList = pwszTemplateList;

    hr = dsEnumCA(dsEnumCASetTemplates, &Args);
    _JumpIfError(hr, error, "dsEnumCA");

error:
    return(hr);
}


HRESULT
dsCAFindByCertType(
    IN WCHAR const *pwszTemplate,
    OPTIONAL WCHAR const *pwszDC,
    IN DWORD dwFlags,
    OUT HCAINFO *phCAInfo)
{
    HRESULT hr;
    WCHAR const *pwszCertType = pwszTemplate;
    WCHAR *pwszAlloc = NULL;
    
    while (TRUE)
    {
	hr = CAFindByCertType(
			pwszCertType,
			pwszDC,		// wszScope
			dwFlags,
			phCAInfo);
	if (S_OK == hr)
	{
	    if (NULL == *phCAInfo)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
		_JumpError(hr, error, "CAFindByCertType");
	    }
	    break;
	}
	_PrintErrorStr2(
		hr,
		"CAFindByCertType",
		pwszCertType,
		HRESULT_FROM_WIN32(ERROR_NOT_FOUND));
	if (NULL != pwszAlloc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	    _JumpError(hr, error, "CAFindByCertType");
	}
	hr = dsDumpTemplate(NULL, pwszTemplate, &pwszAlloc);
	_JumpIfError(hr, error, "dsDumpTemplate");

	if (NULL == pwszAlloc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	    _JumpError(hr, error, "dsDumpTemplate");
	}
	pwszCertType = pwszAlloc;
    }

error:
    if (NULL != pwszAlloc)
    {
	LocalFree(pwszAlloc);
    }
    return(hr);
}


// Display CAs for specified Template

HRESULT
verbTemplateCAs(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszTemplate,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HCAINFO hCAInfo = NULL;
    DWORD dwFlags = CA_FIND_INCLUDE_NON_TEMPLATE_CA | CA_FIND_INCLUDE_UNTRUSTED;
    WCHAR **apwszMachine = NULL;
    WCHAR **apwszCommonName = NULL;

    if (!g_fUserRegistry)
    {
	dwFlags |= CA_FIND_LOCAL_SYSTEM;
    }
    if (NULL != g_pwszDC)
    {
	dwFlags |= CA_FLAG_SCOPE_DNS;
    }
    hr = dsCAFindByCertType(pwszTemplate, g_pwszDC, dwFlags, &hCAInfo);
    _JumpIfError(hr, error, "dsCAFindByCertType");

    while (TRUE)
    {
	HCAINFO hCAInfoNext;
	WCHAR const *pwszError = NULL;

	hr = CAGetCAProperty(hCAInfo, CA_PROP_DNSNAME, &apwszMachine);
	_JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_DNSNAME)");

	hr = CAGetCAProperty(
			hCAInfo,
			CA_PROP_DISPLAY_NAME,
			&apwszCommonName);
	_JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_DISPLAY_NAME)");

	hr = CAAccessCheck(hCAInfo, NULL);
	if (S_OK != hr)
	{
	    pwszError = myGetErrorMessageText(hr, FALSE);
	}
	wprintf(L"%ws\\%ws", apwszMachine[0], apwszCommonName[0]);
	if (NULL != pwszError)
	{
	    wprintf(L" -- %ws", pwszError);
	    LocalFree(const_cast<WCHAR *>(pwszError));
	}
	wprintf(wszNewLine);

	CAFreeCAProperty(hCAInfo, apwszMachine);
	apwszMachine = NULL;

	CAFreeCAProperty(hCAInfo, apwszCommonName);
	apwszCommonName = NULL;

	hr = CAEnumNextCA(hCAInfo, &hCAInfoNext);
	_JumpIfError(hr, error, "CAEnumNextCA");

	CACloseCA(hCAInfo);
	hCAInfo = hCAInfoNext;
	if (NULL == hCAInfo)
	{
	    break;
	}
    }
    hr = S_OK;

error:
    if (NULL != apwszMachine)
    {
	CAFreeCAProperty(hCAInfo, apwszMachine);
    }
    if (NULL != apwszCommonName)
    {
	CAFreeCAProperty(hCAInfo, apwszCommonName);
    }
    if (NULL != hCAInfo)
    {
	CACloseCA(hCAInfo);
    }
    return(hr);
}


typedef struct _MODTYPE
{
    WCHAR const *pwszAttributeName;
    DWORD        dwType;
} MODTYPE;

#define MT_STRING	0
#define MT_IGNORE	1
#define MT_TIMEPERIOD	2
#define MT_BINARY	3

const MODTYPE s_amtTemplateAttributes[] =
{
    { CERTTYPE_PROP_CN,		MT_IGNORE },
    { L"instanceType",		MT_IGNORE },
    { CERTTYPE_PROP_DN,		MT_IGNORE },
    { L"objectCategory",	MT_IGNORE },
    { L"objectGUID",		MT_IGNORE },
    { L"name",			MT_IGNORE },
    { L"showInAdvancedViewOnly",MT_IGNORE },
    { L"uSNChanged",		MT_IGNORE },
    { L"uSNCreated",		MT_IGNORE },
    { L"whenChanged",		MT_IGNORE },
    { L"whenCreated",		MT_IGNORE },
    { L"dSCorePropagationData",	MT_IGNORE },

    { CERTTYPE_PROP_EXPIRATION,	MT_TIMEPERIOD },
    { CERTTYPE_PROP_OVERLAP,	MT_TIMEPERIOD },
    { CERTTYPE_PROP_KU,		MT_BINARY },
    { NULL,			MT_STRING }
};


DWORD
ModType(
    IN WCHAR const *pwszName)
{
    MODTYPE const *pmt;

    for (pmt = s_amtTemplateAttributes; NULL != pmt->pwszAttributeName; pmt++)
    {
	if (0 == mylstrcmpiS(pwszName, pmt->pwszAttributeName))
	{
	    break;
	}
    }
    return(pmt->dwType);
}


HRESULT
ConvertBinaryValue(
    IN WCHAR const *pwszValue,
    OUT BERVAL **ppber)
{
    HRESULT hr;
    BYTE *pb = NULL;
    DWORD cb;

    hr = WszToMultiByteInteger(TRUE, pwszValue, &cb, &pb);
    _JumpIfError(hr, error, "WszToMultiByteInteger");

    *ppber = (BERVAL *) LocalAlloc(LMEM_FIXED, sizeof(**ppber));
    if (NULL == *ppber)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    (*ppber)->bv_len = cb;
    (*ppber)->bv_val = (char *) pb;
    pb = NULL;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
ParseTimePeriod(
    IN WCHAR const *pwszValue,
    OUT LONGLONG *pll)
{
    HRESULT hr;
    WCHAR *pwszDup = NULL;
    WCHAR *pwszCount;
    WCHAR *pwszNext;
    LONGLONG ll;
    DWORD lHours;
    DWORD lMinutes;
    DWORD lSeconds;
    
    ll = 0;
    
    hr = myDupString(pwszValue, &pwszDup);
    _JumpIfError(hr, error, "myDupString");

    pwszCount = pwszDup;
    while (TRUE)
    {
	BOOL fValid;
	WCHAR *pwszString;
	DWORD dwCount;
	enum ENUM_PERIOD enumPeriod;
	LONG lCount;

	while (L' ' == *pwszCount)
	{
	    pwszCount++;
	}
	pwszNext = wcschr(pwszCount, L',');
	if (NULL == pwszNext)
	{
	    if (L'\0' == *pwszCount || NULL != wcschr(pwszCount, L':'))
	    {
		break;
	    }
	    pwszNext = &pwszCount[wcslen(pwszCount)];
	    pwszString = pwszNext;
	}
	else
	{
	    pwszString = pwszNext;
	    *pwszNext++ = L'\0';
	}
	while (pwszString > pwszCount && L' ' == *--pwszString)
	{
	    *pwszString = L'\0';
	}

	pwszString = wcschr(pwszCount, L' ');
	if (NULL == pwszString)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpErrorStr(hr, error, "bad time period", pwszCount);
	}
	*pwszString++ = L'\0';
	while (L' ' == *pwszString)
	{
	    pwszString++;
	}
	//wprintf(L"Period: '%ws' '%ws'\n", pwszCount, pwszString);

	dwCount = myWtoI(pwszCount, &fValid);
	if (!fValid)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "bad time period digit");
	}

	hr = myTranslatePeriodUnits(pwszString, dwCount, &enumPeriod, &lCount);
	_JumpIfError(hr, error, "myTranslatePeriodUnits");

	if (0 != dwCount)
	{
	    if (ENUM_PERIOD_YEARS == enumPeriod)
	    {
		// "Years" is implemented without considering leap years.
	    
		ll += (LONGLONG) (lCount * 365 * CVT_DAYS) * CVT_BASE;
	    }
	    else if (ENUM_PERIOD_MONTHS == enumPeriod)
	    {
		// "Months" is implemented assuming 30 days per month
	    
		ll += (LONGLONG) (lCount * 30 * CVT_DAYS) * CVT_BASE;
	    }
	    else if (ENUM_PERIOD_WEEKS == enumPeriod)
	    {
		// "Months" is implemented assuming 7 days per week
	    
		ll += (LONGLONG) (lCount * 7 * CVT_DAYS) * CVT_BASE;
	    }
	    else
	    {
		myMakeExprDateTime((FILETIME *) &ll, lCount, enumPeriod);
	    }
	}
	pwszCount = pwszNext;
    }
    if (3 == swscanf(pwszCount, L"%u:%02u:%02u", &lHours, &lMinutes, &lSeconds))
    {
	if (0 != lHours)
	{
	    myMakeExprDateTime((FILETIME *) &ll, lHours, ENUM_PERIOD_HOURS);
	}
	if (0 != lMinutes)
	{
	    myMakeExprDateTime((FILETIME *) &ll, lMinutes, ENUM_PERIOD_MINUTES);
	}
	if (0 != lSeconds)
	{
	    myMakeExprDateTime((FILETIME *) &ll, lSeconds, ENUM_PERIOD_SECONDS);
	}
    }
    *pll = -ll;
    hr = S_OK;

error:
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
ConvertTimePeriodValue(
    IN WCHAR const *pwszValue,
    OUT BERVAL **ppber)
{
    HRESULT hr;
    LONGLONG ll;
    BYTE *pb = NULL;

    hr = ParseTimePeriod(pwszValue, &ll);
    _JumpIfError(hr, error, "ParseTimePeriod");

    pb = (BYTE *) LocalAlloc(LMEM_FIXED, sizeof(ll));
    if (NULL == pb)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pb, &ll, sizeof(ll));

    *ppber = (BERVAL *) LocalAlloc(LMEM_FIXED, sizeof(**ppber));
    if (NULL == *ppber)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    (*ppber)->bv_len = sizeof(ll);
    (*ppber)->bv_val = (char *) pb;
    pb = NULL;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


VOID
FreeMods(
    IN DWORD cmod,
    LDAPMod *rgmod)
{
    DWORD imod;
    DWORD ival;
    
    if (NULL != rgmod)
    {
	for (imod = 0; imod < cmod; imod++)
	{
	    if (LDAP_MOD_BVALUES & rgmod[imod].mod_op)
	    {
		BERVAL **rgpber = rgmod[imod].mod_bvalues;

		if (NULL != rgpber)
		{
		    for (ival = 0; NULL != rgpber[ival]; ival++)
		    {
			if (rgpber[ival]->bv_val)
			{
			    LocalFree(rgpber[ival]->bv_val);
			}
			LocalFree(rgpber[ival]);
		    }
		    LocalFree(rgpber);
		}
	    }
	    else
	    {
		WCHAR **rgpwsz = rgmod[imod].mod_values;

		if (NULL != rgpwsz)
		{
		    for (ival = 0; NULL != rgpwsz[ival]; ival++)
		    {
			LocalFree(rgpwsz[ival]);
		    }
		    LocalFree(rgpwsz);
		}
	    }
	}
	LocalFree(rgmod);
    }
}


HRESULT
ConvertInfValuesToMods(
    IN DWORD cInfValues,
    INFVALUES const *rgInfValues,
    OUT WCHAR **ppwszCN,
    OUT DWORD *pcmod,
    OUT LDAPMod **prgmod)
{
    HRESULT hr;
    LDAPMod *rgmod = NULL;
    DWORD cmod = 0;
    DWORD imod;
    DWORD i;
    WCHAR *pwszCN = NULL;

    *ppwszCN = NULL;
    *prgmod = NULL;
    for (i = 0; i < cInfValues; i++)
    {
	if (MT_IGNORE != ModType(rgInfValues[i].pwszKey))
	{
	    cmod++;
	}
    }

    rgmod = (LDAPMod *) LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    cmod * sizeof(rgmod[0]));
    if (NULL == rgmod)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    imod = 0;
    for (i = 0; i < cInfValues; i++)
    {
	INFVALUES const *pInfValues = &rgInfValues[i];
	DWORD dwType = ModType(pInfValues->pwszKey);
	WCHAR **ppwsz = NULL;
	BERVAL **ppber = NULL;
	DWORD ival;

	if (NULL != ppwszCN &&
	    NULL == pwszCN &&
	    0 == LSTRCMPIS(pInfValues->pwszKey, CERTTYPE_PROP_CN))
	{
	    hr = myDupString(pInfValues->rgpwszValues[0], &pwszCN);
	    _JumpIfError(hr, error, "myDupString");
	}
	if (MT_IGNORE != dwType)
	{
	    rgmod[imod].mod_op = LDAP_MOD_REPLACE;
	    rgmod[imod].mod_type = pInfValues->pwszKey;

	    if (MT_STRING == dwType)
	    {
		ppwsz = (WCHAR **) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				(pInfValues->cValues + 1) * sizeof(ppwsz[0]));
		if (NULL == ppwsz)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		rgmod[imod].mod_values = ppwsz;
	    }
	    else
	    {
		ppber = (BERVAL **) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				(pInfValues->cValues + 1) * sizeof(ppber[0]));
		if (NULL == ppber)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		rgmod[imod].mod_op |= LDAP_MOD_BVALUES;
		rgmod[imod].mod_bvalues = ppber;
	    }

	    for (ival = pInfValues->cValues; ival > 0; ival--)
	    {
		WCHAR const *pwszValue = pInfValues->rgpwszValues[ival - 1];
		
		switch (dwType)
		{
		    case MT_BINARY:
			hr = ConvertBinaryValue(pwszValue, ppber);
			_JumpIfErrorStr(
				    hr,
				    error,
				    "ConvertBinaryValue",
				    pInfValues->pwszKey);

			ppber++;
			CSASSERT(NULL == *ppber);
			break;

		    case MT_TIMEPERIOD:
			hr = ConvertTimePeriodValue(pwszValue, ppber);
			_JumpIfErrorStr(
				    hr,
				    error,
				    "ConvertTimePeriodValue",
				    pInfValues->pwszKey);

			ppber++;
			CSASSERT(NULL == *ppber);
			break;

		    default:
			CSASSERT(MT_STRING == dwType);
			hr = myDupString(pwszValue, ppwsz);
			_JumpIfErrorStr(
				    hr,
				    error,
				    "myDupString",
				    pInfValues->pwszKey);

			ppwsz++;
			CSASSERT(NULL == *ppwsz);
			break;
		}
	    }
	    imod++;
	}
    }
    CSASSERT(imod == cmod);
    *pcmod = cmod;
    *prgmod = rgmod;
    rgmod = NULL;
    if (NULL != ppwszCN)
    {
	*ppwszCN = pwszCN;
	pwszCN = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszCN)
    {
	LocalFree(pwszCN);
    }
    if (NULL != rgmod)
    {
	FreeMods(cmod, rgmod);
    }
    return(hr);
}


HRESULT
dsAddTemplate(
    IN HINF hInf,
    IN WCHAR const *pwszTemplate,
    IN OUT BSTR *pstrConfigDN,
    IN OUT LDAP **ppld)
{
    HRESULT hr;
    ULONG ldaperr;
    DWORD cInfValues;
    INFVALUES *rgInfValues = NULL;
    DWORD cmod;
    LDAPMod *rgmod = NULL;
    LDAPMod **rgpmod = NULL;
    DWORD imod;
    DWORD ival;
    WCHAR *pwszDNContainer = NULL;
    WCHAR *pwszDNTemplate = NULL;
    WCHAR *pwszCNAlloc = NULL;
    WCHAR const *pwszCN;
    UINT idmsg;
    WCHAR *pwszError = NULL;
    
    hr = myInfGetSectionValues(
			hInf,
			pwszTemplate,
			&cInfValues,
			&rgInfValues);
    _JumpIfError(hr, error, "myInfGetSectionValues");

    hr = ConvertInfValuesToMods(
			cInfValues,
			rgInfValues,
			&pwszCNAlloc,
			&cmod,
			&rgmod);
    _JumpIfError(hr, error, "ConvertInfValuesToMods");

    rgpmod = (LDAPMod **) LocalAlloc(
				LMEM_FIXED,
				(cmod + 3) * sizeof(rgpmod[0]));
    if (NULL == rgpmod)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    for (imod = 0; imod < cmod; imod++)
    {
	rgpmod[imod] = &rgmod[imod];
    }
    rgpmod[imod] = NULL;

    pwszCN = pwszCNAlloc;
    if (NULL == pwszCN)
    {
	pwszCN = pwszTemplate;
    }

    if (g_fVerbose)
    {
	for (imod = 0; NULL != rgpmod[imod]; imod++)
	{
	    WCHAR const *pwszSep = L"";
	    
	    wprintf(L"%ws =", rgpmod[imod]->mod_type);

	    if (LDAP_MOD_BVALUES & rgmod[imod].mod_op)
	    {
		BERVAL **ppber = rgpmod[imod]->mod_bvalues;

		wprintf(wszNewLine);
		for (ival = 0; NULL != ppber[ival]; ival++)
		{
		    DumpHex(
			DH_NOADDRESS | DH_NOTABPREFIX | 8,
			(BYTE const *) ppber[ival]->bv_val,
			ppber[ival]->bv_len);
		    wprintf(wszNewLine);
		}
	    }
	    else
	    {
		WCHAR **ppwsz = rgpmod[imod]->mod_values;

		for (ival = 0; NULL != ppwsz[ival]; ival++)
		{
		    wprintf(L"%ws \"%ws\"", pwszSep, ppwsz[ival]);
		    pwszSep = L",";
		}
		wprintf(wszNewLine);
	    }
	    if (1 < ival)
	    {
		wprintf(wszNewLine);
	    }
	}
    }

    if (NULL == *pstrConfigDN)
    {
	hr = myLdapOpen(
		    g_pwszDC,
		    RLBF_REQUIRE_SECURE_LDAP,
		    ppld,
		    NULL,
		    pstrConfigDN);
	_JumpIfError(hr, error, "myLdapOpen");
    }
    CSASSERT(NULL != *pstrConfigDN);
    CSASSERT(NULL != *ppld);

    hr = BuildDN(g_wszCNTemplates, *pstrConfigDN, FALSE, &pwszDNContainer);
    _JumpIfError(hr, error, "BuildDN");

    hr = BuildDN(pwszCN, pwszDNContainer, TRUE, &pwszDNTemplate);
    _JumpIfError(hr, error, "BuildDN");

    DBGPRINT((DBG_SS_CERTUTILI, "Template DN: %ws\n", pwszDNTemplate));

    idmsg = IDS_CREATED_TEMPLATE;	// "Created DS Template"
    ldaperr = ldap_add_ext_s(*ppld, pwszDNTemplate, rgpmod, NULL, NULL);
    hr = myHLdapError3(
		    *ppld,
		    ldaperr,
		    LDAP_ALREADY_EXISTS,
		    LDAP_OBJECT_CLASS_VIOLATION,
		    &pwszError);
    _PrintIfErrorStr(hr, "ldap_add_ext_s", pwszCN);

    if (LDAP_ALREADY_EXISTS == ldaperr ||
	LDAP_OBJECT_CLASS_VIOLATION == ldaperr)
    {
	if (NULL != pwszError)
	{
	    LocalFree(pwszError);
	    pwszError = NULL;
	}
	for (imod = 0; NULL != rgpmod[imod]; imod++)
	{
	    rgmod[imod].mod_op =
		LDAP_MOD_REPLACE | (LDAP_MOD_BVALUES & rgmod[imod].mod_op);
	}
	idmsg = IDS_UPDATED_TEMPLATE;	// "Updated DS Template"
        ldaperr = ldap_modify_ext_s(*ppld, pwszDNTemplate, rgpmod, NULL, NULL);
        if (LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr)
        {
            ldaperr = LDAP_SUCCESS;
        }
	hr = myHLdapError(*ppld, ldaperr, &pwszError);
        _PrintIfErrorStr(hr, "ldap_modify_ext_s", pwszCN);
    }
    _JumpIfErrorStr(hr, error, "Add/Update", pwszCN);

    wprintf(L"%ws: %ws\n", myLoadResourceString(idmsg), pwszCN);
    if (NULL != pwszError)
    {
	wprintf(L"%ws\n", pwszError);
    }
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    if (NULL != pwszCNAlloc)
    {
	LocalFree(pwszCNAlloc);
    }
    if (NULL != pwszDNContainer)
    {
	LocalFree(pwszDNContainer);
    }
    if (NULL != pwszDNTemplate)
    {
	LocalFree(pwszDNTemplate);
    }
    if (NULL != rgpmod)
    {
	LocalFree(rgpmod);
    }
    if (NULL != rgmod)
    {
	FreeMods(cmod, rgmod);
    }
    if (NULL != rgInfValues)
    {
	myInfFreeSectionValues(cInfValues, rgInfValues);
    }
    return(hr);
}


HRESULT
verbDSAddTemplate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnTemplateInf,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD ErrorLine;
    BOOL fCritical;
    WCHAR *pwszzTemplateList = NULL;
    WCHAR const *pwsz;
    BSTR strConfigDN = NULL;
    LDAP *pld = NULL;
    static WCHAR const * const s_apwszKeys[] =
	{ wszINFKEY_TEMPLATE, NULL };

    hr = myInfOpenFile(pwszfnTemplateInf, &hInf, &ErrorLine);
    _JumpIfError(hr, error, "myInfOpenFIle");

    hr = myInfGetKeyList(
		    hInf,
		    wszINFSECTION_TEMPLATELIST,
		    wszINFKEY_TEMPLATE,
		    s_apwszKeys,
		    &fCritical,
		    &pwszzTemplateList);
    _JumpIfErrorStr(hr, error, "myInfGetKeyList", wszINFKEY_TEMPLATE);

    for (pwsz = pwszzTemplateList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	wprintf(L"[%ws]\n", pwsz);
	hr = dsAddTemplate(hInf, pwsz, &strConfigDN, &pld);
	_JumpIfError(hr, error, "dsAddTemplate");
    }

error:
    if (NULL != pwszzTemplateList)
    {
	LocalFree(pwszzTemplateList);
    }
    if (INVALID_HANDLE_VALUE != hInf)
    {
	WCHAR *pwszT = myInfGetError();

	if (NULL != pwszT)
	{
	    wprintf(L"%ws\n", pwszT);
	}
	myInfCloseFile(hInf);
    }
    myLdapClose(pld, NULL, strConfigDN);
    return(hr);
}


#define DSP_OBJECT_NTAUTHCERT		0x00000001
#define DSP_OBJECT_ROOTTRUST		0x00000002
#define DSP_OBJECT_AIA			0x00000004
#define DSP_OBJECT_KRA			0x00000008
#define DSP_OBJECT_MACHINE      0x00000010
#define DSP_OBJECT_USER         0x00000020
#define DSP_OBJECT_MASK			0x000000ff

#define DSP_ATTRIBUTE_CACERTIFICATE	0x00000100
#define DSP_ATTRIBUTE_USERCERTIFICATE	0x00000200
#define DSP_ATTRIBUTE_CROSSCERTPAIR	0x00000400
#define DSP_ATTRIBUTE_MASK		0x0000ff00

#define DSP_TYPE_KRACERT		0x00010000
#define DSP_TYPE_EECERT			0x00020000
#define DSP_TYPE_ROOTCACERT		0x00040000
#define DSP_TYPE_SUBCACERT		0x00080000
#define DSP_TYPE_MASK			0x00ff0000


typedef struct _DSOBJECTMAP {
    DWORD ObjectFlags;
    WCHAR const *pwszTemplate;
} DSOBJECTMAP;

DSOBJECTMAP s_rgObjectMap[] = {
    { DSP_OBJECT_NTAUTHCERT, g_wszLDAPNTAuthURLTemplate },
    { DSP_OBJECT_ROOTTRUST,  g_wszLDAPRootTrustURLTemplate },
    { DSP_OBJECT_AIA,        g_wszzLDAPIssuerCertURLTemplate },
    { DSP_OBJECT_KRA,        g_wszzLDAPKRACertURLTemplate },
    { DSP_OBJECT_USER,       NULL },
    { DSP_OBJECT_MACHINE,    NULL },
};

HRESULT GetSubjectAltNameEntry(
    CERT_CONTEXT const *pccCert,
    DWORD dwAltNameChoice,
    LPCSTR pcszOID,
    LPWSTR *ppwszValue)
{
    HRESULT hr;
    PCERT_INFO pCertInfo = pccCert->pCertInfo;
    CERT_ALT_NAME_INFO *pInfo = NULL;
    CERT_NAME_VALUE *pNameValue = NULL;
    DWORD cb;

    bool fFound = false;

    *ppwszValue = NULL;

    for (DWORD i = 0; !fFound && i < pCertInfo->cExtension; i++)
    {
        if (0 == strcmp(pCertInfo->rgExtension[i].pszObjId, szOID_SUBJECT_ALT_NAME2))
        {
            // Decode to plain text

            if (!myDecodeObject(
                            X509_ASN_ENCODING,
                            X509_ALTERNATE_NAME,
                            pCertInfo->rgExtension[i].Value.pbData,
                            pCertInfo->rgExtension[i].Value.cbData,
                            CERTLIB_USE_LOCALALLOC,
                            (VOID **) &pInfo,
                            &cb))
            {
                hr = myHLastError();
                _JumpError(hr, error, "myDecodeObject");
            }

            for(DWORD j=0; !fFound && j<pInfo->cAltEntry; j++)
            {
                if(dwAltNameChoice== pInfo->rgAltEntry[j].dwAltNameChoice)
                {
                    switch(dwAltNameChoice)
                    {
                    case CERT_ALT_NAME_OTHER_NAME:
                        if(0==_stricmp(pcszOID, pInfo->rgAltEntry[j].pOtherName->pszObjId))
                        {
                            if (!myDecodeObject(
                                        X509_ASN_ENCODING,
                                        X509_UNICODE_ANY_STRING,
                                        pInfo->rgAltEntry[j].pOtherName->Value.pbData,
                                        pInfo->rgAltEntry[j].pOtherName->Value.cbData,
                                        CERTLIB_USE_LOCALALLOC,
                                        (VOID **) &pNameValue,
                                        &cb))
                            {
                                hr = myHLastError();
                                _JumpError(hr, error, "Policy:myDecodeObject");
                            }

                            hr = myDupString((LPWSTR)pNameValue->Value.pbData, ppwszValue);
                            _JumpIfError(hr, error, "myDupString");

                            fFound = true;
                        }
                        break;
                    case CERT_ALT_NAME_RFC822_NAME:
                        hr = myDupString(pInfo->rgAltEntry[j].pwszRfc822Name, ppwszValue);
                        _JumpIfError(hr, error, "myDupString");
                        fFound = true;
                        break;
                    case CERT_ALT_NAME_DNS_NAME:
                        hr = myDupString(pInfo->rgAltEntry[j].pwszDNSName, ppwszValue);
                        _JumpIfError(hr, error, "myDupString");
                        fFound = true;
                        break;
                        
                    }
                }
            }
        }
    }

    if(!fFound)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }
    else
    {
        hr = S_OK;
    }

error:
    if (NULL != pInfo)
    {
        LocalFree(pInfo);
    }
    if(pNameValue)
    {
        LocalFree(pNameValue);
    }
    return hr;
}


HRESULT
LocateUserOrMachineInDS(
    IN CERT_CONTEXT const *pccCert,
    IN DWORD dwObjectType,
    OUT LPWSTR *ppwszURL)
{
    HRESULT hr = S_FALSE;
    HANDLE hDS = NULL;
    PDOMAIN_CONTROLLER_INFO pDCI = NULL;
    PDS_NAME_RESULT pName = NULL;
    LPCWSTR pwszDC;
    LPWSTR pwszSearchName = NULL;
    LPCWSTR pcwszAttribute;
    LPCWSTR pcwszObjectCategory = 
        (LPC_USEROBJECT==dwObjectType)?wszDSUSERCLASSNAME:wszDSMACHINECLASSNAME;
    LDAP *pld = NULL;
    LPCWSTR pcwszFormat = L"(&(objectCategory=%s)(%s=%s))";
    LPWSTR pwszUserFilter = NULL;

    CSASSERT(dwObjectType==LPC_USEROBJECT || dwObjectType==LPC_MACHINEOBJECT);

    // DSCrackNames first

    if(dwObjectType == LPC_USEROBJECT)
    {
        // look for UPN is subject alt name
        hr = GetSubjectAltNameEntry(
            pccCert,
            CERT_ALT_NAME_OTHER_NAME,
            szOID_NT_PRINCIPAL_NAME,
            &pwszSearchName);
        if(S_OK==hr)
        {
            hr = DsGetDcName(
                NULL,
                NULL,
                NULL,
                NULL,
                DS_GC_SERVER_REQUIRED,
                &pDCI);
            _JumpIfError(hr, error, "DsGetDCName");

            pwszDC = pDCI->DomainControllerName;
            while (*pwszDC == L'\\')
            {
                pwszDC++;
            }

            hr = DsBind(pwszDC, NULL, &hDS);
            _JumpIfError(hr, error, "DSBind");

            hr = DsCrackNames(
                hDS,
                DS_NAME_NO_FLAGS,
                DS_USER_PRINCIPAL_NAME,
                DS_FQDN_1779_NAME,
                1,
                &pwszSearchName,
                &pName);

            if(S_OK==hr && pName->cItems>0 && pName->rItems[0].pName)
            {
                hr = myDupString(pName->rItems[0].pName, ppwszURL);
                _JumpIfError(hr, error, "myDupString");
            }
        }
    }

    // Not found yet? Try other fields
    if(NULL == *ppwszURL)
    {
        if(dwObjectType == LPC_USEROBJECT)
        {
            // look for email is subject alt name
            hr = GetSubjectAltNameEntry(
                pccCert,
                CERT_ALT_NAME_RFC822_NAME,
                NULL,
                &pwszSearchName);
            _PrintIfError(hr, "GetSubjectAltNameEntry");

            if(S_OK != hr)
            {
                hr = myGetRDNAttributeFromNameBlob(
                    &pccCert->pCertInfo->Subject,
                    szOID_RSA_emailAddr,
                    &pwszSearchName);
                _PrintIfError(hr, "myGetRDNAttributeFromNameBlob");
            }

            if(S_OK==hr)
            {
                pcwszAttribute = wszDSMAILATTRIBUTE;
            }
        }
        else // LPC_MACHINEOBJECT
        {
            // look for DNS name in subject alt name
            hr = GetSubjectAltNameEntry(
                pccCert,
                CERT_ALT_NAME_DNS_NAME,
                NULL,
                &pwszSearchName);
            _PrintIfError(hr, "GetSubjectAltNameEntry");

            if(S_OK != hr)
            {
               hr = myGetCommonName(
                           &pccCert->pCertInfo->Subject,
                           FALSE,
                           &pwszSearchName);
               _PrintIfError(hr, "myGetCommonName");
            }

            if(S_OK==hr)
            {
                pcwszAttribute = wszDSDNSHOSTNAMEATTRIBUTE;
            }
        }

        // Found a suitable name? Search the global catalog for the matching object.
        if(NULL != pwszSearchName)
        {
	    hr = myLdapOpen(
			NULL,		// pwszDomainName
			RLBF_REQUIRE_GC | RLBF_REQUIRE_SECURE_LDAP,
			&pld,
			NULL,		// pstrDomainDN
			NULL);		// pstrConfigDN
	    _JumpIfError(hr, error, "myLdapOpen");

            if(dwObjectType == LPC_USEROBJECT)
            {
                // build the search filter, e.g. 
                // (&(objectCategory=user)(mail=bogdant@microsoft.com))

                pwszUserFilter = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*
                    (wcslen(pcwszFormat)+wcslen(pcwszObjectCategory)+
                     wcslen(pcwszAttribute)+wcslen(pwszSearchName)+1));
                _JumpIfAllocFailed(pwszUserFilter, error);

                wsprintf(pwszUserFilter, pcwszFormat, 
                    pcwszObjectCategory, pcwszAttribute, pwszSearchName);

                hr = myLdapFindObjectInForest(
                    pld,
                    pwszUserFilter,
                    ppwszURL);
                _PrintIfErrorStr(hr, "myLdapFindObjectInForest", pwszUserFilter);
            }
            else
            {
                hr = myLdapFindComputerInForest(
                    pld,
                    pwszSearchName,
                    ppwszURL);
                _PrintIfErrorStr(hr, "myLdapFindMachineInForest", pwszSearchName);
            }
        }
    }

    if(NULL == *ppwszURL)
    {
        hr = CRYPT_E_NOT_FOUND;
        _JumpError(hr, error, "Could not find a matching DS object to publish to");
    }

    hr = S_OK;

error:
    if (NULL != hDS)
    {
        DsUnBind(&hDS);
    }
    if(pDCI)
    {
        NetApiBufferFree(pDCI);
    }
    if(pName)
    {
        DsFreeNameResult(pName);
    }
    if(pwszSearchName)
    {
        LocalFree(pwszSearchName);
    }
    myLdapClose(pld, NULL, NULL);
    if(pwszUserFilter)
    {
        LocalFree(pwszUserFilter);
    }

    return hr;
}


HRESULT
dsPublishCert(
    IN CERT_CONTEXT const *pccPublish,
    IN WCHAR const *pwszSanitizedCN,
    IN DWORD dspFlags,
    IN DWORD dwObjectType)
{
    HRESULT hr;
    WCHAR const *pwszAttribute;
    WCHAR *pwszServerName = NULL;	// Shouldn't be necessary
    WCHAR *pwszURL = NULL;
    LDAP *pld = NULL;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    DWORD dwDisposition;
    DWORD i;
    WCHAR *pwszError = NULL;

    hr = myGetMachineDnsName(&pwszServerName);
    _JumpIfError(hr, error, "myGetMachineDnsName");
    
    hr = myLdapOpen(
		g_pwszDC,
		RLBF_REQUIRE_SECURE_LDAP,
		&pld,
		&strDomainDN,
		&strConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    switch (DSP_ATTRIBUTE_MASK & dspFlags)
    {
	case DSP_ATTRIBUTE_CACERTIFICATE:
	    pwszAttribute = wszDSCACERTATTRIBUTE;
	    break;

	case DSP_ATTRIBUTE_USERCERTIFICATE:
	    pwszAttribute = wszDSUSERCERTATTRIBUTE;
	    break;

	case DSP_ATTRIBUTE_CROSSCERTPAIR:
	    pwszAttribute = wszDSCROSSCERTPAIRATTRIBUTE;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad attribute indicator");
    }

    for (i = 0; i < ARRAYSIZE(s_rgObjectMap); i++)
    {
	WCHAR const *pwszTemplate;

	if (0 == (s_rgObjectMap[i].ObjectFlags & DSP_OBJECT_MASK & dspFlags))
	{
	    continue;
	}
	pwszTemplate = s_rgObjectMap[i].pwszTemplate;

	if (NULL != pwszTemplate)
	{
	    hr = myFormatCertsrvStringArray(
				FALSE,		// fURL
				pwszServerName,	// pwszServerName_p1_2
				pwszSanitizedCN,// pwszSanitizedName_p3_7
				0,		// iCert_p4
				MAXDWORD,	// iCertTarget_p4
				strDomainDN,	// pwszDomainDN_p5
				strConfigDN,	// pwszConfigDN_p6
				0,		// iCRL_p8
				FALSE,		// fDeltaCRL_p9
				FALSE,		// fDSAttrib_p10_11
				1,		// cStrings
				&pwszTemplate,	// apwszStringsIn
				&pwszURL);	// apwszStringsOut
	    _JumpIfError(hr, error, "myFormatCertsrvStringArray");
	}
	else
	{
	    // user and machine objects don't have predefined DS location, we 
	    // need to search for it based on information from the cert

	    hr = LocateUserOrMachineInDS(pccPublish, dwObjectType, &pwszURL);
            if (S_OK != hr)
            {
		wprintf(
		    myLoadResourceString(IDS_ERR_CANNOT_FIND_MATCHING_OBJ));
            }
            _JumpIfError(hr, error, "LocateObjectInDS");
        }

	wprintf(L"%ws?%ws\n\n", pwszURL, pwszAttribute);
	if (g_fForce)
	{
	    dwObjectType |= LPC_CREATECONTAINER | LPC_CREATEOBJECT;
	}

	hr = myLdapPublishCertToDS(
			    pld,
			    pccPublish,
			    pwszURL,
			    pwszAttribute,
			    dwObjectType,
			    FALSE,		// fDelete
			    &dwDisposition,
			    &pwszError);
	_JumpIfError(hr, error, "myLdapPublishCertToDS");

	if (LDAP_SUCCESS == dwDisposition)
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_ADDED_TO_DS_STORE), // "%ws added to DS store."
		myLoadResourceString(IDS_CERTIFICATE)); // "Certificate"
	}
	else 
	{
	    CSASSERT(LDAP_ATTRIBUTE_OR_VALUE_EXISTS == dwDisposition);
	    wprintf(
		myLoadResourceString(IDS_FORMAT_ALREADY_IN_DS_STORE), // "%ws already in DS store."
		myLoadResourceString(IDS_CERTIFICATE)); // "Certificate"
	}
	wprintf(wszNewLine);
	wprintf(wszNewLine);

        if (dspFlags & DSP_OBJECT_AIA)
        {
            hr = myLdapFilterCertificates(
				    pld,
				    pwszURL,
				    pwszAttribute,
				    &dwDisposition,
				    &pwszError);
            _JumpIfErrorStr(hr, error, "myLdapFilterCertificates", pwszURL);
        }
	LocalFree(pwszURL);
	pwszURL = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	wprintf(L"%ws\n", pwszError);
	LocalFree(pwszError);
    }
    if (NULL != pwszServerName)
    {
	LocalFree(pwszServerName);
    }
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


HRESULT
dsPublishCRL(
    OPTIONAL IN LDAP *pld,
    IN CRL_CONTEXT const *pCRLPublish,
    IN BOOL fDelta,
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    WCHAR const *pwszAttribute;
    LDAP *pldT = NULL;
    DWORD dwDisposition;
    UINT idMsg = fDelta? IDS_PROP_DELTACRL : IDS_PROP_BASECRL;
    WCHAR *pwszError = NULL;

    pwszAttribute = fDelta? wszDSDELTACRLATTRIBUTE : wszDSBASECRLATTRIBUTE;
    wprintf(L"%ws?%ws\n\n", pwszURL, pwszAttribute);

    if (NULL == pld)
    {
	hr = myLdapOpen(
		    g_pwszDC,
		    RLBF_REQUIRE_SECURE_LDAP,
		    &pldT,
		    NULL,
		    NULL);
	_JumpIfError(hr, error, "myLdapOpen");

	pld = pldT;
    }

    hr = myLdapPublishCRLToDS(
			pld,
			pCRLPublish,
			pwszURL,
			pwszAttribute,
			&dwDisposition,
			&pwszError);
    _JumpIfError(hr, error, "myLdapPublishCRLToDS");

    if (LDAP_SUCCESS == dwDisposition)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_ADDED_TO_DS_STORE), // "%ws added to DS store."
	    myLoadResourceString(idMsg));
    }
    else
    {
	CSASSERT(LDAP_ATTRIBUTE_OR_VALUE_EXISTS == dwDisposition);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_ALREADY_IN_DS_STORE), // "%ws already in DS store."
	    myLoadResourceString(idMsg));
    }
    wprintf(wszNewLine);
    wprintf(wszNewLine);
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	wprintf(L"%ws\n", pwszError);
	LocalFree(pwszError);
    }
    myLdapClose(pldT, NULL, NULL);
    return(hr);
}


HRESULT
IsCrossCACert(
    IN CERT_CONTEXT const *pCertContext,
    OUT BOOL *pfCrossCA)
{
    HRESULT hr;
    WCHAR *pwszObjId = NULL;
    HCERTTYPE hCertType = NULL;
    DWORD dwValue;
    CAutoLPWSTR pwszCertTypeNameV1;

    *pfCrossCA = FALSE;

    // CrossCA is a V2 template, so only fetch the template OID

    hr = cuGetCertType(
		pCertContext->pCertInfo,
		&pwszCertTypeNameV1,// ppwszCertTypeNameV1
		NULL,		// ppwszDisplayNameV1
		&pwszObjId,	// ppwszCertTypeObjId
		NULL,		// ppwszCertTypeName
		NULL);		// ppwszDisplayName
    if (S_OK != hr || NULL == pwszObjId)
    {
	_PrintIfError2(hr, "cuGetCertType", CRYPT_E_NOT_FOUND);
	if (CRYPT_E_NOT_FOUND == hr)
	{
	    hr = S_OK;
	}
	goto error;
    }
    
    if(((LPWSTR)NULL)!=pwszCertTypeNameV1&&
       0 == LSTRCMPIS(pwszCertTypeNameV1, wszCERTTYPE_CROSS_CA))
    {
        *pfCrossCA = TRUE;
    }
    else
    {
        hr = CAFindCertTypeByName(
		    pwszObjId,
		    NULL,
		    CT_ENUM_USER_TYPES | CT_ENUM_MACHINE_TYPES | CT_FIND_BY_OID,
		    &hCertType);
        if (S_OK != hr)
        {
	    _PrintErrorStr2(hr, "CAFindCertTypeByName", pwszObjId, hr);
	    if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	    {
	        _JumpErrorStr(hr, error, "CAFindCertTypeByName", pwszObjId);
	    }
        }
        else
        {
	    hr = CAGetCertTypeFlagsEx(hCertType, CERTTYPE_GENERAL_FLAG, &dwValue);
	    _JumpIfError(hr, error, "CAGetCertTypeFlagsEx");

	    if (CT_FLAG_IS_CROSS_CA & dwValue)
	    {
	        *pfCrossCA = TRUE;
	    }
        }
    }
    hr = S_OK;

error:
    if (NULL != hCertType)
    {
	CACloseCertType(hCertType);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }
    return(hr);
}


HRESULT
IsCACert(
    IN CERT_CONTEXT const *pCertContext,
    OUT BOOL *pfCA)
{
    HRESULT hr;
    CERT_EXTENSION *pExt;
    
    *pfCA = FALSE;
    pExt = CertFindExtension(
		    szOID_BASIC_CONSTRAINTS2,
		    pCertContext->pCertInfo->cExtension,
		    pCertContext->pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	CERT_BASIC_CONSTRAINTS2_INFO Constraints;
	DWORD cb;

	cb = sizeof(Constraints);
	if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_BASIC_CONSTRAINTS2,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    0,
			    &Constraints,
			    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptDecodeObject");
	}
	*pfCA = Constraints.fCA;
    }
    hr = S_OK;

error:
    return(hr);
}


char const *g_apszKRAObjIds[] = {
    szOID_KP_KEY_RECOVERY_AGENT,
    szOID_EFS_RECOVERY,
};


HRESULT
IsKRACert(
    IN CERT_CONTEXT const *pCertContext,
    OUT BOOL *pfKRA)
{
    HRESULT hr;
    CERT_EXTENSION *pExt;
    CERT_ENHKEY_USAGE *pKeyUsage = NULL;
    CERT_POLICIES_INFO *pPolicies = NULL;
    DWORD cb;
    DWORD i;
    DWORD j;
    
    *pfKRA = FALSE;
    pExt = CertFindExtension(
		    szOID_ENHANCED_KEY_USAGE,
		    pCertContext->pCertInfo->cExtension,
		    pCertContext->pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_ENHANCED_KEY_USAGE,
			pExt->Value.pbData,
			pExt->Value.cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pKeyUsage,
			&cb))
	{
	    hr = myHLastError();
	    _JumpIfError(hr, error, "myDecodeObject");
	}
	for (i = 0; i < pKeyUsage->cUsageIdentifier; i++)
	{
	    char const *pszObjId = pKeyUsage->rgpszUsageIdentifier[i];

	    for (j = 0; j < ARRAYSIZE(g_apszKRAObjIds); j++)
	    {
		if (0 == strcmp(
			    pszObjId,
			    g_apszKRAObjIds[j]))
		{
		    *pfKRA = TRUE;
		    hr = S_OK;
		    goto error;
		}
	    }
	}
    }

    pExt = CertFindExtension(
		    szOID_APPLICATION_CERT_POLICIES,
		    pCertContext->pCertInfo->cExtension,
		    pCertContext->pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_CERT_POLICIES,
			pExt->Value.pbData,
			pExt->Value.cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pPolicies,
			&cb))
	{
	    hr = myHLastError();
	    _JumpIfError(hr, error, "myDecodeObject");
	}
	for (i = 0; i < pPolicies->cPolicyInfo; i++)
	{
	    CERT_POLICY_INFO *pPolicyInfo = &pPolicies->rgPolicyInfo[i];

	    for (j = 0; j < ARRAYSIZE(g_apszKRAObjIds); j++)
	    {
		if (0 == strcmp(
			    pPolicyInfo->pszPolicyIdentifier,
			    g_apszKRAObjIds[j]))
		{
		    *pfKRA = TRUE;
		    hr = S_OK;
		    goto error;
		}
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pKeyUsage)
    {
	LocalFree(pKeyUsage);
    }
    if (NULL != pPolicies)
    {
    LocalFree(pPolicies);
    }
    return(hr);
}

HRESULT
IsMachineCert(
    IN CERT_CONTEXT const *pCertContext,
    OUT BOOL *pfMachine)
{
    HRESULT hr;
    HCERTTYPE hCertType = NULL;
    CERT_EXTENSION *pExt;
    CERT_TEMPLATE_EXT *pTemplate = NULL;
    CERT_NAME_VALUE *pbName = NULL;
    LPWSTR pwszTemplate = NULL;
    DWORD dwTemplateFlags;
    DWORD cb;
    bool fNameIsOID;

    *pfMachine = FALSE;
    pExt = CertFindExtension(
		    szOID_CERTIFICATE_TEMPLATE,
		    pCertContext->pCertInfo->cExtension,
		    pCertContext->pCertInfo->rgExtension);

    if (NULL != pExt)
    {
        if (!myDecodeObject(
                        X509_ASN_ENCODING,
                        X509_CERTIFICATE_TEMPLATE,
                        pExt->Value.pbData,
                        pExt->Value.cbData,
                        CERTLIB_USE_LOCALALLOC,
                        (VOID **) &pTemplate,
                        &cb))
        {
            hr = myHLastError();
            _JumpError(hr, error, "myDecodeObject");
        }
        if (!ConvertSzToWsz(&pwszTemplate, pTemplate->pszObjId, -1))
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "ConvertSzToWsz");
        }
        fNameIsOID = true;
    }
    else
    {
        // try v1 template extension

        pExt = CertFindExtension(
		        szOID_ENROLL_CERTTYPE_EXTENSION,
		        pCertContext->pCertInfo->cExtension,
		        pCertContext->pCertInfo->rgExtension);
        if(pExt)
        {
            if (!myDecodeObject(
                            X509_ASN_ENCODING,
                            X509_UNICODE_ANY_STRING,
                            pExt->Value.pbData,
                            pExt->Value.cbData,
                            CERTLIB_USE_LOCALALLOC,
                            (VOID **) &pbName,
                            &cb))
            {
                hr = myHLastError();
                _JumpError(hr, error, "myDecodeObject");
            }

            hr = myDupString((LPWSTR)pbName->Value.pbData, &pwszTemplate);
            _JumpIfError(hr, error, "myDupString");

            fNameIsOID = false;
        }
    }

    if(pwszTemplate)
    {
        hr = CAFindCertTypeByName(
            pwszTemplate,
            NULL,
            (fNameIsOID?CT_FIND_BY_OID:0) |
            CT_ENUM_MACHINE_TYPES |
            CT_ENUM_USER_TYPES,
            &hCertType);

        if(S_OK==hr)
        {
            hr = CAGetCertTypeFlagsEx(
                hCertType,
                CERTTYPE_GENERAL_FLAG,    
                &dwTemplateFlags);
        }

        if(S_OK==hr)
        {
            *pfMachine = (dwTemplateFlags & CT_FLAG_MACHINE_TYPE)?TRUE:FALSE;
        }
    }

    hr = S_OK;

error:
    if (NULL != hCertType)
    {
        CACloseCertType(hCertType);
    }
    LOCAL_FREE(pTemplate);
    LOCAL_FREE(pbName);
    LOCAL_FREE(pwszTemplate);
    return(hr);
}
	
HRESULT
dsPublishCertFromContext(
    IN CERT_CONTEXT const *pCertContext,
    OPTIONAL IN WCHAR const *pwszType)
{
    HRESULT hr;
    BOOL fCrossCA;
    BOOL fCA;
    BOOL fKRA;
    BOOL fRoot;
    BOOL fMachine;
    DWORD dspFlags;
    DWORD dwObjectType;
    WCHAR *pwszCN = NULL;
    WCHAR const *pwszSanitizedCN = NULL;
    WCHAR *pwszSanitizedCNAlloc = NULL;

    // If a CrossCA cert, publish to the Subject CN's AIA container.
    // If a CA cert, publish to the Subject CN's AIA container.
    // If a KRA cert, publish to the Issuer CN's KRA container.
    
    hr = IsCrossCACert(pCertContext, &fCrossCA);
    if (S_OK != hr)
    {
	_PrintError(hr, "IsCrossCACert");
	if (NULL == pwszType && !g_fForce)
	{
	    goto error;
	}
    }

    hr = IsCACert(pCertContext, &fCA);
    _JumpIfError(hr, error, "IsCACert");

    hr = IsKRACert(pCertContext, &fKRA);
    _JumpIfError(hr, error, "IsKRACert");

    hr = IsMachineCert(pCertContext, &fMachine);
    _JumpIfError(hr, error, "IsMachineCert");

    fRoot = CertCompareCertificateName(
			    X509_ASN_ENCODING,
			    &pCertContext->pCertInfo->Subject,
			    &pCertContext->pCertInfo->Issuer);

    dwObjectType = LPC_CAOBJECT;
    if (NULL == pwszType || myIsMinusSignString(pwszType))
    {
	if (fCrossCA)
	{
	    // Don't publish to "Certification Authorities" (root CAs)
	    // because Win2k crypt32 can't handle zero byte cACertificate
	    // attributes, and aborts processing valid roots.

	    dspFlags = DSP_OBJECT_AIA |
			    //DSP_OBJECT_ROOTTRUST |
			    DSP_ATTRIBUTE_CROSSCERTPAIR |
			    DSP_TYPE_SUBCACERT;
	}
	else
	if (fCA)
	{
	    dspFlags = DSP_OBJECT_AIA | DSP_ATTRIBUTE_CACERTIFICATE;
	    if (fRoot)
	    {
		dspFlags |= DSP_OBJECT_ROOTTRUST;
	    }
	}
	else
	if (fKRA)
	{
	    dspFlags = DSP_OBJECT_KRA | DSP_ATTRIBUTE_USERCERTIFICATE;
	    dwObjectType = LPC_KRAOBJECT;
	}
	else
	if(fMachine)
	{
	    dspFlags = 
		DSP_OBJECT_MACHINE |
		DSP_ATTRIBUTE_USERCERTIFICATE |
		DSP_TYPE_EECERT;
	    dwObjectType = LPC_MACHINEOBJECT;
	}
	else
	{
	    dspFlags = 
		DSP_OBJECT_USER |
		DSP_ATTRIBUTE_USERCERTIFICATE |
		DSP_TYPE_EECERT;
	    dwObjectType = LPC_USEROBJECT;
	}
    }
    else
    {
	if (0 == LSTRCMPIS(pwszType, L"NTAuthCA"))
	{
	    dspFlags = DSP_OBJECT_NTAUTHCERT |
			    DSP_ATTRIBUTE_CACERTIFICATE |
			    DSP_TYPE_ROOTCACERT |
			    DSP_TYPE_SUBCACERT;
	    pwszSanitizedCN = L"NTAuthCertificates";
	}
	else
	if (0 == LSTRCMPIS(pwszType, L"RootCA"))
	{
	    dspFlags = DSP_OBJECT_AIA |
			    DSP_OBJECT_ROOTTRUST |
			    DSP_ATTRIBUTE_CACERTIFICATE |
			    DSP_TYPE_ROOTCACERT;
	}
	else
	if (0 == LSTRCMPIS(pwszType, L"SubCA"))
	{
	    dspFlags = DSP_OBJECT_AIA |
			    DSP_ATTRIBUTE_CACERTIFICATE |
			    DSP_TYPE_SUBCACERT;
	}
	else
	if (0 == LSTRCMPIS(pwszType, L"CrossCA"))
	{
	    // Don't publish to "Certification Authorities" (root CAs)
	    // because Win2k crypt32 can't handle zero byte cACertificate
	    // attributes, and aborts processing valid roots.

	    dspFlags = DSP_OBJECT_AIA |
			    //DSP_OBJECT_ROOTTRUST |
			    DSP_ATTRIBUTE_CROSSCERTPAIR |
			    DSP_TYPE_SUBCACERT;
	}
	else
	if (0 == LSTRCMPIS(pwszType, L"KRA"))
	{
	    dspFlags = DSP_OBJECT_KRA |
			    DSP_ATTRIBUTE_USERCERTIFICATE |
			    DSP_TYPE_KRACERT | 
			    DSP_TYPE_EECERT;
	    dwObjectType = LPC_KRAOBJECT;
	}
	else
	if (0 == LSTRCMPIS(pwszType, L"User"))
	{
	    dspFlags = DSP_OBJECT_USER |
			    DSP_ATTRIBUTE_USERCERTIFICATE |
			    DSP_TYPE_EECERT;
	    dwObjectType = LPC_USEROBJECT;
	}
	else
	if (0 == LSTRCMPIS(pwszType, L"Machine"))
	{
	    dspFlags = DSP_OBJECT_MACHINE |
			    DSP_ATTRIBUTE_USERCERTIFICATE |
			    DSP_TYPE_EECERT;
	    dwObjectType = LPC_MACHINEOBJECT;
	}
	else
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "pwszType", pwszType);
	}
	if (!fKRA && (DSP_TYPE_KRACERT & dspFlags))
	{
	    _PrintError(S_OK, "forcing KRA");
	}
	if (fCA && (DSP_TYPE_EECERT & dspFlags))
	{
	    _PrintError(S_OK, "forcing non-CA");
	}
	if (!fCA &&
	    ((DSP_TYPE_ROOTCACERT | DSP_TYPE_SUBCACERT) & dspFlags))
	{
	    _PrintError(S_OK, "forcing CA");
	}
	if (!fRoot &&
	    DSP_TYPE_ROOTCACERT ==
		((DSP_TYPE_ROOTCACERT | DSP_TYPE_SUBCACERT) & dspFlags))
	{
	    _PrintError(S_OK, "forcing Root");
	}
    }
    if (NULL == pwszSanitizedCN)
    {
	hr = myGetCommonName(
		    fCA?
			&pCertContext->pCertInfo->Subject :
			&pCertContext->pCertInfo->Issuer,
		    TRUE,
		    &pwszCN);
	_JumpIfError(hr, error, "myGetCommonName");

	hr = mySanitizeName(pwszCN, &pwszSanitizedCNAlloc);
	_JumpIfError(hr, error, "mySanitizeName");

	pwszSanitizedCN = pwszSanitizedCNAlloc;
    }
    hr = dsPublishCert(
		pCertContext,
		pwszSanitizedCN,
		dspFlags,
		dwObjectType);
    _JumpIfError(hr, error, "dsPublishCert");

error:
    if (NULL != pwszCN)
    {
	LocalFree(pwszCN);
    }
    if (NULL != pwszSanitizedCNAlloc)
    {
	LocalFree(pwszSanitizedCNAlloc);
    }
    return(hr);
}


HRESULT
dsPublishCRLFromContext(
    IN CRL_CONTEXT const *pCRLContext,
    IN BOOL fDelta)
{
    HRESULT hr;
    HRESULT hr2;
    CRL_DIST_POINTS_INFO *pcdp = NULL;
    CERT_EXTENSION *pExt;
    WCHAR *pwszURL = NULL;
    DWORD cb;
    DWORD i;
    DWORD j;

    pExt = CertFindExtension(
		    szOID_CRL_SELF_CDP,
		    pCRLContext->pCrlInfo->cExtension,
		    pCRLContext->pCrlInfo->rgExtension);
    if (NULL == pExt && !fDelta)
    {
	pExt = CertFindExtension(
			szOID_FRESHEST_CRL,
			pCRLContext->pCrlInfo->cExtension,
			pCRLContext->pCrlInfo->rgExtension);
    }
    if (NULL == pExt)
    {
	wprintf(myLoadResourceString(IDS_ERROR_EXTENSION_MISSING));
	wprintf(wszNewLine);
	hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	_JumpError(hr, error, "CertFindExtension");
    }
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CRL_DIST_POINTS,
		    pExt->Value.pbData,
		    pExt->Value.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcdp,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    hr = S_OK;
    for (i = 0; i < pcdp->cDistPoint; i++)
    {
	CRL_DIST_POINT const *pDistPoint = &pcdp->rgDistPoint[i];

	if (CRL_DIST_POINT_FULL_NAME !=
	    pDistPoint->DistPointName.dwDistPointNameChoice)
	{
	    continue;
	}
	for (j = 0; j < pDistPoint->DistPointName.FullName.cAltEntry; j++)
	{
	    CERT_ALT_NAME_ENTRY const *pAltNameEntry = &pDistPoint->DistPointName.FullName.rgAltEntry[j];

#define wszLDAPCOLON	L"ldap:"
	    WCHAR awcLDAP[ARRAYSIZE(wszLDAPCOLON)];

	    if (CERT_ALT_NAME_URL != pAltNameEntry->dwAltNameChoice)
	    {
		continue;
	    }
	    if (ARRAYSIZE(awcLDAP) > wcslen(pAltNameEntry->pwszURL))
	    {
		continue;
	    }
	    CopyMemory(awcLDAP, pAltNameEntry->pwszURL, sizeof(awcLDAP));
	    awcLDAP[ARRAYSIZE(awcLDAP) - 1] = L'\0';
	    if (0 != LSTRCMPIS(awcLDAP, wszLDAPCOLON))
	    {
		continue;
	    }

	    if (NULL != pwszURL)
	    {
		LocalFree(pwszURL);
		pwszURL = NULL;
	    }

	    hr2 = myInternetUncanonicalizeURL(pAltNameEntry->pwszURL, &pwszURL);
	    _PrintIfError(hr2, "myInternetUncanonicalizeURL");
	    if (S_OK == hr)
	    {
		hr = hr2;		// Save first error
	    }

	    hr2 = dsPublishCRL(
			NULL,
			pCRLContext,
			fDelta,
			NULL != pwszURL? pwszURL : pAltNameEntry->pwszURL);
	    _PrintIfError(hr2, "dsPublishCRL");
	    if (S_OK == hr)
	    {
		hr = hr2;		// Save first error
	    }
	}
	_JumpIfError(hr, error, "dsPublishCRL");
    }

error:
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    if (NULL != pcdp)
    {
	LocalFree(pcdp);
    }
    return(hr);
}


HRESULT
dsPublishCRLFromParms(
    IN CRL_CONTEXT const *pCRLContext,
    IN BOOL fDelta,
    IN WCHAR const *pwszServerName,
    OPTIONAL IN WCHAR const *pwszSanitizedCN)
{
    HRESULT hr;
    WCHAR *pwszServerNameAlloc = NULL;	// Shouldn't be necessary
    LDAP *pld = NULL;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    WCHAR *pwszCN = NULL;
    WCHAR *pwszSanitizedCNAlloc = NULL;
    WCHAR *pwszSanitizedCNAlloc2 = NULL;
    WCHAR *pwszURL = NULL;
    DWORD iCert = 0;
    DWORD iCRL = 0;
    WCHAR const *pwszTemplate;

    if (NULL == pwszServerName)
    {
	hr = myGetMachineDnsName(&pwszServerNameAlloc);
	_JumpIfError(hr, error, "myGetMachineDnsName");

	pwszServerName = pwszServerNameAlloc;
    }
    
    hr = myLdapOpen(
		g_pwszDC,
		RLBF_REQUIRE_SECURE_LDAP,
		&pld,
		&strDomainDN,
		&strConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    if (NULL == pwszSanitizedCN)
    {
	hr = myGetCommonName(&pCRLContext->pCrlInfo->Issuer, FALSE, &pwszCN);
	_JumpIfError(hr, error, "myGetCommonName");

	hr = mySanitizeName(pwszCN, &pwszSanitizedCNAlloc);
	_JumpIfError(hr, error, "mySanitizeName");

	pwszSanitizedCN = pwszSanitizedCNAlloc;
    }
    if (MAXDWORD == dsGetNumericSuffix(pwszSanitizedCN))
    {
	CERT_EXTENSION *pExt;

	pExt = CertFindExtension(
			szOID_CERTSRV_CA_VERSION,
			pCRLContext->pCrlInfo->cExtension,
			pCRLContext->pCrlInfo->rgExtension);
	if (NULL != pExt)
	{
	    DWORD NameId;
	    DWORD cb;
	    WCHAR const *pwsz;

	    cb = sizeof(NameId);
	    NameId = 0;
	    if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_INTEGER,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    0,
			    &NameId,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CryptDecodeObject");
	    }
	    iCert = CANAMEIDTOICERT(NameId);
	    iCRL = CANAMEIDTOIKEY(NameId);
	}
    }

    pwszTemplate = g_wszzLDAPRevocationURLTemplate;
    hr = myFormatCertsrvStringArray(
			    FALSE,		// fURL
			    pwszServerName,	// pwszServerName_p1_2
			    pwszSanitizedCN,	// pwszSanitizedName_p3_7
			    iCert,		// iCert_p4
			    MAXDWORD,		// iCertTarget_p4
			    strDomainDN,	// pwszDomainDN_p5
			    strConfigDN,	// pwszConfigDN_p6
			    iCRL,		// iCRL_p8
			    fDelta,		// fDeltaCRL_p9
			    FALSE,		// fDSAttrib_p10_11
			    1,			// cStrings
			    &pwszTemplate,	// apwszStringsIn
			    &pwszURL);		// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

    hr = dsPublishCRL(pld, pCRLContext, fDelta, pwszURL);
    _JumpIfError(hr, error, "dsPublishCRL");

error:
    if (NULL != pwszCN)
    {
	LocalFree(pwszCN);
    }
    if (NULL != pwszSanitizedCNAlloc2)
    {
	LocalFree(pwszSanitizedCNAlloc2);
    }
    if (NULL != pwszSanitizedCNAlloc)
    {
	LocalFree(pwszSanitizedCNAlloc);
    }
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    if (NULL != pwszServerNameAlloc)
    {
	LocalFree(pwszServerNameAlloc);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


// pwszType: NTAuthCA | RootCA | SubCA | CrossCA | KRA | User | Machine
// pwszDSCDPContainer: machine name

HRESULT
verbDSPublish(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfn,
    OPTIONAL IN WCHAR const *pwszTypeOrDSCDPContainer,
    OPTIONAL IN WCHAR const *pwszDSCN,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    CERT_CONTEXT const *pCertContext = NULL;
    CRL_CONTEXT const *pCRLContext = NULL;

    CSASSERT(NULL != pwszfn);
    hr = cuLoadCert(pwszfn, &pCertContext);
    if (S_OK == hr)
    {
	if (NULL != pwszDSCN)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "non-NULL CDP parms");
	}
	hr = dsPublishCertFromContext(pCertContext, pwszTypeOrDSCDPContainer);
	_JumpIfError(hr, error, "dsPublishCertFromContext");
    }
    else
    {
	CERT_EXTENSION *pExt;
	BOOL fDelta;

	hr = cuLoadCRL(pwszfn, &pCRLContext);
	if (S_OK != hr)
	{
	    cuPrintError(IDS_FORMAT_LOADCERTORCRL, hr);
#if 1
	    WCHAR *pwszURL = NULL;
	    HRESULT hr2 = myInternetUncanonicalizeURL(pwszfn, &pwszURL);
	    _PrintIfError(hr2, "myInternetUncanonicalizeURL");
	    if (NULL != pwszURL)
	    {
		LocalFree(pwszURL);
	    }
#endif
	    goto error;
	}
	pExt = CertFindExtension(
			szOID_DELTA_CRL_INDICATOR,
			pCRLContext->pCrlInfo->cExtension,
			pCRLContext->pCrlInfo->rgExtension);
	fDelta = NULL != pExt;

	if (NULL != pwszTypeOrDSCDPContainer)
	{
	    hr = dsPublishCRLFromParms(
				pCRLContext,
				fDelta,
				pwszTypeOrDSCDPContainer,
				pwszDSCN);
	    _JumpIfError(hr, error, "dsPublishCRLFromParms");
	}
	else
	{
	    hr = dsPublishCRLFromContext(pCRLContext, fDelta);
	    _JumpIfError(hr, error, "dsPublishCRLFromContext");
	}
    }

error:
    cuUnloadCRL(&pCRLContext);
    cuUnloadCert(&pCertContext);
    return(hr);
}


HRESULT
dsDumpOIDDisplayNames(
    IN LDAP *pld,
    IN WCHAR const *pwszOIDDN,
    IN WCHAR const *pwszObjId,
    IN DWORD dwLanguageId,
    IN OUT DWORD *pdwType,
    OUT BOOL *pfObjectExists,
    OUT BOOL *pfLangIdExists,
    OPTIONAL OUT WCHAR ***pppwszLdapVal)
{
    HRESULT hr;
    LDAP_TIMEVAL timeval;
    LDAPMessage *pmsg = NULL;
    LDAPMessage *pres;
    DWORD cres;
    WCHAR **ppwszLdapVal = NULL;
    
    *pfObjectExists = FALSE;
    *pfLangIdExists = FALSE;
    if (NULL != pppwszLdapVal)
    {
	*pppwszLdapVal = NULL;
    }
    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;
    hr = ldap_search_st(
		pld,				// ld
		const_cast<WCHAR *>(pwszOIDDN),	// base
		LDAP_SCOPE_BASE,
		NULL,				// filter
		NULL,				// attrs
		FALSE,				// attrsonly
		&timeval,			// timeout
		&pmsg);				// res
    if (S_OK != hr)
    {
	hr = myHLdapError2(pld, hr, LDAP_NO_SUCH_OBJECT, NULL);
	_PrintErrorStr2(
		hr,
		"ldap_search_st",
		pwszOIDDN,
		HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND));
	if (HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND) != hr)
	{
	    goto error;
	}
    }
    else
    {
	cres = ldap_count_entries(pld, pmsg);
	if (0 != cres)
	{
	    for (pres = ldap_first_entry(pld, pmsg); 
		 NULL != pres && NULL == ppwszLdapVal; 
		 pres = ldap_next_entry(pld, pres))
	    {
		DWORD i;
		
		ppwszLdapVal = ldap_get_values(pld, pres, OID_PROP_OID);
		if (NULL != ppwszLdapVal)
		{
		    if (NULL != ppwszLdapVal[0] &&
			0 == lstrcmp(pwszObjId, ppwszLdapVal[0]))
		    {
			*pfObjectExists = TRUE;
		    }
		    ldap_value_free(ppwszLdapVal);
		    ppwszLdapVal = NULL;
		}
		if (*pfObjectExists)
		{
		    ppwszLdapVal = ldap_get_values(pld, pres, OID_PROP_TYPE);
		    if (NULL != ppwszLdapVal)
		    {
			if (NULL != ppwszLdapVal[0])
			{
			    DWORD dw = _wtoi(ppwszLdapVal[0]);

			    if (*pdwType != dw)
			    {
				if (MAXDWORD != *pdwType)
				{
				    wprintf(myLoadResourceString(IDS_TYPE_MISMATCH)); // "Type mismatch"
				    wprintf(wszNewLine);
				    hr = HRESULT_FROM_WIN32(RPC_S_ENTRY_ALREADY_EXISTS);
				    _JumpError(hr, error, "*pdwType mismatch");
				}
				*pdwType = dw;
			    }
			}
			ldap_value_free(ppwszLdapVal);
			ppwszLdapVal = NULL;
		    }

		    i = 0;
		    ppwszLdapVal = ldap_get_values(
					    pld,
					    pres,
					    OID_PROP_LOCALIZED_NAME);
		    if (NULL != ppwszLdapVal)
		    {
			for ( ; NULL != ppwszLdapVal[i]; i++)
			{
			    wprintf(L"  %u: %ws\n", i, ppwszLdapVal[i]);
			    if (!*pfLangIdExists)
			    {
				hr = myLdapOIDIsMatchingLangId(
						ppwszLdapVal[i],
						dwLanguageId,
						pfLangIdExists);
				_PrintIfError(hr, "myLdapOIDIsMatchingLangId");
			    }
			}
		    }
		    if (0 == i)
		    {
			wprintf(myLoadResourceString(IDS_NO_DISPLAY_NAMES)); // "No display names"
			wprintf(wszNewLine);
		    }
		    break;
		}
	    }
	}
    }
    if (NULL != pppwszLdapVal)
    {
	*pppwszLdapVal = ppwszLdapVal;
	ppwszLdapVal = NULL;
    }
    hr = S_OK;

error:
    if (NULL != ppwszLdapVal)
    {
	ldap_value_free(ppwszLdapVal);
    }
    if (NULL != pmsg)
    {
	ldap_msgfree(pmsg);
    }
    return(hr);
}


// Set OID_PROP_LOCALIZED_NAME on the appropriate OID object under g_wszCNOID.

HRESULT
verbOIDName(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszObjId,
    OPTIONAL IN WCHAR const *pwszDisplayName,
    OPTIONAL IN WCHAR const *pwszLanguageId,
    OPTIONAL IN WCHAR const *pwszType)
{
    HRESULT hr;
    DWORD dwLanguageId;
    DWORD dwType;
    WCHAR const *pwszName;
    LDAP *pld = NULL;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    WCHAR *pwszOIDCN = NULL;
    WCHAR *pwszOIDContainer = NULL;
    WCHAR *pwszOIDDN = NULL;
    WCHAR **ppwszLdapVal = NULL;
    BOOL fObjectExists = FALSE;
    BOOL fLangIdExists = FALSE;
    WCHAR *pwszError = NULL;
    
    if (NULL != pwszLanguageId)
    {
	hr = myGetLong(pwszLanguageId, (LONG *) &dwLanguageId);
	_JumpIfError(hr, error, "dwLanguageId must be a number");

	if (64 * 1024 <= dwLanguageId)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "dwLanguageId too large");
	}
    }
    else
    {
	dwLanguageId = GetUserDefaultUILanguage();
	if (0 == dwLanguageId)
	{
	    dwLanguageId = GetSystemDefaultUILanguage();
	}
	if (g_fVerbose)
	{
	    wprintf(
		L"%ws: %x (%u)\n",
		myLoadResourceString(IDS_SYSLANGID_COLON), // "System default Language Id:"
		dwLanguageId,
		dwLanguageId);
	}
    }

    if (NULL != pwszType)
    {
	hr = myGetLong(pwszType, (LONG *) &dwType);
	_JumpIfError(hr, error, "dwType must be a number");
    }
    else
    {
	dwType = MAXDWORD;
    }

    hr = myVerifyObjId(pwszObjId);
    if (S_OK != hr)
    {
	wprintf(myLoadResourceString(IDS_INVALID_OBJECTID)); // "Invalid ObjectId"
	wprintf(wszNewLine);
	_JumpError(hr, error, "myVerifyObjId");
    }
    pwszName = cuGetOIDName(pwszObjId);
    if (S_OK == hr || L'\0' != *pwszName)
    {
	if (L'\0' == *pwszName)
	{
	    pwszName = myLoadResourceString(IDS_UNKNOWN_OBJECTID); // "Unknown ObjectId"
	}
	wprintf(L"%ws -- %ws\n", pwszObjId, pwszName);
    }

    hr = myOIDHashOIDToString(pwszObjId, &pwszOIDCN);
    _JumpIfError(hr, error, "myOIDHashOIDToString");

    hr = myLdapOpen(
		g_pwszDC,
		NULL != pwszDisplayName? RLBF_REQUIRE_SECURE_LDAP : 0,
		&pld,
		&strDomainDN,
		&strConfigDN);
    if (S_OK != hr)
    {
	_PrintError2(hr, "myLdapOpen", HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN));
	if (NULL == pwszDisplayName)
	{
	    hr = S_OK;
	}
	goto error;
    }

    hr = BuildDN(g_wszCNOID, strConfigDN, FALSE, &pwszOIDContainer);
    _JumpIfError(hr, error, "BuildDN");

    hr = BuildDN(pwszOIDCN, pwszOIDContainer, TRUE, &pwszOIDDN);
    _JumpIfError(hr, error, "BuildDN");

    hr = dsDumpOIDDisplayNames(
			pld,
			pwszOIDDN,
			pwszObjId,
			dwLanguageId,
			&dwType,
			&fObjectExists,
			&fLangIdExists,
			&ppwszLdapVal);
    _JumpIfError(hr, error, "dsDumpOIDDisplayNames");

    if (NULL != pwszDisplayName)
    {
	DWORD dwDisposition;

	if (0 == LSTRCMPIS(pwszDisplayName, L"delete"))
	{
	    pwszDisplayName = NULL;	// delete existing entry
	}
	if (fObjectExists)
	{
	    if (fLangIdExists)
	    {
		if (!g_fForce && NULL != pwszDisplayName)
		{
		    hr = HRESULT_FROM_WIN32(RPC_S_ENTRY_ALREADY_EXISTS);
		    _JumpError(hr, error, "ldap_get_values");
		}
	    }
	    else
	    {
		if (NULL == pwszDisplayName)
		{
		    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		    _JumpError(hr, error, "not found");
		}
	    }
	}
	else
	{
	    if (!g_fForce || NULL == pwszDisplayName)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "ldap_first/next_entry");
	    }
	}
	//wprintf(L"%u: %u,%ws\n", dwType, dwLanguageId, pwszDisplayName);
	if (!fObjectExists)
	{
	    CSASSERT(NULL != pwszDisplayName);
	    if (MAXDWORD == dwType)
	    {
		dwType = CERT_OID_TYPE_TEMPLATE;
	    }
	    hr = myLdapCreateOIDObject(
			    pld,
			    pwszOIDDN,
			    dwType,
			    pwszObjId,
			    &dwDisposition,
			    &pwszError);
	    _JumpIfError(hr, error, "myLdapCreateOIDObject");

	    CSASSERT(NULL == pwszError);
	}
	hr = myLdapAddOrDeleteOIDDisplayNameToAttribute(
				    pld,
				    ppwszLdapVal,
				    dwLanguageId,
				    pwszDisplayName,
				    pwszOIDDN,
				    OID_PROP_LOCALIZED_NAME,
				    &dwDisposition,
				    &pwszError);
	_JumpIfError(hr, error, "myLdapAddOrDeleteOIDDisplayNameToAttribute");

	wprintf(wszNewLine);
	if (LDAP_SUCCESS == dwDisposition)
	{
	    wprintf(
		myLoadResourceString(
		    NULL == pwszDisplayName?
			IDS_FORMAT_DELETED_FROM_DS_STORE : // "%ws deleted from DS store."
			IDS_FORMAT_ADDED_TO_DS_STORE), // "%ws added to DS store."
		myLoadResourceString(IDS_LOCALIZEDNAME)); // "Localized name"
	    wprintf(wszNewLine);

	    hr = dsDumpOIDDisplayNames(
				pld,
				pwszOIDDN,
				pwszObjId,
				dwLanguageId,
				&dwType,
				&fObjectExists,
				&fLangIdExists,
				NULL);	// pppwszLdapVal
	    _JumpIfError(hr, error, "dsDumpOIDDisplayNames");
	}
	else 
	{
	    CSASSERT(LDAP_ATTRIBUTE_OR_VALUE_EXISTS == dwDisposition);
	    CSASSERT(NULL != pwszDisplayName);
	    wprintf(
		myLoadResourceString(IDS_FORMAT_ALREADY_IN_DS_STORE), // "%ws already in DS store."
		myLoadResourceString(IDS_LOCALIZEDNAME)); // "Localized name"
	    wprintf(wszNewLine);
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	wprintf(L"%ws\n", pwszError);
	LocalFree(pwszError);
    }
    if (NULL != ppwszLdapVal)
    {
	ldap_value_free(ppwszLdapVal);
    }
    if (NULL != pwszOIDCN)
    {
	LocalFree(pwszOIDCN);
    }
    if (NULL != pwszOIDDN)
    {
	LocalFree(pwszOIDDN);
    }
    if (NULL != pwszOIDContainer)
    {
	LocalFree(pwszOIDContainer);
    }
    myLdapClose(pld, strDomainDN, strConfigDN);
    return(hr);
}


HRESULT
verbPulse(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HANDLE hEventAE = NULL;
    LPCWSTR pcwszGlobal = L"Global\\";
    CAutoLPWSTR pwszEvent;

    pwszEvent = (LPWSTR) LocalAlloc(LMEM_FIXED,
        sizeof(WCHAR)*(1+wcslen(pcwszGlobal)+
        wcslen(MACHINE_AUTOENROLLMENT_TRIGGER_EVENT)));
    _JumpIfAllocFailed(pwszEvent, error);

    wcscpy(pwszEvent, pcwszGlobal);
    wcscat(pwszEvent, MACHINE_AUTOENROLLMENT_TRIGGER_EVENT);

    hEventAE = OpenEvent(
                    EVENT_MODIFY_STATE,
                    FALSE,
                    pwszEvent);
    if (NULL == hEventAE)
    {
        hr = myHLastError();
        _JumpError(hr, error, "OpenEvent");
    }

    if (!PulseEvent(hEventAE))
    {
        hr = myHLastError();
	_JumpError(hr, error, "PulseEvent");
    }
    hr = S_OK;

error:
    if (NULL != hEventAE)
    {
        CloseHandle(hEventAE);
    }
    return(hr);
}


// This function gets the group membership for a given machine...

HRESULT
cuGetGroupMembership(
    IN WCHAR const *pwszSamName)
{
    HRESULT hr;
    WCHAR *pwszDomain = NULL;
    WCHAR *pwszMachine = NULL;
    DOMAIN_CONTROLLER_INFO *pDCInfo = NULL;
    GROUP_USERS_INFO_0 *pgui0 = NULL;
    DWORD cGroup;
    DWORD cGroupTotal;
    DWORD i;
   
    hr = mySplitConfigString(pwszSamName, &pwszDomain, &pwszMachine);
    _JumpIfError(hr, error, "mySplitConfigString");

    if (NULL == pwszMachine || NULL == wcschr(pwszMachine, L'$'))
    {
        wprintf(myLoadResourceString(IDS_ERROR_CHECK_MACHINE_NAME));
        wprintf(wszNewLine);
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad machine name");
    }
    hr = DsGetDcName(
		NULL,
		pwszDomain,
		NULL,
		NULL,
		DS_RETURN_FLAT_NAME,
		&pDCInfo);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpError(hr, error, "DsGetDcName");
    }

    hr = NetUserGetGroups(
                pDCInfo->DomainControllerName,
                pwszMachine,
                0,			// level
                (BYTE **) &pgui0,
                MAX_PREFERRED_LENGTH,	// prefmaxlen
                &cGroup,
                &cGroupTotal);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpError(hr, error, "NetUserGetGroups");
    }

    wprintf(
	L"\n%ws\n",
	myLoadResourceString(IDS_GROUP_LIST_COLON)); // "Group Memberships:"
    for (i = 0; i < cGroup; i++)
    {
        wprintf(L"  %ws\n", pgui0[i].grui0_name);
    }
    hr = S_OK;

error:
    if (NULL != pwszDomain)
    {
        LocalFree(pwszDomain);
    }
    if (NULL != pwszMachine)
    {
        LocalFree(pwszMachine);
    }
    if (NULL != pgui0)
    {
        NetApiBufferFree(pgui0);
    }
    return(hr);
}


#define wszDSSPN		L"servicePrincipalName"
#define wszDSOBJECTCATEGORY	L"ObjectCategory"
#define wszDSSAMACCOUNTNAME	L"sAMAccountName"
#define wszDSUSERACCOUNTCONTROL	L"userAccountControl"

HRESULT
verbMachineInfo(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    LPWSTR pwszDC;
    DWORD dwGetDCFlags = DS_GC_SERVER_REQUIRED |  DS_RETURN_DNS_NAME;
    DOMAIN_CONTROLLER_INFO *pDCInfo = NULL;
    DS_NAME_RESULT *pNameResults = NULL;
    ULONG ldaperr;
    WCHAR *pwszError = NULL;
    char *pszFunc = NULL;

    LDAP *pld = NULL;
    LDAPMessage *SearchResult = NULL;
    LDAPMessage *Entry = NULL;
    WCHAR *pwszAttrName = NULL;
    WCHAR **prgVal = NULL;
    WCHAR **prgSPN = NULL;
    WCHAR **prgDNS = NULL;
    berval **Values = NULL;
    BerElement *bElement = NULL;
    BOOL fRediscover;
    HANDLE hDS = NULL;
    WCHAR *apwszAttrName[] = {
	CA_PROP_DNSNAME,
	wszDSSPN,
	wszDSOBJECTCATEGORY,
	wszDSSAMACCOUNTNAME,
	wszDSUSERACCOUNTCONTROL,
	NULL
    };

    WCHAR *ObjectClassFilter = L"objectClass=computer";

    // Get (and check) machine object in DS
    // Check:
    //   1) SPN
    //   2) Group Membership
    //   3) DNSHostName
    //   4) Object Class
    //   5) Object Category

    if (NULL == wcschr(pwszMachine, L'$'))
    {
        wprintf(myLoadResourceString(IDS_ERROR_NO_TRAILING), pwszMachine);
        wprintf(wszNewLine);

        hr = E_INVALIDARG;
        _JumpError(hr, error, "machine name missing $");
    }

    fRediscover = FALSE;
    while (TRUE)
    {
	if (fRediscover)
	{
	   dwGetDCFlags |= DS_FORCE_REDISCOVERY;
	}

	// in case we rediscovered...

	if (NULL != pDCInfo) 
	{
	    NetApiBufferFree(pDCInfo);
	    pDCInfo = NULL;
	}
	if (NULL != pNameResults)
	{    
	    DsFreeNameResult(pNameResults);
	    pNameResults = NULL;
	}
	if (NULL != pld)
	{
	    ldap_unbind(pld);
	    pld = NULL;
	}
	if (NULL != pwszError)
	{
	    LocalFree(pwszError);
	    pwszError = NULL;
	}

	pszFunc = "DsGetDCName";
	hr = DsGetDcName(NULL, NULL, NULL, NULL, dwGetDCFlags, &pDCInfo);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _JumpError(hr, error, pszFunc);
	}
	if (NULL == pDCInfo ||
	    0 == (pDCInfo->Flags & DS_GC_FLAG) ||
	    0 == (pDCInfo->Flags & DS_DNS_CONTROLLER_FLAG) ||
	    NULL == pDCInfo->DomainControllerName)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
	    _JumpErrorStr(hr, error, pszFunc, L"pDCInfo");
	}

	//  Modify DC name

	pwszDC = pDCInfo->DomainControllerName;
	while (*pwszDC == L'\\')
	{
	    pwszDC++;
	}

	pszFunc = "DsBind";
	hr = DsBind(pwszDC, NULL, &hDS);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _PrintError(hr, pszFunc);
	    if (!fRediscover)
	    {
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, pszFunc);
	}
	
	pszFunc = "DsCrackNames";
	hr = DsCrackNames(
		    hDS,
		    DS_NAME_NO_FLAGS,
		    DS_NT4_ACCOUNT_NAME,
		    DS_FQDN_1779_NAME,
		    1,                        // cNames
		    &pwszMachine,             // rpNames (IN)
		    &pNameResults);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _PrintError(hr, pszFunc);
	    if (!fRediscover)   // only do this once
	    {
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, pszFunc);
	}

	if (1 > pNameResults->cItems ||
	    DS_NAME_NO_ERROR != pNameResults->rItems[0].status)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
	    _JumpErrorStr(hr, error, pszFunc, L"pNameResults");
	}

	// ldap_bind to GC

	pszFunc = "ldap_init";
	pld = ldap_init(pwszDC, LDAP_GC_PORT);
	if (NULL == pld)
	{
	    hr = myHLdapLastError(NULL, &pwszError);
	    _PrintErrorStr(hr, pszFunc, pwszError);
	    if (!fRediscover)   // only do this once
	    {
		fRediscover = TRUE;
		continue;
	    }
	    _JumpErrorStr(hr, error, pszFunc, pwszError);
	}

	// do this because we're explicitly setting DC name; see bug# 347563

	pszFunc = "ldap_set_option";
	ldaperr = ldap_set_option(pld, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);
	if (LDAP_SUCCESS != ldaperr)
	{
	    hr = myHLdapError(pld, ldaperr, &pwszError);
	    _PrintErrorStr(hr, pszFunc, pwszError);
	    if (!fRediscover)   // only do this once
	    {
		fRediscover = TRUE;
		continue;
	    }
	    _JumpErrorStr(hr, error, pszFunc, pwszError);
	}
	
	pszFunc = "ldap_bind_s";
	ldaperr = ldap_bind_s(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
	if (LDAP_SUCCESS != ldaperr)
	{
	    hr = myHLdapError(pld, ldaperr, &pwszError);
	    _PrintErrorStr(hr, pszFunc, pwszError);
	    if (!fRediscover)   // only do this once
	    {
		fRediscover = TRUE;
		continue;
	    }
	    _JumpErrorStr(hr, error, pszFunc, pwszError);
	}
	break;
    }
    
    pszFunc = "ldap_searh_s";
    ldaperr = ldap_search_s(
                    pld,
                    pNameResults->rItems[0].pName,
                    LDAP_SCOPE_BASE,
                    ObjectClassFilter,
                    apwszAttrName, 
                    FALSE,
                    &SearchResult);
    if (LDAP_SUCCESS != ldaperr)
    {
	hr = myHLdapError(pld, ldaperr, &pwszError);
        _JumpErrorStr(hr, error, pszFunc, pwszError);
    }
    
    // should only be 1 entry...

    for (Entry = ldap_first_entry(pld, SearchResult); 
	 NULL != Entry;
	 Entry = ldap_next_entry(pld, Entry))
    {
        for (pwszAttrName = ldap_first_attribute(pld, Entry, &bElement);
	     NULL != pwszAttrName;
	     pwszAttrName = ldap_next_attribute(pld, Entry, bElement))
	{
	    DWORD i;
	    
	    if (NULL != pwszError)
	    {
		LocalFree(pwszError);
		pwszError = NULL;
	    }
            prgVal = ldap_get_values(pld, Entry, pwszAttrName);
            if (NULL == prgVal)
	    {
		pszFunc = "ldap_get_values";
		hr = myHLdapLastError(pld, &pwszError);
		_PrintErrorStr(hr, pszFunc, pwszError);

                wprintf(L"%hs(%ws): %ws\n", pszFunc, pwszAttrName, pwszError);
                continue;
            }
            
            // Display values & store away DNSHostName & SPN values for 
            // comparison.

            //DisplayLdapValues(pwszAttrName, prgVal);
	    wprintf(L"\n%ws:\n", pwszAttrName);
	    for (i = 0; NULL != prgVal[i]; i++)
	    {
		wprintf(L"  %ws\n", prgVal[i]);
	    }
            
            if (0 == LSTRCMPIS(pwszAttrName, CA_PROP_DNSNAME))
	    {
                prgDNS = prgVal;
            }
	    else if (0 == LSTRCMPIS(pwszAttrName, wszDSSPN))
	    {
                prgSPN = prgVal;
            }
	    else if (NULL != prgVal)
	    {
                ldap_value_free(prgVal);
                prgVal = NULL;
            }
        }
    }

    // There *will* be problems w/SPNs.
    // This should help determine what problems there are.

    if (NULL == prgDNS)
    {
        wprintf(
	    myLoadResourceString(IDS_FORMAT_MISSING_MACHINE_ATTRIBUTE), // "Machine object missing %ws attribute."
            CA_PROP_DNSNAME);
	wprintf(wszNewLine);
    }

    if (NULL == prgSPN)
    {
        wprintf(
	    myLoadResourceString(IDS_FORMAT_MISSING_MACHINE_ATTRIBUTE), // "Machine object missing %ws attribute."
	    wszDSSPN);
	wprintf(wszNewLine);
    }

    // Now let's get the group membership for this machine

    hr = cuGetGroupMembership(pwszMachine);
    _PrintIfError(hr, "cuGetGroupMembership");
    hr = S_OK;

error:
    if (NULL != prgDNS)
    {
        ldap_value_free(prgDNS);
    }
    if (NULL != prgSPN)
    {
        ldap_value_free(prgSPN);
    }
    if (NULL != SearchResult)
    {
        ldap_msgfree(SearchResult);
    }
    if (NULL != pDCInfo) 
    {
        NetApiBufferFree(pDCInfo);
    }
    if (NULL != hDS)
    {
        DsUnBind(&hDS);
    }
    if (NULL != pNameResults)
    {    
        DsFreeNameResult(pNameResults);
    }
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    if (NULL != pwszError)
    {
	if (NULL != pszFunc)
	{
	    wprintf(L"%hs: ", pszFunc);
	}
	wprintf(L"%ws\n", pwszError);
	LocalFree(pwszError);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\dbcore.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dbcore.h
//
// Contents:    Cert Server Core interfaces
//
//---------------------------------------------------------------------------

#ifndef __DBCORE_H__
#define __DBCORE_H__


//+--------------------------------------------------------------------------
// Name properties:

extern WCHAR const g_wszPropDistinguishedName[];
extern WCHAR const g_wszPropRawName[];
extern WCHAR const g_wszPropNameType[];

extern WCHAR const g_wszPropCountry[];
extern WCHAR const g_wszPropOrganization[];
extern WCHAR const g_wszPropOrgUnit[];
extern WCHAR const g_wszPropCommonName[];
extern WCHAR const g_wszPropLocality[];
extern WCHAR const g_wszPropState[];
extern WCHAR const g_wszPropTitle[];
extern WCHAR const g_wszPropGivenName[];
extern WCHAR const g_wszPropInitials[];
extern WCHAR const g_wszPropSurName[];
extern WCHAR const g_wszPropDomainComponent[];
extern WCHAR const g_wszPropEMail[];
extern WCHAR const g_wszPropStreetAddress[];


//+--------------------------------------------------------------------------
// Subject Name properties:

extern WCHAR const g_wszPropSubjectDot[];
extern WCHAR const g_wszPropSubjectDistinguishedName[];
extern WCHAR const g_wszPropSubjectRawName[];
extern WCHAR const g_wszPropSubjectNameType[];
extern WCHAR const g_wszPropSubjectCountry[];
extern WCHAR const g_wszPropSubjectOrganization[];
extern WCHAR const g_wszPropSubjectOrgUnit[];
extern WCHAR const g_wszPropSubjectCommonName[];
extern WCHAR const g_wszPropSubjectLocality[];
extern WCHAR const g_wszPropSubjectState[];
extern WCHAR const g_wszPropSubjectTitle[];
extern WCHAR const g_wszPropSubjectGivenName[];
extern WCHAR const g_wszPropSubjectInitials[];
extern WCHAR const g_wszPropSubjectSurName[];
extern WCHAR const g_wszPropSubjectDomainComponent[];
extern WCHAR const g_wszPropSubjectEMail[];
//extern WCHAR const g_wszPropSubjectStreetAddress[];


//+--------------------------------------------------------------------------
// Request properties:

extern WCHAR const g_wszPropRequestRequestID[];
extern WCHAR const g_wszPropRequestRawRequest[];
extern WCHAR const g_wszPropRequestAttributes[];
extern WCHAR const g_wszPropRequestType[];
extern WCHAR const g_wszPropRequestFlags[];
extern WCHAR const g_wszPropRequestStatus[];
extern WCHAR const g_wszPropRequestStatusCode[];
extern WCHAR const g_wszPropRequestDisposition[];
extern WCHAR const g_wszPropRequestDispositionMessage[];
extern WCHAR const g_wszPropRequestSubmittedWhen[];
extern WCHAR const g_wszPropRequestResolvedWhen[];
extern WCHAR const g_wszPropRequestRevokedWhen[];
extern WCHAR const g_wszPropRequestRevokedEffectiveWhen[];
extern WCHAR const g_wszPropRequestRevokedReason[];
extern WCHAR const g_wszPropRequestSubjectNameID[];
extern WCHAR const g_wszPropRequesterName[];
extern WCHAR const g_wszPropRequesterAddress[];


//+--------------------------------------------------------------------------
// Certificate properties:

extern WCHAR const g_wszPropCertificateRequestID[];
extern WCHAR const g_wszPropRawCertificate[];
extern WCHAR const g_wszPropCertificateType[];
extern WCHAR const g_wszPropCertificateSerialNumber[];
extern WCHAR const g_wszPropCertificateIssuerNameID[];
extern WCHAR const g_wszPropCertificateSubjectNameID[];
extern WCHAR const g_wszPropCertificateNotBeforeDate[];
extern WCHAR const g_wszPropCertificateNotAfterDate[];
extern WCHAR const g_wszPropCertificateRawPublicKey[];
extern WCHAR const g_wszPropCertificatePublicKeyAlgorithm[];
extern WCHAR const g_wszPropCertificateRawPublicKeyAlgorithmParameters[];

#endif // __DBCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\odbc.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        odbc.h
//
// Contents:    Cert Server DB includes
//
// History:     06-JAN-97       larrys created
//
//---------------------------------------------------------------------------

#include <sql.h>
#include <sqlext.h>
#include <sqltypes.h>

typedef DWORD     REQID;
typedef DWORD     NAMEID;
typedef DWORD     STATUS;

typedef struct _DBTABLE_RED
{
    WCHAR const *pwszPropName;
    WCHAR const *pwszPropNameObjId;
    DWORD        dwFlags;
    DWORD        dwcbMax;	// maximum allowed strlen/wcslen(value string)
    DWORD        dwTable;
    WCHAR const *pwszFieldName;
    SWORD        wCType;
    SWORD        wSqlType;
} DBTABLE_RED, *PDBTABLE_RED;

/////

typedef struct _DUPTABLE
{
    CHAR const  *pszFieldName;
    BOOL         fDup;
    SWORD        wCType;
    SWORD        wSqlType;
    WCHAR const *pwszPropName;
} DUPTABLE;

#define TABLE_SUBJECT_NAME      105
#define TABLE_ISSUER_NAME       106
#define TABLE_REQUESTSUBJECT_NAME 107

#define ADD_TO_ITEMSCLEAN       1
#define ADD_TO_ITEMSDIRTY       2

RETCODE MapPropID(
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    OUT DBTABLE_RED *pdtout);

STATUS DBStatus(RETCODE rc);

void DBCheck(
#if DBG_CERTSRV
    DWORD Line,
#endif
    DWORD hr,
    void * extra);

STATUS odbcInitRequestQueue(
    UCHAR   *dsn,
    UCHAR   *user,
    UCHAR   *pwd);
void odbcFinishRequestQueue();


RETCODE odbcSPExtensionOrAttributeDB(DWORD id, DBTABLE_RED *pdtOut, UCHAR *pquery,
                                     DWORD cbInProp, BYTE const *pbInProp);

RETCODE odbcGPDataFromDB(REQID ReqId, DWORD dwTable, SWORD wCType,
                         BYTE *pbData, DWORD cbData, UCHAR *szQuery,
                         NAMEID *pnameid, SQLLEN  *poutlen);

STATUS DBStatus(RETCODE rc);

VOID
DBCheck(
    RETCODE rc
    DBGPARM(char const *pszFile)
    DBGPARM(DWORD Line),
    HSTMT hstmt);

#define ITEMINSERT(l,i) (i).itemPrev = &(l),                        \
                        (i).itemNext = (l).itemNext,                \
                        (l).itemNext = (i).itemNext->itemPrev = &(i)
#define ITEMREMOVE(i)   (i).itemNext->itemPrev = (i).itemPrev,      \
                        (i).itemPrev->itemNext = (i).itemNext

#define CDNTRTABLE (sizeof(db_dntr) / sizeof(db_dntr[0]))


#define DBCHECKLINE(rc, hstmt) \
    DBCheck((rc) DBGPARM(__myFILE__) DBGPARM(__LINE__), (hstmt))

HRESULT odbcDBEnumSetup(REQID ReqId, DWORD fExtOrAttr, HANDLE *phEnum);
HRESULT odbcDBEnum(HANDLE hEnum, DWORD *pcb, WCHAR *pb);
HRESULT odbcDBEnumClose(HANDLE hEnum);
//DWORD odbcDBGetReqIdFromSerialNumber(char *pszSerialNumber, DWORD *ReqId);






extern DBTABLE_RED const db_adtRequests[];
extern DBTABLE_RED const db_adtCertificates[];
extern DBTABLE_RED const db_adtNames[];
extern DBTABLE_RED const db_dtExtensionFlags;
extern DBTABLE_RED const db_dtExtensionValue;
extern DBTABLE_RED const db_attrib;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\misc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       misc.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <setupapi.h>
#include <ocmanage.h>
#include "certsrvd.h"
#include "cscsp.h"
#include "initcert.h"
#include "csprop.h"

#define __dwFILE__	__dwFILE_CERTUTIL_MISC_CPP__


DWORD
cuFileSize(
    IN WCHAR const *pwszfn)
{
    WIN32_FILE_ATTRIBUTE_DATA fad;

    if (!GetFileAttributesEx(pwszfn, GetFileExInfoStandard, &fad))
    {
	fad.nFileSizeLow = 0;
    }
    return(fad.nFileSizeLow);
}


HRESULT
verbHexTranslate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnIn,
    IN WCHAR const *pwszfnOut,
    IN OPTIONAL IN WCHAR const *pwszType,
    IN WCHAR const *pwszArg4)
{
    BYTE *pbIn = NULL;
    DWORD cbIn;
    HRESULT hr;
    BOOL fEncode = g_wszEncodeHex == pwszOption;
    DWORD dwEncodeFlags;

    // Read in and decode the file.

    hr = DecodeFileW(
		pwszfnIn,
		&pbIn,
		&cbIn,
		fEncode? CRYPT_STRING_BINARY : CRYPT_STRING_HEX_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }
    CSASSERT(NULL != pbIn && 0 != cbIn);

    wprintf(
	myLoadResourceString(IDS_FORMAT_INPUT_LENGTH), // "Input Length = %d"
	cuFileSize(pwszfnIn));
    wprintf(wszNewLine);

    // Write encoded certificate to file

    dwEncodeFlags = CRYPT_STRING_BINARY;
    if (fEncode)
    {
	dwEncodeFlags = CRYPT_STRING_HEXASCIIADDR;
	if (NULL != pwszType)
	{
	    BOOL fValid;
	    
	    dwEncodeFlags = myWtoI(pwszType, &fValid);
	    if (!fValid)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad encoding type");
	    }
	}
	dwEncodeFlags |= g_CryptEncodeFlags;
    }

    hr = EncodeToFileW(pwszfnOut, pbIn, cbIn, dwEncodeFlags | g_EncodeFlags);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_ENCODETOFILE, hr);
	goto error;
    }
    wprintf(
	myLoadResourceString(IDS_FORMAT_OUTPUT_LENGTH), // "Output Length = %d"
	cuFileSize(pwszfnOut));
    wprintf(wszNewLine);

error:
    if (NULL != pbIn)
    {
	LocalFree(pbIn);
    }
    return(hr);
}


// If a CRL, return CRYPT_STRING_BASE64X509CRLHEADER.
// If a cert or an empty PKCS7 with at least one cert, return
// CRYPT_STRING_BASE64HEADER.
// Otherwise, return CRYPT_STRING_BASE64REQUESTHEADER

HRESULT
GetBase64EncodeFlags(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT DWORD *pdwEncodeFlags)
{
    HRESULT hr;

    *pdwEncodeFlags = CRYPT_STRING_BASE64HEADER;

    // Try as a Cert:

    {
	CERT_CONTEXT const *pCertContext;

	pCertContext = CertCreateCertificateContext(
					X509_ASN_ENCODING,
					pbIn,
					cbIn);
	if (NULL != pCertContext)
	{
	    CertFreeCertificateContext(pCertContext);
	    goto error;
	}
    }

    // Try as a CRL:

    {
	CRL_CONTEXT const *pCRLContext;

	pCRLContext = CertCreateCRLContext(X509_ASN_ENCODING, pbIn, cbIn);
	if (NULL != pCRLContext)
	{
	    CertFreeCRLContext(pCRLContext);
	    *pdwEncodeFlags = CRYPT_STRING_BASE64X509CRLHEADER;
	    goto error;
	}
    }

    // Try as a PKCS10, KeyGen or CMC request

    {
	BYTE *pbDecoded;
	DWORD cbDecoded;
	DWORD i;
	char const *rgpszStructType[] = {
	    X509_CERT_REQUEST_TO_BE_SIGNED,
	    X509_KEYGEN_REQUEST_TO_BE_SIGNED,
	    CMC_DATA,
	};

	for (i = 0; i < ARRAYSIZE(rgpszStructType); i++)
	{
	    if (myDecodeObject(
			X509_ASN_ENCODING,
			rgpszStructType[i],
			pbIn,
			cbIn,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbDecoded,
			&cbDecoded))
	    {
		LocalFree(pbDecoded);
		*pdwEncodeFlags = CRYPT_STRING_BASE64REQUESTHEADER;
		goto error;
	    }
	}
    }

    // Recurse on the PKCS7 to examine the innermost content

    {
	BYTE *pbContents;
	DWORD cbContents;
	DWORD dwMsgType;
	DWORD cRecipient;

	hr = myDecodePKCS7(
			pbIn,
			cbIn,
			&pbContents,
			&cbContents,
			&dwMsgType,
			NULL,
			NULL,
			&cRecipient,
			NULL,
			NULL);
	if (S_OK == hr)
	{
	    if (CMSG_SIGNED == dwMsgType &&
		NULL != pbContents &&
		0 != cbContents &&
		0 == cRecipient)
	    {
		DWORD dwEncodeFlags;

		hr = GetBase64EncodeFlags(
				pbContents,
				cbContents,
				pdwEncodeFlags);
		_JumpIfError(hr, error, "GetBase64EncodeFlags");

	    }
	}
    }

error:
    hr = S_OK;
    return(hr);
}


HRESULT
verbBase64Translate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnIn,
    IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    BYTE *pbIn = NULL;
    DWORD cbIn;
    HRESULT hr;
    BOOL fEncode = g_wszEncode == pwszOption;
    DWORD dwEncodeFlags;

    // Read in and decode the file.

    hr = DecodeFileW(
		pwszfnIn,
		&pbIn,
		&cbIn,
		fEncode? CRYPT_STRING_BINARY : CRYPT_STRING_BASE64_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }
    CSASSERT(NULL != pbIn && 0 != cbIn);

    dwEncodeFlags = CRYPT_STRING_BINARY;
    if (fEncode)
    {
	hr = GetBase64EncodeFlags(pbIn, cbIn, &dwEncodeFlags);
        _JumpIfError(hr, error, "GetBase64EncodeFlags");

	dwEncodeFlags |= g_CryptEncodeFlags;
    }

    wprintf(
	myLoadResourceString(IDS_FORMAT_INPUT_LENGTH), // "Input Length = %d"
	cuFileSize(pwszfnIn));
    wprintf(wszNewLine);

    // Write encoded certificate to file

    hr = EncodeToFileW(
		pwszfnOut,
		pbIn,
		cbIn,
		dwEncodeFlags | g_EncodeFlags);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_ENCODETOFILE, hr);
	goto error;
    }
    wprintf(
	myLoadResourceString(IDS_FORMAT_OUTPUT_LENGTH), // "Output Length = %d"
	cuFileSize(pwszfnOut));
    wprintf(wszNewLine);

error:
    if (NULL != pbIn)
    {
	LocalFree(pbIn);
    }
    return(hr);
}


HRESULT
TestCSP(
    IN WCHAR const *pwszProvName,
    IN DWORD const dwProvType,
    OPTIONAL WCHAR const *pwszKeyContainer)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    DWORD dwFlags = 0;

    if (NULL == pwszKeyContainer)
    {
	dwFlags |= CRYPT_VERIFYCONTEXT;
    }
    if (g_fCryptSilent)
    {
        dwFlags |= CRYPT_SILENT;
    }

    wprintf(
	L"CryptAcquireContext(%ws, %ws, %d, 0x%x)\n",
	NULL == pwszKeyContainer? L"Verify" : pwszKeyContainer,
	pwszProvName,
	dwProvType,
	dwFlags);

    if (!myCertSrvCryptAcquireContext(
                &hProv,
                pwszKeyContainer,
                pwszProvName,
                dwProvType,
                dwFlags,
                !g_fUserRegistry))	// fMachineKeyset
    {
        hr = myHLastError();

	cuPrintError(0, hr);
        _JumpErrorStr(hr, error, "myCertSrvCryptAcquireContext", pwszProvName);
    }
    wprintf(L"%ws\n", myLoadResourceString(IDS_PASS)); // "Pass"
    hr = S_OK;

error:
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return hr;
}


HRESULT
EnumAndTestCSP(
    IN BOOL const fTest)
{
    HRESULT hr;
    DWORD i;
    DWORD dwProvType;
    WCHAR *pwszProvName = NULL;
    BOOL fFirst = TRUE;
    
    for (i = 0; ; i++)
    {
	hr = myEnumProviders(i, NULL, 0, &dwProvType, &pwszProvName);
	if (S_OK != hr)
	{
	    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr ||
		NTE_FAIL == hr)
	    {
		// no more providers under type, terminate loop
		break;
	    }

	    // invalid csp entry, skip it

	    wprintf(myLoadResourceString(IDS_FORMAT_SKIP_CSP_ENUM), i);
	    wprintf(wszNewLine);
	}
	else
	{
	    if (!fFirst)
	    {
		wprintf(wszNewLine);
	    }
	    fFirst = FALSE;
	    wprintf(myLoadResourceString(IDS_PROVIDER_NAME_COLON));
	    wprintf(L" %ws\n", pwszProvName);
	    wprintf(myLoadResourceString(IDS_PROVIDER_TYPE_COLON));
	    wprintf(L" %d\n", dwProvType);
	    if (fTest)
	    {
		hr = TestCSP(pwszProvName, dwProvType, NULL);
	    }
	    LocalFree(pwszProvName);
	    pwszProvName = NULL;
	}
    }
    hr = S_OK;

//error:
    if (NULL != pwszProvName)
    {
	LocalFree(pwszProvName);
    }
    return(hr);
}


HRESULT
verbCSPList(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    return EnumAndTestCSP(FALSE);
}


HRESULT
verbCSPTest(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszKeyContainer,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD dwProvType;

    if (NULL != g_pwszCSP)
    {
        // get prov type
        hr = csiGetProviderTypeFromProviderName(g_pwszCSP, &dwProvType);
        _JumpIfError(hr, error, "GetProviderTypeFromProviderName");

        hr = TestCSP(g_pwszCSP, dwProvType, pwszKeyContainer);
	_JumpIfError(hr, error, "TestCSP");
    }
    else
    {
        hr = EnumAndTestCSP(TRUE);
	_JumpIfError(hr, error, "EnumAndTestCSP");
    }

error:
    return(hr);
}


UINT enumCATypeRscMap[] =
{
    IDS_ENTERPRISE_ROOT,    // ENUM_ENTERPRISE_ROOT = 0
    IDS_ENTERPRISE_SUB,     // ENUM_ENTERPRISE_SUBCA = 1
    IDS_CATYPE_UNKNOWN,     // ENUM_UNUSED2 = 2
    IDS_STANDALONE_ROOT,    // ENUM_STANDALONE_ROOTCA = 3
    IDS_STANDALONE_SUB,     // ENUM_STANDALONE_SUBCA = 4
    // ENUM_UNKNOWN_CA = 5
};


typedef struct _CAINFOTABLE
{
    WCHAR const *pwszCmdLineName;
    LONG         lPropId;
    LONG         lPropType;
    UINT         ids;
    DWORD        dwGetCert;
    DWORD        Flags;
    WCHAR const *pwszRegName;
} CAINFOTABLE;

#define CAITF_FLAGSARG		0x00000001
#define CAITF_INDEXARGMAXDWORD	0x00000002	// default index is MAXDWORD
#define CAITF_INDEXARGZERO	0x00000004	// default index is 0
#define CAITF_INDEXARGREQUIRED	0x00000008	// index required
#define CAITF_SIGCERTCOUNT	0x00000010	// cCASigCert elements
#define CAITF_XCHGCERTCOUNT	0x00000020	// cCAXchgCert elements
#define CAITF_KRACERTCOUNT	0x00000040	// cCAXchgCert elements
#define CAITF_EXITCOUNT		0x00000080	// exit mod count elements
#define CAITF_ASN		0x00000100	// contains dumpable ASN object
#define CAITF_DEFAULT		0x00000200	// default (unnamed) set
#define CAITF_SKIPINVALIDARG	0x00000400	// skip if multiple & E_INVALIDARG
#define CAITF_SKIP		0x00000800	// skip when enumerating all
#define CAITF_OPTIONAL		0x00001000	// not always available
#define CAITF_CRLSTATE		0x00002000	// depends on CRL state
#define CAITF_FORWARDCROSSCERTSTATE  0x00004000	// depends on fwd cross state
#define CAITF_BACKWARDCROSSCERTSTATE 0x00008000	// depends on rev cross state

#define CAITF_INDEXARG (CAITF_INDEXARGMAXDWORD | \
			CAITF_INDEXARGZERO | \
			CAITF_INDEXARGREQUIRED)

WCHAR const g_wszCAInfoCRL[] = L"crl";
WCHAR const g_wszCAInfoCert[] = L"cert";
WCHAR const g_wszCAInfoCertChain[] = L"certchain";
WCHAR const g_wszCAInfoName[] = L"name";
WCHAR const g_wszCAInfoSanitizedName[] = L"sanitizedname";
WCHAR const g_wszCAInfoDSName[] = L"dsname";

#define GETCERT_UNSUPPORTED	MAXDWORD // not supported by old ICertRequest

CAINFOTABLE g_aCAInfoTable[] = 
{
    {
	L"file",
	CR_PROP_FILEVERSION,
	PROPTYPE_STRING,
	IDS_PROP_FILEVERSION,
	GETCERT_FILEVERSION,
	0,
	NULL,
    },
    {
	L"product",
	CR_PROP_PRODUCTVERSION,
	PROPTYPE_STRING,
	IDS_PROP_PRODUCTVERSION,
	GETCERT_PRODUCTVERSION,
	0,
	NULL,
    },
    {
	L"exitcount",
	CR_PROP_EXITCOUNT,
	PROPTYPE_LONG,
	IDS_PROP_EXITCOUNT,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT,
	NULL,
    },
    {
	L"exit",
	CR_PROP_EXITDESCRIPTION,
	PROPTYPE_STRING,
	IDS_PROP_EXITDESCRIPTION,
	GETCERT_EXITVERSIONBYINDEX,
	CAITF_INDEXARGZERO | CAITF_EXITCOUNT,
	NULL,
    },
    {
	L"policy",
	CR_PROP_POLICYDESCRIPTION,
	PROPTYPE_STRING,
	IDS_PROP_POLICYDESCRIPTION,
	GETCERT_POLICYVERSION,
	0,
	NULL,
    },
    {
	g_wszCAInfoName,
	CR_PROP_CANAME,
	PROPTYPE_STRING,
	IDS_PROP_CANAME,
	GETCERT_CANAME,
	CAITF_DEFAULT,
	NULL,
    },
    {
	g_wszCAInfoSanitizedName,
	CR_PROP_SANITIZEDCANAME,
	PROPTYPE_STRING,
	IDS_PROP_SANITIZEDCANAME,
	GETCERT_SANITIZEDCANAME,
	0,
	NULL,
    },
    {
	g_wszCAInfoDSName,
	CR_PROP_SANITIZEDCASHORTNAME,
	PROPTYPE_STRING,
	IDS_PROP_SANITIZEDCASHORTNAME,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT | CAITF_OPTIONAL,
	NULL,
    },
    {
	L"sharedfolder",
	CR_PROP_SHAREDFOLDER,
	PROPTYPE_STRING,
	IDS_PROP_SHAREDFOLDER,
	GETCERT_SHAREDFOLDER,
	CAITF_OPTIONAL,
	NULL,
    },
    {
	L"error1",
	CR_PROP_NONE,		// separate method call in ICertRequest2
	PROPTYPE_STRING,
	IDS_PROP_ERROR1,
	GETCERT_ERRORTEXT1,
	CAITF_FLAGSARG | CAITF_SKIP,
	NULL,
    },
    {
	L"error2",
	CR_PROP_NONE,		// separate method call in ICertRequest2
	PROPTYPE_STRING,
	IDS_PROP_ERROR2,
	GETCERT_ERRORTEXT2,
	CAITF_FLAGSARG | CAITF_SKIP,
	NULL,
    },
    {
	L"type",
	CR_PROP_CATYPE,
	PROPTYPE_LONG,
	IDS_PROP_CATYPE,
	GETCERT_CATYPE,
	CAITF_DEFAULT,
	wszPROPCATYPE,
    },
    {
	L"info",
	CR_PROP_NONE,		// not supported by ICertRequest2
	PROPTYPE_BINARY,
	IDS_PROP_CAINFO,
	GETCERT_CAINFO,
	0,
	NULL,
    },
    {
	L"parent",
	CR_PROP_PARENTCA,
	PROPTYPE_STRING,
	IDS_PROP_PARENTCA,
	GETCERT_PARENTCONFIG,
	CAITF_OPTIONAL,
	NULL,
    },
    {
	L"certcount",
	CR_PROP_CASIGCERTCOUNT,
	PROPTYPE_LONG,
	IDS_PROP_CASIGCERTCOUNT,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT,
	NULL,
    },
    {
	L"xchgcount",
	CR_PROP_CAXCHGCERTCOUNT,
	PROPTYPE_LONG,
	IDS_PROP_CAXCHGCERTCOUNT,
	GETCERT_UNSUPPORTED,
	0,
	NULL,
    },
    {
	L"kracount",
	CR_PROP_KRACERTCOUNT,
	PROPTYPE_LONG,
	IDS_PROP_KRACERTCOUNT,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT,
	NULL,
    },
    {
	L"kraused",
	CR_PROP_KRACERTUSEDCOUNT,
	PROPTYPE_LONG,
	IDS_PROP_KRACERTUSEDCOUNT,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT,
	NULL,
    },
    {
	L"propidmax",
	CR_PROP_CAPROPIDMAX,
	PROPTYPE_LONG,
	IDS_PROP_CAPROPIDMAX,
	GETCERT_UNSUPPORTED,
	0,
	NULL,
    },
// Cert and CRL state:
    {
	L"certstate",
	CR_PROP_CACERTSTATE,
	PROPTYPE_LONG,
	IDS_PROP_CACERTSTATE,
	GETCERT_CACERTSTATEBYINDEX,
	CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT | CAITF_DEFAULT,
	NULL,
    },
    {
	L"certversion",
	CR_PROP_CACERTVERSION,
	PROPTYPE_LONG,
	IDS_PROP_CACERTVERSION,
	GETCERT_UNSUPPORTED,
	CAITF_SKIPINVALIDARG | CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT | CAITF_DEFAULT,
	NULL,
    },
    {
	L"certstatuscode",
	CR_PROP_CACERTSTATUSCODE,
	PROPTYPE_LONG,
	IDS_PROP_CACERSTATUSCODE,
	GETCERT_UNSUPPORTED,
	CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT | CAITF_DEFAULT,
	NULL,
    },
    {
	L"crlstate",
	CR_PROP_CRLSTATE,
	PROPTYPE_LONG,
	IDS_PROP_CRLSTATE,
	GETCERT_CRLSTATEBYINDEX,
	CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT | CAITF_DEFAULT,
	NULL,
    },
    {
	L"krastate",
	CR_PROP_KRACERTSTATE,
	PROPTYPE_LONG,
	IDS_PROP_KRACERTSTATE,
	GETCERT_UNSUPPORTED,
	CAITF_INDEXARGZERO | CAITF_KRACERTCOUNT | CAITF_DEFAULT,
	NULL,
    },
    {
	L"crossstate+",
	CR_PROP_CAFORWARDCROSSCERTSTATE,
	PROPTYPE_LONG,
	IDS_PROP_CAFORWARDCROSSCERTSTATE,
	GETCERT_UNSUPPORTED,
	CAITF_SKIPINVALIDARG | CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT,
	NULL,
    },
    {
	L"crossstate-",
	CR_PROP_CABACKWARDCROSSCERTSTATE,
	PROPTYPE_LONG,
	IDS_PROP_CABACKWARDCROSSCERTSTATE,
	GETCERT_UNSUPPORTED,
	CAITF_SKIPINVALIDARG | CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT,
	NULL,
    },
// Signature certs:
    {
	g_wszCAInfoCert, // L"cert"
	CR_PROP_CASIGCERT,
	PROPTYPE_BINARY,
	IDS_PROP_CASIGCERT,
	GETCERT_CACERTBYINDEX,	// GETCERT_CASIGCERT handled by code hack
	CAITF_SKIPINVALIDARG | CAITF_INDEXARGMAXDWORD | CAITF_SIGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	g_wszCAInfoCertChain, // L"certchain"
	CR_PROP_CASIGCERTCHAIN,
	PROPTYPE_BINARY,
	IDS_PROP_CASIGCERTCHAIN,
	GETCERT_CACERTBYINDEX | GETCERT_CHAIN,	// GETCERT_CASIGCERT | GETCERT_CHAIN handled by code hack
	CAITF_SKIPINVALIDARG | CAITF_INDEXARGMAXDWORD | CAITF_SIGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	L"certcrlchain",
	CR_PROP_CASIGCERTCRLCHAIN,
	PROPTYPE_BINARY,
	IDS_PROP_CASIGCERTCRLCHAIN,
	GETCERT_CACERTBYINDEX | GETCERT_CHAIN | GETCERT_CRLS,
	CAITF_SKIPINVALIDARG | CAITF_INDEXARGMAXDWORD | CAITF_SIGCERTCOUNT | CAITF_ASN,
	NULL,
    },
// Exchange certs:
    {
	L"xchg",
	CR_PROP_CAXCHGCERT,
	PROPTYPE_BINARY,
	IDS_PROP_CAXCHGCERT,
	GETCERT_UNSUPPORTED,
	CAITF_INDEXARGMAXDWORD | CAITF_XCHGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	L"xchgchain",
	CR_PROP_CAXCHGCERTCHAIN,
	PROPTYPE_BINARY,
	IDS_PROP_CAXCHGCERTCHAIN,
	GETCERT_UNSUPPORTED,
	CAITF_INDEXARGMAXDWORD | CAITF_XCHGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	L"xchgcrlchain",
	CR_PROP_CAXCHGCERTCRLCHAIN,
	PROPTYPE_BINARY,
	IDS_PROP_CAXCHGCERTCRLCHAIN,
	GETCERT_UNSUPPORTED,
	CAITF_INDEXARGMAXDWORD | CAITF_XCHGCERTCOUNT | CAITF_ASN,
	NULL,
    },
// KRA certs:
    {
	L"kra",
	CR_PROP_KRACERT,
	PROPTYPE_BINARY,
	IDS_PROP_KRACERT,
	GETCERT_UNSUPPORTED,
	CAITF_INDEXARGMAXDWORD | CAITF_KRACERTCOUNT | CAITF_ASN,
	NULL,
    },
// Cross certs:
    {
	L"cross+",
	CR_PROP_CAFORWARDCROSSCERT,
	PROPTYPE_BINARY,
	IDS_PROP_CAFORWARDCROSSCERT,
	GETCERT_UNSUPPORTED,
	CAITF_FORWARDCROSSCERTSTATE | CAITF_SKIPINVALIDARG | CAITF_INDEXARGMAXDWORD | CAITF_SIGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	L"cross-",
	CR_PROP_CABACKWARDCROSSCERT,
	PROPTYPE_BINARY,
	IDS_PROP_CABACKWARDCROSSCERT,
	GETCERT_UNSUPPORTED,
	CAITF_BACKWARDCROSSCERTSTATE | CAITF_SKIPINVALIDARG | CAITF_INDEXARGMAXDWORD | CAITF_SIGCERTCOUNT | CAITF_ASN,
	NULL,
    },
// CRLs:
    {
	g_wszCAInfoCRL, // L"CRL"
	CR_PROP_BASECRL,
	PROPTYPE_BINARY,
	IDS_PROP_BASECRL,
	GETCERT_CRLBYINDEX,	// GETCERT_CURRENTCRL handled by code hack
	CAITF_CRLSTATE | CAITF_SKIPINVALIDARG | CAITF_INDEXARGMAXDWORD | CAITF_SIGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	L"deltacrl",
	CR_PROP_DELTACRL,
	PROPTYPE_BINARY,
	IDS_PROP_DELTACRL,
	GETCERT_UNSUPPORTED,
	CAITF_CRLSTATE | CAITF_SKIPINVALIDARG | CAITF_INDEXARGMAXDWORD | CAITF_SIGCERTCOUNT | CAITF_ASN,
	NULL,
    },
    {
	L"crlstatus",
	CR_PROP_BASECRLPUBLISHSTATUS,
	PROPTYPE_LONG,
	IDS_PROP_BASECRLPUBLISHSTATUS,
	GETCERT_UNSUPPORTED,
	CAITF_CRLSTATE | CAITF_SKIPINVALIDARG | CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT | CAITF_DEFAULT | CAITF_OPTIONAL,
	wszPROPCRLPUBLISHFLAGS,
    },
    {
	L"deltacrlstatus",
	CR_PROP_DELTACRLPUBLISHSTATUS,
	PROPTYPE_LONG,
	IDS_PROP_DELTACRLPUBLISHSTATUS,
	GETCERT_UNSUPPORTED,
	CAITF_CRLSTATE | CAITF_SKIPINVALIDARG | CAITF_INDEXARGZERO | CAITF_SIGCERTCOUNT | CAITF_DEFAULT | CAITF_OPTIONAL,
	wszPROPCRLPUBLISHFLAGS,
    },
    {
	L"dns",
	CR_PROP_DNSNAME,
	PROPTYPE_STRING,
	IDS_PROP_DNSNAME,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT | CAITF_OPTIONAL,
	NULL,
    },
    {
	L"role",
	CR_PROP_ROLESEPARATIONENABLED,
	PROPTYPE_LONG,
	IDS_PROP_ROLESEPARATIONENABLED,
	GETCERT_UNSUPPORTED,
	CAITF_OPTIONAL | CAITF_SKIP,
	NULL,
    },
    {
	L"ads",
	CR_PROP_ADVANCEDSERVER,
	PROPTYPE_LONG,
	IDS_PROP_ADVANCEDSERVER,
	GETCERT_UNSUPPORTED,
	CAITF_DEFAULT | CAITF_OPTIONAL,
	NULL,
    },
    {
	L"templates",
	CR_PROP_TEMPLATES,
	PROPTYPE_STRING,
	IDS_PROP_TEMPLATES,
	GETCERT_UNSUPPORTED,
	CAITF_SKIPINVALIDARG | CAITF_OPTIONAL,
	NULL,
    },
    {
	NULL,
    },
};


typedef HRESULT (FNPROP_INIT)(
    IN DWORD Flags,
    IN OUT DISPATCHINTERFACE *pdiProp);

typedef VOID (FNPROP_RELEASE)(
    IN OUT DISPATCHINTERFACE *pdiProp);

typedef HRESULT (FNPROP2_GETCAPROPERTY)(
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    IN LONG PropIndex,
    IN LONG PropType,
    IN LONG Flags,
    OUT VOID *pPropertyValue);

typedef HRESULT (FNPROP2_GETCAPROPERTYFLAGS)(
    IN DISPATCHINTERFACE *pdiProp,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT LONG *pPropFlags);

typedef HRESULT (FNPROP2_GETCAPROPERTYDISPLAYNAME)(
    IN DISPATCHINTERFACE *pdiProp,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT BSTR *pstrDisplayName);


FNPROP_INIT *g_pfnProp_Init;
FNPROP_RELEASE *g_pfnProp_Release;
FNPROP2_GETCAPROPERTY *g_pfnProp2_GetCAProperty;
FNPROP2_GETCAPROPERTYFLAGS *g_pfnProp2_GetCAPropertyFlags;
FNPROP2_GETCAPROPERTYDISPLAYNAME *g_pfnProp2_GetCAPropertyDisplayName;


VOID
InitPropFunctionPointers(VOID)
{
    if (g_fAdminInterface)
    {
	g_pfnProp_Init = Admin_Init;
	g_pfnProp_Release = Admin_Release;
	g_pfnProp2_GetCAProperty = Admin2_GetCAProperty;
	g_pfnProp2_GetCAPropertyFlags = Admin2_GetCAPropertyFlags;
	g_pfnProp2_GetCAPropertyDisplayName = Admin2_GetCAPropertyDisplayName;
    }
    else
    {
	g_pfnProp_Init = Request_Init;
	g_pfnProp_Release = Request_Release;
	g_pfnProp2_GetCAProperty = Request2_GetCAProperty;
	g_pfnProp2_GetCAPropertyFlags = Request2_GetCAPropertyFlags;
	g_pfnProp2_GetCAPropertyDisplayName = Request2_GetCAPropertyDisplayName;
    }
}


VOID
cuCAInfoUsage(VOID)
{
    CAINFOTABLE const *pcait;
    UINT id;

    wprintf(wszNewLine);
    wprintf(L"    %ws\n", myLoadResourceString(IDS_CAINFO_USAGEHEADERCOLON)); // "InfoName argument values:"

    for (pcait = g_aCAInfoTable; NULL != pcait->pwszCmdLineName; pcait++)
    {
	id = 0;
	wprintf(L"\t%ws", pcait->pwszCmdLineName);
	if (CAITF_FLAGSARG & pcait->Flags)
	{
	    id = IDS_CAINFO_USAGEERROR;
	}
	if (CAITF_INDEXARG & pcait->Flags)
	{
	    id = IDS_CAINFO_USAGEINDEX;
	}
	if (0 != id)
	{
	    wprintf(L" %ws", myLoadResourceString(id));
	}
	wprintf(L" -- %ws", myLoadResourceString(pcait->ids));
	wprintf(wszNewLine);
    }
}


BOOL
cuParseDecimal(
    IN OUT WCHAR const **ppwc,
    IN OUT DWORD *pcwc,
    OUT DWORD *pdw)
{
    BOOL fFound = FALSE;
    WCHAR const *pwc = *ppwc;
    DWORD cwc = *pcwc;
    DWORD dw = 0;

    while (0 != cwc && iswdigit(*pwc))
    {
	dw = (10 * dw) + *pwc++ - L'0';
	cwc--;
	fFound = TRUE;
    }
    if (fFound && 0 != cwc && L',' == *pwc)
    {
	pwc++;
	cwc--;
    }
    *ppwc = pwc;
    *pcwc = cwc;
    *pdw = dw;
    return(fFound);
}


UINT enumDispositionResourceMap[] =
{
    IDS_CADISP_INCOMPLETE,	// CA_DISP_INCOMPLETE = 0
    IDS_CADISP_ERROR,		// CA_DISP_ERROR = 1
    //IDS_CADISP_ERROR_CRL,	// CA_DISP_ERROR = 1
    IDS_CADISP_REVOKED,		// CA_DISP_REVOKED = 2
    IDS_CADISP_VALID,		// CA_DISP_VALID = 3
    IDS_CADISP_EXPIRED,		// CA_DISP_INVALID = 4
    IDS_CADISP_UNDERSUBMISSION,	// CA_DISP_UNDER_SUBMISSION = 5
    //IDS_CADISP_UNKNOWN,	// ???
};


VOID
DisplayCAState(
    IN LONG lPropId,
    IN DWORD State)
{
    UINT id;

    CSASSERT(
	CR_PROP_CACERTSTATE == lPropId ||
	CR_PROP_CRLSTATE == lPropId ||
	CR_PROP_CAFORWARDCROSSCERTSTATE == lPropId ||
	CR_PROP_CABACKWARDCROSSCERTSTATE == lPropId);

    id = IDS_CADISP_UNKNOWN;
    if (ARRAYSIZE(enumDispositionResourceMap) > State)
    {
	id = enumDispositionResourceMap[State];
	if (IDS_CADISP_ERROR == id && CR_PROP_CRLSTATE == lPropId)
	{
	    id = IDS_CADISP_ERROR_CRL;	// "Error: No CRL for this Cert"
	}
    }
    wprintf(L" -- %ws", myLoadResourceString(id));	// "Valid", etc.
    wprintf(wszNewLine);
}


VOID
DisplayCAVersion(
    IN LONG longValue)
{
    wprintf(
	L" -- V%u.%u\n",
	CANAMEIDTOICERT(longValue),
	CANAMEIDTOIKEY(longValue));
}


UINT enumKRADispositionResourceMap[] =
{
    IDS_CADISP_EXPIRED,		// KRA_DISP_EXPIRED = 0
    IDS_KRADISP_NOTFOUND,	// KRA_DISP_NOTFOUND = 1
    IDS_CADISP_REVOKED,		// KRA_DISP_REVOKED = 2
    IDS_CADISP_VALID,		// KRA_DISP_VALID = 3
    IDS_KRADISP_INVALID,	// KRA_DISP_INVALID = 4
    IDS_KRADISP_UNTRUSTED,	// KRA_DISP_UNTRUSTED = 5
    IDS_KRADISP_NOTLOADED,	// KRA_DISP_NOTLOADED = 6
    //IDS_CADISP_UNKNOWN,	// ???
};


VOID
DisplayKRAState(
    IN DWORD State)
{
    UINT id;

    id = IDS_CADISP_UNKNOWN;
    if (ARRAYSIZE(enumKRADispositionResourceMap) > State)
    {
	id = enumKRADispositionResourceMap[State];
    }
    wprintf(L" -- %ws", myLoadResourceString(id));	// "Valid", etc.
    wprintf(wszNewLine);
}


VOID
cuDisplayCAType(
    IN LONG CAType)
{
    UINT uid;

    if (CAType >= ARRAYSIZE(enumCATypeRscMap))
    {
	uid = IDS_CATYPE_UNKNOWN;
    }
    else
    {
	uid = enumCATypeRscMap[CAType];
    }
    wprintf(myLoadResourceString(uid), CAType);
    wprintf(wszNewLine);
}


//+-------------------------------------------------------------------------
// cuGetCAInfoPropertyByIndex -- display one CA Property for one index value.
//
//--------------------------------------------------------------------------

HRESULT
cuGetCAInfoPropertyByIndex(
    OPTIONAL IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszInfoName,
    OPTIONAL IN LONG const *pPropIndex,
    IN CAINFOTABLE const *pcait,
    IN OUT DISPATCHINTERFACE *pdiProp,
    IN BOOL fV1,
    IN BOOL fDisplayResult,
    OPTIONAL OUT DWORD *pdwValue)
{
    HRESULT hr;
    BYTE *pbBinary = NULL;
    DWORD cbBinary;
    DWORD dwGetCertType;
    DWORD Format;
    DWORD Index = 0;
    DWORD IndexV1 = 0;
    LONG longValue;
    BSTR strValue = NULL;
    BOOL fVerbose = FALSE;
    BOOL fVerboseOld = g_fVerbose;
    BOOL fDisplayed = FALSE;

    if (NULL != pdwValue)
    {
	*pdwValue = MAXDWORD;
    }
    if (g_fVerbose)
    {
	g_fVerbose--;
	fVerbose = TRUE;
    }

    dwGetCertType = pcait->dwGetCert;

    if ((CAITF_INDEXARG | CAITF_FLAGSARG) & pcait->Flags)
    {
	if (NULL == pPropIndex)
	{
	    if ((CAITF_INDEXARGREQUIRED | CAITF_FLAGSARG) & pcait->Flags)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "missing numeric arg");
	    }
	    if (CAITF_INDEXARGMAXDWORD & pcait->Flags)
	    {
		Index = MAXDWORD;
	    }
	    switch (pcait->lPropId)
	    {
		case CR_PROP_BASECRL:
		    dwGetCertType = GETCERT_CURRENTCRL;
		    break;

		case CR_PROP_CASIGCERT:
		    dwGetCertType = GETCERT_CASIGCERT;
		    break;

		case CR_PROP_CASIGCERTCHAIN:
		    dwGetCertType = GETCERT_CASIGCERT | GETCERT_CHAIN;
		    break;
	    }
	}
	else
	{
	    Index = *pPropIndex;
	    IndexV1 = Index;
	}

	if (0 == (CAITF_FLAGSARG & pcait->Flags))
	{
	    if (GETCERT_INDEXVALUEMASK < IndexV1)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "index too large");
	    }
	    CSASSERT(
		0 == IndexV1 ||
		GETCERT_UNSUPPORTED == dwGetCertType ||
		0 == (GETCERT_INDEXVALUEMASK & dwGetCertType));
	}
    }
    else
    {
	if (NULL != pPropIndex)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "too many args");
	}
    }

    if (!fV1)
    {
	if (CR_PROP_NONE != pcait->lPropId)
	{
	    hr = (*g_pfnProp2_GetCAProperty)(
			    pdiProp,
			    g_pwszConfig,
			    pcait->lPropId,
			    Index,
			    pcait->lPropType,
			    PROPTYPE_BINARY == pcait->lPropType?
				CV_OUT_BASE64HEADER : CV_OUT_BINARY,
			    PROPTYPE_LONG == pcait->lPropType?
				(VOID *) &longValue : (VOID *) &strValue);
	    if (E_NOTIMPL != hr && RPC_E_VERSION_MISMATCH != hr)
	    {
		_JumpIfError2(hr, error, "g_pfnProp2_GetCAProperty", hr);
	    }
	    else
	    {
		fV1 = TRUE;
	    }
	}
	else
	{
	    fV1 = TRUE;
	}
    }
    if (fV1)
    {
	DWORD FlagsV1;

	if (g_fAdminInterface || GETCERT_UNSUPPORTED == dwGetCertType)
	{
	    hr = E_NOTIMPL;
	    _JumpIfError(hr, error, "ICertRequest2 required");
	}
	if (CAITF_FLAGSARG & pcait->Flags)
	{
	    FlagsV1 = IndexV1;
	    IndexV1 = 0;
	}
	else
	{
	    FlagsV1 = (CAITF_ASN & pcait->Flags)?
			CR_OUT_BASE64HEADER : CR_OUT_BINARY;
	    if (g_wszCAChain == pwszOption)
	    {
		FlagsV1 |= CR_OUT_CHAIN;
	    }
	}

	hr = Request_GetCACertificate(
			    pdiProp,
			    dwGetCertType | IndexV1, // fExchangeCertificate
			    g_pwszConfig,
			    FlagsV1,
			    &strValue);
	_JumpIfError2(
		hr,
		error,
		"Request_GetCACertificate",
		(CAITF_OPTIONAL & pcait->Flags)?
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) : S_OK);

	// Build up a nice debug print:

	if (fVerbose)
	{
	    WCHAR wszArg[5 + cwcDWORDSPRINTF];

	    switch (dwGetCertType)
	    {
		case GETCERT_CASIGCERT:
		    wcscpy(wszArg, L"SignatureCert");
		    break;

		case GETCERT_CAXCHGCERT:
		    wcscpy(wszArg, L"ExchangeCert");
		    break;

		case GETCERT_CACERTBYINDEX:
		case GETCERT_CRLBYINDEX:
		case GETCERT_CACERTSTATEBYINDEX:
		case GETCERT_CRLSTATEBYINDEX:
		case GETCERT_EXITVERSIONBYINDEX:
		    swprintf(
			wszArg,
			L"\"%c%c.%d\"",
			((char *) &dwGetCertType)[3],
			((char *) &dwGetCertType)[2],
			Index);
		    break;

		default:
		    swprintf(
			wszArg,
			L"\"%c%c%c%c\"",
			((char *) &dwGetCertType)[3],
			((char *) &dwGetCertType)[2],
			((char *) &dwGetCertType)[1],
			((char *) &dwGetCertType)[0]);
		    break;
	    }
	    wprintf(L"GetCACertificate(%ws):\n%ws\n", wszArg, strValue);
	}

	if (PROPTYPE_LONG == pcait->lPropType)
	{
	    DWORD cwc = wcslen(strValue);
	    WCHAR const *pwc = strValue;

	    if (!cuParseDecimal(&pwc, &cwc, (DWORD *) &longValue))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpErrorStr(hr, error, "bad decimal number", strValue);
	    }
	}
    }

    // At this point:
    //   if PROPTYPE_LONG, the value is in longValue,
    //   if PROPTYPE_STRING, the value is in strValue
    //   if PROPTYPE_BINARY, the base64-encoded string is in strValue

    if (PROPTYPE_LONG == pcait->lPropType && NULL != pdwValue)
    {
	*pdwValue = longValue;
    }

    if ((CAITF_ASN & pcait->Flags))
    {
	hr = myCryptStringToBinary(
		    strValue,
		    0,
		    CRYPT_STRING_BASE64HEADER,
		    &pbBinary,
		    &cbBinary,
		    NULL,
		    NULL);
	_JumpIfError(hr, error, "myCryptStringToBinary");

	if (fVerbose)
	{
	    hr = cuDumpAsnBinary(pbBinary, cbBinary, MAXDWORD);
	    _JumpIfError(hr, error, "cuDumpAsnBinary");
	}
    }

    switch (pcait->lPropId)
    {
	case CR_PROP_NONE:
	{
	    switch (dwGetCertType)
	    {
		case GETCERT_ERRORTEXT1:
		case GETCERT_ERRORTEXT2:
		    wprintf(
		    myLoadResourceString(IDS_FORMAT_MESSAGE_TEXT), // "Error message text: %ws"
		    L"");
		    wprintf(L"%ws\n", strValue);
		    fDisplayed = TRUE;
		    break;

		// prettyprint CA Type/CA Info

		case GETCERT_CAINFO:
		{
		    DWORD cwc = wcslen(strValue);
		    WCHAR const *pwc = strValue;
		    CAINFO CAInfo;
		    
		    if (cuParseDecimal(&pwc, &cwc, (DWORD *) &CAInfo.CAType))
		    {
			if (NULL != pwszInfoName &&
			    0 != lstrcmp(L"*", pwszInfoName))
			{
			    cuDisplayCAType(CAInfo.CAType);
			}
			if (cuParseDecimal(&pwc, &cwc, &CAInfo.cCASignatureCerts))
			{
			    wprintf(
				myLoadResourceString(IDS_FORMAT_CCACERTS),
				CAInfo.cCASignatureCerts);
			    wprintf(wszNewLine);
			}
		    }
		    fDisplayed = TRUE;
		    break;
		}
	    }
	    break;
	}
    }
    if (!fDisplayed && fDisplayResult)
    {
	wprintf(L"%ws", myLoadResourceString(pcait->ids));
	if (NULL != pPropIndex)
	{
	    wprintf(L"[%d]", *pPropIndex);
	}
	if (PROPTYPE_LONG == pcait->lPropType)
	{
	    if (0 > longValue || 9 < longValue)
	    {
		wprintf(L": 0x%x (%d)", longValue, longValue);
	    }
	    else
	    {
		wprintf(L": %x", longValue);
	    }
	    switch (pcait->lPropId)
	    {
		// prettyprint Cert/CRL State

		case CR_PROP_CACERTSTATE:
		case CR_PROP_CRLSTATE:
		case CR_PROP_CAFORWARDCROSSCERTSTATE:
		case CR_PROP_CABACKWARDCROSSCERTSTATE:
		    DisplayCAState(pcait->lPropId, longValue);
		    break;

		case CR_PROP_CACERTVERSION:
		    DisplayCAVersion(longValue);
		    break;

		case CR_PROP_KRACERTSTATE:
		    DisplayKRAState(longValue);
		    break;

		case CR_PROP_CATYPE:
		    wprintf(L" -- ");
		    cuDisplayCAType(longValue);
		    break;

		default:
		    wprintf(wszNewLine);
		    break;
	    }
	    if (NULL != pcait->pwszRegName)
	    {
		cuRegPrintDwordValue(
				FALSE,
				pcait->pwszRegName,
				pcait->pwszRegName,
				longValue);
	    }
	}
	else
	{
	    wprintf(L":%ws", (CAITF_ASN & pcait->Flags)? L"\n" : L" ");
	    cuPrintCRLFString(NULL, strValue);
	    wprintf(wszNewLine);
	}
    }

    if (NULL != pwszfnOut && NULL != pbBinary)
    {
	hr = EncodeToFileW(
		    pwszfnOut,
		    pbBinary,
		    cbBinary,
		    CRYPT_STRING_BINARY | g_EncodeFlags);
	if (S_OK != hr)
	{
	    _PrintError(hr, "EncodeToFileW");
	    cuPrintError(IDS_ERR_FORMAT_ENCODETOFILE, hr);
	    goto error;
	}
    }

error:
    g_fVerbose = fVerboseOld;
    if (NULL != pbBinary)
    {
	LocalFree(pbBinary);
    }
    if (NULL != strValue)
    {
	SysFreeString(strValue);
    }
    return(hr);
}


HRESULT
GetCACounts(
    IN OUT DISPATCHINTERFACE *pdiProp,
    IN OUT BOOL *pfV1,
    OUT LONG *pcCASigCerts,
    OUT LONG *pcCAXchgCerts,
    OUT LONG *pcKRACerts,
    OUT LONG *pcExitMods,
    OUT LONG *plPropIdMax)
{
    HRESULT hr;
    BSTR strValue = NULL;

    if (!*pfV1)
    {
	hr = (*g_pfnProp2_GetCAProperty)(
			pdiProp,
			g_pwszConfig,
			CR_PROP_CASIGCERTCOUNT,
			0,
			PROPTYPE_LONG,
			CV_OUT_BINARY,
			pcCASigCerts);
	if (RPC_E_VERSION_MISMATCH != hr)
	{
	    _JumpIfError(hr, error, "g_pfnProp2_GetCAProperty");

	    hr = (*g_pfnProp2_GetCAProperty)(
			    pdiProp,
			    g_pwszConfig,
			    CR_PROP_CAXCHGCERTCOUNT,
			    0,
			    PROPTYPE_LONG,
			    CV_OUT_BINARY,
			    pcCAXchgCerts);
	    _JumpIfError(hr, error, "g_pfnProp2_GetCAProperty");

	    hr = (*g_pfnProp2_GetCAProperty)(
			    pdiProp,
			    g_pwszConfig,
			    CR_PROP_KRACERTCOUNT,
			    0,
			    PROPTYPE_LONG,
			    CV_OUT_BINARY,
			    pcKRACerts);
	    _JumpIfError(hr, error, "g_pfnProp2_GetCAProperty");

	    hr = (*g_pfnProp2_GetCAProperty)(
			    pdiProp,
			    g_pwszConfig,
			    CR_PROP_EXITCOUNT,
			    0,
			    PROPTYPE_LONG,
			    CV_OUT_BINARY,
			    pcExitMods);
	    _JumpIfError(hr, error, "g_pfnProp2_GetCAProperty");

	    hr = (*g_pfnProp2_GetCAProperty)(
			    pdiProp,
			    g_pwszConfig,
			    CR_PROP_CAPROPIDMAX,
			    0,
			    PROPTYPE_LONG,
			    CV_OUT_BINARY,
			    plPropIdMax);
	    _JumpIfError(hr, error, "g_pfnProp2_GetCAProperty");
	}
	else
	{
	    *pfV1 = TRUE;
	}
    }
    if (*pfV1)
    {
	WCHAR const *pwc;
	DWORD cwc;
	
	if (g_fAdminInterface)
	{
	    hr = E_NOTIMPL;
	    _JumpIfError(hr, error, "ICertRequest required");
	}
	hr = Request_GetCACertificate(
			    pdiProp,
			    GETCERT_CAINFO, // fExchangeCertificate
			    g_pwszConfig,
			    CR_OUT_BINARY,
			    &strValue);
	_JumpIfError(hr, error, "Request_GetCACertificate");

	pwc = wcschr(strValue, L',');
	if (NULL == pwc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpErrorStr(hr, error, "bad CAInfo string", strValue);
	}

	pwc++;
	cwc = wcslen(pwc);

	if (!cuParseDecimal(&pwc, &cwc, (DWORD *) pcCASigCerts))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpErrorStr(hr, error, "bad CAInfo cert count", strValue);
	}
	*pcCAXchgCerts = 0;
	*pcExitMods = 1;
	*plPropIdMax = 0;
    }
    if (1 < g_fVerbose)
    {
	wprintf(
	    L"GetCACounts(): cCASigCerts = %d, cCAXchgCerts = %d, cKRACerts = %d\n",
	    *pcCASigCerts,
	    *pcCAXchgCerts,
	    *pcKRACerts);
    }

error:
    if (NULL != strValue)
    {
	SysFreeString(strValue);
    }
    return(hr);
}


//+-------------------------------------------------------------------------
// cuGetCAInfoProperty -- display one CA Property.
//
// If an index is specifed, display the property only for that index.
// Otherwse, display the property for all valid indexes.
//
//--------------------------------------------------------------------------

HRESULT
cuGetCAInfoProperty(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszInfoName,
    OPTIONAL IN WCHAR const *pwszNumber,
    IN BOOL fMultiple,
    IN CAINFOTABLE const *pcait,
    IN LONG cCASigCerts,
    IN LONG cCAXchgCerts,
    IN LONG cKRACerts,
    IN LONG cExitMods,
    IN OUT DISPATCHINTERFACE *pdiProp,
    IN BOOL fV1)
{
    HRESULT hr;
    HRESULT hr2 = S_OK;
    LONG CmdLineIndex;
    LONG PropIndex;
    LONG *pPropIndex = NULL;
    LONG Count = 1;

    // Determine indexed property Count.
    // Non-indexed property Count is always 1.
    
    switch (
	(CAITF_EXITCOUNT | CAITF_SIGCERTCOUNT | CAITF_XCHGCERTCOUNT | CAITF_KRACERTCOUNT) &
	pcait->Flags)
    {
	case CAITF_EXITCOUNT:
	    Count = cExitMods;
	    pPropIndex = &PropIndex;
	    break;
	    
	case CAITF_SIGCERTCOUNT:
	    Count = cCASigCerts;
	    pPropIndex = &PropIndex;
	    break;
	    
	case CAITF_XCHGCERTCOUNT:
	    Count = cCAXchgCerts;
	    pPropIndex = &PropIndex;
	    break;
	    
	case CAITF_KRACERTCOUNT:
	    Count = cKRACerts;
	    pPropIndex = &PropIndex;
	    break;
    }
    if (NULL != pwszNumber)
    {
	hr = myGetSignedLong(pwszNumber, &CmdLineIndex);
	_JumpIfErrorStr(hr, error, "Value not a number", pwszNumber);

	if (MAXDWORD == CmdLineIndex)
	{
	    CmdLineIndex = Count - 1;
	}
	Count = 1;
	pPropIndex = &CmdLineIndex;
    }

    for (PropIndex = 0; PropIndex < Count; PropIndex++)
    {
	DWORD lPropIdState = MAXDWORD;
	BOOL fSkip;

	switch (
	    (CAITF_CRLSTATE | CAITF_FORWARDCROSSCERTSTATE | CAITF_BACKWARDCROSSCERTSTATE) &
	    pcait->Flags)
	{
	    case CAITF_CRLSTATE:
		lPropIdState = CR_PROP_CRLSTATE;
		break;
		
	    case CAITF_FORWARDCROSSCERTSTATE:
		lPropIdState = CR_PROP_CAFORWARDCROSSCERTSTATE;
		break;
		
	    case CAITF_BACKWARDCROSSCERTSTATE:
		lPropIdState = CR_PROP_CABACKWARDCROSSCERTSTATE;
		break;
	}
	if (MAXDWORD != lPropIdState)
	{
	    CAINFOTABLE const *pcaitT;
	    fSkip = FALSE;

	    for (pcaitT = g_aCAInfoTable; NULL != pcaitT->pwszCmdLineName; pcaitT++)
	    {
		if (lPropIdState == pcaitT->lPropId)
		{
		    LONG PropIndexState = *pPropIndex;
		    DWORD dwState;

		    hr = cuGetCAInfoPropertyByIndex(
				    NULL,	// pwszOption
				    NULL,	// pwszfnOut
				    NULL,	// pwszInfoName
				    &PropIndexState,
				    pcaitT,
				    pdiProp,
				    fV1,
				    (CAITF_ASN & pcait->Flags)?
					TRUE : FALSE,	// fDisplayResult
				    &dwState);	// pdwValue
		    _PrintIfError2(hr, "cuGetCAInfoPropertyByIndex", hr);
		    if (S_OK == hr && CA_DISP_ERROR == dwState)
		    {
			fSkip = TRUE;
		    }
		    break;
		}
	    }
	    if (fSkip)
	    {
		continue;
	    }
	}
	if (1 < g_fVerbose)
	{
	    wprintf(
		NULL == pPropIndex?
		    L"cuGetCAInfoProperty(%ws): %ws:\n" :
		    L"cuGetCAInfoProperty(%ws): %ws[%u]:\n",
		pcait->pwszCmdLineName,
		pcait->pwszCmdLineName,
		NULL == pPropIndex? -1 : *pPropIndex);
	}

	hr = cuGetCAInfoPropertyByIndex(
			pwszOption,
			pwszfnOut,
			pwszInfoName,
			pPropIndex,
			pcait,
			pdiProp,
			fV1,
			TRUE,		// fDisplayResult
			NULL);		// pdwValue
	if (E_INVALIDARG == hr &&
	    (fMultiple || 1 < Count) &&
	    (CAITF_SKIPINVALIDARG & pcait->Flags))
	{
	    _PrintIfError2(hr, "cuGetCAInfoPropertyByIndex", hr);
	    hr = S_OK;
	}
	_PrintIfErrorStr3(
		    hr,
		    "cuGetCAInfoPropertyByIndex",
		    pcait->pwszCmdLineName,
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
		    E_INVALIDARG);
	if (S_OK == hr2)
	{
	    hr2 = hr;		// Save first error
	}
    }
    hr = hr2;

error:
    return(hr);
}


//+-------------------------------------------------------------------------
// cuGetCAInfo -- display one or more CA Properties.
//
// If indexed property counts will be needed, fetch them first, so we know
// how many of each indexed property to fetch.
//
// If pwszInfoName is NULL, display the default set of properties.
// If pwszInfoName is L"*", display all properties.
// Otherwise, display only the specified property.
//
//--------------------------------------------------------------------------

HRESULT
cuGetCAInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszInfoName,
    OPTIONAL IN WCHAR const *pwszNumber)
{
    HRESULT hr;
    HRESULT hr2 = S_OK;
    DISPATCHINTERFACE diProp;
    BOOL fV1 = g_fV1Interface;
    BOOL fMustRelease = FALSE;
    BOOL fMultiple = FALSE;
    LONG cCASigCerts = 0;
    LONG cCAXchgCerts = 0;
    LONG cKRACerts = 0;
    LONG cExitMods = 0;
    LONG lPropIdMax;
    CAINFOTABLE const *pcait;

    InitPropFunctionPointers();

    hr = (*g_pfnProp_Init)(g_DispatchFlags, &diProp);
    _JumpIfError(hr, error, "g_pfnProp_Init");

    fMustRelease = TRUE;

    if (NULL == pwszInfoName ||
	(0 != LSTRCMPIS(pwszInfoName, g_wszCAInfoName) &&
	 0 != LSTRCMPIS(pwszInfoName, g_wszCAInfoSanitizedName) &&
	 0 != LSTRCMPIS(pwszInfoName, g_wszCAInfoDSName)))
    {
	hr = GetCACounts(
		    &diProp,
		    &fV1,
		    &cCASigCerts,
		    &cCAXchgCerts,
		    &cKRACerts,
		    &cExitMods,
		    &lPropIdMax);
	_JumpIfError(hr, error, "GetCACounts");
    }

    if (NULL == pwszInfoName || 0 == lstrcmp(L"*", pwszInfoName))
    {
	CSASSERT(NULL == pwszfnOut);
	if (NULL != pwszNumber)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "too many args");
	}
	fMultiple = TRUE;	// loop displaying default or all entries
    }

    for (pcait = g_aCAInfoTable; ; pcait++)
    {
	if (NULL == pcait->pwszCmdLineName)
	{
	    if (!fMultiple)
	    {
		hr = E_INVALIDARG;
		_JumpErrorStr(hr, error, "bad command line name", pwszInfoName);
	    }
	    break;
	}
	if (fMultiple)
	{
	    if (NULL == pwszInfoName)
	    {
		if (0 == (CAITF_DEFAULT & pcait->Flags))
		{
		    continue;
		}
	    }
	    else
	    {
		if (CAITF_SKIP & pcait->Flags)
		{
		    continue;
		}
	    }
	    if (fV1)
	    {
		if (GETCERT_UNSUPPORTED == pcait->dwGetCert)
		{
		    continue;
		}
	    }
	    else
	    {
		if (CR_PROP_NONE == pcait->lPropId)
		{
		    continue;
		}
	    }
	}
	else
	{
	    if (0 != mylstrcmpiS(pwszInfoName, pcait->pwszCmdLineName))
	    {
		continue;
	    }
	}
	hr = cuGetCAInfoProperty(
			pwszOption,
			pwszfnOut,
			pwszInfoName,
			pwszNumber,
			fMultiple,
			pcait,
			cCASigCerts,
			cCAXchgCerts,
			cKRACerts,
			cExitMods,
			&diProp,
			fV1);
	if ((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr ||
	     HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr ||
	     E_INVALIDARG == hr) &&
	    (CAITF_OPTIONAL & pcait->Flags) &&
	    fMultiple)
	{
	    _PrintError2(hr, "cuGetCAInfoProperty", hr);
	    hr = S_OK;
	}
	_PrintIfError2(hr, "cuGetCAInfoProperty", E_INVALIDARG);
	if (S_OK == hr2)
	{
	    hr2 = hr;		// Save first error
	}
	if (!fMultiple)
	{
	    break;
	}
    }
    hr = hr2;

error:
    if (fMustRelease)
    {
	(*g_pfnProp_Release)(&diProp);
    }
    return(hr);
}


HRESULT
verbGetCACertificate(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnCert,
    OPTIONAL IN WCHAR const *pwszIndex,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    if (NULL == pwszIndex)
    {
	pwszIndex = L"-1";
    }
    hr = cuGetCAInfo(
		pwszOption,
		pwszfnCert,
		g_wszCACert == pwszOption?
		    g_wszCAInfoCert : g_wszCAInfoCertChain,
		pwszIndex);
    _JumpIfError(hr, error, "cuGetCAInfo");

error:
    return(hr);
}


HRESULT
verbGetCAInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszInfoName,
    OPTIONAL IN WCHAR const *pwszNumber,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = cuGetCAInfo(pwszOption, NULL, pwszInfoName, pwszNumber);
    _JumpIfError(hr, error, "cuGetCAInfo");

error:
    return(hr);
}


HRESULT
verbGetCAPropInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszInfoName,
    OPTIONAL IN WCHAR const *pwszNumber,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hr2 = S_OK;
    DISPATCHINTERFACE diProp;
    BOOL fV1 = g_fV1Interface;
    BOOL fMustRelease = FALSE;
    LONG cCASigCerts;
    LONG cCAXchgCerts;
    LONG cKRACerts;
    LONG cExitMods;
    LONG lPropIdMax;
    LONG lPropId;
    BSTR strDisplayName = NULL;

    InitPropFunctionPointers();

    hr = (*g_pfnProp_Init)(g_DispatchFlags, &diProp);
    _JumpIfError(hr, error, "g_pfnProp_Init");

    fMustRelease = TRUE;

    hr = GetCACounts(
		&diProp,
		&fV1,
		&cCASigCerts,
		&cCAXchgCerts,
		&cKRACerts,
		&cExitMods,
		&lPropIdMax);
    _JumpIfError(hr, error, "GetCACounts");

    for (lPropId = 1; lPropId <= lPropIdMax; lPropId++)
    {
	LONG lPropFlags;
	
	// don't use the display name twice!
	
	if (NULL != strDisplayName)
	{
	    SysFreeString(strDisplayName);
	    strDisplayName = NULL;
	}
	hr = (*g_pfnProp2_GetCAPropertyFlags)(
				    &diProp,
				    g_pwszConfig,
				    lPropId,
				    &lPropFlags);
	_PrintIfError(hr, "g_pfnProp2_GetCAPropertyFlags");
	if (S_OK == hr)
	{
	    hr = (*g_pfnProp2_GetCAPropertyDisplayName)(
					&diProp,
					g_pwszConfig,
					lPropId,
					&strDisplayName);
	    _PrintIfError(hr, "g_pfnProp2_GetCAPropertyDisplayName");

	    wprintf(L"%3d: ", lPropId);
	    cuPrintSchemaEntry(
			NULL,	// pwszName
			NULL != strDisplayName? strDisplayName : g_wszEmpty,
			lPropFlags,
			0);		// cbMax
	}
    }

error:
    if (fMustRelease)
    {
	(*g_pfnProp_Release)(&diProp);
    }
    if (NULL != strDisplayName)
    {
	SysFreeString(strDisplayName);
    }
    return(hr);
}


HRESULT
verbGetConfig(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    wprintf(
	myLoadResourceString(IDS_FORMAT_CONFIG_STRING), // "Config String: ""%ws"""
	g_pwszConfig);
    wprintf(wszNewLine);
    return(S_OK);
}


HRESULT
verbGetConfig2(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszFlags,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    ICertGetConfig *pConfig = NULL;
    BSTR strConfig = NULL;
    LONG Flags;

    hr = CoCreateInstance(
                CLSID_CCertGetConfig,
                NULL,               // pUnkOuter
                CLSCTX_INPROC_SERVER,
                IID_ICertGetConfig,
                (VOID **) &pConfig);
    _JumpIfError(hr, error, "CoCreateInstance");

    Flags = CC_LOCALCONFIG;
    if (NULL != pwszFlags)
    {
	hr = myGetLong(pwszFlags, &Flags);
	_JumpIfError(hr, error, "Flags must be a number");
    }

    hr = pConfig->GetConfig(Flags, &strConfig);
    _JumpIfError(hr, error, "GetConfig");

    wprintf(
	myLoadResourceString(IDS_FORMAT_ICERTCONFIG_CONFIG_STRING), // "ICertGetConfig Config String: ""%ws"""
	strConfig);
    wprintf(wszNewLine);

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != pConfig)
    {
	pConfig->Release();
    }
    return(hr);
}


HRESULT
verbGetConfig3(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszFlags,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    LONG count;
    DISPATCHINTERFACE diConfig;
    BOOL fRelease = FALSE;
    BSTR strConfig = NULL;
    LONG Flags;
    
    hr = Config_Init(g_DispatchFlags, &diConfig);
    _JumpIfError(hr, error, "Config_Init");

    fRelease = TRUE;

    hr = Config_Reset(&diConfig, 0, &count);
    _JumpIfError(hr, error, "Config_Reset");

    Flags = CC_UIPICKCONFIG;
    if (NULL != pwszFlags)
    {
	hr = myGetLong(pwszFlags, &Flags);
	_JumpIfError(hr, error, "Flags must be a number");
    }

    hr = Config_GetConfig(&diConfig, Flags, &strConfig);
    _JumpIfError(hr, error, "Config_GetConfig");

    hr = ConfigDumpEntry(&diConfig, NULL, -1, NULL);
    _JumpIfError(hr, error, "ConfigDumpEntry");

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (fRelease)
    {
	Config_Release(&diConfig);
    }
    return(hr);
}


HRESULT
verbErrorDump(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszErrorCode,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hrDump;
    WCHAR awchr[cwcHRESULTSTRING];
    WCHAR const *pwszError = NULL;
    
    hr = myGetSignedLong(pwszErrorCode, &hrDump);
    _JumpIfError(hr, error, "bad numeric operand");

    wprintf(
	L"%ws -- %u (%d)\n",
	myHResultToString(awchr, hrDump),
	hrDump,
	hrDump);

    pwszError = myGetErrorMessageText(hrDump, g_fVerbose);
    wprintf(
	myLoadResourceString(IDS_FORMAT_MESSAGE_TEXT), // "Error message text: %ws"
	pwszError);
    wprintf(wszNewLine);
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
        LocalFree(const_cast<WCHAR *>(pwszError));
    }
    return(hr);
}


HRESULT
RequestCACertificateAndComplete(
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszParentMachine,
    OPTIONAL IN WCHAR const *pwszParentCA,
    OPTIONAL IN WCHAR const *pwszfnCACert,
    OPTIONAL OUT WCHAR **ppwszRequestFile)
{
    HRESULT hr;
    WCHAR *pwszCAName = NULL;
    WCHAR *pwszFinalCAName;

    pwszFinalCAName = wcschr(g_pwszConfig, L'\\');
    if (NULL != pwszFinalCAName)
    {
        pwszFinalCAName++;
    }
    else
    {
        hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGACTIVE, &pwszCAName);
        _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", wszREGACTIVE);

        pwszFinalCAName = pwszCAName;
    }
    if (g_fForce)
    {
	Flags |= CSRF_OVERWRITE;
    }
    if (g_fCryptSilent)
    {
	Flags |= CSRF_UNATTENDED;
    }
    hr = CertServerRequestCACertificateAndComplete(
				g_hInstance,		// hInstance
			        NULL,			// hwnd
			        Flags,			// Flags
				pwszFinalCAName,	// pwszCAName
			        pwszParentMachine,	// pwszParentMachine
			        pwszParentCA,		// pwszParentCA
				pwszfnCACert,		// pwszCAChainFile
				ppwszRequestFile);	// ppwszRequestFile
    _JumpIfError(hr, error, "CertServerRequestCACertificateAndComplete");

error:
    if (NULL != pwszCAName)
    {
        LocalFree(pwszCAName);
    }
    return(hr);
}


HRESULT
verbInstallCACert(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnCACert,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = RequestCACertificateAndComplete(
				CSRF_INSTALLCACERT,
			        NULL,		// pwszParentMachine
			        NULL,		// pwszParentCA
				pwszfnCACert,	// pwszfnCACert
				NULL);		// ppwszRequestFile
    _JumpIfError(hr, error, "RequestCACertificateAndComplete");

error:
    return(hr);
}


HRESULT
verbRenewCACert(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszReuseKeys,
    IN WCHAR const *pwszParentConfig,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD Flags = CSRF_RENEWCACERT | CSRF_NEWKEYS;
    WCHAR *pwszParentMachine = NULL;
    WCHAR *pwszParentCA = NULL;
    WCHAR *pwszRequestFile = NULL;

    if (NULL != pwszReuseKeys)
    {
	if (0 == LSTRCMPIS(pwszReuseKeys, L"ReuseKeys"))
	{
	    Flags &= ~CSRF_NEWKEYS;
	}
	else if (NULL == pwszParentConfig)
	{
	    pwszParentConfig = pwszReuseKeys;
	}
	if (NULL != pwszParentConfig)
	{
	    hr = mySplitConfigString(
			    pwszParentConfig,
			    &pwszParentMachine,
			    &pwszParentCA);
	    _JumpIfErrorStr(hr, error, "mySplitConfigString", pwszParentConfig);
	}
    }

    hr = RequestCACertificateAndComplete(
			        Flags,			// Flags
			        pwszParentMachine,	// pwszParentMachine
			        pwszParentCA,		// pwszParentCA
				NULL,			// pwszfnCACert
				&pwszRequestFile);	// ppwszRequestFile
    _JumpIfError(hr, error, "RequestCACertificateAndComplete");

    if (NULL != pwszRequestFile)
    {
	wprintf(
	    L"%ws %ws\n",
	    myLoadResourceString(IDS_REQUEST_FILE_COLON),
	    pwszRequestFile);
    }

error:
    if (NULL != pwszRequestFile)
    {
        LocalFree(pwszRequestFile);
    }
    if (NULL != pwszParentMachine)
    {
        LocalFree(pwszParentMachine);
    }
    if (NULL != pwszParentCA)
    {
        LocalFree(pwszParentCA);
    }
    return(hr);
}


VOID
cuPrintVRootDisposition(
    IN DWORD idmsg,
    IN DWORD Disposition)
{
    DWORD idDisp = 0;
    
    switch (0x0000ffff & Disposition)
    {
	case VFD_CREATED:      idDisp = IDS_VROOTDISP_CREATED;      break;
	case VFD_DELETED:      idDisp = IDS_VROOTDISP_DELETED;      break;
	case VFD_EXISTS:       idDisp = IDS_VROOTDISP_EXISTS;       break;
	case VFD_NOTFOUND:     idDisp = IDS_VROOTDISP_NOTFOUND;     break;
	case VFD_CREATEERROR:  idDisp = IDS_VROOTDISP_CREATEERROR;  break;
	case VFD_DELETEERROR:  idDisp = IDS_VROOTDISP_DELETERROR;   break;
	case VFD_NOTSUPPORTED: idDisp = IDS_VROOTDISP_NOTSUPPORTED; break;
    }
    if (0 != idDisp)
    {
	wprintf(myLoadResourceString(idmsg), myLoadResourceString(idDisp));
	wprintf(wszNewLine);
    }

    idDisp = 0;
    switch (Disposition >> 16)	// display ASP disposition
    {
	case VFD_CREATED:     idDisp = IDS_VROOTDISP_ENABLEDASP;        break;
	case VFD_EXISTS:      idDisp = IDS_VROOTDISP_ASPALREADYENABLED; break;
	case VFD_CREATEERROR: idDisp = IDS_VROOTDISP_ENABLEASPERROR;    break;
    }
    if (0 != idDisp)
    {
	wprintf(L"%ws\n", myLoadResourceString(idDisp));
    }
}


HRESULT
verbCreateVRoots(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszDelete,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD VRootDisposition = 0;
    DWORD ShareDisposition = 0;
    DWORD Flags;

    WCHAR* pwszPath = NULL;
    ENUM_CATYPES CAType = ENUM_UNKNOWN_CA;
    DWORD cb = sizeof(ENUM_CATYPES);
    DWORD dwType;
    HKEY hkey = NULL;

    hr = myRegOpenRelativeKey(
			NULL,
			L"ca",
			RORKF_CREATESUBKEYS,
			&pwszPath,
			NULL,           // ppwszName
			&hkey);
    if (S_OK == hr)
    {
	cb = sizeof(CAType);
	hr = RegQueryValueEx(
			 hkey,
			 wszREGCATYPE,
			 0,
			 &dwType,
			 (BYTE *) &CAType,
			 &cb);
	_JumpIfErrorStr(hr, error, "RegQueryValueEx", wszREGCATYPE);
    }
    else
    {
	hr = myRegOpenRelativeKey(
			NULL,
			L"",
			RORKF_CREATESUBKEYS,
			&pwszPath,
			NULL,           // ppwszName
			&hkey);
	_JumpIfError(hr, error, "myRegOpenRelativeKey");

	cb = sizeof(CAType);
	hr = RegQueryValueEx(
			 hkey,
			 wszREGWEBCLIENTCATYPE,
			 0,
			 &dwType,
			 (BYTE *) &CAType,
			 &cb);
	_JumpIfErrorStr(hr, error, "RegQueryValueEx", wszREGWEBCLIENTCATYPE);
    }

    if (0 != LSTRCMPIS(pwszDelete, L"delete"))
    {
	Flags =	VFF_CREATEVROOTS | 
		    VFF_CREATEFILESHARES | 
		    VFF_CLEARREGFLAGIFOK |
		    VFF_ENABLEASP;
    }
    else
    {
	Flags = VFF_DELETEVROOTS | VFF_DELETEFILESHARES;
    }

    hr = myModifyVirtualRootsAndFileShares(
				    Flags,
                                    CAType,
                                    FALSE,     // synchronous -- blocking call
				    INFINITE,  // will block for good
				    &VRootDisposition,
				    &ShareDisposition);
    cuPrintVRootDisposition(IDS_FORMAT_VROOT, VRootDisposition);
    cuPrintVRootDisposition(IDS_FORMAT_FILESHARE, ShareDisposition);
    _JumpIfError(hr, error, "myModifyVirtualRootsAndFileShares");

error:
    if (pwszPath)
       LocalFree(pwszPath);
    if (hkey)
       RegCloseKey(hkey);

    return(hr);
}


HRESULT
cuPingCertSrv(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT CAINFO **ppCAInfo)
{
    HRESULT hr;
    WCHAR *pwszzCANames = NULL;
    DWORD dwServerVersion;
    WCHAR wszVersion[12];

    if (NULL != ppCAInfo)
    {
	*ppCAInfo = NULL;
    }
    wprintf(
	myLoadResourceString(IDS_FORMAT_CONNECTING), // "Connecting to %ws"
	pwszConfig);

    hr = myPingCertSrv(
		pwszConfig,
		NULL,
		&pwszzCANames,
		NULL,
		ppCAInfo,
		&dwServerVersion,
                NULL);
    wprintf(wszNewLine);
    if (S_OK != hr)
    {
	cuPrintErrorAndString(
		    NULL,
		    IDS_FORMAT_SERVER_DEAD, // "Server could not be reached: %ws"
		    hr,
		    NULL);
    }
    _JumpIfError(hr, error, "Ping");

    if (1 == dwServerVersion)
    {
	wszVersion[0] = L'\0';
    }
    else
    {
	swprintf(wszVersion, L"%u", dwServerVersion);
    }

    wprintf(
	myLoadResourceString(IDS_FORMAT_SERVER_ALIVE), // "Server ""%ws"" ICertRequest%ws interface is alive"
	pwszzCANames,		// Assume only one CA Name for now
	wszVersion);

error:
    wprintf(wszNewLine);
    if (NULL != pwszzCANames)
    {
	LocalFree(pwszzCANames);
    }
    return(hr);
}


HRESULT
verbPing(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;

    hr = cuPingCertSrv(g_pwszConfig, NULL);
    _JumpIfError(hr, error, "cuPingCertSrv");

error:
    return(hr);
}


HRESULT
OpenAdminServer(
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OUT DWORD *pdwServerVersion,
    OUT ICertAdminD2 **ppICertAdminD)
{
    HRESULT hr;

    *pdwServerVersion = 0;
    hr = myOpenAdminDComConnection(
			g_pwszConfig,
			ppwszAuthority,
			NULL,
			pdwServerVersion,
			ppICertAdminD);
    _JumpIfError(hr, error, "myOpenDComConnection");

    CSASSERT(0 != *pdwServerVersion);

error:
    return(hr);
}


VOID
CloseAdminServer(
    IN OUT ICertAdminD2 **ppICertAdminD)
{
    myCloseDComConnection((IUnknown **) ppICertAdminD, NULL);
}


HRESULT
verbPingAdmin(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    ICertAdminD2 *pICertAdminD = NULL;
    WCHAR const *pwszAuthority;
    WCHAR wszVersion[12];
    DWORD dwServerVersion = 0;

    wprintf(
	myLoadResourceString(IDS_FORMAT_CONNECTING), // "Connecting to %ws"
	g_pwszConfig);

    hr = OpenAdminServer(&pwszAuthority, &dwServerVersion, &pICertAdminD);
    _JumpIfError(hr, error, "OpenAdminServer");

    CSASSERT(0 != dwServerVersion);

    if (1 == dwServerVersion)
    {
	wszVersion[0] = L'\0';
    }
    else
    {
	swprintf(wszVersion, L"%u", dwServerVersion);
    }
    if (2 <= dwServerVersion)
    {
	hr = pICertAdminD->Ping2(pwszAuthority);
	_JumpIfError(hr, error, "Ping2");
    }
    else
    {
	hr = pICertAdminD->Ping(pwszAuthority);
	_JumpIfError(hr, error, "Ping");
    }

    wprintf(wszNewLine);
    wprintf(
	myLoadResourceString(IDS_ADMIN_INTERFACE_ALIVE), // "Server ICertAdmin%ws interface is alive"
	wszVersion);

error:
    wprintf(wszNewLine);
    if (NULL != pICertAdminD)
    {
	CloseAdminServer(&pICertAdminD);
    }
    return(hr);
}


HRESULT
verbGetMapiInfo(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszArg1,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszProfileName = NULL; // obsolete
    WCHAR *pwszLogonName = NULL;
    WCHAR *pwszPassword = NULL;
    DWORD cwc;

    hr = myGetMapiInfo(NULL, &pwszProfileName, &pwszLogonName, &pwszPassword);
    _JumpIfError2(
	    hr,
	    error,
	    "myGetMapiInfo",
	    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    wprintf(L"\"%ws\" \"", pwszLogonName);
    for (cwc = wcslen(pwszPassword); cwc != 0; cwc--)
    {
	wprintf(L"*");
    }
    wprintf(L"\"\n");
    hr = S_OK;

error:
    if (NULL != pwszProfileName)
    {
	LocalFree(pwszProfileName);
    }
    if (NULL != pwszLogonName)
    {
	LocalFree(pwszLogonName);
    }
    if (NULL != pwszPassword)
    {
	myZeroDataString(pwszPassword); // password data
	LocalFree(pwszPassword);
    }
    return(hr);
}


HRESULT
verbSetMapiInfo(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszLogonName,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR wszPassword[MAX_PATH];
    WCHAR const *pwszPassword;
    WCHAR const *pwszProfileName = L"";

    verbGetMapiInfo(pwszOption, NULL, NULL, NULL, NULL);

    hr = cuGetPassword(
		    0,			// idsPrompt
		    NULL,		// pwszfn
		    g_pwszPassword,
		    TRUE,		// fVerify
		    wszPassword,
		    ARRAYSIZE(wszPassword),
		    &pwszPassword);
    _JumpIfError(hr, error, "cuGetPassword");
    
    hr = mySaveMapiInfo(NULL, pwszProfileName, pwszLogonName, pwszPassword);
    _JumpIfError(hr, error, "mySaveMapiInfo");

    hr = verbGetMapiInfo(pwszOption, NULL, NULL, NULL, NULL);
    _JumpIfError(hr, error, "verbGetMapiInfo");

error:
    SecureZeroMemory(wszPassword, sizeof(wszPassword));	// password data
    return(hr);
}


HRESULT
verbGetCertFromUI(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszObjId,
    IN WCHAR const *pwszCNArg,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    char *pszObjId = NULL;
    WCHAR const *pwszCommonName = NULL;
    CERT_CONTEXT const *pCert = NULL;
    BOOL fKRA = FALSE;
    BOOL fERA = FALSE;
    DWORD i;

    if (NULL != pwszObjId)
    {
	hr = S_FALSE;
	if (iswdigit(*pwszObjId))
	{
	    hr = myVerifyObjId(pwszObjId);
	    if (S_OK == hr)
	    {
		if (!myConvertWszToSz(&pszObjId, pwszObjId, -1))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "myConvertWszToSz");
		}
		cuDumpOIDAndDescriptionA(pszObjId);
		wprintf(wszNewLine);
	    }
	}
	if (S_OK != hr)
	{
	    if (0 == LSTRCMPIS(pwszObjId, L"KRA"))
	    {
		fKRA = TRUE;
	    }
	    else if (0 == LSTRCMPIS(pwszObjId, L"ERA"))
	    {
		fERA = TRUE;
	    }
	    else
	    {
		pwszCommonName = pwszObjId;
	    }
	}
    }
    if (NULL != pwszCNArg)
    {
	if (NULL != pwszCommonName)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad arg");
	}
	pwszCommonName = pwszCNArg;
    }

    if (fKRA)
    {
	hr = myGetKRACertificateFromPicker(
				g_hInstance,
				NULL,		// hwndParent
				IDS_GETCERT_TITLE,
				IDS_GETCERT_SUBTITLE_KRA,
				pwszCommonName,
                                TRUE,		// is DS available?
				g_fCryptSilent,
				&pCert);
	_JumpIfError(hr, error, "myGetKRACertificateFromPicker");
    }
    else if (fERA)
    {
	hr = myGetERACertificateFromPicker(
				g_hInstance,
				NULL,		// hwndParent
				IDS_GETCERT_TITLE,
				IDS_GETCERT_SUBTITLE_ERA,
				pwszCommonName,
				g_fCryptSilent,
				&pCert);
	_JumpIfError(hr, error, "myGetERACertificateFromPicker");
    }
    else
    {
	hr = myGetCertificateFromPicker(
				g_hInstance,
				NULL,		// hwndParent
				IDS_GETCERT_TITLE,
				NULL != pszObjId?
				    IDS_GETCERT_SUBTITLE_OBJID :
				    IDS_GETCERT_SUBTITLE,

				// dwFlags: HKLM+HKCU My store
				CUCS_MYSTORE |
				    CUCS_CASTORE |
				    CUCS_KRASTORE |
				    CUCS_ROOTSTORE |

				    CUCS_MACHINESTORE |
				    CUCS_USERSTORE |
				    CUCS_DSSTORE |
				    (g_fCryptSilent? CUCS_SILENT : 0),
				pwszCommonName,
				0,
				NULL,
				NULL != pszObjId? 1 : 0,	// cpszObjId
				NULL != pszObjId? &pszObjId : NULL,
				&pCert);
	_JumpIfError(hr, error, "myGetCertificateFromPicker");
    }

    if (NULL != pCert)
    {
        hr = cuDumpAsnBinary(
			pCert->pbCertEncoded,
			pCert->cbCertEncoded,
			MAXDWORD);
        _JumpIfError(hr, error, "cuDumpAsnBinary(cert)");
    }

error:
    if (NULL != pCert)
    {
        CertFreeCertificateContext(pCert);
    }
    if (NULL != pszObjId)
    {
        LocalFree(pszObjId);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\reg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       reg.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <xenroll.h>
#include "polreg.h"
#include "certtype.h"

#define __dwFILE__	__dwFILE_CERTUTIL_REG_CPP__


// add two WCHAR L'\0's after the registry value, in case of a poorly
// formed REG_MULTI_SZ.  Add another to handle possible odd sizes.

#define cbVALUEZEROPAD	(3 * sizeof(WCHAR))


typedef struct _DUMPFLAGS
{
    DWORD Mask;
    DWORD Value;
    WCHAR const *pwszDescription;
} DUMPFLAGS;


#define _DFBIT(def)		{ (def), (def), L#def }
#define _DFBIT2(mask, def)	{ (mask), (def), L#def }


DUMPFLAGS g_adfEditFlags[] =
{
    _DFBIT(EDITF_ENABLEREQUESTEXTENSIONS),
    _DFBIT(EDITF_REQUESTEXTENSIONLIST),
    _DFBIT(EDITF_DISABLEEXTENSIONLIST),
    _DFBIT(EDITF_ADDOLDKEYUSAGE),
    _DFBIT(EDITF_ADDOLDCERTTYPE),
    _DFBIT(EDITF_ATTRIBUTEENDDATE),
    _DFBIT(EDITF_BASICCONSTRAINTSCRITICAL),
    _DFBIT(EDITF_BASICCONSTRAINTSCA),
    _DFBIT(EDITF_ENABLEAKIKEYID),
    _DFBIT(EDITF_ATTRIBUTECA),
    _DFBIT(EDITF_IGNOREREQUESTERGROUP),
    _DFBIT(EDITF_ENABLEAKIISSUERNAME),
    _DFBIT(EDITF_ENABLEAKIISSUERSERIAL),
    _DFBIT(EDITF_ENABLEAKICRITICAL),
    _DFBIT(EDITF_SERVERUPGRADED),
    _DFBIT(EDITF_ATTRIBUTEEKU),
    _DFBIT(EDITF_ENABLEDEFAULTSMIME),
    _DFBIT(EDITF_EMAILOPTIONAL),
    _DFBIT(EDITF_ATTRIBUTESUBJECTALTNAME2),
    _DFBIT(EDITF_ENABLELDAPREFERRALS),
    _DFBIT(EDITF_ENABLECHASECLIENTDC),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfCRLFlags[] =
{
    _DFBIT(CRLF_DELTA_USE_OLDEST_UNEXPIRED_BASE),
    _DFBIT(CRLF_DELETE_EXPIRED_CRLS),
    _DFBIT(CRLF_CRLNUMBER_CRITICAL),
    _DFBIT(CRLF_REVCHECK_IGNORE_OFFLINE),
    _DFBIT(CRLF_IGNORE_INVALID_POLICIES),
    _DFBIT(CRLF_REBUILD_MODIFIED_SUBJECT_ONLY),
    _DFBIT(CRLF_SAVE_FAILED_CERTS),
    _DFBIT(CRLF_IGNORE_UNKNOWN_CMC_ATTRIBUTES),
    _DFBIT(CRLF_IGNORE_CROSS_CERT_TRUST_ERROR),
    _DFBIT(CRLF_PUBLISH_EXPIRED_CERT_CRLS),
    _DFBIT(CRLF_ENFORCE_ENROLLMENT_AGENT),
    _DFBIT(CRLF_DISABLE_RDN_REORDER),
    _DFBIT(CRLF_DISABLE_ROOT_CROSS_CERTS),
    _DFBIT(CRLF_LOG_FULL_RESPONSE),
    _DFBIT(CRLF_USE_XCHG_CERT_TEMPLATE),
    _DFBIT(CRLF_USE_CROSS_CERT_TEMPLATE),
    _DFBIT(CRLF_ALLOW_REQUEST_ATTRIBUTE_SUBJECT),
    _DFBIT(CRLF_REVCHECK_IGNORE_NOREVCHECK),
    _DFBIT(CRLF_PRESERVE_EXPIRED_CA_CERTS),
    _DFBIT(CRLF_PRESERVE_REVOKED_CA_CERTS),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfInterfaceFlags[] =
{
    _DFBIT(IF_LOCKICERTREQUEST),
    _DFBIT(IF_NOREMOTEICERTREQUEST),
    _DFBIT(IF_NOLOCALICERTREQUEST),
    _DFBIT(IF_NORPCICERTREQUEST),
    _DFBIT(IF_NOREMOTEICERTADMIN),
    _DFBIT(IF_NOLOCALICERTADMIN),
    _DFBIT(IF_NOREMOTEICERTADMINBACKUP),
    _DFBIT(IF_NOLOCALICERTADMINBACKUP),
    _DFBIT(IF_NOSNAPSHOTBACKUP),
    _DFBIT(IF_ENFORCEENCRYPTICERTREQUEST),
    _DFBIT(IF_ENFORCEENCRYPTICERTADMIN),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfKRAFlags[] =
{
    _DFBIT(KRAF_ENABLEFOREIGN),
    _DFBIT(KRAF_SAVEBADREQUESTKEY),
    _DFBIT(KRAF_ENABLEARCHIVEALL),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfDBFlags[] =
{
    _DFBIT(DBFLAGS_READONLY),
    _DFBIT(DBFLAGS_CREATEIFNEEDED),
    _DFBIT(DBFLAGS_CIRCULARLOGGING),
    _DFBIT(DBFLAGS_LAZYFLUSH),
    _DFBIT(DBFLAGS_MAXCACHESIZEX100),
    _DFBIT(DBFLAGS_CHECKPOINTDEPTH60MB),
    _DFBIT(DBFLAGS_LOGBUFFERSLARGE),
    _DFBIT(DBFLAGS_LOGBUFFERSHUGE),
    _DFBIT(DBFLAGS_LOGFILESIZE16MB),
    _DFBIT(DBFLAGS_MULTITHREADTRANSACTIONS),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfLDAPFlags[] =
{
    _DFBIT(LDAPF_SSLENABLE),
    _DFBIT(LDAPF_SIGNDISABLE),
    { 0, 0, NULL }
};

#define ISSCERT_LDAPURL		ISSCERT_LDAPURL_OLD
#define ISSCERT_HTTPURL		ISSCERT_HTTPURL_OLD
#define ISSCERT_FTPURL		ISSCERT_FTPURL_OLD
#define ISSCERT_FILEURL		ISSCERT_FILEURL_OLD

DUMPFLAGS g_adfIssuercertFlags[] =
{
    _DFBIT(ISSCERT_LDAPURL),
    _DFBIT(ISSCERT_HTTPURL),
    _DFBIT(ISSCERT_FTPURL),
    _DFBIT(ISSCERT_FILEURL),
    _DFBIT(ISSCERT_ENABLE),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfRequestDispositionFlags[] =
{
    _DFBIT2(REQDISP_MASK, REQDISP_PENDING),
    _DFBIT2(REQDISP_MASK, REQDISP_ISSUE),
    _DFBIT2(REQDISP_MASK, REQDISP_DENY),
    _DFBIT2(REQDISP_MASK, REQDISP_USEREQUESTATTRIBUTE),
    _DFBIT(REQDISP_PENDINGFIRST),
    { 0, 0, NULL }
};


#define REVEXT_CDPLDAPURL	REVEXT_CDPLDAPURL_OLD
#define REVEXT_CDPHTTPURL	REVEXT_CDPHTTPURL_OLD
#define REVEXT_CDPFTPURL	REVEXT_CDPFTPURL_OLD
#define REVEXT_CDPFILEURL	REVEXT_CDPFILEURL_OLD

DUMPFLAGS g_adfRevocationTypeFlags[] =
{
    _DFBIT(REVEXT_CDPLDAPURL),
    _DFBIT(REVEXT_CDPHTTPURL),
    _DFBIT(REVEXT_CDPFTPURL),
    _DFBIT(REVEXT_CDPFILEURL),
    _DFBIT(REVEXT_CDPENABLE),
    _DFBIT(REVEXT_ASPENABLE),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfSetupStatus[] =
{
    _DFBIT(SETUP_SERVER_FLAG),
    _DFBIT(SETUP_CLIENT_FLAG),
    _DFBIT(SETUP_SUSPEND_FLAG),
    _DFBIT(SETUP_REQUEST_FLAG),
    _DFBIT(SETUP_ONLINE_FLAG),
    _DFBIT(SETUP_DENIED_FLAG),
    _DFBIT(SETUP_CREATEDB_FLAG),
    _DFBIT(SETUP_ATTEMPT_VROOT_CREATE),
    _DFBIT(SETUP_FORCECRL_FLAG),
    _DFBIT(SETUP_UPDATE_CAOBJECT_SVRTYPE),
    _DFBIT(SETUP_SERVER_UPGRADED_FLAG),
    _DFBIT(SETUP_SECURITY_CHANGED),
    _DFBIT(SETUP_W2K_SECURITY_NOT_UPGRADED_FLAG),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfCertPublishFlags[] =
{
    _DFBIT(EXITPUB_FILE),
    _DFBIT(EXITPUB_ACTIVEDIRECTORY),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfCAType[] =
{
    _DFBIT2(MAXDWORD, ENUM_ENTERPRISE_ROOTCA),
    _DFBIT2(MAXDWORD, ENUM_ENTERPRISE_SUBCA),
    _DFBIT2(MAXDWORD, ENUM_STANDALONE_ROOTCA),
    _DFBIT2(MAXDWORD, ENUM_STANDALONE_SUBCA),
    _DFBIT2(MAXDWORD, ENUM_UNKNOWN_CA),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfForceTeletex[] =
{
    _DFBIT2(ENUM_TELETEX_MASK, ENUM_TELETEX_OFF),
    _DFBIT2(ENUM_TELETEX_MASK, ENUM_TELETEX_ON),
    _DFBIT2(ENUM_TELETEX_MASK, ENUM_TELETEX_AUTO),
    _DFBIT2(ENUM_TELETEX_UTF8, ENUM_TELETEX_UTF8),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfCSURL[] =
{
    _DFBIT(CSURL_SERVERPUBLISH),
    _DFBIT(CSURL_ADDTOCERTCDP),
    _DFBIT(CSURL_ADDTOFRESHESTCRL),
    _DFBIT(CSURL_ADDTOCRLCDP),
    _DFBIT(CSURL_PUBLISHRETRY),
    _DFBIT(CSURL_ADDTOCERTOCSP),
    _DFBIT(CSURL_SERVERPUBLISHDELTA),
    { 0, 0, NULL }
};


// Enrollment Flags:

DUMPFLAGS g_adfTemplateEnroll[] =
{
    _DFBIT(CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS),
    _DFBIT(CT_FLAG_PEND_ALL_REQUESTS),
    _DFBIT(CT_FLAG_PUBLISH_TO_KRA_CONTAINER),
    _DFBIT(CT_FLAG_PUBLISH_TO_DS),
    _DFBIT(CT_FLAG_AUTO_ENROLLMENT_CHECK_USER_DS_CERTIFICATE),
    _DFBIT(CT_FLAG_AUTO_ENROLLMENT),
    _DFBIT(CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT),
    _DFBIT(CT_FLAG_DOMAIN_AUTHENTICATION_NOT_REQUIRED),
    _DFBIT(CT_FLAG_USER_INTERACTION_REQUIRED),
    _DFBIT(CT_FLAG_ADD_TEMPLATE_NAME),
    _DFBIT(CT_FLAG_REMOVE_INVALID_CERTIFICATE_FROM_PERSONAL_STORE),
    _DFBIT(CT_FLAG_ALLOW_ENROLL_ON_BEHALF_OF),
    { 0, 0, NULL }
};


// Certificate Subject Name Flags:

DUMPFLAGS g_adfTemplateName[] =
{
    _DFBIT(CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT),
    _DFBIT(CT_FLAG_ADD_EMAIL),
    _DFBIT(CT_FLAG_ADD_OBJ_GUID),
    _DFBIT(CT_FLAG_ADD_DIRECTORY_PATH),
    _DFBIT(CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME),
    _DFBIT(CT_FLAG_SUBJECT_ALT_REQUIRE_SPN),
    _DFBIT(CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID),
    _DFBIT(CT_FLAG_SUBJECT_ALT_REQUIRE_UPN),
    _DFBIT(CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL),
    _DFBIT(CT_FLAG_SUBJECT_ALT_REQUIRE_DNS),
    _DFBIT(CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN),
    _DFBIT(CT_FLAG_SUBJECT_REQUIRE_EMAIL),
    _DFBIT(CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME),
    _DFBIT(CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfTemplatePrivateKey[] =
{
// Private Key Flags:
    _DFBIT(CT_FLAG_REQUIRE_PRIVATE_KEY_ARCHIVAL),
    _DFBIT(CT_FLAG_EXPORTABLE_KEY),
    _DFBIT(CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED),
    { 0, 0, NULL }
};


// Old V1 template flags definitions:
//efine CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT   0x00000001
//efine CT_FLAG_ADD_EMAIL                   0x00000002
//efine CT_FLAG_ADD_OBJ_GUID                0x00000004
//efine CT_FLAG_PUBLISH_TO_DS               0x00000008
//efine CT_FLAG_EXPORTABLE_KEY              0x00000010
//efine CT_FLAG_AUTO_ENROLLMENT             0x00000020
//efine CT_FLAG_MACHINE_TYPE                0x00000040
//efine CT_FLAG_IS_CA                       0x00000080
//efine CT_FLAG_ADD_DIRECTORY_PATH          0x00000100
//efine CT_FLAG_ADD_TEMPLATE_NAME           0x00000200
#define CT_FLAG_ADD_SUBJECT_DIRECTORY_PATH  0x00000400
//efine CT_FLAG_IS_CROSS_CA                 0x00000800
//efine CT_FLAG_IS_DEFAULT                  0x00010000
//efine CT_FLAG_IS_MODIFIED                 0x00020000
#define CT_FLAG_IS_DELETED                  0x00040000
#define CT_FLAG_POLICY_MISMATCH             0x00080000


// General Flags

DUMPFLAGS g_adfTemplateGeneral[] =
{
    _DFBIT(CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT),
    _DFBIT(CT_FLAG_ADD_EMAIL),
    _DFBIT(CT_FLAG_ADD_OBJ_GUID),
    _DFBIT(CT_FLAG_PUBLISH_TO_DS),
    _DFBIT(CT_FLAG_EXPORTABLE_KEY),
    _DFBIT(CT_FLAG_AUTO_ENROLLMENT),
    _DFBIT(CT_FLAG_MACHINE_TYPE),
    _DFBIT(CT_FLAG_IS_CA),
    _DFBIT(CT_FLAG_ADD_DIRECTORY_PATH),
    _DFBIT(CT_FLAG_ADD_TEMPLATE_NAME),
    _DFBIT(CT_FLAG_ADD_SUBJECT_DIRECTORY_PATH),
    _DFBIT(CT_FLAG_IS_CROSS_CA),
    _DFBIT(CT_FLAG_IS_DEFAULT),
    _DFBIT(CT_FLAG_IS_MODIFIED),
    _DFBIT(CT_FLAG_IS_DELETED),
    _DFBIT(CT_FLAG_POLICY_MISMATCH),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfKMSCertStatus[] =
{
    _DFBIT(CERTFLAGS_REVOKED),
    _DFBIT(CERTFLAGS_NOT_EXPIRED),
    _DFBIT(CERTFLAGS_SIGNING),
    _DFBIT(CERTFLAGS_SEALING),
    _DFBIT(CERTFLAGS_CURRENT),
    _DFBIT(CERTFLAGS_IMPORTED),
    _DFBIT2(CERTFLAGS_VERSION_3, CERTFLAGS_VERSION_1),
    _DFBIT2(CERTFLAGS_VERSION_3, CERTFLAGS_VERSION_3),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfCRLPublishFlags[] =
{
    _DFBIT(CPF_BASE),
    _DFBIT(CPF_DELTA),
    _DFBIT(CPF_COMPLETE),
    _DFBIT(CPF_SHADOW),
    _DFBIT(CPF_CASTORE_ERROR),
    _DFBIT(CPF_BADURL_ERROR),
    _DFBIT(CPF_MANUAL),
    _DFBIT(CPF_SIGNATURE_ERROR),
    _DFBIT(CPF_LDAP_ERROR),
    _DFBIT(CPF_FILE_ERROR),
    _DFBIT(CPF_FTP_ERROR),
    _DFBIT(CPF_HTTP_ERROR),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfCAFlags[] =
{
    _DFBIT(CA_FLAG_NO_TEMPLATE_SUPPORT),
    _DFBIT(CA_FLAG_SUPPORTS_NT_AUTHENTICATION),
    _DFBIT(CA_FLAG_CA_SUPPORTS_MANUAL_AUTHENTICATION),
    _DFBIT(CA_FLAG_CA_SERVERTYPE_ADVANCED),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfOIDFlags[] =
{
    _DFBIT2(MAXDWORD, CERT_OID_TYPE_TEMPLATE),
    _DFBIT2(MAXDWORD, CERT_OID_TYPE_ISSUER_POLICY),
    _DFBIT2(MAXDWORD, CERT_OID_TYPE_APPLICATION_POLICY),
    { 0, 0, NULL }
};


DUMPFLAGS g_adfRequestClientId[] =
{
    _DFBIT2(MAXDWORD, XECI_DISABLE),
    _DFBIT2(MAXDWORD, XECI_XENROLL),
    _DFBIT2(MAXDWORD, XECI_AUTOENROLL),
    _DFBIT2(MAXDWORD, XECI_REQWIZARD),
    _DFBIT2(MAXDWORD, XECI_CERTREQ),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfSMTPEventFilter[] = 
{
#ifndef EXITEVENT_CERTUNREVOKED
#define EXITEVENT_CERTUNREVOKED	0x100
#endif
    _DFBIT(EXITEVENT_CERTISSUED),
    _DFBIT(EXITEVENT_CERTPENDING),
    _DFBIT(EXITEVENT_CERTDENIED),
    _DFBIT(EXITEVENT_CERTREVOKED),
    _DFBIT(EXITEVENT_CERTRETRIEVEPENDING),
    _DFBIT(EXITEVENT_CRLISSUED),
    _DFBIT(EXITEVENT_SHUTDOWN),
    _DFBIT(EXITEVENT_STARTUP),
    _DFBIT(EXITEVENT_CERTUNREVOKED),
    { 0, 0, NULL }
};


typedef struct _DUMPFLAGSREGMAP
{
    WCHAR const *pwszRegName;
    DUMPFLAGS const *adf;
} DUMPFLAGSREGMAP;


DUMPFLAGSREGMAP g_adfrm[] = {
    { wszREGEDITFLAGS,		g_adfEditFlags },
    { wszREGISSUERCERTURLFLAGS,	g_adfIssuercertFlags },
    { wszREGREQUESTDISPOSITION,	g_adfRequestDispositionFlags },
    { wszREGREVOCATIONTYPE,	g_adfRevocationTypeFlags },
    { wszREGSETUPSTATUS,	g_adfSetupStatus },
    { wszREGCERTPUBLISHFLAGS,	g_adfCertPublishFlags },
    { wszREGCRLEDITFLAGS,	g_adfEditFlags },
    { wszREGCRLFLAGS,		g_adfCRLFlags },
    { wszREGKRAFLAGS,		g_adfKRAFlags },
    { wszREGINTERFACEFLAGS,	g_adfInterfaceFlags },
    { wszREGLDAPFLAGS,		g_adfLDAPFlags },
    { wszREGDBFLAGS,		g_adfDBFlags },
    { wszREGCATYPE,		g_adfCAType},
    { wszREGWEBCLIENTCATYPE,	g_adfCAType},
    { wszREGFORCETELETEX,	g_adfForceTeletex},
    { CERTTYPE_RPOP_ENROLLMENT_FLAG, g_adfTemplateEnroll },
    { CERTTYPE_PROP_NAME_FLAG, g_adfTemplateName },
    { CERTTYPE_PROP_PRIVATE_KEY_FLAG, g_adfTemplatePrivateKey },
  //{ CERTTYPE_PROP_FLAGS,      g_adfTemplateGeneral },
    { wszCUREGDSTEMPLATEFLAGS,	g_adfTemplateGeneral },
    { wszCUREGDSCAFLAGS,	g_adfCAFlags },
  //{ OID_PROP_TYPE,		g_adfOIDFlags },
    { wszCUREGDSOIDFLAGS,	g_adfOIDFlags },
    { wszPROPCERTIFICATEENROLLMENTFLAGS, g_adfTemplateEnroll },
    { wszPROPCERTIFICATEGENERALFLAGS, g_adfTemplateGeneral },
    { wszKMSCERTSTATUS,		g_adfKMSCertStatus },
    { wszPROPCRLPUBLISHFLAGS,	g_adfCRLPublishFlags },
    { wszREQUESTCLIENTID,	g_adfRequestClientId },
    { wszREGCRLPUBLICATIONURLS, g_adfCSURL },
    { wszREGCACERTPUBLICATIONURLS, g_adfCSURL },
    { wszREGEXITSMTPEVENTFILTER, g_adfSMTPEventFilter },
    { NULL,			NULL }
};


VOID
cuPrintFlags(
    IN DWORD Flags,
    IN DUMPFLAGS const *pdf)
{
    DWORD ExtraFlags = Flags;
    
    for ( ; NULL != pdf->pwszDescription; pdf++)
    {
	BOOL fSet = (Flags & pdf->Mask) == pdf->Value;

	if (fSet || g_fVerbose)
	{
	    wprintf(
		L"    %ws%ws -- %x",
		fSet? g_wszEmpty : L"  " wszLPAREN,
		pdf->pwszDescription,
		pdf->Value);
	    if (9 < pdf->Value)
	    {
		wprintf(L" (%d)", pdf->Value);
	    }
	    if (!fSet)
	    {
		wprintf(wszRPAREN);
	    }
	    wprintf(wszNewLine);
	}
	ExtraFlags &= ~pdf->Mask;
    }
    if (0 != ExtraFlags)
    {
	wprintf(L"    0x%x (%u)\n", ExtraFlags, ExtraFlags);
    }
}


WCHAR const *
regTail(
    IN WCHAR const *pwszRegName)
{
    WCHAR const *pwsz = wcsrchr(pwszRegName, L'\\');

    if (NULL != pwsz)
    {
	pwsz++;
    }
    else
    {
	pwsz = pwszRegName;
    }
    return(pwsz);
}


HRESULT
cuLookupRegFlags(
    IN WCHAR const *pwszRegName,
    OUT DUMPFLAGS const **ppdf)
{
    HRESULT hr = E_INVALIDARG;
    DUMPFLAGSREGMAP const *pdfrm;

    *ppdf = NULL;
    pwszRegName = regTail(pwszRegName);
    for (pdfrm = g_adfrm; NULL != pdfrm->pwszRegName; pdfrm++)
    {
	if (0 == mylstrcmpiS(pwszRegName, pdfrm->pwszRegName))
	{
	    *ppdf = pdfrm->adf;
	    hr = S_OK;
	    break;
	}
    }
    return(hr);
}


VOID
cuPrintRegDWord(
    IN DWORD Value,
    IN WCHAR const *pwszRegName)
{
    HRESULT hr;

    pwszRegName = regTail(pwszRegName);
    if (0 == LSTRCMPIS(pwszRegName, wszREGVERSION))
    {
	wprintf(L" -- %u.%u", Value >> 16, Value & ((1 << 16) - 1));
    }
}


BOOL
cuPrintRegFlags(
    IN BOOL fNewLine,
    IN DWORD Flags,
    IN WCHAR const *pwszRegName)
{
    HRESULT hr;
    DUMPFLAGS const *pdf;

    pwszRegName = regTail(pwszRegName);
    if (0 == LSTRCMPIS(pwszRegName, wszHASHALGORITHM) ||
	0 == LSTRCMPIS(pwszRegName, wszENCRYPTIONALGORITHM))
    {
	cuDumpAlgid(Flags);
	hr = S_OK;
    }
    else
    {
	hr = cuLookupRegFlags(pwszRegName, &pdf);
	_JumpIfError2(hr, error, "cuLookupRegFlags", hr);

	if (fNewLine)
	{
	    wprintf(wszNewLine);
	}
	cuPrintFlags(Flags, pdf);
    }

error:
    return(S_OK == hr);
}


HRESULT
cuMapRegFlags(
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszRegValue,
    IN BOOL fClearField,
    IN OUT DWORD *pFlags)
{
    HRESULT hr;
    WCHAR const *pwsz;
    DUMPFLAGS const *pdf;

    hr = cuLookupRegFlags(pwszRegName, &pdf);
    _JumpIfErrorStr2(hr, error, "cuLookupRegFlags", pwszRegName, hr);

    for ( ; NULL != pdf->pwszDescription; pdf++)
    {
	if (0 == mylstrcmpiS(pwszRegValue, pdf->pwszDescription))
	{
	    break;
	}
	pwsz = wcschr(pdf->pwszDescription, L'_');
	if (NULL == pwsz)
	{
	    continue;
	}
	if (0 == mylstrcmpiS(pwszRegValue, &pwsz[1]))
	{
	    break;
	}
    }
    if (NULL == pdf->pwszDescription)
    {
	hr = E_INVALIDARG;
	_JumpErrorStr2(hr, error, "no match", pwszRegValue, hr);
    }

    *pFlags &= ~pdf->Mask;
    if (!fClearField)
    {
	*pFlags |= pdf->Value;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
OpenSubKey(
    IN HKEY hkey,
    IN WCHAR const *pwszName,
    IN BOOL fCreateSubKey,
    OUT HKEY *phkeySub,
    OUT WCHAR **ppwszSubKeyName,
    OUT WCHAR **ppwszValueName)
{
    HRESULT hr;
    HKEY hkeySub = NULL;
    WCHAR *pwszSubKeyName = NULL;
    WCHAR *pwszT;
    DWORD cwcSkip;
    DWORD i;
    WCHAR awc[MAX_PATH];
    
    *phkeySub = NULL;
    hr = myDupString(pwszName, &pwszSubKeyName);
    _JumpIfError(hr, error, "myDupString");

    cwcSkip = wcslen(pwszName);

    hr = RegOpenKeyEx(
		hkey,
		pwszSubKeyName,
		0,
		KEY_ALL_ACCESS,
		&hkeySub);
    if (S_OK != hr)
    {
	//_PrintErrorStr(hr, "RegOpenKeyEx", pwszName);

	hkeySub = NULL;
	pwszT = wcsrchr(pwszSubKeyName, L'\\');
	if (NULL != pwszT)
	{
	    *pwszT = L'\0';
	    cwcSkip = SAFE_SUBTRACT_POINTERS(pwszT, pwszSubKeyName) + 1;

	    hr = RegOpenKeyEx(
			hkey,
			pwszSubKeyName,
			0,
			KEY_ALL_ACCESS,
			&hkeySub);
	    if ((HRESULT) ERROR_FILE_NOT_FOUND == hr && fCreateSubKey)
	    {
		hr = RegCreateKey(hkey, pwszSubKeyName, &hkeySub);
		_JumpIfErrorStr(hr, error, "RegCreateKey", pwszSubKeyName);
	    }
	    _JumpIfErrorStr(hr, error, "RegOpenKeyEx", pwszSubKeyName);
	}
    }

    if (NULL != hkeySub)
    {
	pwszName += cwcSkip;

	if (L'\0' != *pwszName)
	{
	    // Look for case-ignore registry value name, & use the value's
	    // correct upper/lower case spelling if an existing registry value:

	    for (i = 0; ; i++)
	    {
		DWORD cwc = ARRAYSIZE(awc);
		hr = RegEnumValue(hkeySub, i, awc, &cwc, NULL, NULL, NULL, NULL);
		if (S_OK != hr)
		{
		    hr = S_OK;
		    break;
		}
		if (0 == mylstrcmpiL(awc, pwszName))
		{
		    pwszName = awc;
		    break;
		}
	    }
	}
    }

    hr = myDupString(pwszName, ppwszValueName);
    _JumpIfError(hr, error, "myDupString");

    if (NULL != hkeySub)
    {
	*phkeySub = hkeySub;
	hkeySub = NULL;
    }
    *ppwszSubKeyName = pwszSubKeyName;
    pwszSubKeyName = NULL;

error:
    if (NULL != pwszSubKeyName)
    {
	LocalFree(pwszSubKeyName);
    }
    if (NULL != hkeySub)
    {
	RegCloseKey(hkeySub);
    }
    return(myHError(hr));
}


VOID
PrintRegStringValue(
    IN WCHAR const *pwszLookupName,
    IN WCHAR const *pwszValue)
{
    DWORD Flags;
    WCHAR *pwszDup = NULL;
    
    wprintf(L"%ws", pwszValue);
    if (iswdigit(*pwszValue))
    {
	BOOL fParmValid = FALSE;
	DWORD dwParm;
	WCHAR const *pwszObjId = pwszValue;
	WCHAR *pwszParm = wcschr(pwszValue, L',');

	if (NULL != pwszParm)
	{
	    HRESULT hr;

	    hr = myDupString(pwszValue, &pwszDup);
	    _PrintIfError(hr, "myDupString");

	    pwszParm = wcschr(pwszDup, L',');
	    if (NULL != pwszParm)
	    {
		*pwszParm++ = L'\0';
		dwParm = myWtoI(pwszParm, &fParmValid);
		pwszObjId = fParmValid? pwszDup : NULL;
	    }
	}
	if (NULL != pwszObjId)
	{
	    cuPrintPossibleObjectIdName(pwszObjId);
	    if (fParmValid)
	    {
		wprintf(L" %x", dwParm);
		if (9 < dwParm)
		{
		    wprintf(L" (%d)", dwParm);
		}
	    }
	}
    }
    cuPrintRegFlags(TRUE, _wtoi(pwszValue), pwszLookupName);
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
}


VOID
PrintRegValue(
    IN WCHAR const *pwszLookupName,
    IN WCHAR const *pwszDisplayName,
    IN DWORD dwType,
    IN BOOL fPrintDwordNameAndValue,
    IN BOOL fPrintType,
    IN DWORD cwcSeparator,
    IN DWORD cbValue,
    OPTIONAL IN BYTE const *pbValue,
    OPTIONAL OUT BOOL *pfLongValue)
{
    HRESULT hr;
    DWORD i;
    WCHAR const *pwsz;
    BOOL fLongValue = FALSE;
    char const *pszEqual = NULL != pbValue? " =" : "";
    
    if (0 == cwcSeparator && fPrintType)
    {
	cwcSeparator = 1;
    }
    if (fPrintDwordNameAndValue)
    {
	wprintf(L"  %ws%*ws", pwszDisplayName, cwcSeparator, L"");
    }
    switch (dwType)
    {
	case REG_DWORD:
	    if (fPrintDwordNameAndValue)
	    {
		wprintf(
		    L"%ws%hs",
		    fPrintType? L"REG_DWORD" : L"",
		    pszEqual);
	    }
	    if (NULL != pbValue)
	    {
		CSASSERT(sizeof(DWORD) == cbValue);
		if (fPrintDwordNameAndValue)
		{
		    wprintf(L" %x", *(DWORD *) pbValue);
		    if (9 < *(DWORD *) pbValue)
		    {
			wprintf(L" (%d)", *(DWORD *) pbValue);
		    }
		    cuPrintRegDWord(*(DWORD *) pbValue, pwszLookupName);
		    wprintf(wszNewLine);
		}
		if (cuPrintRegFlags(FALSE, *(DWORD *) pbValue, pwszLookupName))
		{
		    fLongValue = TRUE;
		}
	    }
	    else
	    {
		if (fPrintDwordNameAndValue)
		{
		    wprintf(wszNewLine);
		}
	    }
	    break;

	case REG_SZ:
	    if (fPrintType)
	    {
		wprintf(L"REG_SZ");
	    }
	    if (NULL != pbValue && 0 != cbValue)
	    {
		CSASSERT((wcslen((WCHAR const *) pbValue) + 1) * sizeof(WCHAR) == cbValue);
		wprintf(L" = ");
		PrintRegStringValue(pwszLookupName, (WCHAR const *) pbValue);
		if (44 < wcslen((WCHAR const *) pbValue))
		{
		    fLongValue = TRUE;
		}
	    }
	    wprintf(wszNewLine);
	    break;

	case REG_MULTI_SZ:
	    wprintf(
		L"%ws%hs",
		fPrintType? L"REG_MULTI_SZ" : L"",
		pszEqual);
	    if (NULL != pbValue && 0 != cbValue)
	    {
		pwsz = (WCHAR const *) pbValue;
		if (L'\0' == *pwsz)
		{
		    // empty value
		}
		else if (!fPrintType && L'\0' == pwsz[wcslen(pwsz) + 1])
		{
		    // single value

		    wprintf(L" ");
		    PrintRegStringValue(pwszLookupName, (WCHAR const *) pbValue);
		    pwsz += wcslen(pwsz) + 1;
		}
		else
		{
		    wprintf(wszNewLine);
		    i = 0;
		    for ( ; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
		    {
			wprintf(L"    %u: ", i);
			PrintRegStringValue(pwszLookupName, pwsz);
			wprintf(wszNewLine);
			i++;
		    }
		    fLongValue = TRUE;
		}
		CSASSERT(
		    (pwsz == (WCHAR *) pbValue && 2 * sizeof(WCHAR) == cbValue) ||
		    (SAFE_SUBTRACT_POINTERS((BYTE *) pwsz, pbValue) +
			sizeof(WCHAR) ==
			cbValue));
	    }
	    if (!fLongValue)
	    {
		wprintf(wszNewLine);
	    }
	    break;

	default:
	case REG_BINARY:
	    if (fPrintType)
	    {
		if (REG_BINARY == dwType)
		{
		    wprintf(L"REG_BINARY");
		}
		else
		{
		    wprintf(L"???=%x%", dwType);
		}
	    }
	    wprintf(L"%hs", pszEqual);
	    if (NULL != pbValue && 0 != cbValue)
	    {
		BOOL fDump = TRUE;
		WCHAR const *pwszNL = wszNewLine;
		
		if (REG_BINARY == dwType && sizeof(FILETIME) == cbValue)
		{
		    hr = cuDumpFileTimeOrPeriod(
					0,
					NULL,
					(FILETIME const *) pbValue);
		    if (S_OK == hr)
		    {
			if (g_fVerbose)
			{
			    pwszNL = NULL;
			}
			else
			{
			    fDump = FALSE;
			}
		    }
		}
		if (fDump)
		{
		    if (NULL != pwszNL)
		    {
			wprintf(pwszNL);
		    }
		    DumpHex(0, pbValue, cbValue);
		    fLongValue = TRUE;
		}
	    }
	    break;
    }
    if (NULL != pfLongValue)
    {
	*pfLongValue = fLongValue;
    }
}


BOOL
cuRegPrintDwordValue(
    IN BOOL fPrintNameAndValue,
    IN WCHAR const *pwszLookupName,
    IN WCHAR const *pwszDisplayName,
    IN DWORD dwValue)
{
    BOOL fDisplayed = FALSE;

    PrintRegValue(
	    pwszLookupName,
	    pwszDisplayName,
	    REG_DWORD,
	    fPrintNameAndValue,
	    FALSE,
	    0,		// cwcSeparator
	    sizeof(dwValue),
	    (BYTE const *) &dwValue,
	    &fDisplayed);
    return(fDisplayed);
}


VOID
cuRegPrintAwszValue(
    IN WCHAR const *pwszName,
    OPTIONAL IN WCHAR const * const *prgpwszValues)
{
    WCHAR *pwszzValues = NULL;
    WCHAR *pwsz;
    DWORD cwcAlloc;
    DWORD i;

    cwcAlloc = 1;
    if (NULL == prgpwszValues || NULL == prgpwszValues[0])
    {
	cwcAlloc++;
    }
    else
    {
	for (i = 0; NULL != prgpwszValues[i]; i++)
	{
	    cwcAlloc += wcslen(prgpwszValues[i]) + 1;
	}
    }
    pwszzValues = (WCHAR *) LocalAlloc(LMEM_FIXED, cwcAlloc * sizeof(WCHAR));
    if (NULL == pwszzValues)
    {
	_JumpError(E_OUTOFMEMORY, error, "LocalAlloc");
    }
    pwsz = pwszzValues;
    if (NULL == prgpwszValues || NULL == prgpwszValues[0])
    {
	*pwsz++ = L'\0';
    }
    else
    {
	for (i = 0; NULL != prgpwszValues[i]; i++)
	{
	    wcscpy(pwsz, prgpwszValues[i]);
	    pwsz += wcslen(pwsz) + 1;
	}
    }
    *pwsz = L'\0';
    CSASSERT(SAFE_SUBTRACT_POINTERS(pwsz, pwszzValues) + 1 == cwcAlloc);
    
    PrintRegValue(
	    pwszName,
	    pwszName,
	    REG_MULTI_SZ,
	    TRUE,
	    FALSE,
	    0,		// cwcSeparator
	    cwcAlloc * sizeof(WCHAR),
	    (BYTE const *) pwszzValues,
	    NULL);	// pfLongValue

error:
    if (NULL != pwszzValues)
    {
	LocalFree(pwszzValues);
    }
}


#define REGOP_NONE	0
#define REGOP_SET	1
#define REGOP_CLEAR	2


BOOL
IsInList(
    IN WCHAR const *pwsz,
    OPTIONAL IN WCHAR const *pwszzList)
{
    BOOL fFound = FALSE;
    WCHAR *pwszT;
    
    if (NULL != pwszzList)
    {
	for ( ; L'\0' != *pwszzList; pwszzList += wcslen(pwszzList) + 1)
	{
	    if (0 == mylstrcmpiL(pwszzList, pwsz))
	    {
		fFound = TRUE;
		break;
	    }
	}
    }
    return(fFound);
}


HRESULT
CombineMultiSzRegValues(
    IN DWORD RegOp,
    IN WCHAR const *pwszRegValue,
    IN DWORD dwTypeOld,
    IN DWORD cbValueOld,
    OPTIONAL IN BYTE const *pbValueOld,
    OUT BYTE **ppbValue,
    OUT DWORD *pcbValue)
{
    HRESULT hr;
    WCHAR *pwszDst;
    WCHAR const *pwsz;
    DWORD cpwsz;
    WCHAR const **apwsz = NULL;
    DWORD cOld = 0;
    DWORD cNew = 0;
    DWORD cCombined;
    WCHAR *pwszzNew = NULL;
    DWORD cwc;
    DWORD i;
    
    if (REGOP_NONE != RegOp)
    {
	pwsz = (WCHAR *) pbValueOld;
	if (NULL != pwsz && 0 != cbValueOld)
	{
	    for ( ; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	    {
		cOld++;
	    }
	}
    }

    // Convert backslash-n sequences to L'\0' and move data up.

    cwc = wcslen(pwszRegValue) + 1 + 1;
    pwszzNew = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszzNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pwszDst = pwszzNew;
    pwsz = pwszRegValue;

    if (L'\0' != *pwsz && REGOP_CLEAR != RegOp)
    {
	cNew++;
    }
    while (L'\0' != *pwsz)
    {
	WCHAR wc;

	wc = *pwsz++;
	if (L'\\' == wc && L'n' == *pwsz)
	{
	    if (0 != cNew)
	    {
		cNew++;
	    }
	    wc = L'\0';
	    pwsz++;
	    while (L'\\' == pwsz[0] && L'n' == pwsz[1])
	    {
		pwsz += 2;
	    }
	}
	*pwszDst++ = wc;
    }
    *pwszDst++ = L'\0';
    *pwszDst = L'\0';


    apwsz = (WCHAR const **) LocalAlloc(LMEM_FIXED, (cOld + cNew) * sizeof(apwsz[0]));
    if (NULL == apwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    cCombined = 0;
    if (cOld)
    {
	for (pwsz = (WCHAR *) pbValueOld; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    if (REGOP_SET == RegOp || !IsInList(pwsz, pwszzNew))
	    {
		apwsz[cCombined++] = pwsz;
	    }
	}
    }
    if (cNew)
    {
	for (pwsz = pwszzNew; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    if (REGOP_NONE == RegOp || !IsInList(pwsz, (WCHAR *) pbValueOld))
	    {
		apwsz[cCombined++] = pwsz;
	    }
	}
    }
    CSASSERT(cOld + cNew >= cCombined);

    cwc = 1;
    for (i = 0; i < cCombined; i++)
    {
	cwc += wcslen(apwsz[i]) + 1;
    }
    if (0 == cCombined)
    {
	cwc++;
    }

    *pcbValue = cwc * sizeof(WCHAR);
    *ppbValue = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbValue);
    if (NULL == *ppbValue)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pwszDst = (WCHAR *) *ppbValue;
    for (i = 0; i < cCombined; i++)
    {
	wcscpy(pwszDst, apwsz[i]);
	pwszDst += wcslen(pwszDst) + 1;
    }
    if (0 == cCombined)
    {
	*pwszDst++ = L'\0';
    }
    *pwszDst = L'\0';

    CSASSERT(SAFE_SUBTRACT_POINTERS(pwszDst, (WCHAR *) *ppbValue) + 1 == cwc);
    hr = S_OK;

error:
    if (NULL != apwsz)
    {
	LocalFree(apwsz);
    }
    if (NULL != pwszzNew)
    {
	LocalFree(pwszzNew);
    }
    return(hr);
}


HRESULT
ParseRegValue(
    IN WCHAR const *pwszRegName,
    IN DWORD cbValueOld,
    IN BYTE const *pbValueOld,
    IN OUT DWORD *pdwType,
    IN WCHAR const *pwszRegValue,
    OUT DWORD *pcbValue,
    OUT BYTE **ppbValue)
{
    HRESULT hr;
    WCHAR const *pwsz;
    DWORD cb;
    DWORD dw;
    DWORD dwValue;
    DWORD dwType;
    DWORD cNewLine;
    DWORD RegOp;
    BOOL fNumber;

    // A leading '-' or '+' character is used as a REGOP_* operator.
    // To include it as part of the string, add leading whitespace,
    // or separate the operator from the string by one or more spaces.
    //
    // "-foo" -- remove "foo" from registry value
    // "- foo" -- remove "foo" from registry value
    // " -foo" -- overwrite registry value with "-foo"
    // "--foo" -- remove "-foo" from registry value
    // "- -foo" -- remove "-foo" from registry value

    dwValue = 0;
    cNewLine = 0;
    if (REG_DWORD == *pdwType)
    {
	CSASSERT(sizeof(dw) == cbValueOld);
	dwValue = *(DWORD *) pbValueOld;
    }
    if (L'+' == *pwszRegValue)
    {
	RegOp = REGOP_SET;		// set bits in existing value
	pwszRegValue++;
    }
    else if (myIsMinusSign(*pwszRegValue))
    {
	RegOp = REGOP_CLEAR;		// clear bits in existing value
	pwszRegValue++;
    }
    else
    {
	RegOp = REGOP_NONE;		// overwrite value
	dwValue = 0;
    }
    while (L' ' == *pwszRegValue || L'\t' == *pwszRegValue)
    {
	pwszRegValue++;
    }

    cb = sizeof(dwValue);		// assume REG_DWORD
    dwType = REG_DWORD;

    fNumber = FALSE;
    
    if (L'+' == *pwszRegValue ||
	myIsMinusSign(*pwszRegValue) ||
	iswdigit(*pwszRegValue))
    {
	hr = myGetSignedLong(pwszRegValue, (LONG *) &dw);
	if (S_OK == hr)
	{
	    fNumber = TRUE;
	    switch (RegOp)
	    {
		default:
		case REGOP_NONE:
		    dwValue = dw;
		    break;

		case REGOP_SET:
		    dwValue |= dw;
		    break;

		case REGOP_CLEAR:
		    dwValue &= ~dw;
		    break;
	    }
	}
    }
    if (!fNumber)
    {
	hr = cuMapRegFlags(
			pwszRegName,
			pwszRegValue,
			REGOP_CLEAR == RegOp,
			&dwValue);
	if (S_OK != hr)
	{
	    pwsz = pwszRegValue;
	    while (TRUE)
	    {
		pwsz = wcschr(pwsz, L'\\');
		if (NULL == pwsz)
		{
		    break;
		}
		if (L'n' == *++pwsz)
		{
		    cNewLine++;
		}
	    }
	    if (REGOP_SET == RegOp || 0 != cNewLine)
	    {
		dwType = REG_MULTI_SZ;
	    }
	    else
	    {
		dwType = REG_SZ;
	    }
	    cb = (wcslen(pwszRegValue) + 1) * sizeof(WCHAR);
	}
    }

    if (REG_NONE != *pdwType && dwType != *pdwType)
    {
	if (REG_SZ == dwType && REG_MULTI_SZ == *pdwType)
	{
	    dwType = REG_MULTI_SZ;
	    if (0 == cNewLine)
	    {
		cb += sizeof(WCHAR);
	    }
	}
	else if (REG_MULTI_SZ != dwType || REG_SZ != *pdwType)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "bad registry value type");
	}
    }

    if (REG_MULTI_SZ == dwType)
    {
	hr = CombineMultiSzRegValues(
			    RegOp,
			    pwszRegValue,
			    *pdwType,
			    cbValueOld,
			    pbValueOld,
			    ppbValue,
			    pcbValue);
	_JumpIfError(hr, error, "CombineMultiSzRegValues");
    }
    else
    {
	*ppbValue = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == *ppbValue)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	*pcbValue = cb;

	if (REG_DWORD == dwType)
	{
	    CSASSERT(sizeof(dwValue) == cb);
	    CopyMemory(*ppbValue, &dwValue, sizeof(dwValue));
	}
	else
	{
	    if (REGOP_NONE != RegOp)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpErrorStr(hr, error, "bad registry value string", pwszRegValue);
	    }
	    CSASSERT((wcslen(pwszRegValue) + 1) * sizeof(WCHAR) <= cb);
	    wcscpy((WCHAR *) *ppbValue, pwszRegValue);
	}
    }
    *pdwType = dwType;
    if (g_fVerbose)
    {
	DumpHex(0, *ppbValue, *pcbValue);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
WriteRegValue(
    IN HKEY hkey,
    IN WCHAR const *pwszName,
    IN DWORD dwType,
    IN DWORD cbValue,
    IN BYTE const *pbValue)
{
    HRESULT hr;

    hr = RegSetValueEx(hkey, pwszName, 0, dwType, pbValue, cbValue);
    _JumpIfErrorStr(hr, error, "RegSetValueEx", pwszName);

error:
    return(myHError(hr));
}


HRESULT
ReadRegValue(
    IN HKEY hkey,
    IN WCHAR const *pwszName,
    OUT DWORD *pdwType,
    OUT DWORD *pcbValue,
    OUT BYTE **ppbValue)
{
    HRESULT hr;
    DWORD cb;

    *ppbValue = NULL;
    cb = 0;
    hr = RegQueryValueEx(
		    hkey,
		    pwszName,
		    NULL,
		    pdwType,
		    NULL,
		    &cb);
    _JumpIfErrorStr2(hr, error, "RegQueryValueEx", pwszName, ERROR_FILE_NOT_FOUND);

    // add two WCHAR L'\0's after the registry value, in case of a poorly
    // formed REG_MULTI_SZ.  Add another to handle possible odd sizes.

    *ppbValue = (BYTE *) LocalAlloc(LMEM_FIXED, cb + cbVALUEZEROPAD);
    if (NULL == *ppbValue)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    hr = RegQueryValueEx(
		    hkey,
		    pwszName,
		    NULL,
		    pdwType,
		    *ppbValue,
		    &cb);
    _JumpIfErrorStr(hr, error, "RegQueryValueEx", pwszName);

    if (REG_SZ == *pdwType || REG_MULTI_SZ == *pdwType)
    {
	WCHAR *pwszStart;
	WCHAR *pwsz;
	DWORD cbT;

	CSASSERT(0 == ((sizeof(WCHAR) - 1) & cb));
	pwszStart = (WCHAR *) *ppbValue;
	cbT = ~(sizeof(WCHAR) - 1) & cb;
	pwsz = &pwszStart[cbT / sizeof(WCHAR)];

	ZeroMemory(pwsz, cbVALUEZEROPAD);
	pwsz = pwszStart;
	while (L'\0' != pwsz[0] || L'\0' != pwsz[1])
	{
	    pwsz++;
	}
	cbT = (SAFE_SUBTRACT_POINTERS(pwsz, pwszStart) +
		(REG_SZ == *pdwType? 1 : 2)) * sizeof(WCHAR);
	CSASSERT(cb == cbT);
	cb = cbT;
    }
    *pcbValue = cb;

error:
    if (S_OK != hr)
    {
	if (NULL != *ppbValue)
	{
	    LocalFree(*ppbValue);
	    *ppbValue = NULL;
	}
    }
    return(myHError(hr));
}


#define cwcVALUENAME	25	// Nominal registry value name length

HRESULT
DumpRegKeysAndValues(
    IN HKEY hkey,
    OPTIONAL WCHAR *pwszValueNamePrefix)
{
    HRESULT hr;
    DWORD i;
    DWORD j;
    DWORD cwc;
    DWORD dwType;
    WCHAR awc[MAX_PATH + 1];
    DWORD cb;
    BYTE *pb;
    BYTE ab[8 + cbVALUEZEROPAD];	// enough for small registry values
    DWORD cbAlloc;
    BYTE *pbAlloc = ab;
    BOOL fLongValue;
    WCHAR *pwszPrefix = NULL;
    DWORD cwcPrefix;

    if (NULL != pwszValueNamePrefix)
    {
	cwcPrefix = wcslen(pwszValueNamePrefix);
	pwszPrefix = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwcPrefix + 1) * sizeof(WCHAR));
	if (NULL == pwszPrefix)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    for (i = j = 0; ; i++)
    {
	cwc = ARRAYSIZE(awc);
	hr = RegEnumKey(hkey, i, awc, cwc);
	if (S_OK != hr)
	{
	    if ((HRESULT) ERROR_NO_MORE_ITEMS != hr)
	    {
		_PrintError(hr, "RegEnumKey");
	    }
	    break;
	}
	if (NULL != pwszPrefix)
	{
	    wcsncpy(pwszPrefix, awc, cwcPrefix);
	    pwszPrefix[cwcPrefix] = L'\0';
	    if (0 != mylstrcmpiL(pwszValueNamePrefix, pwszPrefix))
	    {
		continue;
	    }
	}

	if (0 == j)
	{
	    wprintf(wszNewLine);
	    wprintf(myLoadResourceString(IDS_KEYS));	// "Keys:"
	    wprintf(wszNewLine);
	}
	else if (0 == (j % 5))
	{
	    wprintf(wszNewLine);
	}
	wprintf(L"  %ws\n", awc);
	j++;
    }

    cbAlloc = sizeof(ab) - cbVALUEZEROPAD;
    fLongValue = FALSE;
    for (i = j = 0; ; i++)
    {
	DWORD cwcSep;

	cwc = ARRAYSIZE(awc);
	cb = cbAlloc;
	pb = pbAlloc;
	hr = RegEnumValue(hkey, i, awc, &cwc, NULL, &dwType, pb, &cb);
	if (S_OK != hr)
	{
	    if ((HRESULT) ERROR_MORE_DATA != hr)
	    {
		if ((HRESULT) ERROR_NO_MORE_ITEMS != hr)
		{
		    _PrintError(hr, "RegEnumValue");
		}
		break;
	    }
	    CSASSERT(NULL != pb);
	    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb + cbVALUEZEROPAD);
	    if (NULL == pb)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    if (ab != pbAlloc)
	    {
		LocalFree(pbAlloc);
	    }
	    pbAlloc = pb;
	    cbAlloc = cb;
	    cwc = ARRAYSIZE(awc);
	    hr = RegEnumValue(hkey, i, awc, &cwc, NULL, &dwType, pb, &cb);
	    _JumpIfError(hr, error, "RegEnumValue");
	}
	if (NULL != pb)
	{
	    ZeroMemory(&pb[cb], cbVALUEZEROPAD);
	}
	if (NULL != pwszPrefix)
	{
	    wcsncpy(pwszPrefix, awc, cwcPrefix);
	    pwszPrefix[cwcPrefix] = L'\0';
	    if (0 != mylstrcmpiL(pwszValueNamePrefix, pwszPrefix))
	    {
		continue;
	    }
	}
	if (0 == j)
	{
	    wprintf(wszNewLine);
	    wprintf(myLoadResourceString(IDS_VALUES));	// "Values:"
	    wprintf(wszNewLine);
	}
	else if (fLongValue || 0 == (j % 5))
	{
	    wprintf(wszNewLine);
	}
	cwcSep = wcslen(awc);
	cwcSep = cwcVALUENAME < cwcSep? 0 : cwcVALUENAME - cwcSep;
	PrintRegValue(awc, awc, dwType, TRUE, TRUE, cwcSep, cb, pb, &fLongValue);
	j++;
    }
    hr = S_OK;

error:
    if (NULL != pbAlloc && ab != pbAlloc)
    {
	LocalFree(pbAlloc);
    }
    if (NULL != pwszPrefix)
    {
	LocalFree(pwszPrefix);
    }
    return(myHError(hr));
}


WCHAR const *
wszHKEY(
    IN WCHAR const *pwszPath)
{
    WCHAR const *pwszKey =  L"HKEY_LOCAL_MACHINE\\";

    if (g_fUserRegistry && 0 == _wcsnicmp(
				    pwszPath,
				    wszCERTTYPECACHE,
				    WSZARRAYSIZE(wszCERTTYPECACHE)))
    {
	pwszKey = L"HKEY_CURRENT_USER\\";
    }
    return(pwszKey);
}


HRESULT
verbGetReg(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszPath = NULL;
    WCHAR *pwszName = NULL;
    WCHAR *pwszValueName = NULL;
    WCHAR *pwszSubKeyName = NULL;
    DWORD dwType;
    DWORD cbValue;
    BYTE *pbValue = NULL;
    HKEY hkey = NULL;
    HKEY hkeySub = NULL;
    HKEY hkeyT;

    if (NULL == pwszRegName)
    {
	pwszRegName = L"";
    }
    hr = myRegOpenRelativeKey(
			g_pwszConfig,
			pwszRegName,
			RORKF_FULLPATH | (g_fUserRegistry? RORKF_USERKEY : 0),
			&pwszPath,
			&pwszName,
			&hkey);
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszRegName);

    hr = OpenSubKey(
		hkey,
		pwszName,
		FALSE,
		&hkeySub,
		&pwszSubKeyName,
		&pwszValueName);
    _JumpIfError(hr, error, "OpenSubKey");

    hkeyT = NULL != hkeySub? hkeySub : hkey;
    wprintf(
	L"%ws%ws%ws%ws:\n",
	wszHKEY(pwszPath),
	L'\0' != *pwszPath? pwszPath : wszREGKEYCONFIG,
	L'\0' != *pwszSubKeyName? L"\\" : L"",
	pwszSubKeyName);

    if (NULL == pwszValueName ||
	L'\0' == *pwszValueName ||
	NULL != wcschr(pwszValueName, L'*'))
    {
	if (NULL != pwszValueName)
	{
	    WCHAR *pwsz = wcschr(pwszValueName, L'*');

	    if (NULL != pwsz)
	    {
		*pwsz = L'\0';
	    }
	}

	hr = DumpRegKeysAndValues(hkeyT, pwszValueName);
	_JumpIfError(hr, error, "DumpRegKeysAndValues");
    }
    else
    {
	hr = ReadRegValue(hkeyT, pwszValueName, &dwType, &cbValue, &pbValue);
	_JumpIfErrorStr(hr, error, "ReadRegValue", pwszValueName);

	wprintf(wszNewLine);
	PrintRegValue(
		pwszValueName,
		pwszValueName,
		dwType,
		TRUE,
		TRUE,
		0,
		cbValue,
		pbValue,
		NULL);
    }

error:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != hkeySub)
    {
        RegCloseKey(hkeySub);
    }
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != pwszSubKeyName)
    {
	LocalFree(pwszSubKeyName);
    }
    if (NULL != pwszValueName)
    {
	LocalFree(pwszValueName);
    }
    if (NULL != pbValue)
    {
	LocalFree(pbValue);
    }
    return(hr);
}


HRESULT
verbSetReg(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszRegValue,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszPath = NULL;
    WCHAR *pwszName = NULL;
    WCHAR *pwszValueName = NULL;
    WCHAR *pwszSubKeyName = NULL;
    DWORD dwType;
    DWORD cbValue;
    DWORD cbValueArg;
    BYTE *pbValueOld = NULL;
    BYTE *pbValueNew = NULL;
    BYTE *pbValueArg = NULL;
    HKEY hkey = NULL;
    HKEY hkeySub = NULL;
    HKEY hkeyT;
    DWORD dw;

    hr = myRegOpenRelativeKey(
			g_pwszConfig,
			pwszRegName,
			RORKF_FULLPATH |
			    RORKF_CREATESUBKEYS |
			    (g_fUserRegistry? RORKF_USERKEY : 0) |
			    (g_fForce? RORKF_CREATEKEY : 0),
			&pwszPath,
			&pwszName,
			&hkey);
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszRegName);

    hr = OpenSubKey(
		hkey,
		pwszName,
		g_fForce,
		&hkeySub,
		&pwszSubKeyName,
		&pwszValueName);
    _JumpIfError(hr, error, "OpenSubKey");

    hkeyT = NULL != hkeySub? hkeySub : hkey;
    wprintf(
	L"%ws%ws%ws%ws:\n",
	g_fVerbose? wszHKEY(pwszPath) : L"",
	L'\0' != *pwszPath? pwszPath : wszREGKEYCONFIG,
	L'\0' != *pwszSubKeyName? L"\\" : L"",
	pwszSubKeyName);

    hr = ReadRegValue(hkeyT, pwszValueName, &dwType, &cbValue, &pbValueOld);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
	_JumpIfErrorStr(hr, error, "ReadRegValue", pwszValueName);
    }

    if (NULL != pbValueOld)
    {
	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_OLD_REG_VALUE));	// "Old Value:"
	wprintf(wszNewLine);
	PrintRegValue(
		pwszValueName,
		pwszValueName,
		dwType,
		TRUE,
		TRUE,
		0,
		cbValue,
		pbValueOld,
		NULL);
    }
    else
    {
	dwType = REG_NONE;
    }

    hr = ParseRegValue(
		    pwszRegName,
		    cbValue,
		    pbValueOld,
		    &dwType,
		    pwszRegValue,
		    &cbValueArg,
		    &pbValueArg);
    _JumpIfErrorStr(hr, error, "ParseRegValue", pwszRegValue);

    hr = WriteRegValue(hkeyT, pwszValueName, dwType, cbValueArg, pbValueArg);
    _JumpIfErrorStr(hr, error, "WriteRegValue", pwszValueName);

    hr = ReadRegValue(hkeyT, pwszValueName, &dwType, &cbValue, &pbValueNew);
    _JumpIfErrorStr(hr, error, "ReadRegValue", pwszValueName);

    wprintf(wszNewLine);
    wprintf(myLoadResourceString(IDS_NEW_REG_VALUE));	// "New Value:"
    wprintf(wszNewLine);
    PrintRegValue(
	    pwszValueName,
	    pwszValueName,
	    dwType,
	    TRUE,
	    TRUE,
	    0,
	    cbValue,
	    pbValueNew,
	    NULL);

error:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != hkeySub)
    {
        RegCloseKey(hkeySub);
    }
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != pwszSubKeyName)
    {
	LocalFree(pwszSubKeyName);
    }
    if (NULL != pwszValueName)
    {
	LocalFree(pwszValueName);
    }
    if (NULL != pbValueOld)
    {
	LocalFree(pbValueOld);
    }
    if (NULL != pbValueArg)
    {
	LocalFree(pbValueArg);
    }
    if (NULL != pbValueNew)
    {
	LocalFree(pbValueNew);
    }
    return(hr);
}


HRESULT
verbDelReg(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszRegName,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszPath = NULL;
    WCHAR *pwszName = NULL;
    WCHAR *pwszValueName = NULL;
    WCHAR *pwszSubKeyName = NULL;
    DWORD dwType;
    DWORD cbValue;
    BYTE *pbValueOld = NULL;
    HKEY hkey = NULL;
    HKEY hkeySub = NULL;
    HKEY hkeyT;
    DWORD dw;

    hr = myRegOpenRelativeKey(
			g_pwszConfig,
			pwszRegName,
			RORKF_FULLPATH |
			    RORKF_CREATESUBKEYS |
			    (g_fUserRegistry? RORKF_USERKEY : 0),
			&pwszPath,
			&pwszName,
			&hkey);
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszRegName);

    hr = OpenSubKey(
		hkey,
		pwszName,
		FALSE,
		&hkeySub,
		&pwszSubKeyName,
		&pwszValueName);
    _JumpIfError(hr, error, "OpenSubKey");

    hkeyT = NULL != hkeySub? hkeySub : hkey;
    wprintf(
	L"%ws%ws%ws%ws:\n",
	wszHKEY(pwszPath),
	L'\0' != *pwszPath? pwszPath : wszREGKEYCONFIG,
	L'\0' != *pwszSubKeyName? L"\\" : L"",
	pwszSubKeyName);

    hr = ReadRegValue(hkeyT, pwszValueName, &dwType, &cbValue, &pbValueOld);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
	_JumpIfErrorStr(hr, error, "ReadRegValue", pwszValueName);
    }

    if (NULL != pbValueOld)
    {
	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_OLD_REG_VALUE));	// "Old Value:"
	wprintf(wszNewLine);
	PrintRegValue(
		pwszValueName,
		pwszValueName,
		dwType,
		TRUE,
		TRUE,
		0,
		cbValue,
		pbValueOld,
		NULL);
    }
    if (NULL == pwszValueName || L'\0' == *pwszValueName)
    {
	if (!g_fForce)
	{
	    hr = E_ACCESSDENIED;
	    _JumpErrorStr(hr, error, "use -f", pwszSubKeyName);
	}
	if (NULL != hkeySub)
	{
	    RegCloseKey(hkeySub);
	    hkeySub = NULL;
	}
	hr = RegDeleteKey(hkey, pwszSubKeyName);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _JumpErrorStr(hr, error, "RegDeleteKey", pwszSubKeyName);
	}
    }
    else
    {
	hr = RegDeleteValue(hkeyT, pwszValueName);
	if (S_OK != hr)
	{
	    hr = myHError(hr);
	    _JumpErrorStr(hr, error, "RegDeleteValue", pwszValueName);
	}
    }
    hr = S_OK;

error:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != hkeySub)
    {
        RegCloseKey(hkeySub);
    }
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != pwszSubKeyName)
    {
	LocalFree(pwszSubKeyName);
    }
    if (NULL != pwszValueName)
    {
	LocalFree(pwszValueName);
    }
    if (NULL != pbValueOld)
    {
	LocalFree(pbValueOld);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDI_APP                         		201

#define IDS_DUMP_DESCRIPTION				301
#define IDS_GETCONFIG_DESCRIPTION			302
#define IDS_GETCONFIG2_DESCRIPTION			303
#define IDS_CAVERSION					304
#define IDS_DECODEHEX_DESCRIPTION			305
#define IDS_DECODE_DESCRIPTION				306
#define IDS_ENCODE_DESCRIPTION				307
#define IDS_DENY_DESCRIPTION				308
#define IDS_RESUBMIT_DESCRIPTION			309
#define IDS_REVOKE_DESCRIPTION				310
#define IDS_CRL_DESCRIPTION				311
#define IDS_GETCRL_DESCRIPTION				312
#define IDS_ISVALID_DESCRIPTION				313
#define IDS_SETATTRIBUTES_DESCRIPTION			314
#define IDS_SETEXTENSION_DESCRIPTION			315
#define IDS_CACERT_DESCRIPTION				316
#define IDS_CACHAIN_DESCRIPTION				317
#define IDS_IMPORTKMS_USAGEARGS				318
#define IDS_IMPORTKMS_DESCRIPTION			319
#define IDS_DB_DESCRIPTION				320
#define IDS_VERIFYKEYS_DESCRIPTION			321
#define IDS_VERIFY_DESCRIPTION				322
#define IDS_7F_DESCRIPTION				323
#define IDS_USAGE_DESCRIPTION				324
#define IDS_VERBOSE_DESCRIPTION				325
#define IDS_IDISPATCH_DESCRIPTION			326
#define IDS_REVERSE_DESCRIPTION				327
#define IDS_OPTIONS_USAGEARGS				328
#define IDS_CRL_REASON_UNRECOGNIZED			329
#define IDS_INFILEOUTFILE_USAGEARGS			330
#define IDS_SCHEMA_COLUMNHEADERS 			331
#define IDS_SCHEMA_COLUMNUNDERLINE			332
#define IDS_DENY_USAGEARGS				333
#define IDS_RESUBMIT_USAGEARGS				334
#define IDS_REVOKE_USAGEARGS				335
#define IDS_CRL_USAGEARGS				336
#define IDS_GETCRL_USAGEARGS				337
#define IDS_ISVALID_USAGEARGS				338
#define IDS_SETATTRIBUTES_USAGEARGS			339
#define IDS_SETEXTENSION_USAGEARGS			340
#define IDS_CACERT_USAGEARGS				341
#define IDS_CACHAIN_USAGEARGS				342
#define IDS_VERIFYKEYS_USAGEARGS			343
#define IDS_VERIFY_USAGEARGS				344
#define IDS_7F_USAGEARGS				345
#define IDS_ERR_NOMEMORY				346
#define IDS_FORMAT_USAGE_MISSINGNAMEDARG		347
#define IDS_FORMAT_USAGE_UNKNOWNARG			348
#define IDS_FORMAT_USAGE_MULTIPLEVERBARGS		349
#define IDS_USAGE_MISSINGARG				350
#define IDS_USAGE_TOOMANYARGS				351
#define IDS_USAGE_INTERNALVERBTABLEERROR		352
#define IDS_FORMAT_USAGE_EXTRAOPTION			353
#define IDS_USAGE_HEADER				354
#define IDS_USAGE_OPTIONS				355
#define IDS_USAGE_VERBS					356
#define IDS_OIDNAME_ARGDESCRIPTION			357
#define IDS_INDEXED					358
#define IDS_FORMAT_INPUT_LENGTH				359
#define IDS_NO_KEYAUTHORITYSERIAL			360
#define IDS_FORMAT_OUTPUT_LENGTH			361
#define IDS_ERR_FORMAT_DECODEFILE			362
#define IDS_ERR_FORMAT_ENCODETOFILE			363
#define IDS_ISSUER					364
#define IDS_SUBJECT					365
#define IDS_ERR_FORMAT_ISSUER_NOT_KEYAUTHORITY		366
#define IDS_ISSUER_IS_KEYAUTHORITY			367
#define IDS_NO_KEYAUTHORITY				368
#define IDS_SERIAL_NOT_KEYAUTHORITY			369
#define IDS_SERIAL_IS_KEYAUTHORITY			370
#define IDS_ISSUERNAME					371
#define IDS_KEYAUTHORITYNAME				372
#define IDS_KEYID					373
#define IDS_KEYAUTHORITYSERIAL				374
#define IDS_CASERIAL					375
#define IDS_PROCESSCOLON				376
#define IDS_TCAINFO_USAGEARGS				377
#define IDS_ERR_FORMAT_LOADKEYS				378
#define IDS_ERR_FORMAT_LOADCACERT			379
#define IDS_ERR_PUBLICKEY_MISMATCH			380
#define IDS_CONTAINER_PUBLIC_KEY			381
#define IDS_CERT_PUBLIC_KEY				382
#define IDS_FORMAT_KEY_IS_VERIFY			383
#define IDS_FORMAT_KEY_NOT_VERIFY			384
#define IDS_FORMAT_IS_REVOKED				385
#define IDS_ERR_FORMAT_VERIFY_REVSTATUS			386
#define IDS_CANNOT_CHECK_REVSTATUS			387
#define IDS_REVSTATUS_OK				388
#define IDS_FORMAT_LOADTESTCERT				389
#define IDS_FORMAT_LOADCACERT				390
#define IDS_CERT					391
#define IDS_ISSUINGCACERT				392
#define IDS_CERT_SERIAL					393
#define IDS_ISSUINGCACERT_SERIAL			394
#define IDS_ISSUINGCA_NOT_ROOT				395
#define IDS_ISSUINGCA_SUBJECT_NOT_ISSUER		396
#define IDS_ISSUINGCA_SUBJECT_IS_ISSUER			397
#define IDS_FORMAT_CERTVERIFYSUBJECTCERTIFICATECONTEXT_FLAGS	398
#define IDS_ERR_FORMAT_VALIDATION			399
#define IDS_ERR_CA_SIG_NOT_ISSUER			400
#define IDS_ERR_EXPIRED					401
#define IDS_CERT_CURRENT				402
#define IDS_CRL_DIST_POINTS				403
#define IDS_NETSCAPE_REVOCATION_URL			404
#define IDS_NO_REVCHECKEXTENSION			405
#define IDS_FORMAT_IS_VERIFY				406
#define IDS_FORMAT_NOT_VERIFY				407
#define IDS_FORMAT_REVCHECK_SKIPPED			408
#define IDS_FORMAT_REVCHECK_PASS			409
#define IDS_FORMAT_REVCHECK_REVOKED			410
#define IDS_FORMAT_REVCHECK_FAIL			411
#define IDS_SIGNATUREMATCHES				412
#define IDS_CRLENTRIES					413
#define IDS_CERTCOLON					414
#define IDS_QUESTIONMARKS				415
#define IDS_FORMAT_SUSPECT_LENGTH			416
#define IDS_FORMAT_FIELD				417
#define IDS_FORMAT_OID					418
#define IDS_FORMAT_EXTENSION_OID			419
#define IDS_ERR_FORMAT_NO_SIGNATUREMATCHES		420
#define IDS_ERR_FORMAT_CANNOT_DECODE			421
#define IDS_ALG_OID					422
#define IDS_ALG_PARAMETERS_COLON			423
#define IDS_NULL					424
#define IDS_FORMAT_PUBLICKEY_UNUSEDBITS			425
#define IDS_FORMAT_CHALLENGE_STRING			426
#define IDS_FORMAT_CONFIG_STRING			427
#define IDS_FORMAT_ICERTCONFIG_CONFIG_STRING		428
#define IDS_FORMAT_PENDING_REQUESTID			429
#define IDS_CERT_ISSUED					430
#define IDS_CERT_NOT_ISSUED_DISPOSITION			431
#define IDS_CERT_DISPOSITION_INVALID			432
#define IDS_CERT_DISPOSITION_VALID			433
#define IDS_CERT_DISPOSITION_REVOKED			434
#define IDS_PROPTYPE_DATE				435
#define IDS_PROPTYPE_LONG				436
#define IDS_PROPTYPE_STRING				437
#define IDS_PROPTYPE_BINARY				438
#define IDS_SCHEMA_COLON				439
#define IDS_FORMAT_ROWID				440
#define IDS_FORMAT_OPENING_DB				441
#define IDS_PROP_EMPTY					442
#define IDS_FORMAT_ERROR				443
#define IDS_SEPARATOR					444
#define IDS_REQTYPE_ANY					445
#define IDS_REQTYPE_PKCS10				446
#define IDS_REQTYPE_KEYGEN				447
#define IDS_REQTYPE_PKCS7				448
#define IDS_REQTYPE_UNKNOWN				449
#define IDS_REQFLAGS_FORCETELETEX			450
#define IDS_REQFLAGS_RENEWAL				451
#define IDS_CRITICAL					452
#define IDS_DISABLED					453
#define IDS_FORMAT_POLICYFLAGS				454
#define IDS_REQUEST					455
#define IDS_POLICY					456
#define IDS_ADMIN					457
#define IDS_SERVER					458
#define IDS_UNKNOWN					459
#define IDS_FORMAT_ORIGIN				460
#define IDS_FORMAT_UNKNOWN_HEX				461
#define IDS_GETCONFIG3_DESCRIPTION			462
#define IDS_REQUEST_PROPERTIES				463
#define IDS_CERT_PROPERTIES				464
#define IDS_LOG_COMMANDLINE				465
#define IDS_CONFIGDISPLAY_SANITIZEDNAME_COLON		466
#define IDS_FORMAT_EXTENSION				467
#define IDS_ERR_FORMAT_SHOW_TOO_FEW_ARGS		468
#define IDS_ERR_FORMAT_SHOW_TOO_MANY_ARGS		469
#define IDS_ERR_CONFIGGETCONFIG				470
#define IDS_ERR_FORMAT_COMMAND_FAILED			471
#define IDS_CHECK7F_FIELD_UNKNOWN			472
#define IDS_CHECK7F_FIELD_NONE				473
#define IDS_CHECK7F_FIELD_OTHER				474
#define IDS_CHECK7F_FIELD_ISSUER			475
#define IDS_CHECK7F_FIELD_ISSUERRDN			476
#define IDS_CHECK7F_FIELD_ISSUERRDNATTRIBUTE		477
#define IDS_CHECK7F_FIELD_ISSUERRDNSTRING		478
#define IDS_CHECK7F_FIELD_SUBJECT			479
#define IDS_CHECK7F_FIELD_SUBJECTRDN			480
#define IDS_CHECK7F_FIELD_SUBJECTRDNATTRIBUTE		481
#define IDS_CHECK7F_FIELD_SUBJECTRDNSTRING		482
#define IDS_CHECK7F_FIELD_EXTENSIONS			483
#define IDS_CHECK7F_FIELD_EXTENSIONARRAY		484
#define IDS_CHECK7F_FIELD_EXTENSION			485
#define IDS_CHECK7F_FIELD_EXTENSIONVALUE		486
#define IDS_CHECK7F_FIELD_EXTENSIONVALUERAW		487
#define IDS_NO_KEY_PROVIDER_INFO			488
#define IDS_VIEW_DESCRIPTION				489
#define IDS_FORMAT_ADDED_TO_DS_STORE			490
#define IDS_PING_DESCRIPTION				491
#define IDS_PINGADMIN_DESCRIPTION			492
#define IDS_CONFIGDISPLAY_COMMONNAME_COLON		493
#define IDS_CONFIGDISPLAY_ORGUNIT_COLON			494
#define IDS_CONFIGDISPLAY_ORG_COLON			495
#define IDS_CONFIGDISPLAY_LOCALITY_COLON		496
#define IDS_CONFIGDISPLAY_STATE_COLON			497
#define IDS_CONFIGDISPLAY_COUNTRY_COLON			498
#define IDS_CONFIGDISPLAY_CONFIG_COLON			499
#define IDS_CONFIGDISPLAY_EXCHANGECERT_COLON		500
#define IDS_CONFIGDISPLAY_SIGCERT_COLON			501
#define IDS_CONFIGDISPLAY_DESCRIPTION_COLON		502
#define IDS_CONFIGDISPLAY_SERVER_COLON			503
#define IDS_CONFIGDISPLAY_AUTHORITY_COLON		504
#define IDS_CONFIGDISPLAY_ENTRY				505
#define IDS_CERTIFICATE_EXTENSIONS			506
#define IDS_REQUEST_ATTRIBUTES				507
#define IDS_SHUTDOWN_DESCRIPTION			508
#define IDS_LOG_STATUS					509
#define IDS_SCHEMA_DESCRIPTION				510
#define IDS_LOG_STATUSOK				511
#define IDS_PASSWORD_DESCRIPTION			512
#define IDS_DUMP_CERT					513
#define IDS_DUMP_CRL					514
#define IDS_DUMP_REQUEST				515
#define IDS_DUMP_KEYGEN					516
#define IDS_FORMAT_VERSION				517
#define IDS_SERIAL					518
#define IDS_SIGNATURE_ALGORITHM				519
#define IDS_PUBLICKEY_ALGORITHM				520
#define IDS_ISSUERUNIQUEID				521
#define IDS_SUBJECTUNIQUEID				522
#define IDS_NOTBEFORE					523
#define IDS_NOTAFTER					524
#define IDS_THISUPDATE					525
#define IDS_NEXTUPDATE					526
#define IDS_REVOCATIONDATE				527
#define IDS_EXTENSIONS					528
#define IDS_CRLEXTENSIONS				529
#define IDS_DUMP_PKCS7					530
#define IDS_ERR_FORMAT_ROOT_CERT_BAD_SIG		531
#define IDS_NO_ROOT_CERT				532
#define IDS_ROOT_CERT					533
#define IDS_NO_ROOT_CERT_GOOD_SIG			534
#define IDS_REVOKING					535
#define IDS_PASSWORDPROMPT				536
#define IDS_UNKNOWN_EXTENSION				537
#define IDS_PRIVATEKEY					538
#define IDS_LENGTH					539
#define IDS_GMT_DESCRIPTION				540
#define IDS_GMT_SUFFIX					541
#define IDS_BACKUPPFX_USAGEARGS				542
#define IDS_BACKUPPFX_DESCRIPTION			543
#define IDS_RESTOREPFX_USAGEARGS			544
#define IDS_RESTOREPFX_DESCRIPTION			545
#define IDS_STORE_USAGEARGS				546
#define IDS_STORE_DESCRIPTION				547
#define IDS_FORMAT_PROVIDER_TYPE			548
#define IDS_FORMAT_KEY_CONTAINER			549
#define IDS_FORMAT_PROVIDER_NAME			550
#define IDS_FORMAT_KEYSPEC				551
#define IDS_FORMAT_FLAGS 				552
#define IDS_FORMAT_RESTORED				553
#define IDS_FORMAT_BACKEDUP				554
#define IDS_INSTALLCERT_USAGEARGS			555
#define IDS_INSTALLCERT_DESCRIPTION			556
#define IDS_DUMP_PKCS7_CONTENTS				557
#define IDS_DUMP_PKCS7_ATTRIBUTES			558
#define IDS_DUMP_PKCS7_SIGNCERT				559
#define IDS_FORMAT_DUMP_LEVEL_START			560
#define IDS_FORMAT_DUMP_LEVEL_END			561
#define IDS_FORMAT_LANG					562
#define IDS_FORMAT_FILE					563
#define IDS_FORMAT_PRODUCT				564
#define IDS_DUMP_PKCS7_NO_SIGNER			565
#define IDS_DUMP_PKCS7_NO_CONTENT			566
#define IDS_DUMP_PKCS7_NO_CERTIFICATES			567
#define IDS_DUMP_PKCS7_NO_CRLS				568
#define IDS_DUMP_PKCS7_CERTIFICATES			569
#define IDS_DUMP_PKCS7_CRLS				570
#define IDS_RENEWAL_CERT				571
#define IDS_FORMAT_ENCRYPTEDHASH_COLON			572
#define IDS_FORMAT_PKCS7_ATTRIBUTE_COUNT		573
#define IDS_ATTRIBUTE					574
#define IDS_FORMAT_PKCS7_ATTRIBUTE_VALUE		575
#define IDS_BACKUPDB_USAGEARGS				576
#define IDS_BACKUPDB_DESCRIPTION			577
#define IDS_RESTOREDB_USAGEARGS				578
#define IDS_RESTOREDB_DESCRIPTION			579
#define IDS_CRL_REASON_UNSPECIFIED			580
#define IDS_CRL_REASON_KEY_COMPROMISE			581
#define IDS_CRL_REASON_CA_COMPROMISE			582
#define IDS_CRL_REASON_AFFILIATION_CHANGED		583
#define IDS_CRL_REASON_SUPERSEDED			584
#define IDS_CRL_REASON_CESSATION_OF_OPERATION		585
#define IDS_CRL_REASON_CERTIFICATE_HOLD			586
#define IDS_CRL_REASON_REMOVE_FROM_CRL			587
#define IDS_CSPLIST_DESCRIPTION			        588
#define IDS_CSPTEST_DESCRIPTION				589
#define IDS_CSPTEST_USAGEARGS				590
#define IDS_SILENT_DESCRIPTION				591
#define IDS_VIEW_ARGDESCRIPTION				592
#define IDS_GETCERT_USAGEARGS				593
#define IDS_DISP_ACTIVE					594
#define IDS_DISP_PENDING				595
#define IDS_DISP_ISSUED					596
#define IDS_DISP_REVOKED				597
#define IDS_DISP_ERROR					598
#define IDS_DISP_DENIED					599
#define IDS_RENEWALCERT					600
#define IDS_FORMAT_RESTORE_NEEDS_RESTART		601
#define IDS_ADMIN_INTERFACE_ALIVE			602
#define IDS_DB_OPEN_FAILURE				603
#define IDS_DB_ACCESS_STOP_SERVER			604
#define IDS_CONFIGDISPLAY_LOCAL				605
#define IDS_ERR_FORMAT_NO_LOCAL_CONFIG			606
#define IDS_CRL_REASON_UNREVOKE				607
#define IDS_ERROR_ACCESSDENIED_CAUSE                    608
#define IDS_NO_KEY_PROPERTY				609
#define IDS_FORMAT_SERVER_ALIVE				610
#define IDS_FORMAT_CONNECTING				611
#define IDS_USER_DESCRIPTION				612
#define IDS_FORMAT_DUMP_CERT_INDEX			613
#define IDS_NEWPASSWORDPROMPT				614
#define IDS_CONFIRMPASSWORDPROMPT			615
#define IDS_NOCONFIRMPASSWORD				616
#define IDS_NO_KEY					617
#define IDS_BACKUP_USAGEARGS				618
#define IDS_BACKUP_DESCRIPTION				619
#define IDS_RESTORE_USAGEARGS				620
#define IDS_RESTORE_DESCRIPTION 			621
#define IDS_ADDSTORE_USAGEARGS				622
#define IDS_ADDSTORE_DESCRIPTION			623
#define IDS_DELSTORE_USAGEARGS				624
#define IDS_DELSTORE_DESCRIPTION			625
#define IDS_VERIFYSTORE_USAGEARGS			626
#define IDS_VERIFYSTORE_DESCRIPTION			627
#define IDS_FORMAT_DELETE_CERT_INDEX			628
#define IDS_UNTRUSTED_ROOT				629
#define IDS_INCOMPLETE_CHAIN				630
#define IDS_CERT_VERIFIES				631
#define IDS_CR_DISP_INCOMPLETE				632
#define IDS_CR_DISP_ERROR				633
#define IDS_CR_DISP_DENIED				634
#define IDS_CR_DISP_ISSUED				635
#define IDS_CR_DISP_ISSUED_OUT_OF_BAND			636
#define IDS_CR_DISP_UNDER_SUBMISSION			637
#define IDS_CR_DISP_REVOKED				638
#define IDS_CERT_DISPOSITION_PENDING			639
#define IDS_ROOT_STORE_NEEDS_ROOT_CERT			640
#define IDS_FORCE_DESCRIPTION				641
#define IDS_FORMAT_USE_FORCE 				642
#define IDS_FORMAT_BACKEDUPDBNOFULL			643
#define IDS_FORMAT_BACKEDUPDBFULL			644
#define IDS_FORMAT_BACKEDUPDB				645
#define IDS_FORMAT_BACKEDUPDBKEEP			646
#define IDS_FORMAT_BACKEDUPDBNOKEEP			647
#define IDS_FORMAT_RESTOREDB				648
#define IDS_UNKNOWN_ATTRIBUTE				649
#define IDS_OIDNAME_USAGEARGS				650
#define IDS_OIDNAME_DESCRIPTION				651
#define IDS_UNKNOWN_OBJECTID				652
#define IDS_IMPORTCERT_USAGEARGS                        653
#define IDS_IMPORTCERT_DESCRIPTION                      654
#define IDS_FORMAT_IMPORTCERT                           655
#define IDS_REVOCATION_OFFLINE				656
#define IDS_NO_REVOCATION_CHECK				657
#define IDS_DYNAMICFILES_DESCRIPTION			658
#define IDS_GETREG_USAGEARGS				659
#define IDS_GETREG_DESCRIPTION				660
#define IDS_SETREG_USAGEARGS				661
#define IDS_SETREG_DESCRIPTION				662
#define IDS_OLD_REG_VALUE				663
#define IDS_NEW_REG_VALUE				664
#define IDS_FORMAT_ALTNAMECOUNT				665
#define IDS_ALTNAME					666
#define IDS_DATABASELOCATIONS_DESCRIPTION		667
#define IDS_FORMAT_INVALIDBACKUPDIR			668
#define IDS_FORMAT_INVALIDRESTOREDIR			669
#define IDS_FORMAT_BADBACKUPRESULTS			670
#define IDS_FORMAT_RESTOREDDBNOFULL			671
#define IDS_FORMAT_RESTOREDDBFULL			672
#define IDS_IMPORTEDCERT				673
#define IDS_NOWNOTBEFORE_ERROR				674
#define IDS_NOWNOTAFTER_ERROR				675
#define IDS_CANOTBEFORE_ERROR				676
#define IDS_CANOTAFTER_ERROR				677
#define IDS_TELETEX_EXTENSIONS				678
#define IDS_ERRCODE_USAGEARGS				679
#define IDS_ERRCODE_DESCRIPTION				680
#define IDS_VROOT_DESCRIPTION				681
#define IDS_FORMAT_VROOT				682
#define IDS_FORMAT_FILESHARE				683
#define IDS_VROOTDISP_CREATED				684
#define IDS_VROOTDISP_DELETED				685
#define IDS_VROOTDISP_EXISTS				686
#define IDS_VROOTDISP_NOTFOUND				687
#define IDS_VROOTDISP_CREATEERROR			688
#define IDS_VROOTDISP_DELETERROR			689
#define IDS_VROOTDISP_NOTSUPPORTED			690
#define IDS_VROOT_USAGEARGS				691
#define IDS_BACKUPPROGRESSDB				692
#define IDS_BACKUPPROGRESSLOG				693
#define IDS_BACKUPPROGRESSTRUNCATELOG			694
#define IDS_RESTOREPROGRESSDB				695
#define IDS_RESTOREPROGRESSLOG				696
#define IDS_MAXINDEX					697
#define IDS_DISP_CA_CERT				698
#define IDS_DISP_CA_CERT_CHAIN				699
#define IDS_CHARS					700
#define IDS_OVERFLOW					701
#define IDS_FORMAT_USAGE_REPEATEDNAMEDARG		702
#define IDS_INCOMPLETE_CONFIG				703
#define IDS_DSPUBLISH_ARGDESCRIPTION			704
#define IDS_DB_ACCESS_INSTALL_SERVER			705
#define IDS_RED_CONNECTING				706
#define IDS_RED_CONNECT_FAIL				707
#define IDS_RED_CROW_CONVERT				708
#define IDS_RED_CROW_DUP				709
#define IDS_RED_CROW_BADCA				710
#define IDS_RED_ROWID					711
#define IDS_RED_SKIP_DUP				712
#define IDS_RED_SKIP_BADCA				713
#define IDS_RED_ROW_MAP					714
#define IDS_RED_BEGIN_NAMES				715
#define IDS_RED_END_NAMES				716
#define IDS_GETMAPI_DESCRIPTION				717
#define IDS_SETMAPI_USAGEARGS				718
#define IDS_SETMAPI_DESCRIPTION				719
#define IDS_VIEW_ROWS					720
#define IDS_VIEW_ROWPROPERTIES				721
#define IDS_VIEW_ATTRIBUTES				722
#define IDS_VIEW_EXTENSIONS				723
#define IDS_VIEW_TOTALFIELDS				724
#define IDS_VIEW_STATS					725
#define IDS_PRIVATE_KEY_NOT_EXPORTABLE                  726
#define IDS_ENTERPRISE_ROOT                             727
#define IDS_ENTERPRISE_SUB                              728
#define IDS_STANDALONE_ROOT                             729
#define IDS_STANDALONE_SUB                              730
#define IDS_CATYPE_UNKNOWN                              731
#define IDS_RENEWCERT_USAGEARGS				732
#define IDS_RENEWCERT_DESCRIPTION			733
#define IDS_FORMAT_CERTHASH_COLON			734
#define IDS_FORMAT_MESSAGE_TEXT				735
#define IDS_FORMAT_DUMP_CRL_INDEX			736
#define IDS_FORMAT_DELETE_CRL_INDEX			737
#define IDS_FORMAT_CCACERTS				738
#define IDS_KEYS					739
#define IDS_VALUES					740
#define IDS_FORMAT_LOADTESTCRL				741
#define IDS_CRL						742
#define IDS_NOWNOTBEFORECRL_ERROR			743
#define IDS_NOWNOTAFTERCRL_ERROR			744
#define IDS_CANOTBEFORECRL_ERROR			745
#define IDS_CANOTAFTERCRL_ERROR				746
#define IDS_ISSUINGCA_CRLSUBJECT_NOT_ISSUER		747
#define IDS_ISSUINGCA_CRLSUBJECT_IS_ISSUER		748
#define IDS_ERR_CA_SIG_NOT_CRLISSUER			749
#define IDS_CRL_SIG_OK					750
#define IDS_KEYID_IS_KEYAUTHORITY			751
#define IDS_ERR_KEYID_NOT_KEYAUTHORITY			752
#define IDS_NO_KEYID					753
#define IDS_CADISP_INCOMPLETE				754
#define IDS_CADISP_ERROR				755
#define IDS_CADISP_ERROR_CRL				756
#define IDS_CADISP_REVOKED				757
#define IDS_CADISP_VALID				758
#define IDS_CADISP_EXPIRED				759
#define IDS_CADISP_UNDERSUBMISSION			760
#define IDS_CADISP_UNKNOWN				761
#define IDS_KEY_USAGEARGS				762
#define IDS_KEY_DESCRIPTION				763
#define IDS_DELKEY_USAGEARGS				764
#define IDS_DELKEY_DESCRIPTION				765
#define IDS_REVOKED_CERT				766
#define IDS_PROP_CACERSTATUSCODE			767
#define IDS_CONFIGDISPLAY_FLAGS_COLON			768
#define IDS_ERR_PRIVATEKEY_MISMATCH			769
#define IDS_SIGNATURE_OK				770
#define IDS_SIGNATURE_BAD				771
#define IDS_DSCERT_DESCRIPTION				772
#define IDS_DSCERT_USAGEARGS				773
#define IDS_DSCRL_DESCRIPTION				774
#define IDS_DSCRL_USAGEARGS				775
#define IDS_DS_USAGEARGS				776
#define IDS_DS_DESCRIPTION				777
#define IDS_DSDEL_USAGEARGS				778
#define IDS_DSDEL_DESCRIPTION				779
#define IDS_DELETING					780
#define IDS_CAINFO_USAGEARGS				781
#define IDS_CAINFO_DESCRIPTION				782
#define IDS_CAINFO_USAGEHEADERCOLON			783
#define IDS_CAINFO_USAGEERROR				784
#define IDS_CAINFO_USAGEINDEX				785
#define IDS_REQFLAGS_FORCEUTF8				786
#define IDS_FORMAT_SIGNATURE_UNUSEDBITS			787
#define IDS_CONFIGDISPLAY_SHORTNAME_COLON		788
#define IDS_CONFIGDISPLAY_SANITIZEDSHORTNAME_COLON	789
#define IDS_SMIME_CAPABILITIES				790
#define IDS_REQUEST_FILE_COLON				791
#define IDS_PKCS7ATTRIBUTE				792
#define IDS_NO_SIGNATURE				793
#define IDS_DUMP_CERTSEQ				794
#define IDS_MISSING_CERT				795
#define IDS_REQFLAGS_VALIDENCRYPTEDKEYHASH		796
#define IDS_SCHEMA_USAGE				797
#define IDS_VIEW_USAGE					798
#define IDS_DSDELTACRL_USAGEARGS			799
#define IDS_DSDELTACRL_DESCRIPTION			800
#define IDS_SECONDS_DESCRIPTION				801
#define IDS_NOBASICCONSTRAINTS2_ERROR			802
#define IDS_CANNOTDECODEBASICCONSTRAINTS2_ERROR		803
#define IDS_ENDENTITYCACERT_ERROR			804
#define IDS_CACERT					805
#define IDS_ENDENTITYCERT				806
#define IDS_FORMAT_ELEMENT				807
#define IDS_REQTYPE_CMC					808
#define IDS_ERR_FORMAT_BAD_CERT				809
#define IDS_ENCRYPTION_OK				810
#define IDS_ENCRYPTION_BAD				811
#define IDS_V1_DESCRIPTION				812
#define IDS_PROP_FILEVERSION				813
#define IDS_PROP_PRODUCTVERSION				814
#define IDS_PROP_EXITCOUNT				815
#define IDS_PROP_EXITDESCRIPTION			816
#define IDS_PROP_POLICYDESCRIPTION			817
#define IDS_PROP_CANAME					818
#define IDS_PROP_SANITIZEDCANAME			819
#define IDS_PROP_SHAREDFOLDER				820
#define IDS_PROP_CATYPE					821
#define IDS_PROP_PARENTCA				822
#define IDS_PROP_CASIGCERTCOUNT				823
#define IDS_PROP_CASIGCERT				824
#define IDS_PROP_CASIGCERTCHAIN				825
#define IDS_PROP_CAXCHGCERTCOUNT			826
#define IDS_PROP_CAXCHGCERT				827
#define IDS_PROP_CAXCHGCERTCHAIN			828
#define IDS_PROP_BASECRL				829
#define IDS_PROP_DELTACRL				830
#define IDS_PROP_CACERTSTATE				831
#define IDS_PROP_CRLSTATE				832
#define IDS_PROP_CAINFO					833
#define IDS_CAPROPINFO_DESCRIPTION			834
#define IDS_ADMIN_DESCRIPTION				835
#define IDS_PROP_CAPROPIDMAX				836
#define IDS_GETCERT_DESCRIPTION				837
#define IDS_GETCERT_TITLE    				838
#define IDS_GETCERT_SUBTITLE				839
#define IDS_GETCERT_SUBTITLE_OBJID			840
#define IDS_GETCERT_SUBTITLE_ERA			841
#define IDS_GETCERT_SUBTITLE_KRA			842
#define IDS_FORMAT_KEYIDHASH_COLON			843
#define IDS_DUMP_CMC					844
#define IDS_DUMP_CMCRESPONSE				845
#define IDS_TAGGED_ATTRIBUTES				846
#define IDS_TAGGED_CONTENTINFO				847
#define IDS_TAGGED_REQUESTS				848
#define IDS_TAGGED_OTHERMESSAGES			849
#define IDS_UNKNOWN_REQUEST_CHOICE			850
#define IDS_BODY_PART_ID				851
#define IDS_ERR_FORMAT_LOADKEY				852
#define IDS_EXPIRED_CERT				853
#define IDS_DUMP_PKCS7_UNAUTHATTRIBUTES			854
#define IDS_DUMP_PKCS7_CONTENT_TYPE			855
#define IDS_DATA_REFERENCE				856
#define IDS_CERT_REFERENCE				857
#define IDS_VALUE					858
#define IDS_UNKNOWN_TAGGED_ATTRIBUTE			859
#define IDS_DUMP_PKCS7_SIGNER_COUNT			860
#define IDS_SIGNER_INFO					861
#define IDS_HASH_ALGORITHM				862
#define IDS_HASH_ENCRYPTION_ALGORITHM			863
#define IDS_FORMAT_STORED_HASH_COLON			864
#define IDS_FORMAT_COMPUTED_HASH_COLON			865
#define IDS_CMCATTRIBUTE				866
#define IDS_EXCHANGEAIA					867
#define IDS_EXCHANGEVERSION				868
#define IDS_HASHFILE_USAGEARGS                          869
#define IDS_HASHFILE_DESCRIPTION                        870
#define IDS_FORMAT_HASHFILEOUTPUT                       871
#define IDS_REQFLAGS_CAXCHGCERT				872
#define IDS_PASS					873
#define IDS_DUMP_PKCS7_NO_RECIPIENT			874
#define IDS_DUMP_PKCS7_RECIPIENT_COUNT			875
#define IDS_RECIPIENT_INFO				876
#define IDS_PROP_DNSNAME				877
#define IDS_GETKEY_USAGEARGS				878
#define IDS_GETKEY_DESCRIPTION				879
#define IDS_RECOVERKEY_USAGEARGS			880
#define IDS_RECOVERKEY_DESCRIPTION			881
#define IDS_DUMP_USAGEARGS				882
#define IDS_DUMP_DECRYPTED				883
#define IDS_CANT_DECRYPT				884
#define IDS_NEED_RECOVERY_CERT				885
#define IDS_USER_CERT					886
#define IDS_ALGORITHM_CLASS				887
#define IDS_ALGORITHM_TYPE				888
#define IDS_ALGORITHM_SUBID				889
#define IDS_CMC_STATUS					890
#define IDS_BODY_REFERENCE				891
#define IDS_CMC_STATUSSTRING				892
#define IDS_CMC_OTHERCHOICE				893
#define IDS_CMC_FAILINFO				894
#define IDS_PENDTOKEN					895
#define IDS_PENDTIME					896
#define IDS_DSPUBLISH_USAGEARGS				897
#define IDS_DSPUBLISH_DESCRIPTION			898
#define IDS_FORMAT_LOADCERTORCRL			899
// Leave 900 to 1999 for clibres.h
#define IDS_BYTES					2000
#define IDS_FORMAT_ALREADY_IN_DS_STORE			2001
#define IDS_CERTIFICATE					2002
#define IDS_FORMAT_SUBJECTKEYID_COLON			2003
#define IDS_PRECOMPUTED					2004
#define IDS_CANNOT_CREATE_STORE				2005
#define IDS_CANNOT_OPEN_STORE				2006
#define IDS_REPAIRSTORE_USAGEARGS			2007
#define IDS_REPAIRSTORE_DESCRIPTION			2008
#define IDS_FORMAT_BIT_KEY				2009
#define IDS_DELREG_DESCRIPTION				2010
#define IDS_DETACHED_SIGNATURE				2011
#define IDS_EXPORTPFX_USAGEARGS				2012
#define IDS_EXPORTPFX_DESCRIPTION			2013
#define IDS_IMPORTPFX_USAGEARGS				2014
#define IDS_IMPORTPFX_DESCRIPTION			2015
#define IDS_DSTEMPLATE_USAGEARGS			2016
#define IDS_DSTEMPLATE_DESCRIPTION			2017
#define IDS_DSADDTEMPLATE_USAGEARGS			2018
#define IDS_DSADDTEMPLATE_DESCRIPTION			2019
#define IDS_CREATED_TEMPLATE				2020
#define IDS_UPDATED_TEMPLATE				2021
#define IDS_FORMAT_COMMAND_SUCCEEDED			2022
#define IDS_FORMAT_RESTART_SERVER			2023
#define IDS_TEMPLATE_USAGEARGS				2024
#define IDS_TEMPLATE_DESCRIPTION			2025
#define IDS_TEMPLATECAS_USAGEARGS			2026
#define IDS_TEMPLATECAS_DESCRIPTION			2027
#define IDS_CATEMPLATES_USAGEARGS			2028
#define IDS_CATEMPLATES_DESCRIPTION			2029
#define IDS_UT_DESCRIPTION				2030
#define IDS_MT_DESCRIPTION				2031
#define IDS_TEMPLATE_EXTENSIONS				2032
#define IDS_FORMAT_ENTER_PASSWORD_OUTPUT_FILE		2033
#define IDS_FORMAT_ENTER_PASSWORD			2034
#define IDS_NOCR_DESCRIPTION				2035
#define IDS_ENCODEHEX_USAGEARGS				2036
#define IDS_ENCODEHEX_DESCRIPTION			2037
#define IDS_FORMAT_ELEMENT_DUMP				2038
#define IDS_SPLIT_DESCRIPTION				2039
#define IDS_ENTERPRISE_DESCRIPTION			2040
#define IDS_EXPORTPVK_USAGEARGS				2041
#define IDS_EXPORTPVK_DESCRIPTION			2042
#define IDS_FORMAT_QUERYING				2043
#define IDS_PROP_ROLESEPARATIONENABLED			2044
#define IDS_ISSUANCE_POLICIES				2045
#define IDS_APPLICATION_POLICIES			2046
#define IDS_URLCACHE_USAGEARGS				2047
#define IDS_URLCACHE_DESCRIPTION			2048
#define IDS_PROP_KRACERTCOUNT				2049
#define IDS_PROP_KRACERTUSEDCOUNT			2050
#define IDS_PROP_KRACERT				2051
#define IDS_INVALID_OBJECTID				2052
#define IDS_DUMP_PKCS7CMS				2053
#define IDS_NO_DISPLAY_NAMES				2054
#define IDS_TYPE_MISMATCH				2055
#define IDS_LOCALIZEDNAME				2056
#define IDS_CSP_PROVIDER_INFO				2057
#define IDS_SIGN_USAGEARGS				2058
#define IDS_SIGN_DESCRIPTION				2059
#define IDS_SIGNINGSUBJECT				2060
#define IDS_DELETEROW_USAGEARGS				2061
#define IDS_DELETEROW_DESCRIPTION			2062
#define IDS_FORMAT_DELETED_ROW_COUNT			2063
#define IDS_FORMAT_DATE_REQUIRES_TABLE			2064
#define IDS_FORMAT_DATE_IN_FUTURE			2065
#define IDS_FORMAT_CRLHASH_COLON			2066
#define IDS_REQTYPE_CRLS				2067
#define IDS_REQTYPE_FULLRESPONSE			2068
#define IDS_PROP_CASIGCERTCRLCHAIN			2069
#define IDS_PROP_CAXCHGCERTCRLCHAIN			2070
#define IDS_PULSE_DESCRIPTION				2071
#define IDS_MACHINEINFO_USAGEARGS			2072
#define IDS_MACHINEINFO_DESCRIPTION			2073
#define IDS_FORMAT_MISSING_MACHINE_ATTRIBUTE		2074
#define IDS_GROUP_LIST_COLON				2075
#define IDS_DCINFO_USAGEARGS				2076
#define IDS_DCINFO_DESCRIPTION				2077
#define IDS_REMOTEENTROOT				2078
#define IDS_REMOTEKDCCERT				2079
#define IDS_DCUNAVAILABLE				2080
#define IDS_FORMAT_TESTINGDC				2081
#define IDS_FORMAT_DCROOTCERTS				2082
#define IDS_FORMAT_KDCCERTS				2083
#define IDS_UNKNOWN_PROPERTY				2084
#define IDS_TEMPLATE_NAME				2085
#define IDS_FORMAT_PUBLICKEY_LENGTH			2086
#define IDS_PROP_ADVANCEDSERVER				2087
#define IDS_PROP_BASECRLPUBLISHSTATUS			2088
#define IDS_PROP_DELTACRLPUBLISHSTATUS			2089
#define IDS_PROP_TEMPLATES				2090
#define IDS_FORMAT_PROVPARM				2091
#define IDS_FORMAT_PROVPARMFLAGS			2092
#define IDS_ARCHIVED					2093
#define IDS_ENTINFO_USAGEARGS				2094
#define IDS_ENTINFO_DESCRIPTION				2095
#define IDS_TCAINFO_DESCRIPTION				2096
#define IDS_FORMAT_DSSKEY_LENGTH			2097
#define IDS_FORMAT_DUMP_CTL_INDEX			2098
#define IDS_CLIENTID					2099
#define IDS_USERCOLON					2100
#define IDS_MACHINECOLON				2101
#define IDS_DUMP_CTL					2102
#define IDS_LISTID					2103
#define IDS_SEQUENCENO					2104
#define IDS_SUBJECT_ALGORITHM				2105
#define IDS_CTLENTRIES					2106
#define IDS_USAGEENTRIES				2107
#define IDS_FORMAT_SUBJECTID_COLON			2108
#define IDS_VIEWSTORE_TITLE				2109
#define IDS_VIEWSTORE_SUBTITLE				2110
#define IDS_VIEWSTORE_SUBTITLE_DELETE			2111
#define IDS_FORMAT_SAVED_CERT_NAME			2112
#define IDS_FORMAT_DELETED_CERT_NAME			2113
#define IDS_REQFLAGS_ENROLLONBEHALFOF			2114
#define IDS_SCINFO_USAGEARGS				2115
#define IDS_SCINFO_DESCRIPTION				2116
#define IDS_SERVICEPAUSED				2117
#define IDS_SERVICESTOPPED				2118
#define IDS_SERVICEUNKNOWNSTATE				2119
#define IDS_SMARTCARD_RUNNING				2120
#define IDS_SMARTCARD_NOTRUNNING			2121
#define IDS_SIGNATURE_NOTKEYEXCHANGE			2122
#define IDS_FORMAT_SERVER_DEAD				2123
#define IDS_GETDECRYPTCERT_SUBTITLE			2124
#define IDS_DISP_FOREIGN_CERT				2125
#define IDS_DISP_KRA_CERT				2126
#define IDS_UPN_COLON					2127
#define IDS_REQFLAGS_SUBJECTUNMODIFIED			2128
#define IDS_REQFLAGS_PUBLISHERROR			2129
#define IDS_NULL_SIGNATUREMATCHES			2130
#define IDS_FORMAT_SOURCE_URL				2131
#define IDS_FORMAT_LOCAL_FILENAME			2132
#define IDS_FORMAT_USE_COUNT				2133
#define IDS_FORMAT_HIT_RATE				2134
#define IDS_FORMAT_FILE_SIZE				2135
#define IDS_FORMAT_LAST_MOD_TIME_COLON			2136
#define IDS_FORMAT_EXPIRE_TIME_COLON			2137
#define IDS_FORMAT_LAST_ACCESS_TIME_COLON		2138
#define IDS_FORMAT_LAST_SYNC_TIME_COLON			2139
#define IDS_ERROR_CHECK_MACHINE_NAME			2140
#define IDS_ERROR_NO_TRAILING				2141
#define IDS_ISSUER_DOMAIN_POLICY			2142
#define IDS_SUBJECT_DOMAIN_POLICY			2143
#define IDS_FORMAT_MAP_ARRAY_COLON			2144
#define IDS_FORMAT_CERT_TYPE_NOT_DC			2145
#define IDS_FORMAT_CERT_USAGE_MISSING			2146
#define IDS_FORMAT_DELETE_DC_CERT			2147
#define IDS_FORMAT_DELETE_CERT_FROM_STORE_FAILED	2148
#define IDS_FORMAT_KDC_PATH				2149
#define IDS_NO_KDC_MY_STORE				2150
#define IDS_NO_KDC_ENT_STORE				2151
#define IDS_FORMAT_OPEN_REMOTE_MY_FAILED		2152
#define IDS_FORMAT_ERROR_GET_ARCHIVE_PROP		2153
#define IDS_LIST_ARCHIVED_CERT				2154
#define IDS_NO_AUTOENROLLED_CERT			2155 
#define IDS_FORMAT_OPEN_STORE_REMOTE_ENT_FAILED		2156
#define IDS_NO_AUTOENROLL_OBJECT			2157
#define IDS_NO_ACCESS					2158
#define IDS_URLFETCH_DESCRIPTION			2159
#define IDS_SCHEMA_ARGDESCRIPTION			2160
#define IDS_FORMAT_CA_EXPIRATION			2161
#define IDS_SUPPORTED_TEMPLATE				2162
#define IDS_NO_SUPPORTED_TEMPLATE			2163
#define IDS_FORMAT_CA_NAME_PROP_FAILED			2164
#define IDS_FORMAT_CA_NAME_LIST				2165
#define IDS_FORMAT_CA_DNS_PROP_FAILED			2166
#define IDS_FORMAT_CA_MACHINE_LIST			2167
#define IDS_FORMAT_CA_DS_LIST				2168
#define IDS_FORMAT_CERT_DN_PROP_FAILED			2169
#define IDS_FORMAT_CERT_DN_LIST				2170
#define IDS_FORMAT_CA_ALG_PROP_FAILED			2171
#define IDS_FORMAT_CA_ALG_LIST				2172
#define IDS_NO_ALG_UNEXPECTED				2173
#define IDS_NO_CT_FOR_CA				2174
#define IDS_NO_CT_BUT_EXISTS				2175
#define IDS_NO_CA_ON_DOMAIN				2176
#define IDS_NO_DFS					2177
#define IDS_DFS_DATA_ACCESS				2178
#define IDS_NO_ENTRY_IN_PING				2179
#define IDS_NO_DSPATH					2180
#define IDS_FORMAT_REG_QUERY_VALUE_FAILED		2181
#define IDS_NO_FILE_SYS_PATH				2182
#define IDS_DONE					2183
#define IDS_FORMAT_LDAP_NO_ENTRY			2184
#define IDS_ROOT_CERT_IN_POLICY				2185
#define IDS_FORMAT_CERT_COLON				2186
#define IDS_NO_ROOT_IN_POLICY				2187
#define IDS_CHECK_EVENT_LOG				2188
#define IDS_POLICY_MACHINE				2189
#define IDS_POLICY_USER					2190
#define IDS_POSSIBLE_NO_POLICY				2191
#define IDS_DC_DESCRIPTION				2192
#define IDS_DC_USAGE					2193
#define IDS_DISPLAYNAME_COLON				2194
#define IDS_FORMAT_COMPUTER_NAME			2195
#define IDS_FORMAT_USER_NAME				2196
#define IDS_BAD_OPTION					2197
#define IDS_FORMAT_MACHINE_LIST				2198
#define IDS_KEY_COLON					2199
#define IDS_FORMAT_GPO_NAME				2200
#define IDS_REQUEST_SIGNATUREMATCHES			2201
#define IDS_OUT_USAGE					2202
#define IDS_OUT_DESCRIPTION				2203
#define IDS_RESTRICT_USAGE				2204
#define IDS_RESTRICT_DESCRIPTION			2205
#define IDS_CONFIG_USAGE				2206
#define IDS_CONFIG_DESCRIPTION				2207
#define IDS_USAGE_LIST_VERBS				2208
#define IDS_FORMAT_USAGE_ONE_HELP			2209
#define IDS_USAGE_ALL_HELP				2210
#define IDS_IMPORT_CERT_FOREIGN				2211
#define IDS_IMPORT_CERT_DOMESTIC			2212
#define IDS_IMPORT_CERT_EXISTS				2213
#define IDS_IMPORT_KEY_REPLACED				2214
#define IDS_IMPORT_KEY_SAVED				2215
#define IDS_IMPORT_KEY_EXISTS				2216
#define IDS_IMPORT_CERT_SKIPPED_SIGNING			2217
#define IDS_KMS_USERS					2218
#define IDS_KMS_CERTS_SKIPPED				2219
#define IDS_KMS_CERTS_TOTAL				2220
#define IDS_KMS_CERTS_FOREIGN				2221
#define IDS_KMS_CERTS_ALREADYSAVED			2222
#define IDS_KMS_CERTS_SAVED				2223
#define IDS_KMS_CERTS_NOTSAVED				2224
#define IDS_KMS_KEYS_TOTAL				2225
#define IDS_KMS_KEYS_ALREADYSAVED			2226
#define IDS_KMS_KEYS_UPDATED				2227
#define IDS_KMS_KEYS_SAVED				2228
#define IDS_KMS_KEYS_NOTSAVED				2229
#define IDS_MERGEPFX_DESCRIPTION			2230
#define IDS_MERGEPFX_USAGEARGS				2231
#define IDS_ONLINE					2232
#define IDS_OFFLINE					2233
#define IDS_PREVIOUS_CA_CERT_HASH			2234
#define IDS_MESSAGE_DIGEST				2235
#define IDS_ARCHIVED_KEY_CERT_HASH			2236
#define IDS_ISSUED_CERT_HASH				2237
#define IDS_ENCRYPTED_KEY_HASH				2238
#define IDS_CRL_NUMBER					2239
#define IDS_MINIMUM_BASE_CRL_NUMBER			2240
#define IDS_VIRTUAL_BASE_CRL_NUMBER			2241
#define IDS_CRL_NEXT_PUBLISH				2242
#define IDS_SIGNING_TIME				2243
#define IDS_FRESHEST_CRL_CDP				2244
#define IDS_CRL_SELF_CDP				2245
#define IDS_APPLICATION_CERT_POLICIES			2246
#define IDS_APPLICATION_POLICY_MAPPINGS			2247
#define IDS_APPLICATION_POLICY_CONSTRAINTS		2248
#define IDS_POLICY_MAPPINGS				2249
#define IDS_POLICY_CONSTRAINTS				2250
#define IDS_COUNTER_SIGNATURE				2251
#define IDS_FORMAT_MACHINE_AND_ARCHIVED_CERTS		2252
#define IDS_FORMAT_FOR_DC				2253
#define IDS_V1_AUTOENROLLMENT_OBJECTS_COLON		2254
#define IDS_FORMAT_SKIP_CSP_ENUM			2255
#define IDS_PROVIDER_NAME_COLON				2256
#define IDS_PROVIDER_TYPE_COLON				2257
#define IDS_PRIVATEKEY_VERIFIES				2258
#define IDS_PROCESSING_KMS_EXPORTS_COLON		2259
#define IDS_USER_COLON					2260
#define IDS_ENCRYPTED_KEY_COLON				2261
#define IDS_DECRYPTED_KEY_COLON				2262
#define IDS_ERROR_SYMMETRIC_KEY				2263
#define IDS_SYMMETRIC_KEY_IMPORTED			2264
#define IDS_MOVED_SIGNATURE_KEY				2265
#define IDS_CERT_TYPES					2266
#define IDS_CERT_TYPE					2267
#define IDS_FORMAT_CAS_ON_DOMAIN			2268
#define IDS_CAENUMNEXTCA				2269
#define IDS_CACHED_LDAP_DC				2270
#define IDS_SCREADER_STATUS_COLON			2271
#define IDS_SC_USER_SCOPE				2272
#define IDS_SC_NO_LIST					2273
#define IDS_SC_LIST_FAILED				2274
#define IDS_SC_LIST_FAILED_NO_READERS			2275
#define IDS_SC_LIST_FAILED_GENERIC			2276
#define IDS_SC_READERS_COLON				2277
#define IDS_SC_MINUS_READER_COLON			2278
#define IDS_SC_MINUS_STATUS_COLON			2279
#define IDS_SC_STATUS_NO_CARD				2280
#define IDS_SC_STATUS_UNKNOWN				2281
#define IDS_SC_STATUS_BUSY				2282
#define IDS_SC_STATUS_SHARED				2283
#define IDS_SC_STATUS_AVAILABLE				2284
#define IDS_SC_STATUS_NO_RESPONSE			2285
#define IDS_SC_MINUS_CARD_COLON				2286
#define IDS_SC_UNKNOWN_CARD				2287
#define IDS_FORMAT_SC_TESTING_MATCH			2288
#define IDS_SC_SIZE_ZERO				2289
#define IDS_SC_KEYPROVINFO_KEY				2290
#define IDS_SC_CERT_KEY					2291
#define IDS_SC_KEY_MATCHES				2292
#define IDS_SC_BAD_CHAIN				2293
#define IDS_SC_GOOD_CHAIN				2294
#define IDS_FORMAT_SC_NO_KEY_COLON			2295
#define IDS_FORMAT_SC_CANNOT_OPEN_KEY_COLON		2296
#define IDS_FORMAT_SC_NO_CERT_COLON			2297
#define IDS_SC_VALIDATING_CHAIN				2298
#define IDS_FORMAT_SC_CERT_DISPLAYED_COLON		2299
#define IDS_SC_ANALYZING_CARD_COLON			2300
#define IDS_FORMAT_SC_CANNOT_GET_CSP			2301
#define IDS_DELETEROW_ARGDESCRIPTION			2302
#define IDS_ALL_POLICIES				2303
#define IDS_NO_POLICIES					2304
#define IDS_URL_OPEN_TITLE				2305
#define IDS_URL_FILE_FILTER				2306
#define IDS_URL_DEFAULT_EXT				2307
#define IDS_CONVERTEPF_DESCRIPTION			2308
#define IDS_CONVERTEPF_USAGEARGS			2309
#define IDS_ERR_CANNOT_FIND_MATCHING_OBJ		2310
#define IDS_GETKMSCACERT_TITLE				2311
#define IDS_GETKMSCACERT_SUBTITLE			2312
#define IDS_SETEXTENSION_ARGDESCRIPTION			2313
#define IDS_SIGN_ARGDESCRIPTION				2314
#define IDS_CAINFO_ARGDESCRIPTION			2315
#define IDS_SETREG_ARGDESCRIPTION			2316
#define IDS_CRL_ARGDESCRIPTION				2317
#define IDS_GETCRL_ARGDESCRIPTION			2318
#define IDS_VERIFY_ARGSDESCRIPTION			2319
#define IDS_VERIFYKEYS_ARGDESCRIPTION			2320
#define IDS_STORE_ARGDESCRIPTION			2321
#define IDS_ADDSTORE_ARGDESCRIPTION			2322
#define IDS_DELSTORE_ARGDESCRIPTION			2323
#define IDS_BACKUP_ARGDESCRIPTION			2324
#define IDS_BACKUPDB_ARGDESCRIPTION			2325
#define IDS_BACKUPPFX_ARGDESCRIPTION			2326
#define IDS_RESTORE_ARGDESCRIPTION			2327
#define IDS_RESTOREDB_ARGDESCRIPTION			2328
#define IDS_RESTOREPFX_ARGDESCRIPTION			2329
#define IDS_EXPORTPFX_ARGDESCRIPTION			2330
#define IDS_IMPORTPFX_ARGDESCRIPTION			2331
#define IDS_IMPORTKMS_ARGDESCRIPTION			2332
#define IDS_MERGEPFX_ARGDESCRIPTION			2333
#define IDS_CONVERTPFX_ARGDESCRIPTION			2334
#define IDS_SETATTRIBUTES_ARGDESCRIPTION		2335
#define IDS_REVOKE_ARGDESCRIPTION			2336
#define IDS_IMPORTCERT_ARGDESCRIPTION			2337
#define IDS_CACERT_ARGDESCRIPTION			2338
#define IDS_CACHAIN_ARGDESCRIPTION			2339
#define IDS_RENEWCERT_ARGDESCRIPTION			2340
#define IDS_URL_DESCRIPTION				2341
#define IDS_URL_USAGEARGS				2342
#define IDS_FORMAT_CERT_ALREADY_IN_STORE		2343
#define IDS_FORMAT_CERT_ADDED_TO_STORE			2344
#define IDS_FORMAT_CRL_ALREADY_IN_STORE			2345
#define IDS_FORMAT_CRL_ADDED_TO_STORE			2346
#define IDS_FORMAT_CTL_ALREADY_IN_STORE			2347
#define IDS_FORMAT_CTL_ADDED_TO_STORE			2348
#define IDS_GETKMSV1CACERT_TITLE			2349
#define IDS_GETKMSV1CACERT_SUBTITLE			2350
#define IDS_PROP_ERROR1					2351
#define IDS_PROP_ERROR2					2352
#define IDS_STATUS_RETRIEVING				2353
#define IDS_STATUS_SUCCESS				2354
#define IDS_STATUS_FAILURE				2355
#define IDS_STATUS_VERIFYING				2356
#define IDS_STATUS_VERIFICATION_FAILURE			2357
#define IDS_STATUS_NO_RETRIEVAL				2358
#define IDS_STATUS_ERROR				2359
#define IDS_STATUS_EXPIRED				2360
#define IDS_STATUS_WRONG_ISSUER				2361
#define IDS_STATUS_REVOKED				2362
#define IDS_STATUS_CANNOT_CHECK_REVOCATION 		2363
#define IDS_STATUS_NO_CRL				2364
#define IDS_STATUS_OK					2365
#define IDS_CDP_ITEM_TYPE				2366
#define IDS_AIA_ITEM_TYPE				2367
#define IDS_BASE_CRL_ITEM_TYPE				2368
#define IDS_DELTA_CRL_ITEM_TYPE				2369
#define IDS_CERT_ITEM_TYPE				2370
#define IDS_NO_ITEM_TYPE				2371
#define IDS_STATUS_COLUMN				2372
#define IDS_TYPE_COLUMN					2373
#define IDS_URL_COLUMN					2374
#define IDS_TIME_COLUMN					2375
#define IDS_GET_OBJECT_URL				2378
#define IDS_CERT_SUBJECT				2379
#define IDS_BASE_CRL_ISSUER				2380
#define IDS_DELTA_CRL_ISSUER				2381
#define IDS_NO_SELECTION				2382
#define IDS_NO_CERT_SELECTED				2383
#define IDS_OPEN_FILE_ERROR				2384
#define IDS_SELECT_CERT_OR_CRL				2385
#define IDS_ERROR_INFO					2386
#define IDS_FORMAT_URL_RETRIEVE_ERROR			2387
#define IDS_FORMAT_URL_EXTRACT_ERROR			2388
#define IDS_CANNOT_FIND_EPF_CA_CERT			2389
#define IDS_GETKEY_ARGDESCRIPTION			2390
#define IDS_FORMAT_DELETED_FROM_DS_STORE		2391
#define IDS_PROP_CAFORWARDCROSSCERTSTATE		2392
#define IDS_PROP_CABACKWARDCROSSCERTSTATE		2393
#define IDS_PROP_CAFORWARDCROSSCERT			2394
#define IDS_PROP_CABACKWARDCROSSCERT			2395
#define IDS_PROP_KRACERTSTATE				2396
#define IDS_KRADISP_NOTFOUND				2397
#define IDS_KRADISP_INVALID				2398
#define IDS_KRADISP_UNTRUSTED				2399
#define IDS_KRADISP_NOTLOADED				2400
#define IDS_REQFLAGS_CACROSSCERT			2401
#define IDS_SYSLANGID_COLON				2402
#define IDS_FORMAT_RECOVER_VERSIONX_KEYS_COLON		2403
#define IDS_WEAKPFX_DESCRIPTION				2404
#define IDS_CERT_SIG_OK					2405
#define IDS_KEY_USAGE_COUNT				2406
#define IDS_KEY_USAGE_COUNT_DISABLED			2407
#define IDS_KEY_USAGE_COUNT_NOTSUPPORTED		2408
#define IDS_PROP_CACERTVERSION				2409
#define IDS_VROOTDISP_ENABLEDASP			2410
#define IDS_VROOTDISP_ASPALREADYENABLED			2411
#define IDS_VROOTDISP_ENABLEASPERROR			2412
#define IDS_CERT_TYPE_MISSING				2413
#define IDS_PROP_SANITIZEDCASHORTNAME			2414
#define IDS_FORMAT_DELETED_WININETCACHE			2415
#define IDS_FORMAT_WININETCACHE				2416
#define IDS_PERMITTED					2417
#define IDS_EXCLUDED					2418
#define IDS_IPADDRESS					2419
#define IDS_MASK					2420
#define IDS_URLCACHE_ARGDESCRIPTION			2421
#define IDS_SUBTREE					2422
#define IDS_RELATED_CERTS_COLON				2423
#define IDS_RELATED_CRLS_COLON				2424
#define IDS_EXACT_MATCH_COLON				2425
#define IDS_PROTECT_DESCRIPTION				2426
#define IDS_SETCATEMPLATES_DESCRIPTION			2427
#define IDS_SETCATEMPLATES_USAGEARGS			2428
#define IDS_ADDING					2429
#define IDS_REMOVING					2430
#define IDS_ALREADYPRESENT				2431
#define IDS_NOTPRESENT					2432
#define IDS_KMSEXPORT_SIG_OK				2433
#define IDS_PROP_AUTOENROLL				2434
#define IDS_REQUESTID					2435
#define IDS_CADNSNAME					2436
#define IDS_FRIENDLYNAME				2437
#define IDS_TOKENMATCH					2438
#define IDS_BAD_ASN_LENGTH				2439
#define IDS_FORMAT_ASN_EXTRA				2440
#define IDS_FORMAT_VERIFIES_AGAINST_CERT		2441
#define IDS_FORMAT_NO_MATCH_CERT			2442
#define IDS_EXPECTED					2443
#define IDS_PUBLIC_KEY_COLON				2444
#define IDS_CERT_PUBLIC_KEY_COLON			2445
#define IDS_CERTS					2446
#define IDS_SIGNING					2447
#define IDS_EXCHANGE					2448
#define IDS_FORMAT_LOADCACERTCROSSED			2449
#define IDS_CROSSEDCACERT				2450
#define IDS_CROSSEDCACERT_SERIAL			2451
#define IDS_CROSEDGCA_SUBJECT_IS_SUBJECT		2452
#define IDS_CROSSEDCA_SUBJECT_NOT_SUBJECT		2453
#define IDS_CROSEDGCA_NOT_IS_PUBLICKEY			2454
#define IDS_CROSEDGCA_NOT_PUBLICKEY			2455
#define IDS_CROSSEDKEYID_IS_KEYID			2456
#define IDS_CROSSEDKEYID_NOT_KEYID			2457
#define IDS_CACERTEXT					2458
#define IDS_CANONICALIZED				2459
#define IDS_ERROR_EXTENSION_MISSING			2460
#define IDS_STATUS_VERIFIED				2461
#define IDS_STATUS_BAD_CA_CERT_SUBJECT			2462
#define IDS_STATUS_BAD_CERT_ISSUER			2463
#define IDS_STATUS_OLD_BASE_CRL				2464
#define IDS_STATUS_BAD_AKI				2465
#define IDS_STATUS_BAD_IDP				2466
#define IDS_CRLISSUER_NOT_EEISSUER			2467
#define IDS_CRLISSUER_IS_EEISSUER			2468
#define IDS_CSP_DESCRIPTION			        2469
#define IDS_CRL_IDP_MISMATCH				2470
#define IDS_CRLISSUER_NOT_DELTAISSUER			2471
#define IDS_CRLISSUER_IS_DELTAISSUER			2472
#define IDS_CRLNAMEID_NOT_CERTNAMEID			2473
#define IDS_CRLNAMEID_NOT_DELTANAMEID			2474
#define IDS_CRL_MINBASE_MISMATCH			2475
#define IDS_CRL_NOT_BASE				2476
#define IDS_CRL_NOT_DELTA				2477
#define IDS_VERIFYING_ISSUED_CERT			2478
#define IDS_VERIFYING_DELTA_CRL				2479
#define IDS_FORMAT_DELETED_WINHTTPCACHE			2480
#define IDS_FORMAT_WINHTTPCACHE				2481
#define IDS_FORMAT_META_FILENAME			2482
#define IDS_WININET_CACHE_ENTRY_COLON			2483
#define IDS_WINHTTP_CACHE_ENTRY_COLON			2484
#define IDS_CANAME					2485
#define IDS_MACHINENAME					2486
#define IDS_TIME_COLON					2487
#define IDS_CERT_AIA					2488
#define IDS_CERT_CDP					2489
#define IDS_BASECRL_CDP					2490
#define IDS_TIMEOUT_DESCRIPTION				2491
#define IDS_TIMEOUT_USAGE				2492

#define IDD_URLTESTDLG                  		3000
#define IDC_URLLIST                     		3001
#define IDC_RETRIEVE                    		3002
#define IDC_SELECT	                  		3003
#define IDC_RETRIEVECRLS                		3004
#define IDC_RETRIEVECERTS               		3005
#define IDC_RETRIEVECROSSCERTS          		3006
#define IDC_SIMPLENAME                    		3007
#define IDC_TIMEOUT                     		3008
#define IDC_DOWNLOADURL                 		3009
#define IDC_CHK_LDAPSIGN                		3010
#define IDC_SUBJECTTYPE					3011
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\scinfo.cpp ===
//+-------------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (C) Microsoft Corporation, 1996 - 2001
//
// File:       scinfo.cpp
//
// Abstract:
//
// This application is used to provide a snapshot of the Calais (Smart Card
// Resource Manager) service's status, and to display certificates on smart
// cards via the common WinNT UI.
//
// SCInfo -- describes the RM status and displays each available sc cert(s)
//
// The following options are always enabled:
//	Readername	-- for just one reader
//	-sig		-- display signature key certs only
//	-ex		-- display exchange key certs only
//	-nocert		-- don't look for certs to display
//	-key		-- verify keyset public key matches cert public key
//
// Author: Amanda Matlosz (AMatlosz) 07/14/1998
//
// Environment: Win32 Console App
//
// Notes: For use in NT5 public key rollout testing
//
// Need to include the following libs:
//	winscard.lib
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <winscard.h>
#include <winsvc.h>
#include <cryptui.h>

#include "cscsp.h"

#define __dwFILE__	__dwFILE_CERTUTIL_SCINFO_CPP__


#define wszSCARDSERVICE	L"SCardSvr"


//+-------------------------------------------------------------------------
// IsSCardSvrRunning checks the registry and queries the service for status
//--------------------------------------------------------------------------

HRESULT
IsSCardSvrRunning()
{
    HRESULT hr;
    WCHAR const *pwszError = NULL;
    UINT idmsg = IDS_SMARTCARD_NOTRUNNING; // "The Microsoft Smart Card Resource Manager is not running."

    HANDLE hSCardSvrStarted = NULL;
    HMODULE hDll = GetModuleHandle(L"winscard.dll");

    typedef HANDLE (WINAPI FNSCARDACCESSSTARTEDEVENT)(VOID);
    FNSCARDACCESSSTARTEDEVENT *pfnSCardAccessStartedEvent;

    pfnSCardAccessStartedEvent = (FNSCARDACCESSSTARTEDEVENT *)
			    GetProcAddress(hDll, "SCardAccessStartedEvent");

    if (NULL == pfnSCardAccessStartedEvent)
    {
	hr = myHLastError();
	pwszError = L"GetProcAddress";
	_JumpErrorStr(hr, error, "GetProcAddress", L"SCardAccessStartedEvent");
    }
    hSCardSvrStarted = (*pfnSCardAccessStartedEvent)();
    if (NULL == hSCardSvrStarted)
    {
	hr = myHLastError();
	if (S_OK == hr)
	{
	    hr = E_HANDLE;
	}
	pwszError = L"SCardAccessStartedEvent";
	_JumpError(hr, error, "SCardAccessStartedEvent");
    }
    hr = WaitForSingleObject(hSCardSvrStarted, 1000);
    if (WAIT_OBJECT_0 != hr)
    {
	hr = myHError(hr);
	pwszError = L"WaitForSingleObject";
	_JumpError(hr, error, "WaitForSingleObject");
    }
    idmsg = IDS_SMARTCARD_RUNNING; // "The Microsoft Smart Card Resource Manager is running."
    hr = S_OK;

error:

    // Display status

    wprintf(myLoadResourceString(idmsg));
    wprintf(wszNewLine);
    if (S_OK != hr)
    {
	// IDS_SERVICEPAUSED; // "Service is paused."
	// IDS_SERVICESTOPPED; // "Service is stopped."
	cuPrintErrorAndString(
		pwszError,
		IDS_SERVICEUNKNOWNSTATE, // "Service is in an unknown state."
		hr,
		NULL);
    }
    return(hr);
}


VOID
FreeReaderList(
    IN SCARDCONTEXT hSCard,
    IN WCHAR *pwszzReaderNameAlloc,
    IN SCARD_READERSTATE *prgReaderState)
{
    if (NULL != hSCard)
    {
	if (NULL != pwszzReaderNameAlloc)
	{
	    SCardFreeMemory(hSCard, pwszzReaderNameAlloc);
	}
        SCardReleaseContext(hSCard);
    }
    if (NULL != prgReaderState)
    {
	LocalFree(prgReaderState);
    }
}


//+-------------------------------------------------------------------------
// BuildReaderList tries to set *phSCard and get a list of currently available
// smart card readers.
//--------------------------------------------------------------------------

HRESULT
BuildReaderList(
    OPTIONAL IN WCHAR const *pwszReaderName,
    OUT SCARDCONTEXT *phSCard,
    OUT WCHAR **ppwszzReaderNameAlloc,
    OUT SCARD_READERSTATE **pprgReaderState,
    OUT DWORD *pcReaders)
{
    HRESULT hr;
    DWORD i;
    DWORD dwAutoAllocate;
    SCARDCONTEXT hSCard = NULL;
    WCHAR *pwszzReaderNameAlloc = NULL;
    SCARD_READERSTATE *prgReaderState = NULL;
    DWORD cReaders;

    *phSCard = NULL;
    *ppwszzReaderNameAlloc = NULL;
    *pcReaders = 0;
    *pprgReaderState = NULL;

    wprintf(myLoadResourceString(IDS_SCREADER_STATUS_COLON));
    wprintf(wszNewLine);

    // Acquire global SCARDCONTEXT from resource manager if possible

    hr = SCardEstablishContext(SCARD_SCOPE_USER, NULL, NULL, &hSCard);
    if (S_OK != hr)
    {
	cuPrintAPIError(L"SCardEstablishContext", hr);
	wprintf(myLoadResourceString(IDS_SC_USER_SCOPE));
	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_SC_NO_LIST));
	wprintf(wszNewLine);
	_JumpError(hr, error, "SCardEstablishContext");
    }

    // Build a readerstatus array from either a list of readers; or use the one
    // the user specified

    cReaders = 1;
    if (NULL == pwszReaderName)
    {
	dwAutoAllocate = SCARD_AUTOALLOCATE;
	hr = SCardListReaders(
			    hSCard,
			    SCARD_DEFAULT_READERS,
			    (WCHAR *) &pwszzReaderNameAlloc,
			    &dwAutoAllocate);
	if (S_OK != hr)
	{
	    cuPrintAPIError(L"SCardListReaders", hr);
	    wprintf(myLoadResourceString(IDS_SC_LIST_FAILED));
	    wprintf(wszNewLine);

	    if (SCARD_E_NO_READERS_AVAILABLE == hr)
	    {
		wprintf(myLoadResourceString(IDS_SC_LIST_FAILED_NO_READERS));
	    }
	    else
	    {
		wprintf(myLoadResourceString(IDS_SC_LIST_FAILED_GENERIC));
	    }
	    wprintf(wszNewLine);
	    _JumpError(hr, error, "SCardListReaders");
	}

	// Build a readerstatus array...

	cReaders = 0;
	if (NULL != pwszzReaderNameAlloc)
	{
	    for (
		pwszReaderName = pwszzReaderNameAlloc;
		L'\0' != *pwszReaderName;
		pwszReaderName += wcslen(pwszReaderName) + 1)
	    {
		cReaders++;
	    }
	}
	pwszReaderName = pwszzReaderNameAlloc;
    }
    prgReaderState = (SCARD_READERSTATE *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cReaders * sizeof(**pprgReaderState));
    if (NULL == prgReaderState)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    wprintf(myLoadResourceString(IDS_SC_READERS_COLON));
    wprintf(L" %u\n", cReaders);
    for (i = 0; i < cReaders; i++)
    {
	wprintf(L"  %u: %ws\n", i, pwszReaderName);
	prgReaderState[i].szReader = const_cast<WCHAR *>(pwszReaderName);
	prgReaderState[i].dwCurrentState = SCARD_STATE_UNAWARE;
	pwszReaderName += wcslen(pwszReaderName) + 1;
    }

    // ...And get the reader status from the resource manager

    hr = SCardGetStatusChange(
			hSCard,
			INFINITE,	// hardly
			prgReaderState,
			cReaders);
    if (S_OK != hr)
    {
	cuPrintAPIError(L"SCardGetStatusChange", hr);
	_JumpError(hr, error, "SCardGetStatusChange");
    }
    *phSCard = hSCard;
    hSCard = NULL;

    *ppwszzReaderNameAlloc = pwszzReaderNameAlloc;
    pwszzReaderNameAlloc = NULL;

    *pprgReaderState = prgReaderState;
    prgReaderState = NULL;

    *pcReaders = cReaders;
    hr = S_OK;

error:
    FreeReaderList(hSCard, pwszzReaderNameAlloc, prgReaderState);
    return(hr);
}


//+-------------------------------------------------------------------------
// DisplayReaderList displays the status for a list of readers.
//--------------------------------------------------------------------------

HRESULT
DisplayReaderList(
    IN SCARDCONTEXT hSCard,
    IN SCARD_READERSTATE const *prgReaderState,
    IN DWORD cReaders)
{
    HRESULT hr;
    DWORD i;
    DWORD dwAutoAllocate;
    UINT idsMsg;

    // Display all reader information

    for (i = 0; i < cReaders; i++)
    {
	DWORD dwState;
	WCHAR const *pwszSep;
	static WCHAR const s_wszSep[] = L" | ";

	//--- reader: readerName

	wprintf(myLoadResourceString(IDS_SC_MINUS_READER_COLON));
	wprintf(L" %ws\n", prgReaderState[i].szReader);

	//--- status: /bits/

	wprintf(myLoadResourceString(IDS_SC_MINUS_STATUS_COLON));
	dwState = prgReaderState[i].dwEventState;

	pwszSep = L" ";
	if (SCARD_STATE_UNKNOWN & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_UNKNOWN", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_UNAVAILABLE & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_UNAVAILABLE", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_EMPTY & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_EMPTY", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_PRESENT & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_PRESENT", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_EXCLUSIVE & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_EXCLUSIVE", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_INUSE & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_INUSE", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_MUTE & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_MUTE", pwszSep);
	    pwszSep = s_wszSep;
	}
	if (SCARD_STATE_UNPOWERED & dwState)
	{
	    wprintf(L"%wsSCARD_STATE_UNPOWERED", pwszSep);
	}
	wprintf(wszNewLine);

	//--- status: what scstatus would say

	// NO CARD

	if (SCARD_STATE_EMPTY & dwState)	// SC_STATUS_NO_CARD
	{
	    idsMsg = IDS_SC_STATUS_NO_CARD;
	}

	// CARD in reader: SHARED, EXCLUSIVE, FREE, UNKNOWN ?

	else
	if (SCARD_STATE_PRESENT & dwState)
	{
	    if (SCARD_STATE_MUTE & dwState)	// SC_STATUS_UNKNOWN
	    {
		idsMsg = IDS_SC_STATUS_UNKNOWN;
	    }
	    else
	    if (SCARD_STATE_INUSE & dwState)
	    {
		if (dwState & SCARD_STATE_EXCLUSIVE & dwState)
		{
		    // SC_STATUS_EXCLUSIVE

		    idsMsg = IDS_SC_STATUS_BUSY;
		}
		else				// SC_STATUS_SHARED
		{
		    idsMsg = IDS_SC_STATUS_SHARED;
		}
	    }
	    else				// SC_SATATUS_AVAILABLE
	    {
		idsMsg = IDS_SC_STATUS_AVAILABLE;
	    }
	}
	// READER ERROR: at this point, something's gone wrong
	else	// SCARD_STATE_UNAVAILABLE & dwState -- SC_STATUS_ERROR
	{

	    idsMsg = IDS_SC_STATUS_NO_RESPONSE;
	}
	wprintf(myLoadResourceString(IDS_SC_MINUS_STATUS_COLON));
	wprintf(L" ");
	wprintf(myLoadResourceString(idsMsg));
	wprintf(wszNewLine);

	// card name(s):

	wprintf(myLoadResourceString(IDS_SC_MINUS_CARD_COLON));
	if (0 < prgReaderState[i].cbAtr)
	{
	    WCHAR *pwszCardName = NULL;

	    // Get the name of the card

	    dwAutoAllocate = SCARD_AUTOALLOCATE;
	    hr = SCardListCards(
			    hSCard,
			    prgReaderState[i].rgbAtr,
			    NULL,
			    0,
			    (WCHAR *) &pwszCardName,
			    &dwAutoAllocate);
	    if (S_OK != hr || NULL == pwszCardName)
	    {
		wprintf(L" ");
		wprintf(myLoadResourceString(IDS_SC_UNKNOWN_CARD));
	    }
	    else
	    {
		WCHAR const *pwszName;

		pwszSep = L"";
		for (
		    pwszName = pwszCardName;
		    L'\0' != *pwszName;
		    pwszName += wcslen(pwszName) + 1)
		{
		    wprintf(L"%ws %ws", pwszSep, pwszName);
		    pwszSep = L",";
		}
	    }
	    if (NULL != pwszCardName)
	    {
		SCardFreeMemory(hSCard, pwszCardName);
	    }
	}
	wprintf(wszNewLine);
    }
    hr = S_OK;

//error:
    return(hr);
}


HRESULT
myCryptGetProvParamToUnicode(
    IN HCRYPTPROV hProv,
    IN DWORD dwParam,
    OUT WCHAR **ppwszOut,
    IN DWORD dwFlags)
{
    HRESULT hr;
    char *psz = NULL;
    DWORD cb;

    *ppwszOut = NULL;
    if (!CryptGetProvParam(hProv, dwParam, NULL, &cb, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetProvParam");
    }

    psz = (char *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == psz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (!CryptGetProvParam(hProv, dwParam, (BYTE *) psz, &cb, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetProvParam");
    }

    if (!myConvertSzToWsz(ppwszOut, psz, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertSzToWsz");
    }
    hr = S_OK;

error:
    if (NULL != psz)
    {
        LocalFree(psz);
    }
    return(hr);
}


//+-------------------------------------------------------------------------
// GetCertContext -- called by DisplayCerts
//--------------------------------------------------------------------------

HRESULT
GetCertContext(
    IN HCRYPTPROV hProv,
    IN HCRYPTKEY hKey,
    IN DWORD dwKeySpec,
    IN WCHAR const *pwszKeyType,
    OUT CERT_CONTEXT const **ppCert)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    CERT_PUBLIC_KEY_INFO *pKey = NULL;
    CRYPT_KEY_PROV_INFO KeyProvInfo;
    WCHAR *pwszContainerName = NULL;
    WCHAR *pwszProvName = NULL;
    BYTE *pbCert = NULL;
    DWORD cbCert;
    DWORD cbKey;

    *ppCert = NULL;

    // Get the cert from this key

    if (!CryptGetKeyParam(hKey, KP_CERTIFICATE, NULL, &cbCert, 0))
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) != hr)
        {
            _JumpError(hr, error, "CryptGetKeyParam");
        }
    }
    pbCert = (BYTE *) LocalAlloc(LMEM_FIXED, cbCert);
    if (NULL == pbCert)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (!CryptGetKeyParam(hKey, KP_CERTIFICATE, pbCert, &cbCert, 0))
    {
        hr = myHLastError();
	_JumpError(hr, error, "CryptGetKeyParam");
    }

    // Convert the certificate into a Cert Context.

    pCert = CertCreateCertificateContext(
				    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				    pbCert,
				    cbCert);
    if (NULL == pCert)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertCreateCertificateContext");
    }

    // Perform public key check

    wprintf(wszNewLine);
    wprintf(myLoadResourceString(IDS_FORMAT_SC_TESTING_MATCH), pwszKeyType);
    wprintf(wszNewLine);

    if (!CryptExportPublicKeyInfo(
		    hProv,
		    dwKeySpec,
		    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
		    NULL,
		    &cbKey))		// in, out
    {
	hr = myHLastError();
	cuPrintAPIError(L"CryptExportPublicKeyInfo", hr);
	_JumpError(hr, error, "CryptExportPublicKeyInfo");
    }
    if (0 == cbKey)
    {
	hr = SCARD_E_UNEXPECTED;	// huh?
	wprintf(
	    myLoadResourceString(IDS_SC_SIZE_ZERO),
	    L"CryptExportPublicKeyInfo");
	wprintf(wszNewLine);
	_JumpError(hr, error, "zero info size");
    }

    pKey = (CERT_PUBLIC_KEY_INFO *) LocalAlloc(LMEM_FIXED, cbKey);
    if (NULL == pKey)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!CryptExportPublicKeyInfo(
			    hProv,
			    dwKeySpec,
			    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			    pKey,
			    &cbKey))
    {
	hr = myHLastError();
	cuPrintAPIError(L"CryptExportPublicKeyInfo", hr);
	_JumpError(hr, error, "CryptExportPublicKeyInfo");
    }

    if (!CertComparePublicKeyInfo(
	  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
	  pKey,			// from the private keyset
	  &pCert->pCertInfo->SubjectPublicKeyInfo))	// cert public key
    {
	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_SC_KEYPROVINFO_KEY));
	wprintf(wszNewLine);
	cuDumpPublicKey(pKey);

	wprintf(wszNewLine);
	wprintf(myLoadResourceString(IDS_SC_CERT_KEY));
	wprintf(wszNewLine);
	cuDumpPublicKey(&pCert->pCertInfo->SubjectPublicKeyInfo);

	// by design, CertComparePublicKeyInfo doesn't set last error!

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "CertComparePublicKeyInfo");
    }
    wprintf(myLoadResourceString(IDS_SC_KEY_MATCHES));
    wprintf(wszNewLine);

    // Associate cryptprovider w/ the private key property of this cert
    // ... need the container name

    hr = myCryptGetProvParamToUnicode(
			hProv,
			PP_CONTAINER,
			&pwszContainerName,
			0);
    _JumpIfError(hr, error, "myCryptGetProvParamToUnicode");

    //  ... need the provider name

    hr = myCryptGetProvParamToUnicode(hProv, PP_NAME, &pwszProvName, 0);
    _JumpIfError(hr, error, "myCryptGetProvParamToUnicode");

    // Set the cert context properties to reflect the prov info

    KeyProvInfo.pwszContainerName = pwszContainerName;
    KeyProvInfo.pwszProvName = pwszProvName;
    KeyProvInfo.dwProvType = PROV_RSA_FULL;
    KeyProvInfo.dwFlags = CERT_SET_KEY_CONTEXT_PROP_ID;
    KeyProvInfo.cProvParam = 0;
    KeyProvInfo.rgProvParam = NULL;
    KeyProvInfo.dwKeySpec = dwKeySpec;

    if (!CertSetCertificateContextProperty(
				    pCert,
				    CERT_KEY_PROV_INFO_PROP_ID,
				    0,
				    (VOID *) &KeyProvInfo))
    {
        hr = myHLastError();

	// the cert's been incorrectly created -- scrap it.

	_JumpError(hr, error, "CertSetCertificateContextProperty");
    }
    hr = cuDumpCertKeyProviderInfo(g_wszPad2, pCert, NULL, NULL);
    _PrintIfError(hr, "cuDumpCertKeyProviderInfo");

    if (!g_fCryptSilent)
    {
	if (AT_SIGNATURE == dwKeySpec)
	{
	    hr = myValidateKeyForSigning(
				    hProv,
				    &pCert->pCertInfo->SubjectPublicKeyInfo,
				    CALG_SHA1);
	}
	else
	{
	    hr = myValidateKeyForEncrypting(
				    hProv,
				    &pCert->pCertInfo->SubjectPublicKeyInfo,
				    CALG_RC4);
	}
	if (S_OK != hr)
	{
	    if (SCARD_W_CANCELLED_BY_USER != hr)
	    {
		wprintf(myLoadResourceString(IDS_ERR_PRIVATEKEY_MISMATCH)); // "ERROR: Certificate public key does NOT match private key"
		wprintf(wszNewLine);
		//_JumpError(hr, error, "myValidateKeyForEncrypting");
		_PrintError(hr, "myValidateKeyForEncrypting");
	    }
	}
	else
	{
	    wprintf(myLoadResourceString(IDS_PRIVATEKEY_VERIFIES));
	    wprintf(wszNewLine);
	}
    }
    *ppCert = pCert;
    pCert = NULL;
    hr = S_OK;

error:
    if (NULL != pbCert)
    {
	LocalFree(pbCert);
    }
    if (NULL != pKey)
    {
	LocalFree(pKey);
    }
    if (NULL != pwszContainerName)
    {
        LocalFree(pwszContainerName);
    }
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    return(hr);
}


//+-------------------------------------------------------------------------
// DisplayChainInfo -- This code verifies that the SC cert is valid.
// Uses identical code to KDC cert chaining engine.
//
// Author: Todds
//--------------------------------------------------------------------------

DWORD
DisplayChainInfo(
    IN CERT_CONTEXT const *pCert)
{
    HRESULT hr;
    CERT_CHAIN_PARA ChainParameters;
    char *pszSCUsage = szOID_KP_SMARTCARD_LOGON;
    CERT_CHAIN_CONTEXT const *pChainContext = NULL;
    DWORD VerifyState;

    ZeroMemory(&ChainParameters, sizeof(ChainParameters));
    ChainParameters.cbSize = sizeof(ChainParameters);
    ChainParameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParameters.RequestedUsage.Usage.cUsageIdentifier = 1;
    ChainParameters.RequestedUsage.Usage.rgpszUsageIdentifier = &pszSCUsage;

    if (!CertGetCertificateChain(
                          HCCE_LOCAL_MACHINE,
                          pCert,
                          NULL,			// evaluate at current time
                          NULL,			// no additional stores
                          &ChainParameters,
                          CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT,
                          NULL,			// reserved
                          &pChainContext))
    {
        hr = myHLastError();
	cuPrintAPIError(L"CertGetCertificateChain", hr);
	_JumpError(hr, error, "CertGetCertificateChain");
    }
    if (CERT_TRUST_NO_ERROR != pChainContext->TrustStatus.dwErrorStatus)
    {
	wprintf(
	    L"CertGetCertificateChain(dwErrorStatus) = 0x%x\n",
	    pChainContext->TrustStatus.dwErrorStatus);
	wprintf(myLoadResourceString(IDS_SC_BAD_CHAIN));
	wprintf(wszNewLine);
    }
    else
    {
	wprintf(myLoadResourceString(IDS_SC_GOOD_CHAIN));
	wprintf(wszNewLine);
    }

    hr = cuVerifyCertContext(
			pCert,			// pCert
			NULL,			// hStoreCA
			1,			// cApplicationPolicies
			&pszSCUsage,		// apszApplicationPolicies
			0,			// cIssuancePolicies
			NULL,			// apszIssuancePolicies
			TRUE,			// fNTAuth
			&VerifyState);
    _JumpIfError(hr, error, "cuVerifyCertContext");

error:
    if (NULL != pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }
    return(hr);
}


HRESULT
DisplayReaderCertAndKey(
    IN SCARD_READERSTATE const *pReaderState,
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec,
    IN WCHAR const *pwszKeyType,
    IN WCHAR const *pwszCardName,
    IN WCHAR const *pwszCSPName)
{
    HRESULT hr;
    HCRYPTKEY hKey = NULL;
    CERT_CONTEXT const *pCert = NULL;
    DWORD cwc;
    WCHAR *pwszTitle = NULL;
    CRYPTUI_VIEWCERTIFICATE_STRUCT CertViewInfo;

    // Get the key

    if (!CryptGetUserKey(hProv, dwKeySpec, &hKey))
    {
	hr = myHLastError();
	cuPrintAPIError(L"CryptGetUserKey", hr);
	if (NTE_NO_KEY == hr)
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_SC_NO_KEY_COLON),
		pwszKeyType);
	}
	else
	{
	    wprintf(
		myLoadResourceString(IDS_FORMAT_SC_CANNOT_OPEN_KEY_COLON),
		pwszKeyType);
	}
	wprintf(L" %ws\n", pReaderState->szReader);
	_JumpError2(hr, error, "CryptGetUserKey", NTE_NO_KEY);
    }

    // Get the cert for this key

    hr = GetCertContext(hProv, hKey, dwKeySpec, pwszKeyType, &pCert);
    if (S_OK != hr)
    {
	wprintf(
	    myLoadResourceString(IDS_FORMAT_SC_NO_CERT_COLON),
	    pwszKeyType);
	wprintf(L" %ws\n", pReaderState->szReader);
	_JumpError(hr, error, "GetCertContext");
    }

    // Attempt to build a certificate chain

    wprintf(wszNewLine);
    wprintf(myLoadResourceString(IDS_SC_VALIDATING_CHAIN));
    wprintf(wszNewLine);

    DisplayChainInfo(pCert);

    // call common UI to display Cert Context
    // (from cryptui.h (cryptui.dll))

    if (!g_fCryptSilent)
    {
	cwc = wcslen(pReaderState->szReader) +
		2 +
		wcslen(pwszKeyType);
	pwszTitle = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszTitle)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	swprintf(
	    pwszTitle,
	    L"%ws: %ws",
	    pReaderState->szReader,
	    pwszKeyType);

	ZeroMemory(&CertViewInfo, sizeof(CertViewInfo));
	CertViewInfo.dwSize = sizeof(CertViewInfo);
	//CertViewInfo.hwndParent = NULL;
	CertViewInfo.szTitle = pwszTitle;
	CertViewInfo.dwFlags = CRYPTUI_DISABLE_EDITPROPERTIES |
				    CRYPTUI_DISABLE_ADDTOSTORE | 
				    CRYPTUI_ENABLE_REVOCATION_CHECKING;
	CertViewInfo.pCertContext = pCert;

	CryptUIDlgViewCertificate(&CertViewInfo, NULL);
	CertFreeCertificateContext(pCert);
    }
    wprintf(
	myLoadResourceString(IDS_FORMAT_SC_CERT_DISPLAYED_COLON),
	pwszKeyType);
    wprintf(L" %ws\n", pReaderState->szReader);
    hr = S_OK;

error:
    if (NULL != pwszTitle)
    {
	LocalFree(pwszTitle);
    }
    if (NULL != hKey)
    {
	CryptDestroyKey(hKey);
    }
    return(hr);
}


HRESULT
DisplayReaderCert(
    IN SCARDCONTEXT hSCard,
    IN SCARD_READERSTATE const *pReaderState)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD dwAutoAllocate;
    WCHAR wszFQCN[256];
    HCRYPTPROV hProv = NULL;
    WCHAR *pwszCardName = NULL;
    WCHAR *pwszCSPName = NULL;

    if (0 >= pReaderState->cbAtr)
    {
	hr = S_OK;
	goto error;	// no point to do any more work on this reader
    }

    // Inform user of current test

    wprintf(L"\n=======================================================\n");
    wprintf(myLoadResourceString(IDS_SC_ANALYZING_CARD_COLON));
    wprintf(L" %ws\n", pReaderState->szReader);

    // Get the name of the card

    dwAutoAllocate = SCARD_AUTOALLOCATE;
    hr = SCardListCards(
		    hSCard,
		    pReaderState->rgbAtr,
		    NULL,			// rgguidInterfaces 
		    0,				// cguidInterfaceCount 
		    (WCHAR *) &pwszCardName,	// mszCards 
		    &dwAutoAllocate);		// pcchCards 
    _JumpIfError(hr, error, "SCardListCards");

    dwAutoAllocate = SCARD_AUTOALLOCATE;
    hr = SCardGetCardTypeProviderName(
				hSCard,
				pwszCardName,
				SCARD_PROVIDER_CSP,
				(WCHAR *) &pwszCSPName,
				&dwAutoAllocate);
    if (S_OK != hr)
    {
	cuPrintAPIError(L"SCardGetCardTypeProviderName", hr);
	wprintf(
	    myLoadResourceString(IDS_FORMAT_SC_CANNOT_GET_CSP),
	    pwszCardName);
	_JumpError(hr, error, "SCardGetCardTypeProviderName");
    }

    // Prepare FullyQualifiedContainerName for CryptAcquireContext call

    swprintf(wszFQCN, L"\\\\.\\%ws\\", pReaderState->szReader);

    if (!CryptAcquireContext(
			&hProv,
			wszFQCN,	// default container via reader
			pwszCSPName,
			PROV_RSA_FULL,
			g_fCryptSilent? CRYPT_SILENT : 0))
    {
	hr = myHLastError();
	wprintf(L"%ws:\n", pReaderState->szReader);
	wprintf(L"%ws:\n", pwszCSPName);
	cuPrintAPIError(L"CryptAcquireContext", hr);
	_JumpError(hr, error, "SCardGetCardTypeProviderName");
    }

    // Enumerate the keys user specified and display the certs...

    hr = DisplayReaderCertAndKey(
			pReaderState,
			hProv,
			AT_SIGNATURE,
			L"AT_SIGNATURE",
			pwszCardName,
			pwszCSPName);
    _PrintIfError2(hr, "DisplayReaderCertAndKey", NTE_NO_KEY);

    hr2 = DisplayReaderCertAndKey(
			pReaderState,
			hProv,
			AT_KEYEXCHANGE,
			L"AT_KEYEXCHANGE",
			pwszCardName,
			pwszCSPName);
    _PrintIfError2(hr2, "DisplayReaderCertAndKey", NTE_NO_KEY);
    if (S_OK == hr)
    {
	hr = hr2;
	hr2 = S_OK;
    }

    // ignore NTE_NO_KEY if the other key type exists or has a different error:

    if (NTE_NO_KEY == hr)
    {
	hr = hr2;
	_PrintIfError2(hr, "DisplayReaderCertAndKey", NTE_NO_KEY);
    }

error:
    if (NULL != pwszCSPName)
    {
	SCardFreeMemory(hSCard, pwszCSPName);
    }
    if (NULL != pwszCardName)
    {
	SCardFreeMemory(hSCard, pwszCardName);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


//+-------------------------------------------------------------------------
// DisplayCerts
//--------------------------------------------------------------------------

HRESULT
DisplayCerts(
    IN SCARDCONTEXT hSCard,
    IN SCARD_READERSTATE const *prgReaderState,
    IN DWORD cReaders)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD i;

    // For each reader that has a card, load the CSP and display the cert

    hr = S_OK;
    for (i = 0; i < cReaders; i++)
    {
	hr2 = DisplayReaderCert(hSCard, &prgReaderState[i]);
	_PrintIfError(hr2, "DisplayReaderCert");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    return(hr);
}


//+-------------------------------------------------------------------------
// verbSCInfo -- This is the main entry point for the smart card test program.
// Nice and simple, borrowed from DBarlow
//
// Author: Doug Barlow (dbarlow) 11/10/1997
//
// Revisions:
// 	AMatlosz 2/26/98
//--------------------------------------------------------------------------

HRESULT
verbSCInfo(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszReaderName,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HRESULT hr2;
    SCARDCONTEXT hSCard = NULL;
    WCHAR *pwszzReaderNameAlloc = NULL;
    SCARD_READERSTATE *prgReaderState = NULL;
    DWORD cReaders;
    
    hr = IsSCardSvrRunning();
    _JumpIfError(hr, error, "IsSCardSvrRunning");

    hr = BuildReaderList(
		    pwszReaderName,
		    &hSCard,
		    &pwszzReaderNameAlloc,
		    &prgReaderState,
		    &cReaders);
    _PrintIfError(hr, "BuildReaderList");

    hr2 = DisplayReaderList(hSCard, prgReaderState, cReaders);
    _PrintIfError(hr2, "DisplayReaderList");
    if (S_OK == hr)
    {
	hr = hr2;
    }

    hr2 = DisplayCerts(hSCard, prgReaderState, cReaders);
    _PrintIfError(hr2, "DisplayCerts");
    if (S_OK == hr)
    {
	hr = hr2;
    }
    wprintf(wszNewLine);
    wprintf(myLoadResourceString(IDS_DONE));
    wprintf(wszNewLine);

error:
    FreeReaderList(hSCard, pwszzReaderNameAlloc, prgReaderState);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\tools\certut\store.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       store.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <winldap.h>
#include <setupapi.h>
#include "ocmanage.h"
#include "initcert.h"
#include "cscsp.h"
#include "csber.h"
#include "csldap.h"
#define __dwFILE__	__dwFILE_CERTUTIL_STORE_CPP__

#define RSAPRIV_MAGIC	0x32415352	// "RSA2"


DWORD
cuGetSystemStoreFlags()
{
    return(g_fEnterpriseRegistry?
	    CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE :
	    (g_fUserRegistry?
	     CERT_SYSTEM_STORE_CURRENT_USER :
	     CERT_SYSTEM_STORE_LOCAL_MACHINE));
}


// Parse a CertIndex -- any one of the following:
//
// Return the following in *piCert, *piCRL and *piCTL.  MAXDWORD if not
// specified
// Each value must be less than 64k.
//  iCert		decimal number
//  iCert.iCRL		decimal number, period, decimal number
//  iCert.iCRL.iCTL	decimal number, period, decimal number, period, number
//  .iCRL		period, decimal number
//  ..iCTL		period, period, decimal number
//
// Return the string in *ppwszCertName, if no Cert, CRL and CTL indexes.

HRESULT
ParseCertCRLIndex(
    IN WCHAR const *pwszCertIndex,
    OUT WCHAR **ppwszCertName,
    OUT DWORD *piCert,
    OUT DWORD *piCRL,
    OUT DWORD *piCTL)
{
    HRESULT hr;
    WCHAR *pwszCopy = NULL;
    
    *ppwszCertName = NULL;
    *piCert = MAXDWORD;
    *piCRL = MAXDWORD;
    *piCTL = MAXDWORD;
    if (NULL != pwszCertIndex && 0 != lstrcmp(L"*", pwszCertIndex))
    {
	BOOL fNumericIndex = TRUE;
	WCHAR *pwszCert;
	WCHAR *pwszCRL;
	WCHAR *pwszCTL;
	
	if (L' ' == *pwszCertIndex)
	{
	    fNumericIndex = FALSE;
	    pwszCertIndex++;
	}
	hr = myDupString(pwszCertIndex, &pwszCopy);
	_JumpIfError(hr, error, "myDupString");

	pwszCert = pwszCopy;

	if (!iswdigit(*pwszCert) && L'.' != *pwszCert)
	{
	    fNumericIndex = FALSE;
	}

	pwszCRL = NULL;
	pwszCTL = NULL;
	if (fNumericIndex)
	{
	    pwszCRL = wcschr(pwszCert, L'.');
	    if (NULL != pwszCRL)
	    {
		*pwszCRL++ = L'\0';
		pwszCTL = wcschr(pwszCRL, L'.');
		if (NULL != pwszCTL)
		{
		    *pwszCTL++ = L'\0';
		    if (L'\0' != *pwszCTL)
		    {
			hr = myGetLong(pwszCTL, (LONG *) piCTL);
			if (S_OK != hr || 64*1024 <= *piCTL)
			{
			    fNumericIndex = FALSE;
			}
		    }
		}
		if (fNumericIndex && L'\0' != *pwszCRL)
		{
		    hr = myGetLong(pwszCRL, (LONG *) piCRL);
		    if (S_OK != hr || 64*1024 <= *piCRL)
		    {
			fNumericIndex = FALSE;
		    }
		}
	    }
	}
	if (fNumericIndex && L'\0' != *pwszCert)
	{
	    hr = myGetLong(pwszCert, (LONG *) piCert);
	    if (S_OK != hr || 64*1024 <= *piCert)
	    {
		fNumericIndex = FALSE;
	    }
	}
	if (!fNumericIndex)
	{
	    hr = myRevertSanitizeName(pwszCertIndex, ppwszCertName);
	    _JumpIfError(hr, error, "myRevertSanitizeName");

	    *piCert = MAXDWORD;
	    *piCRL = MAXDWORD;
	    *piCTL = MAXDWORD;
	}
    }
    if (1 < g_fVerbose)
    {
	wprintf(
	    L"pwszCertIndex=%ws, %ws, %d.%d.%d\n",
	    pwszCertIndex,
	    *ppwszCertName,
	    *piCert,
	    *piCRL,
	    *piCTL);
    }
    hr = S_OK;

error:
    if (NULL != pwszCopy)
    {
	LocalFree(pwszCopy);
    }
    return(hr);
}


HRESULT
DeleteKeys(
    IN CERT_CONTEXT const *pcc,
    IN BOOL fUser)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;

    hr = myCertGetKeyProviderInfo(pcc, &pkpi);
    _PrintIfError(hr, "myCertGetKeyProviderInfo");
    if (S_OK == hr)
    {
	HCRYPTPROV hProv;

	if (!myCertSrvCryptAcquireContext(
			&hProv,
			pkpi->pwszContainerName,
			pkpi->pwszProvName,
			pkpi->dwProvType,
			pkpi->dwFlags | CRYPT_DELETEKEYSET,
			!fUser))
	{
	    hr = myHLastError();
	    _PrintIfError(hr, "myCertSrvCryptAcquireContext");
	}
	else
	{
	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"DeleteKeys(%ws, %ws)\n",
		!fUser? L"Machine" : L"User",
		pkpi->pwszContainerName));
	}
    }
    hr = S_OK;

//error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    return(hr);
}


// Delete keys copied into new CSP, and close store

HRESULT
cuDeleteStoreAndKeys(
    OPTIONAL IN HCERTSTORE hStore,
    IN BOOL fUser)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc;
    
    // Enumerate certs and delete keys

    pcc = NULL;
    while (TRUE)
    {
	pcc = CertEnumCertificatesInStore(hStore, pcc);
	if (NULL == pcc)
	{
	    break;
	}
	hr = DeleteKeys(pcc, fUser);
	_PrintIfError(hr, "DeleteKeys");
    }
    CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    hr = S_OK;

//error:
    return(hr);
}


HRESULT
CopyOneCertAndKeys(
    IN CERT_CONTEXT const *pcc,
    IN BOOL fUser,
    IN WCHAR const *pwszNewCSP,
    IN OUT HCERTSTORE hStore)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    WCHAR *pwszKeyContainerName = NULL;
    CERT_CONTEXT const *pccNew = NULL;

    pccNew = CertCreateCertificateContext(
				X509_ASN_ENCODING,
				pcc->pbCertEncoded,
				pcc->cbCertEncoded);
    if (NULL == pccNew)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertCreateCertificateContext");
    }

    hr = myCertGetKeyProviderInfo(pcc, &pkpi);
    _PrintIfError(hr, "myCertGetKeyProviderInfo");
    if (S_OK == hr)
    {
	hr = cuGenerateKeyContainerName(pcc, &pwszKeyContainerName);
	_JumpIfError(hr, error, "cuGenerateKeyContainerName");

	hr = myCopyKeys(
		    pkpi,
		    pkpi->pwszContainerName,	// pwszOldContainer
		    pwszKeyContainerName,	// pwszNewContainer
		    pwszNewCSP,			// pwszNewCSP
		    fUser,			// fOldUserKey
		    fUser,			// fNewUserKey
		    FALSE,			// fNewProtect
		    g_fForce);
	_JumpIfError(hr, error, "myCopyKeys");

	pkpi->pwszContainerName = pwszKeyContainerName;
	pkpi->pwszProvName = const_cast<WCHAR *>(pwszNewCSP);

	if (!CertSetCertificateContextProperty(
					    pccNew,
					    CERT_KEY_PROV_INFO_PROP_ID,
					    0,
					    pkpi))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertSetCertificateContextProperty");
	}
    }
    if (!CertAddCertificateContextToStore(
				    hStore,
				    pccNew,
				    CERT_STORE_ADD_ALWAYS,
				    NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddCertificateContextToStore");
    }
    hr = S_OK;

error:
    if (NULL != pccNew)
    {
	CertFreeCertificateContext(pccNew);
    }
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pwszKeyContainerName)
    {
        LocalFree(pwszKeyContainerName);
    }
    return(hr);
}


HRESULT
cuCopyStoreToNewCSP(
    IN HCERTSTORE hStoreIn,
    IN BOOL fUser,
    IN WCHAR const *pwszNewCSP,
    OUT HCERTSTORE *phStoreOut)
{
    HRESULT hr;
    HCERTSTORE hStoreOut = NULL;
    CERT_CONTEXT const *pcc;
    
    *phStoreOut = NULL;
    hStoreOut = CertOpenStore(
			CERT_STORE_PROV_MEMORY,
			X509_ASN_ENCODING,
			NULL,
			CERT_STORE_NO_CRYPT_RELEASE_FLAG |
			    CERT_STORE_ENUM_ARCHIVED_FLAG,
			NULL);
    if (NULL == hStoreOut)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    // Enumerate certs:
    // copy certs to new store and keys to new CSP

    pcc = NULL;
    while (TRUE)
    {
	pcc = CertEnumCertificatesInStore(hStoreIn, pcc);
	if (NULL == pcc)
	{
	    break;
	}
	hr = CopyOneCertAndKeys(pcc, fUser, pwszNewCSP, hStoreOut);
	_JumpIfError(hr, error, "CopyOneCertAndKeys");
    }
    *phStoreOut = hStoreOut;
    hStoreOut = NULL;
    hr = S_OK;

error:
    if (NULL != hStoreOut)
    {
	cuDeleteStoreAndKeys(hStoreOut, fUser);
    }
    return(hr);
}


HRESULT
SavePFXStoreToFile(
    IN HCERTSTORE hStoreSave,
    IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszNewCSP,
    OPTIONAL IN WCHAR const *pwszSalt,
    OPTIONAL IN WCHAR const *pwszV3CACertId,
    IN BOOL fSaveAsPFX,
    IN DWORD dwEPFAlg,
    IN WCHAR const *pwszPassword,
    IN OUT WCHAR **ppwszPassword)
{
    HRESULT hr;
    CRYPT_DATA_BLOB pfx;
    WCHAR wszPassword[MAX_PATH];
    HCERTSTORE hStoreT = NULL;
    BOOL fUser = !g_fEnterpriseRegistry && g_fUserRegistry;

    pfx.pbData = NULL;

    if (NULL == *ppwszPassword)
    {
	hr = cuGetPassword(
			IDS_FORMAT_ENTER_PASSWORD_OUTPUT_FILE,
			pwszfnOut,
			pwszPassword,
			TRUE,		// fVerify
			wszPassword,
			ARRAYSIZE(wszPassword),
			&pwszPassword);
	_JumpIfError(hr, error, "cuGetPassword");

	hr = myDupString(pwszPassword, ppwszPassword);
	_JumpIfError(hr, error, "myDupString");
    }
    pwszPassword = *ppwszPassword;

    if (fSaveAsPFX)
    {
	if (NULL != pwszNewCSP)
	{
	    // Copy keys to new CSP, create new store with updated KeyProvInfo

	    //wprintf(L"New CSP: %ws\n", pwszNewCSP);
	    hr = cuCopyStoreToNewCSP(hStoreSave, fUser, pwszNewCSP, &hStoreT);
	    _JumpIfError(hr, error, "cuCopyStoreToNewCSP");

	    hStoreSave = hStoreT;
	}

	// GemPlus returns NTE_BAD_TYPE instead of NTE_BAD_KEY, blowing up
	// REPORT_NOT_ABLE* filtering.  If they ever get this right, we can
	// pass "[...] : EXPORT_PRIVATE_KEYS"

	hr = myPFXExportCertStore(
		hStoreSave,
		&pfx,
		pwszPassword,
		!g_fWeakPFX,
		EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY);
	_JumpIfError(hr, error, "myPFXExportCertStore");

	hr = EncodeToFileW(
		    pwszfnOut,
		    pfx.pbData,
		    pfx.cbData,
		    CRYPT_STRING_BINARY | g_EncodeFlags);
	_JumpIfError(hr, error, "EncodeToFileW");
    }
    else
    {
	hr = EPFSaveCertStoreToFile(
			    hStoreSave,
			    pwszPassword,
			    pwszfnOut,
			    pwszV3CACertId,
			    dwEPFAlg,
			    pwszSalt);
	_JumpIfError(hr, error, "EPFSaveCertStoreToFile");
    }

error:
    SecureZeroMemory(wszPassword, sizeof(wszPassword));	// password data
    if (NULL != hStoreT)
    {
	cuDeleteStoreAndKeys(hStoreT, fUser);
    }
    if (NULL != pfx.pbData)
    {
	LocalFree(pfx.pbData);
    }
    return(hr);
}


HRESULT
SavePFXToFile(
    IN CERT_CONTEXT const *pCert,
    IN WCHAR const *pwszfnOut,
    IN BOOL fFirst,
    IN WCHAR const *pwszPassword,
    IN OUT WCHAR **ppwszPassword)
{
    HRESULT hr;
    HCERTSTORE hTempMemoryStore = NULL;

    hTempMemoryStore = CertOpenStore(
				CERT_STORE_PROV_MEMORY,
				X509_ASN_ENCODING,
				NULL,
				CERT_STORE_NO_CRYPT_RELEASE_FLAG |
				    CERT_STORE_ENUM_ARCHIVED_FLAG,
				NULL);
    if (NULL == hTempMemoryStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    // Begin Chain Building

    hr = myAddChainToMemoryStore(hTempMemoryStore, pCert, g_dwmsTimeout);
    _JumpIfError(hr, error, "myAddChainToMemoryStore");

    // End Chain Building

    hr = SavePFXStoreToFile(
			hTempMemoryStore,
			pwszfnOut,
			NULL,		// pwszNewCSP
			NULL,		// pwszSalt
			NULL,		// pwszV3CACertId
			TRUE,		// fSaveAsPFX
			0,		// dwEPFAlg
			pwszPassword,
			ppwszPassword);
    _JumpIfError(hr, error, "SavePFXStoreToFile");

error:
    if (NULL != hTempMemoryStore)
    {
	CertCloseStore(hTempMemoryStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
SavePVKToFile(
    IN CERT_CONTEXT const *pCert,
    IN WCHAR const *pwszfnOut,
    IN BOOL fFirst)
{
    return(S_OK);
}


HRESULT
cuDumpCTLProperties(
    IN CTL_CONTEXT const *pCTL)
{
    HRESULT hr;
    DWORD dwPropId;
    BYTE *pb = NULL;
    DWORD cb;

    dwPropId = 0;
    while (TRUE)
    {
	if (NULL != pb)
	{
	    LocalFree(pb);
	    pb = NULL;
	}
	dwPropId = CertEnumCTLContextProperties(pCTL, dwPropId);
	if (0 == dwPropId)
	{
	    break;
	}
	while (TRUE)
	{
	    if (!CertGetCTLContextProperty(pCTL, dwPropId, pb, &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertGetCTLContextProperty");
	    }
	    if (NULL != pb)
	    {
		break;		// memory alloc'd, property fetched
	    }
	    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	    if (NULL == pb)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	}
	hr = cuDumpFormattedProperty(dwPropId, NULL, pb, cb);
	_PrintIfError(hr, "cuDumpFormattedProperty");
    }
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
cuDumpCRLProperties(
    IN CRL_CONTEXT const *pCRL)
{
    HRESULT hr;
    DWORD dwPropId;
    BYTE *pb = NULL;
    DWORD cb;

    dwPropId = 0;
    while (TRUE)
    {
	if (NULL != pb)
	{
	    LocalFree(pb);
	    pb = NULL;
	}
	dwPropId = CertEnumCRLContextProperties(pCRL, dwPropId);
	if (0 == dwPropId)
	{
	    break;
	}
	while (TRUE)
	{
	    if (!CertGetCRLContextProperty(pCRL, dwPropId, pb, &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertGetCRLContextProperty");
	    }
	    if (NULL != pb)
	    {
		break;		// memory alloc'd, property fetched
	    }
	    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	    if (NULL == pb)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	}
	hr = cuDumpFormattedProperty(dwPropId, NULL, pb, cb);
	_PrintIfError(hr, "cuDumpFormattedProperty");
    }
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
cuDumpCertProperties(
    IN CERT_CONTEXT const *pCert)
{
    HRESULT hr;
    DWORD dwPropId;
    BYTE *pb = NULL;
    DWORD cb;

    dwPropId = 0;
    while (TRUE)
    {
	dwPropId = CertEnumCertificateContextProperties(pCert, dwPropId);
	if (0 == dwPropId)
	{
	    break;
	}
	if (NULL != pb)
	{
	    LocalFree(pb);
	    pb = NULL;
	}
	while (TRUE)
	{
	    if (!CertGetCertificateContextProperty(pCert, dwPropId, pb, &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertGetCertificateContextProperty");
	    }
	    if (NULL != pb)
	    {
		break;		// memory alloc'd, property fetched
	    }
	    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	    if (NULL == pb)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	}
	hr = cuDumpFormattedProperty(dwPropId, NULL, pb, cb);
	_PrintIfError(hr, "cuDumpFormattedProperty");
    }
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
SetCertificateKeyProvInfo(
    IN CERT_CONTEXT const *pCert,
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    IN CERT_PUBLIC_KEY_INFO const *pPubKeyInfo)
{
    HRESULT hr;

    if (!myCertComparePublicKeyInfo(
			    X509_ASN_ENCODING,
			    CERT_V1 == pCert->pCertInfo->dwVersion,
			    pPubKeyInfo,
			    &pCert->pCertInfo->SubjectPublicKeyInfo))
    {
	// by design, (my)CertComparePublicKeyInfo doesn't set last error!

	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError2(hr, error, "myCertComparePublicKeyInfo", hr);
    }
    if (!CertSetCertificateContextProperty(
					pCert,
					CERT_KEY_PROV_INFO_PROP_ID,
					0,
					pkpi))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertSetCertificateContextProperty");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
cuFindCertificateKeyProvInfo(
    IN CERT_CONTEXT const *pCert)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    KEY_LIST *pKeyList = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKeyInfoSig = NULL;
    CERT_PUBLIC_KEY_INFO *pPubKeyInfoXchg = NULL;

    if (NULL != g_pwszCSP)
    {
	DWORD dwKeySpec;
	DWORD dwProvType;
	KEY_LIST *pKeyT;
	
	hr = csiGetProviderTypeFromProviderName(g_pwszCSP, &dwProvType);
        _JumpIfErrorStr(hr, error, "csiGetProviderTypeFromProviderName", g_pwszCSP);
	if (!CryptAcquireCertificatePrivateKey(
					pCert,
					CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
					NULL,	// pvReserved
					&hProv,
					&dwKeySpec,
					NULL))	// pfCallerFreeProv
	{
	    hr = myHLastError();
	    _PrintError(hr, "CryptFindCertificateKeyProvInfo");
	}
	else
	{
	    hr = CRYPT_E_EXISTS;
	    _PrintError2(hr, "Key Exists!", hr);
	    if (!g_fForce)
	    {
		goto error;
	    }
	}
	hr = csiGetKeyList(
		    dwProvType,		// dwProvType
		    g_pwszCSP,		// pwszProvName
		    !g_fUserRegistry,	// fMachineKeyset
		    !g_fCryptSilent,	// inverted fSilent: default is Silent!
		    &pKeyList);
	_JumpIfErrorStr(hr, error, "csiGetKeyList", g_pwszCSP);

	for (pKeyT = pKeyList; NULL != pKeyT; pKeyT = pKeyT->next)
	{
	    DWORD dwProvTypeT;

	    dwProvTypeT = dwProvType;
	    hr = cuLoadKeys(
			g_pwszCSP,
			&dwProvTypeT,
			pKeyT->pwszName,
			!g_fUserRegistry,	// fMachineKeyset
			TRUE,
			NULL,
			&pPubKeyInfoSig,
			&pPubKeyInfoXchg);
	    if (S_OK != hr)
	    {
		cuPrintError(IDS_ERR_FORMAT_LOADKEYS, hr);
	    }
	    else
	    {
		CRYPT_KEY_PROV_INFO kpi;

		ZeroMemory(&kpi, sizeof(kpi));
		kpi.pwszContainerName = pKeyT->pwszName;
		kpi.pwszProvName = g_pwszCSP;
		kpi.dwProvType = dwProvTypeT;
		kpi.dwFlags = g_fUserRegistry? 0 : CRYPT_MACHINE_KEYSET;

		if (NULL != pPubKeyInfoSig)
		{
		    kpi.dwKeySpec = AT_SIGNATURE;
		    
		    hr = SetCertificateKeyProvInfo(
				    pCert,
				    &kpi,
				    pPubKeyInfoSig);
		    if (S_OK == hr)
		    {
			break;
		    }
		    _PrintError2(hr, "SetCertificateKeyProvInfo", hr);
		}
		if (NULL != pPubKeyInfoXchg)
		{
		    kpi.dwKeySpec = AT_KEYEXCHANGE;

		    hr = SetCertificateKeyProvInfo(
				    pCert,
				    &kpi,
				    pPubKeyInfoXchg);
		    if (S_OK == hr)
		    {
			break;
		    }
		    _PrintError2(hr, "SetCertificateKeyProvInfo", hr);
		}
	    }
	    if (NULL != pPubKeyInfoSig)
	    {
		LocalFree(pPubKeyInfoSig);
		pPubKeyInfoSig = NULL;
	    }
	    if (NULL != pPubKeyInfoXchg)
	    {
		LocalFree(pPubKeyInfoXchg);
		pPubKeyInfoXchg = NULL;
	    }
	}
	if (NULL == pKeyT)
	{
	    hr = CRYPT_E_NOT_FOUND;
	    _JumpError(hr, error, "cuFindCertificateKeyProvInfo");
	}
    }
    else
    {
	if (!CryptFindCertificateKeyProvInfo(
				    pCert,
				    0,		// dwFlags
				    NULL))	// pvReserved
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptFindCertificateKeyProvInfo");
	}
    }
    hr = S_OK;

error:
    if (NULL != pPubKeyInfoSig)
    {
	LocalFree(pPubKeyInfoSig);
    }
    if (NULL != pPubKeyInfoXchg)
    {
	LocalFree(pPubKeyInfoXchg);
    }
    if (NULL != pKeyList)
    {
	csiFreeKeyList(pKeyList);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
EnumCertsInStore(
    IN HCERTSTORE hStore,
    IN DWORD Mode,
    IN DWORD iCertSave,
    OPTIONAL IN WCHAR const *pwszCertName,
    IN DWORD cbHash,
    OPTIONAL IN BYTE *pbHash,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszPasswordArg,
    IN OUT WCHAR **ppwszPassword,
    OUT DWORD *pcCert)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD iCert;
    CERT_CONTEXT const *pCert = NULL;
    BSTR strSerialNumber = NULL;

    *pcCert = 0;
    hr2 = S_OK;
    if (NULL != pwszCertName)
    {
	hr = myMakeSerialBstr(pwszCertName, &strSerialNumber);
	_PrintIfError2(hr, "myMakeSerialBstr", hr);
    }
    for (iCert = 0; ; iCert++)
    {
	DWORD VerifyState;
	BOOL fSigningKey;
	BOOL fMatchingKey;

	pCert = CertEnumCertificatesInStore(hStore, pCert);
	if (NULL == pCert)
	{
	    break;
	}
	if (MAXDWORD == iCertSave || iCert == iCertSave)
	{
	    DWORD cb;

	    if (NULL != pwszCertName)
	    {
		BOOL fMatch;
		
		hr = myCertMatch(
			    pCert,
			    pwszCertName,
			    FALSE,		// fAllowMissingCN
			    pbHash,
			    cbHash,
			    strSerialNumber,
			    &fMatch);
		_PrintIfError(hr, "myCertMatch");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
		if (S_OK != hr || !fMatch)
		{
		    continue;
		}
	    }
	    if (0 != *pcCert)
	    {
		wprintf(wszNewLine);
	    }

	    wprintf(
		myLoadResourceString(IDS_FORMAT_DUMP_CERT_INDEX),  // "================ Certificate %d ================"
		iCert);
	    wprintf(wszNewLine);

	    if (CertGetCertificateContextProperty(
					    pCert,
					    CERT_ARCHIVED_PROP_ID,
					    NULL,
					    &cb))
	    {
		wprintf(myLoadResourceString(IDS_ARCHIVED)); // "Archived!"
		wprintf(wszNewLine);
	    }
	    if ((iCert == iCertSave || NULL != pwszCertName) &&
		NULL != pwszfnOut &&
		(DVNS_SAVECERT & Mode))
	    {
		hr = EncodeToFileW(
			    pwszfnOut,
			    pCert->pbCertEncoded,
			    pCert->cbCertEncoded,
			    CRYPT_STRING_BINARY | g_EncodeFlags);
		_PrintIfError(hr, "EncodeToFileW");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }

	    hr = cuDumpAsnBinary(
			    pCert->pbCertEncoded,
			    pCert->cbCertEncoded,
			    MAXDWORD);
	    _PrintIfError(hr, "cuDumpAsnBinary");
	    if (S_OK == hr2)
	    {
		hr2 = hr;
	    }

	    if (DVNS_REPAIRKPI & Mode)
	    {
		hr = cuFindCertificateKeyProvInfo(pCert);
		_PrintIfError(hr, "cuFindCertificateKeyProvInfo");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    
	    }
	    if ((DVNS_DUMPPROPERTIES & Mode) && !g_fQuiet)
	    {
		hr = cuDumpCertProperties(pCert);
		_PrintIfError(hr, "cuDumpCertProperties");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }
	    if (DVNS_DUMPKEYS & Mode)
	    {
		if (0 == (DVNS_DUMPPROPERTIES & Mode) || g_fQuiet)
		{
		    hr = cuDumpCertKeyProviderInfo(
					    g_wszPad2,
					    pCert,
					    NULL,
					    NULL);
		    _PrintIfError(hr, "cuDumpCertKeyProviderInfo");
		    if (S_OK == hr2)
		    {
			hr2 = hr;
		    }
		}
		hr = cuDumpPrivateKey(pCert, &fSigningKey, &fMatchingKey);
		if (!IsHrSkipPrivateKey(hr))
		{
		    if (S_OK != hr)
		    {
			wprintf(myLoadResourceString(
			    fSigningKey?
				IDS_SIGNATURE_BAD :   // "Signature test FAILED"
				IDS_ENCRYPTION_BAD)); // "Encryption test FAILED"
			wprintf(wszNewLine);
			_PrintError(hr, "cuDumpPrivateKey");
			fMatchingKey = FALSE;
		    }

		    if (fMatchingKey)
		    {
			wprintf(myLoadResourceString(
			    fSigningKey?
				IDS_SIGNATURE_OK :   // "Signature test passed"
				IDS_ENCRYPTION_OK)); // "Encryption test passed"
			wprintf(wszNewLine);
		    }
		}
	    }
	    if (DVNS_VERIFYCERT & Mode)
	    {
		hr = cuVerifyCertContext(
				pCert,
				(DVNS_CASTORE & Mode)? hStore : NULL,
				0,		// cApplicationPolicies
				NULL,		// apszApplicationPolicies
				0,		// cIssuancePolicies
				NULL,		// apszIssuancePolicies
				FALSE,		// fNTAuth
				&VerifyState);
		if (S_OK != hr)
		{
		    cuPrintError(IDS_ERR_FORMAT_BAD_CERT, hr);
		    _PrintError(hr, "cuVerifyCertContext");
		    if (S_OK == hr2)
		    {
			hr2 = hr;		// Save first error
		    }
		}
		else if (0 == (VS_ERRORMASK & VerifyState))
		{
		    wprintf(myLoadResourceString(IDS_CERT_VERIFIES)); // "Certificate is valid"
		}
		wprintf(wszNewLine);
	    }
	    if (DVNS_SAVEPFX & Mode)
	    {
		hr = SavePFXToFile(
				pCert,
				pwszfnOut,
				0 == *pcCert,
				pwszPasswordArg,
				ppwszPassword);
		_PrintIfError(hr, "SavePFXToFile");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }
	    if (DVNS_SAVEPVK & Mode)
	    {
		hr = SavePVKToFile(pCert, pwszfnOut, 0 == *pcCert);
		_PrintIfError(hr, "SavePVKToFile");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }
	    (*pcCert)++;
	}
    }
    hr = hr2;
    _JumpIfError(hr, error, "EnumCertsInStore");

error:
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


HRESULT
EnumCRLsInStore(
    IN HCERTSTORE hStore,
    IN DWORD Mode,
    IN DWORD iCRLSave,
    OPTIONAL IN WCHAR const *pwszCertName,
    IN DWORD cbHash,
    OPTIONAL IN BYTE *pbHash,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OUT DWORD *pcCRL)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD iCRL;
    CRL_CONTEXT const *pCRL = NULL;

    *pcCRL = 0;
    hr2 = S_OK;
    for (iCRL = 0; ; iCRL++)
    {
	pCRL = CertEnumCRLsInStore(hStore, pCRL);
	if (NULL == pCRL)
	{
	    break;
	}
	if (MAXDWORD == iCRLSave || iCRL == iCRLSave)
	{
	    if (NULL != pwszCertName)
	    {
		BOOL fMatch;
		
		hr = myCRLMatch(
			    pCRL,
			    pwszCertName,
			    FALSE,		// fAllowMissingCN
			    pbHash,
			    cbHash,
			    &fMatch);
		_PrintIfError(hr, "myCRLMatch");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
		if (S_OK != hr || !fMatch)
		{
		    continue;
		}
	    }
	    if (0 != *pcCRL)
	    {
		wprintf(wszNewLine);
	    }

	    wprintf(
		myLoadResourceString(IDS_FORMAT_DUMP_CRL_INDEX),  // "================ CRL %d ================"
		iCRL);
	    wprintf(wszNewLine);

	    if ((iCRL == iCRLSave || NULL != pwszCertName) &&
		NULL != pwszfnOut &&
		(DVNS_SAVECRL & Mode))
	    {
		hr = EncodeToFileW(
			    pwszfnOut,
			    pCRL->pbCrlEncoded,
			    pCRL->cbCrlEncoded,
			    CRYPT_STRING_BINARY | g_EncodeFlags);
		_PrintIfError(hr, "EncodeToFileW");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }

	    hr = cuDumpAsnBinary(
			    pCRL->pbCrlEncoded,
			    pCRL->cbCrlEncoded,
			    MAXDWORD);
	    _PrintIfError(hr, "cuDumpAsnBinary");
	    if (S_OK == hr2)
	    {
		hr2 = hr;
	    }

	    if ((DVNS_DUMPPROPERTIES & Mode) && !g_fQuiet)
	    {
		hr = cuDumpCRLProperties(pCRL);
		_PrintIfError(hr, "cuDumpCRLProperties");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }
	    (*pcCRL)++;
	}
    }
    hr = hr2;
    _JumpIfError(hr, error, "EnumCRLsInStore");

error:
    if (NULL != pCRL)
    {
	CertFreeCRLContext(pCRL);
    }
    return(hr);
}


HRESULT
EnumCTLsInStore(
    IN HCERTSTORE hStore,
    IN DWORD Mode,
    IN DWORD iCTLSave,
    OPTIONAL IN WCHAR const *pwszCertName,
    IN DWORD cbHash,
    OPTIONAL IN BYTE *pbHash,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OUT DWORD *pcCTL)
{
    HRESULT hr;
    HRESULT hr2;
    DWORD iCTL;
    CTL_CONTEXT const *pCTL = NULL;

    *pcCTL = 0;
    hr2 = S_OK;
    for (iCTL = 0; ; iCTL++)
    {
	pCTL = CertEnumCTLsInStore(hStore, pCTL);
	if (NULL == pCTL)
	{
	    break;
	}
	if (MAXDWORD == iCTLSave || iCTL == iCTLSave)
	{
	    DWORD cb;

	    if (NULL != pwszCertName)
	    {
		BOOL fMatch;
		
		hr = myCTLMatch(pCTL, pbHash, cbHash, &fMatch);
		_PrintIfError(hr, "myCTLMatch");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
		if (S_OK != hr || !fMatch)
		{
		    continue;
		}
	    }
	    if (0 != *pcCTL)
	    {
		wprintf(wszNewLine);
	    }

	    wprintf(
		myLoadResourceString(IDS_FORMAT_DUMP_CTL_INDEX),  // "================ CTL %d ================"
		iCTL);
	    wprintf(wszNewLine);

	    if (CertGetCTLContextProperty(
				    pCTL,
				    CERT_ARCHIVED_PROP_ID,
				    NULL,
				    &cb))
	    {
		wprintf(myLoadResourceString(IDS_ARCHIVED)); // "Archived!"
		wprintf(wszNewLine);
	    }
	    if ((iCTL == iCTLSave || NULL != pwszCertName) &&
		NULL != pwszfnOut &&
		(DVNS_SAVECTL & Mode))
	    {
		hr = EncodeToFileW(
			    pwszfnOut,
			    pCTL->pbCtlEncoded,
			    pCTL->cbCtlEncoded,
			    CRYPT_STRING_BINARY | g_EncodeFlags);
		_PrintIfError(hr, "EncodeToFileW");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }

	    hr = cuDumpAsnBinary(
			    pCTL->pbCtlEncoded,
			    pCTL->cbCtlEncoded,
			    MAXDWORD);
	    _PrintIfError(hr, "cuDumpAsnBinary");
	    if (S_OK == hr2)
	    {
		hr2 = hr;
	    }

	    if ((DVNS_DUMPPROPERTIES & Mode) && !g_fQuiet)
	    {
		hr = cuDumpCTLProperties(pCTL);
		_PrintIfError(hr, "cuDumpCTLProperties");
		if (S_OK == hr2)
		{
		    hr2 = hr;
		}
	    }
#if 0
	    if (DVNS_VERIFYCERT & Mode)
	    {
		hr = cuVerifyCertContext(
				pCTL,
				(DVNS_CASTORE & Mode)? hStore : NULL,
				NULL,			// apszPolicies
				0,			// cPolicies
				FALSE,			// fNTAuth
				&VerifyState);
		if (S_OK != hr)
		{
		    cuPrintError(IDS_ERR_FORMAT_BAD_CTL, hr);
		    _PrintError(hr, "cuVerifyCertContext");
		    if (S_OK == hr2)
		    {
			hr2 = hr;		// Save first error
		    }
		}
		else
		{
		    wprintf(myLoadResourceString(IDS_CTL_VERIFIES)); // "CTL is valid"
		}
		wprintf(wszNewLine);
	    }
#endif
	    (*pcCTL)++;
	}
    }
    hr = hr2;
    _JumpIfError(hr, error, "EnumCTLsInStore");

error:
    if (NULL != pCTL)
    {
	CertFreeCTLContext(pCTL);
    }
    return(hr);
}


HRESULT
cuDumpAndVerifyStore(
    IN HCERTSTORE hStore,
    IN DWORD Mode,
    OPTIONAL IN WCHAR const *pwszCertName,
    IN DWORD iCertSave,
    IN DWORD iCRLSave,
    IN DWORD iCTLSave,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszPasswordArg)
{
    HRESULT hr;
    HRESULT hr2;
    BYTE *pbHash = NULL;
    DWORD cbHash;
    BOOL fVerboseOld = g_fVerbose;
    BOOL fQuietOld = g_fQuiet;
    WCHAR *pwszPassword = NULL;
    DWORD cCert = 0;
    DWORD cCRL = 0;
    DWORD cCTL = 0;

    if (g_fVerbose)
    {
	g_fVerbose--;
    }
    else
    {
	g_fQuiet = TRUE;
    }
    hr2 = S_OK;

    if (NULL != pwszCertName)
    {
	hr = WszToMultiByteInteger(TRUE, pwszCertName, &cbHash, &pbHash);
	_PrintIfError2(hr, "WszToMultiByteInteger", hr);
    }

    if (NULL != pwszCertName ||
	MAXDWORD != iCertSave ||
	(MAXDWORD == iCRLSave && MAXDWORD == iCTLSave))
    {
	hr = EnumCertsInStore(
			hStore,
			Mode, 
			iCertSave,
			pwszCertName,
			cbHash,
			pbHash,
			pwszfnOut,
			pwszPasswordArg,
			&pwszPassword,
			&cCert);
	_PrintIfError(hr, "EnumCertsInStore");
	if (S_OK == hr2)
	{
	    hr2 = hr;
	}
    }

    if (NULL != pwszCertName ||
	MAXDWORD != iCRLSave ||
	(MAXDWORD == iCertSave && MAXDWORD == iCTLSave))
    {
	hr = EnumCRLsInStore(
			hStore,
			Mode,
			iCRLSave,
			pwszCertName,
			cbHash,
			pbHash,
			pwszfnOut,
			&cCRL);
	_PrintIfError(hr, "EnumCRLsInStore");
	if (S_OK == hr2)
	{
	    hr2 = hr;
	}
    }

    if (NULL != pwszCertName ||
	MAXDWORD != iCTLSave ||
	(MAXDWORD == iCertSave && MAXDWORD == iCRLSave))
    {
	hr = EnumCTLsInStore(
			hStore,
			Mode,
			iCTLSave,
			pwszCertName,
			cbHash,
			pbHash,
			pwszfnOut,
			&cCTL);
	_PrintIfError(hr, "EnumCTLsInStore");
	if (S_OK == hr2)
	{
	    hr2 = hr;
	}
    }

    hr = hr2;
    if (S_OK == hr && NULL != pwszCertName && 0 == (cCert + cCRL + cCTL))
    {
	hr = NTE_NOT_FOUND;
        _JumpError(hr, error, "cuDumpAndVerifyStore");
    }

error:
    g_fVerbose = fVerboseOld;
    g_fQuiet = fQuietOld;
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    if (NULL != pwszPassword)
    {
	myZeroDataString(pwszPassword);	// password data
	LocalFree(pwszPassword);
    }
    return(hr);
}


// Reorder LDAP URL paramaters as per RFC 2255:
//    Attribute list: ?attribute,...
//    Scope: ?sub or ?one or ?base
//    Search filter: ?objectClass=*,...

HRESULT
PatchLdapURL(
    IN WCHAR const *pwszURLIn,
    OUT WCHAR **ppwszURLOut)
{
    HRESULT hr;
    DWORD cParm;
    DWORD iParm;
    WCHAR *pwsz;
    WCHAR *pwszT = NULL;
    WCHAR *pwszURLOut = NULL;
    WCHAR **apwsz = NULL;

    *ppwszURLOut = NULL;

    hr = myDupString(pwszURLIn, &pwszT);
    _JumpIfError(hr, error, "myDupString");

    pwsz = pwszT; 
    for (cParm = 0; ; cParm++)
    {
	pwsz = wcschr(pwsz, L'?');
	if (NULL == pwsz)
	{
	    break;
	}
	pwsz++;
    }
    if (1 < cParm)
    {
	apwsz = (WCHAR **) LocalAlloc(LMEM_FIXED, sizeof(apwsz[0]) * cParm);
	if (NULL == apwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	pwsz = pwszT; 
	for (iParm = 0; iParm < cParm; iParm++)
	{
	    pwsz = wcschr(pwsz, L'?');
	    CSASSERT(NULL != pwsz);
	    *pwsz++ = L'\0';
	    apwsz[iParm] = pwsz;
	}
	CSASSERT(cParm == iParm);
	CSASSERT(NULL == wcschr(pwsz, L'?'));

	hr = myDupString(pwszURLIn, &pwszURLOut);
	_JumpIfError(hr, error, "myDupString");

	pwsz = wcschr(pwszURLOut, L'?');
	if (NULL != pwsz)
	{
	    DWORD i;
	    
	    *pwsz = L'\0';
	    for (i = 0; i < 3; i++)
	    {
		for (iParm = 0; iParm < cParm; iParm++)
		{
		    BOOL fScope;
		    BOOL fFilter;
		    BOOL fCopy;
		    
		    fScope =
			0 == mylstrcmpiS(apwsz[iParm], &wszDSSUBSEARCH[1]) ||
			0 == mylstrcmpiS(apwsz[iParm], &wszDSBASESEARCH[1]) ||
			0 == mylstrcmpiS(apwsz[iParm], &wszDSONESEARCH[1]);
		    fFilter = NULL != wcschr(apwsz[iParm], L'=');

		    switch (i)
		    {
			case 0:  fCopy = !fScope && !fFilter; break;
			case 1:  fCopy = fScope;	      break;
			default: fCopy = fFilter;	      break;
		    }
		    if (fCopy)
		    {
			wcscat(pwszURLOut, L"?");
			wcscat(pwszURLOut, apwsz[iParm]);
		    }
		}
	    }
	    CSASSERT(wcslen(pwszURLOut) == wcslen(pwszURLIn));

	    // If the URL was reordered, return the patched URL.

	    if (0 != lstrcmp(pwszURLIn, pwszURLOut))
	    {
		*ppwszURLOut = pwszURLOut;
		pwszURLOut = NULL;
	    }
	}
    }
    hr = NULL == *ppwszURLOut? S_FALSE : S_OK;

error:
    if (NULL != apwsz)
    {
	LocalFree(apwsz);
    }
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    if (NULL != pwszURLOut)
    {
	LocalFree(pwszURLOut);
    }
    return(hr);
}


#define wszLDAPCOLONSLASH	L"ldap:/"
#define wszFMTLDAPPREFIX	L"ldap://%ws/"

HRESULT
cuOpenCertStore(
    IN WCHAR const *pwszStoreName,
    IN OUT DWORD *pMode,
    OPTIONAL OUT WCHAR **ppwszStoreNameOut,
    OUT HCERTSTORE *phStore)
{
    HRESULT hr;
    WCHAR awcLdap[ARRAYSIZE(wszLDAPCOLONSLASH)];
    LPCSTR pszStoreProvider = CERT_STORE_PROV_SYSTEM_REGISTRY_W;
    WCHAR *pwszStoreAlloc = NULL;
    WCHAR *pwszStoreAlloc2 = NULL;
    WCHAR *pwszStoreNameOut = NULL;

    if (NULL != ppwszStoreNameOut)
    {
	*ppwszStoreNameOut = NULL;
    }
    if (NULL == pwszStoreName ||
	0 == wcscmp(L"*", pwszStoreName) ||
	0 == LSTRCMPIS(pwszStoreName, wszCA_CERTSTORE))
    {
        pwszStoreName = wszCA_CERTSTORE;
    	*pMode |= DVNS_CASTORE;
    }
    wcsncpy(awcLdap, pwszStoreName, ARRAYSIZE(awcLdap) - 1);
    awcLdap[ARRAYSIZE(awcLdap) - 1] = L'\0';
    if (0 == LSTRCMPIS(awcLdap, wszLDAPCOLONSLASH))
    {
	pszStoreProvider = CERT_STORE_PROV_LDAP_W;
	*pMode |= DVNS_DSSTORE;
    }
    else
    {
	CSASSERT(3 < ARRAYSIZE(awcLdap));
	awcLdap[3] = L'\0';
	if (0 == LSTRCMPIS(awcLdap, L"CN="))
	{
	    DWORD cwc = WSZARRAYSIZE(wszFMTLDAPPREFIX) + wcslen(pwszStoreName);

	    if (NULL != g_pwszDC)
	    {
		cwc += wcslen (g_pwszDC);
	    }
	    pwszStoreAlloc = (WCHAR *) LocalAlloc(
					    LMEM_FIXED, 
					    (cwc + 1) * sizeof(WCHAR));
	    if (NULL == pwszStoreAlloc)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    swprintf(
		pwszStoreAlloc,
		wszFMTLDAPPREFIX,
		NULL != g_pwszDC? g_pwszDC : g_wszEmpty);
	    wcscat(pwszStoreAlloc, pwszStoreName);
	    pwszStoreName = pwszStoreAlloc;
	    pszStoreProvider = CERT_STORE_PROV_LDAP_W;
	    *pMode |= DVNS_DSSTORE;
	}
    }
    if (DVNS_DSSTORE & *pMode)
    {
	hr = PatchLdapURL(pwszStoreName, &pwszStoreAlloc2);
	if (S_FALSE != hr)
	{
	    _JumpIfError(hr, error, "PatchLdapURL");

	    pwszStoreName = pwszStoreAlloc2;
	}
    }

    if (NULL != ppwszStoreNameOut)
    {
	hr = myDupString(pwszStoreName, &pwszStoreNameOut);
	_JumpIfError(hr, error, "myDupString");
    }
    if ((DVNS_DSSTORE & *pMode) &&
	0 == ((DVNS_REPAIRKPI | DVNS_WRITESTORE) & *pMode))
    {
	wprintf(L"%ws\n", pwszStoreName);
	*phStore = myUrlCertOpenStore(
				CRYPT_WIRE_ONLY_RETRIEVAL |
				    CRYPT_RETRIEVE_MULTIPLE_OBJECTS,
				pwszStoreName);
	if (NULL == *phStore)
	{
	    hr = myHLastError();
	    _PrintErrorStr(hr, "myUrlCertOpenStore", pwszStoreName);
	    if (CRYPT_E_NOT_FOUND != hr)
	    {
		_JumpError(hr, error, "myUrlCertOpenStore");
	    }
	}
    }
    if (NULL == *phStore)
    {
	*phStore = CertOpenStore(
		    pszStoreProvider,
		    X509_ASN_ENCODING,
		    NULL,		// hProv
		    CERT_STORE_NO_CRYPT_RELEASE_FLAG |
			CERT_STORE_ENUM_ARCHIVED_FLAG |
			(((DVNS_REPAIRKPI | DVNS_WRITESTORE) & *pMode)?
			    0 : CERT_STORE_READONLY_FLAG) |
			(g_fForce? 0 : CERT_STORE_OPEN_EXISTING_FLAG) |
			cuGetSystemStoreFlags(),
		    pwszStoreName);
	if (NULL == *phStore)
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, "CertOpenStore", pwszStoreName);
	}
    }
    if (NULL != ppwszStoreNameOut)
    {
	*ppwszStoreNameOut = pwszStoreNameOut;
	pwszStoreNameOut = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszStoreAlloc)
    {
	LocalFree(pwszStoreAlloc);
    }
    if (NULL != pwszStoreAlloc2)
    {
	LocalFree(pwszStoreAlloc2);
    }
    if (NULL != pwszStoreNameOut)
    {
	LocalFree(pwszStoreNameOut);
    }
    return(hr);
}


HRESULT
DumpAndVerifyNamedStore(
    IN WCHAR const *pwszStoreName,
    IN DWORD Mode,
    OPTIONAL IN WCHAR const *pwszCertName,
    IN DWORD iCertSave,
    IN DWORD iCRLSave,
    IN DWORD iCTLSave,
    OPTIONAL IN WCHAR const *pwszfnOut,
    OPTIONAL IN WCHAR const *pwszPassword)
{
    HRESULT hr;
    HCERTSTORE hStore = NULL;

    hr = cuOpenCertStore(pwszStoreName, &Mode, NULL, &hStore);
    _JumpIfError(hr, error, "cuOpenCertStore");

    hr = cuDumpAndVerifyStore(
			hStore,
			Mode,
			pwszCertName,
			iCertSave,
			iCRLSave,
			iCTLSave,
			pwszfnOut,
			pwszPassword);
    _JumpIfError(hr, error, "cuDumpAndVerifyStore");

error:
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
myDupStringN(
    IN WCHAR const *pwszIn,
    IN DWORD cwc,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    
    CSASSERT(wcslen(pwszIn) >= cwc);
    *ppwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppwszOut, pwszIn, cwc * sizeof(WCHAR));
    (*ppwszOut)[cwc] = L'\0';
    hr = S_OK;

error:
    return(hr);
}


#define URLI_DC		0
#define URLI_DN		1
#define URLI_ATTRIBUTE	2
#define URLI_SCOPE	3
#define URLI_CLASS	4
#define URLI_MAX	5

HRESULT
ParseLdapUrl(
    IN WCHAR const *pwszIn,
    OUT WCHAR *ppwszOut[URLI_MAX])
{
    HRESULT hr;
    WCHAR *pwszAlloc = NULL;
    WCHAR awcLdap[ARRAYSIZE(wszLDAPCOLONSLASH)];
    DWORD cSlash;
    WCHAR const *pwsz;
    DWORD i;
    
    ZeroMemory(ppwszOut, URLI_MAX * sizeof(*ppwszOut));
    wcsncpy(awcLdap, pwszIn, ARRAYSIZE(awcLdap) - 1);
    awcLdap[ARRAYSIZE(awcLdap) - 1] = L'\0';
    if (0 != LSTRCMPIS(awcLdap, wszLDAPCOLONSLASH))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "ldap:URL");
    }

    hr = myInternetUncanonicalizeURL(pwszIn, &pwszAlloc);
    _JumpIfError(hr, error, "myInternetUncanonicalizeURL");

    pwszIn = pwszAlloc;
    pwszIn += WSZARRAYSIZE(wszLDAPCOLONSLASH);

    cSlash = 1;
    while (L'/' == *pwszIn)
    {
	pwszIn++;
	cSlash++;
    }
    if (2 == cSlash)
    {
	pwsz = pwszIn;
	while (L'\0' != *pwszIn && L'/' != *pwszIn)
	{
	    pwszIn++;
	}
	hr = myDupStringN(
		    pwsz,
		    SAFE_SUBTRACT_POINTERS(pwszIn, pwsz),
		    &ppwszOut[0]);
	_JumpIfError(hr, error, "myDupStringN");

	if (L'\0' != *pwszIn)
	{
	    pwszIn++;
	}
    }
    for (i = 1; i < URLI_MAX; i++)
    {
	pwsz = pwszIn;
	while (L'\0' != *pwszIn && L'?' != *pwszIn)
	{
	    pwszIn++;
	}
	hr = myDupStringN(
		    pwsz,
		    SAFE_SUBTRACT_POINTERS(pwszIn, pwsz),
		    &ppwszOut[i]);
	_JumpIfError(hr, error, "myDupStringN");

	if (L'\0' == *pwszIn)
	{
	    break;
	}
	pwszIn++;
    }
    hr = S_OK;

error:
    for (i = 0; i < ARRAYSIZE(ppwszOut); i++)
    {
	wprintf(L"DeleteLastLdapValue[%u](%ws)\n", i, ppwszOut[i]);
    }
    if (S_OK != hr)
    {
	for (i = 0; i < URLI_MAX; i++)
	{
	    if (NULL != ppwszOut[i])
	    {
		LocalFree(ppwszOut[i]);
		ppwszOut[i] = NULL;
	    }
	}
    }
    if (NULL != pwszAlloc)
    {
	LocalFree(pwszAlloc);
    }
    return(hr);
}


HRESULT
myLdapDeleteLastValue(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    OPTIONAL IN BYTE const *pb,
    IN DWORD cb,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    DWORD cres;
    DWORD cber;
    DWORD iber;
    DWORD i;
    LDAP_TIMEVAL timeval;
    LDAPMessage *pmsg = NULL;
    LDAPMessage *pres;
    WCHAR *apwszAttrs[2];
    struct berval **ppberval = NULL;
    struct berval *rgpberVals[2];
    struct berval certberval;
    LDAPMod *mods[2];
    LDAPMod certmod;
    char chZero = '\0';

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }

    apwszAttrs[0] = const_cast<WCHAR *>(pwszAttribute);
    apwszAttrs[1] = NULL;

    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;

    hr = ldap_search_st(
		pld,			// ld
		const_cast<WCHAR *>(pwszDN), // base
		LDAP_SCOPE_BASE,	// scope
		NULL,			// filter
		apwszAttrs,		// attrs
		FALSE,			// attrsonly
		&timeval,		// timeout
		&pmsg);			// res
    if (S_OK != hr)
    {
	*pdwDisposition = hr;
	hr = myHLdapError(pld, hr, NULL);
	_JumpErrorStr(hr, error, "ldap_search_st", pwszDN);
    }
    cres = ldap_count_entries(pld, pmsg);
    if (1 != cres)
    {
	// Exactly one entry was not found.

	hr = NTE_NOT_FOUND;
	_JumpError(hr, error, "ldap_count_entries");
    }

    pres = ldap_first_entry(pld, pmsg); 
    if (NULL == pres)
    {
	hr = NTE_NOT_FOUND;
	_JumpError(hr, error, "ldap_first_entry");
    }

    ppberval = ldap_get_values_len(
				pld,
				pres,
				const_cast<WCHAR *>(pwszAttribute));
    hr = NTE_NOT_FOUND;
    if (NULL == ppberval)
    {
	_JumpError(hr, error, "ppberval");
    }
    cber = 0;
    while (NULL != ppberval[cber])
    {
	cber++;
    }
    if (NULL != pb)
    {
	if (1 != cber)
	{
	    _JumpError(hr, error, "cber");
	}
	if (ppberval[0]->bv_len != cb ||
	    0 != memcmp(ppberval[0]->bv_val, pb, cb))
	{
	    _JumpError(hr, error, "memcmp");
	}
    }

    // set disposition assuming there's nothing to do:

    *pdwDisposition = LDAP_ATTRIBUTE_OR_VALUE_EXISTS;

    mods[0] = &certmod;
    mods[1] = NULL;

    certmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
    certmod.mod_type = const_cast<WCHAR *>(pwszAttribute);
    certmod.mod_bvalues = rgpberVals;

    rgpberVals[0] = &certberval;
    rgpberVals[1] = NULL;

    certberval.bv_val = &chZero;
    certberval.bv_len = sizeof(chZero);

    hr = ldap_modify_ext_s(
		    pld,
		    const_cast<WCHAR *>(pwszDN), // base
		    mods,
		    NULL,
		    NULL);
    *pdwDisposition = hr;
    if (hr != S_OK)
    {
	hr = myHLdapError(pld, hr, ppwszError);
	_JumpError(hr, error, "ldap_modify_ext_s");
    }
    hr = S_OK;

error:
    if (NULL != ppberval)
    {
	ldap_value_free_len(ppberval);
    }
    if (NULL != pmsg)
    {
	ldap_msgfree(pmsg);
    }
    return(hr);
}


HRESULT
DeleteLastLdapValue(
    IN WCHAR const *pwszURL,
    OPTIONAL IN BYTE const *pb,
    IN DWORD cb)
{
    HRESULT hr;
    WCHAR *rgpwsz[URLI_MAX];
    DWORD i;
    DWORD dwDisposition;
    WCHAR *pwszError = NULL;
    LDAP *pld = NULL;

    ZeroMemory(rgpwsz, sizeof(rgpwsz));

    hr = ParseLdapUrl(pwszURL, rgpwsz);
    _JumpIfErrorStr(hr, error, "ParseLdapUrl", pwszURL);

    if (NULL != rgpwsz[URLI_SCOPE] &&
	0 != mylstrcmpiS(rgpwsz[URLI_SCOPE], &wszDSBASESEARCH[1]))
    {
	hr = E_INVALIDARG;
	_JumpErrorStr(hr, error, "ldap scope", rgpwsz[URLI_SCOPE]);
    }

    hr = myLdapOpen(rgpwsz[URLI_DC], 0, &pld, NULL, NULL);
    _JumpIfError(hr, error, "myLdapOpen");

    hr = myLdapDeleteLastValue(
		    pld,
		    rgpwsz[URLI_DN],
		    rgpwsz[URLI_ATTRIBUTE],
		    pb,
		    cb,
		    &dwDisposition,
		    &pwszError);
    _JumpIfErrorStr(hr, error, "myLdapDeleteLastValue", pwszError);

error:
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    for (i = 0; i < ARRAYSIZE(rgpwsz); i++)
    {
	if (NULL != rgpwsz[i])
	{
	    wprintf(L"DeleteLastLdapValue[%u](%ws)\n", i, rgpwsz[i]);
	    LocalFree(rgpwsz[i]);
	}
    }
    myLdapClose(pld, NULL, NULL);
    return(hr);
}


HRESULT
CommitStore(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszStoreName,
    IN DWORD Mode,
    OPTIONAL IN BYTE const *pb,
    IN DWORD cb)
{
    HRESULT hr;
    
    if (!CertControlStore(hStore, 0, CERT_STORE_CTRL_COMMIT, NULL))
    {
	// Add workaround for LdapMapErrorToWin32 incorrect mapping 
	// LDAP_OBJECT_CLASS_VIOLATION -> E_INVALIDARG. Mapping it to
	// the correct code should be pretty safe, CertControlStore
	// shouldn't otherwise fail with this error code since we know
	// our code passes the right parameters.

	hr = myHLastError();
	_PrintError(hr, "CertControlStore");

	if (DVNS_DSSTORE & Mode)
	{
	    if (E_INVALIDARG == HRESULT_FROM_WIN32(hr))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION);
		_PrintError(hr, "CertControlStore");
	    }
	    if (HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION) == hr)
	    {
		hr = DeleteLastLdapValue(pwszStoreName, pb, cb);
		_JumpIfError(hr, error, "DeleteLastLdapValue");
	    }
	}
	_JumpIfError(hr, error, "CertControlStore");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
verbViewOrDeleteStore(
    IN WCHAR const *pwszOption,
    OPTIONAL IN WCHAR const *pwszStoreName,
    OPTIONAL IN WCHAR const *pwszCertId,
    OPTIONAL IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    WCHAR *pwszStoreNameNew = NULL;
    DWORD Mode;
    DWORD iCert;
    DWORD iCRL;
    DWORD iCTL;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pCert = NULL;
    CERT_CONTEXT const *pCertDeleted = NULL;
    BOOL fDelete = g_wszViewDelStore == pwszOption;
    WCHAR *pwszSubject = NULL;

    hr = ParseCertCRLIndex(pwszCertId, &pwszCertName, &iCert, &iCRL, &iCTL);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertId);

    Mode = DVNS_SAVECERT;
    if (fDelete)
    {
	Mode |= DVNS_WRITESTORE;
    }

    hr = cuOpenCertStore(pwszStoreName, &Mode, &pwszStoreNameNew, &hStore);
    _JumpIfError(hr, error, "cuOpenCertStore");

    hr = myGetCertificateFromPicker(
		g_hInstance,		// hInstance
		NULL,			// hwndParent
		IDS_VIEWSTORE_TITLE,	// idTitle
		fDelete? IDS_VIEWSTORE_SUBTITLE_DELETE :
			 IDS_VIEWSTORE_SUBTITLE, // idSubTitle
		0,			// dwFlags -- CUCS_*
		pwszCertName,		// pwszCommonName
		1,			// cStore
		&hStore,		// rghStore
		0,			// cpszObjId
		NULL,			// apszObjId
		&pCert);		// ppCert
    _JumpIfError(hr, error, "myGetCertificateFromPicker");

    if (NULL != pCert)
    {
	hr = myCertNameToStr(
		    X509_ASN_ENCODING,
		    &pCert->pCertInfo->Subject,
		    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    &pwszSubject);
	_JumpIfError(hr, error, "myCertNameToStr");

	if (NULL != pwszfnOut)
	{
	    hr = EncodeToFileW(
			pwszfnOut,
			pCert->pbCertEncoded,
			pCert->cbCertEncoded,
			CRYPT_STRING_BINARY | g_EncodeFlags);
	    _JumpIfError(hr, error, "EncodeToFileW");
	    wprintf(
		myLoadResourceString(
		    IDS_FORMAT_SAVED_CERT_NAME), // "Saved certificate %ws"
		    pwszSubject);
	    wprintf(L": %ws\n", pwszfnOut);
	}
	if (fDelete)
	{
	    pCertDeleted = CertDuplicateCertificateContext(pCert);
	    if (!CertDeleteCertificateFromStore(pCert))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertDeleteCertificateFromStore");
	    }
	    pCert = NULL;

	    hr = CommitStore(
			hStore,
			pwszStoreNameNew,
			Mode,
			pCertDeleted->pbCertEncoded,
			pCertDeleted->cbCertEncoded);
	    _JumpIfError(hr, error, "CommitStore");

	    wprintf(
		myLoadResourceString(
		    IDS_FORMAT_DELETED_CERT_NAME), // "Deleted certificate %ws"
		    pwszSubject);
	    wprintf(wszNewLine);
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszSubject)
    {
	LocalFree(pwszSubject);
    }
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    if (NULL != pwszStoreNameNew)
    {
	LocalFree(pwszStoreNameNew);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != pCertDeleted)
    {
	CertFreeCertificateContext(pCertDeleted);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
verbStore(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszCertId,
    IN WCHAR const *pwszfnOut,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    DWORD iCert;
    DWORD iCRL;
    DWORD iCTL;

    hr = ParseCertCRLIndex(pwszCertId, &pwszCertName, &iCert, &iCRL, &iCTL);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertId);

    hr = DumpAndVerifyNamedStore(
		    pwszStoreName,
		    DVNS_SAVECERT |
			DVNS_SAVECRL |
			DVNS_SAVECTL |
			DVNS_DUMP |
			DVNS_DUMPKEYS |
			DVNS_DUMPPROPERTIES,
		    pwszCertName,
		    iCert,
		    iCRL,
		    iCTL,
		    pwszfnOut,
		    NULL);
    _JumpIfError(hr, error, "DumpAndVerifyNamedStore");

error:
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    return(hr);
}


HRESULT
DisplayAddResult(
    OPTIONAL IN CERT_NAME_BLOB const *pName,
    IN DWORD Index,
    IN DWORD idsMsg)
{
    HRESULT hr = S_OK;
    WCHAR *pwszName = NULL;
    WCHAR wszIndex[cwcDWORDSPRINTF];

    if (NULL != pName)
    {
	hr = myCertNameToStr(
		    X509_ASN_ENCODING,
		    pName,
		    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    &pwszName);
	_JumpIfError(hr, error, "myCertNameToStr");
    }
    else
    {
	swprintf(wszIndex, L"%u", Index);
    }
    wprintf(myLoadResourceString(idsMsg), NULL != pName? pwszName : wszIndex);
    wprintf(wszNewLine);

error:
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    return(hr);
}


HRESULT
AddCertToStore(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszStoreName,
    IN CERT_CONTEXT const *pccAdd,
    IN DWORD Index)
{
    HRESULT hr;
    BOOL fRoot = FALSE;
    CERT_CONTEXT const *pcc = NULL;
    DWORD cDup;
    DWORD cDisplay;
    DWORD i;

    if (CertCompareCertificateName(
		    X509_ASN_ENCODING,
		    &pccAdd->pCertInfo->Issuer,
		    &pccAdd->pCertInfo->Subject))
    {
	hr = cuVerifySignature(
			pccAdd->pbCertEncoded,
			pccAdd->cbCertEncoded,
			&pccAdd->pCertInfo->SubjectPublicKeyInfo,
			FALSE,
			FALSE);
	fRoot = S_OK == hr;
	_PrintIfError(hr, "cuVerifySignature");
    }
    if (0 == LSTRCMPIS(pwszStoreName, wszROOT_CERTSTORE) &&
	!fRoot &&
	!g_fForce)
    {
	wprintf(myLoadResourceString(IDS_ROOT_STORE_NEEDS_ROOT_CERT));  // "Cannot add a non-root certificate to the root store"
	wprintf(wszNewLine);
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Non-root cert");
    }

    cDup = 0;
    cDisplay = 0;
    for (i = 0; ; i++)
    {
	pcc = CertEnumCertificatesInStore(hStore, pcc);
	if (NULL == pcc)
	{
	    break;
	}

	// Skip Certs for other Subjects

	if (!CertCompareCertificateName(
			    X509_ASN_ENCODING,
			    &pcc->pCertInfo->Issuer,
			    &pccAdd->pCertInfo->Issuer))
	{
	    continue;
	}

	// Skip Certs with different public keys

	if (!CertComparePublicKeyInfo(
			  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
			  &pcc->pCertInfo->SubjectPublicKeyInfo,
			  &pccAdd->pCertInfo->SubjectPublicKeyInfo))
	{
	    continue;
	}

	if (0 == cDisplay++)
	{
	    wprintf(myLoadResourceString(IDS_RELATED_CERTS_COLON)); // "Related Certificates:"
	    wprintf(wszNewLine);
	}
	wprintf(wszNewLine);

	// Remember if an exact match exists

	if (pcc->cbCertEncoded == pccAdd->cbCertEncoded &&
	    0 == memcmp(
		    pcc->pbCertEncoded,
		    pccAdd->pbCertEncoded,
		    pcc->cbCertEncoded))
	{
	    cDup++;
	    wprintf(myLoadResourceString(IDS_EXACT_MATCH_COLON)); // "Exact match:"
	    wprintf(wszNewLine);
	}
	hr = cuDumpAsnBinaryQuiet(
			pcc->pbCertEncoded,
			pcc->cbCertEncoded,
			i);
	_PrintIfError(hr, "cuDumpAsnBinaryQuiet");
    }

    if (0 == cDup)
    {
	if (!CertAddCertificateContextToStore(
					hStore,
					pccAdd,
					CERT_STORE_ADD_ALWAYS,
					NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertAddCertificateContextToStore");
	}
    }
    else
    {
	wprintf(wszNewLine);
    }

    hr = DisplayAddResult(
	    &pccAdd->pCertInfo->Subject,
	    Index,
	    0 != cDup?
		IDS_FORMAT_CERT_ALREADY_IN_STORE : // "Certificate ""%ws"" already in store."
		IDS_FORMAT_CERT_ADDED_TO_STORE);   // "Certificate ""%ws"" added to store."
    _JumpIfError(hr, error, "DisplayAddResult");

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
AddCRLToStore(
    IN HCERTSTORE hStore,
    IN CRL_CONTEXT const *pCRLAdd,
    IN DWORD Index)
{
    HRESULT hr;
    CRL_CONTEXT const *pCRL = NULL;
    DWORD cDup;
    DWORD cDisplay;
    BOOL fDeltaAdd;
    BOOL fDelta;
    DWORD NameId;
    DWORD NameIdAdd;
    DWORD i;

    hr = myIsDeltaCRL(pCRLAdd, &fDeltaAdd);
    _JumpIfError(hr, error, "myIsDeltaCRL");

    hr = myGetCRLNameId(pCRLAdd, &NameIdAdd);
    _PrintIfError2(hr, "DisplayAddResult", hr);

    cDup = 0;
    cDisplay = 0;
    for (i = 0; ; i++)
    {
	pCRL = CertEnumCRLsInStore(hStore, pCRL);
	if (NULL == pCRL)
	{
	    break;
	}
	hr = myIsDeltaCRL(pCRL, &fDelta);
	_JumpIfError(hr, error, "myIsDeltaCRL");

	// Skip base or delta CRLs when we're looking for the other.

	if (fDeltaAdd ^ fDelta)
	{
	    continue;
	}

	// Skip CRLs for other Issuers

	if (!CertCompareCertificateName(
			    X509_ASN_ENCODING,
			    &pCRL->pCrlInfo->Issuer,
			    &pCRLAdd->pCrlInfo->Issuer))
	{
	    continue;
	}
	hr = myGetCRLNameId(pCRL, &NameId);
	_PrintIfError2(hr, "DisplayAddResult", hr);

	// Skip CRLs for different CA keys

	if (MAXDWORD != NameIdAdd && MAXDWORD != NameId)
	{
	    if (CANAMEIDTOIKEY(NameIdAdd) != CANAMEIDTOIKEY(NameId))
	    {
		continue;
	    }
	}

	if (0 == cDisplay++)
	{
	    wprintf(myLoadResourceString(IDS_RELATED_CRLS_COLON)); // "Related CRLs:"
	    wprintf(wszNewLine);
	}
	wprintf(wszNewLine);

	// Remember if an exact match exists

	if (pCRL->cbCrlEncoded == pCRLAdd->cbCrlEncoded &&
	    0 == memcmp(
		    pCRL->pbCrlEncoded,
		    pCRLAdd->pbCrlEncoded,
		    pCRL->cbCrlEncoded))
	{
	    cDup++;
	    wprintf(myLoadResourceString(IDS_EXACT_MATCH_COLON)); // "Exact match:"
	    wprintf(wszNewLine);
	}
	hr = cuDumpAsnBinaryQuiet(
			pCRL->pbCrlEncoded,
			pCRL->cbCrlEncoded,
			i);
	_PrintIfError(hr, "cuDumpAsnBinaryQuiet");
    }

    if (0 == cDup)
    {
	if (!CertAddCRLContextToStore(
				hStore,
				pCRLAdd,
				CERT_STORE_ADD_ALWAYS,
				NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertAddCRLContextToStore");
	}
    }
    else
    {
	wprintf(wszNewLine);
    }

    hr = DisplayAddResult(
	    &pCRLAdd->pCrlInfo->Issuer,
	    Index,
	    0 != cDup?
	IDS_FORMAT_CRL_ALREADY_IN_STORE : // "CRL ""%ws"" already in store."
	IDS_FORMAT_CRL_ADDED_TO_STORE);   // "CRL ""%ws"" added to store."
    _JumpIfError(hr, error, "DisplayAddResult");

error:
    if (NULL != pCRL)
    {
	CertFreeCRLContext(pCRL);
    }
    return(hr);
}


HRESULT
AddCTLToStore(
    IN HCERTSTORE hStore,
    IN CTL_CONTEXT const *pCTL,
    IN DWORD Index)
{
    HRESULT hr;
    BOOL fDup = FALSE;

    if (!CertAddCTLContextToStore(hStore, pCTL, CERT_STORE_ADD_NEW, NULL))
    {
	hr = myHLastError();
	if (CRYPT_E_EXISTS != hr)
	{
	    _JumpError(hr, error, "CertAddCTLContextToStore");
	}
	fDup = TRUE;
    }
    hr = DisplayAddResult(
	    NULL,
	    Index,
	    fDup?
	IDS_FORMAT_CTL_ALREADY_IN_STORE : // "CTL ""%ws"" already in store."
	IDS_FORMAT_CTL_ADDED_TO_STORE);   // "CTL ""%ws"" added to store."
    _JumpIfError(hr, error, "DisplayAddResult");

error:
    return(hr);
}


HRESULT
AddCertToStoreFromFile(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszfnIn,
    OUT BOOL *pfBadAsn)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    BOOL fRoot = FALSE;

    *pfBadAsn = FALSE;

    // Load and decode certificate

    hr = cuLoadCert(pwszfnIn, &pCert);
    if (CRYPT_E_ASN1_BADTAG == hr)
    {
	*pfBadAsn = TRUE;
    }
    _JumpIfError(hr, error, "cuLoadCert");

    hr = AddCertToStore(hStore, pwszStoreName, pCert, 0);
    _JumpIfError(hr, error, "AddCertToStore");

error:
    cuUnloadCert(&pCert);
    return(hr);
}


HRESULT
AddCRLToStoreFromFile(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszfnIn,
    OUT BOOL *pfBadAsn)
{
    HRESULT hr;
    CRL_CONTEXT const *pCRL = NULL;

    *pfBadAsn = FALSE;

    hr = cuLoadCRL(pwszfnIn, &pCRL);
    if (CRYPT_E_ASN1_BADTAG == hr)
    {
	*pfBadAsn = TRUE;
    }
    _JumpIfError(hr, error, "cuLoadCRL");

    hr = AddCRLToStore(hStore, pCRL, 0);
    _JumpIfError(hr, error, "AddCRLToStore");

error:
    cuUnloadCRL(&pCRL);
    return(hr);
}


HRESULT
AddPKCS7ToStoreFromFile(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszfnIn)
{
    HRESULT hr;
    BYTE *pb = NULL;
    DWORD cb;
    HCERTSTORE hStorePKCS7 = NULL;
    DWORD i;
    CERT_CONTEXT const *pCert = NULL;
    CRL_CONTEXT const *pCRL = NULL;
    CTL_CONTEXT const *pCTL = NULL;

    hr = DecodeFileW(pwszfnIn, &pb, &cb, CRYPT_STRING_ANY);
    if (S_OK != hr)
    {
	cuPrintError(IDS_ERR_FORMAT_DECODEFILE, hr);
	goto error;
    }

    hr = myDecodePKCS7(
		    pb,
		    cb,
		    NULL,	// ppbContents
		    NULL,	// pcbContents
		    NULL,	// pdwMsgType
		    NULL,	// ppszInnerContentObjId
		    NULL,	// pcSigner
		    NULL,	// pcRecipient
		    &hStore,
		    NULL);	// phMsg
    _JumpIfError(hr, error, "myDecodePKCS7");

    for (i = 0; ; i++)
    {
	pCert = CertEnumCertificatesInStore(hStore, pCert);
	if (NULL == pCert)
	{
	    break;
	}
	hr = AddCertToStore(hStore, pwszStoreName, pCert, i);
	_JumpIfError(hr, error, "AddCertToStore");
    }

    for (i = 0; ; i++)
    {
	pCRL = CertEnumCRLsInStore(hStore, pCRL);
	if (NULL == pCRL)
	{
	    break;
	}
	hr = AddCRLToStore(hStore, pCRL, i);
	_JumpIfError(hr, error, "AddCRLToStore");
    }

    for (i = 0; ; i++)
    {
	pCTL = CertEnumCTLsInStore(hStore, pCTL);
	if (NULL == pCTL)
	{
	    break;
	}
	hr = AddCTLToStore(hStore, pCTL, i);
	_JumpIfError(hr, error, "AddCTLToStore");
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != pCRL)
    {
	CertFreeCRLContext(pCRL);
    }
    if (NULL != pCTL)
    {
	CertFreeCTLContext(pCTL);
    }
    if (NULL != hStorePKCS7)
    {
	CertCloseStore(hStorePKCS7, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
verbAddStore(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszfnIn,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    DWORD Mode;
    HCERTSTORE hStore = NULL;
    BOOL fBadAsn;

    Mode = DVNS_WRITESTORE;	// force open for write

    hr = cuOpenCertStore(pwszStoreName, &Mode, NULL, &hStore);
    if (S_OK != hr)
    {
	wprintf(
	    myLoadResourceString(
		g_fForce?
		    IDS_CANNOT_CREATE_STORE :   // "Cannot open Cert store."
		    IDS_CANNOT_OPEN_STORE),
	    L"-f");   // "Cannot open existing Cert store.  Use %ws switch to force Cert store creation."
	wprintf(wszNewLine);
        _JumpErrorStr(hr, error, "cuOpenCertStore", pwszStoreName);
    }

    hr = AddCertToStoreFromFile(hStore, pwszStoreName, pwszfnIn, &fBadAsn);
    if (S_OK != hr)
    {
	if (!fBadAsn)
	{
	    _JumpError(hr, error, "AddCertToStoreFromFile");
	}
	hr = AddCRLToStoreFromFile(hStore, pwszfnIn, &fBadAsn);
	if (S_OK != hr)
	{
	    if (!fBadAsn)
	    {
		_JumpError(hr, error, "AddCRLToStoreFromFile");
	    }
	    hr = AddPKCS7ToStoreFromFile(hStore, pwszStoreName, pwszfnIn);
	    _JumpIfError(hr, error, "AddPKCS7ToStoreFromFile");
	}
    }
    CSASSERT(S_OK == hr);

error:
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
SaveFirstBlob(
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT BYTE **ppbDeleted,
    IN OUT DWORD *pcbDeleted)
{
    HRESULT hr;
    
    if (NULL == *ppbDeleted)
    {
	*pcbDeleted = cbEncoded;
	*ppbDeleted = (BYTE *) LocalAlloc(LMEM_FIXED, cbEncoded);
	if (NULL == *ppbDeleted)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(*ppbDeleted, pbEncoded, cbEncoded);
    }
    hr = S_OK;

error:
    return(hr);
}

 
HRESULT
verbDelStore(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszCertId,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszStore = NULL;
    HCERTSTORE hStore = NULL;
    CERT_CONTEXT const *pCert = NULL;
    CRL_CONTEXT const *pCRL = NULL;
    WCHAR *pwszCertName = NULL;
    BYTE *pbHash = NULL;
    DWORD cbHash;
    BSTR strSerialNumber = NULL;
    DWORD Mode;
    DWORD iCert;
    DWORD iCertDel;
    DWORD iCRL;
    DWORD iCRLDel;
    DWORD iCTL;
    DWORD iCTLDel;
    DWORD cCertDeleted;
    DWORD cCRLDeleted;
    BYTE *pbDeleted = NULL;
    DWORD cbDeleted;

    if (NULL == pwszStoreName || 0 == wcscmp(L"*", pwszStoreName))
    {
        pwszStoreName = wszCA_CERTSTORE;
    }

    hr = ParseCertCRLIndex(pwszCertId, &pwszCertName, &iCertDel, &iCRLDel, &iCTLDel);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertId);

    if (MAXDWORD == iCertDel && NULL == pwszCertName && MAXDWORD == iCRLDel)
    {
	hr = E_INVALIDARG;
	_JumpErrorStr(hr, error, "incomplete Index arg", pwszCertId);
    }
    if (NULL != pwszCertName)
    {
	hr = WszToMultiByteInteger(TRUE, pwszCertName, &cbHash, &pbHash);
	_PrintIfError2(hr, "WszToMultiByteInteger", hr);

	hr = myMakeSerialBstr(pwszCertName, &strSerialNumber);
	_PrintIfError2(hr, "myMakeSerialBstr", hr);
    }

    Mode = DVNS_WRITESTORE;	// force open for write

    hr = cuOpenCertStore(pwszStoreName, &Mode, NULL, &hStore);
    _JumpIfError(hr, error, "cuOpenCertStore");

    cCertDeleted = 0;
    cCRLDeleted = 0;
    if (MAXDWORD != iCertDel || NULL != pwszCertName)
    {
	for (iCert = 0; ; iCert++)
	{
	    pCert = CertEnumCertificatesInStore(hStore, pCert);
	    if (NULL == pCert)
	    {
		break;
	    }
	    if (iCert == iCertDel ||
		(MAXDWORD == iCertDel && NULL != pwszCertName))
	    {
		CERT_CONTEXT const *pCertT;

		if (NULL != pwszCertName)
		{
		    BOOL fMatch;
		    
		    hr = myCertMatch(
				pCert,
				pwszCertName,
				FALSE,		// fAllowMissingCN
				pbHash,
				cbHash,
				strSerialNumber,
				&fMatch);
		    _JumpIfError(hr, error, "myCertMatch");

		    if (!fMatch)
		    {
			continue;
		    }
		}
		wprintf(
		    myLoadResourceString(IDS_FORMAT_DELETE_CERT_INDEX),  // "Deleting Certificate %d"
		    iCert);
		wprintf(wszNewLine);

		cCertDeleted++;
		SaveFirstBlob(
			pCert->pbCertEncoded,
			pCert->cbCertEncoded,
			&pbDeleted,
			&cbDeleted);
		pCertT = CertDuplicateCertificateContext(pCert);
		if (!CertDeleteCertificateFromStore(pCertT))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CertDeleteCertificateFromStore");
		}
		if (iCert == iCertDel)
		{
		    break;
		}
	    }
	}
    }
    if (MAXDWORD != iCRLDel || NULL != pwszCertName)
    {
	for (iCRL = 0; ; iCRL++)
	{
	    pCRL = CertEnumCRLsInStore(hStore, pCRL);
	    if (NULL == pCRL)
	    {
		break;
	    }
	    if (iCRL == iCRLDel ||
		(MAXDWORD == iCRLDel && NULL != pwszCertName))
	    {
		CRL_CONTEXT const *pCRLT;

		if (NULL != pwszCertName)
		{
		    BOOL fMatch;
		    
		    hr = myCRLMatch(
				pCRL,
				pwszCertName,
				FALSE,		// fAllowMissingCN
				pbHash,
				cbHash,
				&fMatch);
		    _JumpIfError(hr, error, "myCRLMatch");

		    if (!fMatch)
		    {
			continue;
		    }
		}
		wprintf(
		    myLoadResourceString(IDS_FORMAT_DELETE_CRL_INDEX),  // "Deleting CRL %d"
		    iCRL);
		wprintf(wszNewLine);

		cCRLDeleted++;
		SaveFirstBlob(
			pCRL->pbCrlEncoded,
			pCRL->cbCrlEncoded,
			&pbDeleted,
			&cbDeleted);
		pCRLT = CertDuplicateCRLContext(pCRL);
		if (!CertDeleteCRLFromStore(pCRLT))
		{
		    hr = myHLastError();
		    _JumpError(hr, error, "CertDeleteCRLFromStore");
		}
		if (iCRL == iCRLDel)
		{
		    break;
		}
	    }
	}
    }
    if (0 != cCertDeleted + cCRLDeleted)
    {
	BOOL fSingle = 1 == cCertDeleted + cCRLDeleted;

	hr = CommitStore(
		    hStore,
		    pwszStoreName,
		    Mode,
		    fSingle? pbDeleted : NULL,
		    fSingle? cbDeleted : 0);
	_JumpIfError(hr, error, "CommitStore");
    }
    hr = S_OK;

error:
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    if (NULL != pbDeleted)
    {
	LocalFree(pbDeleted);
    }
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    if (NULL != pwszStore)
    {
	LocalFree(pwszStore);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != pCRL)
    {
	CertFreeCRLContext(pCRL);
    }
    if (NULL != hStore)
    {
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
verbVerifyStore(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszCertId,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    DWORD iCert;
    DWORD iCRL;
    DWORD iCTL;

    hr = ParseCertCRLIndex(pwszCertId, &pwszCertName, &iCert, &iCRL, &iCTL);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertId);

    hr = DumpAndVerifyNamedStore(
		    pwszStoreName,
		    DVNS_SAVECERT |
			DVNS_SAVECRL |
			DVNS_SAVECTL |
			DVNS_VERIFYCERT |
			DVNS_DUMPKEYS |
			DVNS_DUMPPROPERTIES,
		    pwszCertName,
		    iCert,
		    iCRL,
		    iCTL,
		    NULL,
		    NULL);
    _JumpIfError(hr, error, "DumpAndVerifyNamedStore");

error:
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    return(hr);
}


HRESULT
verbRepairStore(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszStoreName,
    IN WCHAR const *pwszCertId,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    DWORD iCert;
    DWORD iCRL;
    DWORD iCTL;

    hr = ParseCertCRLIndex(pwszCertId, &pwszCertName, &iCert, &iCRL, &iCTL);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertId);

    hr = DumpAndVerifyNamedStore(
		    pwszStoreName,
		    DVNS_SAVECERT |
			DVNS_SAVECRL |
			DVNS_SAVECTL |
			DVNS_REPAIRKPI |
			DVNS_DUMPKEYS,
		    pwszCertName,
		    iCert,
		    iCRL,
		    iCTL,
		    NULL,
		    NULL);
    _JumpIfError(hr, error, "DumpAndVerifyNamedStore");

error:
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    return(hr);
}


HRESULT
verbExportPVK(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszCertId,
    IN WCHAR const *pwszfnPVKBaseName,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    DWORD iCert;
    DWORD iCRL;
    DWORD iCTL;

    hr = ParseCertCRLIndex(pwszCertId, &pwszCertName, &iCert, &iCRL, &iCTL);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertId);

    hr = DumpAndVerifyNamedStore(
		    wszMY_CERTSTORE,
		    DVNS_SAVEPVK | DVNS_DUMPKEYS,
		    pwszCertName,
		    iCert,
		    iCRL,
		    iCTL,
		    pwszfnPVKBaseName,
		    g_pwszPassword);
    _JumpIfError(hr, error, "DumpAndVerifyNamedStore");

error:
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    return(hr);
}


HRESULT
verbExportPFX(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszCertId,
    IN WCHAR const *pwszfnPFX,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    WCHAR *pwszCertName = NULL;
    DWORD iCert;
    DWORD iCRL;
    DWORD iCTL;

    hr = ParseCertCRLIndex(pwszCertId, &pwszCertName, &iCert, &iCRL, &iCTL);
    _JumpIfErrorStr(hr, error, "ParseCertCRLIndex", pwszCertId);

    hr = DumpAndVerifyNamedStore(
		    wszMY_CERTSTORE,
		    DVNS_SAVEPFX | DVNS_DUMPKEYS,
		    pwszCertName,
		    iCert,
		    iCRL,
		    iCTL,
		    pwszfnPFX,
		    g_pwszPassword);
    _JumpIfError(hr, error, "DumpAndVerifyNamedStore");

error:
    if (NULL != pwszCertName)
    {
	LocalFree(pwszCertName);
    }
    return(hr);
}


HRESULT
cuGenerateKeyContainerName(
    IN CERT_CONTEXT const *pcc,
    OUT WCHAR **ppwszKeyContainerName)
{
    HRESULT hr;
    GUID guid;
    WCHAR *pwszGUID = NULL;
    WCHAR *pwszSimpleName = NULL;
    WCHAR *pwszRawContainerName = NULL;
    DWORD cwc;
    
    *ppwszKeyContainerName = NULL;

    hr = myCertGetNameString(
			pcc,
			CERT_NAME_SIMPLE_DISPLAY_TYPE,
			&pwszSimpleName);
    _JumpIfError(hr, error, "myCertGetNameString");

    myUuidCreate(&guid);
    hr = myCLSIDToWsz(&guid, &pwszGUID);
    _JumpIfError(hr, error, "myCLSIDToWsz");

    cwc = wcslen(pwszSimpleName) + 1 + wcslen(pwszGUID);
    pwszRawContainerName = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszRawContainerName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszRawContainerName, pwszSimpleName);
    wcscat(pwszRawContainerName, L"-");
    wcscat(pwszRawContainerName, pwszGUID);

    hr = mySanitizeName(pwszRawContainerName, ppwszKeyContainerName);
    _JumpIfError(hr, error, "mySanitizeName");

    wprintf(L"%ws -- %ws\n", pwszSimpleName, *ppwszKeyContainerName);

error:
    if (NULL != pwszGUID)
    {
        LocalFree(pwszGUID);
    }
    if (NULL != pwszSimpleName)
    {
        LocalFree(pwszSimpleName);
    }
    if (NULL != pwszRawContainerName)
    {
        LocalFree(pwszRawContainerName);
    }
    return(hr);
}


HRESULT
cuImportChainAndKeys(
    IN CERT_CHAIN_CONTEXT const *pChain,
    OPTIONAL IN WCHAR const *pwszNewCSP,
    IN BOOL fUser,
    OPTIONAL IN WCHAR const *pwszStoreName)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    WCHAR *pwszKeyContainerName = NULL;
    CERT_CONTEXT const *pcc;

    if (NULL == pwszStoreName)
    {
	pwszStoreName = wszMY_CERTSTORE;
    }
    pcc = pChain->rgpChain[0]->rgpElement[0]->pCertContext;

    hr = myCertGetKeyProviderInfo(pcc, &pkpi);
    _JumpIfError(hr, error, "myCertGetKeyProviderInfo");

    hr = cuGenerateKeyContainerName(pcc, &pwszKeyContainerName);
    _JumpIfError(hr, error, "cuGenerateKeyContainerName");

    if (NULL == pwszNewCSP)
    {
	pwszNewCSP = pkpi->pwszProvName;
    }
    hr = myCopyKeys(
		pkpi,
		pkpi->pwszContainerName,	// pwszOldContainer
		pwszKeyContainerName,		// pwszNewContainer
		pwszNewCSP,			// pwszNewCSP
		fUser,				// fOldUserKey
		fUser,				// fNewUserKey
		g_fProtect,
		g_fForce);
    _JumpIfError(hr, error, "myCopyKeys");

    pkpi->pwszContainerName = pwszKeyContainerName;
    pkpi->pwszProvName = const_cast<WCHAR *>(pwszNewCSP);

    hr = mySaveChainAndKeys(
			pChain->rgpChain[0],
			pwszStoreName,
			cuGetSystemStoreFlags(),
			pkpi,
			NULL);
    _JumpIfError(hr, error, "mySaveChainAndKeys");

error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pwszKeyContainerName)
    {
        LocalFree(pwszKeyContainerName);
    }
    return(hr);
}


HRESULT
ReadPFXOrEPFIntoCertStore(
    IN WCHAR const *pwszfnPFXOrEPF,
    IN BOOL fUser,
    OUT HCERTSTORE *phStore)
{
    HRESULT hr;
    CRYPT_DATA_BLOB pfx;
    WCHAR const *pwszPassword;
    WCHAR wszPassword[MAX_PATH];
    HCERTSTORE hStore = NULL;

    pfx.pbData = NULL;
    *phStore = NULL;

    hr = cuGetPassword(
		    0,			// idsPrompt
		    NULL,		// pwszfn
		    g_pwszPassword,
		    FALSE,		// fVerify
		    wszPassword,
		    ARRAYSIZE(wszPassword),
		    &pwszPassword);
    _JumpIfError(hr, error, "cuGetPassword");

    hr = DecodeFileW(
		pwszfnPFXOrEPF,
		&pfx.pbData,
		&pfx.cbData,
		CRYPT_STRING_ANY);
    _JumpIfError(hr, error, "DecodeFileW");

    CSASSERT(NULL != pfx.pbData);

    if (PFXIsPFXBlob(&pfx))
    {
	hStore = myPFXImportCertStore(
		    &pfx,
		    pwszPassword,
		    CRYPT_EXPORTABLE | 
			(fUser? CRYPT_USER_KEYSET : CRYPT_MACHINE_KEYSET));
	if (NULL == hStore)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myPFXImportCertStore");
	}
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _PrintError(hr, "PFXIsPFXBlob");

	hStore = CertOpenStore(
			    CERT_STORE_PROV_MEMORY,
			    X509_ASN_ENCODING,
			    NULL,
			    CERT_STORE_NO_CRYPT_RELEASE_FLAG |
				CERT_STORE_ENUM_ARCHIVED_FLAG,
			    NULL);
	if (NULL == hStore)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertOpenStore");
	}
	hr = EPFFileDump(pwszfnPFXOrEPF, pwszPassword, hStore);
	if (S_FALSE == hr)	// if not an EPF file
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}
	_JumpIfErrorStr(hr, error, "EPFFileDump", pwszfnPFXOrEPF);
    }
    *phStore = hStore;
    hStore = NULL;
    hr = S_OK;

error:
    SecureZeroMemory(wszPassword, sizeof(wszPassword));	// password data
    if (NULL != hStore)
    {
        myDeleteGuidKeys(hStore, !fUser);
	CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pfx.pbData)
    {
        LocalFree(pfx.pbData);
    }
    return(hr);
}


HRESULT
verbImportPFX(
    IN WCHAR const *pwszOption,
    IN WCHAR const *pwszfnPFXOrEPF,
    IN WCHAR const *pwszArg2,
    IN WCHAR const *pwszArg3,
    IN WCHAR const *pwszArg4)
{
    HRESULT hr;
    HCERTSTORE hStorePFX = NULL;
    RESTORECHAIN *paRestoreChain = NULL;
    DWORD cRestoreChain;
    DWORD iChain;
    BOOL fUser = !g_fEnterpriseRegistry && g_fUserRegistry;

    hr = ReadPFXOrEPFIntoCertStore(pwszfnPFXOrEPF, fUser, &hStorePFX);
    _JumpIfError(hr, error, "ReadPFXOrEPFIntoCertStore");

    cRestoreChain = 0;
    hr = myGetChainArrayFromStore(
                                hStorePFX,
				FALSE,
				fUser,
                                NULL,		// ppwszCommonName
                                &cRestoreChain,
                                NULL);
    _JumpIfError(hr, error, "myGetChainArrayFromStore");

    if (0 == cRestoreChain)
    {
        hr = HRESULT_FROM_WIN32(CRYPT_E_SELF_SIGNED);
        _JumpError(hr, error, "myGetChainArrayFromStore <no chain>");
    }

    paRestoreChain = (RESTORECHAIN *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cRestoreChain * sizeof(paRestoreChain[0]));
    if (NULL == paRestoreChain)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    hr = myGetChainArrayFromStore(
			    hStorePFX,
			    FALSE,
			    fUser,
			    NULL,		// ppwszCommonName
			    &cRestoreChain,
			    paRestoreChain);
    _JumpIfError(hr, error, "myGetChainArrayFromStore");

    for (iChain = 0; iChain < cRestoreChain; iChain++)
    {
	CERT_CHAIN_CONTEXT const *pChain = paRestoreChain[iChain].pChain;
	CERT_PUBLIC_KEY_INFO *pPublicKeyInfo;

	if (1 > pChain->cChain)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "No Chain Context");
	}
	hr = cuImportChainAndKeys(pChain, g_pwszCSP, fUser, wszMY_CERTSTORE);
	_JumpIfError(hr, error, "cuImportChainAndKeys");
    }
    hr = S_OK;

error:
    if (NULL != paRestoreChain)
    {
        for (iChain = 0; iChain < cRestoreChain; iChain++)
	{
	    if (NULL != paRestoreChain[iChain].pChain)
	    {
		CertFreeCertificateChain(paRestoreChain[iChain].pChain);
	    }
	}
	LocalFree(paRestoreChain);
    }
    if (NULL != hStorePFX)
    {
        myDeleteGuidKeys(hStorePFX, !fUser);
	CertCloseStore(hStorePFX, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
AddStringToList(
    IN WCHAR const *pwszNew,
    IN OUT WCHAR ***papwsz)
{
    HRESULT hr;
    WCHAR *pwszAlloc = NULL;
    WCHAR **ppwsz;
    DWORD i;

    // Count the strings in the existing list.
    // If the new string matches an existing string, return imemdiately.

    ppwsz = *papwsz;
    i = 0;
    if (NULL != ppwsz)
    {
	for ( ; NULL != ppwsz[i]; i++)
	{
	    if (0 == lstrcmp(pwszNew, ppwsz[i]))
	    {
		hr = S_OK;
		goto error;
	    }
	}
    }
    hr = myDupString(pwszNew, &pwszAlloc);
    _JumpIfError(hr, error, "myDupString");

    ppwsz = (WCHAR **) LocalAlloc(LMEM_FIXED, (i + 2) * sizeof(*ppwsz));
    if (NULL == ppwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // Insert the new string at the head of the list.

    ppwsz[0] = pwszAlloc;
    pwszAlloc = NULL;
    if (0 != i)
    {
	CopyMemory(&ppwsz[1], *papwsz, i * sizeof(*ppwsz));
	LocalFree(*papwsz);
    }
    ppwsz[i + 1] = NULL;
    *papwsz = ppwsz;
    hr = S_OK;

error:
    if (NULL != pwszAlloc)
    {
	LocalFree(pwszAlloc);
    }
    return(hr);
}


HRESULT
AddPFXOrEPFToStoreSub(
    IN WCHAR const *pwszfn,
    IN WCHAR const *pwszPassword,
    OPTIONAL IN CRYPT_DATA_BLOB *ppfx,
    IN HCERTSTORE hStoreMerge)
{
    HRESULT hr;
    HCERTSTORE hStorePFX = NULL;
    CERT_CONTEXT const *pCert = NULL;

    if (NULL == ppfx)
    {
	hr = EPFFileDump(pwszfn, pwszPassword, hStoreMerge);
	if (S_FALSE == hr)	// if not an EPF file
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}
	_JumpIfErrorStr(hr, error, "EPFFileDump", pwszfn);
    }
    else
    {
	hStorePFX = myPFXImportCertStore(
			    ppfx,
			    pwszPassword,
			    CRYPT_EXPORTABLE |
				(g_fUserRegistry?
				    CRYPT_USER_KEYSET : CRYPT_MACHINE_KEYSET));
	if (NULL == hStorePFX)
	{
	    hr = myHLastError();
	    _JumpErrorStr2(
		    hr,
		    error,
		    "myPFXImportCertStore",
		    pwszfn,
		    HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
	}
	while (TRUE)
	{
	    pCert = CertEnumCertificatesInStore(hStorePFX, pCert);
	    if (NULL == pCert)
	    {
		break;
	    }
	    if (!CertAddCertificateContextToStore(
					    hStoreMerge,
					    pCert,
					    CERT_STORE_ADD_REPLACE_EXISTING,
					    NULL))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertAddCertificateContextToStore");
	    }
	    if (!CertDeleteCertificateFromStore(pCert))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertDeleteCertificateFromStore");
	    }
	    pCert = NULL;
	}
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    if (NULL != hStorePFX)
    {
        myDeleteGuidKeys(hStorePFX, !g_fUserRegistry);
	CertCloseStore(hStorePFX, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
myCryptGetDefaultProvider(
    DWORD dwProvType,
    DWORD dwFlags,
    WCHAR **ppwszProvName)
{
    HRESULT hr;
    DWORD cb;

    *ppwszProvName = NULL;
    cb = 0;
    while (TRUE)
    {
	if (!CryptGetDefaultProvider(
			    dwProvType,
			    NULL,		// pdwReserved
			    dwFlags,
			    *ppwszProvName,
			    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptGetDefaultProvider");
	}
	if (NULL != *ppwszProvName)
	{
	    break;
	}
	*ppwszProvName = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == *ppwszProvName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


#define cuSIGN_KEY_USAGE \
	(CERT_DIGITAL_SIGNATURE_KEY_USAGE | \
	 CERT_NON_REPUDIATION_KEY_USAGE | \
	 CERT_KEY_CERT_SIGN_KEY_USAGE | \
	 CERT_OFFLINE_CRL_SIGN_KEY_USAGE | \
	 CERT_CRL_SIGN_KEY_USAGE)

#define cuENCRYPT_KEY_USAGE \
	(CERT_KEY_ENCIPHERMENT_KEY_USAGE | \
	 CERT_DATA_ENCIPHERMENT_KEY_USAGE | \
	 CERT_KEY_AGREEMENT_KEY_USAGE | \
	 CERT_ENCIPHER_ONLY_KEY_USAGE)

static CHAR const *s_cuapszObjIdSign[] =
{
    szOID_PKIX_KP_CLIENT_AUTH,
    szOID_PKIX_KP_CODE_SIGNING,
    szOID_PKIX_KP_TIMESTAMP_SIGNING,
    szOID_KP_TIME_STAMP_SIGNING,
    szOID_KP_QUALIFIED_SUBORDINATION,
    szOID_KP_DOCUMENT_SIGNING,
    szOID_KP_SMARTCARD_LOGON,
};

static CHAR const *s_cuapszObjIdEncrypt[] =
{
    szOID_PKIX_KP_EMAIL_PROTECTION,
    szOID_KP_KEY_RECOVERY_AGENT,
    szOID_KP_KEY_RECOVERY,
    szOID_PKIX_KP_SERVER_AUTH,
};

BOOL
IsSigningCert(
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    BOOL fSigningCert = TRUE;
    CERT_EXTENSION const *pExt;
    DWORD cb;
    BOOL fMatch;

    pExt = CertFindExtension(
		    szOID_KEY_USAGE,
		    pcc->pCertInfo->cExtension,
		    pcc->pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	CRYPT_DATA_BLOB aBlob[1 + BLOB_ROUND(2)];

	cb = sizeof(aBlob);
	if (CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_KEY_USAGE,
			    pExt->Value.pbData,
			    pExt->Value.cbData,
			    0,
			    aBlob,
			    &cb))
	{
	    if (1 <= aBlob[0].cbData)
	    {
		if (cuSIGN_KEY_USAGE & aBlob[0].pbData[0])
		{
		    goto done;
		}
		if (cuENCRYPT_KEY_USAGE & aBlob[0].pbData[0])
		{
		    fSigningCert = FALSE;
		    goto done;
		}
	    }
	}
    }
    hr = myCertMatchEKUOrApplicationPolicies(
				    pcc,
				    ARRAYSIZE(s_cuapszObjIdSign),
				    s_cuapszObjIdSign,
				    FALSE,	// fUsageRequired
				    &fMatch);
    if (S_OK == hr && fMatch)
    {
	goto done;
    }
			
    hr = myCertMatchEKUOrApplicationPolicies(
				    pcc,
				    ARRAYSIZE(s_cuapszObjIdEncrypt),
				    s_cuapszObjIdEncrypt,
				    FALSE,	// fUsageRequired
				    &fMatch);
    if (S_OK == hr && fMatch)
    {
	fSigningCert = FALSE;
	goto done;
    }

done:
    return(fSigningCert);
}


HRESULT
AddCertAndKeyBlobToStore(
    IN HCERTSTORE hStore,
    IN CERT_CONTEXT const *pcc,
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    IN ALG_ID aiKeyAlg)
{
    HRESULT hr;
    BYTE *pbKeyAlloc = NULL;
    DWORD cbKeyAlloc;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    CRYPT_KEY_PROV_INFO kpi;
    WCHAR *pwszProviderName = NULL;
    WCHAR *pwszKeyContainerName = NULL;
    BOOL fSigningKey;
    BOOL fMatchingKey;
    BOOL fQuiet;

#if 0
    wprintf(wszNewLine);
    DumpHex(
	DH_NOTABPREFIX | DH_NOASCIIHEX | DH_PRIVATEDATA | 4,
	pbKey,
	cbKey);
#endif

    hr = cuGenerateKeyContainerName(pcc, &pwszKeyContainerName);
    _JumpIfError(hr, error, "cuGenerateKeyContainerName");

    hr = myCryptGetDefaultProvider(
			PROV_RSA_FULL,
			g_fUserRegistry?
			    CRYPT_USER_DEFAULT : CRYPT_MACHINE_DEFAULT,
			&pwszProviderName);
    _JumpIfError(hr, error, "myCryptGetDefaultProvider");

    if (!CryptAcquireContext(
			&hProv,
			pwszKeyContainerName,
			pwszProviderName,
			PROV_RSA_FULL,
			CRYPT_NEWKEYSET))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }

    if (PRIVATEKEYBLOB == ((PUBLICKEYSTRUC const *) pbKey)->bType &&
	CUR_BLOB_VERSION == ((PUBLICKEYSTRUC const *) pbKey)->bVersion &&
	RSAPRIV_MAGIC ==
	    ((RSAPUBKEY const *) &pbKey[sizeof(PUBLICKEYSTRUC)])->magic)
    {
	if (0 == aiKeyAlg)
	{
	    aiKeyAlg = ((PUBLICKEYSTRUC const *) pbKey)->aiKeyAlg;
	}
	else
	if (aiKeyAlg != ((PUBLICKEYSTRUC const *) pbKey)->aiKeyAlg)
	{
	    ((PUBLICKEYSTRUC *) pbKey)->aiKeyAlg = aiKeyAlg;
	}
    }
    if (0 == aiKeyAlg)
    {
	aiKeyAlg = IsSigningCert(pcc)? CALG_RSA_SIGN : CALG_RSA_KEYX;
    }
    if (!CryptImportKey(hProv, pbKey, cbKey, NULL, CRYPT_EXPORTABLE, &hKey))
    {
	hr = myHLastError();
	_PrintError(hr, "CryptImportKey");

	hr = myDecodeKMSRSAKey(
		    pbKey,
		    cbKey,
		    aiKeyAlg,
		    &pbKeyAlloc,
		    &cbKeyAlloc);
	_JumpIfError(hr, error, "myDecodeKMSRSAKey");

	pbKey = pbKeyAlloc;
	cbKey = cbKeyAlloc;

	//cuDumpPrivateKeyBlob(pbKey, cbKey, FALSE);
	if (!CryptImportKey(hProv, pbKey, cbKey, NULL, CRYPT_EXPORTABLE, &hKey))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptImportKey");
	}
    }
    ZeroMemory(&kpi, sizeof(kpi));
    kpi.pwszContainerName = pwszKeyContainerName;
    kpi.pwszProvName = pwszProviderName;
    kpi.dwProvType = PROV_RSA_FULL;
    kpi.dwKeySpec = CALG_RSA_SIGN == aiKeyAlg? AT_SIGNATURE : AT_KEYEXCHANGE;

    if (!CertSetCertificateContextProperty(
					pcc,
					CERT_KEY_PROV_INFO_PROP_ID,
					0,
					&kpi))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertSetCertificateContextProperty");
    }
    if (!CertAddCertificateContextToStore(
				    hStore,
				    pcc,
				    CERT_STORE_ADD_NEW,
				    NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertAddCertificateContextToStore");
    }

    fQuiet = g_fQuiet;
    g_fQuiet = TRUE;
    hr = cuDumpPrivateKey(pcc, &fSigningKey, &fMatchingKey);
    g_fQuiet = fQuiet;
    if (!IsHrSkipPrivateKey(hr))
    {
	if (S_OK != hr)
	{
	    wprintf(myLoadResourceString(
		fSigningKey?
		    IDS_SIGNATURE_BAD :   // "Signature test FAILED"
		    IDS_ENCRYPTION_BAD)); // "Encryption test FAILED"
	    wprintf(wszNewLine);
	    _PrintError(hr, "cuDumpPrivateKey");
	    fMatchingKey = FALSE;
	}

	if (fMatchingKey)
	{
	    wprintf(myLoadResourceString(
		fSigningKey?
		    IDS_SIGNATURE_OK :   // "Signature test passed"
		    IDS_ENCRYPTION_OK)); // "Encryption test passed"
	    wprintf(wszNewLine);
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszProviderName)
    {
        LocalFree(pwszProviderName);
    }
    if (NULL != pwszKeyContainerName)
    {
        LocalFree(pwszKeyContainerName);
    }
    if (NULL != hKey)
    {
	CryptDestroyKey(hKey);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != pbKeyAlloc)
    {
	SecureZeroMemory(pbKeyAlloc, cbKeyAlloc);	// Key material
	LocalFree(pbKeyAlloc);
    }
    return(hr);
}


#define cwcEXTMAX	4

typedef struct _KEYEXTENSION {
    WCHAR const *pwszExt;
    ALG_ID      aiKeyAlg;
} KEYEXTENSION;

KEYEXTENSION s_akePrivate[] =
{
    { L".sig", CALG_RSA_SIGN },
    { L".enc", CALG_RSA_KEYX },
    { L".key", 0 },
    { L".pri", 0 },
};


HRESULT
AddCertAndKeyToStore(
    IN CERT_CONTEXT const *pcc,
    IN WCHAR const *pwszfn,
    IN HCERTSTORE hStore,
    IN BYTE const *pbCert,
    IN DWORD cbCert)
{
    HRESULT hr;
    WCHAR *pwszfnKey = NULL;
    WCHAR *pwszfnExt;
    KEYEXTENSION const *pke;
    BYTE *pbKey = NULL;
    DWORD cbKey;

    pwszfnKey = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszfn) + cwcEXTMAX + 1) * sizeof(WCHAR));
    if (NULL == pwszfnKey)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszfnKey, pwszfn);
    pwszfnExt = wcsrchr(pwszfnKey, L'.');
    if (NULL == pwszfnExt || NULL != wcschr(pwszfnExt, L'\\'))
    {
	pwszfnExt = &pwszfnKey[wcslen(pwszfnKey)];
    }

    for (pke = s_akePrivate; ; pke++)
    {
	if (pke >= &s_akePrivate[ARRAYSIZE(s_akePrivate)])
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpErrorStr(hr, error, "No private key file", pwszfnKey);
	}
	CSASSERT(cwcEXTMAX >= wcslen