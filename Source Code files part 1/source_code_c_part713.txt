_paramWaitLogFlush_OLD,
                                        0,        //wait 0 msecs after commit
                                                  //before flushing
                                        NULL      //ignored
                                               )
                                        );

                        //
                        // There does not seem to be any need to set
                        // Log Flush Period.
                        //

                        //
                        // set the log file path
                        //
FUTURES("Use DEFAULT_LOG_PATH after putting it in a header file")
                        if (WinsCnf.pLogFilePath == NULL)
                        {
                                //
                                // We should use the same directory as
                                // the one for system.mdb file
                                //

//                                pLogFilePath = ".\\wins";
                                WinsCnf.pLogFilePath = LOGFILE_PATH;
                                fFreeMem = FALSE;
                        }
                        else
                        {
#if 0
#ifdef UNICODE
                                CHAR        AsciiLogFilePath[WINS_MAX_FILENAME_SZ];
                                WinsMscConvertUnicodeStringToAscii(
                                        (LPBYTE)WinsCnf.pLogFilePath,
                                        AsciiLogFilePath,
                                        WINS_MAX_FILENAME_SZ
                                                );
                                pLogFilePath = (LPBYTE)AsciiLogFilePath;
#else
                                pLogFilePath = (LPBYTE)WinsCnf.pLogFilePath;
#endif
#endif
                        }

                        DBGPRINT1(FLOW, "SetSystemParam: LogFilePath = (%s)\n", WinsCnf.pLogFilePath);
                        //
                        // Set the log file path.
                        //
                        CALL_M(JetSetSystemParameter(
                                        &sJetInstance,
                                        (JET_SESID)0,        //SesId - ignored
                                        JET_paramLogFilePath_OLD,
                                        0,        //ignored
                                        WinsCnf.pLogFilePath
                                        //pLogFilePath
                                                   )
                                              );

                        //
                        // Free this memory.  It is not needed any more
                        //
                        if (fFreeMem)
                        {
                           WinsMscDealloc(WinsCnf.pLogFilePath);
                        }
                }

    }
    else
    {

                if (!RtlEqualMemory(WinsCnf.pLogFilePath, LOGFILE_PATH, sizeof(LOGFILE_PATH)))
                {
                  DBGPRINT0(DET, "SetSystemParam: Setting Log file path again\n");
                  WinsCnf.pLogFilePath = LOGFILE_PATH;
                  CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    (JET_SESID)0,        //SesId - ignored
                                    JET_paramLogFilePath_OLD,
                                    0,        //ignored
                                    WinsCnf.pLogFilePath
                                               )
                                          );
                }

    }

    return WINS_SUCCESS;

}

STATUS
SetSystemParams(
        BOOL fBeforeInit
        )

/*++

Routine Description:
        This function is called to set the system parameters for Jet

Arguments:

        fBeforeInit         - indicates whether this function has been called
                          prior to JetInit
Externals Used:

        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{
        if (DynLoadJetVersion >= DYN_LOAD_JET_600) {

            return SetSystemParamsJet600( fBeforeInit );
        }
        else if (DynLoadJetVersion == DYN_LOAD_JET_500)
        {

            return SetSystemParamsJet500( fBeforeInit );

        } else {

            return SetSystemParamsJet200( fBeforeInit );
        }
}


VOID
UpdHighestVersNoRecIfReqd(
        PWINSTHD_TLS_T                pTls,
        PNMSDB_ROW_INFO_T        pRowInfo,
        PNMSDB_STAT_INFO_T        pStatInfo
        )

/*++

Routine Description:
        This function is called to check if the record being replaced is
        the highest version number record owned by the local WINS. If so,
        the special record that records the highest version number reached
        for local records is updated to reflect the version number of the
        record to be replaced

Arguments:

        pTls          - ptr to thread local storage,
        pRowInfo - ptr to info of record to store in db
        pStatInfo - ptr to info of record to replace in db

Externals Used:
        None

Return Value:
        NONE

Error Handling:

Called by:
        NmsDbUpdateRow, NmsDbSeekNUpdate

Side Effects:

Comments:
        This function is always called from inside the NmsNmhNamRegCrtSec
--*/
{
        VERS_NO_T        MyMaxVersNo;

        //
        //  Decrement the value of the vers. no. counter by 1
        //
        NMSNMH_DEC_VERS_NO_M(NmsNmhMyMaxVersNo,
                            MyMaxVersNo
                           );

        //
        // If a local record is being replaced by a replica, then only are we
        // interested in updating the special record
        //
        if ((pStatInfo->OwnerId == NMSDB_LOCAL_OWNER_ID) && (pRowInfo->OwnerId
                        != NMSDB_LOCAL_OWNER_ID))
        {
                //
                // Check if the local record to be replaced has the highest
                // version number that we know of for local records
                //
                if (LiEql(pStatInfo->VersNo, MyMaxVersNo))
                {
                        //
                        // Update (or insert) the special record that records
                        // the highest version number reached
                        //
                        NmsDbUpdHighestVersNoRec(pTls, MyMaxVersNo, FALSE);
                }
        }

        return;
}

STATUS
NmsDbUpdHighestVersNoRec(
        IN PWINSTHD_TLS_T        pTls,
        IN VERS_NO_T                MyMaxVersNo,
        IN BOOL                        fEnterCrtSec
        )

/*++

Routine Description:

        This function is called to update the record that stores the
        highest version number reached for entries owned by the local WINS.

Arguments:
        pTls - Thread local storage

Externals Used:
        None

Return Value:
        NONE

Error Handling:

Called by:
        NmsDbDoScavenging, UpdHighestVersNoRecIfReqd() in nmsdb.c

Side Effects:

Comments:
        None
--*/

{
        DWORD            OwnerId    = OWNER_ID_OF_SPEC_REC;
        DWORD           FldNo      = 0;
        JET_ERR         JetRetStat;
        DWORD           ActFldLen  = 0;  //length of fld retrieved
        JET_TABLEID     TblId;
        JET_SESID       SesId;
        DWORD           FlagVal = 0;
        COMM_ADD_T      Add;

        DBGENTER("NmsDbUpdHighestVersNoRec\n");

        //
        // pTls should be non NULL if this function was called by
        // UpdHighestVersNoRecIfReqd()
        //
        if (pTls == NULL)
        {
                GET_TLS_M(pTls);
                ASSERT(pTls != NULL);
        }
        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;


        /*
        *  Set the clustered index as the current index
        */
        CALL_M(
                JetSetCurrentIndex( SesId,
                                            TblId,
                                            NMSDB_NAM_ADD_CLUST_INDEX_NAME
                                  )
                      );
        //
        //
        //if called by UpdHighestVersNoRecIfReqd(), fEnterCrtSec should be
        // FALSE
        //
        if (fEnterCrtSec)
        {
                EnterCriticalSection(&NmsNmhNamRegCrtSec);
        }

try {


        //
        // If the special record exists in the db, seek to it
        //
        if (sfHighestVersNoRecExists)
        {
             DBGPRINT2(DET, "NmsDbUpdHighestVersNoRec: REPLACING SPECIAL OWNER ID RECORD. New Version # = (%d %d)\n", MyMaxVersNo.HighPart, MyMaxVersNo.LowPart);
             //
             // If the special record's version number is less than the
             // version number passed to us, replace it with the new one
             //
             if (
                 (fEnterCrtSec == FALSE) ||
                 (LiGtr(MyMaxVersNo, sHighestVersNoSaved))
                 )
             {
                  CALL_M( JetMakeKey(
                        SesId,
                        TblId,
                        spHighestVersNoRecName,
                        sizeof(spHighestVersNoRecName),
                        JET_bitNewKey
                          )
                        );

                  CALL_M(JetSeek(
                                SesId,
                                TblId,
                                JET_bitSeekEQ
                            )
                        );


                  CALL_M(JetBeginTransaction(SesId));
        try{
                  JetRetStat = JetPrepareUpdate(
                                 SesId,
                                 TblId,
                                 JET_prepReplace
                                );

                  if (
                     (JetRetStat != JET_errSuccess)
                               &&
                     (JetRetStat != JET_wrnNoWriteLock)
                     )
                  {
                       RET_M(JetRetStat);
                  }

                  //
                  // Update the version number
                  //
                  // add 5th column (this is the version number long(DWORD)
                  CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &MyMaxVersNo,
                                sizeof(VERS_NO_T),
                                0,
                                NULL /*optional info */
                                )
                              );

                  //
                  // Update the record
                  //
                  CALL_M(JetUpdate (
                                SesId,
                                TblId,
                                NULL,
                                0L,
                                NULL
                                   )
                               );
        }
        finally {
                  if (AbnormalTermination())
                  {
                        // if there is an abnormal termination, we already have an error
                        // code here. We shouldn't override it with any other error code.
                        JetRollback(SesId, JET_bitRollbackAll);
                  }
                  else
                  {
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
                        CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)
                          sHighestVersNoSaved = MyMaxVersNo;
                  }
               }
           }
#ifdef WINSDBG
                else
                {
                        DBGPRINT0(DET, "NmsDbUpdHighestVersNoRec: The record has a higher version number the one we wish to store. NO UPDATE IS BEING MADE\n");
                }
#endif
        }
        else  // special record not there
        {
           DWORD TimeStamp = MAXLONG;
           DBGPRINT2(DET, "NmsDbUpdHighestVersNoRec: INSERTING SPECIAL OWNER ID RECORD. Version # = (%d %d)\n", MyMaxVersNo.HighPart, MyMaxVersNo.LowPart);
                CALL_M(JetBeginTransaction(SesId));
           try {
                  JetRetStat = JetPrepareUpdate(
                                 SesId,
                                 TblId,
                                 JET_prepInsert
                                );

                  if (
                     (JetRetStat != JET_errSuccess)
                               &&
                     (JetRetStat != JET_wrnNoWriteLock)
                     )
                  {
                       RET_M(JetRetStat);
                  }

                 //
                 // Set the name
                 //
                 CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                                spHighestVersNoRecName,
                                sizeof(spHighestVersNoRecName),
                                0,
                                NULL /*optional info */
                                )
                    );



                 /* Set the owner byte        */
                 CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                &OwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                0,
                                NULL /*optional info */
                                 )
                               );

                  //
                  // Set the version number
                  //
                  // add 5th column (this is the version number long(DWORD)
                  CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &MyMaxVersNo,
                                sizeof(VERS_NO_T),
                                0,
                                NULL /*optional info */
                                )
                              );

                 //
                 // Set the flags column.  We mark it STATIC so that
                 // the scavenger thread does not pick it up for                                 // scavenging. Even if that were not the case, we still need
                 // to set this column  to avoid a JET_wrnColumnNull from
                 // JetRetrieveColumn (in NmsDbGetDataRecs).
                 //
                 NMSDB_SET_STATIC_M(FlagVal);
                 NMSDB_SET_STATE_M(FlagVal, NMSDB_E_ACTIVE);
                  CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &FlagVal,
                                sizeof(FlagVal),
                                0,
                                NULL /*optional info */
                                 )
                               );

                 //
                 // set the timestamp column to avoid getting a
                 // JET_wrnColumnNull from
                 // JetRetrieveColumn (in NmsDbGetDataRecsByName).
                 //
                 CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                &TimeStamp,
                                sizeof(DWORD),  /*change type to TIME_STAMP_T
                                                 *later*/
                                0,
                                NULL /*optional info */
                                 )
                                    );

                 //
                 // set this address column  to avoid a JET_wrnColumnNull from
                 // JetRetrieveColumn (in NmsDbGetDataRecsByName).
                 //
                  CALL_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                &Add,
                                sizeof(Add),
                                0,
                                NULL /*optional info */
                                 )
                               );
                  //
                  // Update the record
                  //
                  JetRetStat = JetUpdate (
                                SesId,
                                TblId,
                                NULL,
                                0L,
                                NULL
                                    );

            } // end of try block
            finally {

                  if (AbnormalTermination())
                  {
                        // if there is an abnormal termination, we already have an error
                        // code here. We shouldn't override it with any other error code.
                        JetRollback(SesId, JET_bitRollbackAll);
                  }
                  else
                  {
                        if (JetRetStat == JET_errSuccess)
                        {
#pragma prefast(suppress:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
                          CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
                        }
                        else
                        {
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
                          CALL_M(JetRollback(SesId, JET_bitRollbackAll));
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)
                        }

                        //
                        // The only time we will get KeyDuplicate is if somebody
                        // entered the special name in the db.  In such a
                        // situation, we should mark the record as existent
                        // such that next time we end up replacing the
                        // offensive record. Replacing this record can be
                        // done right now but at this stage it is not worth
                        // the time required to test it. In any case, the
                        // probability of problems due to this are miniscule.
                        //
                        if ( (JetRetStat == JET_errSuccess) ||
                             (JetRetStat == JET_errKeyDuplicate))
                        {
#ifdef WINSDBG
                           if (JetRetStat == JET_errKeyDuplicate)
                           {
                                DBGPRINT0(ERR, "NmsDbUpdHighestVersNoRec: DUPLICATE SPECIAL OWNER ID RECORD\n");
                           }
#endif
                           sHighestVersNoSaved      = MyMaxVersNo;
                           sfHighestVersNoRecExists = TRUE;
                        }
                  }
               }
        }


 } // end of try { .. }
finally {
          if (fEnterCrtSec)
          {
                LeaveCriticalSection(&NmsNmhNamRegCrtSec);
          }

 }
        DBGLEAVE("NmsDbUpdHighestVersNoRec\n");
        return(WINS_SUCCESS);
}

STATUS
NmsDbDelDataRecs(
        DWORD            dwOwnerId,
        VERS_NO_T        MinVersNo,
        VERS_NO_T        MaxVersNo,
        BOOL             fEnterCrtSec,
        BOOL             fFragmentedDel
        )

/*++

Routine Description:
        This function is called to delete a specified range of records
        of a WINS from the local db

Arguments:
        pWinsAdd  - Address of owner WINS
        MinVersNo - Min. Vers. No
        MaxVersNo = Max. Vers. No

Externals Used:
        None

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        WinsDelDbRecs

Side Effects:

Comments:
        This function is called in the Pull thread or an RPC thread.
        On exit, it sets the index to the clustered index on the
        name-address table
--*/

{
        JET_ERR         JetRetStat;
        DWORD           ActFldLen; //length of fld retrieved
        JET_TABLEID     TblId;
        JET_SESID       SesId;
        PWINSTHD_TLS_T  pTls;
        VERS_NO_T       VersNo;
#if NEW_OWID
        DWORD            RecordOwnerId;
#else
        DWORD            RecordOwnerId = 0;
#endif

        DWORD           NoOfRecsUpd = 0;
        STATUS          RetStat = WINS_SUCCESS;
        BOOL            fAllToBeDeleted = FALSE;
        //BOOL            fTransActive = FALSE;
        BOOL            fEntered = FALSE;
        DWORD           Count = 0;
        LONG            RetVal;

        DBGENTER("NmsDbDelDataRecs\n");


        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);
        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;

        if (fEnterCrtSec)
        {
                EnterCriticalSection(&NmsNmhNamRegCrtSec);
                fEntered = TRUE;
        }
        if (dwOwnerId == NMSDB_LOCAL_OWNER_ID)
        {
                NMSNMH_DEC_VERS_NO_M(NmsNmhMyMaxVersNo, VersNo);
        }
        else
        {
               if (WinsCnf.State_e != WINSCNF_E_INITING)
               {
                  EnterCriticalSection(&RplVersNoStoreCrtSec);
                  VersNo = (pRplPullOwnerVersNo+dwOwnerId)->VersNo;
                  LeaveCriticalSection(&RplVersNoStoreCrtSec);
               }
               else
               {
                   VersNo = (pRplPullOwnerVersNo+dwOwnerId)->VersNo;
               }
        }

        //
        // If both minimum and maximum version numbers specified are 0,
        // it means all the records of the WINS need to be deleted
        //
        if (LiEqlZero(MinVersNo) && LiEqlZero(MaxVersNo))
        {
                fAllToBeDeleted = TRUE;
        }
#if 0
        else
        {
                if (LiGtr(MinVersNo, VersNo))
                {
                      DBGPRINT4(DET, "NmsDbDelDataRecs: Wrong range to delete. Min. Vers. no (%d %d) is > the max. (%d %d) that this WINS server knows of.\n",
                        MinVersNo.HighPart, MinVersNo.LowPart,
                        VersNo.HighPart, VersNo.LowPart,
                        );

                       LeaveCriticalSection(&NmsNmhNamRegCrtSec);
                       return(WINS_FAILURE);
                 }

                 //
                 // We should never attempt to delete a record that is not in
                 // our database currently
                 //
                 MaxVersNo = LiGtr(MaxVersNo, VersNo) ? VersNo : MaxVersNo;
        }
#endif

try {

        //
        // Let us make sure that the special record points to the highest
        // version number that we know of for local records.  Note:
        // When there is atleast one record of a higher version number
        // than the highest version numbered record to be deleted,
        // there is no need to update the special record. Checking
        // whether this is the case would be more overhead (in general).
        //We therefore use the strategem of always updating the special record.
        //
        if (dwOwnerId == NMSDB_LOCAL_OWNER_ID)
        {
                NmsDbUpdHighestVersNoRec(pTls, VersNo, FALSE);
        }

        //
        // Don't start a transaction since if the number of records are
        // huge, the transaction can become long in duration and JetDelete
        // may return an "out of Memory" error.
        //
        // Ian's comments on 8/26/94
        //
        // If you call JetDelete outside of any transaction, then JET
        // internally wraps a begin transction/commit trnasaction around the
        // delete.  Another user at transaction level 0 will immediately see
        // this change, but another user in a transction, i.e. at transaction
        // level 1 or greater, will not see this change until they return to
        // transaction level 0.

        //
        // Thus, you do not have to delete records in a transaction, unless
        // you are deleting multiple records which must be deleted atomically,
        // or which must be seen to be deleted atomically.
        //

        //CALL_M(JetBeginTransaction(SesId));
        //fTransActive = TRUE;

        do {

        if (fFragmentedDel && fEnterCrtSec && !fEntered)
        {
                 EnterCriticalSection(&NmsNmhNamRegCrtSec);
                 fEntered = TRUE;
        }

        CALL_M( JetSetCurrentIndex(
                                 pTls->SesId,
                                 pTls->NamAddTblId,
                                 NMSDB_NAM_ADD_PRIM_INDEX_NAME
                                   )
              );

        CALL_M( JetMakeKey(
                                SesId,
                                TblId,
                                &dwOwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                JET_bitNewKey          //since this is the first
                                                 //data value of the key
                          )
              );

        CALL_M( JetMakeKey(
                                SesId,
                                TblId,
                                &MinVersNo,
                                sizeof(VERS_NO_T),
                                0        //0 for grbit since this is not the
                                        //first component of the key
                          )
              );

        JetRetStat = JetSeek(
                        SesId,
                        TblId,
                        JET_bitSeekGE
                        );

        if (JetRetStat != JET_errRecordNotFound)
        {
           do {

                   CALL_M(JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                             &RecordOwnerId,
                             NAM_ADD_OWNERID_SIZE,
                             &ActFldLen,
                             0,
                             NULL
                                     )
                    );

                   //
                   // if only tombstones are required, it means that we need
                   // all tombstones irrespective of owner
                   //
                   if (RecordOwnerId != dwOwnerId )
                   {
                      //
                      // We have exhausted all records for the owner. Break out
                      // of the loop
                      //
                      RetVal = -1; //to break out of the out loop
                      break;
                   }


                  //
                  // Retrieve the version number
                  //
                  CALL_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &VersNo,
                                sizeof(VERS_NO_T),
                                &ActFldLen,
                                0,
                                NULL
                                     )
                          );

                 //
                 // If MaxVersNo is not zero and VersNo retrieved is
                 // greater than it, break out of the loop.
                 //
                 // NOTE: fAllToBeDeleted is used instead of LiEqlZero()
                 // since the latter is a function call and would be
                 // costlier (this is the reason, why fAllToBeDeleted exists)
                 //
                 if (!fAllToBeDeleted && LiGtr(VersNo, MaxVersNo))
                 {
                     //
                     // We have acquired records upto MaxVersNo.  Break out
                     // of the loop
                     //
                     RetVal = -1;  // to break out of the outer loop
                     break;
                 }

                CALL_M(JetDelete(
                                SesId,
                                TblId
                                )
                        );

#ifdef WINSDBG
                 NmsDbDelDelDataRecs++;
#endif
                 NoOfRecsUpd++;
             } while(
                ((RetVal = JetMove(SesId, TblId, JET_MoveNext, 0)) >= 0)
                                    &&
                (++Count < 50)
                    );

             if (fFragmentedDel && fEntered)
             {
                 LeaveCriticalSection(&NmsNmhNamRegCrtSec);
                 fEntered = FALSE;
                 MinVersNo = VersNo;
                 Count = 0;
             }
             if (RetVal < 0)
             {
                  break;
             }
        }
        else
        {
                DBGPRINT0(DET, "NmsDbDelDataRecs: There are no records to delete\n");
                RetStat = WINS_SUCCESS;
                break;
        }
      } while (TRUE);
} // end of try
finally {
        JET_ERR JetRetStat;

        DBGPRINT3(SCV, "NmsDbDelDataRecs: Deleted records of owner id = (%d) in the range (%x - %x)\n", dwOwnerId, MinVersNo, VersNo);
        if (fEntered)
        {
                LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        }

        //
        // Change the index to clustered
        //
        JetRetStat = JetSetCurrentIndex(
                                 pTls->SesId,
                                 pTls->NamAddTblId,
                                 NMSDB_NAM_ADD_CLUST_INDEX_NAME
                                   );
        if (!AbnormalTermination())
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
            CALL_M(JetRetStat);
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)

  } // end of finally

        WinsEvtLogDetEvt(TRUE, WINS_EVT_DEL_RECS, NULL, __LINE__, "ddddd",
                  dwOwnerId, MinVersNo.LowPart, MinVersNo.HighPart,
                             VersNo.LowPart, VersNo.HighPart);

        DBGPRINT1(DET, "NmsDbDelDataRecs: No. Of. records deleted = (%d)\n",                        NoOfRecsUpd);
        DBGLEAVE("NmsDbDelDataRecs\n");
        return(RetStat);
}

STATUS
NmsDbTombstoneDataRecs(
        DWORD            dwOwnerId,
        VERS_NO_T        MinVersNo,
        VERS_NO_T        MaxVersNo
        )

/*++

Routine Description:
        This function is called to tombstone a specified range of records
        of a WINS from the local db

Arguments:
        pWinsAdd  - Address of owner WINS
        MinVersNo - Min. Vers. No
        MaxVersNo = Max. Vers. No

Externals Used:
        None

Return Value:

Called by:
        WinsTombstoneDbRecs

Side Effects:

Comments:
        This function is called on RPC thread.
        On exit, it sets the index to the clustered index on the
        name-address table
--*/

{
        JET_ERR         JetRetStat;
        DWORD           ActFldLen; //length of fld retrieved
        JET_TABLEID     TblId;
        JET_SESID       SesId;
        PWINSTHD_TLS_T  pTls;
        DWORD            RecordOwnerId = 0;
        DWORD           NoOfRecsUpd = 0;
        STATUS          RetStat = WINS_SUCCESS;
        BOOL            fAllToBeTombstoned = FALSE;
        DWORD           Count = 0;
        LONG            RetVal;
        BOOL            fIncVersNo;
        VERS_NO_T       VersNo;
        DWORD           FlagVal;
        BOOL            LockHeld = FALSE;
        BOOL            UpdateOwnerId = FALSE;
        DWORD_PTR       NewTimeStamp;
        time_t                  CurrentTime;
        DWORD           dwNewOwnerId;

        DBGENTER("NmsDbTombstoneDataRecs\n");


        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);
        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;


        (void)time(&CurrentTime);
        NewTimeStamp = CurrentTime + WinsCnf.TombstoneTimeout;
        DBGPRINT1(DET, "NmsDbTombstoneDataRecs: The new tombstone Time is %.19s\n",
                  asctime(localtime(&NewTimeStamp)));

        if (NMSDB_LOCAL_OWNER_ID != dwOwnerId) {
            UpdateOwnerId = TRUE;
            dwNewOwnerId = NMSDB_LOCAL_OWNER_ID;
        }

        // If both minimum and maximum version numbers specified are 0,
        // it means all the records of the WINS need to be deleted
        if (LiEqlZero(MinVersNo) && LiEqlZero(MaxVersNo)){
            if (NMSDB_LOCAL_OWNER_ID == dwOwnerId) {
                MaxVersNo = NmsNmhMyMaxVersNo;
            } else {
                fAllToBeTombstoned = TRUE;
            }
        }

        CALL_N_JMP_M( JetSetCurrentIndex(
                                 pTls->SesId,
                                 pTls->NamAddTblId,
                                 NMSDB_NAM_ADD_PRIM_INDEX_NAME
                                   ),
                      Cleanup
              );
        CALL_N_JMP_M( JetMakeKey(
                                SesId,
                                TblId,
                                &dwOwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                JET_bitNewKey          //since this is the first
                          ),
                      Cleanup
              );
        CALL_N_JMP_M( JetMakeKey(
                                SesId,
                                TblId,
                                &MinVersNo,
                                sizeof(VERS_NO_T),
                                0        //0 for grbit since this is not the
                          ),
                      Cleanup
              );
        JetRetStat = JetSeek(
                        SesId,
                        TblId,
                        JET_bitSeekGE
                        );
        if (JetRetStat == JET_errRecordNotFound) {
                DBGPRINT0(DET, "NmsDbTombstoneDataRecs: There are no records to tombstone\n");
                RetStat = WINS_FAILURE;
                goto Cleanup;
        }
        if (JetRetStat != JET_errSuccess && JetRetStat != JET_wrnSeekNotEqual) {
            DBGPRINT1(ERR, "NmsDbTombstoneDataRecs: JetSeek failed with %ld\n",JetRetStat);
            RetStat = WINS_FAILURE;
            goto Cleanup;
        }
        while (TRUE) {
            // tombstone 50 recs at a time so that we dont hold crit section
            // for long time.
            EnterCriticalSection(&NmsNmhNamRegCrtSec);
            LockHeld = TRUE;

            do {
                CALL_N_JMP_M(
                    JetRetrieveColumn(
                         SesId,
                         TblId,
                         sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                         &RecordOwnerId,
                         NAM_ADD_OWNERID_SIZE,
                         &ActFldLen,
                         0,
                         NULL),
                    Cleanup
                );
                if (RecordOwnerId != dwOwnerId ){
                  // We have exhausted all records for the owner. Break of the loop
                  goto Cleanup;
                }
                // Retrieve the version number
                CALL_N_JMP_M(
                    JetRetrieveColumn(
                            SesId,
                            TblId,
                            sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                            &VersNo,
                            sizeof(VERS_NO_T),
                            &ActFldLen,
                            0,
                            NULL),
                    Cleanup
                );

                DBGPRINT2(DET, "NmsDbTombstoneDataRecs: tombstone record - (%lx - %lx)\n", VersNo.HighPart, VersNo.LowPart);
                // If MaxVersNo is not zero and VersNo retrieved is
                // greater than it, break out of the loop.
                if (!fAllToBeTombstoned && LiGtr(VersNo, MaxVersNo)){
                    // We have acquired records upto MaxVersNo.  Break of the loop
                    goto Cleanup;
                }
                // retrieve the flags column
                CALL_N_JMP_M(
                    JetRetrieveColumn(
                            SesId,
                            TblId,
                            sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                            &FlagVal,
                            sizeof(FlagVal),
                            &ActFldLen,
                            0,
                            NULL
                            ),
                    Cleanup
                );

                CALL_N_JMP_M(JetBeginTransaction(SesId),Cleanup);
                try {
                    CALL_N_RAISE_EXC_IF_ERR_M( JetPrepareUpdate(
                                                    SesId,
                                                    TblId,
                                                    JET_prepReplace
                                                    )
                    );

                    // make it tombstone.
                    NMSDB_SET_STATE_M(FlagVal,NMSDB_E_TOMBSTONE);

                    // Update the flags field
                    CALL_N_RAISE_EXC_IF_ERR_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &FlagVal,
                                sizeof(FlagVal),
                                0,
                                NULL /*optional info */
                                )
                    );

                    VersNo = NmsNmhMyMaxVersNo;

                    // Update the version number field so that this record gets
                    // propagated eventually
                    CALL_N_RAISE_EXC_IF_ERR_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                                &VersNo,
                                sizeof(VERS_NO_T),
                                0,
                                NULL /*optional info */
                                )
                    );

                    if (UpdateOwnerId) {
                        CALL_N_RAISE_EXC_IF_ERR_M( JetSetColumn(
                                    SesId,
                                    TblId,
                                    sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                    &dwNewOwnerId,
                                    NAM_ADD_OWNERID_SIZE,
                                    0,
                                    NULL /*optional info */
                                    )
                        );
                    }


                    CALL_N_RAISE_EXC_IF_ERR_M( JetSetColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                                &NewTimeStamp,
                                sizeof(DWORD),
                                0,
                                NULL /*optional info */
                                )
                    );

                    // Update the record
                    CALL_N_RAISE_EXC_IF_ERR_M(JetUpdate (
                                SesId,
                                TblId,
                                NULL,
                                0L,
                                NULL
                                )
                    );

                } // end of try block
                finally {
                    if (AbnormalTermination()){
                        CALL_N_JMP_M(JetRollback(SesId,JET_bitRollbackAll), Cleanup);
                    }else{
                        CALL_N_JMP_M(JetCommitTransaction(SesId,JET_bitCommitFlush), Cleanup);
                        NMSNMH_INC_VERS_COUNTER_M(NmsNmhMyMaxVersNo,NmsNmhMyMaxVersNo);
                        NoOfRecsUpd++;
                    }
                }
            } while(((RetVal = JetMove(SesId, TblId, JET_MoveNext, 0)) >= 0)&&(++Count < 50));

            LeaveCriticalSection(&NmsNmhNamRegCrtSec);
            LockHeld = FALSE;
            DBGPRINT2(SCV, "NmsDbTombstoneDataRecs: tombstoned records %ld, RetVal %ld, \n", Count, RetVal);
            Count = 0;
            if (RetVal < 0) {
                break;
            }
        }

        DBGPRINT3(SCV, "NmsDbTombstoneDataRecs: tombstone records of owner id = (%d) in the range (%x - %x)\n", dwOwnerId, MinVersNo, VersNo);
        WinsEvtLogDetEvt(TRUE, WINS_EVT_DEL_RECS, NULL, __LINE__, "ddddd",
                  dwOwnerId, MinVersNo.LowPart, MinVersNo.HighPart,
                             VersNo.LowPart, VersNo.HighPart);


Cleanup:
        // Change the index to clustered
        JetSetCurrentIndex(
            pTls->SesId,
            pTls->NamAddTblId,
            NMSDB_NAM_ADD_CLUST_INDEX_NAME
            );


        if (!LockHeld) {
            EnterCriticalSection(&NmsNmhNamRegCrtSec);
        }
        if (NoOfRecsUpd)  RPL_PUSH_NTF_M(RPL_PUSH_NO_PROP, NULL, NULL, NULL);
        LeaveCriticalSection(&NmsNmhNamRegCrtSec);


        DBGPRINT1(DET, "NmsDbTombstoneDataRecs: No. Of. records tombstoned = (%d)\n",NoOfRecsUpd);
        DBGLEAVE("NmsDbTombstoneDataRecs\n");
        return(RetStat);
}


STATUS
NmsDbSetFlushTime(
        DWORD WaitTime
        )

/*++

Routine Description:
        This function is called to set a session specific flush time

Arguments:
        WaitTime - Time in msecs to wait after a commit

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        RplPullInit

Side Effects:

Comments:
        None
--*/
{
        PWINSTHD_TLS_T        pTls;

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);


        if (DynLoadJetVersion >= DYN_LOAD_JET_600) {
            CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    pTls->SesId,
                                    JET_paramWaitLogFlush,
                                    WaitTime,
                                    NULL        //ignored
                                           )
                                    );
        } else {
            CALL_M(JetSetSystemParameter(
                                    &sJetInstance,
                                    pTls->SesId,
                                    JET_paramWaitLogFlush_OLD,
                                    WaitTime,
                                    NULL        //ignored
                                           )
                                    );
        }

        return(WINS_SUCCESS);
}

STATUS
NmsDbOpenTables(
        WINS_CLIENT_E        Client_e //client
        )

/*++

Routine Description:
        This function opens one or both of name-address mapping and
        owner-address mapping tables.  It further starts a transaction

Arguments:

        Client_e - Client

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{
        PWINSTHD_TLS_T        pTls;

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        //
        // Open the name to address mapping table
        //

        CALL_N_RAISE_EXC_IF_ERR_M( JetOpenTable(
                        pTls->SesId,
                        pTls->DbId,
                        NMSDB_NAM_ADD_TBL_NM,
                        NULL, /*ptr to parameter list; should be
                                       *non-NULL only if a query is being
                                       *opened (not the case here)*/
                        0,  /*Length of above parameter list*/
                        0,  //shared access
                        &pTls->NamAddTblId
                             )
              );

//        DBGPRINT2(SPEC, "NmsDbOpenTables: OPENED NAME-ADD table for client = (%d). Table id is (%x)\n", Client_e, pTls->NamAddTblId);

        pTls->fNamAddTblOpen = TRUE;

        /*
         *  If the client is not the replicator (i.e. it is the Name Space
         *  Manager (Nbt thread) or an RPC thread, we want to set the current
         *  index on the Name Address Mapping table to the clustered index.
         *  We are not interested in the Owner to Address Mapping table in the
         *  database (it has already been read into the in-memory table
         *  NmsDbOwnAddTbl which is what we are interested in).
         */
        if (
                (Client_e != WINS_E_RPLPULL)
                        &&
                (Client_e != WINS_E_RPLPUSH)
                        &&
                (Client_e != WINS_E_NMSSCV)
           )
        {
                /*
                  Set the clustered index as the current index
                */
                       CALL_N_RAISE_EXC_IF_ERR_M( JetSetCurrentIndex(
                        pTls->SesId,
                        pTls->NamAddTblId,
                        NMSDB_NAM_ADD_CLUST_INDEX_NAME
                                 )
                            );

        }
        else
        {
                /*
                 * The client is a replicator thread.
                 */
                if (Client_e == WINS_E_RPLPUSH)
                {
                        /*
                           * Set the primary index as the current index
                        */
                               CALL_N_RAISE_EXC_IF_ERR_M( JetSetCurrentIndex(
                                        pTls->SesId,
                                        pTls->NamAddTblId,
                                        NMSDB_NAM_ADD_PRIM_INDEX_NAME
                                                   )

                                            );
                }
                else  // it is the PULL thread
                {

                        /*
                           *Set the clustered index as the current index
                        */
                               CALL_N_RAISE_EXC_IF_ERR_M( JetSetCurrentIndex(
                                                pTls->SesId,
                                                pTls->NamAddTblId,
                                                NMSDB_NAM_ADD_CLUST_INDEX_NAME
                                                   )
                                          );
                }

                CALL_N_RAISE_EXC_IF_ERR_M( JetOpenTable(
                                pTls->SesId,
                                pTls->DbId,
                                NMSDB_OWN_ADD_TBL_NM,
                                NULL, /*ptr to parameter list; should be
                                       *non-NULL only if a query is being
                                       *opened*/
                                0,  /*Length of above parameter list*/
                                0,  //shared access
                                &pTls->OwnAddTblId
                                          )
                      );

 //               DBGPRINT2(SPEC, "NmsDbOpenTables: Opened OWN-ADD table for client = (%d). Table id is (%x)\n", Client_e, pTls->OwnAddTblId);

                pTls->fOwnAddTblOpen = TRUE;

                /*
                  Set the clustered index as the current index
                */
                       CALL_N_RAISE_EXC_IF_ERR_M( JetSetCurrentIndex(
                                pTls->SesId,
                                pTls->OwnAddTblId,
                                NMSDB_OWN_ADD_CLUST_INDEX_NAME
                                           )

                            );
        }

        return(WINS_SUCCESS);
}

STATUS
NmsDbCloseTables(
        VOID
        )

/*++

Routine Description:
        This function is called to close the tables that were opened

Arguments:
        None

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/

{

        PWINSTHD_TLS_T        pTls;

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        if (pTls->fNamAddTblOpen)
        {
                CALL_N_RAISE_EXC_IF_ERR_M(JetCloseTable(
                                pTls->SesId,
                                pTls->NamAddTblId
                                    )
                       );

//               DBGPRINT1(SPEC, "NmsDbCloseTables: CLOSED NAME-ADD table. Table id is (%x)\n", pTls->NamAddTblId);
                pTls->fNamAddTblOpen = FALSE;
        }

        if (pTls->fOwnAddTblOpen)
        {
                CALL_N_RAISE_EXC_IF_ERR_M(JetCloseTable(
                                pTls->SesId,
                                pTls->OwnAddTblId
                                    )
                                      );
//                DBGPRINT1(SPEC, "NmsDbCloseTables: CLOSED NAME-ADD table. Table id is (%x)\n", pTls->OwnAddTblId);
                pTls->fOwnAddTblOpen = FALSE;
        }

        return(WINS_SUCCESS);
}



STATUS
NmsDbGetNamesWPrefixChar(
        IN  BYTE                         PrefixChar,
        OUT PWINSINTF_BROWSER_INFO_T     *ppInfo,
        OUT LPDWORD                         pEntriesRead
        )

/*++

Routine Description:
        This function retrieves all records starting with PrefixChar

Arguments:
        PrefixChar        - Prefix character
        ppInfo          - address of pointer to info structure
        pEntriesRead        - Entries read

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        WinsGetNames

Side Effects:

Comments:
        None
--*/

{
        PWINSTHD_TLS_T  pTls;
        volatile DWORD           Iter = 0;
        JET_SESID       SesId;
        JET_TABLEID     TblId;
        JET_ERR         JetRetStat;
        DWORD           Flag;
        DWORD           ActFldLen;  //length of fld retrieved
        PWINSINTF_BROWSER_INFO_T     pInfo;
        STATUS          RetStat = WINS_SUCCESS;

        DWORD           CommitCnt = 1;          //the number of commits already done - do not change
        BOOL            fTransCommitted = TRUE; // says whether the last commit should be done or not
        DWORD           dwEntriesAvailable;     // number of records for which storage is available


        DBGENTER("NmsDbGetNamesWPrefixChar\n");

        //
        // Initialize the out args to default values
        //
        *pEntriesRead = 0;
        *ppInfo       = NULL;

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);
        SesId = pTls->SesId;
        TblId = pTls->NamAddTblId;

        CALL_M(JetBeginTransaction(SesId));
        fTransCommitted = FALSE;
try {

        // dwEntriesAvailable shows how many records were found during the first iteration
        // (when it is incremented) and how many records are to be read during the second
        // iteration (when it is decremented)
        dwEntriesAvailable = 0;

        //
        // We iterate a max of two times, the first time to get the
        // count of records and the second time to get the records
        //
        while(Iter < 2)
        {
           //
           // Seek to the first record starting with 1B character
           //
           CALL_N_JMP_M( JetMakeKey(
                        SesId,
                        TblId,
                        &PrefixChar,
                        sizeof(BYTE),
                        JET_bitNewKey
                          ), ErrorProc
                        );
           if ((JetRetStat = JetSeek(
                                SesId,
                                TblId,
                                JET_bitSeekGE
                                  )) != JET_errRecordNotFound)
           {

                BYTE  Name[NMSDB_MAX_NAM_LEN];
                DWORD NameLen;

                if (JetRetStat != JET_wrnSeekNotEqual)
                {
                        CALL_N_JMP_M(JetRetStat, ErrorProc);
                }

                //
                // Move one record at a time until we get to a record that
                // does not have 1B as the starting prefix.
                //
                do
                {
                    BOOL bFiltered;

                    //
                    // retrieve the name
                    //
                    CALL_N_JMP_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                        Name,
                        NMSDB_MAX_NAM_LEN,
                        &NameLen,
                        0,
                        NULL
                                     ), ErrorProc
                         );

                    //
                    // Check if the first character is 1B
                    //
                    if (Name[0] != PrefixChar)
                    {
                        break;
                    }
                    if ((NameLen < WINS_MAX_NS_NETBIOS_NAME_LEN) || (Name[NameLen - 2] == 0))
                    {
                        continue;
                    }

                    // --ft:10/18/00
                    // Add 1B name filtering here, if there is a filter specified for 1B names
                    //
                    EnterCriticalSection(&g_cs1BFilter);
                    bFiltered = IsNmInFilter(g_p1BFilter, Name, WINS_MAX_NS_NETBIOS_NAME_LEN-1);
                    LeaveCriticalSection(&g_cs1BFilter);
                    
                    if (!bFiltered)
                        continue;
                    //
                    // --tf

                    if (Iter == 1)
                    {

                      //
                      // Retrieve the flag byte
                      //
                      CALL_N_JMP_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                                &Flag,
                                sizeof(Flag),
                                &ActFldLen,
                                0,
                                NULL
                                     ), ErrorProc
                                  );


                      if (!NMSDB_ENTRY_ACT_M(Flag))
                      {
                           continue;
                      }

                      // specify the length of the string otherwise RPC
                      // will transport up to the first '\0'. For shorter names this would lead
                      // to loosing the record type on the way..
                      pInfo->dwNameLen = NameLen;
                      pInfo->pName = midl_user_allocate(NameLen + 1);
                      RtlMoveMemory(pInfo->pName, Name, NameLen);

                      // add this to make sure RPC doesn't go over limits.
                      // RPC is seeing pName as 'string' which makes it to pick up bytes
                      // up to the first '\0'.
                      // This hides a bug for names that contain extended chars (with '\0'
                      // somewhere in the middle) but fixing this breaks compatibility with
                      // Win2K (querying Win2K results in RPC not being able to unmarshall
                      // the responses and causing WinsGetBrowser to fail entirely).
                      pInfo->pName[NameLen] = '\0';

                      //
                      // Swap the first and 16th byte
                      //
                      WINS_SWAP_BYTES_M(pInfo->pName,
                                        pInfo->pName + 15
                                       );
                      pInfo++;

                      // increment the number of records that have been retrieved
                      (*pEntriesRead)++;

                      // check if there remains storage for more entries
                      dwEntriesAvailable--;

                      // if no memory available, break the loop
                      if (dwEntriesAvailable == 0)
                          break;

                    }
                    else
                    {
                        dwEntriesAvailable++;
                        // increment pEntriesRead here just to be able to control
                        // the granularity of [BeginTransaction()..CommitTransaction()] during both
                        // iterations
                        (*pEntriesRead)++;
                    }

                   //
                   // decrease the granularity of [BeginTransaction()..CommitTransaction()] intervals
                   //
                   if (*pEntriesRead/CommitCnt >= MAX_RECS_BEFORE_COMMIT)
                   {
                       CALL_M(
                                JetCommitTransaction(SesId, JET_bitCommitFlush)
                                    );
                       fTransCommitted = TRUE;
                       CommitCnt++;
                       CALL_M( JetBeginTransaction(SesId) );
                       fTransCommitted = FALSE;
                   }

                } while(JetMove(SesId, TblId, JET_MoveNext, 0) >= 0);

                //
                // If we found records, allocate memory to store them
                //
                if ((Iter == 0) && (dwEntriesAvailable != 0))
                {
                   *ppInfo        =  midl_user_allocate(dwEntriesAvailable *
                                           sizeof(WINSINTF_BROWSER_INFO_T));
                   pInfo = *ppInfo;
                   // reset the pEntriesRead, as from now on it will really count the records that have been retrieved.
                   *pEntriesRead = 0;
                }
                else
                {
                    // either two iterations already done, or no entries detected during the first iteration.
                    // break the loop in either case, otherwise AV could happen or even worse, other locations
                    // from the memory space of the same process might get overwritten.
                    break;
                }

                Iter++;
         }
         else
         {
              //
              // If we failed in the first seek, initialize the out vars
              // to indicate that there are no records.  If we failed in
              // the second seek, set return status to WINS_FAILURE, so
              // that we do any cleanup that is required
              //
              if (Iter == 0)
              {
                *pEntriesRead = 0;
                *ppInfo       = NULL;
              }
              else
              {
                 RetStat = WINS_FAILURE;
              }
              break;    //break out of the while loop
         }

         //
         // if no entries were read from the db, break;
         //
         if (dwEntriesAvailable == 0)
         {
              break;
         }

     } // end of while
  }
except(EXCEPTION_EXECUTE_HANDLER) {
           DWORD ExcCode = GetExceptionCode();
           DBGPRINT1(EXC, "NmsDbGetNamesWPrefixChar. Got Exception (%x)",
                                        ExcCode);
           WINSEVT_LOG_M(ExcCode, WINS_EVT_BROWSER_NAME_EXC);
           RetStat = WINS_FAILURE;
        }

        if (RetStat == WINS_SUCCESS)
        {
             goto Done;
        }
ErrorProc:
        //
        // if memory was allocated, do cleanup
        //
        if (*ppInfo != NULL)
        {
             //
             // If any memory was allocated for names, free it
             //
             pInfo = *ppInfo;
             while (*pEntriesRead > 0)
             {
                 midl_user_free(pInfo++->pName);
                 (*pEntriesRead)--;
             }
             //
             // Free the main block
             //
             midl_user_free(*ppInfo);

             //
             // Reinit the out args to indicate no records to the client
             //
             *ppInfo       = NULL;
             *pEntriesRead = 0;
        }
        RetStat = WINS_FAILURE;

Done:

        if (!fTransCommitted)
            CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
        DBGLEAVE("NmsDbGetNamesWPrefixChar\n");
        return(RetStat);

} // NmsDbGetNamesWPrefixChar

STATUS
NmsDbCleanupOwnAddTbl(
        LPDWORD        pNoOfOwners
        )

/*++

Routine Description:
        This function is called by the scavenger thread to cleanup
        the OwnAdd Table
Arguments:
        SesId - Jet Session id
        TblId - Table Id of the Name-Address Mapping table

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:
        NmsDbInit

Side Effects:

Comments:
     This function returns the highest owner id found.
--*/

{
        DWORD           OwnerId;
#if NEW_OWID
        DWORD           TmpOwnerId;
#else
        DWORD           TmpOwnerId = 0;
#endif
        DWORD          ActFldLen;
        JET_ERR        JetRetStat;
        PWINSTHD_TLS_T pTls;
        JET_SESID      SesId;
        JET_TABLEID    TblId;
        BOOL           fNoOfOwnersInited = FALSE;
        DWORD          No;
        STATUS         RetStat = WINS_SUCCESS;

        DBGENTER("NmsDbCleanupOwnAddTbl\n");
        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        SesId = pTls->SesId;
        TblId = pTls->NamAddTblId;

        /*
         * Set the primary index as the current index
        */
        CALL_N_RAISE_EXC_IF_ERR_M( JetSetCurrentIndex(
                        SesId,
                        TblId,
                        NMSDB_NAM_ADD_PRIM_INDEX_NAME
                                   )
                      );

        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
        *pNoOfOwners = NmsDbNoOfOwners;
try {

        OwnerId = NmsDbNoOfOwners;
        do
        {

                  DBGPRINT1(FLOW, "NmsDbCleanupOwnAddTbl: will seek for owner less than = (%d)\n", OwnerId);
                 //
                 // Construct a partial key made of owner id.
                 //
                 CALL_N_RAISE_EXC_IF_ERR_M( JetMakeKey(
                                SesId,
                                TblId,
                                &OwnerId,
                                NAM_ADD_OWNERID_SIZE,
                                JET_bitNewKey          //since this is the first
                                                 //data value of the key
                          )
                        );

                  //
                  // Seek to the record that has a key that is Less than or
                  // Equal to the OwnerId value.
                  //
                  // Since we have specified a partial key (saying in effect
                  // that the other component of the key is NULL), JetSeek
                  // must return wrnSeekNotEqual since it will never find
                  // a record with NULL for the second component of the index
                  // -- Ian 7/13/93
                  //
                  JetRetStat = JetSeek(
                                              SesId,
                                              TblId,
                                              JET_bitSeekLE
                                      );

                  //
                  // If we found a record
                  //
                  if (JetRetStat != JET_errRecordNotFound)
                  {
                    ASSERT(JetRetStat == JET_wrnSeekNotEqual);

                    /*
                     * Retrieve the owner Id column.
                    */
                       CALL_N_RAISE_EXC_IF_ERR_M(
                          JetRetrieveColumn(
                                     SesId,
                                     TblId,
                                     sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                                     &TmpOwnerId,
                                     NAM_ADD_OWNERID_SIZE,
                                     &ActFldLen,
                                     JET_bitRetrieveFromIndex,
                                     NULL
                                                 )
                                      );

                   if(!fNoOfOwnersInited)
                   {
                     //
                     // We want to return the highest owner id that we find.
                     // not the number of owners.  The param. name is
                     // misleading
                     //
                     *pNoOfOwners      = TmpOwnerId;
                     fNoOfOwnersInited = TRUE;
                   }

                  DBGPRINT1(FLOW, "NmsDbCleanupOwnAddTbl: records found for owner id = (%d)\n", TmpOwnerId);
                   //
                   // Mark all those records in the owner-address table
                   // that don't have corresponding records in the
                   // name - address table
                   //
                   if (OwnerId >= 1)
                   {
                     for (No = OwnerId - 1; No > TmpOwnerId; No--)
                     {

                        if ((pNmsDbOwnAddTbl+No)->WinsState_e ==
                                                NMSDB_E_WINS_ACTIVE)
                        {
                          //
                          // We may have deleted this entry in an earlier
                          // invocation.  If so, we bypass the deletion here.
                          //
                          if ((pNmsDbOwnAddTbl+No)->WinsState_e !=
                                                      NMSDB_E_WINS_DELETED)
                          {
                             DBGPRINT1(FLOW, "NmsDbCleanupOwnAddTbl: Deleting WINS with owner id = (%d)\n", No);
                             (pNmsDbOwnAddTbl+No)->WinsState_e = NMSDB_E_WINS_DELETED;
                             NmsDbWriteOwnAddTbl(
                                        NMSDB_E_DELETE_REC,
                                        No,
                                        NULL,
                                        NMSDB_E_WINS_DELETED,
                                        NULL,
                                        NULL
                                          );
                          }
                          else
                          {
                               DBGPRINT1(DET, "NmsDbCleanupOwnAddTbl: Owner Id (%d) is already in DELETED state\n", OwnerId);
                          }
                        }

                     }


                     //
                     // Make OwnerId = the max owner id that we found.
                     //
                     OwnerId = TmpOwnerId;
                   }
                   else
                   {
                        //
                        // Owner Id is 0, our job is done
                        //
                        break;
                   }
                }
                else  //record not found
                {
                           if(!fNoOfOwnersInited)
                           {
                                //
                                // Since fNoOfOwnersInited is FALSE, we
                                // did not find even one record
                                //
                                DBGPRINT1(FLOW, "NmsDbCleanupOwnAddTbl: THERE IS NOT EVEN ONE REPLICA RECORD IN THE DB. No of owners in Own-Add Tbl are (%d)\n",
                                        NmsDbNoOfOwners
                                        )
                                *pNoOfOwners      = 0;
                           }
                           if (OwnerId > 0)
                           {
                               for (No = OwnerId - 1; No > 0; No--)
                               {

                               DBGPRINT1(FLOW, "NmsDbCleanupOwnAddTbl: Deleting WINS with owner id = (%d)\n", No);
                               if ((pNmsDbOwnAddTbl+No)->WinsState_e ==
                                                NMSDB_E_WINS_ACTIVE)
                               {
                                   (pNmsDbOwnAddTbl+No)->WinsState_e =
                                                     NMSDB_E_WINS_DELETED;
                                   NmsDbWriteOwnAddTbl(
                                        NMSDB_E_DELETE_REC,
                                        No,
                                        NULL,
                                        NMSDB_E_WINS_DELETED,
                                        NULL,
                                        NULL
                                          );
                               }

                               } // end of for
                           }
                           //
                           // No more records in the db. Break out of the loop
                           //
                           break;
                }

        } while (TRUE);
} // end of try
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "NmsDbCleanupOwnAddTbl: Got exception (%x)\n", ExcCode);
        WINSEVT_LOG_M(ExcCode, WINS_EVT_CLEANUP_OWNADDTBL_EXC);
        RetStat = WINS_FAILURE;
        }

        LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
        DBGLEAVE("NmsDbCleanupOwnAddTbl\n");
        return(RetStat);
}


STATUS
NmsDbBackup(
    LPBYTE  pBackupPath,
    DWORD   TypeOfBackup
    )

/*++

Routine Description:
    This function is called to backup the jet db

Arguments:
    pBackupPath - backup dir
    fIncremental - indicates whether the backup is incremental/full

Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/
{
  JET_ERR   JetRetStat;
  DWORD     RetStat = WINS_SUCCESS;
  static BOOL      sFullBackupDone = FALSE;
  BOOL        fBackupChanged = FALSE;

  DBGENTER("NmsDbBackup\n");
  if (pBackupPath != NULL)
  {
     DBGPRINT2(FLOW, "NmsDbBackup:Backup path = (%s).\n Type of Backup = (%s)\n", pBackupPath, TypeOfBackup == NMSDB_FULL_BACKUP ? "FULL" : "INCREMENTAL");
  }
  else
  {
     DBGPRINT0(FLOW, "NmsDbBackup. Null Backup path\n");
  }

  //
  // If we have to do an incremental backup to a non-null directory and we
  // haven't ever done a full back in this instance of WINS, we do a full
  // backup
  //
  if ((pBackupPath != NULL) && (TypeOfBackup  != NMSDB_FULL_BACKUP) && !sFullBackupDone)
  {
       TypeOfBackup = NMSDB_FULL_BACKUP;
       fBackupChanged = TRUE;
  }
      if (DynLoadJetVersion >= DYN_LOAD_JET_500)
      {
          JetRetStat = JetBackup(pBackupPath, (ULONG)TypeOfBackup, NULL);

      }
      else
      {
          JetRetStat = JetBackup(pBackupPath, (ULONG)TypeOfBackup);

      }
      if (JetRetStat != JET_errSuccess)

      {

          DBGPRINT3(ERR, "NmsDbBackup: Could not do %s backup to dir (%s). Error from JetBackup is (%d)\n", TypeOfBackup == NMSDB_FULL_BACKUP ? "FULL" : "INCREMENTAL", pBackupPath, JetRetStat);

          WinsEvtLogDetEvt(FALSE, WINS_EVT_BACKUP_ERR, NULL, __LINE__,
                    "sd", pBackupPath, JetRetStat);

          RetStat = WINS_FAILURE;
      }
      else
      {
        //
        // Backup was successful. Let us set the static flag to indicate that.
        //
        if (fBackupChanged)
        {
          sFullBackupDone = TRUE;
          fBackupChanged  = FALSE;
        }
      }


  DBGLEAVE("NmsDbBackup\n");
  return(RetStat);
}


STATUS
NmsDbGetDataRecsByName(
  LPBYTE          pName,
  DWORD           NameLen,
  DWORD           Location,
  DWORD           NoOfRecsDesired,
  PCOMM_ADD_T     pWinsAdd,
  DWORD           TypeOfRecs,
  LPVOID          *ppRBuf,
  LPDWORD         pRspBuffLen,
  LPDWORD         pNoOfRecsRet
 )

/*++

Routine Description:


Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:

Side Effects:

Comments:
	None
--*/

{
        JET_ERR             JetRetStat = JET_errSuccess;
        DWORD                OwnerId;
        DWORD               ActFldLen; //length of fld retrieved
        VERS_NO_T           TmpNoOfEntries;
        LPBYTE              pStartBuff;
        DWORD               SaveBufLen;
        BYTE                EntTyp; //type of entry (unique/group/special group)
        PRPL_REC_ENTRY2_T   pRspBuf;
        JET_TABLEID         TblId;
        JET_SESID           SesId;
        PWINSTHD_TLS_T      pTls;
#if NEW_OWID
        DWORD                RecordOwnerId;
#else
        DWORD               RecordOwnerId = 0;
#endif
        STATUS              RetStat = WINS_SUCCESS;
        BYTE                Name[NMSDB_MAX_NAM_LEN];
        DWORD               InitHeapSize;
        LONG                MoveDir = JET_MoveNext;
        DWORD               MemSize;

#ifdef WINSDBG
        DWORD               StartTime;
        DWORD               EndTime;
#endif

        BOOL            fAllocNew;
        BOOL            fTransCommitted = TRUE; // says whether the last commit should be done or not
        DWORD           CommitCnt = 1;          //the number of commits already done - do not change

        DBGENTER("NmsDbGetDataRecsByName\n");

        GET_TLS_M(pTls);
        ASSERT(pTls != NULL);

        TblId  = pTls->NamAddTblId;
        SesId  = pTls->SesId;


#ifdef WINSDBG
         if (pWinsAdd != NULL)
         {
           struct in_addr  InAddr;
           InAddr.s_addr = htonl(pWinsAdd->Add.IPAdd);
           DBGPRINT3(DET, "NmsDbGetDataRecsByName:Will retrieve %d records starting from record with name (%s) of WINS having address = (%s)\n",
                   NoOfRecsDesired, pName, inet_ntoa(InAddr) );
         }
         else
         {
           DBGPRINT2(DET, "NmsDbGetDataRecsByName:Will retrieve %d records starting from record with name (%s)\n", NoOfRecsDesired, pName);
         }
#endif

        //
        // initialize the default no. that determines the size of the
        // buffer to allocate in case the range specified by the Max and
        // Min Vers. No args is > it
        //
PERF("Move this to NmsDbInit")
        WINS_ASSIGN_INT_TO_VERS_NO_M(TmpNoOfEntries, NoOfRecsDesired);
        pTls->HeapHdl = NULL;  //make it NULL so that the caller can determine
                               //whether this function allocated a heap
                               //before returning (normally/abnormally)


        //
        // Store the memory size for the records.  Note: This
        // does not contain the memory for the name and addresses
        // (in case of a special group or a multihomed entry). The
        // sizes for these will be added as we store each record.
        //
//        MemSize     = RPL_REC_ENTRY_SIZE *  (TmpNoOfEntries.LowPart + 1);
        MemSize     = RPL_REC_ENTRY2_SIZE *  (DWORD)(TmpNoOfEntries.QuadPart + 1);
        *pRspBuffLen = MemSize + 10000; //for good measure;


        //
        // We will create a heap with the above amount of memory plus a
        // pad for heap overhead.  We add TmpNoOfEntries.LowPart * 17
        // since each record will have memory allocated for the name.
        // Names in general will be 17 bytes long (we attach a NULL at the
        // end when registering names).
        //
//        InitHeapSize = *pRspBuffLen + (TmpNoOfEntries.LowPart * 17)
        InitHeapSize = *pRspBuffLen + ((DWORD)(TmpNoOfEntries.QuadPart * 17)
                                        + PAD_FOR_REC_HEAP);

        //
        // Create the heap
        //
        pTls->HeapHdl = WinsMscHeapCreate(0, InitHeapSize);

        pRspBuf = WinsMscHeapAlloc(pTls->HeapHdl, MemSize);

        pStartBuff  = (LPBYTE)pRspBuf;        //save start of buffer
        SaveBufLen  = MemSize;                //save size of buffer
        *pNoOfRecsRet  = 0;

        *ppRBuf  = pStartBuff;

        //
        // Actually, we can call RplFindOwnerId for Scavenger thread
        // We choose not to do so to avoid some overhead -- see the
        // comment in the else block.
        //
        if (pWinsAdd != NULL)
        {
          fAllocNew =  FALSE;
          try {
              if (RplFindOwnerId(
                            pWinsAdd,
                            &fAllocNew,
                            &OwnerId,
                            WINSCNF_E_IGNORE_PREC,
                            WINSCNF_LOW_PREC
                            ) != WINS_SUCCESS
                  )
                {
                        //
                        // The client may not look at the return value, but
                        // it will look at the *pNoOfRecs value and thus
                        // determine that there are no records.
                        //
                        return(WINS_FAILURE);
                }
             }
            except(EXCEPTION_EXECUTE_HANDLER) {
                        DWORD  ExcCode = GetExceptionCode();
                        DBGPRINT1(EXC,
                              "NmsDbGetDataRecsByName: Got exception %x",
                                        ExcCode);
                        WINSEVT_LOG_M(ExcCode, WINS_EVT_EXC_RETRIEVE_DATA_RECS);
                        return(WINS_FAILURE);
                }

               //
               //It is ok not to enter a critical section here since even if
               //the array entry is being changed at this time, the repercussion
               //  of us seeing the old value is insignificant
               //
               if ((OwnerId != NMSDB_LOCAL_OWNER_ID) && LiEqlZero((pRplPullOwnerVersNo+OwnerId)->VersNo))
               {
                 DBGPRINT2(DET, "NmsDbGetDataRecsByName: WINS with address = (%x) and owner id = (%d) has 0 records in the db\n", pWinsAdd->Add.IPAdd, OwnerId);
                 return(WINS_SUCCESS);
               }
        }
        /*
        *  start a transaction
        */

        CALL_M(JetBeginTransaction(pTls->SesId));
        fTransCommitted = FALSE;
try {
        if ((pName != NULL) || ((pName == NULL) && (Location != WINSINTF_END)))
        {
          CALL_M( JetMakeKey(
                        SesId,
                        TblId,
                        pName,
                        NameLen,
                        JET_bitNewKey
                          )
              );

          JetRetStat = JetSeek(  SesId,  TblId,  JET_bitSeekGE);
          if (
             (JetRetStat == JET_errRecordNotFound)
                   ||
             ((JetRetStat != JET_errSuccess) && (JetRetStat != JET_wrnSeekNotEqual))
             )
          {
                //DBGPRINT0(ERR, "Weird.  Could not locate even one record\n");

                //WINSEVT_LOG_M(WINS_FAILURE,WINS_EVT_CANT_FIND_ANY_REC_IN_RANGE);

                //
                // Don't free memory.  It will get freed later.
                //

                //
                // Don't use macro CALL_M since that will call return
                // which will cause overhead since the system will
                // search for a termination handler. We don't want
                // that for the case where there are no records in the db
                //
                if (JetRetStat != JET_errRecordNotFound)
                {
#ifdef WINSDBG
                   DBGPRINT2(ERR, "Jet Error: JetRetStat is (%d). Line is (%d)\n",
                                      JetRetStat, __LINE__);
#endif
                   WINSEVT_LOG_D_M(JetRetStat, WINS_EVT_DATABASE_ERR);
                   RetStat = WINS_FAILURE;
                }

          }
       }
       else
       {
            CALL_M(JetMove(
                     SesId,
                     TblId,
                     JET_MoveLast,
                     //Location == WINSINTF_END ? JET_MoveLast : JET_MoveFirst,
                     0)
                   );


       }
CHECK("Check with IAN JOSE")
       //
       // We are assured of there being at least one record since the
       // JetSeek succeeded (if not for the owner we are interested in
       // then for the next one).
       // We can therefore safely use the do .. while() construct
       //
       // *NOT REALLY.  It seems that JetSeek can return JET_wrnSeekNE
       // even when there are no records in the db.  In such a case,
       // our JetRetrieveColumn will fail with a CurrencyNot there error
       //

     //
     // If we found an exact match or a name greater than the search string,
     // retrieve the record.
     //
     if ((RetStat == WINS_SUCCESS) && (JetRetStat != JET_errRecordNotFound))
     {
       if (Location == WINSINTF_END)
       {
                MoveDir = JET_MovePrevious;

       }
#ifdef WINSDBG
           //(void)time(&StartTime);
           StartTime = GetTickCount();
#endif
           do
           {

              CALL_M(JetRetrieveColumn(
                             SesId,
                             TblId,
                             sNamAddTblRow[NAM_ADD_OWNERID_INDEX].Fid,
                             &RecordOwnerId,
                             NAM_ADD_OWNERID_SIZE,
                             &ActFldLen,
                             0,
                             NULL
                                        ));

               if ((pWinsAdd != NULL) && (RecordOwnerId != OwnerId))
               {
                   //
                   // We have exhausted all records for the owner. Break out
                   // of the loop
                   //
                  continue;
               }
               else
               {
                    if (RecordOwnerId == OWNER_ID_OF_SPEC_REC)
                    {
                          continue;
                    }
               }

              pRspBuf->OwnerId = RecordOwnerId;
              //
              // Retrieve the version number
              //
              CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_VERSIONNO_INDEX].Fid,
                        &(pRspBuf->VersNo),
                        sizeof(VERS_NO_T),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                  );

                //
                // retrieve the name
                //
                CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_NAME_INDEX].Fid,
                        Name,
                        NMSDB_MAX_NAM_LEN,
                        &(pRspBuf->NameLen),
                        0,
                        NULL
                                     )
                  );

             //
             // if name length is > 255, jet is returning an invalid value.
             // Make the length equal to the max. length we can have for
             // a netbios name.  Also, log an event
             //
             if (pRspBuf->NameLen > WINS_MAX_NAME_SZ)
             {
                 WINSEVT_LOG_M(pRspBuf->NameLen, WINS_EVT_NAME_TOO_LONG);
                 DBGPRINT1(ERR, "NmsDbGetDataRecsByName: Name length is too long = (%x)\n", pRspBuf->NameLen);
                 pRspBuf->NameLen = WINS_MAX_NS_NETBIOS_NAME_LEN;
             }
             //
             // This macro will allocate memory for the name
             //
             NMSDB_STORE_NAME_M(pTls, pRspBuf, Name, pRspBuf->NameLen);

             //
             // Adjust the size to be passed to the push thread
             //
             *pRspBuffLen += pRspBuf->NameLen;

              //
              // Retrieve the flags byte
              //
              CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_FLAGS_INDEX].Fid,
                        &(pRspBuf->Flag),
                        sizeof(pRspBuf->Flag),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                  );

              //
              // if we were asked to retrieve only static records and
              // this record is not a static record, skip it.
              //
              if ((TypeOfRecs & WINSINTF_STATIC) && !NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag))
              {
//                        DBGPRINT0(DET, "NmsDbGetDataRecs: Encountered a dynamic record but were asked to retrieve only static records\n");
                        continue;
              }
              if ((TypeOfRecs & WINSINTF_DYNAMIC) && NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag))
              {
//                        DBGPRINT0(DET, "NmsDbGetDataRecs: Encountered a static record but were asked to retrieve only dynamic records\n");
                        continue;
              }

              EntTyp = (BYTE)((pRspBuf->Flag & NMSDB_BIT_ENT_TYP));
              if (
                        (EntTyp == NMSDB_UNIQUE_ENTRY)
                                    ||
                        (EntTyp == NMSDB_NORM_GRP_ENTRY)
                 )
              {
                      /* It is a unique entry*/
                      pRspBuf->fGrp = (EntTyp == NMSDB_UNIQUE_ENTRY) ?
                                                        FALSE : TRUE;
                      CALL_M( JetRetrieveColumn(
                                SesId,
                                TblId,
                                sNamAddTblRow[NAM_ADD_ADDRESS_INDEX].Fid,
                                &pRspBuf->NodeAdd,
                                 sizeof(COMM_ADD_T),
                                &ActFldLen,
                                0,
                                NULL
                                        )
                            );

               }
               else  // it is a special group or a multihomed entry
               {

                      //
                      // Even if the entry is a multihomed entry, we set the
                      // fGrp flag to TRUE so that the formatting function
                      // works properly (called by PUSH thread).  The EntTyp
                      // will be used to decipher whether it is a multihomned
                      // entry or not
                      //
FUTURES("Remove this hacky mechanism")
                      pRspBuf->fGrp =
                          (EntTyp == NMSDB_SPEC_GRP_ENTRY) ? TRUE : FALSE;

                     /*
                     *  get member addresses.
                     *
                     * This function is only called on RPC thread.  We want to get
                     * the members, even if they are expired.  We can do that by
                     * passing a TRUE value for the STATIC flag parameter.
                     * NmsDbGetDataRecsByName is the only way to get all the members
                     * including the expired ones.
                     */
                     StoreGrpMems(
                             pTls,
                             WINS_E_WINSRPC,
                             pRspBuf->pName,
                             0,     //not accessed by StoreGrpMems if Client_e
                                    //is not WINS_E_NMSSCV
                             SesId,
                             TblId,
                             TRUE, // NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag),
                             (PRPL_REC_ENTRY_T)pRspBuf
                            );

                   if (
                        (pRspBuf->NoOfAdds == 0)
                                &&
                        (NMSDB_ENTRY_ACT_M(pRspBuf->Flag))
                      )
                   {
                          //
                          //change the state to released so that the
                          //record shows up as released when displayed
                          //
                          NMSDB_CLR_STATE_M(pRspBuf->Flag);
                          NMSDB_SET_STATE_M(pRspBuf->Flag, NMSDB_E_RELEASED);
                   }

                     *pRspBuffLen +=
                           (pRspBuf->NoOfAdds * sizeof(COMM_ADD_T) * 2);

               }

                //
                // get the timestamp field
                //
                CALL_M( JetRetrieveColumn(
                        SesId,
                        TblId,
                        sNamAddTblRow[NAM_ADD_TIMESTAMP_INDEX].Fid,
                        &(pRspBuf->TimeStamp),
                        sizeof(pRspBuf->TimeStamp),
                        &ActFldLen,
                        0,
                        NULL
                                     )
                       );

                if (NMSDB_IS_ENTRY_STATIC_M(pRspBuf->Flag) &&
                    (RecordOwnerId == NMSDB_LOCAL_OWNER_ID) &&
                    NMSDB_ENTRY_ACT_M(pRspBuf->Flag))
                {
                    pRspBuf->TimeStamp = MAXLONG;
                }


             //
             // increment the counter and the pointer to past the last record.
             //
             pRspBuf = (PRPL_REC_ENTRY2_T)((LPBYTE)pRspBuf + RPL_REC_ENTRY2_SIZE);
             (*pNoOfRecsRet)++;

             //
             // if we have retrieved the max. number asked for, break out of
             // the loop
             //
             if (*pNoOfRecsRet == NoOfRecsDesired)
             {
                      break;
             }

             //
             // decrease the granularity of [BeginTransaction()..CommitTransaction()] intervals
             //
             if (*pNoOfRecsRet/CommitCnt >= MAX_RECS_BEFORE_COMMIT)
             {
                CALL_M(JetCommitTransaction(SesId, JET_bitCommitFlush));
                fTransCommitted = TRUE;
                CommitCnt++;
                CALL_M(JetBeginTransaction(SesId));
                fTransCommitted = FALSE;
             }

          } while(JetMove(SesId, TblId, MoveDir/*JET_MoveNext*/, 0) >= 0);
#ifdef WINSDBG
           EndTime = GetTickCount();
           DBGPRINT2(TM, "NmsDbGetDataRecs: Retrieved %d records in %d secs\n",
                                *pNoOfRecsRet, StartTime - EndTime);
#endif
   } // if RetStat == WINS_SUCCESS
} // end of try {..}
finally {
                if (AbnormalTermination())
                {
                        DBGPRINT0(ERR,
                            "NmsDbGetDataRecsByName: Terminating abnormally\n");
                        WINSEVT_LOG_D_M(WINS_FAILURE, WINS_EVT_RPC_EXC);
                        RetStat = WINS_FAILURE;
                }
                DBGPRINT1(FLOW, "NmsDbGetDataRecsByName:Retrieved %d records\n",
                                        *pNoOfRecsRet);

                //
                //
                // We are done. Let us commit the transaction if it is not yet committed
                //
                if (!fTransCommitted)
                {
                    JET_ERR JetRetStat;

                    JetRetStat = JetCommitTransaction(SesId, JET_bitCommitFlush);
                    if (RetStat != WINS_FAILURE)
#pragma prefast(disable:243, Taken care of by the AbnormalTermination() test (PREfast bug 553))
#pragma prefast(suppress:241, Taken care of by the AbnormalTermination() test (PREfast bug 553))
                        CALL_M(JetRetStat);
#pragma prefast(enable:243, Why disable/enable? Prefast bug 709)
                }
        }

        DBGLEAVE("NmsDbGetDataRecsByName\n");
        return(RetStat);
}


STATUS
NmsDbEndTransaction(
  VOID
 )

/*++

Routine Description:


Arguments:


Externals Used:
	None

	
Return Value:

   Success status codes --
   Error status codes   --

Error Handling:

Called by:
       WinsMscChkTermEvt
Side Effects:

Comments:
	None
--*/

{
       PWINSTHD_TLS_T pTls;
       DBGENTER("NmsDbEndTransaction\n");
       GET_TLS_M(pTls);
       ASSERT(pTls != NULL);
       CALL_M(
                    JetCommitTransaction(pTls->SesId, JET_bitCommitFlush)
             );
       DBGLEAVE("NmsDbEndTransaction\n");
       return(WINS_SUCCESS);
}

#if DYNLOADJET
STATUS
SetForJet(
  VOID
 )
{
  HMODULE DllHandle;
  DWORD   Error;
  LPTSTR  pDllName;

#ifdef WINS_INTERACTIVE
  DynLoadJetVersion = getenv("JET500") ?  DYN_LOAD_JET_500
                                        : (getenv("JET200") ?  DYN_LOAD_JET_200 : DYN_LOAD_JET_600);
#endif

  DBGENTER("SetForJet\n");

  if (DynLoadJetVersion == DYN_LOAD_JET_500)
  {
    pDllName = TEXT("jet500.dll");
    NAM_ADD_OWNERID_SIZE = sizeof(DWORD);
    BASENAME = "j50";
    sNamAddTblRow[3].FldTyp = JET_coltypLong;
    sOwnAddTblRow[0].FldTyp = JET_coltypLong;
  }
  else if (DynLoadJetVersion == DYN_LOAD_JET_600 ) {
      // jet600.dll is now called esent.dll!
      pDllName = TEXT("esent.dll");
      NAM_ADD_OWNERID_SIZE = sizeof(DWORD);
      BASENAME = "j50";
      sNamAddTblRow[3].FldTyp = JET_coltypLong;
      sOwnAddTblRow[0].FldTyp = JET_coltypLong;

  }
  else
  {
    pDllName = TEXT("jet.dll");
    NAM_ADD_OWNERID_SIZE = sizeof(BYTE);
    BASENAME = "jet";
    sNamAddTblRow[3].FldTyp = JET_coltypUnsignedByte;
    sOwnAddTblRow[0].FldTyp = JET_coltypUnsignedByte;
  }


  DBGPRINT2(ERR,"SetForJet: loading DLL %ws: version %ld\n", pDllName, DynLoadJetVersion);

  OWN_ADD_OWNERID_SIZE = NAM_ADD_OWNERID_SIZE;

  //
  // Load the DLL that contains the service.
  //

  DllHandle = LoadLibrary( pDllName );
  if ( DllHandle == NULL )
  {
        Error = GetLastError();
        DBGPRINT2(ERR,"SetForJet: Failed to load DLL %ws: %ld\n", pDllName, Error);
        return(WINS_FAILURE);
  }
  else
  {
         DWORD i;
         for (i=0; i < NMSDB_SIZEOFJETFTBL; i++)
         {
            CHAR chFnName[64];
            LPSTR pAt;
            LPSTR pFnName;

            pFnName = (LPSTR)NmsDbJetFTbl[i].pFName;
#if _X86_
            if ( DynLoadJetVersion != DYN_LOAD_JET_200) {
                strcpy(chFnName,NmsDbJetFTbl[i].pFName);
                pAt = strrchr(chFnName,'@');
                if (pAt != NULL)
                {
                    *pAt = '\0';
                    pFnName = chFnName;
                }
            }
#endif
            if ((NmsDbJetFTbl[i].pFAdd = (JETPROC)GetProcAddress(DllHandle,
                      (DynLoadJetVersion >= DYN_LOAD_JET_500) ? pFnName : ULongToPtr(NmsDbJetFTbl[i].FIndex))) == NULL)
            {
              DBGPRINT2(ERR, "SetForJet: Failed to get address of function %s: %ld\n", NmsDbJetFTbl[i].pFName, GetLastError());
              return(WINS_FAILURE);
            }
            else
            {
              DBGPRINT3(DET, "SetForJet: Got address of function %s (%d): %p\n", NmsDbJetFTbl[i].pFName, i, NmsDbJetFTbl[i].pFAdd);

            }
         }

  }
  return(WINS_SUCCESS);
}
#endif


//
// Name of the process that converts jet200 db to jet500 db format
//
CHECK("Unicode from results in an exception from CreateProcess")
//#define JETCONVDB             TEXT("jetconv WINS /@")

VOID
RecoverJetDb(
    DYN_LOAD_JET_VERSION    JetVersion
    )
/*++
    This routine recovers the database by calling JetInit/JetTerm on
    the database.
Argument:
    JetVersion - The version of the jet to use when recovering the db.
--*/
{
    DYN_LOAD_JET_VERSION  JetVersionSv = DynLoadJetVersion;

    ASSERT(DYN_LOAD_JET_500 <= JetVersion );

    //
    // First JetTerm the current jet engine.
    //
    NmsDbRelRes();

    //
    // now load the appropriate version jet dll.
    //
    DynLoadJetVersion = JetVersion;

    SetForJet();


    //
    // set system params and jetinit.
    //
    SetSystemParams(TRUE);

    JetInit(&sJetInstance);

    //
    // finally, JetTerm this jet dll.
    //
    NmsDbRelRes();

    DynLoadJetVersion = JetVersionSv;
    return;
}

#define JETCONVDB200             "jetconv WINS /200 /@"
#define JETCONVDB500             "jetconv WINS /500 /@"

STATUS
ConvertJetDb(
    JET_ERR         JetRetStat
 )
{
    BOOL RetVal;
    PROCESS_INFORMATION ProcInfo = {0};
    STARTUPINFOA StartInfo = {0};
    LPSTR      pArg;



    DBGPRINT1(DET, "ConvertJetDb: Converting %s\n", (JetRetStat == JET_errDatabase200Format)
                                                    ? JETCONVDB200 : JETCONVDB500);

    if (JetRetStat == JET_errDatabase200Format)
    {

         fDbIs200 = TRUE;
         if (DynLoadJetVersion == DYN_LOAD_JET_500)
         {
               //
               // Can not run jet200 using jet500.dll on NT5.0
               //

               DBGPRINT0(ERR, "Can not run jet200 using jet500.dll on NT5.0\n");
               return WINS_FAILURE;

         } else if (DynLoadJetVersion == DYN_LOAD_JET_600){
             pArg = JETCONVDB200;
         } else {
             ASSERT(FALSE);
             return WINS_FAILURE;
         }

    } else if ( JetRetStat == JET_errDatabase500Format ) {

        if (DynLoadJetVersion == DYN_LOAD_JET_600)
        {
              // before we start the conversion, we need to bring the db to
              // consistent state. The 351 to 4.0 conversion tool (upg351db.exe)
              // did this from within the tool but the 4.0 to 5.0 tool
              // does not do this from within the tool so we need to do it here.
              RecoverJetDb( DYN_LOAD_JET_500 );

              // Start the convert process
              //
              pArg = JETCONVDB500;
              fDbIs500 = TRUE;

        } else {
            ASSERT(FALSE);
            return WINS_FAILURE;

        }

    }

    //return WINS_FAILURE;

    StartInfo.cb = sizeof(StartInfo);
    //

    // Create the convert process to do the conversion.  This process
    //
    DBGPRINT0(DET, "ConvertJetDb - creating convert process\n");
    RetVal =  CreateProcessA(
                             NULL,        //
                             pArg,
                             NULL,         //default proc. sec.
                             NULL,         //default thread. sec.
                             FALSE,        //don't inherit handles
                             DETACHED_PROCESS, //no creation flags
                             NULL,        //default env.
                             NULL,        //current drv/dir. same as creator
                             &StartInfo,        //no startup info
                             &ProcInfo        //no process info.
                             );
    if (!RetVal)
    {
         DBGPRINT1(ERR, "ConvertJetDb: Create process failed with error (%x)\n", GetLastError());
         return(WINS_FAILURE);
    }

    fConvJetDbCalled = TRUE;

    // if CreateProcess was successful, clean out handles passed to WINS
    CloseHandle(ProcInfo.hProcess);
    CloseHandle(ProcInfo.hThread);

    //
    // Log an event.
    //
    DBGPRINT0(DET, "ConvertJetDb - returning\n");

//    WINSEVT_LOG_M(WINS_SUCCESS, WINS_EVT_TEMP_TERM_UNTIL_CONV);
    return(WINS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\rpl\rplmsgf.c ===
/****
 TODO

        Change name of this module to one that indicates the module to be
        platform dependent
****/

/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:
        rplmsgf.c


Abstract:
        This module contains functions to format and unformat messages
        sent between the replicators on different WINS servers


Functions:
        RplMsgfFrmAddVersMapReq--format send ip address - max version #
                                   records request
        RplMsgfFrmAddVersMapRsp--format response to send ip address - max
                                   version # request sent earlier

        RplMsgfFrmSndEntriesReq--format send data records  request

        RplMsgfFrmSndEntriesRsp--format response to "send data records"
                                     request

        RplMsgfUfmAddVersMapRsp--unformat  "send address - max version #"
                                 response

        RplMsgfUfmSndEntriesReq--unformat "send data records" request

        RplMsgfUfmSndEntriesRsp--unformat "send data records" response

        ....

Portability:

        This module is non-portable across different address families (different
        transports) since it relies on the address being an IP address.

Author:

        Pradeep Bahl (PradeepB)          Jan-1993

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include "wins.h"
#ifdef DBGSVC
#include "nms.h"
#endif
#include "comm.h"
#include "nmsdb.h"
#include "rpl.h"
#include "rplmsgf.h"
#include "winsevt.h"
#include "winsmsc.h"

/*
 *        Local Macro Declarations
 */

/*
  ENTRY_DELIM  -- Delimiter between data records (name-address mapping records)
                  in the message. The end of the message is marked by two of
                  these.

                  Since a data record starts with the length of the name
                  (which will never by FFFFFFFF), this delimiter serves us
                  fine.
*/
#define ENTRY_DELIM        0xFFFFFFFF                //-1

/*
 *        Local Typedef Declarations
*/



/*
 *        Global Variable Definitions
 */



/*
 *        Local Variable Definitions
 */



/*
 *        Local Function Prototype Declarations
 */

/* prototypes for functions local to this module go here */


FUTURES("Change to a macro")
PERF("Change to a macro")
VOID
RplMsgfFrmAddVersMapReq(
        IN  LPBYTE        pBuff,
        OUT LPDWORD        pMsgLen
        )

/*++

Routine Description:
        This function formats the message to request a remote WINS server's
        replicator to send the IP address - Max Version # mappings

Arguments:


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

        GetVersNo() in rplpull.c
Side Effects:

Comments:
        None
--*/
{
        RPLMSGF_SET_OPC_M(pBuff, RPLMSGF_E_ADDVERSNO_MAP_REQ);
        *pMsgLen = 4;
        return;
}



VOID
RplMsgfFrmAddVersMapRsp(
#if SUPPORT612WINS > 0
    IN  BOOL fPnrIsBeta1Wins,
#endif
        IN  RPLMSGF_MSG_OPCODE_E   Opcode_e,
        IN  LPBYTE                 pBuff,
        IN  DWORD                  BuffLen,
        IN  PRPL_ADD_VERS_NO_T     pOwnerAddVersNoMap,
        IN  DWORD                  MaxNoOfOwners,
        IN  DWORD                  InitiatorWinsIpAdd,
        OUT LPDWORD                pMsgLen
        )

/*++

Routine Description:

        This function formats the following two messages

        1)Response to the "send me IP address - version # map " request"

        2)Push Notification message.

        Both messages are identical except for the opcode



Arguments:

        Opcode_e              - Opcode indicating the message to send
        pBuff                 - Buffer to populate
        BuffLen               - Buffer length
        pOwnerAddVersNoMap    - Array of address to version numbers mappings.
                                The version number is the max version number
                                for the owner RQ server
        MaxNoOfOwners         - Max. No Of Owners in this WINS's db
        InitiatorWinsIpAdd    - Address of WINS that initiated the push.
        pMsgLen               - Actual length of buffer filled in

Externals Used:
        None


Return Value:

        None

Error Handling:

Called by:
        Push Handler (Push Thread)

Side Effects:

Comments:
        None
--*/

{
        LPLONG          pTmpL = (LPLONG)pBuff;
        LPBYTE          pTmpB = pBuff;
        DWORD           i;    //counter for looping over all records
        VERS_NO_T       StartVersNo;
        WINS_UID_T      Uid;

        //
        // Backward compatibility with pre-3.51 beta copies of WINS.
        //
        StartVersNo.QuadPart = 0;
        Uid                  = 1;

        RPLMSGF_SET_OPC_M(pTmpB, Opcode_e);

        pTmpL = (LPLONG)pTmpB;


        /*
         * Store number of records in the buffer
        */
        COMM_HOST_TO_NET_L_M( MaxNoOfOwners,  *pTmpL );

        pTmpL +=  1;

        //
        // To guard us (PUSH thread) against simultaneous updates to the
        // NmsDbOwnAddTbl array (by the PULL thread).  This array is
        // accessed by RPL_FIND_ADD_BY_OWNER_ID_M macro
        //

        /*
        *  Now, let us store all the records
        */
          for (i = 0; i < MaxNoOfOwners; i++)
        {


            /*
             *         We will send the V part of the address since the other
             *  end knows the T and L (more like XDR encoding where T is
             *        not sent)
            */

NONPORT("Do not rely on the address being a long here")

            /*
             *        As an optmization here, we make use of the fact that
             *        the address is an IP address and is therefore a long.
             *        When we start working with more than one address family or
             *        when the size of the IP address changes, we should change
             *        the code here.  For now, there is no harm in optimizing
             *        it
            */
           COMM_HOST_TO_NET_L_M(
                (pOwnerAddVersNoMap + i)->OwnerWinsAdd.Add.IPAdd, *pTmpL
                               );


           pTmpL++;  //advance to next 4 bytes

           /*
            * Store the version number
           */
            WINS_PUT_VERS_NO_IN_STREAM_M(
                                &((pOwnerAddVersNoMap + i)->VersNo),
                                pTmpL
                                        );

            pTmpL = (LPLONG)((LPBYTE)(pTmpL) + WINS_VERS_NO_SIZE); //adv. the
                                                                  //pointer
#if SUPPORT612WINS > 0
      if (fPnrIsBeta1Wins == FALSE)
      {
#endif
           /*
            * Store the Start version number
           */
            WINS_PUT_VERS_NO_IN_STREAM_M( &StartVersNo, pTmpL );

            pTmpL = (LPLONG)((LPBYTE)(pTmpL) + WINS_VERS_NO_SIZE); //adv. the
                                                                  //pointer
            COMM_HOST_TO_NET_L_M( Uid,  *pTmpL );
            pTmpL++;
#if SUPPORT612WINS > 0
      }
#endif

        }

        COMM_HOST_TO_NET_L_M( InitiatorWinsIpAdd,  *pTmpL );
        pTmpL++;

        //
        // Let us tell our client the exact length of the response message
        //
        *pMsgLen = (ULONG) ( (LPBYTE)pTmpL - (LPBYTE)pBuff );
        return;

} // RplMsgfFormatAddVersMapRsp()



VOID
RplMsgfFrmSndEntriesReq(
#if SUPPORT612WINS > 0
    IN  BOOL fPnrIsBeta1Wins,
#endif
        IN  LPBYTE        pBuff,
        IN  PCOMM_ADD_T pWinsAdd,
        IN  VERS_NO_T        MaxVersNo,
        IN  VERS_NO_T        MinVersNo,
        IN  DWORD       RplType, //for now
        OUT LPDWORD        pMsgLen
        )

/*++

Routine Description:

        This function is called to format a "send data entries" request for
        getting records belonging to a particular WINS server.

Arguments:
        pBuff     - Buffer that will store the request message
        pWinsAdd  - Address of the RQ server whose data records are being
                   sought
        MaxVersNo - Max. Version Number in the range of records sought
        MinVersNo - Min. Version Number in the range of records sought.
        pMsgLen   - Length of request message

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        PullEntries() in rplpull.c

Side Effects:

Comments:
        I might update this function to format a request for getting
        data records of more than one WINS server.

        For the sake of simplicity, I have chosen not to do so currently.
--*/
{
        LPBYTE            pTmpB = pBuff;
        LPLONG            pTmpL;

        RPLMSGF_SET_OPC_M(pTmpB, RPLMSGF_E_SNDENTRIES_REQ);
        pTmpL = (LPLONG)pTmpB;

        /*
         * We will send the V part of the address since the other
         * end knows the T and L (more like XDR encoding where T is
         * not sent)
        */

NONPORT("Do not rely on the address being a long here")

        /*
         * As an optmization here, we make use of the fact that
         * the address is an IP address and is therefore a long.
         * When we start working with more than one address family or
         * when the size of the IP address changes, we should change
         * the code here.  For now, there is no harm in optimizing
         * it
        */

        COMM_HOST_TO_NET_L_M(pWinsAdd->Add.IPAdd, *pTmpL);


        pTmpL++;  //advance to next 4 bytes

        /*
        *  Store the max version number
        */
        WINS_PUT_VERS_NO_IN_STREAM_M(&MaxVersNo, pTmpL);
        pTmpL = (LPLONG)((LPBYTE)(pTmpL) + WINS_VERS_NO_SIZE);  //advance the
                                                                //pointer

        /*
         * Store the min version number
        */
        WINS_PUT_VERS_NO_IN_STREAM_M(&MinVersNo, pTmpL);
        pTmpL = (LPLONG)((LPBYTE)(pTmpL) + WINS_VERS_NO_SIZE);  //advance the
                                                                //pointer

#if SUPPORT612WINS > 0
    if (fPnrIsBeta1Wins == FALSE)
    {
#endif
            COMM_HOST_TO_NET_L_M(RplType, *pTmpL);
            pTmpL++;
#if SUPPORT612WINS > 0
    }
#endif
        //
        // Let us tell the caller the exact length of the request message
        //
        *pMsgLen = (ULONG) ((LPBYTE)pTmpL - pBuff );

        return;

}


VOID
RplMsgfFrmSndEntriesRsp (
#if SUPPORT612WINS > 0
    IN  BOOL fPnrIsBeta1Wins,
#endif
        IN LPBYTE                pBuff,
        IN DWORD                NoOfRecs,
        IN LPBYTE                pName,
        IN DWORD                NameLen,
        IN BOOL                        fGrp,
        IN DWORD                NoOfAdds,
        IN PCOMM_ADD_T                pNodeAdd,
        IN DWORD                Flag,
        IN VERS_NO_T                VersNo,
        IN BOOL                        fFirstTime,
        OUT LPBYTE                *ppNewPos
        )

/*++

Routine Description:

        This function is used to format a "send entries" response.  The
        function is called once for each data entry record that needs to be
        sent.

        The first time, it is called (fFirstTime = TRUE), it puts the
        opcode and the first directory entry in the buffer. On subsequent
        calls the data entries passed are tacked on at the end of the
        buffer


Arguments:
        ppBuff - ptr to address of location to start storing the info from.
        NoOfRecs - No of records that are being sent.
        pName   - Name of unique entry or group
        NameLen - Length of name
        fGrp        - Indicates whether the name is a unique name or a group name
        NoOfAdds - No of addresses (useful if entry is a group entry)
        pNodeAdd - Ptr to address of node (if unique entry) or to list of
                   addresses if (entry group)
        Flag        - The flag word of the entry
        VersNo  - The version number of the entry
        fFirstTime - Indicates whether this is the first call in a sequence of
                     calls to this function for formatting a send data entries
                     response
        ppNewPos - contains the starting position for the next record


Externals Used:
        None


Return Value:

        None

Error Handling:

Called by:

Side Effects:

Comments:
        NOTE NOTE NOTE

        The set of calls to this function result in a message
        containing records pertaining to one owner.  This is the owner
        whose records were requested by the PULL partner
--*/

{
        LPLONG            pTmpL = (LPLONG)pBuff;
        LPBYTE      pTmpB = pBuff;
        DWORD            i;                  /*counter for looping over all records*/


        if (fFirstTime)
        {

                //
                // In the first invocation, we need to offset the
                // pointer by the header size used by COMM code for
                // its header
                //
                // Due to the above, this formatting function is slightly
                // inconsistent with the other formatting functions that
                // don't do any offsetting.  Subsequent invocations do
                // not require any offseting.
                //

                RPLMSGF_SET_OPC_M(pTmpB, RPLMSGF_E_SNDENTRIES_RSP);
                pTmpL++;  //advance to next 4 bytes

                COMM_HOST_TO_NET_L_M(NoOfRecs, *pTmpL);
                pTmpL++;        //advance to next 4 bytes
                pTmpB = (LPBYTE)pTmpL;

        }

        /*
         * Store the length of the name
        */
        COMM_HOST_TO_NET_L_M(NameLen, *pTmpL);
        pTmpB += sizeof(LONG);

        /*
         *Store the name.
        */
        WINSMSC_COPY_MEMORY_M(pTmpB, pName, NameLen);

        /*
        * Adjust the pointer
        */
        pTmpB += NameLen;

        /*
        * let us align the next field at a long boundary
        */
        pTmpB +=  sizeof(LONG) - ((ULONG_PTR) pTmpB  % sizeof(LONG));

        /*
        * Store the Flags field
        */
#if SUPPORT612WINS > 0
    if (fPnrIsBeta1Wins == FALSE)
    {
#endif
        pTmpL   = (LPLONG)pTmpB;
            COMM_HOST_TO_NET_L_M(Flag, *pTmpL);
            pTmpB += sizeof(LONG);
#if SUPPORT612WINS > 0
    }
    else
    {
       *pTmpB++ = (BYTE)Flag;
    }
#endif

        /*
        * Store the group flag
        */
        *pTmpB++ = (UCHAR)fGrp;

        //align it on a long boundary
        pTmpB +=  sizeof(LONG) - ((ULONG_PTR)pTmpB % sizeof(LONG));

        pTmpL = (LPLONG)pTmpB;

        /*
        * Store the Version Number
        */
        WINS_PUT_VERS_NO_IN_STREAM_M(&VersNo, pTmpL);

        pTmpL = (LPLONG)((LPBYTE)pTmpL + WINS_VERS_NO_SIZE);

        if (NMSDB_ENTRY_TYPE_M(Flag) == NMSDB_UNIQUE_ENTRY)
        {
          /*
          *  We will send the V part of the address since the other
          *  and knows the T and L (more like XDR encoding where T is
          *  not sent)
          */

NONPORT("Do not rely on the address being a long here")

          /*
          * As an optmization here, we make use of the fact that
          * the address is an IP address and is therefore a long.
          * When we start working with more than one address family or
          * when the size of the IP address changes, we should change
          * the code here.  For now, there is no harm in optimizing
          * it
         */

         COMM_HOST_TO_NET_L_M(pNodeAdd->Add.IPAdd, *pTmpL);
         pTmpL++;

        }
        else        //it is a group or a multihomed entry
        {

                if (NMSDB_ENTRY_TYPE_M(Flag) != NMSDB_NORM_GRP_ENTRY)
                {

                        //
                        // we were passed a ptr to the address of the
                        // first member in a ptr instead of a pptr.
                        //
                        PCOMM_ADD_T        *ppNodeAdd = (PCOMM_ADD_T *)pNodeAdd;

                        //
                        // let us threfore initialize pNodeAdd to the address
                        // of the first member
                        //
                        pNodeAdd = *ppNodeAdd;

                        /*
                        *  It is a special group or a multihomed entry.
                        * store the number of addresses first
                        */
                        pTmpB = (LPBYTE)pTmpL;

FUTURES("If we start storing > 255 members in a group, then change the")
FUTURES("following (i.e. use COMM_HOST_TO_NET_L_M)")

                        *pTmpB++ = (BYTE)NoOfAdds;
                        pTmpB += sizeof(LONG) - 1;
                        DBGPRINT2(DET, "RplMsgfFrmSndEntriesRsp: NoOfAdds=(%d) in %s\n", NoOfAdds, NMSDB_ENTRY_TYPE_M(Flag) == NMSDB_SPEC_GRP_ENTRY ?
                                "SPECIAL GROUP" : "MULTIHOMED");
                        pTmpL = (LPLONG)pTmpB;

                        /*
                        * Store all the addresses
                        *  Note: The No of addresses is an even number
                        *  because we
                        *  are passing two addresses for each member in the
                        *  list (that is what this function gets).  The first
                        *  address of the pair is the address of the member;
                        *  the second address of the pair is the address
                        *  of the WINS server that registered or refreshed the
                        *  member)
                       */
                        for (i = 0; i < NoOfAdds ; i++)
                        {
                                   COMM_HOST_TO_NET_L_M(
                                        pNodeAdd->Add.IPAdd,
                                        *pTmpL
                                                    );
                                  pNodeAdd++;  //increment to point to
                                             //address of member
                                  pTmpL++;
                                   COMM_HOST_TO_NET_L_M(
                                                pNodeAdd->Add.IPAdd,
                                                *pTmpL
                                                    );
                                  pNodeAdd++;  //increment to point to
                                             //address of owner
                                  pTmpL++;
                        }
                }
                else // it is a normal group
                {
                         COMM_HOST_TO_NET_L_M(pNodeAdd->Add.IPAdd, *pTmpL);
                         pTmpL++;
                }
        }

        /*
        * Store the end delimiter (2 row delimiters in sequence).
        */
        *pTmpL++ = ENTRY_DELIM;
        *pTmpL   = ENTRY_DELIM;

        /*
        * Init ppBuff to point to last delimiter, so that next entry if
        * there starts from that location.  If there is no other entry,
        * then two delimiters will be there to mark the end of the message
        */
        *ppNewPos = (LPBYTE)pTmpL;
        return;
}


VOID
RplMsgfUfmAddVersMapRsp(
#if SUPPORT612WINS > 0
        IN      BOOL                fIsPnrBeta1Wins,
#endif
        IN      LPBYTE              pBuff,
        OUT     LPDWORD             pNoOfMaps,
        OUT     LPDWORD             pInitiatorWinsIpAdd,
        IN OUT  PRPL_ADD_VERS_NO_T  *ppAddVers
        )

/*++

Routine Description:

        This function unformats the request to the
        "give me address - version #" message

Arguments:
        pBuff     - Buffer that contains the response message
        pNoOfMaps - No of Address - Version # entries
        pAddVers  - array of structures storing add-version # mappings

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        GetVersNo() in rplpull.c

Side Effects:

Comments:
        pBuff should be pointing to the location just past the opcode
        (i.e. 4 bytes from the start of the opcode in the message received
--*/
{
     DWORD               i = 0;
     PRPL_ADD_VERS_NO_T  pAddVers;
     VERS_NO_T           StartVersNo;
     WINS_UID_T          Uid;

     //
     // Get the No of Mappings
     //
     COMM_NET_TO_HOST_L_M(*((LPLONG)pBuff), *pNoOfMaps);
     ASSERT(*pNoOfMaps > 0);

     pBuff += sizeof(LONG);
     if (*pNoOfMaps > 0)
     {

        WinsMscAlloc(*pNoOfMaps * sizeof(RPL_ADD_VERS_NO_T), ppAddVers);
        pAddVers = *ppAddVers;

        //
        // get all the mappings
        //
        for(i=0; i < *pNoOfMaps ; i++, pAddVers++)
        {
           COMM_NET_TO_HOST_L_M(*((LPLONG)pBuff),
                                pAddVers->OwnerWinsAdd.Add.IPAdd);
          pAddVers->OwnerWinsAdd.AddTyp_e = COMM_ADD_E_TCPUDPIP;
          pAddVers->OwnerWinsAdd.AddLen   = sizeof(COMM_IP_ADD_T);

          pBuff += sizeof(LONG);
          WINS_GET_VERS_NO_FR_STREAM_M(pBuff, &pAddVers->VersNo);

          pBuff += WINS_VERS_NO_SIZE;
#if SUPPORT612WINS > 0
          if (fIsPnrBeta1Wins == FALSE)
          {
#endif
            WINS_GET_VERS_NO_FR_STREAM_M(pBuff, &StartVersNo);

            pBuff += WINS_VERS_NO_SIZE;

            COMM_NET_TO_HOST_L_M(*((LPLONG)pBuff), Uid);
            pBuff += sizeof(LONG);
#if SUPPORT612WINS > 0
          }
#endif
        }
#if SUPPORT612WINS > 0
        if (fIsPnrBeta1Wins == FALSE)
        {
#endif
          if (pInitiatorWinsIpAdd != NULL)
          {
                COMM_NET_TO_HOST_L_M(*((LPLONG)pBuff), *pInitiatorWinsIpAdd);
           }
#if SUPPORT612WINS > 0
        }
#endif

     } // if (NoOfMaps > 0)
     return;
}


VOID
RplMsgfUfmSndEntriesReq(
#if SUPPORT612WINS > 0
    IN  BOOL fPnrIsBeta1Wins,
#endif
        IN         LPBYTE                     pBuff,
        OUT        PCOMM_ADD_T            pWinsAdd,
        OUT        PVERS_NO_T            pMaxVersNo,
        OUT        PVERS_NO_T            pMinVersNo,
        OUT     LPDWORD             pRplType
        )

/*++

Routine Description:

        This function unformats the "send entries request"

Arguments:
        pBuff          - buffer that holds the request
        pWinsAdd - memory that will hold the address of the
                   WINS whose records are being requested
        pMaxVersNo - Max. Vers. No requested
        pMinVersNo - Min. Vers. No requested

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        HandleAddVersMapReq in rplpush.c

Side Effects:

Comments:
        pBuff should be pointing to the location just past the opcode
        (i.e. 4 bytes from the start of the opcode in the message received)
--*/
{
        LPLONG        pTmpL = (LPLONG)pBuff;

NONPORT("Port when we start supporting different address families")
        pWinsAdd->AddTyp_e = COMM_ADD_E_TCPUDPIP;
        COMM_NET_TO_HOST_L_M(*pTmpL, pWinsAdd->Add.IPAdd);
        pTmpL++;

        WINS_GET_VERS_NO_FR_STREAM_M(pTmpL, pMaxVersNo);
        pTmpL = (LPLONG)((LPBYTE)pTmpL + WINS_VERS_NO_SIZE);
        WINS_GET_VERS_NO_FR_STREAM_M(pTmpL, pMinVersNo);

#if SUPPORT612WINS > 0
    if (fPnrIsBeta1Wins == FALSE)
    {
#endif
        if (pRplType != NULL)
        {
           pTmpL = (LPLONG)((LPBYTE)pTmpL + WINS_VERS_NO_SIZE);

           //COMM_NET_TO_HOST_L_M(*pTmpL, *pRplType);
           *pRplType = WINSCNF_RPL_DEFAULT_TYPE;
        }
#if SUPPORT612WINS > 0
    }
    else
    {
         *pRplType = WINSCNF_RPL_DEFAULT_TYPE;
    }
#endif
        return;
}

//__inline
VOID
RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
    IN  BOOL fPnrIsBeta1Wins,
#endif
        IN OUT         LPBYTE                 *ppBuff,
        OUT     LPDWORD                pNoOfRecs,
        OUT     IN LPBYTE        pName,
        OUT     LPDWORD                pNameLen,
        OUT     LPBOOL                pfGrp,
        OUT     LPDWORD                pNoOfAdds,
        OUT        PCOMM_ADD_T        pNodeAdd,
        OUT     LPDWORD                pFlag,
        OUT     PVERS_NO_T        pVersNo,
        IN BOOL                        fFirstTime
        )

/*++

Routine Description:

        This function unformats the "send entries response"

        When it is called the first time (fFirstTime = TRUE), it
        returns the value for the NoOfRecs OUTARG and the first
        record.  The value of ppBuff is adjusted to point to just past
        the row delimiter.

        When called the second or subsequent times, the function returns with
        the next entry in the list, until all entries have been exhausted.

        The function finds out that it is at the end of the list when
        it encounters at ENTRY_DELIM in the first 'sizeof(LONG)' bytes in
        the buffer.

        When a group entry is returned, pNodeAdd is made to point to the
        start location in *ppBuff where the list of members are stored.
        The caller will have to use the COMM_NET_TO_HOST_L_M macro to
        convert each address to its host form.

        The above requires the caller to know the transport that is used
        (by the fact that it is extracting the IP address).  For the sake
        of overall optimization, this is considered ok (If we didn't do this,
        this function would have to allocate a buffer to store all the
        addresses for a group and return that)


Arguments:

        pNodeAdd -- This should point to an array of COMM_ADD_T structures.
                    Since we have a maximum of 25 group members,
                    the caller can use an auto array.

Externals Used:
        None


Return Value:

        NONE
Error Handling:

Called by:

Side Effects:

Comments:

        ppBuff should be pointing to the location just past the opcode
        (i.e. 4 bytes from the start of the opcode in the message received)
        when the function is called the first time.  For subsequent calls,
        it would be at a row delimiter (ENTRY_DELIM)


--*/
{
        LPLONG        pTmpL = (LPLONG)*ppBuff;
        LPBYTE        pTmpB;


        if (fFirstTime)
        {
                COMM_NET_TO_HOST_L_M(*pTmpL, *pNoOfRecs);
                if (*pNoOfRecs == 0)
                {
                   return;
                }
                pTmpL++;
        }
        else
        {
                //
                // If we are pointing to a delimiter, then we have
                // reached the end of the list of data records.
                //
                if (*pTmpL == ENTRY_DELIM)
                {
                        DBGPRINT0(ERR, "RplMsgfUnfSndEntriesRsp:Weird. The function should not have been called\n");
                        /*
                          we have reached the end of the array, return
                          success.

                         Note: the caller should not have called us,
                          since we gave him the No of Recs value before (
                          the first time he called)
                        */
                        WINSEVT_LOG_M(
                                            WINS_FAILURE,
                                            WINS_EVT_SFT_ERR
                                           );
                        return;
                }
        }

        pTmpB = (LPBYTE)pTmpL;

        /*
         * Store the length of the name.
        */
        COMM_NET_TO_HOST_L_M(*pTmpL, *pNameLen);
        if(*pNameLen > 255) {
            *pNoOfRecs = 0;
            return;
        }
        pTmpB += sizeof(LONG);

        /*
         * Store the name.
        */
        WINSMSC_COPY_MEMORY_M(pName, pTmpB, *pNameLen);

        /*
        * Adjust the pointer
        */
        pTmpB += *pNameLen;

        /*
        * The next field is at a long boundary.  So, let us adjust pTmpB
        */
        pTmpB +=  sizeof(LONG) - ((ULONG_PTR)pTmpB % sizeof(LONG));

        /*
        * Store the Flags field
        */
#if SUPPORT612WINS > 0
    if (fPnrIsBeta1Wins == FALSE)
    {
#endif
        pTmpL   = (LPLONG)pTmpB;
            COMM_NET_TO_HOST_L_M(*pTmpL, *pFlag);
            pTmpB += sizeof(LONG);
#if SUPPORT612WINS > 0
    }
    else
    {
        *pFlag = (DWORD)*pTmpB++;
    }
#endif

        /*
        *  Store the group field
        */
        *pfGrp = *pTmpB++;

        //align it at a long boundary
        pTmpB +=  sizeof(LONG) - ((ULONG_PTR)pTmpB % sizeof(LONG));

        pTmpL = (LPLONG)pTmpB;

        /*
        *  Store the Version Number
        */
        WINS_GET_VERS_NO_FR_STREAM_M(pTmpL, pVersNo);
        pTmpL = (LPLONG)((LPBYTE)pTmpL + WINS_VERS_NO_SIZE);

        if (NMSDB_ENTRY_TYPE_M(*pFlag) == NMSDB_UNIQUE_ENTRY)
        {

NONPORT("Do not rely on the address being a long here")

          /*
          As an optmization here, we make use of the fact that
          the address is an IP address and is therefore a long.
          When we start working with more than one address family or
          when the size of the IP address changes, we should change
          the code here.  For now, there is no harm in optimizing
          code here
         */
         pNodeAdd->AddTyp_e = COMM_ADD_E_TCPUDPIP;
         COMM_NET_TO_HOST_L_M(*pTmpL, pNodeAdd->Add.IPAdd);
         pNodeAdd->AddLen = sizeof(COMM_IP_ADD_T);
         pTmpL++;

        }
        else          //it is either a group entry or a multihomed entry
        {
                DWORD i;

             if(NMSDB_ENTRY_TYPE_M(*pFlag) != NMSDB_NORM_GRP_ENTRY)
             {
                /*
                * store the number of addresses first
                */
                pTmpB = (LPBYTE)pTmpL;

FUTURES("If we start storing > 255 members in a group, then change the")
FUTURES("following (i.e. use COMM_HOST_TO_NET_L_M)")

                *pNoOfAdds = *pTmpB++;
                pTmpB += sizeof(LONG) - 1;

                DBGPRINT2(FLOW, "RplMsgfUfrmSndEntriesRsp: NoOfAdds=(%d) in %s record \n", *pNoOfAdds, NMSDB_ENTRY_TYPE_M(*pFlag) == NMSDB_SPEC_GRP_ENTRY ? "SPECIAL GROUP": "MULTIHOMED");

                pTmpL = (LPLONG)pTmpB;


                /*
                 Init the pointer to the list of addresses

                 Note: The No of addresses is an even number because we
                        are passing two addresses for each member in the
                        list (that is what this function returns).  The first
                        address of the pair is the address of the member;
                        the second address of the pair is the address
                        of the WINS server that registered or refreshed the
                        member)
                */
                for (i = 0; i < *pNoOfAdds ; i++)
                {
NONPORT("this will have to be changed when we move to other address families")

                  //
                  // Get address of owner
                  //
                  pNodeAdd->AddTyp_e = COMM_ADD_E_TCPUDPIP;
                  pNodeAdd->AddLen   = sizeof(COMM_IP_ADD_T);
                   COMM_NET_TO_HOST_L_M(*pTmpL, pNodeAdd->Add.IPAdd);
                  pNodeAdd++;
                  pTmpL++;

                  //
                  // Get address of member
                  //
                  pNodeAdd->AddTyp_e = COMM_ADD_E_TCPUDPIP;
                  pNodeAdd->AddLen   = sizeof(COMM_IP_ADD_T);
                   COMM_NET_TO_HOST_L_M(*pTmpL, pNodeAdd->Add.IPAdd);
                  pNodeAdd++;
                  pTmpL++;
                }
           }
           else //it is a normal group
           {
                 pNodeAdd->AddTyp_e = COMM_ADD_E_TCPUDPIP;
                 COMM_NET_TO_HOST_L_M(*pTmpL, pNodeAdd->Add.IPAdd);
                 pNodeAdd->AddLen = sizeof(COMM_IP_ADD_T);
                 pTmpL++;
           }
        }

        /*
        * Make the ptr point to the location after the ENTRY_DELIM
        */
        pTmpL++ ;

        /*
        * Init ppBuff to point to last delimiter, so that next entry if
        * there starts from that location.  If there is no other entry,
        * then two delimiters will be there to mark the end of the message
        */
        *ppBuff = (LPBYTE)pTmpL;

        return;
}

VOID
RplMsgfUfmPullPnrReq(
        LPBYTE                pMsg,
        DWORD                        MsgLen,
        PRPLMSGF_MSG_OPCODE_E pPullReqType_e
        )

/*++

Routine Description:

        This function unformats a message received from a WINS
        that is a pull partner

Arguments:


Externals Used:
        None

Return Value:

        None

Error Handling:

Called by:
        Push Thread

Side Effects:

Comments:
        Change this function to a macro
--*/
{
        UNREFERENCED_PARAMETER(MsgLen);

        //
        //  First three bytes should be 0s.
        //
PERF("since we never use up more than 1 byte for the opcode, we can get")
PERF("rid of the first 3 assignements down below and retrieve the opcode")
PERF("directly from the 4th byte.  Make corresponding change in the formatting")
PERF("functions too")

        *pPullReqType_e |= *pMsg++ << 24;
        *pPullReqType_e |= *pMsg++ << 16;
        *pPullReqType_e |= *pMsg++ << 8;
        *pPullReqType_e  = *pMsg ;
        return;
}



VOID
RplMsgfFrmUpdVersNoReq(
        IN  LPBYTE        pBuff,
        IN  LPBYTE        pName,
        IN  DWORD        NameLen,
        OUT LPDWORD        pMsgLen
                )

/*++

Routine Description:

        This function is called to format an "update version number" request

Arguments:
        pBuff -   Buffer that will hold the formatted request
        pName -   Name in the name-address mapping db that needs to have
                  its version no. updated
        NameLen - Length of the name
        pMsgLen - Length of the formatted message

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        InfRemWins() in nmschl.c

Side Effects:

Comments:
        None
--*/

{

        LPBYTE        pTmpB = pBuff;
        LPLONG  pTmpL = (LPLONG)pBuff;

        RPLMSGF_SET_OPC_M(pTmpB, RPLMSGF_E_UPDVERSNO_REQ);
        pTmpL = (LPLONG)pTmpB;

        /*
         * Store the length of the name.
        */
        COMM_HOST_TO_NET_L_M(NameLen, *pTmpL);
        pTmpB += sizeof(LONG);

        /*
         * Store the name.
        */
        WINSMSC_COPY_MEMORY_M(pTmpB, pName, NameLen);

        /*
        * Adjust the pointer
        */
        pTmpB += NameLen;

        //
        // Find size of req buffer
        //
        *pMsgLen = (ULONG) (pTmpB - pBuff);

        return;
}

VOID
RplMsgfUfmUpdVersNoReq(
        IN   LPBYTE        pBuff,
        OUT  LPBYTE        pName,
        OUT  LPDWORD        pNameLen
                )

/*++

Routine Description:
        This function is called to unformat the "update version no" request
        sent by a remote WINS

Arguments:
        pBuff - Buffer holding the formatted request
        pName - Name whose version no. is to be updated
        pNameLen - Length of name

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        HandleUpdVersNoReq in rplpush.c
Side Effects:

Comments:
        None
--*/

{
        LPBYTE pTmpB = pBuff;
        LPLONG pTmpL = (LPLONG)pBuff;

        /*
         * Store the length of the name.
        */
        COMM_NET_TO_HOST_L_M(*pTmpL, *pNameLen);
        pTmpB += sizeof(LONG);

        /*
         * Store the name.
        */
        WINSMSC_COPY_MEMORY_M(pName, pTmpB, *pNameLen);

        /*
        * Adjust the pointer
        */
        pTmpB += *pNameLen;

        return;

}
VOID
RplMsgfFrmUpdVersNoRsp(
        IN LPBYTE                         pRspBuff,
        IN BYTE                                Rcode,
        OUT LPDWORD                         pRspBuffLen
        )

/*++

Routine Description:

        This function is called to send the response to the "update version
          # request"

Arguments:
        pRspBuff - Buffer to hold the formatted response
        Rcode    - result of the operation
        pRspBuffLen  - Length of response

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        HandleUpdVersNoReq() in rplpush.c

Side Effects:

Comments:
        None
--*/

{

        LPBYTE        pTmpB = pRspBuff;

        RPLMSGF_SET_OPC_M(pTmpB, RPLMSGF_E_UPDVERSNO_RSP);
        *pTmpB++ = Rcode;

        *pRspBuffLen = (ULONG) (pTmpB - pRspBuff);

        return;
}


FUTURES("change to a macro")
PERF("change to a macro")

VOID
RplMsgfUfmUpdVersNoRsp(
        IN  LPBYTE                         pRspBuff,
        OUT LPBYTE                        pRcode
        )

/*++

Routine Description:

        This function is called to unformat the response to the
        "update version number" request.

Arguments:
        pRspBuff  - Buffer holding the formatted response
        pRcode          - result of the update

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        InfRemWins() in nmschl.c

Side Effects:

Comments:
        Change to a macro
--*/

{
        *pRcode = *pRspBuff;
        return;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\rpl\rpl.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

        rpl.c

Abstract:
        This module contains functions used by the COMSYS and NMS components
        of WINS.  It also contains functions used by both the Pull and Push
        handler components of the Replicator

Functions:
        RplInit
        RplInsertQue
        RplFindOwnerId
        RplPushProc

Portability:

        This module is portable


Author:

        Pradeep Bahl (PradeepB)          Jan-1993

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include "wins.h"
#include <winsock2.h>
#include "nms.h"
#include "nmsdb.h"
#include "winsmsc.h"
#include "winsevt.h"
#include "winscnf.h"
#include "winsque.h"
#include "winsthd.h"
#include "comm.h"
#include "nmsnmh.h"
#include "rpl.h"
#include "rplmsgf.h"
#include "rplpull.h"
#include "rplpush.h"


/*
 *        Local Macro Declarations
 */
#define INIT_REC_BUFF_HEAP_SIZE                1000            //1000 bytes

//
// defines for the local message sent by the replicator to the Push/Pull
// thread and for setting the opcode in such a message
//
#define LOCAL_RPL_MSG_SZ        (RPL_OPCODE_SIZE + COMM_BUFF_HEADER_SIZE + sizeof(LONG))
#define SET_OPCODE_M(pBuff, Opc)  {                                \
                                     *((pBuff) + LOCAL_RPL_MSG_SZ + 3) = \
                                                (Opc);                        \
                                  }
#define USER_PORTION_M(pMsg)        (pMsg + COMM_BUFF_HEADER_SIZE + sizeof(LONG))
#define USER_LEN_M(TotalLen)        (TotalLen - COMM_BUFF_HEADER_SIZE - sizeof(LONG))
/*
 *        Local Typedef Declarations
 */



/*
 *        Global Variable Definitions
 */
HANDLE            RplWrkItmHeapHdl;
#if 0
HANDLE            RplRecHeapHdl;
#endif

HANDLE                RplSyncWTcpThdEvtHdl; //Sync up with the TCP thread
//
// critical section to guard the RplPullOwnerVersNo array
//
CRITICAL_SECTION  RplVersNoStoreCrtSec;

/*
 *        Local Variable Definitions
 */

//
// Critical Section that is instantiated only if this WINS server has
// one or more Push Partners
//
CRITICAL_SECTION  sPushNtfCrtSec;

/*
 *        Local Function Prototype Declarations
 */

/* prototypes for functions local to this module go here */
STATUS
ERplInit(
        VOID
)

/*++

Routine Description:
        This function is called to initialize the replicator.

        It creates the PULL and PUSH threads

Arguments:
        pRplConfigRec        - A list of configuration records

Externals Used:
        None

Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        Init() in nms.c

Side Effects:

Comments:
        Replicator connections are dynamic.  They are initiated when
        needed and terminated when they have served their purpose.

        If the connections were to be made STATIC, we would do the
        following in the above function:


        Start a dialogue with each pull partner.  Also
        creates a dialogue with each of the WINS servers that we have to
        send a notification to.
--*/
{

        STATUS         RetStat;


        //
        // Make a copy of the magic number
        //
        RplPullCnfMagicNo        = WinsCnf.MagicNo;


        /*
        * Create heap for allocating Rpl work items
        */
        DBGPRINT0(HEAP_CRDL, "ERplInit: Rpl Wrk. Item. Heap\n");
        RplWrkItmHeapHdl =  WinsMscHeapCreate(
                                0,    /*to have mutual exclusion        */
                                RPL_WRKITM_BUFF_HEAP_SIZE
                                        );

#if 0
        /*
        * Create heap for allocating memory for names that are longer
        * than 17 characters and for storing group members when the
        * number of members are > 5
        */
        RplRecHeapHdl =  WinsMscHeapCreate(
                                0,    /*to have mutual exclusion        */
                                INIT_REC_BUFF_HEAP_SIZE
                                        );
#endif

        /*
          We create a PULL thread regardless of whether or not there
          was a PULL record in the configuration info (in the registry).
          This is because another WINS could send this WINS a push
          notification.  This push notification will be received by the
          PUSH thread which will forward it to the PULL thread.

          Considering that a situation where an RQ server in a multi-RQ
          configuration not getting Push notifications or not pulling
          from another RQ server is rare, we go ahead and create the
          PULL thread.

          A redundent PULL thread is not much overhead. Creating a PULL thread
          on demand is going to be messier.
        */
        WinsMscCreateEvt(
                          TEXT("RplPullSynchWTcpThdEvtHd"),
                          FALSE,                 //auto-reset
                          &RplSyncWTcpThdEvtHdl
                        );


        //
        // Initialize the critical section that guards the
        // RplPullOwnerVersNo Table.
        //
        InitializeCriticalSection(&RplVersNoStoreCrtSec);

        RetStat = WinsMscSetUpThd(
                        &QueRplPullQueHd,
                        RplPullInit,
                        &WinsCnf,
                        &WinsThdPool.RplThds[WINSTHD_RPL_PULL_INDEX].ThdHdl,
                        &WinsThdPool.RplThds[WINSTHD_RPL_PULL_INDEX].ThdId
                             );

        if (RetStat == WINS_SUCCESS)
        {
                        WinsThdPool.RplThds[WINSTHD_RPL_PULL_INDEX].fTaken =
                                                                TRUE;
                        WinsThdPool.ThdCount++;  //increment the thread count
        }

        //
        //  initialize the sPushNtfCrtSec Critical Section.  This is
        //  used by ERplPushProc
        //
CHECK("Is this critical section needed. I don't think so")
        InitializeCriticalSection(&sPushNtfCrtSec);

        /*
        We create the PUSH thread regardless of whether or not there was
        any PUSH record in the configuration info in the registry.  This is
        because, other WINS servers could pull from this WINS or send it
        a push notification.


        Perhaps we should wait until the first connection from a PULL
        partner is received.  That however will complicate the design
        a bit more.   Considering that a situation where nobody is pulling
        from the RQ server is going to be rare in a multi-RQ server
        configuration, we just go ahead and create the PUSH thread now
        and keep the design simple and clean.
        */
PERF("Don't create the thread here. Let WinsQueInsertRplPushWrkItm create it")

        //
        // Set it to TRUE here before creating the thread instead of after
        // it has been created to escape the window where another thread
        // creates it from inside WinsQueInsertRplPushWrkItm (Not the
        // case currently)
        //
        fRplPushThdExists = TRUE;
        RetStat = WinsMscSetUpThd(
                        &QueRplPushQueHd,
                        RplPushInit,
                        &WinsCnf,
                        &WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].ThdHdl,
                        &WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].ThdId
                                );

        if (RetStat == WINS_SUCCESS)
        {
                WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].fTaken =
                                                                TRUE;
                WinsThdPool.ThdCount++;  //increment the thread count
        }
        else
        {
                fRplPushThdExists = FALSE;
        }
        return(WINS_SUCCESS);
}



STATUS
RplFindOwnerId (
        IN  PCOMM_ADD_T                 pWinsAdd,
        IN  OUT LPBOOL                  pfAllocNew,
        OUT DWORD UNALIGNED             *pOwnerId,
        IN  DWORD                       InitpAction_e,
        IN  DWORD                       MemberPrec
        )

/*++

Routine Description:

        The function finds the owner id correponding to a WINS server.

        It searches the OwnerIdAddTbl for a match.  If none is found, it
        creates a mapping in the table and returns with the same.

Arguments:
        pWinsAdd -- Address of WINS whose owner id is sought
        pfAllocNew -- On input, if TRUE, assign an owner id. if this WINS is
                      not known. On output indicates whether a new entry
                      was allocated or old one (deleted one) reused
        pOwnerId  -- Owner Id of WINS
        pNewStartVersNo - Start vers. no of this WINS.
        pOldStartVersNo - Start vers. no of this WINS that we have.
        pNewUid         - Uid of the WINS
        pOldUid         - Old Uid of the WINS


Externals Used:
        NmsDbOwnAddTbl

Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        NmsDbGetDataRecs, HandleUpdVersNoReq in rplpush.c

Side Effects:

Comments:
        This function is always called with either the last 4 arguments being
        NULL or non-NULL.
--*/

{
        DWORD                  i;
        STATUS                 RetStat       = WINS_SUCCESS;
        DWORD                  NoOfOwners;
        PNMSDB_ADD_STATE_T     pOwnAddTbl     = pNmsDbOwnAddTbl;
        BOOL                   fDelEntryFound = FALSE;
        DWORD                  OwnerIdOfFirstDelEntry;


        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
        NoOfOwners = NmsDbNoOfOwners;
try {
        /*
        *        check OwnerIdAddTbl for a mapping
        */
        for (i = 0; i < NoOfOwners; i++, pOwnAddTbl++)
        {
                if (
                        (ECommCompAdd(
                                pWinsAdd,
                                &(pOwnAddTbl->WinsAdd)
                                       )  == COMM_SAME_ADD)
                                  ||
                        (pOwnAddTbl->WinsState_e ==
                                        NMSDB_E_WINS_DELETED)
                   )
                {


                        //
                        // if the state of WINS in the in-memory table is
                        // deleted, then we check if we are allowed (by the
                        // client of this function) to allocate a new
                        // entry (or reuse one that is deleted). If yes,
                        // we change the state of this WINS to ACTIVE
                        // and also update the database table
                        //
                        if (pOwnAddTbl->WinsState_e == NMSDB_E_WINS_DELETED)
                        {
                            if (!fDelEntryFound)
                            {
                              fDelEntryFound = TRUE;
                              OwnerIdOfFirstDelEntry = i;
                            }
                            continue;
                        }
                        else  // state is not deleted (means we found our entry)
                        {
#if 0
                                ModifyRec();
#endif

                                //
                                // Since we did not reuse an old one, set
                                // *pfAllocNew to FALSE
                                //
                                *pfAllocNew = FALSE;
                        }
                        *pOwnerId = i;
                        break;
                }
        }

        //
        // if we did not find any entry in the table ...
        //
        if (i == NoOfOwners)
        {
            //
            // If we are authorized to create an entry and we have one or
            // more vacant slots to do this ..
            //
            if (*pfAllocNew)
            {
                  //
                  // If we have a deleted entry, reuse it
                  //
                  if (fDelEntryFound)
                  {
                        pOwnAddTbl = pNmsDbOwnAddTbl+OwnerIdOfFirstDelEntry;
                        pOwnAddTbl->WinsState_e =  NMSDB_E_WINS_ACTIVE;
                        pOwnAddTbl->WinsAdd     = *pWinsAdd;

#if 0
                        AssignStartVersNo()
#endif
                       WINS_ASSIGN_INT_TO_VERS_NO_M(pOwnAddTbl->StartVersNo, 0);

                        /*
                        * Write the record into the database table
                        */
                        NmsDbWriteOwnAddTbl(
                                        NMSDB_E_INSERT_REC,
                                        OwnerIdOfFirstDelEntry,
                                        pWinsAdd,
                                        NMSDB_E_WINS_ACTIVE,
                                        &pOwnAddTbl->StartVersNo,
                                        &pOwnAddTbl->Uid
                                           );
                        //
                        // The above function has incremented the
                        // number of owners. Since we reused
                        // a deleted entry, let us correct the
                        // count
                        //
                        NmsDbNoOfOwners--;
                        *pOwnerId = OwnerIdOfFirstDelEntry;
                  }
                  else  // we don't have a deleted entry
                  {
                       /*
                        * If mapping could not be found, create one and store it
                        *
                        *  Enter the critical section first since an RPC thread
                        *  may be accessing this table (WinsStatus())
                        */

                        if (i >= NmsDbTotNoOfSlots)
                        {

                           WINSMSC_REALLOC_M(
                             sizeof(NMSDB_ADD_STATE_T)*(NmsDbTotNoOfSlots * 2),
                             (LPVOID *)&pNmsDbOwnAddTbl
                                      );
                           pOwnAddTbl = pNmsDbOwnAddTbl + NmsDbTotNoOfSlots;
                           NmsDbTotNoOfSlots *= 2;
                           DBGPRINT1(DET, "RplFindOwnerId: NO OF SLOTS IN NMSDBOWNASSTBL HAS BEEN INCREASED TO %d\n", NmsDbTotNoOfSlots);

                           if (RplPullMaxNoOfWins < NmsDbTotNoOfSlots)
                           {
                                RplPullAllocVersNoArray(&pRplPullOwnerVersNo, NmsDbTotNoOfSlots);
                                RplPullMaxNoOfWins = NmsDbTotNoOfSlots;
                           }

                           DBGPRINT2(DET, "RplFindOwnerId: NO OF SLOTS IN NMSDBOWNADDTBL and in RPL_OWNER_VERS_NO_ARRAY HAS BEEN INCREASED TO (%d and %d)\n", NmsDbTotNoOfSlots, RplPullMaxNoOfWins);

                        }
                        pOwnAddTbl->WinsAdd     = *pWinsAdd;
                        pOwnAddTbl->WinsState_e = NMSDB_E_WINS_ACTIVE;
#if 0
                        InitStartVersNo()
#endif
                       *pOwnerId                       = i;

                       /*
                       * Write the record into the database table. The following
                       * call will increment NmsDbNoOfOwners
                       */
                       NmsDbWriteOwnAddTbl(
                           NMSDB_E_INSERT_REC,
                           i,
                           pWinsAdd,
                           NMSDB_E_WINS_ACTIVE,
                           &pOwnAddTbl->StartVersNo,
                           &pOwnAddTbl->Uid
                                   );

                }
           }
           else  //can't allocate a new one
           {

                //
                // if we weren't asked to allocate a new one, return a
                // failure code.  If we were asked to allocate a new one,
                // raise an exception (serious error)
                //
                RetStat     = WINS_FAILURE;
                *pfAllocNew = FALSE;
           }
        }
 }
 except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("RplFindOwnerId");
        RetStat = WINS_FAILURE;
        //
        // log a message
        //
  }
        //
        // if we were able to find the member or inserted it
        //
        if (RetStat != WINS_FAILURE)
        {
                if (
                        (InitpAction_e == WINSCNF_E_INITP)
                                ||
                        (
                           (InitpAction_e == WINSCNF_E_INITP_IF_NON_EXISTENT)
                                         &&
                           (*pfAllocNew)
                        )
                   )
                {
                        pOwnAddTbl->MemberPrec = MemberPrec;
                }

        }
        LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
        return(RetStat);
}


STATUS
ERplInsertQue(
        WINS_CLIENT_E        Client_e,
        QUE_CMD_TYP_E        CmdType_e,
        PCOMM_HDL_T        pDlgHdl,
        MSG_T                pMsg,
        MSG_LEN_T        MsgLen,
        LPVOID                pClientCtx,
        DWORD           MagicNo
        )

/*++

Routine Description:
        This function is called to queue a replicator request

Arguments:
        Client_e - Client that is inserting the work item
        CmdType_e - Type of command to be specified in the work item
        pDlgHdl   - Dlg Hdl if relevant to the work item
        pMsg          - Message if this function is executing in a comm thread
        Msglen    - Length of the message
        pClientCtx - Context of the client to insert in the work item


Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:
        ParseMsg() in comm.c, HandleUpdNtf() in rplpush.c, etc

Side Effects:

Comments:
        None
--*/

{

FUTURES("Move all this to queue.c; Enter and leave critical sections")

        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm;
        PQUE_TMM_REQ_WRK_ITM_T        pTmmWrkItm;

        QueAllocWrkItm(
                        RplWrkItmHeapHdl,
                        sizeof(QUE_RPL_REQ_WRK_ITM_T),
                        (LPVOID *)&pWrkItm
                      );

        switch(CmdType_e)
        {
          /*
            Wrk item queues by COMSYS (tcp listener thread) -- when a
                replicator  message has been received
          */
          case(QUE_E_CMD_REPLICATE_MSG):

                        pWrkItm->pMsg     = pMsg;
                        pWrkItm->MsgLen   = MsgLen;
                        pWrkItm->DlgHdl   = *pDlgHdl;
                        pWrkItm->CmdTyp_e = CmdType_e;

                        QueInsertRplPushWrkItm(
                                (PLIST_ENTRY)pWrkItm,
                                FALSE         //we are not in the crit. sec.
                                      );
                        break;

          //
          //  Work items are also queued as a result of
          //  administrative action
          //
          case(QUE_E_CMD_REPLICATE):
          case(QUE_E_CMD_PULL_RANGE):

                        DBGPRINT0(FLOW,
                   "RplInsertQue: PULL Trigger command from administrator\n"
                                 );

                        pWrkItm->CmdTyp_e   = CmdType_e;
                        pWrkItm->pClientCtx = pClientCtx;
            pWrkItm->MagicNo    = MagicNo;
                        QueInsertWrkItm(
                                (PLIST_ENTRY)pWrkItm,
                                QUE_E_RPLPULL,
                                NULL
                                      );
                        break;

          /*
           *  Wrk items queued by the Timer Manager thread -- when a timeout
           *  has occurred.
          */

          //
          //  Currently, not being used by TMM. This if for future extensibility
          //  Tmm interfaces with different clients and it is better that
          //  that it be unaware of who the client is (see wintmm.c).  When
          //  in the future, there is a case where TMM acquires knowledge
          //  of who the client is, it can use the ERplInsertQue function
          //  for Rpl Client to notify it if the timer expiration.
          //
          case(QUE_E_CMD_TIMER_EXPIRED):

                        pTmmWrkItm             = pClientCtx;

                        pWrkItm->pClientCtx = pTmmWrkItm->pClientCtx;
                        pWrkItm->CmdTyp_e   = CmdType_e;

                        QueInsertWrkItm(
                                        (PLIST_ENTRY)pWrkItm,
                                        QUE_E_UNKNOWN_TYPQ,
                                        pTmmWrkItm->pRspQueHd
                                               );
                        break;

          /*
           * Wrk item queues by the main thread -- when configuration
           * has changed
          */
          case(QUE_E_CMD_CONFIG):                //fall through
          case(QUE_E_CMD_DELETE_WINS):
          case(QUE_E_CMD_ADDR_CHANGE):

                        pWrkItm->pClientCtx = pClientCtx;
                        pWrkItm->CmdTyp_e   = CmdType_e;
                        QueInsertWrkItm(
                                        (PLIST_ENTRY)pWrkItm,
                                        QUE_E_RPLPULL,
                                        NULL
                                       );
                        break;


          /*
            Wrk item queued by an NBT thread -- when a certain number
            of updates have been exceeded

            It can also be queued by an RPC thread as a result of administrative            action.
          */
          case(QUE_E_CMD_SND_PUSH_NTF):
          case(QUE_E_CMD_SND_PUSH_NTF_PROP):

#ifdef WINSDBG
                        if (Client_e == WINS_E_WINSRPC)
                        {
                                DBGPRINT0(FLOW,
                  "RplInsertQue: PUSH trigger command from administrator\n");

                        }
#endif
                        pWrkItm->pClientCtx = pClientCtx;
                        pWrkItm->pMsg            = pMsg;
                        pWrkItm->CmdTyp_e   = CmdType_e;
                        pWrkItm->MagicNo    = MagicNo;

                        QueInsertSndNtfWrkItm( (PLIST_ENTRY)pWrkItm);
                        break;

          //
          // Work item queued by the Push thread on getting an update
          // notification message from a remote WINS
          //
          case(QUE_E_CMD_HDL_PUSH_NTF):

PERF("currently we are not passing any pClientCtx. So we can take off this")
PERF("assignment")
                        pWrkItm->pClientCtx = pClientCtx;
                        pWrkItm->CmdTyp_e   = CmdType_e;
                        pWrkItm->DlgHdl            = *pDlgHdl;
                        pWrkItm->pMsg            = pMsg;
                        pWrkItm->MsgLen     = MsgLen;
                        pWrkItm->MagicNo    = MagicNo;

                        QueInsertNetNtfWrkItm( (PLIST_ENTRY)pWrkItm);
                        break;

          default:
                        DBGPRINT1(ERR,
                                  "ERplInsertQue: Invalid client Id (%d)\n",
                                   Client_e
                                 );
                        WINSEVT_LOG_M(WINS_FATAL_ERR, WINS_EVT_SFT_ERR);
                        break;
        }

        return(WINS_SUCCESS);
}



FUTURES("Optimize so that records with Invalid metric are not looked at")
VOID
ERplPushProc(
        BOOL                fAddDiff,
        LPVOID          pCtx,
        PCOMM_ADD_T     pNoPushWins1,
        PCOMM_ADD_T     pNoPushWins2
        )

/*++

Routine Description:
        This function is called in an NBT thread or in the PULL thread
        to push notifications to remote WINS servers (Pull pnrs)

Arguments:
        fAddDiff - Indicates whether this function got called as a result of
                   address change
        pCtx     - ctx to be passed in the work item
        pNoPushWins1 - Add of wins to which a trigger should not be sent
        pNoPushWins2 - Add of wins to which a trigger should not be sent

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        NmsNmhNamRegInd, NmsNmhNamRegGrp, NmsNmhReplRegInd, NmsNmhReplGrpMems,
        NmsNmhUpdVersNo, PullEntries in rplpull.c

Side Effects:

Comments:
        This function is called inside of the NmsNmhNamRegCrtSec section.
        There is no need for the thread to be within the WinsCnfCnfCrtSec
        since the thread (main thread) that changes WinsCnf structure
        enters the NmsNmsNamRegCrtSec (besides the WinsCnfCnfCrtSec)
        prior to changing WinsCnf.

--*/

{

        PRPL_CONFIG_REC_T        pCnfRec;
        COMM_IP_ADD_T                IPAdd1 = 0;
        COMM_IP_ADD_T                IPAdd2 = 0;

        if (fAddDiff)
        {
                if (pNoPushWins1)
                {
                        IPAdd1 = pNoPushWins1->Add.IPAdd;
                }
                if (pNoPushWins2)
                {
                        IPAdd2 = pNoPushWins2->Add.IPAdd;
                }
        }


        //
        // The trigger needs to be sent to all our Push Pnrs
        //
        pCnfRec =  WinsCnf.PushInfo.pPushCnfRecs;

        DBGPRINT2(RPL, "ERplPushProc: CurrVersNo is %d %d \n", NmsNmhMyMaxVersNo.HighPart, NmsNmhMyMaxVersNo.LowPart);
        if (!pCnfRec) {
            return;
        }
        //
        // Loop over all our Push pnrs
        //
        for (
                        ;
                pCnfRec->WinsAdd.Add.IPAdd != INADDR_NONE;
                pCnfRec = (PRPL_CONFIG_REC_T)(
                               (LPBYTE) pCnfRec + RPL_CONFIG_REC_SIZE
                                             )
            )
        {

                //
                // If the replication is not being done as a result of
                // an address change, then compare our current max. version
                // number with the last one at which we sent triggers to see
                // if the requisite number of updates have been made to
                // justify another trigger.
                //
                if (!fAddDiff)
                {
                   //
                   // If the Update count field is invalid, go to the next
                   // record
                   //
                   if (pCnfRec->UpdateCount == RPL_INVALID_METRIC)
                   {
                        continue;
                   }

           //
           // This function is always called from the macro, RPL_PUSH_NTF_M().
           // When called, NmsNmhMyMaxVersNo is always the version # to be given
           // to the next record. pCnfRec->LastVersNo is the version
           // that was given to the first record after the last update
           // notification or the first update since WINS invocation if
           // no update notification was sent on WINS invocation.
           //
                   if(
                        (LiSub(NmsNmhMyMaxVersNo, pCnfRec->LastVersNo)/pCnfRec->UpdateCount)
                           == 0
             )

          {
                        DBGPRINT0(RPL, "ERplPushProc: Update Count notification threshold not reached yet\n");
                        continue;
                  }
            }
            else
            {
                   //
                   // If fAddDiff flag is TRUE, it can either mean that
                   // this function got invoked as a result of a
                   // name registration done by an NBT thread that changed
                   // the address after conflict resolution or it can mean
                   // that replication trigger was sent by an administrator
                   // who desires its propagation along a fan out tree
                   // of WINS servers (we might be at the starting point of
                   // the tree (root of the tree triggered by the admin) or
                   // at another level.  If we are not at the root, we need
                   // to check the Push Partners to which we must not
                   // propagate (we don't want to propagate to the WINS that
                   // that propagated the trigger to us.
                   //
                   if (
                        (pCnfRec->WinsAdd.Add.IPAdd == IPAdd1)
                                        ||
                        (pCnfRec->WinsAdd.Add.IPAdd == IPAdd2)
                      )
                   {
                        continue;
                   }

FUTURES("Check whether we have just done replication with this WINS")
FUTURES("This check can be madei if we store the version numbers of")
FUTURES("all owners - in our db - that we replicated to this WINS in the")
FUTURES("last replication cycle in the configuration record of this WINS")
CHECK("Is storing this information - more memory - more cycles at replication")
CHECK("more cycles at reinitialization - etc worth the saving in cycles")
CHECK("at propagation time")

               }
CHECK("Do we need this critical section ??")

               EnterCriticalSection(&sPushNtfCrtSec);
          try
          {
                {
                   pCnfRec->LastVersNo = NmsNmhMyMaxVersNo;
           DBGPRINT0(RPL, "ERplPushProc: Update Count notification BEING SENT\n");
                   ERplInsertQue(
                                WINS_E_NMSNMH,
                                fAddDiff ? QUE_E_CMD_SND_PUSH_NTF_PROP :
                                        QUE_E_CMD_SND_PUSH_NTF,
                                NULL,                  //no need to pass dlg hdl
                                pCtx,                  //ctx
                                0,                   //msg length
                                pCnfRec,
                                pCnfRec->MagicNo
                                );
                }
          }
          except(EXCEPTION_EXECUTE_HANDLER)
          {
                DWORD ExcCode = GetExceptionCode();
                DBGPRINT1(EXC, "ERplPushProc: Got Exception (%x)\n", ExcCode);
                //
                // log a message
                //
                WINSEVT_LOG_M(ExcCode, WINS_EVT_PUSH_TRIGGER_EXC);
          }
                LeaveCriticalSection(&sPushNtfCrtSec);

        } // end of for loop

        return;

} // ERplPushProc()




PRPL_CONFIG_REC_T
RplGetConfigRec(
    RPL_RR_TYPE_E   TypeOfRec_e,
    PCOMM_HDL_T     pDlgHdl,
    PCOMM_ADD_T     pAdd
    )
/*++

Routine Description:

    This function is called to search the list of pull/push pnrs and
    return with the address of the pnr corresponding to the address passed
    in.

Arguments:
    RPL_RR_TYPE_E Type of record (pull/push)
    PCOMM_HDL_T   Dlg Hdl (implicit) of Pnr

Externals Used:
        None


Return Value:
    Address of Pnr's config structure or NULL

Error Handling:

Called by:
    Push thread & CheckIfDel() in Pull thread
Side Effects:

Comments:
        None
--*/

{
    PRPL_CONFIG_REC_T   pPnr;
    BOOL                fRplPnr = FALSE;
    COMM_ADD_T          WinsAdd;
    PCOMM_ADD_T         pWinsAdd = &WinsAdd;

    DBGENTER("GetConfigRec\n");

    EnterCriticalSection(&WinsCnfCnfCrtSec);
    if (TypeOfRec_e == RPL_E_PULL)
    {
        pPnr = WinsCnf.PullInfo.pPullCnfRecs;
    }
    else
    {
        pPnr = WinsCnf.PushInfo.pPushCnfRecs;
    }

   try {
          if (pPnr != NULL)
          {
                 if (pAdd == NULL)
                 {
                   COMM_INIT_ADD_FR_DLG_HDL_M(pWinsAdd, pDlgHdl);
                 }
                 else
                 {
                       pWinsAdd = pAdd;
                 }

                 //
                 // Search for the Cnf record for the WINS we want to
                 // send the PUSH notification to/Replicate with.
                 //
                 for (
                                ;
                        (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE)
                                        &&
                                !fRplPnr;
                                // no third expression
                      )
                 {
                      //
                      // Check if this is the one we want
                      //
                      if (pPnr->WinsAdd.Add.IPAdd == pWinsAdd->Add.IPAdd)
                      {
                        //
                        // We are done.  Set the fRplPnr flag to TRUE so that
                        // we break out of the loop.
                        //
                        // Note: Don't use break since that would cause
                        // a search for a 'finally' block
                        //
                        fRplPnr = TRUE;
                        continue;        //so that we break out of the loop

                      }

                      //
                      // Get the next record that follows this one sequentially
                      //
                      pPnr = WinsCnfGetNextRplCnfRec(
                                                pPnr,
                                                RPL_E_IN_SEQ   //seq. traversal
                                                   );
                 }
        }
     }
     except(EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("GetConfigRec");
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_EXC_PULL_TRIG_PROC);
        }
     LeaveCriticalSection(&WinsCnfCnfCrtSec);

#ifdef WINSDBG
     if (fRplPnr)
     {
         DBGPRINT1(RPLPUSH, "LEAVING GetConfigRec - Pnr with address %x is in our list\n", pWinsAdd->Add.IPAdd);
     }
     else
     {
         if (pDlgHdl)
         {
           COMM_INIT_ADD_FR_DLG_HDL_M(pWinsAdd, pDlgHdl);
           DBGPRINT1(RPLPUSH, "LEAVING GetConfigRec - Pnr with address %x is NOT in our list\n", pWinsAdd->Add.IPAdd);
         }

     }
#endif

    return(fRplPnr ? pPnr : NULL);
}

#if 0
VOID
ERplPushCompl(
        PCOMM_ADD_T     pNoPushWins
        )

/*++

Routine Description:
        This function is called by the PULL thread to push notifications
        to remote WINS servers that have an INVALID_METRIC in their
        UpdateCount field (Pull pnrs)

Arguments:
        pNoPushWins - Add of wins to which a trigger should not be sent

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        This function is called inside of the NmsNmhNamRegCrtSec section.
        There is no need for the thread to be within the WinsCnfCnfCrtSec
        since the thread (main thread) that changes WinsCnf structure
        enters the NmsNmsNamRegCrtSec (besides the WinsCnfCnfCrtSec)
        prior to changing WinsCnf.

--*/

{

        VERS_NO_T                 CurrVersNo;
        PRPL_CONFIG_REC_T        pCnfRec;
        BOOL                        fPush;

        //
        // The trigger needs to be sent to all our Push Pnrs
        //
        pCnfRec =  WinsCnf.PushInfo.pPushCnfRecs;

        //
        // Let us get the current highest version no. of records owned by us
        //
        NMSNMH_DEC_VERS_NO_M(
                                  NmsNmhMyMaxVersNo,
                                  CurrVersNo
                                    );
        //
        // Loop over all our Push pnrs
        //
        for (
                        ;
                pCnfRec->WinsAdd.Add.IPAdd != INADDR_NONE;
                pCnfRec = (PRPL_CONFIG_REC_T)(
                               (LPBYTE) pCnfRec + RPL_CONFIG_REC_SIZE
                                             )
            )
        {

               //
               // If the Update count field is invalid, go to the next
               // record
               //
               if (
                         (pCnfRec->UpdateCount != RPL_INVALID_METRIC)
                                        ||
                         (pCnfRec->WinsAdd.Add.IPAdd == pNoPushWins)
                  )
               {
                        continue;
               }

               EnterCriticalSection(&sPushNtfCrtSec);
        try
        {
                {
                   pCnfRec->LastVersNo = CurrVersNo;
                   ERplInsertQue(
                                WINS_E_NMSNMH,
                                QUE_E_CMD_SND_PUSH_NTF,
                                NULL,                  //no need to pass dlg hdl
                                NULL,                  //no msg is there
                                0,                   //msg length
                                pCnfRec
                                );
                }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
                DBGPRINTEXC("ERplPushCompl:");
                //
                // log a message
                //
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_PUSH_TRIGGER_EXC);
                }

                LeaveCriticalSection(&sPushNtfCrtSec);
        }

        return;

} // ERplPushCompl()




//
// Cut and Paste from RplFindOwnerId
//
VOID
ModifyRec()
{
                                //
                                // The entry may have been inserted with a
                                // 0 start version counter value.  If we
                                // have a valid value now, put that in.
                                //
                                if (
                                     pNewStartVersNo != NULL
                                                &&
                                     (
                                       (LiNeq(pOwnAddTbl->StartVersNo,
                                                        *pNewStartVersNo))
                                                ||
                                       (pOwnAddTbl->Uid != *pNewUid)
                                     )

                                   )
                                {

                                        /*
                                         * Write the record into the database
                                         * table
                                        */
                                        NmsDbWriteOwnAddTbl(
                                                NMSDB_E_MODIFY_REC,
                                                i,
                                                pWinsAdd,
                                                NMSDB_E_WINS_ACTIVE,
                                                pNewStartVersNo,
                                                pNewUid
                                                           );

                                       *pOldStartVersNo =
                                                pOwnAddTbl->StartVersNo;
                                       *pOldUid =  pOwnAddTbl->Uid;
                                       //
                                       // Init the in-memory table's field
                                       //
                                       pOwnAddTbl->StartVersNo =
                                                        *pNewStartVersNo;
                                       pOwnAddTbl->Uid = *pNewUid;
                                }
                                else
                                {
                                        if (pOldStartVersNo != NULL)
                                        {
                                           *pOldStartVersNo =
                                                pOwnAddTbl->StartVersNo;

                                        }
                                        if (pOldUid != NULL)
                                        {
                                           *pOldUid = pOwnAddTbl->Uid;

                                        }
                                }
} //ModifyRec()
//
// Cut and paste from RplFindOwnerId
//
VOID
AssignStartVersNo()
{
                        //
                        // If we have a start version number for this
                        // WINS, use it to initialize the in-memory
                        // table field, else make the same 0.
                        //
                        if (pNewStartVersNo != NULL)
                        {
                           pOwnAddTbl->StartVersNo = *pNewStartVersNo;
                           pOwnAddTbl->Uid         = *pNewUid;

                           //
                           // Assign 0, since we didn't have any s.vers.
                           // # for this owner
                           //
                            WINS_ASSIGN_INT_TO_VERS_NO_M(
                                                *pOldStartVersNo, 0);

                           //
                           // Assign 0, since we didn't have any Uid
                           // for this owner
                           //
                           *pOldUid = 0;
                        }
                        else
                        {
                           //
                           // Assign 0, since we don't have any s.vers.
                           // # for this owner
                           //
                           WINS_ASSIGN_INT_TO_VERS_NO_M(
                                        pOwnAddTbl->StartVersNo, 0
                                                              );
                           //
                           // Assign 0, since we didn't have any Uid
                           // for this owner
                           //
                           pOwnAddTbl->Uid =  0;
                        }
} //AssignStartVersNo()
//
// Cut and paste from RplFindOwnerId()
//
InitStartVersNo()
{

                        if (pNewStartVersNo != NULL)
                        {
                          pOwnAddTbl->StartVersNo = *pNewStartVersNo;
                          WINS_ASSIGN_INT_TO_VERS_NO_M(*pOldStartVersNo,0);
                          pOwnAddTbl->Uid = *pNewUid;
                          *pOldUid = 0;
                        }
                        else
                        {
                          WINS_ASSIGN_INT_TO_VERS_NO_M(pOwnAddTbl->StartVersNo,0);
                          pOwnAddTbl->Uid = 0;
                        }
} //InitStartVersNo()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\rpl\rplpush.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:
        rplpush.c

Abstract:
        This module contains functions of the PUSH handler component
        of the Replicator.

        These functions handle the pull requests from a Pull Partner


Functions:
        RplPushInit
        ExecuteWrkItm
        HandleAddVersMapReq
        HandleSndEntriesReq
        HandleUpdNtf
        HandleUpdVersNoReq

Portability:

        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Jan-1993

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include "wins.h"
#include "nmsnmh.h"
#include "nms.h"
#include "rpl.h"
#include "rplmsgf.h"
#include "rplpush.h"
#include "rplpull.h"
#include "winsevt.h"
#include "winsque.h"
#include "nmsdb.h"
#include "winsmsc.h"
#include "winscnf.h"
#include "comm.h"


/*
 *        Local Macro Declarations
*/

//
// The amount of time the push thread will wait after its last activity
// before exiting.  This is kept to be 5 mts for now.
//
//  It is a good idea to keep it less than the Min. Replication time
//  interval
//
#define   WAIT_TIME_BEFORE_EXITING        (300000)

/*
 *        Local Typedef Declarations
*/


/*
 *        Global Variable Definitions
*/

HANDLE                RplPushCnfEvtHdl;

BOOL                fRplPushThdExists = FALSE;

/*
 *        Local Variable Definitions
*/



/*
 *        Local Function Prototype Declarations
*/
STATIC
STATUS
HandleAddVersMapReq(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );
STATIC
STATUS
HandleSndEntriesReq(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );


STATIC
VOID
HandleUpdNtf(
#if PRSCONN
        BOOL                          fPrsConn,
#endif
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );

STATIC
VOID
HandleUpdVersNoReq(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );
STATIC
VOID
ExecuteWrkItm(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );


/* prototypes for functions local to this module go here */

STATUS
RplPushInit(
        LPVOID pParam
        )

/*++

Routine Description:

        This function is the start function of the Push Thread.
        The function blocks on an auto-reset event variable until signalled

          When signalled it
                dequeues a work item from from its work queue and executes it

Arguments:
        pParam

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        ERplInit

Side Effects:

Comments:
        None
--*/
{
        HANDLE                         ThdEvtArr[2];
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm;
        DWORD                        ArrInd;
        DWORD                        RetVal;
        BOOL                        fSignaled;


        UNREFERENCED_PARAMETER(pParam);
try {
        //
        // Initialize the thd
        //
        NmsDbThdInit(WINS_E_RPLPUSH);
        DBGMYNAME("Replicator Push Thread\n");

        //
        // We do this at each thread creation to save on STATIC storage.  This
        // way when the thread is not there we don't consume resources.
        //
        ThdEvtArr[0]    = NmsTermEvt;
        ThdEvtArr[1]        = QueRplPushQueHd.EvtHdl;

        while(TRUE)
        {
try {
           /*
            *  Block until signaled or until timer expiry
           */
           WinsMscWaitTimedUntilSignaled(
                                ThdEvtArr,
                                2,
                                &ArrInd,
                                WAIT_TIME_BEFORE_EXITING,
                                &fSignaled
                                );

           //
           // If the wait was interrupted due to a termination signal or
           // if the wait timed out, exit the thread.
           //
           if (!fSignaled || (ArrInd == 0))
           {
                //
                // if the thread has timed out, we need to exit it. Before
                // we do that, we check whether some thread sneaked in
                // a message after the timeout
                //
                if (!fSignaled)
                {
                        PQUE_HD_T        pQueHd = pWinsQueQueHd[QUE_E_RPLPUSH];

                        //
                        // QueGetWrkItm also enters the Push thread's critical
                        // section.  I don't want to write a separate function
                        // or overload the QueGetWrkItem function to avoid
                        // the double entry into the critical section.
                        //
                        EnterCriticalSection(&pQueHd->CrtSec);
                        RetVal                  = QueGetWrkItm(
                                                        QUE_E_RPLPUSH,
                                                        (LPVOID)&pWrkItm
                                                          );
                        //
                        // if we got a request execute it.
                        //
                        if (RetVal != WINS_NO_REQ)
                        {
                                LeaveCriticalSection(&pQueHd->CrtSec);
                                NmsDbOpenTables(WINS_E_RPLPUSH);
                                ExecuteWrkItm(pWrkItm);
                                NmsDbCloseTables();
                        }
                        else
                        {
                                //
                                // set the flag to FALSE so that if a message
                                // comes for this Push thread, it is created.
                                //
                                fRplPushThdExists = FALSE;
                                WinsThdPool.ThdCount--;

                                WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].
                                        fTaken = FALSE;

                                //
                                // Be sure to close the handle, otherwise
                                // the thread object will stay.
                                //
                                CloseHandle(
                                  WinsThdPool.RplThds[WINSTHD_RPL_PUSH_INDEX].
                                                                ThdHdl
                                           );
                                LeaveCriticalSection(&pQueHd->CrtSec);
                                WinsMscTermThd(WINS_SUCCESS,
                                        WINS_DB_SESSION_EXISTS);
                        }
              }
              else  //signaled for termination by the main thread
              {
                        WinsMscTermThd(WINS_SUCCESS,
                                        WINS_DB_SESSION_EXISTS);
              }

           }


           /*
            *loop forever until all work items have been handled
           */
            while(TRUE)
           {
                /*
                 *  dequeue the request from the queue
                */
                RetVal = QueGetWrkItm(
                                        QUE_E_RPLPUSH,
                                        (LPVOID)&pWrkItm
                                     );
                if (RetVal == WINS_NO_REQ)
                {
                        break;
                }


                NmsDbOpenTables(WINS_E_RPLPUSH);
                ExecuteWrkItm(pWrkItm);
                NmsDbCloseTables();

                //
                //  Check for termination here since WINS could be under
                //  stress with a large number of messages in the queue.
                //  We don't want to delay the stop.
                //
                WinsMscChkTermEvt(
#ifdef WINSDBG
                            WINS_E_RPLPUSH,
#endif
                            FALSE
                            );
           }
      } // end of try
      except(EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("Replicator Push thread");
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPUSH_EXC);
        }

    } // end of while
  } // end of try

except (EXCEPTION_EXECUTE_HANDLER) {

        DBGPRINTEXC("Replicator Push thread");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPUSH_ABNORMAL_SHUTDOWN);

        //
        // If NmsDbThdInit comes back with an exception, it is possible
        // that the session has not yet been started.  Passing
        // WINS_DB_SESSION_EXISTS however is ok
        //
        WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
 }
     //
     // We should never get here.
     //
     return(WINS_FAILURE);
}


VOID
ExecuteWrkItm(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:

        The function executes a work item. The work item can either be
        a push notification request from within this WINS (from an NBT thread)
        or a replication request (from a remote WINS)

Arguments:
        pWrkItm - ptr to a work item

Externals Used:
        None


Return Value:

        None

Error Handling:

Called by:
        RplPushInit

Side Effects:

Comments:
        None
--*/

{

        RPLMSGF_MSG_OPCODE_E        PullReqType_e;
#if PRSCONN
        BOOL                        fPrsConn = FALSE;
#endif
        BOOL                        fPushNtf = FALSE;

        //
        // get the opcode
        //
        RplMsgfUfmPullPnrReq(
                                pWrkItm->pMsg,
                                pWrkItm->MsgLen,
                                &PullReqType_e
                            );

        switch(PullReqType_e)
        {

          case(RPLMSGF_E_ADDVERSNO_MAP_REQ):
                HandleAddVersMapReq(pWrkItm);
#ifdef WINSDBG
                NmsCtrs.RplPushCtrs.NoAddVersReq++;
#endif
                break;

          case(RPLMSGF_E_SNDENTRIES_REQ):
                HandleSndEntriesReq(pWrkItm);
#ifdef WINSDBG
                NmsCtrs.RplPushCtrs.NoSndEntReq++;
#endif
                break;
#if PRSCONN
          case(RPLMSGF_E_UPDATE_NTF_PRS):
          case(RPLMSGF_E_UPDATE_NTF_PROP_PRS):
               fPrsConn = TRUE;
#endif
          case(RPLMSGF_E_UPDATE_NTF):
          case(RPLMSGF_E_UPDATE_NTF_PROP):

                fPushNtf = TRUE;
#if PRSCONN
                HandleUpdNtf(fPrsConn, pWrkItm);
#else
                HandleUpdNtf(pWrkItm);
#endif

#ifdef WINSDBG
                NmsCtrs.RplPushCtrs.NoUpdNtfReq++;
#endif
                break;

          case(RPLMSGF_E_UPDVERSNO_REQ):
#ifdef WINSDBG
                NmsCtrs.RplPushCtrs.NoUpdVersReq++;
#endif
                HandleUpdVersNoReq(pWrkItm);
                break;

          default:
#ifdef WINSDBG
                NmsCtrs.RplPushCtrs.NoInvReq++;
#endif
                DBGPRINT1(ERR, "RplPush: ExecuteWrkItm: Invalid Opcode (%d)\n",
                                                PullReqType_e);
                WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                break;
        }

        //
        // If the message is not an update notification,
        // Free the message buffer.  For an update
        // notification, the message is handed to
        // the PULL thread to handle.  Therefore, we should not free it
        // The work items needs to be freed always since we always allocate
        // a new work item when queuing a request.
        //
        if ( !fPushNtf)
        {
                ECommFreeBuff(pWrkItm->pMsg - COMM_HEADER_SIZE);

        }

        //
        // Deallocate the work item
        //
        QueDeallocWrkItm( RplWrkItmHeapHdl,  pWrkItm );

        return;
}


STATUS
HandleAddVersMapReq(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:

        This function handles a "send address - version # " request

Arguments:
        pWrkItm - Work item that carries the request and associated info

Externals Used:
        None


Return Value:

   Success status codes --
   Error status codes  --

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

        LPBYTE                   pRspBuff;
        DWORD                    RspMsgLen;
        PRPL_ADD_VERS_NO_T       pPullAddNVersNo;
        DWORD                    i = 0;
        DWORD                    MaxNoOfOwners;
        PRPL_CONFIG_REC_T        pPnr;
        COMM_ADD_T               WinsAdd;
        BOOL                     fRplPnr = FALSE;
        BOOL                     fExc    = FALSE;
        struct in_addr           InAddr;
        PCOMM_ADD_T              pWinsAdd;
        PNMSDB_WINS_STATE_E      pWinsState_e;
        DWORD                    SizeOfBuff;
        BOOL                     fRspBuffAlloc = FALSE;
#if SUPPORT612WINS > 0
        BOOL                     fIsPnrBeta1Wins;
#endif

        DBGENTER("HandleAddVersMapReq\n");

        //
        // We need to handle this request only if
        // either the WINS that sent this message is one of our
        // pull pnrs or if the fRplOnlyWCnfPnrs in the registry is FALSE
        //

        EnterCriticalSection(&WinsCnfCnfCrtSec);
   try {
        if (WinsCnf.fRplOnlyWCnfPnrs)
        {
              if ((pPnr = WinsCnf.PushInfo.pPushCnfRecs) != NULL)
              {
                 COMM_INIT_ADD_FR_DLG_HDL_M(&WinsAdd, &pWrkItm->DlgHdl);

                 //
                 // Search for the Cnf record for the WINS we want to
                 // send the PUSH notification to/Replicate with.
                 //
                 for (
                                ;
                        (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE)
                                        &&
                                !fRplPnr;
                                // no third expression
                      )
                 {
                      //
                      // Check if this is the one we want
                      //
                      if (pPnr->WinsAdd.Add.IPAdd == WinsAdd.Add.IPAdd)
                      {
                        //
                        // We are done.  Set the fRplPnr flag to TRUE so that
                        // we break out of the loop.
                        //
                        // Note: Don't use break since that would cause
                        // a search for a 'finally' block
                        //
                        fRplPnr = TRUE;
                        continue;        //so that we break out of the loop

                      }

                      //
                      // Get the next record that follows this one sequentially
                      //
                      pPnr = WinsCnfGetNextRplCnfRec(
                                                pPnr,
                                                RPL_E_IN_SEQ   //seq. traversal
                                                   );
                 }
              }
        }
        else
        {
                fRplPnr     = TRUE;
        }
     }
     except(EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("HandleAddVersMapReq");
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_EXC_PULL_TRIG_PROC);
                fExc = TRUE;
        }
        LeaveCriticalSection(&WinsCnfCnfCrtSec);
try {

        if (fRplPnr)
        {

           VERS_NO_T        MinOwnVersNo;
           BOOL             fOwnInited = FALSE;
           DWORD            TotNoOfOwners;

           MaxNoOfOwners = 0;
           WINS_ASSIGN_INT_TO_LI_M(MinOwnVersNo, 1);


           DBGPRINT1(TMP, "HandleAddVersMap: WINS (%x) made an AddVersMap request\n", WinsAdd.Add.IPAdd);
           EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
           TotNoOfOwners = NmsDbNoOfOwners;
           LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
           WinsMscAlloc(sizeof(RPL_ADD_VERS_NO_T) * TotNoOfOwners, &pPullAddNVersNo);

           //
           // If version counter value > 1, we will send it
           //
           EnterCriticalSection(&NmsNmhNamRegCrtSec);
           if (LiGtr(NmsNmhMyMaxVersNo, MinOwnVersNo))
           {
              /*
              *  Get the max. version no for entries owned by self
              *
              *  The reason we subtract 1 from NmsNmhMyMaxVersNo is because
              *  it contains the version number to be given to the next record
              *  to be registered/updated.
              */
              NMSNMH_DEC_VERS_NO_M(
                             NmsNmhMyMaxVersNo,
                             pPullAddNVersNo->VersNo
                            );
               pPullAddNVersNo->OwnerWinsAdd = NmsLocalAdd;
               pPullAddNVersNo->StartVersNo  =  NmsDbStartVersNo;

               MaxNoOfOwners++;
               fOwnInited = TRUE;
           }
           LeaveCriticalSection(&NmsNmhNamRegCrtSec);


           //
           //  BUG 26196
           // Note: These critical sections are taken in the order given below
           // by the RPC thread executing GetConfig
           //
           EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
           EnterCriticalSection(&RplVersNoStoreCrtSec);

    try {
           for (i = 1; i < TotNoOfOwners; i++)
           {
                //
                // If the highest version number for an owner as identified
                // by the RplPullOwnerVersNo table is zero, there is no
                // need to send the mapping of this owner.  The reason
                // we may have a such an entry in our in-memory table is
                // because 1)All records of the owner got deleted. Local
                // WINS got terminated and reinvoked. On reinvocation, it
                // did not find any records in the db.
                //           2)Local WINS received a Pull range
                //             request for an owner that it did not know about.
                //             Since Pull Range request comes in as a
                //             "SndEntries" request, the Push thread has
                //             no way of distinguishing it from a normal
                //             2 message pull request.  For a 2 message
                //             request, "SndEntries" request will always
                //             have a subset of the WINS servers that
                //             have records in our db.
                //
                if (LiGtrZero((pRplPullOwnerVersNo+i)->VersNo) &&
                     (pNmsDbOwnAddTbl+i)->WinsState_e == NMSDB_E_WINS_ACTIVE)
                {
                   PVERS_NO_T    pStartVersNo;
                   (pPullAddNVersNo+MaxNoOfOwners)->VersNo = (pRplPullOwnerVersNo+i)->VersNo;
                   //
                   // Note:  Since RplPullOwnerVersNo[i] is > 0, the
                   // State of the entry can not be deleted (see
                   // RplPullPullEntrie)
                   //
                   RPL_FIND_ADD_BY_OWNER_ID_M(i, pWinsAdd, pWinsState_e,
                                        pStartVersNo);
                   (pPullAddNVersNo+MaxNoOfOwners)->OwnerWinsAdd  = *pWinsAdd;
                   (pPullAddNVersNo+MaxNoOfOwners++)->StartVersNo = *pStartVersNo;
                   DBGPRINT3(RPLPUSH, "HandleAddVersMap:Owner Add (%x) - Vers. No (%d %d)\n", pWinsAdd->Add.IPAdd, (pRplPullOwnerVersNo+i)->VersNo.HighPart, (pRplPullOwnerVersNo+i)->VersNo.LowPart);
                }
PERF("Speed it up by using pointer arithmetic")
           }
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
       DBGPRINTEXC("HandleAddVersMapReq");
       DBGPRINT1(EXC, "HandleAddVersMapReq: Exc. while checking vers. nos of owners\n", GetExceptionCode());
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_EXC_PULL_TRIG_PROC);
     }

           //
           // Let us initialize RplPullOwnerVersNo entry for the local WINS
           //
           //  This is done so that if we later on pull from the remote WINS,
           //  we don't end up pulling our own records
           //

           if (fOwnInited)
           {
              pRplPullOwnerVersNo->VersNo      =   pPullAddNVersNo->VersNo;
              pRplPullOwnerVersNo->StartVersNo =  pPullAddNVersNo->StartVersNo;
              DBGPRINT3(RPLPUSH, "HandleAddVersMap: Owner Add (%x) - Vers. No (%d %d)\n", NmsLocalAdd.Add.IPAdd, (pRplPullOwnerVersNo+i)->VersNo.HighPart, (pRplPullOwnerVersNo+i)->VersNo.LowPart);
           }

           LeaveCriticalSection(&RplVersNoStoreCrtSec);
           LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);

#if SUPPORT612WINS > 0
        COMM_IS_PNR_BETA1_WINS_M(&pWrkItm->DlgHdl, fIsPnrBeta1Wins);
#endif

           SizeOfBuff = RPLMSGF_ADDVERSMAP_RSP_SIZE_M(MaxNoOfOwners);
           WinsMscAlloc(SizeOfBuff, &pRspBuff);
           fRspBuffAlloc = TRUE;
           /*
            * format the response
           */
           RplMsgfFrmAddVersMapRsp(
#if SUPPORT612WINS > 0
                        fIsPnrBeta1Wins,
#endif
                        RPLMSGF_E_ADDVERSNO_MAP_RSP,
                        pRspBuff + COMM_N_TCP_HDR_SZ,
                        SizeOfBuff - COMM_N_TCP_HDR_SZ,
                        pPullAddNVersNo,
                        MaxNoOfOwners,
                        0,
                        &RspMsgLen
                           );

           //
           // Free the memory we allocated earlier
           //
           WinsMscDealloc(pPullAddNVersNo);

           /*
            * Send the response.  We don't check the return code.  ECommSndRsp
            * may have failed due to communication failure.  There is nothing
            * more to be done for either the success of failure case.
           */
           (VOID)ECommSndRsp(
                        &pWrkItm->DlgHdl,
                        pRspBuff + COMM_N_TCP_HDR_SZ,
                        RspMsgLen
                   );

           //
           // We don't end the dialogue.  It will get terminated when
           // the initiator terminates it.
           //
        }
        else
        {
                if (!fExc)
                {
                  COMM_INIT_ADD_FR_DLG_HDL_M(&WinsAdd, &pWrkItm->DlgHdl);
                  DBGPRINT1(RPLPUSH, "HandleAddVersMapReq: Got a pull request message from a WINS to which we are not allowed to push replicas. Address of WINS is (%x)\n",
                   WinsAdd.Add.IPAdd
                        );
                   COMM_HOST_TO_NET_L_M(WinsAdd.Add.IPAdd,InAddr.s_addr);

                   WinsMscLogEvtStrs(COMM_NETFORM_TO_ASCII_M(&InAddr),
                                     WINS_EVT_ADD_VERS_MAP_REQ_NOT_ACCEPTED,
                                     TRUE);

                }

                //
                // We need to end the dialogue.  The work item and the message
                // will get deallocated by the caller
                //

                //
                // End the implicit dialogue
                //
                (VOID)ECommEndDlg(&pWrkItm->DlgHdl);
        }

   }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("HandleAddVersMapReq");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPUSH_EXC);
        }
        if (fRspBuffAlloc)
        {
           WinsMscDealloc(pRspBuff);
        }
        DBGLEAVE("HandleAddVersMapReq\n")
        return(WINS_SUCCESS);
}


STATUS
HandleSndEntriesReq(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:

        This function handles the "send data entries req"

Arguments:
        pWrkItm - Work item carrying info about the "Send Entries" request from
                  a remote WINS

Externals Used:
        None


Return Value:

   Success status codes --  WINS_SUCCESS
   Error status codes   --  WINS_FAILURE

Error Handling:

Called by:

        RplPushInit()

Side Effects:

Comments:
        None
--*/
{

        COMM_ADD_T             WinsAdd;          /*address of WINS server whose records
                                         *are being requested*/
        VERS_NO_T             MaxVers, MinVers; /*max. amd min. versions of
                                                *records*/
FUTURES("use NMSDB_ROW_INFO_T structure - Maybe")
        PRPL_REC_ENTRY_T     pBuff;
        LPBYTE               pStartBuff = NULL;
        DWORD                RspBufLen;
        DWORD                NoOfRecs = 0;
        DWORD                i;
        LPBYTE               pNewPos;
        LPBYTE               pTxBuff;
        LPBYTE               pStartTxBuff;
        STATUS               RetStat;
        PWINSTHD_TLS_T       pTls;
        PRPL_CONFIG_REC_T    pPnr;
        BOOL                 fOnlyDynRecs = FALSE;
        DWORD                RplType = WINSCNF_RPL_DEFAULT_TYPE;
        DWORD                RplTypeFMsg;
        BYTE                 Name[1];   //dummy to prevent RtlCopyMemory from
                                        //barfing
       COMM_ADD_T ReqWinsAdd;
#if SUPPORT612WINS > 0
    BOOL        fIsPnrBeta1Wins;
#endif

        DBGENTER("HandleSndEntriesReq\n");
        GET_TLS_M(pTls);
        pTls->HeapHdl = NULL;
//#ifdef WINSDBG
try {
//#endif
        //
        // Check if this is one of our configured partners. If yes,
        // pass the value of fOnlyDynRecs to NmsDbGetDataRecs.
        //
        // We allow access to even those WINSs that are not partners since
        // we need to let them do revalidation of replicas (except for
        // this replication activity, all other from non-configured partners
        // is stopped at the first step - HandleAddVersMapReq).
        //
        if ((pPnr = RplGetConfigRec(RPL_E_PUSH, &pWrkItm->DlgHdl, NULL)) != NULL)
        {
                 fOnlyDynRecs = pPnr->fOnlyDynRecs;
                 RplType      = pPnr->RplType;
        }
        else
        {
            // if this is not one of our replication partners, get the
            // generic (default) "OnlyDynRecs"
            EnterCriticalSection(&WinsCnfCnfCrtSec);
            fOnlyDynRecs = WinsCnf.PushInfo.fOnlyDynRecs;
            LeaveCriticalSection(&WinsCnfCnfCrtSec);
        }

#if SUPPORT612WINS > 0
        COMM_IS_PNR_BETA1_WINS_M(&pWrkItm->DlgHdl, fIsPnrBeta1Wins);
#endif
         /*
        *  Unformat the request message
        */
        RplMsgfUfmSndEntriesReq(
#if SUPPORT612WINS > 0
            fIsPnrBeta1Wins,
#endif
                                pWrkItm->pMsg + 4, /*past the
                                                    *opcode  */
                                 &WinsAdd,
                                &MaxVers,
                                &MinVers,
                                &RplTypeFMsg
                            );
//        ASSERTMSG("Min. Vers. No is >= Max. Vers. No", LiGeq(MaxVers, MinVers));

FUTURES("Check if the request is a PULL RANGE request.  If it is, honor it")
FUTURES("only if the Requesting WINS is under the PUSH key or RplOnlyWCnfPnrs")
FUTURES("is set to 0")

       COMM_INIT_ADD_FR_DLG_HDL_M(&ReqWinsAdd, &pWrkItm->DlgHdl);

#ifdef WINSDBG
       DBGPRINT2(TMP, "HandleSndEntriesReq: WINS (%x) made a SndEntries request for Owner = (%x) \n", ReqWinsAdd.Add.IPAdd, WinsAdd.Add.IPAdd);
       DBGPRINT4(TMP, "HandleSndEntriesReq: Min Vers No (%d %d); Max Vers No = (%d %d)\n", MinVers.HighPart, MinVers.LowPart, MaxVers.HighPart, MaxVers.LowPart);
#endif
        if (RplType == WINSCNF_RPL_DEFAULT_TYPE)
        {
               DBGPRINT2(RPLPUSH, "HandleSndEntriesReq: Pnr (%x) is requesting replication of type (%x)\n", ReqWinsAdd.Add.IPAdd, RplTypeFMsg);
//               WINSEVT_LOG_INFO_M(ReqWinsAdd.Add.IPAdd, WINS_EVT_PNR_PARTIAL_RPL_TYPE);
               RplType = RplTypeFMsg;
        }

        // make sure any previous thread heap is cleaned up - NmsDbGetDataRecs will
        // create a new heap and allocate memory.
        if (pTls->HeapHdl != NULL)
        {
            // destroying the heap deletes all the memory allocated in it
            WinsMscHeapDestroy(pTls->HeapHdl);
            pTls->HeapHdl = NULL;
        }

        /*
        *
        * Call database manager function to get the records. No need
        * to check the return status here
        */
        (VOID)NmsDbGetDataRecs(
                          WINS_E_RPLPUSH,
                          THREAD_PRIORITY_NORMAL, //not looked at
                          MinVers,
                          MaxVers,
                          0,                //not of use here
                          LiEqlZero(MaxVers) ? TRUE : FALSE, //if max. vers.
                                                               //no. is zero,
                                                               //we want all
                                                               //recs.
                          FALSE,        //not looked at in this call
                          NULL,                //must be NULL since we are not
                                        //doing scavenging of clutter
                          &WinsAdd,
                          fOnlyDynRecs,
                          RplType,
                          (LPVOID *)&pStartBuff,
                          &RspBufLen,
                          &NoOfRecs
                        );

        // NmsDbGetDataRecs from above is supposed to have already created the heap!
        ASSERT(pTls->HeapHdl != NULL);
        //
        // Allocate a buffer for transmitting the records.  Even if the
        // above function failed, we still should have received a buffer
        // from it (pStartBuff). Note: RspBufLen contains the size of memory
        // required for a flattened stream of records.
        //
        pStartTxBuff = WinsMscHeapAlloc(pTls->HeapHdl, RspBufLen);
        pTxBuff      = pStartTxBuff + COMM_N_TCP_HDR_SZ;

        pBuff        = (PRPL_REC_ENTRY_T)pStartBuff;

        DBGPRINT4(RPLPUSH, "Formatting 1st record for sending --name (%s)\nfGrp (%d)\nVersNo (%d %d)\n", pBuff->pName/*pBuff->Name*/,
                    pBuff->fGrp,
                    pBuff->VersNo.HighPart,
                    pBuff->VersNo.LowPart
                );

        /*
        * format the response
        *
        *  Note:  It is quite possible that NmsDbGetDataRecs retrieved 0
        *          records.  Even if it did, we are still assured of getting
        *          a buffer of the RPL_CONFIG_REC_SIZE size.  Since at the
        *          time of allocation, memory is 'zero'ed by default, we
        *          won't run into any problems in the following function
        *          call.  Check out this function to reassure yourself.
        *
        *         Like mentioned in NmsDbGetDataRecs, the following call
        *          will serve to format a valid response to the remote WINS
        */
        RplMsgfFrmSndEntriesRsp(
#if SUPPORT612WINS > 0
            fIsPnrBeta1Wins,
#endif
                                pTxBuff,
                                NoOfRecs,
NOTE("expedient HACK - for now. Later on modify FrmSndEntriesRsp ")
                                NoOfRecs ? pBuff->pName : Name,
                                pBuff->NameLen,
                                pBuff->fGrp,
                                pBuff->NoOfAdds,
                                pBuff->NodeAdd,
                                pBuff->Flag,
                                pBuff->VersNo,
                                TRUE,                         /*First time*/
                                &pNewPos
                           );


PERF("Change RplFrmSndEntriesRsp so that it does the looping itself")
          for (i = 1; i < NoOfRecs; i++)
          {

             pBuff = (PRPL_REC_ENTRY_T)((LPBYTE)pBuff + RPL_REC_ENTRY_SIZE);

//             DBGPRINT4(RPLPUSH, "Formatting record for sending --name (%s)\nfGrp (%d)\nVersNo (%d %d)\n", pBuff->pName/*pBuff->Name*/, pBuff->fGrp, pBuff->VersNo.HighPart, pBuff->VersNo.LowPart);

             /*
             *  Format the response
             */
             RplMsgfFrmSndEntriesRsp(
#if SUPPORT612WINS > 0
            fIsPnrBeta1Wins,
#endif
                                pNewPos,
                                NoOfRecs,                //not used by func
                                pBuff->pName,
                                pBuff->NameLen,
                                pBuff->fGrp,
                                pBuff->NoOfAdds,
                                pBuff->NodeAdd,
                                pBuff->Flag,
                                pBuff->VersNo,
                                FALSE, /*Not First time*/
                                &pNewPos
                                );


        }

       RspBufLen = (ULONG) (pNewPos - pTxBuff);

       /*
        * Call ECommSndRsp to send the response.
       */
       RetStat = ECommSndRsp(
                    &pWrkItm->DlgHdl,
                    pTxBuff,
                    RspBufLen
                    );

#ifdef WINSDBG
{
//        COMM_IP_ADD_T IPAdd;

        struct in_addr InAdd;
 //       COMM_GET_IPADD_M(&pWrkItm->DlgHdl, &IPAdd);
        InAdd.s_addr = htonl(ReqWinsAdd.Add.IPAdd);

        if (RetStat != WINS_SUCCESS)
        {
                 DBGPRINT2(RPLPUSH, "HandleSndEntriesReq: ERROR: Could not send (%d) records to WINS with address = (%s)\n",
                                NoOfRecs,
                                inet_ntoa(InAdd)
                 );
        }
        else
        {
                 DBGPRINT2(RPLPUSH, "HandleSndEntriesReq: Sent (%d) records to WINS with address = (%s)\n",
                                NoOfRecs,
                                inet_ntoa(InAdd)
                         );
        }
}
#endif

//#ifdef WINSDBG
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("HandleSndEntriesReq");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPUSH_EXC);
      } //end of exception handler
//#endif

        // make sure any previous thread heap is cleaned up before getting out of this call
        if (pTls->HeapHdl != NULL)
        {
            // destroying the heap deletes all the memory allocated in it
            WinsMscHeapDestroy(pTls->HeapHdl);
            pTls->HeapHdl = NULL;
        }

        DBGLEAVE("HandleSndEntriesReq\n");
        return(WINS_SUCCESS);
}


VOID
HandleUpdNtf(
#if PRSCONN
        BOOL                          fPrsConn,
#endif
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:
        This function is called to handle an update notification message
        received from a remote WINS

Arguments:
        fPrsConn - Indicates whether the connection is persistent or not
        pWrkItm - Work Item containing the message and other relevant info

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        RplPushInit()

Side Effects:

Comments:
        None
--*/

{
        PRPL_CONFIG_REC_T        pPnr;
        COMM_ADD_T                WinsAdd;
        BOOL                        fRplPnr = FALSE;
        BOOL                        fExc    = FALSE;
        struct        in_addr                InAddr;
        DWORD         RplType;


        DBGENTER("HandleUpdNtf - PUSH thread\n");

        //
        // We need to forward this request to the PULL thread only if
        // either the WINS that sent this notification is one of our
        // push pnrs or if the fRplOnlyWCnfPnrs in the registry is FALSE
        //
FUTURES("user RplGetConfigRec instead of the following code")

        EnterCriticalSection(&WinsCnfCnfCrtSec);
   try {
        if (WinsCnf.fRplOnlyWCnfPnrs)
        {
              if ((pPnr = WinsCnf.PullInfo.pPullCnfRecs) != NULL)
              {
                 COMM_INIT_ADD_FR_DLG_HDL_M(&WinsAdd, &pWrkItm->DlgHdl);

                 //
                 // Search for the Cnf record for the WINS we want to
                 // send the PUSH notification to/Replicate with.
                 //
                 for (
                                ;
                        (pPnr->WinsAdd.Add.IPAdd != INADDR_NONE)
                                        &&
                                !fRplPnr;
                                // no third expression
                      )
                 {
                      //
                      // Check if this is the one we want
                      //
                      if (pPnr->WinsAdd.Add.IPAdd == WinsAdd.Add.IPAdd)
                      {
                        //
                        // We are done.  Set the fRplPnr flag to TRUE so that
                        // we break out of the loop.
                        //
                        // Note: Don't use break since that would cause
                        // a search for a 'finally' block
                        //
                        fRplPnr = TRUE;
                        RplType = pPnr->RplType;
                        continue;        //so that we break out of the loop

                      }

                      //
                      // Get the next record that follows this one sequentially
                      //
                      pPnr = WinsCnfGetNextRplCnfRec(
                                                pPnr,
                                                RPL_E_IN_SEQ   //seq. traversal
                                                   );
                 }
              }
        }
        else
        {
                fRplPnr     = TRUE;
                RplType     = WinsCnf.PullInfo.RplType;
        }
     }
     except(EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("HandleUpdNtf");
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_EXC_PUSH_TRIG_PROC);
                fExc = TRUE;
        }
        LeaveCriticalSection(&WinsCnfCnfCrtSec);
#ifdef WINSDBG
try {
#endif
        if (fRplPnr)
        {
            //
            // Inform the TCP listener thread that it should stop
            // monitoring the dialogue since we are handing it over to
            // the PULL thread
            //
#if PRSCONN
            if (!fPrsConn)
#endif
            {
              if (!ECommProcessDlg(&pWrkItm->DlgHdl, COMM_E_NTF_STOP_MON))
              {

                //
                // Free the buffer
                //
                ECommFreeBuff(pWrkItm->pMsg - COMM_HEADER_SIZE);
                DBGPRINT0(ERR, "HandleUpdNtf - PUSH thread. No Upd Ntf could be sent.  It could be because the link went down\n");
                return;
              }
              else
              {
                     COMM_INIT_ADD_FR_DLG_HDL_M(&WinsAdd, &pWrkItm->DlgHdl);
                     COMM_HOST_TO_NET_L_M(WinsAdd.Add.IPAdd,InAddr.s_addr);

                     WinsMscLogEvtStrs(COMM_NETFORM_TO_ASCII_M(&InAddr),
                                     WINS_EVT_UPD_NTF_ACCEPTED, TRUE);
              }
            }

            //
            // Forward the request to the Pull thread
            //
            ERplInsertQue(
                WINS_E_RPLPUSH,
                QUE_E_CMD_HDL_PUSH_NTF,
                &pWrkItm->DlgHdl,
                pWrkItm->pMsg,                //msg containing the push ntf
                pWrkItm->MsgLen,        //msg length
                ULongToPtr(RplType),    //context to pass
                0                       //no magic no
                     );

           //
           // The Pull thread will now terminate the dlg
           //
        }
        else  //we need to reject this trigger
        {
                if (!fExc)
                {
                   COMM_INIT_ADD_FR_DLG_HDL_M(&WinsAdd, &pWrkItm->DlgHdl);
                   DBGPRINT1(RPLPUSH, "HandleUpdNtf: Got a push trigger from a WINS with which we are not allowed to pull replicas. Address of WINS is (%d)\n",
                   WinsAdd.Add.IPAdd
                        );

                   COMM_HOST_TO_NET_L_M(WinsAdd.Add.IPAdd,InAddr.s_addr);

                   WinsMscLogEvtStrs(COMM_NETFORM_TO_ASCII_M(&InAddr),
                                     WINS_EVT_UPD_NTF_NOT_ACCEPTED, TRUE);
                }

                //
                // We need to first deallocate the message and then end the
                // dialogue.  The work item will get deallocated by the caller
                //

                //
                // Free the buffer
                //
                ECommFreeBuff(pWrkItm->pMsg - COMM_HEADER_SIZE);

                //
                // End the implicit dialogue
                //
                (VOID)ECommEndDlg(&pWrkItm->DlgHdl);
        }

#ifdef WINSDBG
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("HandleUpdNtf");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPUSH_EXC);
        }
#endif

        DBGLEAVE("HandleUpdNtf - PUSH thread\n");
        return;
}

VOID
HandleUpdVersNoReq(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:
        This function is called to handle an update version number
        request received from a remote WINS

        This message is sent by a remote WINS as a result of a clash
        during replication.

Arguments:
        pWrkItm - work item

Externals Used:
        None

Return Value:

        None

Error Handling:

Called by:
        RplPushInit()

Side Effects:

Comments:
        None
--*/

{
        BYTE                Name[NMSDB_MAX_NAM_LEN];
        DWORD                NameLen;
        BYTE                Rcode;
        DWORD                RspBuffLen;
        BYTE                RspBuff[RPLMSGF_UPDVERSNO_RSP_SIZE];
        COMM_ADD_T      WinsAdd;
        struct in_addr  InAddr;

        DBGENTER("HandleUpdVerdNoReq\n");

#ifdef WINSDBG
try {
#endif
        //
        // log an event
        //
        COMM_GET_IPADD_M(&pWrkItm->DlgHdl, &WinsAdd.Add.IPAdd);
        COMM_HOST_TO_NET_L_M(WinsAdd.Add.IPAdd,InAddr.s_addr);
        WinsMscLogEvtStrs(COMM_NETFORM_TO_ASCII_M(&InAddr), WINS_EVT_REM_WINS_INF, TRUE);

        /*
        *  Unformat the request message
        */
        RplMsgfUfmUpdVersNoReq(
                                pWrkItm->pMsg + 4, /*past the
                                                    *opcode  */
                                Name,
                                &NameLen
                                );

        //
        // handle the request
        //
        NmsNmhUpdVersNo( Name, NameLen, &Rcode, &WinsAdd );


        //
        //Format the response
        //
        RplMsgfFrmUpdVersNoRsp(
                        RspBuff + COMM_N_TCP_HDR_SZ,
                        Rcode,
                        &RspBuffLen
                              );

        //
        // Send the response. No need to check the return code.
        //
        (VOID)ECommSndRsp(
                        &pWrkItm->DlgHdl,
                        RspBuff + COMM_N_TCP_HDR_SZ,
                        RspBuffLen
                   );

        //
        // No need to end the dialogue.  The initiator of the dlg will end it.
        //
#ifdef WINSDBG
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("HandleUpdVersNoReq");
        WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPUSH_EXC);
        }
#endif

        DBGLEAVE("HandleUpdVerdNoReq\n");
        return;

} // HandleUpdVersNoReq()



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wins\server\rpl\rplpull.c ===
/*++
Copyright (c) 1990  Microsoft Corporation

Module Name:
        Rplpull.c

Abstract:

        This module implements the pull functionality of the WINS replicator

Functions:

        GetReplicasNew
        GetVersNo
        RplPullPullEntries
        SubmitTimerReqs
        SubmitTimer
        SndPushNtf
        HdlPushNtf
        EstablishComm
        RegGrpRpl
        IsTimeoutToBeIgnored
        InitRplProcess
        Reconfig
        RplPullInit
        RplPullRegRepl

Portability:

        This module is portable

Author:

        Pradeep Bahl (PradeepB)          Jan-1993

Revision History:

        Modification date        Person                Description of modification
        -----------------        -------                ----------------------------
--*/

/*
 *       Includes
*/
#include <time.h>
#include <stdlib.h>
#include <search.h>
#include "wins.h"
#include <winsock2.h>
#include "comm.h"
#include "assoc.h"
#include "winsque.h"
#include "rpl.h"
#include "rplpull.h"
#include "rplpush.h"
#include "rplmsgf.h"
#include "nms.h"
#include "nmsnmh.h"
#include "nmsdb.h"
#include "winsmsc.h"
#include "winsevt.h"
#include "winscnf.h"
#include "winstmm.h"
#include "winsintf.h"

/*
 *        Local Macro Declarations
*/
//
// defines to use for retrying communication with a remote WINS on a
// communication failure exception (when trying to establish a connection).
//
// The retries are done before moving on in the list to the next WINS
// (if one is there).  When MAX_RETRIES_TO_BE_DONE retries have been done,
// we do not retry again until the next replication cycle at which
// time the whole process is repeated).
//
// The number of replication cycles this process of retries is to be
// continued is a registry parameter
//

//
// NOTE:
// Since TCP/IP's retry strategy has been improved (more retries than before)
// and made a registry parameter, we now probably don't need to do the retries
//
#define  MAX_RETRIES_TO_BE_DONE                (0)        //0 for testing only


//
// Time to wait before flushing for the Rpl Pull thread
//
#define FLUSH_TIME                (2000)        //2 secs

//
// Note: Don't make the retry time interval  too large since communications
//       with Remote WINS servers is established in sequence.   20 secs
//       is not bad.
//
#define  RETRY_TIME_INTVL                (20000)    //in millisecs

#define FIVE_MINUTES       300
/*
 *        Local Typedef Declarations
*/

/*
 *        Global Variable Definitions
 */

HANDLE    RplPullCnfEvtHdl;        //handle to event signaled by main
                                        //thread when a configuration change
                                        //has to be given to the Pull handler
                                        //thread


BOOL      fRplPullAddDiffInCurrRplCycle; //indicates whether the address
                                              //of any entry in this WINS's db
                                              //changed as a result of
                                              //replication

#if 0
BOOL      fRplPullTriggeredWins;   //indicates that during the current
                                         //replication cycle, one or more
                                         //WINS's were triggered.  This
                                         //when TRUE, then if the above
                                         //"AddDiff.." flag is TRUE, it means
                                         //that the PULL thread should trigger
                                        //all PULL Pnrs that have an INVALID
                                        //metric in their UpdateCount field
                                        //(of the RPL_CONFIG_T struct)

BOOL     fRplPullTrigger;        //Indication to the PULL thread to
                                        //trigger Pull pnrs since one or more
                                        //address changed.  fRplPullTriggerWins
                                        //has got be FALSE when this is true
#endif

BOOL     fRplPullContinueSent = FALSE;

//
//  This array is indexed by the owner id. of an RQ server that has entries in
//  our database.  Each owner's max. version number is stored in this array
//

PRPL_VERS_NOS_T pRplPullOwnerVersNo;
DWORD           RplPullMaxNoOfWins = RPL_MAX_OWNERS_INITIALLY;

DWORD           RplPullCnfMagicNo;    //stores the id. of the current WinsCnf
                                      //structure that the Pull thread
                                      // is operating with


/*
 *        Local Variable Definitions
*/
/*
        pPushPnrVersNoTbl -- Table whose some (or all) entries are
                              initialized at replication time.
*/
/*
 pPushPnrVersNoTbl

  This table stores the Max. version number pertaining to each WINS server
  that owns entries in the local database of Push Partners

  Note: The table is STATIC for now.  We might change it to be a dynamic one
        later.

  The first dimension indicates the Push Pnr.  The second dimension indicates
  the owner WINS that has records in the Push Pnr's local db
*/
STATIC PRPL_VERS_NOS_T  pPushPnrVersNoTbl;


//
// Var. that stores the handles to the timer requests that have been
// submitted
//
STATIC WINSTMM_TIMER_REQ_ACCT_T   SetTimeReqs;


STATIC BOOL        sfPulled = FALSE;//indicates whether the PULL thread pulled
                                  //anything from a WINS.  Set by PullEntries.
                                //Looked at by HdlPushNtf

/*
 *        Local Function Prototype Declarations
*/
STATIC
VOID
GetReplicasNew(
        IN PRPL_CONFIG_REC_T        pPullCnfRecs,
        IN RPL_REC_TRAVERSAL_E      RecTrv_e      //indicates how we have to
                                              //interpret the above list
        );

VOID
ConductChkNew(
    PPUSHPNR_DATA_T pPushPnrData,
    VERS_NO_T       vnMaxLocal,
    VERS_NO_T       vnMaxRemote);

STATIC
VOID
GetVersNo(
        PPUSHPNR_DATA_T        pPushPnrData  //info about Push Pnr
        );

STATIC
VOID
SubmitTimerReqs(
        IN  PRPL_CONFIG_REC_T        pPullCnfRecs
        );
STATIC
VOID
SubmitTimer(
        LPVOID                        pWrkItm,
        IN  PRPL_CONFIG_REC_T        pPullCnfRec,
        BOOL                        fResubmit
        );


STATIC
VOID
SndPushNtf(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );

STATIC
VOID
HdlPushNtf(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        );

STATIC
VOID
EstablishComm(
        IN  PRPL_CONFIG_REC_T     pPullCnfRecs,
        IN  BOOL                  fAllocPushPnrData,
        IN  PPUSHPNR_DATA_T       *ppPushPnrData,
        IN  RPL_REC_TRAVERSAL_E   RecTrv_e,
        OUT LPDWORD               pNoOfPushPnrs
        );


STATIC
STATUS
RegGrpRepl(
        LPBYTE               pName,
        DWORD                NameLen,
        DWORD                Flag,
        DWORD                OwnerId,
        VERS_NO_T            VersNo,
        DWORD                NoOfAdds,
        PCOMM_ADD_T        pNodeAdd,
        PCOMM_ADD_T        pOwnerWinsAdd
        );

STATIC
BOOL
IsTimeoutToBeIgnored(
        PQUE_TMM_REQ_WRK_ITM_T  pWrkItm
        );
STATIC
VOID
InitRplProcess(
        PWINSCNF_CNF_T        pWinsCnf
 );

STATIC
VOID
Reconfig(
        PWINSCNF_CNF_T        pWinsCnf
  );

VOID
AddressChangeNotification(
        PWINSCNF_CNF_T        pWinsCnf
  );

STATIC
VOID
PullSpecifiedRange(
        PCOMM_HDL_T                     pDlgHdl,
        PWINSINTF_PULL_RANGE_INFO_T     pPullRangeInfo,
        BOOL                            fAdjMinVersNo,
        DWORD                           RplType

        );

STATIC
VOID
DeleteWins(
        PCOMM_ADD_T        pWinsAdd
  );

BOOL
AcceptPersona(
  PCOMM_ADD_T  pWinsAdd
 );

VOID
FilterPersona(
  PPUSHPNR_DATA_T   pPushData
 );

//
// Function definitions
//

DWORD
RplPullInit (
        LPVOID pWinsCnfArg
        )

/*++

Routine Description:
        This is the initialization (startup function) of the PULL thread.
        It does the following:

Arguments:
        pWinsCnfArg - Address of the WINS configuration block

Externals Used:
        None


Return Value:

   Success status codes -- WINS_SUCCESS
   Error status codes   -- WINS_FAILURE

Error Handling:

Called by:
        ERplInit

Side Effects:

Comments:
        None
--*/

{


        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm;
        HANDLE                        ThdEvtArr[3];
        DWORD                        ArrInd;
        DWORD                        RetVal;
        BOOL                        fIsTimerWrkItm;               //indicates whether
                                                       //it is a timer wrk
                                                       //item
        PWINSCNF_CNF_T                pWinsCnf      = pWinsCnfArg;
        PRPL_CONFIG_REC_T        paPullCnfRecs = pWinsCnf->PullInfo.pPullCnfRecs;
        PRPL_CONFIG_REC_T        paCnfRec = paPullCnfRecs;

        SYSTEMTIME                LocalTime;
        BOOL                      bRecoverable = FALSE;

while(TRUE)
{
try
 {

    if (!bRecoverable)
    {
        //
        // Initialize self with the db engine
        //
        NmsDbThdInit(WINS_E_RPLPULL);
        NmsDbOpenTables(WINS_E_RPLPULL);
        DBGMYNAME("Replicator Pull Thread");

        //
        // Create the  event handle to wait for configuration changes.  This
        // event is signaled by the main thread when it needs to reinit
        // the Pull handler component of the Replicator
        //
        WinsMscCreateEvt(
                          RPL_PULL_CNF_EVT_NM,
                          FALSE,                //auto-reset
                          &RplPullCnfEvtHdl
                        );

        ThdEvtArr[0]    = NmsTermEvt;
        ThdEvtArr[1]        = QueRplPullQueHd.EvtHdl;
        ThdEvtArr[2]    = RplPullCnfEvtHdl;

        //
        // If logging is turned on, specify the wait time for flushing
        // NOTE: We override the wait time we specified for all sessions
        // for this thread because that wait time is too less (100 msecs) and
        // will cause unnecessary overhead.
        //
        if (WinsCnf.fLoggingOn)
        {
                //
                // Set flush time to 2 secs.
                //
                NmsDbSetFlushTime(FLUSH_TIME);
        }

        /*
                Loop forever doing the following:

                Pull replicas from the Pull Partners specified in the
                work item.

                Block on the event until signalled (it will get signalled
                  if one of the following happens:
                        1)the configuration changes
                        2)the timer for another replication expires
                        3)WINS is terminating

                do the needful
       */


        //
        // Wait until signaled by the TCP thd. Will be signaled after
        // the TCP listener thread has inserted an entry for the WINS
        // in the NmsDbOwnAddTbl
        //
        WinsMscWaitInfinite( RplSyncWTcpThdEvtHdl );


        //
        // Do startup replication only if there is atleast one PUSH pnr
        //
        if (paPullCnfRecs != NULL)
        {
try {
                InitRplProcess(pWinsCnf);
    }
except(EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("RplPullInit");
                DBGPRINT0(EXC, "RplPullInit: Exception during init time replication\n");
    }
        }

        NmsDbCloseTables();

        bRecoverable = TRUE;

    } // end if (!bRecoverable)

        while(TRUE)
        {
           /*
            *  Block until signalled
           */
           WinsMscWaitUntilSignaled(
                                ThdEvtArr,
                                3,
                                &ArrInd,
                                FALSE
                                );

           if (ArrInd == 0)
           {
                //WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_ORDERLY_SHUTDOWN);
                WinsMscTermThd(WINS_SUCCESS, WINS_DB_SESSION_EXISTS);
           }

           /*
            * loop forever until all work items have been handled
           */
            while(TRUE)
           {

                /*
                 *  dequeue the request from the queue
                */
                RetVal = QueGetWrkItm(
                                        QUE_E_RPLPULL,
                                        (LPVOID)&pWrkItm
                                     );
                if (RetVal == WINS_NO_REQ)
                {
                        break;
                }

        WinsMscChkTermEvt(
#ifdef WINSDBG
                       WINS_E_RPLPULL,
#endif
                       FALSE
                        );

                fIsTimerWrkItm = FALSE;

                NmsDbOpenTables(WINS_E_RPLPULL);
                DBGPRINT1(RPLPULL, "RplPullInit: Dequeued a work item. Cmd Type is (%d)\n", pWrkItm->CmdTyp_e);

                switch(pWrkItm->CmdTyp_e)
                {
                    case(QUE_E_CMD_TIMER_EXPIRED):

                               //
                               // We may want to ignore this timeout if it
                               // pertains to a previous configuration
                               //
                               if (
                                     !IsTimeoutToBeIgnored(
                                        (PQUE_TMM_REQ_WRK_ITM_T)pWrkItm
                                                        )
                                  )
                               {
                                  WinsIntfSetTime(
                                                &LocalTime,
                                                WINSINTF_E_PLANNED_PULL);
#ifdef WINSDBG
                                  DBGPRINT5(REPL, "STARTING A REPLICATION CYCLE on %d/%d at %d.%d.%d (hr.mts.sec)\n",
                                        LocalTime.wMonth,
                                        LocalTime.wDay,
                                        LocalTime.wHour,
                                        LocalTime.wMinute,
                                        LocalTime.wSecond);
                                  DBGPRINT5(RPLPULL, "STARTING A REPLICATION CYCLE on %d/%d at %d.%d.%d (hr.mts.sec)\n",
                                        LocalTime.wMonth,
                                        LocalTime.wDay,
                                        LocalTime.wHour,
                                        LocalTime.wMinute,
                                        LocalTime.wSecond);
#endif
                                         GetReplicasNew(
                                     ((PQUE_TMM_REQ_WRK_ITM_T)pWrkItm)->
                                                                pClientCtx,
                                      RPL_E_VIA_LINK //use the pNext field to
                                                     //get to the next record
                                      );

                                  DBGPRINT0(RPLPULL, "REPLICATION CYCLE END\n");

                                  /*Resubmit the timer request*/
                                  SubmitTimer(
                                        pWrkItm,
                                        ((PQUE_TMM_REQ_WRK_ITM_T)pWrkItm)
                                                                ->pClientCtx,
                                        TRUE        //it is a resubmission
                                        );
                               }

                               //
                               // Set the flag so that we do not free
                               // the work item.  It was resubmitted
                               //
                               fIsTimerWrkItm = TRUE;
                               break;

                    //
                    // Pull in replicas
                    //
                    case(QUE_E_CMD_REPLICATE):

                            //
                            // Make sure that we are not using old info
                            //
                            if ((pWrkItm->MagicNo == RplPullCnfMagicNo) ||
                                ((pWrkItm->MagicNo == 0 ) && ((PRPL_CONFIG_REC_T)(pWrkItm->pClientCtx))->fTemp))
                            {
                               WinsIntfSetTime(
                                                &LocalTime,
                                                WINSINTF_E_ADMIN_TRIG_PULL);
                               GetReplicasNew( pWrkItm->pClientCtx,
                                            RPL_E_NO_TRAVERSAL );
                                if (
                                       ((PRPL_CONFIG_REC_T)
                                                (pWrkItm->pClientCtx))->fTemp
                                   )
                                {
                                        WinsMscDealloc(pWrkItm->pClientCtx);
                                }
                            }
                            else
                            {
                               DBGPRINT0(ERR, "RplPullInit: Can not honor this request since the configuration under the PARTNERS key may have changed\n");
                               WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_CNF_CHANGE);
                            }
                            break;

                    //
                    // Pull range of records
                    //
                    case(QUE_E_CMD_PULL_RANGE):

                            //
                            // Make sure that we are not using old info
                            //
                            if ((pWrkItm->MagicNo == RplPullCnfMagicNo)  ||
                                (pWrkItm->MagicNo == 0 &&
                                ((PRPL_CONFIG_REC_T)((PWINSINTF_PULL_RANGE_INFO_T)(pWrkItm->pClientCtx))->pPnr)->fTemp))
                            {
                                //
                                // Pull the specified range.  If the Pnr
                                // record is temp, this function will
                                // deallocate it.
                                //
                                PullSpecifiedRange(NULL, pWrkItm->pClientCtx, FALSE,
                                ((PRPL_CONFIG_REC_T)(((PWINSINTF_PULL_RANGE_INFO_T)(pWrkItm->pClientCtx))->pPnr))->RplType);

                                //
                                // Deallocate the client ctx
                                //
                                WinsMscDealloc(pWrkItm->pClientCtx);
                            }
                            else
                            {
                               DBGPRINT0(ERR, "RplPullInit: Can not honor this request since the configuration under the PARTNERS key may have changed\n");
                               WINSEVT_LOG_INFO_M(WINS_SUCCESS, WINS_EVT_CNF_CHANGE);
                            }
                            break;

                    //
                    //reconfigure
                    //
                    case(QUE_E_CMD_CONFIG):
                        Reconfig(pWrkItm->pClientCtx);
                        break;

                    //
                    // Delete WINS from the Owner Add table (delete records
                    // also
                    //
                    case(QUE_E_CMD_DELETE_WINS):
                        DeleteWins(pWrkItm->pClientCtx);
                        break;

                    //
                    // ip addr of this machine changed, modify the own - addr table
                    case(QUE_E_CMD_ADDR_CHANGE):
                        AddressChangeNotification(pWrkItm->pClientCtx);
                        break;
                    //
                    //Push notification. Local message from an NBT thread,
                    //from an RPC thread (Push Trigger) or from this thread
                    //itself
                    //
                    case(QUE_E_CMD_SND_PUSH_NTF_PROP):
                    case(QUE_E_CMD_SND_PUSH_NTF):

                        //
                        // Make sure that we are not using old info
                        //
                        if ((pWrkItm->MagicNo == RplPullCnfMagicNo)  ||
                            (pWrkItm->MagicNo == 0 &&
                            ((PRPL_CONFIG_REC_T)(pWrkItm->pClientCtx))->fTemp))
                        {

                          SndPushNtf(pWrkItm);
                        }
                        break;

                    //
                    //Push notification from a remote WINS. Forwarded to Pull
                    //thread by the Push thread
                    //
                    case(QUE_E_CMD_HDL_PUSH_NTF):

                          HdlPushNtf(pWrkItm);
                          break;

                    default:

                        DBGPRINT1(ERR,
                          "RplPullInit: Invalid command code = (%d)\n",
                                        pWrkItm->CmdTyp_e);
                        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
                        break;

                }  // end of switch

                NmsDbCloseTables();

                //
                // deallocate the work item only if it is not a timer work item
                // We don't deallocate a timer work item here because of two
                // reasons:
                //
                //   1) it is reused
                //   2) it is allocated from the timer work item heap
                //
                if (!fIsTimerWrkItm)
                {
                        /*
                        *    deallocate the work item
                        */
                        QueDeallocWrkItm( RplWrkItmHeapHdl,  pWrkItm );
                }
            } //while(TRUE) for getting all work items
         } //while (TRUE)
  } // end of try
except(EXCEPTION_EXECUTE_HANDLER)
 {
        if (bRecoverable)
        {
            DBGPRINTEXC("RplPullInit");
            WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPULL_EXC);
        }
        else
        {
            DBGPRINTEXC("RplPullInit");
            WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPULL_ABNORMAL_SHUTDOWN);

            //
            // If NmsDbThdInit comes back with an exception, it is possible
            // that the session has not yet been started.  Passing
            // WINS_DB_SESSION_EXISTS however is ok
            //
            WinsMscTermThd(WINS_FAILURE, WINS_DB_SESSION_EXISTS);
        }
 } // end of except {.. }
} // end of while(TRUE)


     //
     // We never reach here
     //
     ASSERT(0);
     return(WINS_FAILURE);
}

//////////////////////////////////////////////////////////////////////////////////
//------------------- GetReplicasNew() -------------------------------------------
// This call replaces the original GetReplicas() function due to several issues
// hidden in that one.
// ft: 06/06/2000
//
// Parameters:
// 1) pPullCnfRecs: gives the info about the partners where the records are to be pulled
// 2) RecvTrv_e: tells which of the partners from the first parameter should be involved
//    in the replication. This parameter can be either RPL_E_VIA_LINK, RPL_E_NO_TRAVERSAL
//    or RPL_E_IN_SEQ. It is used only at the end of the path:
//    EstablishComm()->WinsCnfGetNextRplCnfRec()
//
VOID
GetReplicasNew (
    IN PRPL_CONFIG_REC_T    pPullCnfRecs,   // info about the (pull) repl partners to use
    IN RPL_REC_TRAVERSAL_E  RecTrv_e        // repl partner retrieval method
    )
{
    // The type & variable naming here is confusing. We are not dealing with push
    // partners, but with pull partners, meaning "partners from which this server
    // is currently pulling records". This is how WINSSNAP & WINSMON are both naming
    // these kind of partners. I preserve though the original type naming (and hence
    // the original variable naming) just to limit the size of the change.
    PPUSHPNR_DATA_T       pPushPnrData;     // info on the connections to the partners
    DWORD                 nPushPnrData;     // number of elements in pPushPnrData
    DWORD                 i, j;             // general use counters

    DBGENTER("GetReplicasNew\n");

    // Establish communications with the Pull Partners
    // For each of the partners in the list, the call below attempts to open a connection
    // to the server (if needed). All the nPushPnrData partners to which the connection 
    // is established successfully are specified in the array (PPUSHPNR_DATA_T)pPushPnrData.
    EstablishComm(
        pPullCnfRecs,   // IN  - info about the replication partners
        TRUE,           // IN  - pPushPnrData should be allocated
        &pPushPnrData,  // OUT - info on the connections to the partners
        RecTrv_e,       // IN  - which of the partners should we connect to
        &nPushPnrData); // OUT - number of elements in pPushPnrData

    // NOTE: regardless the number of partners, pPushPnrData gets allocated so it will
    // be unconditionally deallocated later.
    //
    // --Checkpoint-------------
    // At this point, pPushPnrData[i].PushPnrId == i+1.
    // The link between pPushPnrData[i] and the corresponding RPL_CONFIG_REC_T is done
    // through (RPL_CONFIG_REC_T)pPushPnrData[i].pPullCnfRec
    // -------------------------
    //
    // Contact each of the partners in pPushPnrData and get its OwnerAddr<->VersNo maps.
    // The map of each partner is stored in (PRPL_ADD_VERS_NO)pPushPnrData[i].pAddVers
    // The size of the map is stored in (DWORD)pPushPnrData[i].NoOfMaps
    for (i = 0; i < nPushPnrData; ) // no 3rd part for this "for"
    {
        PPUSHPNR_DATA_T pPnrData = &(pPushPnrData[i]); // get pointer to the current partner

        try 
        {
            GetVersNo(pPnrData);
            i++;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            // an exception was raised inside GetVersNo()
            DWORD ExcCode = GetExceptionCode();

            // dump the error
            DBGPRINT2(
                EXC, "GetReplicasNew->GetVersNo(%x); hit exception = (%x).\n",
                pPnrData->pPullCnfRec->WinsAdd.Add.IPAdd,
                ExcCode);
            // log the error
            WINSEVT_LOG_M(
                ExcCode,
                (ExcCode == WINS_EXC_COMM_FAIL) ?  WINS_EVT_CONN_ABORTED :  WINS_EVT_SFT_ERR);

            // update the replication counters for that partner
            (VOID)InterlockedIncrement(&pPnrData->pPullCnfRec->NoOfCommFails);
            (VOID)InterlockedDecrement(&pPnrData->pPullCnfRec->NoOfRpls);

            // Delete the dialog
            ECommEndDlg(&pPnrData->DlgHdl);

            // If there is a persistent dialog, it has to be marked as 
            // "no longer active"
            if (pPnrData->fPrsConn)
                ECOMM_INIT_DLG_HDL_M(&(pPnrData->pPullCnfRec->PrsDlgHdl));

            // one of the partners could not be contacted, so
            // eliminate it from the pPnrData array
            nPushPnrData--;
            // adjust the array such that the active partners are kept compact
            // the PushPnrId is also changed to keep true the assertion
            // pPushPnrData[i].PushPnrId == i+1;
            if (i != nPushPnrData)
            {
                DWORD origPushPnrId = pPushPnrData[i].PushPnrId;

                // !!! whole PUSHPNR_DATA_T structure is copied here !!!
                pPushPnrData[i] = pPushPnrData[nPushPnrData];
                pPushPnrData[i].PushPnrId = origPushPnrId;
            }
            // since the counter "i" is not incremented, the partner that
            // has just been moved will be the one considered next
            continue;
        }  // end of exception handler
    }  // end of for loop for looping over Push Pnrs

    // --Checkpoint--------------
    // At this point, pPushPnrData contains only the partners for which a connection
    // could be established, nPushPnrData is updated to count only these partners
    // and the pPushPnrData[i].PushPnrId == i+1 still holds.
    // (PRPL_ADD_VERS_NO)pPushPnrData[i].pAddVers gives the map OwnerAddr<->VersNo as
    // known by that replication partner. (DWORD)pPushPnrData[i].NoOfMaps gives the
    // number of entries in the map.
    // --------------------------
    DBGPRINT1(RPLPULL, "GetReplicasNew: Active PushPnrs = (%d)\n", nPushPnrData);

    // do stuff only if there is at least someone to talk to
    if (nPushPnrData > 0)
    {
        // array giving info on what owner should be pulled from what repl partner
        // the array starts with the image of the local OwnerId<->VersNo mapping and
        // grows dynamically for as many new Owners are retrieved in the mappings
        // of the other replication partners.
        PPUSHPNR_TO_PULL_FROM_T pPushPnrToPullFrom;
        DWORD                   nPushPnrToPullFrom; // size of the array
        VERS_NO_T               vnLocalMax;         // maximum local version number

        // depending on the server's state, get the maximum local version number
        //
        // If WINS is "init time paused", RplPullOwnerversNo will
        // have the max. version no. of locally owned records. We
        // can not use NmsNmhMyMaxVersNo since it may have been
        // adjusted to a higher value
        //
        if (fWinsCnfInitStatePaused)
        {
            vnLocalMax =  pRplPullOwnerVersNo[0].StartVersNo;
        }
        else
        {
            EnterCriticalSection(&NmsNmhNamRegCrtSec);
            NMSNMH_DEC_VERS_NO_M(NmsNmhMyMaxVersNo, vnLocalMax) ;
            LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        }

        // Initialize (PPUSHPNR_TO_PULL_FROM_T)pPushPnrToPullFrom. This is copying the local
        // image of the OwnerId<->VersNo mapping. Any entry in this table having pPushPnrData
        // set to NULL means the local server has the highest VersNo for that particular Owner
        nPushPnrToPullFrom = NmsDbNoOfOwners;
        WinsMscAlloc(
            nPushPnrToPullFrom * sizeof(RPL_VERS_NOS_T),
            (LPVOID *)&pPushPnrToPullFrom);

        // make sure no one is messing up with pRplPullOwnerVersNo as we're copying it
        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
        for (i = 0; i < nPushPnrToPullFrom; i++)
        {
            // avoid copying info for old owners that were deleted already from the
            // internal tables (pNmsDbOwnAddTbl & pPushPnrToPullFrom)
            // for those, the entry slot will look like (NULL, 0:0) so they basically
            // won't be taken into account for replication
            if (pNmsDbOwnAddTbl[i].WinsState_e != NMSDB_E_WINS_DELETED)
            {
                pPushPnrToPullFrom[i].pPushPnrData = NULL;
                pPushPnrToPullFrom[i].VersNo = pRplPullOwnerVersNo[i].VersNo;
            }
        }
        // reset the maximum local number to what we got before.
        pPushPnrToPullFrom[0].VersNo = vnLocalMax;
        LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);

        // --Checkpoint--------------
        // At this point, pPushPnrToPullFrom is copying the OwnerId<->VersNo mapping
        // from the local server. Entry at index 0 contains the highest local VersNo,
        // all the others contain each owner's highest VersNo as it is known locally.
        // Each entry has pPushPnrData set to NULL as they don't refer yet to any
        // repl partner info. Later, pPushPnrData will point to the structure corresponding
        // to the repl partner with the highest VersNo for the corresponding owner.
        // --------------------------
    
        // We attempt now to do a merge of all the maps we got from each of the partners.
        // The merge means identifying which partner has the highest VersNo for
        // each of the OwnerAddr. In the same time, some of the OwnerAddr we just got
        // might not be already present in the local OwnerId<->OwnerAddr (pNmsDbOwnAddTbl)
        // and OwnerId<->VersNo (pRplPullOwnerVersNo)tables. So we need to get a new
        // OwnerId for these ones and adjust appropriately the internal tables & the
        // OwnerId<->OwnerAddr db table. This is done through RplFindOwnerId().
        //
        // for each active replication partner ...
        for (i = 0; i < nPushPnrData; i++)
        {
            // get pointer to the current partner's data
            PPUSHPNR_DATA_T pPnrData = &(pPushPnrData[i]); 

            // for each of the replication partner's map entry ...
            for (j = 0; j < pPnrData->NoOfMaps; j++)
            {
                // get the pointer to the current (OwnerAddr<->VersNo) map entry 
                PRPL_ADD_VERS_NO_T pPnrMapEntry = &(pPnrData->pAddVers[j]);
                BOOL               fAllocNew; // true if this is a brand new owner
                DWORD              OwnerId;

                // filter out owners that are not supposed to be accepted
                // (either a persona non-grata or not a persona grata)
                if (!AcceptPersona(&(pPnrMapEntry->OwnerWinsAdd)))
                    continue;

                // Locate or allocate an OwnerId for this owner
                // No need to enter the critical section RplOwnAddTblCrtSec since
                // only the Pull thread changes the NmsDbNoOfOwners value (apart
                // from the main thread at initialization).  RplFindOwnerId changes
                // this value only if it is asked to allocate a new entry)
                // Though NmsDbGetDataRecs (called by Rpc threads, Push thread, and
                // scavenger thread) calls RplFindOwnerId, that call is not asking
                // for new OwnerId allocation.
                fAllocNew = TRUE;
                RplFindOwnerId(
                    &(pPnrMapEntry->OwnerWinsAdd),
                    &fAllocNew,
                    &OwnerId,
                    WINSCNF_E_INITP_IF_NON_EXISTENT,
                    WINSCNF_LOW_PREC);

                if (nPushPnrToPullFrom < (OwnerId+1))
                {
                    // if this is an owner we didn't hear of yet, RplFindOwnerId is enlarging
                    // dynamically the internal tables (pNmsDbOwnAddTbl & pRplPullOwnerVersNo)
                    // so we need to do the same
                    nPushPnrToPullFrom = OwnerId+1;

                    // note: the memory that is added to the array is zero-ed by the call
                    WINSMSC_REALLOC_M( 
                        nPushPnrToPullFrom * sizeof(RPL_VERS_NOS_T),
                        (LPVOID *)&pPushPnrToPullFrom);
                }

                // it is guaranteed now, OwnerId is within the range of the pPushPnrToPullFrom.
                if (fAllocNew)
                {
                    // if a new OwnerId was generated (either new slot into the tables or
                    // an old slot has been reused) this means the partner is coming up with
                    // a new owner: obviously he's the one having the most recent info on
                    // that partner (at least for now)
                    pPushPnrToPullFrom[OwnerId].pPushPnrData = pPnrData;
                    pPushPnrToPullFrom[OwnerId].VersNo = pPnrMapEntry->VersNo;
                }
                else
                {
                    // the owner already exists in the list, so we need to check whether the
                    // info on this owner is not more recent on a different partner (or on this
                    // local server)
                    if ( LiGtr(pPnrMapEntry->VersNo, pPushPnrToPullFrom[OwnerId].VersNo) )
                    {
                        // yes it is, so we need to update the entry in the pPushPndToPullFrom
                        // table such that it points to this partner and shows the new greater
                        // version number.
                        pPushPnrToPullFrom[OwnerId].VersNo       = pPnrMapEntry->VersNo;
                        pPushPnrToPullFrom[OwnerId].pPushPnrData = pPnrData;
                    }
                    // else the info is not the most recent one, so just ignore it.
                } // end checking the OwnerId
            } // end looping through partner's map entries
        } // end looping through the list of partners

        // --Checkpoint--------------
        // At this point pPushPnrToPullFrom contains the union of all the OwnerId<->VersNo mappings
        // from all the partners. Each entry contains the highest VersNo known across all partners
        // for the corresponding owner, and points to the partner that came with this info (or NULL
        // if the highest VersNo was already known locally).
        // --------------------------

        // start pulling each owner from the partner able to provide the most up-to-date information
        // (having the highest version number).
        // start doing so from the entry '1' in the pPushPnrToPullFrom since entry '0' corresponds
        // to the local owner. That one will be handled later
        for (i = 1; i < nPushPnrToPullFrom; i++)
        {
            PPUSHPNR_TO_PULL_FROM_T pPushPartner = &(pPushPnrToPullFrom[i]);
            VERS_NO_T vnToPullFrom;

            // if pPushPnrData member is null this means the local server has the highest version
            // number for this owner. So nothing to pull from anyone here
            // the same, if fDlgStarted is NULL this means that partner hit an exception previously
            // and its dialog has been shut down. Don't attempt to get back to that partner in this
            // case.
            if (pPushPartner->pPushPnrData == NULL ||
                !pPushPartner->pPushPnrData->fDlgStarted)
                continue;


            // set the local variable vnToPullFrom to the first version number that is not known
            // locally (one more than the highest known)
            NMSNMH_INC_VERS_NO_M(pRplPullOwnerVersNo[i].VersNo, vnToPullFrom);

            try
            {
                // eventually we got here: start pulling
                RplPullPullEntries(
                    &(pPushPartner->pPushPnrData->DlgHdl), // active dialog to use
                    i,                                     // owner id
                    pPushPartner->VersNo,                  // max VersNo
                    vnToPullFrom,                          // min VersNo
                    WINS_E_RPLPULL,                        // the client is the replicator
                    NULL,                                  // pointer to rsp buffer (used only by scavenger)
                    TRUE,                                  // update counters
                    pPushPartner->pPushPnrData->RplType);  // replication type for this partner
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                DWORD ExcCode = GetExceptionCode();
                // dump the error
                DBGPRINT2(
                    EXC,
                    "GetReplicasNew->RplPullPullEntries(%x): hit exception (%x)\n",
                    pPushPartner->pPushPnrData->pPullCnfRec->WinsAdd.Add.IPAdd,
                    ExcCode);
                // log the error
                WINSEVT_LOG_M(
                    WINS_FAILURE,
                    ExcCode == WINS_EXC_COMM_FAIL ?  WINS_EVT_CONN_ABORTED : WINS_EVT_SFT_ERR);

                // ----bug #120788----
                // If an exception happens at this point, the persistent connection is left open and it might just
                // happen that the remote partner is still pushing data. This could fill up the TCP window
                // and could have the sender blocked indefinitely in RplPushInit->HandleSndEntriesReq.
                // Because of this the remote sender will be unable to push out data, and given that the
                // same thread is the one that is sending out the VersNo table (see the beginning of this 
                // function) subsequent replications will not be possible over the same connection.
                // FIX: in case anything goes wrong such that we get to this exception handler
                // just close the connection even if it is persistent. This causes any remote WINS to break
                // out from HandleSndEntriesReq and avoid getting stuck.
                ECommEndDlg(&(pPushPartner->pPushPnrData->DlgHdl));

                // If there is a persistent dialog, it has to be marked as "no longer active"
                if (pPushPartner->pPushPnrData->fPrsConn)
                    ECOMM_INIT_DLG_HDL_M(&(pPushPartner->pPushPnrData->pPullCnfRec->PrsDlgHdl));

                // Closing the dialog is not enough. Some other owners might be pulled out from the same 
                // partner. We shouldn't allow that, so just ban that partner for this replication cycle.
                pPushPartner->pPushPnrData->fDlgStarted = FALSE;

                // since we dropped down this connection and we won't look at it further lets delete its
                // mapping also
                if (pPushPartner->pPushPnrData->NoOfMaps)
                    WinsMscDealloc(pPushPartner->pPushPnrData->pAddVers);

            } // end except handler
        } // end looping through owners list

        // --Checkpoint--------------
        // Nothing has changed in the pPushPnrToPullFrom array except probably some dialogs that were shut down
        // because of exceptions in RplPullPullEntries. Owners handled by these partners were simply skipped.
        // At this point all replication is done, the most recent information about each owner apart has been
        // brought down from the partners that were holding it.
        // --------------------------

        // one more thing is left to be done: Check whether there is not a remote WINS partner
        // pretending to have more up-to-date information about the local WINS.
        if (pPushPnrToPullFrom[0].pPushPnrData != NULL &&
            pPushPnrToPullFrom[0].pPushPnrData->fDlgStarted)
        {
            ConductChkNew(
                pPushPnrToPullFrom[0].pPushPnrData,
                vnLocalMax,
                pPushPnrToPullFrom[0].VersNo);
        }

        // release the pPushPnrToPullFrom buffer
        WinsMscDealloc(pPushPnrToPullFrom);

    } // end "if there are active partners" case

    // cleanup starts here..
    for (i = 0; i < nPushPnrData; i++)
    {
        PPUSHPNR_DATA_T pPnrData = &(pPushPnrData[i]); 

        if (pPnrData->fDlgStarted == TRUE)
        {
            if (!pPnrData->fPrsConn)
                ECommEndDlg(&(pPnrData->DlgHdl));

            //Deallocate the memory pointed to by PushPnrData structure
            if (pPnrData->NoOfMaps)
                WinsMscDealloc(pPnrData->pAddVers);
        }
    }

    // deallocate the memory containing push pnr info.
    WinsMscDealloc(pPushPnrData);

    // If Wins is in the init time paused state, unpause it.
    //
    if (fWinsCnfInitStatePaused)
    {
        //inform sc to send a continue to WINS.
        EnterCriticalSection(&RplVersNoStoreCrtSec);
        fRplPullContinueSent = TRUE;
        WinsMscSendControlToSc(SERVICE_CONTROL_CONTINUE);
        LeaveCriticalSection(&RplVersNoStoreCrtSec);
    }

    DBGLEAVE("GetReplicasNew\n");
}
//------------------- END OF GetReplicasNew() ------------------------------------
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//------------------- ConductChkNew() --------------------------------------------
// This call replaces the original ConductChk() function due to major redesign in
// replicator's code.
// ft: 06/06/2000
//
// Parameters:
// 1) pPushPnrData: points to the replication partner that seems to have more
//    up-to-date information on self
// 2) vnMaxLocal: maximum local version number as detected before the replication
//    started
// 3) vnMaxRemote: maximum version number of the local server as known by the
//    remote partner
//
VOID
ConductChkNew(
    PPUSHPNR_DATA_T pPushPnrData,
    VERS_NO_T       vnMaxLocal,
    VERS_NO_T       vnMaxRemote)
{
    RPL_CONFIG_REC_T           Pnr;
    WINSINTF_PULL_RANGE_INFO_T PullRangeInfo;
    BOOL                       fVersNoAdj = FALSE;

    DBGENTER("ConductChkNew\n");

    Pnr.WinsAdd           = pPushPnrData->WinsAdd;
    Pnr.MagicNo           = 0;
    Pnr.RetryCount        = 0;
    Pnr.LastCommFailTime  = 0;
    Pnr.LastCommTime      = 0;
    Pnr.PushNtfTries      = 0;
    Pnr.fTemp             = FALSE; // We want the buffer to be deallocated by thread

    PullRangeInfo.OwnAdd.Type  = WINSINTF_TCP_IP;
    PullRangeInfo.OwnAdd.Len   = sizeof(COMM_IP_ADD_T);
    PullRangeInfo.OwnAdd.IPAdd = NmsLocalAdd.Add.IPAdd;
    PullRangeInfo.MaxVersNo    = vnMaxRemote;
    PullRangeInfo.MinVersNo    = vnMaxLocal;
    PullRangeInfo.pPnr         = &Pnr;
    NMSNMH_INC_VERS_NO_M(PullRangeInfo.MinVersNo, PullRangeInfo.MinVersNo);

    DBGPRINT5(
        RPLPULL, "ConductCheckNew(%x): Checking range [%x:%x - %x:%x]\n",
        Pnr.WinsAdd.Add.IPAdd,
        vnMaxLocal.HighPart, vnMaxLocal.LowPart,
        vnMaxRemote.HighPart, vnMaxRemote.LowPart);

    // We are pulling our own records. We want to store all.
    PullSpecifiedRange(
        &(pPushPnrData->DlgHdl),
        &PullRangeInfo,
        TRUE,                       //adjust min to NmsNmhMyMaxVersNo.
        WINSCNF_RPL_DEFAULT_TYPE);

    // If the version number is greater than the version counter value (this is 
    // different from the first entry of RplPullOwnerVersNo table since we look
    // in the registry to determine its value).
    EnterCriticalSection(&NmsNmhNamRegCrtSec);
    if (LiGtr(vnMaxRemote, NmsNmhMyMaxVersNo))
    {
        NmsNmhMyMaxVersNo.QuadPart = vnMaxRemote.QuadPart + 1;
        fVersNoAdj = TRUE;
    }
    LeaveCriticalSection(&NmsNmhNamRegCrtSec);

    if (fVersNoAdj)
    {
#ifdef WINSDBG
        vnMaxRemote.QuadPart += 1;
        DBGPRINT2(
            RPLPULL, "ConductCheck: Local VersNo adjusted to %x:%x\n",
            vnMaxRemote.HighPart, vnMaxRemote.LowPart);
#endif
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_ADJ_VERS_NO);
    }

    DBGLEAVE("ConductCheckNew\n");
}
//------------------- END OF ConductChkNew() ------------------------------------
//////////////////////////////////////////////////////////////////////////////////

VOID
GetVersNo(
        PPUSHPNR_DATA_T        pPushPnrData  //info about Push Pnr
        )

/*++

Routine Description:

        This function does the following:
                formats a "get address to Version Number mapping" request,
                sends it and waits for response
                Unformats the response


Arguments:
        pPushPnrData - Information about the Push Pnr which needs to
                       be contacted in order to get the version number
                       info.

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        GetReplicasNew

Side Effects:

Comments:

        Some optimization can be affected by the caller of this function
--*/

{

        BYTE        Msg[RPLMSGF_ADDVERSMAP_REQ_SIZE]; //Buffer that will contain
                                                      //the request to send

        DWORD       MsgLen;                        //Msg Length
        LPBYTE      pRspMsg;                       //ptr to Rsp message
        DWORD       RspMsgLen = 0;                 //Rsp msg length
#if SUPPORT612WINS > 0
    BOOL            fIsPnrBeta1Wins;
#endif

        DBGENTER("GetVersNo\n");
        /*
        * format the request to ask for version numbers
        */
        RplMsgfFrmAddVersMapReq( Msg + COMM_N_TCP_HDR_SZ,  &MsgLen );

        /*
         * Send "send me IP address - Version Number" messages to  the
         * Push Pnr
         *
         * NOTE: If there is a communication failure or if the other WINS
         * brings down the link, this function will raise a COMM_FAIL
         * exception (caught in the caller of GetVersNo)
        */
        ECommSndCmd(
                        &pPushPnrData->DlgHdl,
                        Msg + COMM_N_TCP_HDR_SZ,
                        MsgLen,
                        &pRspMsg,
                        &RspMsgLen
                   );

#if SUPPORT612WINS > 0
        COMM_IS_PNR_BETA1_WINS_M(&pPushPnrData->DlgHdl, fIsPnrBeta1Wins);
#endif
        /*
        *  Unformat the Rsp Message
        */
        RplMsgfUfmAddVersMapRsp(
#if SUPPORT612WINS > 0
                        fIsPnrBeta1Wins,
#endif
                        pRspMsg + 4,                 //past the opcodes
                        &(pPushPnrData->NoOfMaps),
                        NULL,
                        &pPushPnrData->pAddVers
                               );

#ifdef WINSDBG
        {
          DWORD i;
          struct in_addr InAddr;
          PRPL_ADD_VERS_NO_T  pAddVers;     //maps

          DBGPRINT1(RPLPULL, " %d Add-Vers Mappings retrieved.\n",
                                      pPushPnrData->NoOfMaps);

          for (i=0, pAddVers = pPushPnrData->pAddVers; i < pPushPnrData->NoOfMaps; i++, pAddVers++)
          {
                InAddr.s_addr = htonl(
                        pAddVers->OwnerWinsAdd.Add.IPAdd
                                     );
                DBGPRINT3(RPLPULL,"Add (%s)  - MaxVersNo (%lu %lu)\n",
                                inet_ntoa(InAddr),
                                pAddVers->VersNo.HighPart,
                                pAddVers->VersNo.LowPart
                                );
          }
       }
#endif
        ECommFreeBuff(pRspMsg - COMM_HEADER_SIZE);  //decrement to begining
                                                     //of buff
        DBGLEAVE("GetVersNo\n");
        return;

}


VOID
RplPullPullEntries(
        PCOMM_HDL_T             pDlgHdl,
        DWORD                   dwOwnerId,
        VERS_NO_T               MaxVersNo,
        VERS_NO_T               MinVersNo,
        WINS_CLIENT_E           Client_e,
        LPBYTE                  *ppRspBuff,
        BOOL                    fUpdCntrs,
        DWORD                   RplType
        )

/*++

Routine Description:
        This function is called to pull replicas for a particular owner from
        a Push Pnr.


Arguments:
        pDlgHdl   - Dialogue with the Push Pnr
        dwOwnerId - Owner Id. of WINS whose records are to be pulled.
        MaxVersNo - Max. Vers. No. in the set of replicas to pull
        MinVersNo - Min. Vers. No. in the set of replicas to pull
        Client_e  - indicates who the client is
        ppRspBuff - address of pointer to response buffer if client is
                    WINS_E_NMSSCV -- Scavenger thread executing VerifyIfClutter

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        GetReplicasNew

Side Effects:

Comments:
        None
--*/
{

        BYTE                Buff[RPLMSGF_SNDENTRIES_REQ_SIZE];
        DWORD               MsgLen;
        LPBYTE              pRspBuff;
        DWORD               RspMsgLen = 0;
        DWORD               NoOfRecs;
        BYTE                Name[NMSDB_MAX_NAM_LEN];
        DWORD               NameLen;
        BOOL                fGrp;
        DWORD               NoOfAdds;
        COMM_ADD_T          NodeAdd[NMSDB_MAX_MEMS_IN_GRP * 2]; //twice the # of
                                                             //members because
                                                             //for each member
                                                             //we have an owner
        DWORD               Flag;
        VERS_NO_T           VersNo, TmpVersNo;
        DWORD               i;
        LPBYTE              pTmp;
        PCOMM_ADD_T         pWinsAdd;
        PNMSDB_WINS_STATE_E pWinsState_e;
        PVERS_NO_T           pStartVersNo;
        STATUS              RetStat = WINS_SUCCESS;
#if SUPPORT612WINS > 0
        BOOL                fIsPnrBeta1Wins;
#endif

        DBGENTER("RplPullPullEntries\n");

#if SUPPORT612WINS > 0
        COMM_IS_PNR_BETA1_WINS_M(pDlgHdl, fIsPnrBeta1Wins);
#endif

        WinsMscChkTermEvt(
#ifdef WINSDBG
                    Client_e,
#endif
                    FALSE
                        );

        sfPulled = FALSE;                //we haven't pulled anything yet.
        RPL_FIND_ADD_BY_OWNER_ID_M(
                                dwOwnerId,
                                pWinsAdd,
                                pWinsState_e,
                                pStartVersNo
                                  );

        while(TRUE)
        {

#ifdef WINSDBG
         {
                PCOMMASSOC_DLG_CTX_T   pDlgCtx = pDlgHdl->pEnt;
                PCOMMASSOC_ASSOC_CTX_T pAssocCtx = pDlgCtx->AssocHdl.pEnt;
                struct in_addr InAdd;

                InAdd.s_addr = htonl(pWinsAdd->Add.IPAdd);
                DBGPRINT2(RPLPULL, "Going to Pull Entries owned by WINS with Owner Id = (%d) and address = (%s)\n", dwOwnerId, inet_ntoa(InAdd));

                InAdd.s_addr = htonl(pAssocCtx->RemoteAdd.sin_addr.s_addr);

                DBGPRINT5(RPLPULL, "RplPullPullEntries: Range of records is  = (%lu %lu) to (%lu %lu) and is being pulled from WINS with address - (%s)\n",
                        MinVersNo.HighPart,
                        MinVersNo.LowPart,
                        MaxVersNo.HighPart,
                        MaxVersNo.LowPart,
                        inet_ntoa(InAdd)
                 );
        }
#endif
        /*
        * Format the "send me data entries" message
        */
        RplMsgfFrmSndEntriesReq(
#if SUPPORT612WINS > 0
                               fIsPnrBeta1Wins,
#endif
                                Buff + COMM_N_TCP_HDR_SZ,
                                pWinsAdd,
                                MaxVersNo,
                                MinVersNo,
                                RplType,
                                &MsgLen
                           );

FUTURES("In case a huge range is being pulled, change the sTimeToWait")
FUTURES("in comm.c to a higher timeout value so that select does not")
FUTURES("time out")
        /*
        * send the cmd to the Push Pnr and read in the response
        */
        ECommSndCmd(
                        pDlgHdl,
                        Buff + COMM_N_TCP_HDR_SZ,
                        MsgLen,
                        &pRspBuff,
                        &RspMsgLen
                    );

        DBGPRINT0(RPLPULL, "RplPull: Received Response from Push pnr\n");

        if (Client_e == WINS_E_NMSSCV)
        {
                *ppRspBuff = pRspBuff;
                /*--ft: 01/07/200 moved to ChkConfNUpd--
                if (WinsCnf.LogDetailedEvts > 0)
                {
                    PCOMMASSOC_DLG_CTX_T   pDlgCtx = pDlgHdl->pEnt;
                    PCOMMASSOC_ASSOC_CTX_T pAssocCtx = pDlgCtx->AssocHdl.pEnt;
                    DWORD IpPartner = pAssocCtx->RemoteAdd.sin_addr.s_addr;

                    WinsEvtLogDetEvt(TRUE, WINS_EVT_REC_PULLED, TEXT("Verification"), __LINE__, "ddd", IpPartner, pWinsAdd->Add.IPAdd, 0);
                }
                --tf--*/
                DBGLEAVE("RplPullPullEntries\n");

                return;
        }

        pTmp = pRspBuff + 4;         //past the opcode

PERF("Speed this up by moving it into RplPullRegRepl")
        /*
         * Get the no of records from the response
        */
        RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
                        fIsPnrBeta1Wins,
#endif
                        &pTmp,
                        &NoOfRecs,
                        Name,
                        &NameLen,
                        &fGrp,
                        &NoOfAdds,
                        NodeAdd,
                        &Flag,
                        &TmpVersNo,
                        TRUE /*Is it first time*/
                               );

        DBGPRINT1(RPLPULL, "RplPullPullEntries: No of Records pulled are (%d)\n",
                                        NoOfRecs);

        if (WinsCnf.LogDetailedEvts > 0)
        {
            PCOMMASSOC_DLG_CTX_T   pDlgCtx = pDlgHdl->pEnt;
            PCOMMASSOC_ASSOC_CTX_T pAssocCtx = pDlgCtx->AssocHdl.pEnt;
            DWORD IpPartner = pAssocCtx->RemoteAdd.sin_addr.s_addr;

            WinsEvtLogDetEvt(TRUE, WINS_EVT_REC_PULLED, TEXT("Pull replication"), __LINE__, "ddd", IpPartner, pWinsAdd->Add.IPAdd, NoOfRecs);
        }
        if (NoOfRecs > 0)
        {


           if (RplPullRegRepl(
                           Name,
                           NameLen,
                           Flag,
                           dwOwnerId,
                           TmpVersNo,
                           NoOfAdds,
                           NodeAdd,
                           pWinsAdd,
                           RplType
                          ) == WINS_SUCCESS)
           {

              VersNo = TmpVersNo;

              /*
               * Repeat until all replicas have been retrieved from the
               * response buffer
              */
              for (i=1; i<NoOfRecs; i++)
              {
                  RplMsgfUfmSndEntriesRsp(
#if SUPPORT612WINS > 0
                                 fIsPnrBeta1Wins,
#endif
                                  &pTmp,
                                  &NoOfRecs,
                                  Name,
                                  &NameLen,
                                  &fGrp,
                                  &NoOfAdds,  //will be > 1 only if fGrp is
                                              // is TRUE and it is a special
                                              //group
                                  NodeAdd,
                                  &Flag,
                                  &TmpVersNo,
                                  FALSE /*Is it first time*/
                                 );


                   if (RplPullRegRepl(
                           Name,
                           NameLen,
                           Flag,
                           dwOwnerId,
                           TmpVersNo,
                           NoOfAdds,
                           NodeAdd,
                           pWinsAdd,
                           RplType
                          ) != WINS_SUCCESS)
                 {
                     DBGPRINT5(ERR, "RplPullPullEntries: Could not register record.\nName=(%s[%x])\nVersNo=(%d %d)\ndwOwnerId=(%d)\n", Name, Name[15], TmpVersNo.HighPart, TmpVersNo.LowPart, dwOwnerId);
                     break;
                 }
                 else
                 {
                         VersNo = TmpVersNo;
                 }
             } //end of for (looping over all records starting from
               //the second one
             sfPulled = TRUE;
          }
          else
          {
                     DBGPRINT5(ERR, "RplPullPullEntries: Could not register record.\nName=(%s[%x])\nVersNo=(%d %d)\ndwOwnerId=(%d)\n", Name, Name[15], TmpVersNo.HighPart, TmpVersNo.LowPart, dwOwnerId);
                     RetStat = WINS_FAILURE;


          }

           DBGPRINT2(RPLPULL,
                    "RplPullPullEntries. Max. Version No pulled = (%d %d)\n",
                     VersNo.HighPart, VersNo.LowPart
                         );


        }
        else // NoOfRecs == 0
        {
                DBGPRINT0(RPLPULL, "RplPullPullEntries: 0 records pulled\n");
        }

        //
        // Let us free the response buffer
        //
        ECommFreeBuff(pRspBuff - COMM_HEADER_SIZE);

        //
        // let us store the max. version number pulled from the Push Pnr
        // in the RplPullOwnerVersNo array.  This array is looked at by
        // the Push thread and RPC threads so we have to synchronize
        // with them

        //
        //  NOTE NOTE NOTE
        //       It is possible that one or more group (normal or
        //       special) records clashed with records in the db.
        //       During conflict resolution, the ownership of the
        //       record in the db may not get changed
        //       (See ClashAtReplGrpMems).  Thus, even though the
        //       version number counter for the WINS whose replicas
        //       were pulled gets updated it is possible that there
        //       may not be any (or there may be less than what got pulled)
        //       records for that owner in the db. In such a
        //       case,  a third WINS that tries to pull records owned by
        //       such a WINS may end up pulling 0 (or less number of) records.
        //       This is normal and correct behavior
        //
        //

        //
        // If the number of
        // records pulled is greater than 1, update the counters.
        //
        if (NoOfRecs > 0)
        {
          if (RetStat == WINS_SUCCESS)
          {
            //
            // fUpdCntrs will be FALSE if we have pulled as a result of a
            // PULL RANGE request from the administrator.  For all other
            // cases, it is TRUE. If FALSE, we will update the counter
            // only if the highest version number that we successfully
            // pulled is greater than what is there in our counter for
            // the WINS server.
            //
            if (        fUpdCntrs
                          ||
                        LiGtr(VersNo, (pRplPullOwnerVersNo+dwOwnerId)->VersNo)
               )
            {
                EnterCriticalSection(&RplVersNoStoreCrtSec);

                //
                // NOTE: Store the max. version number pulled and not the
                // MaxVersNo that we specified.  This is because, if we have
                // not pulled released records, then if they get changed to
                // ACTIVE prior to a future replication cycle (version number
                // remains unchanged when a released record changes to an
                // ACTIVE record due to a name registration), we will pull them.
                //
                (pRplPullOwnerVersNo+dwOwnerId)->VersNo                = VersNo;

                LeaveCriticalSection(&RplVersNoStoreCrtSec);

                //
                // We will pull our own records only due to a Pull Range
                // request.  PullSpecifiedRange calls this function
                // from inside the NmsNmhNamRegCrtSec Section.
                //
                if (dwOwnerId == NMSDB_LOCAL_OWNER_ID)
                {
                      if (LiGeq(VersNo, NmsNmhMyMaxVersNo))
                      {
                          NMSNMH_INC_VERS_COUNTER_M(VersNo, NmsNmhMyMaxVersNo);
                      }
                }
                //
                // If vers. number pulled is smaller than the Max. Vers no,
                // specified, check if it is because of the limit we have set
                // for the max. number or records that can be replicated
                // at a time.  If yes, pull again.
                //
                if (
                        LiLtr(VersNo, MaxVersNo)
                                &&
                        (NoOfRecs == RPL_MAX_LIMIT_FOR_RPL)
                   )
                {
                       MinVersNo = VersNo;
                       NMSNMH_INC_VERS_NO_M(MinVersNo, MinVersNo);

                       /*
                        *  We may have been signaled by the main thread
                        *  Check it.
                       */
                       WinsMscChkTermEvt(
#ifdef WINSDBG
                                  Client_e,
#endif
                                   FALSE
                                         );
                       continue;
                }
            }
          } //if RetStat == 0
        }  // if NoOfRecs > 0
        else  // no of records pulled in is zero
        {
                //
                // if the number of records pulled in is 0, then check if
                // we have any records for the owner in the database.
                // If there are none and fUpdCtrs is FALSE, meaning
                // that this is a PULL SPECIFIED RANGE request from the
                // administrator, delete the record for the owner from
                // the in-memory and database tables
                //
                if (
                        (LiEqlZero((pRplPullOwnerVersNo+dwOwnerId)->VersNo))
                                        &&
                        (!fUpdCntrs)
                                        &&
                        (dwOwnerId != NMSDB_LOCAL_OWNER_ID)
                   )
                {
                        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
                        try {
                          (pNmsDbOwnAddTbl+dwOwnerId)->WinsState_e =
                                                NMSDB_E_WINS_DELETED;
                          NmsDbWriteOwnAddTbl(
                                NMSDB_E_DELETE_REC,
                                dwOwnerId,
                                NULL,               //address of WINS
                                NMSDB_E_WINS_DELETED,
                                NULL,
                                NULL
                                        );
                        } // end of try
                        finally {
                          LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
                        }

                }
                break;  //break out of the while loop
         } // end of else

         break;
       }  //end of while (TRUE)

       DBGLEAVE("RplPullPullEntries\n");
       return;
}


VOID
SubmitTimerReqs(
        PRPL_CONFIG_REC_T        pPullCnfRecs
        )

/*++

Routine Description:
        This function goes through the array of configuration records
        submitting a timer request for each config. record that specifies
        a time interval

        Note: a single timer request is submitted for all records that
                have the same time interval specified in them.

Arguments:
        pPullCnfRecs - Array of Pull Configuration records

Externals Used:
        None

Return Value:

        None

Error Handling:

Called by:
        InitRplProcess

Side Effects:

Comments:
        The records in the pPullCnfRecs array are traversed in sequence

        This function is called only at Init/Reconfig time
--*/

{

        DBGENTER("SubmitTimerReqs\n");
try {
        SetTimeReqs.NoOfSetTimeReqs = 0;

        for(
                ;
                pPullCnfRecs->WinsAdd.Add.IPAdd != INADDR_NONE;
                pPullCnfRecs = (PRPL_CONFIG_REC_T) (
                                   (LPBYTE)pPullCnfRecs + RPL_CONFIG_REC_SIZE
                                                    )
           )
        {

                //
                // Submit a timer request only if we have not submitted one
                // already for the same time interval value
                //
                if  (!pPullCnfRecs->fLinked)
                {
                        //
                        // If it has an invalid time interval, check that
                        // it is not a one time only replication record
                        //
                        if  (pPullCnfRecs->TimeInterval == RPL_INVALID_METRIC)
                        {
                                if (!pPullCnfRecs->fSpTime)
                                {
                                        continue;
                                }
                                else  // a specific time is given
                                {
                                  //
                                  // If Init time replication is specified,
                                  // we must have done replication
                                  // (in InitTimeRpl).
                                  // We should check if SpTimeIntvl <= 0. If
                                  // it is, we skip this record. The time for
                                  // Specific time replication is past. In any
                                  // case, we just pulled (in InitTimeRpl)
                                  //
                                  if (
                                        (WinsCnf.PullInfo.InitTimeRpl)
                                                &&
                                        (pPullCnfRecs->SpTimeIntvl <= 0)
                                     )
                                  {
                                        continue;
                                  }
                                }
                        }

                        SubmitTimer(
                                    NULL,  //NULL means, SubmitTimer should
                                       //allocate its own work item
                                    pPullCnfRecs,
                                FALSE                //it is not a resubmission
                                    );
                }

        } // end of for loop
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("SubmitTimerReqs\n");
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
        }
        DBGLEAVE("SubmitTimerReqs\n");
        return;
}



VOID
SubmitTimer(
        LPVOID                        pWrkItm,
        PRPL_CONFIG_REC_T         pPullCnfRec,
        BOOL                        fResubmit
        )

/*++

Routine Description:
        This function is called to submit a single timer request
        It is passed the address of a pull configuration record that
        may have other pull config. records linked to it.  Records
        are linked if they require replication to happen at the same time.


Arguments:

        pWrkItm     - Work item to submit after initialization
        pPullCnfRec - Address of a configuration record pertaining to a
                      Push Pnr
        fResubmit   - indicates whether this work item was submitted earlier (
                      and is now being resubmitted)

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        SubmitTimerReqs(), RplPullInit()

Side Effects:

Comments:
        None
--*/

{
        time_t            AbsTime;
        DWORD             TimeInt;
        BOOL              fTimerSet = FALSE;
        DWORD             LastMaxVal = 0;
        LPVOID            pStartOfPullGrp = pPullCnfRec;
        PRPL_CONFIG_REC_T pSvPtr = pPullCnfRec;
        BOOL              fSubmit = TRUE;

        ASSERT(pPullCnfRec);

        //
        // Let us check all linked records.
        // We stop at the first one with a Retry Count <=
        // MaxNoOfRetries specified in WinsCnf. If found, we submit a timer,
        // else we return
        //
        for (
                        ;
                pPullCnfRec != NULL;
                pPullCnfRec = WinsCnfGetNextRplCnfRec(
                                                pPullCnfRec,
                                                RPL_E_VIA_LINK //get the
                                                               //linked rec
                                                      )
            )
        {
                //
                // If the number of retries have exceeded the max. no. allowed,
                // check if we should submit a timer request for it now.
                //
                if (pPullCnfRec->RetryCount > WinsCnf.PullInfo.MaxNoOfRetries)
                {

                        if (pPullCnfRec->RetryAfterThisManyRpl
                                        < (DWORD)((pPullCnfRec->TimeInterval >
                                                   WINSCNF_MAX_WAIT_BEFORE_RETRY_RPL) ? 0 : WINSCNF_RETRY_AFTER_THIS_MANY_RPL
                                ))
                        {
                                pPullCnfRec->RetryAfterThisManyRpl++;

                                //
                                // Is this record closer to a retry than
                                // the any other we have seen so far. If
                                // yes, then save the value of the
                                // RetryAfterThisManyRpl field and the
                                // address of the record.  Note: A record
                                // with an invalid time interval but with
                                // a specific time will never be encountered
                                // by this section of the code (because
                                // fSpTime will be set to FALSE -- see below;
                                // Also, see SubmitTimerReqs)
                                //
                                if (pPullCnfRec->RetryAfterThisManyRpl >
                                                 LastMaxVal)
                                {
                                        pSvPtr = pPullCnfRec;
                                        LastMaxVal =
                                           pPullCnfRec->RetryAfterThisManyRpl;

                                }

                                continue;        //check the next record
                        }
                        else
                        {
                                pPullCnfRec->RetryAfterThisManyRpl = 0;
                                //pPullCnfRec->RetryAfterThisManyRpl = 1;
                                pPullCnfRec->RetryCount = 0;
                        }
                }

FUTURES("Get rid of the if below")
                //
                // If this is a retry and TimeInterval is valid, use the retry time
        // interval.  If time interval is invalid, it means that we tried
        // to establish comm. at a specific time.
                //
                if ((pPullCnfRec->RetryCount != 0) && (pPullCnfRec->TimeInterval != RPL_INVALID_METRIC))
                {
//                        TimeInt = WINSCNF_RETRY_TIME_INT;
                        TimeInt = pPullCnfRec->TimeInterval;
                }
                else  // this is not a retry
                {
                        //
                        // Specific time replication is done only once at
                        // the particular time specified. After that
                        // replication is driven by the TimeInterval value
                        //
                        if (pPullCnfRec->fSpTime)
                        {
                                TimeInt      = (DWORD)pPullCnfRec->SpTimeIntvl;
                                pPullCnfRec->fSpTime = FALSE;
                        }
                        else
                        {
                                if (pPullCnfRec->TimeInterval
                                                != RPL_INVALID_METRIC)
                                {
                                        TimeInt = pPullCnfRec->TimeInterval;
                                }
                                else
                                {
                                        //
                                        // Since we have submitted a request
                                        // for all records in this chain
                                        // atleast once, break out of the
                                        // loop (All records in this chain
                                        // have an invalid time interval).
                                        //
                                        fSubmit = FALSE;
                                        break; // we have already submitted
                                               // this one time only request
                                }
                        }
                }

                //
                // Set fTimerSet to TRUE to indicate that there is atleast
                // one partner for which we will be submitting a timer request.
                //
                fTimerSet = TRUE;

                //
                // We need to submit the request. Break out of the loop
                //
                break;
        }

        //
        // Do we need to submit a timer request
        //
        if (fSubmit)
        {

           //
           // If fTimerSet is FALSE,
           // it means that communication could not be established
           // with any member of the group (despite WinsCnf.MaxNoOfRetries
           // retries with each). We should compute the time interval to the
           // earliest retry that we should do.
           //
           if (!fTimerSet)
           {
              // fixes #391314
              if (WINSCNF_RETRY_AFTER_THIS_MANY_RPL == pSvPtr->RetryAfterThisManyRpl)
              {
                  TimeInt = pSvPtr->TimeInterval;
              }
              else
              {
                  TimeInt = pSvPtr->TimeInterval *
                                (WINSCNF_RETRY_AFTER_THIS_MANY_RPL -
                                                pSvPtr->RetryAfterThisManyRpl);
              }
              pSvPtr->RetryAfterThisManyRpl = 0;
              pSvPtr->RetryCount             = 0;
           }

           (void)time(&AbsTime);
           if( pSvPtr->LastRplTime == 0 ) {

               //
               //  This is our first replication.  Just add the interval to
               //  the current time.
               //

               AbsTime += TimeInt;
               pSvPtr->LastRplTime = AbsTime;

           } else {

               //
               //  We have replicated before.  We need to make sure that
               //  our replication time is at an interval based on the time
               //  the last replication started.
               //

               do {

                   pSvPtr->LastRplTime += TimeInt;

               } while( pSvPtr->LastRplTime <= AbsTime );

               AbsTime = pSvPtr->LastRplTime;
           }


           DBGPRINT3(RPLPULL, "SubmitTimer: %s a Timer Request for (%d) secs to expire at abs. time = (%d)\n",
fResubmit ? "Resubmitting" : "Submitting", TimeInt, AbsTime);

           WinsTmmInsertEntry(
                                pWrkItm,
                                WINS_E_RPLPULL,
                                QUE_E_CMD_SET_TIMER,
                                fResubmit,
                                AbsTime,
                                TimeInt,
                                &QueRplPullQueHd,
                                pStartOfPullGrp,
                                pSvPtr->MagicNo,
                                &SetTimeReqs
                                 );
        }

        return;
}



VOID
SndPushNtf(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:
        This function is called to push a notification to a remote WINS (Pull
        Partner) that a certain number of updates have been done.

    It can be called either as a result of a version number update or from
    HdlPushNtf() to propagate a net trigger.

Arguments:
        pConfigRec  -  Configuration record of the Push Pnr to whome the
                       notification needs to be sent

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        RplPullInit()

Side Effects:

Comments:
        None
--*/

{

   LPBYTE                      pBuff;
   DWORD                       MsgLen;
   COMM_HDL_T                  DlgHdl;
   DWORD                       i;
   PRPL_ADD_VERS_NO_T          pPullAddVersNoTbl;
   PRPL_ADD_VERS_NO_T          pPullAddVersNoTblTmp;
   PCOMM_ADD_T                 pWinsAdd;
   PNMSDB_WINS_STATE_E         pWinsState_e;
   PVERS_NO_T                  pStartVersNo;
   time_t                      CurrentTime;
   BOOL                        fStartDlg = FALSE;
   volatile PRPL_CONFIG_REC_T  pConfigRec = pWrkItm->pClientCtx;
   DWORD                       NoOfOwnersActive = 0;
#if SUPPORT612WINS > 0
   BOOL                        fIsPnrBeta1Wins;
#endif
   DWORD                       StartOwnerId;
   DWORD                       EndOwnerId;
   BOOL                        fPullAddVersNoTblAlloc = FALSE;
   DWORD                       SizeOfBuff;
   BOOL                        fBuffAlloc = FALSE;
#if PRSCONN
   BOOL                        fDlgActive = TRUE;
#endif
   RPLMSGF_MSG_OPCODE_E        Opcd_e;

   DBGENTER("SndPushNtf\n");

   //
   // No need for entering a critical section while using pConfigRec,
   // since only the Pull thread deallocates it on reconfiguration
   // (check Reconfig)
   //


   //
   // Check whether we want to try sending or not.   We will not try if
   // we have had 2 comm. failure in the past 5 mts. This is to guard
   // against the case where a lot of push request get queued up for
   // the pull thread for communicating with a wins with which comm
   // has been lost.
   //
   (void)time(&CurrentTime);

#define PUSH_TRY_LIMIT    2

   if (
        ((CurrentTime - pConfigRec->LastCommFailTime) < FIVE_MINUTES)
                        &&
        (pConfigRec->PushNtfTries >= PUSH_TRY_LIMIT)        //try two times

     )
   {
        DBGPRINT2(ERR, "SndPushNtf: Since we have tried %d times unsuccessfully in the past 5 mts to communicate with the WINS server (%X) , we are returning\n",
                pConfigRec->PushNtfTries,
                pConfigRec->WinsAdd.Add.IPAdd);

        WINSEVT_LOG_D_M(pConfigRec->WinsAdd.Add.IPAdd, WINS_EVT_NO_NTF_PERS_COMM_FAIL);
        return;
   }

   //
   // If it is a push notification without propagate, we should send all
   // our maps. If it is a push with propagate, we should send only one
   // map -- If we are initiating the trigger, we should send map of
   // records owned by us.  If not, we should send the map of records
   // owned by the WINS that initiated the trigger
   //
   if ( pWrkItm->CmdTyp_e == QUE_E_CMD_SND_PUSH_NTF)
   {
          StartOwnerId   = 0;
          EndOwnerId = StartOwnerId + NmsDbNoOfOwners;
   }
   else
   {
          BOOL fAllocNew = FALSE;
          COMM_ADD_T  WinsAdd;
          STATUS RetStat;

          //
          // If we are propagating a net trigger and the address in pMsg is
          // not our own, it means that the trigger came from a new WINS. If
          // it is our own, it means that the trigger came from an old WINS(3.5)
          // or 3.51 beta/RC1. In this case we should send all of our maps.
          //
          if (
               (pWrkItm->pMsg)
                   &&
               (PtrToUlong(pWrkItm->pMsg) != NmsLocalAdd.Add.IPAdd)
             )
          {
            //
            // we are propagating a net trigger.  pMsg above will not be NULL
            // only if we are propagating a net trigger
            //
            COMM_INIT_ADD_M(&WinsAdd, PtrToUlong(pWrkItm->pMsg));
            RetStat = RplFindOwnerId(
                        &WinsAdd,
                        &fAllocNew,  //don't assign
                        &StartOwnerId,
                        WINSCNF_E_IGNORE_PREC,
                        WINSCNF_LOW_PREC
                         );
            if (RetStat == WINS_FAILURE)
            {
                ASSERTMSG("DROPPING PROPAGATE\n", FALSE);
                //
                // log an event and return
                //
                DBGPRINT1(RPLPULL, "SndPushNtf: WEIRD -- Dropping the push with propagate since we did not find the owner (%x) in our table. HOW CAN THAT HAPPEN\n", WinsAdd.Add.IPAdd);
                return;
            }
            EndOwnerId = StartOwnerId + 1;
          }
          else
          {
             //
             // Either we are initiating the trigger or we are propagating
             // one sent by a 3.5 or a 3.51 BETA/RC1 WINS
             //
             if (!pWrkItm->pMsg)
             {
                //
                // We are initiating a trigger. Just send one map (records
                // owned by us)
                //
                StartOwnerId = 0;
                EndOwnerId   = 1;
             }
             else
             {
               //
               // Send all the maps except our own since we don't know who
               // initiated the trigger. Not sending ours lowers the
               // probability of this trigger process continuing indefinitely
               //

               //
               // Actually no need to test this since we will never
               // have this case (HdlPushNtf() must have pulled records
               // of atleast one other WINS).
               //
               if (NmsDbNoOfOwners == 1)
               {
                 //
                 // nothing to propagate. Just return
                 //
                 return;
               }
               else
               {
                 StartOwnerId = 1;
               }
               EndOwnerId   = NmsDbNoOfOwners;
             }
          }

   }

   //
   // If we are trying after a comm. failure
   //
   if (pConfigRec->PushNtfTries == PUSH_TRY_LIMIT)
   {
        pConfigRec->PushNtfTries = 0;
   }




FUTURES("If/When we start having persistent dialogues, we should check if we")
FUTURES("already have a dialogue with the WINS. If there is one, we should")
FUTURES("use that.  To find this out, loop over all Pull Config Recs to see")
FUTURES("if there is match (use the address as the search key")

try {

#if PRSCONN
   //
   // If the pnr is not a persistent pnr or if it is one but the dlg with it
   // is not active
   //
   if (
     (!pConfigRec->fPrsConn)
         ||
     !ECommIsBlockValid(&pConfigRec->PrsDlgHdl)
         ||
     (((CurrentTime - pConfigRec->LastCommTime) > FIVE_MINUTES) &&
     !(fDlgActive = ECommIsDlgActive(&pConfigRec->PrsDlgHdl)))
    )
   {
     if (!fDlgActive)
     {
        ECommEndDlg(&pConfigRec->PrsDlgHdl);
     }

     //
     // Init the pEnt field to NULL so that ECommEndDlg (in the
     // exception handler) called as a result of an exception from
     // behaves fine.
     //
     DlgHdl.pEnt = NULL;

     //
     // Start a dialogue.  Don't retry if there is comm. failure
     //
     ECommStartDlg(
                        &pConfigRec->WinsAdd,
                        COMM_E_RPL,
                        &DlgHdl
                );

     //
     // If the pnr is not NT 5, we can not send a PRS opcode to it (it will just
     // chuck it. The macro below will set the fPrsConn field of the partner
     // record to FALSE if the partner is not an NT 5+ partner
     //
     if (pConfigRec->fPrsConn)
     {
        ECOMM_IS_PNR_POSTNT4_WINS_M(&DlgHdl, pConfigRec->fPrsConn);
     }

     if (pConfigRec->fPrsConn)
     {
        pConfigRec->PrsDlgHdl = DlgHdl;
     }
   }
   else
   {
     DlgHdl    = pConfigRec->PrsDlgHdl;
   }
#else
   //
   // Init the pEnt field to NULL so that ECommEndDlg (in the
   // exception handler) called as a result of an exception from
   // behaves fine.
   //
   DlgHdl.pEnt = NULL;

   //
   // Start a dialogue.  Don't retry if there is comm. failure
   //
   ECommStartDlg(
                        &pConfigRec->WinsAdd,
                        COMM_E_RPL,
                        &DlgHdl
                );

#endif
   fStartDlg = TRUE;

   pConfigRec->LastCommFailTime = 0;
   if (pConfigRec->PushNtfTries > 0)
   {
     pConfigRec->PushNtfTries     = 0;
   }

    /*
     *  Get the max. version no for entries owned by self
     *  No need to enter a critical section before retrieving
     *  the version number.
     *
     *  The reason we subtract 1 from NmsNmhMyMaxVersNo is because
     *  it contains the version number to be given to the next record
     *  to be registered/updated.
    */
   EnterCriticalSection(&NmsNmhNamRegCrtSec);
   EnterCriticalSection(&RplVersNoStoreCrtSec);
   NMSNMH_DEC_VERS_NO_M(
                        NmsNmhMyMaxVersNo,
                        pRplPullOwnerVersNo->VersNo
                        );
   LeaveCriticalSection(&RplVersNoStoreCrtSec);
   LeaveCriticalSection(&NmsNmhNamRegCrtSec);



   WinsMscAlloc(
                 sizeof(RPL_ADD_VERS_NO_T) * (EndOwnerId - StartOwnerId),
                 (LPVOID *)&pPullAddVersNoTbl
               );
   fPullAddVersNoTblAlloc = TRUE;

   //
   // Initialize PullAddVersNoTbl array
   //
   for (i=StartOwnerId; i < EndOwnerId; i++)
   {
    RPL_FIND_ADD_BY_OWNER_ID_M(i, pWinsAdd, pWinsState_e, pStartVersNo);
    if (*pWinsState_e == NMSDB_E_WINS_ACTIVE)
    {
          (pPullAddVersNoTbl + NoOfOwnersActive)->VersNo = (pRplPullOwnerVersNo+i)->VersNo;
          (pPullAddVersNoTbl + NoOfOwnersActive)->OwnerWinsAdd  = *pWinsAdd;
          NoOfOwnersActive++;
    }
   }

#if SUPPORT612WINS > 0
   COMM_IS_PNR_BETA1_WINS_M(&DlgHdl, fIsPnrBeta1Wins);
#endif

   //
   // format the Push notification message. This message is exactly same
   // as the Address to Version Number Mapping message except the opcode
   //

   SizeOfBuff = RPLMSGF_ADDVERSMAP_RSP_SIZE_M(NoOfOwnersActive);
   WinsMscAlloc(SizeOfBuff, (LPVOID *)&pBuff);
   fBuffAlloc = TRUE;

#if PRSCONN

   //
   //  Send a PRS opcode if we are supposed to be forming a persistent conn
   //
   if (pConfigRec->fPrsConn)
   {
        Opcd_e = (pWrkItm->CmdTyp_e == QUE_E_CMD_SND_PUSH_NTF) ? RPLMSGF_E_UPDATE_NTF_PRS                                : RPLMSGF_E_UPDATE_NTF_PROP_PRS;
   }
   else
#endif
   {

        Opcd_e = (pWrkItm->CmdTyp_e == QUE_E_CMD_SND_PUSH_NTF) ? RPLMSGF_E_UPDATE_NTF                                : RPLMSGF_E_UPDATE_NTF_PROP;

   }
   RplMsgfFrmAddVersMapRsp(
#if SUPPORT612WINS > 0
        fIsPnrBeta1Wins,
#endif
        Opcd_e,
        pBuff + COMM_N_TCP_HDR_SZ,
        SizeOfBuff - COMM_N_TCP_HDR_SZ,
        pPullAddVersNoTbl,
        NoOfOwnersActive,
        (pWrkItm->pMsg != NULL) ? PtrToUlong(pWrkItm->pMsg) : NmsLocalAdd.Add.IPAdd,
                           //
                           // pMsg above will be Non-NULL only for the case
                           // when we are propagating the net upd. ntf.
                           //
        &MsgLen
                 );
   //
   // send the message to the remote WINS.  Use an existent dialogue
   // if there with the remote WINS
   //

   ECommSendMsg(
                &DlgHdl,
                NULL,                //no need for address since this is a TCP conn
                pBuff + COMM_N_TCP_HDR_SZ,
                MsgLen
                );


#if PRSCONN
   pConfigRec->LastCommTime = CurrentTime;
   if (!pConfigRec->fPrsConn)
#endif
   {
      //
      // Ask ComSys (TCP listener thread) to monitor the dialogue
      //
      ECommProcessDlg(
                &DlgHdl,
                COMM_E_NTF_START_MON
              );
   }

 } // end of try {..}
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT2(EXC, "SndPushNtf -PULL thread. Got Exception (%x). WinsAdd = (%x)\n", ExcCode, pConfigRec->WinsAdd.Add.IPAdd);
        WINSEVT_LOG_M(ExcCode, WINS_EVT_RPLPULL_PUSH_NTF_EXC);
        if (ExcCode == WINS_EXC_COMM_FAIL)
        {
                pConfigRec->LastCommFailTime = CurrentTime;
NOTE("Causes an access violation when compiled with no debugs.  Haven't")
NOTE("figured out why. This code is not needed")
                pConfigRec->PushNtfTries++;  //increment count of tries.
        }
        if (fStartDlg)
        {
                //
                // End the dialogue.
                //
                ECommEndDlg(&DlgHdl);
#if PRSCONN
                if (pConfigRec->fPrsConn)
                {
                    ECOMM_INIT_DLG_HDL_M(&(pConfigRec->PrsDlgHdl));
                }
#endif
        }
 } //end of exception handler

   if (fPullAddVersNoTblAlloc)
   {
       WinsMscDealloc(pPullAddVersNoTbl);

   }
   //
   // If this is a temporary configuration record, we need to deallocate it
   // It can be a temporary config. record only if
   //   1)We are executing here due to an rpc request
   //
   if (pConfigRec->fTemp)
   {
        WinsMscDealloc(pConfigRec);
   }

   //
   // dealloc the buffer we allocated
   //
   if (fBuffAlloc)
   {
        WinsMscDealloc(pBuff);

   }

   //
   // In the normal case, the connection will be terminated by the other side.
   //
  DBGLEAVE("SndPushNtf\n");
  return;
}


VOID
EstablishComm(
        IN  PRPL_CONFIG_REC_T    pPullCnfRecs,
        IN  BOOL                 fAllocPushPnrData,
        IN  PPUSHPNR_DATA_T      *ppPushPnrData,
        IN  RPL_REC_TRAVERSAL_E  RecTrv_e,
        OUT LPDWORD              pNoOfPushPnrs
        )

/*++

Routine Description:
        This function is called to establish communications with
        all the WINS servers i(Push Pnrs) specified by the the config records

Arguments:
        pPullCnfRecs  - Pull Config records
        pPushPnrData  - Array of data records each pertaining to a PUSH pnr
        RecTrv_e      - indicates whether the list of configuration records
                        is to be traversed in sequence
        pNoOfPushPnrs - No of Push Pnrs

Externals Used:
        None

Return Value:
        VOID

Error Handling:

Called by:
        GetReplicasNew

Side Effects:

Comments:
        On return from this function, pPushPnrData will have zero or more
        partners starting from index 0 with which dlg could be started.
        PushPnrId will start from 1 (if dlg. could be established with
        atleast one partner) and can be any number in the range 1
        to MAX_RPL_OWNERS (the number indicates the iteration of the for
        loop at which this WINS was encountered)
--*/

{
#define INITIAL_NO_OF_PNRS    30

        volatile DWORD  i;
        volatile DWORD  NoOfRetries = 0;
        DWORD           TotNoOfPushPnrSlots = INITIAL_NO_OF_PNRS;
        PPUSHPNR_DATA_T pPushPnrData;
#if PRSCONN
        time_t          CurrentTime;
        BOOL            fDlgActive;
#endif

        DBGENTER("EstablishComm\n");

        *pNoOfPushPnrs = 0;

        //
        // if the client wants this function to allocate pPushPnrData
        //
        if (fAllocPushPnrData)
        {
          WinsMscAlloc(sizeof(PUSHPNR_DATA_T) * TotNoOfPushPnrSlots, (LPVOID *)ppPushPnrData);
        }

        pPushPnrData = *ppPushPnrData;

        /*
          Start a dialogue with all Push Partners specified in the
          Pull Cnf Recs  passed as input argument and get
          the version numbers of the different owners kept
          in the database of these Push Pnrs

          i = 0 for self's data
        */
#if PRSCONN
        (void)time(&CurrentTime);
#endif
        for (
                i = 1;
                pPullCnfRecs->WinsAdd.Add.IPAdd != INADDR_NONE;
                        // no third expression
            )
        {


try
 {

#if PRSCONN

                fDlgActive = TRUE;

                //
                // If this partner is not a persistent conn. pnr or if he is one
                // but the dlg that we have with it is not valid, start a dlg
                // with him.  A dlg may not be valid either because we never
                // formed one with pnr or because it got disconnected as
                // a result of the pnr terminating.
                //
                // there is a corner case: two servers, A<->B replication partners
                // A pulls records from B and then on B WINS is restarted. Then, any
                // communication that A attempts with B in less than five minutes will
                // fail. This is because A will still think the connection is up.
                // A can't do otherwise, because there would be too much overhead in 
                // testing each time the TCP connection (see CommIsDlgActive).
                // This check has to be done at least at certain intervals (5min).
                if (
                    (!pPullCnfRecs->fPrsConn)
                             ||
                    !ECommIsBlockValid(&pPullCnfRecs->PrsDlgHdl)
                               ||
                   (((CurrentTime - pPullCnfRecs->LastCommTime) > FIVE_MINUTES) &&
                   !(fDlgActive = ECommIsDlgActive(&pPullCnfRecs->PrsDlgHdl)))
                      )
                {

                  //
                  // if the dlg is gone, end it so that the dlg block gets
                  // deallocated.
                  //
                  if (!fDlgActive)
                  {
                     ECommEndDlg(&pPullCnfRecs->PrsDlgHdl);
                  }
#endif
                  //
                  // Let us make sure that we don't try to establish
                  // communications with a WINS whose retry count is
                  // over.  If this is such a WINS's record, get the
                  // next WINS's record and continue.  If there is
                  // no WINS left to establish comm with, break out of
                  // the for loop
                  //
                  //
                  if (pPullCnfRecs->RetryCount > WinsCnf.PullInfo.MaxNoOfRetries)
                  {
                        pPullCnfRecs = WinsCnfGetNextRplCnfRec(
                                                        pPullCnfRecs,
                                                        RecTrv_e
                                                              );
                        if (pPullCnfRecs == NULL)
                        {
                                      break;  // break out of the for loop
                        }
                        continue;
                  }
                  ECommStartDlg(
                                &pPullCnfRecs->WinsAdd,
                                COMM_E_RPL,
                                &pPushPnrData->DlgHdl
                             );

                  pPushPnrData->fDlgStarted = TRUE;
#if PRSCONN
                  //
                  // If the dlg is supposed to be persistent, store it as such
                  //
                  if (pPullCnfRecs->fPrsConn)
                  {
                       pPullCnfRecs->PrsDlgHdl = pPushPnrData->DlgHdl;
                       pPushPnrData->fPrsConn = TRUE;
                  }
                }
                else //There is a pers dlg and it is very much active
                {

                       pPushPnrData->DlgHdl = pPullCnfRecs->PrsDlgHdl;
                       pPushPnrData->fPrsConn = TRUE;
                       pPushPnrData->fDlgStarted = TRUE;
                       //
                       // No need to set fPrsConn field of PushPnrData to FALSE
                       // Memory is initialized to 0 by default
                       //
                }

                //
                // It is ok to set it here as against after the data is sent
                //
                pPullCnfRecs->LastCommTime = CurrentTime;
#endif

                pPushPnrData->RplType     = pPullCnfRecs->RplType;

                 //
                 // Note: Don't use RplFindOwnerId to get the owner id.
                 // corresponding to the Wins with which communication
                 // is being established because doing so will create an
                 // entry for the WINS in the table. If this partner
                 // turns out to be bogus, we will have to remove
                 // the entry later.
                 //
                 // We will do this later.
                 //
                 pPushPnrData->PushPnrId    = i;
                 pPushPnrData->WinsAdd      = pPullCnfRecs->WinsAdd;
                 pPushPnrData->pPullCnfRec  = pPullCnfRecs;

                 //
                 // we were able to establish comm., so let us init the
                 // LastCommFailTime to 0. NOTE: Currently, this field
                 // is not used for pull partners.
                 //
                 pPullCnfRecs->LastCommFailTime = 0;

                 //
                 // Reset the retry counter back to 0
                 //
                 NoOfRetries = 0;

                 (VOID)InterlockedIncrement(&pPullCnfRecs->NoOfRpls);
                 //
                 // reinit Retry Count to 0
                 //
                 pPullCnfRecs->RetryCount = 0;


                //
                // Note: These should get incremented only if there is
                // no exception.  That is why they are here versus in the
                // as expr3 of the for clause
                //
                pPushPnrData++;
                (*pNoOfPushPnrs)++;

                if (fAllocPushPnrData && (*pNoOfPushPnrs == TotNoOfPushPnrSlots))
                {
                     WINSMSC_REALLOC_M(sizeof(PUSHPNR_DATA_T) * (TotNoOfPushPnrSlots * 2), ppPushPnrData);
                     pPushPnrData = (*ppPushPnrData) + TotNoOfPushPnrSlots;
                     TotNoOfPushPnrSlots *= 2;

                }
                i++;

                WinsMscChkTermEvt(
#ifdef WINSDBG
                         WINS_E_RPLPULL,
#endif
                         FALSE
                            );

                //
                //  Note: the following
                //  is required even when an exception is raised. Therefore
                //  it is repeated inside the exception handler code.
                //
                pPullCnfRecs = WinsCnfGetNextRplCnfRec(
                                                pPullCnfRecs,
                                                RecTrv_e
                                                      );
                if (pPullCnfRecs == NULL)
                {
                      break;  // break out of the for loop
                }
 }        // end of try blk
except(EXCEPTION_EXECUTE_HANDLER)  {
                DBGPRINTEXC("EstablishComm");
                if (GetExceptionCode() == WINS_EXC_COMM_FAIL)
                {

#ifdef WINSDBG
                    struct in_addr        InAddr;
                    InAddr.s_addr = htonl( pPullCnfRecs->WinsAdd.Add.IPAdd );
                    DBGPRINT1(EXC, "EstablishComm: Got a comm. fail with WINS at address = (%s)\n", inet_ntoa(InAddr));
#endif
                    WinsMscChkTermEvt(
#ifdef WINSDBG
                       WINS_E_RPLPULL,
#endif
                       FALSE
                                     );
                   //
                   // Store the time (for use in SndPushNtf)
                   //
#if PRSCONN
                   pPullCnfRecs->LastCommFailTime = CurrentTime;
#else
                   (VOID)time(&(pPullCnfRecs->LastCommFailTime));
#endif

                   //
                   // Check if we have exhausted the max. no. of retries
                   // we are allowed in one replication cycle. If not,
                   // sleep for some time (20sec) and try again..
                   //
                   // --ft: 07/10: comment out this piece of code since
                   // MAX_RETRIES_TO_BE_DONE is set to 0 (#def)
                   //
                   //if (NoOfRetries < MAX_RETRIES_TO_BE_DONE)
                   //{
                   //     // Maybe the remote WINS is coming up.  We should
                   //     // give it a chance to come up.  Let us sleep for
                   //     // some time.
                   //     //
                   //     Sleep(RETRY_TIME_INTVL);
                   //     NoOfRetries++;
                   //     continue;
                   //}

                   (VOID)InterlockedIncrement(&pPullCnfRecs->NoOfCommFails);


                   //
                   //  Only Communication failure exception is to
                   //  be  consumed.
                   //
                   //  We will retry at the next replication time.
                   //
                   // Note: the comparison operator needs to be <= and not
                   // < (this is required for the 0 retry case). If we
                   // use <, a timer request would be submitted for
                   // the WINS (by SubmitTimerReqs following GetReplicasNew
                   // in RplPullInit which will result in a retry.
                   //
                   if (pPullCnfRecs->RetryCount <= WinsCnf.PullInfo.MaxNoOfRetries)
                   {
                        pPullCnfRecs->RetryCount++;

                        //
                        // We will now retry at the next
                        // replication time.
                        //

CHECK("A retry time interval different than the replication time interval")
CHECK("could be used here.  Though this will complicate the code, it may")
CHECK("be a good idea to do it if the replication time interval is large")
CHECK("Alternatively, considering that we have already retried a certain")
CHECK("no. of times, we can put the onus on the administrator to trigger")
CHECK("replication.  I need to think this some more")

                   }
                   else  //max. no of retries done
                   {
                        WINSEVT_LOG_M(
                            WINS_FAILURE,
                            WINS_EVT_CONN_RETRIES_FAILED
                        );
                        DBGPRINT0(ERR, "Could not connect to WINS. All retries failed\n");
                   }

                    //
                    //  Go to the next configuration record based on the
                    //  value of the RecTrv_e flag
                    //
                    pPullCnfRecs = WinsCnfGetNextRplCnfRec(
                                                pPullCnfRecs,
                                                RecTrv_e
                                                      );
                    if (pPullCnfRecs == NULL)
                    {
                        break;  //break out of the for loop
                    }
                  }
                  else
                  {
                        //
                        // A non comm failure error is serious. It needs
                        // to be propagated up
                        //
                        WINS_RERAISE_EXC_M();
                  }
            }  //end of exception handler
         }  // end of for loop for looping over config records
         DBGLEAVE("EstablishComm\n");
         return;
}



VOID
HdlPushNtf(
        PQUE_RPL_REQ_WRK_ITM_T        pWrkItm
        )

/*++

Routine Description:

        This function is called to handle a push notification received from
        a remote WINS.

Arguments:
        pWrkItm - the work item that the Pull thread pulled from its queue

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        RplPullInit

Side Effects:

Comments:
        None
--*/

{
      BOOL                   fFound = FALSE;
      PUSHPNR_DATA_T         PushPnrData[1];
      DWORD                  OwnerId;
      DWORD                  i;
      VERS_NO_T              MinVersNo;
      VERS_NO_T              MaxVersNo;
      RPLMSGF_MSG_OPCODE_E   Opcode_e;
      BOOL                   fPulled = FALSE;
      BOOL                   fAllocNew;
#if SUPPORT612WINS > 0
      BOOL                   fIsPnrBeta1Wins;
#endif
      DWORD                  InitiatorWinsIpAdd;

#if PRSCONN
      BOOL                   fImplicitConnPrs;
      time_t                 CurrentTime;
      BOOL                   fDlgActive = TRUE;
      COMM_HDL_T             DlgHdl;
      PCOMM_HDL_T            pDlgHdl = &DlgHdl;
      PRPL_CONFIG_REC_T  pPnr;
#endif
      DWORD                  ExcCode = WINS_EXC_INIT;

      DBGENTER("HdlPushNtf - PULL thread\n");


#if SUPPORT612WINS > 0
      COMM_IS_PNR_BETA1_WINS_M(&pWrkItm->DlgHdl, fIsPnrBeta1Wins);
#endif
#if 0
      COMM_INIT_ADD_FROM_DLG_HDL_M(&PnrAdd, pWrkItm->DlgHdl);
#endif


      //
      // We want to pull all records starting from the min vers. no.
      //
      WINS_ASSIGN_INT_TO_VERS_NO_M(MaxVersNo, 0);

      //
      // Get the opcode from the message
      //
      RPLMSGF_GET_OPC_FROM_MSG_M(pWrkItm->pMsg, Opcode_e);

      //
      // Unformat the message to get the owner to version number maps
      //
      RplMsgfUfmAddVersMapRsp(
#if SUPPORT612WINS > 0
                         fIsPnrBeta1Wins,
#endif

                        pWrkItm->pMsg + 4,               //past the opcodes
                        &(PushPnrData[0].NoOfMaps),
                        &InitiatorWinsIpAdd,          //Wins that initiated
                                                      //the prop
                        &PushPnrData[0].pAddVers
                             );

      //
      // Free the buffer that carried the message. We don't need it anymore
      //
      ECommFreeBuff(pWrkItm->pMsg - COMM_HEADER_SIZE); //decrement to
                                                         // begining
                                                              //of buff


#if PRSCONN

      (VOID)time(&CurrentTime);
      //
      // We determine whether or not the partner has formed a persistent
      // connection with us from the opcode
      //
      fImplicitConnPrs = ((Opcode_e == RPLMSGF_E_UPDATE_NTF_PRS) || (Opcode_e == RPLMSGF_E_UPDATE_NTF_PROP_PRS));

FUTURES("When we start having persistent dialogues, we should check if we")
FUTURES("already have a dialogue with the WINS. If there is one, we should")
FUTURES("use that.  To find this out, loop over all Pull Config Recs to see")
FUTURES("if there is match (use the address as the search key")
      //
      // If the connection formed with us is persistent, get the
      // config record or the pnr.  Nobody can change the config
      // rec array except the current thread (pull thread)
      //
      if (fImplicitConnPrs)
      {


          if ((pPnr = RplGetConfigRec(RPL_E_PULL, &pWrkItm->DlgHdl,NULL)) != NULL)
          {
                   //
                   // if the pnr is not persistent for pulling  or if it
                   // is persistent but the dlg is invalid, start it. Store
                   // the dlg hdl in a temp var.
                   //
                   if ((!pPnr->fPrsConn)
                             ||
                        !ECommIsBlockValid(&pPnr->PrsDlgHdl)
                               ||
                          (((CurrentTime - pPnr->LastCommTime) > FIVE_MINUTES) &&
                          !(fDlgActive = ECommIsDlgActive(&pPnr->PrsDlgHdl))))
                   {

                     //
                     // If the dlg is inactive, end it so that we start from
                     // a clean slate.
                     //
                     if (!fDlgActive)
                     {
                        ECommEndDlg(&pPnr->PrsDlgHdl);
                     }
                     ECommStartDlg(
                                &pPnr->WinsAdd,
                                COMM_E_RPL,
                                pDlgHdl
                             );

                     if (pPnr->fPrsConn)
                     {
                        pPnr->PrsDlgHdl = *pDlgHdl;
                     }

                   }
                   else
                   {

                     pDlgHdl = &pPnr->PrsDlgHdl;
                   }
         }
         else
         {
                   //
                   // Apparently a window where a reconfig of this
                   // WINS caused the remote guy to be removed as a pull
                   // pnr.  This is a window because the push thread
                   // checks whether the remote guy is a pnr prior to
                   // handing the request to the pull thread. We will in
                   // this case just bail out
                   //
                   ASSERTMSG("window condition.  Pnr no longer there.  Did you reconfigure in the very recent past If yes, hit go, else log it", FALSE);
                   ECommEndDlg(&pWrkItm->DlgHdl);
                   DBGPRINT0(FLOW, "LEAVE: HdlPushNtf - PULL thread\n");
                   return;

         }
      }
      else
      {
               pDlgHdl = &pWrkItm->DlgHdl;
      }
#endif

      //
      // loop over all WINS address - Version number maps sent to us
      // by the remote client
      //
try {
      PRPL_ADD_VERS_NO_T pAddVers;

      // filter personas grata / non grata from the list of OwnerAddress<->VersionNo
      // given to us by the remote pusher
      FilterPersona(&(PushPnrData[0]));

      pAddVers = PushPnrData[0].pAddVers;

      // at this point all WINS in PushPnrData are allowed by the lists of personas grata/non-grata
      for (i=0; i < PushPnrData[0].NoOfMaps; i++, pAddVers++)
      {

            fAllocNew = TRUE;
                  RplFindOwnerId(
                    &pAddVers->OwnerWinsAdd,
                    &fAllocNew,        //allocate entry if not existent
                    &OwnerId,
                    WINSCNF_E_INITP_IF_NON_EXISTENT,
                    WINSCNF_LOW_PREC
                              );

            //
            // If the local WINS has older information than the remote
            // WINS, pull the new information.  Here we are comparing
            // the highest version number in the local db for a particular
            // WINS with the highest version number that the remote Pusher
            // has.  NOTE: if the map sent by the PULL PNR pertains to
            // self, it means that we went down and came up with a truncated
            // database (partners have replicas).  DON"T PULL these records
            //
            if (
                   (OwnerId != NMSDB_LOCAL_OWNER_ID)

               )
            {
                //
                // If the max. vers. number is less than or equal to
                // what we have, don't pull
                //
                if (LiLeq(
                        pAddVers->VersNo,
                        (pRplPullOwnerVersNo+OwnerId)->VersNo
                                   )
                )
                {
                        continue;       //check the next owner
                }


                NMSNMH_INC_VERS_NO_M(
                                (pRplPullOwnerVersNo+OwnerId)->VersNo,
                                MinVersNo
                                  );

                //
                // Pull Entries
                //
                RplPullPullEntries(
                        pDlgHdl,
                        OwnerId,
                        MaxVersNo,        //inited to 0
                        MinVersNo,
                        WINS_E_RPLPULL,
                        NULL,
                        TRUE,        //update counters
                        PtrToUlong (pWrkItm->pClientCtx)
                           );

                //
                // If atleast one valid record was pulled by WINS, sfPulled
                // will be set to TRUE.  Since this can get reset by the
                // next call to RplPullPullEntries, let us save it.
                //
                if (sfPulled)
                {
                        fPulled = TRUE;
                }

            }
     }  //end of for{} over all wins address - version # maps
} // end of try {}
except (EXCEPTION_EXECUTE_HANDLER) {
        ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "HdlPushNtf: Encountered exception %x\n", ExcCode);
        if (ExcCode == WINS_EXC_COMM_FAIL)
        {
                COMM_IP_ADD_T        RemoteIPAdd;
                COMM_GET_IPADD_M(&pWrkItm->DlgHdl, &RemoteIPAdd);
                DBGPRINT1(EXC, "HdlPushNtf: Communication Failure with Remote Wins having address = (%x)\n", RemoteIPAdd);
        }
        WINSEVT_LOG_M(ExcCode, WINS_EVT_EXC_PUSH_TRIG_PROC);
 }

    if (PushPnrData[0].NoOfMaps > 0)
    {
      WinsMscDealloc(PushPnrData[0].pAddVers);
    }

    //
    // If opcode indicates push propagation and we did pull atleast one
    // record from the WINS that sent us the Push notification, do the
    // propagation now.  We do not propagate to the guy who sent us
    // the trigger.
    //
    // Note: We never propagate if this update notification has made its way
    // back to us because of some loop.  We also don't propagate it if
    // we have been told not to by the admin.
    //
    if (((Opcode_e == RPLMSGF_E_UPDATE_NTF_PROP)
#if PRSCONN
             || (Opcode_e == RPLMSGF_E_UPDATE_NTF_PROP_PRS)
#endif
       ) && fPulled && !COMM_MY_IP_ADD_M(InitiatorWinsIpAdd) && (WinsCnf.PushInfo.PropNetUpdNtf == DO_PROP_NET_UPD_NTF))
    {
      COMM_ADD_T        WinsAdd;

      COMM_INIT_ADD_FR_DLG_HDL_M(&WinsAdd, &pWrkItm->DlgHdl);

      //
      // We need to synchronize with the NBT threads
      //
      EnterCriticalSection(&NmsNmhNamRegCrtSec);

      //
      // Check whether we have any PULL pnrs.  (We need to access WinsCnf
      // from within the NmsNmhNamRegCrtSec)
      //

      // We do this test here instead of in the RPL_PUSH_NTF_M macro to
      // localize the overhead to this function only.  Note: If the
      // Initiator WINS address is 0, it means that it is a Daytona WINS (not
      // a PPC release WINS).  In such a case, we put our own address.  This
      // has the advantage of stopping propagations in a loop of new WINSs if
      // they have gone around the loop once..
      //
      if (WinsCnf.PushInfo.NoOfPullPnrs != 0)
      {
        try
        {
           RPL_PUSH_NTF_M(
                        RPL_PUSH_PROP,
            (InitiatorWinsIpAdd == 0) ? ULongToPtr(NmsLocalAdd.Add.IPAdd) : ULongToPtr(InitiatorWinsIpAdd),
                        &WinsAdd,         //don't want to send to this guy.
                        NULL
                       );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
          DBGPRINTEXC("HdlPushNtf: Exception while propagating a trigger");
          WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_PUSH_PROP_FAILED);
        }
      }
      LeaveCriticalSection(&NmsNmhNamRegCrtSec);
    }

     //
     // End the dlg. The right dlg will get terminated.
     // Note: The dlg is explicit (if we establishd it) or implicit (established
     // by the remote client).
     //
     // So, if the remote connection is not persistent or if it is but we
     // the pnr is not persistent for pulling (meaning we established an
     // explicit connection with it, end the dlg.  pDlgHdl points to the right
     // dlg
     //
#if PRSCONN
     if (!fImplicitConnPrs || !pPnr->fPrsConn)
     {
        ECommEndDlg(pDlgHdl);
     }
     else
     {
         //
         // if we are here, it means that we pPnr is set to a Partner.  If
         // we had a comm. failure with it, we should end the Prs Dlg with
         // it.
         //
         if (ExcCode == WINS_EXC_COMM_FAIL)
         {
            ECommEndDlg(&pPnr->PrsDlgHdl);
         }

     }
#else
        ECommEndDlg(pDlgHdl);
#endif


     DBGPRINT0(FLOW, "LEAVE: HdlPushNtf - PULL thread\n");
     return;

}



STATUS
RegGrpRepl(
        LPBYTE                pName,
        DWORD                NameLen,
        DWORD                Flag,
        DWORD                OwnerId,
        VERS_NO_T        VersNo,
        DWORD                NoOfAdds,
        PCOMM_ADD_T        pNodeAdd,
        PCOMM_ADD_T        pOwnerWinsAdd
        )

/*++

Routine Description:
        This function is called to register a replica of a group entry

Arguments:


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:
        RplPullPullEntries

Side Effects:

Comments:
        None
--*/

{

        NMSDB_NODE_ADDS_T GrpMems;
        DWORD                  i;                //for loop counter
        DWORD                  n = 0;                //index into the NodeAdd array
        BYTE                  EntTyp;
        BOOL                  fAllocNew;
        STATUS            RetStat;
        GrpMems.NoOfMems = 0;

        DBGENTER("RegGrpRepl\n");
        EntTyp = (BYTE)NMSDB_ENTRY_TYPE_M(Flag);

        //
        // Check if it is a special group or a multihomed entry
        //
        if (EntTyp != NMSDB_NORM_GRP_ENTRY)
        {
CHECK("I think I have now stopped sending timed out records");
                //
                // If we did not get any member.  This can only mean that
                // all members of this group/multihomed entry have timed out
                // at the remote WINS.
                //
                if (NoOfAdds != 0)
                {
                        GrpMems.NoOfMems =  NoOfAdds;
                        for (i = 0; i < NoOfAdds; i++)
                        {
                                //
                                // The first address is the address of
                                // the WINS that is the owner of the
                                // member.
                                //
                                fAllocNew = TRUE;
                                RplFindOwnerId(
                                        &pNodeAdd[n++],
                                        &fAllocNew,  //assign if not there
                                        &GrpMems.Mem[i].OwnerId,
                                        WINSCNF_E_INITP_IF_NON_EXISTENT,
                                        WINSCNF_LOW_PREC
                                                    );

                                //
                                // The next address is the address of the
                                // member
                                //
                                GrpMems.Mem[i].Add = pNodeAdd[n++];
                        }
                }
#ifdef WINSDBG
                else  //no members
                {
                        if (NMSDB_ENTRY_STATE_M(Flag) != NMSDB_E_TOMBSTONE)
                        {
                                DBGPRINT0(EXC, "RegGrpRepl: The replica of a special group without any members is not a TOMBSTONE\n");
                                WINSEVT_LOG_M(
                                        WINS_FAILURE,
                                        WINS_EVT_RPL_STATE_ERR
                                             );
                                WINS_RAISE_EXC_M(WINS_EXC_RPL_STATE_ERR);
                        }
                }
#endif
        }
        else  // it is a normal group
        {
NOTE("On a clash with a special group, this owner id. will be stored which")
NOTE("can be misleading")
                GrpMems.NoOfMems       =  1;
                GrpMems.Mem[0].OwnerId = OwnerId;  //misleading (see ClashAtRegGrpRpl()
                                           //in nmsnmh.c - clash between normal
                                           //grp and special grp.
                GrpMems.Mem[0].Add     =  *pNodeAdd;
        }

        RetStat = NmsNmhReplGrpMems(
                        pName,
                        NameLen,
                        EntTyp,
                        &GrpMems,
                        Flag,
                        OwnerId,
                        VersNo,
                        pOwnerWinsAdd
                        );
        DBGLEAVE("RegGrpRepl\n");
        return(RetStat);
}

BOOL
IsTimeoutToBeIgnored(
        PQUE_TMM_REQ_WRK_ITM_T  pWrkItm
        )

/*++

Routine Description:
        This function is called to determine if the timeout that the
        PULL thread received needs to be ignored

Arguments:
        pWrkItm - Timeout work itm

Externals Used:
        None


Return Value:

        TRUE if the timeout needs to be ignored
        FALSE otherwise

Error Handling:

Called by:
        RplPullInit

Side Effects:

Comments:
        None
--*/

{
        BOOL                        fRetVal = FALSE;

try {
        //
        // If this is the timeout based on old config
        // ignore it.  If the old configuration memory blocks
        // have not been deallocated as yet, deallocate them
        //
        if (pWrkItm->MagicNo != RplPullCnfMagicNo)
        {
                //
                // Deallocate the work item and deallocate
                // the configuration block
                //
                WinsTmmDeallocReq(pWrkItm);
                fRetVal = TRUE;
        }
 }
except (EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("IsTimeoutToBeIgnored");
        WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_SFT_ERR);
 }
        return(fRetVal);
}
VOID
InitRplProcess(
        PWINSCNF_CNF_T        pWinsCnf
 )

/*++

Routine Description:
        This function is called to start the replication process.  This
        comprises of getting the replicas if the InitTimeRpl field
        is set to 1.  Timer requests are also submitted.

Arguments:
        pWinsCnf - pointer to the Wins Configuration structure

Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:
        RplPullInit()

Side Effects:

Comments:
        None
--*/

{
        PRPL_CONFIG_REC_T        pPullCnfRecs = pWinsCnf->PullInfo.pPullCnfRecs;
        BOOL                        fAllocNew;
        DWORD                        OwnerWinsId;
        STATUS                        RetStat;

        //
        // Initialize Owner-Id table with new entries if any
        //
        for (
                        ;
                pPullCnfRecs->WinsAdd.Add.IPAdd != INADDR_NONE;
                        //no third expression
            )
        {
                fAllocNew = TRUE;
                RetStat = RplFindOwnerId(
                                &pPullCnfRecs->WinsAdd,
                                &fAllocNew,
                                &OwnerWinsId,
                                WINSCNF_E_INITP,
                                pPullCnfRecs->MemberPrec
                                );

                if (RetStat == WINS_FAILURE)
                {
FUTURES("Improve error recovery")
                        //
                        // We have hit the limit. Break out of the loop
                        // but carry on in the hope that the situation
                        // will correct itself by the time we replicate.
                        // If InitTimeReplication is TRUE, there is no
                        // chance of the table entries getting freed up.
                        // Even if some entries get freed, when we make
                        // an entry for the WINS which we couldn't insert now,
                        // it will take LOW_PREC.
                        //
                        break;
                }
                pPullCnfRecs = WinsCnfGetNextRplCnfRec(
                                                pPullCnfRecs,
                                                RPL_E_IN_SEQ
                                                      );
        }

        //
        // Do init time replication if not prohibited by the config
        // info.
        //
        if (pWinsCnf->PullInfo.InitTimeRpl)
        {
                /*
                 * Pull replicas and handle them
                */
                GetReplicasNew(
                        pWinsCnf->PullInfo.pPullCnfRecs,
                        RPL_E_IN_SEQ        //records are in sequence
                                 );

        }
        //
        // For all Push partners with which replication has to be done
        // periodically, submit timer requests
        //
        SubmitTimerReqs(pWinsCnf->PullInfo.pPullCnfRecs);
        return;

} // InitRplProcess()


VOID
Reconfig(
        PWINSCNF_CNF_T        pWinsCnf
  )

/*++

Routine Description:
        This function is called to reconfigure the PULL handler

Arguments:
        pNewWinsCnf - New Configuration

Externals Used:
        None


Return Value:

        None
Error Handling:

Called by:
        RplPullInit when it gets the CONFIGURE message
Side Effects:

Comments:
        None
--*/

{
        BOOL    fNewInfo  = FALSE;
        BOOL    fValidReq = FALSE;
#if PRSCONN
        PRPL_CONFIG_REC_T pOldPnr, pNewPnr;
        DWORD i, n;
#endif

        DBGENTER("Reconfig (PULL)\n");

        //
        // synchronize with rpc threads and with the push thread
        //
        EnterCriticalSection(&WinsCnfCnfCrtSec);

try {

        //
        // Get the latest magic no (set by the main thread)
        //
            RplPullCnfMagicNo        = WinsCnfCnfMagicNo;

        //
        // If the latest magic no is not the same as the one
        // in this configuration block, we can ignore this
        // configuration request
        //
        if (WinsCnfCnfMagicNo == pWinsCnf->MagicNo)
        {
           fValidReq = TRUE;
           DBGPRINT1(RPLPULL, "Reconfig: Magic No (%d) match\n", WinsCnfCnfMagicNo);

           //
           // Initialize the Push records if required
           //
           // Note: NBT threads look at Push config
           // records after doing registrations.  Therefore
           // we should enter the critical section before
           // changing WinsCnf
           //
           EnterCriticalSection(&NmsNmhNamRegCrtSec);
           try {
                if (WinsCnf.PushInfo.pPushCnfRecs != NULL)
                {
#if PRSCONN
                   //
                   // Copy the statistics info
                   //
                   pOldPnr = WinsCnf.PushInfo.pPushCnfRecs;
                   for (i = 0; i < WinsCnf.PushInfo.NoOfPullPnrs; i++)
                   {
                      pNewPnr = pWinsCnf->PushInfo.pPushCnfRecs;
                      for (n=0; n < pWinsCnf->PushInfo.NoOfPullPnrs; n++)
                      {
                          if (pNewPnr->WinsAdd.Add.IPAdd == pOldPnr->WinsAdd.Add.IPAdd)
                          {
                               pNewPnr->LastCommFailTime = pOldPnr->LastCommFailTime;
                               pNewPnr->LastCommTime = pOldPnr->LastCommFailTime;
                               //
                               // If the partner stays persistent, init the dlg
                               // hdl.
                               //
                               if (pNewPnr->fPrsConn && (pNewPnr->fPrsConn == pOldPnr->fPrsConn))
                               {
                                   pNewPnr->PrsDlgHdl = pOldPnr->PrsDlgHdl;
                               }
                               else
                               {
                                   //
                                   // The partner was persistent but is no
                                   // longer so. Terminate the dlg
                                   //
                                   if (pOldPnr->fPrsConn)
                                   {
                                        ECommEndDlg(&pOldPnr->PrsDlgHdl);
                                   }

                               }
                               break;
                          }
                          pNewPnr = (PRPL_CONFIG_REC_T)((LPBYTE)pNewPnr + RPL_CONFIG_REC_SIZE);
                      }
                      pOldPnr = (PRPL_CONFIG_REC_T)((LPBYTE)pOldPnr + RPL_CONFIG_REC_SIZE);
                   }
#endif

                   WinsMscDealloc(WinsCnf.PushInfo.pPushCnfRecs);
                }

                WinsCnf.PushInfo = pWinsCnf->PushInfo;

               //
               // Initialize the push records
               //
               if (pWinsCnf->PushInfo.pPushCnfRecs != NULL)
               {
PERF("Do the following along with the stuff under PRSCONN")
                   RPLPUSH_INIT_PUSH_RECS_M(&WinsCnf);
               }
           }
           except(EXCEPTION_EXECUTE_HANDLER) {
                DBGPRINTEXC("Reconfig (PULL thread)");

                //
                // Log a message
                //
                WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RECONFIG_ERR);
             }
             LeaveCriticalSection(&NmsNmhNamRegCrtSec);

          //
          // We need to first get rid of all timer requests that
          // we made based on the previous configuration
          //
          if (WinsCnf.PullInfo.pPullCnfRecs != NULL)
          {
#if !PRSCONN
                PRPL_CONFIG_REC_T pOldPnr, pNewPnr;
                DWORD i, n;
#endif

                fNewInfo = TRUE;

                //
                // Cancel (and deallocate) all requests that we might have
                // submitted
                //
                WinsTmmDeleteReqs(WINS_E_RPLPULL);

                //
                // Copy the statistics info
                //
                pOldPnr = WinsCnf.PullInfo.pPullCnfRecs;
                for (i = 0; i < WinsCnf.PullInfo.NoOfPushPnrs; i++)
                {
                      pNewPnr = pWinsCnf->PullInfo.pPullCnfRecs;
                      for (n=0; n < pWinsCnf->PullInfo.NoOfPushPnrs; n++)
                      {
                          if (pNewPnr->WinsAdd.Add.IPAdd == pOldPnr->WinsAdd.Add.IPAdd)
                          {
                               pNewPnr->NoOfRpls      = pOldPnr->NoOfRpls;
                               pNewPnr->NoOfCommFails = pOldPnr->NoOfCommFails;
#if PRSCONN
                               pNewPnr->LastCommFailTime = pOldPnr->LastCommFailTime;
                               pNewPnr->LastCommTime = pOldPnr->LastCommFailTime;
                               //
                               // If the partner stays persistent, init the dlg
                               // hdl.
                               //
                               if (pNewPnr->fPrsConn && (pNewPnr->fPrsConn == pOldPnr->fPrsConn))
                               {
                                   pNewPnr->PrsDlgHdl = pOldPnr->PrsDlgHdl;
                               }
                               else
                               {
                                   //
                                   // The partner was persistent but is no
                                   // longer so. Terminate the dlg
                                   //
                                   if (pOldPnr->fPrsConn)
                                   {
                                        ECommEndDlg(&pOldPnr->PrsDlgHdl);
                                   }

                               }
#endif
                               break;
                          }
                          pNewPnr = (PRPL_CONFIG_REC_T)((LPBYTE)pNewPnr + RPL_CONFIG_REC_SIZE);
                      }
                      pOldPnr = (PRPL_CONFIG_REC_T)((LPBYTE)pOldPnr + RPL_CONFIG_REC_SIZE);
                }

                //
                // Deallocate the memory holding the pull configuration blocks
                //
                //
                WinsMscDealloc(WinsCnf.PullInfo.pPullCnfRecs);
          }

          //
          // Initialize with the new information
          //
          WinsCnf.PullInfo    = pWinsCnf->PullInfo;

     }
#ifdef WINSDBG
     else
     {
           DBGPRINT2(RPLPULL, "Reconfig: Magic Nos different. WinsCnfCnfMagicNo=(%d), pWinsCnf->MagicNo = (%d)\n", WinsCnfCnfMagicNo, pWinsCnf->MagicNo);
     }
#endif

   }
except(EXCEPTION_EXECUTE_HANDLER) {
        DBGPRINTEXC("Reconfig: Pull Thread");
        }

        //
        // synchronize with rpc threads doing WinsStatus/WinsTrigger
        //
        LeaveCriticalSection(&WinsCnfCnfCrtSec);

        if (fValidReq)
        {
          if (WinsCnf.pPersonaList != NULL)
          {
                 WinsMscDealloc(WinsCnf.pPersonaList);
          }
          WinsCnf.fPersonaGrata = pWinsCnf->fPersonaGrata;
          WinsCnf.NoOfPersona  = pWinsCnf->NoOfPersona;
          WinsCnf.pPersonaList = pWinsCnf->pPersonaList;

          //
          // Start the replication process if there are PULL records
          // in the new configuration
          //
          if (WinsCnf.PullInfo.pPullCnfRecs != NULL)
          {
                InitRplProcess(&WinsCnf);
          }
        }

        //
        // Deallocate the new config structure
        //
        WinsCnfDeallocCnfMem(pWinsCnf);

        DBGLEAVE("Reconfig (PULL)\n");
        return;
} // Reconfig()

VOID
AddressChangeNotification(
        PWINSCNF_CNF_T        pWinsCnf
  )

/*++

Routine Description:
        This function is called to handle address change of the local
        machine.

Arguments:
        pNewWinsCnf - New Configuration

Externals Used:
        None


Return Value:

        None
Error Handling:

Side Effects:

Comments:
        None
--*/

{
    DBGENTER("AddressChangeNotification\n");
    //
    // if our address has changed, the following routine
    // will reinitialize the owner address table with own address
    //

    InitOwnAddTbl();
    DBGLEAVE("AddressChangeNotification\n");
        return;
} // AddressChangeNotification()

VOID
PullSpecifiedRange(
        PCOMM_HDL_T                 pDlgHdl,
        PWINSINTF_PULL_RANGE_INFO_T pPullRangeInfo,
        BOOL                        fAdjustMin,
        DWORD                       RplType
        )

/*++

Routine Description:
        This function is called to pull a specified range of records from
        a remote WINS server

Arguments:


Externals Used:
        None

Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{

        PUSHPNR_DATA_T       PushPnrData[1];
        DWORD                NoOfPushPnrs = 1;
        DWORD                OwnerId;
        BOOL                 fEnterCrtSec = FALSE;
        PRPL_CONFIG_REC_T    pPnr = pPullRangeInfo->pPnr;
        COMM_ADD_T           OwnAdd;
        BOOL                 fAllocNew = TRUE;
        PPUSHPNR_DATA_T      pPushPnrData = PushPnrData;

        //
        // Establish communications with the Push Pnr
        //
        // When this function returns, the 'NoOfPushPnrs' entries of
        // PushPnrData array will be initialized.
        //
        if (pDlgHdl == NULL)
        {
           EstablishComm(
                        pPnr,
                        FALSE,
                        &pPushPnrData,
                        RPL_E_NO_TRAVERSAL,
                        &NoOfPushPnrs
                     );
        }
        else
        {
               PushPnrData[0].DlgHdl = *pDlgHdl;
        }


try {

        //
        // if communication could be established above, NoOfPushPnrs will
        // be 1
        //
        if (NoOfPushPnrs == 1)
        {
          //
          // Get owner id. of WINS whose entries are to be pulled
          //
          OwnAdd.AddTyp_e                = pPullRangeInfo->OwnAdd.Type;
          OwnAdd.AddLen                = pPullRangeInfo->OwnAdd.Len;
          OwnAdd.Add.IPAdd        = pPullRangeInfo->OwnAdd.IPAdd;

PERF("for the case where pDlgHdl != NULL, the Owner Id is 0. See GetReplicasNew->ConductChkNew")
PERF("We could make use of that to go around the RplFindOwnerId call")

          (VOID)RplFindOwnerId(
                        &OwnAdd,
                        &fAllocNew,//allocate a new entry if WINS is not found
                        &OwnerId,
                        WINSCNF_E_INITP_IF_NON_EXISTENT,
                        WINSCNF_LOW_PREC
                      );
          //
          // if a new entry was not allocated, it means that there are
          // records for this owner in the database.  We might have to
          // delete some or all.
          //
          // If the local WINS owns the records, enter the critical section
          // so that NmsNmhMyMaxVersNo is not changed by Nbt or Rpl threads
          // while we are doing our work here
          //
          if (!fAllocNew)
          {
            if (OwnerId == NMSDB_LOCAL_OWNER_ID)
            {
                //
                // See NOTE NOTE NOTE below.
                //
                EnterCriticalSection(&NmsNmhNamRegCrtSec);
                fEnterCrtSec = TRUE;

                //
                // If we have not been told to adjust the min. vers. no,
                // delete all records that have a version number greater
                // than the minimum to be pulled
                //
                if (LiLtr(pPullRangeInfo->MinVersNo, NmsNmhMyMaxVersNo))
                {
                      if (!fAdjustMin)
                      {
                        NmsDbDelDataRecs(
                                OwnerId,
                                pPullRangeInfo->MinVersNo,
                                pPullRangeInfo->MaxVersNo,
                                FALSE,                //do not enter critical section
                                FALSE          //one shot deletion
                                        );
                      }
                      else
                      {
                           pPullRangeInfo->MinVersNo = NmsNmhMyMaxVersNo;
                      }
                }

            }
            else//records to be pulled are owned by some other WINS server
            {
                if (LiLeq(pPullRangeInfo->MinVersNo,
                                (pRplPullOwnerVersNo+OwnerId)->VersNo))
                {
                        NmsDbDelDataRecs(
                                OwnerId,
                                pPullRangeInfo->MinVersNo,
                                pPullRangeInfo->MaxVersNo,
                                TRUE,                  //enter critical section
                                FALSE           //one shot deletion
                                        );
                }
            }
         }


          //
          // Pull Entries.
          //
          // NOTE NOTE NOTE
          //
          // RplPullPullEntries will update NmsNmhMyMaxVersNo counter if
          // we pull our own records with the highest version number being
          // pulled being > NmsNmhMyMaxVersNo.  For the above case,
          // RplPullPullEntries assumes that we are inside the
          // NmsNmhNamRegCrtSec critical section.
          //
          if (LiGeq(pPullRangeInfo->MaxVersNo, pPullRangeInfo->MinVersNo))
          {
            RplPullPullEntries(
                   &PushPnrData[0].DlgHdl,
                   OwnerId,                        //owner id
                   pPullRangeInfo->MaxVersNo,  //Max vers. no to be pulled
                   pPullRangeInfo->MinVersNo,  //Min vers. no to be pulled
                   WINS_E_RPLPULL,
                   NULL,
                   FALSE,        //don't update RplOwnAddTblVersNo counters
                                //unless pulled version number is > what
                                //we currently have.
                   RplType
                              );
         }
        } // end of if (NoOfPushPnrs == 1)
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "PullSpecifiedRange: Got exception %x",  ExcCode);
        WINSEVT_LOG_M(ExcCode, WINS_EVT_PULL_RANGE_EXC);
 }

        if (fEnterCrtSec)
        {
                //
                // The following assumes that we enter the critical section
                // in this function only when pulling our own records.  This
                // is true currently.
                // If the min. vers. no. specified for pulling is <
                // the Min. for scavenging, adjust the min. for scavenging.
                // Note: We may not have pulled this minimum but we adjust
                // the min. for scavenging regardless.  This is to save
                // the overhead that would exist if we were to adopt the
                // approach of having RplPullPullEntries do the same (we
                // would need to pass an arg. to it; Note: This function
                // will be used in rare situations by an admin.
                //
                // We need to synchronize with the Scavenger thread.
                //
                if (LiGtr(NmsScvMinScvVersNo, pPullRangeInfo->MinVersNo))
                {
                        NmsScvMinScvVersNo = pPullRangeInfo->MinVersNo;
                }
                        LeaveCriticalSection(&NmsNmhNamRegCrtSec);
        }

        if (pPnr->fTemp)
        {
                WinsMscDealloc(pPullRangeInfo->pPnr);
        }


        if (pDlgHdl == NULL)
        {
#if PRSCONN
           if (!PushPnrData[0].fPrsConn)
           {
             //
             // End the dialogue
             //
             ECommEndDlg(&PushPnrData[0].DlgHdl);
           }
#else

           ECommEndDlg(&PushPnrData[0].DlgHdl);
#endif
        }

        return;

} //PullSpecifiedRange()


STATUS
RplPullRegRepl(
        LPBYTE                pName,
        DWORD                NameLen,
        DWORD                Flag,
        DWORD                OwnerId,
        VERS_NO_T        VersNo,
        DWORD                NoOfAdds,
        PCOMM_ADD_T        pNodeAdd,
        PCOMM_ADD_T        pOwnerWinsAdd,
        DWORD           RplType
        )

/*++

Routine Description:
        This function is called to register a replica.

Arguments:


Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        It is called by RplPullPullEntries and by ChkConfNUpd in nmsscv.c
--*/

{
       STATUS RetStat;

try {
           //
           // If this is a unique replica, call NmsNmhReplRegInd
           //
           if (NMSDB_ENTRY_TYPE_M(Flag) == NMSDB_UNIQUE_ENTRY)
           {
                //
                // If only spec. grps and pdc name are to be replicated and
                // this name is not a pdc name, skip it
                //
#if 0
                if ((RplType & WINSCNF_RPL_SPEC_GRPS_N_PDC)
                   && (!NMSDB_IS_IT_PDC_NM_M(pName)))
                {
                       DBGPRINT1(RPLPULL, "RplPullRegRepl: Ignoring unique record - name = (%s)\n", pName);
                       return(WINS_SUCCESS);
                }
#endif

                RetStat = NmsNmhReplRegInd(
                                pName,
                                NameLen,
                                pNodeAdd,
                                Flag,
                                OwnerId,
                                VersNo,
                                pOwnerWinsAdd  //add. of WINS owning the record
                                   );
           }
           else  // it is either a normal or a special group or a multihomed
                 // entry
           {
#if 0
                if ((RplType & WINSCNF_RPL_SPEC_GRPS_N_PDC)
                                     &&
                   (!NMSDB_ENTRY_SPEC_GRP_M(NMSDB_ENTRY_TYPE_M(Flag))))
                {
                       DBGPRINT1(RPLPULL, "RplPullRegRepl: Ignoring non-SG record - name = (%s)\n", pName);
                       return(WINS_SUCCESS);
                }
#endif
                RetStat = RegGrpRepl(
                           pName,
                           NameLen,
                           Flag,
                           OwnerId,
                           VersNo,
                           NoOfAdds,
                           pNodeAdd,
                           pOwnerWinsAdd  //add. of WINS owning the record
                          );
           }
}
except(EXCEPTION_EXECUTE_HANDLER) {
        DWORD ExcCode = GetExceptionCode();
        DBGPRINT1(EXC, "RplPullRegRepl: Got Exception %x", ExcCode);
    WINSEVT_LOG_M(GetExceptionCode(), WINS_EVT_RPLPULL_EXC);
    RetStat = WINS_FAILURE;
        }

        if (RetStat == WINS_FAILURE)
        {
            WinsEvtLogDetEvt(FALSE, NMSDB_ENTRY_TYPE_M(Flag) == NMSDB_UNIQUE_ENTRY ? WINS_EVT_RPL_REG_UNIQUE_ERR : WINS_EVT_RPL_REG_GRP_MEM_ERR,
               NULL, __LINE__, "sddd", pName,
               pOwnerWinsAdd->Add.IPAdd,
               VersNo.LowPart, VersNo.HighPart);

                WINSEVT_LOG_M(pNodeAdd->Add.IPAdd, WINS_EVT_RPL_REG_ERR);

             //
             // If WINS has been directed to continue replication on error,
             // change RetStat to fool the caller into thinking that
             // the replica registration was successful.
             //
             if (!WinsCnf.fNoRplOnErr)
             {
                   RetStat = WINS_SUCCESS;
             }
        }
        return(RetStat);
} // RplPullRegRepl()


VOID
DeleteWins(
        PCOMM_ADD_T        pWinsAdd
  )

/*++

Routine Description:
        This function deletes all records belonging to a WINS.  It
        also removes the entry of the WINS from the Owner-Add database
        table.  It marks the entry as deleted in the in-memory table so
        that it can be reused if need be.

Arguments:
        pWinsAdd - Address of WINS whose entry is to be removed

Externals Used:
        None


Return Value:
        None

Error Handling:

Called by:

Side Effects:

Comments:
        None
--*/
{
   BOOL           fAllocNew = FALSE;
   DWORD   OwnerId;
   STATUS  RetStat;
   DWORD   fEnterCrtSec = FALSE;
   DWORD ExcCode = WINS_SUCCESS;

   //
   // Find the owner id of the WINS. If the WINS is not in the table
   // return
   //
   RetStat = RplFindOwnerId(
                                pWinsAdd,
                                &fAllocNew,
                                &OwnerId,
                                WINSCNF_E_IGNORE_PREC,
                                WINSCNF_LOW_PREC
                            );

   if (RetStat == WINS_SUCCESS)
   {
        if (OwnerId == NMSDB_LOCAL_OWNER_ID)
        {
                //
                // We always keep the entry for the local WINS.
                //
                DBGPRINT0(ERR, "DeleteWins: Sorry, you can not delete the local WINS\n");
                //WINSEVT_LOG_M(WINS_FAILURE, WINS_EVT_DELETE_LOCAL_WINS_DISALLOWED);
        }
        else
        {
                VERS_NO_T        MinVersNo;
                VERS_NO_T        MaxVersNo;
                WINSEVT_STRS_T  EvtStrs;
                WCHAR           String[WINS_MAX_NAME_SZ];
                struct in_addr  InAddr;

                InAddr.s_addr = htonl(pWinsAdd->Add.IPAdd);
                (VOID)WinsMscConvertAsciiStringToUnicode(
                            inet_ntoa( InAddr),
                            (LPBYTE)String,
                            WINS_MAX_NAME_SZ);

                EvtStrs.NoOfStrs = 1;
                EvtStrs.pStr[0]  = String;
                WINSEVT_LOG_INFO_STR_D_M(WINS_EVT_DEL_OWNER_STARTED, &EvtStrs);

                WINS_ASSIGN_INT_TO_VERS_NO_M(MinVersNo, 0);
                WINS_ASSIGN_INT_TO_VERS_NO_M(MaxVersNo, 0);


                //
                // Need to synchronize with NBT threads or rpc threads that
                // might be modifying these records. NmsDelDataRecs will
                // enter the critical section
                //
#if 0
                EnterCriticalSection(&NmsNmhNamRegCrtSec);
#endif

        try {
                //
                // Delete all records
                //
                RetStat = NmsDbDelDataRecs(
                                OwnerId,
                                MinVersNo,
                                MaxVersNo,
                                TRUE,               //enter critical section
                                TRUE         //fragmented deletion
                                        );

                //
                // If all records were deleted, mark entry as deleted.
                //
                if (RetStat == WINS_SUCCESS)
                {
                        EnterCriticalSection(&RplVersNoStoreCrtSec);
                        WINS_ASSIGN_INT_TO_LI_M((pRplPullOwnerVersNo+OwnerId)->VersNo, 0);
                        LeaveCriticalSection(&RplVersNoStoreCrtSec);

                        //
                        // Delete the entry for the WINS from the db table
                        // and mark WINS as deleted in the in-memory table.
                        //
                        // This way, we will free up entries in the table.
                        //
                        EnterCriticalSection(&NmsDbOwnAddTblCrtSec);
                        fEnterCrtSec = TRUE;
                        (pNmsDbOwnAddTbl+OwnerId)->WinsState_e =  NMSDB_E_WINS_DELETED;
                        //
                        // Delete entry from the owner-Add table
                        //
                        NmsDbWriteOwnAddTbl(
                                NMSDB_E_DELETE_REC,
                                OwnerId,
                                NULL,
                                NMSDB_E_WINS_DELETED,
                                NULL,
                                NULL
                                        );

                }
                else
                {
                      DBGPRINT2(ERR, "DeleteWins: Could not delete one or more records of WINS with owner Id = (%d) and address = (%x)\n", OwnerId,
pWinsAdd->Add.IPAdd);
                }
           } //end of try
           except(EXCEPTION_EXECUTE_HANDLER) {
               ExcCode = GetExceptionCode();
               DBGPRINT1(EXC, "DeleteWins: Got Exception (%x)\n", ExcCode);
               RetStat = WINS_FAILURE;
           } // end of exception handler

          if (fEnterCrtSec)
          {
                  LeaveCriticalSection(&NmsDbOwnAddTblCrtSec);
          }

          if (RetStat == WINS_FAILURE)
          {
               //
               // There is no danger of pWinsAdd being NULL. See WinsDeleteWins
               //
               WinsEvtLogDetEvt(FALSE, WINS_EVT_COULD_NOT_DELETE_WINS_RECS,
                 NULL, __LINE__, "dd", pWinsAdd->Add.IPAdd,
                 ExcCode );

               //
               // Since we are leaving the database in an inconsistent state,
               // mark the WINS as inconsistent
               //
               (pNmsDbOwnAddTbl+OwnerId)->WinsState_e =  NMSDB_E_WINS_INCONSISTENT;

          } else {
              WINSEVT_LOG_INFO_STR_D_M(WINS_EVT_DEL_OWNER_COMPLETED, &EvtStrs);
          }

      }  // end of else
   } // end of if (WINS is in own-add table)

   //
   // deallocate the buffer
   //
   WinsMscDealloc(pWinsAdd);
   return;
}

BOOL
AcceptPersona(
  PCOMM_ADD_T  pWinsAdd
 )
/*++
Routine Description:
   Accept a persona in either of the two situations:
   - PersonaType setting points to 'Persona Grata list', the list exists and
     the address is in the list.
   - PersonaType setting points to 'Persona Non-Grata list' and either the list
     doesn't exist or the address is not there.
   Side effects:
   - If none of the two settings is defined (PersonaType & PersonaList)
     this is like a non-existant 'Persona Non-Grata list' which means all WINS 
     will be accepted.
   - If only PersonaType exists and it says 'Persona Grata list' this is like
     a non-existant Persona Grata list hence no WINS will be accepted!
Arguments:
   pWinsAdd - address of the WINS to check
Return Value:
   TRUE if the WINS pWinsAdd is a persona grata/non-grata (depending on fGrata),
   FALSE otherwise
Called by:
   FilterPersona()
--*/
{
    PRPL_ADD_VERS_NO_T pPersona = NULL;

    DBGPRINT1(RPLPULL, "AcceptPersona check for address=(%x)\n", pWinsAdd->Add.IPAdd);

    // if the list exists, look for the address in it
    if (WinsCnf.pPersonaList != NULL)
        pPersona = bsearch(
                      pWinsAdd,
                      WinsCnf.pPersonaList,
                      (size_t)WinsCnf.NoOfPersona,
                      sizeof(COMM_ADD_T),
                      ECommCompareAdd);;

    if (WinsCnf.fPersonaGrata)
        // if the list is 'persona grata', the address has to be there in order to 
        // be accepted.
        return (pPersona != NULL);
    else
        // otherwise, WINS is accepted if either the list doesn't exist or the address
        // is not there
        return (pPersona == NULL);
}

VOID
FilterPersona(
  PPUSHPNR_DATA_T   pPushData
  )
/*++
Routine Description:
    Filters out from the PUSHPNR_DATA_T structure those OwnerAddress<->VersionNo mappings
    that are denied by persona grata/non-grata list. This routine adjustes from that structure
    only the NoOfMaps field and moves around elements in the array pointed by pAddVers
    (bubbling up the ones that are accepted).
Arguments:
    pPushData - pointer to the PUSHPNR_DATA_T providing the mapping table
Called by:
    HdlPushNtf
--*/
{
    DWORD i, newNoOfMaps;
    PRPL_ADD_VERS_NO_T pAddVers = pPushData->pAddVers;

    // in most common case, none of 'PersonaType' or 'PersonaList' is defined. This means
    // we deny no WINS so we don't need to filter anything - then get out right away.
    if (!WinsCnf.fPersonaGrata && WinsCnf.pPersonaList == NULL)
        return;

    for (i = 0, newNoOfMaps = 0; i < pPushData->NoOfMaps; i++)
    {
        if (AcceptPersona(&(pAddVers[i].OwnerWinsAdd)))
        {
            // if the decision is to accept this WINS, move it to the top of the list
            // over the ones that were rejected. If none was rejected yet, no memory
            // operation is performed.
            if (newNoOfMaps < i)
            {
                memcpy(&pAddVers[newNoOfMaps], &pAddVers[i], sizeof(RPL_ADD_VERS_NO_T));
            }

            // since this wins was accepted, increment the counter of accepted wins.
            newNoOfMaps++;
        }
    }

    // only the first newNoOfMaps have to be considered from now on
    pPushData->NoOfMaps = newNoOfMaps;

    // just in case no WINS was accepted, cleanup the pAddVers array
    if (pPushData->NoOfMaps == 0 && pPushData->pAddVers != NULL)
    {
        WinsMscDealloc(pPushData->pAddVers);
        pPushData->pAddVers = NULL;
    }
}

VOID
RplPullAllocVersNoArray(
      PRPL_VERS_NOS_T *ppRplOwnerVersNo,
      DWORD          CurrentNo
     )
{

        if (*ppRplOwnerVersNo != NULL)
        {
          DWORD MemSize = sizeof(RPL_VERS_NOS_T) * (CurrentNo + 100);
          WINSMSC_REALLOC_M( MemSize,  (LPVOID *)ppRplOwnerVersNo );
        }
        else
        {
          DWORD MemSize = sizeof(RPL_VERS_NOS_T) * (CurrentNo + 100);
          WinsMscAlloc(
                    MemSize,
                    (LPVOID *)ppRplOwnerVersNo
                    );

        }
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\cluster.h ===
#ifndef WLBSCLUSTER_H
#define WLBSCLUSTER_H

#include "wlbsconfig.h"


class CWlbsControl;

//+----------------------------------------------------------------------------
//
// class CWlbsCluster
//
// Description:  This class is exported to perform cluster configuration,
//
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------

class __declspec(dllexport) CWlbsCluster
{
public:
    CWlbsCluster(DWORD dwConfigIndex);

    DWORD GetClusterIp() {return m_this_cl_addr;} 
    DWORD GetHostID() {return m_this_host_id;}
    DWORD GetDedicatedIp() {return m_this_ded_addr;}

    bool Initialize(const GUID& AdapterGuid);
    bool ReInitialize();

    DWORD ReadConfig(PWLBS_REG_PARAMS reg_data);   // read the config from registry
    DWORD WriteConfig(const PWLBS_REG_PARAMS reg_data);

    DWORD CommitChanges(CWlbsControl* pWlbsControl);
    bool  IsCommitPending() const {return m_reload_required;}  // whether changes are commited

    const GUID& GetAdapterGuid() { return m_AdapterGuid;}

    DWORD GetPassword();

    DWORD GetClusterIpOrIndex(CWlbsControl* pControl);

public:
    DWORD m_dwConfigIndex; // unique index for the cluster

protected:
	// Cluser IP of this adapter. Reflect the value in driver instead of registry.  
	// The value does not change, if WriteConfig is called but Commint is not called.
	// See bug 162812 162854
    DWORD        m_this_cl_addr;   
    
    DWORD        m_this_host_id; // Host ID of the cluster.  Reflect the value in driver instead of registry
    DWORD        m_this_ded_addr;  // Dedicated IP of this adapter
    
    WLBS_REG_PARAMS  m_reg_params; // original settings

    GUID		 m_AdapterGuid;

    bool         m_notify_adapter_required;  // whether we need to reload the nic driver
    bool         m_reload_required;  // set if change in registry need to be picked by wlbs driver
};

#endif // WLBSCLUSTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\cluster.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cluster.cpp
//
// Module:   WLBS API
//
// Description: Implement class CWlbsCluster
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:   Created    3/9/00
//
//+----------------------------------------------------------------------------
#include "precomp.h"

#include <debug.h>
#include "cluster.h"
#include "control.h"
#include "param.h"
#include "cluster.tmh" // For event tracing


CWlbsCluster::CWlbsCluster(DWORD dwConfigIndex)
{
    m_reload_required = false;
    m_notify_adapter_required = false;
    m_this_cl_addr    = 0;
    m_this_host_id  = 0;
    m_this_ded_addr   = 0;
    m_dwConfigIndex = dwConfigIndex;
}


//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::ReadConfig
//
// Description:  Read cluster settings from registry
//
// Arguments: PWLBS_REG_PARAMS reg_data - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsCluster::ReadConfig(PWLBS_REG_PARAMS reg_data)
{
    TRACE_VERB("->%!FUNC!");

    if (ParamReadReg(m_AdapterGuid, reg_data) == false)
    {
        TRACE_VERB("<-%!FUNC! return %d", WLBS_REG_ERROR);
        return WLBS_REG_ERROR;
    }

    /* create a copy in the old_params structure. this will be required to
     * determine whether a reload is needed or a reboot is needed for commit */

    memcpy ( &m_reg_params, reg_data, sizeof (WLBS_REG_PARAMS));

//    m_this_cl_addr = IpAddressFromAbcdWsz(m_reg_params.cl_ip_addr);
    m_this_ded_addr = IpAddressFromAbcdWsz(m_reg_params.ded_ip_addr);
    
    TRACE_VERB("<-%!FUNC! return %d", WLBS_OK);
    return WLBS_OK;
} 


//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::GetClusterIpOrIndex
//
// Description:  Get the index or IP of the cluster.  If the cluster IP is non-zero
//              The IP is return.
//              If the cluster IP is 0, the index is returned
//
// Arguments: CWlbsControl* pControl - 
//
// Returns:   DWORD - 
//
// History: fengsun  Created Header    7/3/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsCluster::GetClusterIpOrIndex(CWlbsControl* pControl)
{
    TRACE_VERB("->%!FUNC!");

    DWORD dwIp = CWlbsCluster::GetClusterIp();

    if (dwIp!=0)
    {
        //
        // Return the cluster IP if non 0
        //
        TRACE_VERB("<-%!FUNC! return %d", dwIp);
        return dwIp;
    }

    if (pControl->GetClusterNum() == 1)
    {
        //
        // For backward compatibility, return 0 if only one cluster exists
        //

        TRACE_VERB("<-%!FUNC! return 0");
        return 0;
    }

    //
    // Ip address is in the reverse order
    //
    dwIp = (CWlbsCluster::m_dwConfigIndex) <<24;
    TRACE_VERB("<-%!FUNC! returning IP address in reverse order %d", dwIp);
    return dwIp;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::WriteConfig
//
// Description:  Write cluster settings to registry
//
// Arguments: WLBS_REG_PARAMS* reg_data - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsCluster::WriteConfig(WLBS_REG_PARAMS* reg_data)
{
    TRACE_VERB("->%!FUNC!");
    DWORD Status;

    Status = ParamWriteConfig(m_AdapterGuid, reg_data, &m_reg_params, &m_reload_required, &m_notify_adapter_required);

    TRACE_VERB("<-%!FUNC! return %d", Status);
    return Status;
}


//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::CommitChanges
//
// Description:  Notify wlbs driver or nic driver to pick up the changes
//
// Arguments: CWlbsControl* pWlbsControl - 
//
// Returns:   DWORD - 
//
// History: fengsun  Created Header    7/6/00
//          chrisdar  07.31.01  Modified adapter notification code to not disable
//                              and enable the NIC. Just do property change now.
//          KarthicN 08/28/01 Moved contents over to ParamCommitChanges
//
//+----------------------------------------------------------------------------
DWORD CWlbsCluster::CommitChanges(CWlbsControl* pWlbsControl)
{

    TRACE_VERB("->%!FUNC!");
    DWORD Status;

    ASSERT(pWlbsControl);
    Status = ParamCommitChanges(m_AdapterGuid, 
                                pWlbsControl->GetDriverHandle(), 
                                m_this_cl_addr, 
                                m_this_ded_addr, 
                                &m_reload_required,
                                &m_notify_adapter_required);

    TRACE_VERB("<-%!FUNC! return %d", Status);
    return Status;
}




//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::Initialize
//
// Description:  Initialization
//
// Arguments: const GUID& AdapterGuid - 
//
// Returns:   bool - true if succeeded
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
bool CWlbsCluster::Initialize(const GUID& AdapterGuid)
{
    TRACE_VERB("->%!FUNC!");

    m_AdapterGuid = AdapterGuid;
    m_notify_adapter_required = false;
    m_reload_required = false;

    ZeroMemory (& m_reg_params, sizeof (m_reg_params));

    if (!ParamReadReg(m_AdapterGuid, &m_reg_params))
    {
        TRACE_CRIT("%!FUNC! ParamReadReg failed");
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }

    m_this_cl_addr = IpAddressFromAbcdWsz(m_reg_params.cl_ip_addr);
    m_this_ded_addr = IpAddressFromAbcdWsz(m_reg_params.ded_ip_addr);
    m_this_host_id = m_reg_params.host_priority;
    
    TRACE_VERB("->%!FUNC! return true");
    return true;
}



//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::ReInitialize
//
// Description:  Reload settings from registry
//
// Arguments: 
//
// Returns:   bool - true if succeeded
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
bool CWlbsCluster::ReInitialize()
{
    TRACE_VERB("->%!FUNC!");

    if (ParamReadReg(m_AdapterGuid, &m_reg_params) == false)
    {
        TRACE_CRIT("!FUNC! failed reading nlb registry parameters");
        TRACE_VERB("<-%!FUNC! return false");
        return false;
    }

    //
    // Do not change the ClusterIP if the changes has not been commited
    //
    if (!IsCommitPending())
    {
        m_this_cl_addr = IpAddressFromAbcdWsz(m_reg_params.cl_ip_addr);
        m_this_host_id = m_reg_params.host_priority;
    }
    
    m_this_ded_addr = IpAddressFromAbcdWsz(m_reg_params.ded_ip_addr);
    
    TRACE_VERB("<-%!FUNC! return true");
    return true;
} 

//+----------------------------------------------------------------------------
//
// Function:  CWlbsCluster::GetPassword
//
// Description:  Get remote control password for this cluster
//
// Arguments: 
//
// Returns:   DWORD - password
//
// History:   fengsun Created Header    2/3/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsCluster::GetPassword()
{
    TRACE_VERB("->%!FUNC!");

    HKEY  key = NULL;
    LONG  status;
    DWORD dwRctPassword = 0;

    if (!(key = RegOpenWlbsSetting(m_AdapterGuid, true)))
    {
        TRACE_CRIT("%!FUNC! RegOpenWlbsSetting failed");
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }
    
    DWORD size = sizeof(dwRctPassword);
    status = RegQueryValueEx (key, CVY_NAME_RCT_PASSWORD, 0L, NULL,
                              (LPBYTE) & dwRctPassword, & size);
    if (status != ERROR_SUCCESS)
    {
        dwRctPassword = CVY_DEF_RCT_PASSWORD;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d", CVY_NAME_RCT_PASSWORD, status);
    }

    status = RegCloseKey(key);
    if (ERROR_SUCCESS != status)
    {
        TRACE_CRIT("%!FUNC! registry close failed with %d", status);
    }

    TRACE_VERB("<-%!FUNC!");
    return dwRctPassword;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\control.cpp ===
//+----------------------------------------------------------------------------
//
// File:         control.cpp
//
// Module:       
//
// Description: Implement class CWlbsControl
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:       Created    3/2/00
//
//+----------------------------------------------------------------------------

#include "precomp.h"

#include <debug.h>
#include "notification.h"
#include "cluster.h"
#include "control.h"
#include "param.h"
#include "control.tmh" // for event tracing

//
// Used only by WlbsRemoteControl and helper functions FindHostInList and AddHostToList.
//
typedef struct
{
    DWORD   hostID;
    DWORD   address;
    WCHAR   hostName[CVY_MAX_HOST_NAME + 1];
} HOST, * PHOST;
//
// Global variable for the dll instance
//
HINSTANCE g_hInstCtrl;

//
// Helper functions
//
DWORD MapStateFromDriverToApi(DWORD dwDriverState);

//+----------------------------------------------------------------------------
//
// Function:  IsLocalHost
//
// Description:  
//
// Arguments: CWlbsCluster* pCluster - 
//            DWORD dwHostID - 
//
// Returns:   inline bool - 
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
inline bool IsLocalHost(CWlbsCluster* pCluster, DWORD dwHostID)
{
    if (pCluster == NULL)
    {
        return false;
    }

    return dwHostID == WLBS_LOCAL_HOST; // || pCluster->GetHostID() == dwHostID;
}

//+----------------------------------------------------------------------------
//
// Function:  FindHostInList
//
// Description:  Takes an array of HOST structs and searches it for a match to the parameters
//               that identify a unique host: hostID, host IP and host name.
//
// Arguments: DWORD hostID               - host ID to search for in the respondedHosts array
//            DWORD address              - host IP to search for in the respondedHosts array
//            PWCHAR hostname            - host name to search for in the respondedHosts array
//            const PHOST respondedHosts - array of hosts that have responded thus far
//            DWORD numhosts             - number of entries in respondedHosts
//
// Returns:   inline bool - true if match found, false otherwise
//
// History: chrisdar  08.06.01
//
//+----------------------------------------------------------------------------
inline bool FindHostInList(DWORD hostID, DWORD address, PWCHAR hostname, const PHOST respondedHosts, DWORD numhosts)
{
    //
    // A match is one where and entry in respondedHosts has the same hostid,
    // address and hostname. In the case of hostname, NULL (or no name) is an
    // allowed value.
    //
    bool bFound = false;

    if (NULL == respondedHosts || 0 == numhosts)
    {
        return bFound;
    }

    DWORD dwNumHosts = min(numhosts, WLBS_MAX_HOSTS); // respondedHosts is an arrary of length WLBS_MAX_HOSTS

    DWORD dwIndex;
    for (dwIndex = 0; dwIndex < dwNumHosts; dwIndex++)
    {
        if (respondedHosts[dwIndex].hostID == hostID &&
            respondedHosts[dwIndex].address == address)
        {
            //
            // Host ID and IP match. Now check the name, allowing for NULL
            // as a valid value too.
            //
            if (NULL != hostname)
            {
                if (wcscmp(respondedHosts[dwIndex].hostName, hostname) == 0)
                {
                    //
                    // hostname was provided and we found it in the list.
                    // NOTE: This branch catches the case where both are empty strings (L"")
                    //
                    bFound = true;
                    break;
                }
            }
            else if (NULL == hostname && 0 == wcscmp(respondedHosts[dwIndex].hostName, L""))
            {
                //
                // hostname is NULL and we have an matching entry in the list with an empty string hostName
                //
                bFound = true;
                break;
            }
        }
    }
    return bFound;
}

//+----------------------------------------------------------------------------
//
// Function:  AddHostToList
//
// Description:  Add an entry to the host list with the specified host parameters.
//               This function does NOT validate or ensure the uniqueness of entries.
//
// Arguments: DWORD hostID               - host ID to search for in the respondedHosts array
//            DWORD address              - host IP to search for in the respondedHosts array
//            PWCHAR hostname            - host name to search for in the respondedHosts array
//            const PHOST respondedHosts - array of hosts that have responded thus far
//            DWORD numhosts             - number of entries in respondedHosts
//
// Returns:   inline void
//
// History: chrisdar  08.06.01
//
//+----------------------------------------------------------------------------
inline void AddHostToList(DWORD hostID, DWORD address, PWCHAR hostname, const PHOST respondedHosts, DWORD numhosts)
{
    //
    // Caller will increment numhosts when we return, whether we succeed or not.
    // So don't worry about tracking the number of elements in respondedHosts.
    // If the caller doesn't do this, then we will just overwrite the previous
    // entry we made.
    //
    if (numhosts >= WLBS_MAX_HOSTS)
    {
        return;
    }

    respondedHosts[numhosts].hostID = hostID;
    respondedHosts[numhosts].address = address;
    respondedHosts[numhosts].hostName[0] = L'\0'; // Should be zeroed out already, but just in case...
    if (NULL != hostname)
    {
        wcsncpy(respondedHosts[numhosts].hostName, hostname, CVY_MAX_HOST_NAME);
        // Terminate the end of the destination string with a NULL, even in the case that we don't need to.
        // It's simpler than checking if needed. Worst case we overwrite a NULL with a NULL.
        respondedHosts[numhosts].hostName[CVY_MAX_HOST_NAME] = L'\0'; 
    }
}

//+----------------------------------------------------------------------------
//
// Function:  QueryPortFromSocket
//
// Synopsis:  
//    This routine retrieves the port number to which a socket is bound.
//
// Arguments:
//    Socket - the socket to be queried
//
// Return Value:
//    USHORT - the port number retrieved
//
// History:   Created Header    2/10/99
//
//+----------------------------------------------------------------------------
static USHORT QueryPortFromSocket(SOCKET Socket)
{
    SOCKADDR_IN Address;
    int AddressLength;
    AddressLength = sizeof(Address);
    getsockname(Socket, (PSOCKADDR)&Address, &AddressLength);
    return Address.sin_port;
} 

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::CWlbsControl
//
// Description:  
//
// Arguments: None
//
// Returns:   Nothing
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
CWlbsControl::CWlbsControl()
{
    m_local_ctrl      = FALSE;
    m_remote_ctrl     = FALSE;
    m_hdl             = INVALID_HANDLE_VALUE;
    m_registry_lock   = INVALID_HANDLE_VALUE;
    m_def_dst_addr    = 0;
    m_def_timeout     = IOCTL_REMOTE_RECV_DELAY;
    m_def_port        = CVY_DEF_RCT_PORT;
    m_def_passw       = CVY_DEF_RCT_PASSWORD;

    m_dwNumCluster = 0;

    for (int i = 0; i < WLBS_MAX_CLUSTERS; i ++)
    {
        m_cluster_params [i] . cluster = 0;
        m_cluster_params [i] . passw   = CVY_DEF_RCT_PASSWORD;
        m_cluster_params [i] . timeout = IOCTL_REMOTE_RECV_DELAY;
        m_cluster_params [i] . port    = CVY_DEF_RCT_PORT;
        m_cluster_params [i] . dest    = 0;
    }

    ZeroMemory(m_pClusterArray, sizeof(m_pClusterArray));
}




//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::~CWlbsControl
//
// Description:  
//
// Arguments: None
//
// Returns:   Nothing
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
CWlbsControl::~CWlbsControl()
{
    for (DWORD i=0; i< m_dwNumCluster; i++)
    {
        delete m_pClusterArray[i];
    }
        
    if (m_hdl)
    {
        CloseHandle(m_hdl);
    }

    if (m_remote_ctrl) 
    {
        WSACleanup();  // WSAStartup is called in Initialize()
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::Initialize
//
// Description:  Initialization
//
// Arguments: None
//
// Returns:   bool - true if succeeded
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::Initialize()
{
    TRACE_VERB("->%!FUNC!");
    WORD            ver;
    int             ret;
    DWORD           dwInitResult = 0;

    if (IsInitialized())
    {
        TRACE_INFO("%!FUNC! already initialized. Reinitializing...");
        if (!ReInitialize())
        {
            TRACE_CRIT("%!FUNC! reinitialization failed");
            // This check was added for tracing. No abort was done previously on error, so don't do so now.
        }
        dwInitResult = GetInitResult();
        if (WLBS_INIT_ERROR == dwInitResult)
        {
            TRACE_CRIT("%!FUNC! failed while determining whether nlb is configured for remote or local only activity");
        }

        TRACE_VERB("<-%!FUNC! returns %d", dwInitResult);
        return dwInitResult;
    }
    
    if (_tsetlocale (LC_ALL, _TEXT(".OCP")) == NULL)
    {
        TRACE_CRIT("%!FUNC! illegal locale specified");
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }


    /* open Winsock */

    WSADATA         data;
    int iWsaStatus = 0;
    DWORD dwStatus = 0;

    TRACE_INFO("%!FUNC! initializing winsock");
    iWsaStatus = WSAStartup (WINSOCK_VERSION, & data);
    if (iWsaStatus == 0)
    {
        m_remote_ctrl = TRUE;
    }
    else
    {
        TRACE_CRIT("%!FUNC! WSAStartup failed with %d", iWsaStatus);
    }


    /* if succeeded querying local parameters - connect to device */

    if (m_hdl != INVALID_HANDLE_VALUE)
    {
        TRACE_INFO("%!FUNC! closing handle to the device object");
        if (!CloseHandle (m_hdl))
        {
            dwStatus = GetLastError();
            TRACE_CRIT("%!FUNC! closing handle to the device object failed with %d", dwStatus);
        }
    }

    TRACE_INFO("%!FUNC! opening (creating handle to) the device object");
    m_hdl = CreateFile (_TEXT("\\\\.\\WLBS"), GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);

    if (INVALID_HANDLE_VALUE == m_hdl)
    {
        dwStatus = GetLastError();
        if (dwStatus == ERROR_FILE_NOT_FOUND)
        {
            //
            // Occurs often under bind/unbind stress. Means NLB not installed or not bound.
            //
            TRACE_INFO("%!FUNC! creating handle to the device object failed with %d", dwStatus);
        }
        else
        {
            TRACE_CRIT("%!FUNC! creating handle to the device object failed with %d", dwStatus);
        }

        dwInitResult = GetInitResult();
        if (dwInitResult == WLBS_INIT_ERROR)
        {
            TRACE_CRIT("%!FUNC! failed while determining whether nlb is configured for remote or local only activity");
        }

        TRACE_VERB("<-%!FUNC! returns %d", dwInitResult);
        return dwInitResult;
    }
    else
    {
        TRACE_INFO("%!FUNC! device object opened successfully");
        m_local_ctrl = TRUE;
    }

    //
    // enumerate clusters
    //

    HKEY hKeyWlbs;
    DWORD dwError;
    const PWCHAR pwszTmpRegPath = L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface";
    dwError = RegOpenKeyEx (HKEY_LOCAL_MACHINE, 
                            pwszTmpRegPath,
                            0L, KEY_READ, & hKeyWlbs);

    if (dwError != ERROR_SUCCESS)
    {
        TRACE_CRIT(L"%!FUNC! failed to open registry %ls with %d", pwszTmpRegPath, dwError);
        dwInitResult = GetInitResult();
        if (dwInitResult == WLBS_INIT_ERROR)
        {
            TRACE_CRIT("%!FUNC! failed while determining whether nlb is configured for remote or local only activity");
        }

        TRACE_VERB("<-%!FUNC! returns %d", dwInitResult);
        return dwInitResult;
    }

    m_dwNumCluster = 0;

    TRACE_INFO(L"%!FUNC! enumerating registry subkeys in %ls", pwszTmpRegPath);
    for (int index=0;;index++)
    {
        WCHAR szAdapterGuid[128];
        DWORD dwSize = sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]);
        
        dwError = RegEnumKeyEx(hKeyWlbs, index, 
                        szAdapterGuid, &dwSize,
                        NULL, NULL, NULL, NULL);

        if (dwError != ERROR_SUCCESS)
        {
            if (dwError != ERROR_NO_MORE_ITEMS)
            {
                TRACE_CRIT(L"%!FUNC! attempt to enumerate nlb subkey index %i failed with %d", index, dwError);
            }
            TRACE_INFO(L"%!FUNC! finished enumerating registry subkeys in %ls", pwszTmpRegPath);
            break;
        }

        GUID AdapterGuid;
        HRESULT hr = CLSIDFromString(szAdapterGuid, &AdapterGuid);

        if (FAILED(hr))
        {
            TRACE_CRIT(L"%!FUNC! translating to class identifier for string %ls failed with %d", szAdapterGuid, hr);
            TRACE_INFO(L"%!FUNC! enumerate next subkey");
            continue;
        }

        IOCTL_CVY_BUF    in_buf;
        IOCTL_CVY_BUF    out_buf;

        DWORD status = WlbsLocalControl (m_hdl, AdapterGuid,
            IOCTL_CVY_QUERY, & in_buf, & out_buf, NULL);

        if (status == WLBS_IO_ERROR) 
        {
            TRACE_CRIT(L"%!FUNC! error querying local host with IOCTL_CVY_QUERY");
            TRACE_INFO(L"%!FUNC! enumerate next subkey");
            continue;
        }
        
        //
        // Use index instead of m_dwNumCluster as the cluster index
        // m_dwNumCluster will change is a adapter get unbound.
        // index will change only if an adapter get removed
        //
        m_pClusterArray[m_dwNumCluster] = new CWlbsCluster(index);
        
        if (m_pClusterArray[m_dwNumCluster] == NULL)
        {
            TRACE_CRIT(L"%!FUNC! memory allocation failure while creating nlb cluster configuration instance");
            ASSERT(m_pClusterArray[m_dwNumCluster]);
        }
        else
        {
            TRACE_VERB(L"%!FUNC! nlb cluster configuration instance created");
            if (!m_pClusterArray[m_dwNumCluster]->Initialize(AdapterGuid))
            {
                TRACE_CRIT(L"%!FUNC! initialization of nlb cluster configuration instance failed. Ignoring...");
            }
            m_dwNumCluster++;
        }
    }

    dwError = RegCloseKey(hKeyWlbs);
    if (dwError != ERROR_SUCCESS)
    {
        TRACE_CRIT(L"%!FUNC! close registry path %ls failed with %d", pwszTmpRegPath, dwError);
    }
    
    dwInitResult = GetInitResult();
    if (dwInitResult == WLBS_INIT_ERROR)
    {
        TRACE_CRIT("%!FUNC! failed while determining whether nlb is configured for remote or local only activity");
    }

    TRACE_VERB("<-%!FUNC! returns %d", dwInitResult);
    return dwInitResult;
} 



//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::ReInitialize
//
// Description:  Re-Initialization to get the current cluster list
//
// Arguments: None
//
// Returns:   bool - true if succeeded
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
bool CWlbsControl::ReInitialize()
{
    TRACE_VERB("->%!FUNC!");
    ASSERT(m_hdl != INVALID_HANDLE_VALUE);

    if ( m_hdl == INVALID_HANDLE_VALUE )
    {
        TRACE_CRIT("%!FUNC! handle to device object is invalid");
        TRACE_VERB("<-%!FUNC! returning false");
        return false;
    }
    

    HKEY hKeyWlbs;
    DWORD dwError;
    const PWCHAR pwszTmpRegPath = L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface";
    
    dwError = RegOpenKeyEx (HKEY_LOCAL_MACHINE, 
                            pwszTmpRegPath,
                            0L, KEY_READ, & hKeyWlbs);

    if (dwError != ERROR_SUCCESS)
    {
        TRACE_CRIT(L"%!FUNC! failed to open registry %ls with %d", pwszTmpRegPath, dwError);
        TRACE_VERB("<-%!FUNC! returning false");
        return false;
    }


    //
    // Re enumerate the clusters
    //
    
    DWORD dwNewNumCluster = 0;   // the number of new clusters
    bool fClusterExists[WLBS_MAX_CLUSTERS];
    CWlbsCluster* NewClusterArray[WLBS_MAX_CLUSTERS];

    for (DWORD i=0;i<m_dwNumCluster;i++)
    {
        fClusterExists[i] = false;
    }

    TRACE_VERB(L"%!FUNC! enumerating registry subkeys in %ls", pwszTmpRegPath);
    for (int index=0;;index++)
    {
        WCHAR szAdapterGuid[128];
        DWORD dwSize = sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]);
        
        dwError = RegEnumKeyEx(hKeyWlbs, index, 
                        szAdapterGuid, &dwSize,
                        NULL, NULL, NULL, NULL);

        if (dwError != ERROR_SUCCESS)
        {
            if (dwError != ERROR_NO_MORE_ITEMS)
            {
                TRACE_CRIT(L"%!FUNC! attempt to enumerate nlb subkey index %i failed with %d", index, dwError);
                TRACE_VERB("<-%!FUNC! returning false");
                return false;
            }
            TRACE_INFO(L"%!FUNC! finished enumerating registry subkeys in %ls", pwszTmpRegPath);
            break;
        }

        GUID AdapterGuid;
        HRESULT hr = CLSIDFromString(szAdapterGuid, &AdapterGuid);

        if (FAILED(hr))
        {
            TRACE_CRIT(L"%!FUNC! translating to class identifier for string %ls failed with %d", szAdapterGuid, hr);
            TRACE_INFO(L"%!FUNC! enumerate next subkey");
            continue;
        }

        IOCTL_CVY_BUF    in_buf;
        IOCTL_CVY_BUF    out_buf;

        DWORD status = WlbsLocalControl (m_hdl, AdapterGuid,
            IOCTL_CVY_QUERY, & in_buf, & out_buf, NULL);

        if (status == WLBS_IO_ERROR)
        {
            TRACE_CRIT(L"%!FUNC! error querying local host with IOCTL_CVY_QUERY");
            TRACE_INFO(L"%!FUNC! enumerate next subkey");
            continue;
        }

        //
        // Check if this is a new adapter
        //
        TRACE_VERB(L"%!FUNC! checking if index %i is a new adapter", index);
        for (DWORD j=0; j<m_dwNumCluster; j++)
        {
            ASSERT(m_pClusterArray[j]);
            
            if (IsEqualGUID(AdapterGuid, m_pClusterArray[j]->GetAdapterGuid()))
            {
                ASSERT(fClusterExists[j] == false);
                
                fClusterExists[j] = true;
                
                //
                // Since adapter could be added or removed, since last time,
                // The index could be changed
                //
                m_pClusterArray[j]->m_dwConfigIndex = index;

                break;
            }
        }

        //
        // It is a new adapter
        //
        if (j == m_dwNumCluster)
        {
            TRACE_VERB(L"%!FUNC! index %i is a new adapter", index);
            CWlbsCluster* pCluster = new CWlbsCluster(index);

            if (pCluster == NULL)
            {
                TRACE_CRIT(L"%!FUNC! memory allocation failure for new cluster adapter instance for index %i", index);
                ASSERT(pCluster);
            }
            else
            {
                TRACE_VERB(L"%!FUNC! cluster instance for adapter index %i successfully created", index);
                if (!pCluster->Initialize(AdapterGuid))
                {
                    TRACE_CRIT(L"%!FUNC! initialize of cluster instance for adapter index %i failed.", index);
                }

                //
                // Add
                //
                TRACE_VERB(L"%!FUNC! cluster instance for adapter index %i added to cluster array", index);
                NewClusterArray[dwNewNumCluster] = pCluster;
                dwNewNumCluster++;
            }
        }
    }

    dwError = RegCloseKey(hKeyWlbs);
    if (dwError != ERROR_SUCCESS)
    {
        TRACE_CRIT(L"%!FUNC! close registry path %ls failed with %d", pwszTmpRegPath, dwError);
    }

    //
    //  Create the new cluster array
    //
    TRACE_VERB(L"%!FUNC! creating the new cluster array");
    for (i=0; i< m_dwNumCluster; i++)
    {
        if (!fClusterExists[i])
        {
            TRACE_VERB(L"%!FUNC! deleting cluster instance %i the no longer exists", i);
            delete m_pClusterArray[i];
        }
        else
        {
            //
            // Reload settings
            //
            if (!m_pClusterArray[i]->ReInitialize())
            {
                TRACE_CRIT(L"%!FUNC! reinitialize of cluster instance %i failed. It will be kept.", i);
            }

            TRACE_INFO(L"%!FUNC! keeping cluster instance %i", i);
            NewClusterArray[dwNewNumCluster] = m_pClusterArray[i];
            dwNewNumCluster++;
        }

        m_pClusterArray[i] = NULL;
    }


    //
    // Copy the array back
    //
    TRACE_VERB(L"%!FUNC! copying cluster array");
    m_dwNumCluster = dwNewNumCluster;
    CopyMemory(m_pClusterArray, NewClusterArray, m_dwNumCluster * sizeof(m_pClusterArray[0]));

    ASSERT(m_pClusterArray[m_dwNumCluster] == NULL);
    
    TRACE_VERB("<-%!FUNC! returning true");
    return true;
} 

//+----------------------------------------------------------------------------
//
// Function:  MapStateFromDriverToApi
//
// Description:  Map the state return from wlbs driver to the API state
//
// Arguments: DWORD dwDriverState - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD MapStateFromDriverToApi(DWORD dwDriverState)
{
    struct STATE_MAP
    {
        DWORD dwDriverState;
        DWORD dwApiState;
    } 
    StateMap[] =
    {  
        {IOCTL_CVY_ALREADY, WLBS_ALREADY},
        {IOCTL_CVY_BAD_PARAMS, WLBS_BAD_PARAMS},
        {IOCTL_CVY_NOT_FOUND, WLBS_NOT_FOUND},
        {IOCTL_CVY_STOPPED, WLBS_STOPPED},
        {IOCTL_CVY_SUSPENDED, WLBS_SUSPENDED},
        {IOCTL_CVY_CONVERGING, WLBS_CONVERGING},
        {IOCTL_CVY_SLAVE, WLBS_CONVERGED},
        {IOCTL_CVY_MASTER, WLBS_DEFAULT},
        {IOCTL_CVY_BAD_PASSWORD, WLBS_BAD_PASSW},
        {IOCTL_CVY_DRAINING, WLBS_DRAINING},
        {IOCTL_CVY_DRAINING_STOPPED, WLBS_DRAIN_STOP},
        {IOCTL_CVY_DISCONNECTED, WLBS_DISCONNECTED},
        {IOCTL_CVY_GENERIC_FAILURE, WLBS_FAILURE},
        {IOCTL_CVY_REQUEST_REFUSED, WLBS_REFUSED},
        {IOCTL_CVY_OK, WLBS_OK}
    };

    for (int i=0; i<sizeof(StateMap) /sizeof(StateMap[0]); i++)
    {
        if (StateMap[i].dwDriverState == dwDriverState)
        {
            return StateMap[i].dwApiState;
        }
    }

    //
    // Default
    //
    return WLBS_OK;
}


//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::GetClusterFromIp
//
// Description:  Get the cluster object from IP
//
// Arguments: DWORD dwClusterIp - 
//
// Returns:   CWlbsCluster* - Caller can NOT free the return object 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
inline 
CWlbsCluster* CWlbsControl::GetClusterFromIp(DWORD dwClusterIp)
{
    TRACE_VERB("->%!FUNC! look for cluster 0x%lx", dwClusterIp);
    for (DWORD i=0; i< m_dwNumCluster; i++)
    {
        if(m_pClusterArray[i]->GetClusterIp() == dwClusterIp)
        {
            TRACE_VERB("<-%!FUNC! found cluster instance");
            return m_pClusterArray[i];
        }
    }

    TRACE_VERB("<-%!FUNC! cluster instance not found");
    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::GetClusterFromAdapter
//
// Description:  Get the cluster object from adapter guid
//
// Arguments: GUID *pAdapterGuid -- GUID of the adapter. 
//
// Returns:   CWlbsCluster* - Caller can NOT free the return object 
//
// History:   JosephJ Created 4/20/01
//
//+----------------------------------------------------------------------------
inline 
CWlbsCluster* CWlbsControl::GetClusterFromAdapter(IN const GUID &AdapterGuid)
{
    TRACE_VERB("->%!FUNC!");
    for (DWORD i=0; i< m_dwNumCluster; i++)
    {
        const GUID& Guid = m_pClusterArray[i]->GetAdapterGuid();
        if (IsEqualGUID(Guid, AdapterGuid))
        {
            TRACE_VERB("<-%!FUNC! found cluster instance");
            return m_pClusterArray[i];
        }
    }

    TRACE_VERB("<-%!FUNC! cluster instance not found");
    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::ValidateParam
//
// Description:  Validate the specified WLBS cluster parameter. It has no side effects other to munge paramp, for example reformatting
//              IP addresses into canonical form.
//
// Arguments: paramp    -- params to validate
//
// Returns:   TRUE if params look valid, false otherwise.
//
// History:   JosephJ Created 4/25/01
//
//+----------------------------------------------------------------------------
BOOL
CWlbsControl::ValidateParam(
    IN OUT PWLBS_REG_PARAMS paramp
    )
{
    return ::WlbsValidateParams(paramp)!=0;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControlWrapper::GetClusterFromIpOrIndex
//
// Description:  
//
// Arguments: DWORD dwClusterIpOrIndex - 
//
// Returns:   CWlbsCluster* - 
//
// History: fengsun  Created Header    7/3/00
//
//+----------------------------------------------------------------------------
CWlbsCluster* CWlbsControl::GetClusterFromIpOrIndex(DWORD dwClusterIpOrIndex)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx", dwClusterIpOrIndex);

    for (DWORD i=0; i<m_dwNumCluster; i++)
    {
        if (m_pClusterArray[i]->GetClusterIpOrIndex(this) == dwClusterIpOrIndex)
        {
            TRACE_VERB("<-%!FUNC! instance found");
            return m_pClusterArray[i];
        }
    }

    TRACE_VERB("<-%!FUNC! cluster instance not found");
    return NULL;
}

/* 
 * Function: CWlbsControlWrapper::IsClusterMember
 * Description: This function searches the list of known NLB clusters on this 
 *              host to determine whether or not this host is a member of a
 *              given cluster.
 * Author: shouse, Created 4.16.01
 */
BOOLEAN CWlbsControl::IsClusterMember (DWORD dwClusterIp)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx", dwClusterIp);

    for (DWORD i = 0; i < m_dwNumCluster; i++) {
        if (m_pClusterArray[i]->GetClusterIp() == dwClusterIp)
        {
            TRACE_VERB("<-%!FUNC! returning true");
            return TRUE;
        }
    }

    TRACE_VERB("<-%!FUNC! returning false");
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::EnumClusterObjects
//
// Description:  Get a list of cluster objects
//
// Arguments: OUT CWlbsCluster** &pdwClusters - The memory is internal to CWlbsControl
///                 Caller can NOT free the pdwClusters memory 
//            OUT DWORD* pdwNum - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    3/3/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::EnumClusterObjects(OUT CWlbsCluster** &ppClusters, OUT DWORD* pdwNum)
{
    TRACE_VERB("->%!FUNC!");
    ASSERT(pdwNum);
    
    ppClusters = m_pClusterArray;

    *pdwNum = m_dwNumCluster;

    TRACE_VERB("<-%!FUNC!");
    return ERROR_SUCCESS;
}



//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::EnumClusters
//
// Description:  Get a list of cluster IP or index
//
// Arguments: OUT DWORD* pdwAddresses - 
//            IN OUT DWORD* pdwNum - IN size of the buffer, OUT element returned
//
// Returns:   DWORD - WLBS error code.
//
// History:   fengsun Created Header    3/3/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::EnumClusters(OUT DWORD* pdwAddresses, IN OUT DWORD* pdwNum)
{
    TRACE_VERB("->%!FUNC!");
    if (pdwNum == NULL)
    {
        TRACE_CRIT("%!FUNC! input array size not provided");
        TRACE_VERB("<-%!FUNC! returning %d", WLBS_BAD_PARAMS);
        return WLBS_BAD_PARAMS;
    }

        if (pdwAddresses == NULL || *pdwNum < m_dwNumCluster)
        {
            *pdwNum = m_dwNumCluster;
            TRACE_CRIT("%!FUNC! input buffer is not large enough for cluster list");
            TRACE_VERB("<-%!FUNC! returning %d", ERROR_MORE_DATA);
            return ERROR_MORE_DATA;
        }

    *pdwNum = m_dwNumCluster;

    for (DWORD i=0; i< m_dwNumCluster; i++)
    {
        pdwAddresses[i] = m_pClusterArray[i]->GetClusterIpOrIndex(this);
    }

    TRACE_VERB("<-%!FUNC! returning %d", WLBS_OK);
    return WLBS_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  WlbsOpen
//
// Description:  Opens & returns handle to NLB driver. 
//               Caller must call CloseHandle() after use of handle
//
// Arguments: None
//
// Returns:   Handle to Driver
//
// History:   KarthicN, Created 8/28/01
//
//+----------------------------------------------------------------------------
HANDLE WINAPI WlbsOpen()
{
    HANDLE hdl;

    TRACE_VERB("->%!FUNC!");
    hdl = CreateFile (_TEXT("\\\\.\\WLBS"), GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
    if (INVALID_HANDLE_VALUE == hdl)
    {
        TRACE_CRIT("%!FUNC! creating handle to the device object failed with %d", GetLastError());
    }
    TRACE_VERB("<-%!FUNC! returning %p", hdl);
    return hdl;
}


//+----------------------------------------------------------------------------
//
// Function:  WlbsLocalControlWrapper
//
// Description:  Wrapper around WlbsLocalControl()
//
// Arguments: handle to NLB driver, Adapter GUID, Ioctl
//
// Returns:   Status Code
//
// History:   KarthicN, Created 8/28/01
//
//+----------------------------------------------------------------------------

DWORD WINAPI WlbsLocalClusterControl(
        IN       HANDLE  NlbHdl,
        IN const GUID *  pAdapterGuid,
        IN       LONG    ioctl,
        IN       DWORD   Vip,
        IN       DWORD   PortNum,
        OUT      DWORD*  pdwHostMap
)
{
    TRACE_VERB("->%!FUNC! ioctl : 0x%x, Vip : 0x%x, Port : 0x%x", ioctl, Vip, PortNum);

    DWORD               status;
    IOCTL_CVY_BUF       in_buf;
    IOCTL_CVY_BUF       out_buf;
    IOCTL_LOCAL_OPTIONS Options, *pOptions;

    pOptions = NULL;
    ZeroMemory(&in_buf, sizeof(in_buf));

    //
    // We only support cluster-wide operations...
    //
    switch(ioctl)
    {
    case IOCTL_CVY_CLUSTER_ON:
    case IOCTL_CVY_CLUSTER_OFF:
    case IOCTL_CVY_CLUSTER_SUSPEND:
    case IOCTL_CVY_CLUSTER_RESUME:
    case IOCTL_CVY_CLUSTER_DRAIN:
    case IOCTL_CVY_QUERY:
        break;

    case IOCTL_CVY_PORT_ON:
    case IOCTL_CVY_PORT_OFF:
    case IOCTL_CVY_PORT_DRAIN:
        ZeroMemory(&Options, sizeof(Options));
        Options.common.port.flags = 0;
        Options.common.port.vip = Vip;
        pOptions = &Options;
        in_buf.data.port.num = PortNum;
        break;

    case IOCTL_CVY_QUERY_PORT_STATE:
        ZeroMemory(&Options, sizeof(Options));
        Options.common.state.port.VirtualIPAddress = Vip;
        Options.common.state.port.Num = (USHORT) PortNum;
        pOptions = &Options;
        break;

    default:
        status = WLBS_BAD_PARAMS;
        TRACE_CRIT("%!FUNC! requested ioctl is not allowed. Only cluster-wide operations can be performed.");
        goto end;
    }
 
 
    status = WlbsLocalControl (NlbHdl, *pAdapterGuid,
                ioctl, & in_buf, & out_buf, pOptions);

    if (status != WLBS_IO_ERROR)
    {
        // For Query, return "Cluster State" as status
        if (ioctl == IOCTL_CVY_QUERY) 
        {
            // If asked for, return host map
            if (pdwHostMap) 
            {
                *pdwHostMap = out_buf.data.query.host_map;
            }
            status = MapStateFromDriverToApi (out_buf.data.query.state);
        }
        // For QueryPortState, return "Port State" as status
        else if (ioctl == IOCTL_CVY_QUERY_PORT_STATE) 
        {
            status  = (DWORD)(pOptions->common.state.port.Status);
        }
        // For everything else, return "operation's result" as status
        else
        {
            status = MapStateFromDriverToApi (out_buf.ret_code);
        }
        TRACE_INFO("%!FUNC! ioctl request was made and returned nlb or port status %d", status);
    }
    else
    {
        TRACE_CRIT("%!FUNC! call to control local cluster failed with WLBS_IO_ERROR");
    }

end:
    TRACE_VERB("<-%!FUNC! returning %d", status);
    return status;
}

//+----------------------------------------------------------------------------
//
// Function:  GetSrcAddress
//
// Description:  Get the source address of the local host
//
// Arguments: 
//
// Returns:   DWORD - the IP address
//
// History:   chrisdar  2002.01.17 Created. Copied from CWlbsControl::Initialize
//
//+----------------------------------------------------------------------------
DWORD GetSrcAddress()
{
    DWORD            dwSrcAddress = 0;
    DWORD            dwStatus;
    CHAR             buf [CVY_STR_SIZE];
    struct hostent * host;

    TRACE_VERB("->");

    if (gethostname (buf, CVY_STR_SIZE) == SOCKET_ERROR)
    {
        dwStatus = WSAGetLastError();
        TRACE_CRIT("gethostname failed with %d", dwStatus);
        goto end;
    }

    // Note: msdn says this api call has been deprecated and should be replaced by getaddrinfo 
    host = gethostbyname (buf);
    if (host == NULL)
    {
        dwStatus = WSAGetLastError();
        TRACE_CRIT("gethostbyname failed with %d", dwStatus);
        goto end;
    }

    if (((struct in_addr *) (host -> h_addr)) -> s_addr == 0)
    {
        TRACE_CRIT("no IP address in host structure");
        goto end;
    }

    dwSrcAddress = ((struct in_addr *) (host -> h_addr)) -> s_addr;

end:

    TRACE_VERB("<- returning source address 0x%x", dwSrcAddress);
    return dwSrcAddress;
}

//+----------------------------------------------------------------------------
//
// Function:  GetRemoteControlSocket
//
// Description:  Create, configure and bind a socket for remote control operations
//
// Arguments: SOCKET* pSock      - the socket to populate
//            DWORD   dwDestIP   - the destination IP (the cluster we will talk to)
//            DWORD   dwDestPort - the destination port. Needed so that the created
//                                 socket doesn't use this port in case the local host
//                                 is a member of the cluster that should handle the
//                                 remote control request.
//            BOOL    isLocal    - Is this host a member of the cluster that will
//                                 receive the remote control request?
//
// Returns:   DWORD - 0 means success. Otherwise, the return value is a socket error.
//                    pSock points to INVALID_SOCKET if this function fails.
//
// History:   chrisdar  2002.01.17 Created. Moved content of here from
//                                 CWlbsControl::WlbsRemoteControl
//
//+----------------------------------------------------------------------------
DWORD GetRemoteControlSocket(SOCKET* pSock, DWORD dwDestIP, WORD wDestPort, BOOL isLocal)
{
    SOCKADDR_IN caddr;
    DWORD       dwStatus = 0;     // For Winsock calls. MSDN says a value of "0" resets the last
                                  // error when retrieving a winsock error, so we use it to indicate success.
    DWORD       mode     = 1;     // Indicates to ioctlsocket that the socket mode is non-blocking
    BOOL        fReady   = FALSE; // "Ready" means we have a bound socket, and it is not bound to dwDestPort.
    const DWORD dwRetryCount = 5;

    TRACE_VERB("-> dwDestIP = 0x%x, wDestPort = 0x%x, host is member of the cluster: %ls", dwDestIP, wDestPort, isLocal ? L"true" : L"false");

    ASSERT (pSock != NULL);
    *pSock = INVALID_SOCKET;

    caddr . sin_family        = AF_INET;
    caddr . sin_port          = htons (0);

    //
    // We keep trying to bind a socket until:
    //     1) We succeed, or
    //     2) We exhaust all options at our disposal, which are:
    //         a) Bind using src IP = cluster IP if we are part of the cluster
    //         b) Bind to any IP if a) fails or we aren't part of the cluster
    //
    // The requirement is that the source port we use for the bound socket must not be the
    // remote control port (dwDestPort) if we are a member of that cluster. The impl below
    // assumes that we shouldn't use this as a source port under any circumstance.
    //

    // Change to use Retries max 5
    for (DWORD i=0; i<dwRetryCount; i++)
    {
        //
        // Create the socket
        //
        ASSERT(*pSock == INVALID_SOCKET);

        *pSock = socket (AF_INET, SOCK_DGRAM, 0);
        if (*pSock == INVALID_SOCKET)
        {
            dwStatus = WSAGetLastError();
            TRACE_CRIT("%!FUNC! socket create failed with 0x%x", dwStatus);
            goto end;
        }

        //
        // Set socket to nonblocking mode
        //
        mode = 1;
        if (ioctlsocket (*pSock, FIONBIO, & mode) == SOCKET_ERROR)
        {
            dwStatus = WSAGetLastError();
            TRACE_CRIT("%!FUNC! setting io mode of ioctlsocket failed with 0x%x", dwStatus);
            goto end;
        }

        //
        // If this host is part of the cluster to be controlled, we'll first try binding
        // with the VIP. If this fails or if this host is *not* part of the cluster,
        // we'll try binding with INADDR_ANY.
        //
        caddr . sin_addr . s_addr = htonl (INADDR_ANY);
        if (isLocal)
        {
            caddr . sin_addr . s_addr = dwDestIP;
        }

        BOOL fBound = FALSE;

        if (bind (*pSock, (LPSOCKADDR) & caddr, sizeof (caddr)) != SOCKET_ERROR)
        {
            fBound = TRUE;
        }
        else if (isLocal)
        {
            dwStatus = WSAGetLastError();
            TRACE_CRIT("%!FUNC! socket bind to local cluster IP failed with 0x%x", dwStatus);

            //
            // Try to bind with any IP. Reset return status to "no error" since we will try again.
            //
            caddr . sin_addr . s_addr = htonl (INADDR_ANY);
            dwStatus = 0;

            if (bind (*pSock, (LPSOCKADDR) & caddr, sizeof (caddr)) != SOCKET_ERROR)
            {
                fBound = TRUE;
            }
            else
            {
                dwStatus = WSAGetLastError();
                TRACE_CRIT("%!FUNC! socket bind to INADDR_ANY failed with 0x%x", dwStatus);
                goto end;
            }
        }

        ASSERT(fBound);

        //
        // Check the client-side port we are bound to. If it is the REMOTE control port
        // (dwDestPort) and we are a member of any cluster, then this is a problem. We
        // will just avoid this case completely and always force winsock to bind again.
        //
        if (QueryPortFromSocket(*pSock) == htons (wDestPort))
        {
            TRACE_INFO("%!FUNC! source port will equal dest port. Close socket and open a new one.");
            if (closesocket (*pSock) == SOCKET_ERROR)
            {
                dwStatus = WSAGetLastError();
                TRACE_CRIT("%!FUNC! closesocket failed with 0x%x", dwStatus);
                *pSock = INVALID_SOCKET;
                goto end;
            }

            *pSock = INVALID_SOCKET;
        }
        else
        {
            //
            // This is the only place where we exit the while loop without an error.
            //
            fReady = TRUE;
            break;
        }
    }

end:

    //
    // Something failed
    //
    if (!fReady)
    {
        if (*pSock != INVALID_SOCKET)
        {
            //
            // Ignore return value of close socket because we don't care if it fails here.
            //
            (VOID) closesocket(*pSock);
            *pSock = INVALID_SOCKET;
        }
    }

    TRACE_VERB("<-%!FUNC! returning %u", dwStatus);
    return dwStatus;
}

//+----------------------------------------------------------------------------
//
// Function:  WlbsRemoteControlInternal
//
// Description:  Perform cluster wide remote control operation
//
// Arguments: LONG                ioctl - 
//            PIOCTL_CVY_BUF      pin_bufp - 
//            PIOCTL_CVY_BUF      pout_bufp - 
//            PWLBS_RESPONSE      pcvy_resp - 
//            PDWORD              nump - 
//            DWORD               trg_addr - 
//            DWORD               hst_addr
//            PIOCTL_REMOTE_OPTIONS optionsp - 
//            PFN_QUERY_CALLBACK  pfnQueryCallBack - function pointer for callback.
//                                                   Used only for remote queries.
//
// Returns:   DWORD - 
//
// History:   chrisdar  2002.01.17 Created. Moved content of CWlbsControl::WlbsRemoteControl
//                                 here so that it can be called from outside the wrapper class.
//
//+----------------------------------------------------------------------------
DWORD
WlbsRemoteControlInternal(
        LONG                  ioctl,
        PIOCTL_CVY_BUF        pin_bufp,
        PIOCTL_CVY_BUF        pout_bufp,
        PWLBS_RESPONSE        pcvy_resp,
        PDWORD                nump,
        DWORD                 trg_addr,
        DWORD                 hst_addr,
        PIOCTL_REMOTE_OPTIONS optionsp,
        BOOL                  isLocal,
        PFN_QUERY_CALLBACK    pfnQueryCallBack,
        DWORD                 timeout,
        WORD                  port,
        DWORD                 dst_addr,
        DWORD                 passw
        )
{
    INT              ret;
    BOOLEAN          responded [WLBS_MAX_HOSTS], heard;
    const BOOL       broadcast = TRUE;      // Used by ioctlsocket for socket options if we are part of the cluster receiving the remote control request.
    DWORD            num_sends, num_recvs;
    SOCKET           sock = INVALID_SOCKET;
    SOCKADDR_IN      saddr;
    DWORD            i, hosts;
    IOCTL_REMOTE_HDR rct_req;
    IOCTL_REMOTE_HDR rct_rep;
    PIOCTL_CVY_BUF   in_bufp  = & rct_req . ctrl;
    DWORD            dwStatus = WLBS_INIT_ERROR;
    DWORD dwSrcAddr;

    HOST respondedHosts[WLBS_MAX_HOSTS];    // Array of hosts that have responded to this remote control request. Only used for query?????
    WCHAR* pszTmpHostName = NULL;

    TRACE_VERB("-> ioctl %d, trg_addr 0x%x, hst_addr 0x%x, dst_addr 0x%x, timeout %d, port 0x%x, local host is a member of the cluster: %ls",
        ioctl,
        trg_addr,
        hst_addr,
        dst_addr,
        timeout,
        port,
        isLocal ? L"true" : L"false");

    hosts = 0;

    dwSrcAddr = GetSrcAddress();

    if(dwSrcAddr == 0)
    {
        TRACE_CRIT("GetSrcAddress failed...aborting");
        dwStatus = WLBS_INIT_ERROR;
        goto end;
    }

    //
    // Setup parameters
    //
    ZeroMemory((PVOID)&rct_req, sizeof(IOCTL_REMOTE_HDR));
    ZeroMemory(respondedHosts, sizeof(HOST)*WLBS_MAX_HOSTS);

    * in_bufp = * pin_bufp;

    if (dst_addr == 0)
    {
        dst_addr = trg_addr;
    }

    rct_req . code     = IOCTL_REMOTE_CODE;
    rct_req . version  = CVY_VERSION_FULL;
    rct_req . id       = GetTickCount ();
    rct_req . cluster  = trg_addr;
    rct_req . host     = hst_addr;
    rct_req . addr     = dwSrcAddr;
    rct_req . password = passw;
    rct_req . ioctrl   = ioctl;

    if (optionsp)
        rct_req.options = *optionsp;

    //
    // Create a socket and set client-side properties
    //
    dwStatus = GetRemoteControlSocket(&sock, trg_addr, port, isLocal);

    if (dwStatus != 0)
    {
        TRACE_CRIT("bind to socket failed with 0x%x", dwStatus);
        goto end;
    }

    //
    // Set up server side of socket
    //
    saddr . sin_family = AF_INET;
    saddr . sin_port   = htons (port);

    //
    // See below. We override this value if we are a member of the cluster receiving the remote control request.
    //
    saddr . sin_addr . s_addr = dst_addr;

    if (isLocal)
    {
        ret = setsockopt (sock, SOL_SOCKET, SO_BROADCAST, (char *) & broadcast,
                          sizeof (broadcast));
        if (ret == SOCKET_ERROR)
        {
            dwStatus = WSAGetLastError();
            TRACE_CRIT("setsocketopt failed with 0x%x", dwStatus);
            goto end;
        }

        saddr . sin_addr . s_addr = INADDR_BROADCAST;
    }

    //
    // Setup for remote control request
    //
    for (i = 0; i < WLBS_MAX_HOSTS; i ++)
        responded [i] = FALSE;

    heard = FALSE;

    for (num_sends = 0; num_sends < IOCTL_REMOTE_SEND_RETRIES; num_sends ++)
    {
        /* Set "access bits" in request IOCTL code to use remote (control) settings ie. FILE_ANY_ACCESS */
        SET_IOCTL_ACCESS_BITS_TO_REMOTE(rct_req.ioctrl)

        //
        // Send a remote control request
        //
        ret = sendto (sock, (PCHAR) & rct_req, sizeof (rct_req), 0,
                      (LPSOCKADDR) & saddr, sizeof (saddr));

        if (ret == SOCKET_ERROR)
        {
            //
            // Use local scope variable because a failure here isn't a condition for aborting.
            //
            DWORD dwTmpStatus = WSAGetLastError();
            TRACE_CRIT("sendto failed with 0x%x. Sleep %d then retry...", dwTmpStatus, timeout);

            //
            // Sendto could fail if the adapter is too busy. Allow retry.
            //
            Sleep (timeout);
            continue;
        }

        if (ret != sizeof (rct_req))
        {
            TRACE_INFO("sendto sent %i bytes out of %i. Retry...", ret, sizeof (rct_req));
            continue;
        }

        /* Set "access bits" in request IOCTL code to use local settings ie. FILE_WRITE_ACCESS */
        SET_IOCTL_ACCESS_BITS_TO_LOCAL(rct_req.ioctrl)

        WLBS_RESPONSE callbackResp;

        for (num_recvs = 0; num_recvs < IOCTL_REMOTE_RECV_RETRIES; num_recvs ++)
        {            
            //
            // Receive a remote control reply
            //
            ZeroMemory((PVOID)&rct_rep, sizeof(IOCTL_REMOTE_HDR));

            ret = recv (sock, (PCHAR) & rct_rep, sizeof (rct_rep), 0);

            if (ret == SOCKET_ERROR)
            {
                dwStatus = WSAGetLastError();
                if (dwStatus == WSAEWOULDBLOCK)
                {
                    TRACE_INFO("recv is blocking. Sleep %d then retry...", timeout);
                    Sleep (timeout);
                    continue;
                }
                else if (dwStatus == WSAECONNRESET)
                {
                    //
                    // Remote control is disabled
                    //
                    TRACE_INFO("recv failed with connection reset. Check for more receives");
                    continue;
                }
                else
                {
                    TRACE_CRIT("recv failed with 0x%x", dwStatus);
                    goto end;
                }
            }

            if (ret != sizeof (rct_rep))
            {
                TRACE_INFO("recv received %i bytes out of %i. Sleep %d and try again...", ret, sizeof (rct_rep), timeout);
                Sleep (timeout);
                continue;
            }

            if (rct_rep . cluster != trg_addr)
            {
                TRACE_INFO("recv received from unintended party %d. Sleep %d and try again...", trg_addr, timeout);
                Sleep (timeout);
                continue;
            }

            if (rct_rep . code != IOCTL_REMOTE_CODE)
            {
                TRACE_INFO("recv received unexpected code type. Sleep %d and try again...", timeout);
                Sleep (timeout);
                continue;
            }

            if (rct_rep . id != rct_req . id)
            {
                TRACE_INFO("recv received unexpected message id. Sleep %d and try again...", timeout);
                Sleep (timeout); 
                continue;
            }

            if (rct_rep . host > WLBS_MAX_HOSTS || rct_rep . host == 0 )
            {
                TRACE_INFO("recv received illegal host id %ul. Sleep %d and try again...", rct_rep . host, timeout);
                Sleep (timeout); 
                continue;
            }

            /* Set "access bits" in reply IOCTL code to use local settings ie. FILE_WRITE_ACCESS */
            SET_IOCTL_ACCESS_BITS_TO_LOCAL(rct_rep.ioctrl)

            //
            // Set the pointer to the host name if the host says it provided one
            // Do this here because the flags checking would otherwise need to be done in
            // several places with a NULL pointer passed when hostname is not provided.
            // Instead, we can do the check once use the pointer filled here.
            //
            pszTmpHostName = NULL;
            if (rct_rep.options.query.flags & NLB_OPTIONS_QUERY_HOSTNAME)
            {
                pszTmpHostName = rct_rep.options.query.hostname;
                pszTmpHostName[CVY_MAX_HOST_NAME] = UNICODE_NULL; // Just in case the host name is not null terminated, do it.
            }
            if (! responded [rct_rep . host - 1]
                || !FindHostInList(rct_rep . host, rct_rep . addr, pszTmpHostName, respondedHosts, hosts))
            {
                if (hosts < WLBS_MAX_HOSTS)
                {
                    AddHostToList(rct_rep . host, rct_rep . addr, pszTmpHostName, respondedHosts, hosts);

                    pout_bufp [hosts] = rct_rep . ctrl;

                    if (hosts < * nump && pcvy_resp != NULL)
                    {
                        pcvy_resp [hosts] . id      = rct_rep . host;
                        pcvy_resp [hosts] . address = rct_rep . addr;

                        switch (rct_req.ioctrl) {
                        case IOCTL_CVY_QUERY:
                            pcvy_resp[hosts].status = MapStateFromDriverToApi(rct_rep.ctrl.data.query.state);
                            pcvy_resp[hosts].options.query.flags = rct_rep.options.query.flags;
                            if (NULL != pszTmpHostName)
                            {
                                wcsncpy(pcvy_resp[hosts].options.query.hostname, pszTmpHostName, CVY_MAX_HOST_NAME);
                                // Terminate the end of the destination with a NULL. If source string was shorter than count specified
                                // this will be a no-op but it's simpler than checking if we need to do it. Worst case we overwrite a NULL with a NULL.
                                pcvy_resp[hosts].options.query.hostname[CVY_MAX_HOST_NAME] = L'\0';
                            }

                            if (NULL != pfnQueryCallBack)
                            {
                                CopyMemory((PVOID)&callbackResp, (PVOID)&pcvy_resp[hosts], sizeof(WLBS_RESPONSE));
                                (*pfnQueryCallBack)(&callbackResp);
                            }
                            break;
                        case IOCTL_CVY_QUERY_FILTER:
                            pcvy_resp[hosts].status = MapStateFromDriverToApi(rct_rep.ctrl.data.query.state);

                            pcvy_resp[hosts].options.state.flags = rct_rep.options.common.state.flags;
                            pcvy_resp[hosts].options.state.filter = rct_rep.options.common.state.filter;
                            break;
                        case IOCTL_CVY_QUERY_PORT_STATE:
                            pcvy_resp[hosts].status = MapStateFromDriverToApi(rct_rep.ctrl.data.query.state);

                            pcvy_resp[hosts].options.state.flags = rct_rep.options.common.state.flags;
                            pcvy_resp[hosts].options.state.port = rct_rep.options.common.state.port;
                            break;
                        default:
                            pcvy_resp[hosts].status = MapStateFromDriverToApi(rct_rep.ctrl.ret_code);
                            break;
                        }
                    }
                    else
                    {
                        // We only log this event if the user wants the response and the response is too big...
                        if (pcvy_resp != NULL)
                        {
                            TRACE_INFO("recv has received %d responses but the caller can only accept %d. ", hosts, *nump);
                        }
                    }

                    hosts ++;
                }
            }

            responded [rct_rep . host - 1] = TRUE;
            heard = TRUE;

            if (hst_addr != WLBS_ALL_HOSTS)
            {
                dwStatus = WLBS_OK;
                goto end;
            }
        }
    }

    dwStatus = WLBS_OK;

    if (! heard)
    {
        dwStatus = WLBS_TIMEOUT;
    }

end:

    * nump = hosts;

    if (sock != INVALID_SOCKET)
    {
        //
        // We never return the status of closesocket() because:
        //   1) If everything was a success until now, we have the info
        //      the caller needs and we must return status="WLBS_OK"
        //      so that the caller can get the data.
        //   2) If we've failed somewhere above, then that error is more
        //      important to report than the reason for the closesocket()
        //      failure.
        //
        (VOID) closesocket(sock);
    }

    TRACE_VERB("<- returning 0x%x", dwStatus);
    return dwStatus;
}

//+----------------------------------------------------------------------------
//
// Function:  GetNextHostInHostMap
//
// Description:  Used by WlbsGetClusterMembers, it traverses a 32-bit host map
//               to find the next host after the one input.
//
// Arguments: ULONG host_id  - input host id, range 1-32. We look for a host after this in the map
//            ULONG host_map - input 32-bit map of hosts
//
// Returns:   ULONG - the next host in the map (sequentially). If none, then 
//                    IOCTL_NO_SUCH_HOST is returned.
//
// History:   ChrisDar, Created 2002 May 21
//
// Notes:     The user passes a host id with range 1-32, but the map uses bit 0 for host 1.
//            This makes this function a little tricky.
//+----------------------------------------------------------------------------
ULONG GetNextHostInHostMap(ULONG host_id, ULONG host_map)
{
    ULONG next_host_id = IOCTL_NO_SUCH_HOST;
    /* The map encodes the first host in bit 0, hence 0-31 based range. Use this in the search */ 
    ULONG map_host_id = host_id - 1;

    /* This is illegal input data */
    ASSERT(map_host_id < CVY_MAX_HOSTS); // 0-based range
    if (map_host_id >= CVY_MAX_HOSTS)
    {
        TRACE_CRIT("%!FUNC! illegal host id [1-32] %d", map_host_id+1);
        goto end;
    }

    //
    // This is an early bail-out because the "get next" semantics of this function imply that the input
    // host id will not be the largest possible.
    // NOTE: ChrisDar: 2002 May 23. This check was added because host_map >>= 32 leaves host_map unchanged
    //       in test code. That will cause an assert in the code below as we expect host_map = 0 in this
    //       case.
    //
    if (map_host_id >= CVY_MAX_HOSTS - 1)
    {
        TRACE_VERB("%!FUNC! input host id [1-32] %d is already the largest possible. No need to search for next host in map.", map_host_id+1);
        goto end;
    }

    //
    // Shift the host_map forward to the position just beyond host_id (ignore whether it is set in the map)
    //
    map_host_id++;
    host_map >>= map_host_id;

    //
    // Find the next host in the map, if any.
    //
    while (host_map != 0)
    {
        ASSERT(map_host_id < CVY_MAX_HOSTS);

        if ((host_map & 0x1) == 1)
        {
            /* Return a host id that has range 1-32 */
            next_host_id = map_host_id + 1;
            break;
        }

        host_map >>= 1;
        map_host_id++;
    }

end:
    return next_host_id;
}


//+----------------------------------------------------------------------------
//
// Function:  WlbsGetSpecifiedOrAllClusterMembers
//
// Description:  Wrapper around WlbsRemoteControl() for a query
//
// Arguments: in Adapter GUID, 
//            in host id (pass IOCTL_FIRST_HOST if interested in all cluster member) 
//            out for number of hosts and
//            out for information requested. All must be valid pointers.
//
// Returns:   Status Code
//
// History:  KarthicN, Created  2002, July 12 - Added support for querying a specific
//                                              cluster member and changed name from
//                                              WlbsGetClusterMembers.
//
//+----------------------------------------------------------------------------
DWORD WlbsGetSpecifiedOrAllClusterMembers
(
    IN  const GUID     * pAdapterGuid,
    IN  ULONG            host_id,
    OUT DWORD          * pNumHosts,
    OUT PWLBS_RESPONSE   pResponse
)
{
    TRACE_VERB("->");

    DWORD                status = WLBS_OK;
    HANDLE               hNlb = INVALID_HANDLE_VALUE;
    ULONG                ulNumHosts = 0;

    //
    // We retrieve cached identitiy information for the caller
    //
    const LONG          ioctl = IOCTL_CVY_QUERY_MEMBER_IDENTITY;

    ASSERT(pNumHosts != NULL);
    ASSERT(pResponse != NULL);

    //
    // Open a handle to the driver
    //
    hNlb = WlbsOpen();
    if (hNlb == INVALID_HANDLE_VALUE)
    {
        TRACE_CRIT(L"!FUNC! failed to open handle to driver. Exiting...");
        *pNumHosts = 0;
        status = WLBS_INIT_ERROR;
        goto end;
    }

    bool first_iter = true;

    /* Host IDs are 1-32 */
    do
    {
        IOCTL_CVY_BUF        in_buf;
        IOCTL_CVY_BUF        out_buf;
        IOCTL_LOCAL_OPTIONS  options;

        ZeroMemory(&in_buf, sizeof(in_buf));
        ZeroMemory(&options, sizeof(options));
        options.identity.host_id = host_id;

        status = WlbsLocalControl (hNlb, *pAdapterGuid, ioctl, &in_buf, &out_buf, &options);
        if (status != WLBS_OK || out_buf.ret_code != IOCTL_CVY_OK)
        {
            TRACE_CRIT(L"%!FUNC! IOCTL call failed. Status = 0x%x", status);
            break;
        }

        if (options.identity.cached_entry.host == IOCTL_NO_SUCH_HOST)
        {
            TRACE_INFO(L"%!FUNC! Identity cache has been traversed");
            break;
        }

        if (*pNumHosts <= ulNumHosts)
        {
            TRACE_INFO(L"%!FUNC! No more room in output array");
            break;
        }

        pResponse[ulNumHosts].id = options.identity.cached_entry.host;
        pResponse[ulNumHosts].address = options.identity.cached_entry.ded_ip_addr;

        HRESULT hr = StringCchCopy(pResponse[ulNumHosts].options.identity.fqdn,
                                   ASIZECCH(pResponse[ulNumHosts].options.identity.fqdn),
                                   options.identity.cached_entry.fqdn
                                   );

        ulNumHosts++;

        ASSERT(hr == S_OK); // This shouldn't happen since we allocated a buffer large enough to handle any legal fqdn

        if (hr != S_OK)
        {
            //
            // Not nice, but no problem since the API truncates the name. But report it so we can fix the logic error.
            //
            TRACE_CRIT(L"%!FUNC! fqdn too long to fit into destination buffer");
        }

        // If a specific host id is passed, break out of the loop and return
        if (first_iter) 
        {
            if (host_id != IOCTL_FIRST_HOST)
                break;
            first_iter = false;
        }

        /* Check if we need to IOCTL for more cache entries */
        host_id = GetNextHostInHostMap(options.identity.cached_entry.host, options.identity.host_map);

    } while (host_id != IOCTL_NO_SUCH_HOST);

    *pNumHosts = ulNumHosts;

    (VOID) CloseHandle(hNlb);

end:
    TRACE_VERB("<- returning %d", status);
    return status;
}

//+----------------------------------------------------------------------------
//
// Function:  WlbsGetClusterMembers
//
// Description:  Wrapper around WlbsGetSpecifiedOrAllClusterMembers() for querying
//               all cluster members
//
// Arguments: in Adapter GUID, out for number of hosts and
//            out for information requested. All must be valid pointers.
//
// Returns:   Status Code
//
// History:   ChrisDar, Created 2002 Jan 11
//            KarthicN, Edited  2002, July 12 - Moved most of the code to new 
//                                              function WlbsGetSpecifiedOrAllClusterMembers
//
//+----------------------------------------------------------------------------
DWORD WINAPI WlbsGetClusterMembers
(
    IN  const GUID     * pAdapterGuid,
    OUT DWORD          * pNumHosts,
    OUT PWLBS_RESPONSE   pResponse
)
{
    return WlbsGetSpecifiedOrAllClusterMembers(pAdapterGuid, IOCTL_FIRST_HOST, pNumHosts, pResponse);
}

//+----------------------------------------------------------------------------
//
// Function:  WlbsGetSpecifiedClusterMember
//
// Description:  Wrapper around WlbsGetSpecifiedOrAllClusterMembers() to query
//               the specified cluster member
//
// Arguments: in Adapter GUID, in host_id, 
//            out for information requested. All must be valid pointers.
//
// Returns:   Status Code
//
// History:   KarthicN, Created 2002 July 12
//
//+----------------------------------------------------------------------------
DWORD WINAPI WlbsGetSpecifiedClusterMember
(
    IN  const GUID     * pAdapterGuid,
    IN  ULONG            host_id,
    OUT PWLBS_RESPONSE   pResponse
)
{
    DWORD  NumHosts = 1;
    return WlbsGetSpecifiedOrAllClusterMembers(pAdapterGuid, host_id, &NumHosts, pResponse);
}

//+----------------------------------------------------------------------------
//
// Function:  WlbsLocalControl
//
// Description:  Send DeviceIoControl to local driver
//
// Arguments: HANDLE hDevice - 
//            const GUID& AdapterGuid - the guid of the adapter
//            LONG ioctl - 
//            PIOCTL_CVY_BUF in_bufp - 
//            PIOCTL_CVY_BUF out_bufp - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
DWORD WlbsLocalControl
(
    HANDLE               hDevice, 
    const GUID&          AdapterGuid, 
    LONG                 ioctl, 
    PIOCTL_CVY_BUF       in_bufp, 
    PIOCTL_CVY_BUF       out_bufp,
    PIOCTL_LOCAL_OPTIONS optionsp
)
{
    TRACE_VERB("->%!FUNC! ioctl %i", ioctl);

    BOOLEAN         res;
    DWORD           act;
    IOCTL_LOCAL_HDR inBuf;  
    IOCTL_LOCAL_HDR outBuf;
    HRESULT         hresult;
    WCHAR szGuid[128];
    
    ZeroMemory((PVOID)&inBuf, sizeof(IOCTL_LOCAL_HDR));
    ZeroMemory((PVOID)&outBuf, sizeof(IOCTL_LOCAL_HDR));

    if (StringFromGUID2(AdapterGuid, szGuid, sizeof(szGuid)/ sizeof(szGuid[0])) == 0)
    {
        TRACE_CRIT("%!FUNC! buffer size %d is too small to hold guid string", sizeof(szGuid)/ sizeof(szGuid[0]));
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }

    hresult = StringCbCopy(inBuf.device_name, sizeof(inBuf.device_name), L"\\DEVICE\\");
    if (FAILED(hresult)) 
    {
        TRACE_CRIT("%!FUNC! string copy failed, Error code : 0x%x", HRESULT_CODE(hresult));
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }

    hresult = StringCbCat(inBuf.device_name, sizeof(inBuf.device_name), szGuid);
    if (FAILED(hresult)) 
    {
        TRACE_CRIT("%!FUNC! string append failed, Error code : 0x%x", HRESULT_CODE(hresult));
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }
    inBuf.ctrl = *in_bufp;

    if (optionsp)
        inBuf.options = *optionsp;

    res = (BOOLEAN) DeviceIoControl (hDevice, ioctl, &inBuf, sizeof (inBuf),
                                     &outBuf, sizeof (outBuf), & act, NULL);

    if (! res || act != sizeof (outBuf))
    {
        DWORD dwStatus = GetLastError();
        TRACE_CRIT("%!FUNC! call to nlb driver failed with %d", dwStatus);
        TRACE_VERB("<-%!FUNC! returning %d", WLBS_IO_ERROR);
        return WLBS_IO_ERROR;
    }

    /* We have verified that the IOCTL succeeded and the output buffer is the right size. We can now look
       into the output buffer. */
    if (outBuf.ctrl.ret_code == IOCTL_CVY_NOT_FOUND)
    {
        TRACE_INFO("%!FUNC! call to nlb driver returned IOCTL_CVY_NOT_FOUND");
        TRACE_VERB("<-%!FUNC! returning %d", WLBS_IO_ERROR);
        return WLBS_IO_ERROR;
    }

    *out_bufp = outBuf.ctrl;
    
    if (optionsp)
        *optionsp = outBuf.options;

    TRACE_VERB("<-%!FUNC! returning %d", WLBS_OK);
    return WLBS_OK;
}


//+----------------------------------------------------------------------------
//
// Function:  NotifyDriverConfigChanges
//
// Description:  Notify wlbs driver to pick up configuration changes from 
//                               registry
//
// Arguments: HANDLE hDeviceWlbs - The WLBS driver device handle
//                         const GUID& - AdapterGuid Adapter guid       
//
//
// Returns:   DWORD - Win32 Error code
//
// History:   fengsun Created Header    2/3/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI NotifyDriverConfigChanges(HANDLE hDeviceWlbs, const GUID& AdapterGuid)
{
    TRACE_VERB("->%!FUNC!");

    LONG                status;

    IOCTL_CVY_BUF       in_buf;
    IOCTL_CVY_BUF       out_buf;

    status = WlbsLocalControl (hDeviceWlbs, AdapterGuid, IOCTL_CVY_RELOAD, & in_buf, & out_buf, NULL);

    if (status == WLBS_IO_ERROR)
    {
        TRACE_CRIT("%!FUNC! call to do local control failed with %d", status);
        return status;
    }

    if (out_buf.ret_code == IOCTL_CVY_BAD_PARAMS)
    {
        TRACE_CRIT("%!FUNC! call to do local control failed due to bad parameters");
        TRACE_VERB("<-%!FUNC! returning %d", WLBS_BAD_PARAMS);
        return WLBS_BAD_PARAMS;
    }

    TRACE_VERB("<-%!FUNC! returning %d", ERROR_SUCCESS);
    return ERROR_SUCCESS;
}


//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsRemoteControl
//
// Description:  Send a remote control packet
//
// Arguments: ONG                 ioctl - 
//            PIOCTL_CVY_BUF      pin_bufp - 
//            PIOCTL_CVY_BUF      pout_bufp - 
//            PWLBS_RESPONSE      pcvy_resp - 
//            PDWORD              nump - 
//            DWORD               trg_addr - 
//            DWORD               hst_addr
//            PIOCTL_REMOTE_OPTIONS optionsp - 
//            PFN_QUERY_CALLBACK  pfnQueryCallBack - function pointer for callback.
//                                                   Used only for remote queries.
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//            chrisdar  07.31.01  Added optional callback function pointer for
//                                query. Allows user to get results from query
//                                as the hosts reply rather than waiting for the
//                                timer to expire. This recovers NT4 behavior.
//            chrisdar  08.06.01  Changed definition of a unique host from host ID
//                                to host ID, host IP (DIP) and host name. Makes
//                                multiple hosts using the same host ID apparent in
//                                queries and the like.
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsRemoteControl
(
    LONG                  ioctl,
    PIOCTL_CVY_BUF        pin_bufp,
    PIOCTL_CVY_BUF        pout_bufp,
    PWLBS_RESPONSE        pcvy_resp,
    PDWORD                nump,
    DWORD                 trg_addr,
    DWORD                 hst_addr,
    PIOCTL_REMOTE_OPTIONS optionsp,
    PFN_QUERY_CALLBACK    pfnQueryCallBack
)
{
    DWORD            timeout;
    WORD             port;
    DWORD            dst_addr;
    DWORD            passw;
    BOOL             fIsLocal = TRUE;
    DWORD            i;

    timeout   = m_def_timeout;
    port      = m_def_port;
    dst_addr  = m_def_dst_addr;
    passw     = m_def_passw;

//    LOCK(m_lock);

    //
    // Find parameters for the cluster 
    //
    for (i = 0; i < WLBS_MAX_CLUSTERS; i ++)
    {
        if (m_cluster_params [i] . cluster == trg_addr)
            break;
    }

    if (i < WLBS_MAX_CLUSTERS)
    {
        timeout  = m_cluster_params [i] . timeout;
        port     = m_cluster_params [i] . port;
        dst_addr = m_cluster_params [i] . dest;
        passw    = m_cluster_params [i] . passw;
    }

    CWlbsCluster* pCluster = GetClusterFromIp(trg_addr);
    if (pCluster == NULL)
    {
        fIsLocal = FALSE;
        TRACE_INFO("%!FUNC! cluster instance not found");
    }
/*    
    if (pCluster)
    {
        //
        // Always uses password in registry for local cluster
        //
        passw = pCluster->GetPassword();
    }
*/
//    UNLOCK(m_lock);

    return WlbsRemoteControlInternal (ioctl, pin_bufp, pout_bufp, pcvy_resp, nump, trg_addr, hst_addr, optionsp, fIsLocal, pfnQueryCallBack, timeout, port, dst_addr, passw);

}


//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsQuery
//
// Description:
//            This function is for internal use only and assumes that the caller
//            has initialized pCluster.
//
// Arguments: CWlbsCluster*      pCluster - 
//            DWORD              host - 
//            PWLBS_RESPONSE     response - 
//            PDWORD             num_hosts - 
//            PDWORD             host_map - 
//            PFN_QUERY_CALLBACK pfnQueryCallBack
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//            chrisdar  07.31.01  Modified interface to replace the reserved
//                                PVOID with an optional callback function pointer.
//                                This is to provide wlbs.exe with host status as
//                                it arrives.
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsQuery
(
    CWlbsCluster*       pCluster,
    DWORD               host,
    PWLBS_RESPONSE      response,
    PDWORD              num_hosts,
    PDWORD              host_map,
    PFN_QUERY_CALLBACK  pfnQueryCallBack
)
{
    TRACE_VERB("->%!FUNC! host 0x%lx", host);

    LONG             ioctl = IOCTL_CVY_QUERY;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;

    ASSERT(pCluster != NULL);

    DWORD dwInitResult = GetInitResult();
    if (dwInitResult == WLBS_INIT_ERROR)
    {
        TRACE_CRIT("%!FUNC! failed checking GetInitResult");
        TRACE_VERB("<-%!FUNC! returning %d", dwInitResult);
        return dwInitResult;
    }

    /* The following condition is to take care of the case when num_hosts is null
     * and host_map contains some junk value. This could crash this function. */

    if (num_hosts == NULL || *num_hosts == 0)
    {
        TRACE_INFO("%!FUNC! caller does not want query results returned");
        response = NULL;
    }

    if (IsLocalHost(pCluster, host))
    {
        IOCTL_CVY_BUF       out_buf;
        IOCTL_LOCAL_OPTIONS localOptions;

        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
            ioctl, & in_buf, & out_buf, &localOptions);
        if (status == WLBS_IO_ERROR)
        {
            TRACE_CRIT("%!FUNC! local control call failed with %d", status);
            TRACE_VERB("<-%!FUNC! returning %d", status);
            return status;
        }

        if (host_map != NULL)
            * host_map = out_buf . data . query . host_map;

        if (response != NULL)
        {
            response [0] . id      = out_buf . data . query . host_id;
            response [0] . address = 0;
            response [0] . status  = MapStateFromDriverToApi (out_buf . data . query . state);

            /* Fill in the optional query information. */
            response[0].options.query.flags = localOptions.query.flags;
            response[0].options.query.NumConvergences = localOptions.query.NumConvergences;
            response[0].options.query.LastConvergence = localOptions.query.LastConvergence;
        }

        if (num_hosts != NULL)
            * num_hosts = 1;

        status = MapStateFromDriverToApi (out_buf . data . query . state);
        TRACE_INFO("%!FUNC! local query returned %d", status);
    }
    else
    {
        status = RemoteQuery(pCluster->GetClusterIp(),
                             host, response, num_hosts, host_map, pfnQueryCallBack);
        TRACE_INFO("%!FUNC! remote query returned %d", status);
    }

    TRACE_VERB("<-%!FUNC! returning %d", status);
    return status;
} 


//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsQuery
//
// Description:  
//
// Arguments: WORD               cluster - 
//            DWORD              host - 
//            PWLBS_RESPONSE     response - 
//            PDWORD             num_hosts - 
//            PDWORD             host_map - 
//            PFN_QUERY_CALLBACK pfnQueryCallBack
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//            chrisdar  07.31.01  Modified interface to replace the reserved
//                                PVOID with an optional callback function pointer.
//                                This is to provide wlbs.exe with host status as
//                                it arrives.
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsQuery
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    PDWORD           host_map,
    PFN_QUERY_CALLBACK    pfnQueryCallBack
)
{
    TRACE_VERB("->%!FUNC! cluster=0x%lx, host=0x%lx", cluster, host);

    DWORD ret;

    DWORD dwInitResult = GetInitResult();

    if (dwInitResult == WLBS_INIT_ERROR)
    {
        TRACE_INFO("%!FUNC! failed checking GetInitResult with %d", dwInitResult);
        ret = dwInitResult;
        goto end;
    }

    if (cluster == WLBS_LOCAL_CLUSTER && dwInitResult == WLBS_REMOTE_ONLY)
    {
        TRACE_INFO("%!FUNC! can't query local cluster; this host is configured for remote only");
        ret = dwInitResult;
        goto end;
    }

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);  
    if (pCluster == NULL)
    {
        ret = RemoteQuery(cluster, host, response, num_hosts, host_map, pfnQueryCallBack);
        TRACE_INFO("%!FUNC! remote query returned %d", ret);
        goto end;
    }
    else
    {
        ret = WlbsQuery(pCluster, host, response, num_hosts, host_map, pfnQueryCallBack);
        TRACE_INFO("%!FUNC! local query returned %d", ret);
        goto end;
    }

end:

    TRACE_VERB("<-%!FUNC! return %d", ret);
    return ret; 
}
 


//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::RemoteQuery
//
// Description:  
//
// Arguments: DWORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts - 
//            PDWORD           host_map - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::RemoteQuery
(
    DWORD                 cluster,
    DWORD                 host,
    PWLBS_RESPONSE        response,
    PDWORD                num_hosts,
    PDWORD                host_map,
    PFN_QUERY_CALLBACK    pfnQueryCallBack
)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx, host 0x%lx", cluster, host);

    LONG                 ioctl = IOCTL_CVY_QUERY;
    DWORD                status;
    IOCTL_CVY_BUF        in_buf;
    IOCTL_CVY_BUF        out_buf [WLBS_MAX_HOSTS];
    DWORD                hosts;
    DWORD                hmap = 0;
    DWORD                active;
    DWORD                i;
    BOOLEAN              bIsMember = IsClusterMember(cluster);
    IOCTL_REMOTE_OPTIONS options;

    DWORD dwInitResult = GetInitResult();
    if (dwInitResult == WLBS_LOCAL_ONLY)
    {
        TRACE_CRIT("%!FUNC! only local actions may be performed");
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (num_hosts != NULL)
        hosts = * num_hosts;
    else
        hosts = 0;

    /* Reset the flags. */
    options.query.flags = 0;
    
    /* If I am myself a member of the target cluster, then set the query cluster flags appropriately. */
    if (bIsMember)
        options.query.flags |= NLB_OPTIONS_QUERY_CLUSTER_MEMBER;
    status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                         cluster, host, &options, pfnQueryCallBack);

    if (status >= WSABASEERR || status == WLBS_TIMEOUT)
    {
        TRACE_CRIT("%!FUNC! remote query failed with %d", status);

        if (num_hosts != NULL)
            * num_hosts = 0;
        
        TRACE_VERB("<-%!FUNC! return %d", status);
        return status;
    }

    if (host == WLBS_ALL_HOSTS)
    {
        for (status = WLBS_STOPPED, active = 0, i = 0; i < hosts; i ++)
        {
            switch (MapStateFromDriverToApi (out_buf [i] . data . query . state))
            {
            case WLBS_SUSPENDED:

                if (status == WLBS_STOPPED)
                    status = WLBS_SUSPENDED;

                break;

            case WLBS_CONVERGING:

                if (status != WLBS_BAD_PASSW)
                    status = WLBS_CONVERGING;

                break;

            case WLBS_DRAINING:

                if (status == WLBS_STOPPED)
                    status = WLBS_DRAINING;

                break;

            case WLBS_CONVERGED:

                if (status != WLBS_CONVERGING && status != WLBS_BAD_PASSW)
                    status = WLBS_CONVERGED;

                hmap = out_buf [i] . data . query . host_map;
                active ++;
                break;

            case WLBS_BAD_PASSW:

                status = WLBS_BAD_PASSW;
                break;

            case WLBS_DEFAULT:

                if (status != WLBS_CONVERGING && status != WLBS_BAD_PASSW)
                    status = WLBS_CONVERGED;

                hmap = out_buf [i] . data . query . host_map;
                active ++;
                break;

            case WLBS_STOPPED:
            default:
                break;

            }
        }

        if (status == WLBS_CONVERGED)
            status = active;

        TRACE_INFO("%!FUNC! result on all hosts is %d", status);
    }
    else
    {
        status = MapStateFromDriverToApi (out_buf [0] . data . query . state);
        hmap = out_buf [0] . data . query . host_map;
        TRACE_INFO("%!FUNC! result on host is %d", status);
    }

    if (host_map != NULL)
        * host_map = hmap;

    if (num_hosts != NULL)
        * num_hosts = hosts;

    TRACE_VERB("<-%!FUNC! return %d", status);
    return status;
} 


//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsSuspend
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsSuspend
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx, host 0x%lx", cluster, host);

    LONG             ioctl = IOCTL_CVY_CLUSTER_SUSPEND;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;

    DWORD dwInitResult = GetInitResult();
    if (dwInitResult == WLBS_INIT_ERROR)
    {
        TRACE_CRIT("%!FUNC! GetInitResult failed with %d", dwInitResult);
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (num_hosts == NULL || *num_hosts == 0)
    {
        TRACE_INFO("%!FUNC! caller does not want host information returned");
        response = NULL;
    }

    CWlbsCluster* pCluster= GetClusterFromIpOrIndex(cluster);
    if (pCluster && dwInitResult == WLBS_REMOTE_ONLY)
    {
        TRACE_CRIT("%!FUNC! host is configured for remote action only and can't perform this action locally");
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (pCluster && IsLocalHost(pCluster, host))
    {
        TRACE_INFO("%!FUNC! executing locally");

        IOCTL_CVY_BUF       out_buf;

        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                    ioctl, & in_buf, & out_buf, NULL);

        if (status == WLBS_IO_ERROR)
        {
            TRACE_CRIT("%!FUNC! local control failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        TRACE_INFO("%!FUNC! executing remotely");

        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;

        if (dwInitResult == WLBS_LOCAL_ONLY)
        {
            TRACE_CRIT("%!FUNC! host is configured for local action only and can't perform this action remotely");
            TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
            return dwInitResult;
        }

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, NULL, NULL /* no callback */);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
        {
            TRACE_CRIT("%!FUNC! remote call failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_STOPPED:
                case WLBS_DRAIN_STOP:
                default:
                    break;
                }
            }
            TRACE_INFO("%!FUNC! result on all hosts is %d", status);
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
            TRACE_INFO("%!FUNC! result on host is %d", status);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    TRACE_VERB("<-%!FUNC! return %d", status);
    return status;
} 

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsResume
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsResume
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx, host 0x%lx", cluster, host);

    LONG             ioctl = IOCTL_CVY_CLUSTER_RESUME;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;

    DWORD dwInitResult = GetInitResult();
    if (dwInitResult == WLBS_INIT_ERROR)
    {
        TRACE_CRIT("%!FUNC! GetInitResult failed with %d", dwInitResult);
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (num_hosts == NULL || *num_hosts == 0)
    {
        TRACE_INFO("%!FUNC! caller does not want host information returned");
        response = NULL;
    }

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    
    if (pCluster && dwInitResult == WLBS_REMOTE_ONLY)
    {
        TRACE_CRIT("%!FUNC! host is configured for remote action only and can't perform this action locally");
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (pCluster && IsLocalHost(pCluster, host))
    {
        TRACE_INFO("%!FUNC! executing locally");

        IOCTL_CVY_BUF       out_buf;

        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, NULL);

        if (status == WLBS_IO_ERROR)
        {
            TRACE_CRIT("%!FUNC! local control failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        TRACE_INFO("%!FUNC! executing remotely");

        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;

        if (dwInitResult == WLBS_LOCAL_ONLY)
        {
            TRACE_CRIT("%!FUNC! host is configured for local action only and can't perform this action remotely");
            TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
            return dwInitResult;
        }

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, NULL, NULL /* no callback */);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
        {
            TRACE_CRIT("%!FUNC! remote call failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }


        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                default:
                    break;
                }
            }
            TRACE_INFO("%!FUNC! result on all hosts is %d", status);
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
            TRACE_INFO("%!FUNC! result on host is %d", status);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    TRACE_VERB("<-%!FUNC! return %d", status);
    return status;
} 

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsStart
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsStart
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx, host 0x%lx", cluster, host);

    LONG             ioctl = IOCTL_CVY_CLUSTER_ON;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;

    DWORD dwInitResult = GetInitResult();
    if (dwInitResult == WLBS_INIT_ERROR)
    {
        TRACE_CRIT("%!FUNC! GetInitResult failed with %d", dwInitResult);
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (num_hosts == NULL || *num_hosts == 0)
    {
        TRACE_INFO("%!FUNC! caller does not want host information returned");
        response = NULL;
    }

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    if (pCluster && dwInitResult == WLBS_REMOTE_ONLY)
    {
        TRACE_CRIT("%!FUNC! host is configured for remote action only and can't perform this action locally");
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (pCluster && IsLocalHost(pCluster, host))
    {
        TRACE_INFO("%!FUNC! executing locally");

        IOCTL_CVY_BUF       out_buf;

        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, NULL);

        if (status == WLBS_IO_ERROR)
        {
            TRACE_CRIT("%!FUNC! local control failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        TRACE_INFO("%!FUNC! executing remotely");

        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;

        if (dwInitResult == WLBS_LOCAL_ONLY)
        {
            TRACE_CRIT("%!FUNC! host is configured for local action only and can't perform this action remotely");
            TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
            return dwInitResult;
        }

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, NULL, NULL /* no callback */);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
        {
            TRACE_CRIT("%!FUNC! remote call failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PARAMS:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_BAD_PARAMS;

                    break;

                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW && status != WLBS_BAD_PARAMS)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_DRAIN_STOP:
                    break;
                default:
                    break;

                }
            }
            TRACE_INFO("%!FUNC! result on all hosts is %d", status);
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
            TRACE_INFO("%!FUNC! result on host is %d", status);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    TRACE_VERB("<-%!FUNC! return %d", status);
    return status;

}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsStop
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsStop
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx, host 0x%lx", cluster, host);

    LONG             ioctl = IOCTL_CVY_CLUSTER_OFF;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;


    DWORD dwInitResult = GetInitResult();
    if (dwInitResult == WLBS_INIT_ERROR)
    {
        TRACE_CRIT("%!FUNC! GetInitResult failed with %d", dwInitResult);
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (num_hosts == NULL || *num_hosts == 0)
    {
        TRACE_INFO("%!FUNC! caller does not want host information returned");
        response = NULL;
    }

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    if (pCluster && dwInitResult == WLBS_REMOTE_ONLY)
    {
        TRACE_CRIT("%!FUNC! host is configured for remote action only and can't perform this action locally");
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (pCluster && IsLocalHost(pCluster, host))
    {
        TRACE_INFO("%!FUNC! executing locally");

        IOCTL_CVY_BUF       out_buf;

        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, NULL);

        if (status == WLBS_IO_ERROR)
        {
            TRACE_CRIT("%!FUNC! local control failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        TRACE_INFO("%!FUNC! executing remotely");

        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;

        if (dwInitResult == WLBS_LOCAL_ONLY)
        {
            TRACE_CRIT("%!FUNC! host is configured for local action only and can't perform this action remotely");
            TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
            return dwInitResult;
        }

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, NULL, NULL /* no callback */);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
        {
            TRACE_CRIT("%!FUNC! remote call failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_DRAIN_STOP:
                default:
                    break;
                }
            }
            TRACE_INFO("%!FUNC! result on all hosts is %d", status);
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
            TRACE_INFO("%!FUNC! result on host is %d", status);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    TRACE_VERB("<-%!FUNC! return %d", status);
    return status;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsDrainStop
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsDrainStop
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx, host 0x%lx", cluster, host);

    LONG             ioctl = IOCTL_CVY_CLUSTER_DRAIN;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;

    DWORD dwInitResult = GetInitResult();
    if (dwInitResult == WLBS_INIT_ERROR)
    {
        TRACE_CRIT("%!FUNC! GetInitResult failed with %d", dwInitResult);
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (num_hosts == NULL || *num_hosts == 0)
    {
        TRACE_INFO("%!FUNC! caller does not want host information returned");
        response = NULL;
    }

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    if (pCluster && dwInitResult == WLBS_REMOTE_ONLY)
    {
        TRACE_CRIT("%!FUNC! host is configured for remote action only and can't perform this action locally");
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (pCluster && IsLocalHost(pCluster, host))
    {
        TRACE_INFO("%!FUNC! executing locally");

        IOCTL_CVY_BUF       out_buf;

        status = WlbsLocalControl (m_hdl,pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, NULL);

        if (status == WLBS_IO_ERROR)
        {
            TRACE_CRIT("%!FUNC! local control failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        TRACE_INFO("%!FUNC! executing remotely");

        IOCTL_CVY_BUF       out_buf [WLBS_MAX_HOSTS];
        DWORD               hosts;
        DWORD               i;

        if (dwInitResult == WLBS_LOCAL_ONLY)
        {
            TRACE_CRIT("%!FUNC! host is configured for local action only and can't perform this action remotely");
            TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
            return dwInitResult;
        }

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, NULL, NULL /* no callback */);

        if (status >= WSABASEERR)
        {
            TRACE_CRIT("%!FUNC! remote call failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (status == WLBS_TIMEOUT)
        {
            TRACE_INFO("%!FUNC! remote call timed out");
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_STOPPED, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:

                    if (status != WLBS_BAD_PASSW && status != WLBS_SUSPENDED)
                        status = WLBS_OK;

                case WLBS_STOPPED:
                default:
                    break;

                }
            }
            TRACE_INFO("%!FUNC! result on all hosts is %d", status);
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
            TRACE_INFO("%!FUNC! result on host is %d", status);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    TRACE_VERB("<-%!FUNC! return %d", status);
    return status;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsEnable
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts - 
//            DWORD            port
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsEnable
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            vip,
    DWORD            port
)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx, host 0x%lx", cluster, host);

    LONG             ioctl = IOCTL_CVY_PORT_ON;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;

    DWORD dwInitResult = GetInitResult();
    if (dwInitResult == WLBS_INIT_ERROR)
    {
        TRACE_CRIT("%!FUNC! GetInitResult failed with %d", dwInitResult);
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (num_hosts == NULL || *num_hosts == 0)
    {
        TRACE_INFO("%!FUNC! caller does not want host information returned");
        response = NULL;
    }

    in_buf . data . port . num = port;

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    if (pCluster && dwInitResult == WLBS_REMOTE_ONLY)
    {
        TRACE_CRIT("%!FUNC! host is configured for remote action only and can't perform this action locally");
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (pCluster && IsLocalHost(pCluster, host))
    {
        TRACE_INFO("%!FUNC! executing locally");

        IOCTL_CVY_BUF       out_buf;
        IOCTL_LOCAL_OPTIONS options;

        /* Set the port options. */
        options.common.port.flags = 0;
        options.common.port.vip = vip;
        
        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, &options);

        if (status == WLBS_IO_ERROR)
        {
            TRACE_CRIT("%!FUNC! local control failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        TRACE_INFO("%!FUNC! executing remotely");

        IOCTL_CVY_BUF        out_buf [WLBS_MAX_HOSTS];
        DWORD                hosts;
        DWORD                i;
        IOCTL_REMOTE_OPTIONS options;

        /* Set the port options. */
        options.common.port.flags = 0;
        options.common.port.vip = vip;

        dwInitResult = GetInitResult();
        if (dwInitResult == WLBS_LOCAL_ONLY)
        {
            TRACE_CRIT("%!FUNC! host is configured for local action only and can't perform this action remotely");
            TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
            return dwInitResult;
        }

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, &options, NULL /* no callback */);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
        {
            TRACE_CRIT("%!FUNC! remote call failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_NOT_FOUND:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_NOT_FOUND;

                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW && status != WLBS_NOT_FOUND)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_STOPPED:
                case WLBS_DRAINING:
                default:
                    break;

                }
            }
            TRACE_INFO("%!FUNC! result on all hosts is %d", status);
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
            TRACE_INFO("%!FUNC! result on host is %d", status);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    TRACE_VERB("<-%!FUNC! return %d", status);
    return status;

}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsDisable
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts - 
//            DWORD            port
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsDisable
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            vip,
    DWORD            port
)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx, host 0x%lx", cluster, host);

    LONG             ioctl = IOCTL_CVY_PORT_OFF;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;

    DWORD dwInitResult = GetInitResult();
    if (dwInitResult == WLBS_INIT_ERROR)
    {
        TRACE_CRIT("%!FUNC! GetInitResult failed with %d", dwInitResult);
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (num_hosts == NULL || *num_hosts == 0)
    {
        TRACE_INFO("%!FUNC! caller does not want host information returned");
        response = NULL;
    }

    in_buf . data . port . num = port;

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    dwInitResult = GetInitResult();
    if (pCluster && (dwInitResult == WLBS_REMOTE_ONLY))
    {
        TRACE_CRIT("%!FUNC! host is configured for remote action only and can't perform this action locally");
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (pCluster && IsLocalHost(pCluster, host))
    {
        TRACE_INFO("%!FUNC! executing locally");

        IOCTL_CVY_BUF       out_buf;
        IOCTL_LOCAL_OPTIONS options;

        /* Set the port options. */
        options.common.port.flags = 0;
        options.common.port.vip = vip;

        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, &options);

        if (status == WLBS_IO_ERROR)
        {
            TRACE_CRIT("%!FUNC! local control failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        TRACE_INFO("%!FUNC! executing remotely");

        IOCTL_CVY_BUF        out_buf [WLBS_MAX_HOSTS];
        DWORD                hosts;
        DWORD                i;
        IOCTL_REMOTE_OPTIONS options;

        /* Set the port options. */
        options.common.port.flags = 0;
        options.common.port.vip = vip;

        if (dwInitResult == WLBS_LOCAL_ONLY)
        {
            TRACE_CRIT("%!FUNC! host is configured for local action only and can't perform this action remotely");
            TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
            return dwInitResult;
        }

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, &options, NULL /* no callback */);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
        {
            TRACE_CRIT("%!FUNC! remote call failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_NOT_FOUND:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_NOT_FOUND;

                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW && status != WLBS_NOT_FOUND)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_STOPPED:
                case WLBS_DRAINING:
                default:
                    break;

                }
            }
            TRACE_INFO("%!FUNC! result on all hosts is %d", status);
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
            TRACE_INFO("%!FUNC! result on host is %d", status);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    TRACE_VERB("<-%!FUNC! return %d", status);
    return status;

}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsDrain
//
// Description:  
//
// Arguments: WORD            cluster - 
//            DWORD            host - 
//            PWLBS_RESPONSE   response - 
//            PDWORD           num_hosts - 
//            DWORD            port
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
DWORD CWlbsControl::WlbsDrain
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            vip,
    DWORD            port
)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx, host 0x%lx", cluster, host);

    LONG             ioctl = IOCTL_CVY_PORT_DRAIN;
    DWORD            status;
    IOCTL_CVY_BUF    in_buf;

    DWORD dwInitResult = GetInitResult();
    if (dwInitResult == WLBS_INIT_ERROR)
    {
        TRACE_CRIT("%!FUNC! GetInitResult failed with %d", dwInitResult);
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (num_hosts == NULL || *num_hosts == 0)
    {
        TRACE_INFO("%!FUNC! caller does not want host information returned");
        response = NULL;
    }

    in_buf . data . port . num = port;

    CWlbsCluster* pCluster = GetClusterFromIpOrIndex(cluster);
    if (pCluster && dwInitResult == WLBS_REMOTE_ONLY)
    {
        TRACE_CRIT("%!FUNC! host is configured for remote action only and can't perform this action locally");
        TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
        return dwInitResult;
    }

    if (pCluster && IsLocalHost(pCluster, host))
    {
        TRACE_INFO("%!FUNC! executing locally");

        IOCTL_CVY_BUF       out_buf;
        IOCTL_LOCAL_OPTIONS options;

        /* Set the port options. */
        options.common.port.flags = 0;
        options.common.port.vip = vip;

        status = WlbsLocalControl (m_hdl, pCluster->GetAdapterGuid(),
                ioctl, & in_buf, & out_buf, &options);

        if (status == WLBS_IO_ERROR)
        {
            TRACE_CRIT("%!FUNC! local control failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (num_hosts != NULL)
            * num_hosts = 0;

        status = MapStateFromDriverToApi (out_buf . ret_code);
    }
    else
    {
        TRACE_INFO("%!FUNC! executing remotely");

        IOCTL_CVY_BUF        out_buf [WLBS_MAX_HOSTS];
        DWORD                hosts;
        DWORD                i;
        IOCTL_REMOTE_OPTIONS options;

        /* Set the port options. */
        options.common.port.flags = 0;
        options.common.port.vip = vip;

        if (dwInitResult == WLBS_LOCAL_ONLY)
        {
            TRACE_CRIT("%!FUNC! host is configured for local action only and can't perform this action remotely");
            TRACE_VERB("<-%!FUNC! return %d", dwInitResult);
            return dwInitResult;
        }

        if (num_hosts != NULL)
            hosts = * num_hosts;
        else
            hosts = 0;

        status = WlbsRemoteControl (ioctl, & in_buf, out_buf, response, & hosts,
                             cluster, host, &options, NULL /* no callback */);

        if (status >= WSABASEERR || status == WLBS_TIMEOUT)
        {
            TRACE_CRIT("%!FUNC! remote call failed with %d", status);
            TRACE_VERB("<-%!FUNC! return %d", status);
            return status;
        }

        if (host == WLBS_ALL_HOSTS)
        {
            for (status = WLBS_OK, i = 0; i < hosts; i ++)
            {
                switch (MapStateFromDriverToApi (out_buf [i] . ret_code))
                {
                case WLBS_BAD_PASSW:

                    status = WLBS_BAD_PASSW;
                    break;

                case WLBS_NOT_FOUND:

                    if (status != WLBS_BAD_PASSW)
                        status = WLBS_NOT_FOUND;

                    break;

                case WLBS_SUSPENDED:

                    if (status != WLBS_BAD_PASSW && status != WLBS_NOT_FOUND)
                        status = WLBS_SUSPENDED;
                    break;

                case WLBS_OK:
                case WLBS_ALREADY:
                case WLBS_STOPPED:
                case WLBS_DRAINING:
                default:
                    break;

                }
            }
            TRACE_INFO("%!FUNC! result on all hosts is %d", status);
        }
        else
        {
            status = MapStateFromDriverToApi (out_buf [0] . ret_code);
            TRACE_INFO("%!FUNC! result on host is %d", status);
        }

        if (num_hosts != NULL)
            * num_hosts = hosts;
    }

    TRACE_VERB("<-%!FUNC! return %d", status);
    return status;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsPortSet
//
// Description:  
//
// Arguments: DWORD cluster - 
//            WORD port - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
VOID CWlbsControl::WlbsPortSet(DWORD cluster, WORD port)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx, port 0x%hx", cluster, port);

    DWORD           i;
    DWORD           j;
    WORD            rct_port;

//    LOCK(global_info.lock);

    if (port == 0)
        rct_port = CVY_DEF_RCT_PORT;
    else
        rct_port = port;

    TRACE_INFO("%!FUNC! using remote control port %d", rct_port);

    if (cluster == WLBS_ALL_CLUSTERS)
    {
        TRACE_INFO("%!FUNC! performing action on all cluster instances");
        /* when all clusters are targeted - change the default and go through
           the entire parameter table setting new values */

        m_def_port = rct_port;

        for (i = 0; i < WLBS_MAX_CLUSTERS; i ++)
            m_cluster_params [i] . port = rct_port;
    }
    else
    {
        TRACE_INFO("%!FUNC! performing action on cluster %d", cluster);
        for (i = 0, j = WLBS_MAX_CLUSTERS; i < WLBS_MAX_CLUSTERS; i ++)
        {
            /* mark an empty slot in case we will have to enter a new value */

            if (j == WLBS_MAX_CLUSTERS && m_cluster_params [i] . cluster == 0)
                j = i;

            if (m_cluster_params [i] . cluster == cluster)
            {
                m_cluster_params [i] . port = rct_port;
                TRACE_INFO("%!FUNC! cluster %d found and port set to %d", cluster, rct_port);
                break;
            }
        }

        /* if we did not locate specified cluster in the table and there is an
           empty slot - enter new cluster info in the table */

        if (i >= WLBS_MAX_CLUSTERS && j != WLBS_MAX_CLUSTERS)
        {
            m_cluster_params [j] . cluster = cluster;
            m_cluster_params [j] . port    = rct_port;
            TRACE_INFO("%!FUNC! cluster %d was not found. A new entry was made and the port set to %d", cluster, rct_port);
        }
    }

//    UNLOCK(global_info.lock);
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsPasswordSet
//
// Description:  
//
// Arguments: WORD           cluster - 
//            PTCHAR          password
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
VOID CWlbsControl::WlbsPasswordSet
(
    DWORD           cluster,
    const WCHAR* password
)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx", cluster);

    DWORD           i;
    DWORD           j;
    DWORD           passw;

//    LOCK(global_info.lock);

    if (password != NULL)
    {
#ifndef UNICODE
        passw = License_string_encode (password);
#else
        passw = License_wstring_encode((WCHAR*)password);
#endif
        TRACE_INFO("%!FUNC! using user-provided password");
    }
    else
    {
        passw = CVY_DEF_RCT_PASSWORD;
        TRACE_INFO("%!FUNC! password not provided. Using default.");
    }

    if (cluster == WLBS_ALL_CLUSTERS)
    {
        TRACE_INFO("%!FUNC! performing action on all cluster instances");

        /* when all clusters are targeted - change the default and go through
           the entire parameter table setting new values */

        m_def_passw = passw;

        for (i = 0; i < WLBS_MAX_CLUSTERS; i ++)
            m_cluster_params [i] . passw = passw;
    }
    else
    {
        TRACE_INFO("%!FUNC! performing action on cluster 0x%lx", cluster);

        for (i = 0, j = WLBS_MAX_CLUSTERS; i < WLBS_MAX_CLUSTERS; i ++)
        {
            /* mark an empty slot in case we will have to enter a new value */

            if (j == WLBS_MAX_CLUSTERS && m_cluster_params [i] . cluster == 0)
                j = i;

            if (m_cluster_params [i] . cluster == cluster)
            {
                m_cluster_params [i] . passw = passw;
                TRACE_INFO("%!FUNC! cluster %d found and password was set", cluster);
                break;
            }
        }

        /* if we did not locate specified cluster in the table and there is an
           empty slot - enter new cluster info in the table */

        if (i >= WLBS_MAX_CLUSTERS && j != WLBS_MAX_CLUSTERS)
        {
            m_cluster_params [j] . cluster = cluster;
            m_cluster_params [j] . passw   = passw;
            TRACE_INFO("%!FUNC! cluster 0x%lx was not found. A new entry was made and the password was set", cluster);
        }
    }

//    UNLOCK(global_info.lock);
    TRACE_VERB("<-%!FUNC!");
} /* end WlbsPasswordSet */

VOID CWlbsControl::WlbsCodeSet
(
    DWORD           cluster,
    DWORD           passw
)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx", cluster);

    DWORD           i;
    DWORD           j;

//    LOCK(global_info.lock);

    if (cluster == WLBS_ALL_CLUSTERS)
    {
        TRACE_INFO("%!FUNC! performing action on all cluster instances");

        /* when all clusters are targeted - change the default and go through
           the entire parameter table setting new values */

        m_def_passw = passw;

        for (i = 0; i < WLBS_MAX_CLUSTERS; i ++)
            m_cluster_params [i] . passw = passw;
    }
    else
    {
        TRACE_INFO("%!FUNC! performing action on cluster 0x%lx", cluster);

        for (i = 0, j = WLBS_MAX_CLUSTERS; i < WLBS_MAX_CLUSTERS; i ++)
        {
            /* mark an empty slot in case we will have to enter a new value */

            if (j == WLBS_MAX_CLUSTERS && m_cluster_params [i] . cluster == 0)
                j = i;

            if (m_cluster_params [i] . cluster == cluster)
            {
                m_cluster_params [i] . passw = passw;
                TRACE_INFO("%!FUNC! cluster 0x%lx found and password was set", cluster);
                break;
            }
        }

        /* if we did not locate specified cluster in the table and there is an
           empty slot - enter new cluster info in the table */

        if (i >= WLBS_MAX_CLUSTERS && j != WLBS_MAX_CLUSTERS)
        {
            m_cluster_params [j] . cluster = cluster;
            m_cluster_params [j] . passw   = passw;
            TRACE_INFO("%!FUNC! cluster 0x%lx was not found. A new entry was made and the password was set", cluster);
        }
    }

//    UNLOCK(global_info.lock);
    TRACE_VERB("<-%!FUNC!");

} /* end WlbsCodeSet */

VOID CWlbsControl::WlbsDestinationSet
(
    DWORD           cluster,
    DWORD           dest
)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx, dest 0x%lx", cluster, dest);

    DWORD           i;
    DWORD           j;

//    LOCK(global_info.lock);

    if (cluster == WLBS_ALL_CLUSTERS)
    {
        TRACE_INFO("%!FUNC! performing action on all cluster instances");
        /* when all clusters are targeted - change the default and go through
           the entire parameter table setting new values */

        m_def_dst_addr = dest;

        for (i = 0; i < WLBS_MAX_CLUSTERS; i ++)
            m_cluster_params [i] . dest = dest;
    }
    else
    {
        TRACE_INFO("%!FUNC! performing action on cluster 0x%lx", cluster);
        for (i = 0, j = WLBS_MAX_CLUSTERS; i < WLBS_MAX_CLUSTERS; i ++)
        {
            /* mark an empty slot in case we will have to enter a new value */

            if (j == WLBS_MAX_CLUSTERS && m_cluster_params [i] . cluster == 0)
                j = i;

            if (m_cluster_params [i] . cluster == cluster)
            {
                TRACE_INFO("%!FUNC! cluster 0x%lx found and destination set to %d", cluster, dest);
                m_cluster_params [i] . dest = dest;
                break;
            }
        }

        /* if we did not locate specified cluster in the table and there is an
           empty slot - enter new cluster info in the table */

        if (i >= WLBS_MAX_CLUSTERS && j != WLBS_MAX_CLUSTERS)
        {
            m_cluster_params [j] . cluster = cluster;
            m_cluster_params [j] . dest    = dest;
            TRACE_INFO("%!FUNC! cluster 0x%lx was not found. A new entry was made and the desintation set to 0x%lx", cluster, dest);
        }
    }

//    UNLOCK(global_info.lock);
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsControl::WlbsTimeoutSet
//
// Description:  
//
// Arguments: DWORD cluster - 
//            DWORD milliseconds - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/25/00
//
//+----------------------------------------------------------------------------
VOID CWlbsControl::WlbsTimeoutSet(DWORD cluster, DWORD milliseconds)
{
    TRACE_VERB("->%!FUNC! cluster 0x%lx, milliseconds 0x%lx", cluster, milliseconds);

    DWORD           i;
    DWORD           j;
    DWORD           timeout;

//    LOCK(global_info.lock);

    if (milliseconds == 0)
        timeout = IOCTL_REMOTE_RECV_DELAY;
    else
        timeout = milliseconds / (IOCTL_REMOTE_SEND_RETRIES *
                                  IOCTL_REMOTE_RECV_RETRIES);

    if (timeout < 10)
        timeout = 10;

    TRACE_INFO("%!FUNC! using timeout value of %d", timeout);

    if (cluster == WLBS_ALL_CLUSTERS)
    {
        TRACE_INFO("%!FUNC! performing action on all cluster instances");
        /* when all clusters are targeted - change the default and go through
           the entire parameter table setting new values */

        m_def_timeout = timeout;

        for (i = 0; i < WLBS_MAX_CLUSTERS; i ++)
            m_cluster_params [i] . timeout = timeout;
    }
    else
    {
        TRACE_INFO("%!FUNC! performing action on cluster 0x%lx", cluster);
        for (i = 0, j = WLBS_MAX_CLUSTERS; i < WLBS_MAX_CLUSTERS; i ++)
        {
            /* mark an empty slot in case we will have to enter a new value */

            if (j == WLBS_MAX_CLUSTERS && m_cluster_params [i] . cluster == 0)
                j = i;

            if (m_cluster_params [i] . cluster == cluster)
            {
                m_cluster_params [i] . timeout = timeout;
                TRACE_INFO("%!FUNC! cluster 0x%lx found and timeout set to %d", cluster, timeout);
                break;
            }
        }

        /* if we did not locate specified cluster in the table and there is an
           empty slot - enter new cluster info in the table */

        if (i >= WLBS_MAX_CLUSTERS && j < WLBS_MAX_CLUSTERS)
        {
            m_cluster_params [j] . cluster = cluster;
            m_cluster_params [j] . timeout = timeout;
            TRACE_INFO("%!FUNC! cluster 0x%lx was not found. A new entry was made and the timeout to %d", cluster, timeout);
        }
    }

//    UNLOCK(global_info.lock);
    TRACE_VERB("<-%!FUNC!");
} /* end WlbsTimeoutSet */

DWORD CWlbsControl::WlbsQueryLocalState (CWlbsCluster * pCluster, DWORD operation, PNLB_OPTIONS pOptions, PWLBS_RESPONSE pResponse, PDWORD pcResponses) {
    DWORD               status = WLBS_OK;
    IOCTL_CVY_BUF       in_buf;
    IOCTL_CVY_BUF       out_buf;
    IOCTL_LOCAL_OPTIONS localOptions;

    ASSERT(pCluster);
    ASSERT(pOptions);
    ASSERT(pResponse);
    ASSERT(pcResponses);

    switch (operation) {
    case IOCTL_CVY_QUERY_BDA_TEAMING:
        localOptions.state.flags = 0;
        localOptions.state.bda = pOptions->state.bda;
        
        status = WlbsLocalControl(m_hdl, pCluster->GetAdapterGuid(), operation, &in_buf, &out_buf, &localOptions);

        if (status == WLBS_IO_ERROR) return WLBS_IO_ERROR;

        pResponse[0].id                   = out_buf.data.query.host_id;
        pResponse[0].address              = 0;
        pResponse[0].status               = MapStateFromDriverToApi(out_buf.ret_code);
        pResponse[0].options.state.flags  = localOptions.state.flags;
        pResponse[0].options.state.bda    = localOptions.state.bda;

        if (pcResponses != NULL) *pcResponses = 1;

        break;
    case IOCTL_CVY_QUERY_PARAMS:
        localOptions.state.flags = 0;
        localOptions.state.params = pOptions->state.params;
        
        status = WlbsLocalControl(m_hdl, pCluster->GetAdapterGuid(), operation, &in_buf, &out_buf, &localOptions);

        if (status == WLBS_IO_ERROR) return WLBS_IO_ERROR;

        pResponse[0].id                   = out_buf.data.query.host_id;
        pResponse[0].address              = 0;
        pResponse[0].status               = MapStateFromDriverToApi(out_buf.ret_code);
        pResponse[0].options.state.flags  = localOptions.state.flags;
        pResponse[0].options.state.params = localOptions.state.params;

        if (pcResponses != NULL) *pcResponses = 1;

        break;
    case IOCTL_CVY_QUERY_PORT_STATE:
        localOptions.common.state.flags = 0;
        localOptions.common.state.port = pOptions->state.port;
        
        status = WlbsLocalControl(m_hdl, pCluster->GetAdapterGuid(), operation, &in_buf, &out_buf, &localOptions);

        if (status == WLBS_IO_ERROR) return WLBS_IO_ERROR;

        pResponse[0].id                   = out_buf.data.query.host_id;
        pResponse[0].address              = 0;
        pResponse[0].status               = MapStateFromDriverToApi(out_buf.ret_code);
        pResponse[0].options.state.flags  = localOptions.common.state.flags;
        pResponse[0].options.state.port   = localOptions.common.state.port;

        if (pcResponses != NULL) *pcResponses = 1;

        break;
    case IOCTL_CVY_QUERY_FILTER:
        localOptions.common.state.flags = 0;
        localOptions.common.state.filter = pOptions->state.filter;
        
        status = WlbsLocalControl(m_hdl, pCluster->GetAdapterGuid(), operation, &in_buf, &out_buf, &localOptions);

        if (status == WLBS_IO_ERROR) return WLBS_IO_ERROR;

        pResponse[0].id                   = out_buf.data.query.host_id;
        pResponse[0].address              = 0;
        pResponse[0].status               = MapStateFromDriverToApi(out_buf.ret_code);
        pResponse[0].options.state.flags  = localOptions.common.state.flags;
        pResponse[0].options.state.filter = localOptions.common.state.filter;

        if (pcResponses != NULL) *pcResponses = 1;

        break;
    default:
        return WLBS_IO_ERROR;
    }

    return status; 
}

DWORD CWlbsControl::WlbsQueryRemoteState (DWORD cluster, DWORD host, DWORD operation, PNLB_OPTIONS pOptions, PWLBS_RESPONSE pResponse, PDWORD pcResponses) {
    DWORD                status = WLBS_OK;
    IOCTL_CVY_BUF        in_buf;
    IOCTL_CVY_BUF        out_buf[WLBS_MAX_HOSTS];
    IOCTL_REMOTE_OPTIONS remoteOptions;
    BOOLEAN              bIsMember = IsClusterMember(cluster);

    ASSERT(pOptions);
    ASSERT(pResponse);
    ASSERT(pcResponses);

    if (GetInitResult() == WLBS_LOCAL_ONLY) return WLBS_LOCAL_ONLY;

    switch (operation) {
    case IOCTL_CVY_QUERY_PARAMS:
    case IOCTL_CVY_QUERY_BDA_TEAMING:
        return WLBS_LOCAL_ONLY;
    case IOCTL_CVY_QUERY_PORT_STATE:
        remoteOptions.common.state.flags = 0;
        remoteOptions.common.state.port = pOptions->state.port;
        
        status = WlbsRemoteControl(operation, &in_buf, out_buf, pResponse, pcResponses, cluster, host, &remoteOptions, NULL /* no callback */);
        
        if (status >= WSABASEERR || status == WLBS_TIMEOUT) *pcResponses = 0;

        break;
    case IOCTL_CVY_QUERY_FILTER:
        remoteOptions.common.state.flags = 0;
        remoteOptions.common.state.filter = pOptions->state.filter;
        
        status = WlbsRemoteControl(operation, &in_buf, out_buf, pResponse, pcResponses, cluster, host, &remoteOptions, NULL /* no callback */);
        
        if (status >= WSABASEERR || status == WLBS_TIMEOUT) *pcResponses = 0;

        break;
    default:
        return WLBS_IO_ERROR;
    }

    return status;
}

DWORD CWlbsControl::WlbsQueryState (DWORD cluster, DWORD host, DWORD operation, PNLB_OPTIONS pOptions, PWLBS_RESPONSE pResponse, PDWORD pcResponses) {
    DWORD          status = WLBS_OK;
    CWlbsCluster * pCluster = NULL;

    ASSERT(pOptions);
    ASSERT(pResponse);
    ASSERT(pcResponses);

    if (GetInitResult() == WLBS_INIT_ERROR) return WLBS_INIT_ERROR;

    if (cluster == WLBS_LOCAL_CLUSTER && (GetInitResult() == WLBS_REMOTE_ONLY)) return WLBS_REMOTE_ONLY;

    pCluster = GetClusterFromIpOrIndex(cluster);  

    if (!pCluster || !IsLocalHost(pCluster, host))
        status = WlbsQueryRemoteState(cluster, host, operation, pOptions, pResponse, pcResponses);
    else
        status = WlbsQueryLocalState(pCluster, operation, pOptions, pResponse, pcResponses);

    return status;
}


//+----------------------------------------------------------------------------
//
// Function:  DllMain
//
// Description:  Dll entry point
//
// Arguments: HINSTANCE handle - 
//            DWORD reason - 
//            LPVOID situation - 
//
// Returns:   BOOL WINAPI - 
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
BOOL WINAPI DllMain(HINSTANCE handle, DWORD reason, LPVOID situation)
{
    BOOL fRet = TRUE;

    switch (reason)
    {
    case DLL_PROCESS_ATTACH:
        _tsetlocale (LC_ALL, _TEXT(".OCP"));
        DisableThreadLibraryCalls(handle);
        g_hInstCtrl = handle; 

        //
        // Enable tracing
        //
        WPP_INIT_TRACING(L"Microsoft\\NLB");

        if (WlbsInitializeConnectionNotify() != ERROR_SUCCESS)
        {
            fRet = FALSE;
        }
        break;
    
    case DLL_THREAD_ATTACH:        
        break;

    case DLL_PROCESS_DETACH:
        //
        // Disable tracing
        //
        WPP_CLEANUP();

        WlbsUninitializeConnectionNotify();

        break;

    case DLL_THREAD_DETACH:
        break;

    default:
        fRet = FALSE;
        break;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\control.h ===
#ifndef WLBSCONTROL_H
#define WLBSCONTROL_H

#include "cluster.h"

class CWlbsCluster;

//+----------------------------------------------------------------------------
//
// class CWlbsControl
//
// Description:  This class is exported to perform cluster control operation,
//               as well as get Cluster objects
//
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
class __declspec(dllexport) CWlbsControl
{
friend DWORD WINAPI WlbsCommitChanges(DWORD cluster);

public:
    CWlbsControl();
    ~CWlbsControl();
    DWORD Initialize();
    bool  ReInitialize();

    //
    // ChrisDar 2002-01-10
    //
    // Though this is a public method it is intended to be called internally.
    // External use of query should go through the WlbsQuery method that
    // takes a DWORD for the cluster argument.
    //
    DWORD WlbsQuery(CWlbsCluster* pCluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts,
        PDWORD           host_map,
        PFN_QUERY_CALLBACK  pfnQueryCallBack);

    DWORD WlbsQuery(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts,
        PDWORD           host_map,
        PFN_QUERY_CALLBACK  pfnQueryCallBack);

    DWORD WlbsQueryState
        (
            DWORD          cluster,
            DWORD          host,
            DWORD          operation,
            PNLB_OPTIONS   pOptions,
            PWLBS_RESPONSE pResponse,
            PDWORD         pcResponses
        );

    DWORD WlbsSuspend(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts);


    DWORD WlbsResume(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts);

    DWORD WlbsStart(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts);

    DWORD WlbsStop(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts);

    DWORD WlbsDrainStop(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts);

    DWORD WlbsEnable(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts,
        DWORD            vip,
        DWORD            port);

    DWORD WlbsDisable(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts,
        DWORD            vip,
        DWORD            port);

    DWORD WlbsDrain(DWORD            cluster,
        DWORD            host,
        PWLBS_RESPONSE   response,
        PDWORD           num_hosts,
        DWORD            vip,
        DWORD            port);

    //
    // Set remote control parameters
    //
    void WlbsPortSet(DWORD cluster, WORD port);
    void WlbsPasswordSet(DWORD cluster, const WCHAR* password);
    void WlbsCodeSet(DWORD cluster, DWORD passw);
    void WlbsDestinationSet(DWORD cluster, DWORD dest);
    void WlbsTimeoutSet(DWORD cluster, DWORD milliseconds);

    DWORD EnumClusters(OUT DWORD* pdwAddresses, IN OUT DWORD* pdwNum); // for API wrapper
    DWORD GetClusterNum() { return m_dwNumCluster;}
    DWORD EnumClusterObjects(OUT CWlbsCluster** &ppClusters, OUT DWORD* pdwNum);

    CWlbsCluster* GetClusterFromIp(DWORD dwClusterIp);
    CWlbsCluster* GetClusterFromIpOrIndex(DWORD dwClusterIpOrIndex);


    HANDLE GetDriverHandle() {return m_hdl;}


    //
    // GetClusterFromAdapter looks up an adapter based on its GUID.
    //
    CWlbsCluster*
    GetClusterFromAdapter(
        IN const GUID &AdapterGuid
        );

    //
    // ValidateParam validates and fixes up the specified parameters structure. It has no side effects other than changing some
    // fields within paramp, such as IP addresses which may be reformatted into canonical form.
    //
    BOOL
    ValidateParam(
        IN OUT PWLBS_REG_PARAMS paramp
        );

    //
    // Performs local cluster-wide control operations on the specified GUID. 
    //
    /* OBSOLETE
   DWORD LocalClusterControl(
        IN const GUID& AdapterGuid,
        IN LONG    ioctl
        );
        */
   

    BOOLEAN IsClusterMember (DWORD dwClusterIp);

protected:
    struct WLBS_CLUSTER_PARAMS
    {
        DWORD           cluster;
        DWORD           passw;
        DWORD           timeout;
        DWORD           dest;
        WORD            port;
        WORD            valid;
    };

    enum { WLBS_MAX_CLUSTERS = 128};
    WLBS_CLUSTER_PARAMS m_cluster_params [WLBS_MAX_CLUSTERS]; // Cluster settings for remote control

    BOOL         m_init_once;    // whether WlbsInit is called
    BOOL         m_remote_ctrl;  // Whether remote operation can be performed on this machine
    BOOL         m_local_ctrl;   // Whether local operation can be performed on this machine
    HANDLE       m_hdl;          // handle to the device object
//    HANDLE       lock;         // An mutex
    DWORD        m_def_dst_addr;   // Default destination address for all clusters, set by WlbsDestinationSet
    DWORD        m_def_timeout;// Time out value for remote control
    WORD         m_def_port;           // UDP port for remote control
    DWORD        m_def_passw;  // Default password for remote control
    HANDLE       m_registry_lock; // used for mutually exclusive access to the registry, should use named lock 
    DWORD m_dwNumCluster;       // number of clusters on this host

    CWlbsCluster* m_pClusterArray[WLBS_MAX_CLUSTERS];  // an array of all clusters
    
    DWORD GetInitResult()
    {
        if (m_local_ctrl && m_remote_ctrl)
            return WLBS_PRESENT;
        if (m_local_ctrl)
            return WLBS_LOCAL_ONLY;
        else if (m_remote_ctrl)
            return WLBS_REMOTE_ONLY;
        else
            return WLBS_INIT_ERROR;
    };

    bool IsInitialized() const {return m_hdl != INVALID_HANDLE_VALUE;}
    
    DWORD RemoteQuery(DWORD cluster,
        DWORD               host,
        PWLBS_RESPONSE      response,
        PDWORD              num_hosts,
        PDWORD              host_map,
        PFN_QUERY_CALLBACK  pfnQueryCallBack);
        
    DWORD WlbsRemoteControl(LONG          ioctl,
                    PIOCTL_CVY_BUF        pin_bufp,
                    PIOCTL_CVY_BUF        pout_bufp,
                    PWLBS_RESPONSE        pcvy_resp,
                    PDWORD                nump,
                    DWORD                 trg_addr,
                    DWORD                 hst_addr,
                    PIOCTL_REMOTE_OPTIONS optionsp,
                    PFN_QUERY_CALLBACK    pfnQueryCallBack);
    
    DWORD WlbsQueryLocalState
        (
            CWlbsCluster * pCluster,
            DWORD          operation,
            PNLB_OPTIONS   pOptions,
            PWLBS_RESPONSE pResponse,
            PDWORD         pcResponses
        );

    DWORD WlbsQueryRemoteState
        (
            DWORD          cluster,
            DWORD          host,
            DWORD          operation,
            PNLB_OPTIONS   pOptions,
            PWLBS_RESPONSE pResponse,
            PDWORD         pcResponses
        );
};


DWORD WlbsLocalControl(HANDLE hDevice, const GUID& AdapterGuid,
                       LONG ioctl, PIOCTL_CVY_BUF in_bufp, 
                       PIOCTL_CVY_BUF out_bufp, PIOCTL_LOCAL_OPTIONS optionsp);

DWORD WINAPI WlbsLocalControlWrapper(HANDLE      hdl,
                                     const GUID& AdapterGuid,
                                     LONG        ioctl);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\makefile.inc ===
$(O)\wlbsapi.res: wlbsapi.rc
$(O)\wlbsapitest.res: wlbsapitest.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\license.c ===
/*++

Copyright(c) 2000  Microsoft Corporation

Module Name:

    license.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    Code to encrypt/decrypt passwords and port rules.

Author:

    kyrilf

History:

    JosephJ 11/22/00 Gutted this file and folded in three constants from
                the now defunct license.h. Basically the functions in this
                file used to do lots of things but now only encrypt/decrypt
                port rules and passwords. The port rules stuff is only used
                for upgrading from olde versions of wlbs so that may go away
                as well.

        This file is located in two places:
            WLBS netconfig code -- net\config\netcfg\wlbscfg
            WLBS API code -- net\wlbs\api

        Because this involves password encryption, we don't want to make
        the functions callable via a DLL entrypoint, and setting up
        a static library to be shared between netconfig and api stuff is
        not trivial and overkill because the two trees are far apart.
        
--*/
#include <precomp.h>


/* CONSTANTS */


static UCHAR    data_key [] =
                            { 0x3f, 0xba, 0x6e, 0xf0, 0xe1, 0x44, 0x1b, 0x45,
                              0x41, 0xc4, 0x9f, 0xfb, 0x46, 0x54, 0xbc, 0x43 };

static UCHAR    str_key [] =

                           { 0xdb, 0x1b, 0xac, 0x1a, 0xb9, 0xb1, 0x18, 0x03,
                             0x55, 0x57, 0x4a, 0x62, 0x36, 0x21, 0x7c, 0xa6 };


/* Encryption and decryption routines are based on a public-domain Tiny
   Encryption Algorithm (TEA) by David Wheeler and Roger Needham at the
   Computer Laboratory of Cambridge University. For reference, please
   consult http://vader.brad.ac.uk/tea/tea.shtml */


static VOID License_decipher (
    PULONG              v,
    PULONG              k)
{
   ULONG                y = v [0],
                        z = v [1],
                        a = k [0],
                        b = k [1],
                        c = k [2],
                        d = k [3],
                        n = 32,
                        sum = 0xC6EF3720,
                        delta = 0x9E3779B9;

    /* sum = delta<<5, in general sum = delta * n */

    while (n-- > 0)
    {
        z -= (y << 4) + c ^ y + sum ^ (y >> 5) + d;
        y -= (z << 4) + a ^ z + sum ^ (z >> 5) + b;
        sum -= delta;
    }

    v [0] = y; v [1] = z;

} /* end License_decipher */


static VOID License_encipher (
    PULONG              v,
    PULONG              k)
{
    ULONG               y = v [0],
                        z = v [1],
                        a = k [0],
                        b = k [1],
                        c = k [2],
                        d = k [3],
                        n = 32,
                        sum = 0,
                        delta = 0x9E3779B9;

    while (n-- > 0)
    {
        sum += delta;
        y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
        z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;
    }

    v [0] = y; v [1] = z;

} /* end License_encipher */



BOOL License_data_decode (
    PCHAR               data,
    ULONG               len)
{
    ULONG               i;


    if (len % LICENSE_DATA_GRANULARITY != 0)
        return FALSE;

    for (i = 0; i < len; i += LICENSE_DATA_GRANULARITY)
        License_decipher ((PULONG) (data + i), (PULONG) data_key);

    return TRUE;

} /* License_data_decode */


ULONG License_string_encode (
    PCHAR               str)
{
    CHAR                buf [LICENSE_STR_IMPORTANT_CHARS + 1];
    ULONG               code, i;
    PULONG              nibp;


    for (i = 0; i < LICENSE_STR_IMPORTANT_CHARS; i++)
    {
        if (str[i] == 0)
            break;

        buf[i] = str[i];
    }

    for (; i < LICENSE_STR_IMPORTANT_CHARS + 1; i ++)
        buf[i] = 0;

    for (i = 0; i < LICENSE_STR_NIBBLES; i ++)
        License_encipher ((PULONG) (buf + i * LICENSE_DATA_GRANULARITY),
                          (PULONG) str_key);

    for (i = 0, code = 0; i < LICENSE_STR_NIBBLES; i ++)
    {
        nibp = (PULONG) (buf + (i * LICENSE_DATA_GRANULARITY));
        code ^= nibp [0] ^ nibp [1];
    }

    /* V2.2 - if password consists of the same characters - XORing nibbles
       above makes it go to 0 - put some recovery for that special case since
       we cannot modify the algorithm due to legacy issues */

    if (code == 0 && str [0] != 0)
        code = * ((PULONG) buf);

    return code;

} /* License_string_encode */

ULONG License_wstring_encode (
    PWCHAR              str)
{
    CHAR                buf [LICENSE_STR_IMPORTANT_CHARS + 1];
    ULONG               code, i;
    PULONG              nibp;


    for (i = 0; i < LICENSE_STR_IMPORTANT_CHARS; i++)
    {
        if (str[i] == 0)
            break;

        buf[i] = (UCHAR)str[i];
    }

    for (; i < LICENSE_STR_IMPORTANT_CHARS + 1; i ++)
        buf[i] = 0;

    for (i = 0; i < LICENSE_STR_NIBBLES; i ++)
        License_encipher ((PULONG) (buf + i * LICENSE_DATA_GRANULARITY),
                          (PULONG) str_key);

    for (i = 0, code = 0; i < LICENSE_STR_NIBBLES; i ++)
    {
        nibp = (PULONG) (buf + (i * LICENSE_DATA_GRANULARITY));
        code ^= nibp [0] ^ nibp [1];
    }

    /* V2.2 - if password consists of the same characters - XORing nibbles
       above makes it go to 0 - put some recovery for that special case since
       we cannot modify the algorithm due to legacy issues */

    if (code == 0 && str [0] != 0)
        code = * ((PULONG) buf);

    return code;

} /* License_wstring_encode */


BOOL License_data_encode (
    PCHAR               data,
    ULONG               len)
{
    ULONG               i;


    if (len % LICENSE_DATA_GRANULARITY != 0)
        return FALSE;

    for (i = 0; i < len; i += LICENSE_DATA_GRANULARITY)
        License_encipher ((PULONG) (data + i), (PULONG) data_key);

    return TRUE;

} /* License_data_encode */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\license.h ===
#ifdef  __cplusplus
extern "C"
{
#endif

ULONG License_string_encode (
    PCHAR               str);               /* NULL-terminated character string */
/*
  Encodes string

  returns ULONG:
    <code> => encoded string

  function:
*/

ULONG License_wstring_encode (
    PWCHAR              str);               /* NULL-terminated wide character string */
/*
  Encodes string

  returns ULONG:
    <code> => encoded string

  function:
*/


BOOL License_data_encode (
    PCHAR               data,               /* pointer to data */
    ULONG               len);               /* data length in bytes */
/*
  Encodes arbitrary data stream

  returns BOOL:
    TRUE  => data encoded OK
    FALSE => length has to be the multiples of LICENSE_DATA_GRANULARITY  bytes

  function:
*/


BOOL License_data_decode (
    PCHAR               data,               /* pointer to data */
    ULONG               len);               /* data length in bytes */
/*
  Decodes arbitrary data stream

  returns BOOL:
    TRUE  => data encoded OK
    FALSE => length has to be the multiples of LICENSE_DATA_GRANULARITY bytes

  function:
*/

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\precomp.h ===
#include <windows.h>
#include <winsock2.h>
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>
#include <tchar.h>
#include <setupapi.h>
#include <devguid.h>
#include <objbase.h>
#include <shlwapi.h>
#include <strsafe.h>

#include <wlbsctrl.h>
#include <wlbsparm.h>
#include <wlbsiocl.h>
#include <wlbsconfig.h>
#include <wlbsutil.h>


#include "license.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\notification.h ===
#ifndef NOTIFICATION_H
#define NOTIFICATION_H
DWORD
WlbsInitializeConnectionNotify();

VOID
WlbsUninitializeConnectionNotify();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\param.h ===
//+----------------------------------------------------------------------------
//
// File:         param.h
//
// Module:       WLBS API
//
// Description: Function here are used by API internally and by notifier object 
//              externally
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:       fengsun Created    3/9/00
//
//+----------------------------------------------------------------------------

#pragma once

#include "wlbsconfig.h"
#include "wlbsutil.h"

#define WLBS_FIELD_LOW 0
#define WLBS_FIELD_HIGH 255
#define WLBS_IP_FIELD_ZERO_LOW 1
#define WLBS_IP_FIELD_ZERO_HIGH 223


bool WINAPI ParamReadReg
(
    const GUID& AdapterGuid,    /* IN  - Adapter GUID */
    PWLBS_REG_PARAMS reg_data,   /* OUT - Registry parameters */
    bool fUpgradeFromWin2k = false,
    bool *pfPortRulesInBinaryForm = NULL
);

BOOL WINAPI WlbsValidateParams
(
    PWLBS_REG_PARAMS paramp  /* IN OUT - Registry parameters */
);

bool WINAPI ParamWriteReg
(
    const GUID& AdapterGuid,    /* IN  - Adapter GUID */
    PWLBS_REG_PARAMS reg_data   /* IN - Registry parameters */
);

bool WINAPI ParamDeleteReg
(
    const GUID& AdapterGuid,    /* IN  - Adapter GUID */
    bool  fDeleteObsoleteEntries = false
);

DWORD WINAPI ParamSetDefaults(PWLBS_REG_PARAMS    reg_data);

bool WINAPI RegChangeNetworkAddress(const GUID& AdapterGuid, const WCHAR* mac_address, BOOL fRemove);

void WINAPI NotifyAdapterAddressChange (const WCHAR * driver_name);
void WINAPI NotifyAdapterAddressChangeEx (const WCHAR * driver_name, const GUID& AdapterGuid, bool bWaitAndQuery);
void WINAPI GetDriverNameFromGUID (const GUID & AdapterGuid, OUT TCHAR * driver_name, DWORD size);
void WINAPI NotifyAdapterPropertyChange (const WCHAR * driver_name, DWORD eventFlag);

DWORD WINAPI NotifyDriverConfigChanges(HANDLE hDeviceWlbs, const GUID& AdapterGuid);

bool WINAPI RegReadAdapterIp(const GUID& AdapterGuid,   
        OUT DWORD& dwClusterIp, OUT DWORD& dwDedicatedIp);

HKEY WINAPI RegOpenWlbsSetting(const GUID& AdapterGuid, bool fReadOnly = false);

DWORD ParamWriteConfig(const GUID&      AdapterGuid,
                       WLBS_REG_PARAMS* new_reg_params, 
                       WLBS_REG_PARAMS* old_reg_params, 
                       bool *           p_reload_required, 
                       bool *           p_notify_adapter_required);

DWORD ParamCommitChanges(const GUID& AdapterGuid, 
                         HANDLE      hDeviceWlbs, 
                         DWORD&      cl_addr, 
                         DWORD&      ded_addr, 
                         bool *      p_reload_required,
                         bool *      p_mac_addr_change);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\wlbsapitest.c ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <winsock.h>
#include <tchar.h>
#include <iphlpapi.h>


#include "wlbsctrl.h"
#include "wlbsparm.h"
#include "wlbsiocl.h"

#define BUF_SIZE 256

typedef enum
{
    init,
    query,
    suspend,
    resume,
    wlbsstart,
    stop,
    drainstop,
    enable,
    disable,
    drain,
    resolve,
    addresstostring,
    addresstoname,
    readreg,
    writereg,
    commit,
    getnumportrules,
    enumportrules,
    getportrule,
    addportrule,
    deleteportrule,
    setpassword,
    portset,
    destinationset,
    timeoutset,
    codeset
}
TEST_COMMAND;

PTCHAR ErrStrings [] = {_TEXT("Init"),
    _TEXT("Query"),
    _TEXT("Suspend"),
    _TEXT("Resume"),
    _TEXT("Start"),
    _TEXT("Stop"),
    _TEXT("DrainStop"),
    _TEXT("Enable"),
    _TEXT("Disable"),
    _TEXT("Drain"),
    _TEXT("Resolve"),
    _TEXT("AddressToString"),
    _TEXT("AddressToName"),
    _TEXT("ReadReg"),
    _TEXT("WriteReg"),
    _TEXT("Commit"),
    _TEXT("GetNumPortRules"),
    _TEXT("EnumPortRules"),
    _TEXT("GetPortRule"),
    _TEXT("AddPortRule"),
    _TEXT("SetPassword"),
    _TEXT("PortSet"),
    _TEXT("DestinationSet"),
    _TEXT("TimeoutSet"),
    _TEXT("CodeSet"),
};

typedef struct Err_Struct
{
    struct Err_Struct * next;
    TCHAR comment [BUF_SIZE];
}
Err_Struct, * PErr_Struct;

static global_init = WLBS_INIT_ERROR;
static PErr_Struct headq = NULL, tailq = NULL;
static total_tests  = 0;
static failed_tests = 0;
static TCHAR remote_password [BUF_SIZE];
static TCHAR tbuf [BUF_SIZE];
static TCHAR status_buf [BUF_SIZE];
static BOOL verbose = FALSE;
static remote_cl_ip = 0;
static remote_host_ip = 0;
static BOOL remote_test = FALSE;
static BOOL local_test = FALSE;
static BOOL init_test = FALSE;
static BOOL version_nt4 = FALSE;
static timeout = 1000; /* 1 second by default */

void print_error_messages ();
/* This function adds a error message to the list of error messages.
 * This list will be displayed at the end.
 */
void add_error (PTCHAR errmsg)
{
    PErr_Struct err = (PErr_Struct) malloc (sizeof (Err_Struct));
    
    total_tests ++;
    failed_tests++;
    _tcscpy (err -> comment, errmsg);
    err -> next = NULL;
    
    if (tailq == NULL)
        headq = tailq = err;
    else
    {
        tailq -> next = err;
        tailq = err;
    }

    if (verbose)
        _tprintf (_TEXT("%s\n"), err -> comment);

    return;
}


/* Compares the expected value with the actual returned value and generates an error message
 * which gets appended to the list of error messages
 */
void verify_return_value (PTCHAR string, DWORD expected, DWORD actual)
{

    TCHAR tbuf [BUF_SIZE];


    if (verbose)
        _tprintf( _TEXT("%s %s\n"), status_buf, string);
    else
    {
        putchar (8);
        putchar (8);
        putchar (8);
        putchar (8);
        printf("%4d", total_tests);
    }
    
    if (expected == actual)
    {
        total_tests ++;
        return;
    }

    _stprintf ( tbuf, _TEXT("Test Number %d %s Testing %s Expected %d Returned %d"),
                total_tests, status_buf, string, expected, actual);

    add_error (tbuf);
    return;
}


/* When two return values are possible, such as WLBS_CONVERGED or WLBS_DEFAULT */
void verify_return_value2 (PTCHAR string, DWORD expected1, DWORD expected2, DWORD actual)
{

    if (verbose)
        _tprintf( _TEXT("%s %s\n"), status_buf, string);

    if (expected1 == actual || expected2 == actual)
    {
        total_tests ++;
        return;
    }

    _stprintf ( tbuf, _TEXT("Test Number %d %s Testing %s Expected %d or %d Returned %d"),
                total_tests, status_buf, string, expected1, expected2, actual);

    add_error (tbuf);
    return;
}


void verify_return_value3 (PTCHAR string, DWORD expected1, DWORD expected2, DWORD expected3, DWORD actual)
{

    if (verbose)
        _tprintf( _TEXT("%s %s\n"), status_buf, string);

    if (expected1 == actual || expected2 == actual || expected3 == actual)
    {
        total_tests ++;
        return;
    }

    _stprintf ( tbuf, _TEXT("Test Number %d %s Testing %s Expected %d or %d or %d Returned %d"),
                total_tests, status_buf, string, expected1, expected2, expected3, actual);

    add_error (tbuf);
    return;
}


/* This function calls all the apis without calling init
 * Each of the apis should return WLBS_INIT_ERROR */
void check_init()
{
    TEST_COMMAND cmd;
    WLBS_REG_PARAMS reg_data;
    WLBS_PORT_RULE port_rule;
    WLBS_PORT_RULE port_rules [WLBS_MAX_RULES];
    DWORD num = WLBS_MAX_RULES;
    DWORD status, status1;


    _tcscpy (status_buf, _TEXT("Calling the apis without Initializing"));

    status = WlbsQuery(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL,NULL,NULL);
    verify_return_value (_TEXT("Query"), WLBS_INIT_ERROR, status);

    status = WlbsSuspend(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL);
    verify_return_value (_TEXT("Suspend"), WLBS_INIT_ERROR, status);

    status = WlbsResume(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL);
    verify_return_value (_TEXT("Resume"), WLBS_INIT_ERROR, status);

    status = WlbsStart(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL);
    verify_return_value (_TEXT("Start"), WLBS_INIT_ERROR, status);

    status = WlbsStop(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL);
    verify_return_value (_TEXT("Stop"), WLBS_INIT_ERROR, status);

    status = WlbsDrainStop(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL);
    verify_return_value (_TEXT("DrainStop"), WLBS_INIT_ERROR, status);

    status = WlbsEnable(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL,80);
    verify_return_value (_TEXT("Enable"), WLBS_INIT_ERROR, status);

    status = WlbsDisable(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL,80);
    verify_return_value (_TEXT("Disable"), WLBS_INIT_ERROR, status);

    status = WlbsDrain(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL,80);
    verify_return_value (_TEXT("Drain"), WLBS_INIT_ERROR, status);

    status = WlbsReadReg(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST, &reg_data);
    verify_return_value (_TEXT("ReadReg"), WLBS_INIT_ERROR, status);

    status = WlbsWriteReg(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST, &reg_data);
    verify_return_value (_TEXT("WriteReg"), WLBS_INIT_ERROR, status);

    status = WlbsCommitChanges(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST);
    verify_return_value (_TEXT("CommitChanges"), WLBS_INIT_ERROR, status);

    status = WlbsGetNumPortRules(&reg_data);
    verify_return_value (_TEXT("GetNumPortRules"), WLBS_INIT_ERROR, status);

    status = WlbsEnumPortRules(&reg_data, port_rules, &num);
    verify_return_value (_TEXT("EnumPortRules"), WLBS_INIT_ERROR, status);

    status = WlbsGetPortRule(&reg_data, 80, &port_rule);
    verify_return_value (_TEXT("GetPortRule"), WLBS_INIT_ERROR, status);

    status = WlbsAddPortRule(&reg_data, &port_rule);
    verify_return_value (_TEXT("AddPortRule"), WLBS_INIT_ERROR, status);

    status = WlbsDeletePortRule (&reg_data, 80);
    verify_return_value (_TEXT("DeletePortRule"), WLBS_INIT_ERROR, status);

    /* With an invalid product name, init returns REMOTE_ONLY
     * On subsequent calls, it will return the same value.
     * Hence this test has to be performed in isolation
     */
    if (init_test)
    {
        status = WlbsInit (_TEXT("JunkName"), WLBS_API_VER, NULL);
        verify_return_value2 (_TEXT("Init with junk product name"), WLBS_INIT_ERROR, WLBS_REMOTE_ONLY, status);
        return;
    }

    status = WlbsInit (_TEXT(WLBS_PRODUCT_NAME), WLBS_API_VER, NULL);
    verify_return_value3 (_TEXT("Init"), WLBS_PRESENT, WLBS_REMOTE_ONLY, WLBS_LOCAL_ONLY, status);

    status1 = WlbsInit (_TEXT(WLBS_PRODUCT_NAME), WLBS_API_VER, NULL);
    verify_return_value (_TEXT("Init Again"), status, status1);

    global_init = status;
    return;
}


/* This function brings a particular host to the converged state.
 * This is done by first suspending the host and then resuming 
 * and starting it. Wait till the cluster converges and then return
 */
BOOL GetHostToConvergedState (DWORD cluster, DWORD host)
{
    DWORD status;
    /* suspend the host and then do a resume and start to get it to converged state */

    status = WlbsSuspend (cluster, host, NULL, NULL);
    if (!(status == WLBS_OK || status == WLBS_ALREADY || status == WLBS_STOPPED))
        return FALSE;

    status = WlbsResume (cluster, host, NULL, NULL);
    if (status != WLBS_OK)
        return FALSE;

    status = WlbsStart (cluster, host, NULL, NULL);
    if (status != WLBS_OK)
        return FALSE;

    Sleep(10000); /* Wait for 10 seconds till it converges */

    status = WlbsQuery (cluster, host, NULL, NULL, NULL, NULL);
    if (status == WLBS_CONVERGED || status == WLBS_DEFAULT)
        return TRUE;
    else
        return FALSE;
}


/* This function gets all the hosts on a given cluster to the converged state */
BOOL GetClusterToConvergedState (DWORD cluster)
{
    /* suspend the entire cluster
     * resume the entire cluster
     * start the entire cluster
     * wait for convergence
     * Query should return the number of active hosts
     */
    DWORD status;

    /* Set the timeout so that this process gets speeded up */
    if (cluster == WLBS_LOCAL_CLUSTER)
        WlbsTimeoutSet (WlbsGetLocalClusterAddress (), 2000);
    else
        WlbsTimeoutSet (cluster, 2000);

    status = WlbsSuspend (cluster, WLBS_ALL_HOSTS, NULL, NULL);
    status = WlbsResume  (cluster, WLBS_ALL_HOSTS, NULL, NULL);
    status = WlbsStart   (cluster, WLBS_ALL_HOSTS, NULL, NULL);
    Sleep (10000);
    status = WlbsQuery   (cluster, WLBS_ALL_HOSTS, NULL, NULL, NULL, NULL);

    if (status == WLBS_BAD_PASSW)
        printf("Please ensure that the password on all the machines is the same\n");

    /* Restore it to the default value */
    if (cluster == WLBS_LOCAL_CLUSTER)
        WlbsTimeoutSet (WlbsGetLocalClusterAddress (), 0);
    else
        WlbsTimeoutSet (cluster, 0);

    if ( 1 <= status && status <= WLBS_MAX_HOSTS)
        return TRUE;
    else
        return FALSE;
}


/* This function goes through the response array and verifies that for each host that is converged,
 * the corresponding bit in the hostmap is set.
 * This function is useful only when the response array is from a converged cluster
 */
BOOL verify_hostmap_response (PWLBS_RESPONSE response, DWORD num_response, DWORD host_map)
{
    DWORD i,j;


    /* For each response, if the host is converged or is the default host, then it should
     * figure in the hostmap. Verify this.
     */
    /* This function should be invoked only when the response array is from a converged cluster.
     * or from a single host, when it is converged
     */
    for (i = 0; i < num_response; i++)
    {
        if (response [i] . status == WLBS_CONVERGED || response [i] . status == WLBS_DEFAULT)
        {
            if ( ! ( host_map & (1 << (response [i] . id - 1))) )
                return FALSE;
        }
        else /* That particular bit should not be set */
        {
            if ( host_map & (1 << (response [i] . id - 1)) )
                return FALSE;
        }
    }

    return TRUE;
}


/* Verify that all the responses show the same state. This is used in cluster-wide control tests.
 * If the cluster is reported to be suspended, then all the hosts should show their status
 * to be WLBS_SUSPENDED
 */
void verify_response_status (PWLBS_RESPONSE response, DWORD num_host, DWORD expected_status)
{
    DWORD i;
    TCHAR temp [40];

    for (i = 0 ; i < num_host; i++)
    {
        _stprintf (temp, _TEXT("Verifying response for host %d"), response [i] . id);
        verify_return_value2 ( temp, expected_status, WLBS_ALREADY, response [i] . status);
    }
}


/* This function opens a TCP connection to the cluster ip on the specified port.
 * This function is used to test Drainstop
 */
SOCKET OpenConnection (DWORD cluster, DWORD port)
{

    SOCKET sock = INVALID_SOCKET;
    SOCKADDR_IN caddr, saddr;
    INT ret;

    sock = socket (AF_INET, SOCK_STREAM, 0);

    if (sock == INVALID_SOCKET)
        return sock;

    caddr . sin_family        = AF_INET;
    caddr . sin_port          = htons (0);
    caddr . sin_addr . s_addr = htonl (INADDR_ANY);

    ret = bind (sock, (LPSOCKADDR) & caddr, sizeof (caddr));

    if (ret == SOCKET_ERROR)
    {
        closesocket (sock);
        return INVALID_SOCKET;
    }

    /* setup server's address */

    saddr . sin_family = AF_INET;
    saddr . sin_port   = htons ((USHORT)port);
    saddr . sin_addr . s_addr = cluster;

    ret = connect (sock, (LPSOCKADDR) & saddr, sizeof (saddr));
    if (ret == SOCKET_ERROR)
    {
        closesocket (sock);
        return INVALID_SOCKET;
    }

    return sock;
}


/* This function performs the password testing. The same function can be used for single host
 * or cluster-wide testing.
 */
void password_test (DWORD cluster, DWORD host, PTCHAR password)
{
    DWORD status1;

    /* The input password is the correct password */
    _stprintf (status_buf, _TEXT("Password test for cluster %d host %d"), cluster, host);

    /* If the password is null, then return,since password testing cannot be performed. */
     if (password == NULL)
        return;

     /* If it is an empty string, then again the testing cannot be performed */
    if (_tcslen (password) == 0)
        return;

    WlbsPasswordSet(cluster, _TEXT("JunkPassword"));

    /* All commands should return bad passw */
    status1 = WlbsQuery (cluster, host, NULL, NULL, NULL, NULL);
    verify_return_value (_TEXT("Query"), WLBS_BAD_PASSW, status1);

    status1 = WlbsDrain (cluster, host, NULL, NULL, 80);
    verify_return_value (_TEXT("Drain"), WLBS_BAD_PASSW, status1);

    status1 = WlbsDisable (cluster, host, NULL, NULL, 80);
    verify_return_value (_TEXT("Disable"), WLBS_BAD_PASSW, status1);

    status1 = WlbsEnable (cluster, host, NULL, NULL, 80);
    verify_return_value (_TEXT("Enable"), WLBS_BAD_PASSW, status1);

    status1 = WlbsSuspend (cluster, host, NULL, NULL);
    verify_return_value (_TEXT("Suspend"), WLBS_BAD_PASSW, status1);

    status1 = WlbsResume (cluster, host, NULL, NULL);
    verify_return_value (_TEXT("Resume"), WLBS_BAD_PASSW, status1);

    status1 = WlbsStop (cluster, host, NULL, NULL);
    verify_return_value (_TEXT("Stop"), WLBS_BAD_PASSW, status1);

    status1 = WlbsDrainStop (cluster, host, NULL, NULL);
    verify_return_value (_TEXT("Drainstop"), WLBS_BAD_PASSW, status1);

    status1 = WlbsStart (cluster, host, NULL, NULL);
    verify_return_value (_TEXT("Start"), WLBS_BAD_PASSW, status1);

    WlbsPasswordSet (cluster, password); /* Reset the password for future tests */
    Sleep (10000); /* Wait till the cluster converges */
    return;
}


/* This function verifies the portset api.
 * It sets the port for a given cluster and makes a query on the host
 * The return value should match the expected value, which can be either
 * WLBS_TIMEOUT or some WINSOCK error in case of an invalid port
 * or the status of the host if the port is a valid one
 */
void verify_port (DWORD cluster, DWORD host, DWORD port, DWORD expected)
{
    DWORD status;
    TCHAR temp [BUF_SIZE];

    WlbsPortSet (cluster, (WORD)port);
    status = WlbsQuery (cluster, host, NULL, NULL, NULL, NULL);

    _stprintf (temp, _TEXT("Verifying port set for port %d"), port);
    verify_return_value (temp, expected, status);
    return;
}


/* Get the cluster/host to drainstopped state by establishing a connection and then drainstopping it */
BOOL GetDrainstopState (DWORD cluster, DWORD host, SOCKET * sock, DWORD port)
{
    DWORD status;
    BOOL connected = FALSE;

    /* First, get the cluster or host to the converged state */
    if (host == WLBS_ALL_HOSTS)
    {
        if (!GetClusterToConvergedState (cluster))
            return FALSE;
    }
    else if (!GetHostToConvergedState (cluster, host))
        return FALSE;

    /* Open a TCP connection on the specified port */
    *sock = OpenConnection (cluster, port);
    if (*sock == INVALID_SOCKET)
    {
        add_error(_TEXT("Unable to open a connection to the cluster"));
        return FALSE;
    }

    /* DrainStop the host and then query it. If the status is not draining, something is wrong */
    status = WlbsDrainStop (cluster, host, NULL, NULL);
    verify_return_value (_TEXT("Drainstop with active connection"), WLBS_OK, status);
    Sleep (10000); /* Wait for the cluster to converge */

    status = WlbsQuery (cluster, host, NULL, NULL, NULL, NULL);
    verify_return_value (_TEXT("Query after Drainstop with active connection"), WLBS_DRAINING, status);

    if (status != WLBS_DRAINING)
        return FALSE;

    return TRUE;
}


/* This function deals with the parameter testing of the apis on a single host */
void single_host_parameter_test (DWORD cluster, DWORD host)
{
    DWORD status1, status2;
    DWORD host_map1, host_map2;
    DWORD num_host1, num_host2;
    WLBS_RESPONSE response1, response2, *response;
    DWORD cl_ip, host_ip, host_id;
    TCHAR temp1[40], temp2[40];
    DWORD temp;


    temp = 40;
    if (cluster == WLBS_LOCAL_CLUSTER)
        _stprintf (temp1, _TEXT("local cluster"));
    else
        WlbsAddressToString (cluster, temp1, &temp);

    temp = 40;
    if (cluster == WLBS_LOCAL_HOST)
        _stprintf (temp2, _TEXT("local host"));
    else
        WlbsAddressToString (host, temp2, &temp);

    _stprintf (status_buf, _TEXT("Single Host Parameter Test for cluster:%s host:%s"), temp1, temp2);

    /* First verify that the response structure and the returned value match */
    num_host1 = 1;
    host_map1 = 0;
    status1 = WlbsQuery (cluster, host, &response1, &num_host1, &host_map1, NULL);

    if ( ! verify_hostmap_response (&response1, num_host1, host_map1) )
    {
        _stprintf (tbuf, _TEXT("Querying cluster %d, host %d, returned mismatched hostmap and response"),
                   cluster, host);
        add_error (tbuf);
    }

    if (cluster == WLBS_LOCAL_CLUSTER && host == WLBS_LOCAL_HOST)
    {
        /* On a local host, there can be additional tests. Query the host remotely and verify that
         * both the local and remote queries return the same status, the same id and the same hostmap
         */
        cl_ip = WlbsGetLocalClusterAddress ();
        host_ip = WlbsGetDedicatedAddress ();
        host_id = response1 . id;

        /* Query remotely first using the host ip */
        num_host2 = 1;
        host_map2 = 0;
        status2 = WlbsQuery (cl_ip, host_ip, &response2, &num_host2, &host_map2, NULL);
        verify_return_value (_TEXT("Comparing Local and Remote Query"), status1, status2);

        if (host_map1 != host_map2)
        {
            _stprintf (tbuf, _TEXT("Local host query and remote host query returned different hostmaps %d %d\n"),
                       host_map1, host_map2);
            add_error (tbuf);
        }

        if (response1 . status != response2 . status)
        {
            _stprintf (tbuf, _TEXT("Local host query and remote query returned different statuses in response"));
            add_error (tbuf);
        }

        if (response1 . id != response2 . id)
        {
            _stprintf (tbuf, _TEXT("Local host query and remote query returned different ids in response"));
            add_error (tbuf);
        }

        if (response2 . address != host_ip )
        {
            _stprintf (tbuf, _TEXT("Local host query and remote query returned different IP Addresses"));
            add_error (tbuf);
        }


        /* Now query the host remotely using the host_id as a parameter and verify the returns */
        num_host2 = 1;
        status2 = WlbsQuery (WLBS_LOCAL_CLUSTER, host_id, &response2, &num_host2, &host_map2, NULL);
        verify_return_value (_TEXT("Querying remotely with host id"), status1, status2);

        if (host_map1 != host_map2)
        {
            _stprintf (tbuf, _TEXT("Local host query and remote host query with id returned different hostmaps %d %d\n"),
                       host_map1, host_map2);
            add_error (tbuf);
        }

        if (response1 . status != response2 . status)
        {
            _stprintf (tbuf, _TEXT("Local host query and remote query with id returned different statuses in response"));
            add_error (tbuf);
        }

        if (response1 . id != response2 . id)
        {
            _stprintf (tbuf, _TEXT("Local host query and remote query with id returned different ids in response"));
            add_error (tbuf);
        }

        if (response2 . address != host_ip )
        {
            _stprintf (tbuf, _TEXT("Local host query and remote query returned different IP Addresses"));
            add_error (tbuf);
        }
    }

    status2 = WlbsQuery (cluster, host, NULL, NULL, NULL, NULL);
    verify_return_value (_TEXT("Querying with all parameters NULL"), status1, status2);

    num_host2 = 0;
    status2 = WlbsQuery (cluster, host, NULL, &num_host2, NULL, NULL);
    verify_return_value (_TEXT("Querying with num_host parameter = 0 and host_map = NULL"), status1, status2);

    status2 = WlbsQuery (1234, 0, NULL, NULL, NULL, NULL);
    verify_return_value (_TEXT("Querying non-existent cluster 1234"), WLBS_TIMEOUT, status2);

    status2 = WlbsQuery (cluster, 33, NULL, NULL, NULL, NULL);
    verify_return_value (_TEXT("Querying non-existent host 33"), WLBS_TIMEOUT, status2);

    /* Verify the portset command, only for remote queries
     * since the remote port is not used for local queries
     */
    if (! ( cluster == WLBS_LOCAL_CLUSTER && host == WLBS_LOCAL_HOST ) )
    {
        verify_port (cluster, host, 3000, WLBS_TIMEOUT);
        verify_port (cluster, host, 0, status1);
        verify_port (cluster, host, CVY_DEF_RCT_PORT, status1);
    }

    return;
}


/* This function goes through the state changes of for single host operations */
void single_host_state_changes (DWORD cluster, DWORD host)
{
    DWORD status1, status2;
    WLBS_RESPONSE response [WLBS_MAX_HOSTS];
    DWORD num_host1, num_host2;
    DWORD host_map1, host_map2;
    SOCKET sock = INVALID_SOCKET;
    DWORD temp_address;
    TCHAR temp1[40], temp2[40];
    DWORD temp;

    /* Assume that the host is in the converged state now */

    temp = 40;
    if (cluster == WLBS_LOCAL_CLUSTER)
        _stprintf (temp1, _TEXT("local cluster"));
    else
        WlbsAddressToString (cluster, temp1, &temp);

    temp = 40;
    if (cluster == WLBS_LOCAL_HOST)
        _stprintf (temp2, _TEXT("local host"));
    else
        WlbsAddressToString (host, temp2, &temp);


    _stprintf (status_buf, _TEXT("Single Host State Changes cluster %s host %s"), temp1, temp2);

    /* Call each of the apis and verify that the return values are consistent with the current
     * state of the host. For example, Disable would return different values depending on whether
     * the host was suspended or converged ....
     */
    num_host1 = 1;
    status1 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value2 (_TEXT("Query"), WLBS_CONVERGED, WLBS_DEFAULT, status1);

/* The following tests assume that there is a port rule for port number 80.
 * Otherwise the return code will be WLBS_NOT_FOUND.
 */
    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Disable 80"), WLBS_OK, status2);
    if (status2 == WLBS_NOT_FOUND)
        printf("Please ensure that a port rule exists for port number 80.\n");

    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Disable Again 80"), WLBS_ALREADY, status2);

    /* If a port rule is disabled, drain returns already */
    num_host1 = 1;
    status2 = WlbsDrain (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Drain 80"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Enable 80"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Enable Again 80"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Disable ALL"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Disable Again ALL"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsDrain (cluster, host, response, &num_host1, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Drain ALL"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Enable ALL"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Enable Again ALL"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsSuspend (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Suspend"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsDrain (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Drain after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Disable after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Enable after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsSuspend (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Suspend Again"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsStop (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Stop after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsStart (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Start after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsDrainStop (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("DrainStop after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsResume (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Resume after Suspend"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query after Resume"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsDrain (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Drain when Stopped"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Disable when Stopped"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Enable when Stopped"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsResume (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Resume when Stopped"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsStop (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Stop when Stopped"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsDrainStop (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("DrainStop when Stopped"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsSuspend (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Suspend when Stopped"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query when Suspended"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsResume (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Resume when Suspended"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query when Stopped"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsStart (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Start when Stopped"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value3 (_TEXT("Query after Starting"), WLBS_CONVERGING, WLBS_CONVERGED, WLBS_DEFAULT, status2);

    Sleep (10000); /* Wait for the cluster to converge */

    /* Modify the code to keep polling the host till it is converged ###### */

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value2 (_TEXT("Query after Waiting for Convergence"), WLBS_CONVERGED, WLBS_DEFAULT, status2);

    num_host1 = 1;
    status2 = WlbsStart (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Start when Converged"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsResume (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Resume when Converged"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsStop (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Stop when Converged"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query when Stopped"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsStart (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Start when Stopped"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value3 (_TEXT("Query after Starting"), WLBS_CONVERGING, WLBS_CONVERGED, WLBS_DEFAULT, status2);

    Sleep (10000); /* Wait for the cluster to converge */

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value2 (_TEXT("Query after Waiting for Convergence"), WLBS_CONVERGED, WLBS_DEFAULT, status2);

    /* DrainStop is to be tested only on a remote host */
    if ((cluster == WLBS_LOCAL_CLUSTER || cluster == WlbsGetLocalClusterAddress()) &&
        (host == WLBS_LOCAL_HOST || host == WlbsGetDedicatedAddress()) )
        return;


    /* To test drainstop on a particular host, stop the entire cluster. Then start only this particular host.
     * Open a connection to it. Then do a drainstop. Query should return draining. Then close the connection.
     * Query again. The return value should be stopped. This should be done only on a remote host. This test
     * would fail on a local host, since the connection setup does not go through the wlbs driver, but gets
     * routed up the stack.
     */

    num_host1 = WLBS_MAX_HOSTS;
    status2 = WlbsStop (cluster, WLBS_ALL_HOSTS, response, &num_host1);
    verify_return_value (_TEXT("Cluster-wide stop to test drainstop"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsStart (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Start on host after Cluster-wide stop"), WLBS_OK, status2);

    Sleep (10000); /* Wait till the host converges */

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value2 (_TEXT("Query after Waiting for Convergence"), WLBS_CONVERGED, WLBS_DEFAULT, status2);


    if (!GetDrainstopState (cluster, host, &sock, 80))
        return;

    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Disable after DrainStop with active connection"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsDrain (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Drain after DrainStop with active connection"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Enable after DrainStop with active connection"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Enable again after DrainStop with active connection"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsResume (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Resume after DrainStop with active connection"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsStop (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Stop after DrainStop with active connection"), WLBS_DRAIN_STOP, status2);

    closesocket (sock);

    /* Start the host and open a connection again */
    if (!GetDrainstopState (cluster, host, &sock, 80))
        return;

    num_host1 = 1;
    status2 = WlbsStart (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Start after DrainStop with active connection"), WLBS_DRAIN_STOP, status2);

    closesocket (sock);

    if (!GetDrainstopState (cluster, host, &sock, 80))
        return;

    num_host1 = 1;
    status2 = WlbsSuspend (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Suspend after DrainStop with active connection"), WLBS_DRAIN_STOP, status2);

    closesocket (sock); /* close the connection */

    if (!GetDrainstopState (cluster, host, &sock, 80))
        return;

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query after DrainStop with active connection"), WLBS_DRAINING, status2);

    closesocket (sock);
    Sleep (10000); /* Wait for it to figure out that all the connections have been terminated */

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query after DrainStop with closed connection"), WLBS_STOPPED, status2);

    /* issue a cluster-wide start to bring back all the hosts to the converged state.*/
    num_host1 = WLBS_MAX_HOSTS;
    status2 = WlbsStart (cluster, WLBS_ALL_HOSTS, response, &num_host1);
    verify_return_value (_TEXT("Cluster-wide start to restore original state"), WLBS_OK, status2);

    Sleep (10000); /* Wait for convergence */
    return;
}


/* This function tests the single host control operations.
 * It performs both the parameter tests as well as the
 * state change tests.
 */
void check_single_host_operations ( )
{
    DWORD local_cluster_ip = 0;
    DWORD local_dedicated_ip = 0;
    DWORD remote_cluster_ip = 0;
    DWORD remote_host = 0;

    if (global_init == WLBS_INIT_ERROR)
    {
        add_error(_TEXT("Cannot perform Control test due to Init Error"));
        return;
    }
    

    if (local_test)
    {
        do {
            if (global_init == WLBS_PRESENT)
            {
                WLBS_REG_PARAMS reg_data;
                DWORD status;

                local_cluster_ip = WlbsGetLocalClusterAddress();
                local_dedicated_ip = WlbsGetDedicatedAddress();

                status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & reg_data);
                WlbsCodeSet (local_cluster_ip, reg_data . i_rct_password);
                /* test the local call path */
                if ( ! GetHostToConvergedState(WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST))
                {
                    printf("Unable to get the local host to converged state\n");
                    break;
                }
                single_host_parameter_test (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
                single_host_state_changes (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);

                /* test the remote call path */
                WlbsCodeSet (local_cluster_ip, reg_data . i_rct_password);
                single_host_parameter_test (local_cluster_ip, local_dedicated_ip);
                single_host_state_changes (local_cluster_ip, local_dedicated_ip);
            }
        } while (FALSE);
    }

    if ( ! remote_test)
        return;

    if (global_init == WLBS_PRESENT || global_init == WLBS_REMOTE_ONLY)
    {
        /* test a remote host on a remote cluster */

        if (remote_cl_ip == 0)
        {
            printf("Remote cluster address is invalid, so Control operations on a remote host are not tested\n");
            return;
        }

        if (remote_host_ip == 0)
        {
            printf("Remote host address is invalid, so Control operations on a remote host are not tested\n");
            return;
        }

        /* Set the password for the remote host and set it so that the operations can be performed */
        WlbsPasswordSet (remote_cl_ip, remote_password);
        WlbsTimeoutSet (remote_cl_ip, timeout);
        if ( ! GetHostToConvergedState(remote_cl_ip, remote_host_ip) )
        {
            printf("Unable to get the remote host to converged state. Not performing state change tests");
            return;
        }

        single_host_state_changes (remote_cl_ip, remote_host_ip);
    }
    else
        printf("Unable to perform the remote tests\n");

    return;
}


/* This function verifies the parameter testing for cluster-wide queries. It checks the response array
 * verifies it with the hostmap
 */
void cluster_parameter_test (DWORD cluster)
{
    DWORD status1, status2;
    DWORD host_map1, host_map2, temp_host_map;
    DWORD num_host1, num_host2;
    WLBS_RESPONSE response1, response2 [WLBS_MAX_HOSTS];
    PWLBS_RESPONSE response = NULL;
    DWORD stopped_host_id = 0;
    DWORD i;

    
    _stprintf (status_buf, _TEXT("Cluster-wide parameter testing for cluster %d"), cluster);

    /* Query with all parameters set to null should return the number of active hosts */
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, NULL, NULL, NULL, NULL);
    
    /* Query with num_hosts set to 0. On return num_hosts should be >= status1 */
    num_host1 = 0;
    status2 = WlbsQuery (cluster, WLBS_ALL_HOSTS, NULL, &num_host1, &host_map1, NULL);
    if (num_host1 < status1)
    {
        _stprintf (tbuf, _TEXT("Cluster-wide query returned %d active and %d total hosts"), status1, num_host1);
        add_error (tbuf);
        return;
    }

    /* Response array = #hosts + 1. Check that the boundaries are not overwritten. */
    response = (PWLBS_RESPONSE) malloc (sizeof (WLBS_RESPONSE) * (num_host1 + 1));
    memset (response, 0, (sizeof (WLBS_RESPONSE) * (num_host1 + 1)));
    memset (&response1, 0, sizeof (WLBS_RESPONSE));
    num_host2 = num_host1 - 1;

    status2 = WlbsQuery (cluster, WLBS_ALL_HOSTS, &response [1], &num_host2, &host_map2, NULL);
    if (memcmp (&response1, &response[0], sizeof (WLBS_RESPONSE)) ||
        memcmp (&response1, &response[num_host1], sizeof (WLBS_RESPONSE)) )
    {
        add_error(_TEXT("Response Array boundaries are over-written"));
    }

    free (response);
    response = NULL;

    /* Query again with the full response buffer */
    /* Verify that the hostmap and response array are in sync */
    num_host1 = WLBS_MAX_HOSTS;

    status2 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response2, &num_host1, &host_map1, NULL);
    if (! verify_hostmap_response (response2, num_host1, host_map1) )
        add_error (_TEXT("Hostmap and Response do not match for the cluster wide query"));

    /* The following test is to verify the correctness of the hostmap parameter
     * Save the host_map returned in the previous query.
     * Stop a converged host.
     * Query again and get the new host_map.
     * */
    for (i = 0 ; i < num_host1; i++)
    {
        if (response2 [i] . status == WLBS_CONVERGED || response2 [i] . status == WLBS_DEFAULT)
        {
            stopped_host_id = response2 [i] . id;
            break;
        }
    }

    status1  = WlbsStop (cluster, stopped_host_id, NULL, NULL);

    Sleep (10000); /* Wait for the cluster to converge */

    /* Query the cluster again */
    num_host1 = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response2, &num_host1, &host_map1, NULL);
    if (status2 == 1) /* This is to take care of single host clusters */
        verify_return_value (_TEXT("Querying cluster after stopping 1 host"), WLBS_STOPPED, status1);
    else
        verify_return_value (_TEXT("Querying cluster after stopping 1 host"), status2 - 1, status1);


    if (status2 > 1) /* The following verification can be done only if there are 2 or more hosts in the cluster */
    {
        /* Verify that the corresponding bit in the host_map is not set */
        if (! verify_hostmap_response (response2, num_host1, host_map1) )
            add_error (_TEXT("Hostmap and Response do not match for the cluster wide query"));

        if (host_map1 & (1 << (stopped_host_id - 1)) )
        {
            _stprintf (tbuf, _TEXT("Stopping host %d did not change the host_map"), stopped_host_id);
            add_error (tbuf);
        }
    }

    /* start the host again */
    status1 = WlbsStart (cluster, stopped_host_id, NULL, NULL);

    /* wait for it to converge */
    Sleep (10000);
    
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, NULL, NULL, NULL, NULL);
    if (! (status1 >= 1 && status1 <= WLBS_MAX_HOSTS) )
        printf("Unable to get the cluster to the converged state after Cluster parameter testing\n");

    /* Test portset */
    verify_port (cluster, WLBS_ALL_HOSTS, 3000, WLBS_TIMEOUT);
    verify_port (cluster, WLBS_ALL_HOSTS, 0, status1);
    verify_port (cluster, WLBS_ALL_HOSTS, CVY_DEF_RCT_PORT, status1);

    return;
}


void verify_timeout (DWORD cluster, DWORD timeout)
{
    DWORD time1, time2, time_diff;
    DWORD status;

    WlbsTimeoutSet (cluster, timeout);
    if (timeout == 0) /* set it to the default value */
        timeout = IOCTL_REMOTE_RECV_DELAY * IOCTL_REMOTE_SEND_RETRIES * IOCTL_REMOTE_RECV_RETRIES;

    time1 = GetTickCount ();
    status = WlbsQuery (cluster, WLBS_ALL_HOSTS, NULL, NULL, NULL, NULL);
    time2 = GetTickCount ();

    time_diff = time2 - time1;

    if (abs (time_diff - timeout) > 1000) /* Keep a margin of 1 sec */
    {
        _stprintf ( tbuf, _TEXT("Expected timeout %d, Actual timeout %d"), timeout, time_diff);
        add_error (tbuf);
    }

    return;
}


/* This function takes the entire cluster through the different state changes.
 * Some special cases are when one particular host is suspended
 * or when one particular host is in the drainstop state.
 * In such cases, WLBS_SUSPENDED or WLBS_DRAINING or WLBS_DRAIN_STOP are returned.
 * These return values are also verified.
 * After these special cases, the entire cluster is taken through the state changes.
 * In these tests, the response array is checked to verify that the statuses of each
 * host is in synch with the value returned by the control operation.
 */
void cluster_state_changes (DWORD cluster)
{
    DWORD status1, status2;
    WLBS_REG_PARAMS reg_data;
    BOOL password_flag = TRUE;
    WLBS_RESPONSE response [WLBS_MAX_HOSTS];
    DWORD num_host, host_map;
    DWORD suspended_host_id;
    DWORD temp_address;
    SOCKET sock = INVALID_SOCKET;


    _stprintf (status_buf, _TEXT("Checking cluster state changes for cluster %d"), cluster);

    /* Password check on the local cluster only */
    if (cluster == WLBS_LOCAL_CLUSTER)
    {
        DWORD password;
        DWORD cluster = WlbsGetLocalClusterAddress ();


        status1 = WlbsReadReg(WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & reg_data);
        password = reg_data . i_rct_password;
        status1 = WlbsSetRemotePassword (&reg_data, _TEXT("NewPassword"));
        status1 = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & reg_data);
        status1 = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
        Sleep (10000);

        if (status1 != WLBS_OK)
        {
            password_flag = FALSE;
            add_error (_TEXT("Unable to change the password on the local machine."));
        }

        if (password_flag)
            password_test (WLBS_LOCAL_CLUSTER, WLBS_ALL_HOSTS, _TEXT("NewPassword"));

        status1 = WlbsReadReg(WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & reg_data);
        reg_data . i_rct_password = password;
        status1 = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & reg_data);
        status1 = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
        WlbsCodeSet (cluster, password);
        Sleep (10000); /* Wait till the cluster converges */
    }
    /* Password check on the remote cluster by getting the password beforehand */
    else
    {
        password_test (cluster, WLBS_ALL_HOSTS, remote_password);

        /* Reset the password to the original state */
        WlbsPasswordSet (cluster, remote_password);
    }

    /* Bring any one host to the suspended state. On every command, the response should be WLBS_SUSPENDED */
    _stprintf (status_buf, _TEXT("Cluster-wide commands with one suspended host"));

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);

    suspended_host_id = response [0] . id;
    status1 = WlbsSuspend (cluster, suspended_host_id, NULL, NULL);
    Sleep (10000); /* Wait for the cluster to converge. */

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsStop (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Stop after suspending 1 host"), WLBS_SUSPENDED, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDrainStop (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Stop after suspending 1 host"), WLBS_SUSPENDED, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsStart (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Start after suspending 1 host"), WLBS_SUSPENDED, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDrain (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Drain after suspending 1 host"), WLBS_SUSPENDED, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDisable (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Disable after suspending 1 host"), WLBS_SUSPENDED, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsEnable (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Enable after suspending 1 host"), WLBS_SUSPENDED, status1);

    /* Now get the cluster to the converged state and test the state changes */
    if ( !GetClusterToConvergedState (cluster))
    {
        add_error (_TEXT("Unable to get the cluster to the converged state"));
        return;
    }

    _stprintf ( status_buf, _TEXT("Cluster-wide commands"));

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsSuspend (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Cluster-wide Suspend"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    verify_return_value (_TEXT("Query after Cluster-wide Suspend"), WLBS_SUSPENDED, status1);
    verify_response_status (response, num_host, WLBS_SUSPENDED);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsResume (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Cluster-wide Resume after Suspend"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    verify_return_value (_TEXT("Cluster-wide Query after Resume"), WLBS_STOPPED, status1);
    verify_response_status (response, num_host, WLBS_STOPPED);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsStart (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Cluster-wide Start after Resume"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    if (! (status1 == WLBS_CONVERGING || ( 1 <= status1 && status1 <= WLBS_MAX_HOSTS)) )
    {
        add_error (_TEXT("Error in query after cluster-wide start"));
    }

    Sleep (10000); /* Wait for the cluster to converge */

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    if ( ! ( 1 <= status1 && status1 <= WLBS_MAX_HOSTS) )
        printf("Unable to get the cluster to converged state after Starting\n");

    /* Test for invalid port numbers */
    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDrain (cluster, WLBS_ALL_HOSTS, response, &num_host, CVY_MAX_PORT + 1);
    verify_return_value (_TEXT("Drain on invalid port"), WLBS_NOT_FOUND, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDisable (cluster, WLBS_ALL_HOSTS, response, &num_host, CVY_MAX_PORT + 1);
    verify_return_value (_TEXT("Disable on invalid port"), WLBS_NOT_FOUND, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsEnable (cluster, WLBS_ALL_HOSTS, response, &num_host, CVY_MAX_PORT + 1);
    verify_return_value (_TEXT("Enable on invalid port"), WLBS_NOT_FOUND, status1);

    Sleep (10000); /* Wait for the cluster to converge */

    /* Test for invalid port numbers */
    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDrain (cluster, WLBS_ALL_HOSTS, response, &num_host, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Drain on all port"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDisable (cluster, WLBS_ALL_HOSTS, response, &num_host, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Disable on all port"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsEnable (cluster, WLBS_ALL_HOSTS, response, &num_host, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Enable on all port"), WLBS_OK, status1);

    Sleep (10000);

    /* Test timeout */
    if (cluster == WLBS_LOCAL_CLUSTER)
        temp_address = WlbsGetLocalClusterAddress ();
    else
        temp_address = cluster;

    verify_timeout (temp_address, 5000);
    verify_timeout (temp_address, 1000);
    verify_timeout (temp_address, 0);

    WlbsTimeoutSet (temp_address, timeout); /* Set the value specified by the user */


    if (cluster == WLBS_LOCAL_CLUSTER)
        return; /* DrainStop is not checked, since the connection will not be visible to the wlbs driver */


    if (!GetDrainstopState (cluster, WLBS_ALL_HOSTS, &sock, 80))
        return;

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    verify_return_value (_TEXT("Query after DrainStop with active connection"), WLBS_DRAINING, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDisable (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Disable after DrainStop with active connection"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDrain (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Drain after DrainStop with active connection"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsEnable (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Enable after DrainStop with active connection"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsEnable (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Enable again after DrainStop with active connection"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsStop (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Stop after DrainStop with active connection"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    verify_return_value (_TEXT("Query after Stop on DrainStop with active connection"), WLBS_STOPPED, status1);

    closesocket (sock);

    if (!GetDrainstopState (cluster, WLBS_ALL_HOSTS, &sock, 80))
        return;

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsStart (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Start after DrainStop with active connection"), WLBS_OK, status1);

    Sleep (10000);
    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    if (!(1 <= status1 && status1 <= WLBS_MAX_HOSTS))
        return;

    closesocket (sock);

    if (!GetDrainstopState (cluster, WLBS_ALL_HOSTS, &sock, 80))
        return;

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsSuspend (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Suspend after DrainStop with active connection"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    verify_return_value (_TEXT("Suspend after DrainStop with active connection"), WLBS_SUSPENDED, status1);

    closesocket (sock);

    if (!GetDrainstopState (cluster, WLBS_ALL_HOSTS, &sock, 80))
        return;

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsResume (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Resume on DrainStop with active connection"), WLBS_OK, status1);

    closesocket (sock); /* close the connection */

    Sleep (10000); /* Wait for the host to figure out that all the connections have terminated */
    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    verify_return_value (_TEXT("Query after DrainStop with closed connection"), WLBS_STOPPED, status1);

    /* issue a cluster-wide start to bring back all the hosts to the converged state.*/
    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsStart (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Cluster-wide start to restore original state"), WLBS_OK, status1);

    Sleep (10000); /* Wait for the cluster to converge */
    return;
}


void check_cluster_operations ( )
{
    DWORD cluster = 0;

    if (local_test)
    {
        if (global_init = WLBS_PRESENT)
        {
            WLBS_REG_PARAMS reg_data;
            DWORD status;

            status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &reg_data);
            if (status != WLBS_OK)
            {
                printf("Unable to read from the registry to set the password\nAborting cluster checks\n");
                return;
            }

            WlbsCodeSet (WlbsGetLocalClusterAddress (), reg_data . i_rct_password );
            WlbsTimeoutSet (WlbsGetLocalClusterAddress (), timeout);
            if (GetClusterToConvergedState (WLBS_LOCAL_CLUSTER))
            {
                cluster_parameter_test (WLBS_LOCAL_CLUSTER);
                cluster_state_changes (WLBS_LOCAL_CLUSTER);
            }
            else
            {
                add_error (_TEXT("Unable to get the local cluster to the converged state"));
            }
        }
    }

    if (!remote_test)
        return;

    WlbsPasswordSet (remote_cl_ip, remote_password);
    WlbsTimeoutSet (remote_cl_ip, timeout);
    if ( GetClusterToConvergedState (remote_cl_ip))
    {
        cluster_parameter_test (remote_cl_ip);
        cluster_state_changes (remote_cl_ip);
    }
    else
        add_error (_TEXT("Unable to get the remote cluster to the converged state"));

    return;
}


/* This function is used to find the first place where the 2 structures differ */
DWORD find_mem_change (PWLBS_REG_PARAMS data1, PWLBS_REG_PARAMS data2, DWORD size)
{
    DWORD i;

    printf("size of dword %d\n", sizeof (DWORD));
    for (i = 4; i < size ; i += 4)
    {
        if (memcmp (data1, data2, i))
            return i;
    }
    return 0;
}


void check_rules_in_structure (PWLBS_REG_PARAMS reg_data)
{
    DWORD i;

    printf("the number of rules is %d\n", reg_data -> i_num_rules);
    for (i = 0 ; i < WLBS_MAX_RULES; i++)
    {
        if (reg_data -> i_port_rules [i] . i_valid)
        {
            printf("\tFound valid port rule %d with start port %d ep %d\n", i,
                   reg_data -> i_port_rules [i] . start_port,
                   reg_data -> i_port_rules [i] . end_port);
        }
    }
    return;
}


/* This function tests the reads and writes to the registry */
void check_registry_rw ()
{
    WLBS_REG_PARAMS saved;
    WLBS_REG_PARAMS newdata;
    WLBS_REG_PARAMS temp;
    DWORD status;


    if (global_init == WLBS_REMOTE_ONLY || global_init == WLBS_INIT_ERROR)
    {
        add_error (_TEXT("Cannot check registry rw since wlbs is not installed"));
        return;
    }

    /* parameter testing */
    _stprintf (status_buf, _TEXT("Parameter Test for ReadReg and WriteReg"));
    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL);
    verify_return_value (_TEXT("ReadReg with null regdata"), WLBS_BAD_PARAMS, status);
    
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL);
    verify_return_value (_TEXT("WriteReg with null regdata"), WLBS_BAD_PARAMS, status);

    status = WlbsReadReg (12, WLBS_LOCAL_HOST, & saved);
    verify_return_value (_TEXT("ReadReg on remote cluster"), WLBS_LOCAL_ONLY, status);

    status = WlbsWriteReg (12, WLBS_LOCAL_HOST, & saved);
    verify_return_value (_TEXT("WriteReg on remote cluster"), WLBS_LOCAL_ONLY, status);

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, 10, & saved);
    verify_return_value (_TEXT("ReadReg on remote host"), WLBS_LOCAL_ONLY, status);

    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, 10, & saved);
    verify_return_value (_TEXT("WriteReg on remote host"), WLBS_LOCAL_ONLY, status);

    /* now test the actual working of read and write reg */

    _stprintf (status_buf, _TEXT("Testing ReadReg and WriteReg for correctness"));
    
    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & saved);
    verify_return_value (_TEXT("ReadReg"), WLBS_OK, status);

    /* The following memset is to avoid any spurious differences */
    memset (&newdata, 0, sizeof (WLBS_REG_PARAMS));

    /* Fill in the structure with valid values */
    newdata . alive_period = saved . alive_period + 1;
    newdata . alive_tolerance = saved . alive_tolerance + 1;
    _tcscpy (newdata . cl_ip_addr, _TEXT("111.222.111.222"));
    _tcscpy (newdata . cl_mac_addr, _TEXT("11-22-33-44-55-66"));
    _tcscpy (newdata . cl_net_mask, _TEXT("255.255.255.0"));
    newdata . cluster_mode = FALSE;
    _tcscpy (newdata . ded_ip_addr, _TEXT("111.222.111.233"));
    _tcscpy (newdata . ded_net_mask, _TEXT("255.255.255.0"));
    _tcscpy (newdata . domain_name, _TEXT("TESTDOMAINNAME"));
    newdata . dscr_per_alloc = 1024;
    newdata . host_priority = saved . host_priority + 1;
    newdata . i_cleanup_delay = 3600;
    _tcscpy (newdata . i_cluster_nic_name, saved . i_cluster_nic_name); /* This is for read-only */
    newdata . i_convert_mac = FALSE;
    newdata . i_expiration = 0;
    newdata . i_ft_rules_enabled = TRUE;
    newdata . i_ip_chg_delay = saved . i_ip_chg_delay + 1;
    _tcscpy (newdata . i_license_key, _TEXT("JUNKLICENSEKEY"));
    newdata . i_max_hosts = LICENSE_MAX_HOSTS;
    newdata . i_max_rules = LICENSE_RULES;
    newdata . i_mcast_spoof = FALSE;
    newdata . i_num_rules = 0;
    newdata . i_parms_ver = saved . i_parms_ver;
    memset ( newdata . i_port_rules, 0, sizeof (WLBS_PORT_RULE) * WLBS_MAX_RULES);
    newdata . i_rct_password = 23445;
    newdata . i_rmt_password = 98765;
    newdata . i_scale_client = 10;
    newdata . i_verify_date  = 0;
    newdata . i_version = 0;
    _tcscpy (newdata . i_virtual_nic_name, _TEXT("TEMP_VIRTUAL_NIC_NAME"));
    newdata . install_date = 50000;
    newdata . mask_src_mac = FALSE;
    newdata . max_dscr_allocs = 1024;
    newdata . mcast_support = FALSE;
    newdata . i_nbt_support = FALSE;
    newdata . num_actions = saved . num_actions + 1;
    newdata . num_packets = saved . num_packets + 1;
    newdata . num_send_msgs = saved . num_send_msgs + 1;
    newdata . rct_enabled = FALSE;
    newdata . rct_port = 2000;


    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & newdata);
    verify_return_value (_TEXT("WriteReg"), WLBS_OK, status);

    memset (&temp, 0, sizeof (WLBS_REG_PARAMS));

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & temp);
    verify_return_value (_TEXT("ReadReg after a write"), WLBS_OK, status);

    memset ( temp . i_port_rules, 0, sizeof (WLBS_PORT_RULE) * WLBS_MAX_RULES);
    if (memcmp(&temp, &newdata, sizeof (WLBS_REG_PARAMS)))
    {
        _stprintf (tbuf, _TEXT("1:The data written and the data read back differ in the location %d\n"),
                   find_mem_change (&newdata, &temp, sizeof (WLBS_REG_PARAMS)) );
        add_error (tbuf);
    }

    /* restore the original status of the registry */
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & saved);
    verify_return_value (_TEXT("WriteReg to restore original state"), WLBS_OK, status);

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & newdata);
    verify_return_value (_TEXT("ReadReg"), WLBS_OK, status);

    newdata . i_convert_mac = FALSE;
    newdata . mcast_support = FALSE;
    _tcscpy (newdata . cl_mac_addr, _TEXT("11-22-33-44-55-66"));

    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & newdata);
    verify_return_value (_TEXT("WriteReg with convertmac = false; mcast = false"), WLBS_OK, status);

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & temp);
    verify_return_value (_TEXT("ReadReg with convertmac = false; mcast = false"), WLBS_OK, status);

    if (memcmp (&temp, &newdata, sizeof (WLBS_REG_PARAMS)) )
    {
        _stprintf (tbuf, _TEXT("2:The data written and the data read back differ in the location %d\n"),
                   find_mem_change (&newdata, &temp, sizeof (WLBS_REG_PARAMS)) );
        add_error (tbuf);
    }

    newdata . i_convert_mac = TRUE;
    newdata . mcast_support = FALSE;

    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & newdata);
    verify_return_value (_TEXT("WriteReg with convertmac = true; mcast = false"), WLBS_OK, status);

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & temp);
    if ( _tcsnicmp(_TEXT("02-bf"), temp . cl_mac_addr, _tcslen(_TEXT("02-bf")) ) )
    {
        _stprintf (tbuf, _TEXT("Error in converting mac address in the unicast mode"));
        add_error (tbuf);
    }

    newdata . mcast_support = TRUE;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & newdata);
    verify_return_value (_TEXT("WriteReg with convertmac = true; mcast = true"), WLBS_OK, status);

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & temp);

    if ( _tcsnicmp (_TEXT("03-bf"), temp . cl_mac_addr, _tcslen(_TEXT("03-bf")) ))
    {
        _stprintf (tbuf, _TEXT("Error in converting mac address in the multicast mode"));
        add_error (tbuf);
    }

    /* These tests are to verify that parameter checking in WlbsWriteReg is o.k. */

    newdata . host_priority = CVY_MIN_PRIORITY - 1;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with host priority = 0"), WLBS_BAD_PARAMS, status);

    newdata . host_priority = CVY_MAX_PRIORITY + 1;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with host priority = 33"), WLBS_BAD_PARAMS, status);
    newdata . host_priority = saved . host_priority;

    newdata . rct_port = CVY_MIN_RCT_PORT - 1;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with RCT port = 0"), WLBS_BAD_PARAMS, status);

    newdata . rct_port = CVY_MAX_RCT_PORT + 1;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with RCT port = 65536"), WLBS_BAD_PARAMS, status);
    newdata . rct_port = saved . rct_port;

    newdata . i_num_rules = CVY_MAX_NUM_RULES + 1;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with num_rules = 33"), WLBS_BAD_PARAMS, status);
    newdata . i_num_rules = saved . i_num_rules;

    newdata . i_convert_mac = FALSE;
    _tcscpy (newdata . ded_ip_addr, _TEXT("0.0.0.0"));
    _tcscpy (newdata . cl_ip_addr, _TEXT("0.0.0.0"));
    _tcscpy (newdata . ded_net_mask, _TEXT("0.0.0.0"));
    _tcscpy (newdata . cl_net_mask, _TEXT("0.0.0.0"));
    _tcscpy (newdata . cl_mac_addr, _TEXT("00-11-22-33-44-AA"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with all ip addresses = 0"), WLBS_OK, status);

    _tcscpy (newdata . cl_mac_addr, _TEXT("0g-11-hh-jj-kk-ll"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with cl mac addr = 0g-11-hh-jj-kk-ll"), WLBS_BAD_PARAMS, status);
    _tcscpy (newdata . cl_mac_addr, _TEXT("00-11-22-33-44-AA"));

    _tcscpy (newdata . cl_mac_addr, _TEXT("00-11-22-33-44-5G"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with cl mac addr = 00-11-22-33-44-5G"), WLBS_BAD_PARAMS, status);
    _tcscpy (newdata . cl_mac_addr, _TEXT("00-11-22-33-44-AA"));

    _tcscpy (newdata . ded_net_mask, _TEXT("333.222.222.222"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with ded ip mask = 333.222.222.222"), WLBS_BAD_PARAMS, status);
    _tcscpy (newdata . ded_net_mask, _TEXT("0.0.0.0"));

    _tcscpy (newdata . ded_ip_addr, _TEXT("333.222.222.222"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with ded ip addr = 333.222.222.222"), WLBS_BAD_PARAMS, status);
    _tcscpy (newdata . ded_ip_addr, _TEXT("0.0.0.0"));

    _tcscpy (newdata . cl_net_mask, _TEXT("333.222.222.222"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with cl ip mask = 333.222.222.222"), WLBS_BAD_PARAMS, status);
    _tcscpy (newdata . cl_net_mask, _TEXT("0.0.0.0"));

    _tcscpy (newdata . cl_ip_addr, _TEXT("333.222.222.222"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with cl ip addr = 333.222.222.222"), WLBS_BAD_PARAMS, status);
    _tcscpy (newdata . cl_ip_addr, _TEXT("0.0.0.0"));


    /* Restore the initial state */
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & saved);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
    return;
}


/* This function verifies the commit functionality.
 * It writes a new priority to the registry and commits it.
 * A local query is made. The host id is checked to see that the commit has
 * indeed forced the driver to load the new host id.
 * This may cause the cluster (in case of multiple hosts) to go into convergence
 * if the id is duplicated .....
 */

void verify_host_id_changes (PWLBS_REG_PARAMS reg_data, DWORD old_priority, DWORD new_priority)
{
    DWORD status;
    DWORD num_host, host_map;
    WLBS_RESPONSE response;


    reg_data -> host_priority = new_priority;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, reg_data);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
    verify_return_value (_TEXT("Commit after changing host priority"), WLBS_OK, status);
    num_host = 1;
    status = WlbsQuery (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &response, &num_host, &host_map, NULL);

    /* Hope that Query does not return any winsock error ... */
    verify_return_value (_TEXT("Verifying the host priority after commit"),
                         new_priority,
                         response . id);

    return;
}


/* This function changes only the cluster and dedicated ip addresses and verifies them */
void verify_ip_address_changes (PWLBS_REG_PARAMS reg_data, PTCHAR cl_ip_addr, PTCHAR ded_ip_addr)
{
    DWORD status;

    _tcscpy ( reg_data -> cl_ip_addr,  cl_ip_addr);
    _tcscpy ( reg_data -> ded_ip_addr, ded_ip_addr);
    reg_data -> i_convert_mac = FALSE; /* So that the mac address does not change */

    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, reg_data);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
    /* Both nt4 and nt5 should return WLBS_OK.
     * Reboot should not be returned since the mac address is not changed.
     */
    verify_return_value (_TEXT("Commit after changing ip addresses"), WLBS_OK, status);

    verify_return_value (_TEXT("Verify Changed Cluster IP Address"),
                         WlbsResolve (cl_ip_addr),
                         WlbsGetLocalClusterAddress());

    verify_return_value (_TEXT("Verify Changed Cluster IP Address"),
                         WlbsResolve (ded_ip_addr),
                         WlbsGetDedicatedAddress());

    return;
}


/* This function verifies that the mac address is as specified in the registry structure.
 * It uses IP helper functions to get the mac address from the adapters.
 * It firsts lists all the adapters and verifies that the address on one of those
 * matches that in the registry.
 * This function will not work on NT4 machines since NT4 does not support some
 * IP helper functions.
 */
void verify_mac_address (PWLBS_REG_PARAMS reg_data)
{
    IP_ADAPTER_INFO *padapter_info = NULL, *temp_adapter_info = NULL;
    ULONG size;
    DWORD status;
    BOOL found = FALSE;
    CHAR AddressFromReg [CVY_MAX_NETWORK_ADDR + 1];
    CHAR AddressFromIPHelper [CVY_MAX_NETWORK_ADDR + 1];
    DWORD i;
    DWORD num_interfaces = 0;


    Sleep (30000); /* Wait for the driver to finish reloading and then check */

#ifdef UNICODE
    sprintf (AddressFromReg, "%ls", reg_data -> cl_mac_addr);
#else
    sprintf (AddressFromReg, "%s",  reg_data -> cl_mac_addr);
#endif

    status = GetNumberOfInterfaces (&num_interfaces);
    if (status != NO_ERROR)
    {
        printf("Unable to find any network interfaces on the local computer\nAborting the test\n");
        return;
    }

    size = sizeof (IP_ADAPTER_INFO) * num_interfaces;
    padapter_info = (IP_ADAPTER_INFO *) malloc (size);
    if (padapter_info == NULL)
        return;

    for (i = 0 ; i < num_interfaces; i++)
        padapter_info [i] . Next = NULL;

    status = GetAdaptersInfo (padapter_info, & size);
    if (status != ERROR_SUCCESS)
    {
        printf("Unable to Get Adapter Info. Cannot verify mac address.\n");
        switch (status)
        {
        case ERROR_BUFFER_OVERFLOW : printf ("Required buffer size is %d\n", size);
            break;

        case ERROR_INVALID_PARAMETER : printf ("Invalid parameter\n");
            break;

        case ERROR_NO_DATA : printf ("No Adapter Information\n");
            break;

        case ERROR_NOT_SUPPORTED : printf ("Error not supported");
            break;

        default:
            break;
        }
        return;
    }

    temp_adapter_info = padapter_info;
    while (padapter_info)
    {
        sprintf (AddressFromIPHelper, "%02x-%02x-%02x-%02x-%02x-%02x",
                 padapter_info -> Address [0],
                 padapter_info -> Address [1],
                 padapter_info -> Address [2],
                 padapter_info -> Address [3],
                 padapter_info -> Address [4],
                 padapter_info -> Address [5]);

        if (_stricmp (AddressFromIPHelper, AddressFromReg) == 0)
        {
            found = TRUE;
            break;
        }
        padapter_info = padapter_info -> Next;
    }

    /* Free the allocated memory */
    while (temp_adapter_info)
    {
        padapter_info = temp_adapter_info;
        temp_adapter_info = temp_adapter_info -> Next;
        free (padapter_info);
    }

    if (!found && !reg_data -> mcast_support)
    {
        add_error (_TEXT("In unicast mode, the registry mac address does not match the adapter mac address\n"));
        return;
    }

    if (found && reg_data -> mcast_support)
    {
        add_error (_TEXT("In multicast mode, the registry mac address was written to the NIC"));
        return;
    }
    /* If mac address is generated by converting the ip address,
     * then verify that the conversion takes place
     */
    if (reg_data -> i_convert_mac)
    {
        if (!reg_data -> mcast_support)
            if (_strnicmp (AddressFromIPHelper, "02-bf", strlen ("02-bf")) )
                add_error (_TEXT("Generation of MAC address in unicast mode failed"));
    }

    return;
}



/* This function checks the working of commit api. */
void check_commit (DWORD entry_point)
{

    WLBS_REG_PARAMS saved, newdata, temp_data;
    DWORD status;
    WLBS_RESPONSE response;
    DWORD num_host, host_map;
    DWORD old_priority, new_priority;


    _stprintf (status_buf, _TEXT("Checking Commit"));
    if (global_init == WLBS_REMOTE_ONLY || global_init == WLBS_INIT_ERROR)
    {
        _stprintf (tbuf, _TEXT("%s Unable to Perform Commit checks"), status_buf);
        add_error(tbuf);
        return;
    }

    /* Save the original configuration */
    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &saved);
    if (status != WLBS_OK)
    {
        _stprintf(tbuf, _TEXT("%s Unable to save the original configuration. Aborting the tests\n"), status_buf);
        add_error (tbuf);
        return;
    }

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);

    /* This is because commit returns reboot in nt4 on a commit when the mac address changes. */
    if (version_nt4)
    {
        if (entry_point == 1)
        {
            _tprintf(_TEXT("Use ipconfig to ensure that the mac address is %s\n"), newdata . cl_mac_addr);
            goto mac_addr_change1;
        }
        else if (entry_point == 2)
        {
            _tprintf(_TEXT("Use ipconfig to ensure that the mac address is %s\n"), newdata . cl_mac_addr);
            goto mac_addr_change2;
        }
        else if (entry_point == 3)
        {
            _tprintf(_TEXT("Use ipconfig to ensure that the mac address is the manufacturer specified one.\n"));
            goto mac_addr_change3;
        }
        else if (entry_point == 4)
        {
            _tprintf(_TEXT("Use ipconfig to ensure that the mac address is the manufacturer specified one.\n"));
            _tprintf(_TEXT("Please note that the cluster IP address has been changed by this test.\nPlease reset the cluster settings\n"));
            return;
        }
    }

    /* Write without any changes */
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
    verify_return_value (_TEXT("Commit without any changes"), WLBS_OK, status);

    /* Change only the host priority and verify that query returns the correct priority */
    old_priority = newdata . host_priority;
    new_priority = newdata . host_priority + 1; /* Could cause the cluster to stop operations */
    if (new_priority > CVY_MAX_HOST_PRIORITY)
        new_priority = 1;

    verify_host_id_changes ( &newdata, old_priority, new_priority);

    /* Change back to the original value and verify */
    verify_host_id_changes ( &newdata, new_priority, old_priority);

    /* Verify changes in the ip addresses */
    verify_ip_address_changes ( &newdata, _TEXT("111.111.111.111"), _TEXT("222.222.222.222"));

    /* Restore the original addresses and verify */
    verify_ip_address_changes ( &newdata, saved . cl_ip_addr, saved . ded_ip_addr);

    /* Now verify mac address changes */
    newdata . i_convert_mac = FALSE;
    newdata . mcast_support = FALSE;
    _stprintf (newdata . cl_mac_addr, _TEXT("00-12-34-56-78-9a"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);

    if (!version_nt4)
    {
        verify_return_value (_TEXT("Changing mac address 1"), WLBS_OK, status);
        status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &temp_data);
        verify_mac_address (&temp_data);
    }
    else
    {
        verify_return_value (_TEXT("Changing mac address 1"), WLBS_REBOOT, status);
        printf("\n");
        print_error_messages ();
        printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
        printf("Please reboot the machine and start the test as \n wlbsapitest reboot 1");
        exit (1);
    }

mac_addr_change1:
    /* When convert mac is true and mcast support is false */
    newdata . i_convert_mac = TRUE;
    newdata . mcast_support = FALSE;
    _stprintf (newdata . cl_mac_addr, _TEXT("00-12-34-56-78-9a"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);

    if (!version_nt4)
    {
        verify_return_value (_TEXT("Changing mac address 2"), WLBS_OK, status);
        status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &temp_data);
        verify_mac_address (&temp_data);
    }
    else
    {
        verify_return_value (_TEXT("Changing mac address 2"), WLBS_REBOOT, status);
        printf("\n");
        print_error_messages ();
        printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
        printf("Please reboot the machine and start the test as \n wlbsapitest reboot 2");
        exit (1);
    }

mac_addr_change2:
    /* When convertmac is true and mcast_support is also true */
    newdata . i_convert_mac = TRUE;
    newdata . mcast_support = TRUE;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);

    if (!version_nt4)
    {
        verify_return_value (_TEXT("Changing mac address 3"), WLBS_OK, status);
        status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &temp_data);
        verify_mac_address (&temp_data);
    }
    else
    {

        verify_return_value (_TEXT("Changing mac address 3"), WLBS_REBOOT, status);
        printf("\n");
        print_error_messages ();
        printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
        printf("Please reboot the machine and start the test as \n wlbsapitest reboot 3");
        exit (1);
    }

mac_addr_change3:

    /* Add a test to change the cluster ip address in multicast mode with convertmac set to true
     * and verify that ipconfig does not display this multicast mac address.
     */

    _tcscpy (newdata . cl_ip_addr, _TEXT("111.222.111.222"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);

    if (!version_nt4)
    {
        verify_return_value (_TEXT("Changing mac address 4"), WLBS_OK, status);
        status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &temp_data);
        verify_mac_address (&temp_data);
    }
    else
    {

        verify_return_value (_TEXT("Changing mac address 4"), WLBS_REBOOT, status);
        printf("\n");
        print_error_messages ();
        printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
        printf("Please reboot the machine and start the test as \n wlbsapitest reboot 4");
        exit (1);
    }



    /* restore the original state */
    if (entry_point == 0)
    {
        status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &saved);
        status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
    }

    return;
}


/* This function performs the parameter tests for the port rule APIs.
 * This includes passing NULL parameters, invalid parameters ...
 */
void port_rule_parameter_test (PWLBS_REG_PARAMS reg_data)
{
    DWORD status;
    PWLBS_PORT_RULE rules;
    WLBS_PORT_RULE rule1, rule2;
    DWORD num_rules1, num_rules2;

    _stprintf (status_buf, _TEXT("Port Rule APIs Parameter Test"));

    status = WlbsGetNumPortRules (NULL);
    verify_return_value (_TEXT("GetNumPortRules"), WLBS_BAD_PARAMS, status);

    status = WlbsEnumPortRules (NULL, NULL, NULL);
    verify_return_value (_TEXT("EnumPortRules"), WLBS_BAD_PARAMS, status);

    status = WlbsEnumPortRules (reg_data, NULL, NULL);
    verify_return_value (_TEXT("EnumPortRules"), WLBS_BAD_PARAMS, status);

    /* find the number of rules through both EnumPortRules as well as through GetNumPortRules
     * Verify that both return the same number of rules
     */
    num_rules1 = 0;
    status = WlbsEnumPortRules (reg_data, NULL, &num_rules1);
    verify_return_value (_TEXT("EnumPortRules"), WLBS_TRUNCATED, status);
    num_rules2 = WlbsGetNumPortRules (reg_data);
    verify_return_value (_TEXT("EnumPortRules and GetNumPortRules"), num_rules2, num_rules1);

    status = WlbsGetPortRule (NULL, 80, NULL);
    verify_return_value (_TEXT("GetPortRule with regdata null"), WLBS_BAD_PARAMS, status);

    status = WlbsGetPortRule (reg_data, 80, NULL);
    verify_return_value (_TEXT("GetPortRule with port_rule null"), WLBS_BAD_PARAMS, status);

    status = WlbsGetPortRule (reg_data, CVY_MAX_PORT + 1, &rule1);
    verify_return_value (_TEXT("GetPortRule with invalid port"), WLBS_BAD_PARAMS, status);

    status = WlbsAddPortRule (NULL, NULL);
    verify_return_value (_TEXT("AddPortRule with regdata null"), WLBS_BAD_PARAMS, status);
    
    status = WlbsAddPortRule (reg_data, NULL);
    verify_return_value (_TEXT("AddPortRule with port_rule null"), WLBS_BAD_PARAMS, status);

    status = WlbsDeletePortRule (NULL, 80);
    verify_return_value (_TEXT("DeletePortRule with regdata null"), WLBS_BAD_PARAMS, status);

    status = WlbsDeletePortRule (reg_data, CVY_MAX_PORT + 1);
    verify_return_value (_TEXT("DeletePortRule with invalid port number"), WLBS_BAD_PARAMS, status);

    return;
}


/* This function deletes all the existing port rules in the reg_params structure.
 * This helps in starting off from a known state.
 */
void delete_all_rules ( PWLBS_REG_PARAMS reg_data )
{
    WLBS_PORT_RULE rules [WLBS_MAX_RULES];
    DWORD num_rules;
    DWORD i;

    num_rules = WLBS_MAX_RULES;
    WlbsEnumPortRules ( reg_data, rules, & num_rules );

    for (i = 0 ; i < num_rules ; i++)
        WlbsDeletePortRule ( reg_data, rules [i] . start_port );

    return;
}


/* This function generates num_rules number of valid and non-ovelapping port rules
 * and returns it in the rules array
 */
void generate_valid_rules ( PWLBS_PORT_RULE rules, DWORD num_rules, DWORD range )
{

    DWORD i;
    static DWORD pri = 0;

    for (i = 0 ; i < num_rules ; i++)
    {
        rules [i] . start_port = i * range;
        rules [i] . end_port = rules [i] . start_port + range - 1;
        rules [i] . mode = (pri++) % CVY_MAX_MODE + 1;
        rules [i] . protocol = (pri++) % CVY_MAX_PROTOCOL + 1;
        

        if (rules [i] . mode == WLBS_SINGLE)
            rules [i] . mode_data . single . priority =  (pri++) % (WLBS_MAX_HOSTS) + 1;

        if (rules [i] . mode == WLBS_MULTI)
        {
            rules [i] . mode_data . multi . affinity = (WORD) ((pri++) % (CVY_MAX_AFFINITY + 1));
            rules [i] . mode_data . multi . equal_load = (WORD) ((pri++) % 2);
            rules [i] . mode_data . multi . load = (WORD) ((pri++) % (CVY_MAX_LOAD + 1));
        }
    }
    return;
}


/* Verify that the rules returned by Enum are in sorted order */
BOOL verify_enum_port_rules (PWLBS_PORT_RULE rules, DWORD num_rules)
{
    DWORD i;

    if (num_rules == 0)
        return TRUE;

    for (i = 0 ; i < num_rules - 1; i++)
    {
        if (rules [i] . start_port >= rules [i + 1] . start_port)
            return FALSE;
    }

    return TRUE;
}


/* Check that add and delete apis work fine. Verify this through calls to GetNum, Enum, GetPort */
void check_add_delete_port_rules (PWLBS_REG_PARAMS reg_data,
                                  PWLBS_PORT_RULE rule_list,
                                  DWORD num_rules,
                                  DWORD range)
{
    DWORD status;
    DWORD num_rules1, num_rules2;
    WLBS_PORT_RULE rule, rules [WLBS_MAX_RULES];
    DWORD i, j, port;

    /* First check the addportrule functionality.
     * After adding each rule, check that GetNumPortRules returns the correct value.
     * Verify that EnumPortRules also returns the correct number of rules
     */
    for (i = 0 ; i < WLBS_MAX_RULES ; i++)
    {
        j = (i * range) % num_rules;
        status = WlbsAddPortRule (reg_data, &rule_list [j] );
        verify_return_value (_TEXT("AddPortRule"), WLBS_OK, status);

        num_rules1 = WlbsGetNumPortRules (reg_data);
        verify_return_value (_TEXT("GetNumPortRules"), i+1, num_rules1);

        num_rules2 = WLBS_MAX_RULES;
        status = WlbsEnumPortRules (reg_data, rules, &num_rules2);
        verify_return_value (_TEXT("EnumPortRules"), WLBS_OK, status);
        verify_return_value (_TEXT("EnumPortRules and GetNum"), num_rules1, num_rules2);

        if (!verify_enum_port_rules (rules, num_rules2))
        {
            add_error (_TEXT("Error in Verifying EnumPortRules. Aborting tests"));
            return;
        }

        /* Verify that GetPortRule returns the correct port rule that was added 
         * Do a GetPortRule on the start port, the end port as well as on any port
         * number in between.
         */
        if (j%3 == 0)
            port = rule_list [j] . start_port;
        else if (j%3 == 1)
            port = rule_list [j] . end_port;
        else
            port = (rule_list [j] . start_port + rule_list [j] . end_port)/2;
    
        status = WlbsGetPortRule (reg_data, port, & rule);
        verify_return_value (_TEXT("GetPortRule"), WLBS_OK, status);

        /* These two fields are set when the rule is added */
        rule_list [j] . i_valid = rule . i_valid;
        rule_list [j] . i_code  = rule . i_code;

        if (memcmp (&rule, &rule_list [j], sizeof (WLBS_PORT_RULE)) )
            add_error (_TEXT("Port rule that was added is changed when retrieved"));
    }

    /* Now there is no space for any further rules.
     * Try to add the remaining rules.
     * WlbsAddPortRule should return WLBS_MAX_PORT_RULES each time.
     * Also, get port rule should return WLBS_NOT_FOUND
     */
    for (i = WLBS_MAX_RULES; i < num_rules; i++)
    {
        j = (i * range) % num_rules;
        
        status = WlbsAddPortRule (reg_data, & rule_list [j]);
        verify_return_value (_TEXT("AddPortRule more than 32 rules"), WLBS_MAX_PORT_RULES, status);

        port = rule_list [j] . start_port;
        status = WlbsGetPortRule (reg_data, port, &rule);
        verify_return_value (_TEXT("GetPortRule non-existent rule"), WLBS_NOT_FOUND, status);

        verify_return_value (_TEXT("GetNumPortRules when max rules"), WLBS_MAX_RULES,
                             WlbsGetNumPortRules(reg_data));
    }

    /* Test delete functionality.
     * Pass the start port, end port or any intermediate port number as input.
     * Verify that the port rule has indeed been deleted by checking GetNumPortRules,
     * EnumPortRules as well GetPortRule
     */
    for (i = 0 ; i < WLBS_MAX_RULES; i ++)
    {
        j = (i * range) % num_rules;

        if (j%3 == 0)
            port = rule_list [j] . start_port;
        else if (j%3 == 1)
            port = rule_list [j] . end_port;
        else
            port = (rule_list [j] . start_port + rule_list [j] . end_port) / 2;

        status = WlbsDeletePortRule (reg_data, port);
        verify_return_value (_TEXT("DeletePortRule"), WLBS_OK, status);

        num_rules1 = WlbsGetNumPortRules (reg_data);
        verify_return_value (_TEXT("GetNumPortRules after deleting"), WLBS_MAX_RULES - i - 1, num_rules1);

        num_rules2 = WLBS_MAX_RULES;
        status = WlbsEnumPortRules (reg_data, rules, &num_rules2);
        verify_return_value (_TEXT("EnumPortRules after deleting"), WLBS_OK, status);
        verify_return_value (_TEXT("EnumPortRules and GetNum after deleting"), num_rules1, num_rules2);

        if (!verify_enum_port_rules (rules, num_rules2))
        {
            add_error (_TEXT("Error in Verifying EnumPortRules. Aborting tests"));
            return;
        }

        status = WlbsGetPortRule (reg_data, port, & rule);
        verify_return_value (_TEXT("GetPortRule after deleting"), WLBS_NOT_FOUND, status);
    }

    /* Try to delete the remaining rules. WLBS_NOT_FOUND should be returned in all cases.
     * Also, GetNumPortRules should return 0 always */
    for (i = WLBS_MAX_RULES; i < num_rules; i++)
    {
        j = (i * range) % num_rules;
        status = WlbsDeletePortRule (reg_data, rule_list [j] . start_port);
        verify_return_value (_TEXT("DeletePortRule on empty rule list"), WLBS_NOT_FOUND, status);
        verify_return_value (_TEXT("GetNumPortRules on empty rule list"), 0,
                             WlbsGetNumPortRules(reg_data));
    }

    return;
}


void port_rule_functional_test (PWLBS_REG_PARAMS reg_data)
{
#define MAX_RULES 50

    WLBS_PORT_RULE rule1, rule2, rule_list1 [MAX_RULES], rule_list2 [WLBS_MAX_RULES];
    DWORD status1, status2;
    DWORD num_rules1, num_rules2;

    /* Delete all the existing rules. Add invalid rules and check that the error is detected.
     * Add new rules in both sorted and unsorted order and then do an enum to verify that
     * the rules get sorted. Verify that GetNumPortRules returns the correct value each time.
     * Delete the rules in random order and also in sorted order. Verify that the rule is
     * indeed deleted. Also, verify that enum returns all the rules in sorted order.
     */
    delete_all_rules (reg_data);
    generate_valid_rules (rule_list1, MAX_RULES, 500);

    rule1 = rule_list1 [0];
    /* First, try adding invalid rules. The return value should be WLBS_BAD_PORT_PARAMS */
    /* The invalid cases are listed in the apitest.c file */

    /* start port > end port */
    rule1 . start_port = rule1 . end_port + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule sp > ep"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid start port */
    rule1 . start_port = CVY_MAX_PORT + 1;
    rule1 . end_port = rule1 . start_port;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule sp > MAX_PORT"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid end port */
    rule1 . start_port = 80;
    rule1 . end_port = CVY_MAX_PORT + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule sp = 80 ep > MAX_PORT"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid protocol */
    rule1 = rule_list1 [0];
    rule1 . protocol = CVY_MIN_PROTOCOL - 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidProtocol"), WLBS_BAD_PORT_PARAMS, status1);

    rule1 . protocol = CVY_MAX_PROTOCOL + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidProtocol"), WLBS_BAD_PORT_PARAMS, status1);

    rule1 . protocol = CVY_MAX_PROTOCOL;
    /* invalid mode */
    rule1 . mode = CVY_MIN_MODE - 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidMode"), WLBS_BAD_PORT_PARAMS, status1);

    rule1 . mode = CVY_MAX_MODE + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidMode"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid priority */
    rule1 . mode = CVY_SINGLE;
    rule1 . mode_data . single . priority = CVY_MIN_PRIORITY - 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidPriority"), WLBS_BAD_PORT_PARAMS, status1);

    rule1 . mode_data . single . priority = CVY_MAX_PRIORITY + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidPriority"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid affinity */
    rule1 . mode = CVY_MULTI;
    rule1 . mode_data . multi . affinity = CVY_MAX_AFFINITY + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidAffinity"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid equal load */
    rule1 . mode_data . multi . affinity = CVY_MAX_AFFINITY;
    rule1 . mode_data . multi . equal_load = CVY_MAX_EQUAL_LOAD + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidEqualLoad"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid load */
    rule1 . mode_data . multi . equal_load = CVY_MIN_EQUAL_LOAD;
    rule1 . mode_data . multi . load = CVY_MAX_LOAD + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidLoad"), WLBS_BAD_PORT_PARAMS, status1);

    /* add a valid rule and then test for overlapping rules
     * Test the different cases where overlapping can occur
     */
    rule1 = rule_list1 [1];
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule ValidRule"), WLBS_OK, status1);

    rule2 = rule1;
    status1 = WlbsAddPortRule (reg_data, &rule2);
    verify_return_value (_TEXT("AddPortRule Overlap. same start and end ports"), WLBS_PORT_OVERLAP, status1);

    rule2 . start_port = rule1 . start_port + 1;
    rule2 . end_port   = rule2 . end_port - 1;
    status1 = WlbsAddPortRule (reg_data, &rule2);
    verify_return_value (_TEXT("AddPortRule Overlap 2 "), WLBS_PORT_OVERLAP, status1);

    rule2 . start_port = rule1 . start_port - 1;
    rule2 . end_port   = rule2 . end_port + 1;
    status1 = WlbsAddPortRule (reg_data, &rule2);
    verify_return_value (_TEXT("AddPortRule Overlap 3 "), WLBS_PORT_OVERLAP, status1);

    /* The following two tests would fail if the start port and the end port both are the same */
    rule2 . start_port = rule1 . start_port - 1;
    rule2 . end_port   = rule2 . end_port - 1;
    status1 = WlbsAddPortRule (reg_data, &rule2);
    verify_return_value (_TEXT("AddPortRule Overlap 4 "), WLBS_PORT_OVERLAP, status1);

    rule2 . start_port = rule1 . start_port + 1;
    rule2 . end_port   = rule2 . end_port + 1;
    status1 = WlbsAddPortRule (reg_data, &rule2);
    verify_return_value (_TEXT("AddPortRule Overlap 5 "), WLBS_PORT_OVERLAP, status1);

    status1 = WlbsDeletePortRule (reg_data, rule1 . start_port);
    verify_return_value (_TEXT("DeletePortRule"), WLBS_OK, status1);

    /* First test the APIs by inserting and deleting the rules in sorted order */
    check_add_delete_port_rules (reg_data, rule_list1, MAX_RULES, 1);
    /* Then test the APIs by inserting and deleting the rules in pseudo - unsorted order */
    check_add_delete_port_rules (reg_data, rule_list1, MAX_RULES, 7);

    return;
#undef MAX_RULES
}


void check_port_rule_apis ()
{

    WLBS_REG_PARAMS saved, reg_data;
    DWORD status;

    if (global_init == WLBS_REMOTE_ONLY || global_init == WLBS_INIT_ERROR)
    {
        add_error (_TEXT("WLBS is not installed on this host. Port rule apis cannot be tested"));
        return;
    }

    /* Save the existing configuration */
    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &saved);
    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &reg_data);

    port_rule_parameter_test (&reg_data);
    port_rule_functional_test (&reg_data);

    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &saved);

    return;
}


void print_error_messages ()
{
    PErr_Struct temp;
    DWORD i = 0;

    while (headq)
    {
        temp = headq;
        i++;
        _tprintf (_TEXT("Error %d %s\n"), i, temp -> comment);
        headq = headq -> next;
        free(temp);
    }

    return;
}


#define INTERNET_ADDRESS "111.111.11.11"

/* This function tests WlbsResolve, WlbsAddressToString and WlbsAddressToName */
void check_winsock_wrappers ()
{
    DWORD lenp;
    DWORD address;
    TCHAR buf1[5], buf2[20], buf3[100], buf4[100];
    CHAR cbuf[100], cbuf2[20];
    int len = 1000;
    struct hostent * host;

    _stprintf (status_buf, _TEXT("Verifying Winsock Wrappers"));
    verify_return_value (_TEXT("WlbsResolve on invalid name"), WlbsResolve(_TEXT("junkname")), 0);
    gethostname (cbuf, len); /* Assume that this function does not fail */
#ifdef UNICODE
    swprintf (buf4, _TEXT("%S"), cbuf);
#else
    sprintf (buf4, "%s", cbuf);
#endif

    host = gethostbyname (cbuf);
    if (host == NULL)
    {
        add_error(_TEXT("gethostbyname failed, aborting winsock wrapper test\n"));
        return;

    }

    verify_return_value (_TEXT("WlbsResolve on null name"), WlbsResolve(NULL),0);

    address = ((struct in_addr *) (host -> h_addr)) -> s_addr;
    verify_return_value (_TEXT("WlbsResolve on local machine name"), WlbsResolve(buf4),
                         address);

    verify_return_value (_TEXT("WlbsResolve on valid dotted notation"),
                         WlbsResolve(_TEXT("111.111.111.111")),
                         inet_addr ("111.111.111.111"));

    verify_return_value (_TEXT("WlbsResolve on invalid dotted notation"),
                         WlbsResolve(_TEXT("333.111.111.111")), 0);


    lenp = 0;
    verify_return_value (_TEXT("WlbsAddressToString on null buffer"),
                         WlbsAddressToString (address , NULL, &lenp),
                         FALSE );
    verify_return_value (_TEXT("WlbsAddressToString required buffer length"),
                         strlen (inet_ntoa (* ((struct in_addr *) &address)) ) + 1, lenp);

    lenp = 5;
    verify_return_value (_TEXT("WlbsAddressToString on insufficient buffer"),
                         WlbsAddressToString (address , buf1, &lenp),
                         FALSE );
    verify_return_value (_TEXT("WlbsAddressToString required buffer length"),
                         strlen (inet_ntoa (* ((struct in_addr *) &address)) ) + 1, lenp);

    lenp = 20;
    verify_return_value (_TEXT("WlbsAddressToString on sufficient buffer"),
                         WlbsAddressToString (address , buf2, &lenp),
                         TRUE );
    verify_return_value (_TEXT("WlbsAddressToString required buffer length"),
                         strlen (inet_ntoa (* ((struct in_addr *) &address)) ) + 1, lenp);

#ifdef UNICODE
    sprintf (cbuf2, "%ls", buf2);
#else
    sprintf (cbuf2, "%s", buf2);
#endif

    if (_stricmp (cbuf2, inet_ntoa (* ((struct in_addr *) &address))) )
    {
        _stprintf (tbuf,
                   _TEXT("WlbsAddressToString return was different from the value supplied. Expected %S Got %S"),
                   cbuf2, inet_ntoa (* ((struct in_addr *) &address)) );

        add_error (tbuf);
    }

    /* WlbsAddressToName */
    lenp = 0;
    verify_return_value (_TEXT("WlbsAddressToName on null buffer"),
                         FALSE,
                         WlbsAddressToName (address, NULL, &lenp));
    verify_return_value (_TEXT("WlbsAddressToName required buffer length"),
                         strlen ((gethostbyaddr ((char *) & address, sizeof (DWORD), AF_INET)) -> h_name) + 1,
                         lenp);

    lenp = 5;
    verify_return_value (_TEXT("WlbsAddressToName on insufficient buffer"),
                         FALSE,
                         WlbsAddressToName (address , buf1, &lenp));
    verify_return_value (_TEXT("WlbsAddressToName required buffer length"),
                         strlen ((gethostbyaddr ((char *) & address, sizeof (DWORD), AF_INET)) -> h_name) + 1,
                         lenp);

    lenp = 100;
    verify_return_value (_TEXT("WlbsAddressToName on sufficient buffer"),
                         TRUE,
                         WlbsAddressToName (address , buf3, &lenp));
    verify_return_value (_TEXT("WlbsAddressToName required buffer length"),
                         strlen ((gethostbyaddr ((char *) & address, sizeof (DWORD), AF_INET)) -> h_name) + 1,
                         lenp);

    sprintf (cbuf, "%s", (gethostbyaddr ((char *) & address, sizeof (DWORD), AF_INET)) -> h_name);
#ifdef UNICODE
    swprintf (buf4, L"%S", cbuf);
#else
    sprintf (buf4, "%s", cbuf);
#endif
    if (_tcsicmp (buf3, buf4) )
    {
        _stprintf (tbuf,
                  _TEXT("WlbsAddressToName return was different from the value supplied. Expected %s Got %s"),
                  buf4, buf3);

        add_error (tbuf);
    }

    return;
}



void print_usage ()
{
    printf("Usage  : wlbsapitest [local] [remote cl_ip host_ip] [init] [verbose] [reboot 1|2|3] [timeout t]\n");
    printf("local  : for local cluster/host tests\n");
    printf("remote : for remote cluster/host tests\n");
    printf("init   : for testing a WlbsInit special case\n");
    printf("verbose: for printing the tests as they are carried out\n");
    printf("reboot : for testing commit on nt4 machines. Contact kumar for further info.\n");
    printf("timeout: for specifying the timeout value for cluster-wide queries. Specify it in milliseconds\n");
    return;
}


INT __cdecl _tmain
(
    INT             argc,
    PTCHAR          __targv []
)
{
    DWORD i;
    INT arg_count;
    OSVERSIONINFO   osiv;
    DWORD entry_point = 0;

    if (argc == 1)
    {
        print_usage();
        return 1;
    }

    /* Now parse the command line */
    arg_count = 1;

    while (arg_count < argc)
    {
        do {

            if ( ! _tcsicmp (__targv [arg_count], _TEXT("local")) )
                {
                local_test = TRUE;
                arg_count++;
                break;
            }

            if ( ! _tcsicmp (__targv [arg_count], _TEXT("remote")) )
                {
                if ( (argc - arg_count) <= 2)
                {
                    print_usage ();
                    return 1;
                }

                remote_cl_ip = WlbsResolve (__targv [arg_count + 1]);
                remote_host_ip = WlbsResolve (__targv [arg_count + 2]);
                remote_test = TRUE;
                arg_count += 3;
                break;
            }

            if ( ! _tcsicmp (__targv [arg_count], _TEXT("verbose")) )
            {
                verbose = TRUE;
                arg_count ++;
                break;
            }

            if ( ! _tcsicmp (__targv [arg_count], _TEXT("init")) )
            {
                init_test = TRUE;
                arg_count ++;
                break;
            }

            if ( ! _tcsicmp (__targv [arg_count], _TEXT("timeout")) )
            {
                if (argc - arg_count <= 1)
                {
                    print_usage ();
                    return 1;
                }
                timeout = _ttoi ( __targv [arg_count + 1] );
                arg_count += 2;
                break;
            }

            if ( ! _tcsicmp (__targv [arg_count], _TEXT("reboot")) )
            {
                if (argc - arg_count <= 1)
                {
                    print_usage ();
                    return 1;
                }
                entry_point = _ttoi ( __targv [arg_count + 1] );
                arg_count += 2;
                if (entry_point > 3)
                {
                    print_usage ();
                    return 1;
                }
                break;
            }

            print_usage ();
            return 1;

        } while ( 0 );
    }


    if (remote_test)
    {
        printf("Please enter the password for the remote host/cluster : ");
        _tscanf (_TEXT("%s"), remote_password);
    }

    if (!verbose)
        printf("Test Number: 0000");

    /* Get the version info on the OS (nt4 or higher) and store the info. */
    memset (&osiv, 0, sizeof (OSVERSIONINFO));
    osiv . dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (GetVersionEx(&osiv) == 0)
        printf("error in getting the os version\n");
    version_nt4 = (osiv . dwPlatformId == VER_PLATFORM_WIN32_NT) &&
                  (osiv . dwMajorVersion == 4);

    check_init();
    if (init_test)
    {
        printf("\n");
        print_error_messages();
        printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
        return 1;
    }

    if (version_nt4)
        if (entry_point != 0)
        {
            check_commit (entry_point);
            return 1;
        }

    check_single_host_operations();
    check_cluster_operations();


    if (!local_test)
    {
        printf("\n");
        print_error_messages();
        printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
        return 1;
    }

    check_port_rule_apis();
    check_registry_rw();
    check_commit(0);
    check_winsock_wrappers();
    printf("\n");
    print_error_messages();
    printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\notification.cpp ===
/* 
 * File: notification.cpp
 * Description: Support for connection notification.
 * Author: shouse 4.30.01
 */


#include "precomp.h"
#include <iphlpapi.h>
#include "debug.h"
#include "notification.tmh"

extern DWORD MapStateFromDriverToApi(DWORD dwDriverState);

/* The length of the IP to GUID hash table. */
#define IP_TO_GUID_HASH 19

/* Loopback IP address. (127.0.0.1) */
#define IP_LOOPBACK_ADDRESS 0x0100007f

/* Spin count mask specifying a preallocated event for use by InitializeCriticalSectionAndSpinCount */
#define PREALLOC_CRITSECT_SPIN_COUNT 0x80000000

/* An Ip to GUID table entry. */
typedef struct IPToGUIDEntry {
    ULONG dwIPAddress;
    WCHAR szAdapterGUID[CVY_MAX_DEVNAME_LEN];
    IPToGUIDEntry * pNext;
} IPToGUIDEntry;

/* The WLBS device - necessary for IOCTLs. */
WCHAR szDevice[CVY_STR_SIZE];

/* The IP to GUID map is an array of linked lists hashed on IP address. */
IPToGUIDEntry * IPToGUIDMap[IP_TO_GUID_HASH];

/* An overlapped structure for IP address change notifications. */
OVERLAPPED AddrChangeOverlapped;

/* A handle for IP address change notifications. */
HANDLE hAddrChangeHandle;

/* A handle for an IP address change event. */
HANDLE hAddrChangeEvent;

/* A preallocated critical section for IP address change notifications to
   protect against one thread of execution tearing down notification state
   while another is using it. */
CRITICAL_SECTION csConnectionNotify;

/* A boolean to indicate whether or not connection notification has been initialized.
   Initialization is performed upon the first call to either WlbsConnectionUp or WlbsConnectionDown. */
static BOOL fInitialized = FALSE;

/*
 * Function: GetGUIDFromIP
 * Description: Gets the GUID from the IPToGUID table corresponding to the
 *              the given IP address.
 * Returns: If the call succeeds, returns a pointer to the unicode string
 *          containing the CLSID (GUID).  Upon failure, returns NULL.
 * Author: shouse 6.15.00 
 */
WCHAR * GetGUIDFromIP (ULONG IPAddress) {
    TRACE_VERB("->%!FUNC!");

    IPToGUIDEntry * entry = NULL;

    /* Loop through the linked list at the hashed index and return the GUID from the entry
       corresponding to the given IP address. */
    for (entry = IPToGUIDMap[IPAddress % IP_TO_GUID_HASH]; entry; entry = entry->pNext)
    {
        if (entry->dwIPAddress == IPAddress) 
        {
            if (NULL != entry->szAdapterGUID) TRACE_VERB("->%!FUNC! return guid %ls", entry->szAdapterGUID);
            else TRACE_VERB("->%!FUNC! return guid which is NULL");
            return entry->szAdapterGUID;
        }
    }

    /* At this point, we can't find the IP address in the table, so bail. */
    TRACE_VERB("<-%!FUNC! return NULL");
    return NULL;
}

/*
 * Function: GetGUIDFromIndex
 * Description: Gets the GUID from the AdaptersInfo table corresponding
 *              to the given IP address.
 * Returns: If the call succeeds, returns a pointer to the string containing
 *          the adapter name (GUID).  Upon failure, returns NULL.
 * Author: shouse 6.15.00 
 */
CHAR * GetGUIDFromIndex (PIP_ADAPTER_INFO pAdapterTable, DWORD dwIndex) {
    TRACE_VERB("->%!FUNC!");

    PIP_ADAPTER_INFO pAdapterInfo = NULL;   

    /* Loop through the adapter table looking for the given index.  Return the adapter
       name for the corresponding index. */
    for (pAdapterInfo = pAdapterTable; pAdapterInfo; pAdapterInfo = pAdapterInfo->Next)
    {
        if (pAdapterInfo->Index == dwIndex)
        {
            TRACE_VERB("->%!FUNC! return guid %s", pAdapterInfo->AdapterName);
            return pAdapterInfo->AdapterName;
        }
    }

    /* If we get this far, we can't find it, so bail. */
    TRACE_VERB("<-%!FUNC! return NULL");
    return NULL;
}

/*
 * Function: PrintIPAddress
 * Description: Prints an IP address in dot notation.
 * Returns: 
 * Author: shouse 6.15.00 
 */
void PrintIPAddress (ULONG IPAddress) {
    CHAR szIPAddress[16];
    HRESULT hresult;

    hresult = StringCbPrintfA(szIPAddress, sizeof(szIPAddress), "%d.%d.%d.%d", 
                              IPAddress & 0x000000ff, (IPAddress & 0x0000ff00) >> 8, 
                              (IPAddress & 0x00ff0000) >> 16, (IPAddress & 0xff000000) >> 24);

    if (SUCCEEDED(hresult)) 
    {
        TRACE_VERB("%!FUNC! %-15s", szIPAddress);
    }
}

/*
 * Function: PrintIPToGUIDMap
 * Description: Traverses and prints the IPToGUID map.
 * Returns: 
 * Author: shouse 6.15.00 
 */
void PrintIPToGUIDMap (void) {
    IPToGUIDEntry * entry = NULL;
    DWORD dwHash;

    /* Loop through the linked list at each hashed index and print the IP to GUID mapping. */
    for (dwHash = 0; dwHash < IP_TO_GUID_HASH; dwHash++) {
        for (entry = IPToGUIDMap[dwHash]; entry; entry = entry->pNext) {
            PrintIPAddress(entry->dwIPAddress);
            TRACE_VERB("%!FUNC! -> GUID %ws\n", entry->szAdapterGUID);
        }
    }
}

/*
 * Function: DestroyIPToGUIDMap
 * Description: Destroys the IPToGUID map.
 * Returns: Returns ERROR_SUCCESS if successful.  Returns an error code otherwise.
 * Author: shouse 6.15.00 
 * Modified: chrisdar 07.23.02 - Changed to return void. If this function fails there isn't
 *               anything we can do about it. When bailing if HeapFree failed we didn't
 *               NULL the pointer, hence we had an invalid pointer.
 */
void DestroyIPToGUIDMap (void) {
    TRACE_VERB("->%!FUNC!");

    IPToGUIDEntry * next = NULL;
    DWORD dwHash;

    /* Loop through all hash indexes. */
    for (dwHash = 0; dwHash < IP_TO_GUID_HASH; dwHash++) {
        next = IPToGUIDMap[dwHash];
        
        /* Loop through the linked list and free each entry. */
        while (next) {
            IPToGUIDEntry * entry = NULL;

            entry = next;
            next = next->pNext;

            if (!HeapFree(GetProcessHeap(), 0, entry)) {
                //
                // Don't abort on error because we need to clean up the whole table.
                //
                TRACE_CRIT("%!FUNC! memory deallocation failed with %d", GetLastError());
            }

            entry = NULL;
        }

        /* Reset the pointer to the head of the list in the array. */
        IPToGUIDMap[dwHash] = NULL;
    }

    TRACE_VERB("<-%!FUNC! return void");
    return;
}

/*
 * Function: BuildIPToGUIDMap
 * Description: Builds the IPToGUID map by first getting information on all adapters and
 *              then retrieving the map of IP addresses to adapters.  Using those tables,
 *              this constructs a mapping of IP addresses to adapter GUIDs.
 * Returns:  Returns ERROR_SUCCESS if successful.  Returns an error code otherwise.
 * Author:   shouse   6.14.00
 * Modified: chrisdar 07.24.02 Free dynamically allocated memory when an error occurs.
 *               Also no longer ignore failures in strsafe functions as this makes
 *               the table entries useless.
 */
//
// TODO: 24 July 2002 chrisdar
// Three issues need to be fixed in this function:
//      1. Method of allocating memory for output of GetAdaptersInfo can fail if adapter
//         list changes between calls. This was seen in testing.
//      2. Same as 1. except for output of GetIpAddrTable.
//      3. Output from GetAdaptersInfo has all of the information needed (except that
//         IPs are strings instead of dwords). Remove calls to GetIpAddrTable and modify
//         logic to use output of GetAdaptersInfo.
//
DWORD BuildIPToGUIDMap (void) {
    TRACE_VERB("->%!FUNC!");

    DWORD dwError = ERROR_SUCCESS;
    PMIB_IPADDRTABLE pAddressTable = NULL;
    PIP_ADAPTER_INFO pAdapterTable = NULL;
    DWORD dwAddressSize = 0;
    DWORD dwAdapterSize = 0;
    DWORD dwEntry;
    HRESULT hresult;

    /* Destroy the IP to GUID map first. */
    DestroyIPToGUIDMap();

    /* Query the necessary length of a buffer to hold the adapter info. */
    if ((dwError = GetAdaptersInfo(pAdapterTable, &dwAdapterSize)) != ERROR_BUFFER_OVERFLOW) {
        TRACE_CRIT("%!FUNC! GetAdaptersInfo for buffer size failed with %d", dwError);
        goto exit;
    }

    /* Allocate a buffer of the indicated size. */
    if (!(pAdapterTable = (PIP_ADAPTER_INFO)HeapAlloc(GetProcessHeap(), 0, dwAdapterSize))) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        TRACE_CRIT("%!FUNC! memory allocation for adapter table failed with %d", dwError);
        goto exit;
    }

    /* Fill the buffer with the adapter info. */
    if ((dwError = GetAdaptersInfo(pAdapterTable, &dwAdapterSize)) != NO_ERROR) {
        TRACE_CRIT("%!FUNC! GetAdaptersInfo for filling adapter buffer failed with %d", dwError);
        goto exit;
    }

    /* Query the necessary length of a buffer to hold the IP address table. */
    if ((dwError = GetIpAddrTable(pAddressTable, &dwAddressSize, TRUE)) != ERROR_INSUFFICIENT_BUFFER) {
        TRACE_CRIT("%!FUNC! GetIpAddrTable for IP address length failed with %d", dwError);
        goto exit;
    }

    /* Allocate a buffer of the indicated size. */
    if (!(pAddressTable = (PMIB_IPADDRTABLE)HeapAlloc(GetProcessHeap(), 0, dwAddressSize))) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        TRACE_CRIT("%!FUNC! memory allocation for IP address failed with %d", dwError);
        goto exit;
    }

    /* Fill the buffer with the IP address table. */
    if ((dwError = GetIpAddrTable(pAddressTable, &dwAddressSize, TRUE)) != NO_ERROR) {
        TRACE_CRIT("%!FUNC! GetIpAddrTable for filling IP address buffer failed with %d", dwError);
        goto exit;
    }
    
    /* For each entry in the IP address to adapter table, create an entry for our IP address to GUID table. */
    for (dwEntry = 0; dwEntry < pAddressTable->dwNumEntries; dwEntry++) {
        PCHAR pszDeviceName = NULL;
        IPToGUIDEntry * entry = NULL;
        
        /* Only create an entry if the IP address is nonzero and is not the IP loopback address. */
        if ((pAddressTable->table[dwEntry].dwAddr != 0UL) && (pAddressTable->table[dwEntry].dwAddr != IP_LOOPBACK_ADDRESS)) {
            WCHAR szAdapterGUID[CVY_MAX_DEVNAME_LEN];

            /* Retrieve the GUID from the interface index. */
            if (!(pszDeviceName = GetGUIDFromIndex(pAdapterTable, pAddressTable->table[dwEntry].dwIndex))) {
                dwError = ERROR_INCORRECT_ADDRESS;
                TRACE_CRIT("%!FUNC! failed retriving interface index from guid with %d", dwError);
                goto exit;
            }
            
            /* Allocate a buffer for the IP to GUID entry. */
            if (!(entry = (IPToGUIDEntry *)HeapAlloc(GetProcessHeap(), 0, sizeof(IPToGUIDEntry)))) {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                TRACE_CRIT("%!FUNC! memory allocation failure for the IP to guid entry");
                goto exit;
            }
            
            /* Zero the entry contents. */
            ZeroMemory((VOID *)entry, sizeof(entry));
            
            /* Insert the entry at the head of the linked list indexed by the IP address % HASH. */
            entry->pNext = IPToGUIDMap[pAddressTable->table[dwEntry].dwAddr % IP_TO_GUID_HASH];
            IPToGUIDMap[pAddressTable->table[dwEntry].dwAddr % IP_TO_GUID_HASH] = entry;
            
            /* Fill in the IP address. */
            entry->dwIPAddress = pAddressTable->table[dwEntry].dwAddr;
            
            /* GUIDS in NLB multi-NIC are expected to be prefixed with "\DEVICE\". */
            hresult = StringCbCopy(entry->szAdapterGUID, sizeof(entry->szAdapterGUID), L"\\DEVICE\\");
            if (FAILED(hresult)) 
            {
                dwError = (DWORD) hresult;
                TRACE_CRIT("%!FUNC! string copy failed for DEVICE, Error code : 0x%x", HRESULT_CODE(hresult));
                goto exit;
            }

            /* Convert the adapter name ASCII string to a GUID unicode string and place it in the table entry. */
            if (!MultiByteToWideChar(CP_ACP, 0, pszDeviceName, -1, szAdapterGUID, CVY_MAX_DEVNAME_LEN)) {
                dwError = GetLastError();
                TRACE_CRIT("%!FUNC! converting ascii string to guid failed with %d", dwError);
                goto exit;
            }

            /* Cat the GUID onto the "\DEVICE\". */
            hresult = StringCbCat(entry->szAdapterGUID, sizeof(entry->szAdapterGUID), szAdapterGUID);
            if (FAILED(hresult)) 
            {
                dwError = (DWORD) hresult;
                TRACE_CRIT("%!FUNC! string append of guid failed, Error code : 0x%x", HRESULT_CODE(hresult));
                goto exit;
            }
        }
        else
        {
            TRACE_INFO("%!FUNC! IP address passed is either 0 or localhost. Skipping it.");
        }
    }
    
    //
    // Note that this printing is for debug purposes only. It is left enabled in all builds because it
    // only calls TRACE_VERB for ouput.
    //
    PrintIPToGUIDMap();

exit:

    /* Free the buffers used to query the IP stack. */
    if (pAddressTable) HeapFree(GetProcessHeap(), 0, pAddressTable);
    if (pAdapterTable) HeapFree(GetProcessHeap(), 0, pAdapterTable);

    TRACE_VERB("<-%!FUNC! return %d", dwError);
    return dwError;
}

/*
 * Function: WlbsConnectionNotificationInit
 * Description: Initialize connection notification by retrieving the device driver
 *              information for later use by IOCTLs and build the IPToGUID map.
 * Returns: Returns ERROR_SUCCESS if successful.  Returns an error code otherwise.
 * Author: shouse 6.15.00 
 */
DWORD WlbsConnectionNotificationInit (void) {
    TRACE_VERB("->%!FUNC!");

    DWORD dwError = ERROR_SUCCESS;
    WCHAR szDriver[CVY_STR_SIZE];
    HRESULT hresult;

    hresult = StringCbPrintf(szDevice, sizeof(szDevice), L"\\\\.\\%ls", CVY_NAME);
    if (FAILED(hresult)) 
    {
        dwError = HRESULT_CODE(hresult);
        TRACE_CRIT("%!FUNC! StringCbPrintf failed, Error code : 0x%x", dwError);
        TRACE_VERB("<-%!FUNC! return 0x%x", dwError);
        return dwError;
    }

    /* Query for the existence of the WLBS driver. */
    if (!QueryDosDevice(szDevice + 4, szDriver, CVY_STR_SIZE)) {
        dwError = GetLastError();
        TRACE_CRIT("%!FUNC! querying for nlb driver failed with %d", dwError);
        TRACE_VERB("<-%!FUNC! return %d", dwError);
        return dwError;
    }

    /* Build the IP to GUID mapping. */
    if ((dwError = BuildIPToGUIDMap()) != ERROR_SUCCESS) {
        TRACE_CRIT("%!FUNC! ip to guid map failed with %d", dwError);
        TRACE_VERB("<-%!FUNC! return %d", dwError);
        return dwError;
    }

    /* Create an IP address change event. */
    if (!(hAddrChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
        dwError = GetLastError();
        TRACE_CRIT("%!FUNC! create event failed with %d", dwError);
        TRACE_VERB("<-%!FUNC! return %d", dwError);
        return dwError;
    }

    /* Clear the overlapped structure. */
    ZeroMemory(&AddrChangeOverlapped, sizeof(OVERLAPPED));

    /* Place the event handle in the overlapped structure. */
    AddrChangeOverlapped.hEvent = hAddrChangeEvent;

    /* Tell IP to notify us of any changes to the IP address to interface mapping. */
    dwError = NotifyAddrChange(&hAddrChangeHandle, &AddrChangeOverlapped);

    if ((dwError != NO_ERROR) && (dwError != ERROR_IO_PENDING)) {
        TRACE_CRIT("%!FUNC! register of event with ip failed with %d", dwError);
        TRACE_VERB("<-%!FUNC! return %d", dwError);
        return dwError;
    }

    TRACE_VERB("<-%!FUNC! return %d", ERROR_SUCCESS);
    return ERROR_SUCCESS;
}

/*
 * Function: ResolveAddressTableChanges
 * Description: Checks for changes in the IP address to adapter mapping and rebuilds the
 *              IPToGUID map if necessary.
 * Returns: Returns ERROR_SUCCESS upon success.  Returns an error code otherwise.
 * Author: shouse 6.20.00
 */
DWORD ResolveAddressTableChanges (void) {
    TRACE_VERB("->%!FUNC!");

    DWORD dwError = ERROR_SUCCESS;
    DWORD dwLength = 0;

    /* Check to see if the IP address to adapter table has been modified. */
    if (GetOverlappedResult(hAddrChangeHandle, &AddrChangeOverlapped, &dwLength, FALSE)) {
        TRACE_INFO("%!FUNC! IP address to adapter table modified... Rebuilding IP to GUID map...");
        
        /* If so, rebuild the IP address to GUID mapping. */
        if ((dwError = BuildIPToGUIDMap()) != ERROR_SUCCESS) {
            TRACE_CRIT("%!FUNC! ip to guid map failed with %d", dwError);
            goto exit;
        }

        /* Tell IP to notify us of any changes to the IP address to interface mapping. */        
        dwError = NotifyAddrChange(&hAddrChangeHandle, &AddrChangeOverlapped);

        if ((dwError == NO_ERROR) || (dwError == ERROR_IO_PENDING))
        {
            dwError = ERROR_SUCCESS;
        }
        else
        {
            TRACE_CRIT("%!FUNC! register of event with ip failed with %d", dwError);
            goto exit;
        }
    }
    else
    {
        dwError = GetLastError();
        if (dwError == ERROR_IO_PENDING || dwError == ERROR_IO_INCOMPLETE)
        {
            dwError = ERROR_SUCCESS;
        }
        else
        {
            TRACE_CRIT("%!FUNC! GetOverlappedResult failed with %d", dwError);
            goto exit;
        }
    }

exit:

    TRACE_VERB("->%!FUNC! return %d", dwError);
    return dwError;
}

/*
 * Function: MapExtendedStatusToWin32
 * Description: Converts the status code returned by the driver into a Win32 error code defined in winerror.h.
 * Returns: A Win32 error code.
 * Author: shouse, 9.7.01
 * Notes: 
 */
DWORD MapExtendedStatusToWin32 (DWORD dwDriverState) {

    struct STATE_MAP {
        DWORD dwDriverState;
        DWORD dwApiState;
    } StateMap[] = {  
        {IOCTL_CVY_BAD_PARAMS,      ERROR_INVALID_PARAMETER},
        {IOCTL_CVY_NOT_FOUND,       ERROR_NOT_FOUND},
        {IOCTL_CVY_GENERIC_FAILURE, ERROR_GEN_FAILURE},
        {IOCTL_CVY_REQUEST_REFUSED, ERROR_REQUEST_REFUSED},
        {IOCTL_CVY_OK,              ERROR_SUCCESS}
    };

    for (int i = 0; i < sizeof(StateMap) / sizeof(StateMap[0]); i++) {
        if (StateMap[i].dwDriverState == dwDriverState)
            return StateMap[i].dwApiState;
    }

    /* If we can't find the appropriate driver error code in the map, return failure. */
    return ERROR_GEN_FAILURE;
}

/*
 * Function: WlbsCancelConnectionNotify
 * Description: Cancel IP route and address change notifications from TCP/IP. Call this once after any call to WlbsConnectionNotify. 
 * Returns: dwError - DWORD status = ERROR_SUCCESS if call is successful. 
 * Author: chrisdar 7.16.02
 */
DWORD WINAPI WlbsCancelConnectionNotify()
{
    DWORD dwError = ERROR_SUCCESS;

    TRACE_VERB("-> %!FUNC!");

    EnterCriticalSection(&csConnectionNotify);

    if (!fInitialized)
    {
        TRACE_VERB("%!FUNC! notification cleanup is not needed...exiting.");
        goto end;
    }

    if (CancelIPChangeNotify(&AddrChangeOverlapped))
    {
        DWORD BytesTrans;
        //
        // Block until the cancel operation completes
        //
        if (!GetOverlappedResult(&hAddrChangeHandle, &AddrChangeOverlapped, &BytesTrans, TRUE))
        {
            dwError = GetLastError();
            if (dwError == ERROR_OPERATION_ABORTED)
            {
                //
                // This is the expected status since we canceled IP change notifications. Overwrite with success for caller.
                //
                dwError = ERROR_SUCCESS;
            }
            else
            {
                TRACE_CRIT("%!FUNC! GetOverlappedResult failed with error 0x%x", dwError);
            }
        }
    }
    else
    {
        //
        // Failure conditions are:
        //     Requested operation already in progress
        //     There is no notification to cancel
        // Neither is a critical error but tell the user about it since this shouldn't happen.
        //
        dwError = GetLastError();
        TRACE_INFO("%!FUNC! CancelIPChangeNotify failed with error 0x%x", dwError);
    }

    if (!CloseHandle(hAddrChangeEvent))
    {
        //
        // Don't return this status to caller. Just absorb it.
        //
        TRACE_CRIT("%!FUNC! CloseHandle failed with error 0x%x", GetLastError());
    }

    hAddrChangeEvent = INVALID_HANDLE_VALUE;
    AddrChangeOverlapped.hEvent = INVALID_HANDLE_VALUE;

    /* Destroy the IP to GUID map first. */
    DestroyIPToGUIDMap();

    fInitialized = FALSE;

end:

    LeaveCriticalSection(&csConnectionNotify);

    TRACE_VERB("<- %!FUNC! return status = 0x%x", dwError);
    return dwError;
}

/*
 * Function: WlbsConnectionNotify
 * Description: Used to notify the WLBS load module that a connection has been established, reset or closed.
 * Returns: Returns ERROR_SUCCESS if successful.  Returns an error code otherwise.
 * Author: shouse 6.13.00 
 * Notes: All tuple parameters (IPs, ports and protocols) are expected in NETWORK BYTE ORDER.
 */
DWORD WINAPI WlbsConnectionNotify (ULONG ServerIp, USHORT ServerPort, ULONG ClientIp, USHORT ClientPort, BYTE Protocol, NLB_OPTIONS_CONN_NOTIFICATION_OPERATION Operation, PULONG NLBStatusEx) {
    TRACE_VERB("->%!FUNC! server ip 0x%lx, server port %d, client ip 0x%lx, client port %d", ServerIp, ServerPort, ClientIp, ClientPort);

    IOCTL_LOCAL_HDR Header;
    DWORD           dwError = ERROR_SUCCESS;
    PWCHAR          pszAdapterGUID = NULL;
    HANDLE          hDescriptor;
    DWORD           dwLength = 0;
    HRESULT         hresult;

    EnterCriticalSection(&csConnectionNotify);

    /* By default, the extended NLB status is success. */
    *NLBStatusEx = ERROR_SUCCESS;

    /* If not done so already, initialize connection notification support. */
    if (!fInitialized) {
        if ((dwError = WlbsConnectionNotificationInit()) != ERROR_SUCCESS) {
            LeaveCriticalSection(&csConnectionNotify);
            TRACE_CRIT("%!FUNC! initializing connection notification failed with %d", dwError);
            TRACE_VERB("->%!FUNC! return %d", dwError);
            return dwError;
        }

        fInitialized = TRUE;
    }

    /* Zero the IOCTL input and output buffers. */
    ZeroMemory((VOID *)&Header, sizeof(IOCTL_LOCAL_HDR));

    /* Resolve any changes to the IP address table before we map this IP address. */
    if ((dwError = ResolveAddressTableChanges()) != ERROR_SUCCESS) {
        //
        // WlbsCancelConnectionNotify will also enter the critical section, but this is legal. A
        // thread that owns the critical section can enter it multiple times without blocking itself.
        // However, it must leave the critical section an equal number of times before another
        // thread can enter.
        //
        (void) WlbsCancelConnectionNotify();
        LeaveCriticalSection(&csConnectionNotify);
        TRACE_CRIT("%!FUNC! resolve ip addresses failed with %d", dwError);
        TRACE_VERB("->%!FUNC! return %d", dwError);
        return dwError;
    }

    /* Retrieve the GUID corresponding to the adapter on which this IP address is configured. */
    if (!(pszAdapterGUID = GetGUIDFromIP(ServerIp))) {
        (void) WlbsCancelConnectionNotify();
        dwError = ERROR_INCORRECT_ADDRESS;
        LeaveCriticalSection(&csConnectionNotify);
        TRACE_CRIT("%!FUNC! retrieve guid failed with %d", dwError);
        TRACE_VERB("->%!FUNC! return %d", dwError);
        return dwError;
    }

    /* Copy the GUID into the IOCTL input buffer. */
    hresult = StringCbCopy(Header.device_name, sizeof(Header.device_name), pszAdapterGUID);
    if (FAILED(hresult)) 
    {
        (void) WlbsCancelConnectionNotify();
        dwError = HRESULT_CODE(hresult);
        LeaveCriticalSection(&csConnectionNotify);
        TRACE_CRIT("%!FUNC! StringCbCopy failed, Error code : 0x%x", dwError);
        TRACE_VERB("<-%!FUNC! return 0x%x", dwError);
        return dwError;
    }

    LeaveCriticalSection(&csConnectionNotify);

    /* Copy the function parameters into the IOCTL input buffer. */
    Header.options.notification.flags = 0;
    Header.options.notification.conn.Operation = Operation;
    Header.options.notification.conn.ServerIPAddress = ServerIp;
    Header.options.notification.conn.ServerPort = ntohs(ServerPort);
    Header.options.notification.conn.ClientIPAddress = ClientIp;
    Header.options.notification.conn.ClientPort = ntohs(ClientPort);
    Header.options.notification.conn.Protocol = (USHORT)Protocol;

    PrintIPAddress(ServerIp);
    TRACE_VERB("%!FUNC! maps to GUID %ws", Header.device_name);
    
    /* Open the device driver. */
    if ((hDescriptor = CreateFile(szDevice, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0)) == INVALID_HANDLE_VALUE) {
        dwError = GetLastError();
        TRACE_CRIT("%!FUNC! open device driver failed with %d", dwError);
        TRACE_VERB("->%!FUNC! return %d", dwError);
        return dwError;
    }
    
    /* Use an IOCTL to notify the WLBS driver state change for the connection. */
    if (!DeviceIoControl(hDescriptor, IOCTL_CVY_CONNECTION_NOTIFY, &Header, sizeof(IOCTL_LOCAL_HDR), &Header, sizeof(IOCTL_LOCAL_HDR), &dwLength, NULL)) {
        dwError = GetLastError();
        CloseHandle(hDescriptor);
        TRACE_CRIT("%!FUNC! ioctl send failed with %d", dwError);
        TRACE_VERB("->%!FUNC! return %d", dwError);
        return dwError;
    }

    /* Make sure the expected number of bytes was returned by the IOCTL. */
    if (dwLength != sizeof(IOCTL_LOCAL_HDR)) {
        dwError = ERROR_INTERNAL_ERROR;
        CloseHandle(hDescriptor);
        TRACE_CRIT("%!FUNC! unexpected ioctl header length %d received. Expecting %d", dwLength, sizeof(IOCTL_LOCAL_HDR));
        TRACE_VERB("->%!FUNC! return %d", dwError);
        return dwError;
    }

    /*
      Extended status can be one of:

      IOCTL_CVY_OK (WLBS_OK), if the notification is accepted.
      IOCTL_CVY_REQUEST_REFUSED (WLBS_REFUSED), if the notification is rejected.
      IOCTL_CVY_BAD_PARAMS (WLBS_BAD_PARAMS), if the arguments are invalid.
      IOCTL_CVY_NOT_FOUND (WLBS_NOT_FOUND), if NLB was not bound to the specified adapter.
      IOCTL_CVY_GENERIC_FAILURE (WLBS_FAILURE), if a non-specific error occurred.
    */

    /* Pass the return code from the driver back to the caller. */
    *NLBStatusEx = MapStateFromDriverToApi(Header.ctrl.ret_code);

    /* Close the device driver. */
    CloseHandle(hDescriptor);

    TRACE_VERB("->%!FUNC! return %d", dwError);
    return dwError;
} 

/*
 * Function: 
 * Description: 
 * Returns: 
 * Author: shouse 6.13.00 
 */
DWORD WINAPI WlbsConnectionUp (ULONG ServerIp, USHORT ServerPort, ULONG ClientIp, USHORT ClientPort, BYTE Protocol, PULONG NLBStatusEx) {
    
    return WlbsConnectionNotify(ServerIp, ServerPort, ClientIp, ClientPort, Protocol, NLB_CONN_UP, NLBStatusEx);
}

/*
 * Function: 
 * Description: 
 * Returns: 
 * Author: shouse 6.13.00 
 */
DWORD WINAPI WlbsConnectionDown (ULONG ServerIp, USHORT ServerPort, ULONG ClientIp, USHORT ClientPort, BYTE Protocol, PULONG NLBStatusEx) {

    return WlbsConnectionNotify(ServerIp, ServerPort, ClientIp, ClientPort, Protocol, NLB_CONN_DOWN, NLBStatusEx);
}

/*
 * Function: 
 * Description: 
 * Returns: 
 * Author: shouse 6.13.00 
 */
DWORD WINAPI WlbsConnectionReset (ULONG ServerIp, USHORT ServerPort, ULONG ClientIp, USHORT ClientPort, BYTE Protocol, PULONG NLBStatusEx) {

    return WlbsConnectionNotify(ServerIp, ServerPort, ClientIp, ClientPort, Protocol, NLB_CONN_RESET, NLBStatusEx);
}

/*
 * Function: WlbsInitializeConnectionNotify
 * Description: Uses InitializeCriticalSectionAndSpinCount to preallocate all
 *              memory associated with locking the critical section. Then
 *              EnterCriticalSection won't raise a STATUS_INVALID_HANDLE
 *              exception, which could otherwise occur during low memory
 *              conditions.
 * Returns: dwError - DWORD status = ERROR_SUCCESS if call is successful. 
 * Author: chrisdar 7.16.02
 */
DWORD WlbsInitializeConnectionNotify()
{
    DWORD dwError = ERROR_SUCCESS;

    TRACE_VERB("-> %!FUNC!");

    if (!InitializeCriticalSectionAndSpinCount(&csConnectionNotify, PREALLOC_CRITSECT_SPIN_COUNT))
    {
        dwError = GetLastError();
        TRACE_CRIT("%!FUNC! InitializeCriticalSectionAndSpinCount failed with error 0x%x", dwError);
    }

    TRACE_VERB("<- %!FUNC! return status = 0x%x", dwError);
    return dwError;
}

/*
 * Function: WlbsUninitializeConnectionNotify
 * Description: Frees memory associated with an initialized critical section.
 *              Behavior is undefined if critical section is owned when this
 *              function is called. After calling this function, the critical
 *              section must be initialized again before it can be used.
 * Returns:
 * Author: chrisdar 7.16.02
 */
VOID WlbsUninitializeConnectionNotify()
{
    TRACE_VERB("-> %!FUNC!");

    DeleteCriticalSection(&csConnectionNotify);

    TRACE_VERB("<- %!FUNC!");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\params.cpp ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    params.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    API - registry parameters support

Author:

    kyrilf

--*/

#include "precomp.h"
#include "cluster.h"
#include "control.h"
#include "param.h"
#include "debug.h"
#include "params.tmh" // for event tracing

extern HINSTANCE g_hInstCtrl; // Global variable for the dll instance, defined in control.cpp

HKEY WINAPI RegOpenWlbsSetting(const GUID& AdapterGuid, bool fReadOnly)
{
    TRACE_VERB("->%!FUNC!");

    WCHAR        reg_path [PARAMS_MAX_STRING_SIZE];
    WCHAR szAdapterGuid[128];
    HRESULT      hresult;
    
    if (0 == StringFromGUID2(AdapterGuid, szAdapterGuid, sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0])))
    {
        TRACE_CRIT("%!FUNC! guid is too large for string. Result is %ls", szAdapterGuid);
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }

    hresult = StringCbPrintf(reg_path, sizeof(reg_path), L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface\\%s",
                szAdapterGuid);
    if (FAILED(hresult)) 
    {
        TRACE_CRIT("StringCbPrintf failed, Error code : 0x%x", HRESULT_CODE(hresult));
        TRACE_VERB("<-%!FUNC! handle NULL");
        return NULL;
    }

    HKEY hKey = NULL;
    DWORD dwRet = RegOpenKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L,
                                fReadOnly? KEY_READ : KEY_WRITE, & hKey);

    if (dwRet != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! failed to read %ls from registry with 0x%lx", reg_path, dwRet);
        TRACE_VERB("<-%!FUNC! handle NULL");
        return NULL;
    }

    TRACE_VERB("<-%!FUNC! return valid handle");
    return hKey;    
}

//+----------------------------------------------------------------------------
//
// Function:  TransformOldPortRulesToNew
//
// Description: Transforms port rules contained in structures without the virtual 
//              ip address into the new ones that do
//
// Arguments: Array of Old Port Rules, Array of New Port Rules, Length of Array 
//
// Returns:   void
//
// History:   KarthicN, Created on 3/19/01
//
//+----------------------------------------------------------------------------
void TransformOldPortRulesToNew(PWLBS_OLD_PORT_RULE  p_old_port_rules,
                                PWLBS_PORT_RULE      p_new_port_rules, 
                                DWORD                num_rules)
{
    HRESULT hresult;

    TRACE_VERB("->%!FUNC! number of rules %d", num_rules);

    if (num_rules == 0) 
        return;
            
    while(num_rules--)
    {
        hresult = StringCbCopy(p_new_port_rules->virtual_ip_addr, sizeof(p_new_port_rules->virtual_ip_addr), CVY_DEF_ALL_VIP);
        if (FAILED(hresult))
        {
            TRACE_CRIT("%!FUNC! string copy for vip failed, Error code : 0x%x", HRESULT_CODE(hresult));
            // This check was added for tracing. No abort was done previously on error, so don't do so now.
        }
        p_new_port_rules->start_port      = p_old_port_rules->start_port;
        p_new_port_rules->end_port        = p_old_port_rules->end_port;
 #ifdef WLBSAPI_INTERNAL_ONLY
        p_new_port_rules->code            = p_old_port_rules->code;
 #else
        p_new_port_rules->Private1        = p_old_port_rules->Private1;
 #endif
        p_new_port_rules->mode            = p_old_port_rules->mode;
        p_new_port_rules->protocol        = p_old_port_rules->protocol;

 #ifdef WLBSAPI_INTERNAL_ONLY
        p_new_port_rules->valid           = p_old_port_rules->valid;
 #else
        p_new_port_rules->Private2        = p_old_port_rules->Private2;
 #endif
        switch (p_new_port_rules->mode) 
        {
        case CVY_MULTI :
             p_new_port_rules->mode_data.multi.equal_load = p_old_port_rules->mode_data.multi.equal_load;
             p_new_port_rules->mode_data.multi.affinity   = p_old_port_rules->mode_data.multi.affinity;
             p_new_port_rules->mode_data.multi.load       = p_old_port_rules->mode_data.multi.load;
             break;
        case CVY_SINGLE :
             p_new_port_rules->mode_data.single.priority  = p_old_port_rules->mode_data.single.priority;
             break;
        default:
             TRACE_CRIT("%!FUNC! illegal port rule mode %d. Ignoring property...", p_new_port_rules->mode);
             break;
        }
        p_old_port_rules++;
        p_new_port_rules++;
    }

    TRACE_VERB("<-%!FUNC!");
    return;
}

/* Open the bi-directional affinity teaming registry key for a specified adapter. */
HKEY WINAPI RegOpenWlbsBDASettings (const GUID& AdapterGuid, bool fReadOnly) {
    TRACE_VERB("->%!FUNC!");

    WCHAR reg_path[PARAMS_MAX_STRING_SIZE];
    WCHAR szAdapterGuid[128];
    HKEY  hKey = NULL;
    DWORD dwRet;
    HRESULT hresult;
    
    if (0 == StringFromGUID2(AdapterGuid, szAdapterGuid, sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0])))
    {
        TRACE_CRIT("%!FUNC! guid is too large for string. Result is %ls", szAdapterGuid);
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }
            
    hresult = StringCbPrintf(reg_path, sizeof(reg_path), L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface\\%ls\\%ls", szAdapterGuid, CVY_NAME_BDA_TEAMING);
    if (FAILED(hresult)) 
    {
        TRACE_CRIT("StringCbPrintf failed, Error code : 0x%x", HRESULT_CODE(hresult));
        TRACE_VERB("<-%!FUNC! handle NULL");
        return NULL;
    }

    dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, reg_path, 0L, fReadOnly ? KEY_READ : KEY_WRITE, &hKey);

    //
    // BDA isn't typically configured so don't report not-found errors
    //
    if (dwRet != ERROR_SUCCESS) {
        if (dwRet != ERROR_FILE_NOT_FOUND)
        {
            TRACE_CRIT("%!FUNC! failed to read %ls from registry with 0x%lx", reg_path, dwRet);
        }
        TRACE_VERB("<-%!FUNC! handle NULL");
        return NULL;
    }

    TRACE_VERB("<-%!FUNC! return valid handle %p", hKey);
    return hKey;
}

/* Create the bi-directional affinity teaming registry key for a specified adapter. */
HKEY WINAPI RegCreateWlbsBDASettings (const GUID& AdapterGuid) {
    TRACE_VERB("->%!FUNC!");

    WCHAR reg_path[PARAMS_MAX_STRING_SIZE];
    WCHAR szAdapterGuid[128];
    HKEY  hKey = NULL;
    DWORD dwRet;
    DWORD disp;
    HRESULT hresult;

    if (0 == StringFromGUID2(AdapterGuid, szAdapterGuid, sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0])))
    {
        TRACE_CRIT("%!FUNC! guid is too large for string. Result is %ls", szAdapterGuid);
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }
            
    hresult = StringCbPrintf(reg_path, sizeof(reg_path), L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface\\%ls\\%ls", szAdapterGuid, CVY_NAME_BDA_TEAMING);
    if (FAILED(hresult)) 
    {
        TRACE_CRIT("StringCbPrintf failed, Error code : 0x%x", HRESULT_CODE(hresult));
        TRACE_VERB("<-%!FUNC! handle NULL");
        return NULL;
    }
    
    dwRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, reg_path, 0L, L"", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &disp);

    if (dwRet != ERROR_SUCCESS) {
        TRACE_CRIT("%!FUNC! failed to create %ls in registry with 0x%lx", reg_path, dwRet);
        TRACE_VERB("<-%!FUNC! handle NULL");
        return NULL;
    }

    TRACE_VERB("<-%!FUNC! handle");
    return hKey;
}

/* Delete the bi-directional affinity teaming registry key for a specified adapter. */
bool WINAPI RegDeleteWlbsBDASettings (const GUID& AdapterGuid) {
    TRACE_VERB("->%!FUNC!");

    WCHAR reg_path[PARAMS_MAX_STRING_SIZE];
    WCHAR szAdapterGuid[128];
    DWORD dwRet;
    HRESULT hresult;
    
    if (0 == StringFromGUID2(AdapterGuid, szAdapterGuid, sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0])))
    {
        TRACE_CRIT("%!FUNC! guid is too large for string. Result is %ls", szAdapterGuid);
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }
            
    hresult = StringCbPrintf(reg_path, sizeof(reg_path), L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface\\%ls\\%ls", szAdapterGuid, CVY_NAME_BDA_TEAMING);
    if (FAILED(hresult)) 
    {
        TRACE_CRIT("StringCbPrintf failed, Error code : 0x%x", HRESULT_CODE(hresult));
        TRACE_VERB("<-%!FUNC! fail");
        return FALSE;
    }
    
    dwRet = RegDeleteKey(HKEY_LOCAL_MACHINE, reg_path);

    //
    // BDA isn't typically configured so don't report not-found errors
    //
    if (dwRet != ERROR_SUCCESS) {
        if (dwRet != ERROR_FILE_NOT_FOUND)
        {
            TRACE_CRIT("%!FUNC! failed to delete %ls from registry with 0x%lx", reg_path, dwRet);
        }
        TRACE_VERB("<-%!FUNC! fail");
        return FALSE;
    }

    TRACE_VERB("<-%!FUNC! pass");
    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  WlbsParamReadReg
//
// Description:  This function is a wrapper around ParamReadReg, created for
//               the sake for making it callable from 'C' modules
//
// Arguments: const GUID& AdapterGuid - IN, Adapter guid
//            PWLBS_REG_PARAMS paramp - OUT Registry parameters
//
// Returns:   bool  - true if succeeded
//
// History:   karthicn Created Header    8/31/01
//
//+----------------------------------------------------------------------------
BOOL WINAPI WlbsParamReadReg(const GUID * pAdapterGuid, PWLBS_REG_PARAMS paramp)
{
    TRACE_VERB("->%!FUNC!");
    BOOL bRet = ParamReadReg(*pAdapterGuid, paramp);
    TRACE_VERB("<-%!FUNC! returning 0x%x",bRet);
    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  ParamReadReg
//
// Description:  Read cluster settings from registry
//
// Arguments: const GUID& AdapterGuid - IN, Adapter guid
//            PWLBS_REG_PARAMS paramp - OUT Registry parameters
//            bool fUpgradeFromWin2k, whether this is a upgrade from Win2k 
//              or earlier version
//
// Returns:   bool  - true if succeeded
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
bool WINAPI ParamReadReg(const GUID& AdapterGuid, 
    PWLBS_REG_PARAMS paramp, bool fUpgradeFromWin2k, bool *pfPortRulesInBinaryForm)
{
    TRACE_VERB("->%!FUNC!");

    HKEY            bda_key = NULL;
    HKEY            key;
    LONG            status;
    DWORD           type;
    DWORD           size;
    ULONG           i, code;
    WLBS_PORT_RULE* rp;
    WCHAR           reg_path [PARAMS_MAX_STRING_SIZE];
    HRESULT         hresult;

    memset (paramp, 0, sizeof (*paramp));

    //
    // For win2k or NT4, only one cluster is supported, there is no per adapter settings 
    //
    if (fUpgradeFromWin2k)
    {
        hresult = StringCbPrintf(reg_path, sizeof(reg_path), L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters");
        if (FAILED(hresult)) 
        {
            TRACE_CRIT("StringCbPrintf failed, Error code : 0x%x", HRESULT_CODE(hresult));
            TRACE_VERB("<-%!FUNC! return false");
            return FALSE;
        }

        status = RegOpenKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L,
                           KEY_QUERY_VALUE, & key);

        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! failed opening registry for %ls with 0x%lx", reg_path, status);
            TRACE_VERB("<-%!FUNC! return false");
            return false;
        }
    }
    else
    {
        key = RegOpenWlbsSetting(AdapterGuid, true);

        if (key == NULL)
        {
            TRACE_CRIT("%!FUNC! RegOpenWlbsSetting failed");
            TRACE_VERB("<-%!FUNC! return false");
            return false;
        }
    }
    

    size = sizeof (paramp -> install_date);
    status = RegQueryValueEx (key, CVY_NAME_INSTALL_DATE, 0L, & type,
                              (LPBYTE) & paramp -> install_date, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> install_date = 0;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_INSTALL_DATE, status, (DWORD)(paramp -> install_date));
    }

    size = sizeof (paramp -> i_verify_date);
    status = RegQueryValueEx (key, CVY_NAME_VERIFY_DATE, 0L, & type,
                              (LPBYTE) & paramp -> i_verify_date, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_verify_date = 0;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_VERIFY_DATE, status, paramp -> i_verify_date);
    }

    size = sizeof (paramp -> i_parms_ver);
    status = RegQueryValueEx (key, CVY_NAME_VERSION, 0L, & type,
                              (LPBYTE) & paramp -> i_parms_ver, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_parms_ver = CVY_DEF_VERSION;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_VERSION, status, paramp -> i_parms_ver);
    }

    size = sizeof (paramp -> i_virtual_nic_name);
    status = RegQueryValueEx (key, CVY_NAME_VIRTUAL_NIC, 0L, & type,
                              (LPBYTE) paramp -> i_virtual_nic_name, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_virtual_nic_name [0] = 0;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using NULL.", CVY_NAME_VIRTUAL_NIC, status);
    }

    size = sizeof (paramp -> host_priority);
    status = RegQueryValueEx (key, CVY_NAME_HOST_PRIORITY, 0L, & type,
                              (LPBYTE) & paramp -> host_priority, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> host_priority = CVY_DEF_HOST_PRIORITY;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_HOST_PRIORITY, status, paramp -> host_priority);
    }

    size = sizeof (paramp -> cluster_mode);
    status = RegQueryValueEx (key, CVY_NAME_CLUSTER_MODE, 0L, & type,
                              (LPBYTE) & paramp -> cluster_mode, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> cluster_mode = CVY_DEF_CLUSTER_MODE;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_CLUSTER_MODE, status, paramp -> cluster_mode);
    }

    size = sizeof (paramp -> persisted_states);
    status = RegQueryValueEx (key, CVY_NAME_PERSISTED_STATES, 0L, & type,
                              (LPBYTE) & paramp -> persisted_states, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> persisted_states = CVY_DEF_PERSISTED_STATES;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_PERSISTED_STATES, status, paramp -> persisted_states);
    }

    size = sizeof (paramp -> cl_mac_addr);
    status = RegQueryValueEx (key, CVY_NAME_NETWORK_ADDR, 0L, & type,
                              (LPBYTE) paramp -> cl_mac_addr, & size);

    if (status != ERROR_SUCCESS)
    {
        hresult = StringCbCopy(paramp -> cl_mac_addr, sizeof(paramp -> cl_mac_addr), CVY_DEF_NETWORK_ADDR);
        if (FAILED(hresult)) 
        {
            TRACE_CRIT("%!FUNC! StringCbCopy failed, Error code : 0x%x", HRESULT_CODE(hresult)); 
        }
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %ls", CVY_NAME_NETWORK_ADDR, status, CVY_DEF_NETWORK_ADDR);
    }

    size = sizeof (paramp -> cl_ip_addr);
    status = RegQueryValueEx (key, CVY_NAME_CL_IP_ADDR, 0L, & type,
                              (LPBYTE) paramp -> cl_ip_addr, & size);

    if (status != ERROR_SUCCESS)
    {
        hresult = StringCbCopy (paramp -> cl_ip_addr, sizeof(paramp -> cl_ip_addr), CVY_DEF_CL_IP_ADDR);
        if (FAILED(hresult)) 
        {
            TRACE_CRIT("%!FUNC! StringCbCopy failed, Error code : 0x%x", HRESULT_CODE(hresult)); 
        }
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %ls", CVY_NAME_CL_IP_ADDR, status, CVY_DEF_CL_IP_ADDR);
    }

    size = sizeof (paramp -> cl_net_mask);
    status = RegQueryValueEx (key, CVY_NAME_CL_NET_MASK, 0L, & type,
                              (LPBYTE) paramp -> cl_net_mask, & size);

    if (status != ERROR_SUCCESS)
    {
        hresult = StringCbCopy (paramp -> cl_net_mask, sizeof(paramp -> cl_net_mask), CVY_DEF_CL_NET_MASK);
        if (FAILED(hresult)) 
        {
            TRACE_CRIT("%!FUNC! StringCbCopy failed, Error code : 0x%x", HRESULT_CODE(hresult)); 
        }
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %ls", CVY_NAME_CL_NET_MASK, status, CVY_DEF_CL_NET_MASK);
    }

    size = sizeof (paramp -> ded_ip_addr);
    status = RegQueryValueEx (key, CVY_NAME_DED_IP_ADDR, 0L, & type,
                              (LPBYTE) paramp -> ded_ip_addr, & size);

    if (status != ERROR_SUCCESS)
    {
        hresult = StringCbCopy (paramp -> ded_ip_addr, sizeof(paramp -> ded_ip_addr), CVY_DEF_DED_IP_ADDR);
        if (FAILED(hresult)) 
        {
            TRACE_CRIT("%!FUNC! StringCbCopy failed, Error code : 0x%x", HRESULT_CODE(hresult)); 
        }
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %ls", CVY_NAME_DED_IP_ADDR, status, CVY_DEF_DED_IP_ADDR);
    }


    size = sizeof (paramp -> ded_net_mask);
    status = RegQueryValueEx (key, CVY_NAME_DED_NET_MASK, 0L, & type,
                              (LPBYTE) paramp -> ded_net_mask, & size);

    if (status != ERROR_SUCCESS)
    {
        hresult = StringCbCopy (paramp -> ded_net_mask, sizeof(paramp -> ded_net_mask), CVY_DEF_DED_NET_MASK);
        if (FAILED(hresult)) 
        {
            TRACE_CRIT("%!FUNC! StringCbCopy failed, Error code : 0x%x", HRESULT_CODE(hresult)); 
        }
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %ls", CVY_NAME_DED_NET_MASK, status, CVY_DEF_DED_NET_MASK);
    }


    size = sizeof (paramp -> domain_name);
    status = RegQueryValueEx (key, CVY_NAME_DOMAIN_NAME, 0L, & type,
                              (LPBYTE) paramp -> domain_name, & size);

    if (status != ERROR_SUCCESS)
    {
        hresult = StringCbCopy (paramp -> domain_name, sizeof(paramp -> domain_name), CVY_DEF_DOMAIN_NAME);
        if (FAILED(hresult)) 
        {
            TRACE_CRIT("%!FUNC! StringCbCopy failed, Error code : 0x%x", HRESULT_CODE(hresult)); 
        }
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %ls", CVY_NAME_DOMAIN_NAME, status, CVY_DEF_DOMAIN_NAME);
    }


    size = sizeof (paramp -> alive_period);
    status = RegQueryValueEx (key, CVY_NAME_ALIVE_PERIOD, 0L, & type,
                              (LPBYTE) & paramp -> alive_period, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> alive_period = CVY_DEF_ALIVE_PERIOD;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_ALIVE_PERIOD, status, paramp -> alive_period);
    }


    size = sizeof (paramp -> alive_tolerance);
    status = RegQueryValueEx (key, CVY_NAME_ALIVE_TOLER, 0L, & type,
                              (LPBYTE) & paramp -> alive_tolerance, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> alive_tolerance = CVY_DEF_ALIVE_TOLER;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_ALIVE_TOLER, status, paramp -> alive_tolerance);
    }


    size = sizeof (paramp -> num_actions);
    status = RegQueryValueEx (key, CVY_NAME_NUM_ACTIONS, 0L, & type,
                              (LPBYTE) & paramp -> num_actions, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> num_actions = CVY_DEF_NUM_ACTIONS;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_NUM_ACTIONS, status, paramp -> num_actions);
    }


    size = sizeof (paramp -> num_packets);
    status = RegQueryValueEx (key, CVY_NAME_NUM_PACKETS, 0L, & type,
                              (LPBYTE) & paramp -> num_packets, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> num_packets = CVY_DEF_NUM_PACKETS;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_NUM_PACKETS, status, paramp -> num_packets);
    }


    size = sizeof (paramp -> num_send_msgs);
    status = RegQueryValueEx (key, CVY_NAME_NUM_SEND_MSGS, 0L, & type,
                              (LPBYTE) & paramp -> num_send_msgs, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> num_send_msgs = CVY_DEF_NUM_SEND_MSGS;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_NUM_SEND_MSGS, status, paramp -> num_send_msgs);
    }


    size = sizeof (paramp -> dscr_per_alloc);
    status = RegQueryValueEx (key, CVY_NAME_DSCR_PER_ALLOC, 0L, & type,
                              (LPBYTE) & paramp -> dscr_per_alloc, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> dscr_per_alloc = CVY_DEF_DSCR_PER_ALLOC;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_DSCR_PER_ALLOC, status, paramp -> dscr_per_alloc);
    }

    size = sizeof (paramp -> tcp_dscr_timeout);
    status = RegQueryValueEx (key, CVY_NAME_TCP_TIMEOUT, 0L, & type,
                              (LPBYTE) & paramp -> tcp_dscr_timeout, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> tcp_dscr_timeout = CVY_DEF_TCP_TIMEOUT;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_TCP_TIMEOUT, status, paramp -> tcp_dscr_timeout);
    }

    size = sizeof (paramp -> ipsec_dscr_timeout);
    status = RegQueryValueEx (key, CVY_NAME_IPSEC_TIMEOUT, 0L, & type,
                              (LPBYTE) & paramp -> ipsec_dscr_timeout, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> ipsec_dscr_timeout = CVY_DEF_IPSEC_TIMEOUT;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_IPSEC_TIMEOUT, status, paramp -> ipsec_dscr_timeout);
    }

    size = sizeof (paramp -> filter_icmp);
    status = RegQueryValueEx (key, CVY_NAME_FILTER_ICMP, 0L, & type,
                              (LPBYTE) & paramp -> filter_icmp, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> filter_icmp = CVY_DEF_FILTER_ICMP;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_FILTER_ICMP, status, paramp -> filter_icmp);
    }

    size = sizeof (paramp -> max_dscr_allocs);
    status = RegQueryValueEx (key, CVY_NAME_MAX_DSCR_ALLOCS, 0L, & type,
                              (LPBYTE) & paramp -> max_dscr_allocs, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> max_dscr_allocs = CVY_DEF_MAX_DSCR_ALLOCS;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_MAX_DSCR_ALLOCS, status, paramp -> max_dscr_allocs);
    }


    size = sizeof (paramp -> i_scale_client);
    status = RegQueryValueEx (key, CVY_NAME_SCALE_CLIENT, 0L, & type,
                              (LPBYTE) & paramp -> i_scale_client, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_scale_client = CVY_DEF_SCALE_CLIENT;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_SCALE_CLIENT, status, paramp -> i_scale_client);
    }

    size = sizeof (paramp -> i_cleanup_delay);
    status = RegQueryValueEx (key, CVY_NAME_CLEANUP_DELAY, 0L, & type,
                              (LPBYTE) & paramp -> i_cleanup_delay, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_cleanup_delay = CVY_DEF_CLEANUP_DELAY;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_CLEANUP_DELAY, status, paramp -> i_cleanup_delay);
    }

    /* V1.1.1 */

    size = sizeof (paramp -> i_nbt_support);
    status = RegQueryValueEx (key, CVY_NAME_NBT_SUPPORT, 0L, & type,
                              (LPBYTE) & paramp -> i_nbt_support, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_nbt_support = CVY_DEF_NBT_SUPPORT;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_NBT_SUPPORT, status, paramp -> i_nbt_support);
    }

    /* V1.3b */

    size = sizeof (paramp -> mcast_support);
    status = RegQueryValueEx (key, CVY_NAME_MCAST_SUPPORT, 0L, & type,
                              (LPBYTE) & paramp -> mcast_support, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> mcast_support = CVY_DEF_MCAST_SUPPORT;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_MCAST_SUPPORT, status, paramp -> mcast_support);
    }


    size = sizeof (paramp -> i_mcast_spoof);
    status = RegQueryValueEx (key, CVY_NAME_MCAST_SPOOF, 0L, & type,
                              (LPBYTE) & paramp -> i_mcast_spoof, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_mcast_spoof = CVY_DEF_MCAST_SPOOF;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_MCAST_SPOOF, status, paramp -> i_mcast_spoof);
    }


    size = sizeof (paramp -> mask_src_mac);
    status = RegQueryValueEx (key, CVY_NAME_MASK_SRC_MAC, 0L, & type,
                              (LPBYTE) & paramp -> mask_src_mac, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> mask_src_mac = CVY_DEF_MASK_SRC_MAC;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_MASK_SRC_MAC, status, paramp -> mask_src_mac);
    }


    size = sizeof (paramp -> i_netmon_alive);
    status = RegQueryValueEx (key, CVY_NAME_NETMON_ALIVE, 0L, & type,
                              (LPBYTE) & paramp -> i_netmon_alive, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_netmon_alive = CVY_DEF_NETMON_ALIVE;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_NETMON_ALIVE, status, paramp -> i_netmon_alive);
    }

    size = sizeof (paramp -> i_effective_version);
    status = RegQueryValueEx (key, CVY_NAME_EFFECTIVE_VERSION, 0L, & type,
                              (LPBYTE) & paramp -> i_effective_version, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_effective_version = CVY_NT40_VERSION_FULL;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_EFFECTIVE_VERSION, status, paramp -> i_effective_version);
    }

    size = sizeof (paramp -> i_ip_chg_delay);
    status = RegQueryValueEx (key, CVY_NAME_IP_CHG_DELAY, 0L, & type,
                              (LPBYTE) & paramp -> i_ip_chg_delay, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_ip_chg_delay = CVY_DEF_IP_CHG_DELAY;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_IP_CHG_DELAY, status, paramp -> i_ip_chg_delay);
    }


    size = sizeof (paramp -> i_convert_mac);
    status = RegQueryValueEx (key, CVY_NAME_CONVERT_MAC, 0L, & type,
                              (LPBYTE) & paramp -> i_convert_mac, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_convert_mac = CVY_DEF_CONVERT_MAC;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_CONVERT_MAC, status, paramp -> i_convert_mac);
    }


    size = sizeof (paramp -> i_num_rules);
    status = RegQueryValueEx (key, CVY_NAME_NUM_RULES, 0L, & type,
                              (LPBYTE) & paramp -> i_num_rules, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_num_rules = 0;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_NUM_RULES, status, paramp -> i_num_rules);
    }

    WLBS_OLD_PORT_RULE  old_port_rules [WLBS_MAX_RULES];
    HKEY                subkey;

    //
    // If it an upgrade from Win2k or if unable to open reg key in new location/format, read the binary formatted port
    // rules from old location. Otherwise, read from the new location.
    //
    status = ERROR_SUCCESS;
    if (fUpgradeFromWin2k 
     || ((status = RegOpenKeyEx (key, CVY_NAME_PORT_RULES, 0L, KEY_QUERY_VALUE, & subkey)) != ERROR_SUCCESS))
    {
        // Did we enter the block due to failure of RegOpenKeyEx ?
        if (status != ERROR_SUCCESS) 
        {
            TRACE_CRIT("%!FUNC! registry open for %ls failed with %d. Not an upgrade from Win2k, Assuming upgrade from pre-check-in whistler builds and continuing", CVY_NAME_PORT_RULES, status);
        }

        TRACE_INFO("%!FUNC! port rules are in binary form");

        if (pfPortRulesInBinaryForm) 
            *pfPortRulesInBinaryForm = true;

        size = sizeof (old_port_rules);
        status = RegQueryValueEx (key, CVY_NAME_OLD_PORT_RULES, 0L, & type,
                                  (LPBYTE) old_port_rules, & size);

        if (status != ERROR_SUCCESS  ||
            size % sizeof (WLBS_OLD_PORT_RULE) != 0 ||
            paramp -> i_num_rules != size / sizeof (WLBS_OLD_PORT_RULE))
        {
            ZeroMemory(paramp -> i_port_rules, sizeof(paramp -> i_port_rules));
            paramp -> i_num_rules = 0;
            TRACE_CRIT("%!FUNC! registry read for %ls failed. Skipping all rules", CVY_NAME_OLD_PORT_RULES);
        }
        else // Convert the port rules to new format
        {
            if (paramp -> i_parms_ver > 3) 
            {
                TransformOldPortRulesToNew(old_port_rules, paramp -> i_port_rules, paramp -> i_num_rules);
                TRACE_INFO("%!FUNC! transforming binary port rules to current format");
            }
            else
            {
                TRACE_INFO("%!FUNC! no op on port rules because version is <= 3");
            }
        }
    }
    else // Port Rules in Textual Format
    {
        TRACE_INFO("%!FUNC! port rules are in textual form");

        DWORD idx = 1, num_rules = paramp -> i_num_rules, correct_rules = 0;
        WLBS_PORT_RULE *port_rule;

        if (pfPortRulesInBinaryForm) 
            *pfPortRulesInBinaryForm = false;

        port_rule = paramp -> i_port_rules;

        while(idx <= num_rules)
        {
            HKEY rule_key;
            wchar_t idx_str[8];
            // Open the per port-rule key "1", "2", "3", ...etc
            if ((status = RegOpenKeyEx (subkey, _itow(idx, idx_str, 10), 0L, KEY_QUERY_VALUE, & rule_key)) != ERROR_SUCCESS)
            {
                idx++;
                TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Skipping rule", idx_str, status);
                continue;
            }

            size = sizeof (port_rule -> virtual_ip_addr);
            status = RegQueryValueEx (rule_key, CVY_NAME_VIP, 0L, & type, (LPBYTE) &port_rule->virtual_ip_addr, & size);
            if (status != ERROR_SUCCESS)
            {
                TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Skipping rule", CVY_NAME_VIP, status);
                status = RegCloseKey (rule_key);
                if (status != ERROR_SUCCESS)
                {
                    TRACE_CRIT("%!FUNC! close registry for port rule %ls failed with %d",_itow(idx, idx_str, 10), status);
                }
                idx++;
                continue;
            }

            size = sizeof (port_rule ->start_port );
            status = RegQueryValueEx (rule_key, CVY_NAME_START_PORT, 0L, & type, (LPBYTE) &port_rule->start_port, & size);
            if (status != ERROR_SUCCESS)
            {
                TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Skipping rule", CVY_NAME_START_PORT, status);
                status = RegCloseKey (rule_key);
                if (status != ERROR_SUCCESS)
                {
                    TRACE_CRIT("%!FUNC! close registry for port rule %ls failed with %d",_itow(idx, idx_str, 10), status);
                }
                idx++;
                continue;
            }

            size = sizeof (port_rule ->end_port );
            status = RegQueryValueEx (rule_key, CVY_NAME_END_PORT, 0L, & type, (LPBYTE) &port_rule->end_port, & size);
            if (status != ERROR_SUCCESS)
            {
                TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Skipping rule", CVY_NAME_END_PORT, status);
                status = RegCloseKey (rule_key);
                if (status != ERROR_SUCCESS)
                {
                    TRACE_CRIT("%!FUNC! close registry for port rule %ls failed with %d",_itow(idx, idx_str, 10), status);
                }
                idx++;
                continue;
            }

            size = sizeof (port_rule ->code);
            status = RegQueryValueEx (rule_key, CVY_NAME_CODE, 0L, & type, (LPBYTE) &port_rule->code, & size);
            if (status != ERROR_SUCCESS)
            {
                TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Skipping rule", CVY_NAME_CODE, status);
                status = RegCloseKey (rule_key);
                if (status != ERROR_SUCCESS)
                {
                    TRACE_CRIT("%!FUNC! close registry for port rule %ls failed with %d",_itow(idx, idx_str, 10), status);
                }
                idx++;
                continue;
            }

            size = sizeof (port_rule->mode);
            status = RegQueryValueEx (rule_key, CVY_NAME_MODE, 0L, & type, (LPBYTE) &port_rule->mode, & size);
            if (status != ERROR_SUCCESS)
            {
                TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Skipping rule", CVY_NAME_MODE, status);
                status = RegCloseKey (rule_key);
                if (status != ERROR_SUCCESS)
                {
                    TRACE_CRIT("%!FUNC! close registry for port rule %ls failed with %d",_itow(idx, idx_str, 10), status);
                }
                idx++;
                continue;
            }

            size = sizeof (port_rule->protocol);
            status = RegQueryValueEx (rule_key, CVY_NAME_PROTOCOL, 0L, & type, (LPBYTE) &port_rule->protocol, & size);
            if (status != ERROR_SUCCESS)
            {
                TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Skipping rule", CVY_NAME_PROTOCOL, status);
                status = RegCloseKey (rule_key);
                if (status != ERROR_SUCCESS)
                {
                    TRACE_CRIT("%!FUNC! close registry for port rule %ls failed with %d",_itow(idx, idx_str, 10), status);
                }
                idx++;
                continue;
            }

            port_rule->valid = true;

            DWORD EqualLoad, Affinity;

            switch (port_rule->mode) 
            {
            case CVY_MULTI :
                 size = sizeof (EqualLoad);
                 status = RegQueryValueEx (rule_key, CVY_NAME_EQUAL_LOAD, 0L, & type, (LPBYTE) &EqualLoad, & size);
                 if (status != ERROR_SUCCESS)
                 {
                     TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Skipping rule", CVY_NAME_EQUAL_LOAD, status);
                     status = RegCloseKey (rule_key);
                     if (status != ERROR_SUCCESS)
                     {
                         TRACE_CRIT("%!FUNC! close registry for port rule %ls failed with %d",_itow(idx, idx_str, 10), status);
                     }
                     idx++;
                     continue;
                 }
                 else
                 {
                     port_rule->mode_data.multi.equal_load = (WORD) EqualLoad;
                     TRACE_INFO("%!FUNC! registry read successful for %ls. Using equal load.", CVY_NAME_EQUAL_LOAD);
                 }

                 size = sizeof (Affinity);
                 status = RegQueryValueEx (rule_key, CVY_NAME_AFFINITY, 0L, & type, (LPBYTE) &Affinity, & size);
                 if (status != ERROR_SUCCESS)
                 {
                     TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Skipping rule", CVY_NAME_AFFINITY, status);
                     status = RegCloseKey (rule_key);
                     if (status != ERROR_SUCCESS)
                     {
                         TRACE_CRIT("%!FUNC! close registry for port rule %ls failed with %d",_itow(idx, idx_str, 10), status);
                     }
                     idx++;
                     continue;
                 }
                 else
                 {
                     port_rule->mode_data.multi.affinity = (WORD) Affinity;
                     TRACE_INFO("%!FUNC! registry read successful for %ls. Using affinity %d", CVY_NAME_AFFINITY, port_rule->mode_data.multi.affinity);
                 }

                 size = sizeof (port_rule->mode_data.multi.load);
                 status = RegQueryValueEx (rule_key, CVY_NAME_LOAD, 0L, & type, (LPBYTE) &(port_rule->mode_data.multi.load), & size);
                 if (status != ERROR_SUCCESS)
                 {
                     TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Skipping rule", CVY_NAME_LOAD, status);
                     status = RegCloseKey (rule_key);
                     if (status != ERROR_SUCCESS)
                     {
                         TRACE_CRIT("%!FUNC! close registry for port rule %ls failed with %d",_itow(idx, idx_str, 10), status);
                     }
                     idx++;
                     continue;
                 }
                 break;

            case CVY_SINGLE :
                 size = sizeof (port_rule->mode_data.single.priority);
                 status = RegQueryValueEx (rule_key, CVY_NAME_PRIORITY, 0L, & type, (LPBYTE) &(port_rule->mode_data.single.priority), & size);
                 if (status != ERROR_SUCCESS)
                 {
                     TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Skipping rule", CVY_NAME_PRIORITY, status);
                     status = RegCloseKey (rule_key);
                     if (status != ERROR_SUCCESS)
                     {
                         TRACE_CRIT("%!FUNC! close registry for port rule %ls failed with %d",_itow(idx, idx_str, 10), status);
                     }
                     idx++;
                     continue;
                 }
                 break;

            default:
                 break;
            }

            // Close the per port rule key, ie. "1", "2", ...etc
            status = RegCloseKey (rule_key);
            if (status != ERROR_SUCCESS)
            {
                TRACE_CRIT("%!FUNC! close registry for port rule %ls failed with %d",_itow(idx, idx_str, 10), status);
            }

            port_rule++;
            idx++;
            correct_rules++;
        }

        // Discard those rules on which we encountered some error
        if (paramp->i_num_rules != correct_rules) 
        {
            paramp -> i_num_rules = correct_rules;
            TRACE_INFO("%!FUNC! discarding rules for which errors were encountered");
        }

        // Close the "Port Rules" key
        status = RegCloseKey (subkey);
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! close registry for %ls failed with %d", CVY_NAME_PORT_RULES, status);
        }
    }

    size = sizeof (paramp -> i_license_key);
    status = RegQueryValueEx (key, CVY_NAME_LICENSE_KEY, 0L, & type,
                              (LPBYTE) paramp -> i_license_key, & size);

    if (status != ERROR_SUCCESS)
    {
        hresult = StringCbCopy (paramp -> i_license_key, sizeof(paramp -> i_license_key), CVY_DEF_LICENSE_KEY);
        if (FAILED(hresult)) 
        {
            TRACE_CRIT("%!FUNC! StringCbCopy failed, Error code : 0x%x", HRESULT_CODE(hresult)); 
        }
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %ls", CVY_NAME_LICENSE_KEY, status, CVY_DEF_LICENSE_KEY);
    }

    size = sizeof (paramp -> i_rmt_password);
    status = RegQueryValueEx (key, CVY_NAME_RMT_PASSWORD, 0L, & type,
                              (LPBYTE) & paramp -> i_rmt_password, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_rmt_password = CVY_DEF_RMT_PASSWORD;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using default rmt password", CVY_NAME_RMT_PASSWORD, status);
    }


    size = sizeof (paramp -> i_rct_password);
    status = RegQueryValueEx (key, CVY_NAME_RCT_PASSWORD, 0L, & type,
                              (LPBYTE) & paramp -> i_rct_password, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> i_rct_password = CVY_DEF_RCT_PASSWORD;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using default rct password", CVY_NAME_RCT_PASSWORD, status);
    }


    size = sizeof (paramp -> rct_port);
    status = RegQueryValueEx (key, CVY_NAME_RCT_PORT, 0L, & type,
                              (LPBYTE) & paramp -> rct_port, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> rct_port = CVY_DEF_RCT_PORT;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_RCT_PORT, status, paramp -> rct_port);
    }


    size = sizeof (paramp -> rct_enabled);
    status = RegQueryValueEx (key, CVY_NAME_RCT_ENABLED, 0L, & type,
                              (LPBYTE) & paramp -> rct_enabled, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> rct_enabled = CVY_DEF_RCT_ENABLED;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_RCT_ENABLED, status, paramp -> rct_enabled);
    }

    size = sizeof (paramp -> identity_period);
    status = RegQueryValueEx (key, CVY_NAME_ID_HB_PERIOD, 0L, & type,
                              (LPBYTE) & paramp -> identity_period, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> identity_period = CVY_DEF_ID_HB_PERIOD;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_ID_HB_PERIOD, status, paramp -> identity_period);
    }

    size = sizeof (paramp -> identity_enabled);
    status = RegQueryValueEx (key, CVY_NAME_ID_HB_ENABLED, 0L, & type,
                              (LPBYTE) & paramp -> identity_enabled, & size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> identity_enabled = CVY_DEF_ID_HB_ENABLED;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_ID_HB_ENABLED, status, paramp -> identity_enabled);
    }

    //
    // IGMP support registry entries
    //
    size = sizeof (paramp->fIGMPSupport);
    status = RegQueryValueEx (key, CVY_NAME_IGMP_SUPPORT, 0L, NULL,
                              (LPBYTE) & paramp->fIGMPSupport, &size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> fIGMPSupport = CVY_DEF_IGMP_SUPPORT;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. igmp support will be disabled", CVY_NAME_IGMP_SUPPORT, status);
    }
    
    size = sizeof (paramp->szMCastIpAddress);
    status = RegQueryValueEx (key, CVY_NAME_MCAST_IP_ADDR, 0L, NULL,
                              (LPBYTE) & paramp->szMCastIpAddress, &size);

    if (status != ERROR_SUCCESS)
    {
        hresult = StringCbCopy(paramp -> szMCastIpAddress, sizeof(paramp -> szMCastIpAddress), CVY_DEF_MCAST_IP_ADDR);
        if (SUCCEEDED(hresult))
        {
            TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %ls", CVY_NAME_MCAST_IP_ADDR, status, paramp -> szMCastIpAddress);
        }
        else
        {
            TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Initializing with default also failed, Error code : 0x%x", CVY_NAME_MCAST_IP_ADDR, status, HRESULT_CODE(hresult));
        }
    }
    
    size = sizeof (paramp->fIpToMCastIp);
    status = RegQueryValueEx (key, CVY_NAME_IP_TO_MCASTIP, 0L, NULL,
                              (LPBYTE) & paramp->fIpToMCastIp, &size);

    if (status != ERROR_SUCCESS)
    {
        paramp -> fIpToMCastIp = CVY_DEF_IP_TO_MCASTIP;
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. ip to multicast flag will be set to true", CVY_NAME_IP_TO_MCASTIP, status);
    }

    /* Attempt to open the BDA teaming settings.  They may not be there, 
       so if they aren't, move on; otherwise, extract the settings. */
    if ((bda_key = RegOpenWlbsBDASettings(AdapterGuid, true))) {
        GUID TeamGuid;
        HRESULT hr;

        /* If the key exists, we are part of a team. */
        paramp->bda_teaming.active = TRUE;
        
        /* Find out if we are the master of this team. */
        size = sizeof (paramp->bda_teaming.master);
        status = RegQueryValueEx (bda_key, CVY_NAME_BDA_MASTER, 0L, NULL,
                                  (LPBYTE)&paramp->bda_teaming.master, &size);
        
        /* If we can't get that information, default to a slave. */
        if (status != ERROR_SUCCESS)
        {
            paramp->bda_teaming.master = FALSE;
            TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. teaming master will be set to false", CVY_NAME_BDA_MASTER, status);
        }

        /* Find out if we are reverse hashing or not. */
        size = sizeof (paramp->bda_teaming.reverse_hash);
        status = RegQueryValueEx (bda_key, CVY_NAME_BDA_REVERSE_HASH, 0L, NULL,
                                  (LPBYTE)&paramp->bda_teaming.reverse_hash, &size);
        
        /* If that fails, then assume normal hashing. */
        if (status != ERROR_SUCCESS)
        {
            paramp->bda_teaming.reverse_hash = FALSE;
            TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. teaming master will be set to false", CVY_NAME_BDA_REVERSE_HASH, status);
        }

        /* Get our team ID - this should be a GUID, be we don't enforce that. */
        size = sizeof (paramp->bda_teaming.team_id);
        status = RegQueryValueEx (bda_key, CVY_NAME_BDA_TEAM_ID, 0L, NULL,
                                  (LPBYTE)&paramp->bda_teaming.team_id, &size);
        
        /* The team is absolutely required - if we can't get it, then don't join the team. */
        if (status != ERROR_SUCCESS)
        {
            paramp->bda_teaming.active = CVY_DEF_BDA_ACTIVE;
            TRACE_CRIT("%!FUNC! registry read for %ls failed with %d. Using %d", CVY_NAME_BDA_TEAM_ID, status, paramp->bda_teaming.active);
        }

        /* Attempt to convert the string to a GUID and check for errors. */
        hr = CLSIDFromString(paramp->bda_teaming.team_id, &TeamGuid);

        /* If the conversion fails, bail out - the team ID must not have been a GUID. */
        if (hr != NOERROR) {
            paramp->bda_teaming.active = CVY_DEF_BDA_ACTIVE;
            TRACE_CRIT("%!FUNC! Invalid BDA Team ID: %ls. Setting bda teaming active flag to %d", paramp->bda_teaming.team_id, paramp->bda_teaming.active);
        }
  
        status = RegCloseKey(bda_key);
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! close bda registry key failed with %d", status);
        }
    }

    /* decode port rules prior to version 3 */

    if (paramp -> i_parms_ver <= 3)
    {
        TRACE_INFO("%!FUNC! port rule is version %d", paramp -> i_parms_ver);
        paramp -> i_parms_ver = CVY_PARAMS_VERSION;

        /* decode the port rules */

        if (! License_data_decode ((PCHAR) old_port_rules, paramp -> i_num_rules * sizeof (WLBS_OLD_PORT_RULE))) 
        {
            ZeroMemory(paramp -> i_port_rules, sizeof(paramp -> i_port_rules));
            paramp -> i_num_rules = 0;
            TRACE_CRIT("%!FUNC! port rule decode failed. Skipping rules");
        }
        else
        {
            TransformOldPortRulesToNew(old_port_rules, paramp -> i_port_rules, paramp -> i_num_rules);
            TRACE_INFO("%!FUNC! port rules transformed to current format");
        }

    }

    /* upgrade port rules from params V1 to params V2 */

    if (paramp -> i_parms_ver == 1)
    {
        TRACE_INFO("%!FUNC! upgrading version 1 port rule");
        paramp -> i_parms_ver = CVY_PARAMS_VERSION;

        /* keep multicast off by default for old users */

        paramp -> mcast_support = FALSE;

        for (i = 0; i < paramp -> i_num_rules; i ++)
        {
            rp = paramp -> i_port_rules + i;

            code = CVY_RULE_CODE_GET (rp);

            CVY_RULE_CODE_SET (rp);

            if (code != CVY_RULE_CODE_GET (rp))
            {
                rp -> code = code;
                continue;
            }

            if (! rp -> valid)
             {
                TRACE_INFO("%!FUNC! port rule is invalid. Skip it.");
                continue;
            }

            /* set affinity according to current ScaleSingleClient setting */

            if (rp -> mode == CVY_MULTI)
                rp -> mode_data . multi . affinity = CVY_AFFINITY_SINGLE - (USHORT)paramp -> i_scale_client;

            CVY_RULE_CODE_SET (rp);
        }
    }

    /* upgrade max number of descriptor allocs */

    if (paramp -> i_parms_ver == 2)
    {
        TRACE_INFO("%!FUNC! upgrading properties for version 2");
        paramp -> i_parms_ver = CVY_PARAMS_VERSION;
        paramp -> max_dscr_allocs = CVY_DEF_MAX_DSCR_ALLOCS;
        paramp -> dscr_per_alloc  = CVY_DEF_DSCR_PER_ALLOC;
    }

    status = RegCloseKey (key);
    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! close registry key failed with %d", status);
    }

    paramp -> i_max_hosts        = CVY_MAX_HOSTS;
    paramp -> i_max_rules        = CVY_MAX_USABLE_RULES;
//    paramp -> i_ft_rules_enabled = TRUE;
//    paramp -> version          = 0;

//  CLEAN_64BIT    CVY_CHECK_MIN (paramp -> i_num_rules, CVY_MIN_NUM_RULES);
    CVY_CHECK_MAX (paramp -> i_num_rules, CVY_MAX_NUM_RULES);
    CVY_CHECK_MIN (paramp -> host_priority, CVY_MIN_HOST_PRIORITY);
    CVY_CHECK_MAX (paramp -> host_priority, CVY_MAX_HOST_PRIORITY);

    TRACE_VERB("<-%!FUNC! return true");
    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  WlbsValidateParams
//
// Description:  Validates the cluster parameters. Also munges some fields
//               such as IP addresses to make them canonocal.
//
// Arguments:  PWLBS_REG_PARAMS paramp - 
//
// Returns:   bool - TRUE if params are valid, false otherwise
//
// History:   josephj Created 4/25/01 based on code from ParamWriteReg.
//            karthicn Edited 8/31/01 renamed from ParamValidate to WlbsValidateParams
//
//+----------------------------------------------------------------------------
BOOL WINAPI WlbsValidateParams(const PWLBS_REG_PARAMS paramp)
{
    TRACE_VERB("->%!FUNC!");

    bool fRet = FALSE;
    DWORD   idx;
    IN_ADDR dwIPAddr;
    CHAR *  szIPAddr;
    DWORD   num_rules;
    WLBS_PORT_RULE *port_rule;

    /* verify and if necessary reset the parameters */

    //
    // We don't validate the lower bound for unsigned words when the lower bound is 0. Otherwise we
    // get a compiler warning, promoted to an error, because such a test can't fail
    //
    // Ignore lower bound checking
    //
    CVY_CHECK_MAX (paramp -> i_scale_client, CVY_MAX_SCALE_CLIENT);

    CVY_CHECK_MAX (paramp -> i_nbt_support, CVY_MAX_NBT_SUPPORT);

    CVY_CHECK_MAX (paramp -> mcast_support, CVY_MAX_MCAST_SUPPORT);

    CVY_CHECK_MAX (paramp -> i_mcast_spoof, CVY_MAX_MCAST_SPOOF);

    CVY_CHECK_MAX (paramp -> mask_src_mac, CVY_MAX_MASK_SRC_MAC);

    CVY_CHECK_MAX (paramp -> i_netmon_alive, CVY_MAX_NETMON_ALIVE);

    CVY_CHECK_MAX (paramp -> i_convert_mac, CVY_MAX_CONVERT_MAC);

    CVY_CHECK_MAX (paramp -> rct_port, CVY_MAX_RCT_PORT);

    CVY_CHECK_MAX (paramp -> rct_enabled, CVY_MAX_RCT_ENABLED);

    CVY_CHECK_MAX (paramp -> i_cleanup_delay, CVY_MAX_CLEANUP_DELAY);

    CVY_CHECK_MAX (paramp -> i_ip_chg_delay, CVY_MAX_IP_CHG_DELAY);

    CVY_CHECK_MAX (paramp -> i_num_rules, CVY_MAX_NUM_RULES);

    CVY_CHECK_MAX (paramp -> cluster_mode, CVY_MAX_CLUSTER_MODE);

    CVY_CHECK_MAX (paramp -> tcp_dscr_timeout, CVY_MAX_TCP_TIMEOUT);

    CVY_CHECK_MAX (paramp -> ipsec_dscr_timeout, CVY_MAX_IPSEC_TIMEOUT);

    CVY_CHECK_MAX (paramp -> filter_icmp, CVY_MAX_FILTER_ICMP);

    CVY_CHECK_MAX (paramp -> identity_enabled, CVY_MAX_ID_HB_ENABLED);
    //
    // End Ignore lower bound checking
    //

    //
    // CVY_NAME_VERSION is not validated since its value is used and manipulated before we get here
    // CVY_NAME_LICENSE_KEY is not validated since it can take any value.
    // RMT_PASSWORD is not validated since it can take any storable value
    // RCT_PASSWORD is not validated since it can take any storable value
    // CVY_NAME_IGMP_SUPPORT is not validated because it is of BOOL type and can thus take any value
    // CVY_NAME_IP_TO_MCASTIP is not validated because it is of BOOL type and can thus take any value
    // 

    CVY_CHECK_MIN (paramp -> alive_period, CVY_MIN_ALIVE_PERIOD);
    CVY_CHECK_MAX (paramp -> alive_period, CVY_MAX_ALIVE_PERIOD);

    CVY_CHECK_MIN (paramp -> alive_tolerance, CVY_MIN_ALIVE_TOLER);
    CVY_CHECK_MAX (paramp -> alive_tolerance, CVY_MAX_ALIVE_TOLER);

    CVY_CHECK_MIN (paramp -> num_actions, CVY_MIN_NUM_ACTIONS);
    CVY_CHECK_MAX (paramp -> num_actions, CVY_MAX_NUM_ACTIONS);

    CVY_CHECK_MIN (paramp -> num_packets, CVY_MIN_NUM_PACKETS);
    CVY_CHECK_MAX (paramp -> num_packets, CVY_MAX_NUM_PACKETS);

    CVY_CHECK_MIN (paramp -> dscr_per_alloc, CVY_MIN_DSCR_PER_ALLOC);
    CVY_CHECK_MAX (paramp -> dscr_per_alloc, CVY_MAX_DSCR_PER_ALLOC);

    CVY_CHECK_MIN (paramp -> max_dscr_allocs, CVY_MIN_MAX_DSCR_ALLOCS);
    CVY_CHECK_MAX (paramp -> max_dscr_allocs, CVY_MAX_MAX_DSCR_ALLOCS);

    CVY_CHECK_MIN (paramp -> num_send_msgs, (paramp -> i_max_hosts + 1) * 2);
    CVY_CHECK_MAX (paramp -> num_send_msgs, (paramp -> i_max_hosts + 1) * 10);

    CVY_CHECK_MIN (paramp -> host_priority, CVY_MIN_HOST_PRIORITY);
    CVY_CHECK_MAX (paramp -> host_priority, CVY_MAX_HOST_PRIORITY);

    CVY_CHECK_MIN (paramp -> identity_period, CVY_MIN_ID_HB_PERIOD);
    CVY_CHECK_MAX (paramp -> identity_period, CVY_MAX_ID_HB_PERIOD);

    /* If the cluster IP address is not 0.0.0.0, then make sure the IP address is valid. */
    if (lstrcmpi(paramp->cl_ip_addr, CVY_DEF_CL_IP_ADDR)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->cl_ip_addr)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->cl_ip_addr, WLBS_MAX_CL_IP_ADDR + 1))
            goto error;
    }

    /* If the cluster netmask is not 0.0.0.0, then make sure the netmask is valid. */
    if (lstrcmpi(paramp->cl_net_mask, CVY_DEF_CL_NET_MASK)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->cl_net_mask)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->cl_net_mask, WLBS_MAX_CL_NET_MASK + 1))
            goto error;
    }

    /* If the dedicated IP address is not 0.0.0.0, then make sure the IP address is valid. */
    if (lstrcmpi(paramp->ded_ip_addr, CVY_DEF_DED_IP_ADDR)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->ded_ip_addr)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->ded_ip_addr, WLBS_MAX_DED_IP_ADDR + 1))
            goto error;
    }

    /* If the dedicated netmask is not 0.0.0.0, then make sure the netmask is valid. */
    if (lstrcmpi(paramp->ded_net_mask, CVY_DEF_DED_NET_MASK)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->ded_net_mask)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->ded_net_mask, WLBS_MAX_DED_NET_MASK + 1))
            goto error;
    }

    /* Verify that the port rule VIP is valid, 
       Also, convert the port rule VIPs that might be in the x.x.x or x.x or x form to x.x.x.x */
    idx = 0;
    num_rules = paramp -> i_num_rules;
    while (idx < num_rules) 
    {
        port_rule = &paramp->i_port_rules[idx];

        /* Check if the port rule is valid and the vip is not "All Vip" */
        if (port_rule->valid && lstrcmpi(port_rule->virtual_ip_addr, CVY_DEF_ALL_VIP)) 
        {
            /* Get IP Address into DWORD form */
            if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(port_rule->virtual_ip_addr)))
                goto error;

            /* Check for validity of IP Address */
            if ((dwIPAddr.S_un.S_un_b.s_b1 < WLBS_IP_FIELD_ZERO_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b1 > WLBS_IP_FIELD_ZERO_HIGH) 
             || (dwIPAddr.S_un.S_un_b.s_b2 < WLBS_FIELD_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b2 > WLBS_FIELD_HIGH) 
             || (dwIPAddr.S_un.S_un_b.s_b3 < WLBS_FIELD_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b3 > WLBS_FIELD_HIGH) 
             || (dwIPAddr.S_un.S_un_b.s_b4 < WLBS_FIELD_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b4 > WLBS_FIELD_HIGH)) 
                goto error;

            /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
               address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
               the IP address string (which is used by other parts of NLB, such as the UI)
               consistent, we convert back to a string. */
            if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
                goto error;

            /* Convert the ASCII string to unicode. */
            if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, port_rule->virtual_ip_addr, WLBS_MAX_CL_IP_ADDR + 1))
                goto error;
        }
        idx++;
    }

    /* If either the cluster IP address or the cluster netmask is not 0.0.0.0,
       then make sure the they are a valid IP address/netmask pair. */
    if (lstrcmpi(paramp->cl_ip_addr, CVY_DEF_CL_IP_ADDR) || lstrcmpi(paramp->cl_net_mask, CVY_DEF_CL_NET_MASK)) {
        /* If they have specified a cluster IP address, but no netmask, then fill it in for them. */
        if (!lstrcmpi(paramp->cl_net_mask, CVY_DEF_CL_NET_MASK))
        {
            ParamsGenerateSubnetMask(paramp->cl_ip_addr, paramp->cl_net_mask, ASIZECCH(paramp->cl_net_mask));
        }

        /* Check for valid cluster IP address/netmask pairs. */
        if (!IsValidIPAddressSubnetMaskPair(paramp->cl_ip_addr, paramp->cl_net_mask))
            goto error;
        
        /* Check to make sure that the cluster netmask is contiguous. */
        if (!IsContiguousSubnetMask(paramp->cl_net_mask))
            goto error;

        /* Check to make sure that the dedicated IP and cluster IP are not the same. */
        if (!wcscmp(paramp->ded_ip_addr, paramp->cl_ip_addr))
            goto error;
    }

    /* If either the dedicated IP address or the dedicated netmask is not 0.0.0.0,
       then make sure the they are a valid IP address/netmask pair. */
    if (lstrcmpi(paramp->ded_ip_addr, CVY_DEF_DED_IP_ADDR) || lstrcmpi(paramp->ded_net_mask, CVY_DEF_DED_NET_MASK)) {
        /* If they have specified a cluster IP address, but no netmask, then fill it in for them. */
        if (!lstrcmpi(paramp->ded_net_mask, CVY_DEF_DED_NET_MASK))
        {
            ParamsGenerateSubnetMask(paramp->ded_ip_addr, paramp->ded_net_mask, ASIZECCH(paramp->ded_net_mask));
        }

        /* Check for valid dedicated IP address/netmask pairs. */
        if (!IsValidIPAddressSubnetMaskPair(paramp->ded_ip_addr, paramp->ded_net_mask))
            goto error;
        
        /* Check to make sure that the dedicated netmask is contiguous. */
        if (!IsContiguousSubnetMask(paramp->ded_net_mask))
            goto error;
    }

    /* Check the mac address if the convert_mac flag is not set */
    if ( ! paramp -> i_convert_mac)
    {
        PWCHAR p1, p2;
        WCHAR mac_addr [WLBS_MAX_NETWORK_ADDR + 1];
        DWORD i, j;
        BOOL flag = TRUE;
        HRESULT hresult;

        hresult = StringCbCopy (mac_addr, sizeof(mac_addr), paramp -> cl_mac_addr);
        if (FAILED(hresult)) 
            goto error;

        p2 = p1 = mac_addr;

        for (i = 0 ; i < 6 ; i++)
        {
            if (*p2 == _TEXT('\0'))
            {
                flag = FALSE;
                break;
            }

            j = _tcstoul (p1, &p2, 16);

            if ( j > 255)
            {
                flag = FALSE;
                break;
            }

            if ( ! (*p2 == _TEXT('-') || *p2 == _TEXT(':') || *p2 == _TEXT('\0')) )
            {
                flag = FALSE;
                break;
            }

            if (*p2 == _TEXT('\0') && i < 5)
            {
                flag = FALSE;
                break;
            }

            p1 = p2 + 1;
            p2 = p1;

        }


        if (!flag)
        {
            goto error;
        }
    }

    if (paramp->fIGMPSupport && !paramp->mcast_support)
    {
        //
        // IGMP can not be enabled in unicast mode
        //
        TRACE_CRIT("%!FUNC! IGMP can not be enabled in unicast mode");

        goto error;
    }

    if (paramp->mcast_support && paramp->fIGMPSupport && !paramp->fIpToMCastIp)
    {
        //
        // Verify that the multicast IP is a valid IP form. Ignore default value case since it isn't a valid IP.
        // 
        if (lstrcmpi(paramp -> szMCastIpAddress, CVY_DEF_MCAST_IP_ADDR)) {
            /* Check the validity of the IP address. */
            if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp -> szMCastIpAddress)))
                goto error;
        
            /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
               address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
               the IP address string (which is used by other parts of NLB, such as the UI)
               consistent, we convert back to a string. */
            if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
                goto error;

            /* Convert the ASCII string to unicode. */
            if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp -> szMCastIpAddress, WLBS_MAX_CL_IP_ADDR + 1))
                goto error;
        }

        //
        // Multicast mode with IGMP enabled, and user specified an multicast IP address,
        // The multicast IP address should be in the range of (224-239).x.x.x 
        //       but NOT (224-239).0.0.x or (224-239).128.0.x. 
        //

        DWORD dwMCastIp = IpAddressFromAbcdWsz(paramp->szMCastIpAddress);

        if ((dwMCastIp & 0xf0) != 0xe0 ||
            (dwMCastIp & 0x00ffff00) == 0 || 
            (dwMCastIp & 0x00ffff00) == 0x00008000)
        {
            TRACE_CRIT("%!FUNC! invalid szMCastIpAddress %ws", paramp->szMCastIpAddress);
            goto error;
        }
    }

    /* Generate the MAC address. */
    ParamsGenerateMAC(paramp->cl_ip_addr, paramp->cl_mac_addr, ASIZECCH(paramp->cl_mac_addr), paramp->szMCastIpAddress, ASIZECCH(paramp->szMCastIpAddress), paramp->i_convert_mac, 
                      paramp->mcast_support, paramp->fIGMPSupport, paramp->fIpToMCastIp);

    //
    // We only process bda information if bda teaming is active. We can ignore these properties if it isn't. Dependencies
    // such as WriteRegParam will check this too to see if they should process the information.
    //
    if (paramp -> bda_teaming . active) {
        GUID TeamGuid;
        HRESULT hr;

        //
        // We don't validate the lower bound for unsigned words when the lower bound is 0. Otherwise we
        // get a compiler warning, promoted to an error, because such a test can't fail
        //
        // Ignore lower bound checking
        //
        CVY_CHECK_MAX (paramp -> bda_teaming . master, 1);

        CVY_CHECK_MAX (paramp -> bda_teaming . reverse_hash, 1);
        //
        // End Ignore lower bound checking
        //

        //
        // A teaming ID must be a GUID. Validate that it is, but we don't care what value. This means we ignore
        // the content of TeamGuid.
        //
        hr = CLSIDFromString(paramp -> bda_teaming . team_id, &TeamGuid);

        // If the conversion fails, bail out - the team ID must not have been a GUID
        if (hr != NOERROR) {
            TRACE_CRIT("%!FUNC! invalid BDA Team ID: %ls", paramp->bda_teaming.team_id);
            goto error;
        }
    }    
    
    fRet = TRUE;
    goto end;
    
error:
    fRet = FALSE;
    goto end;

end:
    TRACE_VERB("<-%!FUNC! return %d", fRet);
    return fRet;
}

//+----------------------------------------------------------------------------
//
// Function:  WlbsWriteAndCommitChanges
//
// Description:  Write cluster settings to registry, Commits the changes to NLB driver
//
// Arguments: Adapter GUID, Handle to NLB driver, New registry parameters
//
// Returns:   DWORD - 
//
// History:   KarthicN Created 8/28/01
//
//+----------------------------------------------------------------------------

DWORD WINAPI WlbsWriteAndCommitChanges(HANDLE           NlbHdl,
                                       const GUID *     pAdapterGuid,
                                       WLBS_REG_PARAMS* p_new_reg_params)
{
    TRACE_VERB("->%!FUNC!");
    DWORD           Status;
    WLBS_REG_PARAMS cur_reg_params;
    bool            reload_required;
    bool            notify_adapter_required;

    // Read NLB registry paramters for passing it into ParamWriteConfig
    if (ParamReadReg(*pAdapterGuid, &cur_reg_params) == false)
    {
        TRACE_VERB("<-%!FUNC! return %d", WLBS_REG_ERROR);
        return WLBS_REG_ERROR;
    }

    reload_required = false;
    notify_adapter_required = false;

    // Write NLB registry parameters
    Status = ParamWriteConfig(*pAdapterGuid,
                       p_new_reg_params, 
                       &cur_reg_params, 
                       &reload_required, 
                       &notify_adapter_required);
    if (Status != WLBS_OK) 
    {
        TRACE_VERB("<-%!FUNC! return %d", Status);
        return Status;
    }

    // If reload_required flag is set, commit changes
    if (reload_required) 
    {
        DWORD cl_addr, ded_addr;

        Status = ParamCommitChanges(*pAdapterGuid, 
                                    NlbHdl, 
                                    cl_addr, 
                                    ded_addr, 
                                    &reload_required,
                                    &notify_adapter_required);
        if (Status != WLBS_OK) 
        {
            TRACE_VERB("<-%!FUNC! return %d", Status);
            return Status;
        }
    }

    TRACE_VERB("<-%!FUNC! return %d", Status);
    return Status;
}

//+----------------------------------------------------------------------------
//
// Function:  ParamWriteConfig
//
// Description:  Write cluster settings to registry
//
// Arguments: Adapter GUID, New registry parameters, Old registry parameters,
//            Reload_required flag, Notify_adapter_required flag
//
// Returns:   DWORD - 
//
// History:   KarthicN Created 8/28/01
//            12/2/01 ChrisDar Modified to change the adapter notification conditions.
//                             Was for mac change only; added for cluster IP change too.
//
//+----------------------------------------------------------------------------

DWORD ParamWriteConfig(const GUID&      AdapterGuid,
                       WLBS_REG_PARAMS* new_reg_params, 
                       WLBS_REG_PARAMS* old_reg_params, 
                       bool *           p_reload_required, 
                       bool *           p_notify_adapter_required)
{
    TRACE_VERB("->%!FUNC!");

    if (memcmp (old_reg_params, new_reg_params, sizeof (WLBS_REG_PARAMS)) == 0)
    {
        //
        // No changes
        //
        TRACE_VERB("<-%!FUNC! no changes; return %d", WLBS_OK);
        return WLBS_OK;
    }

    if (ParamWriteReg(AdapterGuid, new_reg_params) == false)
    {
        TRACE_CRIT("%!FUNC! registry write for parameters failed");
        TRACE_VERB("<-%!FUNC! return %d", WLBS_REG_ERROR);
        return WLBS_REG_ERROR;
    }

    /* No errors so far, so set the global flags reload_required and reboot_required
     * depending on which fields have been changed between new_reg_params and old_params.
     */

    *p_reload_required = true;

    /* Adapter reload is required if multicast_support option is changed, or
     * if the user specifies a different mac address or cluster ip address
     */
    if (old_reg_params->mcast_support != new_reg_params->mcast_support ||
        _tcsicmp(old_reg_params->cl_mac_addr, new_reg_params->cl_mac_addr) != 0 ||
        _tcscmp(old_reg_params->cl_ip_addr, new_reg_params->cl_ip_addr) != 0) {
        *p_notify_adapter_required = true;
    
        //
        //  if new_reg_params -> mcast_support then remove mac addr, otherwise write mac addr
        //
        if (RegChangeNetworkAddress (AdapterGuid, new_reg_params->cl_mac_addr, new_reg_params->mcast_support) == false) {
            TRACE_CRIT("%!FUNC! RegChangeNetworkAddress failed");
        }
    }

    /* Write the changes to the structure old_values
     * This copying is done only after all the data has been written into the registry
     * Otherwise, the structure old_values would retain the previous values.
     */

    memcpy(old_reg_params, new_reg_params, sizeof (WLBS_REG_PARAMS));

    TRACE_VERB("<-%!FUNC! return %d", WLBS_OK);
    return WLBS_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  ParamWriteReg
//
// Description:  Write cluster settings to registry
//
// Arguments: const GUID& AdapterGuid - 
//            PWLBS_REG_PARAMS paramp - 
//
// Returns:   bool - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
bool WINAPI ParamWriteReg(const GUID& AdapterGuid, PWLBS_REG_PARAMS paramp)
{
    TRACE_VERB("->%!FUNC!");

    HKEY    bda_key = NULL;
    HKEY    key = NULL;
    DWORD   size;
    LONG    status;
    DWORD   disp, idx;
    DWORD   num_rules;
    WLBS_PORT_RULE *port_rule;
    HRESULT hresult;

    if (!WlbsValidateParams(paramp))
        goto error;

    num_rules = paramp -> i_num_rules;
    /* Generate the MAC address. */
    ParamsGenerateMAC(paramp->cl_ip_addr, paramp->cl_mac_addr, ASIZECCH(paramp->cl_mac_addr), paramp->szMCastIpAddress, ASIZECCH(paramp->szMCastIpAddress), paramp->i_convert_mac, 
                      paramp->mcast_support, paramp->fIGMPSupport, paramp->fIpToMCastIp);
    
    WCHAR reg_path [PARAMS_MAX_STRING_SIZE];

    WCHAR szAdapterGuid[128];

    if (0 == StringFromGUID2(AdapterGuid, szAdapterGuid, sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0])))
    {
        TRACE_CRIT("%!FUNC! guid is too large for string. Result is %ls", szAdapterGuid);
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }
            
    hresult = StringCbPrintf (reg_path, sizeof(reg_path), L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface\\%s",
            szAdapterGuid);
    if (FAILED(hresult)) 
    {
        TRACE_CRIT("%!FUNC! StringCbPrintf failed, Error code : 0x%x", HRESULT_CODE(hresult));
        TRACE_VERB("<-%!FUNC! return false");
        return FALSE;
    }
    
    status = RegCreateKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L, L"",
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS, NULL, & key, & disp);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! RegCreateKeyEx for %ls failed with %d", reg_path, status);
        TRACE_VERB("<-%!FUNC! return false");
        return FALSE;
    }

    size = sizeof (paramp -> install_date);
    status = RegSetValueEx (key, CVY_NAME_INSTALL_DATE, 0L, CVY_TYPE_INSTALL_DATE,
                            (LPBYTE) & paramp -> install_date, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_INSTALL_DATE, status);
        goto error;
    }

    size = sizeof (paramp -> i_verify_date);
    status = RegSetValueEx (key, CVY_NAME_VERIFY_DATE, 0L, CVY_TYPE_VERIFY_DATE,
                            (LPBYTE) & paramp -> i_verify_date, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_VERIFY_DATE, status);
        goto error;
    }

    size = wcslen (paramp -> i_virtual_nic_name) * sizeof (WCHAR);
    status = RegSetValueEx (key, CVY_NAME_VIRTUAL_NIC, 0L, CVY_TYPE_VIRTUAL_NIC,
                            (LPBYTE) paramp -> i_virtual_nic_name, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_VIRTUAL_NIC, status);
        goto error;
    }

    size = sizeof (paramp -> host_priority);
    status = RegSetValueEx (key, CVY_NAME_HOST_PRIORITY, 0L, CVY_TYPE_HOST_PRIORITY,
                            (LPBYTE) & paramp -> host_priority, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_HOST_PRIORITY, status);
        goto error;
    }

    size = sizeof (paramp -> cluster_mode);
    status = RegSetValueEx (key, CVY_NAME_CLUSTER_MODE, 0L, CVY_TYPE_CLUSTER_MODE,
                            (LPBYTE) & paramp -> cluster_mode, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_CLUSTER_MODE, status);
        goto error;
    }

    size = sizeof (paramp -> persisted_states);
    status = RegSetValueEx (key, CVY_NAME_PERSISTED_STATES, 0L, CVY_TYPE_PERSISTED_STATES,
                            (LPBYTE) & paramp -> persisted_states, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_PERSISTED_STATES, status);
        goto error;
    }

    size = wcslen (paramp -> cl_mac_addr) * sizeof (WCHAR);
    status = RegSetValueEx (key, CVY_NAME_NETWORK_ADDR, 0L, CVY_TYPE_NETWORK_ADDR,
                            (LPBYTE) paramp -> cl_mac_addr, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_NETWORK_ADDR, status);
        goto error;
    }

    size = wcslen (paramp -> cl_ip_addr) * sizeof (WCHAR);
    status = RegSetValueEx (key, CVY_NAME_CL_IP_ADDR, 0L, CVY_TYPE_CL_IP_ADDR,
                            (LPBYTE) paramp -> cl_ip_addr, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_CL_IP_ADDR, status);
        goto error;
    }

    size = wcslen (paramp -> cl_net_mask) * sizeof (WCHAR);
    status = RegSetValueEx (key, CVY_NAME_CL_NET_MASK, 0L, CVY_TYPE_CL_NET_MASK,
                            (LPBYTE) paramp -> cl_net_mask, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_CL_NET_MASK, status);
        goto error;
    }

    size = wcslen (paramp -> ded_ip_addr) * sizeof (WCHAR);
    status = RegSetValueEx (key, CVY_NAME_DED_IP_ADDR, 0L, CVY_TYPE_DED_IP_ADDR,
                            (LPBYTE) paramp -> ded_ip_addr, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_DED_IP_ADDR, status);
        goto error;
    }

    size = wcslen (paramp -> ded_net_mask) * sizeof (WCHAR);
    status = RegSetValueEx (key, CVY_NAME_DED_NET_MASK, 0L, CVY_TYPE_DED_NET_MASK,
                            (LPBYTE) paramp -> ded_net_mask, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_DED_NET_MASK, status);
        goto error;
    }

    size = wcslen (paramp -> domain_name) * sizeof (WCHAR);
    status = RegSetValueEx (key, CVY_NAME_DOMAIN_NAME, 0L, CVY_TYPE_DOMAIN_NAME,
                            (LPBYTE) paramp -> domain_name, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_DOMAIN_NAME, status);
        goto error;
    }

    size = sizeof (paramp -> alive_period);
    status = RegSetValueEx (key, CVY_NAME_ALIVE_PERIOD, 0L, CVY_TYPE_ALIVE_PERIOD,
                              (LPBYTE) & paramp -> alive_period, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_ALIVE_PERIOD, status);
        goto error;
    }

    size = sizeof (paramp -> alive_tolerance);
    status = RegSetValueEx (key, CVY_NAME_ALIVE_TOLER, 0L, CVY_TYPE_ALIVE_TOLER,
                            (LPBYTE) & paramp -> alive_tolerance, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_ALIVE_TOLER, status);
        goto error;
    }

    size = sizeof (paramp -> num_actions);
    status = RegSetValueEx (key, CVY_NAME_NUM_ACTIONS, 0L, CVY_TYPE_NUM_ACTIONS,
                            (LPBYTE) & paramp -> num_actions, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_NUM_ACTIONS, status);
        goto error;
    }

    size = sizeof (paramp -> num_packets);
    status = RegSetValueEx (key, CVY_NAME_NUM_PACKETS, 0L, CVY_TYPE_NUM_PACKETS,
                            (LPBYTE) & paramp -> num_packets, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_NUM_PACKETS, status);
        goto error;
    }

    size = sizeof (paramp -> num_send_msgs);
    status = RegSetValueEx (key, CVY_NAME_NUM_SEND_MSGS, 0L, CVY_TYPE_NUM_SEND_MSGS,
                            (LPBYTE) & paramp -> num_send_msgs, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_NUM_SEND_MSGS, status);
        goto error;
    }

    size = sizeof (paramp -> dscr_per_alloc);
    status = RegSetValueEx (key, CVY_NAME_DSCR_PER_ALLOC, 0L, CVY_TYPE_DSCR_PER_ALLOC,
                            (LPBYTE) & paramp -> dscr_per_alloc, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_DSCR_PER_ALLOC, status);
        goto error;
    }

    size = sizeof (paramp -> tcp_dscr_timeout);
    status = RegSetValueEx (key, CVY_NAME_TCP_TIMEOUT, 0L, CVY_TYPE_TCP_TIMEOUT,
                            (LPBYTE) & paramp -> tcp_dscr_timeout, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_TCP_TIMEOUT, status);
        goto error;
    }

    size = sizeof (paramp -> ipsec_dscr_timeout);
    status = RegSetValueEx (key, CVY_NAME_IPSEC_TIMEOUT, 0L, CVY_TYPE_IPSEC_TIMEOUT,
                            (LPBYTE) & paramp -> ipsec_dscr_timeout, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_IPSEC_TIMEOUT, status);
        goto error;
    }

    size = sizeof (paramp -> filter_icmp);
    status = RegSetValueEx (key, CVY_NAME_FILTER_ICMP, 0L, CVY_TYPE_FILTER_ICMP,
                            (LPBYTE) & paramp -> filter_icmp, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_FILTER_ICMP, status);
        goto error;
    }

    size = sizeof (paramp -> max_dscr_allocs);
    status = RegSetValueEx (key, CVY_NAME_MAX_DSCR_ALLOCS, 0L, CVY_TYPE_MAX_DSCR_ALLOCS,
                            (LPBYTE) & paramp -> max_dscr_allocs, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_MAX_DSCR_ALLOCS, status);
        goto error;
    }

    size = sizeof (paramp -> i_scale_client);
    status = RegSetValueEx (key, CVY_NAME_SCALE_CLIENT, 0L, CVY_TYPE_SCALE_CLIENT,
                            (LPBYTE) & paramp -> i_scale_client, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_SCALE_CLIENT, status);
        goto error;
    }

    size = sizeof (paramp -> i_cleanup_delay);
    status = RegSetValueEx (key, CVY_NAME_CLEANUP_DELAY, 0L, CVY_TYPE_CLEANUP_DELAY,
                            (LPBYTE) & paramp -> i_cleanup_delay, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_CLEANUP_DELAY, status);
        goto error;
    }

    /* V1.1.1 */

    size = sizeof (paramp -> i_nbt_support);
    status = RegSetValueEx (key, CVY_NAME_NBT_SUPPORT, 0L, CVY_TYPE_NBT_SUPPORT,
                            (LPBYTE) & paramp -> i_nbt_support, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_NBT_SUPPORT, status);
        goto error;
    }

    /* V1.3b */

    size = sizeof (paramp -> mcast_support);
    status = RegSetValueEx (key, CVY_NAME_MCAST_SUPPORT, 0L, CVY_TYPE_MCAST_SUPPORT,
                            (LPBYTE) & paramp -> mcast_support, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_MCAST_SUPPORT, status);
        goto error;
    }

    size = sizeof (paramp -> i_mcast_spoof);
    status = RegSetValueEx (key, CVY_NAME_MCAST_SPOOF, 0L, CVY_TYPE_MCAST_SPOOF,
                            (LPBYTE) & paramp -> i_mcast_spoof, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_MCAST_SPOOF, status);
        goto error;
    }

    size = sizeof (paramp -> mask_src_mac);
    status = RegSetValueEx (key, CVY_NAME_MASK_SRC_MAC, 0L, CVY_TYPE_MASK_SRC_MAC,
                            (LPBYTE) & paramp -> mask_src_mac, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_MASK_SRC_MAC, status);
        goto error;
    }

    size = sizeof (paramp -> i_netmon_alive);
    status = RegSetValueEx (key, CVY_NAME_NETMON_ALIVE, 0L, CVY_TYPE_NETMON_ALIVE,
                            (LPBYTE) & paramp -> i_netmon_alive, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_NETMON_ALIVE, status);
        goto error;
    }

    size = sizeof (paramp -> i_ip_chg_delay);
    status = RegSetValueEx (key, CVY_NAME_IP_CHG_DELAY, 0L, CVY_TYPE_IP_CHG_DELAY,
                            (LPBYTE) & paramp -> i_ip_chg_delay, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_IP_CHG_DELAY, status);
        goto error;
    }

    size = sizeof (paramp -> i_convert_mac);
    status = RegSetValueEx (key, CVY_NAME_CONVERT_MAC, 0L, CVY_TYPE_CONVERT_MAC,
                            (LPBYTE) & paramp -> i_convert_mac, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_CONVERT_MAC, status);
        goto error;
    }

    size = sizeof (paramp -> i_num_rules);
    status = RegSetValueEx (key, CVY_NAME_NUM_RULES, 0L, CVY_TYPE_NUM_RULES,
                            (LPBYTE) & paramp -> i_num_rules, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_NUM_RULES, status);
        goto error;
    }

    //
    // sort the rules before writing it to the registry
    // EnumPortRules will take the rules from reg_data and return them in
    // sorted order in the array itself
    //

    WlbsEnumPortRules (paramp, paramp -> i_port_rules, & num_rules);

    ASSERT(paramp -> i_parms_ver == CVY_PARAMS_VERSION);  // version should be upgrated in read
    
    HKEY                subkey;

    // Delete all existing Port Rules
    SHDeleteKey(key, CVY_NAME_PORT_RULES); // NOT Checking return value cos the key itself may not be present in which case, it will return error

    // Create "PortRules" key
    status = RegCreateKeyEx (key, CVY_NAME_PORT_RULES, 0L, L"", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, & subkey, & disp);
    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_PORT_RULES, status);
        goto error;
    }

    bool fSpecificVipPortRuleFound = false;

    idx = 1;
    port_rule = paramp -> i_port_rules;
    while(idx <= num_rules)
    {
        // Invalid port rules are placed at the end, So, once an invalid port rule is encountered, we are done
        if (!port_rule->valid) 
            break;

        HKEY rule_key;
        wchar_t idx_str[8];

        // Create the per port-rule key "1", "2", "3", ...etc
        status = RegCreateKeyEx (subkey, _itow(idx, idx_str, 10), 0L, L"", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, & rule_key, & disp);
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry create for %ls failed with %d", idx_str, status);
            goto error;
        }

        // Check if there was any specific-vip port rule
        if (!fSpecificVipPortRuleFound && lstrcmpi(port_rule->virtual_ip_addr, CVY_DEF_ALL_VIP))
             fSpecificVipPortRuleFound = true;

        size = wcslen (port_rule -> virtual_ip_addr) * sizeof (WCHAR);
        status = RegSetValueEx (rule_key, CVY_NAME_VIP, 0L, CVY_TYPE_VIP, (LPBYTE) port_rule->virtual_ip_addr, size);
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_VIP, status);
            goto error;
        }

        size = sizeof (port_rule ->start_port );
        status = RegSetValueEx (rule_key, CVY_NAME_START_PORT, 0L, CVY_TYPE_START_PORT, (LPBYTE) &port_rule->start_port, size);
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_START_PORT, status);
            goto error;
        }

        size = sizeof (port_rule ->end_port );
        status = RegSetValueEx (rule_key, CVY_NAME_END_PORT, 0L, CVY_TYPE_END_PORT, (LPBYTE) &port_rule->end_port, size);
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_END_PORT, status);
            goto error;
        }

        size = sizeof (port_rule ->code);
        status = RegSetValueEx (rule_key, CVY_NAME_CODE, 0L, CVY_TYPE_CODE, (LPBYTE) &port_rule->code, size);
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_CODE, status);
            goto error;
        }

        size = sizeof (port_rule->mode);
        status = RegSetValueEx (rule_key, CVY_NAME_MODE, 0L, CVY_TYPE_MODE, (LPBYTE) &port_rule->mode, size);
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_MODE, status);
            goto error;
        }

        size = sizeof (port_rule->protocol);
        status = RegSetValueEx (rule_key, CVY_NAME_PROTOCOL, 0L, CVY_TYPE_PROTOCOL, (LPBYTE) &port_rule->protocol, size);
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_PROTOCOL, status);
            goto error;
        }

        DWORD EqualLoad, Affinity;

        switch (port_rule->mode) 
        {
        case CVY_MULTI :
             EqualLoad = port_rule->mode_data.multi.equal_load;
             size = sizeof (EqualLoad);
             status = RegSetValueEx (rule_key, CVY_NAME_EQUAL_LOAD, 0L, CVY_TYPE_EQUAL_LOAD, (LPBYTE) &EqualLoad, size);
             if (status != ERROR_SUCCESS)
             {
                 TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_EQUAL_LOAD, status);
                 goto error;
             }

             Affinity = port_rule->mode_data.multi.affinity;
             size = sizeof (Affinity);
             status = RegSetValueEx (rule_key, CVY_NAME_AFFINITY, 0L, CVY_TYPE_AFFINITY, (LPBYTE) &Affinity, size);
             if (status != ERROR_SUCCESS)
             {
                 TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_AFFINITY, status);
                 goto error;
             }

             size = sizeof (port_rule->mode_data.multi.load);
             status = RegSetValueEx (rule_key, CVY_NAME_LOAD, 0L, CVY_TYPE_LOAD, (LPBYTE) &(port_rule->mode_data.multi.load), size);
             if (status != ERROR_SUCCESS)
             {
                 TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_LOAD, status);
                 goto error;
             }
             break;

        case CVY_SINGLE :
             size = sizeof (port_rule->mode_data.single.priority);
             status = RegSetValueEx (rule_key, CVY_NAME_PRIORITY, 0L, CVY_TYPE_PRIORITY, (LPBYTE) &(port_rule->mode_data.single.priority), size);
             if (status != ERROR_SUCCESS)
             {
                 TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_PRIORITY, status);
                 goto error;
             }
             break;

        default:
             break;
        }

        if (ERROR_SUCCESS != RegCloseKey(rule_key))
        {
            TRACE_CRIT("%!FUNC! error closing registry key of individual port rules");
        }

        port_rule++;
        idx++;
    }

    if (ERROR_SUCCESS != RegCloseKey(subkey))
    {
        TRACE_CRIT("%!FUNC! error closing %ls registry key",CVY_NAME_PORT_RULES);
    }

    // If there is a specific-vip port rule, write that info on to the registry
    if (fSpecificVipPortRuleFound)
        paramp -> i_effective_version = CVY_VERSION_FULL;
    else
        paramp -> i_effective_version = CVY_NT40_VERSION_FULL;

    size = sizeof (paramp -> i_effective_version);
    status = RegSetValueEx (key, CVY_NAME_EFFECTIVE_VERSION, 0L, CVY_TYPE_EFFECTIVE_VERSION,
                            (LPBYTE) & paramp -> i_effective_version, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_EFFECTIVE_VERSION, status);
        goto error;
    }

    size = wcslen (paramp -> i_license_key) * sizeof (WCHAR);
    status = RegSetValueEx (key, CVY_NAME_LICENSE_KEY, 0L, CVY_TYPE_LICENSE_KEY,
                            (LPBYTE) paramp -> i_license_key, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_LICENSE_KEY, status);
        goto error;
    }

    size = sizeof (paramp -> i_rmt_password);
    status = RegSetValueEx (key, CVY_NAME_RMT_PASSWORD, 0L, CVY_TYPE_RMT_PASSWORD,
                            (LPBYTE) & paramp -> i_rmt_password, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_RMT_PASSWORD, status);
        goto error;
    }

    size = sizeof (paramp -> i_rct_password);
    status = RegSetValueEx (key, CVY_NAME_RCT_PASSWORD, 0L, CVY_TYPE_RCT_PASSWORD,
                            (LPBYTE) & paramp -> i_rct_password, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_RCT_PASSWORD, status);
        goto error;
    }

    size = sizeof (paramp -> rct_port);
    status = RegSetValueEx (key, CVY_NAME_RCT_PORT, 0L, CVY_TYPE_RCT_PORT,
                            (LPBYTE) & paramp -> rct_port, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_RCT_PORT, status);
        goto error;
    }

    size = sizeof (paramp -> rct_enabled);
    status = RegSetValueEx (key, CVY_NAME_RCT_ENABLED, 0L, CVY_TYPE_RCT_ENABLED,
                            (LPBYTE) & paramp -> rct_enabled, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_RCT_ENABLED, status);
        goto error;
    }

    size = sizeof (paramp -> identity_period);
    status = RegSetValueEx (key, CVY_NAME_ID_HB_PERIOD, 0L, CVY_TYPE_ID_HB_PERIOD,
                            (LPBYTE) & paramp -> identity_period, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_ID_HB_PERIOD, status);
        goto error;
    }

    size = sizeof (paramp -> identity_enabled);
    status = RegSetValueEx (key, CVY_NAME_ID_HB_ENABLED, 0L, CVY_TYPE_ID_HB_ENABLED,
                            (LPBYTE) & paramp -> identity_enabled, size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_ID_HB_ENABLED, status);
        goto error;
    }

    //
    // IGMP support registry entries
    //
    status = RegSetValueEx (key, CVY_NAME_IGMP_SUPPORT, 0L, CVY_TYPE_IGMP_SUPPORT,
                            (LPBYTE) & paramp->fIGMPSupport, sizeof (paramp->fIGMPSupport));
    
    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_IGMP_SUPPORT, status);
        goto error;
    }
    
    status = RegSetValueEx (key, CVY_NAME_MCAST_IP_ADDR, 0L, CVY_TYPE_MCAST_IP_ADDR, (LPBYTE) paramp->szMCastIpAddress, 
                            lstrlen (paramp->szMCastIpAddress)* sizeof(paramp->szMCastIpAddress[0]));

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_MCAST_IP_ADDR, status);
        goto error;
    }

    status = RegSetValueEx (key, CVY_NAME_IP_TO_MCASTIP, 0L, CVY_TYPE_IP_TO_MCASTIP,
                            (LPBYTE) & paramp->fIpToMCastIp, sizeof (paramp->fIpToMCastIp));
    
    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_IP_TO_MCASTIP, status);
        goto error;
    }

    /* If teaming is active on this adapter, then create a subkey to house the BDA teaming configuration and fill it in. */
    if (paramp->bda_teaming.active) {

        /* Attempt to create the registry key. */
        if (!(bda_key = RegCreateWlbsBDASettings(AdapterGuid)))
        {
            TRACE_CRIT("%!FUNC! registry create for bda settings failed");
            goto error;
        }

        /* Set the team ID - if it fails, bail out. */
        status = RegSetValueEx(bda_key, CVY_NAME_BDA_TEAM_ID, 0L, CVY_TYPE_BDA_TEAM_ID, (LPBYTE) paramp->bda_teaming.team_id, 
                               lstrlen(paramp->bda_teaming.team_id) * sizeof(paramp->bda_teaming.team_id[0]));
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_BDA_TEAM_ID, status);
            goto bda_error;
        }

        /* Set the master status - if it fails, bail out. */
        status = RegSetValueEx(bda_key, CVY_NAME_BDA_MASTER, 0L, CVY_TYPE_BDA_MASTER,
                               (LPBYTE)&paramp->bda_teaming.master, sizeof (paramp->bda_teaming.master));
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_BDA_MASTER, status);
            goto bda_error;
        }

        /* Set the reverse hashing flag - if it fails, bail out. */
        status = RegSetValueEx(bda_key, CVY_NAME_BDA_REVERSE_HASH, 0L, CVY_TYPE_BDA_REVERSE_HASH,
                               (LPBYTE)&paramp->bda_teaming.reverse_hash, sizeof (paramp->bda_teaming.reverse_hash));
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_BDA_REVERSE_HASH, status);
            goto bda_error;
        }

        RegCloseKey(bda_key);
    } else {
        /* Delte the registry key and ignore the return value - the key may not even exist. */
        if (!RegDeleteWlbsBDASettings(AdapterGuid))
        {
            // Make this an INFO message since it is possible that the key may not exist
            TRACE_INFO("%!FUNC! registry delete for bda settings failed");
        }
    }

    //
    // Create an empty string if VirtualNICName does not exist
    //
    WCHAR virtual_nic_name[CVY_MAX_CLUSTER_NIC + 1];
    size = sizeof(virtual_nic_name);
    status = RegQueryValueEx (key, CVY_NAME_VIRTUAL_NIC, 0L, NULL,
                              (LPBYTE)virtual_nic_name, & size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d", CVY_NAME_VIRTUAL_NIC, status);
        virtual_nic_name [0] = 0;
        size = wcslen (virtual_nic_name) * sizeof (WCHAR);
        status = RegSetValueEx (key, CVY_NAME_VIRTUAL_NIC, 0L, CVY_TYPE_VIRTUAL_NIC,
                            (LPBYTE) virtual_nic_name, size);
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_VIRTUAL_NIC, status);
        }
    }

    /* lastly write the version number */

    size = sizeof (paramp -> i_parms_ver);
    status = RegSetValueEx (key, CVY_NAME_VERSION, 0L, CVY_TYPE_VERSION,
                            (LPBYTE) & paramp -> i_parms_ver, size);
    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_VERSION, status);
        goto error;
    }

    if (ERROR_SUCCESS != RegCloseKey(key))
    {
        TRACE_CRIT("%!FUNC! error closing registry");
    }

    TRACE_VERB("<-%!FUNC! return true");
    return TRUE;

 error:
    if (ERROR_SUCCESS != RegCloseKey(key))
    {
        TRACE_CRIT("%!FUNC! error closing registry");
    }
    TRACE_VERB("<-%!FUNC! return false");
    return FALSE;

 bda_error:
    if (ERROR_SUCCESS != RegCloseKey(bda_key))
    {
        TRACE_CRIT("%!FUNC! error closing registry");
    }
    TRACE_VERB("<-%!FUNC! return false");
    goto error;
}

//+----------------------------------------------------------------------------
//
// Function: ParamCommitChanges
//
// Description:  Notify wlbs driver or nic driver to pick up the changes
//
// Arguments: Adapter GUID, Handle to NLB driver, Cluster IP Address (filled on return), 
//            Dedicated IP Address (filled on return), reload_required flag, mac_addr changeg flag
//
// Returns:   DWORD - 
//
// History:   KarthicN Created 08/28/01 
//          
//
//+----------------------------------------------------------------------------
DWORD ParamCommitChanges(const GUID& AdapterGuid, 
                         HANDLE      hDeviceWlbs, 
                         DWORD&      cl_addr, 
                         DWORD&      ded_addr, 
                         bool *      p_reload_required,
                         bool *      p_notify_adapter_required)
{
    TRACE_VERB("->%!FUNC!");

    LONG    status;
    
    // Read the cluster IP address and the dedicated IP address from the
    // registry and update the global variables.
    // Always update the cluster IP address and the dedicated IP address
    if (!RegReadAdapterIp(AdapterGuid, cl_addr, ded_addr))
    {
        TRACE_CRIT("%!FUNC! failed reading cluster and dedicate IP addresses from registry");
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }

    /* Check if the driver requires a reload or not. If not, then simply return */
    if (*p_reload_required == false)
    {
        TRACE_VERB("<-%!FUNC! no reload required. return %d", WLBS_OK);
        return WLBS_OK;
    }

    status = NotifyDriverConfigChanges(hDeviceWlbs, AdapterGuid);
    if (ERROR_SUCCESS != status)
    {
        TRACE_CRIT("%!FUNC! NotifyDriverConfigChanges failed with %d", status);
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
        return status;
    }

    *p_reload_required = false; /* reset the flag */

    if (*p_notify_adapter_required)
    {
        *p_notify_adapter_required = false;
        
        /* The NIC card name for the cluster. */
        WCHAR driver_name[CVY_STR_SIZE];
        ZeroMemory(driver_name, sizeof(driver_name));

        /* Get the driver name from the GUID. */
        GetDriverNameFromGUID(AdapterGuid, driver_name, CVY_STR_SIZE);

        /* No longer disable and enable the adapter, since this function never gets called on bind or unbind.
           For other cases, prop change is all that is needed */
        TRACE_INFO("%!FUNC! changing properties of adapter");
        NotifyAdapterAddressChangeEx(driver_name, AdapterGuid, true);
    }

    TRACE_VERB("<-%!FUNC! return %d", WLBS_OK);
    return WLBS_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  ParamDeleteReg
//
// Description:  Delete the registry settings
//
// Arguments: IN const WCHAR* pszInterface - 
//
// Returns:   DWORD WINAPI - 
//
// History:   fengsun Created Header    1/22/00
//
//+----------------------------------------------------------------------------
bool WINAPI ParamDeleteReg(const GUID& AdapterGuid, bool fDeleteObsoleteEntries)
{
    TRACE_VERB("->%!FUNC! pass");

    WCHAR        reg_path [PARAMS_MAX_STRING_SIZE];
    LONG         status;
    HRESULT      hresult;

    WCHAR szAdapterGuid[128];

    if (0 == StringFromGUID2(AdapterGuid, szAdapterGuid, sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0])))
    {
        TRACE_CRIT("%!FUNC! guid is too large for string. Result is %ls", szAdapterGuid);
        // This check was added for tracing. No abort was done previously on error, so don't do so now.
    }

    hresult = StringCbPrintf (reg_path, sizeof(reg_path), L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface\\%s",
            szAdapterGuid);
    if (FAILED(hresult)) 
    {
        TRACE_CRIT("%!FUNC! StringCbPrintf failed, Error code : 0x%x", HRESULT_CODE(hresult));
        TRACE_VERB("<-%!FUNC! return false");
        return FALSE;
    }

    if (fDeleteObsoleteEntries) 
    {
        TRACE_INFO("%!FUNC! deleting obsolete registry entries");
        HKEY hkey;

        // Delete Port Rules in Binary format
        status = RegOpenKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L, KEY_ALL_ACCESS, &hkey);
        if (status == ERROR_SUCCESS)
        {
            status = RegDeleteValue(hkey, CVY_NAME_OLD_PORT_RULES);
            if (ERROR_SUCCESS != status)
            {
                TRACE_CRIT("%!FUNC! registry delete of %ls failed with %d. Skipping it.", CVY_NAME_OLD_PORT_RULES, status);
                // This check was added for tracing. No abort was done previously on error, so don't do so now.
            }
            status = RegCloseKey(hkey);
            if (ERROR_SUCCESS != status)
            {
                TRACE_CRIT("%!FUNC! closing registry failed with %d", status);
            }
        }
        else
        {
            TRACE_CRIT("%!FUNC! registry open for %ls failed with %d. Skipping it.", reg_path, status);
        }

        // Delete Win2k entries, Enumerate & delete values
        hresult = StringCbPrintf (reg_path, sizeof(reg_path), L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters");
        if (FAILED(hresult)) 
        {
            TRACE_CRIT("%!FUNC! StringCbPrintf failed, Error code : 0x%x", HRESULT_CODE(hresult));
            TRACE_VERB("<-%!FUNC! return false");
            return FALSE;
        }

        status = RegOpenKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L, KEY_ALL_ACCESS, &hkey);
        if (status == ERROR_SUCCESS)
        {
           DWORD  Index, ValueNameSize;
           WCHAR  ValueName [PARAMS_MAX_STRING_SIZE];

           Index = 0;
           ValueNameSize = PARAMS_MAX_STRING_SIZE;
           while (RegEnumValue(hkey, Index++, ValueName, &ValueNameSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) 
           {
               status = RegDeleteValue(hkey, ValueName);
               if (ERROR_SUCCESS != status)
               {
                    TRACE_CRIT("%!FUNC! registry delete of %ls failed with %d. Skipping it.", ValueName, status);
                    // This check was added for tracing. No abort was done previously on error, so don't do so now.
               }
           }
           status = RegCloseKey(hkey);
           if (ERROR_SUCCESS != status)
           {
                TRACE_CRIT("%!FUNC! closing registry failed with %d", status);
           }
        }
        else
        {
            TRACE_CRIT("%!FUNC! registry open for %ls failed with %d. Skipping it.", reg_path, status);
        }
    }
    else
    {
        TRACE_INFO("%!FUNC! deleting %ls", reg_path);
        DWORD dwRet = RegDeleteKey(HKEY_LOCAL_MACHINE, reg_path);

        if (dwRet != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry delete of %ls failed with %d", reg_path, dwRet);
            TRACE_VERB("->%!FUNC! fail");
            return false;
        }
    }

    TRACE_VERB("<-%!FUNC! pass");
    return true;
} /* end Params_delete */


//+----------------------------------------------------------------------------
//
// Function:  ParamSetDefaults
//
// Description:  Set default settings
//
// Arguments: PWLBS_REG_PARAMS    reg_data - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI ParamSetDefaults(PWLBS_REG_PARAMS    reg_data)
{
    reg_data -> struct_version = WLBS_REG_PARAMS_VERSION;
    reg_data -> install_date = 0;
    reg_data -> i_verify_date = 0;
//    reg_data -> cluster_nic_name [0] = _TEXT('\0');
    reg_data -> i_parms_ver = CVY_DEF_VERSION;
    reg_data -> i_virtual_nic_name [0] = _TEXT('\0');
    reg_data -> host_priority = CVY_DEF_HOST_PRIORITY;
    reg_data -> cluster_mode = CVY_DEF_CLUSTER_MODE;
    reg_data -> persisted_states = CVY_DEF_PERSISTED_STATES;
    StringCbCopy (reg_data -> cl_mac_addr, sizeof(reg_data -> cl_mac_addr), CVY_DEF_NETWORK_ADDR);
    StringCbCopy (reg_data -> cl_ip_addr, sizeof(reg_data -> cl_ip_addr), CVY_DEF_CL_IP_ADDR);
    StringCbCopy (reg_data -> cl_net_mask, sizeof(reg_data -> cl_net_mask), CVY_DEF_CL_NET_MASK);
    StringCbCopy (reg_data -> ded_ip_addr, sizeof(reg_data -> ded_ip_addr), CVY_DEF_DED_IP_ADDR);
    StringCbCopy (reg_data -> ded_net_mask, sizeof(reg_data -> ded_net_mask), CVY_DEF_DED_NET_MASK);
    StringCbCopy (reg_data -> domain_name, sizeof(reg_data -> domain_name), CVY_DEF_DOMAIN_NAME);
    reg_data -> alive_period = CVY_DEF_ALIVE_PERIOD;
    reg_data -> alive_tolerance = CVY_DEF_ALIVE_TOLER;
    reg_data -> num_actions = CVY_DEF_NUM_ACTIONS;
    reg_data -> num_packets = CVY_DEF_NUM_PACKETS;
    reg_data -> num_send_msgs = CVY_DEF_NUM_SEND_MSGS;
    reg_data -> dscr_per_alloc = CVY_DEF_DSCR_PER_ALLOC;
    reg_data -> tcp_dscr_timeout = CVY_DEF_TCP_TIMEOUT;
    reg_data -> ipsec_dscr_timeout = CVY_DEF_IPSEC_TIMEOUT;
    reg_data -> filter_icmp = CVY_DEF_FILTER_ICMP;
    reg_data -> max_dscr_allocs = CVY_DEF_MAX_DSCR_ALLOCS;
    reg_data -> i_scale_client = CVY_DEF_SCALE_CLIENT;
    reg_data -> i_cleanup_delay = CVY_DEF_CLEANUP_DELAY;
    reg_data -> i_ip_chg_delay = CVY_DEF_IP_CHG_DELAY;
    reg_data -> i_nbt_support = CVY_DEF_NBT_SUPPORT;
    reg_data -> mcast_support = CVY_DEF_MCAST_SUPPORT;
    reg_data -> i_mcast_spoof = CVY_DEF_MCAST_SPOOF;
    reg_data -> mask_src_mac = CVY_DEF_MASK_SRC_MAC;
    reg_data -> i_netmon_alive = CVY_DEF_NETMON_ALIVE;
    reg_data -> i_effective_version = CVY_NT40_VERSION_FULL;
    reg_data -> i_convert_mac = CVY_DEF_CONVERT_MAC;
    reg_data -> i_num_rules = 0;
    memset (reg_data -> i_port_rules, 0, sizeof (WLBS_PORT_RULE) * WLBS_MAX_RULES);
    StringCbCopy (reg_data -> i_license_key, sizeof(reg_data -> i_license_key), CVY_DEF_LICENSE_KEY);
    reg_data -> i_rmt_password = CVY_DEF_RMT_PASSWORD;
    reg_data -> i_rct_password = CVY_DEF_RCT_PASSWORD;
    reg_data -> rct_port = CVY_DEF_RCT_PORT;
    reg_data -> rct_enabled = CVY_DEF_RCT_ENABLED;
    reg_data -> i_max_hosts        = CVY_MAX_HOSTS;
    reg_data -> i_max_rules        = CVY_MAX_USABLE_RULES;
    reg_data -> identity_period = CVY_DEF_ID_HB_PERIOD;
    reg_data -> identity_enabled = CVY_DEF_ID_HB_ENABLED;

    reg_data -> fIGMPSupport = CVY_DEF_IGMP_SUPPORT;
    StringCbCopy(reg_data -> szMCastIpAddress, sizeof(reg_data -> szMCastIpAddress), CVY_DEF_MCAST_IP_ADDR);
    reg_data -> fIpToMCastIp = CVY_DEF_IP_TO_MCASTIP;
        
    reg_data->bda_teaming.active = CVY_DEF_BDA_ACTIVE;
    reg_data->bda_teaming.master = CVY_DEF_BDA_MASTER;
    reg_data->bda_teaming.reverse_hash = CVY_DEF_BDA_REVERSE_HASH;
    reg_data->bda_teaming.team_id[0] = CVY_DEF_BDA_TEAM_ID;

    reg_data -> i_num_rules = 1;

    // fill in the first port rule.
    StringCbCopy (reg_data->i_port_rules[0].virtual_ip_addr, sizeof(reg_data->i_port_rules[0].virtual_ip_addr), CVY_DEF_ALL_VIP);
    reg_data -> i_port_rules [0] . start_port = CVY_DEF_PORT_START;
    reg_data -> i_port_rules [0] . end_port = CVY_DEF_PORT_END;
    reg_data -> i_port_rules [0] . valid = TRUE;
    reg_data -> i_port_rules [0] . mode = CVY_DEF_MODE;
    reg_data -> i_port_rules [0] . mode_data . multi . equal_load = TRUE;
    reg_data -> i_port_rules [0] . mode_data . multi . affinity   = CVY_DEF_AFFINITY;
    reg_data -> i_port_rules [0] . mode_data . multi . load       = CVY_DEF_LOAD;
    reg_data -> i_port_rules [0] . protocol = CVY_DEF_PROTOCOL;
    CVY_RULE_CODE_SET(& reg_data -> i_port_rules [0]);

    return WLBS_OK;
}


EXTERN_C DWORD WINAPI WlbsGetNumPortRules
(
    const PWLBS_REG_PARAMS reg_data
)
{
    if (reg_data == NULL)
        return WLBS_BAD_PARAMS;

    return reg_data -> i_num_rules;

} /* end WlbsGetNumPortRules */

EXTERN_C DWORD WINAPI WlbsGetEffectiveVersion
(
    const PWLBS_REG_PARAMS reg_data
)
{
    if (reg_data == NULL)
        return WLBS_BAD_PARAMS;

    return reg_data -> i_effective_version;

} /* end WlbsGetEffectiveVersion */

EXTERN_C DWORD WINAPI WlbsEnumPortRules
(
    const PWLBS_REG_PARAMS reg_data,
    PWLBS_PORT_RULE  rules,
    PDWORD           num_rules
)
{
    TRACE_VERB("->%!FUNC!");

    DWORD count_rules, i, index;
    DWORD lowest_vip, lowest_port;
    BOOL array_flags [WLBS_MAX_RULES];
    WLBS_PORT_RULE sorted_rules [WLBS_MAX_RULES];

    if ((reg_data == NULL) || (num_rules == NULL))
    {
        TRACE_CRIT("%!FUNC! bad input parameter for registry data or output buffer size");
        TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PARAMS);
        return WLBS_BAD_PARAMS;
    }

    if (*num_rules == 0)
        rules = NULL;
    /* this array is used for keeping track of which rules have already been retrieved */
    /* This is needed since the rules are to be retrieved in the sorted order */

    memset ( array_flags, 0, sizeof(BOOL) * WLBS_MAX_RULES );

    count_rules = 0;

    while ((count_rules < *num_rules) && (count_rules < reg_data -> i_num_rules))
    {
        i = 0;

        /* find the first rule that has not been retrieved */
        while ((! reg_data -> i_port_rules [i] . valid) || array_flags [i])
        {
            i++;
        }

        lowest_vip = htonl(IpAddressFromAbcdWsz(reg_data -> i_port_rules [i] . virtual_ip_addr));
        lowest_port = reg_data -> i_port_rules [i] . start_port;
        index = i;

        /* Compare that rule with the other non-retrieved rules to get the rule with the
           lowest VIP & start_port */

        i++;
        while (i < WLBS_MAX_RULES)
        {
            if (reg_data -> i_port_rules [i] . valid && ( ! array_flags [i] ))
            {
                DWORD current_vip = htonl(IpAddressFromAbcdWsz(reg_data -> i_port_rules [i] . virtual_ip_addr));
                if ((current_vip < lowest_vip) 
                 || ((current_vip == lowest_vip) && (reg_data -> i_port_rules [i] . start_port < lowest_port)))
                {
                    lowest_vip = current_vip;
                    lowest_port = reg_data -> i_port_rules [i] . start_port;
                    index = i;
                }
            }
            i++;
        }
        /*       The array_flags [i] element is set to TRUE if the rule is retrieved */
        array_flags [index] = TRUE;
        sorted_rules [count_rules] = reg_data -> i_port_rules [index];
        count_rules ++;
    }

    /* write the sorted rules back into the return array */
    TRACE_VERB("%!FUNC! sorted rule list is:");
    for (i = 0; i < count_rules; i++)
    {
        rules[i] = sorted_rules[i];
        TRACE_VERB("%!FUNC! rule %d, vip: %ls, start port: %d", i, rules[i] . virtual_ip_addr, rules[i] . start_port);
    }

    /* invalidate the remaining rules in the buffer */
    for (i = count_rules; i < *num_rules; i++)
        rules [i] . valid = FALSE;

    if (*num_rules < reg_data -> i_num_rules)
    {
        *num_rules = reg_data -> i_num_rules;
        TRACE_INFO("<-%!FUNC! returning incomplete list of valid rules. Input buffer length too small.");
        TRACE_VERB("<-%!FUNC! return %d", WLBS_TRUNCATED);
        return WLBS_TRUNCATED;
    }

    *num_rules = reg_data -> i_num_rules;
    TRACE_VERB("<-%!FUNC! return %d", WLBS_OK);
    return WLBS_OK;

} /* end WlbsEnumPortRules */

EXTERN_C DWORD WINAPI WlbsGetPortRule
(
    const PWLBS_REG_PARAMS reg_data,
    DWORD                  vip,
    DWORD                  pos,
    OUT PWLBS_PORT_RULE    rule
)
{
    TRACE_VERB("->%!FUNC! vip 0x%lx, port %d", vip, pos);

    int i;

    if ((reg_data == NULL) || (rule == NULL))
    {
        TRACE_CRIT("%!FUNC! bad input parameter for registry data or output buffer");
        TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PARAMS);
        return WLBS_BAD_PARAMS;
    }

    /* need to check whether pos is within the correct range */
    if ( /* CLEAN_64BIT (pos < CVY_MIN_PORT) || */ (pos > CVY_MAX_PORT))
    {
        TRACE_CRIT("%!FUNC! bad input parameter for port number");
        TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PARAMS);
        return WLBS_BAD_PARAMS;
    }

    /* search through the array for the rules */
    for (i = 0; i < WLBS_MAX_RULES; i++)
    {
        /* check only the valid rules */
        if (reg_data -> i_port_rules[i] . valid == TRUE)
        {
            /* check the range of the rule to see if pos fits into it */
            if ((vip == IpAddressFromAbcdWsz(reg_data -> i_port_rules[i] . virtual_ip_addr)) &&
                (pos >= reg_data -> i_port_rules[i] . start_port) &&
                (pos <= reg_data -> i_port_rules[i] . end_port))
            {
                *rule = reg_data -> i_port_rules [i];
                TRACE_INFO("%!FUNC! port rule found");
                TRACE_VERB("<-%!FUNC! return %d", WLBS_OK);
                return WLBS_OK;
            }
        }
    }

    /* no rule was found for this port */
    TRACE_VERB("<-%!FUNC! return %d", WLBS_OK);
    return WLBS_NOT_FOUND;

} /* end WlbsGetPortRule */


EXTERN_C DWORD WINAPI WlbsAddPortRule
(
    PWLBS_REG_PARAMS reg_data,
    const PWLBS_PORT_RULE rule
)
{
    TRACE_VERB("->%!FUNC!");

    int i;
    DWORD vip;

    if ((reg_data == NULL) || (rule == NULL))
    {
        TRACE_CRIT("%!FUNC! bad input parameter for registry data or port rule");
        TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PARAMS);
        return WLBS_BAD_PARAMS;
    }

    /* Check if there is space for the new rule */
    if (reg_data -> i_num_rules == WLBS_MAX_RULES)
    {
        TRACE_CRIT("%!FUNC! the maxiumum number of port rules %d are already defined", WLBS_MAX_RULES);
        TRACE_VERB("<-%!FUNC! return %d", WLBS_MAX_PORT_RULES);
        return WLBS_MAX_PORT_RULES;
    }

    /* check the rule for valid values */

    /* check for non-zero vip and conflict with dip */
    vip = IpAddressFromAbcdWsz(rule -> virtual_ip_addr);
    if (vip == 0 || (INADDR_NONE == vip && lstrcmpi(rule -> virtual_ip_addr, CVY_DEF_ALL_VIP) != 0))
    {
        TRACE_CRIT("%!FUNC! vip %ls in port rule is malformed", rule -> virtual_ip_addr);
        TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PORT_PARAMS);
        return WLBS_BAD_PORT_PARAMS;
    }

    if (vip == IpAddressFromAbcdWsz(reg_data->ded_ip_addr))
    {
        TRACE_CRIT("%!FUNC! vip %ls in port rule is in used as a dedicated IP address", rule -> virtual_ip_addr);
        TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PORT_PARAMS);
        return WLBS_BAD_PORT_PARAMS;
    }

    /* first check the range of the start and end ports */
    if ((rule -> start_port > rule -> end_port) ||
// CLEAN_64BIT        (rule -> start_port < CVY_MIN_PORT)     ||
        (rule -> end_port   > CVY_MAX_PORT))
    {
        TRACE_CRIT
        (
            "%!FUNC! port range of rule is invalid; start port = %d, end port = %d, max allowed port = %d",
            rule -> start_port,
            rule -> end_port,
            CVY_MAX_PORT
        );
        TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PORT_PARAMS);
        return WLBS_BAD_PORT_PARAMS;
    }

    /* check the protocol range */
    if ((rule -> protocol < CVY_MIN_PROTOCOL) || (rule -> protocol > CVY_MAX_PROTOCOL))
    {
        TRACE_CRIT("%!FUNC! invalid protocol code specified %d", rule -> protocol);
        TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PORT_PARAMS);
        return WLBS_BAD_PORT_PARAMS;
    }

    /* check filtering mode to see whether it is within range */
    if ((rule -> mode < CVY_MIN_MODE) || (rule -> mode > CVY_MAX_MODE))
    {
        TRACE_CRIT("%!FUNC! invalid filtering mode specified %d", rule -> mode);
        TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PORT_PARAMS);
        return WLBS_BAD_PORT_PARAMS;
    }

    /* check load weight and affinity if multiple hosts */
    if (rule -> mode == CVY_MULTI)
    {
        if ((rule -> mode_data . multi . affinity < CVY_MIN_AFFINITY) ||
            (rule -> mode_data . multi . affinity > CVY_MAX_AFFINITY))
        {
            TRACE_CRIT("%!FUNC! invalid affinity code specified %d", rule -> mode_data . multi . affinity);
            TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PORT_PARAMS);
            return WLBS_BAD_PORT_PARAMS;
        }

        if ((rule -> mode_data . multi . equal_load < CVY_MIN_EQUAL_LOAD) ||
            (rule -> mode_data . multi . equal_load > CVY_MAX_EQUAL_LOAD))
        {
            TRACE_CRIT("%!FUNC! invalid equal load percentage specified %d", rule -> mode_data . multi . equal_load);
            TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PORT_PARAMS);
            return WLBS_BAD_PORT_PARAMS;
        }

        if (! rule -> mode_data . multi . equal_load)
        {
            if ((rule -> mode_data . multi . load > CVY_MAX_LOAD))
                //CLEAN_64BIT (rule -> mode_data . multi . load < CVY_MIN_LOAD) ||
            {
                TRACE_CRIT("%!FUNC! invalid non-equal load percentage specified %d", rule -> mode_data . multi . load);
                TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PORT_PARAMS);
                return WLBS_BAD_PORT_PARAMS;
            }
        }
    }

    /* check handling priority range if single host */
    if (rule -> mode == CVY_SINGLE)
    {
        if ((rule -> mode_data . single . priority < CVY_MIN_PRIORITY) ||
            (rule -> mode_data . single . priority > CVY_MAX_PRIORITY))
        {
            TRACE_CRIT("%!FUNC! invalid handlind priority specified %d", rule -> mode_data . single . priority);
            TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PORT_PARAMS);
            return WLBS_BAD_PORT_PARAMS;
        }
    }

    /* go through the rule list and then check for overlapping conditions */
    for (i = 0; i < WLBS_MAX_RULES; i++)
    {
        if (reg_data -> i_port_rules[i] . valid == TRUE)
        {
            if ((IpAddressFromAbcdWsz(reg_data -> i_port_rules[i] . virtual_ip_addr) == vip) 
            && (( (reg_data -> i_port_rules[i] . start_port <= rule -> start_port) &&
                  (reg_data -> i_port_rules[i] . end_port   >= rule -> start_port))      ||
                ( (reg_data -> i_port_rules[i] . start_port >= rule -> start_port)   &&
                  (reg_data -> i_port_rules[i] . start_port <= rule -> end_port))))
            {
                TRACE_CRIT
                (
                    "%!FUNC! port range for new rule overlaps an existing rule; vip = %ls, start port = %d, end port = %d, existing rule: start port = %d, end port = %d",
                    rule -> virtual_ip_addr,
                    rule -> start_port,
                    rule -> end_port,
                    reg_data -> i_port_rules[i] . start_port,
                    reg_data -> i_port_rules[i] . end_port
                );
                TRACE_VERB("<-%!FUNC! return %d", WLBS_PORT_OVERLAP);
                return WLBS_PORT_OVERLAP;
            }
        }
    }


    /* go through the rule list and find out the first empty spot
       and write out the port rule */

    for (i = 0 ; i < WLBS_MAX_RULES ; i++)
    {
        if (reg_data -> i_port_rules[i] . valid == FALSE)
        {
            reg_data -> i_num_rules ++ ;
            reg_data -> i_port_rules [i] = *rule;
            reg_data -> i_port_rules [i] . valid = TRUE;
            CVY_RULE_CODE_SET(& reg_data -> i_port_rules [i]);
            TRACE_INFO
            (
                "%!FUNC! port rule added for vip = %ls, start port = %d, end port = %d",
                rule -> virtual_ip_addr,
                rule -> start_port,
                rule -> end_port
            );
            TRACE_VERB("<-%!FUNC! return %d", WLBS_OK);
            return WLBS_OK;
        }
    }

    TRACE_CRIT
    (
        "%!FUNC! data integrity error. No room for rule, but problem should have been caught earlier. vip = %ls, start port = %d, end port = %d",
        rule -> virtual_ip_addr,
        rule -> start_port,
        rule -> end_port
    );
    TRACE_VERB("<-%!FUNC! return %d", WLBS_MAX_PORT_RULES);
    return WLBS_MAX_PORT_RULES;

} /* end WlbsAddPortRule */


EXTERN_C DWORD WINAPI WlbsDeletePortRule
(
    PWLBS_REG_PARAMS reg_data,
    DWORD            vip,
    DWORD            port
)
{
    TRACE_VERB("->%!FUNC! vip = 0x%lx, %d", vip, port);

    int i;

    if (reg_data == NULL)
    {
        TRACE_CRIT("%!FUNC! registry data not provided");
        TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PARAMS);
        return WLBS_BAD_PARAMS;
    }

    /* check if the port is within the correct range */
    if ( /* CLEAN_64BIT (port < CVY_MIN_PORT) ||*/ (port > CVY_MAX_PORT))
    {
        TRACE_CRIT("%!FUNC! specified port %d is out of range", port);
        TRACE_VERB("<-%!FUNC! return %d", WLBS_BAD_PARAMS);
        return WLBS_BAD_PARAMS;
    }

    /* find the rule associated with this port */

    for (i = 0; i < WLBS_MAX_RULES; i++)
    {
        if (reg_data -> i_port_rules[i] . valid)
        {
            if ((vip  == IpAddressFromAbcdWsz(reg_data -> i_port_rules[i] . virtual_ip_addr)) &&
                (port >= reg_data -> i_port_rules[i] . start_port) &&
                (port <= reg_data -> i_port_rules[i] . end_port))
            {
                reg_data -> i_port_rules[i] . valid = FALSE;
                reg_data -> i_num_rules -- ;
                TRACE_INFO
                (
                    "%!FUNC! deleted port rule for port %d. Rule was vip = %ls, start port = %d, end port = %d",
                    port,
                    reg_data -> i_port_rules[i] . virtual_ip_addr,
                    reg_data -> i_port_rules[i] . start_port,
                    reg_data -> i_port_rules[i] . end_port
                );
                TRACE_VERB("<-%!FUNC! return %d", WLBS_OK);
                return WLBS_OK;
            }
        }
    }

    TRACE_INFO("<-%!FUNC! port rule for port %d not found", port);
    TRACE_VERB("<-%!FUNC! return %d", WLBS_NOT_FOUND);
    return WLBS_NOT_FOUND;

} /* end WlbsDeletePortRule */


EXTERN_C VOID WINAPI  WlbsDeleteAllPortRules
(
    PWLBS_REG_PARAMS reg_data
)
{
    TRACE_VERB("->%!FUNC!");

    reg_data -> i_num_rules = 0;

    ZeroMemory(reg_data -> i_port_rules, sizeof(reg_data -> i_port_rules));

    TRACE_VERB("<-%!FUNC!");

} /* end WlbsDeleteAllPortRules */


EXTERN_C DWORD WINAPI WlbsSetRemotePassword
(
    PWLBS_REG_PARAMS reg_data,
    const WCHAR*     password
)
{
    if (reg_data == NULL)
        return WLBS_BAD_PARAMS;

    if (password != NULL)
    {
        reg_data -> i_rct_password = License_wstring_encode ((WCHAR*)password);
    }
    else
        reg_data -> i_rct_password = CVY_DEF_RCT_PASSWORD;

    return WLBS_OK;

} /* end WlbsSetRemotePassword */

//+----------------------------------------------------------------------------
//
// Function:  RegChangeNetworkAddress
//
// Description:  Change the mac address of the adapter in registry
//
// Arguments: const GUID& AdapterGuid - the adapter guid to look up settings
//            TCHAR mac_address - 
//            BOOL fRemove - true to remove address, false to write address
//
// Returns:   bool - true if succeeded
//
// History:   fengsun Created Header    1/18/00
//
//+----------------------------------------------------------------------------
bool WINAPI RegChangeNetworkAddress(const GUID& AdapterGuid, const WCHAR* mac_address, BOOL fRemove)
{
    if (NULL != mac_address)
        TRACE_VERB("->%!FUNC! mac = %ls", mac_address);
    else
        TRACE_VERB("->%!FUNC! mac = NULL");

    HKEY                key = NULL;
    LONG                status;
    DWORD               size;
    DWORD               type;
    TCHAR               net_addr [CVY_MAX_NETWORK_ADDR + 1];
    HDEVINFO            hdi = NULL;
    SP_DEVINFO_DATA     deid;

    if (fRemove)
    {
        TRACE_INFO("%!FUNC! remove mac address");
    }
    else
    {
        status = CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, mac_address, -1, CVY_DEF_UNICAST_NETWORK_ADDR, -1);
        if (status == 0)
        {
            TRACE_CRIT("MAC address compare with the default value failed with error 0x%x", GetLastError());
            fRemove = TRUE;
        }
        else if (status == CSTR_EQUAL)
        {
            // The MAC is not set as expected
            TRACE_CRIT("%!FUNC! failed to set mac address to %ls because this is the default address (no VIP was specified)", mac_address);
            fRemove = TRUE;
        }
        else
        {
            // Things look good
            TRACE_INFO("%!FUNC! to %ws", mac_address);
        }
    }

    /*
        - write NetworkAddress value into the cluster adapter's params key
          if mac address changed, or remove it if switched to multicast mode
    */

    key = RegOpenWlbsSetting(AdapterGuid, true);

    if (key == NULL)
    {
        TRACE_CRIT("%!FUNC! failed to open registry for the specified adapter");
        goto error;
    }

    TCHAR   driver_name[CVY_STR_SIZE];      //  the NIC card name for the cluster
    size = sizeof (driver_name);
    status = RegQueryValueEx (key, CVY_NAME_CLUSTER_NIC, 0L, & type, (LPBYTE) driver_name,
                              & size);

    if (status != ERROR_SUCCESS)
    {
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d", CVY_NAME_CLUSTER_NIC, status);
        goto error;
    }

    status = RegCloseKey(key);
    if (ERROR_SUCCESS != status)
    {
        TRACE_CRIT("%!FUNC! registry close failed with %d", status);
        // Do not goto error. Added this check as part of implementing tracing
    }

    key = NULL;

    hdi = SetupDiCreateDeviceInfoList (&GUID_DEVCLASS_NET, NULL);
    if (hdi == INVALID_HANDLE_VALUE)
    {
        TRACE_CRIT("%!FUNC! SetupDiCreateDeviceInfoList failed");
        goto error;
    }

    ZeroMemory(&deid, sizeof(deid));
    deid.cbSize = sizeof(deid);

    if (! SetupDiOpenDeviceInfo (hdi, driver_name, NULL, 0, &deid))
    {
        TRACE_CRIT("%!FUNC! SetupDiOpenDeviceInfo failed");
        goto error;
    }

    key = SetupDiOpenDevRegKey (hdi, &deid, DICS_FLAG_GLOBAL, 0,
                                DIREG_DRV, KEY_ALL_ACCESS);

    if (key == INVALID_HANDLE_VALUE)
    {
        TRACE_CRIT("%!FUNC! SetupDiOpenDevRegKey failed");
        goto error;
    }

    /* Now the key has been obtained and this can be passed to the RegChangeNetworkAddress call */

    if ((/*global_info.mac_addr_change ||*/ !fRemove)) /* a write is required */
    {
        /* Check if the saved name exists.
         * If it does not, create a new field and save the old address.
         * Write the new address and return
         */

        size = sizeof (TCHAR) * CVY_STR_SIZE;
        status = RegQueryValueEx (key, CVY_NAME_SAVED_NET_ADDR, 0L, &type,
                                  (LPBYTE) net_addr, &size);

        if (status != ERROR_SUCCESS) /* there is no saved address. so create a field */
        {
            TRACE_CRIT("%!FUNC! registry read for %ls failed with %d", CVY_NAME_SAVED_NET_ADDR, status);
            /* Query the existing mac address in order to save it */
            size = sizeof (net_addr);
            status = RegQueryValueEx (key, CVY_NAME_NET_ADDR, 0L, &type,
                                      (LPBYTE) net_addr, &size);

            if (status != ERROR_SUCCESS) /* create an empty saved address */
            {
                TRACE_CRIT("%!FUNC! registry read for %ls failed with %d", CVY_NAME_NET_ADDR, status);
                net_addr [0] = 0;
                size = 0;
            }

            status = RegSetValueEx (key, CVY_NAME_SAVED_NET_ADDR, 0L, CVY_TYPE_NET_ADDR,
                                    (LPBYTE) net_addr, size);

            /* Unable to save the old value */
            if (status != ERROR_SUCCESS)
            {
                TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_SAVED_NET_ADDR, status);
                goto error;
            }
        }

        /* Write the new network address */
        size = _tcslen (mac_address) * sizeof (TCHAR);
        status = RegSetValueEx (key, CVY_NAME_NET_ADDR, 0L, CVY_TYPE_NET_ADDR,
                                (LPBYTE)mac_address, size);

        /* Unable to write the new address */
        if (status != ERROR_SUCCESS)
        {
            TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_NET_ADDR, status);
            goto error;
        }
    }
    else     // remove the address
    {
        /* If the saved field exists,
         * copy this address into the mac address
         * and remove the saved field and return.
         */

        size = sizeof (net_addr);
        status = RegQueryValueEx (key, CVY_NAME_SAVED_NET_ADDR, 0L, &type,
                                  (LPBYTE)net_addr, &size);

        if (status == ERROR_SUCCESS)
        {
            /* delete both fields if saved address is empty */
            if ((size == 0) || (_tcsicmp (net_addr, _TEXT("none")) == 0))
            {
                status = RegDeleteValue (key, CVY_NAME_SAVED_NET_ADDR);
                if (ERROR_SUCCESS != status)
                {
                    TRACE_CRIT("%!FUNC! registry delete for %ls failed with %d", CVY_NAME_SAVED_NET_ADDR, status);
                }

                status = RegDeleteValue (key, CVY_NAME_NET_ADDR);
                if (ERROR_SUCCESS != status)
                {
                    TRACE_CRIT("%!FUNC! registry delete for %ls failed with %d", CVY_NAME_NET_ADDR, status);
                }
            }
            else /* copy saved address as the network address and delete the saved address field */
            {
                status = RegDeleteValue (key, CVY_NAME_SAVED_NET_ADDR);
                if (ERROR_SUCCESS != status)
                {
                    TRACE_CRIT("%!FUNC! registry delete for %ls failed with %d", CVY_NAME_SAVED_NET_ADDR, status);
                }

                size = _tcslen (net_addr) * sizeof (TCHAR);
                status = RegSetValueEx (key, CVY_NAME_NET_ADDR, 0L, CVY_TYPE_NET_ADDR,
                                        (LPBYTE) net_addr, size);

                /* Unable to set the original address */
                if (status != ERROR_SUCCESS)
                {
                    TRACE_CRIT("%!FUNC! registry write for %ls failed with %d", CVY_NAME_NET_ADDR, status);
                    goto error;
                }
            }
        }
        else
        {
            TRACE_CRIT("%!FUNC! registry read for %ls failed with %d", CVY_NAME_SAVED_NET_ADDR, status);
        }
    }

    status = RegCloseKey (key);
    if (ERROR_SUCCESS != status)
    {
        TRACE_CRIT("%!FUNC! registry close failed");
    }

    key = NULL;

    TRACE_VERB("<-%!FUNC! return true");
    return true;

error:
    if (key != NULL)
    {
        status = RegCloseKey(key);
        if (ERROR_SUCCESS != status)
        {
            TRACE_CRIT("%!FUNC! registry close failed in error recovery code");
        }
    }

    if (hdi != NULL)
        SetupDiDestroyDeviceInfoList (hdi);

    TRACE_VERB("<-%!FUNC! return false");
    return false;
} 


//+----------------------------------------------------------------------------
//
// Function:  NotifyAdapterAddressChange
//
// Description:  Notify the adapter to reload MAC address 
//              The parameter is different from NotifyAdapterAddressChange.
//              Can not overload, because the function has to be exported
//
// Arguments: const WCHAR* driver_name - 
//
// Returns:   void WINAPI - 
//
// History: fengsun Created 5/20/00
//
//+----------------------------------------------------------------------------
void WINAPI NotifyAdapterAddressChange (const WCHAR * driver_name) {

    NotifyAdapterPropertyChange(driver_name, DICS_PROPCHANGE);
}

//+----------------------------------------------------------------------------
//
// Function:  NotifyAdapterAddressChangeEx
//
// Description:  Notify the adapter to reload MAC address 
//              The parameter is different from NotifyAdapterAddressChange.
//              Can not overload, because the function has to be exported
//
// Arguments: const WCHAR* driver_name - 
//            const GUID& AdapterGuid
//            bool bWaitAndQuery
//
// Returns:   void WINAPI - 
//
// History: fengsun Created 5/20/00
//          karthicn Edited 5/29/02 - Added the wait to "query" NLB to ensure that
//                                    the binding process is complete before we
//                                    return.
//
//+----------------------------------------------------------------------------
void WINAPI NotifyAdapterAddressChangeEx (const WCHAR * driver_name, const GUID& AdapterGuid, bool bWaitAndQuery) {

    TRACE_INFO("->%!FUNC! bWaitAndQuery = %ls", bWaitAndQuery ? L"TRUE" : L"FALSE"); 
    
    NotifyAdapterPropertyChange(driver_name, DICS_PROPCHANGE);

    /*
    In order for the network adapter to pick up the new mac address from the registry, it has
    to be disabled and re-enabled. During the disable, NLB and Tcp/Ip are Unbound from the
    network adapter and NLB respectively. During the re-enable, NLB and Tcp/ip are bound to
    the network adapter and NLB respectively. Because the function NotifyAdapterPropertyChange (called above)
    performs the disable and re-enable operation asynchronously, it returns BEFORE the operation
    is completed. The following block of code aims to wait until the operation is completed. We
    check for the completeness of the operation by querying the NLB driver. We are relying on
    the fact that the NLB driver does NOT reply to a Query when the binding process is ongoing.

    This wait is necessary due to the following reasons:
    1. Prompt for reboot when mac address change + ip address change from netconfig: 
       Say, a NLB parameter (like cluster ip) change that causes a mac address change is done from 
       Netconfig. In the same session, let us say that a ip address is changed in tcp/ip.
       If this wait was not there, we will return prematurely from this function and hence, from
       "ApplyPnPChanges" function in our notify object. This causes tcp/ip notify object's 
       "ApplyPnPChanges" function to be called. Tcp/ip's "ApplyPnPChanges" attempts to make 
       the ip address change, but finds that Tcp/ip is NOT yet bound to the network adapter (the
       binding process is not completed yet). Though it is able to add the ip address eventually, 
       it freaks out and pops up the prompt for reboot. 

    2. ParamCommitChanges returns prematurely: If this wait was not there, "ParamCommitChanges" which
       calls this function will return prematurely. The wmi provider (called by App. Center) and 
       NLB Manager provider call "ParamCommitChanges" and want the assurance that the process is
       complete when the function returns.

    -- KarthicN, 05-29-02
    */

    if (bWaitAndQuery == true) 
    {
        //
        // Max wait time = dwWaitBeforeInitial + (dwMaxNumOfRetries * dwWaitBeforeRetry)
        // Max attempts  = 1 + dwMaxNumOfRetries
        //
        //
        // Min wait time = dwWaitBeforeInitial
        // Min attempts  = 1
        //
        DWORD dwWaitBeforeInitial = 2000;
        DWORD dwWaitBeforeRetry   = 3000;
        DWORD dwMaxNumOfRetries   = 4;
        DWORD dwIdx               = 0;

        HANDLE  hTempDeviceWlbs;

        TRACE_INFO("%!FUNC! Sleeping (BEFORE attempt #1) for %d ms, Total Wait (including current) : %d ms, Max Wait: %d ms", 
                   dwWaitBeforeInitial, dwWaitBeforeInitial, dwWaitBeforeInitial + (dwMaxNumOfRetries * dwWaitBeforeRetry)); 

        Sleep(dwWaitBeforeInitial);

        while(true)
        {
            TRACE_INFO("%!FUNC! Calling (attempt #%d) CreateFile() to NLB driver", dwIdx+1);

            hTempDeviceWlbs = CreateFile(_TEXT("\\\\.\\WLBS"), GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
        
            if (hTempDeviceWlbs != INVALID_HANDLE_VALUE) 
            {
                IOCTL_CVY_BUF    in_buf;
                IOCTL_CVY_BUF    out_buf;

                // Send a "Query" IOCTL to the NLB driver
                DWORD dwRet = WlbsLocalControl (hTempDeviceWlbs, AdapterGuid, IOCTL_CVY_QUERY, & in_buf, & out_buf, NULL);

                CloseHandle(hTempDeviceWlbs);

                if (dwRet != WLBS_IO_ERROR) 
                {
                    TRACE_INFO("%!FUNC! Query (attempt #%d) to NLB driver SUCCEEDS, Breaking out... !!!", dwIdx+1);
                    break; // Break out of the while(true)
                }

                TRACE_INFO("%!FUNC! Query (attempt #%d) to NLB driver FAILS !!!", dwIdx+1); 
            }
            else // CreateFile() returned INVALID_HANDLE_VALUE
            {
                DWORD dwStatus = GetLastError();
                TRACE_INFO("%!FUNC! CreateFile() failed opening (attempt #%d) \\\\.\\WLBS device. Error is %d", dwIdx+1, dwStatus);
            }

            if (dwIdx++ >= dwMaxNumOfRetries)
            {
                TRACE_CRIT("%!FUNC! Exhausted the Max wait time (%d ms) and Query is still NOT successful. Giving up...", 
                           dwWaitBeforeInitial + (dwMaxNumOfRetries * dwWaitBeforeRetry));
                break;
            }

            TRACE_INFO("%!FUNC! Sleeping (BEFORE attempt #%d) for %d ms, Total Wait (including current) : %d ms, Max Wait: %d ms", 
                       dwIdx+1, dwWaitBeforeRetry, dwWaitBeforeInitial + (dwIdx * dwWaitBeforeRetry), 
                       dwWaitBeforeInitial + (dwMaxNumOfRetries * dwWaitBeforeRetry));

            Sleep(dwWaitBeforeRetry);
        }
    }

    TRACE_INFO("<-%!FUNC!");
}

/*
 * Function: NotifyAdapterPropertyChange
 * Description: Notify a device that a property change event has occurred.
 *              Event should be one of: DICS_PROPCHANGE, DICS_DISABLE, DICS_ENABLE
 * Author: shouse 7.17.00
 */
void WINAPI NotifyAdapterPropertyChange (const WCHAR * driver_name, DWORD eventFlag) {
    if (NULL == driver_name)
    {
        TRACE_VERB("->%!FUNC! NULL driver name, event flag %d", eventFlag);
    }
    else
    {
        TRACE_VERB("->%!FUNC! driver %ls, event flag %d", driver_name, eventFlag);
    }

    HDEVINFO            hdi = NULL;
    SP_DEVINFO_DATA     deid;

    
    hdi = SetupDiCreateDeviceInfoList (&GUID_DEVCLASS_NET, NULL);
    if (hdi == INVALID_HANDLE_VALUE)
    {
        TRACE_CRIT("%!FUNC! SetupDiCreateDeviceInfoList failed");
        goto end;
    }

    ZeroMemory(&deid, sizeof(deid));
    deid.cbSize = sizeof(deid);

    if (! SetupDiOpenDeviceInfo (hdi, driver_name, NULL, 0, &deid))
    {
        TRACE_CRIT("%!FUNC! SetupDiOpenDeviceInfo failed");
        goto end;
    }

    SP_PROPCHANGE_PARAMS    pcp;
    SP_DEVINSTALL_PARAMS    deip;

    ZeroMemory(&pcp, sizeof(pcp));

    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = eventFlag;
    pcp.Scope = DICS_FLAG_GLOBAL;
    pcp.HwProfile = 0;

    // Now we set the structure as the device info data's
    // class install params

    if (! SetupDiSetClassInstallParams(hdi, &deid,
                                       (PSP_CLASSINSTALL_HEADER)(&pcp),
                                       sizeof(pcp)))
    {
        TRACE_CRIT("%!FUNC! SetupDiSetClassInstallParams failed");
        goto end;
    }

    // Now we need to set the "we have a class install params" flag
    // in the device install params

    // initialize out parameter and set its cbSize field

    ZeroMemory(&deip, sizeof(SP_DEVINSTALL_PARAMS));
    deip.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    // get the header

    if (! SetupDiGetDeviceInstallParams(hdi, &deid, &deip))
    {
        TRACE_CRIT("%!FUNC! SetupDiGetDeviceInstallParams failed");
        goto end;
    }

    deip.Flags |= DI_CLASSINSTALLPARAMS;

    if (! SetupDiSetDeviceInstallParams(hdi, &deid, &deip))
    {
        TRACE_CRIT("%!FUNC! SetupDiSetDeviceInstallParams failed");
        goto end;
    }

    // Notify the driver that the state has changed

    if (! SetupDiCallClassInstaller(DIF_PROPERTYCHANGE, hdi, &deid))
    {
        TRACE_CRIT("%!FUNC! SetupDiCallClassInstaller failed");
        goto end;
    }

    // Set the properties change flag in the device info to
    // let anyone who cares know that their ui might need
    // updating to reflect any change in the device's status
    // We can't let any failures here stop us so we ignore
    // return values

    SetupDiGetDeviceInstallParams(hdi, &deid, &deip);

    deip.Flags |= DI_PROPERTIES_CHANGE;
    SetupDiSetDeviceInstallParams(hdi, &deid, &deip);

end:

    if (hdi != NULL)
        SetupDiDestroyDeviceInfoList (hdi);

    TRACE_VERB("<-%!FUNC!");
}

/*
 * Function: GetDeviceNameFromGUID
 * Description: Given a GUID, return the driver name.
 * Author: shouse 7.17.00
 */
void WINAPI GetDriverNameFromGUID (const GUID & AdapterGuid, OUT WCHAR * driver_name, DWORD size) {
    if (NULL == driver_name)
    {
        TRACE_VERB("->%!FUNC! NULL driver name");
    }
    else
    {
        TRACE_VERB("->%!FUNC! driver %ls", driver_name);
    }

    HKEY key = NULL;
    DWORD type;
    DWORD dwStatus = 0;
    
    if (!(key = RegOpenWlbsSetting(AdapterGuid, true)))
    {
        TRACE_CRIT("%!FUNC! failed opening nlb registry settings");
        TRACE_VERB("<-%!FUNC! on error");
        return;
    }

    dwStatus = RegQueryValueEx(key, CVY_NAME_CLUSTER_NIC, 0L, &type, (LPBYTE)driver_name, &size);
    if (ERROR_SUCCESS != dwStatus)
    {
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d", CVY_NAME_CLUSTER_NIC, dwStatus);
        // This code was added for tracing. There was not abort before so don't abort now.
    }
        
    dwStatus = RegCloseKey(key);
    if (ERROR_SUCCESS != dwStatus)
    {
        TRACE_CRIT("%!FUNC! registry close failed with %d", dwStatus);
        // This code was added for tracing. There was not abort before so don't abort now.
    }

    TRACE_VERB("<-%!FUNC! on error");
}

//+----------------------------------------------------------------------------
//
// Function:  RegReadAdapterIp
//
// Description: Read the adapter IP settings 
//
// Arguments: const GUID& AdapterGuid - 
//            OUT DWORD& dwClusterIp - 
//            OUT DWORD& dwDedicatedIp - 
//
// Returns:   bool - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
bool WINAPI RegReadAdapterIp(const GUID& AdapterGuid,   
        OUT DWORD& dwClusterIp, OUT DWORD& dwDedicatedIp)
{
    TRACE_VERB("->%!FUNC!");

    HKEY            key;
    LONG            status;
    DWORD           size;

    key = RegOpenWlbsSetting(AdapterGuid, true);

    if (key == NULL)
    {
        TRACE_CRIT("%!FUNC! failed to read nlb settings from registry");
        TRACE_VERB("<-%!FUNC! return false");
        return false;
    }

    bool local = false;

    TCHAR nic_name[CVY_STR_SIZE];      // Virtual NIC name
    size = sizeof (nic_name);
    status = RegQueryValueEx (key, CVY_NAME_VIRTUAL_NIC, 0L, NULL,
                              (LPBYTE) nic_name, & size);

    if (status == ERROR_SUCCESS)
    {
        TCHAR szIpAddress[CVY_STR_SIZE];
        size = sizeof (TCHAR) * CVY_STR_SIZE;
        status = RegQueryValueEx (key, CVY_NAME_CL_IP_ADDR, 0L, NULL,
                                      (LPBYTE) szIpAddress, & size);

        if (status == ERROR_SUCCESS)
        {
            dwClusterIp  = IpAddressFromAbcdWsz (szIpAddress);
            local = true;
        }
        else
        {
            TRACE_CRIT("%!FUNC! registry read for %ls failed with %d", CVY_NAME_CL_IP_ADDR, status);
        }

        status = RegQueryValueEx (key, CVY_NAME_DED_IP_ADDR, 0L, NULL,
                                 (LPBYTE) szIpAddress, & size);

        if (status == ERROR_SUCCESS)
        {
            dwDedicatedIp = IpAddressFromAbcdWsz (szIpAddress);
        }
        else
        {
            TRACE_CRIT("%!FUNC! registry read for %ls failed with %d", CVY_NAME_DED_IP_ADDR, status);
        }
    }
    else
    {
        TRACE_CRIT("%!FUNC! registry read for %ls failed with %d", CVY_NAME_VIRTUAL_NIC, status);
    }

    status = RegCloseKey (key);
    if (ERROR_SUCCESS != status)
    {
        TRACE_CRIT("%!FUNC! registry close failed with %d", status);
    }

    TRACE_VERB("<-%!FUNC! on error");
    return local;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\wlbsapi.c ===
/*
  NETWORK LOAD BALANCING - CONTROL API - TEST UTILITY


  Copyright (C), 1999 by Microsoft Corporation

  PROPRIETARY TRADE SECRET INFORMATION OF MICROSOFT CORPORATION

  The information contained in this file is not to be disclosed or copied in any
  form or distributed to a third party without written permission from Microsoft
  Corporation.

  THE SOFTWARE IS PROVIDED TO YOU "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
  EXPRESSED, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


     $Archive::                                                         $
    $Revision::                                                         $
      $Author::                                                         $
        $Date::                                                         $
     $Modtime::                                                         $
  $Nokeywords::                                                         $
*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <winsock.h>
#include <tchar.h>

#include "wlbsctrl.h"
#include "wlbsconfig.h"

#define stricmp strcmp


/* TYPES */


typedef enum
{
    query,
    suspend,
    resume,
    start,
    stop,
    drainstop,
    enable,
    disable,
    drain
}
WLBS_CMD;


/* GLOBALS */

#define BUF_SIZE 80
static CHAR            buf [BUF_SIZE];
static CHAR            buf2 [BUF_SIZE];
static TCHAR           tbuf [BUF_SIZE];
static TCHAR           tbuf2 [BUF_SIZE];
static WLBS_RESPONSE    resp [WLBS_MAX_HOSTS];


/* PROCEDURES */



void generate_port_rules ( PWLBS_PORT_RULE rules, DWORD num_rules, DWORD range );
void delete_all_rules ( PWLBS_REG_PARAMS reg_data );
void test_commit ( PWLBS_REG_PARAMS reg_data, BOOL flag1, BOOL flag2 );
DWORD testnewapi (void);

INT __cdecl _tmain
(
    INT             argc,
    PTCHAR          __targv []
)
{
    DWORD           ret;
    DWORD           status;
    INT             arg_index;
    WLBS_CMD        cmd;
    DWORD           port;
    DWORD           cluster;
    DWORD           host;
    PCHAR           hp;
    PTCHAR          thp;
    DWORD           i;
    DWORD           hosts;
    DWORD           host_map;
    DWORD           buf_size = BUF_SIZE;


    printf ("WLBS Control API V1.0 (c) 1999 by Microsoft Corporation\n");

    /* initialize convoy control routines */

    ret = WlbsInit (_TEXT(WLBS_PRODUCT_NAME), WLBS_API_VER, NULL);

    switch (ret)
    {
    case WLBS_PRESENT:
        printf ("Can execute remote and local commands.\n");
        break;

    case WLBS_REMOTE_ONLY:
        printf ("Can execute local commands.\n");
        break;

    case WLBS_LOCAL_ONLY:
        printf ("Can execute remote commands.\n");
        break;

    default:
        printf ("Error initializing API.\n");
        return 2;
    }


#if 0

    {
        WLBS_REG_PARAMS     params;
        DWORD               status;

        if ((status = WlbsLocalReadReg(& params)) != WLBS_OK)
        {
            printf("WlbsLocalReadReg error %d\n", status);
            return 1;
        }

        printf("WlbsLocalReadReg success\n");

        if (argc > 1)
            _tcsncpy(params.cl_ip_addr, _TEXT("172.31.240.176"), WLBS_MAX_CL_IP_ADDR);
        else
            _tcsncpy(params.cl_ip_addr, _TEXT("172.31.240.175"), WLBS_MAX_CL_IP_ADDR);

        if ((status = WlbsLocalWriteReg(& params)) != WLBS_OK)
        {
            printf("WlbsLocalWriteReg error %d\n", status);
            return 1;
        }

        printf("WlbsLocalWriteReg success\n");

        if ((status = WlbsLocalCommitChanges()) != WLBS_OK)
        {
            printf("WlbsLocalCommitChanges error %d\n", status);
            return 1;
        }

        printf("WlbsLocalCommitChanges success\n");

        return 1;
    }

#endif


    arg_index = 1;

    if (argc < 2)
        goto usage;

    /* parse command line arguments */

    if (_tcsicmp (__targv[arg_index], _TEXT("testnewapi")) == 0)
    {
        testnewapi();
        return 1;
    }
    if (_tcsicmp (__targv [arg_index], _TEXT("suspend")) == 0)
    {
        cmd = suspend;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("resume")) == 0)
    {
        cmd = resume;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("start")) == 0)
    {
        cmd = start;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("stop")) == 0)
    {
        cmd = stop;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("drainstop")) == 0)
    {
        cmd = drainstop;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("query")) == 0)
    {
        cmd = query;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("enable")) == 0)
    {
        arg_index ++;

        if (argc < 3)
            goto usage;

        if (_tcsicmp (__targv [arg_index], _TEXT("all")) == 0)
            port = WLBS_ALL_PORTS;
        else
            port = _ttoi (__targv [arg_index]);

        if (port == 0 && __targv [arg_index][0] != _TEXT('0'))
            goto usage;

        cmd = enable;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("disable")) == 0)
    {
        arg_index ++;

        if (argc < 3)
            goto usage;

        if (_tcsicmp (__targv [arg_index], _TEXT("all")) == 0)
            port = WLBS_ALL_PORTS;
        else
            port = _ttoi (__targv [arg_index]);

        if (port == 0 && __targv [arg_index][0] != _TEXT('0'))
            goto usage;

        cmd = disable;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("drain")) == 0)
    {
        arg_index ++;

        if (argc < 3)
            goto usage;

        if (_tcsicmp (__targv [arg_index], _TEXT("all")) == 0)
            port = WLBS_ALL_PORTS;
        else
            port = _ttoi (__targv [arg_index]);

        if (port == 0 && __targv [arg_index][0] != _TEXT('0'))
            goto usage;

        cmd = drain;
        arg_index ++;
    }
    else
        goto usage;

    cluster = WLBS_LOCAL_CLUSTER;
    host    = WLBS_LOCAL_HOST;

    /* parse remote command arguments */

    if (arg_index < argc)
    {
        thp = _tcschr (__targv [arg_index], _TEXT(':'));

        /* cluster-wide operation */

        if (thp == NULL)
        {
            cluster = WlbsResolve (__targv [arg_index]);

            if (cluster == 0)
            {
                _tprintf (_TEXT("Bad cluster %s\n"), __targv [arg_index]);
                return 1;
            }

            host = WLBS_ALL_HOSTS;
        }
        else
        {
            * thp = 0;
            thp ++;

            cluster = WlbsResolve (__targv [arg_index]);

            if (cluster == 0)
            {
                _tprintf (_TEXT("Bad cluster %s\n"), __targv [arg_index]);
                return 1;
            }

            if (_tcslen (thp) <= 2 && thp [0] >= _TEXT('0') && thp [0] <= _TEXT('9')
                && ((thp [1] >= _TEXT('0') && thp [1] <= _TEXT('9')) || thp [1] == 0))
            {
                host = _ttoi (thp);
            }
            else
            {
                host = WlbsResolve (thp);

                if (host == 0)
                {
                    _tprintf (_TEXT("Bad host %s\n"), thp);
                    return 1;
                }
            }
        }

        arg_index ++;

        /* parse remote control parameters */

        while (arg_index < argc)
        {
            if (__targv [arg_index] [0] == _TEXT('/') || __targv [arg_index] [0] == _TEXT('-'))
            {
                if (_tcsicmp (__targv [arg_index] + 1, _TEXT("PASSW")) == 0)
                {
                    arg_index ++;

                    if (arg_index >= argc || __targv [arg_index] [0] == _TEXT('/') ||
                        __targv [arg_index] [0] == _TEXT('-'))
                    {
                        printf ("Password: ");

                        for (i = 0; i < BUF_SIZE; i ++)
                        {
                            buf [i] = (CHAR) _getch ();

                            if (buf [i] == 13)
                            {
                                buf [i] = 0;
                                break;
                            }
                        }

                        printf ("\n");

                        if (i == 0)
                            WlbsPasswordSet (cluster, NULL);
                        else
                        {
#ifdef UNICODE
                            _stprintf (tbuf, _TEXT("%S"), buf);
#else
                            _stprintf (tbuf, _TEXT("%s"), buf);
#endif
                            WlbsPasswordSet (cluster, tbuf);
                        }
                    }
                    else
                    {
                        WlbsPasswordSet (cluster, __targv [arg_index]);
                        arg_index ++;
                    }

                }
                else if (_tcsicmp (__targv [arg_index] + 1, _TEXT("PORT")) == 0)
                {
                    arg_index ++;

                    if (arg_index >= argc || __targv [arg_index] [0] == _TEXT('/') ||
                        __targv [arg_index] [0] == _TEXT('-'))
                        goto usage;

                    WlbsPortSet (cluster, (USHORT) _ttoi (__targv [arg_index]));

                    if (port == 0)
                        goto usage;

                    arg_index ++;
                }
                else if (_tcsicmp (__targv [arg_index] + 1, _TEXT("DEST")) == 0)
                {
                    arg_index ++;

                    if (arg_index >= argc || __targv [arg_index] [0] == _TEXT('/') ||
                        __targv [arg_index] [0] == _TEXT('-'))
                        goto usage;

                    WlbsDestinationSet (cluster, WlbsResolve (__targv [arg_index]));
                    arg_index ++;
                }
                else if (_tcsicmp (__targv [arg_index] + 1, _TEXT("TIMEOUT")) == 0)
                {
                    arg_index ++;

                    if (arg_index >= argc || __targv [arg_index] [0] == _TEXT('/') ||
                        __targv [arg_index] [0] == _TEXT('-'))
                        goto usage;

                    WlbsTimeoutSet (cluster, _ttoi (__targv [arg_index]));
                    arg_index ++;
                }
                else
                    goto usage;
            }
            else
                goto usage;
        }
    }

    /* execute command */

    hosts = WLBS_MAX_HOSTS;

    switch (cmd)
    {

    case query:

        status = WlbsQuery (cluster, host, resp, &hosts, &host_map, NULL);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_STOPPED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts are stopped.\n");
            else
                printf ("Cluster host %d is stopped.\n", resp [0] . id);

            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts are suspended.\n");
            else
                printf ("Cluster host %d is suspended.\n", resp [0] . id);

            break;

        case WLBS_CONVERGING:

            if (host == WLBS_ALL_HOSTS)
                printf ("Cluster is converging.\n");
            else
                printf ("Cluster host %d is converging.\n", resp [0] . id);

            break;

        case WLBS_DRAINING:

            if (host == WLBS_ALL_HOSTS)
                printf ("Cluster is draining.\n");
            else
                printf ("Cluster host %d is draining.\n", resp [0] . id);

            break;

        case WLBS_CONVERGED:

            printf ("Cluster host %d is converged.\n", resp [0] . id);
            break;

        case WLBS_DEFAULT:

            printf ("Cluster host %d is converged as DEFAULT.\n", resp [0] . id);
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }

            printf ("There are %d active hosts in the cluster.\n", status);
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_STOPPED:
                    printf ("stopped\n");
                    break;

                case WLBS_CONVERGING:
                    printf ("converging\n");
                    break;

                case WLBS_DRAINING:
                    printf ("draining\n");
                    break;

                case WLBS_CONVERGED:
                    printf ("converged\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("suspended\n");
                    break;

                case WLBS_DEFAULT:
                    printf ("converged as DEFAULT\n");
                    break;
                }
            }

        }
        else
        {
            BOOL       first = TRUE;

            printf ("The following hosts are part of the cluster:\n");

            for (i = 0; i < 32; i ++)
            {
                if (host_map & (1 << i))
                {
                    if (! first)
                        printf (", ");
                    else
                        first = FALSE;

                    printf ("%d", i + 1);
                }
            }

            printf ("\n");
        }


        break;

    case suspend:

        status = WlbsSuspend (cluster, host, resp, & hosts);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        case WLBS_ALREADY:

            printf ("Cluster mode control already suspended.\n");
            break;

        case WLBS_DRAIN_STOP:

            printf ("Cluster mode control suspended; draining preempted.\n");
            break;

        case WLBS_STOPPED:

            printf ("Cluster mode stopped and control suspended.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("suspended\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already suspended\n");
                    break;

                case WLBS_DRAIN_STOP:
                    printf ("suspended from draining\n");
                    break;

                case WLBS_STOPPED:
                    printf ("stopped and suspended\n");
                    break;
                }
            }

        }

        break;

    case resume:

        status = WlbsResume (cluster, host, resp, & hosts);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts resumed.\n");
            else
                printf ("Cluster mode control resumed.\n");

            break;

        case WLBS_ALREADY:

            printf ("Cluster mode control already resumed.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("resumed\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already resumed\n");
                    break;
                }
            }

        }

        break;

    case start:

        status = WlbsStart (cluster, host, resp, & hosts);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts started.\n");
            else
                printf ("Cluster mode started.\n");

            break;

        case WLBS_BAD_PARAMS:

            if (host == WLBS_ALL_HOSTS)
                printf ("Some host(s) could not start cluster mode due to parameter errors.\n");
            else
                printf ("Could not start cluster mode due to parameter errors.\n");

            break;

        case WLBS_ALREADY:

            printf ("Cluster mode already started.\n");
            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        case WLBS_DRAIN_STOP:

            printf ("Cluster mode started; draining preempted.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("started\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already started\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("control suspended\n");
                    break;

                case WLBS_DRAIN_STOP:
                    printf ("started from draining\n");
                    break;

                case WLBS_BAD_PARAMS:
                    printf ("bad parameters\n");
                    break;
                }
            }

        }

        break;


    case stop:

        status = WlbsStop (cluster, host, resp, & hosts);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts stopped.\n");
            else
                printf ("Cluster mode stopped.\n");

            break;

        case WLBS_ALREADY:

            printf ("Cluster mode already stopped.\n");
            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        case WLBS_DRAIN_STOP:

            printf ("Cluster mode stopped; draining preempted.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("stopped\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already stopped\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("control suspended\n");
                    break;

                case WLBS_DRAIN_STOP:
                    printf ("stopped from draining\n");
                    break;
                }
            }

        }

        break;

    case drainstop:

        status = WlbsDrainStop (cluster, host, resp, & hosts);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts set to drain.\n");
            else
                printf ("Draining started.\n");

            break;

        case WLBS_STOPPED:

            if (host == WLBS_ALL_HOSTS)
                printf ("Cluster mode stopped on all hosts.\n");
            else
                printf ("Cluster mode stopped.\n");

            break;

        case WLBS_ALREADY:

            printf ("Already draining.\n");
            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("draining\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already draining\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("control suspended\n");
                    break;

                case WLBS_STOPPED:
                    printf ("stopped\n");
                    break;
                }
            }

        }

        break;

    case enable:

        status = WlbsEnable (cluster, host, resp, & hosts, port);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("Port rule(s) enabled on all started hosts.\n");
            else
                printf ("Port rule(s) enabled.\n");

            break;

        case WLBS_NOT_FOUND:

            if (host == WLBS_ALL_HOSTS)
                printf ("Port rule does not exist on some host(s).\n");
            else
                printf ("Port rule does not exist.\n");

            break;

        case WLBS_STOPPED:

            printf ("Cluster mode stopped.\n");
            break;

        case WLBS_ALREADY:

            printf ("Already enabled.\n");
            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        case WLBS_DRAINING:

            printf ("Host is draining.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("enabled\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already enabled\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("control suspended\n");
                    break;

                case WLBS_STOPPED:
                    printf ("stopped\n");
                    break;

                case WLBS_DRAINING:
                    printf ("draining\n");
                    break;

                case WLBS_NOT_FOUND:
                    printf ("not found\n");
                    break;
                }
            }

        }

        break;

    case disable:

        status = WlbsDisable (cluster, host, resp, & hosts, port);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("Port rule(s) disabled on all started hosts.\n");
            else
                printf ("Port rule(s) disabled.\n");

            break;

        case WLBS_NOT_FOUND:

            if (host == WLBS_ALL_HOSTS)
                printf ("Port rule does not exist on some host(s).\n");
            else
                printf ("Port rule does not exist.\n");

            break;

        case WLBS_STOPPED:

            printf ("Cluster mode stopped.\n");
            break;

        case WLBS_ALREADY:

            printf ("Already disabled.\n");
            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        case WLBS_DRAINING:

            printf ("Host is draining.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("disabled\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already disabled\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("control suspended\n");
                    break;

                case WLBS_STOPPED:
                    printf ("stopped\n");
                    break;

                case WLBS_DRAINING:
                    printf ("draining\n");
                    break;

                case WLBS_NOT_FOUND:
                    printf ("not found\n");
                    break;
                }
            }

        }

        break;

    case drain:
        status = WlbsDrain (cluster, host, resp, & hosts, port);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("Port rule(s) set to drain on all started hosts.\n");
            else
                printf ("Port rule(s) set to drain.\n");

            break;

        case WLBS_NOT_FOUND:

            if (host == WLBS_ALL_HOSTS)
                printf ("Port rule does not exist on some host(s).\n");
            else
                printf ("Port rule does not exist.\n");

            break;

        case WLBS_STOPPED:

            printf ("Cluster mode stopped.\n");
            break;

        case WLBS_ALREADY:

            printf ("Already disabled.\n");
            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        case WLBS_DRAINING:

            printf ("Host is draining.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("set to drain\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already draining\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("control suspended\n");
                    break;

                case WLBS_STOPPED:
                    printf ("stopped\n");
                    break;

                case WLBS_DRAINING:
                    printf ("draining\n");
                    break;

                case WLBS_NOT_FOUND:
                    printf ("not found\n");
                    break;
                }
            }

        }

        break;

    default:
        break;
    }

    return 0;

    usage:

    printf ("Usage: %s <command> [<cluster>[:<host>] [/PASSW [<password>]] [/PORT <port>]\n       [/DEST <destination>] [/TIMEOUT <msec>]]\n", __targv [0]);
    printf ("<command>\n");
    printf ("   query                - queries which hosts are currently part of the cluster\n");
    printf ("   suspend              - suspend control over cluster operations\n");
    printf ("   resume               - resume control over cluster operations\n");
    printf ("   start                - starts WLBS cluster operations\n");
    printf ("   stop                 - stops WLBS cluster operations\n");
    printf ("   drainstop            - finishes all existing connections and\n");
    printf ("                          stops WLBS cluster operations\n");
    printf ("   enable  <port> | ALL - enables traffic for <port> rule or ALL ports\n");
    printf ("   disable <port> | ALL - disables ALL traffic for <port> rule or ALL ports\n");
    printf ("   drain   <port> | ALL - disables NEW traffic for <port> rule or ALL ports\n");
    printf ("Remote options:\n");
    printf ("    <cluster>           - cluster name | cluster primary IP address\n");
    printf ("    <host>              - host within the cluster (default - ALL hosts):\n");
    printf ("                          dedicated name | IP address |\n");
    printf ("                          host priority ID (1..32) | 0 for current DEFAULT host\n");
    printf ("    /PASSW <password>   - remote control password (default - NONE)\n");
    printf ("                          blank <password> for console prompt\n");
    printf ("    /PORT <port>        - cluster's remote control UDP port (default - 1717)\n");
    printf ("    /DEST <destination> - alternative destination to send control messages:\n");
    printf ("                          system name | IP address (default - <cluster>)\n");
    printf ("    /TIMEOUT <msecs>    - set timeout for awaiting replies from the cluster\n");
    printf ("                          (default - 10,000)\n");

    return 1;

}




void generate_port_rules ( PWLBS_PORT_RULE rules, DWORD num_rules, DWORD range )
{

    DWORD i;
    static DWORD pri = 1;

    for (i = 0 ; i < num_rules ; i++)
    {
        rules [i] . start_port = i * range;
        rules [i] . end_port = rules [i] . start_port + range - 1;
        rules [i] . mode = WLBS_SINGLE;
        rules [i] . mode = (pri++) % 4 + 1;
        rules [i] . mode = WLBS_MULTI;
        rules [i] . protocol = WLBS_TCP_UDP;

        rules [i] . protocol = (pri++) %4 + 1;
        rules [i] . valid = rand();
        /* The following is just for testing */
        /* rules [i] . end_port = rules [i] . start_port - 1; */

        if (rules [i] . mode == WLBS_SINGLE)
        {
            rules [i] . mode_data . single . priority =  (pri++) % (WLBS_MAX_HOSTS + 6) + 1;
        }

        if (rules [i] . mode == WLBS_MULTI)
        {
            rules [i] . mode_data . multi . affinity = (WORD) ((pri++) % 4);
            rules [i] . mode_data . multi . equal_load = (WORD) ((pri++) % 3);
            rules [i] . mode_data . multi . load = (WORD) ((pri++) % 110);
        }
    }
    return;
}



void delete_all_rules ( PWLBS_REG_PARAMS reg_data )
{
    WLBS_PORT_RULE rules [WLBS_MAX_RULES];
    DWORD num_rules;
    DWORD i;

    num_rules = WlbsGetNumPortRules ( reg_data );
    printf("num_rules is %d\n", num_rules);

    WlbsEnumPortRules ( reg_data, rules, & num_rules );
    printf("num_rules is %d\n", num_rules);

    for (i = 0 ; i < num_rules ; i++)
    {
        if (TRUE)
        {
            printf("Deleting rule %d start %d result %d\n",i,
                   rules [i] . start_port,
                   WlbsDeletePortRule ( reg_data, rules [i] . start_port ) );
        }
    }
    printf("Number of rules in registry is %d\n", WlbsGetNumPortRules ( reg_data ) );
    return;
}


void test_commit ( PWLBS_REG_PARAMS reg_data, BOOL flag1, BOOL flag2 )
{
    /* read from the registry
     * change some values to cause only a reload
     * write and check the return value of commit
     */
    DWORD retval;

    if (flag1)
    {
        retval = WlbsReadReg (WLBS_LOCAL_CLUSTER, reg_data);
        if (retval != WLBS_OK)
        {
            printf("1:Error in reading from the registry\n");
            return;
        }

        /* randomly change some values */
        reg_data -> host_priority = 2;
        reg_data -> alive_period = 1000;
        _stprintf ( reg_data -> domain_name, _TEXT("rkcluster.domain.com"));

        retval = WlbsWriteReg (WLBS_LOCAL_CLUSTER, reg_data);
        if (retval != WLBS_OK)
        {
            printf("1:Error in writing to the registry\n");
            return;
        }

        retval = WlbsCommitChanges (WLBS_LOCAL_CLUSTER);
        if (retval == WLBS_OK)
        {
            printf("1:Successfully reloaded\n");
        }
        else if (retval == WLBS_REBOOT)
        {
            printf("1:Reboot required\n");
        }
        else
        {
            printf("1:retval was neither ok nor reboot\n");
        }
    }
    /* read from the registry
     * change cl_ip_addr or mcast_support or set i_convert_mac to false and set some mac addr
     * write and check the return value of commit
     */

    if (!flag2)
    {
        return;
    }

    retval = WlbsReadReg (WLBS_LOCAL_CLUSTER, reg_data);
    if (retval != WLBS_OK)
    {
        printf("2:Error in reading from the registry\n");
        return;
    }

    {
        /* change the cl_ip_addr */
        _stprintf (reg_data -> cl_ip_addr, _TEXT("10.0.0.200"));

        reg_data -> mcast_support = FALSE;

        reg_data -> i_convert_mac = FALSE;
        _stprintf ( reg_data -> cl_mac_addr, _TEXT("00-bf-ab-cd-ef-13"));

        _tprintf(_TEXT("The original cl net mask is %s\n"), reg_data -> cl_net_mask );
        _tprintf(_TEXT("The original ded net mask is %s\n"), reg_data -> ded_net_mask );
        _stprintf ( reg_data -> cl_net_mask, _TEXT("255.255.255.0"));
        _stprintf ( reg_data -> ded_net_mask , _TEXT("255.255.255.0"));

        _tprintf(_TEXT("The new ip address should be %s\n"), reg_data -> cl_ip_addr);
        _tprintf(_TEXT("The length of the string %d\n"), _tcslen (reg_data -> cl_ip_addr));
    }

    retval = WlbsWriteReg (WLBS_LOCAL_CLUSTER, reg_data);
    if (retval != WLBS_OK)
    {
        printf("2:Error in writing to the registry\n");
        return;
    }

_tprintf (_TEXT("The mac address should be %s"), reg_data -> cl_mac_addr);
    retval = WlbsCommitChanges (WLBS_LOCAL_CLUSTER);
    if (retval == WLBS_OK)
    {
        printf("2:Successfully reloaded\n");
        return;
    }
    else if (retval == WLBS_REBOOT)
    {
        printf("2:Reboot required\n");
        return;
    }
    else if (retval == WLBS_REG_ERROR)
    {
        printf("2:RegError\n");
        return;
    }
    printf("2:The retval from commit was neither ok nor reboot\n");
    return;
}


DWORD testnewapi (void)
{

        WLBS_REG_PARAMS reg_data;
        WLBS_PORT_RULE  rule;
        WLBS_PORT_RULE  rules_list [ 100 ];
        DWORD num_rules = 0;
        DWORD range = 0;
        DWORD status = 0;
        TCHAR * newdomainname = _TEXT("rkcluster.domain.com");
        DWORD i,k;

        DWORD host_map = 0;
        WLBS_RESPONSE response [3];
        DWORD size = 3;
/*
        status = WlbsQuery (WLBS_LOCAL_CLUSTER, 1, response, &size, &host_map, NULL);
        printf("Query status is %d size = %d\n", status, size);
        printf("response is %d %d %x\n", response [0] . id, response [0] . status, response [0] . address);
        printf("response is %d %d %x\n", response [1] . id, response [1] . status, response [1] . address);
        return 0;
  */      
        
        status = WlbsReadReg(WLBS_LOCAL_CLUSTER, &reg_data);

        if (status == WLBS_INIT_ERROR)
        {
            printf ("WlbsReadReg returned an init error\n");
            return 0;
        }

        printf("Printing the TCHAR fields in the reg_data structure\n");
        _tprintf (_TEXT("virtual_nic_name %s\n"), reg_data . i_virtual_nic_name );
        _tprintf (_TEXT("cl_mac_addr      %s\n"), reg_data . cl_mac_addr        );
        _tprintf (_TEXT("cl_ip_addr       %s\n"), reg_data . cl_ip_addr         );
        _tprintf (_TEXT("cl_net_mask      %s\n"), reg_data . cl_net_mask        );
        _tprintf (_TEXT("ded_ip_addr      %s\n"), reg_data . ded_ip_addr        );
        _tprintf (_TEXT("ded_net_mask     %s\n"), reg_data . ded_net_mask       );
        _tprintf (_TEXT("domain_name      %s\n"), reg_data . domain_name        );
        _tprintf (_TEXT("i_license_key    %s\n"), reg_data . i_license_key      );

/*        test_commit ( &reg_data, TRUE, TRUE);
        return 1;
        reg_data . host_priority = 31;
*/
        WlbsSetRemotePassword ( & reg_data, _TEXT(""));

        status = WlbsWriteReg(WLBS_LOCAL_CLUSTER, &reg_data);
        printf("WlbsWriteReg returned %d\n", status);
        return 1;

        memset ((void *) &reg_data, 0, sizeof (WLBS_REG_PARAMS));

        if (WlbsReadReg (WLBS_LOCAL_CLUSTER, &reg_data) == WLBS_INIT_ERROR)
        {
            printf ("WlbsReadReg returned an init error\n");
            return 0;
        }
        _tprintf(_TEXT("Read again from the registry. Domain name %s\n"), reg_data . domain_name );

        printf("The new host priority is %d\n", reg_data . host_priority);

        if (FALSE)
        {
            printf("checking the get num port rules function\n");

            num_rules = WlbsGetNumPortRules ( & reg_data );
            printf("num of rules is %d\n", num_rules );

            printf("checking the get num port rules function\n");
            printf("num of rules is %d\n", WlbsGetNumPortRules ( &reg_data) );

            printf("Writing to the registry %d\n", WlbsWriteReg(WLBS_LOCAL_CLUSTER,  &reg_data) );
            WlbsCommitChanges (WLBS_LOCAL_CLUSTER);

            memset ((void *) &reg_data, 0, sizeof (WLBS_REG_PARAMS));

            if (WlbsReadReg (WLBS_LOCAL_CLUSTER, &reg_data) == WLBS_INIT_ERROR)
            {
                printf ("WlbsReadReg returned an init error\n");
                return 0;
            }

        for (k=0;k<1;k++)
        {
            delete_all_rules ( &reg_data );
            printf("Deleted all the port rules. Num of rules now is %d\n", reg_data . i_num_rules);
            if (TRUE)
            {

                num_rules = 100;
                range = 600;
                generate_port_rules ( rules_list, num_rules, range );
                rules_list [0] . mode = WLBS_SINGLE;
                rules_list [0] . mode_data . single . priority = 5;

                for (i = 0 ; i < num_rules; i++)
                {
                    DWORD status = WlbsAddPortRule (&reg_data, &rules_list [i]);
                    printf("Adding port rule start %d end %d rule # %d result %d\n",
                           rules_list[i] . start_port,
                           rules_list[i] . end_port,
                           i,
                           status);
                }

                printf("Number of rules is %d\n", WlbsGetNumPortRules ( &reg_data ) );
            }

            printf("Writing the changes to the registry\n");
            WlbsWriteReg (WLBS_LOCAL_CLUSTER, &reg_data);
            WlbsCommitChanges (WLBS_LOCAL_CLUSTER);
        }
    }

    for (i=0; i<1; i++)
    {
        memset ( &reg_data, 0, sizeof (reg_data));
        WlbsReadReg (WLBS_LOCAL_CLUSTER, &reg_data);
        reg_data . host_priority = i%32 + 1;
        WlbsWriteReg (WLBS_LOCAL_CLUSTER, &reg_data);
        WlbsCommitChanges (WLBS_LOCAL_CLUSTER);
    }
        test_commit (&reg_data, TRUE, TRUE);
        return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\wrapper.cpp ===
#include "precomp.h"

#include <debug.h>
#include "cluster.h"
#include "control.h"
#include "param.h"

CWlbsControl g_WlbsControl;



DWORD WINAPI WlbsInit
(
    PTCHAR          product,
    DWORD           version,
    PVOID           reserved
)
{
    return g_WlbsControl.Initialize();
}


DWORD WINAPI WlbsQuery
(
    DWORD               cluster,
    DWORD               host,
    PWLBS_RESPONSE      response,
    PDWORD              num_hosts,
    PDWORD              host_map,
    PFN_QUERY_CALLBACK  pfnQueryCallBack
)
{
    return g_WlbsControl.WlbsQuery(cluster, host, response,num_hosts, host_map, pfnQueryCallBack);
}

DWORD WINAPI WlbsQueryState
(
    DWORD          cluster,
    DWORD          host,
    DWORD          operation,
    PNLB_OPTIONS   pOptions,
    PWLBS_RESPONSE pResponse,
    PDWORD         pcResponses
)
{
    return g_WlbsControl.WlbsQueryState(cluster, host, operation, pOptions, pResponse, pcResponses);
}

DWORD WINAPI WlbsSuspend
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    return g_WlbsControl.WlbsSuspend(cluster, host, response, num_hosts);
}

DWORD WINAPI WlbsResume
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    return g_WlbsControl.WlbsResume(cluster, host, response, num_hosts);
}

DWORD WINAPI WlbsStart
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    return g_WlbsControl.WlbsStart(cluster, host, response, num_hosts);
}

DWORD WINAPI WlbsStop
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    return g_WlbsControl.WlbsStop(cluster, host, response, num_hosts);
}

DWORD WINAPI WlbsDrainStop
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    return g_WlbsControl.WlbsDrainStop(cluster, host, response, num_hosts);
}

DWORD WINAPI WlbsEnable
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            vip,
    DWORD            port
)
{
    return g_WlbsControl.WlbsEnable(cluster, host, response, num_hosts, vip, port);
}

DWORD WINAPI WlbsDisable
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            vip,
    DWORD            port
)
{
    return g_WlbsControl.WlbsDisable(cluster, host, response, num_hosts, vip, port);
}

DWORD WINAPI WlbsDrain
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            vip,
    DWORD            port
)
{
    return g_WlbsControl.WlbsDrain(cluster, host, response, num_hosts, vip, port);
}

DWORD WINAPI WlbsResolve
(
    const WCHAR*           address
)
{
    struct hostent *  host;
    char   buf[256];

    if (address == NULL)
        return 0;

    unsigned long addr = IpAddressFromAbcdWsz (address);

    if (addr != INADDR_NONE)
    {
        return addr;
    }

    if (!WideCharToMultiByte(CP_ACP, 0, address, -1, buf, sizeof(buf), NULL, NULL))
        return 0;

    host = gethostbyname (buf);

    if (host == NULL)
        return 0;

    return((struct in_addr *) (host -> h_addr)) -> s_addr;

} /* end WlbsResolve */

#define MAXIPSTRLEN WLBS_MAX_CL_IP_ADDR + 1

BOOL WINAPI WlbsAddressToString
(
    DWORD           address,
    PTCHAR          buf,
    PDWORD          lenp
)
{
    PCHAR temp;
    DWORD len;

    if ( lenp == NULL )
        return FALSE;

    if (*lenp < MAXIPSTRLEN)
        return FALSE;
        
    AbcdWszFromIpAddress(address, buf, *lenp);
    *lenp=lstrlen(buf);
    
    return TRUE;

} /* end WlbsAddressToString */


BOOL WINAPI WlbsAddressToName
(
    DWORD           address,
    PTCHAR          buf,
    PDWORD          lenp
)
{
    struct hostent * name;
    DWORD len;
    HRESULT hresult;

    if ( lenp == NULL )
        return FALSE;

    name = gethostbyaddr ((char *) & address, sizeof (DWORD), AF_INET);

    if (name == NULL)
    {
        *lenp = 0;
        return FALSE;
    }

    len = strlen (name -> h_name) + 1;

    /* This is to prevent stprintf from breaking */
    if (*lenp > 0)
    {
        name -> h_name [*lenp - 1] = 0;
        hresult = StringCchPrintf (buf, *lenp, L"%S", name -> h_name);
        if (FAILED(hresult)) 
        {
            return FALSE;
        }
    }

    if (len > *lenp)
    {
        *lenp = len;
        return FALSE;
    }

    *lenp = len;
    return TRUE;

} /* end WlbsAddressToName */


VOID WINAPI WlbsPortSet
(
    DWORD           cluster,
    WORD            port
)
{
    g_WlbsControl.WlbsPortSet(cluster, port);
}

VOID WINAPI WlbsPasswordSet
(
    DWORD           cluster,
    PTCHAR          password
)
{
    g_WlbsControl.WlbsPasswordSet(cluster, password);
}

VOID WINAPI WlbsCodeSet
(
    DWORD           cluster,
    DWORD           passw
)
{
    g_WlbsControl.WlbsCodeSet(cluster, passw);
}

VOID WINAPI WlbsDestinationSet
(
    DWORD           cluster,
    DWORD           dest
)
{
    g_WlbsControl.WlbsDestinationSet(cluster, dest);
}

VOID WINAPI WlbsTimeoutSet
(
    DWORD           cluster,
    DWORD           milliseconds
)
{
    g_WlbsControl.WlbsTimeoutSet(cluster, milliseconds);
}




//+----------------------------------------------------------------------------
//
// Function:  WlbsReadReg
//
// Description:  
//
// Arguments: WORD           cluster - 
//            PWLBS_REG_PARAMS reg_data
//
// Returns:   DWORD WINAPI - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI WlbsReadReg(
    DWORD           cluster,
    PWLBS_REG_PARAMS reg_data
)
{
    CWlbsCluster* pCluster = g_WlbsControl.GetClusterFromIpOrIndex(cluster);

    if(pCluster == NULL)
    {
        return WLBS_NOT_FOUND;
    }

    return pCluster->ReadConfig(reg_data);
}



//+----------------------------------------------------------------------------
//
// Function:  WlbsWriteReg
//
// Description:  
//
// Arguments: WORD           cluster - 
//            PWLBS_REG_PARAMS reg_data
//
// Returns:   DWORD WINAPI - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI WlbsWriteReg(
    DWORD           cluster,
    const PWLBS_REG_PARAMS reg_data
)
{
    CWlbsCluster* pCluster = g_WlbsControl.GetClusterFromIpOrIndex(cluster);

    if(pCluster == NULL)
    {
        return WLBS_NOT_FOUND;
    }

    return pCluster->WriteConfig(reg_data);
}



//+----------------------------------------------------------------------------
//
// Function:  WlbsCommitChanges
//
// Description:  
//
// Arguments: DWORD cluster - 
//
// Returns:   DWORD WINAPI - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI WlbsCommitChanges(DWORD cluster)
{
    CWlbsCluster* pCluster = g_WlbsControl.GetClusterFromIpOrIndex(cluster);

    if(pCluster == NULL)
    {
        return WLBS_NOT_FOUND;
    }

    return pCluster->CommitChanges(&g_WlbsControl);
}

DWORD WINAPI WlbsSetDefaults
(
    PWLBS_REG_PARAMS    reg_data
)
{
    return ParamSetDefaults(reg_data);
}


BOOL WINAPI WlbsFormatMessage
(
    DWORD,            // error,
    WLBS_COMMAND,     // command,
    BOOL,             // cluster
    PTCHAR          messagep,
    PDWORD          lenp
)
{
    DWORD           len;
    PTSTR           error_str = _TEXT("Not yet implemented");

    len = _tcslen(error_str) + 1;

    /* This is to prevent stprintf from breaking */

    if (lenp == NULL)
        return FALSE;

    if (*lenp == 0)
    {
        *lenp = len;
        return FALSE;
    }

    // CODE REVIEW : Null terminate messagep. Verify that *lenp is the correct length (ie. length of destination)
    _tcsncpy(messagep, error_str, *lenp);
    messagep[*lenp - 1] = 0;

    if (len > *lenp)
    {
        *lenp = len;
        return FALSE;
    }

    *lenp = len;
    return TRUE;

} /* end WlbsFormatMessage */

DWORD WINAPI WlbsEnumClusters(OUT DWORD* pdwAddresses, OUT DWORD* pdwNum)
{
    return g_WlbsControl.EnumClusters(pdwAddresses, pdwNum);
}



//+----------------------------------------------------------------------------
//
// Function:  WlbsGetAdapterGuid
//
// Description:  
//
// Arguments: IN DWORD cluster - 
//            OUT GUID* pAdapterGuid - 
//
// Returns:   DWORD WINAPI - 
//
// History:   fengsun Created Header    3/10/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI WlbsGetAdapterGuid(IN DWORD cluster, OUT GUID* pAdapterGuid)
{
    ASSERT(pAdapterGuid);

    if (pAdapterGuid == NULL)
    {
        return WLBS_BAD_PARAMS;
    }

    CWlbsCluster* pCluster = g_WlbsControl.GetClusterFromIpOrIndex(cluster);

    if(pCluster == NULL)
    {
        return WLBS_NOT_FOUND;
    }

    *pAdapterGuid = pCluster->GetAdapterGuid();

    return WLBS_OK;
}



//+----------------------------------------------------------------------------
//
// Function:  WlbsNotifyConfigChange
//
// Description:  
//
// Arguments: DWORD cluster - 
//
// Returns:   DWORD WINAPI - 
//
// History: fengsun  Created Header    7/3/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI WlbsNotifyConfigChange(DWORD cluster)
{
    CWlbsCluster* pCluster = g_WlbsControl.GetClusterFromIpOrIndex(cluster);

    if(pCluster == NULL)
    {
        return WLBS_NOT_FOUND;
    }

    DWORD dwStatus = NotifyDriverConfigChanges(g_WlbsControl.GetDriverHandle(), pCluster->GetAdapterGuid());

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\componentdef\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\test\notify\random\main.cpp ===
#include <stdio.h>
#include <string.h>
#include <wchar.h>                            
#include <winsock2.h>

#include "wlbsctrl.h"

int __cdecl wmain (int argc, WCHAR ** argv) {

    NLBNotificationConnectionUp    pfnConnectionUp = NULL;
    NLBNotificationConnectionDown  pfnConnectionDown = NULL;
    NLBNotificationConnectionReset pfnConnectionReset = NULL;
    HINSTANCE                      hDLL = NULL;

    DWORD dwNLBStatus = 0;
    DWORD dwStatus = 0;
    struct in_addr daddr;
    char cluster[19];
    char *temp;

    bool  bUp = false;
    bool  bDown = false;
    bool  bReset = false;
    DWORD clus = 0;
    char *base = "192.1.1.1";
    ULONG baseDec;
    ULONG baseI, baseJ, baseK;
    DWORD dwCount;
    int i; 
    int j;
    int k;
    int counter;

    if (argc < 4) goto usage;

    if (!lstrcmpi(argv[1], L"-up")) {
        bUp = true;
    } else if (!lstrcmpi(argv[1], L"-down")) {
        bDown = true;
    } else if (!lstrcmpi(argv[1], L"-reset")) {
        bReset = true;
    } else goto usage;
                
    dwCount = _wtoi(argv[2]);

    if (dwCount == 0)
        goto usage;

    if (!WideCharToMultiByte(CP_ACP, 0, argv[3], -1, cluster, sizeof(cluster), NULL, NULL)) goto usage;

    clus = inet_addr(cluster);

    printf("cluster ip: %s (%08x)\n", cluster, clus);

    hDLL = LoadLibrary(L"wlbsctrl.dll");

    if (!hDLL) {
        dwStatus = GetLastError();
        printf("Unable to open wlbsctrl.dll... GetLastError() returned %u\n", dwStatus);
        return -1;
    }

    pfnConnectionUp    = (NLBNotificationConnectionUp)GetProcAddress(hDLL, "WlbsConnectionUp");
    pfnConnectionDown  = (NLBNotificationConnectionDown)GetProcAddress(hDLL, "WlbsConnectionDown");
    pfnConnectionReset = (NLBNotificationConnectionReset)GetProcAddress(hDLL, "WlbsConnectionReset");

    if (!pfnConnectionUp || !pfnConnectionDown || !pfnConnectionReset) {
        dwStatus = GetLastError();
        FreeLibrary(hDLL);
        printf("Unable to get procedure address... GetLastError() returned %u\n", dwStatus);
        return -1;
    }

    if (bUp) {
        baseDec = inet_addr(base);
        counter = 0;

        for( i = 0, baseI = baseDec; i < 255; ++i )
        {
            for( j = 0, baseJ = baseI; j < 255; ++j )
            {
                for( k = 0, baseK = baseJ; k < 254; ++k )
                {
                    if( counter == dwCount )
                    {
                        goto end;
                    }
                    ++counter;
                    daddr.s_addr = baseK;
                    temp = inet_ntoa(daddr);
                    dwStatus = (*pfnConnectionUp)(clus, htons(500), baseK, htons(500), 50, &dwNLBStatus);
                    printf("(%s) UP -> Return value = %u, NLB extended status = %u\n", temp, dwStatus, dwNLBStatus);
                    baseK += 0x10000;
                }
                baseJ += 0x100;
            }
            baseI += 0x1;
        }
    }

    if (bDown) {
        baseDec = inet_addr(base);
        counter = 0;

        for( i = 0, baseI = baseDec; i < 255; ++i )
        {
            for( j = 0, baseJ = baseI; j < 255; ++j )
            {
                for( k = 0, baseK = baseJ; k < 254; ++k )
                {
                    if( counter == dwCount )
                    {
                        goto end;
                    }
                    ++counter;
                    daddr.s_addr = baseK;
                    temp = inet_ntoa(daddr);
                    dwStatus = (*pfnConnectionUp)(clus, htons(500), baseK, htons(500), 50, &dwNLBStatus);
                    printf("(%s) DOWN -> Return value = %u, NLB extended status = %u\n", temp, dwStatus, dwNLBStatus);
                    baseK += 0x10000;
                }
                baseJ += 0x100;
            }
            baseI += 0x1;
        }
    }
    if (bReset) {
        baseDec = inet_addr(base);
        counter = 0;

        for( i = 0, baseI = baseDec; i < 255; ++i )
        {
            for( j = 0, baseJ = baseI; j < 255; ++j )
            {
                for( k = 0, baseK = baseJ; k < 254; ++k )
                {
                    if( counter == dwCount )
                    {
                        goto end;
                    }
                    ++counter;
                    daddr.s_addr = baseK;
                    temp = inet_ntoa(daddr);
                    dwStatus = (*pfnConnectionUp)(clus, htons(500), baseK, htons(500), 50, &dwNLBStatus);
                    printf("(%s) RST -> Return value = %u, NLB extended status = %u\n", temp, dwStatus, dwNLBStatus);
                    baseK += 0x10000;
                }
                baseJ += 0x100;
            }
            baseI += 0x1;
        }
    }
    return 0;
 end:
    FreeLibrary(hDLL);
    return 0;

 usage:

    printf("%ls [-up | -down | -reset] [count] [cluster ip]\n", argv[0]);
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\test\notify\mthread\main.cpp ===
/*
 * Filename: Main.cpp
 * Description: 
 * Author: chrisdar 07.17.02
 *
 * Tests support for CancelIPChangeNotify to cancel notififcations from TCP/IP.
 * Also exercises notification calls in multiple worker threads (pool size
 * controlled by NUM_THREAD).
 *
 * Each thread invokes an API method at random (selecting among the notification
 * APIs in wlbsctrl.dll). At no time should the call fail due to the state of
 * notifications in the dll. Thus multiple threads of control can use the
 * notification API without fear of stomping on one another.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <process.h>

#include "wlbsctrl.h"
#include "winsock2.h"

/* The number of worker threads to create */
#define NUM_THREAD 8

/* The number of random numbers to generate */
#define NUM_RAND 100

/* Mnemonic for the 4 API methods */
#define CONN_UP 0
#define CONN_DOWN 1
#define CONN_RESET 2
#define CONN_CANCEL 3

/* Function pointers for notification APIs */
NLBNotificationConnectionUp    pfnConnectionUp = NULL;
NLBNotificationConnectionDown  pfnConnectionDown = NULL;
NLBNotificationConnectionReset pfnConnectionReset = NULL;
NLBNotificationCancelNotify    pfnCancelNotify = NULL;

/* Set true when main thread wants worker threads to complete */
BOOL                g_fexit = FALSE;

/* Array of handles to the worker threads */
HANDLE              g_hThread[NUM_THREAD];

/* Couldn't get rand() to generate unique random numbers in worker threads. Resorted to generating an array of random numbers and cycling through it */
UINT                uiRand[NUM_RAND];

/* Index of next random number to use. Shared by worker threads, so this is proctected by a critical section */
UINT                uiIndex = 0;

/* Protects uiIndex */
CRITICAL_SECTION    cs;

/* Only way I could get the thread id to each worker thread. Used only in dumped output so I know which thread is doing the work */
UINT                tid[NUM_THREAD];

/* The function executed by the worker threads */
unsigned __stdcall rndm_notify(void* p)
{
    DWORD dwStatus;
    DWORD dwNLBStatus = 0;

    /* Get my thread id */
    DWORD dwtid = *((DWORD*) p);

    while (!g_fexit)
    {
        Sleep(2000);

        EnterCriticalSection(&cs);
        UINT uiMethod = uiRand[uiIndex];
        uiIndex = (uiIndex++)%NUM_RAND;
        LeaveCriticalSection(&cs);

        switch(uiMethod)
        {
        case CONN_UP:
            dwStatus = (*pfnConnectionUp)(inet_addr("10.0.0.110"), htons(500), inet_addr("10.0.0.204"), htons(500), 50, &dwNLBStatus);
            break;
        case CONN_DOWN:
            dwStatus = (*pfnConnectionDown)(inet_addr("10.0.0.110"), htons(500), inet_addr("10.0.0.204"), htons(500), 50, &dwNLBStatus);
            break;
        case CONN_RESET:
            dwStatus = (*pfnConnectionReset)(inet_addr("10.0.0.110"), htons(500), inet_addr("10.0.0.204"), htons(500), 50, &dwNLBStatus);
            break;
        case CONN_CANCEL:
            dwStatus = (*pfnCancelNotify)();
            break;
        default:
            continue;
        }

        if (dwStatus != ERROR_SUCCESS)
        {
            wprintf(L"Thread %4d: notification %u failed with %d\n", dwtid, uiMethod, dwStatus);
        }
        else
        {
            wprintf(L"Thread %4d: notification %u succeeded\n", dwtid, uiMethod);
        }
    }

    dwStatus = (*pfnCancelNotify)();
    if (dwStatus == ERROR_SUCCESS)
    {
        wprintf(L"Thread %4d: tcp/ip notifications canceled without error\n");
    }
    else
    {
        wprintf(L"Thread %4d: canceling tcp/ip notifications failed with error %d\n", dwStatus);
    }

    wprintf(L"Thread %4d: exiting\n", dwtid);

    return 0;
}

int __cdecl wmain (int argc, WCHAR ** argv) {
    HINSTANCE                      hDLL = NULL;

    int     iRet = 0;
    int     i    = 0;
    DWORD   dwStatus = 0;

    ZeroMemory(g_hThread, sizeof(g_hThread));
    InitializeCriticalSection(&cs);

    srand( (unsigned)time( NULL ) );

    for (i = 0; i < NUM_RAND; i++)
    {
        uiRand[i] = rand()*4/RAND_MAX;
    }

    hDLL = LoadLibrary(L"wlbsctrl.dll");

    if (!hDLL) {
        dwStatus = GetLastError();
        wprintf(L"Unable to open wlbsctrl.dll... GetLastError() returned %u\n", dwStatus);
        iRet = -1;
        goto exit;
    }

    pfnConnectionUp    = (NLBNotificationConnectionUp)GetProcAddress(hDLL, "WlbsConnectionUp");
    pfnConnectionDown  = (NLBNotificationConnectionDown)GetProcAddress(hDLL, "WlbsConnectionDown");
    pfnConnectionReset = (NLBNotificationConnectionReset)GetProcAddress(hDLL, "WlbsConnectionReset");
    pfnCancelNotify    = (NLBNotificationCancelNotify)GetProcAddress(hDLL, "WlbsCancelConnectionNotify");

    if (!pfnConnectionUp || !pfnConnectionDown || !pfnConnectionReset || !pfnCancelNotify) {
        dwStatus = GetLastError();
        wprintf(L"Unable to get procedure address... GetLastError() returned %u\n", dwStatus);
        iRet = -2;
        goto exit;
    }

    wprintf(L"Creating %u threads\n", NUM_THREAD);

    for (i=0; i < NUM_THREAD; i++)
    {
        g_hThread[i] = (HANDLE) _beginthreadex(
                                                  NULL,
                                                  0,
                                                  rndm_notify,
                                                  &tid[i],
                                                  0,
                                                  &tid[i]
                                                 );
        if (g_hThread[i] == 0)
        {
            wprintf(L"thread creation failed with error %d\n", errno);
            iRet = -4;
            goto exit;
        }

        Sleep(100);
    }

    wprintf(L"<return> to end threads and cancel\n");
    (void)getchar();

    g_fexit = TRUE;

    dwStatus = WaitForMultipleObjects(NUM_THREAD, g_hThread, TRUE, INFINITE);

    DWORD dwStatus2 = (*pfnCancelNotify)();
    if (dwStatus2 == ERROR_SUCCESS)
    {
        wprintf(L"tcp/ip notifications canceled without error\n");
    }
    else
    {
        wprintf(L"canceling tcp/ip notifications failed with error %d\n", dwStatus2);
    }

    if (dwStatus != WAIT_OBJECT_0 + NUM_THREAD - 1)
    {
        wprintf(L"wait on threads failed with error %d\n", dwStatus);
        iRet = -5;
        goto exit;
    }

exit:

    if (hDLL != NULL) FreeLibrary(hDLL);
    DeleteCriticalSection(&cs);

    return iRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\api\test\notify\single\main.cpp ===
/*
 * Filename: Main.cpp
 * Description: 
 * Author: shouse, 04.10.01
 */

#include <stdio.h>
#include <string.h>

#include "wlbsctrl.h"
#include "winsock2.h"

#define STATIC_LINK

int __cdecl wmain (int argc, WCHAR ** argv) {
#if defined (DYNAMIC_LINK)
    NLBNotificationConnectionUp    pfnConnectionUp = NULL;
    NLBNotificationConnectionDown  pfnConnectionDown = NULL;
    NLBNotificationConnectionReset pfnConnectionReset = NULL;
    HINSTANCE                      hDLL = NULL;
#endif
    DWORD dwNLBStatus = 0;
    DWORD dwStatus = 0;
    bool  bUp = false;
    bool  bDown = false;
    bool  bReset = false;

    if (argc > 2) goto usage;

    if (argc > 1) {
        if (!lstrcmpi(argv[1], L"-up")) {
            bUp = true;
        } else if (!lstrcmpi(argv[1], L"-down")) {
            bDown = true;
        } else if (!lstrcmpi(argv[1], L"-reset")) {
            bReset = true;
        } else goto usage;
    }
                
#if defined (DYNAMIC_LINK)
    hDLL = LoadLibrary(L"wlbsctrl.dll");

    if (!hDLL) {
        dwStatus = GetLastError();
        printf("Unable to open wlbsctrl.dll... GetLastError() returned %u\n", dwStatus);
        return -1;
    }

    pfnConnectionUp    = (NLBNotificationConnectionUp)GetProcAddress(hDLL, "WlbsConnectionUp");
    pfnConnectionDown  = (NLBNotificationConnectionDown)GetProcAddress(hDLL, "WlbsConnectionDown");
    pfnConnectionReset = (NLBNotificationConnectionReset)GetProcAddress(hDLL, "WlbsConnectionReset");

    if (!pfnConnectionUp || !pfnConnectionDown || !pfnConnectionReset) {
        dwStatus = GetLastError();
        FreeLibrary(hDLL);
        printf("Unable to get procedure address... GetLastError() returned %u\n", dwStatus);
        return -1;
    }

    if (bUp) {
        dwStatus = (*pfnConnectionUp)(inet_addr("12.12.4.2"), htons(500), inet_addr("12.12.4.165"), htons(500), 50, &dwNLBStatus);
        
        printf("UP -> Return value = %u, NLB extended status = %u\n", dwStatus, dwNLBStatus);
    }

    if (bDown) {
        dwStatus = (*pfnConnectionDown)(inet_addr("12.12.4.2"), htons(500), inet_addr("12.12.4.165"), htons(500), 50, &dwNLBStatus);
        
        printf("DOWN -> Return value = %u, NLB extended status = %u\n", dwStatus, dwNLBStatus);
    }

    if (bReset) {
        dwStatus = (*pfnConnectionReset)(inet_addr("12.12.4.2"), htons(500), inet_addr("12.12.4.165"), htons(500), 50, &dwNLBStatus);
        
        printf("RESET -> Return value = %u, NLB extended status = %u\n", dwStatus, dwNLBStatus);
    }

    FreeLibrary(hDLL);
#endif

#if defined (STATIC_LINK)
    if (bUp) {
        dwStatus = WlbsConnectionUp(inet_addr("12.12.4.2"), htons(80), inet_addr("12.12.4.165"), htons(5001), 6, &dwNLBStatus);
        
        printf("UP -> Return value = %u, NLB extended status = %u\n", dwStatus, dwNLBStatus);
    }

    if (bDown) {
        dwStatus = WlbsConnectionDown(inet_addr("12.12.4.2"), htons(80), inet_addr("12.12.4.165"), htons(5001), 6, &dwNLBStatus);
        
        printf("DOWN -> Return value = %u, NLB extended status = %u\n", dwStatus, dwNLBStatus);
    } 

    if (bReset) {
        dwStatus = WlbsConnectionReset(inet_addr("12.12.4.2"), htons(80), inet_addr("12.12.4.165"), htons(5001), 6, &dwNLBStatus);
        
        printf("RESET -> Return value = %u, NLB extended status = %u\n", dwStatus, dwNLBStatus);
    }
#endif

    return 0;

 usage:

    printf("%ls [-up | -down | -reset]\n", argv[0]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\cluster\nlb_cluster.cpp ===
/*
 * Filename: NLB_Cluster.cpp
 * Description: 
 * Author: shouse, 04.10.01
 */

#include <stdio.h>

#include "NLB_Cluster.h"

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Cluster::NLB_Cluster () {

    SecondaryIPAddressList.clear();
    HostList.clear();
    PortRuleList.clear();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Cluster::~NLB_Cluster () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::IsValid () {
    NLB_PortRuleList::iterator iRule;

    if (!Name.IsValid())
        return false;

    if (!PrimaryIPAddress.IsValid())
        return false;

    for (iRule = PortRuleList.begin(); iRule != PortRuleList.end(); iRule++) {
        NLB_PortRuleFilteringMode::NLB_PortRuleFilteringModeType Mode;
        NLB_PortRule                                             Rule = (*iRule).second;
        NLB_IPAddress                                            VirtualIPAddress;

        if (Rule.GetVirtualIPAddress(VirtualIPAddress)) {
            NLB_IPAddressList::iterator iAddress;
            WCHAR                       wszString[MAX_PATH];

            if (VirtualIPAddress == PrimaryIPAddress)
                continue;

            if (!VirtualIPAddress.GetIPAddress(wszString, MAX_PATH))
                return false;
            
            iAddress = SecondaryIPAddressList.find(wszString);
            
            if (iAddress == SecondaryIPAddressList.end())
                return false;
        }

        if (!Rule.GetFilteringMode(Mode))
            return false;

        switch (Mode) {
        case NLB_PortRuleFilteringMode::Single:
        {
            vector<NLB_PortRulePriority>::iterator iPriority;
            vector<NLB_PortRulePriority>           PriorityList;
            
            if (Rule.GetSingleHostFilteringPriorityList(&PriorityList)) {
                for (iPriority = PriorityList.begin(); iPriority != PriorityList.end(); iPriority++) {
                    NLB_PortRulePriority * pPriority = iPriority;
                    WCHAR                  wszHost[MAX_PATH];
                    NLB_Host               Host;
                    
                    if (!pPriority->IsValid())
                        return false;
                    
                    if (!pPriority->GetHost(wszHost, MAX_PATH))
                        return false;
                    
                    if (!GetHost(wszHost, Host))
                        return false;
                }
            }    
            
            break;
        }
        case NLB_PortRuleFilteringMode::Multiple:
        {
            vector<NLB_PortRuleLoadWeight>::iterator iLoadWeight;
            vector<NLB_PortRuleLoadWeight>           LoadWeightList;
            
            if (Rule.GetMultipleHostFilteringLoadWeightList(&LoadWeightList)) {
                for (iLoadWeight = LoadWeightList.begin(); iLoadWeight != LoadWeightList.end(); iLoadWeight++) {
                    NLB_PortRuleLoadWeight * pLoadWeight = iLoadWeight;
                    WCHAR                    wszHost[MAX_PATH];
                    NLB_Host                 Host;
                    
                    if (!pLoadWeight->IsValid())
                        return false;
                    
                    if (!pLoadWeight->GetHost(wszHost, MAX_PATH))
                        return false;
                    
                    if (!GetHost(wszHost, Host))
                        return false;
                }
            }    
            
            break;
        }
        case NLB_PortRuleFilteringMode::Disabled:
            break;
        }
    }

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_Cluster::Clear () {

    Name.Clear();
    Label.Clear();
    Mode.Clear();
    DomainName.Clear();
    NetworkAddress.Clear();
    RemoteControl.Clear();

    PrimaryIPAddress.Clear();
    IGMPMulticastIPAddress.Clear();
    SecondaryIPAddressList.clear();

    HostList.clear();
    PortRuleList.clear();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::SetName (PWCHAR pName) {

    NLB_ASSERT(pName);

    return Name.SetName(pName);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::GetName (PWCHAR pName, ULONG length) {

    NLB_ASSERT(pName);

    return Name.GetName(pName, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::SetLabel (PWCHAR pLabel) {

    NLB_ASSERT(pLabel);

    return Label.SetText(pLabel);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::GetLabel (PWCHAR pLabel, ULONG length) {

    NLB_ASSERT(pLabel);

    return Label.GetText(pLabel, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::SetClusterMode (NLB_ClusterMode::NLB_ClusterModeType eMode) {

    return Mode.SetMode(eMode);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::GetClusterMode (NLB_ClusterMode::NLB_ClusterModeType & eMode) {

    return Mode.GetMode(eMode);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::SetDomainName (PWCHAR pDomain) {

    NLB_ASSERT(pDomain);

    return DomainName.SetDomain(pDomain);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::GetDomainName (PWCHAR pDomain, ULONG length) {

    NLB_ASSERT(pDomain);

    return DomainName.GetDomain(pDomain, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::SetMACAddress (PWCHAR pMAC) {

    NLB_ASSERT(pMAC);

    return NetworkAddress.SetAddress(pMAC);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::GetMACAddress (PWCHAR pMAC, ULONG length) {

    NLB_ASSERT(pMAC);

    return NetworkAddress.GetAddress(pMAC, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::SetRemoteControlSupport (bool bEnabled) {

    return RemoteControl.SetEnabled(bEnabled);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::GetRemoteControlSupport (bool & bEnabled) {

    return RemoteControl.GetEnabled(bEnabled);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::SetRemoteControlPassword (PWCHAR pPassword) {

    NLB_ASSERT(pPassword);

    return RemoteControl.SetPassword(pPassword);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::GetRemoteControlPassword (PWCHAR pPassword, ULONG length) {

    NLB_ASSERT(pPassword);

    return RemoteControl.GetPassword(pPassword, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::SetBidirectionalAffinitySupport (NLB_ClusterBDASupport bda) {

    if (!bda.IsValid())
        return false;

    BDASupport = bda;
        
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::GetBidirectionalAffinitySupport (NLB_ClusterBDASupport & bda) {

    bda = BDASupport;

    return BDASupport.IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::SetPrimaryClusterIPAddress (NLB_IPAddress address) {
    NLB_IPAddress::NLB_IPAddressType Type;
    NLB_IPAddressList::iterator      iAddress;
    NLB_HostList::iterator           iHost;
    WCHAR                            wszString[MAX_PATH];

    if (!address.IsValid())
        return false;

    if (!address.GetIPAddressType(Type))
        return false;

    if (Type != NLB_IPAddress::Primary)
        return false;

    if (!address.GetIPAddress(wszString, MAX_PATH))
        return false;
    
    iAddress = SecondaryIPAddressList.find(wszString);
            
    if (iAddress != SecondaryIPAddressList.end())
        return false;    

    for (iHost = HostList.begin(); iHost != HostList.end(); iHost++) {
        NLB_Host      Host = (*iHost).second;
        NLB_IPAddress DedicatedIPAddress;
        NLB_IPAddress ConnectionIPAddress;

        Host.GetDedicatedIPAddress(DedicatedIPAddress);

        Host.GetConnectionIPAddress(ConnectionIPAddress);

        if (address == DedicatedIPAddress)
            return false;

        if (address == ConnectionIPAddress)
            return false;
    }

    PrimaryIPAddress = address;
    
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::GetPrimaryClusterIPAddress (NLB_IPAddress & address) {

    address = PrimaryIPAddress;

    return PrimaryIPAddress.IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::SetIGMPMulticastIPAddress (NLB_IPAddress address) {
    NLB_IPAddress::NLB_IPAddressType Type;
    
    if (!address.IsValid())
        return false;

    if (!address.GetIPAddressType(Type))
        return false;

    if (Type != NLB_IPAddress::IGMP)
        return false;

    IGMPMulticastIPAddress = address;
    
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::GetIGMPMulticastIPAddress (NLB_IPAddress & address) {

    address = IGMPMulticastIPAddress;

    return IGMPMulticastIPAddress.IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::AddSecondaryClusterIPAddress (NLB_IPAddress address) {
    NLB_IPAddress::NLB_IPAddressType Type;
    NLB_IPAddressList::iterator      iAddress;
    NLB_HostList::iterator           iHost;
    WCHAR                            wszString[MAX_PATH];
    
    if (!address.IsValid()) 
        return false;

    if (!address.GetIPAddressType(Type))
        return false;

    if (Type != NLB_IPAddress::Secondary)
        return false;
   
    if (!address.GetIPAddress(wszString, MAX_PATH))
        return false;
    
    iAddress = SecondaryIPAddressList.find(wszString);
    
    if (iAddress != SecondaryIPAddressList.end())
        return false;
    
    if (address == PrimaryIPAddress)
        return false;

    for (iHost = HostList.begin(); iHost != HostList.end(); iHost++) {
        NLB_Host      Host = (*iHost).second;
        NLB_IPAddress DedicatedIPAddress;
        NLB_IPAddress ConnectionIPAddress;

        Host.GetDedicatedIPAddress(DedicatedIPAddress);

        Host.GetConnectionIPAddress(ConnectionIPAddress);

        if (address == DedicatedIPAddress)
            return false;

        if (address == ConnectionIPAddress)
            return false;
    }

    SecondaryIPAddressList.insert(NLB_IPAddressList::value_type(wszString, address));
    
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::RemoveSecondaryClusterIPAddress (PWCHAR pAddress) {
    NLB_IPAddressList::iterator iAddress;
    
    NLB_ASSERT(pAddress);

    iAddress = SecondaryIPAddressList.find(pAddress);
    
    if (iAddress == SecondaryIPAddressList.end())
        return false;
    
    SecondaryIPAddressList.erase(pAddress);
    
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
ULONG NLB_Cluster::SetSecondaryClusterIPAddressList (vector<NLB_IPAddress> pList) {
    vector<NLB_IPAddress>::iterator iAddress;
    ULONG                           num = 0;

    SecondaryIPAddressList.clear();

    for (iAddress = pList.begin(); iAddress != pList.end(); iAddress++) {
        NLB_IPAddress * pAddress = iAddress;

        if (!AddSecondaryClusterIPAddress(*pAddress))
            continue;

        num++;
    }

    return num;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
ULONG NLB_Cluster::GetSecondaryClusterIPAddressList (vector<NLB_IPAddress> * pList) {
    NLB_IPAddressList::iterator iAddress;
    ULONG                       num = 0;

    NLB_ASSERT(pList);

    pList->clear();

    for (iAddress = SecondaryIPAddressList.begin(); iAddress != SecondaryIPAddressList.end(); iAddress++) {
        NLB_IPAddress address = (*iAddress).second;

        pList->push_back(address);
        
        num++;
    }

    return num;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::AddHost (NLB_Host host) {
    NLB_IPAddressList::iterator iAddress;
    NLB_HostList::iterator      iHost;
    WCHAR                       wszIPAddress[MAX_PATH];
    WCHAR                       wszString[MAX_PATH];
    NLB_IPAddress               MyDIP;
    NLB_IPAddress               MyCIP;
    ULONG                       MyID;

    if (!host.IsValid()) 
        return false;

    if (!host.GetName(wszString, MAX_PATH))
        return false;
    
    if (!host.GetHostID(MyID))
        return false;

    host.GetDedicatedIPAddress(MyDIP);

    host.GetConnectionIPAddress(MyCIP);

    iHost = HostList.find(wszString);
    
    if (iHost != HostList.end())
        return false;

    for (iHost = HostList.begin(); iHost != HostList.end(); iHost++) {
        NLB_Host      OtherHost = (*iHost).second;
        NLB_IPAddress TheirDIP;
        NLB_IPAddress TheirCIP;
        ULONG         TheirID;

        if (!OtherHost.GetHostID(TheirID))
            return false;
        
        OtherHost.GetDedicatedIPAddress(TheirDIP);

        OtherHost.GetConnectionIPAddress(TheirCIP);

        if (TheirID == MyID)
            return false;

        if (MyDIP == TheirDIP)
            return false;

        if (MyCIP == TheirCIP)
            return false;

        if (MyDIP == TheirCIP)
            return false;

        if (MyCIP == TheirDIP)
            return false;
    }
    
    if (MyDIP == PrimaryIPAddress)
        return false;

    if (MyCIP == PrimaryIPAddress)
        return false;

    if (MyDIP.IsValid()) {
        if (!MyDIP.GetIPAddress(wszIPAddress, MAX_PATH))
            return false;
        
        iAddress = SecondaryIPAddressList.find(wszIPAddress);
        
        if (iAddress != SecondaryIPAddressList.end())
            return false;
    }

    if (MyCIP.IsValid()) {
        if (!MyCIP.GetIPAddress(wszIPAddress, MAX_PATH))
            return false;
        
        iAddress = SecondaryIPAddressList.find(wszIPAddress);
        
        if (iAddress != SecondaryIPAddressList.end())
            return false;
    }

    HostList.insert(NLB_HostList::value_type(wszString, host));
    
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::GetHost (PWCHAR pName, NLB_Host & host) {
    NLB_HostList::iterator iHost;

    iHost = HostList.find(pName);
    
    if (iHost == HostList.end())
        return false;
    
    host = (*iHost).second;

    return host.IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::RemoveHost (PWCHAR pName) {
    NLB_HostList::iterator iHost;

    iHost = HostList.find(pName);
    
    if (iHost == HostList.end())
        return false;
    
    HostList.erase(pName);

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
ULONG NLB_Cluster::SetHostList (vector<NLB_Host> pList) {
    vector<NLB_Host>::iterator iHost;
    ULONG                      num = 0;

    HostList.clear();

    for (iHost = pList.begin(); iHost != pList.end(); iHost++) {
        NLB_Host * pHost = iHost;

        if (!AddHost(*pHost))
            continue;

        num++;
    }

    return num;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
ULONG NLB_Cluster::GetHostList (vector<NLB_Host> * pList) {
    NLB_HostList::iterator iHost;
    ULONG                  num = 0;

    NLB_ASSERT(pList);

    pList->clear();

    for (iHost = HostList.begin(); iHost != HostList.end(); iHost++) {
        NLB_Host host = (*iHost).second;

        pList->push_back(host);
        
        num++;
    }

    return num;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::AddPortRule (NLB_PortRule rule) {
    NLB_PortRuleList::iterator iRule;
    WCHAR                      wszString[MAX_PATH];
    NLB_IPAddress              MyVIP;
    ULONG                      MyStart;
    ULONG                      MyEnd;

    if (PortRuleList.size() >= NLB_MAX_NUM_PORT_RULES)
        return false;

    if (!rule.IsValid()) 
        return false;

    if (!rule.GetName(wszString, MAX_PATH))
        return false;
    
    if (!rule.GetPortRange(MyStart, MyEnd))
        return false;

    rule.GetVirtualIPAddress(MyVIP);

    iRule = PortRuleList.find(wszString);
    
    if (iRule != PortRuleList.end())
        return false;
    
    for (iRule = PortRuleList.begin(); iRule != PortRuleList.end(); iRule++) {
        NLB_PortRule  OtherRule = (*iRule).second;
        NLB_IPAddress TheirVIP;
        ULONG         TheirStart;
        ULONG         TheirEnd;

        if (!OtherRule.GetPortRange(TheirStart, TheirEnd))
            return false;
        
        OtherRule.GetVirtualIPAddress(TheirVIP);

        if (((!MyVIP.IsValid() && !TheirVIP.IsValid()) || (MyVIP == TheirVIP)) && 
            (((MyStart < TheirStart) && (MyEnd >= TheirEnd)) || ((MyStart >= TheirStart) && (MyEnd <= TheirEnd))))
            return false;
    }

    PortRuleList.insert(NLB_PortRuleList::value_type(wszString, rule));
    
    return true;    
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::GetPortRule (PWCHAR pName, NLB_PortRule & rule) {
    NLB_PortRuleList::iterator iRule;

    iRule = PortRuleList.find(pName);
    
    if (iRule == PortRuleList.end())
        return false;
    
    rule = (*iRule).second;

    return rule.IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Cluster::RemovePortRule (PWCHAR pName) {
    NLB_PortRuleList::iterator iRule;

    iRule = PortRuleList.find(pName);
    
    if (iRule == PortRuleList.end())
        return false;
    
    PortRuleList.erase(pName);

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
ULONG NLB_Cluster::SetPortRuleList (vector<NLB_PortRule> pList) {
    vector<NLB_PortRule>::iterator iRule;
    ULONG                          num = 0;

    PortRuleList.clear();

    for (iRule = pList.begin(); iRule != pList.end(); iRule++) {
        NLB_PortRule * pRule = iRule;

        if (!AddPortRule(*pRule))
            continue;

        num++;
    }

    return num;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
ULONG NLB_Cluster::GetPortRuleList (vector<NLB_PortRule> * pList) {
    NLB_PortRuleList::iterator iRule;
    ULONG                      num = 0;

    NLB_ASSERT(pList);

    pList->clear();

    for (iRule = PortRuleList.begin(); iRule != PortRuleList.end(); iRule++) {
        NLB_PortRule rule = (*iRule).second;

        pList->push_back(rule);
        
        num++;
    }

    return num;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\cluster\nlb_common.cpp ===
/*
 * Filename: NLB_Common.cpp
 * Description: 
 * Author: shouse, 04.10.01
 */

#include <stdio.h>
#include <objbase.h>

#include "NLB_Common.h"
#include "winsock2.h"
#include "wlbsutil.h"

/*************************************************
 * Class: NLB_Name                               *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Name::NLB_Name () {
    
    Name[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Name::~NLB_Name () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Name::IsValid () { 

    return (Name[0] != L'\0'); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_Name::Clear () {
    
    Name[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Name::GetName (PWCHAR pName, ULONG length) { 
    
    NLB_ASSERT(pName);

    wcsncpy(pName, Name, length - 1);
    
    pName[length - 1] = L'\0';

    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Name::SetName (PWCHAR pName) {
    
    NLB_ASSERT(pName);

    if (wcslen(pName) > NLB_MAX_NAME) return false;
    
    if (wcschr(pName, L' ')) return false;

    wcscpy(Name, pName);
    
    return true;
}

/*************************************************
 * Class: NLB_Label                              *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Label::NLB_Label () {
    
    Text[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Label::~NLB_Label () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Label::IsValid () { 

    return (Text[0] != L'\0'); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_Label::Clear () {
    
    Text[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Label::GetText (PWCHAR pText, ULONG length) { 
    
    NLB_ASSERT(pText);

    wcsncpy(pText, Text, length - 1);
    
    pText[length - 1] = L'\0';
    
    return IsValid();
 }

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Label::SetText (PWCHAR pText) {
    
    NLB_ASSERT(pText);

    if (wcslen(pText) > NLB_MAX_LABEL) return false;
    
    wcscpy(Text, pText);
    
    return true;
}

/*************************************************
 * Class: NLB_Adapter                            *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Adapter & NLB_Adapter::operator= (const NLB_Adapter & adapter) {

    IdentifiedBy = adapter.IdentifiedBy;
    wcscpy(Identifier, adapter.Identifier);

    return *this;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Adapter::NLB_Adapter () {

    IdentifiedBy = Invalid;
    Identifier[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Adapter::~NLB_Adapter () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Adapter::IsValid () { 
    
    return ((IdentifiedBy != Invalid) && (Identifier[0] != L'\0')); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_Adapter::Clear () {

    IdentifiedBy = Invalid;
    Identifier[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Adapter::GetName (PWCHAR pName, ULONG length) { 

    NLB_ASSERT(pName);
        
    if (IdentifiedBy == ByName) {    
        wcsncpy(pName, Identifier, length - 1);
        
        pName[length - 1] = L'\0';

        return IsValid();
    }

    return false;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Adapter::GetGUID (PWCHAR pGUID, ULONG length) { 

    NLB_ASSERT(pGUID);
        
    if (IdentifiedBy == ByGUID) {    
        wcsncpy(pGUID, Identifier, length - 1);
        
        pGUID[length - 1] = L'\0';

        return IsValid();
    }

    return false;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Adapter::SetName (PWCHAR pName) {
        
    NLB_ASSERT(pName);

    if (wcslen(pName) > NLB_MAX_ADAPTER_IDENTIFIER) return false;

    wcscpy(Identifier, pName);
        
    IdentifiedBy = ByName;

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Adapter::SetGUID (PWCHAR pGUID) {
    WCHAR   wszString[NLB_MAX_ADAPTER_IDENTIFIER + 1];
    GUID    UUID;
    HRESULT hr = S_OK;

    NLB_ASSERT(pGUID);

    if (wcslen(pGUID) > NLB_MAX_ADAPTER_IDENTIFIER) return false;

    if (pGUID[0] != L'{')
        wsprintf(wszString, L"{%ls}", pGUID);
    else
        wsprintf(wszString, L"%ls", pGUID);

    hr = CLSIDFromString(wszString, &UUID);
    
    if (hr != NOERROR) return false;

    wcscpy(Identifier, wszString);
        
    IdentifiedBy = ByGUID;

    return true;
}

/*************************************************
 * Class: NLB_IPAddress                          *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::operator== (NLB_IPAddress & address) {

    if (!IsValid() || !address.IsValid())
        return false;

    if (lstrcmpi(IPAddress, address.IPAddress))
        return false;

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_IPAddress & NLB_IPAddress::operator= (const NLB_IPAddress & address) {

    Type = address.Type;
    wcscpy(IPAddress, address.IPAddress);
    wcscpy(SubnetMask, address.SubnetMask);
    Adapter = address.Adapter;

    return *this;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_IPAddress::NLB_IPAddress () {

    Type = Invalid;
    IPAddress[0] = L'\0';
    SubnetMask[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_IPAddress::NLB_IPAddress (NLB_IPAddressType eType) {

    SetIPAddressType(eType);

    IPAddress[0] = L'\0';
    SubnetMask[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_IPAddress::~NLB_IPAddress () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::IsValid () { 

    if (Type == Invalid) 
        return false;

    if (Type == IGMP)
        return (IsValidMulticastIPAddress(IPAddress) == TRUE);

    if (!IsValidIPAddressSubnetMaskPair(IPAddress, SubnetMask))
        return false;
    
    if (!IsContiguousSubnetMask(SubnetMask))
        return false;

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_IPAddress::Clear () {

    Type = Invalid;
    IPAddress[0] = L'\0';
    SubnetMask[0] = L'\0';

    Adapter.Clear();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::GetIPAddressType (NLB_IPAddressType & eType) { 
    
    eType = Type;

    return (Type != Invalid);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::GetIPAddress (PWCHAR pIPAddress, ULONG length) { 

    NLB_ASSERT(pIPAddress);

    wcsncpy(pIPAddress, IPAddress, length - 1);
    
    pIPAddress[length - 1] = L'\0';

    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::GetSubnetMask (PWCHAR pSubnetMask, ULONG length) { 

    NLB_ASSERT(pSubnetMask);

    if ((Type == Virtual) || (Type == Connection) || (Type == IGMP))
        return false;

    wcsncpy(pSubnetMask, SubnetMask, length - 1);
    
    pSubnetMask[length - 1] = L'\0';
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::GetAdapterName (PWCHAR pName, ULONG length) { 

    if (Type == Dedicated)
        return Adapter.GetName(pName, length);

    return false;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::GetAdapterGUID (PWCHAR pGUID, ULONG length) { 

    if (Type == Dedicated)
        return Adapter.GetGUID(pGUID, length);

    return false;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::SetIPAddressType (NLB_IPAddressType eType) {

    switch (eType) {
    case Primary:
    case Secondary:
    case Virtual:
    case IGMP:
    case Dedicated:
    case Connection:
        Type = eType;
        break;
    default:
        return false;
    }
        
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::SetIPAddress (PWCHAR pIPAddress) {
    IN_ADDR dwIPAddr;
    CHAR *  szIPAddr;

    NLB_ASSERT(pIPAddress);

    if (wcslen(pIPAddress) > NLB_MAX_IPADDRESS) return false;

    if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(pIPAddress)))
        return false;
        
    if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
        return false;
    
    if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, IPAddress, NLB_MAX_IPADDRESS + 1))
        return false;

    if (SubnetMask[0] == L'\0')
    {
        ParamsGenerateSubnetMask(IPAddress, SubnetMask, ASIZECCH(SubnetMask));
    }

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::SetSubnetMask (PWCHAR pSubnetMask) {
    IN_ADDR dwIPAddr;
    CHAR *  szIPAddr;

    NLB_ASSERT(pSubnetMask);

    if ((Type == Virtual) || (Type == Connection) || (Type == IGMP))
        return false;

    if (wcslen(pSubnetMask) > NLB_MAX_SUBNETMASK) return false;

    if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(pSubnetMask)))
        return false;
        
    if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
        return false;
    
    if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, SubnetMask, NLB_MAX_IPADDRESS + 1))
        return false;

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::SetAdapterName (PWCHAR pName) { 

    if (Type == Dedicated)
        return Adapter.SetName(pName);
    
    return false;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_IPAddress::SetAdapterGUID (PWCHAR pGUID) { 

    if (Type == Dedicated)
        return Adapter.SetGUID(pGUID);

    return false;
}

/*************************************************
 * Class: NLB_ClusterMode                        *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterMode::NLB_ClusterMode () { 

    Mode = Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterMode::~NLB_ClusterMode () { 

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterMode::IsValid () { 

    return (Mode != Invalid); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_ClusterMode::Clear () { 

    Mode = Invalid;
}
    
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterMode::GetMode (NLB_ClusterModeType & eMode) { 
        
    eMode = Mode;

    return IsValid(); 
}
    
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterMode::SetMode (NLB_ClusterModeType eMode) {

    switch (eMode) {
    case Unicast:
    case Multicast:
    case IGMP:
        Mode = eMode;
        break;
    default:
        return false;
    }

    return true;
}

/*************************************************
 * Class: NLB_ClusterDomainName                  *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterDomainName::NLB_ClusterDomainName () {
    
    Domain[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterDomainName::~NLB_ClusterDomainName () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterDomainName::IsValid () { 

    return (Domain[0] != L'\0'); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_ClusterDomainName::Clear () {
    
    Domain[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterDomainName::GetDomain (PWCHAR pDomain, ULONG length) { 
    
    NLB_ASSERT(pDomain);

    wcsncpy(pDomain, Domain, length - 1);
    
    pDomain[length - 1] = L'\0';
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterDomainName::SetDomain (PWCHAR pDomain) {
    
    NLB_ASSERT(pDomain);

    if (wcslen(Domain) > NLB_MAX_DOMAIN_NAME) return false;
    
    wcscpy(Domain, pDomain);
    
    return true;
}

/*************************************************
 * Class: NLB_ClusterNetworkAddress              *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterNetworkAddress::NLB_ClusterNetworkAddress () {
    
    Address[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterNetworkAddress::~NLB_ClusterNetworkAddress () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterNetworkAddress::IsValid () { 

    return (Address[0] != L'\0'); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_ClusterNetworkAddress::Clear () {
    
    Address[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterNetworkAddress::GetAddress (PWCHAR pAddress, ULONG length) { 
    
    NLB_ASSERT(pAddress);

    wcsncpy(pAddress, Address, length - 1);
    
    pAddress[length - 1] = L'\0';
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterNetworkAddress::SetAddress (PWCHAR pAddress) {
    WCHAR MACAddress[NLB_MAX_NETWORK_ADDRESS + 1];
    PWCHAR p1, p2;
    DWORD i, j;
    
    NLB_ASSERT(pAddress);

    if (wcslen(pAddress) > NLB_MAX_NETWORK_ADDRESS) return false;
    
    /* Make a copy of the MAC address. */
    wcscpy(MACAddress, pAddress);
    
    /* Point to the beginning of the MAC. */
    p2 = p1 = MACAddress;
    
    /* Loop through all six bytes. */
    for (i = 0 ; i < 6 ; i++) {
        /* If we are pointing at the end of the string, its invalid. */
        if (*p2 == L'\0') return false;
        
        /* Convert the hex characters into decimal. */
        j = wcstoul(p1, &p2, 16);
        
        /* If the number is greater than 255, then the format is bad. */
        if (j > 255) return false;
        
        /* If the NEXT character is neither a -, :, nor the NUL character, then the format is bad. */
        if (!((*p2 == L'-') || (*p2 == L':') || (*p2 == L'\0'))) return false;
        
        /* If the NEXT character is the end of the string, but we don't have enough bytes yet, bail out. */
        if ((*p2 == L'\0') && (i < 5)) return false;
        
        /* Repoint to the NEXT character. */
        p1 = p2 + 1;
        p2 = p1;
    }

    wcscpy(Address, pAddress);
    
    return true;
}

/*************************************************
 * Class: NLB_ClusterBDASupport                  *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterBDASupport & NLB_ClusterBDASupport::operator= (const NLB_ClusterBDASupport & bda) {

    Master = bda.Master;
    ReverseHash = bda.ReverseHash;
    wcscpy(TeamID, bda.TeamID);

    return *this;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterBDASupport::NLB_ClusterBDASupport () {
    
    Master = false;
    ReverseHash = false;
    TeamID[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterBDASupport::~NLB_ClusterBDASupport () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterBDASupport::IsValid () { 

    return (TeamID[0] != L'\0'); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_ClusterBDASupport::Clear () {
    
    Master = false;
    ReverseHash = false;
    TeamID[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterBDASupport::GetMaster (bool & bMaster) { 

    bMaster = Master;

    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterBDASupport::GetReverseHashing (bool & bReverse) {

    bReverse = ReverseHash;

    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterBDASupport::GetTeamID (PWCHAR pTeam, ULONG length) { 

    NLB_ASSERT(pTeam);
        
    wcsncpy(pTeam, TeamID, length - 1);
    
    pTeam[length - 1] = L'\0';
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterBDASupport::SetMaster (bool bMaster) { 

    Master = bMaster;

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterBDASupport::SetReverseHashing (bool bReverse) {

    ReverseHash = bReverse;

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterBDASupport::SetTeamID (PWCHAR pTeam) {
    WCHAR   wszString[NLB_MAX_BDA_TEAMID + 1];
    GUID    UUID;
    HRESULT hr = S_OK;

    NLB_ASSERT(pTeam);

    if (wcslen(pTeam) > NLB_MAX_BDA_TEAMID) return false;

    if (pTeam[0] != L'{')
        wsprintf(wszString, L"{%ls}", pTeam);
    else
        wsprintf(wszString, L"%ls", pTeam);

    hr = CLSIDFromString(wszString, &UUID);
    
    if (hr != NOERROR) return false;

    wcscpy(TeamID, wszString);
        
    return true;   
}

/*************************************************
 * Class: NLB_ClusterRemoteControl               *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterRemoteControl::NLB_ClusterRemoteControl () {

    Valid = false;
    Enabled = false;
    Password[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_ClusterRemoteControl::~NLB_ClusterRemoteControl () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterRemoteControl::IsValid () { 
    
    return (Password[0] != L'\0'); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_ClusterRemoteControl::Clear () {

    Valid = false;
    Enabled = false;
    Password[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterRemoteControl::GetEnabled (bool & bEnabled) { 

    bEnabled = Enabled;

    return Valid;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterRemoteControl::GetPassword (PWCHAR pPassword, ULONG length) { 

    NLB_ASSERT(pPassword);

    wcsncpy(pPassword, Password, length - 1);
    
    pPassword[length - 1] = L'\0';

    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterRemoteControl::SetEnabled (bool bEnabled) {
        
    Enabled = bEnabled;

    Valid = true;
        
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_ClusterRemoteControl::SetPassword (PWCHAR pPassword) {

    NLB_ASSERT(pPassword);

    if (wcslen(pPassword) > NLB_MAX_PASSWORD) return false;

    wcscpy(Password, pPassword);
        
    return true;
}

/*************************************************
 * Class: NLB_HostName                           *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_HostName::NLB_HostName () {
    
    Name[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_HostName::~NLB_HostName () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostName::IsValid () { 

    return (Name[0] != L'\0'); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_HostName::Clear () {
    
    Name[0] = L'\0';
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostName::GetName (PWCHAR pName, ULONG length) { 
    
    NLB_ASSERT(pName);

    wcsncpy(pName, Name, length - 1);
    
    pName[length - 1] = L'\0';
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostName::SetName (PWCHAR pName) {
    
    NLB_ASSERT(pName);

    if (wcslen(pName) > NLB_MAX_HOST_NAME) return false;
    
    wcscpy(Name, pName);
    
    return true;
}

/*************************************************
 * Class: NLB_HostID                             *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_HostID::NLB_HostID () {
    
    HostID = NLB_MAX_HOST_ID + 1;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_HostID::~NLB_HostID () {
 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostID::IsValid () { 

    return (HostID <= NLB_MAX_HOST_ID); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_HostID::Clear () {
    
    HostID = NLB_MAX_HOST_ID + 1;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostID::GetID (ULONG & ID) { 
    
    ID = HostID;
    
    return IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostID::SetID (ULONG ID) {
    
    if (ID > NLB_MAX_HOST_ID) return false;
    
    HostID = ID;
    
    return true;
}

/*************************************************
 * Class: NLB_HostState                          *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_HostState::NLB_HostState () { 

    State = Invalid;
    PersistStarted = false;
    PersistStopped = false;
    PersistSuspended = false;
    PersistStartedValid = false;
    PersistStoppedValid = false;
    PersistSuspendedValid = false;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_HostState::~NLB_HostState () { 

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostState::IsValid () { 

    return (State != Invalid); 
}
 
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_HostState::Clear () { 

    State = Invalid;
    PersistStarted = false;
    PersistStopped = false;
    PersistSuspended = false;
    PersistStartedValid = false;
    PersistStoppedValid = false;
    PersistSuspendedValid = false;
}
   
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostState::GetState (NLB_HostStateType & eState) { 
        
    eState = State;

    return IsValid(); 
}
 
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostState::GetPersistence (NLB_HostStateType eState, bool & bPersist) {
    bool bValid = false;

    switch (eState) {
    case Started:
        bPersist = PersistStarted;
        bValid = PersistStartedValid;
        break;
    case Stopped:
        bPersist = PersistStopped;
        bValid = PersistStoppedValid;
        break;
    case Suspended:
        bPersist = PersistSuspended;
        bValid = PersistSuspendedValid;
        break;
    default:
        return false;
    }

    return (IsValid() && bValid); 
}
   
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostState::SetState (NLB_HostStateType eState) {

    switch (eState) {
    case Started:
    case Stopped:
    case Suspended:
        State = eState;
        break;
    default:
        return false;
    }

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_HostState::SetPersistence (NLB_HostStateType eState, bool bPersist) {

    switch (eState) {
    case Started:
        PersistStarted = bPersist;
        PersistStartedValid = true;
        break;
    case Stopped:
        PersistStopped = bPersist;
        PersistStoppedValid = true;
        break;
    case Suspended:
        PersistSuspended = bPersist;
        PersistSuspendedValid = true;
        break;
    default:
        return false;
    }

    return true;
}

/*************************************************
 * Class: NLB_PortRulePortRange                  *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRulePortRange::NLB_PortRulePortRange () {
    
    Start = NLB_MAX_PORT + 1;
    End = NLB_MAX_PORT + 1;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRulePortRange::~NLB_PortRulePortRange () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_PortRulePortRange::Clear () {
    
    Start = NLB_MAX_PORT + 1;
    End = NLB_MAX_PORT + 1;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRulePortRange::IsValid () { 

    return ((Start <= NLB_MAX_PORT) && (End <= NLB_MAX_PORT) && (Start <= End));
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRulePortRange::GetPortRange (ULONG & start, ULONG & end) { 
    
    start = Start;
    end = End;
    
    return IsValid();
 }

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRulePortRange::SetPortRange (ULONG start, ULONG end) {
    
    if ((start > NLB_MAX_PORT) || (end > NLB_MAX_PORT) || (start > end)) return false;
    
    Start = start;
    End = end;
    
    return true;
}

/*************************************************
 * Class: NLB_PortRuleState                      *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRuleState::NLB_PortRuleState () { 

    State = Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRuleState::~NLB_PortRuleState () { 

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleState::IsValid () { 

    return (State != Invalid); 
}
 
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_PortRuleState::Clear () { 

    State = Invalid;
}
   
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleState::GetState (NLB_PortRuleStateType & eState) { 
        
    eState = State;

    return IsValid(); 
}
    
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleState::SetState (NLB_PortRuleStateType eState) {

    switch (eState) {
    case Enabled:
    case Disabled:
    case Draining:
        State = eState;
        break;
    default:
        return false;
    }

    return true;
}

/*************************************************
 * Class: NLB_PortRuleProtocol                   *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRuleProtocol::NLB_PortRuleProtocol () { 

    Protocol = Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRuleProtocol::~NLB_PortRuleProtocol () { 

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleProtocol::IsValid () { 

    return (Protocol != Invalid); 
}
 
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_PortRuleProtocol::Clear () { 

    Protocol = Invalid;
}
   
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleProtocol::GetProtocol (NLB_PortRuleProtocolType & eProtocol) { 
        
    eProtocol = Protocol;

    return IsValid(); 
}
    
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleProtocol::SetProtocol (NLB_PortRuleProtocolType eProtocol) {

    switch (eProtocol) {
    case TCP:
    case UDP:
    case Both:
        Protocol = eProtocol;
        break;
    default:
        return false;
    }

    return true;
}

/*************************************************
 * Class: NLB_PortRuleAffinity                   *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRuleAffinity::NLB_PortRuleAffinity () { 

    Affinity = Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRuleAffinity::~NLB_PortRuleAffinity () { 

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleAffinity::IsValid () { 

    return (Affinity != Invalid); 
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_PortRuleAffinity::Clear () { 

    Affinity = Invalid;
}
    
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleAffinity::GetAffinity (NLB_PortRuleAffinityType & eAffinity) { 
        
    eAffinity = Affinity;

    return IsValid(); 
}
    
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleAffinity::SetAffinity (NLB_PortRuleAffinityType eAffinity) {

    switch (eAffinity) {
    case None:
    case Single:
    case ClassC:
        Affinity = eAffinity;
        break;
    default:
        return false;
    }

    return true;
}

/*************************************************
 * Class: NLB_PortRuleFilteringMode              *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRuleFilteringMode::NLB_PortRuleFilteringMode () { 

    Mode = Invalid;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRuleFilteringMode::~NLB_PortRuleFilteringMode () { 

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleFilteringMode::IsValid () { 

    return (Mode != Invalid); 
}
 
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_PortRuleFilteringMode::Clear () { 

    Mode = Invalid;
}
   
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleFilteringMode::GetMode (NLB_PortRuleFilteringModeType & eMode) { 
        
    eMode = Mode;

    return IsValid(); 
}
    
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleFilteringMode::SetMode (NLB_PortRuleFilteringModeType eMode) {

    switch (eMode) {
    case Single:
    case Multiple:
    case Disabled:
        Mode = eMode;
        break;
    default:
        return false;
    }

    return true;
}

/*************************************************
 * Class: NLB_PortRulePriority                   *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRulePriority::NLB_PortRulePriority () {
    
    Priority = NLB_MAX_PRIORITY + 1;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRulePriority::~NLB_PortRulePriority () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRulePriority::IsValid () { 

    return ((Priority <= NLB_MAX_PRIORITY) && (Priority >= NLB_MIN_PRIORITY));
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_PortRulePriority::Clear () {
    
    Priority = NLB_MAX_PRIORITY + 1;

    Host.Clear();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRulePriority::GetPriority (ULONG & priority) { 
    
    priority = Priority;
    
    return IsValid();
 }

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRulePriority::GetHost (PWCHAR pName, ULONG length) { 
    
    return Host.GetName(pName, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRulePriority::SetPriority (ULONG priority) {
    
    if ((priority > NLB_MAX_PRIORITY) || (priority < NLB_MIN_PRIORITY)) return false;
    
    Priority = priority;
    
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRulePriority::SetHost (PWCHAR pName) {
    
    return Host.SetName(pName);
}

/*************************************************
 * Class: NLB_PortRuleLoadWeight                 *
 *************************************************/

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRuleLoadWeight::NLB_PortRuleLoadWeight () {
    
    Weight = NLB_MAX_LOADWEIGHT + 1;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRuleLoadWeight::~NLB_PortRuleLoadWeight () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleLoadWeight::IsValid () { 

    return (Weight <= NLB_MAX_LOADWEIGHT);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_PortRuleLoadWeight::Clear () {
    
    Weight = NLB_MAX_LOADWEIGHT + 1;

    Host.Clear();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleLoadWeight::GetWeight (ULONG & weight) { 
    
    weight = Weight;
    
    return IsValid();
 }
/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleLoadWeight::GetHost (PWCHAR pName, ULONG length) { 
    
    return Host.GetName(pName, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleLoadWeight::SetWeight (ULONG weight) {
    
    if (weight > NLB_MAX_LOADWEIGHT) return false;
    
    Weight = weight;
    
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRuleLoadWeight::SetHost (PWCHAR pName) {
    
    return Host.SetName(pName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\diplist.h ===
/*++ Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Driver

File Name:

    diplist.h

Abstract:

    Code to lookup if a DIP is in a list of DIPs, without holding any locks.

History:

04/24/2002  JosephJ Created

--*/

#include <ntddk.h>

#define NULL_VALUE 0    // Illegal value; may be used to clear an item.

#define MAX_ITEMS  CVY_MAX_HOSTS   // maximum number of DIPs in our list
#define HASH1_SIZE 257             // size (in bits) of bit-vector (make it a prime)
#define HASH2_SIZE 59              // size of hashtable            (make it a prime) 

//
// I've tested with the following "boundary case"
//
// #define MAX_ITEMS  1
// #define HASH1_SIZE 1
// #define HASH2_SIZE 1
//

#pragma pack(4)

typedef struct
{

    //
    // NOTE: All fields in this structure should be treated as
    // OPAQUE (private members) to callers of the DipList APIs.
    //


    //
    // The "master copy" of values, indexed by the "Index" field in
    // DipListSetItem.
    //
    ULONG    Items[MAX_ITEMS];

    //
    // A bit vector used for a quick check to see if the value MAY exist
    // in the dip list.
    //
    // To lookup a bit based on value "Value", do the following:
    //  
    //  Hash1 = Value % HASH1_SIZE;
    //  u = Hash1/32    // 32 is the number of bits in a ULONG
    //  bit = BitVector[u] & ( (1<<Hash1) % 32)
    //
    ULONG   BitVector[(HASH1_SIZE+sizeof(ULONG))/sizeof(ULONG)];

    //
    // A hash table to lookup a value -- to look up a value, "Value",
    // do the following:
    //
    // Hash2 = Value % HASH2_SIZE;
    // UCHAR *pb = HashTable+Hash2;
    // while (*pb != 0)
    // {
    //    if (Items[*pb-1] == Value)
    //    {
    //       break;   // Found it!
    //    }
    // }
    //
    // Notes:
    //  1. The values in HashTable are 1+index,
    //     where "index" is the index into Items[] where the value is located.
    //  2. The reason for the "1+" above is to allow the use of
    //     0 as a sentinel in HashTable.
    //  3. Note the fact that the hash table (HashTable) is extended
    //     by MAX_ITEMS -- this is to allow overflow of hash buckets without
    //     requiring us to wrap-around to look for items.
    //  4. The LAST entry of HashTable is ALWAYS 0, ensuring that the
    //     while loop above will always terminate properly.
    //
    UCHAR   HashTable[HASH2_SIZE+MAX_ITEMS];

    //
    // Keeps stats on the lookups (only in DBG version)
    //
    struct
    {
        ULONG NumChecks;         // total number of calls to DipListCheckItem
        ULONG NumFastChecks;     // times we just checked the bit vector
        ULONG NumArrayLookups;   // times we looked up an item in HashTable

    } stats;

} DIPLIST;

#pragma pack()

VOID
DipListInitialize(
    DIPLIST  *pDL
    );
//
// Initialize a DIP List
// Must be called with lock held and before calls to any other DIP List
// function.
//

VOID
DipListDeinitialize(
    DIPLIST *pDL
    );
//
// Deinitialize a DIP List
// Must be called with lock held and should be the last call to the DipList.
//

VOID
DipListClear(
    DIPLIST *pDL
    );
//
// Clear all the items in a dip list.
// Must be called with lock held.
// Does not clear the stats.
//

VOID
DipListSetItem(
    DIPLIST *pDL,
    ULONG Index,
    ULONG Value
    );
//
// Set the value of a specific iten the the DIP list.
// Must be called with lock held.
//

BOOLEAN
DipListCheckItem(
    DIPLIST *pDL,
    ULONG Value
    );
//
// Returns TRUE IFF an item exists with the specified value.
// May NOT be called with the lock held. If it's called concurrently
// with one of the other functions, the return value is indeterminate.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\cluster\nlb_host.cpp ===
/*
 * Filename: NLB_Host.cpp
 * Description: 
 * Author: shouse, 04.10.01
 */

#include <stdio.h>

#include "NLB_Host.h"

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Host::NLB_Host () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_Host::~NLB_Host () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::IsValid () {

    if (!Name.IsValid())
        return false;

    if (!HostID.IsValid())
        return false;
    
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_Host::Clear () {

    Name.Clear();
    Label.Clear();
    HostName.Clear();
    HostID.Clear();
    State.Clear();
    
    DedicatedIPAddress.Clear();
    ConnectionIPAddress.Clear();

    Adapter.Clear();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::SetName (PWCHAR pName) {

    NLB_ASSERT(pName);

    return Name.SetName(pName);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::GetName (PWCHAR pName, ULONG length) {

    NLB_ASSERT(pName);

    return Name.GetName(pName, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::SetLabel (PWCHAR pLabel) {

    NLB_ASSERT(pLabel);

    return Label.SetText(pLabel);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::GetLabel (PWCHAR pLabel, ULONG length) {

    NLB_ASSERT(pLabel);

    return Label.GetText(pLabel, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::SetDNSHostname (PWCHAR pName) {

    NLB_ASSERT(pName);

    return HostName.SetName(pName);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::GetDNSHostname (PWCHAR pName, ULONG length) {

    NLB_ASSERT(pName);

    return HostName.GetName(pName, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::SetHostID (ULONG ID) {

    return HostID.SetID(ID);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::GetHostID (ULONG & ID) {

    return HostID.GetID(ID);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::SetState (NLB_HostState::NLB_HostStateType eState) {

    return State.SetState(eState);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::GetState (NLB_HostState::NLB_HostStateType & eState) {

    return State.GetState(eState);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::SetStatePersistence (NLB_HostState::NLB_HostStateType eState, bool bPersist) {

    return State.SetPersistence(eState, bPersist);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::GetStatePersistence (NLB_HostState::NLB_HostStateType eState, bool & bPersist) {

    return State.GetPersistence(eState, bPersist);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::SetDedicatedIPAddress (NLB_IPAddress address) {
    NLB_IPAddress::NLB_IPAddressType Type;

    if (!address.IsValid())
        return false;

    if (!address.GetIPAddressType(Type))
        return false;

    if (Type != NLB_IPAddress::Dedicated)
        return false;

    DedicatedIPAddress = address;
    
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::GetDedicatedIPAddress (NLB_IPAddress & address) {

    address = DedicatedIPAddress;

    return DedicatedIPAddress.IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::SetConnectionIPAddress (NLB_IPAddress address) {
    NLB_IPAddress::NLB_IPAddressType Type;
    
    if (!address.IsValid())
        return false;

    if (!address.GetIPAddressType(Type))
        return false;

    if (Type != NLB_IPAddress::Connection)
        return false;

    ConnectionIPAddress = address;
    
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::GetConnectionIPAddress (NLB_IPAddress & address) {

    address = ConnectionIPAddress;

    return ConnectionIPAddress.IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::SetAdapterName (PWCHAR pName) {

    NLB_ASSERT(pName);

    return Adapter.SetName(pName);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::GetAdapterName (PWCHAR pName, ULONG length) {

    NLB_ASSERT(pName);

    return Adapter.GetName(pName, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::SetAdapterGUID (PWCHAR pGUID) {

    NLB_ASSERT(pGUID);

    return Adapter.SetGUID(pGUID);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_Host::GetAdapterGUID (PWCHAR pGUID, ULONG length) {

    NLB_ASSERT(pGUID);

    return Adapter.GetGUID(pGUID, length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\control\control.cpp ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    control.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    Command-line utility

Author:

    kyrilf
    ramkrish (Post Win2K)

--*/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <process.h>
#include <time.h>
#include <locale.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tchar.h>
#include <shlwapi.h>

#include <strsafe.h>
#include "debug.h"

#define WLBSAPI_INTERNAL_ONLY
#define BACKWARD_COMPATIBILITY
#define CVY_MAX_ADAPTERS    16

#include "wlbsutil.h"
#include "wlbsctrl.h"
#include "wlbsconfig.h"
#include "wlbsparm.h"
#include "wlbsiocl.h"
#include "wlbsip.h"

#define CLIENT
#include "log_msgs.h"

/* CONSTANTS */
#define CVY_OK               1
#define CVY_ERROR_USAGE     -1
#define CVY_ERROR_REGISTRY  -2
#define CVY_ERROR_SYSTEM    -3
#define CVY_ERROR_USER      -4
#define CVY_BUF_SIZE        4096
#define CVY_MAX_EVENTS      10
#define CVY_MAX_INSERTS     10
#define CVY_ALL_CLUSTERS    0xffffffff
#define CVY_ALL_HOSTS       0xffffffff
#define CVY_LOCAL_CLUSTER   0
#define CVY_LOCAL_HOST      WLBS_LOCAL_HOST

typedef enum {
    mcastipaddress,
    iptomcastip,
    masksrcmac,
    iptomacenable,
    netmonalivemsgs
} WLBS_REG_KEYS;

typedef enum {
    query,
    suspend,
    resume,
    __start,
    stop,
    drainstop,
    enable,
    disable,
    drain,
    reload,
    display,
    ip2mac,
    help,
    registry,
    filter,
    params,
    queryport,
    bdateam,
    invalid
} WLBS_COMMANDS;

static HANDLE   file_hdl        = NULL;
static HANDLE   ConsoleHdl;
static BYTE     g_buffer [CVY_BUF_SIZE];
static WCHAR    message [CVY_BUF_SIZE];
static WCHAR    ConsoleBuf [CVY_BUF_SIZE];
static CHAR     g_szConsoleBuf [sizeof(WCHAR)*CVY_BUF_SIZE]; // Used when I/O is redirected to something other than the console buffer.
static WCHAR    wbuf [CVY_STR_SIZE];
static WCHAR    psw_buf [CVY_STR_SIZE];

static WCHAR    g_PathName [MAX_PATH + 1];
static BOOL     g_fOutToConsole = TRUE;

VOID WConsole(const wchar_t *fmt, ...)
{
   va_list  arglist;   
   DWORD    res1, res2;
   
   // Form a string out of the arguments
   va_start(arglist, fmt);
   (VOID) StringCchVPrintf(ConsoleBuf, ASIZECCH(ConsoleBuf), fmt, arglist);
   va_end(arglist);

   // Attempt WriteConsole, if it fails, do a wprintf
   if (g_fOutToConsole)
   {
       if (!WriteConsole(ConsoleHdl, ConsoleBuf, lstrlenW(ConsoleBuf), &res1, &res2))
       {
           wprintf(ConsoleBuf);
       }
   }
   else
   {
       //
       // Don't output anything if we fail to convert using the current code page.
       //
       if (WideCharToMultiByte( GetConsoleOutputCP(), 0, ConsoleBuf, -1, g_szConsoleBuf, ASIZECB(g_szConsoleBuf), NULL, NULL) != 0)
       {
           printf(g_szConsoleBuf);
       }
   }

   return;
}

VOID Message_print (DWORD id, ...) {
    va_list arglist;
    DWORD error;
    
    va_start(arglist, id);
    
    if (FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, id, 0, message, CVY_BUF_SIZE, & arglist) == 0) {
        error = GetLastError();
        
        //
        // Can't localize this because we've got a failure trying
        // to display a localized message..
        //
        WConsole(L"Could not print error message due to: ");
        
        if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, message, CVY_BUF_SIZE, NULL) == 0)
            WConsole(L"%d\n", error);
        else
            WConsole(L"\n %ls\n", message);
    } else
        WConsole(L"%ls", message);
}

VOID Error_print (BOOL sock) {
    DWORD error;

    if (sock) {
        error = WSAGetLastError();

        switch (error) {
            case WSAENETUNREACH:
                Message_print(IDS_CTR_WS_NUNREACH);
                break;
            case WSAETIMEDOUT:
                Message_print(IDS_CTR_WS_TIMEOUT);
                break;
            case WSAHOST_NOT_FOUND:
                Message_print(IDS_CTR_WS_NOAUTH);
                break;
            case WSATRY_AGAIN:
                Message_print(IDS_CTR_WS_NODNS);
                break;
            case WSAENETDOWN:
                Message_print(IDS_CTR_WS_NETFAIL);
                break;
            case WSAEHOSTUNREACH:
                Message_print(IDS_CTR_WS_HUNREACH);
                break;
            case WSAENETRESET:
                Message_print(IDS_CTR_WS_RESET);
                break;
            default:
                Message_print(IDS_CTR_ER_CODE, error);
                break;
        }
    } else {
        error = GetLastError();
        
        if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, message, CVY_BUF_SIZE, NULL) == 0)
            Message_print(IDS_CTR_ER_CODE, error);
        else
            WConsole(L"%ls\n", message);
    }

}

INT Report (WLBS_COMMANDS command, BOOLEAN condensed, ULONG ret_code, ULONG param1, ULONG param2,
            ULONG query_state, ULONG host_id, ULONG host_map) {
    ULONG i;
    BOOL first;

    switch (command) {
        case reload:
            if (ret_code == WLBS_BAD_PARAMS) {
                Message_print(IDS_CTR_BAD_PARAMS);
                return CVY_ERROR_USER;
            } else
                Message_print(IDS_CTR_RELOADED);

            break;
        case resume:
            if (condensed)
                if (ret_code == WLBS_ALREADY)
                    Message_print(IDS_CTR_RESUMED_C_A);
                else
                    Message_print(IDS_CTR_RESUMED_C);
            else
                if (ret_code == WLBS_ALREADY)
                    Message_print(IDS_CTR_RESUMED_A);
                else
                    Message_print(IDS_CTR_RESUMED);

            break;
        case suspend:
            if (condensed)
                if (ret_code == WLBS_ALREADY)
                    Message_print(IDS_CTR_SUSPENDED_C_A);
                else {
                    if (ret_code == WLBS_STOPPED)
                        Message_print(IDS_CTR_FROM_START_C);
                    
                    Message_print(IDS_CTR_SUSPENDED_C);
                }
            else
                if (ret_code == WLBS_ALREADY)
                    Message_print(IDS_CTR_SUSPENDED_A);
                else {
                    if (ret_code == WLBS_STOPPED)
                        Message_print(IDS_CTR_FROM_START);

                    Message_print(IDS_CTR_SUSPENDED);
                }

            break;
        case __start:
            if (ret_code == WLBS_SUSPENDED) {
                if (condensed)
                    Message_print(IDS_CTR_SUSPENDED_C);
                else
                    Message_print(IDS_CTR_SUSPENDED);

                return CVY_ERROR_USER;
            } else if (ret_code == WLBS_BAD_PARAMS) {
                if (condensed)
                    Message_print(IDS_CTR_BAD_PARAMS_C);
                else
                    Message_print(IDS_CTR_BAD_PARAMS);

                return CVY_ERROR_USER;
            } else {
                if (condensed)
                    if (ret_code == WLBS_ALREADY)
                        Message_print(IDS_CTR_STARTED_C_A);
                    else {
                        if (ret_code == WLBS_DRAIN_STOP)
                            Message_print(IDS_CTR_FROM_DRAIN_C);

                        Message_print(IDS_CTR_STARTED_C);
                    }
                else
                    if (ret_code == WLBS_ALREADY)
                        Message_print(IDS_CTR_STARTED_A);
                    else {
                        if (ret_code == WLBS_DRAIN_STOP)
                            Message_print(IDS_CTR_FROM_DRAIN);

                        Message_print(IDS_CTR_STARTED);
                    }
            }

            break;
        case stop:
            if (ret_code == WLBS_SUSPENDED) {
                if (condensed)
                    Message_print(IDS_CTR_SUSPENDED_C);
                else
                    Message_print(IDS_CTR_SUSPENDED);

                return CVY_ERROR_USER;
            }else {
                if (condensed)
                    if (ret_code == WLBS_ALREADY)
                        Message_print(IDS_CTR_STOPPED_C_A);
                    else
                        Message_print(IDS_CTR_STOPPED_C);
                else
                    if (ret_code == WLBS_ALREADY)
                        Message_print(IDS_CTR_STOPPED_A);
                    else
                        Message_print(IDS_CTR_STOPPED);
            }

            break;
        case drainstop:
            if (ret_code == WLBS_SUSPENDED) {
                if (condensed)
                    Message_print(IDS_CTR_SUSPENDED_C);
                else
                    Message_print(IDS_CTR_SUSPENDED);

                return CVY_ERROR_USER;
            } else {
                if (condensed)
                    if (ret_code == WLBS_STOPPED)
                        Message_print(IDS_CTR_STOPPED_C);
                    else if (ret_code == WLBS_ALREADY)
                        Message_print(IDS_CTR_DRAINED_C_A);
                    else
                        Message_print(IDS_CTR_DRAINED_C);
                else
                    if (ret_code == WLBS_STOPPED)
                        Message_print(IDS_CTR_STOPPED);
                    else if (ret_code == WLBS_ALREADY)
                        Message_print(IDS_CTR_DRAINED_A);
                    else
                        Message_print(IDS_CTR_DRAINED);
            }

            break;
        case enable:
        case disable:
        case drain:
            if (ret_code == WLBS_SUSPENDED) {
                if (condensed)
                    Message_print(IDS_CTR_SUSPENDED_C);
                else
                    Message_print(IDS_CTR_SUSPENDED);

                return CVY_ERROR_USER;
            } else if (ret_code == WLBS_STOPPED) {
                if (condensed)
                    Message_print(IDS_CTR_RLS_ST_C);
                else
                    Message_print(IDS_CTR_RLS_ST);

                return CVY_ERROR_USER;
            } else if (ret_code == WLBS_NOT_FOUND) {
                if (param2 == IOCTL_ALL_PORTS)
                {
                    if (param1 == IOCTL_ALL_VIPS) {
                        if (condensed)
                            Message_print(IDS_CTR_RLS_NORULES_C);
                        else
                            Message_print(IDS_CTR_RLS_NORULES);
                    }
                    else if (param1 == IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP)) 
                    {
                        if (condensed)
                            Message_print(IDS_CTR_RLS_NO_ALL_VIP_RULES_C);
                        else
                            Message_print(IDS_CTR_RLS_NO_ALL_VIP_RULES);
                    }
                    else
                    {
                        WCHAR szIpAddress[WLBS_MAX_CL_IP_ADDR+1];
                        AbcdWszFromIpAddress(param1, szIpAddress, ASIZECCH(szIpAddress));
                        if (condensed)
                            Message_print(IDS_CTR_RLS_NO_SPECIFIC_VIP_RULES_C, szIpAddress);
                        else
                            Message_print(IDS_CTR_RLS_NO_SPECIFIC_VIP_RULES, szIpAddress);
                    }
                }
                else
                {
                    if (param1 == IOCTL_ALL_VIPS) {
                        if (condensed)
                            Message_print(IDS_CTR_RLS_NONE_C, param2);
                        else
                            Message_print(IDS_CTR_RLS_NONE, param2);
                    }
                    else if (param1 == IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP)) 
                    {
                        if (condensed)
                            Message_print(IDS_CTR_RLS_NO_ALL_VIP_RULE_FOR_PORT_C, param2);
                        else
                            Message_print(IDS_CTR_RLS_NO_ALL_VIP_RULE_FOR_PORT, param2);
                    }
                    else
                    {
                        WCHAR szIpAddress[WLBS_MAX_CL_IP_ADDR+1];
                        AbcdWszFromIpAddress(param1, szIpAddress, ASIZECCH(szIpAddress));
                        if (condensed)
                            Message_print(IDS_CTR_RLS_NO_SPECIFIC_VIP_RULE_FOR_PORT_C, szIpAddress, param2);
                        else
                            Message_print(IDS_CTR_RLS_NO_SPECIFIC_VIP_RULE_FOR_PORT, szIpAddress, param2);
                    }
                }

                return CVY_ERROR_USER;
            } else {
                switch (command) 
                {
                    case enable:
                         if (condensed)
                             if (ret_code == WLBS_ALREADY)
                                Message_print(IDS_CTR_RLS_EN_C_A);
                             else
                                 Message_print(IDS_CTR_RLS_EN_C);
                         else
                             if (ret_code == WLBS_ALREADY)
                                 Message_print(IDS_CTR_RLS_EN_A);
                             else
                                 Message_print(IDS_CTR_RLS_EN);
                         break;
                    case disable:
                         if (condensed)
                             if (ret_code == WLBS_ALREADY)
                                 Message_print(IDS_CTR_RLS_DS_C_A);
                             else
                                 Message_print(IDS_CTR_RLS_DS_C);
                         else
                             if (ret_code == WLBS_ALREADY)
                                 Message_print(IDS_CTR_RLS_DS_A);
                             else
                                 Message_print(IDS_CTR_RLS_DS);
                         break;
                    case drain :
                         if (condensed)
                             if (ret_code == WLBS_ALREADY)
                                 Message_print(IDS_CTR_RLS_DR_C_A);
                             else
                                 Message_print(IDS_CTR_RLS_DR_C);
                         else
                             if (ret_code == WLBS_ALREADY)
                                 Message_print(IDS_CTR_RLS_DR_A);
                             else
                                 Message_print(IDS_CTR_RLS_DR);
                         break;
                }
            }

            break;
        case query:
            switch (query_state) {
                case WLBS_SUSPENDED:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_SP_C);
                    else
                        Message_print(IDS_CTR_CVG_SP, host_id);

                    return CVY_OK;
                case WLBS_STOPPED:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_UN_C);
                    else
                        Message_print(IDS_CTR_CVG_UN, host_id);

                    return CVY_OK;
                case WLBS_DISCONNECTED:
                    if (condensed)
                        Message_print(IDS_CTR_MEDIA_DISC_C);
                    else
                        Message_print(IDS_CTR_MEDIA_DISC, host_id);

                    return CVY_OK;
                case WLBS_DRAINING:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_DR_C);
                    else
                        Message_print(IDS_CTR_CVG_DR, host_id);

                    break;
                case WLBS_CONVERGING:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_PR_C);
                    else
                        Message_print(IDS_CTR_CVG_PR, host_id);

                    break;
                case WLBS_CONVERGED:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_SL_C);
                    else
                        Message_print(IDS_CTR_CVG_SL, host_id);

                    break;
                case WLBS_DEFAULT:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_MS_C);
                    else
                        Message_print(IDS_CTR_CVG_MS, host_id);

                    break;
                default:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_ER_C);
                    else
                        Message_print(IDS_CTR_CVG_ER, query_state);

                    return CVY_ERROR_SYSTEM;
            }

            if (!condensed) {
                first = TRUE;

                for (i = 0; i < 32; i ++) {
                    if (host_map & (1 << i)) {
                        if (!first)
                            WConsole (L", ");
                        else
                            first = FALSE;

                        WConsole(L"%d", i + 1);
                    }
                }

                WConsole (L"\n");
            }

            break;
        default:
            Message_print(IDS_CTR_IO_ER, command);
            break;
    }

    return CVY_OK;

}

//+----------------------------------------------------------------------------
//
// Function:  pfnQueryCallback
//
// Description:  Callback function to print out received results from remote
//               queries as they arrive. Called by Process only.
//
// Arguments: PWLBS_RESPONSE   pResponse - response structure from query. The
//                                 only fields guaranteed to be filled out are
//                                     pResponse.status 
//                                     pResponse.options.query.flags
//                                     pResponse.options.query.hostname
//                                     pResponse.id      
//                                     pResponse.address
//
// Returns:   VOID
//
// History:   chrisdar  07.31.01  Created
//
//+----------------------------------------------------------------------------
VOID pfnQueryCallback(PWLBS_RESPONSE pResponse)
{
    if (NULL == pResponse) { return; }

    //
    // Print the preamble to the hosts state, e.g., "Host 'hostID' ('ip address') reported: "
    //
    if (pResponse->address == 0) {
        if (pResponse->options.query.flags & NLB_OPTIONS_QUERY_HOSTNAME) {
            Message_print(IDS_CTR_HOST_NAME_ONLY, pResponse->id, pResponse->options.query.hostname);
        } else {
            Message_print(IDS_CTR_HOST_NEITHER, pResponse->id);
        }
    } else {
        DWORD len = CVY_STR_SIZE;
        WlbsAddressToString(pResponse->address, wbuf, &len);

        if (pResponse->options.query.flags & NLB_OPTIONS_QUERY_HOSTNAME) {
            Message_print(IDS_CTR_HOST_BOTH, pResponse->id, pResponse->options.query.hostname, wbuf);
        } else {
            Message_print(IDS_CTR_HOST_DIP_ONLY, pResponse->id, wbuf);
        }
    }

    if (pResponse->status == WLBS_BAD_PASSW) {
        Message_print(IDS_CTR_BAD_PASSW_C);
        WConsole(L"\n");
        return;
    }

    //
    // Print the state, e.g., "converged as DEFAULT".
    // Note: Most of the parameters are hardcoded here because of the constraints
    // under which it is valid to call the function callback.
    //
    // Arg 3 is the response for the API call, which we do not have since the
    // function call is not yet complete. Feed it the individual host status,
    // since the overall status is just the worst status from the hosts that
    // respond anyway. 
    //
    Report(query, TRUE, pResponse->status, 0, 0, pResponse->status, pResponse->id, 0);
}

INT Display (DWORD cluster) {
    HANDLE hdl;
    HINSTANCE lib;
    DWORD flag;
    DWORD actual, needed, records, index = 0, got = 0;
    DWORD j, i, code;
    PWCHAR strp;
    PWCHAR prot;
    WCHAR aff;
    time_t curr_time;
    PWLBS_PORT_RULE rp, rulep;
    BYTE * inserts[CVY_MAX_INSERTS];
    WLBS_REG_PARAMS params;
    DWORD status;

    status = WlbsReadReg(cluster, &params);

    if (status != WLBS_OK) {
        Message_print (IDS_CTR_REMOTE);
        return CVY_ERROR_USER;
    }

    Message_print(IDS_CTR_DSP_CONFIGURATION);

    WCHAR TimeStr[64];
    SYSTEMTIME SysTime;
    GetLocalTime(&SysTime);
    FormatTheTime(&SysTime, TimeStr, sizeof(TimeStr)/sizeof(WCHAR));

    WConsole(L"%-25.25ls = %ls\n", L"Current time", TimeStr);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_VERSION, params.i_parms_ver);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_VIRTUAL_NIC, params.i_virtual_nic_name);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_ALIVE_PERIOD, params.alive_period);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_ALIVE_TOLER, params.alive_tolerance);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_NUM_ACTIONS, params.num_actions);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_NUM_PACKETS, params.num_packets);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_NUM_SEND_MSGS, params.num_send_msgs);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_NETWORK_ADDR, params.cl_mac_addr);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_DOMAIN_NAME, params.domain_name);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_CL_IP_ADDR, params.cl_ip_addr);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_CL_NET_MASK, params.cl_net_mask);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_DED_IP_ADDR, params.ded_ip_addr);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_DED_NET_MASK, params.ded_net_mask);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_HOST_PRIORITY, params.host_priority);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_CLUSTER_MODE, (params.cluster_mode == CVY_HOST_STATE_STARTED) ? L"STARTED" : 
                                                          (params.cluster_mode == CVY_HOST_STATE_STOPPED) ? L"STOPPED" :
                                                          (params.cluster_mode == CVY_HOST_STATE_SUSPENDED) ? L"SUSPENDED" : L"UNKNOWN");
    WConsole(L"%-25.25ls = ", CVY_NAME_PERSISTED_STATES);

    if (!params.persisted_states)
        WConsole(L"NONE");

    if (params.persisted_states & CVY_PERSIST_STATE_STOPPED) {
        WConsole(L"STOPPED");
        
        if ((params.persisted_states &= ~CVY_PERSIST_STATE_STOPPED))
            WConsole(L", ");
    }

    if (params.persisted_states & CVY_PERSIST_STATE_STARTED) {
        WConsole(L"STARTED");
        
        if ((params.persisted_states &= ~CVY_PERSIST_STATE_STARTED))
            WConsole(L", ");
    }

    if (params.persisted_states & CVY_PERSIST_STATE_SUSPENDED) {
        WConsole(L"SUSPENDED");
        
        if ((params.persisted_states &= ~CVY_PERSIST_STATE_SUSPENDED))
            WConsole(L", ");
    }

    WConsole(L"\n");

    WConsole(L"%-25.25ls = %d\n", CVY_NAME_DSCR_PER_ALLOC, params.dscr_per_alloc);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_MAX_DSCR_ALLOCS, params.max_dscr_allocs);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_TCP_TIMEOUT, params.tcp_dscr_timeout);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_IPSEC_TIMEOUT, params.ipsec_dscr_timeout);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_FILTER_ICMP, params.filter_icmp ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_SCALE_CLIENT, params.i_scale_client);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_NBT_SUPPORT, params.i_nbt_support);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_MCAST_SUPPORT, params.mcast_support);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_MCAST_SPOOF, params.i_mcast_spoof);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_MASK_SRC_MAC, params.mask_src_mac);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_IGMP_SUPPORT, params.fIGMPSupport ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_IP_TO_MCASTIP, params.fIpToMCastIp ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_MCAST_IP_ADDR, params.szMCastIpAddress);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_NETMON_ALIVE, params.i_netmon_alive);
    if (params.i_effective_version == CVY_NT40_VERSION_FULL)
        WConsole(L"%-25.25ls = %ls\n", CVY_NAME_EFFECTIVE_VERSION, CVY_NT40_VERSION);
    else
        WConsole(L"%-25.25ls = %ls\n", CVY_NAME_EFFECTIVE_VERSION, CVY_VERSION);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_IP_CHG_DELAY, params.i_ip_chg_delay);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_CONVERT_MAC, params.i_convert_mac);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_CLEANUP_DELAY, params.i_cleanup_delay);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_RCT_ENABLED, params.rct_enabled);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_RCT_PORT, params.rct_port);
    WConsole(L"%-25.25ls = 0x%X\n", CVY_NAME_RCT_PASSWORD, params.i_rct_password);
    WConsole(L"%-25.25ls = 0x%X\n", CVY_NAME_RMT_PASSWORD, params.i_rmt_password);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_CUR_VERSION, CVY_VERSION);
    WConsole(L"%-25.25ls = 0x%X\n", CVY_NAME_INSTALL_DATE, params.install_date);
    WConsole(L"%-25.25ls = 0x%X\n", CVY_NAME_VERIFY_DATE, params.i_verify_date);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_NUM_RULES, params.i_num_rules);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_BDA_TEAMING, params.bda_teaming.active ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_BDA_TEAM_ID, params.bda_teaming.team_id);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_BDA_MASTER, params.bda_teaming.master ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_BDA_REVERSE_HASH, params.bda_teaming.reverse_hash ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_ID_HB_PERIOD, params.identity_period);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_ID_HB_ENABLED, params.identity_enabled ? L"ENABLED" : L"DISABLED");

    WConsole(L"%-25.25ls \n", CVY_NAME_PORT_RULES);

    WConsole(L"Virtual IP addr Start\tEnd\tProt\tMode\t\tPri\tLoad\tAffinity\n");

    for (i = 0; i < params.i_num_rules; i ++) {
        rp = params.i_port_rules + i;

        code = CVY_RULE_CODE_GET(rp);

        CVY_RULE_CODE_SET(rp);

        if (code != CVY_RULE_CODE_GET(rp)) {
            Message_print(IDS_CTR_BAD_RULE_CODE, code, CVY_RULE_CODE_GET(rp));
            rp->code = code;
            continue;
        }

        if (!rp->valid) {
            Message_print(IDS_CTR_INVALID_RULE);
            continue;
        }

        if (rp->start_port > rp->end_port) {
            Message_print(IDS_CTR_BAD_PORT_RANGE, rp->start_port, rp->end_port);
            continue;
        }

        for (j = 0; j < i; j ++) {
            rulep = params.i_port_rules + j;
            if ((IpAddressFromAbcdWsz(rulep->virtual_ip_addr) == IpAddressFromAbcdWsz(rp->virtual_ip_addr)) 
             && ((rulep->start_port < rp->start_port && rulep->end_port >= rp->start_port) ||
                 (rulep->start_port >= rp->start_port && rulep->start_port <= rp->end_port))) {
                Message_print(IDS_CTR_PORT_RANGE_OVERLAP, i, rp->start_port, rp->end_port, j, rulep->start_port, rulep->end_port);
                continue;
            }
        }

        if (rp->start_port > CVY_MAX_PORT) {
            Message_print(IDS_CTR_BAD_START_PORT, rp->start_port);
            continue;
        }

        if (rp->end_port > CVY_MAX_PORT) {
            Message_print(IDS_CTR_BAD_END_PORT, rp->end_port);
            continue;
        }

        if (rp->protocol < CVY_MIN_PROTOCOL || rp->protocol > CVY_MAX_PROTOCOL) {
            Message_print(IDS_CTR_BAD_PROTOCOL, rp->protocol);
            continue;
        }

        if (rp->mode < CVY_MIN_MODE || rp->mode > CVY_MAX_MODE) {
            Message_print(IDS_CTR_BAD_MODE, rp->mode);
            continue;
        }

        switch (rp->protocol) {
            case CVY_TCP:
                prot = L"TCP";
                break;
            case CVY_UDP:
                prot = L"UDP";
                break;
            default:
                prot = L"Both";
                break;
        }

        if (!lstrcmpi(rp->virtual_ip_addr, CVY_DEF_ALL_VIP))            
            WConsole(L"%15ls\t%5d\t%5d\t%ls\t", L"ALL", rp->start_port, rp->end_port, prot);
        else
            WConsole(L"%15ls\t%5d\t%5d\t%ls\t", rp->virtual_ip_addr, rp->start_port, rp->end_port, prot);

        switch (rp->mode) {
            case CVY_SINGLE:
                WConsole(L"%-10.10ls\t%2d", L"Single", rp->mode_data.single.priority);
                break;
            case CVY_MULTI:
                if (rp->mode_data.multi.affinity == CVY_AFFINITY_NONE)
                    aff = L'N';
                else if (rp->mode_data.multi.affinity == CVY_AFFINITY_SINGLE)
                    aff = L'S';
                else
                    aff = L'C';

                if (rp->mode_data.multi.equal_load)
                    WConsole(L"%-10.10ls\t\tEqual\t%lc", L"Multiple", aff);
                else {
                    if (rp->mode_data.multi.load > CVY_MAX_LOAD) {
                        Message_print(IDS_CTR_BAD_LOAD, rp->mode_data.multi.load);
                        continue;
                    }

                    WConsole(L"%-10.10ls\t\t%3d\t%lc", L"Multiple", rp->mode_data.multi.load, aff);
                }

                break;
            default:
                WConsole(L"%-10.10ls", L"Disabled");
                break;
        }

        WConsole(L"\n");
    }

    WConsole(L"\n");

    Message_print(IDS_CTR_DSP_EVENTLOG);

    hdl = OpenEventLog (NULL, L"System");

    if (hdl == NULL) {
        Message_print(IDS_CTR_EVNT_LOG_OPEN_FAIL);
        Error_print (FALSE);
        return CVY_ERROR_SYSTEM;
    }

    if (!GetNumberOfEventLogRecords(hdl, &records)) {
        Message_print(IDS_CTR_EVNT_LOG_NUM_OF_REC_FAIL);
        Error_print (FALSE);
        CloseEventLog (hdl);
        return CVY_ERROR_SYSTEM;
    }

    if (!GetOldestEventLogRecord (hdl, & index)) {
        Message_print(IDS_CTR_EVNT_LOG_LATEST_REC_FAIL);
        Error_print (FALSE);
        CloseEventLog (hdl);
        return CVY_ERROR_SYSTEM;
    }

    const WCHAR* pwcszFile = L"\\drivers\\%ls.sys";

    UINT uiSysDirLen = GetSystemDirectory (g_PathName, ASIZECCH(g_PathName));

    ASSERT( (uiSysDirLen <= (ASIZECCH(g_PathName) - 1)) && (uiSysDirLen != 0) );

    HRESULT hr = StringCchPrintf(g_PathName + uiSysDirLen, ASIZECCH(g_PathName) - uiSysDirLen, pwcszFile, CVY_NAME);

    ASSERT(hr == S_OK);

    lib = LoadLibrary(g_PathName);

    if (lib == NULL) {
        Message_print(IDS_CTR_LOAD_LIB_FAIL);
        Error_print (FALSE);
        CloseEventLog (hdl);
        return CVY_ERROR_SYSTEM;
    }

    index += records - 1;

    flag = EVENTLOG_SEEK_READ | EVENTLOG_BACKWARDS_READ;

    while (got < CVY_MAX_EVENTS && ReadEventLog(hdl, flag, index, g_buffer, sizeof(g_buffer), &actual, &needed)) {
        LPBYTE pbCurrent = g_buffer;

        while (got < CVY_MAX_EVENTS && actual > 0) {
            UNALIGNED EVENTLOGRECORD * recp = (EVENTLOGRECORD *) pbCurrent;

            if (wcscmp ((PWSTR)(((PBYTE) recp) + sizeof(EVENTLOGRECORD)), CVY_NAME) == 0) {
                time_t TimeGenerated = recp->TimeGenerated;
                
                ConvertTimeToSystemTime(TimeGenerated, TimeStr, sizeof(TimeStr)/sizeof(WCHAR));

                strp = (PWCHAR)((LPBYTE)recp + recp->StringOffset);

                for (i = 0; i < CVY_MAX_INSERTS; i ++) {
                    if (i < recp->NumStrings) {
                        inserts[i] = (BYTE*)strp;
                        strp += wcslen (strp) + 1;
                    } else
                        inserts[i] = 0;
                }

                DWORD dwStatus = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY, lib,
                                               recp->EventID, 0, (PWCHAR)message, CVY_BUF_SIZE, (va_list *)inserts);

                //
                // We have multiple message files that store the text for WLBS events, but we are only checking one of them.
                // This code is essentially legacy, so instead of fixing it to search all of the message files, we ignore
                // "not found" errors.
                //
                if (dwStatus > 0 || GetLastError() != ERROR_MR_MID_NOT_FOUND)
                {
                    WConsole(L"#%02d ID: 0x%08X Type: %d Category: %d ", index--, recp->EventID, recp->EventType, recp->EventCategory);
                    WConsole(L"Time: %ls\n", TimeStr);

                    if (dwStatus == 0) {
                        WConsole(L"Could not load message string due to:\n");
                        Error_print(FALSE);
                    } else
                        WConsole(L"%ls", message);

                    for (i = 0; i < recp->DataLength / sizeof(DWORD); i ++) {
                        if (i != 0 && i % 8 == 0)
                            WConsole(L"\n");
                    
                        WConsole(L"%08X ", *(UNALIGNED DWORD*)((PBYTE)recp + recp->DataOffset + i * sizeof(DWORD)));
                    }

                    WConsole(L"\n\n");
                    got++;
                }
            }

            actual -= recp->Length;
            pbCurrent += recp->Length;
            index--;
        }

        flag = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ;
    }

    FreeLibrary(lib);
    CloseEventLog(hdl);

    Message_print(IDS_CTR_DSP_IPCONFIG);

    fflush(stdout);

    const WCHAR* pwcszCmd = L"\\ipconfig.exe";
    const WCHAR* pwcszOption = L"/all";

    uiSysDirLen = GetSystemDirectory(g_PathName, ASIZECCH(g_PathName));

    ASSERT( (uiSysDirLen <= (ASIZECCH(g_PathName) - 1)) && (uiSysDirLen != 0) );

    hr = StringCchCat(g_PathName, ASIZECCH(g_PathName), pwcszCmd);

    ASSERT(hr == S_OK);

    if (_wspawnl(_P_WAIT, g_PathName, g_PathName, pwcszOption, NULL) == -1)
    {
        const DWORD dwErrno = errno;
        if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwErrno, 0, wbuf, CVY_STR_SIZE, NULL) == 0)
        {
            //
            // If we can't resolve the message, then we just print the error code
            //
            (VOID) StringCchPrintf(wbuf, CVY_STR_SIZE, L"11%d", dwErrno);
        }

        Message_print(IDS_CTR_CMD_EXEC_FAILED, wbuf);
        wbuf[0] = L'\0';
    }

    Message_print(IDS_CTR_DSP_STATE);

    return CVY_OK;

}

/* This function parses the remaining arguments to determine whether the command
 * is for all clusters, or a remote cluster or for a single local cluster. */
BOOLEAN Parse (INT argc, PWCHAR argv [], PINT arg_index, PDWORD ptarget_cl, PDWORD ptarget_host) {
    PWCHAR phost;

#ifdef BACKWARD_COMPATIBILITY
    *ptarget_cl = CVY_ALL_CLUSTERS;
    *ptarget_host = CVY_LOCAL_HOST;

    if (*arg_index >= argc)
        return TRUE;
#endif
    
    /* At this point, argv[arg_index] == cluster_ip and/or argv[arg_index+1] == /local or /passw or /port */

    //
    // Special check for /PASSW without a cluster ID, because this is
    // a common error
    //
    if (   _wcsicmp (argv [*arg_index], L"/passw") == 0
        || _wcsicmp (argv [*arg_index], L"-passw") == 0)
    {
        Message_print (IDS_CTR_PSSW_WITHOUT_CLUSTER);
                return FALSE;

    }

    phost = wcschr(argv[* arg_index], L':');

    /* if there is no host part - operation applies to all hosts */
    if (phost == NULL) {
        *ptarget_host = CVY_ALL_HOSTS;
    } else {
        /* split target name so targ points to cluster name and host to host name */
        *phost = 0;
        phost ++;

        if (wcslen(phost) <= 2 && phost[0] >= L'0' && phost[0] <= L'9' && ((phost[1] >= L'0' && phost[1] <= L'9') || phost[1] == 0))
            *ptarget_host = _wtoi(phost);
        else {
            *ptarget_host = WlbsResolve(phost);

            if (*ptarget_host == 0) {
                Message_print(IDS_CTR_BAD_HOST_NAME_IP);
                return FALSE;
            }
        }
    }

    // Retrieve the Cluster IP Address or "ALL"
    if (_wcsicmp (argv[*arg_index], L"all") == 0)
    {
        // If there is a host part, then, cluster ip can not be "ALL"
        if (*ptarget_host != CVY_ALL_HOSTS) 
        {
            Message_print(IDS_CTR_BAD_CLUSTER_NAME_IP);
            return FALSE;
        }
        *ptarget_cl = CVY_ALL_CLUSTERS;
    }
    else
    {
        *ptarget_cl = WlbsResolve(argv[*arg_index]);
        if (*ptarget_cl == 0) {
            Message_print(IDS_CTR_BAD_CLUSTER_NAME_IP);
            return FALSE;
        }
    }

    (*arg_index)++;

    // If there is no host part, then, there better be the LOCAL or GLOBAL flag
    if (*ptarget_host == CVY_ALL_HOSTS) 
    {
        if (*arg_index == argc)
        {
#ifdef BACKWARD_COMPATIBILITY
            return TRUE;
#else
            Message_print(IDS_CTR_CLUSTER_WITHOUT_LOCAL_GLOBAL_FLAG);
            return FALSE;
#endif
        }

        if (_wcsicmp (argv[*arg_index], L"local") == 0) 
        {
            *ptarget_host = CVY_LOCAL_HOST;
            (*arg_index)++;
        } 
#ifdef BACKWARD_COMPATIBILITY
        else if ((argv[*arg_index][0] == L'/') || (argv[*arg_index][0] == L'-')) 
        {
            if (_wcsicmp(argv[*arg_index] + 1, L"local") == 0) 
            {
                *ptarget_host = CVY_LOCAL_HOST;
                (*arg_index)++;
            }
        }
#endif
        else if (_wcsicmp (argv[*arg_index], L"global") == 0)
        {
            // Already set to CVY_ALL_HOSTS
            (*arg_index)++;
        }
        else
        {
            Message_print(IDS_CTR_CLUSTER_WITHOUT_LOCAL_GLOBAL_FLAG);
            return FALSE;
        }
    }

    if (*arg_index == argc)
        return TRUE;

    if ((argv[*arg_index][0] == L'/') || (argv[*arg_index][0] == L'-')) {
#ifdef BACKWARD_COMPATIBILITY
        if (_wcsicmp(argv[*arg_index] + 1, L"local") == 0) {
            (*arg_index)++;
            *ptarget_host = CVY_LOCAL_HOST;
            return TRUE;
        } else 
#endif
        if ((_wcsicmp(argv[*arg_index] + 1, L"port")  == 0) || (_wcsicmp(argv[*arg_index] + 1, L"passw") == 0) || (_wcsicmp(argv[*arg_index] + 1, L"commit") == 0))
            return TRUE;
        else
            return FALSE;
    } else
        return FALSE;

}

VOID Report_convergence_info (ULONG host, ULONG status, PNLB_OPTIONS pOptions) {
    
    /* If the host is stopped, suspended, or disconnected, then no convergence information was returned. 
       This should be caught by the next check as well, but just in case, check here too. */
    if ((status == WLBS_STOPPED) || (status == WLBS_SUSPENDED) || (status == WLBS_DISCONNECTED)) return;

    /* If no convergence information was provided, we can bail out here. */
    if (!(pOptions->query.flags & NLB_OPTIONS_QUERY_CONVERGENCE)) return;

    /* If the time since the last convergence is non-zero, then convergence 
       has completed.  Calculate the time of the last convergence completion
       as the current time minus the time since the last convergence. */
    if (pOptions->query.LastConvergence == NLB_QUERY_TIME_INVALID) {

        /* Convergence is on-going. */
        Message_print(IDS_CTR_CONVERGENCE_INCOMPLETE, host, pOptions->query.NumConvergences);

    } else {
        WCHAR  szLast[64]; /* The string returned by _wctime is ALWAYS 26 characters. */
        time_t tLast;

        /* Get the current time. */
        time(&tLast);

        /* Decrement time by the elapsed time to get the wall clock time of the
           last convergence completion.  Note this is not an exact science as the 
           load module tracks time on a much looser basis than the system does 
           in general, so the two may be "out of whack" by up to a second, which
           can result in two consecutive queries coming up with times for the 
           last convergence that differ by a second. */
        tLast -= pOptions->query.LastConvergence;

        ConvertTimeToSystemTime(tLast, szLast, sizeof(szLast)/sizeof(WCHAR));

        /* Print the time of the last completed convergence. */
        Message_print(IDS_CTR_CONVERGENCE_COMPLETE, host, pOptions->query.NumConvergences, szLast);
    }

    return;
}

VOID Process (WLBS_COMMANDS command, DWORD target_cl, DWORD target_host, ULONG param1,
              ULONG param2, ULONG param3, ULONG dest_port, DWORD dest_addr, PWCHAR dest_password) {
    DWORD              len        = WLBS_MAX_CL_IP_ADDR + 1;
    DWORD              host_map;
    DWORD              status;
    DWORD              i;
    WLBS_REG_PARAMS    reg_data;
    PFN_QUERY_CALLBACK pfnQueryCB = &pfnQueryCallback; // Address of callback function.
    DWORD              num_hosts  = WLBS_MAX_HOSTS;

    PWLBS_RESPONSE     pResponse = new WLBS_RESPONSE[num_hosts];

    if (pResponse == NULL)
    {
        Message_print(IDS_CTR_FAILED_MALLOC);
        return;
    }

    WlbsPasswordSet(target_cl, dest_password);
    WlbsPortSet(target_cl, (USHORT)dest_port);

    switch (command) {
    case query:
        status = WlbsQuery(target_cl, target_host, pResponse, &num_hosts, &host_map, pfnQueryCB);
        break;
    case __start:
        status = WlbsStart(target_cl, target_host, pResponse, &num_hosts);
        break;
    case stop:
        status = WlbsStop(target_cl, target_host, pResponse, &num_hosts);
        break;
    case suspend:
        status = WlbsSuspend(target_cl, target_host, pResponse, &num_hosts);
        break;
    case resume:
        status = WlbsResume(target_cl, target_host, pResponse, &num_hosts);
        break;
    case drainstop:
        status = WlbsDrainStop(target_cl, target_host, pResponse, &num_hosts);
        break;
    case enable:
        status = WlbsEnable(target_cl, target_host, pResponse, &num_hosts, param1, param2);
        break;
    case disable:
        status = WlbsDisable(target_cl, target_host, pResponse, &num_hosts, param1, param2);
        break;
    case drain:
        status = WlbsDrain(target_cl, target_host, pResponse, &num_hosts,  param1, param2);
        break;
    case reload:
        status = WlbsNotifyConfigChange(target_cl);

        if (status == WLBS_LOCAL_ONLY) {
            Message_print(IDS_CTR_REMOTE);
            goto end;
        }

        if (status == WLBS_REG_ERROR || status == WLBS_BAD_PARAMS) {
            Message_print(IDS_CTR_BAD_PARAMS);
            goto end;
        }

        if (status == WLBS_OK) {
            Message_print(IDS_CTR_RELOADED);
            goto end;
        }

        break;
    case display:
        Display(target_cl);
        Process(query, target_cl, target_host, param1, param2, param3, dest_port, dest_addr, dest_password);
        goto end;
    case registry:
        if ((status = WlbsReadReg(target_cl, &reg_data)) != WLBS_OK) {
            Message_print(IDS_CTR_REG_READ);
            goto end;
        }

        switch (param1) {
        case mcastipaddress:
            reg_data.fIpToMCastIp = FALSE;
            WlbsAddressToString(param2, reg_data.szMCastIpAddress, &len);
            break;
        case iptomcastip:
            reg_data.fIpToMCastIp = param2;
            break;
        case iptomacenable:
            reg_data.i_convert_mac = param2;
            break;
        case masksrcmac:
            reg_data.mask_src_mac = param2;
            break;
        case netmonalivemsgs:
            reg_data.i_netmon_alive = param2;
            break;
        }

        if ((status = WlbsWriteReg(target_cl, &reg_data)) != WLBS_OK) {
            Message_print(IDS_CTR_REG_WRITE);
            goto end;
        }

        /* Reload the driver, if /COMMIT was specified. */
        if (param3)
            Process(reload, target_cl, target_host, param1, param2, param3, dest_port, dest_addr, dest_password);

        switch (param1) {
        case mcastipaddress:
        {
            TCHAR igmpaddr[WLBS_MAX_CL_IP_ADDR + 1];
            DWORD dwIgmpAddrLen = WLBS_MAX_CL_IP_ADDR + 1;

            WlbsAddressToString (param2, igmpaddr, &dwIgmpAddrLen);

            Message_print(IDS_CTR_REG_MCASTIPADDRESS, igmpaddr);
            break;
        }
        case iptomcastip:
            Message_print((param2) ? IDS_CTR_REG_IPTOMCASTIP_ON : IDS_CTR_REG_IPTOMCASTIP_OFF);
            break;
        case masksrcmac:
            Message_print((param2) ? IDS_CTR_REG_MASKSRCMAC_ON : IDS_CTR_REG_MASKSRCMAC_OFF);
            break;
        case iptomacenable:
            Message_print((param2) ? IDS_CTR_REG_IPTOMACENABLE_ON : IDS_CTR_REG_IPTOMACENABLE_OFF);
            break;
        case netmonalivemsgs:
            Message_print((param2) ? IDS_CTR_REG_NETMONALIVEMSGS_ON : IDS_CTR_REG_NETMONALIVEMSGS_OFF);
            break;
        }

        goto end;
    default:
        goto end;
    }

    if (status == WLBS_INIT_ERROR) {
        Message_print(IDS_CTR_INIT);
        goto end;
    }

    if (status == WLBS_IO_ERROR) {
        if (command == drain || command == disable || command == enable)
        {
            Message_print(IDS_CTR_PORTRULE_NOT_FOUND_OR_IOCTL_FAILED);
        }
        else
        {
            Message_print(IDS_CTR_IO_ERROR);
        }
        goto end;
    }

    if (status == WLBS_LOCAL_ONLY) {
        Message_print(IDS_CTR_WSOCK);
        goto end;
    }

    if (status == WLBS_REMOTE_ONLY) {
        Message_print(IDS_CTR_NO_CVY, CVY_NAME);
        goto end;
    }

    if (status >= WSABASEERR) {
        Message_print(IDS_CTR_WSOCK);
        Error_print(TRUE);
        goto end;
    }

    if (status == WLBS_TIMEOUT) {
        Message_print(IDS_CTR_NO_RSP3);

        if (command != query)
            Message_print(IDS_CTR_NO_RSP4, CVY_NAME);

        goto end;
    }

    if (status == WLBS_NOT_FOUND) {
        Message_print(IDS_CTR_NOT_FOUND);
        goto end;
    }

    if (target_host == CVY_LOCAL_HOST) {
        if (command == query)
        {
            //
            // A query requires that at least one host responded for use to print out information
            //
            if (num_hosts == 0)
            {
                goto end;
            }

            Report_convergence_info(pResponse[0].id, pResponse[0].status, &pResponse[0].options);

            Report(command, FALSE, status, param1, param2, pResponse[0].status, pResponse[0].id, host_map);
        }
        else
        {
            //
            // All commands other than query ignore the "status" and "id" information
            //
            ULONG ulStatus = 0;
            ULONG ulId     = 0;
            Report(command, FALSE, status, param1, param2, ulStatus, ulId, host_map);
        }

        goto end;
    }

    /* The callback function, if provided, prints report information. Return
       here if we have a callback for a query operation */
    if (command == query && NULL != pfnQueryCB) {
        goto end;
    }

    /* Call Report for each host's response */
    for (i = 0; i < num_hosts; i++) {
        if (pResponse[i].address == 0) {
            if (pResponse[i].options.query.flags & NLB_OPTIONS_QUERY_HOSTNAME) {
                Message_print(IDS_CTR_HOST_NAME_ONLY, pResponse[i].id, pResponse[i].options.query.hostname);
            } else {
                Message_print(IDS_CTR_HOST_NEITHER, pResponse[i].id);
            }
        } else {
            DWORD dwAddrLen = CVY_STR_SIZE;
            WlbsAddressToString(pResponse[i].address, wbuf, &dwAddrLen);

            if (pResponse[i].options.query.flags & NLB_OPTIONS_QUERY_HOSTNAME) {
                Message_print(IDS_CTR_HOST_BOTH, pResponse[i].id, pResponse[i].options.query.hostname, wbuf);
            } else {
                Message_print(IDS_CTR_HOST_DIP_ONLY, pResponse[i].id, wbuf);
            }
        }

        if (pResponse[i].status == WLBS_BAD_PASSW) {
            if (target_host != CVY_ALL_HOSTS) {
                WConsole(L"\n");
                Message_print(IDS_CTR_BAD_PASSW);
            } else {
                Message_print(IDS_CTR_BAD_PASSW_C);
                WConsole(L"\n");
            }

            continue;
        }

        Report(command, TRUE, pResponse[i].status, param1, param2, pResponse[i].status, pResponse[i].id, host_map);
    }

end:
    delete [] pResponse;

    return;
}

VOID Report_port_state (WLBS_RESPONSE response) {
    WCHAR PacketsAccepted[CVY_STR_SIZE];
    WCHAR PacketsDropped[CVY_STR_SIZE];
    WCHAR BytesAccepted[CVY_STR_SIZE];
    WCHAR BytesDropped[CVY_STR_SIZE];

    if (response.status != WLBS_OK) {
        Message_print(IDS_CTR_QUERY_PORT_FAILED);
        return;
    }

    switch (response.options.state.port.Status) {
    case NLB_PORT_RULE_NOT_FOUND:
        Message_print(IDS_CTR_QUERY_PORT_NOT_FOUND);
        break;
    case NLB_PORT_RULE_ENABLED:
        (VOID) StringCchPrintf(PacketsAccepted, ASIZECCH(PacketsAccepted), L"%I64u", response.options.state.port.Statistics.Packets.Accepted);
        (VOID) StringCchPrintf(PacketsDropped,  ASIZECCH(PacketsDropped),  L"%I64u", response.options.state.port.Statistics.Packets.Dropped);

        Message_print(IDS_CTR_QUERY_PORT_ENABLED);
        Message_print(IDS_CTR_QUERY_PORT_STATISTICS, PacketsAccepted, PacketsDropped);

        break;
    case NLB_PORT_RULE_DISABLED:
        Message_print(IDS_CTR_QUERY_PORT_DISABLED);
        break;
    case NLB_PORT_RULE_DRAINING:
        Message_print(IDS_CTR_QUERY_PORT_DRAINING);
        break;
    default:
        Message_print(IDS_CTR_QUERY_PORT_UNKNOWN);
        break;
    }
    
    return;
}

VOID Report_bda_state (WLBS_RESPONSE response) {
    WCHAR ipaddr[CVY_STR_SIZE];
    DWORD len;
    DWORD index;

    if (response.status == WLBS_NOT_FOUND) {
        Message_print(IDS_CTR_QUERY_BDA_NOT_FOUND);
        return;
    }

    if (response.status != WLBS_OK) {
        Message_print(IDS_CTR_QUERY_BDA_FAILED);
        return;
    }
    
    len = CVY_STR_SIZE;
    WlbsAddressToString(response.options.state.bda.Team.Master, ipaddr, &len);

    if (response.options.state.bda.Team.Active)
        WConsole(L"%-22.22ls = %ls\n",  L"Active",             L"Yes");
    else if ((response.options.state.bda.Team.MembershipMap != response.options.state.bda.Team.ConsistencyMap) && !response.options.state.bda.Team.Master)
        WConsole(L"%-22.22ls = %ls\n",  L"Active",             L"No (Inconsistent configuration detected / No master specified)");
    else if (response.options.state.bda.Team.MembershipMap != response.options.state.bda.Team.ConsistencyMap)
        WConsole(L"%-22.22ls = %ls\n",  L"Active",             L"No (Inconsistent configuration detected)");
    else if (!response.options.state.bda.Team.Master)
        WConsole(L"%-22.22ls = %ls\n",  L"Active",             L"No (No master specified)");
    else 
        WConsole(L"%-22.22ls = %ls\n",  L"Active",             L"No (Unknown reason)");

    WConsole(L"%-22.22ls = %08x\n", L"Membership fingerprint", response.options.state.bda.Team.MembershipFingerprint);
    WConsole(L"%-22.22ls = %08x\n", L"Membership map",         response.options.state.bda.Team.MembershipMap);
    WConsole(L"%-22.22ls = %08x\n", L"Consistency map",        response.options.state.bda.Team.ConsistencyMap);
    WConsole(L"%-22.22ls = %ls\n",  L"Master",                 ipaddr);

    WConsole(L"\n%ls (%d)\n",       L"Members",                response.options.state.bda.Team.MembershipCount);

    for (index = 0; index < response.options.state.bda.Team.MembershipCount; index++) {
        len = CVY_STR_SIZE;
        WlbsAddressToString(response.options.state.bda.Team.Members[index].ClusterIPAddress, ipaddr, &len);

        WConsole(L"%ls %ls:\n",           L"Cluster",      ipaddr);
        WConsole(L"  %-20.20ls = %d\n",   L"Member ID",    response.options.state.bda.Team.Members[index].MemberID);
        WConsole(L"  %-20.20ls = %ls\n",  L"Master",       response.options.state.bda.Team.Members[index].Master ? L"Yes" : L"No");
        WConsole(L"  %-20.20ls = %ls\n",  L"Reverse hash", response.options.state.bda.Team.Members[index].ReverseHash ? L"Yes" : L"No");

        if (index < (response.options.state.bda.Team.MembershipCount - 1)) WConsole(L"\n");
    }

    return;
}

VOID Report_filter_state (WLBS_RESPONSE response) {

    if (response.status != WLBS_OK) {
        Message_print(IDS_CTR_QUERY_FILTER_FAILED);
        return;
    }
    
    switch (response.options.state.filter.Accept) {
    case NLB_REJECT_LOAD_MODULE_INACTIVE:
        Message_print(IDS_CTR_QUERY_FILTER_REJECT_LOAD_INACTIVE);
        break;
    case NLB_REJECT_CLUSTER_STOPPED:
        Message_print(IDS_CTR_QUERY_FILTER_REJECT_CLUSTER_STOPPED);
        break;
    case NLB_REJECT_PORT_RULE_DISABLED:
        Message_print(IDS_CTR_QUERY_FILTER_REJECT_RULE_DISABLED);
        break;
    case NLB_REJECT_CONNECTION_DIRTY:
        Message_print(IDS_CTR_QUERY_FILTER_REJECT_CONNECTION_DIRTY);
        break;
    case NLB_REJECT_OWNED_ELSEWHERE:
        Message_print(IDS_CTR_QUERY_FILTER_REJECT_OWNED_ELSEWHERE);
        break;
    case NLB_REJECT_BDA_TEAMING_REFUSED:
        Message_print(IDS_CTR_QUERY_FILTER_REJECT_BDA_REFUSED);
        break;
    case NLB_REJECT_DIP:
        Message_print(IDS_CTR_QUERY_FILTER_REJECT_DIP);
        break;
    case NLB_REJECT_HOOK:
        Message_print(IDS_CTR_QUERY_FILTER_REJECT_HOOK);
        break;
    case NLB_ACCEPT_UNCONDITIONAL_OWNERSHIP:
        Message_print(IDS_CTR_QUERY_FILTER_ACCEPT_OWNED);
        break;
    case NLB_ACCEPT_FOUND_MATCHING_DESCRIPTOR:
        Message_print(IDS_CTR_QUERY_FILTER_ACCEPT_DESCRIPTOR_FOUND);
        break;
    case NLB_ACCEPT_PASSTHRU_MODE:
        Message_print(IDS_CTR_QUERY_FILTER_ACCEPT_PASSTHRU);
        break;
    case NLB_ACCEPT_DIP:
        Message_print(IDS_CTR_QUERY_FILTER_ACCEPT_DIP);
        break;
    case NLB_ACCEPT_BROADCAST:
        Message_print(IDS_CTR_QUERY_FILTER_ACCEPT_BCAST);
        break;
    case NLB_ACCEPT_REMOTE_CONTROL_REQUEST:
        Message_print(IDS_CTR_QUERY_FILTER_ACCEPT_RCTL_REQUEST);
        break;
    case NLB_ACCEPT_REMOTE_CONTROL_RESPONSE:
        Message_print(IDS_CTR_QUERY_FILTER_ACCEPT_RCTL_RESPONSE);
        break;
    case NLB_ACCEPT_HOOK:
        Message_print(IDS_CTR_QUERY_FILTER_ACCEPT_HOOK);
        break;
    case NLB_ACCEPT_UNFILTERED:
        Message_print(IDS_CTR_QUERY_FILTER_ACCEPT_UNFILTERED);
        break;
    case NLB_UNKNOWN_NO_AFFINITY:
        Message_print(IDS_CTR_QUERY_FILTER_UNKNOWN_NO_AFFINITY);
        break;
    default:
        Message_print(IDS_CTR_QUERY_FILTER_UNKNOWN);
        break;
    }

    if (response.options.state.filter.HashInfo.Valid) {
        WCHAR CurrentMap[CVY_STR_SIZE];
        WCHAR AllIdleMap[CVY_STR_SIZE];

        (VOID) StringCchPrintf(CurrentMap, ASIZECCH(CurrentMap), L"0x%015I64x", response.options.state.filter.HashInfo.CurrentMap);
        (VOID) StringCchPrintf(AllIdleMap, ASIZECCH(AllIdleMap), L"0x%015I64x", response.options.state.filter.HashInfo.AllIdleMap);

        Message_print(IDS_CTR_QUERY_FILTER_HASH_INFO, response.options.state.filter.HashInfo.Bin,
                      CurrentMap, AllIdleMap, response.options.state.filter.HashInfo.ActiveConnections);
    }

    if (response.options.state.filter.DescriptorInfo.Valid) {
        Message_print(IDS_CTR_QUERY_FILTER_DESCRIPTOR_INFO, (response.options.state.filter.DescriptorInfo.Alloc) ? L"Yes" : L"No",
                      (response.options.state.filter.DescriptorInfo.Dirty) ? L"Yes" : L"No", response.options.state.filter.DescriptorInfo.RefCount);
    }
    
    return;
}

//+----------------------------------------------------------------------------
//
// Function:  RetrieveStringFromRc
//
// Description:  Retrieve a string from the log_msgs resource file based on
//               the message id passed in by the user. The string is stored in
//               the global buffer 'message'.
//
// Arguments: DWORD id - message ID of the string resource
//
// Returns:   WCHAR* - pointer to the global buffer containing the resource
//                     string. If the lookup fails, the pointer will point to
//                     an empty string. The return pointer is always valid.
//
// History:   ChrisDar, Created 2002 June 11
//
// Notes:     This function uses a global buffer for storing the output string.
//+----------------------------------------------------------------------------
WCHAR* RetrieveStringFromRc(DWORD id)
{
    //
    // Specifying FORMAT_MESSAGE_MAX_WIDTH_MASK here to prevent FormatMessage from introducing line breaks.
    //
    if (FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK, NULL, id, 0, message, sizeof(message)-sizeof(WCHAR), NULL) == 0) {
        message[0] = UNICODE_NULL;
    }

    return message;
}

VOID Report_params_state (WLBS_RESPONSE response) {
    DWORD      index;
    
    if (response.status != WLBS_OK) {
        Message_print(IDS_CTR_QUERY_PARAMS_FAILED);
        return;
    }

    WCHAR      TimeStr[64];
    SYSTEMTIME SysTime;
    GetLocalTime(&SysTime);
    FormatTheTime(&SysTime, TimeStr, sizeof(TimeStr)/sizeof(WCHAR));
    WConsole(L"%-25.25ls = %ls\n",  RetrieveStringFromRc(IDS_CTR_CURR_TIME), TimeStr);
    WConsole(L"%-25.25ls = %ls\n",  RetrieveStringFromRc(IDS_CTR_HOSTNAME),  response.options.state.params.HostName);
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_VERSION,           response.options.state.params.Version);
    WConsole(L"%-25.25ls = %08x\n", CVY_NAME_CUR_VERSION,       CVY_VERSION_FULL);
    WConsole(L"%-25.25ls = %08x\n", CVY_NAME_EFFECTIVE_VERSION, response.options.state.params.EffectiveVersion);
    WConsole(L"%-25.25ls = %08X\n", CVY_NAME_INSTALL_DATE,      response.options.state.params.InstallDate);
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_HOST_PRIORITY,     response.options.state.params.HostPriority);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_CL_IP_ADDR,        response.options.state.params.ClusterIPAddress);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_CL_NET_MASK,       response.options.state.params.ClusterNetmask);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_DED_IP_ADDR,       response.options.state.params.DedicatedIPAddress);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_DED_NET_MASK,      response.options.state.params.DedicatedNetmask);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_MCAST_IP_ADDR,     response.options.state.params.IGMPMulticastIPAddress);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_DOMAIN_NAME,       response.options.state.params.DomainName);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_NETWORK_ADDR,      response.options.state.params.ClusterMACAddress);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_CONVERT_MAC,       response.options.state.params.ClusterIPToMAC ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_MCAST_SUPPORT,     response.options.state.params.MulticastSupport ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_IGMP_SUPPORT,      response.options.state.params.IGMPSupport ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_MCAST_SPOOF,       response.options.state.params.MulticastSpoof ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_MASK_SRC_MAC,      response.options.state.params.MaskSourceMAC ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_ALIVE_PERIOD,      response.options.state.params.HeartbeatPeriod);
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_ALIVE_TOLER,       response.options.state.params.HeartbeatLossTolerance);
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_NUM_ACTIONS,       response.options.state.params.NumActionsAlloc);
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_NUM_PACKETS,       response.options.state.params.NumPacketsAlloc);
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_NUM_SEND_MSGS,     response.options.state.params.NumHeartbeatsAlloc);
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_DSCR_PER_ALLOC,    response.options.state.params.DescriptorsPerAlloc);
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_MAX_DSCR_ALLOCS,   response.options.state.params.MaximumDescriptorAllocs);
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_TCP_TIMEOUT,       response.options.state.params.TCPConnectionTimeout);
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_IPSEC_TIMEOUT,     response.options.state.params.IPSecConnectionTimeout);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_FILTER_ICMP,       response.options.state.params.FilterICMP ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_CLUSTER_MODE,      (response.options.state.params.ClusterModeOnStart == CVY_HOST_STATE_STARTED) ? L"STARTED" : 
                                                                (response.options.state.params.ClusterModeOnStart == CVY_HOST_STATE_STOPPED) ? L"STOPPED" :
                                                                (response.options.state.params.ClusterModeOnStart == CVY_HOST_STATE_SUSPENDED) ? L"SUSPENDED" : L"UNKNOWN");
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_HOST_STATE,        (response.options.state.params.HostState == CVY_HOST_STATE_STOPPED) ? L"STOPPED" :
                                                                (response.options.state.params.HostState == CVY_HOST_STATE_STARTED) ? L"STARTED" :
                                                                (response.options.state.params.HostState == CVY_HOST_STATE_SUSPENDED) ? L"SUSPENDED" : L"UNKNOWN");
    WConsole(L"%-25.25ls = ",       CVY_NAME_PERSISTED_STATES);

    if (!response.options.state.params.PersistedStates)
        WConsole(L"NONE");

    if (response.options.state.params.PersistedStates & CVY_PERSIST_STATE_STOPPED) {
        WConsole(L"STOPPED");
        
        if ((response.options.state.params.PersistedStates &= ~CVY_PERSIST_STATE_STOPPED))
            WConsole(L", ");
    }

    if (response.options.state.params.PersistedStates & CVY_PERSIST_STATE_STARTED) {
        WConsole(L"STARTED");
        
        if ((response.options.state.params.PersistedStates &= ~CVY_PERSIST_STATE_STARTED))
            WConsole(L", ");
    }

    if (response.options.state.params.PersistedStates & CVY_PERSIST_STATE_SUSPENDED) {
        WConsole(L"SUSPENDED");
        
        if ((response.options.state.params.PersistedStates &= ~CVY_PERSIST_STATE_SUSPENDED))
            WConsole(L", ");
    }

    WConsole(L"\n");

    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_SCALE_CLIENT,      response.options.state.params.ScaleClient ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_NBT_SUPPORT,       response.options.state.params.NBTSupport ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_NETMON_ALIVE,      response.options.state.params.NetmonReceiveHeartbeats ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_IP_CHG_DELAY,      response.options.state.params.IPChangeDelay);
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_CLEANUP_DELAY,     response.options.state.params.ConnectionCleanUpDelay);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_RCT_ENABLED,       response.options.state.params.RemoteControlEnabled ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_RCT_PORT,          response.options.state.params.RemoteControlPort);
    WConsole(L"%-25.25ls = %08X\n", CVY_NAME_RCT_PASSWORD,      response.options.state.params.RemoteControlPassword);
    WConsole(L"%-25.25ls = %08X\n", CVY_NAME_RMT_PASSWORD,      response.options.state.params.RemoteMaintenancePassword);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_BDA_TEAMING,       response.options.state.params.BDATeaming.Active ? L"YES" : L"NO");
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_BDA_TEAM_ID,       response.options.state.params.BDATeaming.TeamID);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_BDA_MASTER,        response.options.state.params.BDATeaming.Master ? L"YES" : L"NO");
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_BDA_REVERSE_HASH,  response.options.state.params.BDATeaming.ReverseHash ? L"YES" : L"NO");
    WConsole(L"%-25.25ls = %d\n",   CVY_NAME_ID_HB_PERIOD,      response.options.state.params.IdentityHeartbeatPeriod);
    WConsole(L"%-25.25ls = %ls\n",  CVY_NAME_ID_HB_ENABLED,     response.options.state.params.IdentityHeartbeatEnabled ? L"ENABLED" : L"DISABLED");

    WConsole(L"\n%ls (%d):\n",   CVY_NAME_PORT_RULES,        response.options.state.params.NumPortRules);

    WConsole(L"\n      VIP       Start  End  Prot   Mode   Pri Load Affinity\n");
    WConsole(L"--------------- ----- ----- ---- -------- --- ---- --------\n");

    for (index = 0; index < response.options.state.params.NumPortRules; index++) {
        NLB_OPTIONS_PARAMS_PORT_RULE * rp = response.options.state.params.PortRules + index;
        DWORD  len = CVY_STR_SIZE;
        WCHAR  vip[CVY_STR_SIZE];
        PWCHAR protocol;
        PWCHAR affinity;

        switch (rp->Protocol) {
            case CVY_TCP:
                protocol = L"TCP";
                break;
            case CVY_UDP:
                protocol = L"UDP";
                break;
            case CVY_TCP_UDP:
                protocol = L"Both";
                break;
            default:
                protocol = L"Unknown";
                break;
        }

        WlbsAddressToString(rp->VirtualIPAddress, vip, &len);

        if (rp->VirtualIPAddress == CVY_ALL_VIP_NUMERIC_VALUE) 
            WConsole(L"%-15ls %5d %5d %-4ls ", L"All", rp->StartPort, rp->EndPort, protocol);
        else
            WConsole(L"%-15ls %5d %5d %-4ls ", vip, rp->StartPort, rp->EndPort, protocol);

        switch (rp->Mode) {
        case CVY_SINGLE:
            WConsole(L"%-8ls %3d\n", L"Single", rp->SingleHost.Priority);
            break;
        case CVY_MULTI:
            switch (rp->MultipleHost.Affinity) {
            case CVY_AFFINITY_NONE:
                affinity = L"None";
                break;
            case CVY_AFFINITY_SINGLE:
                affinity = L"Single";
                break;
            case CVY_AFFINITY_CLASSC:
                affinity = L"Class C";
                break;
            default:
                affinity = L"Unknown";
                break;
            }

            if (rp->MultipleHost.Equal)
                WConsole(L"%-8ls %-3ls %4ls %-ls\n", L"Multiple", L"", L"Eql", affinity);
            else
                WConsole(L"%-8ls %-3ls %4d %-ls\n", L"Multiple", L"", rp->MultipleHost.LoadWeight, affinity);

            break;
        case CVY_NEVER:
            WConsole(L"%-8ls\n", L"Disabled");
            break;
        default:
            WConsole(L"%-8ls\n", RetrieveStringFromRc(IDS_CTR_UNK_FILTER_MODE));
            break;
        }
    }

    WConsole(L"\n%ls\n\n", RetrieveStringFromRc(IDS_CTR_STATS));

    WConsole(L"%-35.35ls = %u\n", RetrieveStringFromRc(IDS_CTR_NUM_ACTIVE_CONN), response.options.state.params.Statistics.ActiveConnections);
    WConsole(L"%-35.35ls = %u\n", RetrieveStringFromRc(IDS_CTR_NUM_DSCR_ALLOC), response.options.state.params.Statistics.DescriptorsAllocated);
}

VOID Process_state (WLBS_COMMANDS command, DWORD target_cl, DWORD target_host, PNLB_OPTIONS optionsp, ULONG dest_port, PWCHAR dest_password) {
    DWORD           status;
    DWORD           ioctl;
    DWORD           i;
    DWORD           dwNumHosts = WLBS_MAX_HOSTS;
    PWLBS_RESPONSE  pResponse = new WLBS_RESPONSE[WLBS_MAX_HOSTS];

    if (pResponse == NULL)
    {
        Message_print(IDS_CTR_FAILED_MALLOC);
        return;
    }

    WlbsPasswordSet(target_cl, dest_password);
    WlbsPortSet(target_cl, (USHORT)dest_port);

    switch (command) {
    case params:
        ioctl = IOCTL_CVY_QUERY_PARAMS;
        break;
    case bdateam:
        ioctl = IOCTL_CVY_QUERY_BDA_TEAMING;
        break;
    case queryport:
        ioctl = IOCTL_CVY_QUERY_PORT_STATE;
        break;
    case filter:
        ioctl = IOCTL_CVY_QUERY_FILTER;
        break;
    default:
        Message_print(IDS_CTR_QUERY_UNKNOWN);
        goto end;
    }        

    status = WlbsQueryState(target_cl, target_host, ioctl, optionsp, pResponse, &dwNumHosts);

    if (status == WLBS_INIT_ERROR) {
        Message_print(IDS_CTR_INIT);
        goto end;
    }

    if (status == WLBS_LOCAL_ONLY) {
        switch (command) {
        case params:
        case bdateam:
            Message_print(IDS_CTR_REMOTE);
            break;
        case queryport:
        case filter:
            Message_print(IDS_CTR_WSOCK);
            break;
        default:
            Message_print(IDS_CTR_QUERY_UNKNOWN);
            goto end;
        }        

        goto end;
    }

    if (status == WLBS_REMOTE_ONLY) {
        Message_print(IDS_CTR_NO_CVY, CVY_NAME);
        goto end;
    }

    if (status >= WSABASEERR) {
        Message_print(IDS_CTR_WSOCK);
        Error_print(TRUE);
        goto end;
    }

    if (status == WLBS_TIMEOUT) {
        Message_print(IDS_CTR_NO_RSP3);
        Message_print(IDS_CTR_NO_RSP4, CVY_NAME);
        goto end;
    }

    switch (command) {
    case params:
        Message_print(IDS_CTR_QUERY_PARAMS_HDR);
        break;
    case bdateam:
        Message_print(IDS_CTR_QUERY_BDA_HDR, optionsp->state.bda.TeamID);
        break;
    case queryport:
    {
        WCHAR port[CVY_STR_SIZE];
        WCHAR num[CVY_STR_SIZE];
        DWORD len;

        port[0] = 0;
        num[0] = 0;


        if (optionsp->state.port.VirtualIPAddress != CVY_ALL_VIP_NUMERIC_VALUE) {
            len = CVY_STR_SIZE;
            WlbsAddressToString(optionsp->state.port.VirtualIPAddress, port, &len);

            (VOID) StringCchCat(port, ASIZECCH(port), L":");
        }

        (VOID) StringCchPrintf(num, ASIZECCH(num), L"%u", optionsp->state.port.Num);

        (VOID) StringCchCat(port, ASIZECCH(port), num);
        
        Message_print(IDS_CTR_QUERY_PORT_HDR, port);

        break;
    }
    case filter:
    {            
        WCHAR cltip[CVY_STR_SIZE];
        WCHAR svrip[CVY_STR_SIZE];
        WCHAR prot[CVY_STR_SIZE];
        WCHAR flags[CVY_STR_SIZE];
        DWORD len;
        
        cltip[0] = 0;
        svrip[0] = 0;
        prot[0] = 0;

        len = CVY_STR_SIZE;
        WlbsAddressToString(optionsp->state.filter.ClientIPAddress, cltip, &len);

        len = CVY_STR_SIZE;
        WlbsAddressToString(optionsp->state.filter.ServerIPAddress, svrip, &len);
        
        switch (optionsp->state.filter.Protocol) {
        case TCPIP_PROTOCOL_TCP:
            (VOID) StringCchCopy(prot, ASIZECCH(prot), L"TCP");
            break;
        case TCPIP_PROTOCOL_UDP:
            (VOID) StringCchCopy(prot, ASIZECCH(prot), L"UDP");
            break;
        case TCPIP_PROTOCOL_IPSEC1:
            (VOID) StringCchCopy(prot, ASIZECCH(prot), L"IPSec");
            break;
        case TCPIP_PROTOCOL_PPTP:
            (VOID) StringCchCopy(prot, ASIZECCH(prot), L"PPTP");
            break;
        case TCPIP_PROTOCOL_GRE:
            (VOID) StringCchCopy(prot, ASIZECCH(prot), L"GRE");
            break;
        case TCPIP_PROTOCOL_ICMP:
            (VOID) StringCchCopy(prot, ASIZECCH(prot), L"ICMP");
            break;
        default:
            (VOID) StringCchCopy(prot, ASIZECCH(prot), L"Unknown");
            break;
        }

        ASSERT(prot[0] != 0);

        if (optionsp->state.filter.Flags & NLB_FILTER_FLAGS_CONN_UP)
            (VOID) StringCchCopy(flags, ASIZECCH(flags), L"SYN");
        else if (optionsp->state.filter.Flags & NLB_FILTER_FLAGS_CONN_DOWN)
            (VOID) StringCchCopy(flags, ASIZECCH(flags), L"FIN");
        else if (optionsp->state.filter.Flags & NLB_FILTER_FLAGS_CONN_RESET)
            (VOID) StringCchCopy(flags, ASIZECCH(flags), L"RST");
        else 
            (VOID) StringCchCopy(flags, ASIZECCH(flags), L"None");
        
        Message_print(IDS_CTR_QUERY_FILTER_HDR, cltip, optionsp->state.filter.ClientPort, svrip, optionsp->state.filter.ServerPort, prot, flags);

        break;
    }
    default:
        Message_print(IDS_CTR_QUERY_UNKNOWN);
        goto end;
    }

    if (target_host == CVY_LOCAL_HOST) {
        switch (command) {
        case params:
            Report_params_state(pResponse[0]);
            break;
        case bdateam:
            Report_bda_state(pResponse[0]);
            break;
        case queryport:
            Report_port_state(pResponse[0]);
            break;
        case filter:
            Report_filter_state(pResponse[0]);
            break;
        default:
            Message_print(IDS_CTR_QUERY_UNKNOWN);
            goto end;
        }

        goto end;
    }

    for (i = 0; i < dwNumHosts; i++) {
        if (pResponse[i].address == 0) {
            Message_print(IDS_CTR_HOST_NEITHER, pResponse[i].id);
        } else {
            DWORD len = CVY_STR_SIZE;
            WlbsAddressToString(pResponse[i].address, wbuf, &len);
            Message_print(IDS_CTR_HOST_DIP_ONLY, pResponse[i].id, wbuf);
        }

        if (pResponse[i].status == WLBS_BAD_PASSW) {
            if (target_host != CVY_ALL_HOSTS) {
                WConsole(L"\n");
                Message_print(IDS_CTR_BAD_PASSW);
            } else {
                Message_print(IDS_CTR_BAD_PASSW_C);
                WConsole(L"\n");
            }

            continue;
        }

        switch (command) {
        case params:
            Report_params_state(pResponse[i]);
            break;
        case bdateam:
            Report_bda_state(pResponse[i]);
            break;
        case queryport:
            Report_port_state(pResponse[i]);
            break;
        case filter:
            Report_filter_state(pResponse[i]);
            break;
        default:
            Message_print(IDS_CTR_QUERY_UNKNOWN);
            goto end;
        }
    }
end:
    delete [] pResponse;

    return;
}

BOOL Parse_state (INT argc, PWCHAR argv[], PINT arg_index, WLBS_COMMANDS command, PNLB_OPTIONS optionsp) {
    WCHAR   str[WLBS_MAX_CL_IP_ADDR + 1];
    GUID    guid;
    HRESULT hr;
    PWCHAR  ptr;
    ULONG   len;

    switch (command) {
    case filter:
    {
        PWCHAR pPort = NULL;
            
        if (argc < 5) return FALSE;

        if (!_wcsicmp(argv[*arg_index], L"TCP")) 
        {
            optionsp->state.filter.Protocol = TCPIP_PROTOCOL_TCP;
        } 
        else if (!_wcsicmp(argv[*arg_index], L"UDP")) 
        {
            optionsp->state.filter.Protocol = TCPIP_PROTOCOL_UDP;
        } 
        else if (!_wcsicmp(argv[*arg_index], L"IPSec")) 
        {
            optionsp->state.filter.Protocol = TCPIP_PROTOCOL_IPSEC1;
        } 
        else if (!_wcsicmp(argv[*arg_index], L"PPTP")) 
        {
            optionsp->state.filter.Protocol = TCPIP_PROTOCOL_PPTP;
        } 
        else if (!_wcsicmp(argv[*arg_index], L"GRE")) 
        {
            optionsp->state.filter.Protocol = TCPIP_PROTOCOL_GRE;
        } 
        else if (!_wcsicmp(argv[*arg_index], L"ICMP")) 
        {
            optionsp->state.filter.Protocol = TCPIP_PROTOCOL_ICMP;
        } 
        else 
        {
            return FALSE;
        }

        ++(*arg_index);

        optionsp->state.filter.ClientPort = 0;

        pPort = wcschr(argv[*arg_index], L':');
        
        if (pPort != NULL) 
        {
            *pPort = UNICODE_NULL;
            
            pPort++;
            
            optionsp->state.filter.ClientPort = (USHORT)_wtoi(pPort);

            if (optionsp->state.filter.ClientPort == 0)
            {
                return FALSE;
            }
        }
        
        if (!(optionsp->state.filter.ClientIPAddress = WlbsResolve(argv[*arg_index])))
        {
            return FALSE;
        }

        ++(*arg_index);

        optionsp->state.filter.ServerPort = 0;

        pPort = wcschr(argv[*arg_index], L':');
        
        if (pPort != NULL) 
        {
            *pPort = UNICODE_NULL;
            
            pPort++;
            
            optionsp->state.filter.ServerPort = (USHORT)_wtoi(pPort);

            if (optionsp->state.filter.ServerPort == 0)
            {
                return FALSE;
            }
        }
        
        if (!(optionsp->state.filter.ServerIPAddress = WlbsResolve(argv[*arg_index])))
        {
            return FALSE;
        }

        ++(*arg_index);

        optionsp->state.filter.Flags = NLB_FILTER_FLAGS_CONN_DATA;
                
        if (argc > 5) 
        {
            if (!_wcsicmp(argv[*arg_index], L"SYN")) 
            {
                optionsp->state.filter.Flags |= NLB_FILTER_FLAGS_CONN_UP;
                ++(*arg_index);
            } 
            else if (!_wcsicmp(argv[*arg_index], L"FIN")) 
            {
                optionsp->state.filter.Flags |= NLB_FILTER_FLAGS_CONN_DOWN;
                ++(*arg_index);
            } 
            else if (!_wcsicmp(argv[*arg_index], L"RST")) 
            {
                optionsp->state.filter.Flags |= NLB_FILTER_FLAGS_CONN_RESET;
                ++(*arg_index);
            }
        }

        switch (optionsp->state.filter.Protocol)
        {
        case TCPIP_PROTOCOL_TCP:

            if (optionsp->state.filter.ServerPort == 0)
            {
                return FALSE;
            }

            if (optionsp->state.filter.ClientPort == 0)
            {
                if ((optionsp->state.filter.Flags == NLB_FILTER_FLAGS_CONN_DOWN) || 
                    (optionsp->state.filter.Flags == NLB_FILTER_FLAGS_CONN_RESET))
                {
                    return FALSE;
                }       
                else
                {
                    optionsp->state.filter.Flags = NLB_FILTER_FLAGS_CONN_UP;
                }
            }

            if (optionsp->state.filter.ServerPort != PPTP_CTRL_PORT)
            {
                break;
            }

            optionsp->state.filter.Protocol = TCPIP_PROTOCOL_PPTP;

            /* This fall-through is INTENTIONAL.  In this case, we're verified the TCP
               parameters, but discovered that because the server port was 1723, this
               is actually PPTP, so force it through the PPTP verification as well. */
        case TCPIP_PROTOCOL_PPTP:

            optionsp->state.filter.ServerPort = PPTP_CTRL_PORT;

            if (optionsp->state.filter.ClientPort == 0)
            {
                if ((optionsp->state.filter.Flags == NLB_FILTER_FLAGS_CONN_DOWN) || 
                    (optionsp->state.filter.Flags == NLB_FILTER_FLAGS_CONN_RESET))
                {
                    return FALSE;
                }       
                else
                {
                    optionsp->state.filter.Flags = NLB_FILTER_FLAGS_CONN_UP;
                }
            }

            break;
        case TCPIP_PROTOCOL_UDP:

            if (optionsp->state.filter.ServerPort == 0)
            {
                return FALSE;
            }

            if ((optionsp->state.filter.ServerPort != IPSEC_CTRL_PORT) && (optionsp->state.filter.ServerPort != IPSEC_NAT_PORT))
            {
                if (optionsp->state.filter.Flags != NLB_FILTER_FLAGS_CONN_DATA)
                {
                    return FALSE;
                }

                break;
            }

            optionsp->state.filter.Protocol = TCPIP_PROTOCOL_IPSEC1;

           /* This fall-through is INTENTIONAL.  In this case, we're verified the TCP
               parameters, but discovered that because the server port was 1723, this
               is actually PPTP, so force it through the PPTP verification as well. */
        case TCPIP_PROTOCOL_IPSEC1:
            
            if (optionsp->state.filter.ServerPort == 0)
            {
                optionsp->state.filter.ServerPort = IPSEC_CTRL_PORT;
            }

            if (optionsp->state.filter.ServerPort == IPSEC_CTRL_PORT)
            {
                if (optionsp->state.filter.ClientPort == 0)
                {
                    optionsp->state.filter.ClientPort = IPSEC_CTRL_PORT;
                }

                if (optionsp->state.filter.ClientPort != IPSEC_CTRL_PORT)
                {
                    return FALSE;
                }
            }
            else if (optionsp->state.filter.ServerPort == IPSEC_NAT_PORT)
            {
                if (optionsp->state.filter.ClientPort == 0)
                {
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }

            break;
        case TCPIP_PROTOCOL_GRE:

            if (optionsp->state.filter.Flags != NLB_FILTER_FLAGS_CONN_DATA)
            {
                return FALSE;
            }

            optionsp->state.filter.ServerPort = PPTP_CTRL_PORT;
            optionsp->state.filter.ClientPort = PPTP_CTRL_PORT;

            break;
        case TCPIP_PROTOCOL_ICMP:

            if (optionsp->state.filter.Flags != NLB_FILTER_FLAGS_CONN_DATA)
            {
                return FALSE;
            }

            optionsp->state.filter.ServerPort = 0;
            optionsp->state.filter.ClientPort = 0;

            break;
        default:
            return FALSE;
        }

        break;
    }
    case queryport:
        if (argc < 3) return FALSE;

        optionsp->state.port.VirtualIPAddress = CVY_ALL_VIP_NUMERIC_VALUE;

        if ((ptr = wcspbrk(argv[*arg_index], L":"))) {
            len = (ULONG)(ptr - argv[*arg_index]);
            wcsncpy(str, argv[*arg_index], len);
            str[len] = L'\0';

            if (!(optionsp->state.port.VirtualIPAddress = WlbsResolve(str)))
                return FALSE;

            optionsp->state.port.Num = (USHORT)_wtoi(++ptr);
        } else {
            optionsp->state.port.Num = (USHORT)_wtoi(argv[*arg_index]);
        }
        
        ++(*arg_index);

        break;
    case params:

        break;
    case bdateam:
        if (argc < 3) return FALSE;

        hr = CLSIDFromString(argv[*arg_index], &guid);

        if (hr != NOERROR) return FALSE;

        wcsncpy(optionsp->state.bda.TeamID, argv[*arg_index], CVY_MAX_BDA_TEAM_ID);
        optionsp->state.bda.TeamID[CVY_MAX_BDA_TEAM_ID] = L'\0';

        ++(*arg_index);

        break;
    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
ParsePort(
    PWCHAR          arg,
    PULONG          pvip,
    PULONG          pport
    )
/*
    arg is expected to optionally contain a virtual IP address or a 
    "all", signifying the "all vip" port rule and mandatorilay contain 
    "all", signifying all ports, or a port number in the range of 0-65535.

    Return: TRUE if valid parse, in which case *pvip & *pport contains the parsed
    value. FALSE if invalid parse, in  which case *pvip & *pport are undefined.
*/
{
    BOOL fRet = TRUE;
    WCHAR vip_str[WLBS_MAX_CL_IP_ADDR+1];
    WCHAR *temp_str;
    ULONG port, viplen;

    // Check if a vip or the "ALL" string was passed
    if ((temp_str = wcspbrk(arg,L":")) != NULL)
    {
        viplen = (ULONG)(temp_str - arg);
        wcsncpy(vip_str, arg, viplen);
        vip_str[viplen] = L'\0';
        *pvip = IpAddressFromAbcdWsz(vip_str);

        // A vip was not passed, Check if the "All" string was passed
        if (*pvip == INADDR_NONE) 
        {
            if (_wcsicmp (vip_str, L"all") == 0)
            {
                *pvip = IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP);
            }
            else
            {
                return FALSE;
            }
        }

        arg = temp_str + 1;
    }
    else // Neither a vip nor the "All" string was passed, so this applies to every vip
    {
        *pvip = IOCTL_ALL_VIPS;
    }

    if (_wcsicmp (arg, L"all") == 0)
    {
        port = IOCTL_ALL_PORTS;
    }
    else
    {
        port = _wtoi (arg);

        if (   wcspbrk(arg, L".:") != NULL
            || (port == 0 && arg[0] != L'0')
            || port > 65535
            )
        fRet = FALSE;
    }

    *pport = port;

    return fRet;
}

BOOL Parse_registry (INT argc, PWCHAR argv [], PINT arg_index, PDWORD key, PDWORD value) {

    if (_wcsicmp(argv[*arg_index], L"mcastipaddress") == 0) {
        (*arg_index)++;
        
        *key = mcastipaddress;
        
        if (!(*value = WlbsResolve(argv[*arg_index])))
            return FALSE;
        
        /* The multicast IP address should be in the range of (224-239).x.x.x, but NOT (224-239).0.0.x or (224-239).128.0.x. */
        if ((*value & 0xf0) != 0xe0 || (*value & 0x00ffff00) == 0 || (*value & 0x00ffff00) == 0x00008000) {
            Message_print (IDS_CTR_REG_INVAL_MCASTIPADDRESS);
            return FALSE;
        }
        
        (*arg_index)++;

    } else if (_wcsicmp(argv[*arg_index], L"iptomcastip") == 0) {
        (*arg_index)++;
        
        *key = iptomcastip;
        
        if (_wcsicmp(argv[*arg_index], L"on") == 0)
            *value = 1;
        else if (_wcsicmp(argv[*arg_index], L"off") == 0)
            *value = 0;
        else 
            return FALSE;
        
        (*arg_index)++;

    } else if (_wcsicmp(argv[*arg_index], L"masksrcmac") == 0) {
        (*arg_index)++;
        
        *key = masksrcmac;
        
        if (_wcsicmp(argv[*arg_index], L"on") == 0)
            *value = 1;
        else if (_wcsicmp(argv[*arg_index], L"off") == 0)
            *value = 0;
        else 
            return FALSE;

        (*arg_index)++;
        
    } else if (_wcsicmp(argv[*arg_index], L"iptomacenable") == 0) {
        (*arg_index)++;
        
        *key = iptomacenable;
        
        if (_wcsicmp(argv[*arg_index], L"on") == 0)
            *value = 1;
        else if (_wcsicmp(argv[*arg_index], L"off") == 0)
            *value = 0;
        else 
            return FALSE;

        (*arg_index)++;
        
    } else if (_wcsicmp(argv[*arg_index], L"netmonalivemsgs") == 0) {
        (*arg_index)++;
        
        *key = netmonalivemsgs;
        
        if (_wcsicmp(argv[*arg_index], L"on") == 0)
            *value = 1;
        else if (_wcsicmp(argv[*arg_index], L"off") == 0)
            *value = 0;
        else 
            return FALSE;

        (*arg_index)++;
        
    } else {
        Message_print(IDS_CTR_REG_KEY, argv[*arg_index]);
        return FALSE;
    }

    return TRUE;
}

extern "C"
{

int __cdecl wmain (int argc, PWCHAR argv[]) {
    int  iUsageStatus    = CVY_ERROR_USAGE; // Used as return status when exiting via the "usage:" path. For backward compatibility, this is not always an error path.
    INT arg_index;
    ULONG i, ip;
    PUCHAR bp;
    LONG status;
    DWORD target_cl;
    DWORD target_host;
    WLBS_COMMANDS command = invalid;
    ULONG param1 = 0;
    ULONG param2 = 0;
    ULONG param3 = 0;
    ULONG dest_port;
    PWCHAR dest_password;
    DWORD dest_addr;
    NLB_OPTIONS options;
    DWORD operation = 0;
    DWORD fdwMode = 0;
    WCHAR wszCodePage[6];

    //
    // Set the locale for time and date
    //
    InitUserLocale();

    //
    // Set the locale for character-handling functions
    //
    (VOID) StringCchPrintf(wszCodePage, ASIZECCH(wszCodePage), L".4%d", GetConsoleOutputCP());
    _wsetlocale(LC_CTYPE, wszCodePage);

    //
    // Determine whether we are writing to the console or are being redirected
    //
    if ((ConsoleHdl = GetStdHandle(STD_OUTPUT_HANDLE)) == INVALID_HANDLE_VALUE)
    {
        wprintf(L"GetStdHandle failed, Unable to write to Console !!!\n");
        return CVY_ERROR_SYSTEM;
    }

    g_fOutToConsole = TRUE;
    if( !(GetFileType(ConsoleHdl) & FILE_TYPE_CHAR) ||
        !GetConsoleMode( ConsoleHdl, &fdwMode) )
    {
        g_fOutToConsole = FALSE;
    }

    Message_print(IDS_CTR_NAME, CVY_NAME, CVY_VERSION);

    if (argc < 2) {
usage:
        Message_print(IDS_CTR_USAGE, CVY_NAME);
        Message_print(IDS_CTR_USAGE2);
        Message_print(IDS_CTR_USAGE3);
        Message_print(IDS_CTR_USAGE4);
        return iUsageStatus;
    }

    status = WlbsInit(NULL, WLBS_API_VER, NULL);

    if (status == WLBS_INIT_ERROR) {
        Message_print(IDS_CTR_WSOCK);
        Error_print(TRUE);
        return CVY_ERROR_SYSTEM;
    }

    arg_index = 1;

    ZeroMemory((PVOID)&options, sizeof(NLB_OPTIONS));

    /* parse command */
    if (_wcsicmp(argv [arg_index], L"ip2mac") == 0) {
        command = ip2mac;
        arg_index++;

        if (argc < 3)
            goto usage;

        ip = WlbsResolve(argv[arg_index]);

        bp = (PUCHAR)(&ip);
        Message_print(IDS_CTR_IP, inet_ntoa(*((struct in_addr *)&ip)));
        Message_print(IDS_CTR_UCAST, bp[0], bp[1], bp[2], bp[3]);
        Message_print(IDS_CTR_MCAST, bp[0], bp[1], bp[2], bp[3]);
        Message_print(IDS_CTR_IGMP_MCAST, bp[2], bp[3]);

        return CVY_OK;
    } else if (_wcsicmp(argv[arg_index], L"help") == 0) {
        iUsageStatus = CVY_OK;
        goto usage;
    } else if (_wcsicmp(argv[arg_index], L"suspend") == 0) {
        command = suspend;
        arg_index++;
#ifndef BACKWARD_COMPATIBILITY
        if (argc < 3) 
            goto usage;
#endif
        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"resume") == 0) {
        command = resume;
        arg_index++;
#ifndef BACKWARD_COMPATIBILITY
        if (argc < 3) 
            goto usage;
#endif
        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"start") == 0) {
        command = __start;
        arg_index++;
#ifndef BACKWARD_COMPATIBILITY
        if (argc < 3) 
            goto usage;
#endif
        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"stop") == 0) {
        command = stop;
        arg_index++;
#ifndef BACKWARD_COMPATIBILITY
        if (argc < 3) 
            goto usage;
#endif
        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"drainstop") == 0) {
        command = drainstop;
        arg_index++;
#ifndef BACKWARD_COMPATIBILITY
        if (argc < 3) 
            goto usage;
#endif
        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"query") == 0) {
        command = query;
        arg_index++;
#ifndef BACKWARD_COMPATIBILITY
        if (argc < 3) 
            goto usage;
#endif
        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"enable") == 0) {
        command = enable;
        arg_index++;

#ifdef BACKWARD_COMPATIBILITY
        if (argc < 3)
#else
        if (argc < 4)
#endif
            goto usage;

        if (!ParsePort(argv[arg_index], &param1, &param2))
            goto usage;

        arg_index++;

        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"disable") == 0) {
        command = disable;
        arg_index++;

#ifdef BACKWARD_COMPATIBILITY
        if (argc < 3)
#else
        if (argc < 4)
#endif
            goto usage;

        if (!ParsePort(argv[arg_index], &param1, &param2))
            goto usage;

        arg_index++;

        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"drain") == 0) {
        command = drain;
        arg_index++;

#ifdef BACKWARD_COMPATIBILITY
        if (argc < 3)
#else
        if (argc < 4)
#endif
            goto usage;

        if (!ParsePort(argv[arg_index], &param1, &param2))
            goto usage;

        arg_index++;

        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    }

    /* local only commands */
    else if (_wcsicmp(argv[arg_index], L"display") == 0) {
        command = display;
        arg_index++;
        target_host = CVY_LOCAL_HOST;

        // Verify that the cluster ip or "All" string is passed and there are no more arguments
        if ((arg_index == argc) || (arg_index + 1 < argc))
#ifdef BACKWARD_COMPATIBILITY
            if (arg_index == argc)
                target_cl = CVY_ALL_CLUSTERS;
            else 
                goto usage;
#else
            goto usage;
#endif
        else {
            // Retrieve the Cluster IP Address or "ALL"
            if (_wcsicmp (argv[arg_index], L"all") == 0)
            {
                target_cl   = CVY_ALL_CLUSTERS;
            }
            else
            {
                target_cl = WlbsResolve(argv [arg_index]);

                if (target_cl == 0)
                    goto usage;
            }
            arg_index++;
        }

    } else if (_wcsicmp(argv[arg_index], L"reload") == 0) {
        command = reload;
        arg_index++;
        target_host = CVY_LOCAL_HOST;

        // Verify that the cluster ip or "All" string is passed and there are no more arguments
        if ((arg_index == argc) || (arg_index + 1 < argc))
#ifdef BACKWARD_COMPATIBILITY
            if (arg_index == argc)
                target_cl = CVY_ALL_CLUSTERS;
            else 
                goto usage;
#else
            goto usage;
#endif
        else {
            // Retrieve the Cluster IP Address or "ALL"
            if (_wcsicmp (argv[arg_index], L"all") == 0)
            {
                target_cl   = CVY_ALL_CLUSTERS;
            }
            else
            {
                target_cl = WlbsResolve(argv [arg_index]);

                if (target_cl == 0)
                    goto usage;
            }
            arg_index++;
        }
    }
    else if (_wcsicmp(argv[arg_index], L"registry") == 0)
    {
        command = registry;
        param3 = FALSE;
        arg_index++;

        if (argc < 4) 
            goto reg_usage;

        if (!Parse_registry(argc, argv, &arg_index, &param1, &param2))
            goto reg_usage;

        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto reg_usage;

        /* Force local operation. */
        target_host = CVY_LOCAL_HOST;
    }
    else if (_wcsicmp(argv[arg_index], L"filter") == 0)
    {
        command = filter;
        arg_index++;

        if (!Parse_state(argc, argv, &arg_index, command, &options))
            goto filter_usage;

        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto filter_usage;
    }
    else if (_wcsicmp(argv[arg_index], L"params") == 0)
    {
        command = params;
        arg_index++;

        if (!Parse_state(argc, argv, &arg_index, command, &options))
            goto usage;

        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;

        /* Force local operation. */
        target_host = CVY_LOCAL_HOST;
    }
    else if (_wcsicmp(argv[arg_index], L"queryport") == 0)
    {
        command = queryport;
        arg_index++;

        if (!Parse_state(argc, argv, &arg_index, command, &options))
            goto usage;

        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    }
    else if (_wcsicmp(argv[arg_index], L"bdateam") == 0)
    {
        command = bdateam;
        arg_index++;

        if (!Parse_state(argc, argv, &arg_index, command, &options))
            goto bdateam_usage;

        /* Force local operation across ALL clusters - this operation is 
           actually global and not specific to any one cluster, so we 
           operate on ANY one cluster (in a loop, below) and bail out. */
        target_cl = CVY_ALL_CLUSTERS;
        target_host = CVY_LOCAL_HOST;
    }
    else
        goto usage;
    
    /* The remote control parameters need to be parsed. */
    dest_password = NULL;
    dest_addr = 0;
    dest_port = 0;

    while (arg_index < argc) {
        if (argv[arg_index][0] == L'/' || argv[arg_index][0] == L'-') {
            if (_wcsicmp(argv[arg_index] + 1, L"PASSW") == 0) {
                arg_index++;

                if (arg_index >= argc || argv[arg_index][0] == L'/' || argv[arg_index][0] == L'-') {
                    HANDLE hConsole;
                    DWORD dwMode;      // console mode
                    DWORD dwInputMode; // stdin input mode

                    Message_print(IDS_CTR_PASSW);

                    hConsole = GetStdHandle(STD_INPUT_HANDLE);
                    dwInputMode = GetFileType(hConsole);

                    //
                    // prompt for password, making sure password isn't echoed
                    // if the stdin is redirected, don't bother querying/changing console mode
                    //
                    if (dwInputMode == FILE_TYPE_CHAR) {
                        if (!GetConsoleMode(hConsole, &dwMode)) {
                            Error_print(FALSE);
                            return CVY_ERROR_SYSTEM;
                        }

                        if (!SetConsoleMode(hConsole, dwMode &= ~ENABLE_ECHO_INPUT)) {
                            Error_print(FALSE);
                            return CVY_ERROR_SYSTEM;
                        }
                    }

                    for (i = 0; i < CVY_STR_SIZE - 1; i++) {
                        //
                        // read a character, copying to the buffer
                        // break out of loop on CR and EOF
                        //
                        if ((psw_buf[i] = fgetwc(stdin)) == WEOF)
                            break;

                        if (psw_buf[i] == L'\n')
                            break;
                    }

                    // NULL terminate the password
                    psw_buf[i] = L'\0';

                    // restore previous console mode
                    if (dwInputMode == FILE_TYPE_CHAR)
                        SetConsoleMode(hConsole, dwMode);

                    WConsole(L"\n");

                    if (i == 0)
                        dest_password = NULL;
                    else
                        dest_password = psw_buf;
                } else {
                    dest_password = argv[arg_index];
                    arg_index ++;
                }

            } else if (_wcsicmp(argv[arg_index] + 1, L"PORT") == 0) {
                arg_index++;

                if (arg_index >= argc || argv[arg_index][0] == L'/' || argv[arg_index][0] == L'-')
                    goto usage;

                dest_port = (USHORT)_wtoi(argv[arg_index]);

                if (dest_port == 0)
                    goto usage;

                arg_index++;
            } else if (_wcsicmp(argv[arg_index] + 1, L"DEST") == 0) {
                arg_index++;

                if (arg_index >= argc || argv[arg_index][0] == L'/' || argv[arg_index][0] == L'-')
                    goto usage;

                dest_addr = WlbsResolve(argv [arg_index]);

                if (dest_addr == 0)
                    goto usage;

                arg_index++;
            } else if (_wcsicmp(argv[arg_index] + 1, L"commit") == 0) {
                arg_index++;

                param3 = TRUE;
            } else
                goto usage;
        } else
            goto usage;
    }

    if (target_cl != CVY_ALL_CLUSTERS) {
        switch (command) {
        case params:
        case filter:
        case bdateam:
        case queryport:
            Process_state(command, target_cl, target_host, &options, dest_port, dest_password);
            break;
        default:
            Process(command, target_cl, target_host, param1, param2, param3, dest_port, dest_addr, dest_password);
            break;
        }

        return CVY_OK;
    }

    /* Enumerate all the clusters and call process for each one of them */
    else {
        DWORD clusters[CVY_MAX_ADAPTERS];
        DWORD len;

        len = CVY_MAX_ADAPTERS;

        WlbsEnumClusters(clusters, &len);

        if (!len) {
            Message_print(IDS_CTR_NO_CVY, CVY_NAME);
            return CVY_OK;
        }

        for (i = 0 ; i < len; i++) {
            DWORD buflen = CVY_STR_SIZE;

            switch (command) {
            case bdateam:
                /* If this is a BDA teaming operation, then call process once and break out of this loop.  This is a trick 
                   for retrieving BDA teaming state, which is global, which means that we can call this IOCTL on ANY cluster
                   instance, but we don't need to apply it to all of them - so call it the first one, and break out. */
                Process_state(command, clusters[i], target_host, &options, dest_port, dest_password);
                return CVY_OK;
            case params:
            case filter:
            case queryport:
                WlbsAddressToString(clusters[i], wbuf, &buflen);
                
                Message_print(IDS_CTR_CLUSTER_ID, wbuf);
                
                Process_state(command, clusters[i], target_host, &options, dest_port, dest_password);
                break;
            default:
                WlbsAddressToString(clusters[i], wbuf, &buflen);
                
                Message_print(IDS_CTR_CLUSTER_ID, wbuf);
                
                Process(command, clusters[i], target_host, param1, param2, param3, dest_port, dest_addr, dest_password);
                break;
            }

            if (i < len - 1)
                WConsole (L"\n");
        }

        return CVY_OK;
    }

reg_usage:
        Message_print(IDS_CTR_REG_USAGE, CVY_NAME);
        return CVY_ERROR_USAGE;

filter_usage:
        Message_print(IDS_CTR_FILTER_USAGE1, CVY_NAME);
        Message_print(IDS_CTR_FILTER_USAGE2);
        return CVY_ERROR_USAGE;

bdateam_usage:
        Message_print(IDS_CTR_BDA_TEAMING_USAGE, CVY_NAME);
        return CVY_ERROR_USAGE;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\cluster\nlb_portrule.cpp ===
/*
 * Filename: NLB_PortRule.cpp
 * Description: 
 * Author: shouse, 04.10.01
 */

#include <stdio.h>

#include "NLB_PortRule.h"

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRule::NLB_PortRule () {

    PriorityList.clear();
    LoadWeightList.clear();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
NLB_PortRule::~NLB_PortRule () {

}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::IsValid () {

    if (!Name.IsValid()) 
        return false;

    if (!Range.IsValid())
        return false;

    if (!FilteringMode.IsValid())
        return false;

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
void NLB_PortRule::Clear () {

    Name.Clear();
    Label.Clear();
    State.Clear();

    VirtualIPAddress.Clear();
    Range.Clear();
    Protocol.Clear();
    
    FilteringMode.Clear();
    Affinity.Clear();
    PriorityList.clear();
    LoadWeightList.clear();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::SetName (PWCHAR pName) {

    NLB_ASSERT(pName);

    return Name.SetName(pName);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::GetName (PWCHAR pName, ULONG length) {

    NLB_ASSERT(pName);

    return Name.GetName(pName, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::SetLabel (PWCHAR pLabel) {

    NLB_ASSERT(pLabel);

    return Label.SetText(pLabel);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::GetLabel (PWCHAR pLabel, ULONG length) {

    NLB_ASSERT(pLabel);

    return Label.GetText(pLabel, length);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::SetPortRange (ULONG start, ULONG end) {

    return Range.SetPortRange(start, end);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::GetPortRange (ULONG & start, ULONG & end) {

    return Range.GetPortRange(start, end);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::SetVirtualIPAddress (NLB_IPAddress address) {
    NLB_IPAddress::NLB_IPAddressType Type;

    if (!address.IsValid())
        return false;

    if (!address.GetIPAddressType(Type))
        return false;

    if (Type != NLB_IPAddress::Virtual)
        return false;

    VirtualIPAddress = address;
    
    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::GetVirtualIPAddress (NLB_IPAddress & address) {

    address = VirtualIPAddress;

    return VirtualIPAddress.IsValid();
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::SetState (NLB_PortRuleState::NLB_PortRuleStateType eState) {

    return State.SetState(eState);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::GetState (NLB_PortRuleState::NLB_PortRuleStateType & eState) {

    return State.GetState(eState);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::SetProtocol (NLB_PortRuleProtocol::NLB_PortRuleProtocolType eProtocol) {

    return Protocol.SetProtocol(eProtocol);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::GetProtocol (NLB_PortRuleProtocol::NLB_PortRuleProtocolType & eProtocol) {

    return Protocol.GetProtocol(eProtocol);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::SetFilteringMode (NLB_PortRuleFilteringMode::NLB_PortRuleFilteringModeType eMode) {

    return FilteringMode.SetMode(eMode);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::GetFilteringMode (NLB_PortRuleFilteringMode::NLB_PortRuleFilteringModeType & eMode) {

    return FilteringMode.GetMode(eMode);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::SetAffinity (NLB_PortRuleAffinity::NLB_PortRuleAffinityType eAffinity) {

    return Affinity.SetAffinity(eAffinity);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::GetAffinity (NLB_PortRuleAffinity::NLB_PortRuleAffinityType & eAffinity) {

    return Affinity.GetAffinity(eAffinity);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::AddSingleHostFilteringPriority (PWCHAR pHost, ULONG priority) {
    NLB_SingleHostFilteringPriorityList::iterator iHost;
    NLB_PortRulePriority                          Priority;
    
    if (!Priority.SetHost(pHost)) 
        return false;

    if (!Priority.SetPriority(priority)) 
        return false;

    iHost = PriorityList.find(pHost);
    
    if (iHost != PriorityList.end())
        return false;
    
    PriorityList.insert(NLB_SingleHostFilteringPriorityList::value_type(pHost, Priority));

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::ChangeSingleHostFilteringPriority (PWCHAR pHost, ULONG priority) {

    if (!RemoveSingleHostFilteringPriority(pHost))
        return false;

    if (!AddSingleHostFilteringPriority(pHost, priority))
        return false;

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::GetSingleHostFilteringPriority (PWCHAR pHost, ULONG & priority) {
    NLB_SingleHostFilteringPriorityList::iterator iHost;
    NLB_PortRulePriority                          Priority;

    iHost = PriorityList.find(pHost);
    
    if (iHost == PriorityList.end())
        return false;

    Priority = (*iHost).second;

    return Priority.GetPriority(priority);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::RemoveSingleHostFilteringPriority (PWCHAR pHost) {
    NLB_SingleHostFilteringPriorityList::iterator iHost;

    iHost = PriorityList.find(pHost);
    
    if (iHost == PriorityList.end())
        return false;

    PriorityList.erase(pHost);

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
ULONG NLB_PortRule::SetSingleHostFilteringPriorityList (vector<NLB_PortRulePriority> pList) {
    vector<NLB_PortRulePriority>::iterator iPriority;
    ULONG                                  num = 0;

    PriorityList.clear();

    for (iPriority = pList.begin(); iPriority != pList.end(); iPriority++) {
        NLB_PortRulePriority * pPriority = iPriority;
        WCHAR                  wszString[MAX_PATH];
        ULONG                  value;

        if (!pPriority->IsValid())
            continue;

        if (!pPriority->GetHost(wszString, MAX_PATH))
            continue;

        if (!pPriority->GetPriority(value))
            continue;

        if (!AddSingleHostFilteringPriority(wszString, value))
            continue;
        
        num++;
    }

    return num;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
ULONG NLB_PortRule::GetSingleHostFilteringPriorityList (vector<NLB_PortRulePriority> * pList) {
    NLB_SingleHostFilteringPriorityList::iterator iPriority;
    ULONG                                         num = 0;

    NLB_ASSERT(pList);

    pList->clear();

    for (iPriority = PriorityList.begin(); iPriority != PriorityList.end(); iPriority++) {
        NLB_PortRulePriority Priority = (*iPriority).second;

        pList->push_back(Priority);
        
        num++;
    }

    return num;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::AddMultipleHostFilteringLoadWeight (PWCHAR pHost, ULONG weight) {
    NLB_MultipleHostFilteringLoadWeightList::iterator iHost;
    NLB_PortRuleLoadWeight                            Weight;
    
    if (!Weight.SetHost(pHost))
        return false;

    if (!Weight.SetWeight(weight))
        return false;

    iHost = LoadWeightList.find(pHost);
    
    if (iHost != LoadWeightList.end())
        return false;

    LoadWeightList.insert(NLB_MultipleHostFilteringLoadWeightList::value_type(pHost, Weight));

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::ChangeMultipleHostFilteringLoadWeight (PWCHAR pHost, ULONG weight) {

    if (!RemoveMultipleHostFilteringLoadWeight(pHost))
        return false;

    if (!AddMultipleHostFilteringLoadWeight(pHost, weight))
        return false;

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::GetMultipleHostFilteringLoadWeight (PWCHAR pHost, ULONG & weight) {
    NLB_MultipleHostFilteringLoadWeightList::iterator iHost;
    NLB_PortRuleLoadWeight                            Weight;

    iHost = LoadWeightList.find(pHost);
    
    if (iHost == LoadWeightList.end())
        return false;

    Weight = (*iHost).second;

    return Weight.GetWeight(weight);
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
bool NLB_PortRule::RemoveMultipleHostFilteringLoadWeight (PWCHAR pHost) {
    NLB_MultipleHostFilteringLoadWeightList::iterator iHost;

    iHost = LoadWeightList.find(pHost);
    
    if (iHost == LoadWeightList.end())
        return false;

    LoadWeightList.erase(pHost);

    return true;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
ULONG NLB_PortRule::SetMultipleHostFilteringLoadWeightList (vector<NLB_PortRuleLoadWeight> pList) {
    vector<NLB_PortRuleLoadWeight>::iterator iLoadWeight;
    ULONG                                    num = 0;

    LoadWeightList.clear();

    for (iLoadWeight = pList.begin(); iLoadWeight != pList.end(); iLoadWeight++) {
        NLB_PortRuleLoadWeight * pLoadWeight = iLoadWeight;
        WCHAR                    wszString[MAX_PATH];
        ULONG                    value;

        if (!pLoadWeight->IsValid())
            continue;

        if (!pLoadWeight->GetHost(wszString, MAX_PATH))
            continue;

        if (!pLoadWeight->GetWeight(value))
            continue;

        if (!AddMultipleHostFilteringLoadWeight(wszString, value))
            continue;
        
        num++;
    }

    return num;
}

/*
 * Method: 
 * Description: 
 * Author: Created by shouse, 4.26.01
 * Notes: 
 */
ULONG NLB_PortRule::GetMultipleHostFilteringLoadWeightList (vector<NLB_PortRuleLoadWeight> * pList) {
    NLB_MultipleHostFilteringLoadWeightList::iterator iLoadWeight;
    ULONG                                             num = 0;

    NLB_ASSERT(pList);

    pList->clear();

    for (iLoadWeight = LoadWeightList.begin(); iLoadWeight != LoadWeightList.end(); iLoadWeight++) {
        NLB_PortRuleLoadWeight LoadWeight = (*iLoadWeight).second;

        pList->push_back(LoadWeight);
        
        num++;
    }

    return num;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\init.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	init.c

Abstract:

	Windows Load Balancing Service (WLBS)
        Driver - initialization implementation

Author:

    kyrilf
    shouse

--*/

#define NDIS51_MINIPORT         1
#define NDIS_MINIPORT_DRIVER    1
#define NDIS50                  1
#define NDIS51                  1

#include <stdio.h>
#include <ndis.h>

#include "main.h"
#if defined (NLB_TCP_NOTIFICATION)
#include "load.h"
#endif
#include "init.h"
#include "prot.h"
#include "nic.h"
#include "univ.h"
#include "wlbsparm.h"
#include "log.h"
#include "trace.h"
#include "nlbwmi.h"
#include "init.tmh"

#if defined (NLB_TCP_NOTIFICATION)
/* For TCP connection notifications. */
#include <tcpinfo.h>
#endif

static ULONG log_module_id = LOG_MODULE_INIT;

/* Added for NDIS51. */
extern VOID Nic_pnpevent_notify (
    NDIS_HANDLE           adapter_handle,
    NDIS_DEVICE_PNP_EVENT pnp_event,
    PVOID                 info_buf,
    ULONG                 info_len);

/* Mark code that is used only during initialization. */
#pragma alloc_text (INIT, DriverEntry)

NDIS_STATUS DriverEntry (
    PVOID                         driver_obj,
    PVOID                         registry_path)
{
    NDIS_PROTOCOL_CHARACTERISTICS prot_char;
    NDIS_MINIPORT_CHARACTERISTICS nic_char;
    NDIS_STRING                   prot_name = UNIV_NDIS_PROTOCOL_NAME;
    NTSTATUS                      status;
    PUNICODE_STRING               reg_path = (PUNICODE_STRING) registry_path;
    WCHAR                         params [] = L"\\Parameters\\Interface\\";
    ULONG                         i;

    //
    // Initialize WMI event tracing
    //
    Trace_Initialize( driver_obj, registry_path );

    /* Register Convoy protocol with NDIS. */
    UNIV_PRINT_INFO(("DriverEntry: Loading the driver, driver_obj=0x%p", driver_obj));
    TRACE_INFO("->%!FUNC! Loading the driver, driver_obj=0x%p", driver_obj);

    univ_driver_ptr = driver_obj;

    /* Initialize the array of bindings. */
    univ_adapters_count = 0;

    for (i = 0 ; i < CVY_MAX_ADAPTERS; i++)
    {
        univ_adapters [i] . code            = MAIN_ADAPTER_CODE;
        univ_adapters [i] . announced       = FALSE;
        univ_adapters [i] . inited          = FALSE;
        univ_adapters [i] . bound           = FALSE;
        univ_adapters [i] . used            = FALSE;
        univ_adapters [i] . ctxtp           = NULL;
        univ_adapters [i] . device_name_len = 0;
        univ_adapters [i] . device_name     = NULL;
    }

#if defined (NLB_TCP_NOTIFICATION)
    /* Initialize the TCP connection callback object. */
    univ_tcp_callback_object = NULL;

    /* Initialize the TCP connection callback function. */
    univ_tcp_callback_function = NULL;

    /* Initialize the NLB public connection callback object. */
    univ_alternate_callback_object = NULL;

    /* Initialize the NLB public connection callback function. */
    univ_alternate_callback_function = NULL;
#endif

#if defined (NLB_HOOK_ENABLE)
    /* Allocate the spin lock for filter hook registration. */
    NdisAllocateSpinLock(&univ_hooks.FilterHook.Lock);

    /* Set the state to none. */
    univ_hooks.FilterHook.Operation = HOOK_OPERATION_NONE;

    /* Initially, no filter hook interface is registered. */
    Main_hook_interface_init(&univ_hooks.FilterHook.Interface);

    /* Reset the send filter hook information. */
    Main_hook_init(&univ_hooks.FilterHook.SendHook);

    /* Reset the query filter hook information. */
    Main_hook_init(&univ_hooks.FilterHook.QueryHook);

    /* Reset the receive filter hook information. */
    Main_hook_init(&univ_hooks.FilterHook.ReceiveHook);
#endif

    /* create UNICODE name for the protocol */

    /* Store the registry path as passed, into a unicode string */
    status = NdisAllocateMemoryWithTag (&(DriverEntryRegistryPath.Buffer), reg_path -> Length + sizeof(UNICODE_NULL), UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("DriverEntry: Error allocating memory %x", status));
        TRACE_CRIT("%!FUNC! Error allocating memory 0x%x", status);
        goto error;
    }

    RtlCopyMemory (DriverEntryRegistryPath.Buffer, reg_path -> Buffer, reg_path -> Length);
    DriverEntryRegistryPath.Buffer[reg_path->Length / sizeof(WCHAR)] = UNICODE_NULL;

    DriverEntryRegistryPath.Length =  reg_path -> Length;
    DriverEntryRegistryPath.MaximumLength = reg_path -> Length + sizeof(UNICODE_NULL);


    univ_reg_path_len = reg_path -> Length + wcslen (params) * sizeof (WCHAR) + sizeof (WCHAR);

    status = NdisAllocateMemoryWithTag (& univ_reg_path, univ_reg_path_len, UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("DriverEntry: Error allocating memory %x", status));
        __LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, univ_reg_path_len, status);
        TRACE_CRIT("%!FUNC! Error allocating memory 0x%x", status);

        /* Free previously allocated registry path unicode string */
        NdisFreeMemory(DriverEntryRegistryPath.Buffer, DriverEntryRegistryPath.MaximumLength, 0);
        RtlZeroMemory (&DriverEntryRegistryPath, sizeof(UNICODE_STRING));
        goto error;
    }

    RtlZeroMemory (univ_reg_path, reg_path -> Length + wcslen (params) * sizeof (WCHAR) + sizeof (WCHAR));

    RtlCopyMemory (univ_reg_path, reg_path -> Buffer, reg_path -> Length);

    RtlCopyMemory (((PCHAR) univ_reg_path) + reg_path -> Length, params, wcslen (params) * sizeof (WCHAR));

    /* Initialize miniport wrapper. */
    NdisMInitializeWrapper (& univ_wrapper_handle, driver_obj, registry_path, NULL);

    /* Initialize miniport characteristics. */
    RtlZeroMemory (& nic_char, sizeof (NDIS_MINIPORT_CHARACTERISTICS));

    nic_char . MajorNdisVersion         = UNIV_NDIS_MAJOR_VERSION;
    nic_char . MinorNdisVersion         = UNIV_NDIS_MINOR_VERSION;
    nic_char . HaltHandler              = Nic_halt;
    nic_char . InitializeHandler        = Nic_init;
    nic_char . QueryInformationHandler  = Nic_info_query;
    nic_char . SetInformationHandler    = Nic_info_set;
    nic_char . ResetHandler             = Nic_reset;
    nic_char . ReturnPacketHandler      = Nic_return;
    nic_char . SendPacketsHandler       = Nic_packets_send;
    nic_char . TransferDataHandler      = Nic_transfer;

    /* For NDIS51, define 3 new handlers. These handlers do nothing for now, but stuff will be added later. */
    nic_char . CancelSendPacketsHandler = Nic_cancel_send_packets;
    nic_char . PnPEventNotifyHandler    = Nic_pnpevent_notify;
    nic_char . AdapterShutdownHandler   = Nic_adapter_shutdown;

    UNIV_PRINT_INFO(("DriverEntry: Registering miniport"));
    TRACE_INFO("%!FUNC! Registering miniport");

    status = NdisIMRegisterLayeredMiniport (univ_wrapper_handle, & nic_char, sizeof (nic_char), & univ_driver_handle);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("DriverEntry: Error registering layered miniport with NDIS %x", status));
        __LOG_MSG1 (MSG_ERROR_REGISTERING, MSG_NONE, status);
        TRACE_CRIT("%!FUNC! Error registering layered miniport with NDIS 0x%x", status);
        NdisTerminateWrapper (univ_wrapper_handle, NULL);
        NdisFreeMemory(DriverEntryRegistryPath.Buffer, DriverEntryRegistryPath.MaximumLength, 0);
        RtlZeroMemory (&DriverEntryRegistryPath, sizeof(UNICODE_STRING));
        NdisFreeMemory(univ_reg_path, univ_reg_path_len, 0);
        goto error;
    }

    /* Initialize protocol characteristics. */
    RtlZeroMemory (& prot_char, sizeof (NDIS_PROTOCOL_CHARACTERISTICS));

    /* This value needs to be 0, otherwise error registering protocol */
    prot_char . MinorNdisVersion            = 0;                         
    
    prot_char . MajorNdisVersion            = UNIV_NDIS_MAJOR_VERSION;
    prot_char . BindAdapterHandler          = Prot_bind;
    prot_char . UnbindAdapterHandler        = Prot_unbind;
    prot_char . OpenAdapterCompleteHandler  = Prot_open_complete;
    prot_char . CloseAdapterCompleteHandler = Prot_close_complete;
    prot_char . StatusHandler               = Prot_status;
    prot_char . StatusCompleteHandler       = Prot_status_complete;
    prot_char . ResetCompleteHandler        = Prot_reset_complete;
    prot_char . RequestCompleteHandler      = Prot_request_complete;
    prot_char . SendCompleteHandler         = Prot_send_complete;
    prot_char . TransferDataCompleteHandler = Prot_transfer_complete;
    prot_char . ReceiveHandler              = Prot_recv_indicate;
    prot_char . ReceiveCompleteHandler      = Prot_recv_complete;
    prot_char . ReceivePacketHandler        = Prot_packet_recv;
    prot_char . PnPEventHandler             = Prot_PNP_handle;
    prot_char . Name                        = prot_name;

    UNIV_PRINT_INFO(("DriverEntry: Registering protocol"));
    TRACE_INFO("%!FUNC! Registering protocol");

    NdisRegisterProtocol(& status, & univ_prot_handle, & prot_char, sizeof (prot_char));

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("DriverEntry: Error registering protocol with NDIS %x", status));
        __LOG_MSG1 (MSG_ERROR_REGISTERING, MSG_NONE, status);
        TRACE_CRIT("%!FUNC! Error registering protocol with NDIS 0x%x", status);
        NdisTerminateWrapper (univ_wrapper_handle, NULL);
        NdisFreeMemory(DriverEntryRegistryPath.Buffer, DriverEntryRegistryPath.MaximumLength, 0);
        RtlZeroMemory (&DriverEntryRegistryPath, sizeof(UNICODE_STRING));
        NdisFreeMemory(univ_reg_path, univ_reg_path_len, 0);
        goto error;
    }

    NdisIMAssociateMiniport (univ_driver_handle, univ_prot_handle);

    NdisMRegisterUnloadHandler (univ_wrapper_handle, Init_unload);

    NdisAllocateSpinLock (& univ_bind_lock);

    /* Allocate the global spin lock to protect the list of bi-directional affinity teams. */
    NdisAllocateSpinLock(&univ_bda_teaming_lock);

#if defined (NLB_TCP_NOTIFICATION)
    /* Check to see if the registry key to over-ride notifications is there. If 
       so, use its value to determine whether or not we're using notifications 
       to track our TCP connection state.  By default, the key does not exist 
       and we will use TCP notifications. */
    (VOID)Params_read_notification();

    /* Perform the one-time intialization of the load module. */
    LoadEntry();
#endif

    UNIV_PRINT_INFO(("DriverEntry: return=NDIS_STATUS_SUCCESS"));
    TRACE_INFO("<-%!FUNC! return=NDIS_STATUS_SUCCESS");
    return NDIS_STATUS_SUCCESS;

error:

    UNIV_PRINT_INFO(("DriverEntry: return=0x%x", status));
    TRACE_INFO("<-%!FUNC! return=0x%x", status);
    return status;

} /* end DriverEntry */

VOID Init_unload (
    PVOID       driver_obj)
{
    NDIS_STATUS status;
    ULONG       i;

    UNIV_PRINT_INFO(("Init_unload: Unloading the driver, driver_obj=0x%p", driver_obj));
    TRACE_INFO("->%!FUNC! Unloading the driver, driver_obj=0x%p", driver_obj);

    /* If we failed to deallocate the context during unbind (both halt and unbind
       were not called for example) - do it now before unloading the driver. */
    for (i = 0 ; i < CVY_MAX_ADAPTERS; i++)
    {
        NdisAcquireSpinLock(& univ_bind_lock);

        if (univ_adapters [i] . inited && univ_adapters [i] . ctxtp != NULL)
        {
            univ_adapters [i] . used      = FALSE;
            univ_adapters [i] . inited    = FALSE;
            univ_adapters [i] . announced = FALSE;
            univ_adapters [i] . bound     = FALSE;

            NdisReleaseSpinLock(& univ_bind_lock);

            if (univ_adapters [i] . ctxtp) {
                Main_cleanup (univ_adapters [i] . ctxtp);

                NdisFreeMemory (univ_adapters [i] . ctxtp, sizeof (MAIN_CTXT), 0);
            }

            univ_adapters [i] . ctxtp = NULL;

            if (univ_adapters [i] . device_name)
                NdisFreeMemory (univ_adapters [i] . device_name, univ_adapters [i] . device_name_len, 0);

            univ_adapters [i] . device_name     = NULL;
            univ_adapters [i] . device_name_len = 0;
        }
        else 
        {
            NdisReleaseSpinLock(& univ_bind_lock);
        }
    }

#if defined (NLB_TCP_NOTIFICATION)
    /* Perform the last minute cleanup of the load module. */
    LoadUnload();
#endif

    /* Free the global spin lock to protect the list of bi-directional affinity teams. */
    NdisFreeSpinLock(&univ_bda_teaming_lock);

#if defined (NLB_HOOK_ENABLE)
    /* Free the spin lock for filter hook registration. */
    NdisFreeSpinLock(&univ_hooks.FilterHook.Lock);
#endif

    NdisFreeSpinLock (& univ_bind_lock);

    if (univ_prot_handle == NULL)
    {
        status = NDIS_STATUS_FAILURE;
        UNIV_PRINT_CRIT(("Init_unload: NULL protocol handle. status set to NDIS_STATUS_FAILURE"));
        TRACE_CRIT("%!FUNC! NULL protocol handle. status set to NDIS_STATUS_FAILURE");
    }
    else
    {
        NdisDeregisterProtocol (& status, univ_prot_handle);
        UNIV_PRINT_INFO(("Init_unload: Deregistered protocol. univ_prot_handle=0x%p, status=0x%x", univ_prot_handle, status));
        TRACE_INFO("%!FUNC! Deregistered protocol. univ_prot_handle=0x%p, status=0x%x", univ_prot_handle, status);
    }

    NdisFreeMemory(univ_reg_path, univ_reg_path_len, 0);

    NdisFreeMemory(DriverEntryRegistryPath.Buffer, DriverEntryRegistryPath.MaximumLength, 0);
    RtlZeroMemory (&DriverEntryRegistryPath, sizeof(UNICODE_STRING));

    UNIV_PRINT_INFO(("Init_unload: return"));
    TRACE_INFO("<-%!FUNC! return");

    //
    // Deinitialize WMI event tracing
    //
    Trace_Deinitialize();

} /* end Init_unload */

#if defined (NLB_HOOK_ENABLE)
/*
 * Function: Init_deregister_hooks
 * Description: This function forcefully de-registers any hooks that are registered with
 *              NLB.  This function is called when the last instance of NLB is being 
 *              destroyed and the device driver may be about to be unloaded.  Here, we
 *              remove the hooks and notify whoever registered them that we are going 
 *              away.  At that point, the registrar should close any open file handles on
 *              the NLB driver so the driver can be properly unloaded.
 * Parameters: None.
 * Returns: Nothing.
 * Author: shouse, 12.17.01
 * Notes: There is a lot of code here to handle the case where we have to wait for references
 *        on the filter hooks to go away before we can complete de-registration, but note that
 *        because of guarantees that NDIS makes concerning when an unbind handler will be called,
 *        this should never actually be necessary here - it is included for correctness and 
 *        completeness, not out of necessity.
 */
VOID Init_deregister_hooks (VOID)
{ 
    /* Grab the filter hook spin lock to protect access to the filter hook. */
    NdisAcquireSpinLock(&univ_hooks.FilterHook.Lock);
    
    /* Make sure that another (de)register operation isn't in progress before proceeding. */
    while (univ_hooks.FilterHook.Operation != HOOK_OPERATION_NONE) {
        /* Release the filter hook spin lock. */
        NdisReleaseSpinLock(&univ_hooks.FilterHook.Lock);
        
        /* Sleep while some other operation is in progress. */
        Nic_sleep(10);
        
        /* Grab the filter hook spin lock to protect access to the filter hook. */
        NdisAcquireSpinLock(&univ_hooks.FilterHook.Lock);                
    }

    if (univ_hooks.FilterHook.Interface.Registered) {
        /* Save the current owner of the filter hook interface. */
        HANDLE Owner = univ_hooks.FilterHook.Interface.Owner;

        /* Set the state to de-registering. */
        univ_hooks.FilterHook.Operation = HOOK_OPERATION_DEREGISTERING;

        /* Mark these hooks as NOT registered to keep any more references from accumulating. */
        univ_hooks.FilterHook.SendHook.Registered    = FALSE;
        univ_hooks.FilterHook.QueryHook.Registered   = FALSE;
        univ_hooks.FilterHook.ReceiveHook.Registered = FALSE;
        
        /* Release the filter hook spin lock. */
        NdisReleaseSpinLock(&univ_hooks.FilterHook.Lock);
        
        /* Wait for all references on the filter hook interface to disappear. */
        while (univ_hooks.FilterHook.Interface.References) {
            /* Sleep while there are references on the interface we're de-registering. */
            Nic_sleep(10);
        }
        
        /* Assert that the de-register callback MUST be non-NULL. */
        UNIV_ASSERT(univ_hooks.FilterHook.Interface.Deregister);
        
        /* Call the provided de-register callback to notify the de-registering component 
           that we have indeed de-registered the specified hook. */
        (*univ_hooks.FilterHook.Interface.Deregister)(NLB_FILTER_HOOK_INTERFACE, univ_hooks.FilterHook.Interface.Owner, NLB_HOOK_DEREGISTER_FLAGS_FORCED);
        
        /* Grab the filter hook spin lock to protect access to the filter hook. */
        NdisAcquireSpinLock(&univ_hooks.FilterHook.Lock);

        /* Reset the send filter hook information. */
        Main_hook_init(&univ_hooks.FilterHook.SendHook);

        /* Reset the query filter hook information. */
        Main_hook_init(&univ_hooks.FilterHook.QueryHook);
        
        /* Reset the receive filter hook information. */
        Main_hook_init(&univ_hooks.FilterHook.ReceiveHook);

        /* Reset the hook interface information. */
        Main_hook_interface_init(&univ_hooks.FilterHook.Interface);

        /* Remember the current owner in the hook interface.  When we invoke the forced
           de-register callback, the hook owner is supposed to close their handle on our
           IOCTL interface.  If they do not close it before we try to de-register our 
           IOCTL device, we will fail and the NLB driver will not get unloaded.  Not a 
           big deal, but in that case, we should ensure that we do NOT allow the mis-
           behaved hook to re-register with the same IOCTL handle.  If the driver IS 
           successfully unloaded, this re-set when the driver re-loads, in effect erasing
           our memory of the previous owner. */
        univ_hooks.FilterHook.Interface.Owner = Owner;

        /* Set the state to de-registering. */
        univ_hooks.FilterHook.Operation = HOOK_OPERATION_NONE;

        UNIV_PRINT_INFO(("Init_deregister_hooks: (NLB_FILTER_HOOK_INTERFACE) The filter hook interface was successfully de-registered"));
        TRACE_INFO("%!FUNC! (NLB_FILTER_HOOK_INTERFACE) The filter hook interface was successfullly de-registered");
    }

    /* Release the filter hook spin lock. */
    NdisReleaseSpinLock(&univ_hooks.FilterHook.Lock);
}
#endif

#if defined (NLB_TCP_NOTIFICATION)
/*
 * Function: Init_register_tcp_callback
 * Description: This function registers our callback function with the TCP connection
 *              notification callback object.  We will begin receiving notifications
 *              as soon as TCP is up and running.  TCP will fire these events regardless 
 *              of who is listening (even if nobody is listening).
 * Parameters: None.
 * Returns: NTSTATUS - STATUS_SUCCESS if successful; an error code otherwise.
 * Author: shouse, 4.15.02
 * Notes: 
 */
NTSTATUS Init_register_tcp_callback ()
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    CallbackName;
    NTSTATUS          Status;

    /* Initialize the name of the TCP connection notification object. */
    RtlInitUnicodeString(&CallbackName, TCP_CCB_NAME);
    
    /* Initialize the object attributes. */
    InitializeObjectAttributes(&ObjectAttributes, &CallbackName, OBJ_CASE_INSENSITIVE | OBJ_PERMANENT, NULL, NULL);

    /* Create (or open) the callback. */
    Status = ExCreateCallback(&univ_tcp_callback_object, &ObjectAttributes, TRUE, TRUE);

    if (Status == STATUS_SUCCESS)
    {
        /* Register our callback function, which will be invoked by TCP as TCP connections
           are created, established and subsequently torn-down, */
        univ_tcp_callback_function = ExRegisterCallback(univ_tcp_callback_object, Main_tcp_callback, NULL);

        /* A return value of NULL indicates a failure to register our callback function.
           Translate to an error code and relay the failure back to our caller. */
        if (univ_tcp_callback_function == NULL)
            Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

/*
 * Function: Init_deregister_tcp_callback
 * Description: If the TCP connection notification callback is registered, this
 *              function de-registers our callback function and dereferences the
 *              TCP connection notification callback object.  Note that by the 
 *              time the ExUnregisterCallback function returns, we are GUARANTEED
 *              that our callback function will never be invoked again.
 * Parameters: None.
 * Returns: Nothing.
 * Author: shouse, 4.15.02
 * Notes: ExUnregisterCallback ensures that any in-progress invocations of the callback
 *        complete before it returns, so upon return, our callback will never be invoked
 *        again.
 */
VOID Init_deregister_tcp_callback ()
{
    /* If we successfully registered a callback function, deregister it now. */
    if (univ_tcp_callback_function != NULL)
        ExUnregisterCallback(univ_tcp_callback_function);

    /* Clean up the TCP connection notification callback function. */
    univ_tcp_callback_function = NULL;

    /* If we succeeded in creating/opening the callback object, dereference it now. */
    if (univ_tcp_callback_object != NULL)
        ObDereferenceObject(univ_tcp_callback_object);

    /* Clean up our TCP connection notification callback object. */
    univ_tcp_callback_object = NULL;
}

/*
 * Function: Init_register_alternate_callback
 * Description: This function registers our callback function with the NLB public connection
 *              notification callback object.  We will begin receiving notifications as soon
 *              as other protocols begin sending them.
 * Parameters: None.
 * Returns: NTSTATUS - STATUS_SUCCESS if successful; an error code otherwise.
 * Author: shouse, 8.1.02
 * Notes: 
 */
NTSTATUS Init_register_alternate_callback ()
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    CallbackName;
    NTSTATUS          Status;

    /* Initialize the name of the NLB public connection notification object. */
    RtlInitUnicodeString(&CallbackName, NLB_CONNECTION_CALLBACK_NAME);
    
    /* Initialize the object attributes. */
    InitializeObjectAttributes(&ObjectAttributes, &CallbackName, OBJ_CASE_INSENSITIVE | OBJ_PERMANENT, NULL, NULL);

    /* Create (or open) the callback. */
    Status = ExCreateCallback(&univ_alternate_callback_object, &ObjectAttributes, TRUE, TRUE);

    if (Status == STATUS_SUCCESS)
    {
        /* Register our callback function, which will be invoked by protocols as connections
           are created, established and subsequently torn-down, */
        univ_alternate_callback_function = ExRegisterCallback(univ_alternate_callback_object, Main_alternate_callback, NULL);

        /* A return value of NULL indicates a failure to register our callback function.
           Translate to an error code and relay the failure back to our caller. */
        if (univ_alternate_callback_function == NULL)
            Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

/*
 * Function: Init_deregister_alternate_callback
 * Description: If the NLB public connection notification callback is registered, 
 *              this function de-registers our callback function and dereferences 
 *              the connection notification callback object.  Note that by the 
 *              time the ExUnregisterCallback function returns, we are GUARANTEED
 *              that our callback function will never be invoked again.
 * Parameters: None.
 * Returns: Nothing.
 * Author: shouse, 4.15.02
 * Notes: ExUnregisterCallback ensures that any in-progress invocations of the callback
 *        complete before it returns, so upon return, our callback will never be invoked
 *        again.
 */
VOID Init_deregister_alternate_callback ()
{
    /* If we successfully registered a callback function, deregister it now. */
    if (univ_alternate_callback_function != NULL)
        ExUnregisterCallback(univ_alternate_callback_function);

    /* Clean up the NLB public connection notification callback function. */
    univ_alternate_callback_function = NULL;

    /* If we succeeded in creating/opening the callback object, dereference it now. */
    if (univ_alternate_callback_object != NULL)
        ObDereferenceObject(univ_alternate_callback_object);

    /* Clean up our NLB public connection notification callback object. */
    univ_alternate_callback_object = NULL;
}
#endif

ULONG NLBMiniportCount = 0;

enum _DEVICE_STATE {
    PS_DEVICE_STATE_READY = 0,	// ready for create/delete
    PS_DEVICE_STATE_CREATING,	// create operation in progress
    PS_DEVICE_STATE_DELETING	// delete operation in progress
} NLBControlDeviceState = PS_DEVICE_STATE_READY;

/*
 * Function:
 * Purpose: This function is called by Prot_bind and registers the IOCTL interface for WLBS.
 *          The device is registered only when binding to the first network adapter.
 * Author: shouse, 3.1.01 - Copied largely from the sample IM driver net\ndis\samples\im\
 * Revision : karthicn, 12.17.01 - Added call to initialize WMI for event support
 */
NDIS_STATUS Init_register_device (BOOL *pbFirstMiniport) {
    NDIS_STATUS	     Status = NDIS_STATUS_SUCCESS;
    UNICODE_STRING   DeviceName;
    UNICODE_STRING   DeviceLinkUnicodeString;
    PDRIVER_DISPATCH DispatchTable[IRP_MJ_MAXIMUM_FUNCTION];
    UINT	     i;
    
    UNIV_PRINT_INFO(("Init_register_device: Entering, NLBMiniportCount=%u", NLBMiniportCount));
    TRACE_INFO("->%!FUNC! Entering, NLBMiniportCount=%u", NLBMiniportCount);
    
    *pbFirstMiniport = FALSE;

    NdisAcquireSpinLock(&univ_bind_lock);
    
    ++NLBMiniportCount;
    
    if (1 == NLBMiniportCount)
    {
        ASSERT(NLBControlDeviceState != PS_DEVICE_STATE_CREATING);
        
        *pbFirstMiniport = TRUE;

        UNIV_PRINT_INFO(("Init_register_device: Registering IOCTL interface"));
        TRACE_INFO("%!FUNC! Registering IOCTL interface");

        /* Another thread could be running Init_Deregister_device() on behalf 
           of another miniport instance. If so, wait for it to exit. */
        while (NLBControlDeviceState != PS_DEVICE_STATE_READY)
        {
            NdisReleaseSpinLock(&univ_bind_lock);
            NdisMSleep(1);
            NdisAcquireSpinLock(&univ_bind_lock);
        }
        
        NLBControlDeviceState = PS_DEVICE_STATE_CREATING;
        
        NdisReleaseSpinLock(&univ_bind_lock);
        
        for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
            DispatchTable[i] = Main_dispatch;
        
        NdisInitUnicodeString(&DeviceName, CVY_DEVICE_NAME);
        NdisInitUnicodeString(&DeviceLinkUnicodeString, CVY_DOSDEVICE_NAME);
        
        /* Create a device object and register our dispatch handlers. */
        Status = NdisMRegisterDevice(univ_wrapper_handle, &DeviceName, &DeviceLinkUnicodeString,
            &DispatchTable[0], &univ_device_object, &univ_device_handle);
        
        if (Status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT((" ** Error registering device with NDIS %x", Status));
            __LOG_MSG1(MSG_ERROR_REGISTERING, MSG_NONE, Status);
            TRACE_INFO("%!FUNC! Error registering device with NDIS 0x%x", Status);

            univ_device_object = NULL;
            univ_device_handle = NULL;
        }
        else
        {
            /*
                Even if NdisMRegisterDevice( ) returned NDIS_STATUS_SUCCESS, we used to 
                check if univ_device_handle was null. If it was null, it was considered
                an error and we did not call NdisMDeRegisterDevice(). Per DDK & verified
                by AliD, we only need to check for the return value. So, I removed the 
                additional check. However, since we are not aware of the reasons for the
                introduction of the additional check, I am adding the following ASSERTs,
                just in case.
                --KarthicN, 03-07-02
            */
            ASSERT(univ_device_object != NULL);
            ASSERT(univ_device_handle != NULL);
        }

        /* Initialize WMI */
        NlbWmi_Initialize(); // If non-null, it uses univ_device_object to register with WMI

#if defined (NLB_TCP_NOTIFICATION)
        /* If TCP connection notification is turned on, then register our callback function. */
        if (NLB_TCP_NOTIFICATION_ON())
        {
            /* Initialize the TCP connection notification callback. */
            Status = Init_register_tcp_callback();
            
            if (Status != STATUS_SUCCESS)
            {
                UNIV_PRINT_CRIT(("Init_register_device: Could not create/open TCP connection notification callback, Status=0x%08x", Status));
                TRACE_CRIT("%!FUNC! Could not create/open TCP connection notification callback, Status=0x%08x", Status);
                __LOG_MSG1(MSG_WARN_TCP_CALLBACK_OPEN_FAILED, MSG_NONE, Status);
            }

        /* If NLB public connection notification is turned on, then register our callback function. */
        } 
        else if (NLB_ALTERNATE_NOTIFICATION_ON())
        {
            /* Initialize the NLB public connection notification callback. */
            Status = Init_register_alternate_callback();
            
            if (Status != STATUS_SUCCESS)
            {
                UNIV_PRINT_CRIT(("Init_register_device: Could not create/open NLB public connection notification callback, Status=0x%08x", Status));
                TRACE_CRIT("%!FUNC! Could not create/open NLB public connection notification callback, Status=0x%08x", Status);
                __LOG_MSG1(MSG_WARN_ALTERNATE_CALLBACK_OPEN_FAILED, MSG_NONE, Status);
            }
        }
#endif

        NdisAcquireSpinLock(&univ_bind_lock);
        
        NLBControlDeviceState = PS_DEVICE_STATE_READY;
    }
    
    NdisReleaseSpinLock(&univ_bind_lock);
    
    UNIV_PRINT_INFO(("Init_register_device: return=0x%x", Status));
    TRACE_INFO("<-%!FUNC! return=0x%x", Status);
    
    return (Status);
}

/*
 * Function:
 * Purpose: This function is called by Prot_unbind and deregisters the IOCTL interface for WLBS.
 *          The device is deregistered only when we unbind from the last network adapter
 * Author: shouse, 3.1.01 - Copied largely from the sample IM driver net\ndis\samples\im\
 * Revision : karthicn, 12.17.01 - Added call to de-initialize from WMI for event support
 */
NDIS_STATUS Init_deregister_device (VOID) {
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    
    UNIV_PRINT_INFO(("Init_deregister_device: Entering, NLBMiniportCount=%u", NLBMiniportCount));
    TRACE_INFO("->%!FUNC! Entering, NLBMiniportCount=%u", NLBMiniportCount);
    
    NdisAcquireSpinLock(&univ_bind_lock);
    
    ASSERT(NLBMiniportCount > 0);
    
    --NLBMiniportCount;
    
    if (0 == NLBMiniportCount)
    {
        /* All miniport instances have been halted. Deregisterthe control device. */
        
        ASSERT(NLBControlDeviceState == PS_DEVICE_STATE_READY);
        
        /* Block Init_register_device() while we release the control
           device lock and deregister the device. */
        NLBControlDeviceState = PS_DEVICE_STATE_DELETING;
        
        NdisReleaseSpinLock(&univ_bind_lock);
        
#if defined (NLB_HOOK_ENABLE)
        /* If the last miniport instance is going away, forcefully de-register all 
           registered global hooks now, before we remove the IOCTL interface. */
        Init_deregister_hooks();
#endif

        // Fire wmi event to indicate NLB unbinding from the last nic
        if (NlbWmiEvents[ShutdownEvent].Enable)
        {
            NlbWmi_Fire_Event(ShutdownEvent, NULL, 0);
        }
        else 
        {
            TRACE_VERB("%!FUNC! NOT generating Shutdown event 'cos its generation is disabled");
        }

#if defined (NLB_TCP_NOTIFICATION)
        /* If TCP connection notification is turned on, then de-register our callback function. */
        if (NLB_TCP_NOTIFICATION_ON())
        {
            /* Initialize the TCP connection notification callback. */
            Init_deregister_tcp_callback();
        }
        /* If NLB public connection notification is turned on, then de-register our callback function. */
        else if (NLB_ALTERNATE_NOTIFICATION_ON())
        {
            /* Initialize the NLB public connection notification callback. */
            Init_deregister_alternate_callback();
        }
#endif

        /* DeRegister with WMI */
        NlbWmi_Shutdown();

        UNIV_PRINT_INFO(("Init_deregister_device: Deleting IOCTL interface"));
        TRACE_INFO("%!FUNC! Deleting IOCTL interface");

        if (univ_device_handle != NULL)
        {
            Status = NdisMDeregisterDevice(univ_device_handle);
            univ_device_object = NULL;
            univ_device_handle = NULL;
        }
        
        NdisAcquireSpinLock(&univ_bind_lock);

        NLBControlDeviceState = PS_DEVICE_STATE_READY;
    }

    NdisReleaseSpinLock(&univ_bind_lock);
    
    UNIV_PRINT_INFO(("Init_deregister_Device: return=0x%x", Status));
    TRACE_INFO("<-%!FUNC! return=0x%x", Status);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\diplist.c ===
/*++ Copyright(c) 2001  Microsoft Corporation

Module Name:

    NLB Driver

File Name:

    diplist.c

Abstract:

    Code to lookup if a DIP is in a list of DIPs, without holding any locks.

History:

04/24/2002  JosephJ Created

--*/

#include <ntddk.h>

#include "wlbsparm.h"
#include "diplist.h"

#include "univ.h"

#include "trace.h"
#include "diplist.tmh"

#define BITS_PER_HASHWORD  (8*sizeof((DIPLIST*)0)->BitVector[0])
#define SELECTED_BIT(_hash_value) \
                           (0x1L << ((_hash_value) % BITS_PER_HASHWORD))

VOID
DipListInitialize(
    DIPLIST  *pDL
    )
//
// Initialize a DIP List
// Must be called with lock held and before calls to any other DIP List
// function.
//
{
    NdisZeroMemory(pDL, sizeof(*pDL));
}

VOID
DipListDeinitialize(
    DIPLIST *pDL
    )
//
// Deinitialize a DIP List
// Must be called with lock held and should be the last call to the DipList.
//
{
    //
    // Print out stats...
    //
    TRACE_INFO(
        "DIPLIST: NumChecks=%lu NumFastChecks=%lu NumArrayLookups=%lu",
        pDL->stats.NumChecks,
        pDL->stats.NumFastChecks,
        pDL->stats.NumArrayLookups
        );

    //
    // Clear out the structure...
    //
    NdisZeroMemory(pDL, sizeof(*pDL));
}

VOID
DipListClear(
    DIPLIST *pDL
    )
//
// Clear all the items in a dip list.
// Must be called with lock held.
//
{
    NdisZeroMemory(pDL->Items, sizeof(pDL->Items));
    NdisZeroMemory(pDL->BitVector, sizeof(pDL->BitVector));
    NdisZeroMemory(pDL->HashTable, sizeof(pDL->HashTable));
}


VOID
DipListSetItem(
    DIPLIST *pDL,
    ULONG Index,
    ULONG Value
    )
//
// Set the value of a specific iten the the DIP list.
// Must be called with lock held.
//
{
    if (Index >= MAX_ITEMS)
    {
        ASSERT(!"DipListSetItem Index >= MAX_ITEMS");
        goto end;
    }

    if (pDL->Items[Index] == Value)
    {
        // nothing to do...
        goto end;
    }  

    pDL->Items[Index] = Value;

    //
    // recompute hash table and bit table.
    //
    {
        UCHAR iItem;
        NdisZeroMemory(pDL->BitVector, sizeof(pDL->BitVector));
        NdisZeroMemory(pDL->HashTable, sizeof(pDL->HashTable));
        for (iItem=0;iItem<MAX_ITEMS;iItem++)
        {
            Value = pDL->Items[iItem];

            if (Value == NULL_VALUE)
            {
                // Empty slot -- skip;
                continue;
            }

            //
            // set bitvalue
            //
            {
                ULONG Hash1 = Value % HASH1_SIZE;
                ULONG u     = Hash1/BITS_PER_HASHWORD;
                pDL->BitVector[u] |= SELECTED_BIT(Hash1);
            }
    
            // set hash table entry
            {
                ULONG Hash2 = Value % HASH2_SIZE;
                UCHAR *pItem = pDL->HashTable+Hash2;
                while (*pItem!=0)
                {
                    pItem++;
                }

                //
                // Note we set *pItem to 1+Index, so that 0 can be used
                // as a sentinel.
                //
                *pItem = (iItem+1);
            }
        }
    }

 end:

    return;
}

BOOLEAN
DipListCheckItem(
    DIPLIST *pDL,
    ULONG Value
    )
//
// Returns TRUE IFF an item exists with the specified value.
// May NOT be called with the lock held. If it's called concurrently
// with one of the other functions, the return value is indeterminate.
//
{
    BOOLEAN fRet = FALSE;

#if DBG

    ULONG fRetDbg = FALSE;

    //
    // Debug only: search for the Items array for the specified value...
    //
    {
        int i;
        ULONG *pItem = pDL->Items;
    
        for (i=0; i<MAX_ITEMS; i++)
        {
            if (pItem[i] == Value)
            {
                fRetDbg = TRUE;
                break;
            }
        }
    }

    pDL->stats.NumChecks++;
#endif


    //
    // check bitvalue
    //
    {
        ULONG Hash1 = Value % HASH1_SIZE;
        ULONG u     = Hash1/BITS_PER_HASHWORD;
        if (!(pDL->BitVector[u] & SELECTED_BIT(Hash1)))
        {
            // Can't find it!
#if DBG
            pDL->stats.NumFastChecks++;
#endif // DBG
            goto end;
        }
    }

    // check hash table
    {
        ULONG Hash2 = Value % HASH2_SIZE;
        UCHAR *pItem = pDL->HashTable+Hash2;
        UCHAR iItem;

        //
        // Because of the size of HashTable, we are guaranteed that the LAST
        // entry in the table is ALWAYS NULL. Let's assert this important
        // condition...
        //
        if (pDL->HashTable[(sizeof(pDL->HashTable)/sizeof(pDL->HashTable[0]))-1] != 0)
        {
            ASSERT(!"DipListCheckItem: End of pDL->HashTable not NULL!");
            goto end;
        }


        while ((iItem = *pItem)!=0)
        {

#if DBG
            pDL->stats.NumArrayLookups++;
#endif // DBG

            //
            // Note (iItem-1) is the index in pDL->Items where the 
            // value is located.
            //
            if (pDL->Items[iItem-1] == Value)
            {
                fRet = TRUE; // Found it!
                break;
            }
            pItem++;
        }
    }

 end:

#if DBG
    if (fRet != fRetDbg)
    {
        //
        // We can't break here because we don't hold any locks when we
        // check, so can't GUARANTEE that fRet == fRetDbg.
        // But it'd be highly unusual
        //
        UNIV_PRINT_CRIT(("DipListCheckItem: fRet (%u) != fRetDbg (%u)", fRet, fRetDbg));
        TRACE_CRIT("%!FUNC! fRet (%u) != fRetDbg (%u)", fRet, fRetDbg);
    }
#endif //DBG

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\log.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    log.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - event logging support

Author:

    kyrilf
    shouse

--*/

#ifndef _Log_h_
#define _Log_h_

#include <ndis.h>

#include "log_msgs.h"

/* CONSTANTS */
#define LOG_NUMBER_DUMP_DATA_ENTRIES    2

/* Module IDs */
#define LOG_MODULE_INIT                 1
#define LOG_MODULE_UNLOAD               2
#define LOG_MODULE_NIC                  3
#define LOG_MODULE_PROT                 4
#define LOG_MODULE_MAIN                 5
#define LOG_MODULE_LOAD                 6
#define LOG_MODULE_UTIL                 7
#define LOG_MODULE_PARAMS               8
#define LOG_MODULE_TCPIP                9
#define LOG_MODULE_LOG                  10

#define MSG_NONE                        L""

// Summary of logging function:
// Log_event (MSG_NAME from log_msgs.mc, cluster IP address (hardcoded string %2), message 1 (%3), message 2 (%4), 
//            module location (hardcoded first dump data entry), dump data 1, dump data 2);

/* For logging a single message (string) and up to two ULONGs. */
#define __LOG_MSG(code,msg1)            Log_event (code, MSG_NONE,           msg1, MSG_NONE, __LINE__ | (log_module_id << 16), 0,           0          )
#define LOG_MSG(code,msg1)              Log_event (code, ctxtp->log_msg_str, msg1, MSG_NONE, __LINE__ | (log_module_id << 16), 0,           0          )

#define __LOG_MSG1(code,msg1,d1)        Log_event (code, MSG_NONE,           msg1, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), 0          )
#define LOG_MSG1(code,msg1,d1)          Log_event (code, ctxtp->log_msg_str, msg1, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), 0          )

#define __LOG_MSG2(code,msg1,d1,d2)     Log_event (code, MSG_NONE,           msg1, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), (ULONG)(d2))
#define LOG_MSG2(code,msg1,d1,d2)       Log_event (code, ctxtp->log_msg_str, msg1, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), (ULONG)(d2))

/* For logging up to 2 messages (strings) and up to two ULONGs. */
#define LOG_MSGS(code,msg1,msg2)        Log_event (code, ctxtp->log_msg_str, msg1, msg2,     __LINE__ | (log_module_id << 16), 0,           0          )
#define LOG_MSGS1(code,msg1,msg2,d1)    Log_event (code, ctxtp->log_msg_str, msg1, msg2,     __LINE__ | (log_module_id << 16), (ULONG)(d1), 0          )
#define LOG_MSGS2(code,msg1,msg2,d1,d2) Log_event (code, ctxtp->log_msg_str, msg1, msg2,     __LINE__ | (log_module_id << 16), (ULONG)(d1), (ULONG)(d2))

extern BOOLEAN Log_event 
(
    NTSTATUS code,           /* Status code. */
    PWSTR    str1,           /* Cluster identifier. */
    PWSTR    str2,           /* Message string. */
    PWSTR    str3,           /* Message string. */
    ULONG    loc,            /* Message location identifier. */
    ULONG    d1,             /* Dump data 1. */
    ULONG    d2              /* Dump data 2. */
);

#endif /* _Log_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\makefile.inc ===
#
# generate nlbwmi.bmf & nlbwmimof.h
#

clean:
    del nlbwmimof.h nlbwmi.bmf

$(O)\nlbwmi.mof: nlbwmi.mof

$(O)\nlbwmi.bmf: $(O)\nlbwmi.mof

nlbwmimof.h: $(O)\nlbwmi.bmf
    wmimofck -h$(O)\nlbwmimof.h $(O)\nlbwmi.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\load.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    load.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - load balancing mechanism

Author:

    bbain

--*/

#ifndef _Load_h_
#define _Load_h_

#ifndef KERNEL_MODE

#define SPINLOCK                THREADLOCK
#define IRQLEVEL                ULONG
#define LOCK_INIT(lp)           Lock_init(lp)
#define LOCK_ENTER(lp, pirql)   {if (Lock_enter((lp), INFINITE) != 1)  \
                                    UNIV_PRINT(("Lock enter error")); }
#define LOCK_EXIT(lp, irql)     {if (Lock_exit(lp) != 1)  \
                                    UNIV_PRINT(("Lock exit error")); }

#else

#include <ntddk.h>
#include <ndis.h>               /* Fixed-size block implementation. */

#define LINK                    LIST_ENTRY
#define QUEUE                   LIST_ENTRY
#define Link_init(lp)           InitializeListHead (lp)
#define Link_unlink(lp)         { RemoveEntryList (lp); InitializeListHead (lp); }
#define Queue_init(qp)          InitializeListHead (qp)
#define Queue_enq(qp, lp)       if (IsListEmpty(lp)) { InsertTailList(qp, lp); } else DbgBreakPoint()
#define Queue_front(qp)         (IsListEmpty(qp) ? NULL : (qp)->Flink)
#define Queue_tail(qp)          (IsListEmpty(qp) ? NULL : (qp)->Blink)
#define Queue_deq(qp)           Queue_front(qp); \
                                if (!IsListEmpty (qp)) { PLIST_ENTRY _lp = RemoveHeadList (qp); InitializeListHead(_lp); }
#define Queue_next(qp, lp)      ((IsListEmpty (qp) || (lp)->Flink == (qp)) ? NULL : (lp)->Flink)

#define SPINLOCK                KSPIN_LOCK
#define IRQLEVEL                KIRQL

#if 0   /* 1.03: Removed kernel mode locking in this module */
#define LOCK_INIT(lp)           KeInitializeSpinLock (lp)
#define LOCK_ENTER(lp, pirql)   KeAcquireSpinLock (lp, pirql)
#define LOCK_EXIT(lp, irql)     KeReleaseSpinLock (lp, irql)
#else
#define LOCK_INIT(lp)
#define LOCK_ENTER(lp, pirql)
#define LOCK_EXIT(lp, irql)
#endif

#endif


#include "wlbsparm.h"
#include "params.h"
#include "wlbsiocl.h"

/* CONSTANTS */

/* This is the hardcoded second paramter to Map() when map function limiting is needed. */
#define MAP_FN_PARAMETER 0x00000000

#define CVY_LOADCODE	0xc0deba1c	/* type checking code for load structure */
#define CVY_ENTRCODE	0xc0debaa5	/* type checking code for conn entry */
#define CVY_DESCCODE	0xc0deba5a	/* type checking code for conn descr */
#define CVY_BINCODE 	0xc0debabc	/* type checking code for bin structure */
#if defined (NLB_TCP_NOTIFICATION)
#define CVY_PENDINGCODE 0xc0deba55      /* type checking code for pending connection entries */
#endif

#define CVY_MAXBINS     60      /* number of load balancing bins; must conform to MAP_T definition */
#define CVY_MAX_CHASH   4099    /* maximum hash entries for connection hashing */

#define CVY_EQUAL_LOAD  50      /* load percentage used for equal load balance */

/* TCP connection status */

#define CVY_CONN_UP     1       /* connection may be coming up */
#define CVY_CONN_DOWN   2       /* connection may be going down */
#define CVY_CONN_RESET  3       /* connection is getting reset */

/* broadcast host states */

#define HST_NORMAL  1       /* normal operations */
#define HST_STABLE  2       /* stable convergence detected */
#define HST_CVG     3       /* converging to new load balance */

#define IS_TCP_PKT(protocol)     (((protocol) == TCPIP_PROTOCOL_TCP) || ((protocol) == TCPIP_PROTOCOL_GRE) || ((protocol) == TCPIP_PROTOCOL_PPTP))
#define IS_SESSION_PKT(protocol) (IS_TCP_PKT(protocol) || ((protocol) == TCPIP_PROTOCOL_IPSEC1))

#if defined (NLB_TCP_NOTIFICATION)
#define GET_LOAD_LOCK(lp) (&((PMAIN_CTXT)(CONTAINING_RECORD((lp), MAIN_CTXT, load)))->load_lock)
#endif

/* Bitmap for teaming, which is of the form:

   -------------------------------------
   |XXXXXXXX|PPPPPPPP|PPPPPPPP|NNNNNHMA|
   -------------------------------------

   X: Reserved
   P: XOR of the least significant 16 bits of each participant
   N: Number of participants
   H: Hashing (Reverse=1, Normal=0)
   M: Master (Yes=1, No=0)
   A: Teaming active (Yes=1, No=0)
*/
#define CVY_BDA_TEAMING_CODE_ACTIVE_OFFSET      0
#define CVY_BDA_TEAMING_CODE_MASTER_OFFSET      1
#define CVY_BDA_TEAMING_CODE_HASHING_OFFSET     2
#define CVY_BDA_TEAMING_CODE_NUM_MEMBERS_OFFSET 3
#define CVY_BDA_TEAMING_CODE_MEMBERS_OFFSET     8

#define CVY_BDA_TEAMING_CODE_ACTIVE_MASK        0x00000001
#define CVY_BDA_TEAMING_CODE_MASTER_MASK        0x00000002
#define CVY_BDA_TEAMING_CODE_HASHING_MASK       0x00000004
#define CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK   0x000000f8
#define CVY_BDA_TEAMING_CODE_MEMBERS_MASK       0x00ffff00

#define CVY_BDA_TEAMING_CODE_CREATE(code,active,master,hashing,num,members)                                       \
        (code) |= ((active)  << CVY_BDA_TEAMING_CODE_ACTIVE_OFFSET)      & CVY_BDA_TEAMING_CODE_ACTIVE_MASK;      \
        (code) |= ((master)  << CVY_BDA_TEAMING_CODE_MASTER_OFFSET)      & CVY_BDA_TEAMING_CODE_MASTER_MASK;      \
        (code) |= ((hashing) << CVY_BDA_TEAMING_CODE_HASHING_OFFSET)     & CVY_BDA_TEAMING_CODE_HASHING_MASK;     \
        (code) |= ((num)     << CVY_BDA_TEAMING_CODE_NUM_MEMBERS_OFFSET) & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK; \
        (code) |= ((members) << CVY_BDA_TEAMING_CODE_MEMBERS_OFFSET)     & CVY_BDA_TEAMING_CODE_MEMBERS_MASK;

#define CVY_BDA_TEAMING_CODE_RETRIEVE(code,active,master,hashing,num,members)                                \
        active  = (code & CVY_BDA_TEAMING_CODE_ACTIVE_MASK)      >> CVY_BDA_TEAMING_CODE_ACTIVE_OFFSET;      \
        master  = (code & CVY_BDA_TEAMING_CODE_MASTER_MASK)      >> CVY_BDA_TEAMING_CODE_MASTER_OFFSET;      \
        hashing = (code & CVY_BDA_TEAMING_CODE_HASHING_MASK)     >> CVY_BDA_TEAMING_CODE_HASHING_OFFSET;     \
        num     = (code & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_NUM_MEMBERS_OFFSET; \
        members = (code & CVY_BDA_TEAMING_CODE_MEMBERS_MASK)     >> CVY_BDA_TEAMING_CODE_MEMBERS_OFFSET;

/* DATA STRUCTURES */


/* type for a bin map (V2.04) */

typedef ULONGLONG   MAP_T, * PMAP_T;

/* state for all bins within a port group */

typedef struct {
    ULONG       index;                      /* index in array of bin states */
    ULONG       code;                       /* type checking code (bbain 8/17/99) */
    MAP_T       targ_map;                   /* new target load map for local host */
    MAP_T       all_idle_map;               /* map of bins idle in all other hosts */
    MAP_T       cmap;                       /* cache of cur_map for this host (v2.1) */
    MAP_T       new_map[CVY_MAX_HOSTS];     /* new map for hosts while converging */
    MAP_T       cur_map[CVY_MAX_HOSTS];     /* current ownership mask per host */
    MAP_T       chk_map[CVY_MAX_HOSTS];     /* map of cur & rdy bins for all hosts */
                                            /* used as a check for coverage */
    MAP_T       idle_map[CVY_MAX_HOSTS];    /* map of idle bins per host */
    BOOLEAN     initialized;                /* TRUE => port group has been initialized (v2.06) */
    BOOLEAN     compatible;                 /* TRUE => detected that rule codes do not match */
    BOOLEAN     equal_bal;                  /* TRUE => all hosts balance evenly */
    USHORT      affinity;                   /* TRUE => client affinity for this port */
    ULONG       mode;                       /* processing mode */
    ULONG       prot;                       /* protocol */
    ULONG       tot_load;                   /* total load percentages for all hosts */
    ULONG       orig_load_amt;              /* original load amt. for this host */
    ULONG       load_amt[CVY_MAX_HOSTS];    /* multi:  load percentages per host
                                               single: host priorities (1..CVY_MAXHOSTS)
                                               equal:  100
                                               dead:   0 */
    MAP_T       snd_bins;                   /* local bins to send when ready */
    MAP_T       rcv_bins;                   /* remote bins to receive when ready */
    MAP_T       rdy_bins;                   /* snd bins that are ready to send
                                               or have been sent but not acknowledged */
    MAP_T       idle_bins;                  /* bins with no connections active */
    LONG        tconn;                      /* total # active local connections (v2.06) */
    LONG        nconn[CVY_MAXBINS];         /* # active local connections per bin */
    QUEUE       connq;                      /* queue of active connections on all bins */

    /* Some performance counters. */
    ULONGLONG   packets_accepted;           /* The number of packets accepted by this host on this port rule. */
    ULONGLONG   packets_dropped;            /* The number of packets dropped by this host on this port rule. */
    ULONGLONG   bytes_accepted;             /* The number of bytes accepted by this host on this port rule. */
    ULONGLONG   bytes_dropped;              /* The number of bytes dropped by this host on this port rule. */
} BIN_STATE, * PBIN_STATE;

/* ping message */

#pragma pack(1)

typedef struct {
    USHORT      host_id;                    /* my host id */
    USHORT      master_id;                  /* current master host id */
    USHORT      state;                      /* my host's state */
    USHORT      nrules;                     /* # active rules */
    ULONG       hcode;                      /* unique host code */
    ULONG       pkt_count;                  /* count of packets handled since cvg'd (1.32B) */
    ULONG       teaming;                    /* BDA teaming configuraiton information. */
    ULONG       reserved;                   /* unused. */
    ULONG       rcode[CVY_MAX_RULES];       /* rule code */
    MAP_T       cur_map[CVY_MAX_RULES];     /* my current load map for each port group */
    MAP_T       new_map[CVY_MAX_RULES];     /* my new load map for each port group */
                                            /* if converging */
    MAP_T       idle_map[CVY_MAX_RULES];    /* map of idle bins for each port group */
    MAP_T       rdy_bins[CVY_MAX_RULES];    /* my rdy to send bins for each port group */
    ULONG       load_amt[CVY_MAX_RULES];    /* my load amount for each port group */
    ULONG       pg_rsvd1[CVY_MAX_RULES];    /* reserved */
} PING_MSG, * PPING_MSG;

/* Connection entry flags. */
#define NLB_CONN_ENTRY_FLAGS_USED       0x0001 /* Whether or not the descriptor is currently in use. */
#define NLB_CONN_ENTRY_FLAGS_DIRTY      0x0002 /* Whether or not the descriptor is DIRTY. */
#define NLB_CONN_ENTRY_FLAGS_ALLOCATED  0x0004 /* Whether or not the descriptor was dynamically allocated. */
#define NLB_CONN_ENTRY_FLAGS_VIRTUAL    0x0008 /* Whether or not the descriptor is virtual. */

#pragma pack()

/* unique connection entry */

typedef struct {
    LINK        blink;          /* Link into bin queue or dirty queue. */
    LINK        rlink;          /* Link into the recovery or expired queue. */
#if defined (NLB_TCP_NOTIFICATION)
    LINK        glink;          /* Link into the global established queue. */
    PVOID       load;           /* A pointer to the load module on which this descriptor belongs. */
#endif
    ULONG       code;           /* Type checking code. */
    ULONG       timeout;        /* The time at which this descriptor expires (clock_sec + lifetime). */
    USHORT      flags;          /* Flags => alloc, dirty, used, etc. */
    UCHAR       bin;            /* The bin number this connection belongs on. */
    UCHAR       protocol;       /* The protocol type for this descriptor - we no
                                   longer use descriptors only for TCP connections. */
    ULONG       client_ipaddr;  /* The client IP address. */
    ULONG       svr_ipaddr;     /* The server IP address. */
    USHORT      client_port;    /* The client port. */
    USHORT      svr_port;       /* The server port. */
    SHORT       ref_count;      /* The number of references on this descriptor. */
    USHORT      index;          /* The connection queue index. */
} CONN_ENTRY, * PCONN_ENTRY;

/* connection descriptor */

typedef struct {
    LINK        link;           /* Link into free descriptor pool or hash table queue. */
    ULONG       code;           /* Type checking code. */
    CONN_ENTRY  entry;          /* The connection entry. */
} CONN_DESCR, * PCONN_DESCR;

#if defined (NLB_TCP_NOTIFICATION)
typedef struct {
    LINK        link;           /* Link into the global pending queue. */
    ULONG       code;           /* Type checking code. */
    ULONG       client_ipaddr;  /* The client IP address. */
    ULONG       svr_ipaddr;     /* The server IP address. */
    USHORT      client_port;    /* The client port. */
    USHORT      svr_port;       /* The server port. */
    UCHAR       protocol;       /* The IP protocol. */
} PENDING_ENTRY, * PPENDING_ENTRY;

typedef struct {
    NDIS_SPIN_LOCK lock;        /* A lock to protect access to the queue. */
    ULONG          length;      /* The length of the queue - for debugging purposes. */
    QUEUE          queue;       /* The connection entry queue. */
} GLOBAL_CONN_QUEUE, * PGLOBAL_CONN_QUEUE;
#endif

/* load module's context */

typedef struct {
    ULONG       ref_count;                  /* The reference count on this load module. */
    ULONG       my_host_id;                 /* local host id and priority MINUS one */
    ULONG       code;                       /* type checking code (bbain 8/17/99) */

    PING_MSG    send_msg;                   /* current message to send */

#ifndef KERNEL_MODE     /* 1.03: Removed kernel mode locking in this module */
    SPINLOCK    lock;                       /* lock for mutual exclusion */
#endif

    ULONG       def_timeout,                /* default timeout in msec */
                cur_timeout;                /* current timeout in msec */

    ULONG       cln_timeout;                /* cleanup timeout in msec */
    ULONG       cur_time;                   /* current time waiting for cleanup */

    ULONG       host_map,                   /* map of currently active hosts */
                ping_map,                   /* map of currently pinged hosts */
                min_missed_pings,           /* # missed pings to trigger host dead */
                pkt_count;                  /* count of packets handled since cvg'd (1.32B) */
    ULONG       last_hmap;                  /* host map after last convergence (bbain RTM RC1 6/23/99) */
    ULONG       nmissed_pings[CVY_MAX_HOSTS];
                                            /* missed ping count for each host */
    BOOLEAN     initialized;                /* TRUE => this module has been initialized */
    BOOLEAN     active;                     /* TRUE => this module is active */
    BOOLEAN     consistent;                 /* TRUE => this host has seen consistent
                                               information from other hosts */

    ULONG       legacy_hosts;               /* a host map of legacy (win2k/NT4.0) hosts in the cluster. */

    BOOLEAN     bad_team_config;            /* TRUE => inconsistent BDA teaming configuration detected. */

    BOOLEAN     dup_hosts;                  /* TRUE => duplicate host id's seen */
    BOOLEAN     dup_sspri;                  /* TRUE => duplicate single server
                                               priorities seen */
    BOOLEAN     bad_map;                    /* TRUE => bad new map detected */
    BOOLEAN     overlap_maps;               /* TRUE => overlapping maps detected */
    BOOLEAN     err_rcving_bins;            /* TRUE => error receiving bins detected */
    BOOLEAN     err_orphans;                /* TRUE => orphan bins detected */
    BOOLEAN     bad_num_rules;              /* TRUE => different number of rules seen */
    BOOLEAN     alloc_inhibited;            /* TRUE => inhibited malloc of conn's. */
    BOOLEAN     alloc_failed;               /* TRUE => malloc failed */
    BOOLEAN     bad_defrule;                /* TRUE => invalid default rule detected */

    BOOLEAN     scale_client;               /* TRUE => scale client requests;
                                               FALSE => hash all client requests to one
                                               server host */
    BOOLEAN     cln_waiting;                /* TRUE => waiting for cleanup (v1.32B) */

    ULONG       num_dirty;                  /* Total number of dirty connections. */
    ULONG       dirty_bin[CVY_MAXBINS];     /* Count of dirty connections per bin. */

    ULONG       stable_map;                 /* map of stable hosts */
    ULONG       min_stable_ct;              /* min needed # of timeouts with stable
                                               condition */
    ULONG       my_stable_ct;               /* count of timeouts locally stable */
    ULONG       all_stable_ct;              /* count of timeouts with all stable
                                               condition */

    LONG        nconn;                      /* # active conns across all port rules (v2.1) */
    ULONG       dscr_per_alloc;             /* # conn. descriptors per allocation */
    ULONG       max_dscr_allocs;            /* max # descriptor allocations */
    ULONG       num_dscr_out;               /* number of outstanding descriptors (in use). */
    ULONG       max_dscr_out;               /* maximum number of outstanding descriptors (in use) allowed. */
    HANDLE      free_dscr_pool;             /* FSB descriptor pool handle. */

    BIN_STATE   pg_state[CVY_MAX_RULES];    /* bin state for all active rules */
    CONN_ENTRY  hashed_conn[CVY_MAX_CHASH]; /* hashed connection entries */
    QUEUE       connq[CVY_MAX_CHASH];       /* queues for overloaded hashed conn's. */
    QUEUE       conn_dirtyq;                /* queue of dirty connection entries (v1.32B) */
    QUEUE       conn_rcvryq;                /* connection recover queue V2.1.5 */

    /* NOTE: This general clock mechanism should be moved out to MAIN_CTXT and maintained by main.c
       for use by both the load module and main module.  The load module uses it for things like
       timing out descriptors and the main module should use it for things like IGMP, cluster IP 
       change and descriptor cleanup timeouts. */
    ULONG       clock_sec;                  /* internal clock (sec) used for timing out descriptors.  This clock is used to 
                                               count seconds from the time the load module started, which will cause this
                                               to overflow in approximately 132 years if the machine stayed alive with NLB
                                               running constantly. */
    ULONG       clock_msec;                 /* internal clock (msec w/in a sec) used for timing out descriptors. */
    QUEUE       tcp_expiredq;               /* expired TCP connection descriptor queue */
    QUEUE       ipsec_expiredq;             /* expired IPSec connection descriptor queue */

    ULONG       tcp_timeout;                /* TCP connection descriptor timeout. */
    ULONG       ipsec_timeout;              /* IPSec connection descriptor timeout. */

    ULONG       num_convergences;           /* The total number of convergences since we joined the cluster. */
    ULONG       last_convergence;           /* The time of the last convergence. */

    PCVY_PARAMS params;                     /* pointer to the global parameters */
} LOAD_CTXT, * PLOAD_CTXT;

#if defined (NLB_TCP_NOTIFICATION)
#define CVY_PENDING_MATCH(pp, sa, sp, ca, cp, prot) ((pp)->client_ipaddr == (ca) &&               \
                                                     (pp)->client_port == ((USHORT)(cp)) &&       \
                                                     (pp)->svr_ipaddr == (sa) &&                  \
                                                     (pp)->svr_port == ((USHORT)(sp)) &&          \
                                                     (pp)->protocol == ((UCHAR)(prot)))

#define CVY_PENDING_SET(pp, sa, sp, ca, cp, prot) {                                           \
                                                    (pp)->svr_ipaddr = (sa);                  \
                                                    (pp)->svr_port = (USHORT)(sp);            \
                                                    (pp)->client_ipaddr = (ca);               \
                                                    (pp)->client_port = (USHORT)(cp);         \
                                                    (pp)->protocol = (UCHAR)(prot);           \
                                                  }
#endif

/* FUNCTIONS */


/* Load Module Functions */

#define CVY_CONN_MATCH(ep, sa, sp, ca, cp, prot)  (((ep)->flags & NLB_CONN_ENTRY_FLAGS_USED) && \
                                                   (ep)->client_ipaddr == (ca) &&               \
                                                   (ep)->client_port == ((USHORT)(cp)) &&       \
                                                   (ep)->svr_ipaddr == (sa) &&                  \
                                                   (ep)->svr_port == ((USHORT)(sp)) &&          \
                                                   (ep)->protocol == ((UCHAR)(prot)))

/*
  Determine if a connection entry matches supplied parameters
*/

#define CVY_CONN_SET(ep, sa, sp, ca, cp, prot) {                                           \
                                                 (ep)->svr_ipaddr = (sa);                  \
                                                 (ep)->svr_port = (USHORT)(sp);            \
                                                 (ep)->client_ipaddr = (ca);               \
                                                 (ep)->client_port = (USHORT)(cp);         \
                                                 (ep)->protocol = (UCHAR)(prot);           \
                                                 (ep)->flags |= NLB_CONN_ENTRY_FLAGS_USED; \
                                               }

/*
  Sets up a connection entry for the supplied parameters
*/


#define CVY_CONN_IN_USE(ep) ((ep)->flags & NLB_CONN_ENTRY_FLAGS_USED)
/*
  Checks if connection entry is in use
*/

#define CVY_CONN_CLEAR(ep) { ((ep)->flags &= ~NLB_CONN_ENTRY_FLAGS_USED); }
/*
  Clears a connection entry
*/

extern BOOLEAN Load_start(
    PLOAD_CTXT      lp);
/*
  Start load module

  function:
    Starts load module after previously initialized or stopped.

  returns: Was convergence initiated ?  
*/


extern void Load_stop(
    PLOAD_CTXT      lp);
/*
  Stop load module

  function:
    Stops load module after previously initialized or started.
*/


extern void Load_init(
    PLOAD_CTXT      lp,
    PCVY_PARAMS     params);
/*
  Initialize load module

  function:
    Initializes the load module for the first time.
*/


extern void Load_cleanup(    /* (bbain 2/25/99) */
	PLOAD_CTXT      lp);
/*
  Cleanup load module

  function:
    Cleans up the load module by releasing dynamically allocated memory.
*/

extern BOOLEAN Load_msg_rcv(
    PLOAD_CTXT      lp,
    PVOID           phdr,
    PPING_MSG       pmsg);          /* ptr. to ping message */
/*
  Receive a ping message
*/


extern PPING_MSG Load_snd_msg_get(
    PLOAD_CTXT      lp);
/*
  Get local ping message to send

  returns PPING_MSG:
      <ptr. to ping message to send>
*/

extern BOOLEAN Load_timeout(
    PLOAD_CTXT      lp,
    PULONG          new_timeout,
    PULONG          pnconn);        /* ptr. to # active conns across all port rules (v2.1) */
/*
  Handle timeout

  returns BOOLEAN:
    TRUE  => host is attached to the network
    FALSE => host lost network connection
*/

extern ULONG Load_port_change(
    PLOAD_CTXT      lp,
    ULONG           ipaddr,
    ULONG           port,
    ULONG           cmd,        /* enable, disable, set value */
    ULONG           value);
/*
  Enable or disable traffic handling for a rule containing specified port

  returns ULONG:
    IOCTL_CVY_OK        => port handling changed
    IOCTL_CVY_NOT_FOUND => rule for this port was found
    IOCTL_CVY_ALREADY   => port handling was previously completed
*/


extern ULONG Load_hosts_query(
    PLOAD_CTXT      lp,
    BOOLEAN         internal,
    PULONG          host_map);
/*
  Log and return current host map

  returns ULONG:
    <one of IOCTL_CVY_...state defined in params.h>
*/

/* 
 * Function: Load_packet_check
 * Description: This function determines whether or not to take a data packet
 *              in the IP stream identified by the IP tuple in question.
 *              Protocols that are session-less depend only on the hashing
 *              result and the ownership map.  Session-ful protocols may need
 *              to perform a descriptor look-up if ambiguity exists.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 *             limit_map_fn - whether or not to include server-side parameters in hashing
 *             reverse_hash - whether or not to reverse client and server during hashing
 * Returns: BOOLEAN - do we accept the packet? (TRUE = yes)
 * Author: bbain, shouse, 10.4.01
 * Notes:
 */
extern BOOLEAN Load_packet_check(
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    BOOLEAN         limit_map_fn,
    BOOLEAN         reverse_hash);

/* 
 * Function: Load_conn_advise
 * Description: This function determines whether or not to accept this packet, 
 *              which represents the beginning or end of a session-ful connection.
 *              If the connection is going up, and is successful, this function
 *              creates state to track the connection.  If the connection is 
 *              going down, this function removes the state for tracking the 
 *              connection.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 *             conn_status - whether the connection is going UP, DOWN, or being RESET
 *             limit_map_fn - whether or not to include server-side parameters in hashing
 *             reverse_hash - whether or not to reverse client and server during hashing
 * Returns: BOOLEAN - do we accept the packet (TRUE = yes)
 * Author: bbain, shouse, 10.4.01
 * Notes:
 */
extern BOOLEAN Load_conn_advise(
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    ULONG           conn_status,
    BOOLEAN         limit_map_fn,
    BOOLEAN         reverse_hash);

/*
 * Function: Load_add_reference
 * Description: Adds a reference to the load module to keep it from disappearing while in use.
 * Parameters: pLoad - a pointer to the load module context.
 * Returns: ULONG - the updated number of references.
 * Author: shouse, 3.29.01
 * Notes: 
 */
extern ULONG Load_add_reference (IN PLOAD_CTXT pLoad);

/*
 * Function: Load_release_reference
 * Description: Releases a reference on the load module.
 * Parameters: pLoad - a pointer to the load module context.
 * Returns: ULONG - the updated number of references.
 * Author: shouse, 3.29.01
 * Notes: 
 */
extern ULONG Load_release_reference (IN PLOAD_CTXT pLoad);

/*
 * Function: Load_get_reference_count
 * Description: Returns the current number of references on the given load module.
 * Parameters: pLoad - a pointer to the load module context.
 * Returns: ULONG - the current number of references.
 * Author: shouse, 3.29.01
 * Notes: 
 */
extern ULONG Load_get_reference_count (IN PLOAD_CTXT pLoad);

/* 
 * Function: Load_query_packet_filter
 * Description: This function takes a IP tuple and protocol and consults the load-
 *              balancing state to determine whether or not this packet would be 
 *              accepted by the load module.  In either case, the reason for the
 *              decision is also provided, plus, in most cases, some of the load
 *              module state is also returned to provide some context to justify
 *              the decision.  This function is COMPLETELY unobtrusive and makes
 *              NO changes to the actual state of the load module.
 * Parameters: lp - a pointer to the load module.
 *             pQuery - a pointer to a buffer into which the results are placed.
 *             svr_ipaddr - the server side IP address of this virtual packet.
 *             svr_port - the server side port of this virtual packet.
 *             client_ipaddr - the client side IP address of this virtual packet.
 *             client_ipaddr - the client side port of this virtual packet.
 *             protocol - the protocol of this virtual packet (UDP, TCP or IPSec1).
 *             limit_map_fin - a boolean indication of whether or not to use server
 *                             side parameters in the Map function.  This is controlled
 *                             by BDA teaming.
 *             reverse_hash - whether or not to reverse client and server during hashing
 * Returns: Nothing.
 * Author: shouse, 5.18.01
 * Notes: This function is only observatory and makes NO changes to the state of
 *        the load module. 
 */
extern VOID Load_query_packet_filter 
(
    PLOAD_CTXT                 lp,
    PNLB_OPTIONS_PACKET_FILTER pQuery,
    ULONG                      svr_ipaddr,
    ULONG                      svr_port,
    ULONG                      client_ipaddr,
    ULONG                      client_port,
    USHORT                     protocol,
    UCHAR                      flags,
    BOOLEAN                    limit_map_fn,
    BOOLEAN                    reverse_hash);

/*
 * Function: Load_query_port_state
 * Description: Queries the load module for the current state (enabled/disabled/draining) of a port rule.
 * Parameters: lp - a pointer to the load module context.
 *             pQuery - pointer to the input and output buffer for the query.
 *             ipaddr - the VIP associated with the port rule.
 *             port - a port in the range of the port rule.
 * Returns: Nothing.
 * Author: shouse, 5.18.01
 * Notes: 
 */
extern VOID Load_query_port_state 
(
    PLOAD_CTXT                   lp,
    PNLB_OPTIONS_PORT_RULE_STATE pQuery,
    ULONG                        ipaddr,
    USHORT                       port);

/*
 * Function: Load_query_convergence_info
 * Description: Queries the load module for the convergence statistics
 * Parameters: lp - a pointer to the load module context.
 *             OUT num_cvgs - a pointer to a ULONG to hold the total number of convergences on this host.
 *             OUT last_cvg - a pointer to a ULONG to hold the time since the last convergence completed.
 * Returns: BOOLEAN - whether or not the load module is active.  If TRUE, then the OUT params were filled in.
 * Author: shouse, 10.30.01
 * Notes: 
 */
extern BOOLEAN Load_query_convergence_info (PLOAD_CTXT lp, PULONG num_cvgs, PULONG last_cvg);

/*
 * Function: Load_query_statistics
 * Description: Queries the load module for some relevant statisitics
 * Parameters: lp - a pointer to the load module context.
 *             OUT num_cvgs - a pointer to a ULONG to hold the current number of active connections
 *             OUT last_cvg - a pointer to a ULONG to hold the total number of descriptors allocated thusfar
 * Returns: BOOLEAN - whether or not the load module is active.  If TRUE, then the OUT params were filled in.
 * Author: shouse, 4.19.02
 * Notes: 
 */
extern BOOLEAN Load_query_statistics (PLOAD_CTXT lp, PULONG num_conn, PULONG num_dscr);

/* 
 * Function: Load_conn_get
 * Description: This function returns the connection parameters for the descriptor
 *              at the head of the recovery queue, if one exists.  The recovery 
 *              queue holds all "active" connections, some of which may be stale.
 *              If an active descriptor exists, it fills in the connection info 
 *              and returns TRUE to indicate success; otherwise it returns FALSE
 *              to indicate that no connection was found.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             OUT svr_ipaddr - the server IP address in network byte order
 *             OUT svr_port - the server port in host byte order
 *             OUT client_ipaddr - the client IP address in network byte order
 *             OUT client_port - the client port in host byte order
 *             OUT protocol - the protocol of this connection
 * Returns: BOOLEAN - 
 * Author: shouse, 10.4.01
 * Notes: 
 */
extern BOOLEAN Load_conn_get (PLOAD_CTXT lp, PULONG svr_ipaddr, PULONG svr_port, PULONG client_ipaddr, PULONG client_port, PUSHORT protocol);

/* 
 * Function: Load_conn_sanction
 * Description: This function is called to "sanction" an active connection descriptor.
 *              Sanction means that NLB has verified that this connection is indeed
 *              still active by querying other system entities (such as TCP/IP).  To
 *              sanction a descriptor simply involves moving it from its place in the 
 *              recovery queue (should be the head in most cases) to the tail of the 
 *              recovery queue, where it has the least chance of being cannibalized.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 * Returns: BOOLEAN - was i successful in approbating the descriptor? (TRUE = yes)
 * Author: shouse, 10.4.01
 * Notes:
 */
extern BOOLEAN Load_conn_sanction (PLOAD_CTXT lp, ULONG svr_ipaddr, ULONG svr_port, ULONG client_ipaddr, ULONG client_port, USHORT protocol);

/* 
 * Function: Load_conn_notify
 * Description: This function is nearly identical to Load_conn_advise, except
 *              for two important distinctions; (1) this function is a notification,
 *              not a request, so load-balancing decisions are not made here, and
 *              (2) packet handling statistics are not incremented here, as calls
 *              to this function rarely stem from processing a real packet.  For
 *              example, when a TCP SYN packet is received, main.c calls Load_conn_advise
 *              essentially asking, "hey, should accept this new connection i just 
 *              saw?"  While, when IPSec notifies NLB that a new Main Mode SA has just
 *              been established, main.c calls Load_conn_notify essentially dictating,
 *              "hey a new connection just went up, so whether you like it or not, 
 *              create state to track this connection."
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 *             conn_status - whether the connection is going UP, DOWN, or being RESET
 *             limit_map_fn - whether or not to include server-side parameters in hashing
 *             reverse_hash - whether or not to reverse client and server during hashing
 * Returns: BOOLEAN - was i able to successfully update my state (TRUE = yes)
 * Author: shouse, 10.4.01
 * Notes:
 */
extern BOOLEAN Load_conn_notify (
    PLOAD_CTXT lp, 
    ULONG      svr_ipaddr, 
    ULONG      svr_port, 
    ULONG      client_ipaddr, 
    ULONG      client_port, 
    USHORT     protocol, 
    ULONG      conn_status, 
    BOOLEAN    limit_map_fn, 
    BOOLEAN    reverse_hash);

#if defined (NLB_TCP_NOTIFICATION)
/*
 * Function: Load_conn_up
 * Description: This function is called to create state to track a connection (usually TCP
 *              or IPSec/L2TP).  This is not a function to ask the load module whether or 
 *              not to accept a packet, rather it is a request to create state to track a 
 *              connection that is being established.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 *             limit_map_fn - whether or not to include server-side parameters in hashing
 *             reverse_hash - whether or not to reverse client and server during hashing
 * Returns: BOOLEAN - whether or not state was successfully created to track this connection.
 * Author: shouse, 4.15.02
 * Notes: DO NOT CALL THIS FUNCTION WITH THE LOAD LOCK HELD.
 */
BOOLEAN Load_conn_up (
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    BOOLEAN         limit_map_fn,
    BOOLEAN         reverse_hash);

/*
 * Function: Load_conn_down
 * Description: This function is called to destroy the state being used to track an existing
 *              connection (usually TCP or IPSec/L2TP).  If state for the given 5-tuple is 
 *              found, it is de-referenced and destroyed if appropriate (based partially on
 *              the conn_status).  If state is not found, FALSE is returned, but it not 
 *              considered a catastrophic error.  In the case of TCP notifications, perhaps
 *              the connection was not even established across a NLB NIC.
 * Parameters: svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 *             conn_status - whether the connection is going DOWN or being RESET
 * Returns: BOOLEAN - whether or not the connection state was found and updated.
 * Author: shouse, 4.15.02
 * Notes: DO NOT CALL THIS FUNCTION WITH THE LOAD LOCK HELD.
 */
BOOLEAN Load_conn_down (
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    ULONG           conn_status);

/*
 * Function: Load_conn_pending
 * Description: This function is called to create state for a pending OUTGOING connection on 
 *              the server.  Because at this time, it is unknown on what interface the connection
 *              will ultimately be established, NLB creates global state to track the connection
 *              only until it is established.  For TCP, when the SYN+ACK arrives from the peer,
 *              we only accept it if we find a match in our pending connection queues.  When the 
 *              connection is established, this state is destroyed and new state is created to 
 *              track the connection is appropriate.
 * Parameters: svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 * Returns: BOOLEAN - whether or not state was successfully created to track this pending connection.
 * Author: shouse, 4.15.02
 * Notes: DO NOT CALL THIS FUNCTION WITH THE LOAD LOCK HELD.
 */
BOOLEAN Load_conn_pending (
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol);

/*
 * Function: Load_pending_check
 * Description: This function is called to determine whether or not state exists in the pending
 *              connection queues for this connection.  If it does, the packet should be accepted.
 *              If no state exists, the packet should be dropped. 
 * Parameters: svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 * Returns: BOOLEAN - whether or not to accept the packet.
 * Author: shouse, 4.15.02
 * Notes: DO NOT CALL THIS FUNCTION WITH THE LOAD LOCK HELD.
 */
BOOLEAN Load_pending_check (
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol);

/*
 * Function: Load_conn_establish
 * Description: This function is invoked when a pending connection has become established.  
 *              When the pending connection is established, its state in the pending 
 *              connection queues is destroyed.  If the connection was ultimately established
 *              on an NLB adapter (if lp != NULL), then state will be created to track this
 *              new connection.  Otherwise, the operation consists only of destroying the 
 *              pending connection state.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 *             limit_map_fn - whether or not to include server-side parameters in hashing
 *             reverse_hash - whether or not to reverse client and server during hashing
 * Returns: BOOLEAN - whether or not the operation was successfully completed.
 * Author: shouse, 4.15.02
 * Notes: DO NOT CALL THIS FUNCTION WITH THE LOAD LOCK HELD.
 */
BOOLEAN Load_conn_establish (
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    BOOLEAN         limit_map_fn,
    BOOLEAN         reverse_hash);

/* 
 * Function: LoadEntry
 * Description: This function is called from DriverEntry to allow the load module to perform
 *              any one-time intialization of global data.
 * Parameters: None.
 * Returns: Nothing.
 * Author: shouse, 4.21.02
 * Notes: 
 */
VOID LoadEntry ();

/* 
 * Function: LoadUnload
 * Description: This function is called from Init_unload to allow the load module to perform
 *              any last minute tear-down of global data.
 * Parameters: None.
 * Returns: Nothing.
 * Author: shouse, 4.21.02
 * Notes: By the time this function is called, we are guaranteed to have de-registered
 *        our TCP callback function, if it was indeed registered.  Because ExUnregisterCallback
 *        guarantees that it will not return until all pending ExNotifyCallback routines
 *        have completed, we can be sure that by the time we get here, there will certainly
 *        not be anybody accessing any of the global connection queues or FSB pools.
 */
VOID LoadUnload ();
#endif

#endif /* _Load_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\init.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    init.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - initialization

Author:

    kyrilf

--*/


#ifndef _Init_h_
#define _Init_h_

#include <ndis.h>


/* PROCEDURES */


extern NDIS_STATUS DriverEntry (
    PVOID               driver_obj,         /* driver object */
    PVOID               registry_path);     /* system registry path to our
                                               driver */
/*
  Driver's main entry routine

  returns NDIS_STATUS:

  function:
*/


extern VOID Init_unload (
    PVOID               driver_obj);
/*
  Driver's unload routine

  returns NDIS_STATUS:

  function:
*/

/*
 * Function:
 * Purpose: This function is called by MiniportInitialize and registers the IOCTL interface for WLBS.
 *          The device is registered only for the first miniport instantiation.
 * Author: shouse, 3.1.01
 * Revision: karthicn, 3.6.02, Added argument to tell if it is the first miniport that NLB binds to.
 */
NDIS_STATUS Init_register_device (BOOL *pbFirstMiniport);

/*
 * Function:
 * Purpose: This function is called by MiniportHalt and deregisters the IOCTL interface for WLBS.
 *          The device is deregistered only wnen the last miniport halts.
 * Author: shouse, 3.1.01
 */
NDIS_STATUS Init_deregister_device (VOID);

#endif /* end _Init_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\log.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	log.c

Abstract:

	Windows Load Balancing Service (WLBS)
    Driver - event logging support

Author:

    kyrilf
    shouse

--*/

#include <ntddk.h>

#include "log.h"
#include "univ.h"

#include "trace.h" // For wmi event tracing
#include "log.tmh"

static ULONG log_module_id = LOG_MODULE_LOG;

BOOLEAN Log_event (NTSTATUS code, PWSTR msg1, PWSTR msg2, PWSTR msg3, ULONG loc, ULONG d1, ULONG d2)
{
    PIO_ERROR_LOG_PACKET ErrorLogEntry;
    UNICODE_STRING       ErrorStr[3];
    PWCHAR               InsertStr;
    ULONG                EntrySizeMinimum;
    ULONG                EntrySize;
    ULONG                BytesLeft;
    ULONG volatile       i;

    /* Initialize the three log strings. */
    RtlInitUnicodeString(&ErrorStr[0], msg1);
    RtlInitUnicodeString(&ErrorStr[1], msg2);
    RtlInitUnicodeString(&ErrorStr[2], msg3);

    /* Remember the insertion string should be NUL terminated. So we allocate the 
       extra space of WCHAR. The first parameter to IoAllocateErrorLogEntry can 
       be either the driver object or the device object. If it is given a device 
       object, the name of the device (used in IoCreateDevice) will show up in the 
       place of %1 in the message. See the message file (.mc) for more details. */
    EntrySize = sizeof(IO_ERROR_LOG_PACKET) + LOG_NUMBER_DUMP_DATA_ENTRIES * sizeof (ULONG) +
	ErrorStr[0].Length + ErrorStr[1].Length + ErrorStr[2].Length + 3 * sizeof(WCHAR);

    /* This is the minimum that we can get by with - at least enough room for all 
       of the data dump entries and the 3 NUL terminating characters. */
    EntrySizeMinimum = sizeof(IO_ERROR_LOG_PACKET) + LOG_NUMBER_DUMP_DATA_ENTRIES * sizeof (ULONG) + 3 * sizeof(WCHAR);

    /* If we can't even allocate the minimum amount of space, then bail out - this
       is a critical error that should never happen, as these limits are set at
       compile time, not run time, so unless we do something really dumb, like 
       try to allow 50 strings of 1KB of dump data, this will never happen. */
    if (EntrySizeMinimum > ERROR_LOG_MAXIMUM_SIZE) {
        UNIV_PRINT_CRIT(("Log_event: Log entry size too large, exiting: min=%u, max=%u", EntrySizeMinimum, ERROR_LOG_MAXIMUM_SIZE));
        TRACE_CRIT("%!FUNC! Log entry size too large, exiting: min=%u, max=%u", EntrySizeMinimum, ERROR_LOG_MAXIMUM_SIZE);
        return FALSE;
    }

    /* Truncate the size of the entry if necessary.  In this case, we'll put in
       whatever we can fit and truncate or eliminate the strings that don't fit. */
    if (EntrySize > ERROR_LOG_MAXIMUM_SIZE) {
        UNIV_PRINT_CRIT(("Log_event: Log entry size too large, truncating: size=%u, max=%u", EntrySize, ERROR_LOG_MAXIMUM_SIZE));
        TRACE_CRIT("%!FUNC! Log entry size too large, truncating: size=%u, max=%u", EntrySize, ERROR_LOG_MAXIMUM_SIZE);
        EntrySize = ERROR_LOG_MAXIMUM_SIZE;
    }    

    /* Allocate the log structure. */
    ErrorLogEntry = IoAllocateErrorLogEntry(univ_driver_ptr, (UCHAR)(EntrySize));

    if (!ErrorLogEntry) {
#if DBG
        /* Convert Unicode string to AnsiCode; %ls can only be used in PASSIVE_LEVEL
           Since this function is called from pretty much EVERYWHERE, we cannot 
           assume what IRQ level we're running at, so be cautious. */
        CHAR AnsiString[64];

        for (i = 0; (i < sizeof(AnsiString) - 1) && (i < ErrorStr[0].Length); i++)
            AnsiString[i] = (CHAR)msg1[i];

        AnsiString[i] = '\0';
        
        UNIV_PRINT_CRIT(("Log_event: Error allocating log entry %s", AnsiString));
        TRACE_CRIT("%!FUNC! Error allocating log entry %s", AnsiString);
#endif        
        return FALSE;
    }

    /* Fill in the necessary information into the header. */
    ErrorLogEntry->ErrorCode         = code;
    ErrorLogEntry->SequenceNumber    = 0;
    ErrorLogEntry->MajorFunctionCode = 0;
    ErrorLogEntry->RetryCount        = 0;
    ErrorLogEntry->UniqueErrorValue  = 0;
    ErrorLogEntry->FinalStatus       = STATUS_SUCCESS;
    ErrorLogEntry->DumpDataSize      = (LOG_NUMBER_DUMP_DATA_ENTRIES + 1) * sizeof (ULONG);
    ErrorLogEntry->StringOffset      = sizeof (IO_ERROR_LOG_PACKET) + LOG_NUMBER_DUMP_DATA_ENTRIES * sizeof (ULONG);
    ErrorLogEntry->NumberOfStrings   = 3;

    /* load the NUMBER_DUMP_DATA_ENTRIES plus location id here */
    ErrorLogEntry->DumpData [0]      = loc;
    ErrorLogEntry->DumpData [1]      = d1;
    ErrorLogEntry->DumpData [2]      = d2;

    /* Calculate the number of bytes available in the string storage area. */
    BytesLeft = EntrySize - ErrorLogEntry->StringOffset;

    /* Set a pointer to the beginning of the string storage area. */
    InsertStr = (PWCHAR)((PCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);

    /* Loop through all strings and put in as much of them as we can - we reserve
       at least enough room for all three NUL terminating characters. */
    for (i = 0; i < 3; i++) {
        ULONG Length;

        /* If we're inside the loop there should ALWAYS be at least two bytes left. */
        UNIV_ASSERT(BytesLeft);

        /* Find out how much of this string we can fit into the buffer - save room for the NUL characters. */
        Length = (ErrorStr[i].Length <= (BytesLeft - ((3 - i) * sizeof(WCHAR)))) ? ErrorStr[i].Length : BytesLeft - ((3 - i) * sizeof(WCHAR));

        /* Copy the number of characters that will fit. */
        RtlMoveMemory(InsertStr, ErrorStr[i].Buffer, Length);

        /* Put the NUL character at the end. */
        *(PWCHAR)((PCHAR)InsertStr + Length) = L'\0';

        /* Move the string pointer past the string. */
        InsertStr = (PWCHAR)((PCHAR)InsertStr + Length + sizeof(WCHAR));

        /* Calculate the number of bytes left now. */
        BytesLeft -= (Length + sizeof(WCHAR));
    }

    /* Write the log entry. */
    IoWriteErrorLogEntry(ErrorLogEntry);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\load.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	load.c

Abstract:
Windows Load Balancing Service (WLBS)
    Driver - load balancing algorithm

Author:

    bbain

ToDo:
    Kernel mode queue mgt
    Fail safe mode (single server for everything)
--*/

#ifdef KERNEL_MODE

#include <ntddk.h>

#include "log.h"
#include "univ.h"
#include "main.h" // added for multiple nic

static ULONG log_module_id = LOG_MODULE_LOAD;

#else

#include <stdlib.h>
#include <windows.h>
#endif

#include <stdio.h>
#include "wlbsparm.h"
#include "params.h"
#include "wlbsiocl.h"
#include "wlbsip.h"
#include "load.h"
#include "nlbwmi.h"

//
// For WPP Event Tracing
//
#include "trace.h"  // for event tracing
#include "load.tmh" // for event tracing
#ifndef KERNEL_MODE

#define UNIV_PRINT_INFO(msg)        {                                                            \
                                      printf ("NLB (Information) [%s:%d] ", __FILE__, __LINE__); \
                                      printf msg;                                                \
                                      printf ("\n");                                             \
                                    }

#define UNIV_PRINT_CRIT(msg)        {                                                      \
                                      printf ("NLB (Error) [%s:%d] ", __FILE__, __LINE__); \
                                      printf msg;                                          \
                                      printf ("\n");                                       \
                                    }

#if 0

#define UNIV_PRINT_VERB(msg)        {                                                        \
                                      printf ("NLB (Verbose) [%s:%d] ", __FILE__, __LINE__); \
                                      printf msg;                                            \
                                      printf ("\n");                                         \
                                    }

#else

#define UNIV_PRINT_VERB(msg)

#endif

#define Univ_ulong_to_str(x, y, z)      (y)

#define LOG_MSG(c,s)
#define LOG_MSG1(c,s,d1)
#define LOG_MSG2(c,s,d1,d2)

#else

#endif

#if defined (NLB_TCP_NOTIFICATION)
GLOBAL_CONN_QUEUE g_conn_estabq[CVY_MAX_CHASH];   /* Global queue of all established connections across all NLB instances. */
GLOBAL_CONN_QUEUE g_conn_pendingq[CVY_MAX_CHASH]; /* Global queue of pending connections that may or may not end up being 
                                                     established on a NIC to which NLB is bound. */
HANDLE            g_pending_conn_pool = NULL;     /* Global fixed-size block pool of PENDING_ENTRYs. */
#endif

void Bin_state_print(PBIN_STATE bp, ULONG my_host_id);
void Load_conn_kill(PLOAD_CTXT lp, PBIN_STATE bp);
PBIN_STATE Load_pg_lookup(PLOAD_CTXT lp, ULONG svr_ipaddr, ULONG svr_port, BOOLEAN is_tcp);

VOID Load_init_fsb(PLOAD_CTXT lp, PCONN_DESCR dp);
VOID Load_init_dscr(PLOAD_CTXT lp, PCONN_ENTRY ep, BOOLEAN alloc);
VOID Load_put_dscr(PLOAD_CTXT lp, PBIN_STATE bp, PCONN_ENTRY ep);

#if 0   /* v2.06 */
#define BIN_ALL_ONES    ((MAP_T)-1)                     /* bin map state for 64 ones (v2.04) */
#endif
#define BIN_ALL_ONES    ((MAP_T)(0xFFFFFFFFFFFFFFF))    /* bin map state for 60 ones (v2.04) */

/* Byte offset of a field in a structure of the specified type: */

#define CVY_FIELD_OFFSET(type, field)    ((LONG_PTR)&(((type *)0)->field))

/*
 * Address of the base of the structure given its type, field name, and the
 * address of a field or field offset within the structure:
 */

#define STRUCT_PTR(address, type, field) ((type *)( \
                                         (PCHAR)(address) - \
                                          (PCHAR)CVY_FIELD_OFFSET(type, field)))

#if defined (NLB_TCP_NOTIFICATION)
/* Mark code that is used only during initialization. */
#pragma alloc_text (INIT, LoadEntry)

/* 
 * Function: LoadEntry
 * Description: This function is called from DriverEntry to allow the load module to perform
 *              any one-time intialization of global data.
 * Parameters: None.
 * Returns: Nothing.
 * Author: shouse, 4.21.02
 * Notes: 
 */
VOID LoadEntry ()
{
    INT index;

    /* Initialize the global connection queues. */
    for (index = 0; index < CVY_MAX_CHASH; index++)
    {
        /* Allocate the spin lock to protect the queue. */
        NdisAllocateSpinLock(&g_conn_pendingq[index].lock);
        
        /* Initialize the queue head. */
        Queue_init(&g_conn_pendingq[index].queue);
        
        /* Allocate the spin lock to protect the queue. */
        NdisAllocateSpinLock(&g_conn_estabq[index].lock);
        
        /* Initialize the queue head. */
        Queue_init(&g_conn_estabq[index].queue);
    }
    
    /* Allocate a fixed-size block pool for pending connection entries. */
    g_pending_conn_pool = NdisCreateBlockPool(sizeof(PENDING_ENTRY), 0, 'pBLN', NULL);
    
    if (g_pending_conn_pool == NULL)
    {
        UNIV_PRINT_CRIT(("LoadEntry: Error creating fixed-size block pool"));
        TRACE_CRIT("%!FUNC! Error creating fixed-size block pool");
    }
}

/* 
 * Function: LoadUnload
 * Description: This function is called from Init_unload to allow the load module to perform
 *              any last minute tear-down of global data.
 * Parameters: None.
 * Returns: Nothing.
 * Author: shouse, 4.21.02
 * Notes: By the time this function is called, we are guaranteed to have de-registered
 *        our TCP callback function, if it was indeed registered.  Because ExUnregisterCallback
 *        guarantees that it will not return until all pending ExNotifyCallback routines
 *        have completed, we can be sure that by the time we get here, there will certainly
 *        not be anybody accessing any of the global connection queues or FSB pools.
 */
VOID LoadUnload ()
{
    INT index;

    /* Destroy the fixed-size block pool and all descriptors therein. 
       Note that NdisDestroyBlockPool expects all allocated blocks 
       have been returned to the pool (freed) before it is called. */
    if (g_pending_conn_pool != NULL) 
    {       
        /* Loop through all of the connection descriptor queues and 
           free all of the descriptors we've allocated. */
        for (index = 0; index < CVY_MAX_CHASH; index++)
        {
            PPENDING_ENTRY pp = NULL;
            
            NdisAcquireSpinLock(&g_conn_pendingq[index].lock);
            
            /* Dequeue the head of the queue. */
            pp = (PPENDING_ENTRY)Queue_deq(&g_conn_pendingq[index].queue);
            
            while (pp != NULL)
            {
                UNIV_ASSERT(pp->code == CVY_PENDINGCODE);
                    
                /* Free the descriptor back to the fixed-size block pool. */
                NdisFreeToBlockPool((PUCHAR)pp);
                
                /* Get the next descriptor in the queue. */
                pp = (PPENDING_ENTRY)Queue_deq(&g_conn_pendingq[index].queue);
            }
            
            NdisReleaseSpinLock(&g_conn_pendingq[index].lock);
        }
        
        /* Destroy the fixed-size block pool. */
        NdisDestroyBlockPool(g_pending_conn_pool);
    }
    
    /* De-initialize the global connection queues. */
    for (index = 0; index < CVY_MAX_CHASH; index++)
    {
        /* Free the spin locks. */
        NdisFreeSpinLock(&g_conn_estabq[index].lock);
        NdisFreeSpinLock(&g_conn_pendingq[index].lock);
    }
}
#endif

/*
 * Function: Load_teaming_consistency_notify
 * Description: This function is called to notify a team in which this adapter
 *              might be participating whether the teaming configuration in the
 *              heartbeats is consistent or not.  Inconsistent configuration
 *              results in the entire team being marked inactive - meaning that
 *              no adapter in the team will handle any traffic, except to the DIP.
 * Parameters: member - a pointer to the team membership information for this adapter.
 *             consistent - a boolean indicating the polarity of teaming consistency.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: In order to check to see whether or not this adapter is part of a team,
 *        we need to look into the team member information for this adapter.  This
 *        access should be locked, but for performance reasons, we will only lock
 *        and check for sure if we "think" we're part of a team.  Worst case is that
 *        we are in the process of joining a team and we missed this check - no 
 *        matter, we'll notify them when/if we see this again. 
 */
VOID Load_teaming_consistency_notify (IN PBDA_MEMBER member, IN BOOL consistent) {

    /* Make sure that the membership information points to something. */
    UNIV_ASSERT(member);

    /* We can check without locking to keep the common case minimally expensive.  If we do think
       we're part of a team, then we'll grab the lock and make sure.  If our first indication is 
       that we're not part of a team, then just bail out and if we actually are part of a team, 
       we'll be through here again later to notify our team if necessary. */
    if (!member->active)
        return;

    NdisAcquireSpinLock(&univ_bda_teaming_lock);
        
    /* If we are an active member of a BDA team, then notify our team of our state. */
    if (member->active) {
        /* Assert that the team actually points to something. */
        UNIV_ASSERT(member->bda_team);
        
        /* Assert that the member ID is valid. */
        UNIV_ASSERT(member->member_id <= CVY_BDA_MAXIMUM_MEMBER_ID);
        
        if (consistent) {
            UNIV_PRINT_VERB(("Load_teaming_consistency_notify: Consistent configuration detected."));
            TRACE_VERB("%!FUNC! we are a consistent active member of a BDA team");

            /* Mark this member as consistent. */
            member->bda_team->consistency_map |= (1 << member->member_id);
        } else {
            UNIV_PRINT_VERB(("Load_teaming_consistency_notify: Inconsistent configuration detected."));
            TRACE_VERB("%!FUNC! we are an inconsistent active member of a BDA team");

            /* Mark this member as inconsistent. */
            member->bda_team->consistency_map &= ~(1 << member->member_id);
            
            /* Inactivate the team. */
            member->bda_team->active = FALSE;
        }
    }

    NdisReleaseSpinLock(&univ_bda_teaming_lock);
}

/*
 * Function: Load_teaming_consistency_check
 * Description: This function is used to check our teaming configuration against the
 *              teaming configuration received in a remote heartbeat.  It does little 
 *              more than check the equality of two DWORDS, however, if this is our
 *              first notification of bad configuration, it prints a few debug state-
 *              ments as well.
 * Parameters: bAlreadyKnown - a boolean indication of whether or not we have already detected bad configuration.
 *                             If the misconfiguration is already known, no additional logging is done.
 *             member - a pointer to the team member structure for this adapter.
 *             myConfig - a DWORD containing the teaming "code" for me.
 *             theirCofnig - a DWORD containing the teaming "code" received in the heartbeat from them.
 * Returns: BOOLEAN (as ULONG) - TRUE means the configuration is consistent, FALSE indicates that it is not.
 * Author: shouse, 3.29.01
 * Notes:  In order to check to see whether or not this adapter is part of a team,
 *         we need to look into the team member information for this adapter.  This
 *         access should be locked, but for performance reasons, we will only lock
 *         and check for sure if we "think" we're part of a team.  Worst case is that
 *         we are in the process of joining a team and we missed this check - no 
 *         matter, we'll check again on the next heartbeat.
 */
ULONG Load_teaming_consistency_check (IN BOOLEAN bAlreadyKnown, IN PBDA_MEMBER member, IN ULONG myConfig, IN ULONG theirConfig, IN ULONG version) {
    /* We can check without locking to keep the common case minimally expensive.  If we do think
       we're part of a team, then we'll grab the lock and make sure.  If our first indication is 
       that we're not part of a team, then just bail out and if we actually are part of a team, 
       we'll be through here again later to check the consistency. */
    if (!member->active)
        return TRUE;

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* If we are part of a BDA team, check the BDA teaming configuration consistency. */
    if (member->active) {

        NdisReleaseSpinLock(&univ_bda_teaming_lock);

        /* If the heartbeat is an NT4.0 or Win2k heartbeat, then we can't trust the teaming
           ULONG in the heartbeat, which would contain some random garbage.  In this case, 
           we know that we're teaming but the peer does not support it, so we bail out and
           report an error. */
        if (version < CVY_VERSION_FULL) {
            if (!bAlreadyKnown) {
                UNIV_PRINT_CRIT(("Load_teaming_consistency_check: Bad teaming configuration detected: NT4.0/Win2k host in a teaming cluster"));
                TRACE_CRIT("%!FUNC! Bad teaming configuration detected: NT4.0/Win2k host in a teaming cluster");
            }
            
            return FALSE;
        }

        /* If the bi-directional affinity teaming configurations don't match, do something about it. */
        if (myConfig != theirConfig) {
            if (!bAlreadyKnown) {
                UNIV_PRINT_CRIT(("Load_teaming_consistency_check: Bad teaming configuration detected: Mine=0x%08x, Theirs=0x%08x", myConfig, theirConfig));
                TRACE_CRIT("%!FUNC! Bad teaming configuration detected: Mine=0x%08x, Theirs=0x%08x", myConfig, theirConfig);
                
                /* Report whether or not the teaming active flags are consistent. */
                if ((myConfig & CVY_BDA_TEAMING_CODE_ACTIVE_MASK) != (theirConfig & CVY_BDA_TEAMING_CODE_ACTIVE_MASK)) {
                    UNIV_PRINT_VERB(("Load_teaming_consistency_check: Teaming active flags do not match: Mine=%d, Theirs=%d", 
                                (myConfig & CVY_BDA_TEAMING_CODE_ACTIVE_MASK) >> CVY_BDA_TEAMING_CODE_ACTIVE_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_ACTIVE_MASK) >> CVY_BDA_TEAMING_CODE_ACTIVE_OFFSET));
                    TRACE_VERB("%!FUNC! Teaming active flags do not match: Mine=%d, Theirs=%d", 
                                (myConfig & CVY_BDA_TEAMING_CODE_ACTIVE_MASK) >> CVY_BDA_TEAMING_CODE_ACTIVE_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_ACTIVE_MASK) >> CVY_BDA_TEAMING_CODE_ACTIVE_OFFSET);
                }
                
                /* Report whether or not the master flags are consistent. */
                if ((myConfig & CVY_BDA_TEAMING_CODE_MASTER_MASK) != (theirConfig & CVY_BDA_TEAMING_CODE_MASTER_MASK)) {
                    UNIV_PRINT_VERB(("Load_teaming_consistency_check: Master/slave settings do not match: Mine=%d, Theirs=%d",
                                (myConfig & CVY_BDA_TEAMING_CODE_MASTER_MASK) >> CVY_BDA_TEAMING_CODE_MASTER_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_MASTER_MASK) >> CVY_BDA_TEAMING_CODE_MASTER_OFFSET));
                    TRACE_VERB("%!FUNC! Master/slave settings do not match: Mine=%d, Theirs=%d",
                                (myConfig & CVY_BDA_TEAMING_CODE_MASTER_MASK) >> CVY_BDA_TEAMING_CODE_MASTER_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_MASTER_MASK) >> CVY_BDA_TEAMING_CODE_MASTER_OFFSET);
                }
                
                /* Report whether or not the reverse hashing flags are consistent. */
                if ((myConfig & CVY_BDA_TEAMING_CODE_HASHING_MASK) != (theirConfig & CVY_BDA_TEAMING_CODE_HASHING_MASK)) {
                    UNIV_PRINT_VERB(("Load_teaming_consistency_check: Reverse hashing flags do not match: Mine=%d, Theirs=%d",
                                (myConfig & CVY_BDA_TEAMING_CODE_HASHING_MASK) >> CVY_BDA_TEAMING_CODE_HASHING_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_HASHING_MASK) >> CVY_BDA_TEAMING_CODE_HASHING_OFFSET));
                    TRACE_VERB("%!FUNC! Reverse hashing flags do not match: Mine=%d, Theirs=%d",
                                (myConfig & CVY_BDA_TEAMING_CODE_HASHING_MASK) >> CVY_BDA_TEAMING_CODE_HASHING_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_HASHING_MASK) >> CVY_BDA_TEAMING_CODE_HASHING_OFFSET);
                }
                
                /* Report whether or not the number of team members is consistent. */
                if ((myConfig & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK) != (theirConfig & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK)) {
                    UNIV_PRINT_VERB(("Load_teaming_consistency_check: Numbers of team members do not match: Mine=%d, Theirs=%d",
                                (myConfig & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_NUM_MEMBERS_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_NUM_MEMBERS_OFFSET));
                    TRACE_VERB("%!FUNC! Numbers of team members do not match: Mine=%d, Theirs=%d",
                                (myConfig & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_NUM_MEMBERS_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_NUM_MEMBERS_OFFSET);
                }
                
                /* Report whether or not the team membership lists are consistent. */
                if ((myConfig & CVY_BDA_TEAMING_CODE_MEMBERS_MASK) != (theirConfig & CVY_BDA_TEAMING_CODE_MEMBERS_MASK)) {
                    UNIV_PRINT_VERB(("Load_teaming_consistency_check: Participating members lists do not match: Mine=0x%04x, Theirs=0x%04x",
                                (myConfig & CVY_BDA_TEAMING_CODE_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_MEMBERS_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_MEMBERS_OFFSET));
                    TRACE_VERB("%!FUNC! Participating members lists do not match: Mine=0x%04x, Theirs=0x%04x",
                                (myConfig & CVY_BDA_TEAMING_CODE_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_MEMBERS_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_MEMBERS_OFFSET);
                }
            }
            
            return FALSE;
        }

        return TRUE;
    }

    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    return TRUE;
}

/*
 * Function: Load_teaming_code_create
 * Description: This function pieces together the ULONG code that represents the configuration 
 *              of bi-directional affinity teaming on this adapter.  If the adapter is not part
 *              of a team, then the code is zero.
 * Parameters: code - a pointer to a ULONG that will receive the 32-bit code word.
 *             member - a pointer to the team member structure for this adapter.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes:  In order to check to see whether or not this adapter is part of a team,
 *         we need to look into the team member information for this adapter.  This
 *         access should be locked, but for performance reasons, we will only lock
 *         and check for sure if we "think" we're part of a team.  Worst case is that
 *         we are in the process of joining a team and we missed this check - no 
 *         matter, we'll be through here the next time er send a heartbeat anyway.
 */
VOID Load_teaming_code_create (OUT PULONG code, IN PBDA_MEMBER member) {

    /* Assert that the code actually points to something. */
    UNIV_ASSERT(code);

    /* Assert that the membership information actually points to something. */
    UNIV_ASSERT(member);

    /* Reset the code. */
    *code = 0;

    /* We can check without locking to keep the common case minimally expensive.  If we do think
       we're part of a team, then we'll grab the lock and make sure.  If our first indication is 
       that we're not part of a team, then just bail out and if we actually are part of a team, 
       we'll be through here again later to generate the code next time we send a heartbeat. */
    if (!member->active)
        return;

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* If we are in a team, fill in the team configuration information. */
    if (member->active) {
        /* Assert that the team actually points to something. */
        UNIV_ASSERT(member->bda_team);

        /* Add configuration information for teaming at each timeout. */
        CVY_BDA_TEAMING_CODE_CREATE(*code,
                                    member->active,
                                    member->master,
                                    member->reverse_hash,
                                    member->bda_team->membership_count,
                                    member->bda_team->membership_fingerprint);
    }
    
    NdisReleaseSpinLock(&univ_bda_teaming_lock);
}

/*
 * Function: Load_add_reference
 * Description: This function adds a reference to the load module of a given adapter.
 * Parameters: pLoad - a pointer to the load module to reference.
 * Returns: ULONG - The incremented value.
 * Author: shouse, 3.29.01
 * Notes: 
 */
ULONG Load_add_reference (IN PLOAD_CTXT pLoad) {

    /* Assert that the load pointer actually points to something. */
    UNIV_ASSERT(pLoad);

    /* Increment the reference count. */
    return NdisInterlockedIncrement(&pLoad->ref_count);
}

/*
 * Function: Load_release_reference
 * Description: This function releases a reference on the load module of a given adapter.
 * Parameters: pLoad - a pointer to the load module to dereference.
 * Returns: ULONG - The decremented value.
 * Author: shouse, 3.29.01
 * Notes: 
 */
ULONG Load_release_reference (IN PLOAD_CTXT pLoad) {

    /* Assert that the load pointer actually points to something. */
    UNIV_ASSERT(pLoad);

    /* Decrement the reference count. */
    return NdisInterlockedDecrement(&pLoad->ref_count);
}

/*
 * Function: Load_get_reference_count
 * Description: This function returns the current load module reference count on a given adapter.
 * Parameters: pLoad - a pointer to the load module to check.
 * Returns: ULONG - The current reference count.
 * Author: shouse, 3.29.01
 * Notes: 
 */
ULONG Load_get_reference_count (IN PLOAD_CTXT pLoad) {

    /* Assert that the load pointer actually points to something. */
    UNIV_ASSERT(pLoad);

    /* Return the reference count. */
    return pLoad->ref_count;
}

/* Hash routine is based on a public-domain Tiny Encryption Algorithm (TEA) by
   David Wheeler and Roger Needham at the Computer Laboratory of Cambridge
   University. For reference, please consult
   http://vader.brad.ac.uk/tea/tea.shtml */

ULONG Map (
    ULONG               v1,
    ULONG               v2)         /* v2.06: removed range parameter */
{
    ULONG               y = v1,
                        z = v2,
                        sum = 0;

    const ULONG a = 0x67; //key [0];
    const ULONG b = 0xdf; //key [1];
    const ULONG c = 0x40; //key [2];
    const ULONG d = 0xd3; //key [3];

    const ULONG delta = 0x9E3779B9;

    //
    // Unroll the loop to improve performance
    //
    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    return y ^ z;
} /* end Map */

/*
 * Function: Load_simple_hash
 * Description: This function is a simple hash based on the IP 4-tuple used to locate 
 *              state for the connection.  That is, this hash is used to determine the
 *              queue index in which this connection should store, and can later find, 
 *              its state.
 * Parameters: svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 * Returns: ULONG - the result of the hash.
 * Author: shouse, 4.15.02
 * Notes: 
 */
ULONG Load_simple_hash (
    ULONG svr_ipaddr,
    ULONG svr_port,
    ULONG client_ipaddr,
    ULONG client_port)
{
    return (ULONG)(svr_ipaddr + client_ipaddr + (svr_port << 16) + (client_port << 0));
}

/*
 * Function: Load_complex_hash
 * Description: This is the conventional NLB hashing algorithm, which ends up invoking a 
 *              light-weight encryption algorithm to calculate a hash that is ultimately
 *              used to map this connection to a bin, or "bucket".  If reverse hashing
 *              is set, then server side parameters are used instead of client side.  If
 *              limiting is set, then client and server side paramters should NOT be mixed
 *              when hashing; i.e. use ONLY server OR client, depending on reverse hashing.
 * Parameters: svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             affinity - the client affinity (None, Single or Class C)
 *             reverse_hash - whether or not to reverse client and server during hashing
 *             limit_map_fn - whether or not to include server-side parameters in hashing
 * Returns: ULONG - the result of the hash.
 * Author: shouse, 4.15.02
 * Notes: 
 */
ULONG Load_complex_hash (
    ULONG svr_ipaddr,
    ULONG svr_port,
    ULONG client_ipaddr,
    ULONG client_port,
    ULONG affinity,
    ULONG reverse_hash,
    ULONG limit_map_fn)
{
    /* If we're not reverse-hashing, this is our conventional hash using primarily
       the client information.  If the map limit flag is set, then we are sure NOT
       to use ANY server-side information in the hash.  This is most common in BDA. */
    if (!reverse_hash)
    {
        if (!limit_map_fn) 
        {
            if (affinity == CVY_AFFINITY_NONE)
                return Map(client_ipaddr, ((svr_port << 16) + client_port));
            else if (affinity == CVY_AFFINITY_SINGLE)
                return Map(client_ipaddr, svr_ipaddr);
            else
                return Map(client_ipaddr & TCPIP_CLASSC_MASK, svr_ipaddr);
        } 
        else 
        {
            if (affinity == CVY_AFFINITY_NONE)
                return Map(client_ipaddr, client_port);
            else if (affinity == CVY_AFFINITY_SINGLE)
                return Map(client_ipaddr, MAP_FN_PARAMETER);
            else
                return Map(client_ipaddr & TCPIP_CLASSC_MASK, MAP_FN_PARAMETER);
        }
    }
    /* Otherwise, reverse the client and server information as we hash.  Again, if 
       the map limit flag is set, use NO client-side information in the hash. */
    else
    {
        if (!limit_map_fn) 
        {
            if (affinity == CVY_AFFINITY_NONE)
                return Map(svr_ipaddr, ((client_port << 16) + svr_port));
            else if (affinity == CVY_AFFINITY_SINGLE)
                return Map(svr_ipaddr, client_ipaddr);
            else
                return Map(svr_ipaddr & TCPIP_CLASSC_MASK, client_ipaddr);
        } 
        else 
        {
            if (affinity == CVY_AFFINITY_NONE)
                return Map(svr_ipaddr, svr_port);
            else if (affinity == CVY_AFFINITY_SINGLE)
                return Map(svr_ipaddr, MAP_FN_PARAMETER);
            else
                return Map(svr_ipaddr & TCPIP_CLASSC_MASK, MAP_FN_PARAMETER);
        }
    }
}

BOOLEAN Bin_targ_map_get(
    PLOAD_CTXT      lp,
    PBIN_STATE      binp,           /* ptr. to bin state */
    ULONG           my_host_id,
    PMAP_T          pmap)           /* ptr. to target map */
/*
  Get target map for this host

  returns BOOLEAN:
    TRUE    => valid target map is returned via pmap
    FALSE   => error occurred; no target map returned
*/
{
    ULONG       remsz,          /* remainder size */
                loadsz,         /* size of a load partition */
                first_bit;      /* first bit position of load partition */
    MAP_T       targ_map;       /* bit map of load bins for this host */
    ULONG       tot_load = 0;   /* total of load perecentages */
    ULONG *     pload_list;     /* ptr. to list of load balance perecntages */
    WCHAR       num [20];
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);


    pload_list = binp->load_amt;

    if (binp->mode == CVY_SINGLE)
    {
        ULONG       max_pri;        /* highest priority */
        ULONG       i;

        first_bit  = 0;

        /* compute max priority */

        max_pri = CVY_MAX_HOSTS + 1;

        for (i=0; i<CVY_MAX_HOSTS; i++)
        {
            tot_load += pload_list[i];      /* v2.1 */

            if (pload_list[i] != 0) 
            {
                //
                // If another host has the same priority as this host, do not converge
                //
                if (i!= my_host_id && pload_list[i] == pload_list[my_host_id])
                {
                    if (!(lp->dup_sspri))
                    {
                        UNIV_PRINT_CRIT(("Bin_targ_map_get: Host %d: Duplicate single svr priorities detected", my_host_id));
                        TRACE_CRIT("%!FUNC! Host %d: Duplicate single svr priorities detected", my_host_id);
                        Univ_ulong_to_str (pload_list[my_host_id], num, 10);
                        LOG_MSG(MSG_ERROR_SINGLE_DUP, num);

                        lp->dup_sspri = TRUE;
                    }

                    /* 1.03: return error, which inhibits convergence; note that
                       rule will be automatically reinstated when duplicate server
                       priorities are eliminated */

                    return FALSE;
                }

                if ( pload_list[i] <= max_pri )
                {
                    max_pri = pload_list[i];
                }
            }
        }

        binp->tot_load = tot_load;      /* v2.1 */

        /* now determine if we are the highest priority host */

        if (pload_list[my_host_id] == max_pri)
        {
            loadsz   = CVY_MAXBINS;
            targ_map = BIN_ALL_ONES;    /* v2.05 */
        }
        else
        {
            loadsz   = 0;
            targ_map = 0;               /* v2.05 */
        }
    }

    else    /* load balanced */
    {
        ULONG       i, j;
        ULONG       partsz[CVY_MAX_HOSTS+1];
                                    /* new partition size per host */
        ULONG       cur_partsz[CVY_MAX_HOSTS+1];
                                    /* current partition size per host (v2.05) */
        ULONG       cur_host[CVY_MAXBINS];
                                    /* current host for each bin (v2.05) */
        ULONG       tot_partsz;     /* sum of partition sizes */
        ULONG       donor;          /* current donor host  (v2.05) */
        ULONG       cur_nbins;      /* current # bins (v2.05) */

        /* setup current partition sizes and bin to host mapping from current map (v2.05) */

        cur_nbins = 0;

        for (j=0; j<CVY_MAXBINS; j++)
            cur_host[j] = CVY_MAX_HOSTS;    /* all bins are initially orphans */

        for (i=0; i<CVY_MAX_HOSTS; i++)
        {
            ULONG   count = 0L;
            MAP_T   cmap  = binp->cur_map[i];

            tot_load += pload_list[i];  /* folded into this loop v2.1 */

            for (j=0; j<CVY_MAXBINS && cmap != ((MAP_T)0); j++)
            {
                /* if host i has bin j and it's not a duplicate, set up the mapping */

                if ((cmap & ((MAP_T)0x1)) != ((MAP_T)0) && cur_host[j] == CVY_MAX_HOSTS)
                {
                    count++;
                    cur_host[j] = i;
                }
                cmap >>= 1;
            }

            cur_partsz[i]  = count;
            cur_nbins     += count;
        }

        if (cur_nbins > CVY_MAXBINS)
        {
            UNIV_PRINT_CRIT(("Bin_targ_map_get: Error - too many bins found"));
            TRACE_CRIT("%!FUNC! Error - too many bins found");
            LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);

            cur_nbins = CVY_MAXBINS;
        }

        /* if there are orphan bins, give them to pseudo-host CVY_MAX_HOSTS for now (v2.05) */

        if (cur_nbins < CVY_MAXBINS)
            cur_partsz[CVY_MAX_HOSTS] = CVY_MAXBINS - cur_nbins;
        else
            cur_partsz[CVY_MAX_HOSTS] = 0;

        /* compute total load */

        binp->tot_load = tot_load;      /* v2.06 */

        /* now compute tentative partition sizes and remainder after initially
           dividing up partitions among hosts */

        tot_partsz = 0;
        first_bit  = 0;

        for (i=0; i<CVY_MAX_HOSTS; i++)
        {
            if (tot_load > 0)
                partsz[i] = CVY_MAXBINS * pload_list[i] / tot_load;
            else
                partsz[i] = 0;

            tot_partsz += partsz[i];
        }

        remsz = CVY_MAXBINS - tot_partsz;

        /* check for zero total load */

        if (tot_partsz == 0)
        {
            * pmap = 0;
            return TRUE;
        }

        /* first dole out remainder bits to hosts that currently have bins (this
           minimizes the number of bins that have to move) v2.05 */

        if (remsz > 0)
        {
            for (i=0; i<CVY_MAX_HOSTS && remsz > 0; i++)
                if (cur_partsz[i] > 0 && pload_list[i] > 0)
                {
                    partsz[i]++;
                    remsz--;
                }
        }

        /* now dole out remainder bits to hosts that currently have no bins (to maintain
           the target load balance) v2.05 */

        if (remsz > 0)
        {
            for (i=0; i<CVY_MAX_HOSTS && remsz > 0; i++)
                if (cur_partsz[i] == 0 && pload_list[i] > 0)
                {
                    partsz[i]++;
                    remsz--;
                }
        }

        /* We MUST be out of bins by now. */
        UNIV_ASSERT(remsz == 0);
        
        if (remsz != 0)
        {
            UNIV_PRINT_CRIT(("Bin_targ_map_get: Bins left over (%u) after handing out to all hosts with and without bins!", remsz));
            TRACE_CRIT("%!FUNC! Bins left over (%u) after handing out to all hosts with and without bins!", remsz);
        }

        /* reallocate bins to target hosts to match new partition sizes (v2.05) */

        donor = 0;
        partsz[CVY_MAX_HOSTS] = 0;      /* pseudo-host needs no bins */

        for (i=0; i<CVY_MAX_HOSTS; i++)
        {
            ULONG       rcvrsz;         /* current receiver's target partition */
            ULONG       donorsz;        /* current donor's target partition size */

            /* find and give this host some bins */

            rcvrsz = partsz[i];

            while (rcvrsz > cur_partsz[i])
            {
                /* find a host with too many bins */

                for (; donor < CVY_MAX_HOSTS; donor++)
                    if (partsz[donor] < cur_partsz[donor])
                        break;

                /* if donor is pseudo-host and it's out of bins, give it more bins
                   to keep algorithm from looping; this should never happen */

                if (donor >= CVY_MAX_HOSTS && cur_partsz[donor] == 0)
                {
                    UNIV_PRINT_CRIT(("Bin_targ_map_get: Error - no donor bins"));
                    TRACE_CRIT("%!FUNC! Error - no donor bins");
                    LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);
                    cur_partsz[donor] = CVY_MAXBINS;
                }

                /* now find the donor's bins and give them to the target host */

                donorsz = partsz[donor];        /* donor's target bin count */

                for (j=0; j<CVY_MAXBINS; j++)
                {
                    if (cur_host[j] == donor)
                    {
                        cur_host[j] = i;
                        cur_partsz[donor]--;
                        cur_partsz[i]++;

                        /* if this donor has no more to give, go find the next donor;
                           if this receiver needs no more, go on to next receiver */

                        if (donorsz == cur_partsz[donor] || rcvrsz == cur_partsz[i])
                            break;
                    }
                }

                /* if no bin was found, log a fatal error and exit */

                if (j == CVY_MAXBINS)
                {
                    UNIV_PRINT_CRIT(("Bin_targ_map_get: Error - no bin found"));
                    TRACE_CRIT("%!FUNC! Error - no bin found");
                    LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);
                    break;
                }
            }
        }

        /* finally, compute bit mask for this host (v2.05) */

        targ_map = 0;

        for (j=0; j<CVY_MAXBINS; j++)
        {
            if (cur_host[j] == CVY_MAX_HOSTS)
            {
                UNIV_PRINT_CRIT(("Bin_targ_map_get: Error - incomplete mapping"));
                TRACE_CRIT("%!FUNC! Error - incomplete mapping");
                LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);
                cur_host[j] = 0;
            }

            if (cur_host[j] == my_host_id)
                targ_map |= ((MAP_T)1) << j;
        }
    }

    * pmap = targ_map;

    return TRUE;

}  /* end Bin_targ_map_get */


BOOLEAN Bin_map_check(
    ULONG       tot_load,       /* total load percentage (v2.06) */
    PMAP_T      pbin_map)       /* bin map for all hosts */
{
    MAP_T       tot_map,        /* total map for all hosts */
                ovr_map,        /* overlap map between hosts */
                exp_tot_map;    /* expected total map */
    ULONG       i;


    /* compute expected total map (2.04) */

    if (tot_load == 0)              /* v2.06 */
    {
        return TRUE;
    }
    else
    {
        exp_tot_map = BIN_ALL_ONES;
    }

    /* compute total map and overlap map */

    tot_map = ovr_map = 0;

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        ovr_map |= (pbin_map[i] & tot_map);
        tot_map |= pbin_map[i];
    }

    if (tot_map == exp_tot_map && ovr_map == 0)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}  /* end Bin_map_check */


BOOLEAN Bin_map_covering(
    ULONG       tot_load,       /* total load percentage (v2.06) */
    PMAP_T      pbin_map)       /* bin map for all hosts */
{
    MAP_T       tot_map,        /* total map for all hosts */
                exp_tot_map;    /* expected total map */
    ULONG       i;


    /* compute expected total map (v2.04) */

    if (tot_load == 0)              /* v2.06 */
    {
        return TRUE;
    }
    else
    {
        exp_tot_map = BIN_ALL_ONES;
    }

    /* compute total map and overlap map */

    tot_map = 0;

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        tot_map |= pbin_map[i];
    }

    if (tot_map == exp_tot_map)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}  /* end Bin_map_covering */


void Bin_state_init(
    PLOAD_CTXT      lp,
    PBIN_STATE      binp,           /* ptr. to bin state */
    ULONG           index,          /* index of bin state */
    ULONG           my_host_id,
    ULONG           mode,
    ULONG           prot,
    BOOLEAN         equal_bal,      /* TRUE => balance equally across hosts */
    USHORT          affinity,
    ULONG           load_amt)       /* this host's load percentage if unequal */
/*
  Initialize bin state for a port group
*/
{
    ULONG       i;          /* loop variable */
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);


    if ((equal_bal && mode == CVY_SINGLE) ||
        (mode == CVY_SINGLE && load_amt > CVY_MAX_HOSTS) ||
        index >= CVY_MAXBINS)
    {
        UNIV_ASSERT(FALSE);  // This should never happen
    }

    binp->code       = CVY_BINCODE;  /* (bbain 8/19/99) */
    binp->equal_bal  = equal_bal;
    binp->affinity   = affinity;
    binp->index      = index;
    binp->compatible = TRUE;
    binp->mode       = mode;
    binp->prot       = prot;

    /* initialize target and new load maps */

    binp->targ_map     = 0;
    binp->all_idle_map = BIN_ALL_ONES;
    binp->cmap         = 0;         /* v2.1 */

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        binp->new_map[i]  = 0;
        binp->cur_map[i]  = 0;
        binp->chk_map[i]  = 0;
        binp->idle_map[i] = BIN_ALL_ONES;
    }

    /* initialize load percentages for all hosts */

    if (equal_bal)
    {
        load_amt = CVY_EQUAL_LOAD;
    }

    binp->tot_load = load_amt;

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        if (i == my_host_id)
        {
            binp->orig_load_amt =
            binp->load_amt[i]   = load_amt;
        }
        else
            binp->load_amt[i] = 0;
    }

    /* initialize requesting state to no requests active and all bins local or none */

    binp->snd_bins  = 0;
    binp->rcv_bins  = 0;
    binp->rdy_bins  = 0;
    binp->idle_bins = BIN_ALL_ONES;     /* we are initially idle */

    /* perform first initialization only once (v2.06) */

    if (!(binp->initialized))
    {
        binp->tconn = 0;

        for (i=0; i<CVY_MAXBINS; i++)
        {
            binp->nconn[i] = 0;
        }

        Queue_init(&(binp->connq));
        binp->initialized = TRUE;
    }

    /* Initialize the performance counters. */
    binp->packets_accepted = 0;
    binp->packets_dropped  = 0;
    binp->bytes_accepted   = 0;
    binp->bytes_dropped    = 0;

}  /* end Bin_state_init */


BOOLEAN Bin_converge(
    PLOAD_CTXT      lp,
    PBIN_STATE      binp,           /* ptr. to bin state */
    ULONG           my_host_id)
/*
   Explicitly attempt to converge new port group state

  returns BOOL:
    TRUE  => all hosts have consistent new state for converging
    FALSE => parameter error or inconsistent convergence state
*/
{
    MAP_T           orphan_map;     /* map of orphans that this host will now own */
    ULONG           i;
    BOOLEAN         fCheckMap = FALSE;


    /* determine new target load map; 1.03: return in error if no map generated */

    if (!Bin_targ_map_get(lp, binp, my_host_id, &(binp->targ_map)))
    {
        return FALSE;
    }

    /* compute map of all currently orphan bins; note that all duplicates are
       considered to be orphans */

    orphan_map = 0;
    for (i=0; i<CVY_MAX_HOSTS; i++)
        orphan_map |= binp->cur_map[i];

    orphan_map = ~orphan_map;

    /* update our new map to include all current bins and orphans that are in the
       target set */

    binp->new_map[my_host_id] = binp->cmap |                        /* v2.1 */
                                (binp->targ_map & orphan_map);      /* 1.03 */

    /* check that new load maps are consistent and covering */

    fCheckMap = Bin_map_check(binp->tot_load, binp->new_map);   /* v2.06 */
    return fCheckMap;

}  /* end Bin_converge */


void Bin_converge_commit(
    PLOAD_CTXT      lp,
    PBIN_STATE      binp,           /* ptr. to bin state */
    ULONG           my_host_id)
/*
  Commit to new port group state
*/
{
    ULONG       i;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);
    MAP_T       old_cmap = binp->cmap;

    /* check that new load maps are consistent and covering */

    if (!(Bin_map_check(binp->tot_load, binp->new_map)))    /* v2.06 */
    {
        if (!(lp->bad_map))
        {
            UNIV_PRINT_CRIT(("Bin_converge_commit: Bad new map"));
            TRACE_CRIT("%!FUNC! Bad new map");
            LOG_MSG1(MSG_ERROR_INTERNAL, MSG_NONE, (ULONG_PTR)binp->new_map);

            lp->bad_map = TRUE;
        }
    }

    /* commit to new current maps */

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        binp->chk_map[i] =
        binp->cur_map[i] = binp->new_map[i];
    }

    /* setup new send/rcv bins, and new ready to ship bins; note that ready to
       ship bins are cleared from the current map */

    binp->rdy_bins  = binp->cur_map[my_host_id]  & ~(binp->targ_map);       /* 1.03 */

    binp->cur_map[my_host_id] &= ~(binp->rdy_bins);

    binp->rcv_bins = binp->targ_map & ~(binp->cur_map[my_host_id]);

    binp->cmap     = binp->cur_map[my_host_id];                             /* v2.1 */

    /* If the port rule map has changed, reset the performance counters. */
    if (binp->cmap != old_cmap) {
        binp->packets_accepted = 0;
        binp->packets_dropped  = 0;
        binp->bytes_accepted   = 0;
        binp->bytes_dropped    = 0;
    }
    
#if 0
    /* simulation output generator (2.05) */
    {
        ULONG lcount = 0L;
        ULONG ncount = 0L;
        MAP_T bins  = binp->rdy_bins;

        for (i=0; i<CVY_MAXBINS && bins != 0; i++, bins >>= 1)
            if ((bins & ((MAP_T)0x1)) != ((MAP_T)0))
                lcount++;

        bins = binp->targ_map;

        for (i=0; i<CVY_MAXBINS && bins != 0; i++, bins >>= 1)
            if ((bins & ((MAP_T)0x1)) != ((MAP_T)0))
                ncount++;

        UNIV_PRINT_VERB(("Converge at host %d pg %d: losing %d, will have %d bins\n", my_host_id, binp->index, lcount, ncount));
    }
#endif

}  /* end Bin_converge_commit */


BOOLEAN Bin_host_update(
    PLOAD_CTXT      lp,
    PBIN_STATE      binp,           /* ptr. to bin state */
    ULONG           my_host_id,     /* my host's id MINUS one */
    BOOLEAN         converging,     /* TRUE => we are converging now */
    BOOLEAN         rem_converging, /* TRUE => remote host is converging */
    ULONG           rem_host,       /* remote host's id MINUS one */
    MAP_T           cur_map,        /* remote host's current map or 0 if host died */
    MAP_T           new_map,        /* remote host's new map if converging */
    MAP_T           idle_map,       /* remote host's idle map */
    MAP_T           rdy_bins,       /* bins that host is ready to send; ignored
                                       if converging to prevent bin transfers */
    ULONG           pkt_count,      /* remote host's packet count */
    ULONG           load_amt)       /* remote host's load percentage */
/*
  Update hosts's state for a port group

  returns BOOL:
    TRUE  => if not converging, normal return
             otherwise, all hosts have consistent state for converging
    FALSE => parameter error or inconsistent convergence state

  function:
    Updates hosts's state for a port group and attempts to converge new states if
    in convergence mode.  Called when a ping message is received or when a host
    is considered to have died.  Handles case of newly discovered hosts.  Can be
    called multiple times with the same information.
*/
{
    ULONG       i;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);


    if (rem_host >= CVY_MAX_HOSTS || rem_host == my_host_id)
    {
        UNIV_PRINT_CRIT(("Bin_host_update: Parameter error"));
        TRACE_CRIT("%!FUNC! Parameter error");
        LOG_MSG2(MSG_ERROR_INTERNAL, MSG_NONE, rem_host+1, my_host_id+1);
        return FALSE;
    }

	UNIV_ASSERT(binp->code == CVY_BINCODE);	/* (bbain 8/19/99) */

    /* change load percentage if load changed */

    if (load_amt != binp->load_amt[rem_host])
    {
        binp->load_amt[rem_host] = load_amt;
    }


    /* check for non-overlapping maps */

    if ((binp->cmap & cur_map) != 0)        /* v2.1 */
    {
        /* if we have received fewer packets than the other host or have a higher host id,
           remove duplicates from current map; this uses a heuristic that a newly joining
           host that was subnetted probably did not receive packets; we are trying to avoid
           having two hosts answer to the same client while minimizing disruption of service
           (v1.32B) */

        if (lp->send_msg.pkt_count < pkt_count ||
            (lp->send_msg.pkt_count == pkt_count && rem_host < my_host_id))
        {
            MAP_T   dup_map;

            dup_map = binp->cmap & cur_map;     /* v2.1 */

            binp->cur_map[my_host_id] &= ~dup_map;
            binp->cmap                 = binp->cur_map[my_host_id];     /* v2.1 */
            
            /* If there has been a collision, reset the performance counters. */
            binp->packets_accepted = 0;
            binp->packets_dropped  = 0;
            binp->bytes_accepted   = 0;
            binp->bytes_dropped    = 0;

            Load_conn_kill(lp, binp);
        }

        if (!converging && !rem_converging)
        {
            if (!(lp->overlap_maps))
            {
                UNIV_PRINT_CRIT(("Bin_host_update: Host %d: Two hosts with overlapping maps detected %d.", my_host_id, binp->index));
                TRACE_CRIT("%!FUNC! Host %d: Two hosts with overlapping maps detected %d.", my_host_id, binp->index);
                LOG_MSG2(MSG_WARN_OVERLAP, MSG_NONE, my_host_id+1, binp->index);

                lp->overlap_maps = TRUE;
            }

            /* force convergence if in normal operations */
            return FALSE;
        }
    }

    /* now update remote host's current map */

    binp->cur_map[rem_host] = cur_map;

    /* update idle map and calculate new global idle map if it's changed */

    if (binp->idle_map[rem_host] != idle_map)
    {
        MAP_T   saved_map    = binp->all_idle_map;
        MAP_T   new_idle_map = BIN_ALL_ONES;
        MAP_T   tmp_map;

        binp->idle_map[rem_host] = idle_map;

        /* compute new idle map for all other hosts */

        for (i=0; i<CVY_MAX_HOSTS; i++)
            if (i != my_host_id)
                new_idle_map &= binp->idle_map[i];

        binp->all_idle_map = new_idle_map;

        /* see which locally owned bins have gone idle in all other hosts */

        tmp_map = new_idle_map & (~saved_map) & binp->cmap;     /* v2.1 */

        if (tmp_map != 0)
        {
            UNIV_PRINT_VERB(("Bin_host_update: Host %d pg %d: detected new all idle %08x for local bins",
                         my_host_id, binp->index, tmp_map));
            TRACE_VERB("%!FUNC! Host %d pg %d: detected new all idle 0x%08x for local bins",
                         my_host_id, binp->index, (ULONG)tmp_map);
        }

        tmp_map = saved_map & (~new_idle_map) & binp->cmap;     /* v2.1 */

        if (tmp_map != 0)
        {
            UNIV_PRINT_VERB(("Bin_host_update: Host %d pg %d: detected new non-idle %08x for local bins",
                         my_host_id, binp->index, tmp_map));
            TRACE_VERB("%!FUNC! Host %d pg %d: detected new non-idle 0x%08x for local bins",
                         my_host_id, binp->index, (ULONG)tmp_map);
        }
    }
    /* 1.03: eliminated else clause */

    /* if we are not converging AND other host not converging, exchange bins;
       convergence must now be complete for both hosts */

    if (!converging)
    {
        if (!rem_converging) {      /* 1.03: reorganized code to exchange bins only when both
                                       hosts are not converging to avoid using stale bins */

            MAP_T       new_bins;           /* incoming bins from the remote host */
            MAP_T       old_cmap = binp->cmap;

            /* check to see if remote host has received some bins from us */

            binp->rdy_bins &= (~cur_map);

            /* check to see if we can receive some bins */

            new_bins = binp->rcv_bins & rdy_bins;

            if (new_bins != 0)
            {
                if ((binp->cmap & new_bins) != 0)       /* v2.1 */
                {
                    if (!(lp->err_rcving_bins))
                    {
                        UNIV_PRINT_CRIT(("Bin_host_update: Receiving bins already own"));
                        TRACE_CRIT("%!FUNC! Receiving bins already own");
                        LOG_MSG2(MSG_ERROR_INTERNAL, MSG_NONE, binp->cur_map[my_host_id], new_bins);

                        lp->err_rcving_bins = TRUE;
                    }
                }

                binp->cur_map[my_host_id]  |=  new_bins;
                binp->rcv_bins             &= ~new_bins;

                binp->cmap                  = binp->cur_map[my_host_id];    /* v2.1 */

                /* If the port rule map has changed, reset the performance counters. */
                if (binp->cmap != old_cmap) {
                    binp->packets_accepted = 0;
                    binp->packets_dropped  = 0;
                    binp->bytes_accepted   = 0;
                    binp->bytes_dropped    = 0;
                }

                UNIV_PRINT_VERB(("Bin_host_update: Host %d pg %d: received %08x ; cur now %08x",
                             my_host_id, binp->index, new_bins, binp->cur_map[my_host_id]));
                TRACE_VERB("%!FUNC! host %d pg %d: received 0x%08x ; cur now 0x%08x",
                             my_host_id, binp->index, (ULONG)new_bins, (ULONG)binp->cur_map[my_host_id]);
            }

            /* do consistency check that all bins are covered */

            binp->chk_map[rem_host]   = cur_map | rdy_bins;
            binp->chk_map[my_host_id] = binp->cmap | binp->rdy_bins;        /* v2.1 */

            if (!Bin_map_covering(binp->tot_load, binp->chk_map))   /* v2.06 */
            {
                if (!(lp->err_orphans))
                {
#if 0
                    UNIV_PRINT_CRIT(("Bin_host_update: Host %d: Orphan bins detected", my_host_id));
                    TRACE_CRIT("%!FUNC! Host %d: Orphan bins detected", my_host_id);
                    LOG_MSG1(MSG_ERROR_INTERNAL, MSG_NONE, my_host_id+1);
#endif
                    lp->err_orphans = TRUE;
                }
            }
        }

        return TRUE;
    }

    /* otherwise, store proposed new load map and try to converge current host data */

    else
    {
        BOOLEAN fRet;
        binp->chk_map[rem_host] =
        binp->new_map[rem_host] = new_map;

        fRet = Bin_converge(lp, binp, my_host_id);
        return fRet;
    }

}  /* end Bin_host_update */


void Bin_state_print(
    PBIN_STATE      binp,           /* ptr. to bin state */
    ULONG           my_host_id)
{
#if 0
    ULONG   i;
#endif

    UNIV_PRINT_VERB(("Bin_state_print: Hst %d binp %x: maps: targ %x cur %x new %x; eq %d mode %d amt %d tot %d; bins: snd %x rcv %x rdy %x",
                 my_host_id, binp, binp->targ_map, binp->cur_map[my_host_id], binp->new_map[my_host_id],
                 binp->equal_bal, binp->mode, binp->load_amt[my_host_id],
                 binp->tot_load, binp->snd_bins, binp->rcv_bins, binp->rdy_bins));
    TRACE_VERB("%!FUNC! Hst 0x%x binp 0x%p: maps: targ 0x%x cur 0x%x new 0x%x; eq %d mode %d amt %d tot %d; bins: snd 0x%x rcv 0x%x rdy 0x%x",
                 my_host_id, binp, (ULONG)binp->targ_map, (ULONG)binp->cur_map[my_host_id], (ULONG)binp->new_map[my_host_id],
                 binp->equal_bal, binp->mode, binp->load_amt[my_host_id],
                 binp->tot_load, (ULONG)binp->snd_bins, (ULONG)binp->rcv_bins, (ULONG)binp->rdy_bins);

#if 0
    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        UNIV_PRINT_VERB(("Bin_state_print: Host %d: cur map %x new %x load_amt %d", i+1, binp->cur_map[i],
                     binp->new_map[i], binp->load_amt[i]));
        TRACE_VERB("%!FUNC! Host %d: cur map 0x%x new 0x%x load_amt %d", i+1, binp->cur_map[i],
                     binp->new_map[i], binp->load_amt[i]);
    }

    for (i=0; i<CVY_MAXBINS; i++)
    {
        UNIV_PRINT_VERB(("Bin_state_print: Bin %d: req_host %d bin_state %d nconn %d", i, binp->req_host[i],
                     binp->bin_state[i], binp->nconn[i]));
        TRACE_VERB("%!FUNC! Bin %d: req_host %d bin_state %d nconn %d", i, binp->req_host[i],
                     binp->bin_state[i], binp->nconn[i]);
    }
#endif

}  /* end Bin_state_print */

/*
 * Function: Load_soil_dscr
 * Description: This function marks a given connection dirty and either destroys
 *              it or moves it to the dirty descriptor queue for subsequent cleanup.
 * Parameters: lp - a pointer to the load module.
 *             bp - a pointer to the appropriate port rule.
 *             ep - a pointer to the descriptor to soil.
 * Returns: Nothing.
 * Author: shouse, 7.23.02
 * Notes: 
 */
void Load_soil_dscr (PLOAD_CTXT lp, PBIN_STATE bp, PCONN_ENTRY ep)
{
    /* Mark the connection dirty.  We mark the connection dirty here to 
       ensure that Load_put_dscr does not update the connection counters
       when this descriptor is eventually destroyed. */
    ep->flags |= NLB_CONN_ENTRY_FLAGS_DIRTY;
    
    /* Increment the dirty connection counters.  We do this unconditionally
       because we've already marked the descriptor dirty.  Load_put_dscr 
       will decrement these counters when it sees that the descriptor has
       been marked dirty. */
    lp->dirty_bin[ep->bin]++;
    lp->num_dirty++;
    
    /* Make connection and bin dirty if we don't have a zero timeout period so that they
       will not be handled by TCP/IP anymore; this avoids allowing TCP/IP's now stale
       connection state from handling packets for newer connections should traffic be
       directed to this host in the future.  
       
       Only mark descriptors and bins dirty, how-
       ever, if the descriptor is NOT on the timeout queue. */
    if (!ep->timeout)
    {
        switch (ep->protocol)
        {
        case TCPIP_PROTOCOL_TCP:
        case TCPIP_PROTOCOL_PPTP:
        case TCPIP_PROTOCOL_GRE:
            
#if defined (NLB_TCP_NOTIFICATION)
            /* If TCP notifications are turned on, we will mark these descriptors dirty
               and remove them when TCP notifies us that it has removed the state for 
               the TCP connection.  GRE descriptors always correspond to a PPTP/TCP 
               tunnel and are cleaned up when their "parent" descriptor is cleaned up. */
            if (NLB_NOTIFICATIONS_ON() || (lp->cln_timeout > 0))
#else
            /* If there is a non-zero cleanup timeout, place these descriptors on the
               dirty queue and clean them up when the timeout expires. */
            if (lp->cln_timeout > 0)
#endif
            {
                /* Unlink the descriptor from the bin queue and link it to the dirty queue. */
                Link_unlink(&(ep->blink));
                Queue_enq(&(lp->conn_dirtyq), &(ep->blink));
                
                /* Note that a cleanup is now pending. */
                lp->cln_waiting = TRUE;
            }
            
            /* Otherwise, clean the descriptors up now. */
            else
            {
                /* Clear the descriptor. */
                CVY_CONN_CLEAR(ep); 
                
                /* Release the descriptor. */
                Load_put_dscr(lp, bp, ep);
            }
            
            break;
        case TCPIP_PROTOCOL_IPSEC1:
        case TCPIP_PROTOCOL_IPSEC_UDP:
                
            /* Unlink the descriptor from the bin queue and link it to the dirty queue. */
            Link_unlink(&(ep->blink));
            Queue_enq(&(lp->conn_dirtyq), &(ep->blink));
            
            /* Note that a cleanup is now pending. */
            lp->cln_waiting = TRUE;
            
            break;
        default:
            
            /* Clear the descriptor. */
            CVY_CONN_CLEAR(ep); 
            
            /* Release the descriptor. */
            Load_put_dscr(lp, bp, ep);
            
            break;
        }
    }

    /* Otherwise, if the descriptor is already timing-out (timeout != 0), TCP/IP should 
       not have any stale state for this connection, as it has already terminated, so 
       just destroy the descriptor now. */
    else
    {
        /* Clear the descriptor. */
        CVY_CONN_CLEAR(ep); 
        
        /* Release the descriptor. */
        Load_put_dscr(lp, bp, ep);
    }
}

void Load_conn_kill(
    PLOAD_CTXT      lp,
    PBIN_STATE      bp)
/*
  Kill all connections in a port group (v1.32B)
*/
{
    PCONN_ENTRY ep;         /* ptr. to connection entry */
    QUEUE *     qp;         /* ptr. to bin's connection queue */
    QUEUE *     dqp;        /* ptr. to dirty queue */
    LONG        count[CVY_MAXBINS];
                            /* count of cleaned up connections per bin for checking */
    ULONG       i;
    BOOLEAN     err_bin;    /* bin id error detected */
    BOOLEAN     err_count;  /* connection count error detected */
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    err_bin = err_count = FALSE;

    qp  = &(bp->connq);
    dqp = &(lp->conn_dirtyq);

    for (i=0; i<CVY_MAXBINS; i++)
        count[i] = 0;

    /* remove connections from bin queue and either make dirty or cleanup  */

    ep = (PCONN_ENTRY)Queue_front(qp);
	
    while (ep != NULL)
    {
        UNIV_ASSERT(ep->code == CVY_ENTRCODE);

        if (ep->bin >= CVY_MAXBINS)
        {
            if (!err_bin)
            {
                UNIV_PRINT_CRIT(("Load_conn_kill: Bad bin id"));
                TRACE_CRIT("%!FUNC! Bad bin id");
                LOG_MSG2(MSG_ERROR_INTERNAL, MSG_NONE, ep->bin, CVY_MAXBINS);

                err_bin = TRUE;
            }
        }
        else
        {
            count[ep->bin]++;
        }

        /* Mark the descriptor dirty and either free it or move it to
           the dirty descriptor queue for subsequent cleanup. */
        Load_soil_dscr(lp, bp, ep);

        ep = (PCONN_ENTRY)Queue_front(qp);
    }

    /* now make bins idle */

    for (i=0; i<CVY_MAXBINS; i++)
    {
        if (bp->nconn[i] != count[i])
        {
            if (!err_count)
            {
                UNIV_PRINT_CRIT(("Load_conn_kill: Bad connection count %d %d bin %d", bp->nconn[i], (LONG)count[i], i));
                TRACE_CRIT("%!FUNC! Bad connection count %d %d bin %d", bp->nconn[i], (LONG)count[i], i);

/* KXF 2.1.1 - removed after tripped up at MSFT a few times */
#if 0
                LOG_MSG2(MSG_ERROR_INTERNAL, MSG_NONE, bp->nconn[i], (LONG)count[i]);
#endif

                err_count = TRUE;
            }
        }

        bp->nconn[i] = 0;
    }

    lp->nconn -= bp->tconn;

    if (lp->nconn < 0)
        lp->nconn = 0;

    bp->tconn = 0;

    bp->idle_bins = BIN_ALL_ONES;

    if (lp->cln_waiting)
    {
        lp->cur_time = 0;
    }
}

void Load_conn_cleanup(
    PLOAD_CTXT      lp)
/*
  Clean up all dirty connections (v1.32B)
*/
{
    PCONN_ENTRY ep;         /* ptr. to connection entry */
    PCONN_ENTRY next;       /* ptr. to next connection entry */
    QUEUE *     dqp;        /* ptr. to dirty queue */
    BOOLEAN     err_bin;    /* bin id error detected */
    ULONG       i;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    err_bin = FALSE;

    dqp = &(lp->conn_dirtyq);

    /* dequeue and clean up all connections on dirty connection queue */

    ep = (PCONN_ENTRY)Queue_front(dqp);

    while (ep != NULL)
    {
        PBIN_STATE bp;

        UNIV_ASSERT(ep->code == CVY_ENTRCODE);

        if (ep->bin >= CVY_MAXBINS)
        {
            if (!err_bin)
            {
                UNIV_PRINT_CRIT(("Load_conn_cleanup: Bad bin id"));
                TRACE_CRIT("%!FUNC! Bad bin id");
                LOG_MSG2(MSG_ERROR_INTERNAL, MSG_NONE, ep->bin, CVY_MAXBINS);

                err_bin = TRUE;
            }
        }

        /* If we're about to clean up this descriprtor, it had better be dirty. */
        UNIV_ASSERT(ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY);

        /* Find the NEXT descriptor in the queue before we possibly destroy this one. */
        next = (PCONN_ENTRY)Queue_next(dqp, &(ep->blink));

        switch (ep->protocol)
        {
        case TCPIP_PROTOCOL_IPSEC1:
        case TCPIP_PROTOCOL_IPSEC_UDP:
            break;
        case TCPIP_PROTOCOL_TCP:
        case TCPIP_PROTOCOL_PPTP:
        case TCPIP_PROTOCOL_GRE:
#if defined (NLB_TCP_NOTIFICATION)
            if (!NLB_NOTIFICATIONS_ON())
            {
#endif
                /* Lookup the port rule, so we can update the port rule info. */
                bp = Load_pg_lookup(lp, ep->svr_ipaddr, ep->svr_port, IS_TCP_PKT(ep->protocol));
                
                /* Clear the descriptor. */
                CVY_CONN_CLEAR(ep);
                
                /* Release the descriptor. */
                Load_put_dscr(lp, bp, ep);
#if defined (NLB_TCP_NOTIFICATION)
            }
#endif
            
            break;
        default:

            /* Lookup the port rule, so we can update the port rule info. */
            bp = Load_pg_lookup(lp, ep->svr_ipaddr, ep->svr_port, IS_TCP_PKT(ep->protocol));
            
            /* Clear the descriptor. */
            CVY_CONN_CLEAR(ep);
            
            /* Release the descriptor. */
            Load_put_dscr(lp, bp, ep);
            
            break;
        }

        /* Set the current descriptor to the next descriptor. */
        ep = next;
    }
}

void Load_stop(
    PLOAD_CTXT      lp)
{
    ULONG       i;
    IRQLEVEL    irql;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);	/* (bbain 8/19/99) */
	
    if (!(lp->active))
    {
        return;
    }

    LOCK_ENTER(&(lp->lock), &irql);

    /* make connections for all rules dirty so they will not be handled */

    for (i=0; i<lp->send_msg.nrules; i++)
    {
        PBIN_STATE  bp;     /* ptr. to bin state */

        bp = &(lp->pg_state[i]);
		UNIV_ASSERT(bp->code == CVY_BINCODE);	/* (bbain 8/21/99) */

        Load_conn_kill(lp, bp);  /* (v1.32B) */

        /* advertise that we are not handling any load in case a ping is sent out */

        lp->send_msg.cur_map[i]  = 0;
        lp->send_msg.new_map[i]  = 0;
        lp->send_msg.idle_map[i] = BIN_ALL_ONES;
        lp->send_msg.rdy_bins[i] = 0;
        lp->send_msg.load_amt[i] = 0;
    }

    lp->send_msg.state     = HST_CVG;       /* force convergence (v2.1) */

    /* go inactive until restarted */

    lp->active = FALSE;
    lp->nconn  = 0;         /* v2.1 */

    LOCK_EXIT(&(lp->lock), irql);

}  /* end Load_stop */


BOOLEAN Load_start(            /* (v1.32B) */
        PLOAD_CTXT      lp)
{
    ULONG       i;
    BOOLEAN     ret;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);
    WCHAR me[20];

    if (!(lp->initialized))
        Load_init(lp, & ctxtp -> params);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);	/* (bbain 8/19/99) */

    if (lp->active)
    {
        return FALSE;
    }

    lp->my_host_id =(* (lp->params)).host_priority - 1;

    lp->ping_map   =
    lp->host_map   = 1 << lp->my_host_id;

    lp->last_hmap  = 0;		/* bbain RTM RC1 6/23/99 */

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        lp->nmissed_pings[i] = 0;
    }

    lp->min_missed_pings = (* (lp->params)).alive_tolerance;
    lp->cln_timeout      = (* (lp->params)).cleanup_delay;
    lp->def_timeout      = (* (lp->params)).alive_period;
    lp->stable_map       = 0;
    lp->consistent       = TRUE;

    /* Intiialize the bad teaming configuration detected flag. */
    lp->bad_team_config  = FALSE;

    /* Host map of legacy (win2k/NT4.0) hosts detected. */
    lp->legacy_hosts     = 0;

    lp->dup_hosts        = FALSE;
    lp->dup_sspri        = FALSE;
    lp->bad_map          = FALSE;
    lp->overlap_maps     = FALSE;
    lp->err_rcving_bins  = FALSE;
    lp->err_orphans      = FALSE;
    lp->bad_num_rules    = FALSE;
    lp->alloc_inhibited  = FALSE;
    lp->alloc_failed     = FALSE;
    lp->bad_defrule      = FALSE;

    lp->scale_client     = (BOOLEAN)(* (lp->params)).scale_client;
    lp->my_stable_ct     = 0;
    lp->all_stable_ct    = 0;
    lp->min_stable_ct    = lp->min_missed_pings;

    lp->dscr_per_alloc   = (* (lp->params)).dscr_per_alloc;
    lp->max_dscr_allocs  = (* (lp->params)).max_dscr_allocs;

    /* Calculate the maximum number of outstanding descriptors (in use) allowed. */
    lp->max_dscr_out     = lp->max_dscr_allocs * lp->dscr_per_alloc;

    lp->tcp_timeout      = (* (lp->params)).tcp_dscr_timeout;
    lp->ipsec_timeout    = (* (lp->params)).ipsec_dscr_timeout;

    lp->pkt_count        = 0;

    /* initialize port group bin states; add a default rule at the end */

    if ((* (lp->params)).num_rules >= (CVY_MAX_RULES - 1))
    {
        UNIV_PRINT_CRIT(("Load_start: Too many rules; using max possible."));
        TRACE_CRIT("%!FUNC! Too many rules; using max possible.");
        lp->send_msg.nrules = (USHORT)CVY_MAX_RULES;
    }
    else
        lp->send_msg.nrules = (USHORT)((* (lp->params)).num_rules) + 1;

    for (i=0; i<lp->send_msg.nrules; i++)
    {
        PBIN_STATE  bp;     /* ptr. to bin state */
        PCVY_RULE   rp;     /* ptr. to rules array */

        bp = &(lp->pg_state[i]);
        rp = &((* (lp->params)).port_rules[i]);

        if (i == (((ULONG)lp->send_msg.nrules) - 1))

            /* initialize bin state for default rule to single server with
                host priority */

            Bin_state_init(lp, bp, i, lp->my_host_id, CVY_SINGLE, CVY_TCP_UDP,
                           FALSE, (USHORT)0, (* (lp->params)).host_priority);

        else if (rp->mode == CVY_SINGLE)
            Bin_state_init(lp, bp, i, lp->my_host_id, rp->mode, rp->protocol,
                           FALSE, (USHORT)0, rp->mode_data.single.priority);
        else if (rp->mode == CVY_MULTI)
            Bin_state_init(lp, bp, i, lp->my_host_id, rp->mode, rp->protocol,
                           (BOOLEAN)(rp->mode_data.multi.equal_load),
                           rp->mode_data.multi.affinity,
                           (rp->mode_data.multi.equal_load ?
                            CVY_EQUAL_LOAD : rp->mode_data.multi.load));

        /* handle CVY_NEVER mode as multi-server. the check for
           those modes is done before attempting to hash to the bin in
           Load_packet_check and Load_conn_advise so bin distribution plays
           no role in the behavior, but simply allows the rule to be valid
           across all of the operational servers */

        else
            Bin_state_init(lp, bp, i, lp->my_host_id, rp->mode, rp->protocol,
                           TRUE, (USHORT)0, CVY_EQUAL_LOAD);

        ret = Bin_converge(lp, bp, lp->my_host_id);
        if (!ret)
        {
            UNIV_PRINT_CRIT(("Load_start: Initial convergence inconsistent"));
            TRACE_CRIT("%!FUNC! Initial convergence inconsistent");
            LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);
        }

        /* export current port group state to send msg */

        if (i == (((ULONG)(lp->send_msg.nrules)) - 1))
            lp->send_msg.rcode[i]= 0;
        else
            lp->send_msg.rcode[i]= rp->code;

        lp->send_msg.cur_map[i]   = bp->cmap;                       /* v2.1 */
        lp->send_msg.new_map[i]   = bp->new_map[lp->my_host_id];
        lp->send_msg.idle_map[i]  = bp->idle_bins;
        lp->send_msg.rdy_bins[i]  = bp->rdy_bins;
        lp->send_msg.load_amt[i]  = bp->load_amt[lp->my_host_id];

        // NOTE:  The following line of code was removed when it was discovered that it 
        // routinely produces a Wake On LAN pattern in the heartbeat that causes BroadCom
        // NICs to panic.  Although this is NOT an NLB issue, but rather a firmware issue
        // in BroadCom NICs, it was decided to remove the information from the heartbeat
        // to alleviate the problem for customers with BroadCom NICs upgrading to .NET.
        // This array is UNUSED by NLB, so there is no harm in not filling it in; it was
        // added a long time ago for debugging purposes as part of the now-defunct FIN-
        // counting fix that was part of Win2k SP1.
        //
        // For future reference, should we need to use this space in the heartbeat at some
        // future point in time, it appears that we will need to be careful to avoid potential
        // WOL patterns in our heartbeats where we can avoid it.  A WOL pattern is:
        //
        // 6 bytes of 0xFF, followed by 16 idential instances of a "MAC address" that can
        // appear ANYWHERE in ANY frame type, including our very own NLB heartbeats.  E.g.:
        //
        // FF FF FF FF FF FF 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06
        // 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06
        // 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06
        // 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06
        // 01 02 03 04 05 06
        //
        // The MAC address need not be valid, however.  In NLB heartbeats, the "MAC address"
        // in the mistaken WOL pattern is "00 00 00 00 00 00".  NLB routinely fills heartbeats
        // with FF and 00 bytes, but it seems that by "luck" no other place in the heartbeat
        // seems this vulnerable.  For instance, in the load_amt array, each entry has a 
        // maximum value of 100 (decimal), so there is no possibility of generating the initial
        // 6 bytes of FF to start the WOL pattern.  All of the "map" arrays seem to be saved
        // by two strokes of fortune; (i) little endian and (ii) the bin distribution algorithm.
        // 
        // (i) Since we don't use the 4 most significant bits of the ULONGLONGs used to store 
        // each map, the most significant bit is NEVER FF.  Because Intel is little endian, the
        // most significant byte appears last.  For example:
        // 
        // 0F FF FF FF FF FF FF FF appears in the packet as FF FF FF FF FF FF 0F
        // 
        // This breaks the FF sequence in many scenarios.
        //
        // (ii) The way the bin distribution algorithm distributes buckets to hosts seems to 
        // discourage other possibilities.  For instance, a current map of:
        // 
        // 00 FF FF FF FF FF FF 00 
        // 
        // just isn't likely.  However, it IS STILL POSSIBLE!  So, it is important to note that:
        // 
        // REMOVING THIS LINE OF CODE DOES NOT, IN ANY WAY, GUARANTEE THAT AN NLB HEARTBEAT
        // CANNOT STILL CONTAIN A VALID WAKE ON LAN PATTERN SOMEWHERE ELSE IN THE FRAME!!!

        // lp->send_msg.pg_rsvd1[i]  = (ULONG)bp->all_idle_map;
    }

    /* initialize send msg */

    lp->send_msg.host_id   = (USHORT)(lp->my_host_id);
    lp->send_msg.master_id = (USHORT)(lp->my_host_id);
    lp->send_msg.hcode     = lp->params->install_date;
    lp->send_msg.pkt_count = lp->pkt_count;         /* 1.32B */

    Univ_ulong_to_str (lp->my_host_id+1, me, 10);

    /* Tracking convergence - Starting convergence because this host is joining the cluster. */
    LOG_MSGS(MSG_INFO_CONVERGING_NEW_MEMBER, me, me);
    TRACE_CONVERGENCE("%!FUNC! Initiating convergence on host %d.  Reason: Host %d is joining the cluster.", lp->my_host_id+1, lp->my_host_id+1);

    /* Tracking convergence - Starting convergence. */
    lp->send_msg.state     = HST_CVG;

    /* Reset the convergence statistics. */
    lp->num_convergences = 1;
    lp->last_convergence = 0;

    /* activate module */

    lp->active      = TRUE;

    return TRUE;
}  /* end Load_start */


void Load_init(
   PLOAD_CTXT       lp,
   PCVY_PARAMS      params)
{
    ULONG       i;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    LOCK_INIT(&(lp->lock));

    if (!(lp->initialized))
    {
        lp->code = CVY_LOADCODE;	/* (bbain 8/19/99) */

        /* initialize hashed connection descriptors and queues */

        for (i=0; i<CVY_MAX_CHASH; i++)
        {
            PCONN_ENTRY     ep;

            ep = &(lp->hashed_conn[i]);

            /* Initialize the descriptor at this hash location. */
            Load_init_dscr(lp, ep, FALSE);

            /* Initialize the connection queue at this hash location. */
            Queue_init(&(lp->connq[i]));
        }

        /* Initialize connection free and dirty queues. */
        Queue_init(&(lp->conn_dirtyq));
        Queue_init(&(lp->conn_rcvryq));

        /* Initialize the queues for timing out connection descriptors. */
        Queue_init(&(lp->tcp_expiredq));
        Queue_init(&(lp->ipsec_expiredq));

        /* Reset the number of dirty connections. */
        lp->num_dirty = 0;

        for (i=0; i<CVY_MAXBINS; i++)
        {
            /* Reset the dirty connection bin counters. */
            lp->dirty_bin[i] = 0;
        }

        lp->cln_waiting      = FALSE;
        lp->def_timeout      =
        lp->cur_timeout      = params -> alive_period;
        lp->nconn            = 0;
        lp->active           = FALSE;
        lp->initialized      = TRUE;

        /* Initially, there are no outstanding connection descriptors. */
        lp->num_dscr_out     = 0;
        lp->max_dscr_out     = 0;

        /* Allocate a fixed-size block pool for connection descriptors. */
        lp->free_dscr_pool   = NdisCreateBlockPool(sizeof(CONN_DESCR), 0, 'dBLN', NULL);

        if (lp->free_dscr_pool == NULL)
        {
            UNIV_PRINT_CRIT(("Load_init: Error creating fixed-size block pool"));
            TRACE_CRIT("%!FUNC! Error creating fixed-size block pool");
        }

        /* Store a pointer to the NLB parameters. */
        lp->params = params;

        /* Initialize the reference count on this load module. */
        lp->ref_count = 0;
        
        /* Reset the internally maintained clock used for connection descriptor timeout. */
        lp->clock_sec = 0;
        lp->clock_msec = 0;
    }
    else
    {
        UNIV_ASSERT(lp->code == CVY_LOADCODE);
    }

    /* Don't start module. */

}  /* end Load_init */

/* DO NOT CALL THIS FUNCTION WITH THE LOAD LOCK HELD! */
void Load_cleanup(
    PLOAD_CTXT      lp)
{
    ULONG       i;
    PCONN_ENTRY ep = NULL;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);    

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    UNIV_ASSERT(!lp->active);

#if defined (NLB_TCP_NOTIFICATION)
    /* If notification is on, we need to unlink any connections that we have
       from the global established connection queues. */
    if (NLB_NOTIFICATIONS_ON())
    {
        /* Loop through all of the dirty descriptors and unlink them all 
           from the global connection queue.  There is no need to actually
           clean them up or update any counters as this load module is 
           about to disappear. */
        ep = (PCONN_ENTRY)Queue_deq(&lp->conn_dirtyq);

        while (ep != NULL)
        {
            UNIV_ASSERT(ep->code == CVY_ENTRCODE);
            
            /* If we're about to clean up this descriptor, it had better be dirty. */
            UNIV_ASSERT(ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY);
            
            /* Note: virtual descriptors are NOT placed in the global connection
               queues, so dirty virtual descriptors do not need to be unlinked. */
            if (!(ep->flags & NLB_CONN_ENTRY_FLAGS_VIRTUAL))
            {
                /* Note: The rule for locking the global queues is that you MUST 
                   lock the queues BEFORE locking the load module itself.  For 
                   most load APIs, the main module locks the load module BEFORE 
                   calling the relevant load module API.  Load_cleanup, however,
                   is a case where the load lock is not acquired AT ALL.  Therefore,
                   it is permissible for us to grab the global queue locks here,
                   knowing that the load module lock has NOT BEEN LOCKED.  DO NOT
                   ACQUIRE THE LOAD MODULE LOCK BEFORE CALLING THIS FUNCTION. */
                NdisAcquireSpinLock(&g_conn_estabq[ep->index].lock);
                
                /* Unlink from the global connection queue. */
                g_conn_estabq[ep->index].length--;
                Link_unlink(&ep->glink);
                
                NdisReleaseSpinLock(&g_conn_estabq[ep->index].lock);
            }
            
            /* Get the next descriptor in the queue. */
            ep = (PCONN_ENTRY)Queue_deq(&lp->conn_dirtyq);
        }
    }
#endif

    /* Destroy the fixed-size block pool and all descriptors therein. 
       Note that NdisDestroyBlockPool expects all allocated blocks 
       have been returned to the pool (freed) before it is called. */
    if (lp->free_dscr_pool != NULL) 
    {       
        /* Loop through all of the connection descriptor queues and 
           free all of the descriptors we've allocated. */
        for (i = 0; i < CVY_MAX_CHASH; i++)
        {
            /* Dequeue the head of the queue. */
            PCONN_DESCR dp = (PCONN_DESCR)Queue_deq(&lp->connq[i]);
	
            while (dp != NULL)
            {
                UNIV_ASSERT(dp->code == CVY_DESCCODE);

                /* If we're about to free this descriptor, it had better be allocated. */
                UNIV_ASSERT(dp->entry.flags & NLB_CONN_ENTRY_FLAGS_ALLOCATED);
                
                /* Free the descriptor back to the fixed-size block pool. */
                NdisFreeToBlockPool((PUCHAR)dp);
                
                /* Get the next descriptor in the queue. */
                dp = (PCONN_DESCR)Queue_deq(&lp->connq[i]);
            }
        }
        
        /* Destroy the fixed-size block pool. */
        NdisDestroyBlockPool(lp->free_dscr_pool);
    }

}  /* end Load_cleanup */

void Load_convergence_start (PLOAD_CTXT lp)
{
    PMAIN_CTXT ctxtp = CONTAINING_RECORD(lp, MAIN_CTXT, load);

    lp->consistent = TRUE;

    /* Increment the number of convergences. */
    if (lp->send_msg.state == HST_NORMAL)
        lp->num_convergences++;

    /* Setup initial convergence state. */
    lp->send_msg.state = HST_CVG;

    lp->stable_map    = 0;
    lp->my_stable_ct  = 0;
    lp->all_stable_ct = 0;

    lp->send_msg.master_id = (USHORT)(lp->my_host_id);

}

BOOLEAN Load_msg_rcv(
    PLOAD_CTXT      lp,
    PVOID           phdr,
    PPING_MSG       pmsg)           /* ptr. to ping message */
{
    ULONG       i;
    BOOLEAN     consistent;
    ULONG       my_host;
    ULONG       rem_host;
    ULONG       saved_map;      /* saved host map */
    PPING_MSG   sendp;          /* ptr. to my send message */
    IRQLEVEL    irql;
    WCHAR       me[20];
    WCHAR       them[20];
    ULONG       map;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);
    PMAIN_FRAME_HDR ping_hdrp = (PMAIN_FRAME_HDR)phdr;

    /* Used for tracking convergence and event logging. */
    BOOLEAN     bInconsistentMaster = FALSE;
    BOOLEAN     bInconsistentTeaming = FALSE;
    BOOLEAN     bInconsistentPortRules = FALSE;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    TRACE_HB("%!FUNC! Recv HB from host %d",  (ULONG) pmsg->host_id + 1);

    if (!(lp->active))
    {
        return FALSE;
    }

    my_host  = lp->my_host_id;
    rem_host = (ULONG) pmsg->host_id;

    Univ_ulong_to_str (my_host+1, me, 10);
    Univ_ulong_to_str (rem_host+1, them, 10);

    sendp    = &(lp->send_msg);

    if (rem_host >= CVY_MAX_HOSTS)
    {
        return FALSE;
    }

    LOCK_ENTER(&(lp->lock), &irql);

    /* If this heartbeat is from a win2k host, add it to the legacy host map. */
    if (ping_hdrp->version < CVY_VERSION_FULL)        
        lp->legacy_hosts |=  (1 << rem_host);

    /* filter out packets broadcast by this host */

    if(rem_host == my_host)
    {
        /* if this packet was really from another host, we have duplicate host ids */

        if (sendp->hcode != pmsg->hcode)
        {
            if (!(lp->dup_hosts))
            {
                UNIV_PRINT_CRIT(("Load_msg_rcv: Duplicate host ids detected."));
                TRACE_CRIT("%!FUNC! Duplicate host ids detected.");

                LOG_MSG(MSG_ERROR_HOST_ID, me);

                lp->dup_hosts = TRUE;
            }

            /* Tracking convergence - Starting convergence because duplicate host IDs were detected in the cluster. */
            if (sendp->state == HST_NORMAL) {

                LOG_MSGS(MSG_INFO_CONVERGING_DUPLICATE_HOST_ID, me, them);
                TRACE_CONVERGENCE("%!FUNC! Initiating convergence on host %d.  Reason: Host %d is configured with the same host ID.", my_host+1, rem_host+1);

                // If enabled, fire wmi event indicating start of convergence
                if (NlbWmiEvents[ConvergingEvent].Enable)
                {
                    WCHAR wsDip[CVY_MAX_DED_IP_ADDR + 1];

                    Univ_ip_addr_ulong_to_str (ping_hdrp->ded_ip_addr, wsDip);

                    NlbWmi_Fire_ConvergingEvent(ctxtp, 
                                                NLB_EVENT_CONVERGING_DUPLICATE_HOST_ID, 
                                                wsDip,
                                                rem_host+1);            
                }
                else
                {
                    TRACE_VERB("%!FUNC! NOT Generating NLB_EVENT_CONVERGING_DUPLICATE_HOST_ID 'cos ConvergingEvent generation disabled");
                }
            }

            /* Tracking convergence - Starting convergence. */
            Load_convergence_start(lp);
        }

        /* just update ping and host maps for us */
        lp->ping_map |= (1 << my_host);
        lp->host_map |= (1 << my_host);

        LOCK_EXIT(&(lp->lock), irql);

        return (sendp->state != HST_NORMAL);
    }

    if (sendp->nrules != pmsg->nrules)
    {
        if (!(lp->bad_num_rules))
        {
            UNIV_PRINT_CRIT(("Load_msg_rcv: Host %d: Hosts have diff # rules.", my_host));
            TRACE_CRIT("%!FUNC! Host %d: Hosts have diff # rules.", my_host);

            LOG_MSG2(MSG_ERROR_RULES_MISMATCH, them, sendp->nrules, pmsg->nrules);

            lp->bad_num_rules = TRUE;
        }

        /* Tracking convergence - Starting convergence because the number of port rules on this host and the remote host do not match. */
        if (sendp->state == HST_NORMAL) {

            LOG_MSGS(MSG_INFO_CONVERGING_NUM_RULES, me, them);            
            TRACE_CONVERGENCE("%!FUNC! Initiating convergence on host %d.  Reason: Host %d is configured with a conflicting number of port rules.", my_host+1, rem_host+1);

            // If enabled, fire wmi event indicating start of convergence
            if (NlbWmiEvents[ConvergingEvent].Enable)
            {
                WCHAR wsDip[CVY_MAX_DED_IP_ADDR + 1];

                Univ_ip_addr_ulong_to_str (ping_hdrp->ded_ip_addr, wsDip);

                NlbWmi_Fire_ConvergingEvent(ctxtp, 
                                            NLB_EVENT_CONVERGING_NUM_RULES, 
                                            wsDip,
                                            rem_host+1);            
            }
            else
            {
                TRACE_VERB("%!FUNC! NOT Generating NLB_EVENT_CONVERGING_NUM_RULES 'cos ConvergingEvent generation disabled");
            }
        }

        /* Tracking convergence - Starting convergence. */
        Load_convergence_start(lp);

        /* just update ping and host maps for remote host (bbain 2/17/99) */

        lp->ping_map |= (1 << rem_host);
        lp->host_map |= (1 << rem_host);

        LOCK_EXIT(&(lp->lock), irql);

        return (sendp->state != HST_NORMAL);
    }

    /* update mastership and see if consistent */

    if (rem_host < sendp->master_id)
        sendp->master_id = (USHORT)rem_host;

    consistent = sendp->master_id == pmsg->master_id;       /* 1.03 */

    /* For the purposes of logging the reason for convergence, note this inconsistency. */
    if (!consistent) bInconsistentMaster = TRUE;

    /* update ping and host maps to include remote host */

    lp->ping_map  |= (1 << rem_host);

    saved_map      = lp->host_map;
    lp->host_map  |= (1 << rem_host);

    /* handle host convergence */

    if (sendp->state != HST_NORMAL)
    {
        /* if master, update stable map for remote host */

        if (sendp->master_id == my_host)
        {
            if (pmsg->state == HST_STABLE)
            {
                lp->stable_map |= (1 << rem_host);
            }
            else
            {
                lp->stable_map    &= ~(1 << rem_host);
                lp->all_stable_ct  = 0;
            }
        }

        /* otherwise, update state if have global stable convergence  and the current
           master has signalled completion by returning to the normal state; note
           that we must do this prior to updating port group states  */

        else if (rem_host == sendp->master_id && pmsg->state == HST_NORMAL)
        {
            if (sendp->state == HST_STABLE)
            {
                sendp->state = HST_NORMAL;

                /* Note the time of the last completed convergence. */
                lp->last_convergence = lp->clock_sec;

                /* Notify our BDA team that this cluster is consistently configured.  
                   If we are not part of a BDA team, this call is essentially a no-op. */
                Load_teaming_consistency_notify(&ctxtp->bda_teaming, TRUE);

                /* Reset the bad teaming configuration detected flag if we are converged. */
                lp->bad_team_config = FALSE;

                lp->dup_hosts       = FALSE;
                lp->dup_sspri       = FALSE;
                lp->bad_map         = FALSE;
                lp->overlap_maps    = FALSE;
                lp->err_rcving_bins = FALSE;
                lp->err_orphans     = FALSE;
                lp->bad_num_rules   = FALSE;
                lp->pkt_count       = 0;      /* v1.32B */

                for (i=0; i<sendp->nrules; i++)
                {
                    PBIN_STATE      bp;

                    bp = &(lp->pg_state[i]);

                    bp->compatible = TRUE;      /* 1.03 */

                    Bin_converge_commit(lp, bp, my_host);

                    UNIV_PRINT_VERB(("Load_msg_rcv: Host %d pg %d: new cur map %x idle %x all %x",
                                my_host, i, bp->cur_map[my_host], bp->idle_bins,
                                bp->all_idle_map));
                    TRACE_CONVERGENCE("%!FUNC! Host %d pg %d: new cur map 0x%x idle 0x%x all 0x%x",
                                my_host, i, (ULONG)bp->cur_map[my_host], (ULONG)bp->idle_bins,
                                (ULONG)bp->all_idle_map);

                }

                UNIV_PRINT_VERB(("Load_msg_rcv: Host %d: converged as slave", my_host));
                TRACE_VERB("%!FUNC! Host %d: converged as slave", my_host);
                /* log convergence completion if host map changed (bbain RTM RC1 6/23/99) */
                /* Ignoring return value is OK since the return values are all non-errors */
                Load_hosts_query (lp, TRUE, & map);
                lp->last_hmap = lp->host_map;

                if (lp->legacy_hosts) {
                    /* If a Win2k or NT4.0 host is attempting to join the cluster, warn the user that there are potential 
                       limitations of mixed clusters, such as no virtual cluster support, no IGMP, no BDA, no VPN session
                       support and others.  For some of these, the cluster will not be allowed to converge, while for some
                       it will, so we'll just warn the user that they should check the documentation for limitations. */
                    UNIV_PRINT_INFO(("Load_msg_rcv: NT4.0/Win2k host(s) detected: Be aware of the limitations of operating a mixed cluster."));
                    TRACE_INFO("%!FUNC! NT4.0/Win2k host(s) detected: Be aware of the limitations of operating a mixed cluster.");
                    
                    LOG_MSG(MSG_WARN_MIXED_CLUSTER, MSG_NONE);
                }
            }
            else
            {
                /* Tracking convergence - Starting convergence because the DEFAULT host prematurely ended convergence.  In this case, we 
                   are guaranteed to already be in the HST_CVG state, and because this message can be misleading in some circumstances, 
                   we do not log an event.  For instance, due to timing issues, when a host joins a cluster he can receive a HST_NORMAL 
                   heartbeat from the DEFAULT host while it is still in the HST_CVG state simply because that heartbeat left the DEFAULT 
                   host before it received our first heartbeat, which initiated convergence. */
                TRACE_CONVERGENCE("%!FUNC! Initiating convergence on host %d.  Reason: Host %d, the DEFAULT host, prematurely terminated convergence.", my_host+1, rem_host+1);

                /* Tracking convergence - Starting convergence. */
                Load_convergence_start(lp);
            }
        }
    }

    /* Compare the teaming configuration of this host with the remote host.  If the
       two are inconsitent and we are part of a team, we will initiate convergence. */
    if (!Load_teaming_consistency_check(lp->bad_team_config, &ctxtp->bda_teaming, sendp->teaming, pmsg->teaming, ping_hdrp->version)) {
        /* Only log an event if the teaming configuration was, but is now not, consistent. */
        if (!lp->bad_team_config) {
            /* Note that we saw this. */
            lp->bad_team_config = TRUE;
            
            /* Log the event. */
            LOG_MSG(MSG_ERROR_BDA_BAD_TEAM_CONFIG, them);
        }

        /* Notify the team that this cluster is NOT consistently configured. */
        Load_teaming_consistency_notify(&ctxtp->bda_teaming, FALSE);

        /* Mark the heartbeats inconsistent to force and retain convergence. */
        consistent = FALSE;

        /* For the purposes of logging the reason for convergence, note this inconsistency. */
        bInconsistentTeaming = TRUE;
    }

    /* update port group state */

    for (i=0; i<sendp->nrules; i++)
    {
        BOOLEAN     ret;
        PBIN_STATE  bp;

        bp = &lp->pg_state[i];

        /* if rule codes don't match, print message and handle incompatibility (1.03: note
           that we previously marked rule invalid, which would stop processing) */

        if (sendp->rcode[i] != pmsg->rcode[i])
        {
            /* 1.03: if rule was peviously compatible, print message */

            if (bp->compatible)
            {
                PCVY_RULE rp;

                UNIV_PRINT_CRIT(("Load_msg_rcv: Host %d pg %d: Rule codes do not match.", lp->my_host_id, i));
                TRACE_CRIT("%!FUNC! Host %d pg %d: Rule codes do not match.", lp->my_host_id, i);

				/* bbain 8/27/99 */
                LOG_MSG2(MSG_ERROR_RULES_MISMATCH, them, sendp->rcode[i], pmsg->rcode[i]);

                /* Get the port rule information for this rule. */
                rp = &lp->params->port_rules[i];

                /* Check to see if this is an issue with a win2k host in a cluster utilizing virtual clusters. */
                if ((rp->virtual_ip_addr != CVY_ALL_VIP_NUMERIC_VALUE) && ((sendp->rcode[i] ^ ~rp->virtual_ip_addr) == pmsg->rcode[i])) {
                    UNIV_PRINT_CRIT(("Load_msg_rcv: ** A Windows 2000 or NT4 host MAY be participating in a cluster utilizing virtual cluster support."));
                    TRACE_CRIT("%!FUNC! ** A Windows 2000 or NT4 host MAY be participating in a cluster utilizing virtual cluster support.");
                    LOG_MSG(MSG_WARN_VIRTUAL_CLUSTERS, them);
                }

                bp->compatible = FALSE;
            }

            /* 1.03: mark rule inconsistent to force and continue convergence */

            consistent = FALSE;

            /* For the purposes of logging the reason for convergence, note this inconsistency. */
            bInconsistentPortRules = TRUE;

            /* don't update bin state */

            continue;
        }

        ret = Bin_host_update(lp, bp, my_host, (BOOLEAN)(sendp->state != HST_NORMAL),
                              (BOOLEAN)(pmsg->state != HST_NORMAL),
                              rem_host, pmsg->cur_map[i], pmsg->new_map[i],
                              pmsg->idle_map[i], pmsg->rdy_bins[i],
                              pmsg->pkt_count, pmsg->load_amt[i]);

        if (!ret)
            consistent = FALSE;
    }

    /* update our consistency state */

    lp->consistent = consistent;

    /* if we are in normal operation and we discover a new host or a host goes into
       convergence or we discover an inconsistency, go into convergence */

    if (sendp->state == HST_NORMAL)
    {
        if (lp->host_map != saved_map || pmsg->state == HST_CVG || !consistent)
        {
            ConvergingEventId Cause = NLB_EVENT_CONVERGING_UNKNOWN;

            /* If a host has joined the cluster, or if inconsistent teaming configuration or port 
               rules were detected, then we need to log an event.  However, we segregate the 
               inconsistent master host flag because it is set by the initiating host in MANY
               occasions, so we want to log the most specific reason(s) for convergence if 
               possible and only report the inconsistent master detection only if nothing more
               specific can be deduced. */
            if (lp->host_map != saved_map || bInconsistentTeaming || bInconsistentPortRules) {

                /* If the host maps are different, then we know that the host from which we received 
                   this packet is joining the cluster because the ONLY operation on the host map in 
                   this function is to ADD a remote host to our map.  Otherwise, if the map has not
                   changed, then an inconsistent configuration got us into the branch. */
                if (lp->host_map != saved_map) {
                    /* Tracking convergence - Starting convergence because another host is joining the cluster. */
                    LOG_MSGS(MSG_INFO_CONVERGING_NEW_MEMBER, me, them);
                    TRACE_CONVERGENCE("%!FUNC! Initiating convergence on host %d.  Reason: Host %d is joining the cluster.", my_host+1, rem_host+1);

                    Cause = NLB_EVENT_CONVERGING_NEW_MEMBER;
                } else if (bInconsistentTeaming || bInconsistentPortRules) {
                    /* Tracking convergence - Starting convergence because inconsistent configuration was detected. */
                    LOG_MSGS(MSG_INFO_CONVERGING_BAD_CONFIG, me, them);
                    TRACE_CONVERGENCE("%!FUNC! Initiating convergence on host %d.  Reason: Host %d has conflicting configuration.", my_host+1, rem_host+1);

                    Cause = NLB_EVENT_CONVERGING_BAD_CONFIG;
                } 

            /* If we have nothing better to report, report convergence for an unspecific reason. */
            } else if (bInconsistentMaster || pmsg->state == HST_CVG) {
                /* Tracking convergence - Starting convergence for unknown reasons. */
                LOG_MSGS(MSG_INFO_CONVERGING_UNKNOWN, me, them);
                TRACE_CONVERGENCE("%!FUNC! Initiating convergence on host %d.  Reason: Host %d is converging for an unknown reason.", my_host+1, rem_host+1);
            }

            // If enabled, fire wmi event indicating start of convergence
            if (NlbWmiEvents[ConvergingEvent].Enable)
            {
                WCHAR wsDip[CVY_MAX_DED_IP_ADDR + 1];

                Univ_ip_addr_ulong_to_str (ping_hdrp->ded_ip_addr, wsDip);

                NlbWmi_Fire_ConvergingEvent(ctxtp, 
                                            Cause, 
                                            wsDip,
                                            rem_host+1);            
            }
            else
            {
                TRACE_VERB("%!FUNC! NOT Generating ConvergingEvent(New Member/Bad Config/Unknown) 'cos ConvergingEvent generation disabled");
            }

            /* Tracking convergence - Starting convergence. */
            Load_convergence_start(lp);
        }
    }

    /* otherwise, if we are in convergence and we see an inconsistency, just restart
       our local convergence */

    else
    {
        /* update our consistency state; if we didn't see consistent information,
           restart this host's convergence */

        if (!consistent)
        {
            /* Tracking convergence - Starting convergence because inconsistent configuration was detected.  
               This keeps hosts in a state of convergence when hosts are inconsistently configured.  However,
               since the cluster is already in a state of convergece (HST_CVG or HST_STABLE), don't log an
               event, which may confuse a user. */
            TRACE_CONVERGENCE("%!FUNC! Initiating convergence on host %d.   Reason: Host %d has conflicting configuration.", my_host+1, rem_host+1);

            /* Tracking convergence - Starting convergence. */
            sendp->state = HST_CVG;
            lp->my_stable_ct = 0;
            lp->stable_map &= ~(1 << my_host);
            lp->all_stable_ct = 0;
        }
    }

    LOCK_EXIT(&(lp->lock), irql);

    return (sendp->state != HST_NORMAL);

}  /* end Load_msg_rcv */


PPING_MSG Load_snd_msg_get(
    PLOAD_CTXT      lp)
{
    return &(lp->send_msg);

}  /* end Load_snd_msg_get */

/*
 * Function: Load_age_descriptors
 * Description: This function searches a list of connection descriptors and
 *              removes those whose timeouts have expired.  The queues are
 *              sorted timeout queues, so it is only ever necessary to look
 *              at the head of the queue to find expired descriptors. This
 *              function loops until all expired descriptors are removed.
 * Parameters: lp - a pointer to the load module.
 *             eqp - pointer to the expired descriptor queue to service.
 * Returns: Nothing.
 * Author: shouse, 9.9.01
 * Notes: 
 */
void Load_age_descriptors (PLOAD_CTXT lp, QUEUE * eqp)
{
    PCONN_ENTRY ep;              /* Pointer to connection entry. */
    PBIN_STATE  bp;              /* Pointer to port rule state. */
    LINK *      linkp;           /* Pointer to the queue link. */
    BOOLEAN     err_bin = FALSE; /* Bin ID error detected. */
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD(lp, MAIN_CTXT, load);

    /* Get a pointer to (but do not dequeue) the head of the queue. */
    linkp = (LINK *)Queue_front(eqp);

    /* As long as there are descriptors to check, keep looking - when
       we find the first descriptor that is NOT ready to be dequeued, 
       we stop looking and break out of the loop. */
    while (linkp != NULL) {
        /* Get a pointer to the descriptor (linkp is a pointer to
           the LIST_ENTRY in the descriptor, not the descriptor). */
        ep = STRUCT_PTR(linkp, CONN_ENTRY, rlink);
        UNIV_ASSERT(ep->code == CVY_ENTRCODE);

        /* Do some sanity checking on the bin number. */
        if (ep->bin >= CVY_MAXBINS) {
            if (!err_bin) {
                TRACE_CRIT("%!FUNC! Bad bin number");
                LOG_MSG2(MSG_ERROR_INTERNAL, MSG_NONE, ep->bin, CVY_MAXBINS);

                err_bin = TRUE;
            }
        }

#if defined (TRACE_DSCR)
        DbgPrint("Load_age_descriptors: Descriptor %p: clock=%u, timeout=%u", ep, lp->clock_sec, ep->timeout);
#endif

        /* If the current clock time is greater than or equal to the 
           scheduled timeout for this descriptor, then pull it off 
           and recycle it. */
        if (lp->clock_sec >= ep->timeout) {

#if defined (TRACE_DSCR)
            DbgPrint("Load_age_descriptors: Removing descriptor %p", ep);
#endif

            /* Lookup the port rule, so we can update the port rule info. */
            bp = Load_pg_lookup(lp, ep->svr_ipaddr, ep->svr_port, IS_TCP_PKT(ep->protocol));

            /* Clear the descriptor. */
            CVY_CONN_CLEAR(ep);

            /* Release the descriptor. */
            Load_put_dscr(lp, bp, ep);

        /* Break if this descriptor was not ready to expire yet. */
        } else break;

        /* Grab the next descriptor in the queue. */
        linkp = (LINK *)Queue_front(eqp);
    }
}

BOOLEAN Load_timeout(
    PLOAD_CTXT      lp,
    PULONG          new_timeout,
    PULONG          pnconn)
/*
  Note: we only update ping message in this function since we know that upper level code
  sends out ping messages after calling this routine.  We cannot be sure that Load_msg_rcv
  is sequentialized with sending a message, (1.03)

  Upper level code locks this routine wrt Load_msg_rcv, Load_packet_check, and
  Load_conn_advise.  (1.03)
*/
{
    ULONG       missed_pings;
    ULONG       my_host;
    ULONG       i;
    PPING_MSG   sendp;          /* ptr. to my send message */
    IRQLEVEL    irql;
    ULONG       map;            /* returned host map from query */
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);
    BOOLEAN     fRet = FALSE;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    LOCK_ENTER(&(lp->lock), &irql);

    if ((lp->cln_waiting) && (lp->cur_time < lp->cln_timeout))
    {
        lp->cur_time += lp->cur_timeout;
        
        if (lp->cur_time >= lp->cln_timeout)
        {
            TRACE_INFO("%!FUNC! Cleaning out dirty connection descriptors");
            
            Load_conn_cleanup(lp);
        }
    }

    /* Update the internal clock.  We add the time since the last timeout
       (in ms) to our msec count.  We then add any whole number of seconds
       that have accumulated in msec to the sec count.  The remainder is
       left in msec to accumulate. */
    lp->clock_msec += lp->cur_timeout;
    lp->clock_sec += (lp->clock_msec / 1000);
    lp->clock_msec = (lp->clock_msec % 1000);

    /* Age all conenction descriptors. */
    Load_age_descriptors(lp, &(lp->tcp_expiredq));
    Load_age_descriptors(lp, &(lp->ipsec_expiredq));

    /* Return if not active. */
    if (!(lp->active))
    {
        if (new_timeout != NULL)
            * new_timeout = lp->cur_timeout = lp->def_timeout;
        if (pnconn != NULL)         /* v2.1 */
            * pnconn = lp->nconn;

        LOCK_EXIT(&(lp->lock), irql);
        return FALSE;
    }

    my_host = lp->my_host_id;
    sendp   = &(lp->send_msg);

    /* compute which hosts missed pings and reset ping map */

    missed_pings = lp->host_map & (~lp->ping_map);

#ifdef NO_CLEANUP
    lp->ping_map = 1 << my_host;
#else
    lp->ping_map = 0;
#endif

    /* check whether any host is dead, including ourselves */

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        /* if we have a missed ping for this host, increment count */

        if ((missed_pings & 0x1) == 1)
        {
            lp->nmissed_pings[i]++;

            /* if we missed too many pings, declare host dead and force convergence */

            if (lp->nmissed_pings[i] == lp->min_missed_pings)
            {
                ULONG       j;
                BOOLEAN     ret;
                WCHAR       me[20];
                WCHAR       them[20];

                if (i == my_host)
                {
                    UNIV_PRINT_VERB(("Load_timeout: Host %d: Missed too many pings; this host declared offline", i));
                    TRACE_VERB("%!FUNC! Host %d: Missed too many pings; this host declared offline", i);

                    /* reset our packet count since we are likely not to be receiving
                       packets from others now; this will make us less favored to
                       handle duplicate bins later (v1.32B) */

                    lp->pkt_count = 0;
                }

                lp->host_map &= ~(1<<i);

                /* Reset the legacy host bit if the host has gone off-line. */
                lp->legacy_hosts &= ~(1<<i);

                for (j=0; j<sendp->nrules; j++)
                {
                    PBIN_STATE      bp;

                    bp = &(lp->pg_state[j]);
					UNIV_ASSERT(bp->code == CVY_BINCODE);	/* (bbain 8/19/99) */

                    if (i == my_host)
                    {
                        ULONG       k;

                        /* cleanup connections and restore maps to clean state */

                        Load_conn_kill(lp, bp);

                        bp->targ_map     = 0;
                        bp->all_idle_map = BIN_ALL_ONES;
                        bp->cmap         = 0;               /* v2.1 */
                        bp->compatible   = TRUE;            /* v1.03 */

                        for (k=0; k<CVY_MAX_HOSTS; k++)
                        {
                            bp->new_map[k]  = 0;
                            bp->cur_map[k]  = 0;
                            bp->chk_map[k]  = 0;
                            bp->idle_map[k] = BIN_ALL_ONES;

                            if (k != i)
                                bp->load_amt[k] = 0;
                        }

                        bp->snd_bins   =
                        bp->rcv_bins   =
                        bp->rdy_bins   = 0;
                        bp->idle_bins  = BIN_ALL_ONES;
                        
                        /* Re-initialize the performance counters. */
                        bp->packets_accepted = 0;
                        bp->packets_dropped  = 0;
                        bp->bytes_accepted   = 0;
                        bp->bytes_dropped    = 0;

                        /* compute initial new map for convergence as only host in cluster
                           (v 1.3.2B) */

                        ret = Bin_converge(lp, bp, lp->my_host_id);
                        if (!ret)
                        {
                            UNIV_PRINT_CRIT(("Load_timeout: Initial convergence inconsistent"));
                            TRACE_CRIT("%!FUNC! Initial convergence inconsistent");
                            LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);
                        }
                    }
                    else
                    {
                        ret = Bin_host_update(lp, bp, my_host, TRUE, TRUE,
                                          i, 0, 0, BIN_ALL_ONES, 0, 0, 0);
                    }
                }

                lp->nmissed_pings[i] = 0;

                /* If a host has dropped out of the cluster, then log an event.  However, we don't 
                   log an event when we drop out because the only way for us to drop out of our own
                   cluster is if we are stopping anyway, or if we have lost network connectivity. 
                   Logging such events may be misleading, so we won't bother. */
                if (i != my_host) {
                    Univ_ulong_to_str (my_host+1, me, 10);
                    Univ_ulong_to_str (i+1, them, 10);                   
                    
                    /* Tracking convergence - Starting convergence because a member has fallen out of the cluster. */
                    LOG_MSGS(MSG_INFO_CONVERGING_MEMBER_LOST, me, them);
                    TRACE_CONVERGENCE("%!FUNC! Initiating convergence on host %d.  Reason: Host %d is leaving the cluster.", my_host+1, i+1);

                    // If enabled, fire wmi event indicating start of convergence
                    if (NlbWmiEvents[ConvergingEvent].Enable)
                    {
                        NlbWmi_Fire_ConvergingEvent(ctxtp, 
                                                    NLB_EVENT_CONVERGING_MEMBER_LOST, 
                                                    NLB_EVENT_NO_DIP_STRING,
                                                    i+1);            
                    }
                    else
                    {
                        TRACE_VERB("%!FUNC! NOT Generating NLB_EVENT_CONVERGING_MEMBER_LOST 'cos ConvergingEvent generation disabled");
                    }
                }
                
                /* Tracking convergence - Starting convergence. */
                Load_convergence_start(lp);
            }
        }

        /* otherwise reset missed ping count */

        else
            lp->nmissed_pings[i] = 0;

        missed_pings >>= 1;
    }

    /* handle convergence */

    if (sendp->state != HST_NORMAL)
    {
        /* check whether we have been consistent and have received our own pings
           for a sufficient period to move to a stable state and announce it to
           other hosts */

        if (sendp->state == HST_CVG)
        {
            if (lp->consistent && ((lp->host_map & (1 << my_host)) != 0))
            {
                lp->my_stable_ct++;
                if (lp->my_stable_ct >= lp->min_stable_ct)
                {
                    sendp->state = HST_STABLE;
                    lp->stable_map |= (1 << my_host);
                }
            }
            else
                lp->my_stable_ct = lp->all_stable_ct = 0;	/* wlb B3RC1 */
        }

        /* otherwise, see if we are the master and everybody's been stable for
           a sufficient period for us to terminate convergence */

        else if (sendp->state == HST_STABLE &&
                 my_host == sendp->master_id &&
                 lp->stable_map == lp->host_map)
        {
            lp->all_stable_ct++;
            if (lp->all_stable_ct >= lp->min_stable_ct)
            {
                sendp->state = HST_NORMAL;

                /* Note the time of the last completed convergence. */
                lp->last_convergence = lp->clock_sec;

                /* Notify our BDA team that this cluster is consistently configured.  
                   If we are not part of  BDA team, this call is essentially a no-op. */
                Load_teaming_consistency_notify(&ctxtp->bda_teaming, TRUE);

                /* Reset the bad teaming configuration detected flag if we are converged. */
                lp->bad_team_config = FALSE;

                lp->dup_hosts       = FALSE;
                lp->dup_sspri       = FALSE;
                lp->bad_map         = FALSE;
                lp->overlap_maps    = FALSE;
                lp->err_rcving_bins = FALSE;
                lp->err_orphans     = FALSE;
                lp->bad_num_rules   = FALSE;
                lp->pkt_count       = 0;      /* v1.32B */

                for (i=0; i<sendp->nrules; i++)
                {
                    PBIN_STATE      bp;
                    BOOLEAN         ret;

                    bp = &(lp->pg_state[i]);

                    bp->compatible = TRUE;      /* 1.03 */

                    /* explicitly converge to new map in case we're the only host (v2.06) */

                    ret = Bin_converge(lp, bp, lp->my_host_id);
                    if (!ret)
                    {
                        UNIV_PRINT_CRIT(("Load_timeout: Final convergence inconsistent"));
                        TRACE_CRIT("%!FUNC! Final convergence inconsistent");
                        LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);
                    }

                    Bin_converge_commit(lp, bp, my_host);

                    UNIV_PRINT_VERB(("Load_timeout: Host %d pg %d: new cur map %x idle %x all %x",
                                 my_host, i, bp->cur_map[my_host], bp->idle_bins,
                                 bp->all_idle_map));
                }

                UNIV_PRINT_VERB(("Load_timeout: Host %d: converged as master", my_host));
                TRACE_CONVERGENCE("%!FUNC! Host %d: converged as master", my_host);
                /* log convergence completion if host map changed (bbain RTM RC1 6/23/99) */
                Load_hosts_query (lp, TRUE, & map);
                lp->last_hmap = lp->host_map;

                if (lp->legacy_hosts) {
                    /* If a Win2k or NT4.0 host is attempting to join the cluster, warn the user that there are potential 
                       limitations of mixed clusters, such as no virtual cluster support, no IGMP, no BDA, no VPN session
                       support and others.  For some of these, the cluster will not be allowed to converge, while for some
                       it will, so we'll just warn the user that they should check the documentation for limitations. */
                    UNIV_PRINT_INFO(("Load_timeout: NT4.0/Win2k host(s) detected: Be aware of the limitations of operating a mixed cluster."));
                    TRACE_INFO("%!FUNC! NT4.0/Win2k host(s) detected: Be aware of the limitations of operating a mixed cluster.");
                    
                    LOG_MSG(MSG_WARN_MIXED_CLUSTER, MSG_NONE);
                }
            }
        }
    }

    /* 1.03: update ping message */

    for (i=0; i<sendp->nrules; i++)
    {
        PBIN_STATE      bp;

        bp = &(lp->pg_state[i]);

        /* export current port group state to ping message */

        sendp->cur_map[i]   = bp->cmap;                 /* v2.1 */
        sendp->new_map[i]   = bp->new_map[my_host];
        sendp->idle_map[i]  = bp->idle_bins;
        sendp->rdy_bins[i]  = bp->rdy_bins;
        sendp->load_amt[i]  = bp->load_amt[my_host];

        // NOTE:  The following line of code was removed when it was discovered that it 
        // routinely produces a Wake On LAN pattern in the heartbeat that causes BroadCom
        // NICs to panic.  Although this is NOT an NLB issue, but rather a firmware issue
        // in BroadCom NICs, it was decided to remove the information from the heartbeat
        // to alleviate the problem for customers with BroadCom NICs upgrading to .NET.
        // This array is UNUSED by NLB, so there is no harm in not filling it in; it was
        // added a long time ago for debugging purposes as part of the now-defunct FIN-
        // counting fix that was part of Win2k SP1.
        //
        // For future reference, should we need to use this space in the heartbeat at some
        // future point in time, it appears that we will need to be careful to avoid potential
        // WOL patterns in our heartbeats where we can avoid it.  A WOL pattern is:
        //
        // 6 bytes of 0xFF, followed by 16 idential instances of a "MAC address" that can
        // appear ANYWHERE in ANY frame type, including our very own NLB heartbeats.  E.g.:
        //
        // FF FF FF FF FF FF 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06
        // 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06
        // 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06
        // 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06 01 02 03 04 05 06
        // 01 02 03 04 05 06
        //
        // The MAC address need not be valid, however.  In NLB heartbeats, the "MAC address"
        // in the mistaken WOL pattern is "00 00 00 00 00 00".  NLB routinely fills heartbeats
        // with FF and 00 bytes, but it seems that by "luck" no other place in the heartbeat
        // seems this vulnerable.  For instance, in the load_amt array, each entry has a 
        // maximum value of 100 (decimal), so there is no possibility of generating the initial
        // 6 bytes of FF to start the WOL pattern.  All of the "map" arrays seem to be saved
        // by two strokes of fortune; (i) little endian and (ii) the bin distribution algorithm.
        // 
        // (i) Since we don't use the 4 most significant bits of the ULONGLONGs used to store 
        // each map, the most significant bit is NEVER FF.  Because Intel is little endian, the
        // most significant byte appears last.  For example:
        // 
        // 0F FF FF FF FF FF FF FF appears in the packet as FF FF FF FF FF FF 0F
        // 
        // This breaks the FF sequence in many scenarios.
        //
        // (ii) The way the bin distribution algorithm distributes buckets to hosts seems to 
        // discourage other possibilities.  For instance, a current map of:
        // 
        // 00 FF FF FF FF FF FF 00 
        // 
        // just isn't likely.  However, it IS STILL POSSIBLE!  So, it is important to note that:
        // 
        // REMOVING THIS LINE OF CODE DOES NOT, IN ANY WAY, GUARANTEE THAT AN NLB HEARTBEAT
        // CANNOT STILL CONTAIN A VALID WAKE ON LAN PATTERN SOMEWHERE ELSE IN THE FRAME!!!

        // sendp->pg_rsvd1[i]  = (ULONG)bp->all_idle_map;
    }

    sendp->pkt_count        = lp->pkt_count;            /* 1.32B */

    /* Add configuration information for teaming at each timeout. */
    Load_teaming_code_create(&lp->send_msg.teaming, &ctxtp->bda_teaming);

    /* request fast timeout if converging */

    if (new_timeout != NULL)        /* 1.03 */
    {
        if (sendp->state != HST_NORMAL)
            * new_timeout = lp->cur_timeout = lp->def_timeout / 2;
        else
            * new_timeout = lp->cur_timeout = lp->def_timeout;
    }

    if (pnconn != NULL)             /* v2.1 */
        * pnconn = lp->nconn;

    fRet = (sendp->state != HST_NORMAL);

    LOCK_EXIT(&(lp->lock), irql);

    return fRet;
}  /* end Load_timeout */


PBIN_STATE Load_pg_lookup(
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    BOOLEAN         is_tcp)
{
    PCVY_RULE       rp;     /* ptr. to rules array */
    PBIN_STATE      bp;     /* ptr. to bin state */
    ULONG           i;
    ULONG           nurules;    /* # user defined rules */
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);


    UNIV_ASSERT(lp->code == CVY_LOADCODE);	/* (bbain 8/19/99) */

    rp      = (* (lp->params)).port_rules;
    nurules = (* (lp->params)).num_rules;

    /* check for invalid port value (bbain RC1 6/14/99) */

    UNIV_ASSERT(svr_port <= CVY_MAX_PORT); 

    /* find server port rule */

    for (i=0; i<nurules; i++)
    {
        /* For virtual clusters: If the server IP address matches the VIP for the port rule,
           or if the VIP for the port rule is "ALL VIPs", and if the port lies in the range
           for this rule, and if the protocol matches, this is the rule.  Notice that this
           give priority to rules for specific VIPs over those for "ALL VIPs", which means
           that this code RELIES on the port rules being sorted by VIP/port where the "ALL
           VIP" ports rules are at the end of the port rule list. */
        if ((svr_ipaddr == rp->virtual_ip_addr || CVY_ALL_VIP_NUMERIC_VALUE == rp->virtual_ip_addr) &&
            (svr_port >= rp->start_port && svr_port <= rp->end_port) &&
            ((is_tcp && rp->protocol != CVY_UDP) || (!is_tcp && rp->protocol != CVY_TCP)))
            break;
        else
            rp++;
    }

    /* use default rule if port not found or rule is invalid */

    bp = &(lp->pg_state[i]);
    UNIV_ASSERT(bp->code == CVY_BINCODE);	/* (bbain 8/19/99) */

    return bp;
}  /* end Load_pg_lookup */

/* 
 * Function: Load_find_dscr
 * Description: This function takes a load pointer, hash value and connection 
 *              parameters and searches all possible locations looking for a 
 *              matching connection descriptor.  If it finds ones, it returns
 *              a pointer to the descriptor (CONN_ENTRY); otherwise, it returns
 *              NULL to indicate that no matching descriptor was found.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             index - the connection queue index for this packet
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port number in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port number in host byte order
 *             protocol - the connection protocol
 * Returns: PCONN_ENTRY - a pointer to the descriptor, or NULL if not found
 * Author: shouse, 10.4.01
 * Notes:
 */
PCONN_ENTRY Load_find_dscr (
    PLOAD_CTXT      lp,
    ULONG           index,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol)
{
    BOOLEAN     match = FALSE; /* TRUE => we have a record of this connection. */
    PBIN_STATE  bp;            /* Pointer to bin state. */
    PCONN_ENTRY ep;            /* Pointer to connection entry. */
    PCONN_DESCR dp;            /* Pointer to connection descriptor. */
    QUEUE *     qp;            /* Pointer to connection queue. */

    UNIV_ASSERT(lp->code == CVY_LOADCODE);
 
    /* Get a pointer to the connection entry for this hash ID. */
    ep = &(lp->hashed_conn[index]);

    UNIV_ASSERT(ep->code == CVY_ENTRCODE);

    /* Get a pointer to the conneciton queue. */
    qp = &(lp->connq[index]);

    /* Look in the hashed connection table first. */
    if (CVY_CONN_MATCH(ep, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol)) 
    {
        /* Note that we found a match for this tuple. */
        match = TRUE;
    } 
    else 
    {
        /* Look through the descriptor queue. */
        for (dp = (PCONN_DESCR)Queue_front(qp); dp != NULL; dp = (PCONN_DESCR)Queue_next(qp, &(dp->link))) 
        {
            if (CVY_CONN_MATCH(&(dp->entry), svr_ipaddr, svr_port, client_ipaddr, client_port, protocol)) 
            {
                /* Note that we found a match for this tuple. */
                match = TRUE;
                
                UNIV_ASSERT (dp->code == CVY_DESCCODE);

                /* Get a pointer to the connection entry. */
                ep = &(dp->entry);			

                UNIV_ASSERT (ep->code == CVY_ENTRCODE);

                break;
            }
        }
    }

    /* If we found a match, return it, otherwise return NULL. */
    if (match)
        return ep;
    else 
        return NULL;
}

/* 
 * Function: Load_note_conn_up
 * Description: This function adjusts the appropriate connection counters
 *              for an up-coming connection.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             bp - a pointer to the port rule on which the connection was established
 *             bin - the bin to which the connection maps (Map % 60)
 * Returns: Nothing.
 * Author: shouse, 10.4.01
 * Notes:
 */
VOID Load_note_conn_up (PLOAD_CTXT lp, PBIN_STATE bp, ULONG bin)
{
    /* Increment the number of connections. */ 
    lp->nconn++;
    bp->tconn++;
    bp->nconn[bin]++;
    
    /* Mark bin not idle if necessary. */
    if (bp->nconn[bin] == 1) bp->idle_bins &= ~(((MAP_T) 1) << bin);
}

/* 
 * Function: Load_note_conn_down
 * Description: This function adjusts the appropriate connection counters
 *              for an down-going connection.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             bp - a pointer to the port rule on which the connection resides
 *             bin - the bin to which the connection maps (Map % 60)
 * Returns: Nothing.
 * Author: shouse, 10.4.01
 * Notes:
 */
VOID Load_note_conn_down (PLOAD_CTXT lp, PBIN_STATE bp, ULONG bin)
{
    UNIV_ASSERT(bp->nconn[bin] > 0 && bp->tconn > 0 && lp->nconn > 0);
    
    /* Update the number of connections on the entire load module. */
    if (lp->nconn <= 0)
        lp->nconn = 0;
    else
        lp->nconn--;
    
    /* Update the number of connections on this bin and port rule. */
    if (bp->nconn[bin] <= 0)
        bp->nconn[bin] = 0;
    else
        bp->nconn[bin]--;
    
    /* Update the total number of connections on this port rule. */
    if (bp->tconn <= 0)
        bp->tconn = 0;
    else
        bp->tconn--;
    
    /* If this was the last connection on this bin, update the idle map. */
    if (bp->nconn[bin] == 0) bp->idle_bins |= (((MAP_T) 1) << bin);
}

/* 
 * Function: Load_init_dscr
 * Description: This function initializes a NEWLY ALLOCATED descriptor.
 *              It is only necessary to perform this initialization ONCE.
 *              As descriptors are freed for re-use, use Load_reset_dscr
 *              to "re-initialize" them.
 * Parameters: lp - a pointer to the load context on which this descriptor lives
 *             ep - a pointer to a connection descriptor
 *             alloc - whether or not this descriptor was dynamically allocated
 * Returns: Nothing.
 * Author: shouse, 10.4.01
 * Notes:
 */
VOID Load_init_dscr (PLOAD_CTXT lp, PCONN_ENTRY ep, BOOLEAN alloc)
{
    /* Set the "magic number". */
    ep->code = CVY_ENTRCODE;

#if defined (NLB_TCP_NOTIFICATION)
    /* Save a pointer to this load module. */
    ep->load = lp;
#endif
    
    /* Initialize the hashing results. */
    ep->index = 0;
    ep->bin = 0;

    /* Re-set the flags register. */
    ep->flags = 0;

    /* Is this descriptor in the static hash array, or allocated? */
    if (alloc) 
        ep->flags |= NLB_CONN_ENTRY_FLAGS_ALLOCATED;

    /* Initialize some other descriptor state. */
    ep->timeout = 0;
    ep->ref_count = 0;

    /* Clear the descriptor. */
    CVY_CONN_CLEAR(ep);

    /* Initilize the links. */
    Link_init(&(ep->blink));
    Link_init(&(ep->rlink));
#if defined (NLB_TCP_NOTIFICATION)
    Link_init(&(ep->glink));
#endif
}

/* 
 * Function: Load_init_fsb
 * Description: This function initializes a fixed-size block allocated from the
 *              fixed-size block pool.
 * Parameters: lp - a pointer to the load context on which the descriptor lives
 *             dp - a pointer to a block (connection descriptor)
 * Returns: Nothing.
 * Author: shouse, 4.1.02
 * Notes:
 */
VOID Load_init_fsb (PLOAD_CTXT lp, PCONN_DESCR dp)
{
    /* Set the "magic number". */
    dp->code = CVY_DESCCODE;
    
    /* Initialize the connection queue link. */
    Link_init(&(dp->link));

    /* Initialize the connection entry. */
    Load_init_dscr(lp, &dp->entry, TRUE);
}

/* 
 * Function: Load_reset_dscr
 * Description: This function resets a descriptor for re-use.  This includes
 *              re-initializing the state, setting the bin and queueing the
 *              descriptor onto the recovery and port rule queues. 
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             bp - a pointer to the port rule on which the connection is established
 *             ep - a pointer to the descriptor to be reset
 *             index - the connection queue index
 *             bin - the bin to which the connection maps
 *             references - the number of references to place on the descriptor initially
 * Returns: Nothing.
 * Author: shouse, 10.4.01
 * Notes:
 */
VOID Load_reset_dscr (PLOAD_CTXT lp, PBIN_STATE bp, PCONN_ENTRY ep, ULONG index, ULONG bin, SHORT references)
{
    /* Reset some of the descriptor state to its defaults. */
    ep->ref_count = references;
    ep->timeout = 0;

    /* Clear all descriptor flags except ALLOCATED. */
    ep->flags &= NLB_CONN_ENTRY_FLAGS_ALLOCATED;

    /* Store the hashing results in the descriptor. */
    ep->index = (USHORT)index;
    ep->bin = (UCHAR)bin;

    /* Queue entry into the recovery queue. */
    Queue_enq(&(lp->conn_rcvryq), &(ep->rlink));
    
    /* Queue entry into port group queue. */
    Queue_enq(&(bp->connq), &(ep->blink));
    
    /* Update the connection counters, etc. */
    Load_note_conn_up(lp, bp, bin);
}

/* 
 * Function: Load_put_dscr
 * Description: This function completely releases a descriptor for later
 *              use.  This includes unlinking from all appropriate queues,
 *              decrementing appropriate counters and re-setting some 
 *              descriptor state.  Callers of this function should call 
 *              CVY_CONN_CLEAR to mark the descriptor as unused.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             bp - a pointer to the port rule on which the connection was active
 *             ep - a pointer to the connection descriptor to release
 * Returns: Nothing.
 * Author: shouse, 10.4.01
 * Notes: Callers MUST call CVY_CONN_CLEAR to mark the descriptor unused!
 *        Do NOT access ep after calling this function (it may have been freed)!
 */
VOID Load_put_dscr (PLOAD_CTXT lp, PBIN_STATE bp, PCONN_ENTRY ep)
{
    PCONN_DESCR dp;

    /* Unlink from the bin/dirty and recovery/timeout queues. */
    Link_unlink(&(ep->rlink));
    Link_unlink(&(ep->blink));

    /* If the connection is NOT dirty, then we have to update
       the connection counts, etc.  If it is dirty then the 
       relevant counters have already been reset. */
    if (!(ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY))
    {
        Load_note_conn_down(lp, bp, (ULONG)ep->bin);
    }    
    else
    {
        /* If we're destroying a dirty connection, update the dirty counters. */
        lp->dirty_bin[ep->bin]--;
        lp->num_dirty--;

        /* If this was the last dirty connection, turn off the cleanup waiting flag. */
        if (lp->num_dirty == 0)
            lp->cln_waiting = FALSE;
    }

    /* If this is an allocated (and therefore queued) descriptor,
       there is some additional cleanup to do. */
    if (ep->flags & NLB_CONN_ENTRY_FLAGS_ALLOCATED) 
    {   
        /* Get a pointer to the parent structure. */   
        dp = STRUCT_PTR(ep, CONN_DESCR, entry);
        
        UNIV_ASSERT(dp->code == CVY_DESCCODE);
        
        /* Unlink from the connection queue and put the descriptor back on the free 
           queue.  We MUST do this before calling NdisFreeToBlockPool, as the pool
           implementation will stomp on link because we allow it to re-use that piece
           of our memory to link free blocks.  Since this operation may also result 
           the memory being freed (actually, pages will NEVER be freed immediately,
           but don't tempt fate), do NOT touch the descriptor once we've freed it
           back to the pool.  CALLERS OF THIS FUNCTION SHOULD TAKE THE SAME PRECAUTION
           AND NOT TOUCH THE DESCRIPTOR AFTER CALLING THIS FUNCTION. */
        Link_unlink(&(dp->link));

        /* Free the descriptor back to the fixed-size block pool. */
        NdisFreeToBlockPool((PUCHAR)dp);

        /* Decrement the number of outstanding descriptors from the pool. */
        lp->num_dscr_out--;
    }
}

/* 
 * Function: Load_get_dscr
 * Description: This function finds a descriptor to be used for a new connection
 *              by any available means; this includes an available free descriptor,
 *              allocating new descriptors if necessary, or as a last resort,
 *              cannibalizing an existing, in-use descriptor.  If it succeeds, it
 *              returns a pointer to the descriptor; otherwise, it returns NULL to
 *              indicate the failure to locate an available descriptor.  Callers of
 *              this function should call CVY_CONN_SET upon success to mark the 
 *              descriptor as used and fill in the connection parameters.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             bp - a pointer to the port rule on which the connection is being established
 *             index - the connection queue index
 *             bin - the bin to which the connection belongs
 * Returns: PCONN_ENTRY - a pointer to the new descriptor, or NULL if failed
 * Author: shouse, 10.4.01
 * Notes: Callers of this function MUST call CVY_CONN_SET to mark the descriptor
 *        active and to set the connection parameters (IPs, ports, protocol).
 */
PCONN_ENTRY Load_get_dscr (PLOAD_CTXT lp, PBIN_STATE bp, ULONG index, ULONG bin)
{
    PCONN_DESCR dp = NULL;
    PCONN_ENTRY ep = NULL;
    QUEUE *     qp;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD(lp, MAIN_CTXT, load);

    /* Get a pointer to the connection entry for this hash ID. */
    ep = &(lp->hashed_conn[index]);

    /* Get a pointer to the conneciton queue. */
    qp = &(lp->connq[index]);

    /* If hash entry table is not available, setup and enqueue a new entry. */
    if (CVY_CONN_IN_USE(ep)) {
        /* Get a pointer to a free descriptor. */
        if ((lp->free_dscr_pool != NULL) && (lp->num_dscr_out < lp->max_dscr_out)) 
        {
            /* Allocate a descriptor from the fixed-size block pool. */
            dp = (PCONN_DESCR)NdisAllocateFromBlockPool(lp->free_dscr_pool);

            if (dp == NULL) {
                /* Allocation failed, log a message and bail out. */
                if (!(lp->alloc_failed)) {
                    TRACE_CRIT("%!FUNC! Error allocating connection descriptors");
                    LOG_MSG(MSG_ERROR_MEMORY, MSG_NONE);
                    lp->alloc_failed = TRUE;
                }
                
                return NULL;
            }
            
            /* Initialize the fixed-size block (connection descriptor). */
            Load_init_fsb(lp, dp);
            
            UNIV_ASSERT(dp->code == CVY_DESCCODE);
            
            /* Increment the count of outstading descriptors from the fixed-size block pool. */
            lp->num_dscr_out++;
            
            /* There was a free descriptor, so setup the connection entry pointer. */
            ep = &(dp->entry);
            
            UNIV_ASSERT(ep->code == CVY_ENTRCODE);
        }
#if defined (NLB_TCP_NOTIFICATION)
        /* If notification is turned ON, we do NOT cannibalize descriptors. */
        else if (!NLB_NOTIFICATIONS_ON())
#else
        else
#endif
        {

            /* If we have reached the allocation limit, start taking connection descriptors from
               the timeout or recovery queues since they are likely to be stale and very old. */
            PBIN_STATE rbp;
            LINK *     rlp;

            /* We were unable to allocation more connection descriptors and we will
               be forced to cannibalize a connection descriptor already in use.  Warn
               the administrator that they should consider allowing NLB to allocate
               more connection descriptors. */
            if (!(lp->alloc_inhibited)) {
                TRACE_CRIT("%!FUNC! All descriptors have been allocated and are in use");
                LOG_MSG(MSG_WARN_DESCRIPTORS, CVY_NAME_MAX_DSCR_ALLOCS);
                lp->alloc_inhibited = TRUE;
            }
            
            TRACE_INFO("%!FUNC! Attempting to take a connection descriptor from the TCP timeout queue");
            
            /* Dequeue a descriptor from the TCP timeout queue.  Cannibalize this queue
               first because (i) its the most likely to have an available descriptor, 
               (ii) it should be the least disruptive because the connection has been 
               terminated AND the timeout for TCP is very short. */
            rlp = (LINK *)Queue_deq(&(lp->tcp_expiredq));
            
            if (rlp == NULL) {
                
                TRACE_INFO("%!FUNC! Attempting to take a connection descriptor from the IPSec timeout queue");
                
                /* Dequeue a descriptor from the IPSec timeout queue.  While it is
                   true that descriptors on this queue are theoretically closed,
                   since IPSec cannot be sure that not upper-level protocols still
                   have state at the time a Main Mode SA expires and NLB is notified,
                   these connections are non-trivially likely to regenerate, so it
                   is necessary to keep the state around for a long time (24 hours
                   by default).  Therefore, we cannibalize this timeout queue last
                   as it is the most likely to be disruptive, aside from the revovery
                   queue. */
                rlp = (LINK *)Queue_deq(&(lp->ipsec_expiredq));
                
                if (rlp == NULL) {
                    
                    TRACE_INFO("%!FUNC! Attempting to take a connection descriptor from the recovery queue");
                    
                    /* Dequeue a descriptor from the recovery queue.  Since these are 
                       "live" connections, we take descriptors from this queues as a 
                       last resort. */
                    rlp = (LINK *)Queue_deq(&(lp->conn_rcvryq));
                    
                    /* No descriptors are available anywhere - this should NEVER happen, but. */
                    if (rlp == NULL) return NULL;
                }
            }
            
            TRACE_INFO("%!FUNC! Successfull cannibalized a connection descriptor");
            
            /* Grab a pointer to the connection entry. */
            ep = STRUCT_PTR(rlp, CONN_ENTRY, rlink);
            
            UNIV_ASSERT(ep->code == CVY_ENTRCODE);
            
            if (ep->flags & NLB_CONN_ENTRY_FLAGS_ALLOCATED) {
                /* Unlink allocated descriptors from the hash table queue if necessary 
                   and set dp so that code below will put it back in the right hash queue. */
                dp = STRUCT_PTR(ep, CONN_DESCR, entry);

                UNIV_ASSERT(dp->code == CVY_DESCCODE);
                
                Link_unlink(&(dp->link));
            } else {
                dp = NULL;
            }
            
            /* Dirty connections are not counted, so we don't need to update these counters. */
            if (!(ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY)) 
            {
                /* Find out which port group we are on so we can clean up its counters. */
                rbp = Load_pg_lookup(lp, ep->svr_ipaddr, ep->svr_port, IS_TCP_PKT(ep->protocol));
                
                /* Update the connection counters, etc. to remove all knowledge of this 
                   "old" connection that we're cannibalizing. */
                Load_note_conn_down(lp, rbp, (ULONG)ep->bin);
            } 
            else 
            {
                /* If we're cannibalizing a dirty connection, update the dirty counters. */
                lp->dirty_bin[ep->bin]--;
                lp->num_dirty--;
                
                /* If this was the last dirty connection, turn off the cleanup waiting flag. */
                if (lp->num_dirty == 0)
                    lp->cln_waiting = FALSE;
            }
            
            Link_unlink(&(ep->blink));
            
            /* Mark the descriptor as unused. */
            CVY_CONN_CLEAR(ep);
        }
#if defined (NLB_TCP_NOTIFICATION)
        /* There are no free descriptors, and we refuse to cannibalize. */
        else
        {
            /* We were unable to allocation more connection descriptors and we will
               be forced to cannibalize a connection descriptor already in use.  Warn
               the administrator that they should consider allowing NLB to allocate
               more connection descriptors. */
            if (!(lp->alloc_inhibited)) {
                TRACE_CRIT("%!FUNC! All descriptors have been allocated and are in use");
                LOG_MSG(MSG_WARN_DESCRIPTORS, CVY_NAME_MAX_DSCR_ALLOCS);
                lp->alloc_inhibited = TRUE;
            }

            return NULL;
        }

        /* If notification is ON, then we're sure that descriptors here are dynamic,
           and therefore will ALWAYS have to be re-queued.  If notification is OFF, 
           that depends on whether a potentially cannibalized descriptor was dynamically
           allocated or not. */
        if (NLB_NOTIFICATIONS_ON())
        {
            UNIV_ASSERT(dp != NULL);

            /* Enqueue descriptor in hash table unless it's already a hash table entry (a recovered 
               connection might be in hash table, so make sure we do not end up queueing it). */
            UNIV_ASSERT(dp->code == CVY_DESCCODE);
            
            Queue_enq(qp, &(dp->link));
        }
        else
        {
#endif
            /* Enqueue descriptor in hash table unless it's already a hash table entry (a recovered 
               connection might be in hash table, so make sure we do not end up queueing it). */
            if (dp != NULL) {
                UNIV_ASSERT(dp->code == CVY_DESCCODE);
                
                Queue_enq(qp, &(dp->link));
            }
#if defined (NLB_TCP_NOTIFICATION)
        }
#endif

    }

    UNIV_ASSERT(ep->code == CVY_ENTRCODE);

    /* Reset the descriptor information. */
    Load_reset_dscr(lp, bp, ep, index, bin, 1);

    return ep;
}

/* 
 * Function: Load_timeout_dscr
 * Description: This function moves an active connection descriptor to
 *              the timeout state by dequeueing it from the recovery 
 *              queue, setting the appropriate timeout and moving it to
 *              the appropriate timeout queue, where it will remain active
 *              for some amount of time (configurable via the registry).
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             bp - a pointer to the port rule on which this connection is active
 *             ep - a pointer to the connection descriptor to timeout
 * Returns: Nothing.
 * Author: shouse, 10.4.01
 * Notes:
 */
VOID Load_timeout_dscr (PLOAD_CTXT lp, PBIN_STATE bp, PCONN_ENTRY ep)
{
    /* Virtual descriptors should NEVER get in this function. */
    UNIV_ASSERT(!(ep->flags & NLB_CONN_ENTRY_FLAGS_VIRTUAL));

    /* Take the descriptor  off of the recovery queue and move it to the appropriate
       timeout queue, based on protocol.  Each protocol has its own queue to avoid 
       the need for a sorted insert function, which is expensive. */
    Link_unlink(&(ep->rlink));
            
    /* Set the timeout based on the protocol and add it to the appropriate timeout queue. */
    switch (ep->protocol) {
    case TCPIP_PROTOCOL_TCP:
    case TCPIP_PROTOCOL_PPTP:
        /* If the user has specified a zero timeout, then simply destroy the descriptor. */
        if (!lp->tcp_timeout)
        {
            /* Clear the connection descriptor. */
            CVY_CONN_CLEAR(ep);
            
            /* Release the descriptor. */
            Load_put_dscr(lp, bp, ep);

            break;
        }

        /* The timeout is the current time, plus the timeout for this particular protocol. */
        ep->timeout = lp->clock_sec + lp->tcp_timeout;
        
        Queue_enq(&(lp->tcp_expiredq), &(ep->rlink));
        
#if defined (TRACE_DSCR)
        DbgPrint("Load_timeout_dscr: Moving TCP descriptor %p to the TCP timeout queue: clock=%u, timeout=%d", ep, lp->clock_sec, ep->timeout);
#endif
        
        break;
    case TCPIP_PROTOCOL_IPSEC1:
        /* If the user has specified a zero timeout, then simply destroy the descriptor. */
        if (!lp->ipsec_timeout)
        {
            /* Clear the connection descriptor. */
            CVY_CONN_CLEAR(ep);
            
            /* Release the descriptor. */
            Load_put_dscr(lp, bp, ep);

            break;
        }

        /* The timeout is the current time, plus the timeout for this particular protocol. */
        ep->timeout = lp->clock_sec + lp->ipsec_timeout;
        
        Queue_enq(&(lp->ipsec_expiredq), &(ep->rlink));
        
#if defined (TRACE_DSCR)
        DbgPring("Load_timeout_dscr: Moving IPSec descriptor %p to the IPSec timeout queue: clock=%u, timeout=%u", ep, lp->clock_sec, ep->timeout);
#endif
        
        break;
    default:
        
#if defined (TRACE_DSCR)
        DbgPrint("Load_timeout_dscr: Invalid descriptor protocol (%u).  Removing descriptor %p immediately.", ep->protocol, ep);
#endif
        
        /* Although this should never happen, clean up immediately
           if the protocol in the descriptor is invalid.  Note that
           virtual descriptors, such as GRE, should NEVER be timed 
           out, and therefore should not enter this function. */
        UNIV_ASSERT(0);
        
        /* Clear the connection descriptor. */
        CVY_CONN_CLEAR(ep);
    
        /* Release the descriptor. */
        Load_put_dscr(lp, bp, ep);
                
        break;
    }
}

/* 
 * Function: Load_flush_dscr
 * Description: This function will flush out any descriptor that may be lying around
 *              for the given IP tuple.  This may happen as a result of a RST being
 *              sent on another adapter, which NLB did not see and therefore did not
 *              properly destroy the state for.  This function is called on all incoming
 *              SYN packets to remove this stale state.  For PPTP/IPSec connections, it is 
 *              also necessary to update any matching virtual descriptor found.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             bp - a pointer to the port rule on which this connection is active
 *             index - the connection queue index
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 * Returns: Nothing.
 * Author: shouse, 1.7.02
 * Notes: 
 */
VOID Load_flush_dscr (
    PLOAD_CTXT      lp,
    PBIN_STATE      bp,
    ULONG           index,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol)
{
    PCONN_ENTRY ep;             /* Pointer to connection entry. */
    ULONG       vindex;
    ULONG       hash;
    SHORT       references = 0;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    /* Look for an existing matching connection descriptor. */
    ep = Load_find_dscr(lp, index, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);
    
    /* If not match was found, or the descriptor is already dirty, there's nothing to do. */
    if ((ep != NULL) && !(ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY)) {
            
        UNIV_ASSERT(ep->ref_count >= 0);

        /* Note the number of references on this descriptor. */
        references = ep->ref_count;

        /* Mark the descriptor dirty and either free it or move it to
           the dirty descriptor queue for subsequent cleanup. */
        Load_soil_dscr(lp, bp, ep);

        /* Update the connection counters on the port rule and load module.
           Dirty descriptors update the connection counts when marked dirty,
           not when they are ultimately destroyed. */
        Load_note_conn_down(lp, bp, (ULONG)ep->bin);

        if (protocol == TCPIP_PROTOCOL_PPTP) {
            /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
            hash = Load_simple_hash(svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT);
            
            /* Our index in all connection arrays is this hash, modulo the array size. */
            vindex = hash % CVY_MAX_CHASH;

            /* Look for an existing matching connection descriptor. */
            ep = Load_find_dscr(lp, vindex, svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE);
            
            /* If not match was found, or the descriptor is already dirty, there's nothing to do. */
            if ((ep != NULL) && !(ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY)) {
                
                UNIV_ASSERT(ep->flags & NLB_CONN_ENTRY_FLAGS_VIRTUAL);
                UNIV_ASSERT(ep->ref_count > 0);
                
                /* If the descriptor has more references than the "parent" 
                   descriptor, then we don't want to mark it dirty, or we'll
                   affect the traffic of other connections sharing this 
                   descriptor.  Otherwise, if we account for all references
                   on the virtual descriptor, mark it dirty. */
                if (ep->ref_count <= references) {
                    /* Mark the descriptor dirty and either free it or move it to
                       the dirty descriptor queue for subsequent cleanup. */
                    Load_soil_dscr(lp, bp, ep);
                    
                    /* Update the connection counters on the port rule and load module.
                       Dirty descriptors update the connection counts when marked dirty,
                       not when they are ultimately destroyed. */
                    Load_note_conn_down(lp, bp, (ULONG)ep->bin);
                }
            }
        }
        else if (protocol == TCPIP_PROTOCOL_IPSEC1) {
            /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
            hash = Load_simple_hash(svr_ipaddr, IPSEC_CTRL_PORT, client_ipaddr, IPSEC_CTRL_PORT);
            
            /* Our index in all connection arrays is this hash, modulo the array size. */
            vindex = hash % CVY_MAX_CHASH;

            /* Look for an existing matching connection descriptor. */
            ep = Load_find_dscr(lp, vindex, svr_ipaddr, IPSEC_CTRL_PORT, client_ipaddr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC_UDP);

            /* If not match was found, or the descriptor is already dirty, there's nothing to do. */
            if ((ep != NULL) && !(ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY)) {

                UNIV_ASSERT(ep->flags & NLB_CONN_ENTRY_FLAGS_VIRTUAL);
                UNIV_ASSERT(ep->ref_count > 0);

                /* If the descriptor has more references than the "parent" 
                   descriptor, then we don't want to mark it dirty, or we'll
                   affect the traffic of other connections sharing this 
                   descriptor.  Otherwise, if we account for all references
                   on the virtual descriptor, mark it dirty. */
                if (ep->ref_count <= references) {
                    /* Mark the descriptor dirty and either free it or move it to
                       the dirty descriptor queue for subsequent cleanup. */
                    Load_soil_dscr(lp, bp, ep);
                    
                    /* Update the connection counters on the port rule and load module.
                       Dirty descriptors update the connection counts when marked dirty,
                       not when they are ultimately destroyed. */
                    Load_note_conn_down(lp, bp, (ULONG)ep->bin);
                }
            }
        }

        /* If at least one descriptor has been marked dirty, restart the cleanup timer. */
        if (lp->cln_waiting)
            lp->cur_time = 0;
    }
}

/* 
 * Function: Load_create_dscr
 * Description: This function creates and sets up a new descriptor for a given connection.
 *              The input connection entry pointer is the "existing" descriptor found by
 *              the caller, which can be (probably will be) NULL; in that case, a new 
 *              descriptor needs to be acquired and initialized.  If a descriptor already
 *              exisits, it is updated or cleansed, depending on its state.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             bp - a pointer to the port rule on which this connection is active
 *             ep - a pointer to the connection descriptor, if one was already found
 *             index - the connection queue index
 *             bin - the bin to which the connection maps (Map % 60)
 * Returns: PCONN_ENTRY - a pointer to the connection entry
 * Author: 
 * Notes:
 */
PCONN_ENTRY Load_create_dscr (
    PLOAD_CTXT      lp,
    PBIN_STATE      bp,
    PCONN_ENTRY     ep,
    ULONG           index,
    ULONG           bin)
{
    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    /* If we don't have a connection match, setup a new connection entry. */
    if (ep == NULL) {

        /* Get a new descriptor. */
        ep = Load_get_dscr(lp, bp, index, bin);
        
        /* If we can't find a descriptor, something is severely wrong - bail out. */
        if (ep == NULL) return NULL;
        
        UNIV_ASSERT(ep->code == CVY_ENTRCODE);
        
    /* Otherwise, we have a match; clean up conn entry if dirty since we have a
       new connection, although TCP/IP will likely reject it if it has stale state
       from another connection. */
    } else {
        
        UNIV_ASSERT(ep->code == CVY_ENTRCODE);
        
        if (ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY) {
            
            /* If we're re-using a connection descriptor already
               in use, then we need to pull it off the recovery/
               timeout queue because it might have been previously 
               added to the timeout queue and we don't want it 
               spontaneously expiring on us. */
            Link_unlink(&(ep->rlink));
            
            /* Unlink the descriptor from the dirty queue. */
            Link_unlink(&(ep->blink));

            /* If we cleansing a dirty connection, update the dirty counters. */
            lp->dirty_bin[ep->bin]--;
            lp->num_dirty--;
            
            /* If this was the last dirty connection, turn off the cleanup waiting flag. */
            if (lp->num_dirty == 0)
                lp->cln_waiting = FALSE;
            
            /* Reset the dirty descriptor and re-use it for this connection. */
            Load_reset_dscr(lp, bp, ep, index, bin, ep->ref_count++);
            
        } else {

            ep->timeout = 0;
            
            /* If we're re-using a connection descriptor already
               in use, then we need to pull it off the recovery/
               timeout queue and re-enqueue it on the recoevry 
               queue because it might have been previously added
               to the timeout queue and we don't want it spon-
               taneously expiring on us. */
            Link_unlink(&(ep->rlink));
            Queue_enq(&(lp->conn_rcvryq), &(ep->rlink));

            ep->ref_count++;

        }
    }

    return ep;
}

/* 
 * Function: Load_destroy_dscr
 * Description: This function "destroys" an existing descriptor.  If the operation is
 *              a RST, it is immediately destroyed; if it is a FIN, the reference count
 *              is decremented and depending on the new count, the descriptor is either
 *              moved to a timeout queue or left alone. 
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             bp - a pointer to the port rule on which this connection is active
 *             ep - a pointer to the connection descriptor if one was already found
 *             conn_status - whether this is a RST or a FIN
 * Returns: ULONG - the number of remaining references on the descriptor.
 * Author: shouse, 1.7.02
 * Notes: 
 */
ULONG Load_destroy_dscr (
    PLOAD_CTXT      lp,
    PBIN_STATE      bp,
    PCONN_ENTRY     ep,
    ULONG           conn_status)
{
    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    /* If no descriptor was provided, bail out.  This should NOT be called 
       with a NULL descriptor, but we have to handle it anyway. */
    if (ep == NULL) return 0;

    UNIV_ASSERT(ep->ref_count >= 0);
    
    /* This descriptor was already moved to the expired queue - must be 
       that we received a retransmitted FIN on this connection, or the 
       reference count of a virtual descriptor was skewed. */
    if (!ep->ref_count) {
        
        UNIV_ASSERT(ep->timeout != 0);

        /* If this is a RST notification, then destroy the state now.
           If its a FIN, just ignore it.  Either way, return zero. */
        if (conn_status == CVY_CONN_RESET) {
            
            /* Clear the connection descriptor. */
            CVY_CONN_CLEAR(ep);
            
            /* Release the descriptor. */
            Load_put_dscr(lp, bp, ep);
        }
        
        /* Return - the descriptor already has zero references (no update needed). */
        return 0;
    }
        
    UNIV_ASSERT(ep->ref_count > 0);
        
    /* Decrement the reference count by one. */
    ep->ref_count--;
    
    UNIV_ASSERT(ep->ref_count >= 0);
    
    /* If there are still references on this descriptor, 
       then its not ready to be destroyed yet, so we'll
       keep it around and exit here. */
    if (ep->ref_count > 0) return (ep->ref_count);
    
    /* If this is a RST, or if the descriptor is virtual or dirty, destroy the descriptor 
       now.  There is no need to timeout virtual GRE or IPSec/UDP descriptors; they can be
       immediate destroyed.  Of course, if the descriptor has already been marked dirty,
       then we can destroy it now that the reference count has reached zero. */
    if ((conn_status == CVY_CONN_RESET) || (ep->flags & NLB_CONN_ENTRY_FLAGS_VIRTUAL) || (ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY)) {
        
        /* Clear the connection descriptor. */
        CVY_CONN_CLEAR(ep);
        
        /* Release the descriptor. */
        Load_put_dscr(lp, bp, ep);
        
    /*  However, conventional descriptors, such as TCP or IPSec, should be timed-out gracefully. */
    } else {
        
        /* Otherwise, we're destroying it.  Take the descriptor 
           off of the recovery queue and move it to the appropriate
           timeout queue, based on protocol.  Each protocol has
           its own queue to avoid the need for a sorted insert
           function, which is expensive. */
        Load_timeout_dscr(lp, bp, ep);
        
    }
 
    /* No references left on the descriptor; it was destroyed or timed-out. */
    return 0;
}

/* 
 * Function: Load_packet_check
 * Description: This function determines whether or not to take a data packet
 *              in the IP stream identified by the IP tuple in question.
 *              Protocols that are session-less depend only on the hashing
 *              result and the ownership map.  Session-ful protocols may need
 *              to perform a descriptor look-up if ambiguity exists.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 *             limit_map_fn - whether or not to include server-side parameters in hashing
 *             reverse_hash - whether or not to reverse client and server during hashing
 * Returns: BOOLEAN - do we accept the packet? (TRUE = yes)
 * Author: bbain, shouse, 10.4.01
 * Notes:
 */
BOOLEAN Load_packet_check(
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    BOOLEAN         limit_map_fn,
    BOOLEAN         reverse_hash)
{
    PBIN_STATE      bp;
    ULONG           hash;
    ULONG           index;
    ULONG           bin;
    IRQLEVEL        irql;
    PMAIN_CTXT      ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);
    BOOLEAN         is_tcp_pkt = IS_TCP_PKT(protocol);
    BOOLEAN         is_session_pkt = IS_SESSION_PKT(protocol);
    BOOLEAN         acpt = FALSE;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    TRACE_FILTER("%!FUNC! Enter: lp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u, limit map = %u, reverse hash = %u", 
                 lp, IP_GET_OCTET(svr_ipaddr, 0), IP_GET_OCTET(svr_ipaddr, 1), IP_GET_OCTET(svr_ipaddr, 2), IP_GET_OCTET(svr_ipaddr, 3), svr_port, 
                 IP_GET_OCTET(client_ipaddr, 0), IP_GET_OCTET(client_ipaddr, 1), IP_GET_OCTET(client_ipaddr, 2), IP_GET_OCTET(client_ipaddr, 3), client_port, 
                 protocol, limit_map_fn, reverse_hash);

    /* If the load module is inactive, drop the packet and return here. */
    if (!lp->active) {

        TRACE_FILTER("%!FUNC! Drop packet - load module is inactive");

        acpt = FALSE;
        goto exit;
    }

    /* Increment count of pkts handled. */
    lp->pkt_count++;

    /* Find the port rule for this connection. */
    bp = Load_pg_lookup(lp, svr_ipaddr, svr_port, is_tcp_pkt);

    /* Make sure that Load_pg_lookup properly handled protocol specific rules. */
    UNIV_ASSERT((is_tcp_pkt && bp->prot != CVY_UDP) || (!is_tcp_pkt && bp->prot != CVY_TCP));

    /* Handle CVY_NEVER mode immediately. */
    if (bp->mode == CVY_NEVER) {
        /* Increment the dropped packet count. */
        bp->packets_dropped++;

        TRACE_FILTER("%!FUNC! Drop packet - port rule %u is disabled\n", bp->index);

        acpt = FALSE;
        goto exit;
    }

    /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
    hash = Load_simple_hash(svr_ipaddr, svr_port, client_ipaddr, client_port);

    index = hash % CVY_MAX_CHASH;

    /* Compute the hash. */
    hash = Load_complex_hash(svr_ipaddr, svr_port, client_ipaddr, client_port, bp->affinity, reverse_hash, limit_map_fn);

    bin = hash % CVY_MAXBINS;

    LOCK_ENTER(&(lp->lock), &irql);

    /* Check bin for residency and all other hosts now idle on their bins; in this case
       and if we do not have dirty connections, we must be able to handle the packet. */

    if (((bp->cmap & (((MAP_T) 1) << bin)) != 0) && (!is_session_pkt || (((bp->all_idle_map & (((MAP_T) 1) << bin)) != 0) && (!(lp->cln_waiting))))) {
        /* Note that we may have missed a connection, but it could also be a stale
           packet so we can't start tracking the connection now. */

        TRACE_FILTER("%!FUNC! Accept packet - packet owned unconditionally: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                     "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                     bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);

        /* Increment the accepted packet count. */
        bp->packets_accepted++;

        acpt = TRUE;
        goto unlock;
    
    /* Important note: Virtual descriptors that are not session-based and return
       FALSE for IS_SESSION_PKT() use this case to check for a connection descriptor
       match. (Example: UDP subsequent fragments within IPSec tunnels of protocol
       type TCPIP_PROTOCOL_IPSEC_UDP) Do not disable this code for non-session
       protocols. */

    /* Otherwise, if we have an active connection for this bin or if we have dirty
       connections for this bin and the bin is resident, check for a match. */

    } else if (bp->nconn[bin] > 0 || (lp->cln_waiting && lp->dirty_bin[bin] && ((bp->cmap & (((MAP_T) 1) << bin)) != 0))) {
        PCONN_ENTRY ep;

        /* Look for an existing matching connection descriptor. */
        ep = Load_find_dscr(lp, index, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);

        /* If we can't find one, we don't own the connection. */
        if (ep == NULL) {

            TRACE_FILTER("%!FUNC! Drop packet - packet not owned by this host: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                         "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                         bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);
            
            /* Increment the dropped packet count. */
            bp->packets_dropped++;
            
            acpt = FALSE;
            goto unlock;
        }

        UNIV_ASSERT(ep->code == CVY_ENTRCODE);

        /* If connection was dirty, just block the packet since TCP/IP may have stale
           connection state for a previous connection from another host. */
        if (ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY) {

            TRACE_FILTER("%!FUNC! Drop packet - block dirty connections (%p): Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                         "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                         ep, bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);
            
            /* Increment the dropped packet count. */
            bp->packets_dropped++;
            
            acpt = FALSE;
            goto unlock;
        }
        
        TRACE_FILTER("%!FUNC! Accept packet - matching descriptor found (%p): Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                     "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                     ep, bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);
        
        /* Increment the accepted packet count. */
        bp->packets_accepted++;
        
        acpt = TRUE;
        goto unlock;
    }

    TRACE_FILTER("%!FUNC! Drop packet - packet not owned by this host: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                 "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                 bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);

    /* Increment the dropped packet count. */
    bp->packets_dropped++;

    acpt = FALSE;
    
 unlock:

    LOCK_EXIT(&(lp->lock), irql);

 exit:

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

/* 
 * Function: Load_conn_advise
 * Description: This function determines whether or not to accept this packet, 
 *              which represents the beginning or end of a session-ful connection.
#if !defined (NLB_TCP_NOTIFICATION)
 *              If the connection is going up, and is successful, this function
 *              creates state to track the connection.  If the connection is 
 *              going down, this function removes the state for tracking the 
 *              connection.
#endif
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 *             conn_status - whether the connection is going UP, DOWN, or being RESET
 *             limit_map_fn - whether or not to include server-side parameters in hashing
 *             reverse_hash - whether or not to reverse client and server during hashing
 * Returns: BOOLEAN - do we accept the packet (TRUE = yes)
 * Author: bbain, shouse, 10.4.01
 * Notes:
 */
BOOLEAN Load_conn_advise(
    PLOAD_CTXT  lp,
    ULONG       svr_ipaddr,
    ULONG       svr_port,
    ULONG       client_ipaddr,
    ULONG       client_port,
    USHORT      protocol,
    ULONG       conn_status,
    BOOLEAN     limit_map_fn,
    BOOLEAN     reverse_hash)
{
    ULONG       hash;
    ULONG       vindex;
    ULONG       index;
    ULONG       bin;
    PBIN_STATE  bp;
    PCONN_ENTRY ep;
    IRQLEVEL    irql;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);
    BOOLEAN     is_tcp_pkt = IS_TCP_PKT(protocol);
    BOOLEAN     acpt = TRUE;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);
 
    TRACE_FILTER("%!FUNC! Enter: lp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u, status = %u, limit map = %u, reverse hash = %u",
                 lp, IP_GET_OCTET(svr_ipaddr, 0), IP_GET_OCTET(svr_ipaddr, 1), IP_GET_OCTET(svr_ipaddr, 2), IP_GET_OCTET(svr_ipaddr, 3), svr_port, 
                 IP_GET_OCTET(client_ipaddr, 0), IP_GET_OCTET(client_ipaddr, 1), IP_GET_OCTET(client_ipaddr, 2), IP_GET_OCTET(client_ipaddr, 3), client_port, 
                 protocol, conn_status, limit_map_fn, reverse_hash);

    /* If the load module is inactive, drop the packet and return here. */
    if (!lp->active) {

        TRACE_FILTER("%!FUNC! Drop packet - load module is inactive");

        acpt = FALSE;
        goto exit;
    }

    /* Increment count of pkts handled. */
    lp->pkt_count++;

    /* Find the port rule for this connection. */
    bp = Load_pg_lookup(lp, svr_ipaddr, svr_port, is_tcp_pkt);

    /* Handle CVY_NEVER immediately. */
    if (bp->mode == CVY_NEVER) {
        /* Increment the dropped packet count. */
        bp->packets_dropped++;

        TRACE_FILTER("%!FUNC! Drop packet - port rule %u is disabled\n", bp->index);

        acpt = FALSE;
        goto exit;
    }

    /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
    hash = Load_simple_hash(svr_ipaddr, svr_port, client_ipaddr, client_port);

    index = hash % CVY_MAX_CHASH;

    /* Compute the hash. */
    hash = Load_complex_hash(svr_ipaddr, svr_port, client_ipaddr, client_port, bp->affinity, reverse_hash, limit_map_fn);

    bin = hash % CVY_MAXBINS;

    /* If this is a connection up notification, first clean out any old state that may exist for this 
       connection BEFORE we load-balance IFF we do NOT own the bucket to which the connection maps.
       If we are not the bucket owner, the somebody else probably is; since we know that they will 
       accept the new connection, we need to flush out any state that we may have lying around.
       This cleans out stale state that may have been left around by falling out of sync with TCP/IP.  
       Note that re-transmitted SYNs can wreak havoc here if the bucket map has shifted since the 
       first SYN, however, since the other host has no way of knowing that the second SYN is a 
       re-transmit, there's nothing we can do about it anyway. */
    if ((conn_status == CVY_CONN_UP) && ((bp->cmap & (((MAP_T) 1) << bin)) == 0)) {
        LOCK_ENTER(&(lp->lock), &irql);
        
        /* If this is a SYN, flush out any old descriptor that may be lying around for this connection. */
        Load_flush_dscr(lp, bp, index, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);
        
        LOCK_EXIT(&(lp->lock), &irql);
    }

    /* If this connection is not in our current map and it is not a connection
       down notification for a non-idle bin, just filter it out. */
    if ((bp->cmap & (((MAP_T) 1) << bin)) == 0 && (!((conn_status == CVY_CONN_DOWN || conn_status == CVY_CONN_RESET) && bp->nconn[bin] > 0))) {

        TRACE_FILTER("%!FUNC! Drop packet - packet not owned by this host: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                     "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                     bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);

        /* Increment the dropped packet count. */
        bp->packets_dropped++;

        acpt = FALSE;
        goto exit;
    }

#if defined (NLB_TCP_NOTIFICATION)
    /* DO NOT create a descriptor until TCP or IPSec tells us to via a connection notification. If TCP 
       notification is OFF, then only exit early if its an IPSec SYN. */
    if ((conn_status == CVY_CONN_UP) && (NLB_NOTIFICATIONS_ON() || (protocol == TCPIP_PROTOCOL_IPSEC1))) {

        TRACE_FILTER("%!FUNC! Accept packet - SYN owned by this host: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                     "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                     bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);
#else
    /* DO NOT create a descriptor until IPSec tells us to via a connection notification IOCTL. */
    if ((conn_status == CVY_CONN_UP) && (protocol == TCPIP_PROTOCOL_IPSEC1)) {

        TRACE_FILTER("%!FUNC! Accept packet - IPSec SYN owned by this host: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                     "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                     bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);
#endif

        /* Increment the accepted packet count. */
        bp->packets_accepted++;

        acpt = TRUE;
        goto exit;
    }

    LOCK_ENTER(&(lp->lock), &irql);

    /* Look for an existing matching connection descriptor. */
    ep = Load_find_dscr(lp, index, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);
    
    /* If we see a new connection, handle it. */

    if (conn_status == CVY_CONN_UP) {

        /* Create a new connection descriptor to track this connection. */
        ep = Load_create_dscr(lp, bp, ep, index, bin);

        /* If, for some reason, we were unable to create state for this connection, bail out here. */
        if (ep == NULL) {

            TRACE_FILTER("%!FUNC! Drop packet - no available descriptors: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                         "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                         bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);
            
            /* Increment the dropped packet count. */
            bp->packets_dropped++;

            acpt = FALSE;
            goto unlock;
        }

        /* Set the connection information in the descriptor. */
        CVY_CONN_SET(ep, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);

        /* If this is a new PPTP tunnel, create or update a virtual descriptor to track the GRE data packets. */
        if (protocol == TCPIP_PROTOCOL_PPTP) {
            /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
            hash = Load_simple_hash(svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT);
            
            /* Our index in all connection arrays is this hash, modulo the array size. */
            vindex = hash % CVY_MAX_CHASH;

            /* Look for an existing matching virtual connection descriptor. */
            ep = Load_find_dscr(lp, vindex, svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE);
            
            /* Create or update a virtual descriptor for the GRE traffic. */
            ep = Load_create_dscr(lp, bp, ep, vindex, bin);

            /* If we can't allocate the virtual descriptor, bail out, but don't fail. */
            if (ep == NULL) goto unlock;

            /* Set the connection information in the descriptor. */
            CVY_CONN_SET(ep, svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE);

            /* Set the virtual descriptor flag. */
            ep->flags |= NLB_CONN_ENTRY_FLAGS_VIRTUAL;
        }

    /* Otherwise, if a known connection is going down, remove our connection entry. */

    } else if ((conn_status == CVY_CONN_DOWN || conn_status == CVY_CONN_RESET) && (ep != NULL)) {

        /* If we found state for this connection, the bin is the bin from the descriptor,
           not the calculated bin, which may not even been accurate if the port rules have
           been modified since this connection was established. */
        bin = ep->bin;

        /* If connection was dirty, just block the packet since TCP/IP may have stale
           connection state for a previous connection from another host. */
        if (ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY) {

            TRACE_FILTER("%!FUNC! Drop packet - block dirty connections: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                         "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                         bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);
            
            /* Increment the dropped packet count. */
            bp->packets_dropped++;

            goto unlock;
        }
    
        /* Update the descriptor by destroying it or moving it to the appropriate timeout queue if no references remain. */
        (VOID)Load_destroy_dscr(lp, bp, ep, conn_status);
        
        /* If this is a PPTP tunnel going down, update the virtual GRE descriptor.  Virtual descriptors
           are ALWAYS de-referenced, not destroyed, even if the notification is a RST because these
           descriptors are potentially shared by multiple PPTP tunnels. */
        if (protocol == TCPIP_PROTOCOL_PPTP) {
            /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
            hash = Load_simple_hash(svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT);
            
            /* Our index in all connection arrays is this hash, modulo the array size. */
            vindex = hash % CVY_MAX_CHASH;
            
            /* Look for an existing matching virtual connection descriptor. */
            ep = Load_find_dscr(lp, vindex, svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE);
            
            /* Dereference the virtual GRE descriptor. */
            (VOID)Load_destroy_dscr(lp, bp, ep, conn_status);
        }

    /* Otherwise, we found no match for a FIN/RST packet - drop it. */

    } else {

        TRACE_FILTER("%!FUNC! Drop packet - no matching descriptor found: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                     "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                     bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);
        
        /* Increment the dropped packet count. */
        bp->packets_dropped++;

        acpt = FALSE;
        goto unlock;
    }
    
    TRACE_FILTER("%!FUNC! Accept packet - packet owned by this host: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                 "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                 bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);

    /* Increment the accepted packet count. */
    bp->packets_accepted++;

    // Exit here under one of these conditions:
    //   (i)  got a syn and added a descriptor
    //   (ii) got a fin or a reset and destroyed the descriptor 

    acpt = TRUE;

 unlock:

    LOCK_EXIT(&(lp->lock), irql);

 exit:

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
} 

/* 
 * Function: Load_conn_notify
 * Description: This function is nearly identical to Load_conn_advise, except
 *              for two important distinctions; (1) this function is a notification,
 *              not a request, so load-balancing decisions are not made here, and
 *              (2) packet handling statistics are not incremented here, as calls
 *              to this function rarely stem from processing a real packet.  For
 *              example, when a TCP SYN packet is received, main.c calls Load_conn_advise
 *              essentially asking, "hey, should accept this new connection i just 
 *              saw?"  While, when IPSec notifies NLB that a new Main Mode SA has just
 *              been established, main.c calls Load_conn_notify essentially dictating,
 *              "hey a new connection just went up, so whether you like it or not, 
 *              create state to track this connection."
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 *             conn_status - whether the connection is going UP, DOWN, or being RESET
 *             limit_map_fn - whether or not to include server-side parameters in hashing
 *             reverse_hash - whether or not to reverse client and server during hashing
 * Returns: BOOLEAN - was i able to successfully update my state (TRUE = yes)
 * Author: shouse, 10.4.01
 * Notes:
 */
BOOLEAN Load_conn_notify (
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    ULONG           conn_status,
    BOOLEAN         limit_map_fn,
    BOOLEAN         reverse_hash)
{
    ULONG       hash;
    ULONG       vindex;
    ULONG       index;
    ULONG       bin;
    PBIN_STATE  bp;
    PCONN_ENTRY ep;
    IRQLEVEL    irql;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);
    BOOLEAN     is_tcp_pkt = IS_TCP_PKT(protocol);
    BOOLEAN     acpt = TRUE;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);
 
    TRACE_FILTER("%!FUNC! Enter: lp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u, status = %u, limit map = %u, reverse hash = %u",
                 lp, IP_GET_OCTET(svr_ipaddr, 0), IP_GET_OCTET(svr_ipaddr, 1), IP_GET_OCTET(svr_ipaddr, 2), IP_GET_OCTET(svr_ipaddr, 3), svr_port, 
                 IP_GET_OCTET(client_ipaddr, 0), IP_GET_OCTET(client_ipaddr, 1), IP_GET_OCTET(client_ipaddr, 2), IP_GET_OCTET(client_ipaddr, 3), client_port, 
                 protocol, conn_status, limit_map_fn, reverse_hash);

    /* If the load module is inactive and this is a CONN_UP, drop the packet and return here. 
       If this is a notification for a CONN_DOWN or CONN_RESET, process it. */
    if ((!lp->active) && (conn_status == CVY_CONN_UP)) {

        TRACE_FILTER("%!FUNC! Drop packet - load module is inactive");

        acpt = FALSE;
        goto exit;
    }

    /* Find the port rule for this connection. */
    bp = Load_pg_lookup(lp, svr_ipaddr, svr_port, is_tcp_pkt);

    /* Handle CVY_NEVER immediately. */
    if (bp->mode == CVY_NEVER) {

        TRACE_FILTER("%!FUNC! Drop packet - port rule %u is disabled\n", bp->index);

        acpt = FALSE;
        goto exit;
    }

    /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
    hash = Load_simple_hash(svr_ipaddr, svr_port, client_ipaddr, client_port);

    index = hash % CVY_MAX_CHASH;

    /* Compute the hash. */
    hash = Load_complex_hash(svr_ipaddr, svr_port, client_ipaddr, client_port, bp->affinity, reverse_hash, limit_map_fn);

    bin = hash % CVY_MAXBINS;

    LOCK_ENTER(&(lp->lock), &irql);

    /* Look for an existing matching connection descriptor. */
    ep = Load_find_dscr(lp, index, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);
    
    /* If we see a new connection, handle it. */

    if (conn_status == CVY_CONN_UP) {

        /* Create a new connection descriptor to track this connection. */
        ep = Load_create_dscr(lp, bp, ep, index, bin);

        /* If, for some reason, we were unable to create state for this connection, bail out here. */
        if (ep == NULL) {

            TRACE_FILTER("%!FUNC! Drop packet - no available descriptors: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                         "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                         bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);
            
            acpt = FALSE;
            goto unlock;
        }

        /* Set the connection information in the descriptor. */
        CVY_CONN_SET(ep, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);

        /* If this is a new PPTP tunnel, create or update a virtual descriptor to track the GRE data packets. */
        if (protocol == TCPIP_PROTOCOL_PPTP) {
            /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
            hash = Load_simple_hash(svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT);
            
            /* Our index in all connection arrays is this hash, modulo the array size. */
            vindex = hash % CVY_MAX_CHASH;

            /* Look for an existing matching virtual connection descriptor. */
            ep = Load_find_dscr(lp, vindex, svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE);
            
            /* Create or update a virtual descriptor for the GRE traffic. */
            ep = Load_create_dscr(lp, bp, ep, vindex, bin);

            /* If we can't allocate the virtual descriptor, bail out, but don't fail. */
            if (ep == NULL) goto unlock;

            /* Set the connection information in the descriptor. */
            CVY_CONN_SET(ep, svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE);

            /* Set the virtual descriptor flag. */
            ep->flags |= NLB_CONN_ENTRY_FLAGS_VIRTUAL;
        }
        /* If this is a new IPSEC tunnel, create or update a virtual descriptor to track the UDP subsequent data fragments. */
        else if (protocol == TCPIP_PROTOCOL_IPSEC1) {
            /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
            hash = Load_simple_hash(svr_ipaddr, IPSEC_CTRL_PORT, client_ipaddr, IPSEC_CTRL_PORT);
            
            /* Our index in all connection arrays is this hash, modulo the array size. */
            vindex = hash % CVY_MAX_CHASH;

            /* Look for an existing matching virtual connection descriptor. */
            ep = Load_find_dscr(lp, vindex, svr_ipaddr, IPSEC_CTRL_PORT, client_ipaddr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC_UDP);
            
            /* Create or update a virtual descriptor for the UDP subsequent fragment traffic. */
            ep = Load_create_dscr(lp, bp, ep, vindex, bin);

            /* If we can't allocate the virtual descriptor, bail out, but don't fail. */
            if (ep == NULL) goto unlock;

            /* Set the connection information in the descriptor. */
            CVY_CONN_SET(ep, svr_ipaddr, IPSEC_CTRL_PORT, client_ipaddr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC_UDP);

            /* Set the virtual descriptor flag. */
            ep->flags |= NLB_CONN_ENTRY_FLAGS_VIRTUAL;
        }

    /* Otherwise, if a known connection is going down, remove our connection entry. */

    } else if ((conn_status == CVY_CONN_DOWN || conn_status == CVY_CONN_RESET) && (ep != NULL)) {

        /* If we found state for this connection, the bin is the bin from the descriptor,
           not the calculated bin, which may not even been accurate if the port rules have
           been modified since this connection was established. */
        bin = ep->bin;

        /* Update the descriptor by destroying it or moving it to the appropriate timeout queue if no references remain. */
        (VOID)Load_destroy_dscr(lp, bp, ep, conn_status);

        /* If this is a PPTP tunnel going down, update the virtual GRE descriptor.  Virtual descriptors
           are ALWAYS de-referenced, not destroyed, even if the notification is a RST because these
           descriptors are potentially shared by multiple PPTP tunnels. */
        if (protocol == TCPIP_PROTOCOL_PPTP) {
            /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
            hash = Load_simple_hash(svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT);
            
            /* Our index in all connection arrays is this hash, modulo the array size. */
            vindex = hash % CVY_MAX_CHASH;

            /* Look for an existing matching connection descriptor. */
            ep = Load_find_dscr(lp, vindex, svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE);
            
            /* Dereference the virtual GRE descriptor. */
            (VOID)Load_destroy_dscr(lp, bp, ep, conn_status);
        }

        /* If this is an IPSEC tunnel going down, update the virtual ISPEC_UDP descriptor. Virtual descriptors
           are ALWAYS de-referenced, not destroyed, even if the notification is a RST because these
           descriptors are potentially shared by multiple IPSEC tunnels. */
        
        else if (protocol == TCPIP_PROTOCOL_IPSEC1) {
            /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
            hash = Load_simple_hash(svr_ipaddr, IPSEC_CTRL_PORT, client_ipaddr, IPSEC_CTRL_PORT);
            
            /* Our index in all connection arrays is this hash, modulo the array size. */
            vindex = hash % CVY_MAX_CHASH;

            /* Look for an existing matching virtual connection descriptor. */
            ep = Load_find_dscr(lp, vindex, svr_ipaddr, IPSEC_CTRL_PORT, client_ipaddr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC_UDP);

            /* Dereference the virtual IPSec/UDP descriptor. */
            (VOID)Load_destroy_dscr(lp, bp, ep, conn_status);
        }

    /* Otherwise, we found no match for a FIN/RST packet - drop it. */

    } else {

        TRACE_FILTER("%!FUNC! Drop packet - no matching descriptor for RST/FIN: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                     "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                     bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);
        
        acpt = FALSE;
        goto unlock;
    }
    
    TRACE_FILTER("%!FUNC! Accept packet - packet owned by this host: Port rule = %u, Bin = %u, Current map = 0x%015I64x, " 
                 "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                 bp->index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);

    // Exit here under one of these conditions:
    //   (i)  got a syn and added a descriptor
    //   (ii) got a fin or a reset and destroyed the descriptor 

    acpt = TRUE;

 unlock:

    LOCK_EXIT(&(lp->lock), irql);

 exit:

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
} 

/* 
 * Function: Load_conn_get
 * Description: This function returns the connection parameters for the descriptor
 *              at the head of the recovery queue, if one exists.  The recovery 
 *              queue holds all "active" connections, some of which may be stale.
 *              If an active descriptor exists, it fills in the connection info 
 *              and returns TRUE to indicate success; otherwise it returns FALSE
 *              to indicate that no connection was found.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             OUT svr_ipaddr - the server IP address in network byte order
 *             OUT svr_port - the server port in host byte order
 *             OUT client_ipaddr - the client IP address in network byte order
 *             OUT client_port - the client port in host byte order
 *             OUT protocol - the protocol of this connection
 * Returns: BOOLEAN - 
 * Author: shouse, 10.4.01
 * Notes: 
 */
BOOLEAN Load_conn_get (PLOAD_CTXT lp, PULONG svr_ipaddr, PULONG svr_port, PULONG client_ipaddr, PULONG client_port, PUSHORT protocol)
{
    LINK *      rlp;
    PCONN_ENTRY ep;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    /* Get the descriptor off of the front of the recovery queue - DO NOT dequeue
       it, just get a pointer to the descriptor and LEAVE IT ON THE QUEUE. */
    rlp = (LINK *)Queue_front(&(lp->conn_rcvryq));

    /* If there are no descriptors, return failure. */
    if (rlp == NULL) 
        return FALSE;

    /* Get a pointer to the connection entry. */
    ep = STRUCT_PTR(rlp, CONN_ENTRY, rlink);

    UNIV_ASSERT(ep->code == CVY_ENTRCODE);

    /* Grab the IP tuple information out the descriptor and return it to the caller. */
    *svr_ipaddr    = ep->svr_ipaddr;
    *svr_port      = ep->svr_port;
    *client_ipaddr = ep->client_ipaddr;
    *client_port   = ep->client_port;
    *protocol      = ep->protocol;

    return TRUE;
}

/* 
 * Function: Load_conn_sanction
 * Description: This function is called to "sanction" an active connection descriptor.
 *              Sanction means that NLB has verified that this connection is indeed
 *              still active by querying other system entities (such as TCP/IP).  To
 *              sanction a descriptor simply involves moving it from its place in the 
 *              recovery queue (should be the head in most cases) to the tail of the 
 *              recovery queue, where it has the least chance of being cannibalized.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 * Returns: BOOLEAN - was i successful in approbating the descriptor? (TRUE = yes)
 * Author: shouse, 10.4.01
 * Notes:
 */
BOOLEAN Load_conn_sanction (
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol)
{
    ULONG       hash;
    ULONG       index;
    PCONN_ENTRY ep;
    IRQLEVEL    irql;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD(lp, MAIN_CTXT, load);
    BOOLEAN     acpt = FALSE;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    TRACE_FILTER("%!FUNC! Enter: lp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u", 
                 lp, IP_GET_OCTET(svr_ipaddr, 0), IP_GET_OCTET(svr_ipaddr, 1), IP_GET_OCTET(svr_ipaddr, 2), IP_GET_OCTET(svr_ipaddr, 3), svr_port, 
                 IP_GET_OCTET(client_ipaddr, 0), IP_GET_OCTET(client_ipaddr, 1), IP_GET_OCTET(client_ipaddr, 2), IP_GET_OCTET(client_ipaddr, 3), client_port, protocol);
 
    /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
    hash = Load_simple_hash(svr_ipaddr, svr_port, client_ipaddr, client_port);

    index = hash % CVY_MAX_CHASH;

    LOCK_ENTER(&(lp->lock), &irql);

    /* Try to find a matching descriptor for this connection. */
    ep = Load_find_dscr(lp, index, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);

    /* If there is no matching descriptor, then it must have been destroyed - return failure. */
    if (ep == NULL) {

        TRACE_FILTER("%!FUNC! Drop packet - no matching descriptor found");

        acpt = FALSE;
        goto unlock;
    }

    /* If this descriptor is being timed-out, do nothing - the connection has terminated
       gracefully and the descriptor will be destroyed when it expires. */
    if (ep->timeout) {

        TRACE_FILTER("%!FUNC! Drop packet - matching descriptor found, already expired");

        acpt = FALSE;
        goto unlock;
    }

    /* To approbate the descriptor, we remove it from its place in the recovery queue 
       and move it to the tail; active descriptors are moved to the end of the queue
       to attempt to prevent them from being recycled when we run out of free descriptors. */
    Link_unlink(&(ep->rlink));
    Queue_enq(&(lp->conn_rcvryq), &(ep->rlink));

    TRACE_FILTER("%!FUNC! Accept packet - descriptor approbated");

    acpt = TRUE;

 unlock:

    LOCK_EXIT(&(lp->lock), &irql);

    return acpt;
}

ULONG Load_port_change(
    PLOAD_CTXT      lp,
    ULONG           ipaddr,
    ULONG           port,
    ULONG           cmd,
    ULONG           value)
{
    PCVY_RULE       rp;      /* Pointer to configured port rules. */
    PBIN_STATE      bp;      /* Pointer to load module port rule state. */
    ULONG           nrules;  /* Number of rules. */ 
    ULONG           i;
    ULONG           ret = IOCTL_CVY_NOT_FOUND;
    PMAIN_CTXT      ctxtp = CONTAINING_RECORD(lp, MAIN_CTXT, load);
    BOOLEAN         bPortControlCmd;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    if (! lp->active)
    {
        return IOCTL_CVY_NOT_FOUND;
    }

    bPortControlCmd = TRUE;

    rp = (* (lp->params)).port_rules;

    /* If we are draining whole cluster, include DEFAULT rule; Otherwise, just
       include the user-defined rules (the DEFAULT rule is the last rule). */
    if (cmd == IOCTL_CVY_CLUSTER_DRAIN || cmd == IOCTL_CVY_CLUSTER_PLUG)
        nrules = (* (lp->params)).num_rules + 1;
    else
        nrules = (* (lp->params)).num_rules;

    for (i=0; i<nrules; i++, rp++)
    {
        /* If the virtual IP address is IOCTL_ALL_VIPS (0x00000000), then we are applying this 
           change to all port rules for port X, regardless of VIP.  If the virtual IP address is 
           to be applied to a particular VIP, then we apply only to port rules whose VIP matches.  
           Similarly, if the change is to apply to an "ALL VIP" rule, then we also apply when the 
           VIP matches because the caller uses CVY_ALL_VIP_NUMERIC_VALUE (0xffffffff) as the 
           virtual IP address, which is the same value stored in the port rule state. */
        if ((ipaddr == IOCTL_ALL_VIPS || ipaddr == rp->virtual_ip_addr) && 
            (port == IOCTL_ALL_PORTS || (port >= rp->start_port && port <= rp->end_port)))
        {
            bp = &(lp->pg_state[i]);
            
            UNIV_ASSERT(bp->code == CVY_BINCODE);	/* (bbain 8/19/99) */

            /* If enabling a port rule, set the load amount to original value;
               If disabling a port rule, set the load amount to zero; 
               Otherwise, set the load amount it to the specified amount. */
            if (cmd == IOCTL_CVY_PORT_ON || cmd == IOCTL_CVY_CLUSTER_PLUG)
            {
                if (cmd == IOCTL_CVY_CLUSTER_PLUG) 
                {
                    bPortControlCmd = FALSE;
                }

                if (bp->load_amt[lp->my_host_id] == bp->orig_load_amt)
                {
                    /* If we are the first port rule to match, then set the
                       return value to "Already"; Otherwise, we don't want to
                       overwrite some other port rule's return value of "OK"
                       in the case of ALL_VIPS or ALL_PORTS. */
                    if (ret == IOCTL_CVY_NOT_FOUND) ret = IOCTL_CVY_ALREADY;

                    continue;
                }

                /* Restore the original load amount. */
                bp->load_amt[lp->my_host_id] = bp->orig_load_amt;
                ret = IOCTL_CVY_OK;
            }
            else if (cmd == IOCTL_CVY_PORT_OFF)
            {

                if (bp->load_amt[lp->my_host_id] == 0)
                {
                    /* If we are the first port rule to match, then set the
                       return value to "Already"; Otherwise, we don't want to
                       overwrite some other port rule's return value of "OK"
                       in the case of ALL_VIPS or ALL_PORTS. */
                    if (ret == IOCTL_CVY_NOT_FOUND) ret = IOCTL_CVY_ALREADY;

                    continue;
                }

                bp->load_amt[lp->my_host_id] = 0;

                /* Immediately stop handling all traffic on the port group. */
                bp->cmap                    = 0;
                bp->cur_map[lp->my_host_id] = 0;

                /* Re-initialize the performance counters. */
                bp->packets_accepted = 0;
                bp->packets_dropped  = 0;
                bp->bytes_accepted   = 0;
                bp->bytes_dropped    = 0;

                Load_conn_kill(lp, bp);

                ret = IOCTL_CVY_OK;
            }
            else if (cmd == IOCTL_CVY_PORT_DRAIN || cmd == IOCTL_CVY_CLUSTER_DRAIN)
            {
                if (cmd == IOCTL_CVY_CLUSTER_DRAIN) 
                {
                    bPortControlCmd = FALSE;
                }

                if (bp->load_amt[lp->my_host_id] == 0)
                {
                    /* If we are the first port rule to match, then set the
                       return value to "Already"; Otherwise, we don't want to
                       overwrite some other port rule's return value of "OK"
                       in the case of ALL_VIPS or ALL_PORTS. */
                    if (ret == IOCTL_CVY_NOT_FOUND) ret = IOCTL_CVY_ALREADY;

                    continue;
                }

                /* Set load weight to zero, but continue to handle existing connections. */
                bp->load_amt[lp->my_host_id] = 0;
                ret = IOCTL_CVY_OK;
            }
            else
            {
                UNIV_ASSERT(cmd == IOCTL_CVY_PORT_SET);

                if (bp->load_amt[lp->my_host_id] == value)
                {
                    /* If we are the first port rule to match, then set the
                       return value to "Already"; Otherwise, we don't want to
                       overwrite some other port rule's return value of "OK"
                       in the case of ALL_VIPS or ALL_PORTS. */
                    if (ret == IOCTL_CVY_NOT_FOUND) ret = IOCTL_CVY_ALREADY;

                    continue;
                }

                /* Set the load weight for this port rule. */
                bp->orig_load_amt = value;
                bp->load_amt[lp->my_host_id] = value;
                ret = IOCTL_CVY_OK;
            }

            if (port != IOCTL_ALL_PORTS && ipaddr != IOCTL_ALL_VIPS) break;
        }
    }

    /* If the cluster isn't already converging, then initiate convergence if the load weight of a port rule has been modified. */
    if (ret == IOCTL_CVY_OK) {

        if (bPortControlCmd) 
        {
            // If enabled, fire wmi event indicating enable/disable/drain of ports on this node
            if (NlbWmiEvents[PortRuleControlEvent].Enable)
            {
                WCHAR wsVip[CVY_MAX_VIRTUAL_IP_ADDR + 1];

                Univ_ip_addr_ulong_to_str (ipaddr, wsVip);

                // Form the VIP & Port number in case of All VIPs & All Ports
                switch(cmd)
                {
                case IOCTL_CVY_PORT_ON:
                     NlbWmi_Fire_PortControlEvent(ctxtp, NLB_EVENT_PORT_ENABLED, wsVip, port);
                     break;

                case IOCTL_CVY_PORT_OFF:
                     NlbWmi_Fire_PortControlEvent(ctxtp, NLB_EVENT_PORT_DISABLED, wsVip, port);
                     break;

                case IOCTL_CVY_PORT_DRAIN:
                     NlbWmi_Fire_PortControlEvent(ctxtp, NLB_EVENT_PORT_DRAINING, wsVip, port);
                     break;

                     // For Port Set, do NOT fire event from here. This is 'cos it is only called in the 
                     // reload case and the event is fired from the caller i.e. Main_apply_without_restart().
                     // The event is fired from the caller 'cos this function could be called more than
                     // one time (if there are multiple port rules) and we want to fire the event only once
                case IOCTL_CVY_PORT_SET:
                     break;

                default: 
                     TRACE_CRIT("%!FUNC! Unexpected command code : 0x%x, NOT firing PortControl event", cmd);
                     break;
                }
            }
            else
            {
                TRACE_VERB("%!FUNC! NOT generating event 'cos PortControlEvent event generation is disabled");
            }
        }
        else  // Node Control event
        {
            // If enabled, fire wmi event indicating starting/draining of nlb on this node
            if (NlbWmiEvents[NodeControlEvent].Enable)
            {
                switch(cmd)
                {
                case IOCTL_CVY_CLUSTER_PLUG:
                     NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_STARTED);
                     break;

                case IOCTL_CVY_CLUSTER_DRAIN:
                     NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_DRAINING);
                     break;

                default: 
                     TRACE_CRIT("%!FUNC! Unexpected command code : 0x%x, NOT firing NodeControl event", cmd);
                     break;
                }
            }
            else
            {
                TRACE_VERB("%!FUNC! NOT generating event 'cos NodeControlEvent event generation is disabled");
            }
        }

        if (lp->send_msg.state != HST_CVG) {
            WCHAR me[20];
        
            Univ_ulong_to_str (lp->my_host_id+1, me, 10);

            /* Tracking convergence - Starting convergence because our port rule configuration has changed. */
            LOG_MSGS(MSG_INFO_CONVERGING_NEW_RULES, me, me);
            TRACE_CONVERGENCE("%!FUNC! Initiating convergence on host %d.  Reason: Host %d has changed its port rule configuration.", lp->my_host_id+1, lp->my_host_id+1);

            /* Tracking convergence. */
            Load_convergence_start(lp);

            // If enabled, fire wmi event indicating start of convergence
            if (NlbWmiEvents[ConvergingEvent].Enable)
            {
                NlbWmi_Fire_ConvergingEvent(ctxtp, 
                                            NLB_EVENT_CONVERGING_MODIFIED_RULES, 
                                            ctxtp->params.ded_ip_addr,
                                            ctxtp->params.host_priority);            
            }
            else
            {
                TRACE_VERB("%!FUNC! NOT Generating NLB_EVENT_CONVERGING_MODIFIED_RULES 'cos ConvergingEvent generation disabled");
            }
        }
    }

    return ret;

} /* end Load_port_change */


ULONG Load_hosts_query(
    PLOAD_CTXT      lp,
    BOOLEAN         internal,
    PULONG          host_map)
{
    WCHAR           members[256] = L"";
    WCHAR           num[20]      = L"";
    WCHAR           me[20]       = L"";
    PWCHAR          ptr          = members;
    ULONG           index        = 0;
    ULONG           count        = 0;
    PMAIN_CTXT      ctxtp        = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    for (index = 0; index < CVY_MAX_HOSTS; index++) {
        if (lp->host_map & (1 << index)) {
            ptr = Univ_ulong_to_str(index + 1, ptr, 10);
            *ptr = L',';
            ptr++;
            count++;
        }
    }

    if (count) ptr--;

    *ptr = 0;

    *host_map = lp->host_map;

    Univ_ulong_to_str((*(lp->params)).host_priority, me, 10);
    Univ_ulong_to_str(count, num, 10);

    if (lp->send_msg.state != HST_NORMAL)
    {
        UNIV_PRINT_VERB(("Load_hosts_query: Current host map is %08x and converging", lp->host_map));
        TRACE_VERB("%!FUNC! Current host map is 0x%08x and converging", lp->host_map);

        if (internal)
        {
            /* If there are 9 or less members in the cluster, we can be sure that there
               is enough room in an event log to list the members out.  If not, it might
               get truncated, so we might as well log a different event instead and tell
               the user to perform a "wlbs query" to see the list. */
            if (count < 10) {
                LOG_MSGS(MSG_INFO_CONVERGING_LIST, me, members);
            } else {
                LOG_MSGS1(MSG_INFO_CONVERGING_MAP, me, num, *host_map);
            }
        }

        return IOCTL_CVY_CONVERGING;
    }
    else if (lp->pg_state[(*(lp->params)).num_rules].cmap != 0)
    {
        UNIV_PRINT_VERB(("Load_hosts_query: Current host map is %08x and converged as DEFAULT", lp->host_map));
        TRACE_VERB("%!FUNC! Current host map is 0x%08x and converged as DEFAULT", lp->host_map);

        if (internal)
        {
            /* If there are 9 or less members in the cluster, we can be sure that there
               is enough room in an event log to list the members out.  If not, it might
               get truncated, so we might as well log a different event instead and tell
               the user to perform a "wlbs query" to see the list. */
            if (count < 10) {
                LOG_MSGS(MSG_INFO_MASTER_LIST, me, members);
            } else {
                LOG_MSGS1(MSG_INFO_MASTER_MAP, me, num, *host_map);
            }

            // If enabled, fire wmi event indicating cluster is converged
            if (NlbWmiEvents[ConvergedEvent].Enable)
            {
                NlbWmi_Fire_ConvergedEvent(ctxtp, *host_map);
            }
            else 
            {
                TRACE_VERB("%!FUNC! ConvergedEvent generation disabled");
            }
        }

        return IOCTL_CVY_MASTER;
    }
    else
    {
        UNIV_PRINT_VERB(("Load_hosts_query: Current host map is %08x and converged (NON-DEFAULT)", lp->host_map));
        TRACE_VERB("%!FUNC! Current host map is 0x%08x and converged (NON-DEFAULT)", lp->host_map);

        if (internal)
        {
            /* If there are 9 or less members in the cluster, we can be sure that there
               is enough room in an event log to list the members out.  If not, it might
               get truncated, so we might as well log a different event instead and tell
               the user to perform a "wlbs query" to see the list. */
            if (count < 10) {
                LOG_MSGS(MSG_INFO_SLAVE_LIST, me, members);
            } else {
                LOG_MSGS1(MSG_INFO_SLAVE_MAP, me, num, *host_map);
            }

            // If enabled, fire wmi event indicating cluster is converged
            if (NlbWmiEvents[ConvergedEvent].Enable)
            {
                NlbWmi_Fire_ConvergedEvent(ctxtp, *host_map);
            }
            else 
            {
                TRACE_VERB("%!FUNC! ConvergedEvent generation disabled");
            }
        }
        return IOCTL_CVY_SLAVE;
    }
} /* end Load_hosts_query */

/* 
 * Function: Load_query_packet_filter
 * Description: This function takes a IP tuple and protocol and consults the load-
 *              balancing state to determine whether or not this packet would be 
 *              accepted by the load module.  In either case, the reason for the
 *              decision is also provided, plus, in most cases, some of the load
 *              module state is also returned to provide some context to justify
 *              the decision.  This function is COMPLETELY unobtrusive and makes
 *              NO changes to the actual state of the load module.
 * Parameters: lp - a pointer to the load module.
 *             pQuery - a pointer to a buffer into which the results are placed.
 *             svr_ipaddr - the server side IP address of this virtual packet.
 *             svr_port - the server side port of this virtual packet.
 *             client_ipaddr - the client side IP address of this virtual packet.
 *             client_ipaddr - the client side port of this virtual packet.
 *             protocol - the protocol of this virtual packet (UDP, TCP or IPSec1).
 *             limit_map_fin - a boolean indication of whether or not to use server
 *                             side parameters in the Map function.  This is controlled
 *                             by BDA teaming.
 *             reverse_hash - whether or not to reverse client and server during hashing
 * Returns: Nothing.
 * Author: shouse, 5.18.01
 * Notes: This function is only observatory and makes NO changes to the state of
 *        the load module. 
 */
VOID Load_query_packet_filter (
    PLOAD_CTXT                 lp,
    PNLB_OPTIONS_PACKET_FILTER pQuery,
    ULONG                      svr_ipaddr,
    ULONG                      svr_port,
    ULONG                      client_ipaddr,
    ULONG                      client_port,
    USHORT                     protocol,
    UCHAR                      flags, 
    BOOLEAN                    limit_map_fn,
    BOOLEAN                    reverse_hash)
{
    PBIN_STATE    bp;
    ULONG         hash;
    ULONG         index;
    ULONG         bin;
    QUEUE *       qp;

    /* This variable is used for port rule lookup and since the port rules only cover
       UDP and TCP, we categorize as TCP and non-TCP, meaning that any protocol that's 
       not TCP will be treated like UDP for the sake of port rule lookup. */
    BOOLEAN       is_tcp_pkt = IS_TCP_PKT(protocol);

    /* Further, some protocols are treated with "session" semantics, while others are
       not.  For TCP, this "session" is currently a single TCP connection, which is 
       tracked from SYN to FIN using a connection descriptor.  IPSec "sessions" are
       also tracked using descriptors, so even though its treated like UDP for port
       rule lookup, its treated with the session semantics resembling TCP.  Therefore,
       by default the determination of a session packet is initially the same as the
       determination of a TCP packet. */       
    BOOLEAN       is_session_pkt = IS_SESSION_PKT(protocol);

    UNIV_ASSERT(lp);
    UNIV_ASSERT(pQuery);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    /* If the load module has been "turned off", then we drop the packet. */
    if (!lp->active) {
        pQuery->Accept = NLB_REJECT_LOAD_MODULE_INACTIVE;
        return;
    }

    /* Find the port rule for this server IP address / port pair. */
    bp = Load_pg_lookup(lp, svr_ipaddr, svr_port, is_tcp_pkt);

    UNIV_ASSERT ((is_tcp_pkt && bp->prot != CVY_UDP) || (!is_tcp_pkt && bp->prot != CVY_TCP));

    /* If the matching port rule is configured as "disabled", which means to drop any
       packets that match the rule, then we drop the packet. */
    if (bp->mode == CVY_NEVER) {
        pQuery->Accept = NLB_REJECT_PORT_RULE_DISABLED;
        return;
    }

    /* If the applicable port rule is configured in "No" affinity mode, make sure enough
       information has been specified in the query to faithfully determine packet ownership. */
    if (bp->affinity == CVY_AFFINITY_NONE) {
        /* VPN protocols REQUIRE either "Single" or "Class C" affinity; reject the request. */
        if ((protocol == TCPIP_PROTOCOL_GRE) || (protocol == TCPIP_PROTOCOL_PPTP) || (protocol == TCPIP_PROTOCOL_IPSEC1)) {
            pQuery->Accept = NLB_UNKNOWN_NO_AFFINITY;
            return;
        /* Hasing in "No" affinity requires the client port; if it wasn't specified, reject
           the request.  We check for a non-zero server port to special case ICMP filtering,
           which sets BOTH ports to zero legally. */
        } else if ((client_port == 0) && (svr_port != 0)) {
            pQuery->Accept = NLB_UNKNOWN_NO_AFFINITY;
            return;
        }
    }

    /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
    hash = Load_simple_hash(svr_ipaddr, svr_port, client_ipaddr, client_port);

    index = hash % CVY_MAX_CHASH;

    /* Compute the hash. */
    hash = Load_complex_hash(svr_ipaddr, svr_port, client_ipaddr, client_port, bp->affinity, reverse_hash, limit_map_fn);

    bin = hash % CVY_MAXBINS;

    /* At this point, we can begin providing the requestee some actual information about 
       the state of the load module to better inform them as to why the decision we return
       them was actually made.  Here will provide some appropriate information about the
       port rule we are operating on, including the "bucket" ID, the current "bucket" 
       ownership map and the number of connections active on this "bucket". */
    pQuery->HashInfo.Valid = TRUE;
    pQuery->HashInfo.Bin = bin;
    pQuery->HashInfo.CurrentMap = bp->cmap;
    pQuery->HashInfo.AllIdleMap = bp->all_idle_map;
    pQuery->HashInfo.ActiveConnections = bp->nconn[bin];

    /* If the packet is a connection control packet (TCP SYN/FIN/RST or IPSec MMSA, etc),
       then we treat it differently than normal connection data.  Mimics Load_conn_advise(). */
#if defined (NLB_TCP_NOTIFICATION)
    /* If notifications are turned ON, then we only want to traverse this path if its a session-ful SYN.
       FINs and RSTs should fall into the Load_packet_check path.  If notification is NOT ON, then fall
       through here for all SYNs, FINs and RSTs for session-ful protocols. */
    if (is_session_pkt && ((flags & NLB_FILTER_FLAGS_CONN_UP) || (((flags & NLB_FILTER_FLAGS_CONN_DOWN) || (flags & NLB_FILTER_FLAGS_CONN_RESET)) && !NLB_NOTIFICATIONS_ON())))
#else
    if (is_session_pkt && ((flags & NLB_FILTER_FLAGS_CONN_UP) || (flags & NLB_FILTER_FLAGS_CONN_DOWN) || (flags & NLB_FILTER_FLAGS_CONN_RESET)))
#endif
    {
        PCONN_ENTRY ep;

        /* If this host does not own the bucket and the packet is not a connection
           down or connection reset for a non-idle bin, then we don't own the packet. */
        if (((bp->cmap & (((MAP_T) 1) << bin)) == 0) && (!(((flags & NLB_FILTER_FLAGS_CONN_DOWN) || (flags & NLB_FILTER_FLAGS_CONN_RESET)) && (bp->nconn[bin] > 0)))) {
            pQuery->Accept = NLB_REJECT_OWNED_ELSEWHERE;            
            return;
        }

        /* At this point, we _might_ own the packet - if its a connection up, then 
           we definately do, because we own the bucket it maps to. */
        if (flags & NLB_FILTER_FLAGS_CONN_UP) {
            pQuery->Accept = NLB_ACCEPT_UNCONDITIONAL_OWNERSHIP;       
            return;
        }

        /* Look for an existing matching connection descriptor. */
        ep = Load_find_dscr(lp, index, pQuery->ServerIPAddress, pQuery->ServerPort, pQuery->ClientIPAddress, pQuery->ClientPort, pQuery->Protocol);
        
        /* If we haven't found a matching connection descriptor, then this host 
           certainly does not own this packet. */
        if (ep == NULL) {
            pQuery->Accept = NLB_REJECT_OWNED_ELSEWHERE;
            return;
        }
            
        UNIV_ASSERT(ep->code == CVY_ENTRCODE);
        
        /* If we find a match in the static hash table, fill in some descriptor
           information for the user, including whether or not the descriptor was
           allocated or static (static is this case) and the observed FIN count. */
        pQuery->DescriptorInfo.Valid = TRUE;
        pQuery->DescriptorInfo.Alloc = (ep->flags & NLB_CONN_ENTRY_FLAGS_ALLOCATED) ? TRUE : FALSE;
        pQuery->DescriptorInfo.Dirty = (ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY) ? TRUE : FALSE;
        pQuery->DescriptorInfo.RefCount = ep->ref_count;
            
        /* If the connection is dirty, we do not take the packet because TCP may
           have stale information for this descriptor. */
        if (ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY) {
            pQuery->Accept = NLB_REJECT_CONNECTION_DIRTY;
            return;
        }
        
        /* If the connection is not dirty, we'll take the packet, as it belongs
           to an existing connection that we are servicing on this host. */
        pQuery->Accept = NLB_ACCEPT_FOUND_MATCHING_DESCRIPTOR;
        return;

    /* Otherwise, if its not a control packet, then its just a data packet, which 
       requires that either we unconditionally own this connection (if all other 
       hosts are idle on the bucket this packet maps to), or that we have an active
       connection descriptor for this connection.  Mimics load_packet_check(). */
    } else {
        /* If we currently own the "bucket" to which this connection maps and either NLB provides
           no session support for this protocol, or all other hosts have no exisitng connections
           on this "bucket" and we have no dirty connections, then we can safely take the packet
           with no regard to the connection (session) descriptors. */
        if (((bp->cmap & (((MAP_T) 1) << bin)) != 0) && (!is_session_pkt || (((bp->all_idle_map & (((MAP_T) 1) << bin)) != 0) && (!(lp->cln_waiting))))) {
            pQuery->Accept = NLB_ACCEPT_UNCONDITIONAL_OWNERSHIP;
            return;
            
            /* Otherwise, if there are active connections on this "bucket" or if we own the 
               "bucket" and there are dirty connections on it, then we'll walk our descriptor
               lists to determine whether or not we should take the packet or not. */
        } else if (bp->nconn[bin] > 0 || (lp->cln_waiting && lp->dirty_bin[bin] && ((bp->cmap & (((MAP_T) 1) << bin)) != 0))) {
            PCONN_ENTRY ep;
            
            /* Look for an existing matching connection descriptor. */
            ep = Load_find_dscr(lp, index, pQuery->ServerIPAddress, pQuery->ServerPort, pQuery->ClientIPAddress, pQuery->ClientPort, pQuery->Protocol);
            
            /* If we haven't found a matching connection descriptor, then this host 
               certainly does not own this packet. */
            if (ep == NULL) {
                pQuery->Accept = NLB_REJECT_OWNED_ELSEWHERE;
                return;
            }
            
            UNIV_ASSERT(ep->code == CVY_ENTRCODE);
            
            /* If we find a match in the static hash table, fill in some descriptor
               information for the user, including whether or not the descriptor was
               allocated or static (static is this case) and the observed FIN count. */
            pQuery->DescriptorInfo.Valid = TRUE;
            pQuery->DescriptorInfo.Alloc = (ep->flags & NLB_CONN_ENTRY_FLAGS_ALLOCATED) ? TRUE : FALSE;
            pQuery->DescriptorInfo.Dirty = (ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY) ? TRUE : FALSE;
            pQuery->DescriptorInfo.RefCount = ep->ref_count;
            
            /* If the connection is dirty, we do not take the packet because TCP may
               have stale information for this descriptor. */
            if (ep->flags & NLB_CONN_ENTRY_FLAGS_DIRTY) {
                pQuery->Accept = NLB_REJECT_CONNECTION_DIRTY;
                return;
            }
            
            /* If the connection is not dirty, we'll take the packet, as it belongs
               to an existing connection that we are servicing on this host. */
            pQuery->Accept = NLB_ACCEPT_FOUND_MATCHING_DESCRIPTOR;
            return;
        }
    }

    /* If we get all the way down here, then we aren't going to accept the packet
       because we do not own the "bucket" to which the packet maps and we have no
       existing connection (session) state to allow us to service the packet. */
    pQuery->Accept = NLB_REJECT_OWNED_ELSEWHERE;
    return;
}

/*
 * Function: Load_query_port_state
 * Description: This function returns the state (enabled, disabled, draining) of a particular
 *              port rule and, if found, returns some packet handling statistics for the port
 *              rule, such as the number of packets and bytes accepted and dropped.  These
 *              counters are reset whenever a load weight change is made on the port rule, or
 *              whenever the load module is stopped/started.  This function is just a query 
 *              and therefore makes NO changes to the actual state of any port rule.
 * Parameters: lp - a pointer to the load module.
 *             pQuery - a pointer to a buffer into which the results are placed.
 *             ipaddr - the VIP for the port rule that we are looking for.  When per-VIP rules
 *                      are not used, this IP address is 255.255.255.255 (0xffffffff).
 *             port - the port we are looking for.  This function (and all other port rule
 *                    operation functions, for that matter) identify a port rule by a port 
 *                    number within the range of a rule.  Therefore, 80 identifies the port 
 *                    rule whose start port is 0 and whose end port is 1024, for instance.
 * Returns: Nothing.
 * Author: shouse, 5.18.01
 * Notes: It is very important that this function operates completely unobtrusively.
 */
VOID Load_query_port_state (
    PLOAD_CTXT                   lp,
    PNLB_OPTIONS_PORT_RULE_STATE pQuery,
    ULONG                        ipaddr,
    USHORT                       port)
{
    PCVY_RULE  rp;      /* Pointer to configured port rules. */
    PBIN_STATE bp;      /* Pointer to load module port rule state. */
    ULONG      nrules;  /* Number of configured port rules. */ 
    ULONG      i;

    UNIV_ASSERT(lp);
    UNIV_ASSERT(pQuery);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    /* If the load module is inactive, all rules are in a default state, so
       since there is nothing interesting to report, bail out and report that
       the port rule could not be found. */
    if (!lp->active) {
        pQuery->Status = NLB_PORT_RULE_NOT_FOUND;
        return;
    }

    /* Begin by assuming that we won't find a corresponding rule. */
    pQuery->Status = NLB_PORT_RULE_NOT_FOUND;

    /* Grab a pointer to the beginning of the port rules array.  These are the port
       rules are read from the registry, so no state is associated with them. */
    rp = (*(lp->params)).port_rules;

    /* Find out how many port rules to loop through. */
    nrules = (*(lp->params)).num_rules;

    /* Loop through all port rules looking for a match. */
    for (i = 0; i < nrules; i++, rp++) {
        /* If the VIP matches (this check includes the check for ALL VIP, which is coded as
           0xffffffff by both the user-level software and the load module) and the port number
           is within the range of this port rule, we have a winner. */
        if ((ipaddr == rp->virtual_ip_addr) && ((port >= rp->start_port) && (port <= rp->end_port))) {
            /* Get a pointer to the load module port rule state for this rule.  The load
               module stores the port rules in the same order as they are read from the 
               registry and stored in the NLB params, so we can use the index of the loop
               to directly index into the corresponding load module state for this rule. */
            bp = &(lp->pg_state[i]);
            
            UNIV_ASSERT(bp->code == CVY_BINCODE);

            /* If the load weight is zero, this could be because either the rule is 
               disabled or because it is in the process of draining. */
            if (bp->load_amt[lp->my_host_id] == 0) {
                /* If the current number of connections being served on this port
                   rule is non-zero, then this port rule is being drained - the 
                   count is decremented by every completed connection and goes to
                   zero when the rule is finished draining. */
                if (bp->tconn) {
                    pQuery->Status = NLB_PORT_RULE_DRAINING;
                } else {
                    pQuery->Status = NLB_PORT_RULE_DISABLED;
                } 
            /* If the port rule has a non-zero load weight, then it is enabled. */
            } else {
                pQuery->Status = NLB_PORT_RULE_ENABLED;                
            }

            /* Fill in some statistics for this port rule, including the number 
               of packets and bytes accepted and dropped, which can be used to 
               create an estimate of actual load balancing performance. */
            pQuery->Statistics.Packets.Accepted = bp->packets_accepted;
            pQuery->Statistics.Packets.Dropped  = bp->packets_dropped;
            pQuery->Statistics.Bytes.Accepted   = bp->bytes_accepted;
            pQuery->Statistics.Bytes.Dropped    = bp->bytes_dropped;

            break;
        }
    }
}

/*
 * Function: Load_query_convergence_info
 * Description: Queries the load module for the convergence statistics
 * Parameters: lp - a pointer to the load module context.
 *             OUT num_cvgs - a pointer to a ULONG to hold the total number of convergences on this host.
 *             OUT last_cvg - a pointer to a ULONG to hold the time since the last convergence completed.
 * Returns: BOOLEAN - whether or not the load module is active.  If TRUE, then the OUT params were filled in.
 * Author: shouse, 10.30.01
 * Notes: 
 */
BOOLEAN Load_query_convergence_info (PLOAD_CTXT lp, PULONG num_cvgs, PULONG last_cvg)
{
    PPING_MSG sendp;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    /* If the load module is inactive, return failure. */
    if (!lp->active)
        return FALSE;

    /* Get a pointer to our heartbeat. */
    sendp = &(lp->send_msg);

    /* Otherwise, fill in the total number of convergences since this host has joined
       the cluster and the time, in seconds, since the last convergence completed. */
    *num_cvgs = lp->num_convergences;

    /* If the host is converged, then the time since the last convergence is the 
       current time minus the timestamp of the last convergence.  Otherwise, the
       last convergence has not yet completed, so return zero (in progress). */
    if (sendp->state == HST_NORMAL)
        *last_cvg = lp->clock_sec - lp->last_convergence;
    else
        *last_cvg = NLB_QUERY_TIME_INVALID;

    return TRUE;
}

/*
 * Function: Load_query_statistics
 * Description: Queries the load module for some relevant statisitics
 * Parameters: lp - a pointer to the load module context.
 *             OUT num_cvgs - a pointer to a ULONG to hold the current number of active connections
 *             OUT last_cvg - a pointer to a ULONG to hold the total number of descriptors allocated thusfar
 * Returns: BOOLEAN - whether or not the load module is active.  If TRUE, then the OUT params were filled in.
 * Author: shouse, 4.19.02
 * Notes: 
 */
BOOLEAN Load_query_statistics (PLOAD_CTXT lp, PULONG num_conn, PULONG num_dscr)
{
    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    /* If the load module is inactive, return failure. */
    if (!lp->active)
        return FALSE;

    /* The total number of ACTIVE connections across all port rules. */
    *num_conn = lp->nconn;

    /* The number of descriptors allocated thusfar. */
    *num_dscr = lp->num_dscr_out;

    return TRUE;
}

#if defined (NLB_TCP_NOTIFICATION)
/*
 * Function: Load_conn_up
 * Description: This function is called to create state to track a connection (usually TCP
 *              or IPSec/L2TP).  This is not a function to ask the load module whether or 
 *              not to accept a packet, rather it is a request to create state to track a 
 *              connection that is being established.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 *             limit_map_fn - whether or not to include server-side parameters in hashing
 *             reverse_hash - whether or not to reverse client and server during hashing
 * Returns: BOOLEAN - whether or not state was successfully created to track this connection.
 * Author: shouse, 4.15.02
 * Notes: DO NOT CALL THIS FUNCTION WITH THE LOAD LOCK HELD.
 */
BOOLEAN Load_conn_up (
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    BOOLEAN         limit_map_fn,
    BOOLEAN         reverse_hash)
{
    ULONG           hash;
    ULONG           vindex;
    ULONG           index;
    ULONG           bin;
    PBIN_STATE      bp;
    PCONN_ENTRY     ep;
    IRQLEVEL        irql;
    PNDIS_SPIN_LOCK lockp = GET_LOAD_LOCK(lp);
    BOOLEAN         is_tcp_pkt = IS_TCP_PKT(protocol);
    BOOLEAN         acpt = TRUE;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);
 
    TRACE_FILTER("%!FUNC! Enter: lp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u, limit map = %u, reverse hash = %u",
                 lp, IP_GET_OCTET(svr_ipaddr, 0), IP_GET_OCTET(svr_ipaddr, 1), IP_GET_OCTET(svr_ipaddr, 2), IP_GET_OCTET(svr_ipaddr, 3), svr_port,
                 IP_GET_OCTET(client_ipaddr, 0), IP_GET_OCTET(client_ipaddr, 1), IP_GET_OCTET(client_ipaddr, 2), IP_GET_OCTET(client_ipaddr, 3), client_port, 
                 protocol, limit_map_fn, reverse_hash);

    /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
    hash = Load_simple_hash(svr_ipaddr, svr_port, client_ipaddr, client_port);
    
    /* Our index in all connection arrays is this hash, modulo the array size. */
    index = hash % CVY_MAX_CHASH;

    /* ALWAYS lock the global queues BEFORE locking the load module itself. */
    NdisAcquireSpinLock(&g_conn_estabq[index].lock);

    /* Lock the particular load module instance. */
    NdisAcquireSpinLock(lockp);

    /* If the load module is inactive, drop the packet and return here. */
    if (!lp->active) {

        TRACE_FILTER("%!FUNC! Drop packet - load module is inactive");

        acpt = FALSE;
        goto exit;
    }

    /* Find the port rule for this connection. */
    bp = Load_pg_lookup(lp, svr_ipaddr, svr_port, is_tcp_pkt);

    /* Handle CVY_NEVER immediately. */
    if (bp->mode == CVY_NEVER) {

        TRACE_FILTER("%!FUNC! Drop packet - port rule %u is disabled\n", bp->index);

        acpt = FALSE;
        goto exit;
    }

    /* Compute the hash. */
    hash = Load_complex_hash(svr_ipaddr, svr_port, client_ipaddr, client_port, bp->affinity, reverse_hash, limit_map_fn);

    /* Now hash client address to bin id. */
    bin = hash % CVY_MAXBINS;

    LOCK_ENTER(&(lp->lock), &irql);

    /* Look for an existing matching connection descriptor. */
    ep = Load_find_dscr(lp, index, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);
    
    /* If there is no existing descriptor using this tuple, or if there is one, but its reference 
       count is zero, then the descriptor is NOT on the global connection queue; otherwise it is. */
    if ((ep != NULL) && (ep->ref_count != 0)) {
        /* Temporarily pull this descriptor off of the global connection queue.  We'll end up putting 
           it back on later, but this way we can UNCONDITIONALLY link to the queue when the time comes. */
        g_conn_estabq[index].length--;
        Link_unlink(&ep->glink);
    }

    /* Create a new connection descriptor to track this connection. */
    ep = Load_create_dscr(lp, bp, ep, index, bin);

    /* If, for some reason, we were unable to create state for this connection, bail out here. */
    if (ep == NULL) {

        TRACE_FILTER("%!FUNC! Drop packet - no available descriptors: Port rule = %u, Index = %u, Bin = %u, Current map = 0x%015I64x, " 
                     "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                     bp->index, index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);
            
        acpt = FALSE;
        goto unlock;
    }
    
    /* Set the connection information in the descriptor. */
    CVY_CONN_SET(ep, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);

    /* Insert the descriptor into the global connection queue. */
    g_conn_estabq[index].length++;
    Queue_enq(&g_conn_estabq[index].queue, &ep->glink);

    /* If this is a new PPTP tunnel, create or update a virtual descriptor to track the GRE data packets. */
    if (protocol == TCPIP_PROTOCOL_PPTP) {
        /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
        hash = Load_simple_hash(svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT);
        
        /* Our index in all connection arrays is this hash, modulo the array size. */
        vindex = hash % CVY_MAX_CHASH;

        /* Look for an existing matching virtual connection descriptor. */
        ep = Load_find_dscr(lp, vindex, svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE);
        
        /* Create or update a virtual descriptor for the GRE traffic. */
        ep = Load_create_dscr(lp, bp, ep, vindex, bin);

        /* If we can't allocate the virtual descriptor, bail out, but don't fail. */
        if (ep == NULL) goto unlock;

        /* Set the connection information in the descriptor. */
        CVY_CONN_SET(ep, svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE);

        /* Set the virtual descriptor flag. */
        ep->flags |= NLB_CONN_ENTRY_FLAGS_VIRTUAL;
    }
    /* If this is a new IPSEC tunnel, create or update a virtual descriptor to track the UDP subsequent data fragments. */
    else if (protocol == TCPIP_PROTOCOL_IPSEC1) {
        /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
        hash = Load_simple_hash(svr_ipaddr, IPSEC_CTRL_PORT, client_ipaddr, IPSEC_CTRL_PORT);
        
        /* Our index in all connection arrays is this hash, modulo the array size. */
        vindex = hash % CVY_MAX_CHASH;

        /* Look for an existing matching virtual connection descriptor. */
        ep = Load_find_dscr(lp, vindex, svr_ipaddr, IPSEC_CTRL_PORT, client_ipaddr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC_UDP);        

        /* Create or update a virtual descriptor for the UDP subsequent fragment traffic. */
        ep = Load_create_dscr(lp, bp, ep, vindex, bin);
        
        /* If we can't allocate the virtual descriptor, bail out, but don't fail. */
        if (ep == NULL) goto unlock;

        /* Set the connection information in the descriptor. */
        CVY_CONN_SET(ep, svr_ipaddr, IPSEC_CTRL_PORT, client_ipaddr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC_UDP);

        /* Set the virtual descriptor flag. */
        ep->flags |= NLB_CONN_ENTRY_FLAGS_VIRTUAL;
    }

    TRACE_FILTER("%!FUNC! Accept packet - connection state created: Port rule = %u, Index = %u, Bin = %u, Current map = 0x%015I64x, " 
                 "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                 bp->index, index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);

    acpt = TRUE;

 unlock:

    LOCK_EXIT(&(lp->lock), irql);

 exit:

    /* Unlock the load module. */
    NdisReleaseSpinLock(lockp);

    /* Unlock the global established connection queue. */
    NdisReleaseSpinLock(&g_conn_estabq[index].lock);

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

/*
 * Function: Load_conn_down
 * Description: This function is called to destroy the state being used to track an existing
 *              connection (usually TCP or IPSec/L2TP).  If state for the given 5-tuple is 
 *              found, it is de-referenced and destroyed if appropriate (based partially on
 *              the conn_status).  If state is not found, FALSE is returned, but it not 
 *              considered a catastrophic error.  In the case of TCP notifications, perhaps
 *              the connection was not even established across a NLB NIC.
 * Parameters: svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 *             conn_status - whether the connection is going DOWN or being RESET
 * Returns: BOOLEAN - whether or not the connection state was found and updated.
 * Author: shouse, 4.15.02
 * Notes: DO NOT CALL THIS FUNCTION WITH THE LOAD LOCK HELD.
 */
BOOLEAN Load_conn_down (
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    ULONG           conn_status)
{
    PLOAD_CTXT      lp;
    ULONG           hash;
    ULONG           vindex;
    ULONG           index;
    ULONG           bin;
    LINK *          linkp;
    PBIN_STATE      bp;
    PCONN_ENTRY     ep;
    PPENDING_ENTRY  pp;
    PNDIS_SPIN_LOCK lockp;
    BOOLEAN         match = FALSE;
    BOOLEAN         acpt = TRUE;
    PMAIN_CTXT      ctxtp;

    TRACE_FILTER("%!FUNC! Enter: server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u, status = %u",
                 IP_GET_OCTET(svr_ipaddr, 0), IP_GET_OCTET(svr_ipaddr, 1), IP_GET_OCTET(svr_ipaddr, 2), IP_GET_OCTET(svr_ipaddr, 3), svr_port, 
                 IP_GET_OCTET(client_ipaddr, 0), IP_GET_OCTET(client_ipaddr, 1), IP_GET_OCTET(client_ipaddr, 2), IP_GET_OCTET(client_ipaddr, 3), client_port, protocol, conn_status);

    /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
    hash = Load_simple_hash(svr_ipaddr, svr_port, client_ipaddr, client_port);
    
    /* Our index in all connection arrays is this hash, modulo the array size. */
    index = hash % CVY_MAX_CHASH;

    /* ALWAYS lock the global queues BEFORE locking the load module itself. */
    NdisAcquireSpinLock(&g_conn_pendingq[index].lock);

    /* Grab the entry at the front of this pending connection queue. */
    pp = (PPENDING_ENTRY)Queue_front(&g_conn_pendingq[index].queue);

    while (pp != NULL) {

        UNIV_ASSERT(pp->code == CVY_PENDINGCODE);

        /* Look for a matching descriptor. */
        if (CVY_PENDING_MATCH(pp, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol)) {
            match = TRUE;
            break;
        }
        
        /* Get the next item in the queue. */
        pp = (PPENDING_ENTRY)Queue_next(&g_conn_pendingq[index].queue, &(pp->link));
    }

    /* If we found this connection in the pending connection queue, remove it from
       the queue, destroy the pending connection state and exit.  Otherwise, fall
       through and continue looking in the established connection queue. */
    if (match) {

        UNIV_ASSERT(pp);

        /* Remove the pending connection entry from the pending queue. */
        g_conn_pendingq[index].length--;
        Link_unlink(&pp->link);

        /* Free the descriptor back to the fixed-size block pool. */
        NdisFreeToBlockPool((PUCHAR)pp);

        /* Unlock the global pending connection queue. */
        NdisReleaseSpinLock(&g_conn_pendingq[index].lock);

        acpt = TRUE;
        goto exit;
    }

    /* Unlock the global established connection queue. */
    NdisReleaseSpinLock(&g_conn_pendingq[index].lock);

    /* ALWAYS lock the global queues BEFORE locking the load module itself. */
    NdisAcquireSpinLock(&g_conn_estabq[index].lock);

    /* Grab the entry at the front of this established connection queue. */
    linkp = (LINK *)Queue_front(&g_conn_estabq[index].queue);

    while (linkp != NULL) {
        /* Get the CONN_ENTRY pointer from the link pointer. */
        ep = STRUCT_PTR(linkp, CONN_ENTRY, glink);

        UNIV_ASSERT(ep->code == CVY_ENTRCODE);

        /* Look for a matching descriptor. */
        if (CVY_CONN_MATCH(ep, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol)) {
            match = TRUE;
            break;
        }
        
        /* Get the next item in the queue. */
        linkp = (LINK *)Queue_next(&g_conn_estabq[index].queue, &(ep->glink));
    }

    /* If no matching descriptor was found, bail out. */
    if (!match) {

        TRACE_FILTER("%!FUNC! Drop packet - no matching descriptor for RST/FIN: Index = %u", index);
        
        acpt = FALSE;
        goto unlock;
    }

    UNIV_ASSERT(ep);

    /* Unlink this descriptor here.  We have to do this here because if Load_destroy_dscr does in fact 
       destroy the descriptor, we can't touch it once the function call returns.  So, we'll pull it off
       here unconditionally and if it turns out that there are still references on the descriptor, we'll 
       put it back on when Load_destroy_dscr returns. */
    g_conn_estabq[index].length--;
    Link_unlink(&ep->glink);
    
    /* Grab a pointer to the load module on which the descriptor resides. */
    lp = ep->load;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    /* Get a pointer to the load lock from the load context. */
    lockp = GET_LOAD_LOCK(lp);

    /* Lock the load module on which the connection resides. */
    NdisAcquireSpinLock(lockp);

    LOCK_ENTER(&(lp->lock), &irql);

    /* If we found state for this connection, the bin is the bin from the descriptor,
       not the calculated bin, which may not even been accurate if the port rules have
       been modified since this connection was established. */
    bin = ep->bin;

    /* Lookup the port rule so we can update the port rule info. */
    bp = Load_pg_lookup(lp, ep->svr_ipaddr, ep->svr_port, IS_TCP_PKT(ep->protocol));

    /* If references still remain on the descriptor, then put it back on the global connection queue. */
    if (Load_destroy_dscr(lp, bp, ep, conn_status)) {
        /* Insert the descriptor into the global connection queue. */
        g_conn_estabq[index].length++;
        Queue_enq(&g_conn_estabq[index].queue, &ep->glink);
    }

    /* If this is a PPTP tunnel going down, update the virtual GRE descriptor.  Virtual descriptors
       are ALWAYS de-referenced, not destroyed, even if the notification is a RST because these
       descriptors are potentially shared by multiple PPTP tunnels. */
    if (protocol == TCPIP_PROTOCOL_PPTP) {
        /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
        hash = Load_simple_hash(svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT);
        
        /* Our index in all connection arrays is this hash, modulo the array size. */
        vindex = hash % CVY_MAX_CHASH;

        /* Look for an existing matching connection descriptor.  Now that we have the load module pointer
           from finding the first descriptor, we can narrow our search and look only for virtual descriptors 
           that reside on our load module. */
        ep = Load_find_dscr(lp, vindex, svr_ipaddr, PPTP_CTRL_PORT, client_ipaddr, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE);
        
        /* Dereference the virtual GRE descriptor. */
        (VOID)Load_destroy_dscr(lp, bp, ep, conn_status);
    }
    /* If this is an IPSEC tunnel going down, update the virtual ISPEC_UDP descriptor. Virtual descriptors
       are ALWAYS de-referenced, not destroyed, even if the notification is a RST because these
       descriptors are potentially shared by multiple IPSEC tunnels. */
    else if (protocol == TCPIP_PROTOCOL_IPSEC1) {
        /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
        hash = Load_simple_hash(svr_ipaddr, IPSEC_CTRL_PORT, client_ipaddr, IPSEC_CTRL_PORT);
        
        /* Our index in all connection arrays is this hash, modulo the array size. */
        vindex = hash % CVY_MAX_CHASH;

        /* Look for an existing matching virtual connection descriptor.  Now that we have the load module pointer
           from finding the first descriptor, we can narrow our search and look only for virtual descriptors 
           that reside on our load module. */
        ep = Load_find_dscr(lp, vindex, svr_ipaddr, IPSEC_CTRL_PORT, client_ipaddr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC_UDP);
        
        /* Dereference the virtual IPSec/UDP descriptor. */
        (VOID)Load_destroy_dscr(lp, bp, ep, conn_status);
    }

    TRACE_FILTER("%!FUNC! Accept packet - state found: Port rule = %u, Index = %u, Bin = %u, Current map = 0x%015I64x, " 
                 "All idle map = 0x%015I64x, Connections = %u, Cleanup waiting = %u, Dirty %u",
                 bp->index, index, bin, bp->cmap, bp->all_idle_map, bp->nconn[bin], lp->cln_waiting, lp->dirty_bin[bin]);

    acpt = TRUE;

    LOCK_EXIT(&(lp->lock), irql);

    /* Unlock the load module. */
    NdisReleaseSpinLock(lockp);

 unlock:

    /* Unlock the global established connection queue. */
    NdisReleaseSpinLock(&g_conn_estabq[index].lock);

 exit:

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

/*
 * Function: Load_conn_pending
 * Description: This function is called to create state for a pending OUTGOING connection on 
 *              the server.  Because at this time, it is unknown on what interface the connection
 *              will ultimately be established, NLB creates global state to track the connection
 *              only until it is established.  For TCP, when the SYN+ACK arrives from the peer,
 *              we only accept it if we find a match in our pending connection queues.  When the 
 *              connection is established, this state is destroyed and new state is created to 
 *              track the connection is appropriate.
 * Parameters: svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 * Returns: BOOLEAN - whether or not state was successfully created to track this pending connection.
 * Author: shouse, 4.15.02
 * Notes: DO NOT CALL THIS FUNCTION WITH THE LOAD LOCK HELD.
 */
BOOLEAN Load_conn_pending (
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol)
{
    ULONG           hash;
    ULONG           index;
    PPENDING_ENTRY  pp = NULL;
    BOOLEAN         acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u",
                 IP_GET_OCTET(svr_ipaddr, 0), IP_GET_OCTET(svr_ipaddr, 1), IP_GET_OCTET(svr_ipaddr, 2), IP_GET_OCTET(svr_ipaddr, 3), svr_port, 
                 IP_GET_OCTET(client_ipaddr, 0), IP_GET_OCTET(client_ipaddr, 1), IP_GET_OCTET(client_ipaddr, 2), IP_GET_OCTET(client_ipaddr, 3), client_port, protocol);

    /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
    hash = Load_simple_hash(svr_ipaddr, svr_port, client_ipaddr, client_port);
    
    /* Our index in all connection arrays is this hash, modulo the array size. */
    index = hash % CVY_MAX_CHASH;

    /* If we falied to allocate the pending connection descriptor pool, bail out. */
    if (g_pending_conn_pool == NULL)
    {
        /* Creation of the global pending connection state pool failed. */
        TRACE_FILTER("%!FUNC! Drop packet - no global connection pending pool: Index = %u", index);
        
        acpt = FALSE;
        goto exit;
    }

    /* Allocate a descriptor from the fixed-size block pool. */
    pp = (PPENDING_ENTRY)NdisAllocateFromBlockPool(g_pending_conn_pool);
        
    if (pp == NULL) {
        /* Allocation failed, bail out. */
        TRACE_FILTER("%!FUNC! Drop packet - unable to allocate a pending connection entry: Index = %u", index);
            
        acpt = FALSE;
        goto exit;
    }
        
    /* Initialize the link. */
    Link_init(&pp->link);

    /* Fill in the "magic number". */
    pp->code = CVY_PENDINGCODE;
        
    /* Fill in the IP tuple. */
    CVY_PENDING_SET(pp, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);

    /* ALWAYS lock the global queues BEFORE locking the load module itself. */
    NdisAcquireSpinLock(&g_conn_pendingq[index].lock);

    /* Insert the descriptor into the global connection queue. */
    g_conn_pendingq[index].length++;
    Queue_enq(&g_conn_pendingq[index].queue, &pp->link);

    /* Unlock the global pending connection queue. */
    NdisReleaseSpinLock(&g_conn_pendingq[index].lock);

    TRACE_FILTER("%!FUNC! Accept packet - pending connection state created: Index = %u", index);
        
    acpt = TRUE;

 exit:

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

/*
 * Function: Load_pending_check
 * Description: This function is called to determine whether or not state exists in the pending
 *              connection queues for this connection.  If it does, the packet should be accepted.
 *              If no state exists, the packet should be dropped. 
 * Parameters: svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 * Returns: BOOLEAN - whether or not to accept the packet.
 * Author: shouse, 4.15.02
 * Notes: DO NOT CALL THIS FUNCTION WITH THE LOAD LOCK HELD.
 */
BOOLEAN Load_pending_check (
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol)
{
    ULONG           hash;
    ULONG           index;
    PPENDING_ENTRY  pp = NULL;
    BOOLEAN         match = FALSE;
    BOOLEAN         acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u",
                 IP_GET_OCTET(svr_ipaddr, 0), IP_GET_OCTET(svr_ipaddr, 1), IP_GET_OCTET(svr_ipaddr, 2), IP_GET_OCTET(svr_ipaddr, 3), svr_port, 
                 IP_GET_OCTET(client_ipaddr, 0), IP_GET_OCTET(client_ipaddr, 1), IP_GET_OCTET(client_ipaddr, 2), IP_GET_OCTET(client_ipaddr, 3), client_port, protocol);

    /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
    hash = Load_simple_hash(svr_ipaddr, svr_port, client_ipaddr, client_port);
    
    /* Our index in all connection arrays is this hash, modulo the array size. */
    index = hash % CVY_MAX_CHASH;

    /* ALWAYS lock the global queues BEFORE locking the load module itself. */
    NdisAcquireSpinLock(&g_conn_pendingq[index].lock);

    /* Grab the entry at the front of this pending connection queue. */
    pp = (PPENDING_ENTRY)Queue_front(&g_conn_pendingq[index].queue);

    while (pp != NULL) {

        UNIV_ASSERT(pp->code == CVY_PENDINGCODE);

        /* Look for a matching descriptor. */
        if (CVY_PENDING_MATCH(pp, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol)) {
            match = TRUE;
            break;
        }
        
        /* Get the next item in the queue. */
        pp = (PPENDING_ENTRY)Queue_next(&g_conn_pendingq[index].queue, &(pp->link));
    }

    /* If no matching descriptor was found, bail out. */
    if (!match) {

        TRACE_FILTER("%!FUNC! Drop packet - no matching pending connection state for SYN+ACK: Index = %u", index);
        
        acpt = FALSE;
        goto exit;
    }

    TRACE_FILTER("%!FUNC! Accept packet - pending connection state found: Index = %u", index);

    acpt = TRUE;

 exit:

    /* Unlock the global pending connection queue. */
    NdisReleaseSpinLock(&g_conn_pendingq[index].lock);

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

/*
 * Function: Load_conn_establish
 * Description: This function is invoked when a pending connection has become established.  
 *              When the pending connection is established, its state in the pending 
 *              connection queues is destroyed.  If the connection was ultimately established
 *              on an NLB adapter (if lp != NULL), then state will be created to track this
 *              new connection.  Otherwise, the operation consists only of destroying the 
 *              pending connection state.
 * Parameters: lp - a pointer to the load module context (LOAD_CTXT)
 *             svr_ipaddr - the server IP address in network byte order
 *             svr_port - the server port in host byte order
 *             client_ipaddr - the client IP address in network byte order
 *             client_port - the client port in host byte order
 *             protocol - the protocol of this connection
 *             limit_map_fn - whether or not to include server-side parameters in hashing
 *             reverse_hash - whether or not to reverse client and server during hashing
 * Returns: BOOLEAN - whether or not the operation was successfully completed.
 * Author: shouse, 4.15.02
 * Notes: DO NOT CALL THIS FUNCTION WITH THE LOAD LOCK HELD.
 */
BOOLEAN Load_conn_establish (
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    BOOLEAN         limit_map_fn,
    BOOLEAN         reverse_hash)
{
    ULONG           hash;
    ULONG           index;
    PPENDING_ENTRY  pp = NULL;
    BOOLEAN         match = FALSE;
    BOOLEAN         acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: lp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u, limit map = %u, reverse hash = %u",
                 lp, IP_GET_OCTET(svr_ipaddr, 0), IP_GET_OCTET(svr_ipaddr, 1), IP_GET_OCTET(svr_ipaddr, 2), IP_GET_OCTET(svr_ipaddr, 3), svr_port, 
                 IP_GET_OCTET(client_ipaddr, 0), IP_GET_OCTET(client_ipaddr, 1), IP_GET_OCTET(client_ipaddr, 2), IP_GET_OCTET(client_ipaddr, 3), client_port, 
                 protocol, limit_map_fn, reverse_hash);

    /* Compute a simple and inexpensive hash on all parts of the IP tuple except the protocol. */
    hash = Load_simple_hash(svr_ipaddr, svr_port, client_ipaddr, client_port);
    
    /* Our index in all connection arrays is this hash, modulo the array size. */
    index = hash % CVY_MAX_CHASH;

    /* ALWAYS lock the global queues BEFORE locking the load module itself. */
    NdisAcquireSpinLock(&g_conn_pendingq[index].lock);

    /* Grab the entry at the front of this pending connection queue. */
    pp = (PPENDING_ENTRY)Queue_front(&g_conn_pendingq[index].queue);

    while (pp != NULL) {

        UNIV_ASSERT(pp->code == CVY_PENDINGCODE);

        /* Look for a matching descriptor. */
        if (CVY_PENDING_MATCH(pp, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol)) {
            match = TRUE;
            break;
        }
        
        /* Get the next item in the queue. */
        pp = (PPENDING_ENTRY)Queue_next(&g_conn_pendingq[index].queue, &(pp->link));
    }

    /* If no matching descriptor was found, bail out. */
    if (!match) {

        TRACE_FILTER("%!FUNC! Drop packet - no matching pending connection state: Index = %u", index);
        
        /* Unlock the global pending connection queue. */
        NdisReleaseSpinLock(&g_conn_pendingq[index].lock);

        acpt = FALSE;
        goto exit;
    }
    
    UNIV_ASSERT(pp);
    
    /* Remove the pending connection entry from the pending queue. */
    g_conn_pendingq[index].length--;
    Link_unlink(&pp->link);
    
    /* Unlock the global pending connection queue. */
    NdisReleaseSpinLock(&g_conn_pendingq[index].lock);

    /* Free the descriptor back to the fixed-size block pool. */
    NdisFreeToBlockPool((PUCHAR)pp);

    /* If the load module pointer is non-NULL, then this connection is being established on 
       an NLB adapter.  If so, call Load_conn_up to create state to track the connection. */
    if (lp != NULL) {

        UNIV_ASSERT(lp->code == CVY_LOADCODE);
 
        /* Create state for the connection. */
        acpt = Load_conn_up(lp, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol, limit_map_fn, reverse_hash);
    }

 exit:

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\main.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - packet handling

Author:

    kyrilf
    shouse

--*/

#include <ndis.h>

#include "main.h"
#include "prot.h"
#include "nic.h"
#include "univ.h"
#include "tcpip.h"
#include "wlbsip.h"
#include "util.h"
#include "load.h"
#include "wlbsparm.h"
#include "params.h"
#include "log.h"
#include "trace.h"
#include "nlbwmi.h"
#include "main.tmh"

#if defined (NLB_TCP_NOTIFICATION)
/* For retrieving the IP address table to map an NLB instance
   to an IP interface index; required for TCP notification. */
#include <tcpinfo.h>
#include <tdiinfo.h>
#endif

/* For querying TCP about the state of a TCP connection. */
#include "ntddtcp.h"
#include "ntddip.h"

NTSYSAPI
NTSTATUS
NTAPI
ZwDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    );

EXPORT
VOID
NdisIMCopySendPerPacketInfo(
    IN PNDIS_PACKET DstPacket,
    IN PNDIS_PACKET SrcPacket
    );

EXPORT
VOID
NdisIMCopySendCompletePerPacketInfo(
    IN PNDIS_PACKET DstPacket,
    PNDIS_PACKET SrcPacket
    );

/* GLOBALS */

static ULONG log_module_id = LOG_MODULE_MAIN;

/* The global array of all NLB adapters. */
MAIN_ADAPTER            univ_adapters [CVY_MAX_ADAPTERS];

/* The total number of NLB instances. */
ULONG                   univ_adapters_count = 0;

/* The head of the BDA team list. */
PBDA_TEAM               univ_bda_teaming_list = NULL;

#if defined (NLB_HOOK_ENABLE)
/* The global NLB hook table. */
HOOK_TABLE              univ_hooks;
#endif

/* PROCEDURES */

#if defined (NLB_HOOK_ENABLE)
/*
 * Function: Main_hook_interface_init
 * Description: This function initializes a hook interface by marking it unregistered.
 * Parameters: pInterface - a pointer to the hook interface.
 * Returns: Nothing.
 * Author: shouse, 12.14.01
 * Notes: 
 */
VOID Main_hook_interface_init (PHOOK_INTERFACE pInterface)
{
    pInterface->Registered = FALSE;  /* Mark the interface as unregistered. */
    pInterface->References = 0;      /* Initialize the reference count to zero. */
    pInterface->Owner      = 0;      /* Mark the owner as unknown. */
    pInterface->Deregister = NULL;   /* Zero out the de-register callback function pointer. */
}

/*
 * Function: Main_hook_init
 * Description: This function initializes a hook by marking it unused and unreferenced.
 * Parameters: pHook - a pointer to the hook.
 * Returns: Nothing.
 * Author: shouse, 12.14.01
 * Notes: 
 */
VOID Main_hook_init (PHOOK pHook)
{
    pHook->Registered = FALSE;       /* Mark this hook as unregistered. */

    /* Zero out the union of hook function pointers. */
    NdisZeroMemory(&pHook->Hook, sizeof(HOOK_FUNCTION));
}

/*
 * Function: Main_recv_hook
 * Description: This function invokes the receive packet filter hook if one has been 
 *              configured, and returns the response from the hook back to the caller.
 * Parameters: ctxtp - a pointer to the NLB adapter context.
 *             pPacket - a pointer to the NDIS packet being received.
 *             pPacketInfo - a pointer to the information previously parsed from the NDIS packet.
 * Returns: NLB_FILTER_HOOK_DIRECTIVE - the feedback from the hook invocation.
 * Author: shouse, 04.19.02
 * Notes: If no hook has been registered, this function returns NLB_FILTER_HOOK_PROCEED_WITH_HASH,
 *        which tells NLB to proceed as if the hook did not even exist.
 */
__inline NLB_FILTER_HOOK_DIRECTIVE Main_recv_hook (
    PMAIN_CTXT        ctxtp,
    PNDIS_PACKET      pPacket,
    PMAIN_PACKET_INFO pPacketInfo)
{
    /* By default, we proceed as per usual. */
    NLB_FILTER_HOOK_DIRECTIVE filter = NLB_FILTER_HOOK_PROCEED_WITH_HASH;
    
    /* If a receive packet filter hook has been registered, then we MAY need to 
       call the hook to inspect the packet.  Note that this is not certainty yet, 
       as we check this boolean flag WITHOUT first grabbing the lock in order to
       optimize the common execution path in which no hook is registered. */
    if (univ_hooks.FilterHook.ReceiveHook.Registered) 
    {
        /* If there is a chance this hook is registered, we need to grab the 
           hook lock to make sure. */
        NdisDprAcquireSpinLock(&univ_hooks.FilterHook.Lock);
        
        /* If the registered flag is set and we are holding the hook lock, then
           we are certain that the hook is set and that we need to execute it.
           To prevent this hook information from disappearing while we're using
           it (mostly to prevent the registering component from disappering 
           before we call it), we need to increment the reference count on the
           hook with the lock held.  This will ensure that the hook cannot be 
           de-registered before we're done with it. */
        if (univ_hooks.FilterHook.ReceiveHook.Registered) 
        {
            ULONG dwFlags = 0;

            if (!ctxtp->convoy_enabled)
                dwFlags |= NLB_FILTER_HOOK_FLAGS_STOPPED;
            else if (ctxtp->draining)
                dwFlags |= NLB_FILTER_HOOK_FLAGS_DRAINING;

            NdisInterlockedIncrement(&univ_hooks.FilterHook.Interface.References);
            
            /* Release the spin lock protecting the hook. */
            NdisDprReleaseSpinLock(&univ_hooks.FilterHook.Lock);
            
            UNIV_ASSERT(univ_hooks.FilterHook.ReceiveHook.Hook.ReceiveHookFunction);
            
            TRACE_FILTER("%!FUNC! Invoking the packet receive filter hook");
            
            /* Invoke the hook and save the response. */
            filter = (*univ_hooks.FilterHook.ReceiveHook.Hook.ReceiveHookFunction)(
                univ_adapters[ctxtp->adapter_id].device_name, 
                pPacket, 
                (PUCHAR)pPacketInfo->Ethernet.pHeader, 
                pPacketInfo->Ethernet.Length, 
                (PUCHAR)pPacketInfo->IP.pHeader, 
                pPacketInfo->IP.Length,
                dwFlags);
            
            /* Decrement the reference count on the hook now that we're done with it. */
            NdisInterlockedDecrement(&univ_hooks.FilterHook.Interface.References);
        }
        else 
        {
            /* Release the spin lock protecting the hook. */
            NdisDprReleaseSpinLock(&univ_hooks.FilterHook.Lock);
        }
    }

    return filter;
}

/*
 * Function: Main_query_hook
 * Description: This function invokes the query packet filter hook if one has been 
 *              configured, and returns the response from the hook back to the caller.
 * Parameters: 
 * Returns: NLB_FILTER_HOOK_DIRECTIVE - the feedback from the hook invocation.
 * Author: shouse, 04.19.02
 * Notes: If no hook has been registered, this function returns NLB_FILTER_HOOK_PROCEED_WITH_HASH,
 *        which tells NLB to proceed as if the hook did not even exist.
 */
__inline NLB_FILTER_HOOK_DIRECTIVE Main_query_hook (
    PMAIN_CTXT ctxtp,
    ULONG      svr_addr, 
    ULONG      svr_port, 
    ULONG      clt_addr, 
    ULONG      clt_port, 
    USHORT     protocol)
{
    /* By default, we proceed as per usual. */
    NLB_FILTER_HOOK_DIRECTIVE filter = NLB_FILTER_HOOK_PROCEED_WITH_HASH;
    
    /* If a query packet filter hook has been registered, then we MAY need to 
       call the hook to inspect the packet.  Note that this is not certainty yet, 
       as we check this boolean flag WITHOUT first grabbing the lock in order to
       optimize the common execution path in which no hook is registered. */
    if (univ_hooks.FilterHook.QueryHook.Registered) 
    {
        /* If there is a chance this hook is registered, we need to grab the 
           hook lock to make sure. */
        NdisAcquireSpinLock(&univ_hooks.FilterHook.Lock);
        
        /* If the registered flag is set and we are holding the hook lock, then
           we are certain that the hook is set and that we need to execute it.
           To prevent this hook information from disappearing while we're using
           it (mostly to prevent the registering component from disappering 
           before we call it), we need to increment the reference count on the
           hook with the lock held.  This will ensure that the hook cannot be 
           de-registered before we're done with it. */
        if (univ_hooks.FilterHook.QueryHook.Registered) 
        {
            ULONG dwFlags = 0;

            if (!ctxtp->convoy_enabled)
                dwFlags |= NLB_FILTER_HOOK_FLAGS_STOPPED;
            else if (ctxtp->draining)
                dwFlags |= NLB_FILTER_HOOK_FLAGS_DRAINING;

            NdisInterlockedIncrement(&univ_hooks.FilterHook.Interface.References);
            
            /* Release the spin lock protecting the hook. */
            NdisReleaseSpinLock(&univ_hooks.FilterHook.Lock);
            
            UNIV_ASSERT(univ_hooks.FilterHook.QueryHook.Hook.QueryHookFunction);
            
            TRACE_FILTER("%!FUNC! Invoking the packet query filter hook");
            
            /* Invoke the hook and save the response. */
            filter = (*univ_hooks.FilterHook.QueryHook.Hook.QueryHookFunction)(
                univ_adapters[ctxtp->adapter_id].device_name, 
                svr_addr,
                (USHORT)svr_port,
                clt_addr,
                (USHORT)clt_port,
                (UCHAR)protocol,
                TRUE, /* For now, all queries are in a receive context. */
                dwFlags);
            
            /* Decrement the reference count on the hook now that we're done with it. */
            NdisInterlockedDecrement(&univ_hooks.FilterHook.Interface.References);
        }
        else 
        {
            /* Release the spin lock protecting the hook. */
            NdisReleaseSpinLock(&univ_hooks.FilterHook.Lock);
        }
    }

    return filter;
}

/*
 * Function: Main_send_hook
 * Description: This function invokes the send packet filter hook if one has been 
 *              configured, and returns the response from the hook back to the caller.
 * Parameters: ctxtp - a pointer to the NLB adapter context.
 *             pPacket - a pointer to the NDIS packet being sent.
 *             pPacketInfo - a pointer to the information previously parsed from the NDIS packet.
 * Returns: NLB_FILTER_HOOK_DIRECTIVE - the feedback from the hook invocation.
 * Author: shouse, 04.19.02
 * Notes: If no hook has been registered, this function returns NLB_FILTER_HOOK_PROCEED_WITH_HASH,
 *        which tells NLB to proceed as if the hook did not even exist.
 */
__inline NLB_FILTER_HOOK_DIRECTIVE Main_send_hook (
    PMAIN_CTXT        ctxtp,
    PNDIS_PACKET      pPacket,
    PMAIN_PACKET_INFO pPacketInfo)
{
    /* By default, we proceed as per usual. */
    NLB_FILTER_HOOK_DIRECTIVE filter = NLB_FILTER_HOOK_PROCEED_WITH_HASH;

    /* If a send packet filter hook has been registered, then we MAY need to 
       call the hook to inspect the packet.  Note that this is not certainty yet, 
       as we check this boolean flag WITHOUT first grabbing the lock in order to
       optimize the common execution path in which no hook is registered. */
    if (univ_hooks.FilterHook.SendHook.Registered) 
    {
        /* If there is a chance this hook is registered, we need to grab the 
           hook lock to make sure. */
        NdisAcquireSpinLock(&univ_hooks.FilterHook.Lock);
        
        /* If the registered flag is set and we are holding the hook lock, then
           we are certain that the hook is set and that we need to execute it.
           To prevent this hook information from disappearing while we're using
           it (mostly to prevent the registering component from disappering 
           before we call it), we need to increment the reference count on the
           hook with the lock held.  This will ensure that the hook cannot be 
           de-registered before we're done with it. */
        if (univ_hooks.FilterHook.SendHook.Registered) 
        {
            ULONG dwFlags = 0;

            if (!ctxtp->convoy_enabled)
                dwFlags |= NLB_FILTER_HOOK_FLAGS_STOPPED;
            else if (ctxtp->draining)
                dwFlags |= NLB_FILTER_HOOK_FLAGS_DRAINING;

            NdisInterlockedIncrement(&univ_hooks.FilterHook.Interface.References);
            
            /* Release the spin lock protecting the hook. */
            NdisReleaseSpinLock(&univ_hooks.FilterHook.Lock);
            
            UNIV_ASSERT(univ_hooks.FilterHook.SendHook.Hook.SendHookFunction);
            
            TRACE_FILTER("%!FUNC! Invoking the packet send filter hook");
            
            /* Invoke the hook and save the response. */
            filter = (*univ_hooks.FilterHook.SendHook.Hook.SendHookFunction)(
                univ_adapters[ctxtp->adapter_id].device_name, 
                pPacket, 
                (PUCHAR)pPacketInfo->Ethernet.pHeader, 
                pPacketInfo->Ethernet.Length, 
                (PUCHAR)pPacketInfo->IP.pHeader, 
                pPacketInfo->IP.Length,
                dwFlags);
            
            /* Decrement the reference count on the hook now that we're done with it. */
            NdisInterlockedDecrement(&univ_hooks.FilterHook.Interface.References);
        } 
        else 
        {
            /* Release the spin lock protecting the hook. */
            NdisReleaseSpinLock(&univ_hooks.FilterHook.Lock);
        }
    }

    return filter;
}
#endif

/*
 * Function: Main_external_ioctl
 * Description: This function performs the given IOCTL on the specified device.
 * Parameters: DriverName - the unicode name of the device, e.g. \\Device\WLBS.
 *             Ioctl - the IOCTL code to invoke.
 *             pvInArg - a pointer to the input buffer.
 *             dwInSize - the size of the input buffer.
 *             pvOutArg - a pointer to the output buffer.
 *             dwOutSize - the size of the output buffer.
 * Returns: NTSTATUS - the status of the operation.
 * Author: shouse, 4.15.02
 * Notes: 
 */
NTSTATUS Main_external_ioctl (
    IN PWCHAR         DriverName,
    IN ULONG          Ioctl,
    IN PVOID          pvInArg,
    IN ULONG          dwInSize,
    IN PVOID          pvOutArg,
    IN ULONG          dwOutSize)
{
    NTSTATUS          Status;
    UNICODE_STRING    Driver;
    OBJECT_ATTRIBUTES Attrib;
    IO_STATUS_BLOCK   IOStatusBlock;
    HANDLE            Handle;

    /* Initialize the device driver device string. */
    RtlInitUnicodeString(&Driver, DriverName);
    
    InitializeObjectAttributes(&Attrib, &Driver, OBJ_CASE_INSENSITIVE, NULL, NULL);
    
    /* Open a handle to the device. */
    Status = ZwCreateFile(&Handle, SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA, &Attrib, &IOStatusBlock, NULL, 
                          FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF, 0, NULL, 0);
    
    if (!NT_SUCCESS(Status))
        return STATUS_UNSUCCESSFUL;
    
    /* Send an IOCTL to the driver. */
    Status = ZwDeviceIoControlFile(Handle, NULL, NULL, NULL, &IOStatusBlock, Ioctl, pvInArg, dwInSize, pvOutArg, dwOutSize);
    
    ZwClose(Handle);
    
    return Status;
}

/*
 * Function: Main_schedule_work_item
 * Description: This function schedules the given procedure to be invoked as part of a
 *              deferred NDIS work item, which will be scheduled to run at PASSIVE_LEVEL.
 *              This function will refernce the adapter context to keep it from being
 *              destroyed before the work item executed.  The given procedure is required
 *              to both free the memory in the work item pointer passed to it and to 
 *              dereference the adapter context before returning.
 * Parameters: ctxtp - the adapter context.
 *             funcp - the procedure to invoke when the work item fires.
 * Returns: NTSTATUS - the status of the operation; STATUS_SUCCESS if successful.
 * Author: shouse, 4.15.02
 * Notes: 
 */
NTSTATUS Main_schedule_work_item (PMAIN_CTXT ctxtp, NDIS_PROC funcp)
{
    PNDIS_WORK_ITEM pWorkItem = NULL;
    PMAIN_ADAPTER   pAdapter;
    NDIS_STATUS     status = NDIS_STATUS_SUCCESS;
    
    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

    /* Extract the MAIN_ADAPTER structure given the MAIN_CTXT. */
    pAdapter = &(univ_adapters[ctxtp->adapter_id]);
    
    NdisAcquireSpinLock(&univ_bind_lock);
    
    /* If the adapter is not initialized yet (or anymore), then we don't want to schedule a work item. */
    if (pAdapter->inited) 
    {
        /* Allocate a work item - this will be freed by the callback function. */
        status = NdisAllocateMemoryWithTag(&pWorkItem, sizeof(NDIS_WORK_ITEM), UNIV_POOL_TAG);
        
        /* If we can't allocate a work item, then just bail out - there's not much else we can do. */
        if (status == NDIS_STATUS_SUCCESS) 
        {
            /* This should definately be non-NULL if we get this far. */
            ASSERT(pWorkItem);
            
            /* Add a reference to the context to keep it from disappearing before this work item is serviced. */
            Main_add_reference(ctxtp);
            
            /* Set the callback function in the work item and set the context pointer as our callback context. */
            NdisInitializeWorkItem(pWorkItem, funcp, ctxtp);
            
            /* Add the work item to the queue. */
            status = NdisScheduleWorkItem(pWorkItem);

            /* If we fail to schedule the work item, we have to do the cleanup that the callback
               function is supposed to do ourselves. */
            if (status != NDIS_STATUS_SUCCESS) 
            {
                UNIV_PRINT_CRIT(("Main_schedule_work_item: Failed to schedule work item, status=0x%08x", status));
                TRACE_CRIT("%!FUNC! Failed to schedule work item, status=0x%08x", status);
                
                /* Release the reference on the adapter context. */
                Main_release_reference(ctxtp);
                
                /* Free the work item we allocated. */
                NdisFreeMemory(pWorkItem, sizeof(NDIS_WORK_ITEM), 0);
            }
        }
    }
    
    NdisReleaseSpinLock(&univ_bind_lock);

    return status;
}

#if defined (NLB_TCP_NOTIFICATION)
/*
 * Function: Main_get_context
 * Description: This function takes an IP interface index and translates it to an NLB
 *              adapter context pointer if a match is found; NULL otherwise.
 * Parameters: if_index - the IP interface index.
 * Returns: PMAIN_CTXT - a pointer to the corresponding NLB instance, if found; NULL otherwise.
 * Author: shouse, 4.15.02
 * Notes: 
 */
PMAIN_CTXT Main_get_context (ULONG if_index)
{
    ULONG i;
    ULONG count = 0;

    /* Loop through all of our adapters looking for a match to the given if_index and
       bail out when we find one.  Note that we assume that the same if_index cannot
       exist for two adapters; if it does, we may mistakenly return the wrong adapter.
       However, since the if_index is based on which adapter the primary cluster IP 
       address is configured and we don't allow multiple NLB instances with the same 
       primary cluster IP address, this shouldn't happen unless the administrator has 
       misconfigured TCP/IP.  Note also that while this is a loop, in the most common
       cases, we will find what we're looking for in the first one or two indexes. */
    for (i = 0; i < CVY_MAX_ADAPTERS; i++)
    {
        if (univ_adapters[i].used && univ_adapters[i].bound && univ_adapters[i].inited) 
        {
            if (univ_adapters[i].if_index == if_index)
            {
                /* Return the adapter context pointer. */
                return univ_adapters[i].ctxtp;
            }

            /* Increment the number of NLB instances we've checked so far. */
            count++;

            /* If we've checked them all, we can leave now, rather than continuing to
               loop through all CVY_MAX_ADAPTERS array entries. */
            if (count >= univ_adapters_count) break;
        }
    }

    /* Failed to find the corresponding NLB instance. */
    return NULL;
}

/* Assert that our definitions of the interesting TCP connection states
   matches those that TCP will be sending us in their notifications. */
C_ASSERT(NLB_TCP_CLOSED   == TCP_CONN_CLOSED);
C_ASSERT(NLB_TCP_SYN_SENT == TCP_CONN_SYN_SENT);
C_ASSERT(NLB_TCP_SYN_RCVD == TCP_CONN_SYN_RCVD);
C_ASSERT(NLB_TCP_ESTAB    == TCP_CONN_ESTAB);

/* Assert that both our address info buffer and TCP's address info buffer
   are, at the very least, the same size. */
C_ASSERT(sizeof(NLBTCPAddressInfo) == sizeof(TCPAddrInfo));

/*
 * Function: Main_tcp_callback_handle
 * Description: This function is invoked by TCP/IP as the state of TCP connections change.
 *              We register for this callback when the first NLB instance goes up and de-
 *              register when the last instance of NLB goes away.  When SYNs are received
 *              and TCP creates state, they use this callback to notify NLB so that it can
 *              create state to track the connection.  Likewise, when the connection is 
 *              closed, TCP notifies NLB so that it may destroy the associated state for
 *              that connection.
 * Parameters: pAddressInfo - pointer to an NLBTCPAddressInfo block.
 *             IPInterface - the IP interface, if provided, that the connection is active on.
 *             PreviousState - the previous state for this connection.
 *             CurrentState - the new state that the connection has just transitioned to.
 * Returns: Nothing.
 * Author: shouse, 4.15.02
 * Notes: 
 */
VOID Main_tcp_callback_handle (NLBTCPAddressInfo * pAddressInfo, ULONG IPInterface, ULONG PreviousState, ULONG CurrentState)
{
    UNIV_ASSERT(pAddressInfo != NULL);
     
    /* Check the TCP address information buffer. */
    if (!pAddressInfo) return;

    switch (CurrentState)
    {
    case NLB_TCP_CLOSED:
    {
        TRACE_FILTER("%!FUNC! CLOSED notification received on interface %u", IPInterface);

        UNIV_ASSERT(IPInterface == 0);

        /* Notify the load module that this TCP connection has gone down.  Send a RST to the load module instead of 
           a FIN so that it will immediately relinquish state for this connection - no need to timeout the state. 
           Note: perhaps it would be better to send a CVY_CONN_DOWN, but change the default TCP timeout in the 
           registry to zero.  That way, it would be possible to timeout TCP if necessary, but not by default. */
        (VOID)Main_conn_down(pAddressInfo->LocalIPAddress, 
                             NTOHS(pAddressInfo->LocalPort), 
                             pAddressInfo->RemoteIPAddress, 
                             NTOHS(pAddressInfo->RemotePort), 
                             TCPIP_PROTOCOL_TCP, 
                             CVY_CONN_RESET);
        
        break;
    }
    case NLB_TCP_SYN_SENT:
    {
        TRACE_FILTER("%!FUNC! SYN_SENT notification received on interface %u", IPInterface);

        UNIV_ASSERT(IPInterface == 0);
        
        /* Notify the load module that an outgoing connection has been intiated.  At this time, we do not know on
           which interface the connection will be established, so the load module will create global state to track
           the connection and when SYN+ACKs arrive, that state will be used to determine whether or not to accept
           the packet.  When the connection is finally established, we'll get an ESTAB notification, at which time
           we can move the descriptor to the appropriate load module, or remove it if applicable. */
        (VOID)Main_conn_pending(pAddressInfo->LocalIPAddress, 
                                NTOHS(pAddressInfo->LocalPort), 
                                pAddressInfo->RemoteIPAddress, 
                                NTOHS(pAddressInfo->RemotePort), 
                                TCPIP_PROTOCOL_TCP);

        break;
    }
    case NLB_TCP_SYN_RCVD:
    {
#if defined (NLB_HOOK_ENABLE)
        NLB_FILTER_HOOK_DIRECTIVE filter = NLB_FILTER_HOOK_PROCEED_WITH_HASH;
#endif
        PMAIN_CTXT                ctxtp = NULL;

        TRACE_FILTER("%!FUNC! SYN_RCVD notification received on interface %u", IPInterface);
       
        UNIV_ASSERT(IPInterface != 0);

        NdisAcquireSpinLock(&univ_bind_lock);

        /* Translate the interface index to an adapter context. */
        ctxtp = Main_get_context(IPInterface);

        /* If we did not find an NLB instance corresponding to this interface index, 
           either it is a notification for a non-NLB adapter, or the cluster is mis-
           configured such that NLB has not successfully associated an instance with
           this particular interface index as yet. */
        if (ctxtp == NULL)
        {
            TRACE_FILTER("    This notification is for a non-NLB adapter");

            NdisReleaseSpinLock(&univ_bind_lock);
            break;
        }

        UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

        /* Packets directed to the dedicated IP address are always passed through, as are subnet broadcast
           packets.  Since these packets do not require tracking information, we can return without creating
           any state in the load module. */
        if ((pAddressInfo->LocalIPAddress == ctxtp->ded_ip_addr)    || 
            (pAddressInfo->LocalIPAddress == ctxtp->ded_bcast_addr) || 
            (pAddressInfo->LocalIPAddress == ctxtp->cl_bcast_addr)  ||
            (ctxtp->cl_ip_addr == 0))
        {
            TRACE_FILTER("%!FUNC! Packet directed to the DIP or subnet broadcast");
            
            NdisReleaseSpinLock(&univ_bind_lock);
            break;
        }

        /* Reference the adapter context to keep it from disappearing while we're processing the callback. */
        Main_add_reference(ctxtp);

        NdisReleaseSpinLock(&univ_bind_lock);

#if defined (NLB_HOOK_ENABLE)
        /* Invoke the packet query hook, if one has been registered. */
        filter = Main_query_hook(ctxtp, 
                                 pAddressInfo->LocalIPAddress, 
                                 NTOHS(pAddressInfo->LocalPort), 
                                 pAddressInfo->RemoteIPAddress, 
                                 NTOHS(pAddressInfo->RemotePort), 
                                 TCPIP_PROTOCOL_TCP);
        
        /* Process some of the hook responses. */
        if (filter == NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY) 
        {
            /* If the hook asked us to reject this packet, then break out and don't create state. */
            TRACE_FILTER("%!FUNC! Packet receive filter hook: REJECT packet");

            /* Release our reference on the adapter context. */
            Main_release_reference(ctxtp);
            break;
        }
        else if (filter == NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY) 
        {
            /* If the hook asked us to accept this packet, then break out and don't create state. */
            TRACE_FILTER("%!FUNC! Packet receive filter hook: ACCEPT packet");
            
            /* Release our reference on the adapter context. */
            Main_release_reference(ctxtp);
            break;
        }
        
        /* Notify the load module that a new incoming connection has gone up on this NLB interface. */
        (VOID)Main_conn_up(ctxtp, 
                           pAddressInfo->LocalIPAddress, 
                           NTOHS(pAddressInfo->LocalPort), 
                           pAddressInfo->RemoteIPAddress, 
                           NTOHS(pAddressInfo->RemotePort), 
                           TCPIP_PROTOCOL_TCP, 
                           filter);
#else
        /* Notify the load module that a new incoming connection has gone up on this NLB interface. */
        (VOID)Main_conn_up(ctxtp, 
                           pAddressInfo->LocalIPAddress, 
                           NTOHS(pAddressInfo->LocalPort), 
                           pAddressInfo->RemoteIPAddress, 
                           NTOHS(pAddressInfo->RemotePort), 
                           TCPIP_PROTOCOL_TCP);
#endif
        
        /* Release our reference on the adapter context. */
        Main_release_reference(ctxtp);

        break;
    }
    case NLB_TCP_ESTAB:

        /* NLB currently only needs to process ESTAB notifications whose previous state was SYN_SENT.
           We need to find out on what interface the connection ended up getting established and create
           state to track it if necessary.  If the previous state was SYN_RCVD, then we already know
           what interface the connection was established on and we already have to state to track the 
           connection if necessary.  In that case, bail out now. */
        if (PreviousState == NLB_TCP_SYN_RCVD)
            break;

    {
#if defined (NLB_HOOK_ENABLE)
        NLB_FILTER_HOOK_DIRECTIVE filter = NLB_FILTER_HOOK_PROCEED_WITH_HASH;
#endif
        PMAIN_CTXT                ctxtp = NULL;
        BOOLEAN                   bFlush = FALSE;

        TRACE_FILTER("%!FUNC! ESTAB notification received on interface %u", IPInterface);

        UNIV_ASSERT(IPInterface != 0);

        NdisAcquireSpinLock(&univ_bind_lock);

        /* Translate the interface index to an adapter context. */
        ctxtp = Main_get_context(IPInterface);

        /* If we did not find an NLB instance corresponding to this interface index, 
           either it is a notification for a non-NLB adapter, or the cluster is mis-
           configured such that NLB has not successfully associated an instance with
           this particular interface index as yet.  However, if the context is NULL,
           we may still have work to do, so we don't bail out just yet.  If the context
           is non-NULL, add a reference to it to keep it from being destroyed while
           we're using it. */
        if (ctxtp != NULL)
        {
            UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

            /* Packets directed to the dedicated IP address are always passed through, as are subnet broadcast
               packets.  Since these packets do not require tracking information, we can return without creating
               any state in the load module. */
            if ((pAddressInfo->LocalIPAddress == ctxtp->ded_ip_addr)    || 
                (pAddressInfo->LocalIPAddress == ctxtp->ded_bcast_addr) || 
                (pAddressInfo->LocalIPAddress == ctxtp->cl_bcast_addr)  ||
                (ctxtp->cl_ip_addr == 0))
            {
                TRACE_FILTER("%!FUNC! Packet directed to the DIP or subnet broadcast");
                
                /* We still need to flush out any SYN_SENT information lurking in the load module. */
                bFlush = TRUE;
            }

            /* Reference the adapter context to keep it from disappearing while we're processing the callback. */
            Main_add_reference(ctxtp);
        }
        else
        {
            /* It ctxtp is NULL, that means that the connection was ultimately established
               on a non-NLB NIC.  However, we still need to flush out the temporary state 
               that was created when the SYN_SENT notification was processed. */
            bFlush = TRUE;
        }

        NdisReleaseSpinLock(&univ_bind_lock);

#if defined (NLB_HOOK_ENABLE)
        /* If the context is NULL, then we're not going to be establishing any connection
           state for this notification.  There is no need to query the hook for anything. */
        if (ctxtp != NULL)
        {
            /* Invoke the packet query hook, if one has been registered. */
            filter = Main_query_hook(ctxtp, 
                                     pAddressInfo->LocalIPAddress, 
                                     NTOHS(pAddressInfo->LocalPort), 
                                     pAddressInfo->RemoteIPAddress, 
                                     NTOHS(pAddressInfo->RemotePort), 
                                     TCPIP_PROTOCOL_TCP);
        
            /* Process some of the hook responses. */
            if (filter == NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY) 
            {
                /* If the hook asked us to reject this packet, then we can do so here. */
                TRACE_FILTER("%!FUNC! Packet receive filter hook: REJECT packet");
                
                /* If the hook told us to unconditionally reject this notification, we still 
                   need to flush out the temporary state that was created when the SYN_SENT 
                   notification was processed. */
                bFlush = TRUE;
            }
            else if (filter == NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY) 
            {
                /* If the hook asked us to accept this packet, then break out and don't create state. */
                TRACE_FILTER("%!FUNC! Packet receive filter hook: ACCEPT packet");

                /* If the hook told us to unconditionally accept this notification, we still 
                   need to flush out the temporary state that was created when the SYN_SENT 
                   notification was processed. */                
                bFlush = TRUE;
            }
        }
        
        /* Notify the load module that a new outgoing connection has been established.  Note: ctxtp CAN BE NULL, which means
           that the connection was established on a non-NLB interface or that the hook told us not to accept this connection; 
           in this case, we still need to call into the load module to allow it to cleanup the state it created when the 
           SYN_SENT notification was processed. */
        (VOID)Main_conn_establish(bFlush ? NULL : ctxtp,
                                  pAddressInfo->LocalIPAddress, 
                                  NTOHS(pAddressInfo->LocalPort), 
                                  pAddressInfo->RemoteIPAddress, 
                                  NTOHS(pAddressInfo->RemotePort), 
                                  TCPIP_PROTOCOL_TCP, 
                                  filter);
#else
        /* Notify the load module that a new outgoing connection has been established.  Note: ctxtp CAN BE NULL, which means
           that the connection was established on a non-NLB interface; in this case, we still need to call into the load
           module to allow it to cleanup the state it created when the SYN_SENT notification was processed. */
        (VOID)Main_conn_establish(bFlush ? NULL : ctxtp,
                                  pAddressInfo->LocalIPAddress, 
                                  NTOHS(pAddressInfo->LocalPort), 
                                  pAddressInfo->RemoteIPAddress, 
                                  NTOHS(pAddressInfo->RemotePort), 
                                  TCPIP_PROTOCOL_TCP);
#endif
        
        if (ctxtp != NULL)
        {
            /* Release our reference on the adapter context. */
            Main_release_reference(ctxtp);
        }

        break;
    }
    default:
        TRACE_CRIT("%!FUNC! Unknown notification received on interface %u", IPInterface);
        break;
    }
}

/*
 * Function: Main_tcp_callback
 * Description: This function is invoked by TCP/IP as the state of TCP connections change.
 *              We register for this callback when the first NLB instance goes up and de-
 *              register when the last instance of NLB goes away.  When SYNs are received
 *              and TCP creates state, they use this callback to notify NLB so that it can
 *              create state to track the connection.  Likewise, when the connection is 
 *              closed, TCP notifies NLB so that it may destroy the associated state for
 *              that connection.
 * Parameters: Context - NULL, unused.
 *             Argument1 - pointer to a TCPCcbInfo structure (See net\published\inc\tcpinfo.w).
 *             Argument2 - NULL, unused.
 * Returns: Nothing.
 * Author: shouse, 4.15.02
 * Notes: 
 */
VOID Main_tcp_callback (PVOID Context, PVOID Argument1, PVOID Argument2)
{
    TCPCcbInfo * pTCPConnInfo = (TCPCcbInfo *)Argument1;
    
    /* If TCP notifications are not on, we should not be here - return. */
    if (!NLB_TCP_NOTIFICATION_ON()) return;

    UNIV_ASSERT(pTCPConnInfo);

    /* Check the input buffer from TCP. */
    if (!pTCPConnInfo) return;

    /* Handle the TCP connection notification.  Note that we are passing in an TCPAddrInfo 
       pointer, while this function expects an NLBTCPAddressInfo buffer.  Therefore, it is
       important to ensure that these two structures are in fact one in the same. */
    Main_tcp_callback_handle((NLBTCPAddressInfo *)pTCPConnInfo->tci_connaddr, 
                             pTCPConnInfo->tci_incomingif, 
                             pTCPConnInfo->tci_prevstate, 
                             pTCPConnInfo->tci_currstate);
}

/*
 * Function: Main_alternate_callback
 * Description: This function is invoked by external components as the state of connections 
 *              change.  We register for this callback when the first NLB instance goes up 
 *              and de-register when the last instance of NLB goes away.  When connections
 *              are created and a protocol creates state, they use this callback to notify
 *              NLB so that it can create state to track the connection.  Likewise, when the 
 *              connection is closed, the protocol notifies NLB so that it may destroy the 
 *              associated state for that connection.
 * Parameters: Context - NULL, unused.
 *             Argument1 - pointer to a NLBConnectionInfo structure (See net\published\inc\ntddnlb.w).
 *             Argument2 - NULL, unused.
 * Returns: Nothing.
 * Author: shouse, 8.1.02
 * Notes: 
 */
VOID Main_alternate_callback (PVOID Context, PVOID Argument1, PVOID Argument2)
{
    NLBConnectionInfo * pConnInfo = (NLBConnectionInfo *)Argument1;

    /* If NLB public notifications are not on, we should not be here - return. */
    if (!NLB_ALTERNATE_NOTIFICATION_ON()) return;

    UNIV_ASSERT(pConnInfo);

    /* Check the input buffer. */
    if (!pConnInfo) return;

    /* Only TCP notifications are currently supported. */
    UNIV_ASSERT(pConnInfo->Protocol == NLB_TCPIP_PROTOCOL_TCP);

    switch (pConnInfo->Protocol)
    {
    case NLB_TCPIP_PROTOCOL_TCP:

        UNIV_ASSERT(pConnInfo->pTCPInfo);

        /* Check the TCP connection input buffer. */
        if (!pConnInfo->pTCPInfo) return;

        /* Handle the TCP connection notification. */
        Main_tcp_callback_handle(&pConnInfo->pTCPInfo->Address, 
                                 pConnInfo->pTCPInfo->IPInterface, 
                                 pConnInfo->pTCPInfo->PreviousState, 
                                 pConnInfo->pTCPInfo->CurrentState);

        break;
    default:
        /* Notifications for this protocol are not supported. */
        break;
    }
}

/*
 * Function: Main_set_interface_index
 * Description: This function is called as a result of either the IP address table being
 *              modified (triggers a OID_GEN_NETWORK_LAYER_ADDRESSES NDIS request), or 
 *              when the NLB instance is reloaded (IOCTL_CVY_RELOAD).  This function 
 *              retrieves the IP address table from IP and searches for its primary
 *              cluster IP address in the table.  If it finds it, it notes the IP interface
 *              index on which the primary cluster IP address is configured; this infor-
 *              mation is required in order to process TCP connection notifcation callbacks.
 *              If NLB cannot find its primary cluster IP address in the IP table, or 
 *              if the cluster is misconfigured (primary cluster IP address configured on
 *              the wrong NIC, perhaps), NLB will be unable to properly handle notifications.
 *              Because this function performs IOCTLs on other drivers, it MUST run at 
 *              PASSIVE_LEVEL, in which case NDIS work items might be required to invoke it.
 * Parameters: pWorkItem - the work item pointer, which must be freed if non-NULL.
 *             nlbctxt - the adapter context.
 * Returns: Nothing.
 * Author: shouse, 4.15.02
 * Notes: Note that the code that sets up this work item MUST increment the reference
 *        count on the adapter context BEFORE adding the work item to the queue.  This
 *        ensures that when this callback is executed, the context will stiil be valid,
 *        even if an unbind operation is pending.  This function must free the work
 *        item memory and decrement the reference count - both, whether this function
 *        can successfully complete its task OR NOT.
 */
VOID Main_set_interface_index (PNDIS_WORK_ITEM pWorkItem, PVOID nlbctxt) {
    TCP_REQUEST_QUERY_INFORMATION_EX TrqiInBuf;
    IPSNMPInfo                       IPSnmpInfo;
    PUCHAR                           Context;
    IPAddrEntry *                    pIpAddrTbl;
    TDIObjectID *                    ID;
    ULONG                            IpAddrCount;
    ULONG                            Status;
    ULONG                            dwInBufLen;
    ULONG                            dwOutBufLen;
    KIRQL                            irql;
    ULONG                            k;
    PMAIN_ADAPTER                    pAdapter;
    PMAIN_CTXT                       ctxtp = (PMAIN_CTXT)nlbctxt;

    /* Do some sanity checking on the context - make sure that the MAIN_CTXT code 
       is correct and that its properly attached to an adapter, etc. */
    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

    /* From the context, find the adapter structure, which is where we store
       the IP interface index. */
    pAdapter = &(univ_adapters[ctxtp->adapter_id]);
    
    UNIV_ASSERT(pAdapter->code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT(pAdapter->ctxtp == ctxtp);

    /* Might as well free the work item now - we don't need it. */
    if (pWorkItem)
        NdisFreeMemory(pWorkItem, sizeof(NDIS_WORK_ITEM), 0);

    /* Grab the bind lock. */
    NdisAcquireSpinLock(&univ_bind_lock);
    
    /* Make sure that another if_index update is not in progress. */
    while (pAdapter->if_index_operation != IF_INDEX_OPERATION_NONE) {
        /* Release the bind lock. */
        NdisReleaseSpinLock(&univ_bind_lock);
        
        /* Sleep while some other operation is in progress. */
        Nic_sleep(10);
        
        /* Grab the bind lock. */
        NdisAcquireSpinLock(&univ_bind_lock);
    }

    /* Update the operation flag to reflect the update in progress. */
    pAdapter->if_index_operation = IF_INDEX_OPERATION_UPDATE;
    
    /* Release the bind lock. */
    NdisReleaseSpinLock(&univ_bind_lock);

    /* This shouldn't happen, but protect against it anyway - we cannot manipulate
       the registry if we are at an IRQL > PASSIVE_LEVEL, so bail out. */
    if ((irql = KeGetCurrentIrql()) > PASSIVE_LEVEL) {
        UNIV_PRINT_CRIT(("Main_set_interface_index: IRQL(%u) > PASSIVE_LEVEL(%u), exiting...", irql, PASSIVE_LEVEL));
        TRACE_CRIT("%!FUNC! IRQL(%u) > PASSIVE_LEVEL(%u), exiting...", irql, PASSIVE_LEVEL);
        goto failure;
    }

    /* If the cluster IP address has not been set, don't even bother to look for
       it in the IP address tables; we'd just be wasting cycles. */
    if (ctxtp->cl_ip_addr == 0) {
        UNIV_PRINT_CRIT(("Main_set_interface_index: Primary cluster IP address is not set"));
        TRACE_CRIT("%!FUNC! Primary cluster IP address is not set");
        goto failure;
    }
    
    /* Grab a few pointers to pieces of the request. */
    ID = &(TrqiInBuf.ID);
    Context = (PUCHAR)&(TrqiInBuf.Context[0]);

    /* Calculate the input and output buffer lengths for the IOCTL. */
    dwInBufLen = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutBufLen = sizeof(IPSNMPInfo);

    /* Fill in the IP stats request.  This is used only to get the 
       size of the IP address table from TCP/IP. */
    ID->toi_entity.tei_entity   = CL_NL_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_PROTOCOL;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = IP_MIB_STATS_ID;

    NdisZeroMemory(Context, CONTEXT_SIZE);

    /* Send the request to TCP/IP via an IOCTL. */
    Status = Main_external_ioctl(DD_TCP_DEVICE_NAME, IOCTL_TCP_QUERY_INFORMATION_EX, (PVOID)&TrqiInBuf, sizeof(TCP_REQUEST_QUERY_INFORMATION_EX), (PVOID)&IPSnmpInfo, dwOutBufLen);

    if(NT_SUCCESS(Status)) 
    {
        /* Calculate the size of the buffer necessary to hold the entire IP address table. */
        IpAddrCount = IPSnmpInfo.ipsi_numaddr + 10;
        dwOutBufLen = IpAddrCount * sizeof(IPAddrEntry);

        /* Allocate a buffer for the IP address table. */
        Status = NdisAllocateMemoryWithTag(&pIpAddrTbl, dwOutBufLen, UNIV_POOL_TAG);

        if(!pIpAddrTbl) {
            UNIV_PRINT_CRIT(("Main_set_interface_index: Could not allocate memory for %d IP addresses", IPSnmpInfo.ipsi_numaddr + 10));
            TRACE_CRIT("%!FUNC! Could not allocate memory for %d IP addresses", IPSnmpInfo.ipsi_numaddr + 10);
            goto failure;
        }

        NdisZeroMemory(pIpAddrTbl, dwOutBufLen);
   
        /* Fill in the IP address table request.  This is used to retrieve
           the entire IP address table from TCP/IP. */
        ID->toi_type = INFO_TYPE_PROVIDER;
        ID->toi_id   = IP_MIB_ADDRTABLE_ENTRY_ID;

        NdisZeroMemory(Context, CONTEXT_SIZE); 

        /* Send the request to TCP/IP via an IOCTL. */
        Status = Main_external_ioctl(DD_TCP_DEVICE_NAME, IOCTL_TCP_QUERY_INFORMATION_EX, (PVOID)&TrqiInBuf, sizeof(TCP_REQUEST_QUERY_INFORMATION_EX), (PVOID)pIpAddrTbl, dwOutBufLen);

        if(!NT_SUCCESS(Status))
        {
            /* Free the IP address table buffer. */
            NdisFreeMemory(pIpAddrTbl, dwOutBufLen, 0);

            UNIV_PRINT_CRIT(("Main_set_interface_index: IP_MIB_ADDRTABLE_ENTRY_ID failed with status=0x%08x", Status));
            TRACE_CRIT("%!FUNC! IP_MIB_ADDRTABLE_ENTRY_ID failed with status=0x%08x", Status);
            goto failure;
        }
    }
    else 
    {
        UNIV_PRINT_CRIT(("Main_set_interface_index: IP_MIB_STATS_ID failed with status=0x%08x", Status));
        TRACE_CRIT("%!FUNC! IP_MIB_STATS_ID failed with status=0x%08x", Status);
        goto failure;
    }

    /* Loop through the IP address table looking for our primary cluster IP address. 
       If we don't find it, this is a misconfigure, as the user has not yet added the
       cluster IP address to TCP/IP.  No matter; when they do, we should trap the 
       NDIS request to set the NETwORK_ADDRESS table and we'll fire off another 
       attempt at this. */
    for (k = 0; k < IpAddrCount; k++)
    {
        if (pIpAddrTbl[k].iae_addr == ctxtp->cl_ip_addr) 
            break;
    }

    /* If we couldn't find our cluster IP address in the list, set the interface 
       index to an invalid value. */
    if (k >= IpAddrCount)
    {
        /* Free the IP address table buffer. */
        NdisFreeMemory(pIpAddrTbl, dwOutBufLen, 0);
        
        UNIV_PRINT_CRIT(("Main_set_interface_index: Did not find the primary cluster IP address (%u.%u.%u.%u) in the IP address table", 
                         IP_GET_OCTET(ctxtp->cl_ip_addr, 0), IP_GET_OCTET(ctxtp->cl_ip_addr, 1), IP_GET_OCTET(ctxtp->cl_ip_addr, 2), IP_GET_OCTET(ctxtp->cl_ip_addr, 3)));
        TRACE_CRIT("%!FUNC! Did not find the primary cluster IP address (%u.%u.%u.%u) in the IP address table", 
                   IP_GET_OCTET(ctxtp->cl_ip_addr, 0), IP_GET_OCTET(ctxtp->cl_ip_addr, 1), IP_GET_OCTET(ctxtp->cl_ip_addr, 2), IP_GET_OCTET(ctxtp->cl_ip_addr, 3));
        goto failure;
    }

    /* If we found our cluster IP address in the list, note the interface index. */
    NdisAcquireSpinLock(&univ_bind_lock);
    pAdapter->if_index = pIpAddrTbl[k].iae_index;
    NdisReleaseSpinLock(&univ_bind_lock);
    
    /* Free the IP address table buffer. */
    NdisFreeMemory(pIpAddrTbl, dwOutBufLen, 0);
    
    UNIV_PRINT_INFO(("Main_set_interface_index: NLB cluster %u.%u.%u.%u maps to IP interface %u", 
                     IP_GET_OCTET(ctxtp->cl_ip_addr, 0), IP_GET_OCTET(ctxtp->cl_ip_addr, 1), IP_GET_OCTET(ctxtp->cl_ip_addr, 2), IP_GET_OCTET(ctxtp->cl_ip_addr, 3), pAdapter->if_index));
    TRACE_INFO("%!FUNC! NLB cluster %u.%u.%u.%u maps to IP interface %u", 
               IP_GET_OCTET(ctxtp->cl_ip_addr, 0), IP_GET_OCTET(ctxtp->cl_ip_addr, 1), IP_GET_OCTET(ctxtp->cl_ip_addr, 2), IP_GET_OCTET(ctxtp->cl_ip_addr, 3), pAdapter->if_index);
    
    goto exit;
    
 failure:

    NdisAcquireSpinLock(&univ_bind_lock);
    pAdapter->if_index = 0;
    NdisReleaseSpinLock(&univ_bind_lock);

 exit:

    /* If the work item pointer is non-NULL, then we were called as the result of 
       scheduling an NDIS work item.  In that case, the reference count on the 
       context was incremented to ensure that the context did not disappear before
       this work item was completed; therefore, we need to decrement the reference
       count here.  If the work item pointer is NULL, then this function was called
       internally directly.  In that case, the reference count was not incremented 
       and therefore there is no need to decrement it here.

       Note that if the function is called internally, but without setting the work
       item parameter to NULL, the reference count will be skewed and may cause 
       either invalid memory references later or block unbinds from completing. */
    if (pWorkItem)
        Main_release_reference(ctxtp);

    /* Update the operation flag to reflect the completion of the update. */
    pAdapter->if_index_operation = IF_INDEX_OPERATION_NONE;

    return;
}
#endif

/*
 * Function: Main_add_reference
 * Description: This function adds a reference to the context of a given adapter.
 * Parameters: ctxtp - a pointer to the context to reference.
 * Returns: ULONG - The incremented value.
 * Author: shouse, 3.29.01
 * Notes: 
 */
ULONG Main_add_reference (IN PMAIN_CTXT ctxtp) {

    /* Assert that the context pointer actually points to something. */
    UNIV_ASSERT(ctxtp);

    /* Increment the reference count. */
    return NdisInterlockedIncrement(&ctxtp->ref_count);
}

/*
 * Function: Main_release_reference
 * Description: This function releases a reference on the context of a given adapter.
 * Parameters: ctxtp - a pointer to the context to dereference.
 * Returns: ULONG - The decremented value.
 * Author: shouse, 3.29.01
 * Notes: 
 */
ULONG Main_release_reference (IN PMAIN_CTXT ctxtp) {

    /* Assert that the context pointer actually points to something. */
    UNIV_ASSERT(ctxtp);

    /* Decrement the reference count. */
    return NdisInterlockedDecrement(&ctxtp->ref_count);
}

/*
 * Function: Main_get_reference_count
 * Description: This function returns the current context reference count on a given adapter.
 * Parameters: ctxtp - a pointer to the context to check.
 * Returns: ULONG - The current reference count.
 * Author: shouse, 3.29.01
 * Notes: 
 */
ULONG Main_get_reference_count (IN PMAIN_CTXT ctxtp) {

    /* Assert that the context pointer actually points to something. */
    UNIV_ASSERT(ctxtp);

    /* Return the reference count. */
    return ctxtp->ref_count;
}

/*
 * Function: Main_apply_without_restart
 * Description: This function checks the new set of NLB parameters against the old
 *              set to determine whether or not the changes can be made without
 *              stopping and starting the load module, which destroys all connection
 *              state on the adapter (this is bad).  If the only changes were to
 *              parameters that can be changed without resetting the load module,
 *              such as port rule load weights, then the changes will be made here
 *              and the load module will not be stopped and re-started.  
 * Parameters: ctxtp - a pointer to the context structure for the adapter being reloaded.
 *             pOldParams - a pointer to the "old" NLB parameters.
 *             pCurParams - a pointer to the "new" NLB parameters.
 * Returns: BOOLEAN - if TRUE, the changes were made here and there is no need to reset 
 *          the load module.
 * Author: fengsun, 9.15.00
 * Notes: 
 */
BOOLEAN Main_apply_without_restart (PMAIN_CTXT ctxtp, PCVY_PARAMS pOldParams, PCVY_PARAMS pCurParams) 
{
    CVY_RULE OldRules[CVY_MAX_RULES - 1];
    ULONG    NewWeight;
    ULONG    i;
    BOOLEAN  bAttemptToFireReloadEvent;

    if (pOldParams->num_rules != pCurParams->num_rules)
    {
        return FALSE;
    }

    UNIV_ASSERT(sizeof(OldRules) == sizeof(pOldParams->port_rules));

    /* Copy the Netmon heartbeat message flag from the new params to the old params. */
    pOldParams->netmon_alive = pCurParams->netmon_alive;

    /* Save the old port rules for later comparison. */
    RtlCopyMemory(OldRules, pOldParams->port_rules, sizeof(OldRules));

    /* Copy the new rule weight over the old settings. */
    for (i = 0; i < pCurParams->num_rules; i++) {
        if (pCurParams->port_rules[i].mode == CVY_MULTI) {
            pOldParams->port_rules[i].mode_data.multi.equal_load = pCurParams->port_rules[i].mode_data.multi.equal_load;
            pOldParams->port_rules[i].mode_data.multi.load       = pCurParams->port_rules[i].mode_data.multi.load;
        }
    }

    if (RtlCompareMemory(pOldParams, pCurParams, sizeof(CVY_PARAMS)) != sizeof(CVY_PARAMS))
    {
        return FALSE;
    }

    bAttemptToFireReloadEvent = FALSE;

    for (i = 0; i < pCurParams->num_rules; i++) {
        switch (OldRules[i].mode) {
        case CVY_MULTI:
            if (OldRules[i].mode_data.multi.equal_load && pCurParams->port_rules[i].mode_data.multi.equal_load)
                continue;

            if (!OldRules[i].mode_data.multi.equal_load && !pCurParams->port_rules[i].mode_data.multi.equal_load &&
                (OldRules[i].mode_data.multi.load == pCurParams->port_rules[i].mode_data.multi.load))
                continue;

            if (pCurParams->port_rules[i].mode_data.multi.equal_load)
                NewWeight = CVY_EQUAL_LOAD;
            else
                NewWeight = pCurParams->port_rules[i].mode_data.multi.load;

            UNIV_PRINT_VERB(("Main_apply_without_restart: Calling Load_port_change -> VIP=%08x, port=%d, load=%d\n", OldRules[i].virtual_ip_addr, OldRules[i].start_port, NewWeight));
            TRACE_VERB("%!FUNC! Main_apply_without_restart: Calling Load_port_change -> VIP=0x%08x, port=%d, load=%d", OldRules[i].virtual_ip_addr, OldRules[i].start_port, NewWeight);

            // If enabled, fire wmi event indicating reloading of nlb on this node
            // This is to be done only once, hence the bAttemptToFireReloadEvent flag.
            // This is the only place in the code where the event is fired BEFORE the action
            // takes place. We could not fire this event after the action took place, i.e. 
            // from within Load_port_change 'cos from within Load_port_change, we could not 
            // distinguish between the first & the subsequent calls (for each port rule) to it.
            // We need to distinguish 'cos this event is to be fired only for the first call
            if (bAttemptToFireReloadEvent == FALSE) 
            {
                bAttemptToFireReloadEvent = TRUE;
                if (NlbWmiEvents[NodeControlEvent].Enable)
                {
                    NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_RELOADED);
                }
                else 
                {
                    TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_NODE_RELOADED 'cos NodeControlEvent generation disabled");
                }
            }
                       
            Load_port_change(&ctxtp->load, OldRules[i].virtual_ip_addr, OldRules[i].start_port, IOCTL_CVY_PORT_SET, NewWeight);

            break;
        case CVY_SINGLE:
        case CVY_NEVER:
        default:
            break;
        }
    }

    LOG_MSG(MSG_INFO_CONFIGURE_CHANGE_CONVERGING, MSG_NONE);
    return TRUE;
}

/*
 * Function: Main_alloc_team
 * Description: This function allocates and initializes a BDA_TEAM structure.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter
 * Returns: PBDA_TEAM - a pointer to a new BDA_TEAM structure if successful, NULL if not.
 * Author: shouse, 3.29.01
 * Notes: 
 */
PBDA_TEAM Main_alloc_team (IN PMAIN_CTXT ctxtp, IN PWSTR team_id) {
    PUCHAR      ptr;
    PBDA_TEAM   team;
    NDIS_STATUS status;

    /* Allocate a BDA_TEAM structure. */
    status = NdisAllocateMemoryWithTag(&ptr, sizeof(BDA_TEAM), UNIV_POOL_TAG);
    
    if (status != NDIS_STATUS_SUCCESS) {
        UNIV_PRINT_CRIT(("Main_alloc_team: Unable to allocate a team.  Exiting..."));
        TRACE_CRIT("%!FUNC! Unable to allocate a team");
        LOG_MSG2(MSG_ERROR_MEMORY, MSG_NONE, sizeof(BDA_TEAM), status);
        return NULL;
    }

    /* Make sure that ptr actually points to something. */
    UNIV_ASSERT(ptr);

    /* Zero the memory out. */
    NdisZeroMemory(ptr, sizeof(BDA_TEAM));

    /* Cast the new memory to a team pointer. */
    team = (PBDA_TEAM)ptr;

    /* Set the default field values.  This is redundant (since 
       we just called NdisZeroMemory), but whatever. */
    team->prev = NULL;
    team->next = NULL;
    team->load = NULL;
    team->load_lock = NULL;
    team->active = FALSE;
    team->membership_count = 0;
    team->membership_fingerprint = 0;
    team->membership_map = 0;
    team->consistency_map = 0;

    /* Copy the team ID into the team structure.  Note that the Team ID will be
     NULL-terminated implicitly by the NdisZeroMemory call above. */
    NdisMoveMemory(team->team_id, team_id, CVY_MAX_BDA_TEAM_ID * sizeof(WCHAR));

    return team;
}

/*
 * Function: Main_free_team
 * Description: This function frees the memory used by a BDA_TEAM.
 * Parameters: team - a pointer to the team to be freed.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: 
 */
VOID Main_free_team (IN PBDA_TEAM team) {
 
    /* Make sure that team actually points to something. */
    UNIV_ASSERT(team);

    /* Free the memory that the team structure is using. */
    NdisFreeMemory((PUCHAR)team, sizeof(BDA_TEAM), 0);
}

/*
 * Function: Main_find_team
 * Description: This function searches the linked list of teams looking for
 *              a given team ID.  If team with the same ID is found, a pointer
 *              to that team is returned, otherwise NULL is returned to indicate
 *              that no such team exists.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this team.
 *             team_id - a unicode string containing the team ID, which must be a GUID.
 * Returns: PBDA_TEAM - a pointer to the team if found, NULL otherwise.
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the global teaming lock already acquired!!!
 */
PBDA_TEAM Main_find_team (IN PMAIN_CTXT ctxtp, IN PWSTR team_id) {
    PBDA_TEAM team;
    
    /* We should be at PASSIVE_LEVEL - %ls is OK.  However, be extra paranoid, just in case.  If 
       we're at DISPATCH_LEVEL, then just log an unknown adapter print - don't specify the GUID. */
    if (KeGetCurrentIrql() <= PASSIVE_LEVEL) {
        UNIV_PRINT_VERB(("Main_find_team: Looking for %ls.  Entering...", team_id));
    } else {
        UNIV_PRINT_VERB(("Main_find_team: Looking for (IRQ level too high to print hook GUID).  Entering...", team_id));
    }

    /* Loop through all teams in the linked list.  If we find a matching
       team ID, return a pointer to the team; otherwise, return NULL. */
    for (team = univ_bda_teaming_list; team; team = team->next) {
        /* If we have a match, return a pointer to the team. */
        if (Univ_equal_unicode_string(team->team_id, team_id, wcslen(team->team_id))) {
            UNIV_PRINT_VERB(("Main_find_team: Team found.  Exiting..."));
            return team;
        }
    }

    UNIV_PRINT_VERB(("Main_find_team: Team not found.  Exiting..."));

    return NULL;
}

/*
 * Function: Main_teaming_get_member_id
 * Description: This function assigns a team member a unique, zero-indexed integer ID, 
 *              which is used by the member as in index in a consistency bit map.  Each 
 *              member sets their bit in the consistecy bit map, based on heartbeat 
 *              observations, that is used by the master of the team to determine whether
 *              or not the team should be in an active state.
 * Parameters: team - a pointer to the team which the adapter is joining.
 *             id - out parameter to hold the new ID.
 * Returns: BOOLEAN - always TRUE now, but there may be a need to return failure in the future.
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the team lock already acquired!!!
 */
BOOLEAN Main_teaming_get_member_id (IN PBDA_TEAM team, OUT PULONG id) {
    ULONG index;
    ULONG map;

    /* Make sure that team actually points to something. */
    UNIV_ASSERT(team);

    /* Make sure that ID actually points to something. */
    UNIV_ASSERT(id);

    /* Loop through the membership map looking for the first reset bit.  Because members
       can come and go, this bit will not always be in the (num_membes)th position.  For 
       example, it is perfectly plausible for the membership_map to look like (binary)
       0000 0000 0000 0000 0000 0100 1110 0111, in which case the ID returned by this 
       function would be three. */
    for (index = 0, map = team->membership_map; 
         index <= CVY_BDA_MAXIMUM_MEMBER_ID, map; 
         index++, map >>= 1)
        if (!(map & 0x00000001)) break;

    /* We assert that the index must be less than the maximum number of adapters 
       (CVY_BDA_MAXIMUM_MEMBER_ID = CVY_MAX_ADAPTERS - 1). */
    UNIV_ASSERT(index <= CVY_BDA_MAXIMUM_MEMBER_ID);

    /* Set the member ID. */
    *id = index;

    /* Set our bit in the membership map. */
    team->membership_map |= (1 << *id);

    /* Set our bit in the consistency map.  By default, we assume that this member
       is consistent and heartbeats on this adapter can deternmine otherwise. */
    team->consistency_map |= (1 << *id);

    /* We may have reason to fail this call in the future, but for now, we always succeed. */
    return TRUE;
}

/*
 * Function: Main_teaming_put_member_id
 * Description: This function is called when a member leaves its team, at which
 *              time its ID is put back into the ID pool.
 * Parameters: team - a pointer to the team which this adapter is leaving.
 *             id - the ID, which this function will reset before returning.
 * Returns: BOOLEAN - always TRUE now, but there may be a need to return failure in the future.
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the team lock already acquired!!!
 */
BOOLEAN Main_teaming_put_member_id (IN PBDA_TEAM team, IN OUT PULONG id) {

    /* Make sure that team actually points to something. */
    UNIV_ASSERT(team);

    /* Make sure that ID actually points to something. */
    UNIV_ASSERT(id);

    /* Reet our bit in the membership map.  This effectively prevents 
       us from influencing the active state of the team. */
    team->membership_map &= ~(1 << *id);

    /* Reet our bit in the consistency map. */
    team->consistency_map &= ~(1 << *id);

    /* Set the member ID back to an invalid value. */
    *id = CVY_BDA_INVALID_MEMBER_ID;

    /* We may have reason to fail this call in the future, but for now, we always succeed. */
    return TRUE;
}

/*
 * Function: Main_queue_team
 * Description: This fuction queues a team onto the global doubly-linked list of BDA teams
 *              (univ_bda_teaming_list).  Insertions always occur at the front of the list.
 * Parameters: team - a pointer to the team to queue onto the list.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the global teaming lock already acquired!!!
 */
VOID Main_queue_team (IN PBDA_TEAM team) {

    /* Make sure that team actually points to something. */
    UNIV_ASSERT(team);

    /* Insert at the head of the list by setting next to the current 
       head and pointing the global head pointer to the new team. */
    team->prev = NULL;
    team->next = univ_bda_teaming_list;
    univ_bda_teaming_list = team;

    /* If we are not the only team in the list, then we have to 
       set my successor's previous pointer to point to me. */
    if (team->next) team->next->prev = team;
}

/*
 * Function: Main_dequeue_team
 * Description: This function removes a given team from the global doubly-linked 
 *              list of teams (univ_bda_teaming_list).
 * Parameters: team - a pointer to the team to remove from the list.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the global teaming lock already acquired!!!
 */
VOID Main_dequeue_team (IN PBDA_TEAM team) {

    /* Make sure that team actually points to something. */
    UNIV_ASSERT(team);

    /* Special case when we are the first team in the list, in which case, we
       have no previous pointer and the head of the list needs to be reset. */
    if (!team->prev) {
        /* Point the global head of the list to the next team in the list, 
           which CAN be NULL, meaning that the list is now empty. */
        univ_bda_teaming_list = team->next;
        
        /* If there was a team after me in the list, who is now the new 
           head of the list, set its previous pointer to NULL. */
        if (team->next) team->next->prev = NULL;
    } else {
        /* Point the previous node's next pointer to my successor in the
           list, which CAN be NULL if I was the last team in the list. */
        team->prev->next = team->next;

        /* If there is a team after me in the list, point its previous 
           pointer to my predecessor. */
        if (team->next) team->next->prev = team->prev;
    }
}

/*
 * Function: Main_get_team
 * Description: This function returns a team for the given team ID.  If the team already
 *              exists in the global teaming list, it is returned.  Otherwise, a new team
 *              is allocated, initialized and returned.  Before a team is returned, however,
 *              it is properly referenced by incrementing the reference count (membership_count),
 *              assigning a team member ID to the requestor and fingerprinting the team with
 *              the member's primary cluster IP address.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             team_id - a unicode string (GUID) uniquely identifying the team to retrieve.
 * Returns: PBDA_TEAM - a pointer to the requested team.  NULL if it does not exists and
 *          a new team cannot be allocated, or if the team ID is invalid (empty).
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the global teaming lock already acquired!!!
 */
PBDA_TEAM Main_get_team (IN PMAIN_CTXT ctxtp, IN PWSTR team_id) {
    PBDA_TEAM team;

    /* Make sure that team_id actually points to something. */
    if (!team_id || team_id[0] == L'\0') {
        UNIV_PRINT_CRIT(("Main_get_team: Invalid parameter.  Exiting..."));
        TRACE_CRIT("%!FUNC! Invalid parameter.  Exiting...");
        return NULL;
    }

    /* Try to find a previous instance of this team in the global list.
       If we can't find it in the list, then allocate a new team. */
    if (!(team = Main_find_team(ctxtp, ctxtp->params.bda_teaming.team_id))) {
        /* Allocate and initialize a new team. */
        if (!(team = Main_alloc_team(ctxtp, ctxtp->params.bda_teaming.team_id))) {
            UNIV_PRINT_CRIT(("Main_get_team: Error attempting to allocate memory for a team.  Exiting..."));
            TRACE_CRIT("%!FUNC! Error attempting to allocate memory for a team.  Exiting...");
            return NULL;
        }
     
        /* If a new team was allocated, insert it into the list. */
        Main_queue_team(team);
    }

    /* Increment the reference count on this team.  This reference count prevents
       a team from being destroyed while somebody is still using it. */
    team->membership_count++;

    /* Get a team member ID, which is my index into the consistency bit map. */
    Main_teaming_get_member_id(team, &ctxtp->bda_teaming.member_id);

    /* The fingerprint field is a cumulative XOR of all primary cluster IPs in the team.  We
       only use the two least significant bytes of the cluster IP, which, because the 
       cluster IP address is stored in host order, are the two most significant bytes. */    
    team->membership_fingerprint ^= ((ctxtp->cl_ip_addr >> 16) & 0x0000ffff);

    return team;
}

/*
 * Function: Main_put_team
 * Description: This function releases a reference on a team and frees the team if
 *              no references remain.  Dereferencing includes decrementing the 
 *              membership_count, releasing this member's ID and removing our
 *              fingerprint from the team.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             team - a pointer to the team to dereference.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the global teaming lock already acquired!!!
 */
VOID Main_put_team (IN PMAIN_CTXT ctxtp, IN PBDA_TEAM team) {
    
    /* Make sure that team actually points to something. */
    UNIV_ASSERT(team);

    /* The fingerprint field is a cumulative XOR of all primary cluster IPs in the team.  
       We only use the two least significant bytes of the cluster IP, which, because the 
       cluster IP address is stored in host order, are the two most significant bytes. 
       Because a fingerprint is an XOR, the act of removing our fingerprint is the same
       as it was to add it - we simply XOR our primary cluster IP address to remove it. 
       ((NUM1 ^ NUM2) ^ NUM2) equals NUM1. */    
    team->membership_fingerprint ^= ((ctxtp->cl_ip_addr >> 16) & 0x0000ffff);

    /* Release our team member ID back into the free pool. */
    Main_teaming_put_member_id(team, &ctxtp->bda_teaming.member_id);

    /* Decrement the number of adapters in this team and remove and free the team 
       if this is the last reference on the team. */
    if (!--team->membership_count) {
        /* Remove the team from the list. */
        Main_dequeue_team(team);

        /* Free the memory used by the team. */
        Main_free_team(team);
    }
}

/*
 * Function: Main_teaming_check_consistency
 * Description: This function is called by all adapters during Main_ping, wherein
 *              the master of every team should check its team for consitency and
 *              mark the team active if it is consistent.  Teams are marked incon-
 *              sistent and inactive by the load module or when the master of an 
 *              existing team is removed.  Because on the master performs the con-
 *              sistency check in this function, a team without a master can NEVER
 *              be marked active.
 * Parameters: ctxtp - a pointer to the adapter's MAIN_CTXT structure.
 * Returns: Nothing
 * Author: shouse, 3.29.01
 * Notes: This function acquires the global teaming lock.
 */
VOID Main_teaming_check_consistency (IN PMAIN_CTXT ctxtp) {
    PBDA_TEAM team;

    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we aren't teaming, just bail out here; if we really aren't teaming,
       or are in the process of leaving a team, then no worries; if however, we were
       teaming or in the process of joining a team, then we'll just catch this
       the next time through.  If we do think we're teaming, then we'll go ahead
       and grab the global lock to make sure. */
    if (!ctxtp->bda_teaming.active)
    {
        return;
    }

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* If we actually aren't part of a team, bail out - nothing to do. */
    if (!ctxtp->bda_teaming.active) {
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return;
    }

    /* If we aren't the master of our team, bail out - nothing to do.  
       Only the master can change the state of a team to active. */
    if (!ctxtp->bda_teaming.master) {
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return;
    }

    /* Extract a pointer to my team. */
    team = ctxtp->bda_teaming.bda_team;

    /* Make sure that the team exists. */
    UNIV_ASSERT(team);

    /* If all members of my team are consistent, then activate the team. */
    if (team->membership_map == team->consistency_map) {
        if (!team->active) {
            LOG_MSG(MSG_INFO_BDA_TEAM_REACTIVATED, MSG_NONE);
            team->active = TRUE;
        }
    }

    NdisReleaseSpinLock(&univ_bda_teaming_lock);
}

/*
 * Function: Main_teaming_ip_addr_change
 * Description: This function is called from Main_ip_addr_init when the primary
 *              cluster IP address of an adapter changes (potentially).  We need
 *              to recognize this to properly re-fingerprint the team.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             old_ip - the old cluster IP addres (as a DWORD).
 *             new_ip - the new cluster IP address (as a DWORD).
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: This function acquires the global teaming lock.
 */
VOID Main_teaming_ip_addr_change (IN PMAIN_CTXT ctxtp, IN ULONG old_ip, IN ULONG new_ip) {
    PBDA_TEAM team;

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* If we aren't part of a team, bail out - nothing to do.  Because this function is only
       called during a re-configuration, we won't worry about optimizing and not grabbing the 
       lock as is done in some of the hot paths. */
    if (!ctxtp->bda_teaming.active) {
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return;
    }

    /* Grab a pointer to the team. */
    team = ctxtp->bda_teaming.bda_team;

    /* Make sure that team actually points to something. */
    UNIV_ASSERT(team);

    /* Remove the old cluster IP address by undoing the XOR.  We only use the two
       least significant bytes of the cluster IP, which, because the cluster IP 
       address is stored in host order, are the two most significant bytes. */
    team->membership_fingerprint ^= ((old_ip >> 16) & 0x0000ffff);

    /* XOR with the new cluster IP address. We only use the two least
       significant bytes of the cluster IP, which, because the cluster IP 
       address is stored in host order, are the two most significant bytes. */
    team->membership_fingerprint ^= ((new_ip >> 16) & 0x0000ffff);

    NdisReleaseSpinLock(&univ_bda_teaming_lock);
}

/*
 * Function: Main_teaming_reset
 * Description: This function is called from Main_teaming_cleanup (or Main_teaming_init)
 *              tp cleanup any teaming configuration that may exist on an adapter.  To
 *              do so, we cleanup our membership state and dereference the team. If
 *              we are the master for the team, however, we have to wait until there
 *              are no more references on our load module before allowing the operation
 *              to complete, because this might be called in the unbind path, in 
 *              which case, our load module would be going away.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: This function acquires the global teaming lock.
 */
VOID Main_teaming_reset (IN PMAIN_CTXT ctxtp) {
    PBDA_TEAM team;
    
    NdisAcquireSpinLock(&univ_bda_teaming_lock);   

    /* If we aren't part of a team, bail out - nothing to do. */
    if (!ctxtp->bda_teaming.active) {
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return;
    }

    /* Inactivate teaming on this adapter.  This will cause other entities like the 
       load module and send/receive paths to stop thinking in teaming mode. */
    ctxtp->bda_teaming.active = FALSE;    

    /* Grab a pointer to the team. */
    team = ctxtp->bda_teaming.bda_team;

    /* Make sure that team actually points to something. */
    UNIV_ASSERT(team);

    /* If we are the master for this team, make sure that all references to our load
       module have been released and then remove our load information from the team. */
    if (ctxtp->bda_teaming.master) {
        /* Mark the team as inactive - a team cannot function without a master.  Members
           of an inactive team will NOT accept packets and therefore will not reference
           our load module further while we wait for the reference count to go to zero. */
        team->active = FALSE;
        
        NdisReleaseSpinLock(&univ_bda_teaming_lock);

        /* No need to worry - the team pointer cannot go away even though we don't have 
           the lock acquired; we have a reference on the team until we call Main_put_team. */
        while (Load_get_reference_count(team->load)) {
            /* Sleep while there are references on our load module. */
            Nic_sleep(10);
        }

        NdisAcquireSpinLock(&univ_bda_teaming_lock);   

        /* Remove the pointer to my load module.  We wait until now to prevent another 
           adapter from joining the team claiming to be the master until we are done
           waiting for references on our load module to go away. */
        team->load = NULL;
        team->load_lock = NULL;

        /* If we have just left a team without a master, log an event to notify
           the user that a team cannot function without a designated master. */
        LOG_MSG(MSG_INFO_BDA_MASTER_LEAVE, MSG_NONE);
    }

    /* Reset the teaming context (member_id is set and reset by Main_get(put)_team). */
    ctxtp->bda_teaming.reverse_hash = 0;
    ctxtp->bda_teaming.master = 0;
        
    /* Remove the pointer to the team structure. */
    ctxtp->bda_teaming.bda_team = NULL;

    /* Decrements the reference count and frees the team if necessary. */
    Main_put_team(ctxtp, team);

    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    return;
}

/*
 * Function: Main_teaming_cleanup
 * Description: This function is called from Main_cleanup to cleanup any teaming 
 *              configuration that may exist on an adapter.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: This function acquires the global teaming lock.
 */
VOID Main_teaming_cleanup (IN PMAIN_CTXT ctxtp) {

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* Make sure that another BDA teaming operation isn't in progress before proceeding. */
    while (ctxtp->bda_teaming.operation != BDA_TEAMING_OPERATION_NONE) {
        NdisReleaseSpinLock(&univ_bda_teaming_lock);

        /* Sleep while some other operation is in progress. */
        Nic_sleep(10);

        NdisAcquireSpinLock(&univ_bda_teaming_lock);
    }

    /* If we aren't part of a team, bail out - nothing to do. */
    if (!ctxtp->bda_teaming.active) {
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return;
    }

    /* Set the state to deleting. */
    ctxtp->bda_teaming.operation = BDA_TEAMING_OPERATION_DELETING;

    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    /* Call Main_teaming_reset to actually remove this adapter from its team. */
    Main_teaming_reset(ctxtp);

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* Now that we're done, set the state back to ready to allow other operations to proceed. */
    ctxtp->bda_teaming.operation = BDA_TEAMING_OPERATION_NONE;

    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    return;
}

/*
 * Function: Main_teaming_init
 * Description: This function is called by either Main_init or Main_ctrl to re-initialize
 *              the teaming confguration on this adapter.  If the new teaming configuration,
 *              which is stored in ctxtp->params is the same as the current configuration, 
 *              then we don't need to bother.  Otherwise, if we are already part of a team,
 *              we begin by cleaning up that state, which may unnecssary in some cases, but
 *              it makes things simpler and more straight-forward, so we'll live with it.  
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter. 
 * Returns: BOOLEAN - TRUE if successful, FALSE if unsuccessful.
 * Author: shouse, 3.29.01
 * Notes: This function acquires the global teaming lock.
 */
BOOLEAN Main_teaming_init (IN PMAIN_CTXT ctxtp) {
    BOOLEAN   bSuccess = TRUE;
    PBDA_TEAM team;
    
    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* Make sure that another BDA teaming operation isn't in progress before proceeding. */
    while (ctxtp->bda_teaming.operation != BDA_TEAMING_OPERATION_NONE) {
        NdisReleaseSpinLock(&univ_bda_teaming_lock);

        /* Sleep while some other operation is in progress. */
        Nic_sleep(10);

        NdisAcquireSpinLock(&univ_bda_teaming_lock);
    }

    /* Set the state to creating. */
    ctxtp->bda_teaming.operation = BDA_TEAMING_OPERATION_CREATING;

    /* If the parameters are invalid, do nothing. */
    if (!ctxtp->params_valid) {
        UNIV_PRINT_CRIT(("Main_teaming_init: Parameters are invalid."));
        TRACE_CRIT("%!FUNC! Parameters are invalid");
        bSuccess = TRUE;
        goto end;
    }

    /* Check to see if the state of teaming has changed.  If we were actively teaming 
       before and we are still part of a team, then we may be able to get out of here
       without disturbing anything, if the rest of the configuration hasn't changed. */
    if (ctxtp->bda_teaming.active == ctxtp->params.bda_teaming.active) { 
        if (ctxtp->bda_teaming.active) {
            /* Make sure that I have a pointer to my team. */
            UNIV_ASSERT(ctxtp->bda_teaming.bda_team);

            /* If all other teaming parameters are unchanged, then we can bail out 
               because no  part of the teaming configuration changed. */
            if ((ctxtp->bda_teaming.master == ctxtp->params.bda_teaming.master) &&
                (ctxtp->bda_teaming.reverse_hash == ctxtp->params.bda_teaming.reverse_hash) &&
                Univ_equal_unicode_string(ctxtp->bda_teaming.bda_team->team_id, ctxtp->params.bda_teaming.team_id, wcslen(ctxtp->bda_teaming.bda_team->team_id))) {
                bSuccess = TRUE;
                goto end;
            }
        } else {
            /* If I wasn't teaming before, and I'm not teaming now, there's nothing for me to do. */
            bSuccess = TRUE;
            goto end;
        }
    }

    /* If this adapter is already in a team, cleanup first.  At this point, we know that 
       some part of the teaming configuration has changed, so we'll cleanup our old state
       if we need to and then re-build it with the new parameters if necessary. */
    if (ctxtp->bda_teaming.active) {
        UNIV_PRINT_VERB(("Main_teaming_init: This adapter is already part of a team."));
        TRACE_VERB("%!FUNC! This adapter is already part of a team");

        NdisReleaseSpinLock(&univ_bda_teaming_lock);

        /* Cleanup our old teaming state first. */
        Main_teaming_reset(ctxtp);

        NdisAcquireSpinLock(&univ_bda_teaming_lock);
    } 

    /* If, according to the new configuration, this adapter is not part of a team, do nothing. */
    if (!ctxtp->params.bda_teaming.active) {
        ctxtp->bda_teaming.member_id = CVY_BDA_INVALID_MEMBER_ID;
        bSuccess = TRUE;
        goto end;
    }

    /* Try to find a previous instance of this team.  If the team does not
       exist, Main_get_team will allocate, intialize and reference a new team. */
    if (!(team = Main_get_team(ctxtp, ctxtp->params.bda_teaming.team_id))) {
        UNIV_PRINT_CRIT(("Main_teaming_init: Error attempting to allocate memory for a team."));
        TRACE_CRIT("%!FUNC! Error attempting to allocate memory for a team");
        bSuccess = FALSE;
        goto end;
    }

    /* If we are supposed to be the master for this team, we need to make sure that the
       team doesn't already have a master, and if so, setup the shared load context. */
    if (ctxtp->params.bda_teaming.master) {
        /* If we are supposed to be the master for this team, check for an existing master. */
        if (team->load) {
            /* If the load pointer is set, then this team already has a master. */
            UNIV_PRINT_CRIT(("Main_teaming_init: This team already has a master."));
            TRACE_CRIT("%!FUNC! This team already has a master");

            LOG_MSG(MSG_INFO_BDA_MULTIPLE_MASTERS, MSG_NONE);

            /* Turn teaming off - SHOULD be off already, but... */
            ctxtp->bda_teaming.active = FALSE;

            /* Reset the teaming context (member_id is set and reset by Main_get(put)_team). */
            ctxtp->bda_teaming.reverse_hash = 0;
            ctxtp->bda_teaming.master = 0;
            
            /* Remove the pointer to the team structure. */
            ctxtp->bda_teaming.bda_team = NULL;
    
            /* Release our reference on this team. */
            Main_put_team(ctxtp, team);
            
            bSuccess = FALSE;
            goto end;
        } else {
            /* Otherwise, we are it.  Set the global load state pointers
               to our load module and load lock. */
            team->load = &ctxtp->load;
            team->load_lock = &ctxtp->load_lock;

            /* If all members of my team are consistent, then activate the team. */
            if (team->membership_map == team->consistency_map) team->active = TRUE;

            /* Log the fact that a master has now been assigned to this team. */
            LOG_MSG(MSG_INFO_BDA_MASTER_JOIN, MSG_NONE);
        }
    }

    /* If we have just joined a team without a master, log an event to notify
       the user that a team cannot function without a designated master. */
    if (!team->load) {
        LOG_MSG(MSG_INFO_BDA_NO_MASTER, MSG_NONE);
    }

    /* Store a pointer to the team in the adapter's teaming context. */
    ctxtp->bda_teaming.bda_team = team;

    /* Copy the teaming configuration from the parameters into the teaming context. */
    ctxtp->bda_teaming.master = ctxtp->params.bda_teaming.master;
    ctxtp->bda_teaming.reverse_hash = ctxtp->params.bda_teaming.reverse_hash;
    ctxtp->bda_teaming.active = TRUE;

    /* Over-ride the default reverse-hashing setting with the BDA specific directive. */
    ctxtp->reverse_hash = ctxtp->bda_teaming.reverse_hash;

 end:
    ctxtp->bda_teaming.operation = BDA_TEAMING_OPERATION_NONE;

    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    return bSuccess;
}

/*
 * Function: Main_teaming_acquire_load
 * Description: This function determines which load module a particular adapter should be unsing,
 *              sets the appropriate pointers, and references the appropriate load module.  If an
 *              adapter is not part of a BDA team, then it should always be using its own load
 *              module - in that case, this function does nothing.  If the adapter is part of a 
 *              team, but the team in inactive, we return FALSE to indicate that the adapter should
 *              not accept this packet - inactive teams drop all traffic except traffic to the DIP.  
 *              If the adapter is part of an active team, then we set the load and lock pointers to
 *              point to the team's master load state and appropriately set the reverse hashing
 *              indication based on the parameter setting for this adapter.  In this scenario, which
 *              creates a cross-adapter load reference, we reference the master's load module so
 *              that it doesn't go away while we are using a pointer to it. 
 * Parameters: member - a pointer to the teaming member information for this adapter.
 *             ppLoad - an out pointer to a pointer to a load module set appropriately upon exit.
 *             ppLock - an out pointer to a pointer to a load lock set appropriately upon exit.
 *             pbRefused - an out pointer to a boolean that we set if this packet is refused (TRUE = drop it).
 * Returns: BOOLEAN - an indication of whether or not this adapter is actually part of a team.
 * Author: shouse, 3.29.01
 * Notes: This function acquires the global teaming lock.
 */
BOOLEAN Main_teaming_acquire_load (IN PBDA_MEMBER member, OUT PLOAD_CTXT * ppLoad, OUT PNDIS_SPIN_LOCK * ppLock, OUT BOOLEAN * pbRefused) {
    
    NdisAcquireSpinLock(&univ_bda_teaming_lock);
    
    /* Assert that the team membership information actually points to something. */
    UNIV_ASSERT(member);

    /* Assert that the load pointer and the pointer to the load pointer actually point to something. */
    UNIV_ASSERT(ppLoad && *ppLoad);

    /* Assert that the lock pointer and the pointer to the lock pointer actually point to something. */
    UNIV_ASSERT(ppLock && *ppLock);

    /* Assert that the refused pointer actually points to something. */
    UNIV_ASSERT(pbRefused);

    /* By default, we're not refusing the packet. */
    *pbRefused = FALSE;

    /* If we are an active BDA team participant, check the team state to see whether we
       should accept this packet and fill in the load module/configuration parameters. */
    if (member->active) {
        PBDA_TEAM team = member->bda_team;
        
        /* Assert that the team actually points to something. */
        UNIV_ASSERT(team);
        
        /* If the team is inactive, we will not handle this packet. */
        if (!team->active) {
            /* Refuse the packet. */
            *pbRefused = TRUE;

            NdisReleaseSpinLock(&univ_bda_teaming_lock);

            /* We're not teaming. */
            return FALSE;
        }
        
        /* Otherwise, tell the caller to use the team's load lock and module. */
        *ppLoad = team->load;
        *ppLock = team->load_lock;
        
        /* In the case of cross-adapter load module reference, add a reference to 
           the load module we are going to use to keep it from disappering on us. */
        Load_add_reference(*ppLoad);

        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        
        /* We are teaming. */
        return TRUE;
    }
    
    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    /* We're not teaming. */
    return FALSE;
}

/*
 * Function: Main_teaming_release_load
 * Description: This function releases a reference to a load module if necessary.  If we did not
 *              acquire this load module pointer in teaming mode, then this is unnessary.  Other-
 *              wise, we need to decrement the count, now that we are done using the pointer.
 * Parameters: pLoad - a pointer to the load module to dereference.
 *             pLock - a pointer to the load lock corresponding to the load module pointer (unused).
 *             bTeaming - a boolean indication of whether or not we acquired this pointer in teaming mode.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: 
 */
VOID Main_teaming_release_load (IN PLOAD_CTXT pLoad, IN PNDIS_SPIN_LOCK pLock, IN BOOLEAN bTeaming) {
    
    /* Assert that the load pointer actually points to something. */
    UNIV_ASSERT(pLoad);

    /* Assert that the lock pointer actually points to something. */
    UNIV_ASSERT(pLock);

    /* If this load module was referenced, remove the reference. */
    if (bTeaming) Load_release_reference(pLoad);
}

/*
 * Function: Main_conn_get
 * Description: This function is, for all intents and purposes, a teaming-aware wrapper
 *              around Load_conn_get.  It determines which load module to utilize,
 *              based on the BDA teaming configuration on this adapter.  Adapters that
 *              are not part of a team continue to use their own load modules (Which is
 *              BY FAR, the most common case).  Adapters that are part of a team will
 *              use the load context of the adapter configured as the team's master as
 *              long as the team is in an active state.  In such as case, because of 
 *              the cross-adapter referencing of load modules, the reference count on
 *              the master's load module is incremented to keep it from "going away"
 *              while another team member is using it.  When a team is marke inactive,
 *              which is the result of a misconfigured team either on this host or 
 *              another host in the cluster, the adapter handles NO traffic that would
 *              require the use of a load module.  This function queries the load module
 *              for the connection parameters of an active connection on this adapter.
 *              If an active connection is found, the IP tuple information is returned
 *              in the first five OUT parameters.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             OUT svr_addr - the server IP address (source IP on send, destination IP on recv).
 *             OUT svr_port - the server port (source port on send, destination port on recv).
 *             OUT clt_addr - the client IP address (detination IP on send, source IP on recv).
 *             OUT clt_port - the client port (destination port on send, source port on recv).
 *             OUT protocol - the protocol for this packet. 
 * Returns: BOOLEAN - indication of whether or we retrieved an active connection.
 * Author: shouse, 10.7.01
 * Notes: 
 */
__inline BOOLEAN Main_conn_get (
    PMAIN_CTXT ctxtp, 
    PULONG     svr_addr, 
    PULONG     svr_port, 
    PULONG     clt_addr, 
    PULONG     clt_port, 
    PUSHORT    protocol
) 
{
    /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
       assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
    PLOAD_CTXT      pLoad = &ctxtp->load;
    PNDIS_SPIN_LOCK pLock = &ctxtp->load_lock;
    BOOLEAN         bRefused = FALSE;
    BOOLEAN         bTeaming = FALSE;
    BOOLEAN         acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: ctxtp = %p", ctxtp);

    /* Pre-initialize the IN parameters. */
    *svr_addr = 0;
    *clt_addr = 0;
    *svr_port = 0;
    *clt_port = 0;
    *protocol = 0;

    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we don't think we're teaming, don't bother to check for sure, just
       use our own load module and go with it - in the worst case, we handle a
       packet we perhaps shouldn't have while we were joining a team or changing
       our current team configuration. */
    if (ctxtp->bda_teaming.active) {
        /* Check the teaming configuration and add a reference to the load module before consulting the load 
           module.  If bRefused is TRUE, then the load module was NOT referenced, so we can bail out. */
        bTeaming = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bRefused);

        /* If teaming has suggested that we not allow this packet to pass, dump it. */
        if (bRefused) {

            TRACE_FILTER("%!FUNC! Drop request - BDA team inactive");

            acpt = FALSE;
            goto exit;
        }
    }

    NdisAcquireSpinLock(pLock);

    TRACE_FILTER("%!FUNC! Consulting the load module");
    
    /* Consult the load module. */
    acpt = Load_conn_get(pLoad, svr_addr, svr_port, clt_addr, clt_port, protocol);
    
    NdisReleaseSpinLock(pLock);  
    
 exit:

    /* Release the reference on the load module if necessary.  If we aren't teaming, even in 
       the case we skipped calling Main_teaming_acquire_load_module above bTeaming is FALSE, 
       so there is no need to call this function to release a reference. */
    if (bTeaming) Main_teaming_release_load(pLoad, pLock, bTeaming);

    TRACE_FILTER("%!FUNC! Exit: ctxtp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u, acpt = %u", 
                 ctxtp, IP_GET_OCTET(*svr_addr, 0), IP_GET_OCTET(*svr_addr, 1), IP_GET_OCTET(*svr_addr, 2), IP_GET_OCTET(*svr_addr, 3),*svr_port, IP_GET_OCTET(*clt_addr, 0), 
                 IP_GET_OCTET(*clt_addr, 1), IP_GET_OCTET(*clt_addr, 2), IP_GET_OCTET(*clt_addr, 3),*clt_port, *protocol, acpt);

    return acpt;
}

/*
 * Function: Main_conn_sanction
 * Description: This function is, for all intents and purposes, a teaming-aware wrapper
 *              around Load_conn_sanction.  It determines which load module to utilize,
 *              based on the BDA teaming configuration on this adapter.  Adapters that
 *              are not part of a team continue to use their own load modules (Which is
 *              BY FAR, the most common case).  Adapters that are part of a team will
 *              use the load context of the adapter configured as the team's master as
 *              long as the team is in an active state.  In such as case, because of 
 *              the cross-adapter referencing of load modules, the reference count on
 *              the master's load module is incremented to keep it from "going away"
 *              while another team member is using it.  When a team is marke inactive,
 *              which is the result of a misconfigured team either on this host or 
 *              another host in the cluster, the adapter handles NO traffic that would
 *              require the use of a load module.  This function notifies the load module
 *              that the connection identified by the given IP tuple has been confirmed
 *              to still be active on this host.  The load module reacts by moving the
 *              state information for this connection to the end of its recycle queue.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             svr_addr - the server IP address (source IP on send, destination IP on recv).
 *             svr_port - the server port (source port on send, destination port on recv).
 *             clt_addr - the client IP address (detination IP on send, source IP on recv).
 *             clt_port - the client port (destination port on send, source port on recv).
 *             protocol - the protocol for this packet.
 * Returns: BOOLEAN - indication of whether or not we were able to update the connection.
 * Author: shouse, 10.7.01
 * Notes: 
 */
__inline BOOLEAN Main_conn_sanction (
    PMAIN_CTXT ctxtp, 
    ULONG      svr_addr, 
    ULONG      svr_port, 
    ULONG      clt_addr, 
    ULONG      clt_port, 
    USHORT     protocol
) 
{
    /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
       assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
    PLOAD_CTXT      pLoad = &ctxtp->load;
    PNDIS_SPIN_LOCK pLock = &ctxtp->load_lock;
    BOOLEAN         bRefused = FALSE;
    BOOLEAN         bTeaming = FALSE;
    BOOLEAN         acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: ctxtp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u", 
                 ctxtp, IP_GET_OCTET(svr_addr, 0), IP_GET_OCTET(svr_addr, 1), IP_GET_OCTET(svr_addr, 2), IP_GET_OCTET(svr_addr, 3),svr_port, 
                 IP_GET_OCTET(clt_addr, 0), IP_GET_OCTET(clt_addr, 1), IP_GET_OCTET(clt_addr, 2), IP_GET_OCTET(clt_addr, 3),clt_port, protocol);

    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we don't think we're teaming, don't bother to check for sure, just
       use our own load module and go with it - in the worst case, we handle a
       packet we perhaps shouldn't have while we were joining a team or changing
       our current team configuration. */
    if (ctxtp->bda_teaming.active) {
        /* Check the teaming configuration and add a reference to the load module before consulting the load 
           module.  If the bRefused is TRUE, then the load module was NOT referenced, so we can bail out. */
        bTeaming = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bRefused);

        /* If teaming has suggested that we not allow this packet to pass, dump it. */
        if (bRefused) {

            TRACE_FILTER("%!FUNC! Drop request - BDA team inactive");

            acpt = FALSE;
            goto exit;
        }
    }

    /* Convert TCP port 1723 to PPTP for use by the load module.  This conversion must
       be done in main and not load, as the load module would not know whether to look
       at the server port or client port because of reverse hashing. */
    if ((protocol == TCPIP_PROTOCOL_TCP) && (svr_port == PPTP_CTRL_PORT))
        protocol = TCPIP_PROTOCOL_PPTP;

    NdisAcquireSpinLock(pLock);

    TRACE_FILTER("%!FUNC! Consulting the load module");
    
    /* Consult the load module. */
    acpt = Load_conn_sanction(pLoad, svr_addr, svr_port, clt_addr, clt_port, protocol);
    
    NdisReleaseSpinLock(pLock);  
    
 exit:

    /* Release the reference on the load module if necessary.  If we aren't teaming, even in 
       the case we skipped calling Main_teaming_acquire_load_module above bTeaming is FALSE, 
       so there is no need to call this function to release a reference. */
    if (bTeaming) Main_teaming_release_load(pLoad, pLock, bTeaming);

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

/*
 * Function: Main_packet_check
 * Description: This function is, for all intents and purposes, a teaming-aware wrapper
 *              around Load_packet_check.  It determines which load module to utilize,
 *              based on the BDA teaming configuration on this adapter.  Adapters that
 *              are not part of a team continue to use their own load modules (Which is
 *              BY FAR, the most common case).  Adapters that are part of a team will
 *              use the load context of the adapter configured as the team's master as
 *              long as the team is in an active state.  In such as case, because of 
 *              the cross-adapter referencing of load modules, the reference count on
 *              the master's load module is incremented to keep it from "going away"
 *              while another team member is using it.  When a team is marke inactive,
 *              which is the result of a misconfigured team either on this host or 
 *              another host in the cluster, the adapter handles NO traffic that would
 *              require the use of a load module.  Other traffic, such as traffic to 
 *              the DIP, or RAW IP traffic, is allowed to pass.  This function is called
 *              to filter, in general, TCP data packets, UDP packets and IPSec and GRE
 *              data packets.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             svr_addr - the server IP address (source IP on send, destination IP on recv).
 *             svr_port - the server port (source port on send, destination port on recv).
 *             clt_addr - the client IP address (detination IP on send, source IP on recv).
 *             clt_port - the client port (destination port on send, source port on recv).
 *             protocol - the protocol for this packet. 
#if defined (NLB_HOOK_ENABLE)
 *             filter - the hashing mandate from the packet hook, if invoked.
#endif
 * Returns: BOOLEAN - indication of whether or not to accept the packet.
 * Author: shouse, 3.29.01
 * Notes: 
 */
__inline BOOLEAN Main_packet_check (
    PMAIN_CTXT                ctxtp, 
    ULONG                     svr_addr, 
    ULONG                     svr_port, 
    ULONG                     clt_addr, 
    ULONG                     clt_port, 
#if defined (NLB_HOOK_ENABLE)
    USHORT                    protocol, 
    NLB_FILTER_HOOK_DIRECTIVE filter
#else
    USHORT                    protocol
#endif
) 
{
    /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
       assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
    PLOAD_CTXT      pLoad = &ctxtp->load;
    PNDIS_SPIN_LOCK pLock = &ctxtp->load_lock;
    ULONG           bReverse = ctxtp->reverse_hash;
    BOOLEAN         bRefused = FALSE;
    BOOLEAN         bTeaming = FALSE;
    BOOLEAN         acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: ctxtp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u", 
                 ctxtp, IP_GET_OCTET(svr_addr, 0), IP_GET_OCTET(svr_addr, 1), IP_GET_OCTET(svr_addr, 2), IP_GET_OCTET(svr_addr, 3), svr_port, 
                 IP_GET_OCTET(clt_addr, 0), IP_GET_OCTET(clt_addr, 1), IP_GET_OCTET(clt_addr, 2), IP_GET_OCTET(clt_addr, 3), clt_port, protocol);

    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we don't think we're teaming, don't bother to check for sure, just
       use our own load module and go with it - in the worst case, we handle a
       packet we perhaps shouldn't have while we were joining a team or changing
       our current team configuration. */
    if (ctxtp->bda_teaming.active) {
        /* Check the teaming configuration and add a reference to the load module before consulting the load 
           module.  If the bRefused is TRUE, then the load module was NOT referenced, so we can bail out. */
        bTeaming = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bRefused);

        /* If teaming has suggested that we not allow this packet to pass, dump it. */
        if (bRefused) {

            TRACE_FILTER("%!FUNC! Drop packet - BDA team inactive");

            acpt = FALSE;
            goto exit;
        }
    }
    
#if defined (NLB_HOOK_ENABLE)
    TRACE_FILTER("%!FUNC! Checking the hook feedback: reverse = %u", bReverse);

    switch (filter) {
    case NLB_FILTER_HOOK_PROCEED_WITH_HASH:
        /* Do nothing different as a result of the hook. */
        break;
    case NLB_FILTER_HOOK_REVERSE_HASH:
        /* Ignore whatever hashing settings we found in our configuration
           and hash in the dircetion the hook asked us to. */
        TRACE_FILTER("%!FUNC! Forcing a reverse hash");
        bReverse = TRUE;
        break;
    case NLB_FILTER_HOOK_FORWARD_HASH:
        /* Ignore whatever hashing settings we found in our configuration
           and hash in the dircetion the hook asked us to. */
        TRACE_FILTER("%!FUNC! Forcing a forward hash");
        bReverse = FALSE;
        break;
    case NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY:
    case NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY:
    default:
        /* These cases should be taken care of long before we get here. */
        UNIV_ASSERT(FALSE);
        break;
    }
#endif

    /* Convert TCP port 1723 to PPTP for use by the load module.  This conversion must
       be done in main and not load, as the load module would not know whether to look
       at the server port or client port because of reverse hashing. */
    if ((protocol == TCPIP_PROTOCOL_TCP) && (svr_port == PPTP_CTRL_PORT))
        protocol = TCPIP_PROTOCOL_PPTP;

    NdisAcquireSpinLock(pLock);

    TRACE_FILTER("%!FUNC! Consulting the load module: reverse = %u", bReverse);
    
    /* Consult the load module. */
    acpt = Load_packet_check(pLoad, svr_addr, svr_port, clt_addr, clt_port, protocol, bTeaming, (BOOLEAN)bReverse);
    
    NdisReleaseSpinLock(pLock);  
    
 exit:

    /* Release the reference on the load module if necessary.  If we aren't teaming, even in 
       the case we skipped calling Main_teaming_Acquire_load_module above bTeaming is FALSE, 
       so there is no need to call this function to release a reference. */
    if (bTeaming) Main_teaming_release_load(pLoad, pLock, bTeaming);

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

/*
 * Function: Main_conn_advise
 * Description: This function is, for all intents and purposes, a teaming-aware wrapper
 *              around Load_conn_advise.  It determines which load module to utilize,
 *              based on the BDA teaming configuration on this adapter.  Adapters that
 *              are not part of a team continue to use their own load modules (Which is
 *              BY FAR, the most common case).  Adapters that are part of a team will
 *              use the load context of the adapter configured as the team's master as
 *              long as the team is in an active state.  In such as case, because of 
 *              the cross-adapter referencing of load modules, the reference count on
 *              the master's load module is incremented to keep it from "going away"
 *              while another team member is using it.  When a team is marke inactive,
 *              which is the result of a misconfigured team either on this host or 
 *              another host in the cluster, the adapter handles NO traffic that would
 *              require the use of a load module.  Other traffic, such as traffic to 
 *              the DIP, or RAW IP traffic, is allowed to pass.  This function is called,
 *              in general, to filter TCP control packets - SYN, FIN and RST.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             svr_addr - the server IP address (source IP on send, destination IP on recv).
 *             svr_port - the server port (source port on send, destination port on recv).
 *             clt_addr - the client IP address (detination IP on send, source IP on recv).
 *             clt_port - the client port (destination port on send, source port on recv).
 *             protocol - the protocol for this packet. 
 *             conn_status - the TCP flag in this packet - SYN (UP), FIN (DOWN) or RST (RESET).
#if defined (NLB_HOOK_ENABLE)
 *             filter - the hashing mandate from the packet hook, if invoked.
#endif
 * Returns: BOOLEAN - indication of whether or not to accept the packet.
 * Author: shouse, 3.29.01
 * Notes: 
 */
__inline BOOLEAN Main_conn_advise (
    PMAIN_CTXT                ctxtp, 
    ULONG                     svr_addr, 
    ULONG                     svr_port, 
    ULONG                     clt_addr, 
    ULONG                     clt_port,
    USHORT                    protocol, 
#if defined (NLB_HOOK_ENABLE)
    ULONG                     conn_status, 
    NLB_FILTER_HOOK_DIRECTIVE filter
#else
    ULONG                     conn_status
#endif
) 
{
    /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
       assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
    PLOAD_CTXT      pLoad = &ctxtp->load;
    PNDIS_SPIN_LOCK pLock = &ctxtp->load_lock;
    ULONG           bReverse = ctxtp->reverse_hash;
    BOOLEAN         bRefused = FALSE;
    BOOLEAN         bTeaming = FALSE;
    BOOLEAN         acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: ctxtp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u, status = %u", 
                 ctxtp, IP_GET_OCTET(svr_addr, 0), IP_GET_OCTET(svr_addr, 1), IP_GET_OCTET(svr_addr, 2), IP_GET_OCTET(svr_addr, 3), svr_port, 
                 IP_GET_OCTET(clt_addr, 0), IP_GET_OCTET(clt_addr, 1), IP_GET_OCTET(clt_addr, 2), IP_GET_OCTET(clt_addr, 3), clt_port, protocol, conn_status);

    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we don't think we're teaming, don't bother to check for sure, just
       use our own load module and go with it - in the worst case, we handle a
       packet we perhaps shouldn't have while we were joining a team or changing
       our current team configuration. */
    if (ctxtp->bda_teaming.active) {
        /* Check the teaming configuration and add a reference to the load module before consulting the load 
           module.  If the bRefused is TRUE, then the load module was NOT referenced, so we can bail out. */
        bTeaming = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bRefused);
        
        /* If teaming has suggested that we not allow this packet to pass, dump it. */
        if (bRefused) {       

            TRACE_FILTER("%!FUNC! Drop packet - BDA team inactive");

            acpt = FALSE;
            goto exit;
        }
    }

#if defined (NLB_HOOK_ENABLE)
    TRACE_FILTER("%!FUNC! Checking the hook feedback: reverse = %u", bReverse);

    switch (filter) {
    case NLB_FILTER_HOOK_PROCEED_WITH_HASH:
        /* Do nothing different as a result of the hook. */
        break;
    case NLB_FILTER_HOOK_REVERSE_HASH:
        /* Ignore whatever hashing settings we found in our configuration
           and hash in the dircetion the hook asked us to. */
        TRACE_FILTER("%!FUNC! Forcing a reverse hash");
        bReverse = TRUE;
        break;
    case NLB_FILTER_HOOK_FORWARD_HASH:
        /* Ignore whatever hashing settings we found in our configuration
           and hash in the dircetion the hook asked us to. */
        TRACE_FILTER("%!FUNC! Forcing a forward hash");
        bReverse = FALSE;
        break;
    case NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY:
    case NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY:
    default:
        /* These cases should be taken care of long before we get here. */
        UNIV_ASSERT(FALSE);
        break;
    }
#endif

    /* Convert TCP port 1723 to PPTP for use by the load module.  This conversion must
       be done in main and not load, as the load module would not know whether to look
       at the server port or client port because of reverse hashing. */
    if ((protocol == TCPIP_PROTOCOL_TCP) && (svr_port == PPTP_CTRL_PORT))
        protocol = TCPIP_PROTOCOL_PPTP;

    NdisAcquireSpinLock(pLock);
   
    TRACE_FILTER("%!FUNC! Consulting the load module: reverse = %u", bReverse);

    /* Consult the load module. */
    acpt = Load_conn_advise(pLoad, svr_addr, svr_port, clt_addr, clt_port, protocol, conn_status, bTeaming, (BOOLEAN)bReverse);
    
    NdisReleaseSpinLock(pLock);
    
 exit:

    /* Release the reference on the load module if necessary.  If we aren't teaming, even in 
       the case we skipped calling Main_teaming_Acquire_load_module above, bTeaming is FALSE, 
       so there is no need to call this function to release a reference. */
    if (bTeaming) Main_teaming_release_load(pLoad, pLock, bTeaming);

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

/*
 * Function: Main_conn_notify
 * Description: This function is, for all intents and purposes, a teaming-aware wrapper
 *              around Load_conn_notify.  It determines which load module to utilize,
 *              based on the BDA teaming configuration on this adapter.  Adapters that
 *              are not part of a team continue to use their own load modules (Which is
 *              BY FAR, the most common case).  Adapters that are part of a team will
 *              use the load context of the adapter configured as the team's master as
 *              long as the team is in an active state.  In such as case, because of 
 *              the cross-adapter referencing of load modules, the reference count on
 *              the master's load module is incremented to keep it from "going away"
 *              while another team member is using it.  When a team is marke inactive,
 *              which is the result of a misconfigured team either on this host or 
 *              another host in the cluster, the adapter handles NO traffic that would
 *              require the use of a load module.  Other traffic, such as traffic to 
 *              the DIP, or RAW IP traffic, is allowed to pass.  This function is called
 *              to notify the load module of a detected change in a connection - this
 *              interface is not to _ask_ the load module what to do (as Main_conn_advise
 *              and Main_packet_check do), but rather to _tell_ the load module something
 *              about a connection that may belong on this host.  This function can be,
 *              but often is not, called as a result of the reception or transmission of 
 *              a physical network packet.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             svr_addr - the server IP address (source IP on send, destination IP on recv).
 *             svr_port - the server port (source port on send, destination port on recv).
 *             clt_addr - the client IP address (detination IP on send, source IP on recv).
 *             clt_port - the client port (destination port on send, source port on recv).
 *             protocol - the protocol for this packet. 
 *             conn_status - the TCP flag in this packet - SYN (UP), FIN (DOWN) or RST (RESET).
#if defined (NLB_HOOK_ENABLE)
 *             filter - the hashing mandate from the packet hook, if invoked.
#endif
 * Returns: BOOLEAN - indication of whether or not to accept the packet.
 * Author: shouse, 3.29.01
 * Notes: 
 */
__inline BOOLEAN Main_conn_notify (
    PMAIN_CTXT                ctxtp, 
    ULONG                     svr_addr, 
    ULONG                     svr_port, 
    ULONG                     clt_addr, 
    ULONG                     clt_port,
    USHORT                    protocol, 
#if defined (NLB_HOOK_ENABLE)
    ULONG                     conn_status, 
    NLB_FILTER_HOOK_DIRECTIVE filter
#else
    ULONG                     conn_status
#endif
) 
{
    /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
       assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
    PLOAD_CTXT      pLoad = &ctxtp->load;
    PNDIS_SPIN_LOCK pLock = &ctxtp->load_lock;
    ULONG           bReverse = ctxtp->reverse_hash;
    BOOLEAN         bRefused = FALSE;
    BOOLEAN         bTeaming = FALSE;
    BOOLEAN         acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: ctxtp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u, status = %u", 
                 ctxtp, IP_GET_OCTET(svr_addr, 0), IP_GET_OCTET(svr_addr, 1), IP_GET_OCTET(svr_addr, 2), IP_GET_OCTET(svr_addr, 3), svr_port, 
                 IP_GET_OCTET(clt_addr, 0), IP_GET_OCTET(clt_addr, 1), IP_GET_OCTET(clt_addr, 2), IP_GET_OCTET(clt_addr, 3), clt_port, protocol, conn_status);

    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we don't think we're teaming, don't bother to check for sure, just
       use our own load module and go with it - in the worst case, we handle a
       packet we perhaps shouldn't have while we were joining a team or changing
       our current team configuration. */
    if (ctxtp->bda_teaming.active) {
        /* Check the teaming configuration and add a reference to the load module before consulting the load 
           module.  If the bRefused is TRUE, then the load module was NOT referenced, so we can bail out. */
        bTeaming = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bRefused);
        
        /* If teaming has suggested that we not allow this packet to pass, dump it. */
        if (bRefused) {       

            TRACE_FILTER("%!FUNC! Drop packet - BDA team inactive");

            acpt = FALSE;
            goto exit;
        }
    }
    
#if defined (NLB_HOOK_ENABLE)
    TRACE_FILTER("%!FUNC! Checking the hook feedback: reverse = %u", bReverse);

    switch (filter) {
    case NLB_FILTER_HOOK_PROCEED_WITH_HASH:
        /* Do nothing different as a result of the hook. */
        break;
    case NLB_FILTER_HOOK_REVERSE_HASH:
        /* Ignore whatever hashing settings we found in our configuration
           and hash in the dircetion the hook asked us to. */
        TRACE_FILTER("%!FUNC! Forcing a reverse hash");
        bReverse = TRUE;
        break;
    case NLB_FILTER_HOOK_FORWARD_HASH:
        /* Ignore whatever hashing settings we found in our configuration
           and hash in the dircetion the hook asked us to. */
        TRACE_FILTER("%!FUNC! Forcing a forward hash");
        bReverse = FALSE;
        break;
    case NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY:
    case NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY:
    default:
        /* These cases should be taken care of long before we get here. */
        UNIV_ASSERT(FALSE);
        break;
    }
#endif

    /* Convert TCP port 1723 to PPTP for use by the load module.  This conversion must
       be done in main and not load, as the load module would not know whether to look
       at the server port or client port because of reverse hashing. */
    if ((protocol == TCPIP_PROTOCOL_TCP) && (svr_port == PPTP_CTRL_PORT))
        protocol = TCPIP_PROTOCOL_PPTP;

    NdisAcquireSpinLock(pLock);
    
    TRACE_FILTER("%!FUNC! Consulting the load module: reverse = %u", bReverse);

    /* Consult the load module. */
    acpt = Load_conn_notify(pLoad, svr_addr, svr_port, clt_addr, clt_port, protocol, conn_status, bTeaming, (BOOLEAN)bReverse);
 
    NdisReleaseSpinLock(pLock);
    
 exit:

    /* Release the reference on the load module if necessary.  If we aren't teaming, even in 
       the case we skipped calling Main_teaming_Acquire_load_module above, bTeaming is FALSE, 
       so there is no need to call this function to release a reference. */
    if (bTeaming) Main_teaming_release_load(pLoad, pLock, bTeaming);

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

#if defined (NLB_TCP_NOTIFICATION)
/*
 * Function: Main_conn_up
 * Description: This function is used to notify NLB that a new connection has been established
 *              on the given NLB instance.  This function performs a few house-keeping duties
 *              such as BDA state lookup, hook filter feedback processing, etc. before calling
 *              the load module to create state to track this connection.
 * Parameters: ctxtp - the adapter context for the NLB instance on which the connection was established.
 *             svr_addr - the server IP address of the connection, in network byte order.
 *             svr_port - the server port of the connection, in host byte order.
 *             clt_addr - the client IP address of the connection, in network byte order.
 *             clt_port - the client port of the connection, in host byte order.
 *             protocol - the protocol of the connection.
#if defined (NLB_HOOK_ENABLE)
 *             filter - the feedback from the query hook, if one was registered.
#endif
 * Returns: BOOLEAN - whether or not state was successfully created to track this connection.
 * Author: shouse, 4.15.02
 * Notes: DO NOT ACQUIRE ANY LOAD LOCKS IN THIS FUNCTION.
 */
__inline BOOLEAN Main_conn_up (
    PMAIN_CTXT                ctxtp, 
    ULONG                     svr_addr, 
    ULONG                     svr_port, 
    ULONG                     clt_addr, 
    ULONG                     clt_port,
#if defined (NLB_HOOK_ENABLE)
    USHORT                    protocol,
    NLB_FILTER_HOOK_DIRECTIVE filter
#else
    USHORT                    protocol
#endif
) 
{
    /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
       assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
    PLOAD_CTXT      pLoad = &ctxtp->load;
    PNDIS_SPIN_LOCK pLock = &ctxtp->load_lock;
    ULONG           bReverse = ctxtp->reverse_hash;
    BOOLEAN         bRefused = FALSE;
    BOOLEAN         bTeaming = FALSE;
    BOOLEAN         acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: ctxtp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u", 
                 ctxtp, IP_GET_OCTET(svr_addr, 0), IP_GET_OCTET(svr_addr, 1), IP_GET_OCTET(svr_addr, 2), IP_GET_OCTET(svr_addr, 3), svr_port, 
                 IP_GET_OCTET(clt_addr, 0), IP_GET_OCTET(clt_addr, 1), IP_GET_OCTET(clt_addr, 2), IP_GET_OCTET(clt_addr, 3), clt_port, protocol);

    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we don't think we're teaming, don't bother to check for sure, just
       use our own load module and go with it - in the worst case, we handle a
       packet we perhaps shouldn't have while we were joining a team or changing
       our current team configuration. */
    if (ctxtp->bda_teaming.active) {
        /* Check the teaming configuration and add a reference to the load module before consulting the load 
           module.  If the bRefused is TRUE, then the load module was NOT referenced, so we can bail out. */
        bTeaming = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bRefused);
        
        /* If teaming has suggested that we not allow this packet to pass, dump it. */
        if (bRefused) {       

            TRACE_FILTER("%!FUNC! Drop packet - BDA team inactive");

            acpt = FALSE;
            goto exit;
        }
    }
    
#if defined (NLB_HOOK_ENABLE)
    TRACE_FILTER("%!FUNC! Checking the hook feedback: reverse = %u", bReverse);

    switch (filter) {
    case NLB_FILTER_HOOK_PROCEED_WITH_HASH:
        /* Do nothing different as a result of the hook. */
        break;
    case NLB_FILTER_HOOK_REVERSE_HASH:
        /* Ignore whatever hashing settings we found in our configuration
           and hash in the dircetion the hook asked us to. */
        TRACE_FILTER("%!FUNC! Forcing a reverse hash");
        bReverse = TRUE;
        break;
    case NLB_FILTER_HOOK_FORWARD_HASH:
        /* Ignore whatever hashing settings we found in our configuration
           and hash in the dircetion the hook asked us to. */
        TRACE_FILTER("%!FUNC! Forcing a forward hash");
        bReverse = FALSE;
        break;
    case NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY:
    case NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY:
    default:
        /* These cases should be taken care of long before we get here. */
        UNIV_ASSERT(FALSE);
        break;
    }
#endif

    /* Convert TCP port 1723 to PPTP for use by the load module.  This conversion must
       be done in main and not load, as the load module would not know whether to look
       at the server port or client port because of reverse hashing. */
    if ((protocol == TCPIP_PROTOCOL_TCP) && (svr_port == PPTP_CTRL_PORT))
        protocol = TCPIP_PROTOCOL_PPTP;

    TRACE_FILTER("%!FUNC! Consulting the load module: reverse = %u", bReverse);

    /* Consult the load module. */
    acpt = Load_conn_up(pLoad, svr_addr, svr_port, clt_addr, clt_port, protocol, bTeaming, (BOOLEAN)bReverse);
    
 exit:

    /* Release the reference on the load module if necessary.  If we aren't teaming, even in 
       the case we skipped calling Main_teaming_Acquire_load_module above, bTeaming is FALSE, 
       so there is no need to call this function to release a reference. */
    if (bTeaming) Main_teaming_release_load(pLoad, pLock, bTeaming);

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

/*
 * Function: Main_conn_down
 * Description: This function is used to notify NLB that a protocol is removing state for an exisiting 
 *              (but not necessarily established) connection.  This function calls into the load module
 *              to find and destroy and state associated with this connection, which may or may not
 *              exist; if the connection was established on a non-NLB adapter, then NLB has no state
 *              associated with the connection.
 * Parameters: svr_addr - the server IP address of the connection, in network byte order.
 *             svr_port - the server port of the connection, in host byte order.
 *             clt_addr - the client IP address of the connection, in network byte order.
 *             clt_port - the client port of the connection, in host byte order.
 *             protocol - the protocol of the connection.
 *             conn_status - whether the connection is being torn-down or reset.
 * Returns: BOOLEAN - whether or not NLB found and destroyed the state for this connection.
 * Author: shouse, 4.15.02
 * Notes: DO NOT ACQUIRE ANY LOAD LOCKS IN THIS FUNCTION.
 */
__inline BOOLEAN Main_conn_down (
    ULONG      svr_addr, 
    ULONG      svr_port, 
    ULONG      clt_addr, 
    ULONG      clt_port,
    USHORT     protocol,
    ULONG      conn_status
) 
{
    BOOLEAN    acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u, status = %u", 
                 IP_GET_OCTET(svr_addr, 0), IP_GET_OCTET(svr_addr, 1), IP_GET_OCTET(svr_addr, 2), IP_GET_OCTET(svr_addr, 3), svr_port, 
                 IP_GET_OCTET(clt_addr, 0), IP_GET_OCTET(clt_addr, 1), IP_GET_OCTET(clt_addr, 2), IP_GET_OCTET(clt_addr, 3), clt_port, protocol, conn_status);

    /* Convert TCP port 1723 to PPTP for use by the load module.  This conversion must
       be done in main and not load, as the load module would not know whether to look
       at the server port or client port because of reverse hashing. */
    if ((protocol == TCPIP_PROTOCOL_TCP) && (svr_port == PPTP_CTRL_PORT))
        protocol = TCPIP_PROTOCOL_PPTP;

    TRACE_FILTER("%!FUNC! Consulting the load module");

    /* Consult the load module. */
    acpt = Load_conn_down(svr_addr, svr_port, clt_addr, clt_port, protocol, conn_status);
    
    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

/*
 * Function: Main_conn_pending
 * Description: This function is used to notify NLB that an OUTGOING connection is being established.
 *              Because it is unknown on which adapter the connection will return and ultimately be
 *              established, NLB creates state to track this connection globally and when the connection
 *              is finally established, the protocol informs NLB on which adapter the connection was
 *              completed (via Main_conn_established).  This function merely creates some global state
 *              to ensure that if the connection DOES come back on an NLB adapter, we'll be sure to 
 *              pass the packet(s) up to the protocol.
 * Parameters: svr_addr - the server IP address of the connection, in network byte order.
 *             svr_port - the server port of the connection, in host byte order.
 *             clt_addr - the client IP address of the connection, in network byte order.
 *             clt_port - the client port of the connection, in host byte order.
 *             protocol - the protocol of the connection.
 * Returns: BOOLEAN - whether or not NLB was able to create state to track this pending connection.
 * Author: shouse, 4.15.02
 * Notes: DO NOT ACQUIRE ANY LOAD LOCKS IN THIS FUNCTION.
 */
__inline BOOLEAN Main_conn_pending (
    ULONG      svr_addr, 
    ULONG      svr_port, 
    ULONG      clt_addr, 
    ULONG      clt_port,
    USHORT     protocol
) 
{
    BOOLEAN    acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u", 
                 IP_GET_OCTET(svr_addr, 0), IP_GET_OCTET(svr_addr, 1), IP_GET_OCTET(svr_addr, 2), IP_GET_OCTET(svr_addr, 3), svr_port, 
                 IP_GET_OCTET(clt_addr, 0), IP_GET_OCTET(clt_addr, 1), IP_GET_OCTET(clt_addr, 2), IP_GET_OCTET(clt_addr, 3), clt_port, protocol);

    /* Convert TCP port 1723 to PPTP for use by the load module.  This conversion must
       be done in main and not load, as the load module would not know whether to look
       at the server port or client port because of reverse hashing. */
    if ((protocol == TCPIP_PROTOCOL_TCP) && (svr_port == PPTP_CTRL_PORT))
        protocol = TCPIP_PROTOCOL_PPTP;

    TRACE_FILTER("%!FUNC! Consulting the load module");

    /* Consult the load module. */
    acpt = Load_conn_pending(svr_addr, svr_port, clt_addr, clt_port, protocol);

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

/*
 * Function: Main_pending_check
 * Description: This function checks to see whether or not pending connection state is present
 *              for the given connection.  If so, the packet is accepted; if not, it should be
 *              dropped.
 * Parameters: svr_addr - the server IP address (source IP on send, destination IP on recv).
 *             svr_port - the server port (source port on send, destination port on recv).
 *             clt_addr - the client IP address (detination IP on send, source IP on recv).
 *             clt_port - the client port (destination port on send, source port on recv).
 *             protocol - the protocol for this packet. 
 * Returns: BOOLEAN - indication of whether or not the pending connection was found.
 * Author: shouse, 4.15.02
 * Notes: DO NOT ACQUIRE ANY LOAD LOCKS IN THIS FUNCTION.
 */
__inline BOOLEAN Main_pending_check (
    ULONG      svr_addr, 
    ULONG      svr_port, 
    ULONG      clt_addr, 
    ULONG      clt_port,
    USHORT     protocol
) 
{
    BOOLEAN    acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u", 
                 IP_GET_OCTET(svr_addr, 0), IP_GET_OCTET(svr_addr, 1), IP_GET_OCTET(svr_addr, 2), IP_GET_OCTET(svr_addr, 3), svr_port, 
                 IP_GET_OCTET(clt_addr, 0), IP_GET_OCTET(clt_addr, 1), IP_GET_OCTET(clt_addr, 2), IP_GET_OCTET(clt_addr, 3), clt_port, protocol);

    /* Convert TCP port 1723 to PPTP for use by the load module.  This conversion must
       be done in main and not load, as the load module would not know whether to look
       at the server port or client port because of reverse hashing. */
    if ((protocol == TCPIP_PROTOCOL_TCP) && (svr_port == PPTP_CTRL_PORT))
        protocol = TCPIP_PROTOCOL_PPTP;

    TRACE_FILTER("%!FUNC! Consulting the load module");

    /* Consult the load module. */
    acpt = Load_pending_check(svr_addr, svr_port, clt_addr, clt_port, protocol);

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}

/*
 * Function: Main_conn_establish
 * Description: This function is used to notify NLB that a new OUTGOING connection has been 
 *              established on the given NLB adapter.  Note that the context CAN BE NULL if 
 *              the connection was established on a non-NLB adapter.  In that case, we don't
 *              want to create state to track the connection, but we need to remove our state
 *              that was tracking this pending outgoing connection.  If the context is non-
 *              NULL, then in addition, we need to create the state to track this new connection.
 *              This function performs a few house-keeping duties such as BDA state lookup, hook 
 *              filter feedback processing, etc. before calling the load module to modify the
 *              state for this connection.
 * Parameters: ctxtp - the adapter context for the NLB instance on which the connection was established.
 *             svr_addr - the server IP address of the connection, in network byte order.
 *             svr_port - the server port of the connection, in host byte order.
 *             clt_addr - the client IP address of the connection, in network byte order.
 *             clt_port - the client port of the connection, in host byte order.
 *             protocol - the protocol of the connection.
#if defined (NLB_HOOK_ENABLE)
 *             filter - the feedback from the query hook, if one was registered.
#endif
 * Returns: BOOLEAN - whether or not state was successfully updated for this connection.
 * Author: shouse, 4.15.02
 * Notes: ctxtp CAN BE NULL if the outgoing connection was established on a non-NLB NIC.
 *        DO NOT ACQUIRE ANY LOAD LOCKS IN THIS FUNCTION.
 */
__inline BOOLEAN Main_conn_establish (
    PMAIN_CTXT                ctxtp, 
    ULONG                     svr_addr, 
    ULONG                     svr_port, 
    ULONG                     clt_addr, 
    ULONG                     clt_port,
#if defined (NLB_HOOK_ENABLE)
    USHORT                    protocol,
    NLB_FILTER_HOOK_DIRECTIVE filter
#else
    USHORT                    protocol
#endif
) 
{
    BOOLEAN         acpt = TRUE;

    TRACE_FILTER("%!FUNC! Enter: ctxtp = %p, server IP = %u.%u.%u.%u, server port = %u, client IP = %u.%u.%u.%u, client port = %u, protocol = %u", 
                 ctxtp, IP_GET_OCTET(svr_addr, 0), IP_GET_OCTET(svr_addr, 1), IP_GET_OCTET(svr_addr, 2), IP_GET_OCTET(svr_addr, 3), svr_port, 
                 IP_GET_OCTET(clt_addr, 0), IP_GET_OCTET(clt_addr, 1), IP_GET_OCTET(clt_addr, 2), IP_GET_OCTET(clt_addr, 3), clt_port, protocol);
        
    /* Convert TCP port 1723 to PPTP for use by the load module.  This conversion must
       be done in main and not load, as the load module would not know whether to look
       at the server port or client port because of reverse hashing. */
    if ((protocol == TCPIP_PROTOCOL_TCP) && (svr_port == PPTP_CTRL_PORT))
        protocol = TCPIP_PROTOCOL_PPTP;

    if (ctxtp == NULL)
    {
        TRACE_FILTER("%!FUNC! Consulting the load module");
        
        /* Consult the load module.  Note that Load_conn_establish MUST handle a NULL load pointer. 
           The values of limit_map_fn and reverse_hash are irrelevant in this case. */
        acpt = Load_conn_establish(NULL, svr_addr, svr_port, clt_addr, clt_port, protocol, FALSE, FALSE);
    }
    else
    {
        /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
           assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
        PLOAD_CTXT      pLoad = &ctxtp->load;
        PNDIS_SPIN_LOCK pLock = &ctxtp->load_lock;
        ULONG           bReverse = ctxtp->reverse_hash;
        BOOLEAN         bRefused = FALSE;
        BOOLEAN         bTeaming = FALSE;
        
        /* We check whether or not we are teaming without grabbing the global teaming
           lock in an effort to minimize the common case - teaming is a special mode
           of operation that is only really useful in a clustered firewall scenario.
           So, if we don't think we're teaming, don't bother to check for sure, just
           use our own load module and go with it - in the worst case, we handle a
           packet we perhaps shouldn't have while we were joining a team or changing
           our current team configuration. */
        if (ctxtp->bda_teaming.active) {
            /* Check the teaming configuration and add a reference to the load module before consulting the load 
               module.  If the bRefused is TRUE, then the load module was NOT referenced, so we can bail out. */
            bTeaming = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bRefused);
            
            /* If teaming has suggested that we not allow this packet to pass, dump it. */
            if (bRefused) {       
                
                TRACE_FILTER("%!FUNC! Drop packet - BDA team inactive");
                
                acpt = FALSE;
                goto exit;
            }
        }
        
#if defined (NLB_HOOK_ENABLE)
        TRACE_FILTER("%!FUNC! Checking the hook feedback: reverse = %u", bReverse);
        
        switch (filter) {
        case NLB_FILTER_HOOK_PROCEED_WITH_HASH:
            /* Do nothing different as a result of the hook. */
            break;
        case NLB_FILTER_HOOK_REVERSE_HASH:
            /* Ignore whatever hashing settings we found in our configuration
               and hash in the dircetion the hook asked us to. */
            TRACE_FILTER("%!FUNC! Forcing a reverse hash");
            bReverse = TRUE;
            break;
        case NLB_FILTER_HOOK_FORWARD_HASH:
            /* Ignore whatever hashing settings we found in our configuration
               and hash in the dircetion the hook asked us to. */
            TRACE_FILTER("%!FUNC! Forcing a forward hash");
            bReverse = FALSE;
            break;
        case NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY:
        case NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY:
        default:
            /* These cases should be taken care of long before we get here. */
            UNIV_ASSERT(FALSE);
            break;
        }
#endif

        TRACE_FILTER("%!FUNC! Consulting the load module: reverse = %u", bReverse);        

        /* Consult the load module. */
        acpt = Load_conn_establish(pLoad, svr_addr, svr_port, clt_addr, clt_port, protocol, bTeaming, (BOOLEAN)bReverse);
        
    exit:
        
        /* Release the reference on the load module if necessary.  If we aren't teaming, even in 
           the case we skipped calling Main_teaming_Acquire_load_module above, bTeaming is FALSE, 
           so there is no need to call this function to release a reference. */
        if (bTeaming) Main_teaming_release_load(pLoad, pLock, bTeaming);
    }

    TRACE_FILTER("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
}
#endif

/* 
 * Function: Main_query_packet_filter
 * Desctription: This function takes an IP address tuple and a protocol and determines whether
 *               or not this virtual packet would be accepted by this instance of NLB.  This 
 *               function checks reasons for accept/drop such as NLB being turned off, or the
 *               destination IP address being the dedicated IP address, BDA teaming, etc.  The
 *               load module is then consulted to make a accept/drop decision based on the 
 *               current load balancing policy in place.  The reason for accepting or dropping
 *               the packet is returned, as well as some load-balancing state used to make the
 *               decision, in appropriate instances.  This function DOES NOT change the state 
 *               of NLB at ALL, so its execution does not change or affect normal NLB operation
 *               in any way.
 * Parameters: ctxtp - a pointer to the NLB context buffer for the appropriate NLB instance.
 *             pQuery - a buffer into which the results of filtering the virtual packet are placed.
 * Returns: Nothing.
 * Author: shouse, 5.18.01
 * Notes: It is critical the NO CHANGES are made to NLB here - only observe, don't interfere.
 */
VOID Main_query_packet_filter (PMAIN_CTXT ctxtp, PNLB_OPTIONS_PACKET_FILTER pQuery)
{
    /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
       assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
    PLOAD_CTXT      pLoad;
    PNDIS_SPIN_LOCK pLock;
    ULONG           bReverse = ctxtp->reverse_hash;
    BOOLEAN         bTeaming = FALSE;
    BOOLEAN         bRefused = FALSE;
    BOOLEAN         acpt = TRUE;
#if defined (NLB_HOOK_ENABLE)
    NLB_FILTER_HOOK_DIRECTIVE filter = NLB_FILTER_HOOK_PROCEED_WITH_HASH;
#endif

    UNIV_ASSERT(ctxtp);
    UNIV_ASSERT(pQuery);

    pLoad = &ctxtp->load;
    pLock = &ctxtp->load_lock;

    /* NOTE: This entire operation assumes RECEIVE path semantics - most outgoing traffic
       is not filtered by NLB anyway, so there isn't much need to query send filtering. */

    /* First check for remote control requests, which are always UDP and are always allowed to pass, but
       of course, are never actually seen by the protocol stack (they're turned around internally). */
    if (pQuery->Protocol == TCPIP_PROTOCOL_UDP) {
        /* Otherwise, if the server UDP port is the remote control port, then this is an incoming
           remote control request from another NLB cluster host.  These are always allowed to pass. */
        if (ctxtp->params.rct_enabled &&
            (pQuery->ServerPort == ctxtp->params.rct_port || pQuery->ServerPort == CVY_DEF_RCT_PORT_OLD) &&
            (pQuery->ServerIPAddress == ctxtp->cl_ip_addr || pQuery->ServerIPAddress == TCPIP_BCAST_ADDR)) {
            pQuery->Accept = NLB_ACCEPT_REMOTE_CONTROL_REQUEST;
            return;  
        }
    }

#if defined (NLB_HOOK_ENABLE)
    /* Invoke the packet query hook, if one has been registered. */
    filter = Main_query_hook(ctxtp, pQuery->ServerIPAddress, pQuery->ServerPort, pQuery->ClientIPAddress, pQuery->ClientPort, pQuery->Protocol);

    /* Process some of the hook responses. */
    if (filter == NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY) 
    {
        /* Unconditionally accept the packet. */
        pQuery->Accept = NLB_REJECT_HOOK;
        return;
    }
    else if (filter == NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY) 
    {
        /* Unconditionally drop the packet. */
        pQuery->Accept = NLB_ACCEPT_HOOK;
        return;
    }
#endif

    /* Before we pass remote control responses up the stack, which are normally not filtered, 
       we consult the hook to make sure we aren't supposed to drop it. */
    if (pQuery->Protocol == TCPIP_PROTOCOL_UDP) {
        /* If the client UDP port is the remote control port, then this is a remote control 
           response from another NLB cluster host.  These are always allowed to pass. */
        if (pQuery->ClientPort == ctxtp->params.rct_port || pQuery->ClientPort == CVY_DEF_RCT_PORT_OLD) {
            pQuery->Accept = NLB_ACCEPT_REMOTE_CONTROL_RESPONSE;
            return; 
        }
    }

    /* Check for traffic destined for the dedicated IP address of this host.  
       These packets are always allowed to pass. */
    if (pQuery->ServerIPAddress == ctxtp->ded_ip_addr) {
        pQuery->Accept = NLB_ACCEPT_DIP;
        return;
    }

    /* Check for traffic destined for the cluster or dedicated broadcast IP addresses.  
       These packets are always allowed to pass. */
    if (pQuery->ServerIPAddress == ctxtp->ded_bcast_addr || pQuery->ServerIPAddress == ctxtp->cl_bcast_addr) {
        pQuery->Accept = NLB_ACCEPT_BROADCAST;
        return;
    }
    
    /* Check for passthru packets.  When the cluster IP address has not been specified, the
       cluster moves into passthru mode, in which it passes up ALL packets received. */
    if (ctxtp->cl_ip_addr == 0) {
        pQuery->Accept = NLB_ACCEPT_PASSTHRU_MODE;
        return;
    }
    
    /* Before we load-balance this packet, check to see whether or not its destined for
       the dedicated IP address of another NLB host in our cluster.  If it is, drop it. */
    if (DipListCheckItem(&ctxtp->dip_list, pQuery->ServerIPAddress)) {
        pQuery->Accept = NLB_REJECT_DIP;
        return;
    }

    /* If the cluster is not operational, which can happen, for example as a result of a wlbs.exe
       command such as "wlbs stop", or as a result of bad parameter settings, then drop all traffic 
       that does not meet the above conditions. */
    if (!ctxtp->convoy_enabled) {
        pQuery->Accept = NLB_REJECT_CLUSTER_STOPPED;
        return;
    }

    /* If this is an ICMP filter request, whether or not its filtered at all depends on the FilterICMP
       registry setting.  If we're not filtering ICMP, return ACCEPT now; otherwise, ICMP is filtered
       like UDP with no port information - fall through and consult the load module. */
    if (pQuery->Protocol == TCPIP_PROTOCOL_ICMP) {
        /* If we are filtering ICMP, change the protocol to UDP and the ports to 0, 0 before continuing. */
        if (ctxtp->params.filter_icmp) {
            pQuery->Protocol = TCPIP_PROTOCOL_UDP;
            pQuery->ClientPort = 0;
            pQuery->ServerPort = 0;
        /* Otherwise, return ACCEPT now and bail out. */
        } else {
            pQuery->Accept = NLB_ACCEPT_UNFILTERED;
            return;
        }
    }

    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we don't think we're teaming, don't bother to check for sure, just
       use our own load module and go with it - in the worst case, we handle a
       packet we perhaps shouldn't have while we were joining a team or changing
       our current team configuration. */
    if (ctxtp->bda_teaming.active) {
        /* Check the teaming configuration and add a reference to the load module before consulting the load 
           module.  If the return value is TRUE, then the load module was NOT referenced, so we can bail out. */
        bTeaming = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bRefused);
        
        /* If teaming has suggested that we not allow this packet to pass, the cluster will
           drop it.  This occurs when teams are inconsistently configured, or when a team is
           without a master, in which case there is no load context to consult anyway. */
        if (bRefused) {
            pQuery->Accept = NLB_REJECT_BDA_TEAMING_REFUSED;
            return;
        }
    }

#if defined (NLB_HOOK_ENABLE)
    switch (filter) {
    case NLB_FILTER_HOOK_PROCEED_WITH_HASH:
        /* Do nothing different as a result of the hook. */
        break;
    case NLB_FILTER_HOOK_REVERSE_HASH:
        /* Ignore whatever hashing settings we found in our configuration
           and hash in the dircetion the hook asked us to. */
        bReverse = TRUE;
        break;
    case NLB_FILTER_HOOK_FORWARD_HASH:
        /* Ignore whatever hashing settings we found in our configuration
           and hash in the dircetion the hook asked us to. */
        bReverse = FALSE;
        break;
    case NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY:
    case NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY:
    default:
        /* These cases should be taken care of long before we get here. */
        UNIV_ASSERT(FALSE);
        break;
    }
#endif

    NdisAcquireSpinLock(pLock);

    /* Consult the load module. */
    Load_query_packet_filter(pLoad, pQuery, pQuery->ServerIPAddress, pQuery->ServerPort, pQuery->ClientIPAddress, pQuery->ClientPort, pQuery->Protocol, pQuery->Flags, bTeaming, (BOOLEAN)bReverse);

    NdisReleaseSpinLock(pLock);  
    
    /* Release the reference on the load module if necessary.  If we aren't teaming, even in 
       the case we skipped calling Main_teaming_Acquire_load_module above, bTeaming is FALSE, 
       so there is no need to call this function to release a reference. */
    if (bTeaming) Main_teaming_release_load(pLoad, pLock, bTeaming);

}

ULONG   Main_ip_addr_init (
    PMAIN_CTXT          ctxtp)
{
    ULONG               byte [4];
    ULONG               i;
    PWCHAR              tmp;
    ULONG               old_ip_addr;


    /* initialize dedicated IP address from the register string */

    tmp = ctxtp -> params . ded_ip_addr;
    ctxtp -> ded_ip_addr  = 0;

    /* do not initialize if one was not specified */

    if (tmp [0] == 0)
        goto ded_netmask;

    for (i = 0; i < 4; i ++)
    {
        if (! Univ_str_to_ulong (byte + i, tmp, & tmp, 3, 10) ||
            (i < 3 && * tmp != L'.'))
        {
            UNIV_PRINT_CRIT(("Main_ip_addr_init: Bad dedicated IP address"));
            TRACE_CRIT("%!FUNC! Bad dedicated IP address");
            LOG_MSG (MSG_WARN_DED_IP_ADDR, ctxtp -> params . ded_ip_addr);
            ctxtp -> ded_net_mask = 0;
            goto ded_netmask;
        }

        tmp ++;
    }

    IP_SET_ADDR (& ctxtp -> ded_ip_addr, byte [0], byte [1], byte [2], byte [3]);

    UNIV_PRINT_VERB(("Main_ip_addr_init: Dedicated IP address: %u.%u.%u.%u = %x", byte [0], byte [1], byte [2], byte [3], ctxtp -> ded_ip_addr));
    TRACE_VERB("%!FUNC! Dedicated IP address: %u.%u.%u.%u = 0x%x", byte [0], byte [1], byte [2], byte [3], ctxtp -> ded_ip_addr);

ded_netmask:

    /* initialize dedicated net mask from the register string */

    tmp = ctxtp -> params . ded_net_mask;
    ctxtp -> ded_net_mask = 0;

    /* do not initialize if one was not specified */

    if (tmp [0] == 0)
        goto cluster;

    for (i = 0; i < 4; i ++)
    {
        if (! Univ_str_to_ulong (byte + i, tmp, & tmp, 3, 10) ||
            (i < 3 && * tmp != L'.'))
        {
            UNIV_PRINT_CRIT(("Main_ip_addr_init: Bad dedicated net mask address"));
            TRACE_CRIT("%!FUNC! Bad dedicated net mask address");
            LOG_MSG (MSG_WARN_DED_NET_MASK, ctxtp -> params . ded_net_mask);
            ctxtp -> ded_ip_addr = 0;
            goto cluster;
        }

        tmp ++;
    }

    IP_SET_ADDR (& ctxtp -> ded_net_mask, byte [0], byte [1], byte [2], byte [3]);

    UNIV_PRINT_VERB(("Main_ip_addr_init: Dedicated net mask: %u.%u.%u.%u = %x", byte [0], byte [1], byte [2], byte [3], ctxtp -> ded_net_mask));
    TRACE_VERB("%!FUNC! Dedicated net mask: %u.%u.%u.%u = 0x%x", byte [0], byte [1], byte [2], byte [3], ctxtp -> ded_net_mask);

cluster:

    /* initialize cluster IP address from the register string */

    tmp = ctxtp -> params . cl_ip_addr;

    /* Save the previous cluster IP address to notify bi-directional affinity teaming. */
    old_ip_addr = ctxtp -> cl_ip_addr;

    ctxtp -> cl_ip_addr = 0;

    for (i = 0; i < 4; i ++)
    {
        if (! Univ_str_to_ulong (byte + i, tmp, & tmp, 3, 10) ||
            (i < 3 && * tmp != L'.'))
        {
            UNIV_PRINT_CRIT(("Main_ip_addr_init: Bad cluster IP address"));
            TRACE_CRIT("%!FUNC! Bad cluster IP address");
            LOG_MSG (MSG_ERROR_CL_IP_ADDR, ctxtp -> params . cl_ip_addr);
            ctxtp -> cl_net_mask = 0;
            return FALSE;
        }

        tmp ++;
    }

    IP_SET_ADDR (& ctxtp -> cl_ip_addr, byte [0], byte [1], byte [2], byte [3]);

    UNIV_PRINT_VERB(("Main_ip_addr_init: Cluster IP address: %u.%u.%u.%u = %x", byte [0], byte [1], byte [2], byte [3], ctxtp -> cl_ip_addr));
    TRACE_VERB("%!FUNC! Cluster IP address: %u.%u.%u.%u = 0x%x", byte [0], byte [1], byte [2], byte [3], ctxtp -> cl_ip_addr);

    /* Notify BDA teaming config that a cluster IP address might have changed. */
    Main_teaming_ip_addr_change(ctxtp, old_ip_addr, ctxtp->cl_ip_addr);

    /* initialize cluster net mask from the register string */

    tmp = ctxtp -> params . cl_net_mask;
    ctxtp -> cl_net_mask = 0;

    /* do not initialize if one was not specified */

    for (i = 0; i < 4; i ++)
    {
        if (! Univ_str_to_ulong (byte + i, tmp, & tmp, 3, 10) ||
            (i < 3 && * tmp != L'.'))
        {
            UNIV_PRINT_CRIT(("Main_ip_addr_init: Bad cluster net mask address"));
            TRACE_CRIT("%!FUNC! Bad cluster net mask address");
            LOG_MSG (MSG_ERROR_CL_NET_MASK, ctxtp -> params . cl_net_mask);
            return FALSE;
        }

        tmp ++;
    }

    IP_SET_ADDR (& ctxtp -> cl_net_mask, byte [0], byte [1], byte [2], byte [3]);

    UNIV_PRINT_VERB(("Main_ip_addr_init: Cluster net mask: %u.%u.%u.%u = %x", byte [0], byte [1], byte [2], byte [3], ctxtp -> cl_net_mask));
    TRACE_VERB("%!FUNC! Cluster net mask: %u.%u.%u.%u = 0x%x", byte [0], byte [1], byte [2], byte [3], ctxtp -> cl_net_mask);

    if (ctxtp -> params . mcast_support && ctxtp -> params . igmp_support)
    {
        /* Initialize the multicast IP address for IGMP support */

        tmp = ctxtp -> params . cl_igmp_addr;
        ctxtp -> cl_igmp_addr = 0;

        /* do not initialize if one was not specified */

        for (i = 0; i < 4; i ++)
        {
            if (! Univ_str_to_ulong (byte + i, tmp, & tmp, 3, 10) ||
                (i < 3 && * tmp != L'.'))
            {
                UNIV_PRINT_CRIT(("Main_ip_addr_init: Bad cluster igmp address"));
                TRACE_CRIT("%!FUNC! Bad cluster igmp address");
                LOG_MSG (MSG_ERROR_CL_IGMP_ADDR, ctxtp -> params . cl_igmp_addr);
                return FALSE;
            }

            tmp ++;
        }

        IP_SET_ADDR (& ctxtp -> cl_igmp_addr, byte [0], byte [1], byte [2], byte [3]);

        UNIV_PRINT_VERB(("Main_ip_addr_init: Cluster IGMP Address: %u.%u.%u.%u = %x", byte [0], byte [1], byte [2], byte [3], ctxtp -> cl_igmp_addr));
        TRACE_VERB("%!FUNC! Cluster IGMP Address: %u.%u.%u.%u = 0x%x", byte [0], byte [1], byte [2], byte [3], ctxtp -> cl_igmp_addr);
    }

    if ((ctxtp -> ded_ip_addr != 0 && ctxtp -> ded_net_mask == 0) ||
        (ctxtp -> ded_ip_addr == 0 && ctxtp -> ded_net_mask != 0))
    {
        UNIV_PRINT_CRIT(("Main_ip_addr_init: Need to specify both dedicated IP address AND network mask"));
        TRACE_CRIT("%!FUNC! Need to specify both dedicated IP address AND network mask");
        LOG_MSG (MSG_WARN_DED_MISMATCH, MSG_NONE);
        ctxtp -> ded_ip_addr = 0;
        ctxtp -> ded_net_mask = 0;
    }

    IP_SET_BCAST (& ctxtp -> cl_bcast_addr, ctxtp -> cl_ip_addr, ctxtp -> cl_net_mask);
    UNIV_PRINT_VERB(("Main_ip_addr_init: Cluster broadcast address: %u.%u.%u.%u = %x", ctxtp -> cl_bcast_addr & 0xff, (ctxtp -> cl_bcast_addr >> 8) & 0xff, (ctxtp -> cl_bcast_addr >> 16) & 0xff, (ctxtp -> cl_bcast_addr >> 24) & 0xff, ctxtp -> cl_bcast_addr));
    TRACE_VERB("%!FUNC! Cluster broadcast address: %u.%u.%u.%u = 0x%x", ctxtp -> cl_bcast_addr & 0xff, (ctxtp -> cl_bcast_addr >> 8) & 0xff, (ctxtp -> cl_bcast_addr >> 16) & 0xff, (ctxtp -> cl_bcast_addr >> 24) & 0xff, ctxtp -> cl_bcast_addr);

    if (ctxtp -> ded_ip_addr != 0)
    {
        IP_SET_BCAST (& ctxtp -> ded_bcast_addr, ctxtp -> ded_ip_addr, ctxtp -> ded_net_mask);
        UNIV_PRINT_VERB(("Main_ip_addr_init: Dedicated broadcast address: %u.%u.%u.%u = %x", ctxtp -> ded_bcast_addr & 0xff, (ctxtp -> ded_bcast_addr >> 8) & 0xff, (ctxtp -> ded_bcast_addr >> 16) & 0xff, (ctxtp -> ded_bcast_addr >> 24) & 0xff, ctxtp -> ded_bcast_addr));
        TRACE_VERB("%!FUNC! Dedicated broadcast address: %u.%u.%u.%u = 0x%x", ctxtp -> ded_bcast_addr & 0xff, (ctxtp -> ded_bcast_addr >> 8) & 0xff, (ctxtp -> ded_bcast_addr >> 16) & 0xff, (ctxtp -> ded_bcast_addr >> 24) & 0xff, ctxtp -> ded_bcast_addr);
    }
    else
        ctxtp -> ded_bcast_addr = 0;

    if (ctxtp -> cl_ip_addr == 0)
    {
        UNIV_PRINT_CRIT(("Main_ip_addr_init: Cluster IP address = 0. Cluster host stopped"));
        TRACE_CRIT("%!FUNC! Cluster IP address = 0. Cluster host stopped");
        return FALSE;
    }

    return TRUE;

} /* end Main_ip_addr_init */


ULONG   Main_mac_addr_init (
    PMAIN_CTXT          ctxtp)
{
    ULONG               i, b, len;
    PUCHAR              ap;
    PWCHAR              tmp;
    PUCHAR              srcp, dstp;
    ULONG               non_zero = 0;
    CVY_MAC_ADR         old_mac_addr;

    UNIV_ASSERT(ctxtp -> medium == NdisMedium802_3);

    /* remember old mac address so we can yank it out of the multicast list */
    old_mac_addr = ctxtp->cl_mac_addr;

    /* at the time this routine is called by Prot_bind - ded_mad_addr is
       already set */

    tmp = ctxtp -> params . cl_mac_addr;
    len = CVY_MAC_ADDR_LEN (ctxtp -> medium);

    ap = (PUCHAR) & ctxtp -> cl_mac_addr;

    for (i = 0; i < len; i ++)
    {
        /* setup destination broadcast and source cluster addresses */

        if (! Univ_str_to_ulong (& b, tmp, & tmp, 2, 16) ||
            (i < len - 1 && * tmp != L'-' && * tmp != L':'))
        {
            UNIV_PRINT_CRIT(("Main_mac_addr_init: Bad cluster network address"));
            TRACE_CRIT("%!FUNC! Bad cluster network address");
            LOG_MSG (MSG_ERROR_NET_ADDR, ctxtp -> params . cl_mac_addr);

            /* WLBS 2.3 prevent from failing if no MAC address - just use the
               dedicated one as cluster */

            NdisMoveMemory (& ctxtp -> cl_mac_addr, & ctxtp -> ded_mac_addr, len);
            non_zero = 1;
            break;
        }

        tmp ++;
        ap [i] = (UCHAR) b;

        /* WLBS 2.3 sum up bytes for future non-zero check */

        non_zero += b;
    }

    /* WLBS 2.3 - use dedicated address as cluster address if specified address
       is zero - this could be due to parameter errors */

    if (non_zero == 0)
        NdisMoveMemory (& ctxtp -> cl_mac_addr, & ctxtp -> ded_mac_addr, len);

    /* enforce group flag to proper value */

    if (ctxtp -> params . mcast_support)
        ap [0] |= ETHERNET_GROUP_FLAG;
    else
        ap [0] &= ~ETHERNET_GROUP_FLAG;

    dstp = ctxtp -> media_hdr . ethernet . dst . data;
    srcp = ctxtp -> media_hdr . ethernet . src . data;
    len = ETHERNET_ADDRESS_FIELD_SIZE;

    CVY_ETHERNET_ETYPE_SET (& ctxtp -> media_hdr . ethernet, MAIN_FRAME_SIG);

    ctxtp -> etype_old = FALSE;

    /* V1.3.1b - load multicast address as destination instead of broadcast */

    for (i = 0; i < len; i ++)
    {
        if (ctxtp -> params . mcast_support)
            dstp [i] = ap [i];
        else
            dstp [i] = 0xff;

        srcp [i] = ((PUCHAR) & ctxtp -> ded_mac_addr) [i];

    }

    if (! ctxtp -> params . mcast_support)
    {
        /* V2.0.6 - override source MAC address to prevent switch confusion */

        if (ctxtp -> params . mask_src_mac)
        {
            ULONG byte [4];

            CVY_MAC_ADDR_LAA_SET (ctxtp -> medium, srcp);

            * ((PUCHAR) (srcp + 1)) = (UCHAR) ctxtp -> params . host_priority;

            IP_GET_ADDR(ctxtp->cl_ip_addr, &byte[0], &byte[1], &byte[2], &byte[3]);

            * ((PUCHAR) (srcp + 2)) = (UCHAR) byte[0];
            * ((PUCHAR) (srcp + 3)) = (UCHAR) byte[1];
            * ((PUCHAR) (srcp + 4)) = (UCHAR) byte[2];
            * ((PUCHAR) (srcp + 5)) = (UCHAR) byte[3];

            // * ((PULONG) (srcp + 2)) = ctxtp -> cl_ip_addr;
        }

        /* make source address look difference than our dedicated to prevent
           Compaq drivers from optimizing their reception out */

        else
            CVY_MAC_ADDR_LAA_TOGGLE (ctxtp -> medium, srcp);
    }

    CVY_MAC_ADDR_PRINT (ctxtp -> medium, "Cluster network address: ", ap);
    CVY_MAC_ADDR_PRINT (ctxtp -> medium, "Dedicated network address: ", srcp);

    {
        ULONG               xferred = 0;
        ULONG               needed = 0;
        PNDIS_REQUEST       request;
        MAIN_ACTION         act;
        PUCHAR              ptr;
        NDIS_STATUS         status;
        ULONG               size, j;

        len = CVY_MAC_ADDR_LEN (ctxtp->medium);
        size = ctxtp->max_mcast_list_size * len;

        status = NdisAllocateMemoryWithTag (& ptr, size, UNIV_POOL_TAG);

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT(("Main_mac_addr_init: Error allocating space %d %x", size, status));
            TRACE_CRIT("%!FUNC! Error allocating space %d 0x%x", size, status);
            LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
            return FALSE;
        }

        act.code = MAIN_ACTION_CODE;
        act.ctxtp = ctxtp;
        
        act.op.request.xferred = &xferred;
        act.op.request.needed = &needed;
        act.op.request.external = FALSE;
        act.op.request.buffer_len = 0;
        act.op.request.buffer = NULL;
        
        NdisInitializeEvent(&act.op.request.event);
        
        NdisResetEvent(&act.op.request.event);

        NdisZeroMemory(&act.op.request.req, sizeof(NDIS_REQUEST));
        
        request = &act.op.request.req;

        /* get current mcast list */

        request -> RequestType = NdisRequestQueryInformation;

        request -> DATA . QUERY_INFORMATION . Oid = OID_802_3_MULTICAST_LIST;

        request -> DATA . QUERY_INFORMATION . InformationBufferLength = size;
        request -> DATA . QUERY_INFORMATION . InformationBuffer = ptr;

        act.status = NDIS_STATUS_FAILURE;
        status = Prot_request (ctxtp, & act, FALSE);

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT(("Main_mac_addr_init: Error %x querying multicast address list %d %d", status, xferred, needed));
            TRACE_CRIT("%!FUNC! Error 0x%x querying multicast address list %d %d", status, xferred, needed);
            NdisFreeMemory (ptr, size, 0);
            return FALSE;
        }

        for (i = 0; i < xferred; i += len)
        {
            if (CVY_MAC_ADDR_COMP (ctxtp -> medium, (PUCHAR) ptr + i, & old_mac_addr))
            {
                UNIV_PRINT_VERB(("Main_mac_addr_init: Old cluster MAC matched"));
                TRACE_VERB("%!FUNC! Old cluster MAC matched");
                CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & old_mac_addr);
                break;
            }
        }

        /* Load cluster address as multicast one to the NIC.  If the cluster IP address 0.0.0.0, then we
           don't want to add the multicast MAC address to the NIC. */
        if (ctxtp -> params . mcast_support) 
        {
            if (ctxtp -> params . cl_ip_addr != 0) 
            {
                if (i < xferred) 
                {
                    UNIV_PRINT_VERB(("Main_mac_addr_init: Copying new MAC into multicast list[%d]", i / len));
                    CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & ctxtp->cl_mac_addr);
                    
                    CVY_MAC_ADDR_COPY (ctxtp->medium, (PUCHAR) ptr + i, & ctxtp->cl_mac_addr);
                } 
                else 
                {
                    UNIV_PRINT_VERB(("Main_mac_addr_init: Adding new MAC"));
                    CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & ctxtp->cl_mac_addr);
                    
                    if (xferred + len > size)
                    {
                        UNIV_PRINT_CRIT(("Main_mac_addr_init: No room for cluster mac %d", ctxtp->max_mcast_list_size));
                        LOG_MSG1 (MSG_ERROR_MCAST_LIST_SIZE, MSG_NONE, ctxtp->max_mcast_list_size);
                        NdisFreeMemory (ptr, size, 0);
                        return FALSE;
                    }
                    
                    UNIV_PRINT_VERB(("Main_mac_addr_init: Copying new MAC into multicast list[%d]", i / len));
                    CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & ctxtp->cl_mac_addr);
                    
                    CVY_MAC_ADDR_COPY (ctxtp->medium, (PUCHAR) ptr + xferred, & ctxtp->cl_mac_addr);
                    
                    xferred += len;
                }
            } 
            else 
            {
                UNIV_PRINT_CRIT(("Main_mac_addr_init: Refusing to add an unconfigured cluster MAC address to the multicast list"));
                NdisFreeMemory (ptr, size, 0);
                return FALSE;
            }
        } 
        else 
        {
            if (i < xferred) 
            {
                for (j = i + len; j < xferred; j += len, i+= len) 
                {
                    if (CVY_MAC_ADDR_COMP (ctxtp -> medium, (PUCHAR) ptr + j, & old_mac_addr))
                    {
                        UNIV_PRINT_VERB(("Main_mac_addr_init: Old cluster MAC matched AGAIN - this shouldn't happen!!!"));
                        CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & old_mac_addr);
                        
                        break;
                    }

                    CVY_MAC_ADDR_COPY (ctxtp->medium, (PUCHAR) ptr + i, (PUCHAR) ptr + j);
                }

                xferred -= len;
            } 
            else 
            {
                NdisFreeMemory (ptr, size, 0);
                return TRUE;
            }
        }

        request -> RequestType = NdisRequestSetInformation;
        
        request -> DATA . SET_INFORMATION . Oid = OID_802_3_MULTICAST_LIST;
        
        request -> DATA . SET_INFORMATION . InformationBufferLength = xferred;
        request -> DATA . SET_INFORMATION . InformationBuffer = ptr;
        
        act.status = NDIS_STATUS_FAILURE;
        status = Prot_request (ctxtp, & act, FALSE);
        
        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT(("Main_mac_addr_init: Error %x setting multicast address %d %d", status, xferred, needed));
            TRACE_CRIT("%!FUNC! Error 0x%x setting multicast address %d %d", status, xferred, needed);
            NdisFreeMemory (ptr, size, 0);
            return FALSE;
        }
        
        NdisFreeMemory (ptr, size, 0);
    }

    return TRUE;

} /* end Main_mac_addr_init */


/* Initialize the Ethernet Header and IP packet for sending out IGMP joins/leaves */
ULONG Main_igmp_init (
    PMAIN_CTXT          ctxtp,
    BOOLEAN             join)
{
    PUCHAR              ptr;
    ULONG               checksum;
    PMAIN_IGMP_DATA     igmpd = & (ctxtp -> igmp_frame . igmp_data);
    PMAIN_IP_HEADER     iph  = & (ctxtp -> igmp_frame . ip_data);
    PUCHAR              srcp, dstp;
    UINT                i;

    UNIV_ASSERT (ctxtp -> medium == NdisMedium802_3);

    if ((!ctxtp -> params . mcast_support) || (!ctxtp -> params . igmp_support))
    {
        return FALSE;
    }

    /* Fill in the igmp data */
    igmpd -> igmp_vertype = 0x12; /* Needs to be changed for join/leave */
    igmpd -> igmp_unused  = 0x00;
    igmpd -> igmp_xsum    = 0x0000;
    igmpd -> igmp_address = ctxtp -> cl_igmp_addr;

    /* Compute the IGMP checksum */
    ptr = (PUCHAR) igmpd;
    checksum = 0;

    for (i = 0; i < sizeof (MAIN_IGMP_DATA) / 2; i ++, ptr += 2)
        checksum += (ULONG) ((ptr [0] << 8) | ptr [1]);

    checksum = (checksum >> 16) + (checksum & 0xffff);
    checksum += (checksum >> 16);
    checksum  = (~ checksum);

    ptr = (PUCHAR) (& igmpd -> igmp_xsum);
    ptr [0] = (CHAR) ((checksum >> 8) & 0xff);
    ptr [1] = (CHAR) (checksum & 0xff);

    /* Fill in the IP Header */
    iph -> iph_verlen   = 0x45;
    iph -> iph_tos      = 0;
    iph -> iph_length   = 0x1c00;
    iph -> iph_id       = 0xabcd; /* Need to find the significance of this later */
    iph -> iph_offset   = 0;
    iph -> iph_ttl      = 0x1;
    iph -> iph_protocol = 0x2;
    iph -> iph_xsum     = 0x0;
    iph -> iph_src      = ctxtp -> cl_ip_addr;
    iph -> iph_dest     = ctxtp -> cl_igmp_addr;

    /* Fill in the ethernet header */

    dstp = ctxtp -> media_hdr_igmp . ethernet . dst . data;
    srcp = ctxtp -> media_hdr_igmp . ethernet . src . data;
    
    CVY_ETHERNET_ETYPE_SET (& ctxtp -> media_hdr_igmp . ethernet, MAIN_IP_SIG);

    CVY_MAC_ADDR_COPY (ctxtp -> medium, dstp, & ctxtp -> cl_mac_addr);
    CVY_MAC_ADDR_COPY (ctxtp -> medium, srcp, & ctxtp -> ded_mac_addr);

    /* Fill in a MAIN_PACKET_INFO structure and calculate the IP checksum.
       Note that we are filling in WAY more information than Tcpip_chksum
       actually needs, but we do so not for correctness, but for completeness. */
    {
        MAIN_PACKET_INFO PacketInfo;

        /* Fill in the packet info strucutre. */
        PacketInfo.Medium = NdisMedium802_3;
        PacketInfo.Length = sizeof(MAIN_IP_HEADER);
        PacketInfo.Group = MAIN_FRAME_MULTICAST;
        PacketInfo.Type = TCPIP_IP_SIG;
        PacketInfo.Operation = MAIN_FILTER_OP_NONE;
        
        /* Fill in the ethernet header information. */
        PacketInfo.Ethernet.pHeader = &ctxtp->media_hdr_igmp.ethernet;
        PacketInfo.Ethernet.Length = sizeof(CVY_ETHERNET_HDR);
        
        /* Fill in the IP header information. */
        PacketInfo.IP.pHeader = (PIP_HDR)iph;
        PacketInfo.IP.Length = sizeof(MAIN_IP_HEADER);
        PacketInfo.IP.Protocol = TCPIP_PROTOCOL_IGMP;
        PacketInfo.IP.bFragment = FALSE;

        /* Compute the checksum for the IP header */
        checksum = Tcpip_chksum(&ctxtp->tcpip, &PacketInfo, TCPIP_PROTOCOL_IP);

        IP_SET_CHKSUM((PIP_HDR)iph, (USHORT)checksum);
    }

    return TRUE;

} /* end Main_igmp_init */

VOID Main_idhb_init(
    PMAIN_CTXT          ctxtp
)
{
    ULONG ulBodySize = 0, ulBodySize8 = 0;  /* Size of identity heartbeat in bytes and 8-byte units respectively */
    ULONG ulFqdnCB = 0;                     /* Number of bytes in fqdn, bounded by the size of the destination below */

    ulFqdnCB = min(sizeof(ctxtp->idhb_msg.fqdn) - sizeof(WCHAR),
                   sizeof(WCHAR)*wcslen(ctxtp->params.hostname)
                   );

    ulBodySize = sizeof(TLV_HEADER) + ulFqdnCB + sizeof(WCHAR); /* Include a NULL character whether or not there is an fqdn */

    /* Round up to the nearest 8-byte boundary */
    ulBodySize8 = (ulBodySize + 7)/8;

    UNIV_ASSERT(ulBodySize8 <= WLBS_MAX_ID_HB_BODY_SIZE);

    NdisZeroMemory(&(ctxtp->idhb_msg), sizeof(ctxtp->idhb_msg));

    ctxtp->idhb_msg.header.type    = MAIN_PING_EX_TYPE_IDENTITY;
    ctxtp->idhb_msg.header.length8 = (UCHAR) ulBodySize8;

    /* Copy the host name minus the null-terminator. We've initialized the destination to zero
       so we don't need to overwrite that location. */
    if (ulFqdnCB > 0)
    {
        NdisMoveMemory(&(ctxtp->idhb_msg.fqdn), &(ctxtp->params.hostname), ulFqdnCB);
    }

    ctxtp->idhb_size = 8*ulBodySize8;

    return;
}

NDIS_STATUS Main_init (
    PMAIN_CTXT          ctxtp)
{
    ULONG               i, size;
    NDIS_STATUS         status;
    PMAIN_FRAME_DSCR    dscrp;

    UNIV_ASSERT (ctxtp -> medium == NdisMedium802_3);

    /* Re-set the reference count. */
    ctxtp->ref_count = 0;

    /* Re-set BDA teaming - this will be initialized at the bottom of this function. */
    ctxtp->bda_teaming.active = FALSE;

    if (sizeof (PING_MSG) + sizeof (MAIN_FRAME_HDR) > ctxtp -> max_frame_size)
    {
        UNIV_PRINT_CRIT(("Main_init: Ping message will not fit in the media frame %d > %d", sizeof (PING_MSG) + sizeof (MAIN_FRAME_HDR), ctxtp -> max_frame_size));
        TRACE_CRIT("%!FUNC! Ping message will not fit in the media frame %d > %d", sizeof (PING_MSG) + sizeof (MAIN_FRAME_HDR), ctxtp -> max_frame_size);
        LOG_MSG2 (MSG_ERROR_INTERNAL, MSG_NONE, sizeof (PING_MSG) + sizeof (MAIN_FRAME_HDR), ctxtp -> max_frame_size);
        return NDIS_STATUS_FAILURE;
    }

    /* V2.0.6 initialize IP addresses - might be used in the Main_mac_addr_init
       so have to do it here */

    if (! Main_ip_addr_init (ctxtp))
    {
        ctxtp -> convoy_enabled = FALSE;
        ctxtp -> params_valid   = FALSE;
        UNIV_PRINT_CRIT(("Main_init: Error initializing IP addresses"));
        TRACE_CRIT("%!FUNC! Error initializing IP addresses");
    }

    /* V1.3.1b parse cluster MAC address from parameters */

    if (! Main_mac_addr_init (ctxtp))
    {
        ctxtp -> convoy_enabled = FALSE;
        ctxtp -> params_valid   = FALSE;
        UNIV_PRINT_CRIT(("Main_init: Error initializing cluster MAC address"));
        TRACE_CRIT("%!FUNC! Error initializing cluster MAC address");
    }

#if defined (NLB_TCP_NOTIFICATION)
    /* Now that the cluster IP address is set, try to map this adapter to its IP interface index. */
    Main_set_interface_index(NULL, ctxtp);
#endif

    /* Initialize IGMP message if in igmp mode */

    if (ctxtp -> params . mcast_support && ctxtp -> params . igmp_support)
    {
        if (! Main_igmp_init (ctxtp, TRUE))
        {
            ctxtp -> convoy_enabled = FALSE;
            ctxtp -> params_valid   = FALSE;
            UNIV_PRINT_CRIT(("Main_init: Error initializing IGMP message"));
            TRACE_CRIT("%!FUNC! Error initializing IGMP message");
        }

        UNIV_PRINT_VERB(("Main_init: IGMP message initialized"));
        TRACE_VERB("%!FUNC! IGMP message initialized");
    }

    /* can extract the send message pointer even if load is not inited yet V1.1.4 */
    ctxtp -> load_msgp = Load_snd_msg_get (& ctxtp -> load);

    /* Initialize identity cache */
    NdisZeroMemory(&(ctxtp->identity_cache), sizeof(ctxtp->identity_cache));
    ctxtp->idhb_size = 0;
    Main_idhb_init(ctxtp);

    /* initalize lists and locks */

    NdisInitializeListHead (& ctxtp -> act_list);
    NdisInitializeListHead (& ctxtp -> buf_list);
    NdisInitializeListHead (& ctxtp -> frame_list);

    NdisAllocateSpinLock (& ctxtp -> act_lock);
    NdisAllocateSpinLock (& ctxtp -> buf_lock);
    NdisAllocateSpinLock (& ctxtp -> recv_lock);
    NdisAllocateSpinLock (& ctxtp -> send_lock);
    NdisAllocateSpinLock (& ctxtp -> frame_lock);
    NdisAllocateSpinLock (& ctxtp -> load_lock);

    /* #ps# */
    NdisInitializeNPagedLookasideList (& ctxtp -> resp_list, NULL, NULL, 0,
                                       sizeof (MAIN_PROTOCOL_RESERVED),
                                       UNIV_POOL_TAG, 0);

    /* capture boot-time parameters */

    ctxtp -> num_packets   = ctxtp -> params . num_packets;
    ctxtp -> num_actions   = ctxtp -> params . num_actions;
    ctxtp -> num_send_msgs = ctxtp -> params . num_send_msgs;

#if 0
    /* ###### for tracking send filtering - ramkrish */
    ctxtp -> sends_in        = 0;
    ctxtp -> sends_completed = 0;
    ctxtp -> sends_filtered  = 0;
    ctxtp -> arps_filtered   = 0;
    ctxtp -> mac_modified    = 0;
    ctxtp -> uninited_return = 0;
#endif

    ctxtp->cntr_recv_tcp_resets = 0;
    ctxtp->cntr_xmit_tcp_resets = 0;

    /* V1.1.1 - initalize other contexts */

    Load_init (& ctxtp -> load, & ctxtp -> params);
    UNIV_PRINT_VERB(("Main_init: Initialized load"));
    TRACE_VERB("%!FUNC! Initialized load");

    if (! Tcpip_init (& ctxtp -> tcpip, & ctxtp -> params))
    {
        UNIV_PRINT_CRIT(("Main_init: Error initializing tcpip layer"));
        TRACE_CRIT("%!FUNC! Error initializing tcpip layer");
        goto error;
    }

    UNIV_PRINT_VERB(("Main_init: Initialized tcpip"));
    TRACE_VERB("%!FUNC! Initialized tcpip");

    /* Check the last known host state and see whether or not we are supposed
       to persist that state.  If we are, then no problems; if not, then we 
       need to revert to the preferred initial host state and update the last
       known host state in the registry. */
    switch (ctxtp->params.init_state) {
    case CVY_HOST_STATE_STARTED:
        if (!(ctxtp->params.persisted_states & CVY_PERSIST_STATE_STARTED)) {

            /* If the host state is already correct, don't bother to do anything. */
            if (ctxtp->params.init_state == ctxtp->params.cluster_mode)
                break;

            /* Set the desired state - this is the "cached" value. */
            ctxtp->cached_state = ctxtp->params.cluster_mode;

            /* Update the intial state registry key appropriately.  Because the adapter is not 
               yet "inited" (we're in the process), we cannot increment the reference count on 
               the context.  Therefore, we cannot call Main_set_host_state, which would fire an
               NDIS work item and increment the reference count on the context.  Instead, call
               the work item function directly to write to the registry (which is OK because 
               we're guaranteed to be running at PASSIVE_LEVEL here).  However, in this case, we 
               do NOT want to decrement the reference count in Params_set_host_state because we 
               did not increment it here.  By passing NULL for the NDIS work item pointer, we are 
               notifying this function that it was NOT called as the result of an NDIS work item
               and therefore should NOT decrement the reference count before it exits.*/
            Params_set_host_state(NULL, ctxtp);

            break;
        }

        LOG_MSG(MSG_INFO_HOST_STATE_PERSIST_STARTED, MSG_NONE);

        break;
    case CVY_HOST_STATE_STOPPED:
        if (!(ctxtp->params.persisted_states & CVY_PERSIST_STATE_STOPPED)) {

            /* If the host state is already correct, don't bother to do anything. */
            if (ctxtp->params.init_state == ctxtp->params.cluster_mode)
                break;

            /* Set the desired state - this is the "cached" value. */
            ctxtp->cached_state = ctxtp->params.cluster_mode;

            /* Update the intial state registry key appropriately.  Because the adapter is not 
               yet "inited" (we're in the process), we cannot increment the reference count on 
               the context.  Therefore, we cannot call Main_set_host_state, which would fire an
               NDIS work item and increment the reference count on the context.  Instead, call
               the work item function directly to write to the registry (which is OK because 
               we're guaranteed to be running at PASSIVE_LEVEL here).  However, in this case, we 
               do NOT want to decrement the reference count in Params_set_host_state because we 
               did not increment it here.  By passing NULL for the NDIS work item pointer, we are 
               notifying this function that it was NOT called as the result of an NDIS work item
               and therefore should NOT decrement the reference count before it exits.*/
            Params_set_host_state(NULL, ctxtp);

            break;
        }

        LOG_MSG(MSG_INFO_HOST_STATE_PERSIST_STOPPED, MSG_NONE);

        break;
    case CVY_HOST_STATE_SUSPENDED:
        if (!(ctxtp->params.persisted_states & CVY_PERSIST_STATE_SUSPENDED)) {

            /* If the host state is already correct, don't bother to do anything. */
            if (ctxtp->params.init_state == ctxtp->params.cluster_mode)
                break;

            /* Set the desired state - this is the "cached" value. */
            ctxtp->cached_state = ctxtp->params.cluster_mode;

            /* Update the intial state registry key appropriately.  Because the adapter is not 
               yet "inited" (we're in the process), we cannot increment the reference count on 
               the context.  Therefore, we cannot call Main_set_host_state, which would fire an
               NDIS work item and increment the reference count on the context.  Instead, call
               the work item function directly to write to the registry (which is OK because 
               we're guaranteed to be running at PASSIVE_LEVEL here).  However, in this case, we 
               do NOT want to decrement the reference count in Params_set_host_state because we 
               did not increment it here.  By passing NULL for the NDIS work item pointer, we are 
               notifying this function that it was NOT called as the result of an NDIS work item
               and therefore should NOT decrement the reference count before it exits.*/
            Params_set_host_state(NULL, ctxtp);

            break;
        }

        LOG_MSG(MSG_INFO_HOST_STATE_PERSIST_SUSPENDED, MSG_NONE);
        
        break;
    default:
        UNIV_PRINT_CRIT(("Main_init: Unknown host state: %u", ctxtp->params.init_state));
        goto error;
    }
    
    /* If there have been no errors to this point, setup the host state accordingly. */
    if (ctxtp->params_valid && ctxtp->convoy_enabled) {
        /* If the initial state is started, then start the load module now. */
        if (ctxtp->params.init_state == CVY_HOST_STATE_STARTED) {
            UNIV_PRINT_VERB(("Main_init: Calling load_start"));

            Load_start(&ctxtp->load);

        /* If the initial state is suspended, set the suspended flag. */
        } else if (ctxtp->params.init_state == CVY_HOST_STATE_SUSPENDED) {
            ctxtp->suspended = TRUE;
        }
    }

    /* allocate actions */

    size = sizeof (MAIN_ACTION);
#ifdef _WIN64 // 64-bit -- ramkrish
    ctxtp -> act_size = (size & 0x7) ? (size + 8 - (size & 0x7) ) : size;
#else
    ctxtp -> act_size = size;
#endif

    if (! Main_actions_alloc (ctxtp))
        goto error;

    /* V1.3.2b - allocate buffers */

    ctxtp -> buf_mac_hdr_len = CVY_MAC_HDR_LEN (ctxtp -> medium);
    ctxtp -> buf_size = sizeof (MAIN_BUFFER) + ctxtp -> buf_mac_hdr_len +
                        ctxtp -> max_frame_size - 1;

    /* 64-bit -- ramkrish */
    UNIV_PRINT_VERB(("Main_init: ctxtp -> buf_size = %d", ctxtp -> buf_size));
    TRACE_VERB("%!FUNC! ctxtp -> buf_size = %d", ctxtp -> buf_size);
    size = ctxtp -> buf_size;
#ifdef _WIN64
    ctxtp -> buf_size = (size & 0x7) ? (size + 8 - (size & 0x7)) : size;
    UNIV_PRINT_VERB(("Main_init: ctxtp -> buf_size = %d", ctxtp -> buf_size));
    TRACE_VERB("%!FUNC! ctxtp -> buf_size = %d", ctxtp -> buf_size);
#else
    ctxtp -> buf_size = size;
#endif

    if (! Main_bufs_alloc (ctxtp))
        goto error;

    size = ctxtp -> num_packets;

    /* V1.1.2 - allocate packet pools */

    NdisAllocatePacketPool (& status, & (ctxtp -> send_pool_handle [0]),
                            ctxtp -> num_packets,
                            sizeof (MAIN_PROTOCOL_RESERVED));

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Main_init: Error allocating send packet pool %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        TRACE_CRIT("%!FUNC! Error allocating send packet pool %d 0x%x", size, status);
        goto error;
    }

    ctxtp -> num_send_packet_allocs = 1;
    ctxtp -> cur_send_packet_pool   = 0;
    ctxtp -> num_sends_alloced = ctxtp->num_packets;

    NdisAllocatePacketPool (& status, & (ctxtp -> recv_pool_handle [0]),
                            ctxtp -> num_packets,
                            sizeof (MAIN_PROTOCOL_RESERVED));

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Main_init: Error allocating recv packet pool %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        TRACE_CRIT("%!FUNC! Error allocating recv packet pool %d 0x%x", size, status);
        goto error;
    }

    ctxtp -> num_recv_packet_allocs = 1;
    ctxtp -> cur_recv_packet_pool   = 0;
    ctxtp -> num_recvs_alloced = ctxtp->num_packets;

    /* allocate support for heartbeat ping messages */

    size = sizeof (MAIN_FRAME_DSCR) * ctxtp -> num_send_msgs;

    status = NdisAllocateMemoryWithTag (& ctxtp -> frame_dscrp, size,
                                        UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Main_init: Error allocating frame descriptors %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        TRACE_CRIT("%!FUNC! Error allocating frame descriptors %d 0x%x", size, status);
        goto error;
    }

    size = ctxtp -> num_send_msgs;

    NdisAllocatePacketPool (& status, & ctxtp -> frame_pool_handle,
                            ctxtp -> num_send_msgs,
                            sizeof (MAIN_PROTOCOL_RESERVED));

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Main_init: Error allocating ping packet pool %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        TRACE_CRIT("%!FUNC! Error allocating ping packet pool %d 0x%x", size, status);
        goto error;
    }

    size = 5 * ctxtp -> num_send_msgs;

    NdisAllocateBufferPool (& status, & ctxtp -> frame_buf_pool_handle,
                            5 * ctxtp -> num_send_msgs);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Main_init: Error allocating ping buffer pool %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        TRACE_CRIT("%!FUNC! Error allocating ping buffer pool %d 0x%x", size, status);
        goto error;
    }

    for (i = 0; i < ctxtp -> num_send_msgs; i ++)
    {
        dscrp = & (ctxtp -> frame_dscrp [i]);

        /* this buffer describes Ethernet MAC header */
        
        size = sizeof (CVY_ETHERNET_HDR);
        
        NdisAllocateBuffer (& status, & dscrp -> media_hdr_bufp,
                            ctxtp -> frame_buf_pool_handle,
                            & dscrp -> media_hdr . ethernet,
                            sizeof (CVY_ETHERNET_HDR));
        
        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT(("Main_init: Error allocating ethernet header buffer %d %x", i, status));
            LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
            TRACE_CRIT("%!FUNC! Error allocating ethernet header buffer %d 0x%x", i, status);
            goto error;
        }
        
        dscrp -> recv_len = 0;

        dscrp -> recv_len += sizeof (MAIN_FRAME_HDR) + sizeof (PING_MSG);

        /* this buffer describes frame headers */

        size = sizeof (MAIN_FRAME_HDR);

        NdisAllocateBuffer (& status, & dscrp -> frame_hdr_bufp,
                            ctxtp -> frame_buf_pool_handle,
                            & dscrp -> frame_hdr,
                            sizeof (MAIN_FRAME_HDR));

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT(("Main_init: Error allocating frame header buffer %d %x", i, status));
            LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
            TRACE_CRIT("%!FUNC! Error allocating frame header buffer %d 0x%x", i, status);
            goto error;
        }

        /* this buffer describes receive ping message buffer V1.1.4 */

        size = sizeof (PING_MSG);

        NdisAllocateBuffer (& status, & dscrp -> recv_data_bufp,
                            ctxtp -> frame_buf_pool_handle,
                            & dscrp -> msg,
                            sizeof (PING_MSG));

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT(("Main_init: Error allocating recv msg buffer %d %x", i, status));
            LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
            TRACE_CRIT("%!FUNC! Error allocating recv msg buffer %d 0x%x", i, status);
            goto error;
        }

        dscrp -> send_data_bufp = NULL; /* Allocate this in Main_frame_get */

        NdisInterlockedInsertTailList (& ctxtp -> frame_list,
                                       & dscrp -> link,
                                       & ctxtp -> frame_lock);
    }

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* Set the current state of BDA teaming on this adapter.  This flag
       is used for synchronization to BDA teaming on this adapter. */
    ctxtp->bda_teaming.operation = BDA_TEAMING_OPERATION_NONE;

    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    /* Reset the number of connections forcefully purged. */
    ctxtp->num_purged = 0;

    /* Turn reverse-hashing off.  If we're part of a BDA team, the teaming configuration
       that is setup by the call to Main_teaming_init will over-write this setting. */
    ctxtp->reverse_hash = FALSE;

    /* Initialize the bi-directional affinity teaming if it has been configured. */
    if (!Main_teaming_init(ctxtp))
    {
        ctxtp->convoy_enabled = FALSE;
        ctxtp->params_valid   = FALSE;
        UNIV_PRINT_CRIT(("Main_init: Error initializing bi-directional affinity teaming"));
        TRACE_CRIT("%!FUNC! Error initializing bi-directional affinity teaming");
    }
    else
    {
        UNIV_PRINT_VERB(("Main_init: Initialized bi-directional affinity teaming"));        
        TRACE_VERB("%!FUNC! Initialized bi-directional affinity teaming");
    }

    /* Initialize the DIP list structure. */
    DipListInitialize(&ctxtp->dip_list);

    return NDIS_STATUS_SUCCESS;

error:

    Main_cleanup (ctxtp);

    return NDIS_STATUS_FAILURE;

} /* end Main_init */


VOID Main_cleanup (
    PMAIN_CTXT          ctxtp)
{
    ULONG               i, j;
    PMAIN_BUFFER        bp;


    /* V1.1.4 */

    /* #ps# */
    /* While using packet stacking, ensure that all packets are returned
     * before clearing up the context
     */

    /* Wait for all references on our context have elapsed.  By now, the inited
       flag is reset, which will prevent this reference count from increasing
       while we sit here waiting for it to go to zero. */
    while (Main_get_reference_count(ctxtp)) {
        UNIV_PRINT_VERB(("Main_cleanup: Sleeping...\n"));
        TRACE_VERB("%!FUNC! sleeping");
        
        /* Sleep while there are references on our context.  
           These references come from pending IOCTLs. */
        Nic_sleep(10);
    }

    NdisDeleteNPagedLookasideList (& ctxtp -> resp_list);

    for (i = 0; i < CVY_MAX_ALLOCS; i ++)
    {
        if (ctxtp -> send_pool_handle [i] != NULL)
        {
            while (1)
            {
                if (NdisPacketPoolUsage (ctxtp -> send_pool_handle [i]) == 0)
                    break;

                Nic_sleep (10); /* wait for 10 milliseconds for the packets to be returned */
            }

            NdisFreePacketPool (ctxtp -> send_pool_handle [i]);
            ctxtp -> send_pool_handle [i] = NULL;
        }

        if (ctxtp -> recv_pool_handle [i] != NULL)
        {
            while (1)
            {
                if (NdisPacketPoolUsage (ctxtp -> recv_pool_handle [i]) == 0)
                    break;

                Nic_sleep (10); /* wait for 10 milliseconds for the packets to be returned */
            }

            NdisFreePacketPool (ctxtp -> recv_pool_handle [i]);
            ctxtp -> recv_pool_handle [i] = NULL;
        }

        if (ctxtp -> act_buf [i] != NULL)
            NdisFreeMemory (ctxtp -> act_buf [i],
                            ctxtp -> num_actions * ctxtp -> act_size, 0);

        /* V1.3.2b */

        if (ctxtp -> buf_array [i] != NULL)
        {
            for (j = 0; j < ctxtp -> num_packets; j ++)
            {
                bp = (PMAIN_BUFFER) (ctxtp -> buf_array [i] + j * ctxtp -> buf_size);

                if (bp -> full_bufp != NULL)
                {
                    NdisAdjustBufferLength (bp -> full_bufp,
                                            ctxtp -> buf_mac_hdr_len +
                                            ctxtp -> max_frame_size);
                    NdisFreeBuffer (bp -> full_bufp);
                }

                if (bp -> frame_bufp != NULL)
                {
                    NdisAdjustBufferLength (bp -> frame_bufp,
                                            ctxtp -> max_frame_size);
                    NdisFreeBuffer (bp -> frame_bufp);
                }
            }

            NdisFreeMemory (ctxtp -> buf_array [i],
                            ctxtp -> num_packets * ctxtp -> buf_size, 0);
        }

        if (ctxtp -> buf_pool_handle [i] != NULL)
            NdisFreeBufferPool (ctxtp -> buf_pool_handle [i]);
    }

    if (ctxtp -> frame_dscrp != NULL)
    {
        for (i = 0; i < ctxtp -> num_send_msgs; i ++)
        {
            if (ctxtp -> frame_dscrp [i] . media_hdr_bufp != NULL)
                NdisFreeBuffer (ctxtp -> frame_dscrp [i] . media_hdr_bufp);

            if (ctxtp -> frame_dscrp [i] . frame_hdr_bufp != NULL)
                NdisFreeBuffer (ctxtp -> frame_dscrp [i] . frame_hdr_bufp);

            if (ctxtp -> frame_dscrp [i] . send_data_bufp != NULL)
                NdisFreeBuffer (ctxtp -> frame_dscrp [i] . send_data_bufp);

            if (ctxtp -> frame_dscrp [i] . recv_data_bufp != NULL)
                NdisFreeBuffer (ctxtp -> frame_dscrp [i] . recv_data_bufp);
        }

        NdisFreeMemory (ctxtp -> frame_dscrp, sizeof (MAIN_FRAME_DSCR) *
                        ctxtp -> num_send_msgs, 0);
    }

    if (ctxtp -> frame_buf_pool_handle != NULL)
        NdisFreeBufferPool (ctxtp -> frame_buf_pool_handle);

    /* This packet pool is being used only for the heartbeat messages,
     * so prefer not to check the packet pool usage.
     */
    if (ctxtp -> frame_pool_handle != NULL)
        NdisFreePacketPool (ctxtp -> frame_pool_handle);

    NdisFreeSpinLock (& ctxtp -> act_lock);
    NdisFreeSpinLock (& ctxtp -> buf_lock);     /* V1.3.2b */
    NdisFreeSpinLock (& ctxtp -> recv_lock);
    NdisFreeSpinLock (& ctxtp -> send_lock);
    NdisFreeSpinLock (& ctxtp -> frame_lock);

    /* De-nitialize the DIP list structure. */
    DipListDeinitialize(&ctxtp->dip_list);

    /* Cleanup BDA teaming state. Note: this function will sleep under certain circumstances. */
    Main_teaming_cleanup(ctxtp);

    /* Stop the load module.  If it is not currently active, this is a no-op. */
    Load_stop(&ctxtp->load);

    /* Cleanup the load module before we release our context. 
       DO NOT ACQUIRE THE LOAD LOCK BEFORE CALLING THIS FUNCTION. */
    Load_cleanup(&ctxtp->load);

    NdisFreeSpinLock (& ctxtp -> load_lock);

    return;
} /* end Main_cleanup */


ULONG   Main_arp_handle (
    PMAIN_CTXT          ctxtp,
    PMAIN_PACKET_INFO   pPacketInfo,
    ULONG               send
)
{
    PUCHAR              macp;
    PARP_HDR            arp_hdrp = pPacketInfo->ARP.pHeader;

    /* V1.3.0b multicast support - ARP spoofing. use either this one or
       code in Nic_request_complete that makes TCP/IP believe that station
       current MAC address is the multicast one */

#if defined(TRACE_ARP)
    DbgPrint ("(ARP) %s\n", send ? "send" : "recv");
    DbgPrint ("    MAC type      = %x\n",  ARP_GET_MAC_TYPE (arp_hdrp));
    DbgPrint ("    prot type     = %x\n",  ARP_GET_PROT_TYPE (arp_hdrp));
    DbgPrint ("    MAC length    = %d\n",  ARP_GET_MAC_LEN (arp_hdrp));
    DbgPrint ("    prot length   = %d\n",  ARP_GET_PROT_LEN (arp_hdrp));
    DbgPrint ("    message type  = %d\n",  ARP_GET_MSG_TYPE (arp_hdrp));
    DbgPrint ("    src MAC addr  = %02x-%02x-%02x-%02x-%02x-%02x\n",
                                           ARP_GET_SRC_MAC (arp_hdrp, 0),
                                           ARP_GET_SRC_MAC (arp_hdrp, 1),
                                           ARP_GET_SRC_MAC (arp_hdrp, 2),
                                           ARP_GET_SRC_MAC (arp_hdrp, 3),
                                           ARP_GET_SRC_MAC (arp_hdrp, 4),
                                           ARP_GET_SRC_MAC (arp_hdrp, 5));
    DbgPrint ("    src prot addr = %u.%u.%u.%u\n",
                                           ARP_GET_SRC_PROT (arp_hdrp, 0),
                                           ARP_GET_SRC_PROT (arp_hdrp, 1),
                                           ARP_GET_SRC_PROT (arp_hdrp, 2),
                                           ARP_GET_SRC_PROT (arp_hdrp, 3));
    DbgPrint ("    dst MAC addr  = %02x-%02x-%02x-%02x-%02x-%02x\n",
                                           ARP_GET_DST_MAC (arp_hdrp, 0),
                                           ARP_GET_DST_MAC (arp_hdrp, 1),
                                           ARP_GET_DST_MAC (arp_hdrp, 2),
                                           ARP_GET_DST_MAC (arp_hdrp, 3),
                                           ARP_GET_DST_MAC (arp_hdrp, 4),
                                           ARP_GET_DST_MAC (arp_hdrp, 5));
    DbgPrint ("    dst prot addr = %u.%u.%u.%u\n",
                                           ARP_GET_DST_PROT (arp_hdrp, 0),
                                           ARP_GET_DST_PROT (arp_hdrp, 1),
                                           ARP_GET_DST_PROT (arp_hdrp, 2),
                                           ARP_GET_DST_PROT (arp_hdrp, 3));
#endif

    /* block sending out ARPs while we are changing IPs */

    if (send && univ_changing_ip > 0)
    {
        /* if source IP is the one we are switching to - stop blocking ARPs */

        if (ARP_GET_SRC_PROT_64(arp_hdrp) == ctxtp->cl_ip_addr) /* 64-bit -- ramkrish */
        {
            NdisAcquireSpinLock (& ctxtp -> load_lock);
            univ_changing_ip = 0;
            NdisReleaseSpinLock (& ctxtp -> load_lock);

            UNIV_PRINT_VERB(("Main_arp_handle: IP address changed - stop blocking"));
        }
        else if (ARP_GET_SRC_PROT_64(arp_hdrp) != ctxtp -> ded_ip_addr) /* 64-bit -- ramkrish */
        {
#if defined(TRACE_ARP)
            DbgPrint ("blocked due to IP switching\n");
#endif
//            ctxtp -> arps_filtered ++;
            return FALSE;
        }
    }

    if (ctxtp -> params . mcast_spoof &&
        ctxtp -> params . mcast_support &&
        ARP_GET_PROT_TYPE (arp_hdrp) == ARP_PROT_TYPE_IP &&
        ARP_GET_PROT_LEN  (arp_hdrp) == ARP_PROT_LEN_IP)
    {
        if (send)
        {
            /* if this is a cluster IP address and our dedicated MAC -
               replace dedicated MAC with cluster MAC */

            if (ARP_GET_SRC_PROT_64 (arp_hdrp) != ctxtp -> ded_ip_addr) /* 64-bit -- ramkrish */
            {
                macp = ARP_GET_SRC_MAC_PTR (arp_hdrp);

                if (CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> ded_mac_addr))
                    CVY_MAC_ADDR_COPY (ctxtp -> medium, macp, & ctxtp -> cl_mac_addr);
            }
        }
        else
        {
            /* if this is a cluster IP address and our cluster MAC -
               replace cluster MAC with dedicated MAC */

            if (ARP_GET_SRC_PROT_64 (arp_hdrp) != ctxtp -> ded_ip_addr) /* 64-bit -- ramkrish */
            {
                macp = ARP_GET_SRC_MAC_PTR (arp_hdrp);

                if (CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> cl_mac_addr))
                    CVY_MAC_ADDR_COPY (ctxtp -> medium, macp, & ctxtp -> ded_mac_addr);
            }

            if (ARP_GET_DST_PROT_64 (arp_hdrp) != ctxtp -> ded_ip_addr) /* 64-bit -- ramkrish */
            {
                macp = ARP_GET_DST_MAC_PTR (arp_hdrp);

                if (CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> cl_mac_addr))
                    CVY_MAC_ADDR_COPY (ctxtp -> medium, macp, & ctxtp -> ded_mac_addr);
            }
        }
    }

#if defined(TRACE_ARP)
    DbgPrint ("---- spoofed to -----\n");
    DbgPrint ("    src MAC addr  = %02x-%02x-%02x-%02x-%02x-%02x\n",
                                           ARP_GET_SRC_MAC (arp_hdrp, 0),
                                           ARP_GET_SRC_MAC (arp_hdrp, 1),
                                           ARP_GET_SRC_MAC (arp_hdrp, 2),
                                           ARP_GET_SRC_MAC (arp_hdrp, 3),
                                           ARP_GET_SRC_MAC (arp_hdrp, 4),
                                           ARP_GET_SRC_MAC (arp_hdrp, 5));
    DbgPrint ("    src prot addr = %u.%u.%u.%u\n",
                                           ARP_GET_SRC_PROT (arp_hdrp, 0),
                                           ARP_GET_SRC_PROT (arp_hdrp, 1),
                                           ARP_GET_SRC_PROT (arp_hdrp, 2),
                                           ARP_GET_SRC_PROT (arp_hdrp, 3));
    DbgPrint ("    dst MAC addr  = %02x-%02x-%02x-%02x-%02x-%02x\n",
                                           ARP_GET_DST_MAC (arp_hdrp, 0),
                                           ARP_GET_DST_MAC (arp_hdrp, 1),
                                           ARP_GET_DST_MAC (arp_hdrp, 2),
                                           ARP_GET_DST_MAC (arp_hdrp, 3),
                                           ARP_GET_DST_MAC (arp_hdrp, 4),
                                           ARP_GET_DST_MAC (arp_hdrp, 5));
    DbgPrint ("    dst prot addr = %u.%u.%u.%u\n",
                                           ARP_GET_DST_PROT (arp_hdrp, 0),
                                           ARP_GET_DST_PROT (arp_hdrp, 1),
                                           ARP_GET_DST_PROT (arp_hdrp, 2),
                                           ARP_GET_DST_PROT (arp_hdrp, 3));
#endif

    return TRUE;

} /* end Main_arp_handle */

/*
 * Function: Main_parse_ipsec
 * Description: This function parses UDP packets received on port 500/4500, which are IPSec
 *              control packets.  This function attempts to recognize the start of an 
 *              IPSec session - its virtual 'SYN' packet.  IPSec sessions begin with an
 *              IKE key exchange which is an IKE Main Mode Security Association.  This 
 *              function parses the IKE header and payload to identify the Main Mode
 *              SAs, which NLB will treat like TCP SYNs - all other UDP 500/4500 and IPSec 
 *              traffic is treated like TCP data packets.  The problem is that NLB 
 *              cannot necessarily tell the difference between a new Main Mode SA and
 *              a re-key of an existing Main Mode SA.  Therefore, if the client does not
 *              support intitial contact notification, then every Main Mode SA will be
 *              considered a new session, which means that sessions can potentially 
 *              break depending on how often Main Mode SAs are negotiated.  However, if
 *              the client does support initial contact notification, then the only Main 
 *              Mode SAs that will be reported as such are the initial ones (when no state 
 *              currently exists between the client and the server), which allows NLB to 
 *              distinguish the two types of Main Mode SAs, which should allow NLB to 
 *              reliably keep IPSec sessions "sticky".  IPSec notifies NLB through the 
 *              connection notification APIs to tell NLB when IPSec sessions go up and down, 
 *              allowing NLB to create and clean out descriptors for IPSec  sessions.
 * Parameters: pIKEPacket - a pointer to the IKE packet buffer (this is beyond the UDP header).
 *             ServerPort - the server UDP port on which the packet arrived.
 * Returns: BOOLEAN - TRUE if the packet is a new IPSec session, FALSE if it is not.
 * Author: shouse, 4.28.01
 */
NLB_IPSEC_PACKET_TYPE Main_parse_ipsec (PMAIN_PACKET_INFO pPacketInfo, ULONG ServerPort)
{
    /* Pointer to the IKE header. */
    PIPSEC_ISAKMP_HDR  pISAKMPHeader = (PIPSEC_ISAKMP_HDR)pPacketInfo->IP.UDP.Payload.pPayload;
    /* Pointer to the subsequent generic payloads in the IKE packet. */
    PIPSEC_GENERIC_HDR pGenericHeader;                   

    /* The length of memory contigously accessible from the IKE packet pointer. */
    ULONG              cUDPDataLength = pPacketInfo->IP.UDP.Payload.Length;

    /* The NAT delimiter - should be zero if this is really an NAT'd IKE packet. */
    UCHAR              NATEncapsulatedIPSecDelimiter[IPSEC_ISAKMP_NAT_DELIMITER_LENGTH] = IPSEC_ISAKMP_NAT_DELIMITER;

    /* The Microsoft client vendor ID - used to determine whether or not the client supports initial contact notification. */
    UCHAR              VIDMicrosoftClient[IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH] = IPSEC_VENDOR_ID_MICROSOFT;      
    /* The initial contact suport vendor ID - used to determine whether or not this client support initial contact notification. */
    UCHAR              VIDInitialContactSupport[IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH] = IPSEC_VENDOR_ID_INITIAL_CONTACT_SUPPORT;
    /* The initial contact vendor ID - used to determine whether or not this is an initial contact MMSA. */
    UCHAR              VIDInitialContact[IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH] = IPSEC_VENDOR_ID_INITIAL_CONTACT;

    /* Whether or not we've determined the client to be compatible. */
    BOOLEAN            bInitialContactEnabled = FALSE;
    /* Whether or not this is indeed an initial contact. */
    BOOLEAN            bInitialContact = FALSE;

    /* The length of the IKE packet. */            
    ULONG              cISAKMPPacketLength;
    /* The next payload code in the IKE payload chain. */  
    UCHAR              NextPayload;        

    TRACE_PACKET("%!FUNC! Sniffing IKE header %p, len=%u", pISAKMPHeader, cUDPDataLength);

    /* The UDP data should be at least as long as the initiator cookie.  If the packet is 
       UDP encapsulated IPSec, then the I cookie will be 0 to indicate such. */
    if (cUDPDataLength < IPSEC_ISAKMP_NAT_DELIMITER_LENGTH) {
        TRACE_PACKET("%!FUNC! Malformed UDP data: UDP data length = %u", cUDPDataLength);
        return NLB_IPSEC_OTHER;
    }

    /* If the UDP data length is non-zero, then the UDP payload pointer had BETTER be non-NULL. */
    UNIV_ASSERT(pISAKMPHeader);

    /* If this packet arrived on the IPSec NAT port (4500), it may or may not be IKE.  Check
       the delimiter at the first four bytes of the payload to see whether or not its IKE. If
       the packet arrived on the IPSec control port (500), then this packet MUST be IKE. */
    if (ServerPort == IPSEC_NAT_PORT) {
        /* Need to check the NAT delimiter, which will distinguish clients behind a NAT, 
           which also send their IPSec (ESP) traffic to UDP port 4500.  If the delimiter
           is non-zero, then this is NOT an IKE packet, so we return OTHER. */
        if (!NdisEqualMemory((PVOID)pISAKMPHeader, (PVOID)&NATEncapsulatedIPSecDelimiter[0], sizeof(UCHAR) * IPSEC_ISAKMP_NAT_DELIMITER_LENGTH)) {
            TRACE_PACKET("%!FUNC! This packet is UDP encapsulated IPSec traffic, not an IKE packet");
            return NLB_IPSEC_OTHER;
        }

        /* If this IS encapsulated IKE, then advance the IKISAKMP header pointer by the length of the 
           delimiter and adjust the UDP data length. */
        pISAKMPHeader = (PIPSEC_ISAKMP_HDR)((PUCHAR)pISAKMPHeader + IPSEC_ISAKMP_NAT_DELIMITER_LENGTH);
        cUDPDataLength -= IPSEC_ISAKMP_NAT_DELIMITER_LENGTH;
    }

    /* At this point, this packet should be IKE, so the UDP data should be at least 
       as long as an ISAKMP header. */
    if (cUDPDataLength < IPSEC_ISAKMP_HEADER_LENGTH) {
        TRACE_PACKET("%!FUNC! Malformed ISAKMP header: UDP data length = %u", cUDPDataLength);
        return NLB_IPSEC_OTHER;
    }

    /* Get the total length of the IKE packet from the ISAKMP header. */
    cISAKMPPacketLength = IPSEC_ISAKMP_GET_PACKET_LENGTH(pISAKMPHeader);

    /* Sanity check - the UDP data length and IKE packet length SHOULD be the same, unless the packet 
       is fragmented.  If it is, then we can only look into the packet as far as the UDP data length. 
       If that's not far enough for us to find what we need, then we might miss an initial contact 
       main mode SA; the consequence of which is that we might not accept this connection if we are
       in non-optimized mode, because we'll treat this like data, which requires a descriptor lookup -
       if this is an initial contact, chances are great that no descriptor will exist and all hosts 
       in the cluster will drop the packet.  Or, we may end up deciding that this is an IPSec SYN 
       because we were not able to verify the vendor ID or notify payloads.  In this case, the client
       is basically treated like a legacy client. */
    if (cUDPDataLength < cISAKMPPacketLength)
        /* Only look as far as the end of the UDP packet. */
        cISAKMPPacketLength = cUDPDataLength;

    /* The IKE packet should be at least as long as an ISAKMP header (a whole lot longer, actually). */
    if (cISAKMPPacketLength < IPSEC_ISAKMP_HEADER_LENGTH) {
        TRACE_PACKET("%!FUNC! Malformed ISAKMP header: ISAKMP Packet length = %u", cISAKMPPacketLength);
        return NLB_IPSEC_OTHER;
    }

    /* Get the first payload type out of the ISAKMP header. */
    NextPayload = IPSEC_ISAKMP_GET_NEXT_PAYLOAD(pISAKMPHeader);

    /* IKE security associations are identified by a payload type byte in the header.
       Check that first - this does not ensure that this is what we are looking for 
       because this check will not exclude, for instance, main mode re-keys. */
    if (NextPayload != IPSEC_ISAKMP_SA) {
        /* If this is a NAT encapsulated IKE ID packet, we have to handle this specially, as we MAY
           NOT yet have the correct descriptor to track this session.  In most (*) cases of IPSec/L2TP 
           behind a NAT, the negotiation starts across UDP 500 and then switches to UDP 4500 on the 
           IKE ID packet.  Because our state is tracking UDP 500, we might not correctly handle this
           packet.  Therefore, special case this packet and pass it up on all "appropriate" (**) hosts
           in the cluster, at which point we will be notified by IPSec to change our session tracking
           state to the UDP 4500 and the new ephemeral source port.  From that point on, we can correctly
           track the rest of the session.

           (*) In some cases, the negotiation may start on UDP 4500, in which case there is no transition
           in UDP ports, and NLB has the correct session tracking state from the get go.

           (**) The appropriate hosts are (i) the current bucket owner, and (ii) any hosts that currently
           have IPSec sessions with the same client IP address.  Because we require single affinity for
           IPSec/L2TP, normally this is just one host; if a change in cluster membership occurs, it can
           be 2 hosts, but will rarely be more than that. */
        if ((ServerPort == IPSEC_NAT_PORT) && (NextPayload == IPSEC_ISAKMP_ID)) {
            TRACE_PACKET("%!FUNC! NAT encapsulated IKE ID: Payload=%u", NextPayload);
            return NLB_IPSEC_IDENTIFICATION;
        }

        TRACE_PACKET("%!FUNC! Not a Main Mode Security Association: Payload=%u", NextPayload);
        return NLB_IPSEC_OTHER;
    } 

    /* Calculate a pointer to the fist generic payload, which is directly after the ISAKMP header. */
    pGenericHeader = (PIPSEC_GENERIC_HDR)((PUCHAR)pISAKMPHeader + IPSEC_ISAKMP_HEADER_LENGTH);

    /* Decrement the remaining packet length by the length of the ISAKMP header. */
    cISAKMPPacketLength -= IPSEC_ISAKMP_HEADER_LENGTH;

    /* We are looping through the generic payloads looking for the vendor ID and/or notify information. */
    while (cISAKMPPacketLength > IPSEC_GENERIC_HEADER_LENGTH) {
        /* Extract the payload length from the generic header. */
        USHORT cPayloadLength = IPSEC_GENERIC_GET_PAYLOAD_LENGTH(pGenericHeader);

        /* The payload length must be AT LEAST as long as a generic header.  If its 
           not, then this packet may have been tampered with - bail out. */
        if (cPayloadLength < IPSEC_GENERIC_HEADER_LENGTH) {
            TRACE_PACKET("%!FUNC! Malformed generic header: Payload length = %d", cPayloadLength);
            return NLB_IPSEC_OTHER;
        }

        /* If the length of the next payload is longer than the remaining buffer we have
           available to read, then either (i) the packet is malformed, (ii) the rest of 
           the packet is in another NDIS_BUFFER attached to the packet, or (iii) the packet
           was fragmented and we've gone as far as we can.  If any of these is the case, 
           bail out now and make a decision based on the information we were able to gather
           from the packet thusfar. */
        if (cISAKMPPacketLength < cPayloadLength) {
            TRACE_PACKET("%!FUNC! Missing some necessary IKE packet information: Assuming this is an IPSec SYN");
            goto exit;
        }

        /* Not all clients are going to support this (in fact, only the Microsoft client
           will support it, so we need to first see what the vendor ID of the client is.
           if it is a Microsoft client that supports the initial contact vendor ID, then
           we'll look for the initial contact, which provides better stickiness for IPSec
           connections.  If either the client is non-MS, or if it is not a version that
           supports initial contact, then we can revert to the "second-best" solution, 
           which is to provide stickiness _between_ Main Mode SAs.  This means that if a
           client re-keys their Main Mode session, they _may_ be rebalanced to another
           server.  This is still better than the old UDP implementation, but the only
           way to provide full session support for IPSec (without the distributed session
           table nightmare) is to be able to distinguish initial Main Mode SAs from sub-
           sequent Main Mode SAs (re-keys). */
        if (NextPayload == IPSEC_ISAKMP_VENDOR_ID) {
            PIPSEC_VENDOR_HDR pVendorHeader = (PIPSEC_VENDOR_HDR)pGenericHeader;

            /* Make sure that the vendor ID payload is at least as long as a vendor ID. */
            if (cPayloadLength < (IPSEC_GENERIC_HEADER_LENGTH + IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH)) {
                TRACE_PACKET("%!FUNC! Malformed vendor ID header: Payload length = %d", cPayloadLength);
                return NLB_IPSEC_OTHER;
            }

            /* Look for the Microsoft client vendor ID.  If it is the right version, then we know that 
               the client is going to appropriately set the initial contact information, allowing NLB
               to provide the best possible support for session stickiness. */
            if (NdisEqualMemory((PVOID)IPSEC_VENDOR_ID_GET_ID_POINTER(pVendorHeader), (PVOID)&VIDMicrosoftClient[0], sizeof(UCHAR) * IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH)) {
                /* Make sure that their is a version number attached to the Microsoft Vendor ID.  Not 
                   all vendor IDs have versions attached, but the Microsoft vendor ID should. */
                if (cPayloadLength < (IPSEC_GENERIC_HEADER_LENGTH + IPSEC_VENDOR_ID_PAYLOAD_LENGTH)) {
                    TRACE_PACKET("%!FUNC! Unable to determine MS client version: Payload length = %d", cPayloadLength);
                    return NLB_IPSEC_OTHER;
                }

                if (IPSEC_VENDOR_ID_GET_VERSION(pVendorHeader) >= IPSEC_VENDOR_ID_MICROSOFT_MIN_VERSION) {
                    /* Microsoft clients whose version is greater than or equal to 4 will support
                       initial contact.  Non-MS clients, or old MS clients will not, so they 
                       receive decent, but not guaranteed sitckines, based solely on MM SAs. */
                    bInitialContactEnabled = TRUE;
                }
            }
            /* Look for the initial contact supported vendor ID.  If we find it, then we know that 
               the client is going to appropriately set the initial contact information, allowing NLB
               to provide the best possible support for session stickiness. */
            else if (NdisEqualMemory((PVOID)IPSEC_VENDOR_ID_GET_ID_POINTER(pVendorHeader), (PVOID)&VIDInitialContactSupport[0], sizeof(UCHAR) * IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH)) {
                /* This client supports initial contact, which tells NLB that the inclusion or exclusion
                   of initial contact information is meaningful.  Those clients that do not support initial
                   contact will receive decent, but not guaranteed sitckines, based solely on MM SAs. */
                bInitialContactEnabled = TRUE;
            }
            /* Look for the initial contact vendor ID.  If the initial contact vendor ID is present,
               then this MMSA is a SYN-equivalent.  For backward-compatability reasons, we will also
               support this notification through the ISAKMP_NOTIFY payload, although it violates an
               RFC, as the INITIAL_CONTACT in the ISAKMP_NOTIFY payload MUST be secured by a security
               association and can therefore NOT be presented in the Security Association packet. */
            else if (NdisEqualMemory((PVOID)IPSEC_VENDOR_ID_GET_ID_POINTER(pVendorHeader), (PVOID)&VIDInitialContact[0], sizeof(UCHAR) * IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH)) {
                /* This is an initial contact notification from the client, which means that this is
                   the first time that the client has contacted this server; more precisely, the client
                   currently has no state associated with this peer.  NLB will "re-balance" on initial 
                   contact notifications, but not other Main Mode key exchanges as long as it can 
                   determine that the client will comply with initial contact notification. */
                bInitialContact = TRUE;
            }

        /* Using the ISAKMP_NOTIFY payload to relay the INITIAL_CONTACT information CANNOT be done in
           the Security Association packet, as it violates an RFC (this information MUST be secured by
           a security association and can therefore NOT be transported in the first packet of a negotiation. 
           We will continue to support it for legacy reasons, but note that Version 4 Microsoft clients
           will NOT use this method, but rather will insert an INITIAL_CONTACT vendor ID to notify NLB
           that this is an INITIAL_CONTACT Main Mode Security Association. */
        } else if (NextPayload == IPSEC_ISAKMP_NOTIFY) {
            PIPSEC_NOTIFY_HDR pNotifyHeader = (PIPSEC_NOTIFY_HDR)pGenericHeader;

            /* Make sure that the notify payload is the correct length. */
            if (cPayloadLength < (IPSEC_GENERIC_HEADER_LENGTH + IPSEC_NOTIFY_PAYLOAD_LENGTH)) {
                TRACE_PACKET("%!FUNC! Malformed notify header: Payload length = %d", cPayloadLength);
                return NLB_IPSEC_OTHER;
            }

            if (IPSEC_NOTIFY_GET_NOTIFY_MESSAGE(pNotifyHeader) == IPSEC_NOTIFY_INITIAL_CONTACT) {
                /* This is an initial contact notification from the client, which means that this is
                   the first time that the client has contacted this server; more precisely, the client
                   currently has no state associated with this peer.  NLB will "re-balance" on initial 
                   contact notifications, but not other Main Mode key exchanges as long as it can 
                   determine that the client will comply with initial contact notification. */
                bInitialContact = TRUE;
            }
        }

        /* Get the next payload type out of the generic header. */
        NextPayload = IPSEC_GENERIC_GET_NEXT_PAYLOAD(pGenericHeader);

        /* Calculate a pointer to the next generic payload. */
        pGenericHeader = (PIPSEC_GENERIC_HDR)((PUCHAR)pGenericHeader + cPayloadLength);
        
        /* Decrement the remaining packet length by the length of this payload. */
        cISAKMPPacketLength -= cPayloadLength;
    }

 exit:

    /* If the vendor ID / Notify did not indicate that this client supports initial contact notification,
       then return INITIAL_CONTACT, and we go with the less-than-optimal solution of treating Main Mode 
       SAs as the connection boundaries, which potentially breaks sessions on MM SA re-keys. */
    if (!bInitialContactEnabled) {
        TRACE_PACKET("%!FUNC! This client does not support initial contact notifications.");
        return NLB_IPSEC_INITIAL_CONTACT;
    }

    /* If this was a Main Mode SA from a client that supports initial contact, but did not specify
       the initial contact vendor ID / Notify, then this is a re-key for an existing session. */
    if (!bInitialContact) {
        TRACE_PACKET("%!FUNC! Not an initial contact Main Mode Security Association.");
        return NLB_IPSEC_OTHER;
    }

    TRACE_PACKET("%!FUNC! Found an initial contact Main Mode Security Association.");

    return NLB_IPSEC_INITIAL_CONTACT;
}

/*
 * Function: Main_ip_send_filter
 * Description: This function filters outgoing IP traffic, often by querying the load
 *              module for load-balancing decisions.  Packets addressed to the dedicated
 *              address are always allowed to pass, as are protocols that are not
 *              specifically filtered by NLB.  Generally, all outgoing traffic is allowed
 *              to pass.
 * Parameters: ctxtp - a pointer to the NLB main context structure for this adapter.
 *             pPacketInfo - a pointer to the MAIN_PACKET_INFO structure parsed by Main_send_frame_parse
 *                           which contains pointers to the IP and TCP/UDP headers.
#if defined (NLB_HOOK_ENABLE)
 *             filter - the filtering directive returned by the filtering hook, if registered.
#endif
 * Returns: BOOLEAN - if TRUE, accept the packet, otherwise, reject it.
 * Author: kyrilf, shouse 3.4.02
 * Notes: 
 */
BOOLEAN   Main_ip_send_filter (
    PMAIN_CTXT                ctxtp,
#if defined (NLB_HOOK_ENABLE)
    PMAIN_PACKET_INFO         pPacketInfo,
    NLB_FILTER_HOOK_DIRECTIVE filter
#else
    PMAIN_PACKET_INFO         pPacketInfo
#endif
    )
{
    PIP_HDR             ip_hdrp = NULL;
    PUDP_HDR            udp_hdrp = NULL;
    PTCP_HDR            tcp_hdrp = NULL;
    BOOLEAN             acpt = TRUE;       // Whether or not to accept the packet.
    ULONG               svr_port;          // Port for this host.
    ULONG               svr_addr;          // IP address for this host.
    ULONG               clt_port;          // Port for destination client.
    ULONG               clt_addr;          // IP address for destination client.
    ULONG               flags;             // TCP flags.
    ULONG               Protocol;          // Protocol derived from IP header.

    TRACE_PACKET("%!FUNC! Enter: ctxtp = %p", ctxtp);

#if defined (NLB_HOOK_ENABLE)
    /* These cases should be taken care of outside of this function. */
    UNIV_ASSERT(filter != NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY);
    UNIV_ASSERT(filter != NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY);
#endif

    ip_hdrp = pPacketInfo->IP.pHeader;

    TRACE_PACKET("%!FUNC! IP source address = %u.%u.%u.%u, IP destination address = %u.%u.%u.%u, Protocol = %u\n",
                 IP_GET_SRC_ADDR (ip_hdrp, 0),
                 IP_GET_SRC_ADDR (ip_hdrp, 1),
                 IP_GET_SRC_ADDR (ip_hdrp, 2),
                 IP_GET_SRC_ADDR (ip_hdrp, 3),
                 IP_GET_DST_ADDR (ip_hdrp, 0),
                 IP_GET_DST_ADDR (ip_hdrp, 1),
                 IP_GET_DST_ADDR (ip_hdrp, 2),
                 IP_GET_DST_ADDR (ip_hdrp, 3),
                 IP_GET_PROT (ip_hdrp));

    if (((IP_GET_FRAG_FLGS(ip_hdrp) & 0x1) != 0) || (IP_GET_FRAG_OFF(ip_hdrp) != 0)) {
        TRACE_PACKET("%!FUNC! Fragmented datagram, ID = %u, flags = 0x%x, offset = %u",
                     IP_GET_FRAG_ID(ip_hdrp),
                     IP_GET_FRAG_FLGS(ip_hdrp),
                     IP_GET_FRAG_OFF(ip_hdrp));
    }

    if (pPacketInfo->IP.bFragment) {

        TRACE_FILTER("%!FUNC! Accept packet - allow fragmented packets to pass");

        /* Always let fragmented packets go out. */
        acpt = TRUE;
        goto exit;
    }

    /* Server address is the source IP and client address is the destination IP. */
    svr_addr = IP_GET_SRC_ADDR_64 (ip_hdrp);
    clt_addr = IP_GET_DST_ADDR_64 (ip_hdrp);

    /* Get the IP protocol form the IP header. */
    Protocol = pPacketInfo->IP.Protocol;

    /* Packets directed to the dedicated IP address are always passed through.  If the 
       cluster IP address hasn't been set (parameter error), then fall into a pass-
       through mode and pass all traffic up to the upper-layer protocols. */
    if (svr_addr == ctxtp -> ded_ip_addr || ctxtp -> cl_ip_addr == 0)
    {
        TRACE_FILTER("%!FUNC! Accept packet - allow packets directed to the DIP to pass (or we're in passthru mode)");
        
        acpt = TRUE;
        goto exit;
    }

    switch (Protocol)
    {
    case TCPIP_PROTOCOL_TCP:
        
        tcp_hdrp = pPacketInfo->IP.TCP.pHeader;
        
        TRACE_PACKET("%!FUNC! TCP Source port = %u, Destination port = %u, Sequence number = %u, ACK number = %u, Flags = 0x%x",
                     TCP_GET_SRC_PORT (tcp_hdrp),
                     TCP_GET_DST_PORT (tcp_hdrp),
                     TCP_GET_SEQ_NO (tcp_hdrp),
                     TCP_GET_ACK_NO (tcp_hdrp),
                     TCP_GET_FLAGS (tcp_hdrp));
        
        svr_port = TCP_GET_SRC_PORT (tcp_hdrp);
        clt_port = TCP_GET_DST_PORT (tcp_hdrp);
        
        UNIV_ASSERT(!pPacketInfo->IP.bFragment);
        
        /* Apply filtering algorithm. process connection boundaries different from regular packets. */
        
        /* Get the TCP flags to find out the packet type. */
        flags = TCP_GET_FLAGS (tcp_hdrp);
        
        if (flags & TCP_FLAG_SYN)
        {
            TRACE_PACKET("%!FUNC! Outgoing SYN");

            TRACE_FILTER("%!FUNC! Accept packet - TCP SYNs always permitted to pass");
        } 
        else if (flags & TCP_FLAG_FIN)
        {
            TRACE_PACKET("%!FUNC! Outgoing FIN");

            TRACE_FILTER("%!FUNC! Accept packet - TCP FINs always permitted to pass");
        }
        else if (flags & TCP_FLAG_RST)
        {
            TRACE_PACKET("%!FUNC! Outgoing RST");

#if defined (NLB_TCP_NOTIFICATION)
            /* If TCP notifications are NOT turned on, then we need to pay attention to outgoing
               RSTs and destroy our connection state.  If notifications ARE on, then there is no
               need; allow the packet to pass and clean up when TCP tells us to. */
            if (!NLB_NOTIFICATIONS_ON())
            {
#endif
                /* In the case of an outgoing RST, we always want to allow the packet to pass, 
                   so we ignore the return value, which is the response from the load module. */
#if defined (NLB_HOOK_ENABLE)
                Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_RESET, filter);
#else
                Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_RESET);
#endif
#if defined (NLB_TCP_NOTIFICATION)
            }
#endif

            /* Count the number of outgoing resets we've seen. */
            if (acpt) ctxtp->cntr_xmit_tcp_resets++;
        }
        else
        {
            TRACE_PACKET("%!FUNC! Outgoing data");

            TRACE_FILTER("%!FUNC! Accept packet - TCP data always permitted to pass");
        }

        break;

    case TCPIP_PROTOCOL_UDP:

        udp_hdrp = pPacketInfo->IP.UDP.pHeader;

        TRACE_PACKET("%!FUNC! UDP Source port = %u, Destinoation port = %u",  
                     UDP_GET_SRC_PORT (udp_hdrp),
                     UDP_GET_DST_PORT (udp_hdrp));

        TRACE_FILTER("%!FUNC! Accept packet - UDP traffic always allowed to pass");

        break;

    case TCPIP_PROTOCOL_GRE:

        TRACE_FILTER("%!FUNC! Accept packet - GRE traffic always allowed to pass");
        
        /* PPTP packets are treated like TCP data, which are always allowed to pass. */

        break;

    case TCPIP_PROTOCOL_IPSEC1:
    case TCPIP_PROTOCOL_IPSEC2:

        TRACE_FILTER("%!FUNC! Accept packet - IPSec traffic always allowed to pass");

        /* IPSec packets are treated kind of like TCP data, which are always allowed to pass. */

        break;

    case TCPIP_PROTOCOL_ICMP:

        TRACE_FILTER("%!FUNC! Accept packet - ICMP traffic always allowed to pass");

        /* Allow all outgoing ICMP to pass; incoming ICMP may be filtered, however. */

        break;

    default:

        TRACE_FILTER("%!FUNC! Accept packet - Unknown protocol traffic always allowed to pass");

        /* Allow other protocols to go out on all hosts. */

        break;
    }

 exit:

    TRACE_PACKET("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
} 

/*
 * Function: Main_get_full_payload
 * Description: 
 * Parameters: ctxtp - a pointer to the NLB main context structure for this adapter.
 *             pBuffer - a pointer to the NDIS buffer in which the beginning of the payload is located.
 *             BufferLength - the length of the payload (in bytes) contained in pBuffer.
 *             pPayload - a pointer to the payload, which resides in pBuffer.
 *             ppMem - a pointer to a PUCHAR to hold the address of the new buffer, if one is allocated.
 *             pMemLength - a pointer to a ULONG to hold the length of the memory buffer allocated.
 * Returns: BOOLEAN - if TRUE, the full payload is present; if FALSE, it is not
 * Author: kyrilf, shouse 4.20.02
 * Notes: If ppMem is non-NULL upon exiting this function, the caller is responsible for freeing that memory.
 */
BOOLEAN Main_get_full_payload (
    PMAIN_CTXT   ctxtp, 
    PNDIS_BUFFER pBuffer,
    ULONG        BufferLength,
    PUCHAR       pPayload,
    OUT PUCHAR * ppMem, 
    OUT PULONG   pMemLength)
{
    PNDIS_BUFFER pNDISBuffer = pBuffer;
    ULONG        AllocateLength = BufferLength;
    NDIS_STATUS  Status = NDIS_STATUS_SUCCESS;
    PUCHAR       pAllocate = NULL;
    PUCHAR       pVMem = NULL;
    ULONG        Length = 0;
    ULONG        Copied = 0;

    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);
    
    /* Initialize the OUT params. */
    *ppMem = NULL;
    *pMemLength = 0;

    /* If we don't have enough information to retrieve the entire packet payload, 
       then simply return failure. */
    if ((pBuffer == NULL) || (pPayload == NULL) || (BufferLength == 0))
        return FALSE;

    while (pNDISBuffer != NULL) 
    {    
        /* Get the next buffer in the chain. */
        NdisGetNextBuffer(pNDISBuffer, &pNDISBuffer);
                        
        /* If there are no buffers left, bail out. */
        if (pNDISBuffer == NULL) break;
        
        /* Query the buffer for the virtual address of the buffer and its length. */
        NdisQueryBufferSafe(pNDISBuffer, &pVMem, &Length, NormalPagePriority);
        
        /* If querying the buffer fails, resources are low, bail out. */
        if (pVMem == NULL) return FALSE;

        /* Remember how many bytes we've encountered thusfar. */
        AllocateLength += Length;      
    }
    
    /* If the buffer we were passed in already contains everything there 
       is to be had, then return TRUE to indicate that the entire payload
       has successfully been extracted from the NDIS buffer chain. */
    if (AllocateLength == BufferLength)
        return TRUE;

    /* Allocate the new buffer. */
    Status = NdisAllocateMemoryWithTag(&pAllocate, AllocateLength, UNIV_POOL_TAG);
                
    /* If we could not successfully allocate the memory to hold the payload, bail out. */
    if (Status != NDIS_STATUS_SUCCESS) 
    {
        UNIV_PRINT_CRIT(("Main_get_full_payload: Could not allocate memory to hold entire payload, status=0x%08x", Status));
        TRACE_CRIT("%!FUNC! Could not allocate memory to hold entire payload, status=0x%08x", Status);
        return FALSE;
    } 

    /* Re-set the NDIS_BUFFER pointer to the payload buffer. */
    pNDISBuffer = pBuffer;

    /* Re-set pVMem, which is the source for copying, to the payload pointer
       and the length to the length of the payload buffer. */
    pVMem = pPayload;
    Length = BufferLength;

    while (pNDISBuffer != NULL) {
        /* Copy this chunk of NDIS_BUFFER into the new buffer. */
        RtlCopyMemory(pAllocate + Copied, pVMem, Length);
        
        /* Remember how many bytes we've copied in to the new buffer so far. */
        Copied += Length;
        
        /* Get the next buffer in the chain. */
        NdisGetNextBuffer(pNDISBuffer, &pNDISBuffer);
        
        /* If there are no buffers left, bail out. */
        if (pNDISBuffer == NULL) break;
        
        /* Query the buffer for the virtual address of the buffer and its length. */
        NdisQueryBufferSafe(pNDISBuffer, &pVMem, &Length, NormalPagePriority);
        
        /* If querying the buffer fails, resources are low, bail out. */
        if (pVMem == NULL) break;
    }
    
    /* We have succeeded at copying all payload bytes into the new buffer. */
    if (Copied == AllocateLength) 
    {
        /* Copy the new buffer pointer and its length into the OUT params. 
           The caller of this function is responsible for freeing this memory. */
        *ppMem = pAllocate;
        *pMemLength = AllocateLength;

        return TRUE;
    }
    /* Failure to copy all bytes necessary. */
    else 
    {
        UNIV_PRINT_CRIT(("Main_get_full_payload: Unable to copy entire payload"));
        TRACE_CRIT("%!FUNC! Unable to copy entire payload");

        /* Free the buffer memory. */
        NdisFreeMemory(pAllocate, AllocateLength, 0);

        return FALSE;
    }
}

/*
 * Function: Main_ip_recv_filter
 * Description: This function filters incoming IP traffic, often by querying the load
 *              module for load-balancing decisions.  Packets addressed to the dedicated
 *              address are always allowed to pass, as are protocols that are not
 *              specifically filtered by NLB.  
 * Parameters: ctxtp - a pointer to the NLB main context structure for this adapter.
 *             pPacketInfo - a pointer to the MAIN_PACKET_INFO structure parsed by Main_recv_frame_parse
 *                           which contains pointers to the IP and TCP/UDP headers.
#if defined (NLB_HOOK_ENABLE)
 *             filter - the filtering directive returned by the filtering hook, if registered.
#endif
 * Returns: BOOLEAN - if TRUE, accept the packet, otherwise, reject it.
 * Author: kyrilf, shouse 3.4.02
 * Notes: 
 */
BOOLEAN   Main_ip_recv_filter(
    PMAIN_CTXT                ctxtp,
#if defined (NLB_HOOK_ENABLE)
    PMAIN_PACKET_INFO         pPacketInfo,
    NLB_FILTER_HOOK_DIRECTIVE filter
#else
    PMAIN_PACKET_INFO         pPacketInfo
#endif
    )
{
    PIP_HDR             ip_hdrp = NULL;
    PUDP_HDR            udp_hdrp = NULL;
    PTCP_HDR            tcp_hdrp = NULL;
    BOOLEAN             acpt = TRUE;         // Whether or not to accept the packet.
    ULONG               svr_port;            // Port for this host.
    ULONG               svr_addr;            // IP address for this host.
    ULONG               clt_port;            // Port for destination client.
    ULONG               clt_addr;            // IP address for destination client.
    ULONG               flags;               // TCP flags.
#if defined (OPTIMIZE_FRAGMENTS)
    BOOLEAN             fragmented = FALSE;
#endif
    ULONG               Protocol;            // Protocol derived from IP header.

    TRACE_PACKET("%!FUNC! Enter: ctxtp = %p", ctxtp);

#if defined (NLB_HOOK_ENABLE)
    /* These cases should be taken care of outside of this function. */
    UNIV_ASSERT(filter != NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY);
    UNIV_ASSERT(filter != NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY);
#endif
    
    ip_hdrp = pPacketInfo->IP.pHeader;

    TRACE_PACKET("%!FUNC! IP source address = %u.%u.%u.%u, IP destination address = %u.%u.%u.%u, Protocol = %u\n",
                 IP_GET_SRC_ADDR (ip_hdrp, 0),
                 IP_GET_SRC_ADDR (ip_hdrp, 1),
                 IP_GET_SRC_ADDR (ip_hdrp, 2),
                 IP_GET_SRC_ADDR (ip_hdrp, 3),
                 IP_GET_DST_ADDR (ip_hdrp, 0),
                 IP_GET_DST_ADDR (ip_hdrp, 1),
                 IP_GET_DST_ADDR (ip_hdrp, 2),
                 IP_GET_DST_ADDR (ip_hdrp, 3),
                 IP_GET_PROT (ip_hdrp));

    if (((IP_GET_FRAG_FLGS(ip_hdrp) & 0x1) != 0) || (IP_GET_FRAG_OFF(ip_hdrp) != 0)) {
        TRACE_PACKET("%!FUNC! Fragmented datagram, ID = %u, flags = 0x%x, offset = %u",
                     IP_GET_FRAG_ID(ip_hdrp),
                     IP_GET_FRAG_FLGS(ip_hdrp),
                     IP_GET_FRAG_OFF(ip_hdrp));
    }


#if 0 /* Disable fragment flooding. */

    if (pPacketInfo->IP.bFragment)
    {
#if defined (OPTIMIZE_FRAGMENTS)
        /* In optimized-fragment mode; If we have no rules, or a single rule that will
           not look at anything or only source IP address (the only exception to this
           is multiple handling mode with no affinity that also uses source port for
           its decision making), then we can just rely on normal mechanism to handle
           every fragmented packet, since the algorithm will not attempt to look past 
           the IP header.

           For multiple rules, or single rule with no affinity, apply algorithm only
           to the first packet that has UDP/TCP header and then let fragmented packets
           up on all of the systems.  TCP will then do the right thing and throw away
           the fragments on all of the systems other than the one that handled the first 
           fragment.

           If port rules will not let us handle IP fragments reliably, let TCP filter 
           them out based on sequence numbers. */
        if (! ctxtp -> optimized_frags)
        {
            TRACE_FILTER("%!FUNC! Accept packet - allow fragmented packets to pass");

            acpt = TRUE;
            goto exit;
        }
        
        fragmented = TRUE;
#else
        TRACE_FILTER("%!FUNC! Accept packet - allow fragmented packets to pass");

        acpt = TRUE;
        goto exit;
#endif
    }

#endif /* Disable fragment flooding. */

    /* Server address is the destination IP and client address is the source IP. */
    svr_addr = IP_GET_DST_ADDR_64(ip_hdrp);
    clt_addr = IP_GET_SRC_ADDR_64(ip_hdrp);

    /* Get the protocol ID from the IP header. */
    Protocol = pPacketInfo->IP.Protocol;

    /* Packets directed to the dedicated IP address are always passed through.  If the 
       cluster IP address hasn't been set (parameter error), then fall into a pass-
       through mode and pass all traffic up to the upper-layer protocols. */
    if (svr_addr == ctxtp -> ded_ip_addr || ctxtp -> cl_ip_addr == 0 ||
        svr_addr == ctxtp -> ded_bcast_addr || svr_addr == ctxtp -> cl_bcast_addr)
    {
        TRACE_FILTER("%!FUNC! Accept packet - allow packets directed to the DIP to pass (or we're in passthru mode)");
        
        acpt = TRUE;
        goto exit;
    }

    /* Before we load-balance this packet, check to see whether or not its destined for
       the dedicated IP address of another NLB host in our cluster.  If it is, drop it. */
    if (DipListCheckItem(&ctxtp->dip_list, svr_addr))
    {
        TRACE_FILTER("%!FUNC! Drop packet - packet is destined for the DIP of another cluster host");
        
        acpt = FALSE;
        goto exit;
    }

    /* If the load module is stopped, drop most packets. */
    if (! ctxtp -> convoy_enabled)
    {
        /* Drop TCP, UDP, GRE and IPSEC immediately.  Other protocols will be allowed to pass. */
        if (Protocol == TCPIP_PROTOCOL_TCP || 
            Protocol == TCPIP_PROTOCOL_UDP || 
            Protocol == TCPIP_PROTOCOL_GRE ||
            Protocol == TCPIP_PROTOCOL_IPSEC1 || 
            Protocol == TCPIP_PROTOCOL_IPSEC2)
        {
            TRACE_FILTER("%!FUNC! Drop packet - block non-remote control traffic when NLB is stopped");

            acpt = FALSE;
            goto exit;
        }
    }
    
    switch (Protocol)
    {
    case TCPIP_PROTOCOL_TCP:

        /* If we have a TCP subsequent fragment, treat it as a TCP data packet with Source Port = 80,
           Destination Port = 80. It will be accepted if this host has the hash bucket or if it has a
           matching connection descriptor. 
           This is really a best-effort implementation. It is quite possible that we may be indicating the 
           packet up on the wrong host if the actual port tuple is not 80/80. We could very well have 
           chosen 0/0 as the "assumed" port tuple. Instead, we chose 80/80 since NLB is most commonly 
           used for web traffic.
        */
        if (pPacketInfo->IP.bFragment)
        {
#if defined (NLB_HOOK_ENABLE)
            acpt = Main_packet_check(ctxtp, svr_addr, TCP_HTTP_PORT, clt_addr, TCP_HTTP_PORT, TCPIP_PROTOCOL_TCP, filter);
#else
            acpt = Main_packet_check(ctxtp, svr_addr, TCP_HTTP_PORT, clt_addr, TCP_HTTP_PORT, TCPIP_PROTOCOL_TCP);
#endif
            
            break;
        }

        tcp_hdrp = pPacketInfo->IP.TCP.pHeader;

#if defined (OPTIMIZE_FRAGMENTS)
        if (! fragmented)
        {
#endif
            TRACE_PACKET("%!FUNC! TCP Source port = %u, Destination port = %u, Sequence number = %u, ACK number = %u, Flags = 0x%x",
                         TCP_GET_SRC_PORT (tcp_hdrp),
                         TCP_GET_DST_PORT (tcp_hdrp),
                         TCP_GET_SEQ_NO (tcp_hdrp),
                         TCP_GET_ACK_NO (tcp_hdrp),
                         TCP_GET_FLAGS (tcp_hdrp));            

            clt_port = TCP_GET_SRC_PORT (tcp_hdrp);
            svr_port = TCP_GET_DST_PORT (tcp_hdrp);

            flags = TCP_GET_FLAGS (tcp_hdrp);

#if defined (OPTIMIZE_FRAGMENTS)
        }
        else
        {
            clt_port = 0;
            svr_port = 0;
            flags = 0;
        }
#endif

        /* Apply filtering algorithm.  Process connection boundaries different from regular packets. */

        if (flags & TCP_FLAG_SYN)
        {
            TRACE_PACKET("%!FUNC! Incoming SYN");
            
            /* Make sure the SYN/FIN/RST flags in the TCP header are mutually exclusive. */
            if ((flags & ~TCP_FLAG_SYN) & (TCP_FLAG_FIN | TCP_FLAG_RST))
            {
                TRACE_FILTER("%!FUNC! Drop packet - Invalid TCP flags (0x%x)", flags);
                
                acpt = FALSE;
                goto exit;
            }

#if defined (NLB_TCP_NOTIFICATION)
            /* If this is a "pure" SYN packet incoming (no ACK flag set), then treat this as a new connection
               and call Main_conn_advise.  If TCP connection notification is NOT turned on, then we treat 
               incoming SYN+ACKs the same as SYNs, so call Main_conn_advise in this case as well. */
            if (!(flags & TCP_FLAG_ACK) || !NLB_NOTIFICATIONS_ON())
            {
#endif
#if defined (NLB_HOOK_ENABLE)
                acpt = Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_UP, filter);
#else
                acpt = Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_UP);
#endif
#if defined (NLB_TCP_NOTIFICATION)
            }
            /* Otherwise, a SYN+ACK corresponds to an outgoing TCP connection from the server that is being
               established.  In that case, with TCP notification turned on, we should have state for this
               connection in our pending queue; look it up. */
            else
            {
                acpt = Main_pending_check(svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP);
            }
#endif
        }
        else if (flags & TCP_FLAG_FIN)
        {
            TRACE_PACKET("%!FUNC! Incoming FIN");

            /* Make sure the SYN/FIN/RST flags in the TCP header are mutually exclusive. */
            if ((flags & ~TCP_FLAG_FIN) & (TCP_FLAG_SYN | TCP_FLAG_RST))
            {
                TRACE_FILTER("%!FUNC! Drop packet - Invalid TCP flags (0x%x)", flags);
                
                acpt = FALSE;
                goto exit;
            }

#if defined (NLB_TCP_NOTIFICATION)
            /* If TCP notification is turned on, then we should treat FINs and RSTs as data packets and not 
               as some special control packet.  Call Main_packet_check which will accept the packet if either
               we own the packet unconditionally, or if we find the corresponding state for this connection. */
            if (NLB_NOTIFICATIONS_ON())
            {
#if defined (NLB_HOOK_ENABLE)
                acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, filter);
#else
                acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP);
#endif
            } 
            /* Otherwise, if we're not using TCP notification, then treat this FIN/RST differently and use it
               to notify the load module to remove the state for this connection. */
            else 
            {
#endif
#if defined (NLB_HOOK_ENABLE)
                acpt = Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_DOWN, filter);
#else
                acpt = Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_DOWN);
#endif
#if defined (NLB_TCP_NOTIFICATION)
            }
#endif
        }
        else if (flags & TCP_FLAG_RST)
        {
            TRACE_PACKET("%!FUNC! Incoming RST");

            /* Make sure the SYN/FIN/RST flags in the TCP header are mutually exclusive. */
            if ((flags & ~TCP_FLAG_RST) & (TCP_FLAG_FIN | TCP_FLAG_SYN))
            {
                TRACE_FILTER("%!FUNC! Drop packet - Invalid TCP flags (0x%x)", flags);
                
                acpt = FALSE;
                goto exit;
            }

#if defined (NLB_TCP_NOTIFICATION)
            /* If TCP notification is turned on, then we should treat FINs and RSTs as data packets and not 
               as some special control packet.  Call Main_packet_check which will accept the packet if either
               we own the packet unconditionally, or if we find the corresponding state for this connection. */
            if (NLB_NOTIFICATIONS_ON())
            {
#if defined (NLB_HOOK_ENABLE)
                acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, filter);
#else
                acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP);
#endif
            } 
            /* Otherwise, if we're not using TCP notification, then treat this FIN/RST differently and use it
               to notify the load module to remove the state for this connection. */
            else 
            {
#endif
#if defined (NLB_HOOK_ENABLE)
                acpt = Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_RESET, filter);
#else
                acpt = Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_RESET);
#endif
#if defined (NLB_TCP_NOTIFICATION)
            }
#endif

            /* Count the number of inbound resets we've seen. */
            if (acpt) ctxtp->cntr_recv_tcp_resets++;
        }
        else
        {
            TRACE_PACKET("%!FUNC! Incoming data");

            UNIV_ASSERT(! (flags & (TCP_FLAG_SYN | TCP_FLAG_FIN | TCP_FLAG_RST)));

#if defined (NLB_HOOK_ENABLE)
            acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, filter);
#else
            acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP);
#endif
        }

        break;

    case TCPIP_PROTOCOL_UDP:

        /* If we have a UDP subsequent fragment, treat it as a data packet within an IPSEC
           tunnel. It will be accepted if this host has the hash bucket or if it has a
           matching virtual descriptor. Note that UDP subsequent fragments for other
           protocols will also be accepted if this host has the hash bucket. */ 
        
        if (pPacketInfo->IP.bFragment)
        {
#if defined (NLB_HOOK_ENABLE)
            acpt = Main_packet_check(ctxtp, svr_addr, IPSEC_CTRL_PORT, clt_addr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC_UDP, filter);
#else
            acpt = Main_packet_check(ctxtp, svr_addr, IPSEC_CTRL_PORT, clt_addr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC_UDP);
#endif
            
            break;
        }

        udp_hdrp = pPacketInfo->IP.UDP.pHeader;

#if defined (OPTIMIZE_FRAGMENTS)
        if (! fragmented)
        {
#endif
            TRACE_PACKET("%!FUNC! UDP Source port = %u, Destination port = %u",  
                         UDP_GET_SRC_PORT (udp_hdrp),
                         UDP_GET_DST_PORT (udp_hdrp));

#if defined (OPTIMIZE_FRAGMENTS)
        }
#endif

#if defined (OPTIMIZE_FRAGMENTS)
        if (! fragmented)
        {
#endif
            clt_port = UDP_GET_SRC_PORT (udp_hdrp);
            svr_port = UDP_GET_DST_PORT (udp_hdrp);
#if defined (OPTIMIZE_FRAGMENTS)
        }
        else
        {
            clt_port = 0;
            svr_port = 0;
        }
#endif

        /* UDP packets that arrive on port 500/4500 are IPSec control packets. */
        if ((svr_port == IPSEC_CTRL_PORT) || (svr_port == IPSEC_NAT_PORT)) {
            NLB_IPSEC_PACKET_TYPE PacketType = NLB_IPSEC_OTHER;
            PUCHAR  pOldBuffer = pPacketInfo->IP.UDP.Payload.pPayload;
            ULONG   OldLength = pPacketInfo->IP.UDP.Payload.Length;
            PUCHAR  pNewBuffer = NULL;
            ULONG   NewLength = 0;

            /* Because we need to dig really deep into IPSec IKE payloads, we want to make sure we have access
               to as much of the payload as is available.  If necessary, this function will allocate a new 
               buffer and copy the entire payload from the buffer chain into the single contigous payload buffer. */
            if (Main_get_full_payload(ctxtp, pPacketInfo->IP.UDP.Payload.pPayloadBuffer, pPacketInfo->IP.UDP.Payload.Length, 
                                      pPacketInfo->IP.UDP.Payload.pPayload, &pNewBuffer, &NewLength))
            {
                /* If Main_get_full_payload allocated a new buffer to hold the payload, re-point
                   the PACKET_INFO structure information to the new buffer and length. */
                if (pNewBuffer != NULL) {
                    pPacketInfo->IP.UDP.Payload.pPayload = pNewBuffer;
                    pPacketInfo->IP.UDP.Payload.Length = NewLength;
                }
            }

            /* First, parse the IKE payload to find out whether or not 
               this is an initial contact IKE Main Mode SA, etc. */
            PacketType = Main_parse_ipsec(pPacketInfo, svr_port);

            /* Copy the old buffer pointer back into the packet and free the memory allocated to hold the contiguous buffer. */
            if (pNewBuffer != NULL) {
                pPacketInfo->IP.UDP.Payload.pPayload = pOldBuffer;
                pPacketInfo->IP.UDP.Payload.Length = OldLength;

                /* Free the buffer memory. */
                NdisFreeMemory(pNewBuffer, NewLength, 0);
            }

            /* If this is an intial contact, treat this as a TCP SYN.  Otherwise, treat it like a TCP data packet. */
            if (PacketType == NLB_IPSEC_INITIAL_CONTACT) {
                /* If we own the bucket for this tuple, we'll create a descriptor and accept the packet.  If the client is not behind a 
                   NAT, then the source port will be IPSEC_CTRL_PORT (500).  If the client is behind a NAT, the source port will be 
                   arbitrary, but will persist for the entire IPSec session, so we can use it to distinguish clients behind a NAT.  In
                   such a scenario, all IPSec data (non-control traffic) is encapsulated in UDP packets, so the packet check will be 
                   performed in the else case of this branch.  In a non-NAT case, the data is in IPSec1/2 protocol packets, which will
                   be handled analagously in another case of this protocol switch statement. */
#if defined (NLB_HOOK_ENABLE)
                acpt = Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_IPSEC1, CVY_CONN_UP, filter);
#else
                acpt = Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_IPSEC1, CVY_CONN_UP);
#endif
            } else if (PacketType == NLB_IPSEC_IDENTIFICATION) {
                /* If this is a NAT'd IKE ID, we may need to pass it up on more than one host.  Use the same semantics used for UDP
                   fragmentation, which is to pass it up on the bucket owner and any hosts that have IPSec tunnels established with
                   the same client IP address.  The IPSEC_UDP descriptors are virtual and the presence of a matching one indicates
                   that there is at least one IPSec/L2TP tunnel between the given client and server IP addresses. */
#if defined (NLB_HOOK_ENABLE)
                acpt = Main_packet_check(ctxtp, svr_addr, IPSEC_CTRL_PORT, clt_addr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC_UDP, filter);
#else
                acpt = Main_packet_check(ctxtp, svr_addr, IPSEC_CTRL_PORT, clt_addr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC_UDP);
#endif                
            } else {
                /* If this is part of an existing IPSec session, then we have to have a descriptor in order to accpet it.  This will 
                   keep all IPSec traffic during the key exchange sticky, plus the data exchange if the client is behind a NAT. */
#if defined (NLB_HOOK_ENABLE)
                acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_IPSEC1, filter);
#else
                acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_IPSEC1);
#endif
            }

        } else {
#if defined (NLB_HOOK_ENABLE)
            acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_UDP, filter);
#else
            acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_UDP);
#endif
        }
        
        break;

    case TCPIP_PROTOCOL_GRE:
        
        /* If session support is active, then we have a GRE virtual descriptor that makes sure that
           we only pass up GRE traffic on host(s) that have active PPTP tunnels between this client
           and server IP address.  This does not guarantee that the packet goes up ONLY on the correct
           host, but that it will go up on AT LEAST the correct host. */
#if defined (NLB_HOOK_ENABLE)
        acpt = Main_packet_check(ctxtp, svr_addr, PPTP_CTRL_PORT, clt_addr, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE, filter);
#else
        acpt = Main_packet_check(ctxtp, svr_addr, PPTP_CTRL_PORT, clt_addr, PPTP_CTRL_PORT, TCPIP_PROTOCOL_GRE);
#endif

        break;

    case TCPIP_PROTOCOL_IPSEC1:
    case TCPIP_PROTOCOL_IPSEC2:

        /* If this is part of an existing IPSec session, then we have to have a descriptor in order to accpet it.  Because 
           this can only happen in the case where the client is NOT behind a NAT, we can safely hardcode the client port
           to IPSEC_CTRL_PORT (500).  In NAT scenarios, the data traffic is UDP encapsulated, not IPSec protocol type 
           traffic, and is distinguished by source port. */
#if defined (NLB_HOOK_ENABLE)
        acpt = Main_packet_check(ctxtp, svr_addr, IPSEC_CTRL_PORT, clt_addr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC1, filter);
#else
        acpt = Main_packet_check(ctxtp, svr_addr, IPSEC_CTRL_PORT, clt_addr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC1);
#endif

        break;

    case TCPIP_PROTOCOL_ICMP:
        /* If NLB is configured to filter ICMP, then do so, sending it up on only one host. 
           Hardcode the ports, since ICMP has no notion of port numbers.  Otherwise, send 
           up the ICMP traffic on all hosts (this is the default behavior). */
        if (ctxtp->params.filter_icmp) 
        {
#if defined (NLB_HOOK_ENABLE)
            acpt = Main_packet_check(ctxtp, svr_addr, 0, clt_addr, 0, TCPIP_PROTOCOL_UDP, filter);
#else
            acpt = Main_packet_check(ctxtp, svr_addr, 0, clt_addr, 0, TCPIP_PROTOCOL_UDP);
#endif
        } 

        break;

    default:

        TRACE_FILTER("%!FUNC! Accept packet - Unknown protocol traffic always allowed to pass");

        /* Allow other protocols to go out on all hosts. */

        break;
    }

 exit:

    TRACE_PACKET("%!FUNC! Exit: acpt = %u", acpt);

    return acpt;
} 

/*
 * Function: Main_recv_idhb
 * Description: This function processes an extended heartbeat, looking for
 *              identity information to cache.
 * Parameters: ctxtp - a pointer to the context structure for thie NLB instance.
 *             heartbeatp - a pointer to the NLB heartbeat wrapper that contains
 *                          the length and a pointer to the heartbeat payload.
 * Returns: VOID
 * Author: chrisdar, 2002 May 22
 * Notes: This function should only be called with the load lock held.
 */
VOID Main_recv_idhb(
    PMAIN_CTXT                  ctxtp,
    PMAIN_PACKET_HEARTBEAT_INFO heartbeatp)
{
    PMAIN_FRAME_HDR cvy_hdrp          = heartbeatp->pHeader;
    PTLV_HEADER     pHBBody           = heartbeatp->Payload.pPayloadEx;
    ULONG           ulPayloadLenBytes = heartbeatp->Payload.Length;

    /* cvy_hdrp->host has range 1-32. Change this to 0-31 so that it has the
       same value as the index in the cache array */
    const ULONG host_id = cvy_hdrp->host - 1;

    /* The caller was supposed to validate the information in the header for us.
       But the host ID is pretty darn important because it defines uniqueness. 
       So check it anyway. */
    if (host_id >= CVY_MAX_HOSTS)
    {
        UNIV_PRINT_CRIT(("Main_recv_idhb: host_id [0-31] %u is out of range", host_id));
        TRACE_CRIT("%!FUNC! host_id [0-31] %u is out of range", host_id);
        goto error;
    }

    {
        PTLV_HEADER pTLV         = NULL;
        ULONG       ulTotBodyLen = 0;

        /* The payload of any extended heartbeat type must begin with a TLV header. */
        while ((ulTotBodyLen + sizeof(TLV_HEADER)) <= ulPayloadLenBytes)
        {
            pTLV = (TLV_HEADER *) ((UCHAR *) pHBBody + ulTotBodyLen);

            /* The size stated in the TLV header must be large enough to contain the TLV header. */
            if (8*(pTLV->length8) < sizeof(TLV_HEADER))
            {
                UNIV_PRINT_CRIT(("Main_recv_idhb: Extended heartbeat contains a TLV header with a size (%d) less than the size of the header itself (%d)", 8*(pTLV->length8), sizeof(TLV_HEADER)));
                TRACE_CRIT("%!FUNC! Extended heartbeat contains a TLV header with a size (%d) less than the size of the header itself (%d)", 8*(pTLV->length8), sizeof(TLV_HEADER));
                goto error;
            }

            ulTotBodyLen += 8*(pTLV->length8);

            if (ulTotBodyLen > ulPayloadLenBytes)
            {
                UNIV_PRINT_CRIT(("Main_recv_idhb: Extended heartbeat received from host_id [0-31] %u has length %u (bytes) but internal data implies length should be at least %u", host_id, ulPayloadLenBytes, ulTotBodyLen));
                TRACE_CRIT("%!FUNC! Extended heartbeat received from host_id [0-31] %u has length %u (bytes) but internal data implies length should be at least %u", host_id, ulPayloadLenBytes, ulTotBodyLen);
                goto error;
            }

            if (pTLV->type == MAIN_PING_EX_TYPE_IDENTITY)
            {
                ULONG            fqdn_char = 0;
                UNALIGNED PWCHAR pwszFQDN  = (WCHAR *) (((UCHAR *) pTLV) + sizeof(TLV_HEADER));

                /* In the general case, this is an overestimate of the fqdn length because of padding. That's OK
                   though since the range we use is guaranteed valid and we avoid buffer overflow by bounding
                   the number to the size of the destination */
                fqdn_char = min(sizeof(ctxtp->identity_cache[host_id].fqdn),
                                (8*(pTLV->length8) - sizeof(TLV_HEADER))
                                )/sizeof(WCHAR);

                if (fqdn_char == 0)
                {
                    UNIV_PRINT_CRIT(("Main_recv_idhb: Identity heartbeat from host_id [0-31] %u has no fqdn (at a minimum a NULL-terminator is required)", host_id));
                    TRACE_CRIT("%!FUNC! Identity heartbeat from host_id [0-31] %u has no fqdn (at a minimum a NULL-terminator is required)", host_id);
                    goto error;
                }

                if (pwszFQDN[fqdn_char - 1] != UNICODE_NULL)
                {
                    UNIV_PRINT_CRIT(("Main_recv_idhb: Identity heartbeat received from host_id [0-31] %u has an fqdn that isn't NULL-terminated", host_id));
                    TRACE_CRIT("%!FUNC! Identity heartbeat received from host_id [0-31] %u has an fqdn that isn't NULL-terminated", host_id);
                    goto error;
                }

                NdisMoveMemory(&ctxtp->identity_cache[host_id].fqdn, pwszFQDN, fqdn_char*sizeof(WCHAR));

                if (ctxtp->identity_cache[host_id].ttl == 0)
                {
                    UNIV_PRINT_INFO(("Main_recv_idhb: adding cache entry for host [0-31] %u, dip=0x%x", host_id, cvy_hdrp->ded_ip_addr));
                    TRACE_INFO("%!FUNC! adding cache entry for host [0-31] %u. dip=0x%x, fqdn=%ls", host_id, cvy_hdrp->ded_ip_addr, pwszFQDN);
                }
                else
                {
                    UNIV_PRINT_VERB(("Main_recv_idhb: Updating cache entry for host [0-31] %u, dip=0x%x", host_id, cvy_hdrp->ded_ip_addr));
                    TRACE_VERB("%!FUNC! Updating cache entry for host [0-31] %u, dip=0x%x, fqdn=%ls", host_id, cvy_hdrp->ded_ip_addr, pwszFQDN);
                }

                /* Update the entry with the received data */
                ctxtp->identity_cache[host_id].ded_ip_addr = cvy_hdrp->ded_ip_addr;
                ctxtp->identity_cache[host_id].host_id     = (USHORT) host_id;

                /* Set the time-to-live for expiring this entry */
                UNIV_ASSERT(ctxtp->params.identity_period > 0);
                ctxtp->identity_cache[host_id].ttl = WLBS_ID_HB_TOLERANCE*(ctxtp->params.identity_period);

                /* Update the entry in the DIP list. */
                DipListSetItem(&ctxtp->dip_list, host_id, ctxtp->identity_cache[host_id].ded_ip_addr);

                /* There can only be one identity bundle in the heartbeat. */
                break;
            }
        }
    }

error:
    return;
}

/*
 * Function: Main_recv_ping
 * Description: This function processes an extended heartbeat, looking for
 *              identity information to cache.
 * Parameters: ctxtp - a pointer to the context structure for thie NLB instance.
 *             heartbeatp - a pointer to the NLB heartbeat wrapper that contains
 *                          the length and a pointer to the heartbeat payload.
 * Returns: ULONG - treated as boolean. FALSE means don't process this packet any further.
 * Author: unknown
 * Notes: This function should NOT be called with the load lock held.
 */
ULONG   Main_recv_ping (
    PMAIN_CTXT                  ctxtp,
    PMAIN_PACKET_HEARTBEAT_INFO heartbeatp)
{
#if defined(TRACE_CVY)
    DbgPrint ("(CVY %d)\n", cvy_hdrp->host);
#endif

    PMAIN_FRAME_HDR cvy_hdrp = heartbeatp->pHeader;

    /* Only accept messages from our cluster. */
    if (cvy_hdrp->cl_ip_addr == 0 || cvy_hdrp->cl_ip_addr != ctxtp->cl_ip_addr)
    {
        return FALSE;
    }

    /* Sanity check host id. */
    if (cvy_hdrp->host == 0 || cvy_hdrp->host > CVY_MAX_HOSTS)
    {
        UNIV_PRINT_CRIT(("Main_recv_ping: Bad host id %d", cvy_hdrp -> host));
        TRACE_CRIT("%!FUNC! Bad host id %d", cvy_hdrp -> host);

        if (!ctxtp->bad_host_warned && ctxtp->convoy_enabled)
        {
            WCHAR num[20];

            Univ_ulong_to_str(cvy_hdrp->host, num, 10);
            LOG_MSG(MSG_ERROR_HOST_ID, num);
            ctxtp->bad_host_warned = TRUE;
        }

        return FALSE;
    }

    /* Check the heartbeat type */
    if (cvy_hdrp->code == MAIN_FRAME_EX_CODE)
    {
        /* Cache the information in this heartbeat */
        if (ctxtp->params.identity_enabled)
        {
            NdisDprAcquireSpinLock(&ctxtp->load_lock);
            Main_recv_idhb(ctxtp, heartbeatp);
            NdisDprReleaseSpinLock(&ctxtp->load_lock);
        }

        /* Don't process these heartbeats any further */
        return FALSE;
    }

    if (!ctxtp->convoy_enabled)
    {
        return FALSE;
    }

    if ((cvy_hdrp->host != ctxtp->params.host_priority) &&
        (cvy_hdrp->ded_ip_addr == ctxtp->ded_ip_addr) &&
        (ctxtp->ded_ip_addr != 0))
    {
        UNIV_PRINT_CRIT(("Main_recv_ping: Duplicate dedicated IP address 0x%x", ctxtp -> ded_ip_addr));
        TRACE_CRIT("%!FUNC! Duplicate dedicated IP address 0x%x", ctxtp -> ded_ip_addr);

        if (!ctxtp->dup_ded_ip_warned)
        {
            LOG_MSG(MSG_ERROR_DUP_DED_IP_ADDR, ctxtp->params.ded_ip_addr);
            ctxtp->dup_ded_ip_warned = TRUE;
        }
    } 

    /* Might want to take appropriate actions for a message from a host
       running different version number of software. */
    if (cvy_hdrp->version != CVY_VERSION_FULL)
    {
        ;
    }

    return TRUE;
}

/*
 * Function: Main_ctrl_process
 * Description: This function processes a remote control request and replies if
 *              the request is proper and the cluster is configured to handle
 *              remote control.  If not, the packet is released HERE.  If the 
 *              reply succeeds and the packet send is not pending, the packet
 *              is released HERE.  If the send is pending, the packet will be
 *              released in Prot_send_complete.
 * Parameters: ctxtp - a pointer to the context structure for thie NLB instance.
 *             packetp - a pointer to the NDIS packet on the send path.
 * Returns: NDIS_STATUS - the status of the remote control request.
 * Author: shouse, 10.15.01
 * Notes: 
 */
NDIS_STATUS Main_ctrl_process (PMAIN_CTXT ctxtp, PNDIS_PACKET packetp) 
{
    MAIN_PACKET_INFO PacketInfo;
    NDIS_STATUS      status;
    
    /* Parse the packet. */
    if (!Main_recv_frame_parse(ctxtp, packetp, &PacketInfo))
    {
        /* If processing the request fails because of a packet error,
           misdirected request, malformed request or some other reason,
           then free the packet we allocated here and bail out. */
        Main_packet_put(ctxtp, packetp, TRUE, NDIS_STATUS_SUCCESS);        
    }

    /* Handle remote control request now. */
    status = Main_ctrl_recv(ctxtp, &PacketInfo);
    
    if (status != NDIS_STATUS_SUCCESS) 
    {
        /* If processing the request fails because of a packet error,
           misdirected request, malformed request or some other reason,
           then free the packet we allocated here and bail out. */
        Main_packet_put(ctxtp, packetp, TRUE, NDIS_STATUS_SUCCESS);
    } 
    else 
    {
        /* If processing the request succeeds, send the response out. */
        NdisSend(&status, ctxtp->mac_handle, packetp);
        
        /* If the send is pending, Prot_send_complete will be called 
           to free the packet.  If we're done, free it here. */
        if (status != NDIS_STATUS_PENDING)
            Main_packet_put(ctxtp, packetp, TRUE, status);
    }

    return status;
}

/*
 * Function: Main_ctrl_loopback
 * Description: This function is called from Main_send when a potential remote control
 *              packet is seen being sent.  We call this function to loop the packet 
 *              back to ourselves so that we can respond if need be.  This functionality
 *              used to be done by asking NDIS to loop the packet back, but Netmon 
 *              caused problems because the packet was ALREADY looped back at the NDIS
 *              interface above NLB, so NDIS refused to loop it back again when we asked
 *              it to.  Further, all well-bahaved protocols loop back their own packets 
 *              to themselves anyway, so we bite the bullet and take a stab at becoming
 *              a well-behaved protocol implementation.  This function takes a remote
 *              control packet on the send path, makes a copy of it and tacks it onto 
 *              the remote control request queue, where it will be serviced later by the
 *              heartbeat timer.
 * Parameters: ctxtp - a pointer to the context structure for thie NLB instance.
 *             packtep - a pointer to the NDIS packet on the send path.
 * Returns: Nothing.
 * Author: shouse, 6.10.01
 * Notes: Because this function emulates our receive path, but is called internally on
 *        our send path, the caller of this function should make sure that the IRQL is
 *        set correctly before calling us and re-setting it after.  Packet receive 
 *        functions are run at DPC level by NDIS, yet send packet functions are run at
 *        DPC OR LOWER.  So, the caller should raise the IRQL to DISPATCH_LEVEL and then
 *        restore it after this function returns.  This is just for the sake of paranoia.
 */
VOID Main_ctrl_loopback (PMAIN_CTXT ctxtp, PNDIS_PACKET packetp, PMAIN_PACKET_INFO pPacketInfo)
{
    PMAIN_PROTOCOL_RESERVED resp;
    PNDIS_PACKET_OOB_DATA   oobp;
    PNDIS_PACKET            newp;
    PLIST_ENTRY             entryp;
    PMAIN_BUFFER            bp;
    ULONG                   size;
    ULONG                   xferred;
    ULONG                   lowmark;

    UNIV_PRINT_VERB(("Main_ctrl_loopback: Looping back a remote control request to ourselves"));

    /* Start - code copied from Main_recv. */

    /* Allocate a new packet for the remote control request. */
    newp = Main_packet_alloc(ctxtp, FALSE, &lowmark);

    /* If allocation failed, bail out. */
    if (!newp) 
    {
        UNIV_PRINT_CRIT(("Main_ctrl_loopback: Unable to allocate a packet"));
        TRACE_CRIT("%!FUNC! Unable to allocate a packet");

        /* Increment the number of failed receive allocations. */
        ctxtp->cntr_recv_no_buf++;

        return;
    }

    /* Try to get a buffer to hold the packet contents. */
    while (1) 
    {
        NdisDprAcquireSpinLock(&ctxtp->buf_lock);

        /* Pull the head of the list off. */
        entryp = RemoveHeadList(&ctxtp->buf_list);
        
        /* If we got a buffer, we're good to go - break out of the loop. */
        if (entryp != &ctxtp->buf_list) 
        {
            /* Increment the number of outstanding buffers. */
            ctxtp->num_bufs_out++;

            NdisDprReleaseSpinLock(&ctxtp->buf_lock);

            break;
        }
        
        NdisDprReleaseSpinLock(&ctxtp->buf_lock);
        
        /* Otherwise, the list was empty - try to replenish it. */
        if (!Main_bufs_alloc(ctxtp)) 
        {
            UNIV_PRINT_CRIT(("Main_ctrl_loopback: Unable to allocate a buffer"));
            TRACE_CRIT("%!FUNC! Unable to allocate a buffer");

            /* If we couldn't allocate any buffers, free the packet and bail. */
            NdisFreePacket(newp);

            /* Increment the number of failed receive allocations. */
            ctxtp->cntr_recv_no_buf++;

            return;
        }
    }
    
    /* Get a pointer to the actual buffer. */
    bp = CONTAINING_RECORD(entryp, MAIN_BUFFER, link);

    UNIV_ASSERT(bp->code == MAIN_BUFFER_CODE);
    
    /* Calculate the total size of the packet. */
    size = ctxtp->buf_mac_hdr_len + pPacketInfo->Length;
    
    /* Adjust the size of the buffer to this size. */
    NdisAdjustBufferLength(bp->full_bufp, size);
    
    /* Chain the buffer onto the new packet we've allocated. */
    NdisChainBufferAtFront(newp, bp->full_bufp);
    
    /* Copy the contents of all buffers in the original packet into
       the new packet we've allocated.  This should result in the 
       data (buffers) moving from being spread across several buffers
       (probably 4 - one per layer, since this was a packet on the 
       send path) to a single buffer, which is what we are generally
       expecting on the receive path anyway. */
    NdisCopyFromPacketToPacketSafe(newp, 0, size, packetp, 0, &xferred, NormalPagePriority);
    
    /* Copy the out-of-band data from the old packet to the new one. */
    oobp = NDIS_OOB_DATA_FROM_PACKET(newp);

    oobp->HeaderSize               = ctxtp->buf_mac_hdr_len;
    oobp->MediaSpecificInformation = NULL;
    oobp->SizeMediaSpecificInfo    = 0;
    oobp->TimeSent                 = 0;
    oobp->TimeReceived             = 0;
    
    /* Because packets marked as CTRL never pass above NLB in the 
       network stack, we can always use the ProtocolReserved field. */
    resp = MAIN_PROTOCOL_FIELD(newp);
    
    /* If the packet allocation indicated that we have reached the low
       watermark for available packets, set STATUS_RESOURCES, so that
       the adapter returns the packet to use as soon as possible (this
       is the newly allocated remote control packet, which we will 
       respond to and send in a heartbeat timer handler. */
    if (lowmark) NDIS_SET_PACKET_STATUS(newp, NDIS_STATUS_RESOURCES);
    
    /* Fill in the NLB private packet data. */
    resp->type  = MAIN_PACKET_TYPE_CTRL;
    resp->miscp = bp;
    resp->data  = 0;
    resp->group = pPacketInfo->Group;
    resp->len   = pPacketInfo->Length;
    
    /* If the copy operation failed to copy the entire packet, return the
       allocated resources and return NULL to drop the packet. */
    if (xferred < size)
    {
        /* Note that although this IS a receive, Main_packet_put expects 
           all packets marked as MAIN_PACKET_TYPE_CTRL to specify TRUE
           in the send parameter, as these packets are usually returned
           in the send complete code path when the reply is sent. */
        Main_packet_put(ctxtp, newp, TRUE, NDIS_STATUS_FAILURE);
        
        TRACE_CRIT("%!FUNC! Copy remote control packet contents failed");
        return;
    }        

    /* Because this is a remote control packet, MiniportReserved
       should not contain a pointer to a private protocol buffer. */
    UNIV_ASSERT(!MAIN_MINIPORT_FIELD(newp));

    /* End Main_recv. */

    /* Start - code copied from Prot_packet_recv. */

    /* Handle remote control request now. */
    (VOID)Main_ctrl_process(ctxtp, newp);

    /* End Prot_packet_recv. */
}

/*
 * Function: Main_send
 * Description: This function parses packets being sent out on an NLB adapter and
 *              processes them.  This processing includes filtering IP packets 
 *              and internally looping back outgoing NLB remote control requests.
 * Parameters: ctxtp - pointer to the NLB context for this adapter.
 *             packetp - pointer to the NDIS_PACKET being sent.
 *             exhausted - OUT parameter to indicate that packet resources have 
 *                         been internally exhausted.
 * Returns: PNDIS_PACKET - the packet to be sent down to the miniport.
 * Author: kyrilf, shouse, 3.4.02
 * Notes: 
 */
PNDIS_PACKET Main_send (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packetp,
    PULONG              exhausted)
{
    MAIN_PACKET_INFO    PacketInfo;
    PNDIS_PACKET        newp;

    *exhausted = FALSE;

    /* Parse the packet. */
    if (!Main_send_frame_parse(ctxtp, packetp, &PacketInfo))
    {
        TRACE_CRIT("%!FUNC! failed to parse out IP and MAC pointers");
        return NULL;
    }

    /* Munge the Ethernet MAC addresses, if necessary. */
    Main_spoof_mac(ctxtp, &PacketInfo, TRUE);

    /* Process IP frames. */
    if (PacketInfo.Type == TCPIP_IP_SIG) 
    {
#if defined (NLB_HOOK_ENABLE)
        NLB_FILTER_HOOK_DIRECTIVE filter;
        
        /* Invoke the send filter hook, if registered. */
        filter = Main_send_hook(ctxtp, packetp, &PacketInfo);

        /* Process some of the hook responses. */
        if (filter == NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY) 
        {
            /* If the hook asked us to reject this packet, then we can do so here. */
            TRACE_FILTER("%!FUNC! Packet send filter hook: REJECT packet");
            return NULL;
        } 
        else if (filter == NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY) 
        {
            /* If the hook asked us to accept this packet, then break out - do
               NOT call Main_ip_send_filter. */
            TRACE_FILTER("%!FUNC! Packet send filter hook: ACCEPT packet");
        }
        else
        {
            /* Filter the IP traffic. */
            if (!Main_ip_send_filter(ctxtp, &PacketInfo, filter))
#else
            if (!Main_ip_send_filter(ctxtp, &PacketInfo))
#endif
            {
                TRACE_INFO("%!FUNC! Main_ip_send_filter either failed handling the packet or filtered it out");
                return NULL;
            }
#if defined (NLB_HOOK_ENABLE)
        }
#endif
    }
    /* Process ARP frames. */
    else if (PacketInfo.Type == TCPIP_ARP_SIG) 
    {
        /* Munge the ARPs if necessary. */
        if (!Main_arp_handle(ctxtp, &PacketInfo, TRUE))
        {
            TRACE_INFO("%!FUNC! Main_arp_handle either failed handling ARP or filtered it out");
            return NULL;
        }
    }

    /* If still sending out - get a new packet. */
    newp = Main_packet_get(ctxtp, packetp, TRUE, PacketInfo.Group, PacketInfo.Length);

    *exhausted = (newp == NULL);

    /* If this is an out-going remote control request, we need to internally 
       loop this packet back to ourselves, rather than relying on NDIS to 
       do this for us.  Only bother, however, if remote control is enabled. */
    if ((newp != NULL) && (PacketInfo.Operation == MAIN_FILTER_OP_CTRL_REQUEST))
    {
        if (ctxtp->params.rct_enabled)
        {
            KIRQL irql;
            
            /* Get the current IRQL. */
            irql = KeGetCurrentIrql();
            
            /* The send function for a miniport is ALWAYS run at an 
               IRQL less than or equal to dispatch, but make sure. */
            ASSERT(irql <= DISPATCH_LEVEL);
            
            /* Since we are about to emulate our packet receive path, we want
               to make sure that this call to Main_ctrl_loopback runs at the
               same IRQL that the rest of our receive code runs at, such as
               Prot_packet_recv, so we'll raise it to DISPATCH level, which is
               the level that all protocol receive functions run at, and we'll
               restore the original IRQL when we're done. */
            KeRaiseIrql(DISPATCH_LEVEL, &irql);
            
            /* Internally loop the remote control request back to ourselves,
               so that we can also reply to it.  According to NDIS, all good
               protocol implementations loop back packets internally when 
               necessary and we shouln't rely on NDIS to do this for us. */
            Main_ctrl_loopback(ctxtp, newp, &PacketInfo);
            
            /* Restore the IRQL. */
            KeLowerIrql(irql);
        }

        /* Since we are looping the packet back ourselves, 
           ask NDIS NOT to loop it back to us again. */
        NdisSetPacketFlags(newp, NDIS_FLAGS_DONT_LOOPBACK);
    }

    return newp;
}

/*
 * Function: Main_recv
 * Description: This function is the packet receive engine for incoming packets.
 *              It parses the packet, filters it appropriately, and performs any
 *              necessary processing on packets that will be passed up to the 
 *              protocol(s).
 * Parameters: ctxtp - a pointer to the NLB main context structure for this adapter.
 *             packetp - a pointer to the received NDIS_PACKET.
 * Returns: PNDIS_PACKET - a pointer to the packet to be propagated up to the protocol(s).
 * Author: kyrilf, shouse, 3.4.02
 * Notes: 
 */
PNDIS_PACKET Main_recv (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packetp)
{
    MAIN_PACKET_INFO        PacketInfo;
    PNDIS_PACKET            newp;
    PMAIN_BUFFER            bp;
    PMAIN_PROTOCOL_RESERVED resp;
    PNDIS_PACKET_OOB_DATA   oobp;
    ULONG                   size;
    ULONG                   xferred;
    PLIST_ENTRY             entryp;
    USHORT                  group;
    ULONG                   packet_lowmark;

    UNIV_ASSERT (ctxtp->medium == NdisMedium802_3);

    /* Parse the packet. */
    if (!Main_recv_frame_parse(ctxtp, packetp, &PacketInfo))
    {
        TRACE_CRIT("%!FUNC! failed to parse out IP and MAC pointers");
        return NULL;
    }

    /* Munge the Ethernet MAC addresses, if necessary. */
    Main_spoof_mac(ctxtp, &PacketInfo, FALSE);

    /* Process IP frames.  Because remote control requests are not filtered, they 
       should fall straight through and be accepted.  Remote control responses, 
       however, need to be passed to the filter hook, so although they are not 
       filtered by NLB, they may be filtered by the hook consumer. */
    if ((PacketInfo.Type == TCPIP_IP_SIG) && (PacketInfo.Operation != MAIN_FILTER_OP_CTRL_REQUEST))
    {
#if defined (NLB_HOOK_ENABLE)
        NLB_FILTER_HOOK_DIRECTIVE filter;

        /* Invoke the receive packet hook, if one is registered. */
        filter = Main_recv_hook(ctxtp, packetp, &PacketInfo);

        /* Process some of the hook responses. */
        if (filter == NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY) 
        {
            /* If the hook asked us to reject this packet, then we can do so here. */
            TRACE_INFO("%!FUNC! Packet receive filter hook: REJECT packet");
            return NULL;
        }
        else if (filter == NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY) 
        {
            /* If the hook asked us to accept this packet, then break out - do
               NOT call Main_ip_recv_filter. */
            TRACE_INFO("%!FUNC! Packet receive filter hook: ACCEPT packet");
        }
        else
        {
            /* If this is NOT a remote control response, filter the IP traffic. */
            if ((PacketInfo.Operation != MAIN_FILTER_OP_CTRL_RESPONSE) && !Main_ip_recv_filter(ctxtp, &PacketInfo, filter))
#else
            if ((PacketInfo.Operation != MAIN_FILTER_OP_CTRL_RESPONSE) && !Main_ip_recv_filter(ctxtp, &PacketInfo))
#endif
            {
                TRACE_VERB("%!FUNC! Main_ip_recv_filter either failed handling the packet or filtered it out");
                return NULL;
            }
#if defined (NLB_HOOK_ENABLE)
        }
#endif
    }
    /* Process ARP frames. */
    else if (PacketInfo.Type == TCPIP_ARP_SIG)
    {
        /* Munge the ARPs if necessary. */
        if (!Main_arp_handle(ctxtp, &PacketInfo, FALSE)) 
        {
            TRACE_INFO("%!FUNC! Main_arp_handle either failed handling ARP or filtered it out");
            return NULL;
        }
    }
    /* Process heartbeat frames. */
    else if ((PacketInfo.Type == MAIN_FRAME_SIG) || (PacketInfo.Type == MAIN_FRAME_SIG_OLD))
    {
        /* Call Main_recv_ping to check for invalid host IDs and to ensure that this
           heartbeat is actually intended for this cluster. */
        if (Main_recv_ping(ctxtp, &PacketInfo.Heartbeat))                
        {
            /* Switch into backward compatibility mode if a convoy hearbeat is detected. */
            if ((PacketInfo.Type == MAIN_FRAME_SIG_OLD) && !ctxtp->etype_old)
            {
                CVY_ETHERNET_ETYPE_SET(&ctxtp->media_hdr.ethernet, MAIN_FRAME_SIG_OLD);
                
                ctxtp->etype_old = TRUE;
            }

            NdisDprAcquireSpinLock(&ctxtp->load_lock);
            
            /* Have load deal with contents. */
            if (ctxtp->convoy_enabled) 
            {
                BOOLEAN bConverging = FALSE;

                bConverging = Load_msg_rcv(&ctxtp->load, PacketInfo.Heartbeat.pHeader, PacketInfo.Heartbeat.Payload.pPayload);

                if (bConverging)
                {
                    /* While the cluster is in a converging state, we keep the DIP list clear. 
                       As soon as we have completed convergence, we begin updating the DIP list
                       on every heartbeat while converged. */ 
                    if (!ctxtp->params.identity_enabled)
                    {
                        DipListClear(&ctxtp->dip_list);
                    }
                } 
                else 
                {
                    /* Once converged, every heartbeat updates the relevant DIP entry in the list. */
                    DipListSetItem(&ctxtp->dip_list, PacketInfo.Heartbeat.pHeader->host - 1, PacketInfo.Heartbeat.pHeader->ded_ip_addr);
                }
            }
            
            NdisDprReleaseSpinLock(&ctxtp->load_lock);  
        }

        /* If we're NOT passing the packet up the protocols in order to view it 
           in NetMon, we can drop it here, as we're already done with it. */
        if (!ctxtp->params.netmon_alive)
        {
            return NULL;
        }
    }

    /* Post-process NBT traffic. */
    if (PacketInfo.Operation == MAIN_FILTER_OP_NBT)
    {
        Tcpip_nbt_handle(&ctxtp->tcpip, &PacketInfo);
    }

    /* Get a new packet.  For all non-remote control request packets, 
       attempt to use packet stacking to avoid allocating a new packet. */
    if (PacketInfo.Operation != MAIN_FILTER_OP_CTRL_REQUEST)
    {
        /* Either re-use this packet (packet stacking), or get a new one if necessary. */
        newp = Main_packet_get(ctxtp, packetp, FALSE, PacketInfo.Group, PacketInfo.Length);

        if (newp == NULL) {
            /* Increment the number of failed receive allocations. */
            ctxtp->cntr_recv_no_buf++;
            return NULL;
        }
    }
    /* Copy incoming remote control packet into our own, so we re-use it later to send back reply. */
    else
    {
        /* Allocate a new packet for the remote control request. */
        newp = Main_packet_alloc(ctxtp, FALSE, &packet_lowmark);

        /* If allocation failed, bail out. */
        if (newp == NULL)
        {
            UNIV_PRINT_CRIT(("Main_recv: Unable to allocate a packet"));
            TRACE_CRIT("%!FUNC! Unable to allocate a packet");

            /* Increment the number of failed receive allocations. */
            ctxtp->cntr_recv_no_buf ++;

            return NULL;
        }

        /* Try to get a buffer to hold the packet contents. */
        while (1)
        {
            NdisDprAcquireSpinLock(&ctxtp->buf_lock);

            /* Pull the head of the list off. */
            entryp = RemoveHeadList(&ctxtp->buf_list);

            /* If we got a buffer, we're good to go - break out of the loop. */
            if (entryp != &ctxtp->buf_list)
            {
                /* Increment the number of outstanding buffers. */
                ctxtp->num_bufs_out++;

                NdisDprReleaseSpinLock(&ctxtp->buf_lock);
 
                break;
            }

            NdisDprReleaseSpinLock(&ctxtp->buf_lock);

            UNIV_PRINT_VERB(("Main_recv: Out of buffers"));
            TRACE_VERB("%!FUNC! Out of buffers");

            /* Otherwise, the list was empty - try to replenish it. */
            if (!Main_bufs_alloc(ctxtp))
            {
                TRACE_CRIT("%!FUNC! Main_bufs_alloc failed");

                /* If we couldn't allocate any buffers, free the packet and bail. */
                NdisFreePacket(newp);

                /* Increment the number of failed receive allocations. */
                ctxtp->cntr_recv_no_buf++;

                return NULL;
            }
        }

        /* Get a pointer to the actual buffer. */
        bp = CONTAINING_RECORD(entryp, MAIN_BUFFER, link);

        UNIV_ASSERT(bp->code == MAIN_BUFFER_CODE);

        /* Calculate the total packet size. */
        size = ctxtp->buf_mac_hdr_len + PacketInfo.Length;

        /* Adjust the size of the buffer to this size. */
        NdisAdjustBufferLength(bp->full_bufp, size);

        /* Chain the buffer onto the new packet we've allocated. */
        NdisChainBufferAtFront(newp, bp->full_bufp);

        /* Copy actual data.  Check for success after filling in the private 
           packet data so we can call Main_packet_put to free the resources. */
        NdisCopyFromPacketToPacket(newp, 0, size, packetp, 0, &xferred);

        /* Copy the out-of-band data from the old packet to the new one. */
        oobp = NDIS_OOB_DATA_FROM_PACKET(newp);

        oobp->HeaderSize               = ctxtp->buf_mac_hdr_len;
        oobp->MediaSpecificInformation = NULL;
        oobp->SizeMediaSpecificInfo    = 0;
        oobp->TimeSent                 = 0;
        oobp->TimeReceived             = 0;

        /* Because packets marked as CTRL never pass above NLB in the 
           network stack, we can always use the ProtocolReserved field. */
        resp = MAIN_PROTOCOL_FIELD(newp);

        /* If the packet allocation indicated that we have reached the low
           watermark for available packets, set STATUS_RESOURCES, so that
           the adapter returns the packet to use as soon as possible (this
           is the newly allocated remote control packet, which we will 
           respond to and send in a heartbeat timer handler. */
        if (packet_lowmark) NDIS_SET_PACKET_STATUS(newp, NDIS_STATUS_RESOURCES);

        /* Fill in the NLB private packet data. */
        resp->type  = MAIN_PACKET_TYPE_CTRL;
        resp->miscp = bp;
        resp->data  = 0;
        resp->group = PacketInfo.Group;
        resp->len   = PacketInfo.Length;

        /* If the copy operation failed to copy the entire packet, return the
           allocated resources and return NULL to drop the packet. */
        if (xferred < size)
        {
            /* Note that although this IS a receive, Main_packet_put expects 
               all packets marked as MAIN_PACKET_TYPE_CTRL to specify TRUE
               in the send parameter, as these packets are usually returned
               in the send complete code path when the reply is sent. */
            Main_packet_put(ctxtp, newp, TRUE, NDIS_STATUS_FAILURE);
         
            TRACE_CRIT("%!FUNC! Copy remote control packet contents failed");
            return NULL;
        }        

        /* Because this is a remote control packet, MiniportReserved
           should not contain a pointer to a private protocol buffer. */
        UNIV_ASSERT(!MAIN_MINIPORT_FIELD(newp));
    }

    return newp;
}

ULONG   Main_actions_alloc (
    PMAIN_CTXT              ctxtp)
{
    PMAIN_ACTION            actp;
    ULONG                   size, index, i;
    NDIS_STATUS             status;


    NdisAcquireSpinLock (& ctxtp -> act_lock);

    if (ctxtp -> num_action_allocs >= CVY_MAX_ALLOCS)
    {
        if (! ctxtp -> actions_warned)
        {
            LOG_MSG1 (MSG_WARN_RESOURCES, CVY_NAME_NUM_ACTIONS, ctxtp -> num_actions);
            ctxtp -> actions_warned = TRUE;
        }

        NdisReleaseSpinLock (& ctxtp -> act_lock);
        TRACE_CRIT("%!FUNC! number of action allocs is too high = %u", ctxtp -> num_action_allocs);
        return FALSE;
    }

    index = ctxtp -> num_action_allocs;
    NdisReleaseSpinLock (& ctxtp -> act_lock);

    size = ctxtp -> num_actions * ctxtp -> act_size; /* 64-bit -- ramkrish */

    status = NdisAllocateMemoryWithTag (& (ctxtp -> act_buf [index]), size,
                                        UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Main_actions_alloc: Error allocating actions %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        TRACE_CRIT("%!FUNC! Error allocating actions %d status=0x%x", size, status);
        return FALSE;
    }

    NdisAcquireSpinLock (& ctxtp -> act_lock);
    ctxtp -> num_action_allocs ++;
    NdisReleaseSpinLock (& ctxtp -> act_lock);

    for (i = 0; i < ctxtp -> num_actions; i++)
    {
        /* ensure that actp is aligned along 8-byte boundaries */
        actp = (PMAIN_ACTION) ( (PUCHAR) (ctxtp -> act_buf [index]) + i * ctxtp -> act_size);
        actp -> code  = MAIN_ACTION_CODE;
        actp -> ctxtp = ctxtp;

        NdisInitializeEvent(&actp->op.request.event);
    
        NdisInterlockedInsertTailList (& ctxtp -> act_list,
                                       & actp -> link,
                                       & ctxtp -> act_lock);
    }

    return TRUE;

} /* end Main_actions_alloc */


PMAIN_ACTION Main_action_get (
    PMAIN_CTXT              ctxtp)
{
    PLIST_ENTRY             entryp;
    PMAIN_ACTION            actp;

    while (1)
    {
        NdisAcquireSpinLock (& ctxtp -> act_lock);
        entryp = RemoveHeadList (& ctxtp -> act_list);
        NdisReleaseSpinLock (& ctxtp -> act_lock);

        if (entryp != & ctxtp -> act_list)
            break;

        UNIV_PRINT_VERB(("Main_action_get: Out of actions"));
        TRACE_VERB("%!FUNC! Out of actions");

        if (! Main_actions_alloc (ctxtp))
        {
            UNIV_PRINT_CRIT(("Main_action_get: Main_actions_alloc failed"));
            TRACE_CRIT("%!FUNC! Main_actions_alloc failed");
            return NULL;
        }
    }

    actp = CONTAINING_RECORD (entryp, MAIN_ACTION, link);

    UNIV_ASSERT (actp -> code == MAIN_ACTION_CODE);
    UNIV_ASSERT (actp -> ctxtp == ctxtp);

    actp->status = NDIS_STATUS_FAILURE;

    actp->op.request.xferred = 0;
    actp->op.request.needed = 0;
    actp->op.request.external = FALSE;
    actp->op.request.buffer_len = 0;
    actp->op.request.buffer = NULL;

    NdisResetEvent(&actp->op.request.event);

    NdisZeroMemory(&actp->op.request.req, sizeof(NDIS_REQUEST));

    return actp;

} /* end Main_action_get */


VOID Main_action_put (
    PMAIN_CTXT              ctxtp,
    PMAIN_ACTION            actp)
{

    UNIV_ASSERT (actp -> code == MAIN_ACTION_CODE);

    NdisAcquireSpinLock (& ctxtp -> act_lock);
    InsertTailList (& ctxtp -> act_list, & actp -> link);
    NdisReleaseSpinLock (& ctxtp -> act_lock);

} /* end Main_action_put */


VOID Main_action_slow_put (
    PMAIN_CTXT              ctxtp,
    PMAIN_ACTION            actp)
{

    UNIV_ASSERT (actp -> code == MAIN_ACTION_CODE);

    NdisAcquireSpinLock (& ctxtp -> act_lock);
    InsertTailList (& ctxtp -> act_list, & actp -> link);
    NdisReleaseSpinLock (& ctxtp -> act_lock);

} /* end Main_action_slow_put */


ULONG   Main_bufs_alloc (
    PMAIN_CTXT              ctxtp)
{
    PMAIN_BUFFER        bp;
    NDIS_STATUS         status;
    ULONG               i, size, index;


    NdisAcquireSpinLock (& ctxtp -> buf_lock);

    if (ctxtp -> num_buf_allocs >= CVY_MAX_ALLOCS)
    {
        if (! ctxtp -> packets_warned)
        {
            LOG_MSG1 (MSG_WARN_RESOURCES, CVY_NAME_NUM_PACKETS, ctxtp -> num_packets);
            ctxtp -> packets_warned = TRUE;
        }

        NdisReleaseSpinLock (& ctxtp -> buf_lock);
        TRACE_CRIT("%!FUNC! num_buf_allocs=%u too large", ctxtp -> num_buf_allocs);
        return FALSE;
    }

    index = ctxtp -> num_buf_allocs;
    NdisReleaseSpinLock (& ctxtp -> buf_lock);

    /* get twice as many buffer descriptors (one for entire buffer and one
       just for the payload portion) */

    size = 2 * ctxtp -> num_packets;

    NdisAllocateBufferPool (& status, & (ctxtp -> buf_pool_handle [index]),
                            2 * ctxtp -> num_packets);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Main_bufs_alloc: Error allocating buffer pool %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        TRACE_CRIT("%!FUNC! Error allocating buffer pool %d 0x%x", size, status);
        return FALSE;
    }

    /* allocate memory for the payload */

    size = ctxtp -> num_packets * ctxtp -> buf_size;

    status = NdisAllocateMemoryWithTag (& (ctxtp -> buf_array [index]), size,
                                        UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Main_bufs_alloc: Error allocating buffer space %d %x", size, status));
        TRACE_CRIT("%!FUNC! Error allocating buffer space %d 0x%x", size, status);
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        goto error;
    }

    NdisZeroMemory (ctxtp -> buf_array [index], size);

    for (i = 0; i < ctxtp -> num_packets; i ++)
    {
        bp = (PMAIN_BUFFER) (ctxtp -> buf_array [index] + i * ctxtp -> buf_size);

        bp -> code = MAIN_BUFFER_CODE;

        /* setup buffer descriptors to describe entire buffer and just the
           payload */

        size = ctxtp -> buf_mac_hdr_len + ctxtp -> max_frame_size;

        NdisAllocateBuffer (& status, & bp -> full_bufp,
                            ctxtp -> buf_pool_handle [index],
                            bp -> data, size);

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT(("Main_bufs_alloc: Error allocating header buffer %d %x", i, status));
            TRACE_CRIT("%!FUNC! Error allocating header buffer %d 0x%x", i, status);
            LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
            goto error;
        }

        bp -> framep = bp -> data + ctxtp -> buf_mac_hdr_len;
        size = ctxtp -> max_frame_size;

        NdisAllocateBuffer (& status, & bp -> frame_bufp,
                            ctxtp -> buf_pool_handle [index],
                            bp -> framep, size);

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT_CRIT(("Main_bufs_alloc: Error allocating frame buffer %d %x", i, status));
            TRACE_CRIT("%!FUNC! Error allocating frame buffer %d 0x%x", i, status);
            LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
            goto error;
        }

        NdisInterlockedInsertTailList (& ctxtp -> buf_list,
                                       & bp -> link,
                                       & ctxtp -> buf_lock);
    }

    NdisAcquireSpinLock (& ctxtp -> buf_lock);
    ctxtp -> num_buf_allocs ++;
    ctxtp->num_bufs_alloced += ctxtp->num_packets;
    NdisReleaseSpinLock (& ctxtp -> buf_lock);

    return TRUE;

error:

    if (ctxtp -> buf_array [index] != NULL)
    {
        for (i = 0; i < ctxtp -> num_packets; i ++)
        {
            bp = (PMAIN_BUFFER) (ctxtp -> buf_array [index] + i * ctxtp -> buf_size);

            if (bp -> full_bufp != NULL)
            {
                NdisAdjustBufferLength (bp -> full_bufp,
                                        ctxtp -> buf_mac_hdr_len +
                                        ctxtp -> max_frame_size);
                NdisFreeBuffer (bp -> full_bufp);
            }

            if (bp -> frame_bufp != NULL)
            {
                NdisAdjustBufferLength (bp -> frame_bufp,
                                        ctxtp -> max_frame_size);
                NdisFreeBuffer (bp -> frame_bufp);
            }
        }

        NdisFreeMemory (ctxtp -> buf_array [index],
                        ctxtp -> num_packets * ctxtp -> buf_size, 0);
    }

    if (ctxtp -> buf_pool_handle [index] != NULL)
        NdisFreeBufferPool (ctxtp -> buf_pool_handle [index]);

    return FALSE;

} /* end Main_bufs_alloc */


PNDIS_PACKET Main_frame_get (
    PMAIN_CTXT          ctxtp,
    PULONG              lenp,
    USHORT              frame_type)
{
    PLIST_ENTRY         entryp;
    PMAIN_FRAME_DSCR    dscrp;
    NDIS_STATUS         status;
    PMAIN_PROTOCOL_RESERVED resp;
    PNDIS_PACKET        packet;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;


    NdisAllocatePacket (& status, & packet, ctxtp -> frame_pool_handle);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT_CRIT(("Main_frame_get: Out of PING packets"));
        TRACE_CRIT("%!FUNC! Out of PING packets");

#if 0 /* V1.3.2b */
        if (! ctxtp -> send_msgs_warned)
        {
            LOG_MSG1 (MSG_WARN_RESOURCES, CVY_NAME_NUM_SEND_MSGS, ctxtp -> num_send_msgs);
            ctxtp -> send_msgs_warned = TRUE;
        }
#endif

        ctxtp->cntr_frame_no_buf++;

        return NULL;
    }

    /* #ps# -- ramkrish */
    pktstk = NdisIMGetCurrentPacketStack (packet, & stack_left);
    if (pktstk)
    {
        MAIN_IMRESERVED_FIELD(pktstk) = NULL;
    }

    /* Make sure that the MiniportReserved field is initially NULL. */
    MAIN_MINIPORT_FIELD(packet) = NULL;

    NdisAcquireSpinLock (& ctxtp -> frame_lock);
    entryp = RemoveHeadList (& ctxtp -> frame_list);
    NdisReleaseSpinLock (& ctxtp -> frame_lock);

    if (entryp == & ctxtp -> frame_list)
    {
        UNIV_PRINT_CRIT(("Main_frame_get: Out of PING messages"));
        TRACE_CRIT("%!FUNC! Out of PING messages");

#if 0 /* V1.3.2b */
        if (! ctxtp -> send_msgs_warned)
        {
            LOG_MSG1 (MSG_WARN_RESOURCES, CVY_NAME_NUM_SEND_MSGS, ctxtp -> num_send_msgs);
            ctxtp -> send_msgs_warned = TRUE;
        }
#endif

        ctxtp->cntr_frame_no_buf++;

        NdisFreePacket (packet);
        return NULL;
    }

    dscrp = CONTAINING_RECORD (entryp, MAIN_FRAME_DSCR, link);

    /* fill out the header. in both cases - chain
       the necessary buffer descriptors to the packet */

    {
        PVOID         address = NULL;
        ULONG         size = 0;

        UNIV_ASSERT_VAL (frame_type == MAIN_PACKET_TYPE_PING ||
                 frame_type == MAIN_PACKET_TYPE_IGMP ||
                 frame_type == MAIN_PACKET_TYPE_IDHB,
                 frame_type);

            /* V2.0.6, V2.2 moved here */

        /* Differentiate between igmp and heartbeat messages and allocate buffers */
        if (frame_type == MAIN_PACKET_TYPE_PING)
        {
            size = sizeof (PING_MSG);
            address = (PVOID)(ctxtp -> load_msgp);
        }
        else if (frame_type == MAIN_PACKET_TYPE_IGMP)
        {
            size = sizeof (MAIN_IGMP_FRAME);
            address = (PVOID) (& ctxtp -> igmp_frame);
        }
        else if (frame_type == MAIN_PACKET_TYPE_IDHB)
        {
            /* Not grabbing lock; if anything we screw up the size relative to the
               content of the heartbeat and we send out a garbage packet. But the
               memory is always valid. */
            size = ctxtp->idhb_size;
            address = (PVOID) (&ctxtp->idhb_msg);
        }
        else
        {
            UNIV_PRINT_CRIT(("Main_frame_get: Invalid frame type passed to Main_frame_get 0x%x", frame_type));
            TRACE_CRIT("%!FUNC! Invalid frame type passed to Main_frame_get 0x%x", frame_type);
            UNIV_ASSERT(0);
        }

        /* Allocate the buffer for sending the data */
        if (size > 0)
        {
            NdisAllocateBuffer (& status, & dscrp -> send_data_bufp,
                        ctxtp -> frame_buf_pool_handle,
                        address, size);
        }
        else
        {
            status = NDIS_STATUS_FAILURE;
        }

        if (status != NDIS_STATUS_SUCCESS)
        {
            if (size > 0)
            {
                UNIV_PRINT_CRIT(("Main_frame_get: Failed to allocate buffer for 0x%x", frame_type));
                TRACE_CRIT("%!FUNC! Failed to allocate buffer for 0x%x", frame_type);
            }

            dscrp -> send_data_bufp = NULL;

            NdisAcquireSpinLock (& ctxtp -> frame_lock);
            InsertTailList (& ctxtp -> frame_list, & dscrp -> link);
            NdisReleaseSpinLock (& ctxtp -> frame_lock);

            ctxtp->cntr_frame_no_buf++;

            NdisFreePacket (packet);
            return NULL;
        }

        /* since packet length is always the same, and so are destination
           and source addresses - can use generic media header */

        if (frame_type == MAIN_PACKET_TYPE_PING)
        {
            dscrp -> media_hdr               = ctxtp -> media_hdr;

            dscrp -> frame_hdr . code        = MAIN_FRAME_CODE;
            dscrp -> frame_hdr . version     = CVY_VERSION_FULL;
            dscrp -> frame_hdr . host        = (UCHAR) ctxtp -> params . host_priority;
            dscrp -> frame_hdr . cl_ip_addr  = ctxtp -> cl_ip_addr;
            dscrp -> frame_hdr . ded_ip_addr = ctxtp -> ded_ip_addr;

            NdisChainBufferAtFront (packet, dscrp -> send_data_bufp); /* V1.1.4 */
            NdisChainBufferAtFront (packet, dscrp -> frame_hdr_bufp);
        }
        else if (frame_type == MAIN_PACKET_TYPE_IGMP)
        {
            dscrp -> media_hdr               = ctxtp -> media_hdr_igmp;
            NdisChainBufferAtFront (packet, dscrp -> send_data_bufp); /* V1.1.4 */
        }
        else if (frame_type == MAIN_PACKET_TYPE_IDHB)
        {
            dscrp->media_hdr             = ctxtp->media_hdr;

            dscrp->frame_hdr.code        = MAIN_FRAME_EX_CODE;
            dscrp->frame_hdr.version     = CVY_VERSION_FULL;
            dscrp->frame_hdr.host        = (UCHAR) ctxtp->params.host_priority;
            dscrp->frame_hdr.cl_ip_addr  = ctxtp->cl_ip_addr;
            dscrp->frame_hdr.ded_ip_addr = ctxtp->ded_ip_addr;

            NdisChainBufferAtFront(packet, dscrp->send_data_bufp);
            NdisChainBufferAtFront(packet, dscrp->frame_hdr_bufp);
        }
        else
        {
            UNIV_PRINT_CRIT(("Main_frame_get: Invalid frame type passed to Main_frame_get 0x%x", frame_type));
            TRACE_CRIT("%!FUNC! Invalid frame type passed to Main_frame_get 0x%x", frame_type);
            UNIV_ASSERT(0);
        }

        NdisChainBufferAtFront (packet, dscrp -> media_hdr_bufp);
    }

    /* fill out protocol reserved fields */

    /* Again, since these packets are hidden from upper layers, we should
       be OK using the protocol reserved field regardless of send/receive. */

    resp = MAIN_PROTOCOL_FIELD (packet);
    resp -> type   = frame_type;
    resp -> miscp  = dscrp;
    resp -> data   = 0;
    resp -> len    = 0;
    resp -> group  = 0;

    * lenp = dscrp -> recv_len;

    NdisInterlockedIncrement(&ctxtp->num_frames_out);

    return packet;

} /* end Main_frame_get */


VOID Main_frame_put (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet,
    PMAIN_FRAME_DSCR    dscrp)
{
    PNDIS_BUFFER        bufp;

    /* Again, since these packets are hidden from upper layers, we should
       be OK using the protocol reserved field regardless of send/receive. */

    PMAIN_PROTOCOL_RESERVED resp = MAIN_PROTOCOL_FIELD (packet);

    UNIV_ASSERT_VAL (resp -> type == MAIN_PACKET_TYPE_PING ||
                     resp -> type == MAIN_PACKET_TYPE_IGMP ||
                     resp -> type == MAIN_PACKET_TYPE_IDHB,
                     resp -> type);

    /* strip buffers from the packet buffer chain */

    do
    {
        NdisUnchainBufferAtFront (packet, & bufp);
    }
    while (bufp != NULL);

    /* recyle the packet */

    NdisReinitializePacket (packet);

    NdisFreePacket (packet);

    /* If the send buffer is not null, free this buffer */

    if (dscrp -> send_data_bufp != NULL)
    {
        NdisFreeBuffer (dscrp -> send_data_bufp);
        dscrp -> send_data_bufp = NULL;
    }
    /* put frame descriptor back on the free list */

    NdisAcquireSpinLock (& ctxtp -> frame_lock);
    InsertTailList (& ctxtp -> frame_list, & dscrp -> link);
    NdisReleaseSpinLock (& ctxtp -> frame_lock);

    NdisInterlockedDecrement(&ctxtp->num_frames_out);

} /* end Main_frame_return */


PNDIS_PACKET Main_packet_alloc (
    PMAIN_CTXT              ctxtp,
    ULONG                   send,
    PULONG                  low)
{
    PNDIS_PACKET            newp = NULL;
    PNDIS_HANDLE            poolh;
    ULONG                   i, max, size, start;
    NDIS_STATUS             status;
    PNDIS_PACKET_STACK      pktstk;
    BOOLEAN                 stack_left;


    /* !!! assume that recv and send paths are not re-entrant, otherwise need
       to lock this. make sure that NdisAllocatePacket... routines are not
       called holding a spin lock */

    /* V1.1.2 */
    *low = FALSE;

    if (send)
    {
        poolh = ctxtp -> send_pool_handle;

        NdisAcquireSpinLock (& ctxtp -> send_lock);
        max   = ctxtp -> num_send_packet_allocs;
        start = ctxtp -> cur_send_packet_pool;
        ctxtp -> cur_send_packet_pool = (start + 1) % max;
        NdisReleaseSpinLock (& ctxtp -> send_lock);
    }
    else
    {
        poolh = ctxtp -> recv_pool_handle;

        NdisAcquireSpinLock (& ctxtp -> recv_lock);
        max   = ctxtp -> num_recv_packet_allocs;
        start = ctxtp -> cur_recv_packet_pool;
        ctxtp -> cur_recv_packet_pool = (start + 1) % max;
        NdisReleaseSpinLock (& ctxtp -> recv_lock);
    }

    /* Try to allocate a packet from the existing packet pools */
    i = start;

    do
    {
        NdisAllocatePacket (& status, & newp, poolh [i]);

        if (status == NDIS_STATUS_SUCCESS)
        {
            /* #ps# -- ramkrish */
            pktstk = NdisIMGetCurrentPacketStack (newp, & stack_left);

            if (pktstk)
            {
                MAIN_IMRESERVED_FIELD (pktstk) = NULL;
            }

            /* Make sure that the MiniportReserved field is initially NULL. */
            MAIN_MINIPORT_FIELD(newp) = NULL;

            if (send)
            {
                NdisAcquireSpinLock (& ctxtp -> send_lock);

                /* Because the decrement is interlocked, so should the increment. */
                NdisInterlockedIncrement(& ctxtp -> num_sends_out);

                if ((ctxtp -> num_sends_alloced - ctxtp -> num_sends_out)
                    < (ctxtp -> num_packets / 2))
                {
                    NdisReleaseSpinLock (& ctxtp -> send_lock);
                    break;
                }
                NdisReleaseSpinLock (& ctxtp -> send_lock);
            }
            else
            {
                NdisAcquireSpinLock (& ctxtp -> recv_lock);

                /* Because the decrement is interlocked, so should the increment. */
                NdisInterlockedIncrement(& ctxtp -> num_recvs_out);

                if ((ctxtp -> num_recvs_alloced - ctxtp -> num_recvs_out)
                    < (ctxtp -> num_packets / 2))
                {
                    NdisReleaseSpinLock (& ctxtp -> recv_lock);
                    break;
                }
                NdisReleaseSpinLock (& ctxtp -> recv_lock);
            }

            return newp;
        }

        /* pick the next pool to improve number of tries until we get something */

        i = (i + 1) % max;

    } while (i != start);

    /* At this point, the high level mark has been reached, so allocate a new packet pool */

    if (send)
    {
        NdisAcquireSpinLock (& ctxtp -> send_lock);

        if (ctxtp -> num_send_packet_allocs >= CVY_MAX_ALLOCS)
        {
            * low = TRUE;
            NdisReleaseSpinLock (& ctxtp -> send_lock);
            return newp;
        }

        if (ctxtp -> send_allocing)
        {
            * low = TRUE; /* do not know whether the allocation by another thread will succeed or not */
            NdisReleaseSpinLock (& ctxtp -> send_lock);
            return newp;
        }
        else
        {
            max = ctxtp -> num_send_packet_allocs;
            ctxtp -> send_allocing = TRUE;
            NdisReleaseSpinLock (& ctxtp -> send_lock);
        }
    }
    else
    {
        NdisAcquireSpinLock (& ctxtp -> recv_lock);

        if (ctxtp -> num_recv_packet_allocs >= CVY_MAX_ALLOCS)
        {
            * low = TRUE;
            NdisReleaseSpinLock (& ctxtp -> recv_lock);
            return newp;
        }

        if (ctxtp -> recv_allocing)
        {
            * low = TRUE; /* do not know whether the allocation by another thread will succeed or not */
            NdisReleaseSpinLock (& ctxtp -> recv_lock);
            return newp;
        }
        else
        {
            max = ctxtp -> num_recv_packet_allocs;
            ctxtp -> recv_allocing = TRUE;
            NdisReleaseSpinLock (& ctxtp -> recv_lock);
        }
    }

    /* Due to the send_allocing and recv_allocing flag, at most 1 send or recv thread will be in this portion at any time */
    size = ctxtp -> num_packets;

    NdisAllocatePacketPool (& status, & (poolh [max]),
                            ctxtp -> num_packets,
                            sizeof (MAIN_PROTOCOL_RESERVED));

    if (status != NDIS_STATUS_SUCCESS)
    {
        if (send)
        {
            UNIV_PRINT_CRIT(("Main_packet_alloc: Error allocating send packet pool %d %x", size, status));
            TRACE_CRIT("%!FUNC! Error allocating send packet pool %d 0x%x", size, status);
        }
        else
        {
            UNIV_PRINT_CRIT(("Main_packet_alloc: Error allocating recv packet pool %d %x", size, status));
            TRACE_CRIT("%!FUNC! Error allocating recv packet pool %d %x", size, status);
        }

        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        * low = TRUE;
    }
    else
    {
        if (send)
        {
            NdisAcquireSpinLock (& ctxtp -> send_lock);
            ctxtp -> num_send_packet_allocs ++;
            ctxtp -> num_sends_alloced += ctxtp -> num_packets;
            ctxtp -> send_allocing = FALSE;
            NdisReleaseSpinLock (& ctxtp -> send_lock);
        }
        else
        {
            NdisAcquireSpinLock (& ctxtp -> recv_lock);
            ctxtp -> num_recv_packet_allocs ++;
            ctxtp -> num_recvs_alloced += ctxtp -> num_packets;
            ctxtp -> recv_allocing = FALSE;
            NdisReleaseSpinLock (& ctxtp -> recv_lock);
        }

        * low = FALSE;
    }

    return newp;
} /* Main_packet_alloc */

PNDIS_PACKET Main_packet_get (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packet,
    ULONG                   send,
    USHORT                  group,
    ULONG                   len)
{
    PNDIS_PACKET            newp;
    PMAIN_PROTOCOL_RESERVED resp = NULL;
    ULONG                   packet_lowmark;
    PNDIS_PACKET_STACK      pktstk = NULL;
    BOOLEAN                 stack_left;

    pktstk = NdisIMGetCurrentPacketStack(packet, &stack_left);

    if (stack_left)
    {
        resp = (PMAIN_PROTOCOL_RESERVED)NdisAllocateFromNPagedLookasideList(&ctxtp->resp_list);

        MAIN_IMRESERVED_FIELD(pktstk) = resp;

        if (resp)
        {
            resp->type   = MAIN_PACKET_TYPE_PASS;
            resp->miscp  = packet;
            resp->data   = 0;
            resp->group  = group;
            resp->len    = len;

            return packet;
        }
    }
        
    /* If this is a receive, then we are using MiniportReserved and must allocate a 
       buffer to hold our private data.  If it fails, bail out and dump the packet. */
    if (!send) {
        resp = (PMAIN_PROTOCOL_RESERVED) NdisAllocateFromNPagedLookasideList(&ctxtp->resp_list);

        if (!resp)
        {
            return NULL;
        }
    }

    /* Get a packet. */
    newp = Main_packet_alloc(ctxtp, send, &packet_lowmark);

    if (newp == NULL) {
        /* If packet allocation fails, put the resp buffer back on the list if this is a receive. */
        if (resp) NdisFreeToNPagedLookasideList(&ctxtp->resp_list, resp);

        return NULL;
    }

    pktstk = NdisIMGetCurrentPacketStack(newp, &stack_left);

    if (pktstk)
    {
        MAIN_IMRESERVED_FIELD(pktstk) = NULL;
    }

    /* Make sure that the MiniportReserved field is initially NULL. */
    MAIN_MINIPORT_FIELD(newp) = NULL;

    /* Make new packet resemble the outside one. */
    if (send)
    {
        PVOID media_info = NULL;
        ULONG media_info_size = 0;


        newp->Private.Head = packet->Private.Head;
        newp->Private.Tail = packet->Private.Tail;

        NdisGetPacketFlags(newp) = NdisGetPacketFlags(packet);

        NdisSetPacketFlags(newp, NDIS_FLAGS_DONT_LOOPBACK);

        // Copy the OOB Offset from the original packet to the new packet.
        NdisMoveMemory(NDIS_OOB_DATA_FROM_PACKET(newp),
                       NDIS_OOB_DATA_FROM_PACKET(packet),
                       sizeof(NDIS_PACKET_OOB_DATA));

        // Copy the per packet info into the new packet
        NdisIMCopySendPerPacketInfo(newp, packet);

        // Copy the Media specific information
        NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(packet, &media_info, &media_info_size);

        if (media_info != NULL || media_info_size != 0)
        {
            NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(newp, media_info, media_info_size);
        }
    }
    else
    {
        newp->Private.Head = packet->Private.Head;
        newp->Private.Tail = packet->Private.Tail;

        // Get the original packet(it could be the same packet as one received or a different one
        // based on # of layered MPs) and set it on the indicated packet so the OOB stuff is visible
        // correctly at the top.

        NDIS_SET_ORIGINAL_PACKET(newp, NDIS_GET_ORIGINAL_PACKET(packet));
        NDIS_SET_PACKET_HEADER_SIZE(newp, NDIS_GET_PACKET_HEADER_SIZE(packet));
        NdisGetPacketFlags(newp) = NdisGetPacketFlags(packet);

        if (packet_lowmark)
            NDIS_SET_PACKET_STATUS(newp, NDIS_STATUS_RESOURCES);
        else
            NDIS_SET_PACKET_STATUS(newp, NDIS_GET_PACKET_STATUS(packet));
    }

    /* Fill out reserved field. */

    /* Sends should use ProtocolReserved and receives should use MiniportReserved.  Buffer
       space for MiniportReserved is allocated further up in this function. */
    if (send) { 
        resp = MAIN_PROTOCOL_FIELD(newp);
    } else { 
        MAIN_MINIPORT_FIELD(newp) = resp;
    }

    resp->type   = MAIN_PACKET_TYPE_PASS;
    resp->miscp  = packet;
    resp->data   = 0;
    resp->group  = group;
    resp->len    = len;

    return newp;

} /* end Main_packet_get*/


PNDIS_PACKET Main_packet_put (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packet,
    ULONG                   send,
    NDIS_STATUS             status)
{
    PNDIS_PACKET            oldp = NULL;
    PNDIS_PACKET_STACK      pktstk;
    BOOLEAN                 stack_left;
    PMAIN_PROTOCOL_RESERVED resp;
    PMAIN_BUFFER            bp;
    PNDIS_BUFFER            bufp;

    MAIN_RESP_FIELD(packet, stack_left, pktstk, resp, send);

    UNIV_ASSERT(resp);

    /* Because CTRL packets are actually allocated on the receive path,
       we need to change the send flag to false to get the logic right. */
    if (resp->type == MAIN_PACKET_TYPE_CTRL) 
    {
        UNIV_ASSERT(send);
        send = FALSE;
    }

    if (send)
    {
        if (status == NDIS_STATUS_SUCCESS)
        {
            ctxtp->cntr_xmit_ok++;

            switch (resp->group)
            {
                case MAIN_FRAME_DIRECTED:
                    ctxtp->cntr_xmit_frames_dir++;
                    ctxtp->cntr_xmit_bytes_dir += (ULONGLONG)(resp->len);
                    break;

                case MAIN_FRAME_MULTICAST:
                    ctxtp->cntr_xmit_frames_mcast++;
                    ctxtp->cntr_xmit_bytes_mcast += (ULONGLONG)(resp->len);
                    break;

                case MAIN_FRAME_BROADCAST:
                    ctxtp->cntr_xmit_frames_bcast++;
                    ctxtp->cntr_xmit_bytes_bcast += (ULONGLONG)(resp->len);
                    break;

                default:
                    break;
            }
        }
        else
        {
            ctxtp->cntr_xmit_err++;
        }
    }
    else
    {
        if (status == NDIS_STATUS_SUCCESS)
        {
            ctxtp->cntr_recv_ok++;

            switch (resp->group)
            {
                case MAIN_FRAME_DIRECTED:
                    ctxtp->cntr_recv_frames_dir++;
                    ctxtp->cntr_recv_bytes_dir += (ULONGLONG)(resp->len);
                    break;

                case MAIN_FRAME_MULTICAST:
                    ctxtp->cntr_recv_frames_mcast++;
                    ctxtp->cntr_recv_bytes_mcast += (ULONGLONG)(resp->len);
                    break;

                case MAIN_FRAME_BROADCAST:
                    ctxtp->cntr_recv_frames_bcast++;
                    ctxtp->cntr_recv_bytes_bcast += (ULONGLONG)(resp->len);
                    break;

                default:
                    break;
            }
        }
        else
        {
            ctxtp->cntr_recv_err++;
        }
    }

    /* If this is our packet and buffers. */
    if (resp->type == MAIN_PACKET_TYPE_CTRL)
    {
        /* Strip buffers from the packet buffer chain. */
        NdisUnchainBufferAtFront(packet, &bufp);

        /* Grab the buffer pointer from the private packet data. */
        bp = (PMAIN_BUFFER)resp->miscp;

        UNIV_ASSERT(bp->code == MAIN_BUFFER_CODE);

        NdisAcquireSpinLock(&ctxtp->buf_lock);

        /* Decrement the number of outstanding buffers. */
        ctxtp->num_bufs_out--;

        /* Put the buffer back on our free buffer list. */
        InsertTailList(&ctxtp->buf_list, &bp->link);

        NdisReleaseSpinLock(&ctxtp->buf_lock);
    }
    else
    {
        UNIV_ASSERT_VAL(resp->type == MAIN_PACKET_TYPE_PASS || resp->type == MAIN_PACKET_TYPE_TRANSFER, resp->type);

        oldp = (PNDIS_PACKET)resp->miscp;

        /* If the old packet is the same as this packet, then we were using
           NDIS packet stacking to hold our private data.  In this case, we
           ALWAYS need to free the resp buffer back to our list. */
        if (oldp == packet)
        {
            /* Since we re-use these private data buffers, re-initialize the packet type. */
            resp->type = MAIN_PACKET_TYPE_NONE;

            NdisFreeToNPagedLookasideList(&ctxtp->resp_list, resp);

            /* Return the packet. */
            return packet;
        }

        if (send)
        {
            /* Copy the send complete information from the packet to the original packet. */
            NdisIMCopySendCompletePerPacketInfo(oldp, packet);
        }
        /* It used to be that if a new packet was allocated, we always used 
           protocol reseved, so there was never a need to free our private
           buffer (it was part of the packet itself).  However, now in the 
           case where packet != oldp (we allocated a new packet) we may have
           to free the private data buffer.  If we allocate a packet on the
           send path, we play the part of protocol and use the protocol
           reserved field, which is the former behavior.  However, if we 
           allocate a packet on the receive path, we pull a resp buffer off
           of our lookaside list and store a pointer in the miniport reserved
           field of the packet.  Therefore, if this is the completion of a 
           receive, free the private buffer. */
        else
        {
            /* Since we re-use these private data buffers, re-initialize the packet type. */
            resp->type = MAIN_PACKET_TYPE_NONE;

            NdisFreeToNPagedLookasideList(&ctxtp->resp_list, resp);
        }
    }

    /* These conters ONLY count outstanding allocated packets - for resource tracking. */
    if (send)
        NdisInterlockedDecrement(&ctxtp->num_sends_out);
    else
        NdisInterlockedDecrement(&ctxtp->num_recvs_out);

    /* Re-initialize our packet. */
    NdisReinitializePacket(packet);

    /* Free our packet back to the pool. */
    NdisFreePacket(packet);

    /* Return oldp, which should indicate to the caller (the fact that packet !=  oldp) 
       that oldp, which is the original packet, should be "returned" to miniport. */
    return oldp;
}

/* 
 * Function: Main_purge_connection_state
 * Desctription: This function is called as the result of a work item callback and
 *               is used to clean out potentially stale connection descriptors.  This 
 *               must be done in an NDIS work item because many operations herein
 *               MUST occur at <= PASSIVE_LEVEL, so we can't do this inline, where
 *               much of our code runs at DISPATCH_LEVEL.
 * Parameters: pWorkItem - the NDIS work item pointer
 *             nlbctxt - the context for the callback; this is our MAIN_CTXT pointer
 * Returns: Nothing
 * Author: shouse, 10.4.01
 * Notes: Note that the code that sets up this work item MUST increment the reference
 *        count on the adapter context BEFORE adding the work item to the queue.  This
 *        ensures that when this callback is executed, the context will stiil be valid,
 *        even if an unbind operation is pending.  This function must free the work
 *        item memory and decrement the reference count - both, whether this function
 *        can successfully complete its task OR NOT.
 */
VOID Main_purge_connection_state (PNDIS_WORK_ITEM pWorkItem, PVOID nlbctxt) {
    KIRQL             Irql;
    ULONG             ServerIP;
    ULONG             ServerPort;
    ULONG             ClientIP;
    ULONG             ClientPort;
    USHORT            Protocol;
    BOOLEAN           Success = FALSE;
    ULONG             Count = 0;
    NTSTATUS          Status;
    UNICODE_STRING    Driver;
    OBJECT_ATTRIBUTES Attrib;
    IO_STATUS_BLOCK   IOStatusBlock;
    HANDLE            TCPHandle;
    PMAIN_CTXT        ctxtp = (PMAIN_CTXT)nlbctxt;

    TRACE_VERB("%!FUNC! Enter: Cleaning out stale connection descriptors, ctxtp = %p", ctxtp);

    /* Do a sanity check on the context - make sure that the MAIN_CTXT code is correct. */
    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

    /* Might as well free the work item now - we don't need it. */
    if (pWorkItem)
        NdisFreeMemory(pWorkItem, sizeof(NDIS_WORK_ITEM), 0);

    /* This shouldn't happen, but protect against it anyway - we cannot manipulate
       the registry if we are at an IRQL > PASSIVE_LEVEL, so bail out. */
    if ((Irql = KeGetCurrentIrql()) > PASSIVE_LEVEL) {
        TRACE_CRIT("%!FUNC! Error: IRQL (%u) > PASSIVE_LEVEL (%u) ... Exiting...", Irql, PASSIVE_LEVEL);
        goto exit;
    }

    /* Initialize the device driver device string. */
    RtlInitUnicodeString(&Driver, DD_TCP_DEVICE_NAME);
    
    InitializeObjectAttributes(&Attrib, &Driver, OBJ_CASE_INSENSITIVE, NULL, NULL);
    
    /* Open a handle to the device. */
    Status = ZwCreateFile(&TCPHandle, SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA, &Attrib, &IOStatusBlock, NULL, 
                          FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF, 0, NULL, 0);
    
    if (!NT_SUCCESS(Status)) {
        /* We're running at PASSIVE_LEVEL, so %ls is ok. */
        TRACE_CRIT("%!FUNC! Error: Unable to open %ls, error = 0x%08x", DD_TCP_DEVICE_NAME, Status);
        goto exit;
    }

    /* Get the IP tuple information for the descriptor at the head of the recovery queue from the load module. */
    Success = Main_conn_get(ctxtp, &ServerIP, &ServerPort, &ClientIP, &ClientPort, &Protocol);

    /* As long as there are descriptors to check, at we have serviced the maximum number
       allowed, continue to check descriptors for validity. */
    while (Success && (Count < CVY_DEF_DSCR_PURGE_LIMIT)) {
        switch (Protocol) {
        case TCPIP_PROTOCOL_TCP:
        case TCPIP_PROTOCOL_PPTP:
        {
            TCP_FINDTCB_REQUEST  Request;
            TCP_FINDTCB_RESPONSE Response;

            TRACE_VERB("%!FUNC! Querying TCP for the state of: %u.%u.%u.%u:%u <-> %u.%u.%u.%u:%u",
                       IP_GET_OCTET(ServerIP, 0), IP_GET_OCTET(ServerIP, 1), IP_GET_OCTET(ServerIP, 2), IP_GET_OCTET(ServerIP, 3), ServerPort,
                       IP_GET_OCTET(ClientIP, 0), IP_GET_OCTET(ClientIP, 1), IP_GET_OCTET(ClientIP, 2), IP_GET_OCTET(ClientIP, 3), ClientPort);
            
            /* If this is a TCP connection and we're not cleaning up TCP connection state, bail out now. */
            if (!NLB_TCP_CLEANUP_ON()) {
                /* We are not purging this type of descriptor, so move on. */
                TRACE_VERB("%!FUNC! TCP connection purging disabled");
                
                /* Sanction the existing descriptor by moving to the tail of the recovery queue.  Note that this too can
                   fail if the connection has been torn-down since we got this information from the load module. */
                Success = Main_conn_sanction(ctxtp, ServerIP, ServerPort, ClientIP, ClientPort, Protocol);
                
                if (Success) {
                    TRACE_VERB("%!FUNC! Descriptor sanctioned by default");
                } else {
                    TRACE_VERB("%!FUNC! Unable to sanction descriptor - not found or in time-out");
                }
                
                break;
            }

            /* Fill in the request structure - ports are USHORTs and must be converted to network byte order. */
            Request.Src = ServerIP;
            Request.Dest = ClientIP;
            Request.SrcPort = HTONS(ServerPort);
            Request.DestPort = HTONS(ClientPort);
            
            /* Send an IOCTL to the TCP driver asking it for the TCB information for the associated IP tuple. */
            Status = ZwDeviceIoControlFile(TCPHandle, NULL, NULL, NULL, &IOStatusBlock, IOCTL_TCP_FINDTCB, &Request, sizeof(Request), &Response, sizeof(Response));           

            switch (Status) {
            case STATUS_NOT_FOUND:
                /* TCP does not have state for this IP tuple - must be we've gotten out of SYNC. */
                TRACE_VERB("%!FUNC! ZwDeviceIoControlFile returned STATUS_NOT_FOUND (%08x)", Status);
                
                /* Destroy our descriptor if TCP has no state for this connection.  Note that this CAN fail if the 
                   descriptor has disappeared since we queried the load module for the tuple information because
                   we cannot hold any locks while we query TCP.  Further, it is also possible, yet unlikely, that 
                   the connection has gone away since we got the information from the load module AND re-established 
                   itself since TCP told us it had no state for this tuple; in that case, we'll be destroying a valid
                   connection descriptor here, but since its VERY unlikely, we'll live with it. */
#if defined (NLB_TCP_NOTIFICATION)
                if (NLB_NOTIFICATIONS_ON())
                {
                    Success = Main_conn_down(ServerIP, ServerPort, ClientIP, ClientPort, Protocol, CVY_CONN_RESET);
                }
                else
                {
#endif
#if defined (NLB_HOOK_ENABLE)
                    Success = Main_conn_notify(ctxtp, ServerIP, ServerPort, ClientIP, ClientPort, Protocol, CVY_CONN_RESET, NLB_FILTER_HOOK_PROCEED_WITH_HASH);
#else
                    Success = Main_conn_notify(ctxtp, ServerIP, ServerPort, ClientIP, ClientPort, Protocol, CVY_CONN_RESET);
#endif
#if defined (NLB_TCP_NOTIFICATION)
                }
#endif
                
                if (Success) {
                    /* Increment the count of connections we've had to purge because we got out of sync with TCP/IP.
                       Now that we're getting explicit notifications from TCP/IP, we expect this number to remain
                       VERY close to zero.  Because of timing conditions between getting the information from the 
                       load module, querying TCP/IP and subsequently destroying the state, we only want to increment
                       this counter in cases where we actually SUCCEEDED in destroying TCP connection state. */
                    ctxtp->num_purged++;
                    
                    TRACE_VERB("%!FUNC! Descriptor destroyed - no upper layer state exists");
                } else {
                    TRACE_VERB("%!FUNC! Unable to destroy descriptor - not found");
                }
                
                break;
            case STATUS_SUCCESS:
                /* TCP has an active connection matching this IP tuple - this should be the overwhelmingly common case. */
                TRACE_VERB("%!FUNC! ZwDeviceIoControlFile returned STATUS_SUCCESS (%08x)", Status);
                
                /* Sanction the existing descriptor by moving to the tail of the recovery queue.  Note that this too can
                   fail if the connection has been torn-down since we got this information from the load module. */
                Success = Main_conn_sanction(ctxtp, ServerIP, ServerPort, ClientIP, ClientPort, Protocol);
                
                if (Success) {
                    TRACE_VERB("%!FUNC! Descriptor sanctioned - upper layer state exists");
                } else {
                    TRACE_VERB("%!FUNC! Unable to sanction descriptor - not found or in time-out");
                }
                
                break;
            case STATUS_INVALID_PARAMETER:
                /* There was a parameter error.  Loop around and try again. */
                TRACE_VERB("%!FUNC! ZwDeviceIoControlFile returned STATUS_INVALID_PARAMETER (%08x)", Status);
                break;
            default:
                /* Something else went wrong.  Loop around and try again. */
                TRACE_VERB("%!FUNC! ZwDeviceIoControlFile returned UNKNOWN (%08x)", Status);
                break;
            }
            
                break;
        }
        default:
            /* We cannot purge this type of descriptor, so move on. */
            TRACE_VERB("%!FUNC! Cannot purge protocol %u descriptors", Protocol);

            /* Sanction the existing descriptor by moving to the tail of the recovery queue.  Note that this too can
               fail if the connection has been torn-down since we got this information from the load module. */
            Success = Main_conn_sanction(ctxtp, ServerIP, ServerPort, ClientIP, ClientPort, Protocol);

            if (Success) {
                TRACE_VERB("%!FUNC! Descriptor sanctioned by default");
            } else {
                TRACE_VERB("%!FUNC! Unable to sanction descriptor - not found or in time-out");
            }

            break;
        }

        /* Increment the number of descriptors serviced in this work item. */
        Count++;

        /* Get the IP tuple information for the descriptor at the head of the recovery queue from the load module. */
        Success = Main_conn_get(ctxtp, &ServerIP, &ServerPort, &ClientIP, &ClientPort, &Protocol);
    }

    /* Close the TCP device handle. */
    ZwClose(TCPHandle);

 exit:

    /* Release the reference on the context - this reference count was incremented
       by the code that setup this work item callback. */
    Main_release_reference(ctxtp);

    TRACE_VERB("%!FUNC! Exit");

    return;
}

#if defined (NLB_HOOK_TEST_ENABLE)

VOID Main_deregister_callback1 (PWCHAR hook, HANDLE registrar, ULONG flags)
{
    TRACE_INFO("Deregistering test hook 1...");
    return;
}

VOID Main_deregister_callback2 (PWCHAR hook, HANDLE registrar, ULONG flags)
{
    TRACE_INFO("Deregistering test hook 2...");
    return;
}

NLB_FILTER_HOOK_DIRECTIVE Main_test_hook1 (
    const WCHAR *       pAdapter,                                                /* The GUID of the adapter on which the packet was sent/received. */
    const NDIS_PACKET * pPacket,                                                 /* A pointer to the Ndis packet, which CAN be NULL if not available. */
    const UCHAR *       pMediaHeader,                                            /* A pointer to the media header (ethernet, since NLB supports only ethernet). */
    ULONG               cMediaHeaderLength,                                      /* The length of contiguous memory accessible from the media header pointer. */
    const UCHAR *       pPayload,                                                /* A pointer to the payload of the packet. */
    ULONG               cPayloadLength,                                          /* The length of contiguous memory accesible from the payload pointer. */
    ULONG               Flags                                                    /* Hook-related flags including whether or not the cluster is stopped. */
)                                        
{
    TRACE_INFO("%!FUNC! Inside test hook 1");
    
    if (Flags & NLB_FILTER_HOOK_FLAGS_DRAINING)
    {
        TRACE_INFO("%!FUNC! This host is DRAINING...");
    }
    else if (Flags & NLB_FILTER_HOOK_FLAGS_STOPPED)
    {
        TRACE_INFO("%!FUNC! This host is STOPPED...");
    }

    return NLB_FILTER_HOOK_PROCEED_WITH_HASH;
}

NLB_FILTER_HOOK_DIRECTIVE Main_test_hook2 (
    const WCHAR *       pAdapter,                                                /* The GUID of the adapter on which the packet was sent/received. */
    const NDIS_PACKET * pPacket,                                                 /* A pointer to the Ndis packet, which CAN be NULL if not available. */
    const UCHAR *       pMediaHeader,                                            /* A pointer to the media header (ethernet, since NLB supports only ethernet). */
    ULONG               cMediaHeaderLength,                                      /* The length of contiguous memory accessible from the media header pointer. */
    const UCHAR *       pPayload,                                                /* A pointer to the payload of the packet. */
    ULONG               cPayloadLength,                                          /* The length of contiguous memory accesible from the payload pointer. */
    ULONG               Flags                                                    /* Hook-related flags including whether or not the cluster is stopped. */
)                                        
{
    TRACE_INFO("%!FUNC! Inside test hook 2");
    
    if (Flags & NLB_FILTER_HOOK_FLAGS_DRAINING)
    {
        TRACE_INFO("%!FUNC! This host is DRAINING...");
    }
    else if (Flags & NLB_FILTER_HOOK_FLAGS_STOPPED)
    {
        TRACE_INFO("%!FUNC! This host is STOPPED...");
    }

    return NLB_FILTER_HOOK_PROCEED_WITH_HASH;
}

NLB_FILTER_HOOK_DIRECTIVE Main_test_query_hook (
    const WCHAR *       pAdapter,                                                /* The GUID of the adapter on which the packet was sent/received. */
    ULONG               ServerIPAddress,                                         /* The server IP address of the "packet" in NETWORK byte order. */
    USHORT              ServerPort,                                              /* The server port of the "packet" (if applicable to the Protocol) in HOST byte order. */
    ULONG               ClientIPAddress,                                         /* The client IP address of the "packet" in NETWORK byte order. */
    USHORT              ClientPort,                                              /* The client port of the "packet" (if applicable to the Protocol) in HOST byte order. */
    UCHAR               Protocol,                                                /* The IP protocol of the "packet"; TCP, UDP, ICMP, GRE, etc. */
    BOOLEAN             ReceiveContext,                                          /* A boolean to indicate whether the packet is being processed in send or receive context. */
    ULONG               Flags                                                    /* Hook-related flags including whether or not the cluster is stopped. */
)
{
    TRACE_INFO("%!FUNC! Inside test query hook");
    
    if (Flags & NLB_FILTER_HOOK_FLAGS_DRAINING)
    {
        TRACE_INFO("%!FUNC! This host is DRAINING...");
    }
    else if (Flags & NLB_FILTER_HOOK_FLAGS_STOPPED)
    {
        TRACE_INFO("%!FUNC! This host is STOPPED...");
    }

    return NLB_FILTER_HOOK_PROCEED_WITH_HASH;
}

VOID Main_test_hook_register (HANDLE NLBHandle, IO_STATUS_BLOCK IOBlock, NLBReceiveFilterHook pfnHook, NLBHookDeregister pfnDereg, BOOLEAN deregister)
{
    NLB_IOCTL_REGISTER_HOOK_REQUEST Request;
    NLB_FILTER_HOOK_TABLE           HookTable;
    NTSTATUS                        Status;
    static ULONG                    Failure = 0;

    /* Set the hook identifier to the filter hook GUID. */
    NdisMoveMemory(Request.HookIdentifier, NLB_FILTER_HOOK_INTERFACE, sizeof(WCHAR) * wcslen(NLB_FILTER_HOOK_INTERFACE));
    Request.HookIdentifier[NLB_HOOK_IDENTIFIER_LENGTH] = 0;

    /* Set the owner to our open handle on the device driver. */
    Request.RegisteringEntity = NLBHandle;

    /* Just print some debug information. */
    if (pfnHook == Main_test_hook1) {
        if (deregister) {
            TRACE_INFO("%!FUNC! De-registering test hook 1");
        } else {
            TRACE_INFO("%!FUNC! Registering test hook 1");
        }
    } else {
        if (deregister) {
            TRACE_INFO("%!FUNC! De-registering test hook 2");
        } else {
            TRACE_INFO("%!FUNC! Registering test hook 2");
        }
    }

    /* Set function pointers appropriately. */
    if (deregister) {
        /* If this is a de-register operation, we need to set the hook
           function table pointer to NULL. */
        Request.DeregisterCallback = NULL;
        Request.HookTable          = NULL;
    } else {
        /* Otherwise, we need to set the hook table to the address of a hook 
           table that we've allocated and fill in the function pointers. */
        Request.DeregisterCallback = pfnDereg;

        Request.HookTable = &HookTable;

        /* Alternate between send and receive. */
        if (Failure % 2) {
            HookTable.SendHook    = NULL;
            HookTable.ReceiveHook = pfnHook;
            HookTable.QueryHook   = Main_test_query_hook;
        } else {
            HookTable.SendHook    = pfnHook;
            HookTable.ReceiveHook = NULL;
            HookTable.QueryHook   = Main_test_query_hook;
        }
    }

    switch (Failure) {
    case 0:
    case 1:
    case 3:
    case 4:
    case 6:
    case 9:
    case 12:
    case 11: /* No failure - proceed as per usual. */
        /* Send the request to the NLB device driver. */
        Status = ZwDeviceIoControlFile(NLBHandle, NULL, NULL, NULL, &IOBlock, NLB_IOCTL_REGISTER_HOOK, &Request, sizeof(Request), NULL, 0);
        break;
    case 2:  /* Invalid GUID. */
        NdisMoveMemory(Request.HookIdentifier, L"{57321019-f4d9-42bc-a651-15a0e1d259ac}", sizeof(WCHAR) * wcslen(L"{57321019-f4d9-42bc-a651-15a0e1d259ac}"));

        /* Send the request to the NLB device driver. */
        Status = ZwDeviceIoControlFile(NLBHandle, NULL, NULL, NULL, &IOBlock, NLB_IOCTL_REGISTER_HOOK, &Request, sizeof(Request), NULL, 0);

        UNIV_ASSERT(Status == STATUS_INVALID_PARAMETER);
        break;
    case 5:  /* No de-register callback function, if a register operation. */
        if (!deregister) Request.DeregisterCallback = NULL;

        /* Send the request to the NLB device driver. */
        Status = ZwDeviceIoControlFile(NLBHandle, NULL, NULL, NULL, &IOBlock, NLB_IOCTL_REGISTER_HOOK, &Request, sizeof(Request), NULL, 0);

        if (!deregister) UNIV_ASSERT(Status == STATUS_INVALID_PARAMETER);
        break;
    case 7:  /* No hooks provided, if a register operation. */
        if (!deregister) { HookTable.ReceiveHook = NULL; HookTable.SendHook = NULL; }

        /* Send the request to the NLB device driver. */
        Status = ZwDeviceIoControlFile(NLBHandle, NULL, NULL, NULL, &IOBlock, NLB_IOCTL_REGISTER_HOOK, &Request, sizeof(Request), NULL, 0);

        if (!deregister) UNIV_ASSERT(Status == STATUS_INVALID_PARAMETER);
        break;
    case 8:  /* Invalid input buffer size. */
        
        /* Send the request to the NLB device driver. */
        Status = ZwDeviceIoControlFile(NLBHandle, NULL, NULL, NULL, &IOBlock, NLB_IOCTL_REGISTER_HOOK, &HookTable, sizeof(HookTable), NULL, 0);

        UNIV_ASSERT(Status == STATUS_INVALID_PARAMETER);
        break;
    case 10: /* Invalid output buffer size. */

        /* Send the request to the NLB device driver. */
        Status = ZwDeviceIoControlFile(NLBHandle, NULL, NULL, NULL, &IOBlock, NLB_IOCTL_REGISTER_HOOK, &Request, sizeof(Request), &Request, sizeof(Request));

        UNIV_ASSERT(Status == STATUS_INVALID_PARAMETER);
        break;
    case 13:  /* No query hook provided, if a register operation. */
        if (!deregister) HookTable.QueryHook = NULL;

        /* Send the request to the NLB device driver. */
        Status = ZwDeviceIoControlFile(NLBHandle, NULL, NULL, NULL, &IOBlock, NLB_IOCTL_REGISTER_HOOK, &Request, sizeof(Request), NULL, 0);

        if (!deregister) UNIV_ASSERT(Status == STATUS_INVALID_PARAMETER);
        break;
    }

    Failure = (Failure++) % 14;

    /* Print the return code. */
    switch (Status) {
    case STATUS_SUCCESS:
        TRACE_INFO("%!FUNC! Success");
        break;
    case STATUS_INVALID_PARAMETER:
        TRACE_INFO("%!FUNC! Failed - invalid parameter");
        break;
    case STATUS_ACCESS_DENIED:
        TRACE_INFO("%!FUNC! Failed - access denied");
        break;
    default:
        TRACE_INFO("%!FUNC! Unknown status");
        break;
    }        
}

VOID Main_hook_thread1 (PNDIS_WORK_ITEM pWorkItem, PVOID nlbctxt) 
{
    static ULONG           job1 = 0;
    static BOOLEAN         bOpen1 = FALSE;
    static HANDLE          NLBHandle1;
    static IO_STATUS_BLOCK IOStatusBlock1;
    PMAIN_CTXT             ctxtp = (PMAIN_CTXT)nlbctxt;
    KIRQL                  Irql;

    /* Do a sanity check on the context - make sure that the MAIN_CTXT code is correct. */
    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

    /* Might as well free the work item now - we don't need it. */
    if (pWorkItem)
        NdisFreeMemory(pWorkItem, sizeof(NDIS_WORK_ITEM), 0);

    /* This shouldn't happen, but protect against it anyway - we cannot manipulate
       the registry if we are at an IRQL > PASSIVE_LEVEL, so bail out. */
    if ((Irql = KeGetCurrentIrql()) > PASSIVE_LEVEL) {
        UNIV_PRINT_CRIT(("Main_hook_thread1: Error: IRQL (%u) > PASSIVE_LEVEL (%u) ... Exiting...", Irql, PASSIVE_LEVEL));
        TRACE_CRIT("%!FUNC! Error: IRQL (%u) > PASSIVE_LEVEL (%u) ... Exiting...", Irql, PASSIVE_LEVEL);
        goto exit;
    }

    /* If we haven't yet successfully opened a handle to the NLB device driver, do so now. */
    if (!bOpen1) {
        NTSTATUS          Status;
        UNICODE_STRING    NLBDriver;
        OBJECT_ATTRIBUTES Attrib;

        /* Initialize the NLB driver device string, \Device\WLBS. */
        RtlInitUnicodeString(&NLBDriver, NLB_DEVICE_NAME);
        
        InitializeObjectAttributes(&Attrib, &NLBDriver, OBJ_CASE_INSENSITIVE, NULL, NULL);
        
        /* Open a handle to the NLB device. */
        Status = ZwCreateFile(&NLBHandle1, SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA, &Attrib, &IOStatusBlock1, NULL, 
                              FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF, 0, NULL, 0);
        
        /* If it failed, then bail out - something's wrong. */
        if (!NT_SUCCESS(Status)) {
            UNIV_PRINT_CRIT(("Main_hook_thread1: Error: Unable to open \\Device\\WLBS, status = 0x%08x", Status));
            TRACE_CRIT("%!FUNC! Error: Unable to open \\Device\\WLBS, status = 0x%08x", Status);
            goto exit;
        }
        
        /* Note that we succeeded so we don't try again later. */
        bOpen1 = TRUE;
    }

    /* Attempt one of 5 operations - either registrations or de-registrations. */
    switch (job1) {
    case 0:
        /* De-register. */
        Main_test_hook_register(NLBHandle1, IOStatusBlock1, Main_test_hook1, Main_deregister_callback1, TRUE);
        break;
    case 1:
        /* Register. */
        Main_test_hook_register(NLBHandle1, IOStatusBlock1, Main_test_hook1, Main_deregister_callback1, FALSE);
        break;
    case 2:
        /* Register. */
        Main_test_hook_register(NLBHandle1, IOStatusBlock1, Main_test_hook1, Main_deregister_callback1, FALSE);
        break;
    case 3:
        /* De-register. */
        Main_test_hook_register(NLBHandle1, IOStatusBlock1, Main_test_hook1, Main_deregister_callback1, TRUE);
        break;
    case 4:
        /* Register. */
        Main_test_hook_register(NLBHandle1, IOStatusBlock1, Main_test_hook1, Main_deregister_callback1, FALSE);
        break;
    }

    job1 = (job1++) % 5;

 exit:

    /* Release the reference on the context - this reference count was incremented
       by the code that setup this work item callback. */
    Main_release_reference(ctxtp);

    return;
}

VOID Main_hook_thread2 (PNDIS_WORK_ITEM pWorkItem, PVOID nlbctxt) 
{
    static ULONG           job2 = 0;
    static HANDLE          NLBHandle2;
    static BOOLEAN         bOpen2 = FALSE;
    static IO_STATUS_BLOCK IOStatusBlock2;
    PMAIN_CTXT             ctxtp = (PMAIN_CTXT)nlbctxt;
    KIRQL                  Irql;

    /* Do a sanity check on the context - make sure that the MAIN_CTXT code is correct. */
    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

    /* Might as well free the work item now - we don't need it. */
    if (pWorkItem)
        NdisFreeMemory(pWorkItem, sizeof(NDIS_WORK_ITEM), 0);

    /* This shouldn't happen, but protect against it anyway - we cannot manipulate
       the registry if we are at an IRQL > PASSIVE_LEVEL, so bail out. */
    if ((Irql = KeGetCurrentIrql()) > PASSIVE_LEVEL) {
        UNIV_PRINT_CRIT(("Main_hook_thread2: Error: IRQL (%u) > PASSIVE_LEVEL (%u) ... Exiting...", Irql, PASSIVE_LEVEL));
        TRACE_CRIT("%!FUNC! Error: IRQL (%u) > PASSIVE_LEVEL (%u) ... Exiting...", Irql, PASSIVE_LEVEL);
        goto exit;
    }

    /* If we haven't yet successfully opened a handle to the NLB device driver, do so now. */
    if (!bOpen2) {
        NTSTATUS          Status;
        UNICODE_STRING    NLBDriver;
        OBJECT_ATTRIBUTES Attrib;

        /* Initialize the NLB driver device string, \Device\WLBS. */
        RtlInitUnicodeString(&NLBDriver, NLB_DEVICE_NAME);
        
        InitializeObjectAttributes(&Attrib, &NLBDriver, OBJ_CASE_INSENSITIVE, NULL, NULL);
        
        /* Open a handle to the NLB device. */
        Status = ZwCreateFile(&NLBHandle2, SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA, &Attrib, &IOStatusBlock2, NULL, 
                              FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN_IF, 0, NULL, 0);
        
        /* If it failed, then bail out - something's wrong. */
        if (!NT_SUCCESS(Status)) {
            UNIV_PRINT_CRIT(("Main_hook_thread2: Error: Unable to open \\Device\\WLBS, status = 0x%08x", Status));
            TRACE_CRIT("%!FUNC! Error: Unable to open \\Device\\WLBS, status = 0x%08x", Status);
            goto exit;
        }

        /* Note that we succeeded so we don't try again later. */
        bOpen2 = TRUE;
    }

    /* Attempt one of 5 operations - either registrations or de-registrations. */
    switch (job2) {
    case 0:
        /* De-register. */
        Main_test_hook_register(NLBHandle2, IOStatusBlock2, Main_test_hook2, Main_deregister_callback2, TRUE);
        break;
    case 1:
        /* De-register. */
        Main_test_hook_register(NLBHandle2, IOStatusBlock2, Main_test_hook2, Main_deregister_callback2, TRUE);
        break;
    case 2:
        /* Register. */
        Main_test_hook_register(NLBHandle2, IOStatusBlock2, Main_test_hook2, Main_deregister_callback2, FALSE);
        break;
    case 3:
        /* Register. */
        Main_test_hook_register(NLBHandle2, IOStatusBlock2, Main_test_hook2, Main_deregister_callback2, FALSE);
        break;
    case 4:
        /* De-register. */
        Main_test_hook_register(NLBHandle2, IOStatusBlock2, Main_test_hook2, Main_deregister_callback2, TRUE);
        break;
    }

    job2 = (job2++) % 5;

 exit:

    /* Release the reference on the context - this reference count was incremented
       by the code that setup this work item callback. */
    Main_release_reference(ctxtp);

    return;
}

VOID Main_test_hook (PMAIN_CTXT ctxtp) 
{
    /* Schedule a couple of threads to stress the hook registration and de-registration paths. */
    (VOID)Main_schedule_work_item(ctxtp, Main_hook_thread1);
    (VOID)Main_schedule_work_item(ctxtp, Main_hook_thread2);
}
#endif

VOID Main_age_identity_cache(
    PMAIN_CTXT              ctxtp)
{
    ULONG i = 0;

    for (i=0; i < CVY_MAX_HOSTS; i++)
    {
        ULONG dip       = NULL_VALUE;
        BOOL fSetDip    = (BOOL) ctxtp->params.identity_enabled;

        if (ctxtp->identity_cache[i].ttl > 0)
        {
            UNIV_ASSERT(i == ctxtp->identity_cache[i].host_id);

            if (ctxtp->identity_cache[i].ttl <= ctxtp->curr_tout)
            {
                UNIV_PRINT_INFO(("Main_age_identity_cache: cached entry for host_id [0-31] %u expired", i));
                TRACE_INFO("%!FUNC! cached entry for host_id [0-31] %u expired", i);
                ctxtp->identity_cache[i].ttl = 0;
                fSetDip = TRUE;
            }
            else
            {
                ctxtp->identity_cache[i].ttl -= ctxtp->curr_tout;
                dip = ctxtp->identity_cache[i].ded_ip_addr;
            }
        }

        if (fSetDip)
        {
            /* Always set the dip if caching is currently enabled. Also set it if the ttl was valid when we began aging the cache entries. */
            DipListSetItem(&ctxtp->dip_list, ctxtp->identity_cache[i].host_id, dip);
        }
    }
}

#ifdef PERIODIC_RESET
static ULONG countdown = 0;
ULONG   resetting = FALSE;
#endif

VOID Main_ping (
    PMAIN_CTXT              ctxtp,
    PULONG                  toutp)
{
    ULONG                   len, conns;
    BOOLEAN                 converging = FALSE;
    PNDIS_PACKET            packet;
    NDIS_STATUS             status;
    BOOLEAN                 send_heartbeat = TRUE;

#ifdef PERIODIC_RESET   /* enable this to simulate periodic resets */

    if (countdown++ == 15)
    {
        NDIS_STATUS     status;

        resetting = TRUE;

        NdisReset (& status, ctxtp -> mac_handle);

        if (status == NDIS_STATUS_SUCCESS)
            resetting = FALSE;

        countdown = 0;
    }

#endif

    /* If unbind handler has been called, return here */
    if (ctxtp -> unbind_handle)
    {
        return;
    }

#if defined (NLB_HOOK_TEST_ENABLE)
    /* Aritifically test the hook by spawning a couple of "threads" to
       do register and de-register operations on the filter hook. */
    Main_test_hook(ctxtp);
#endif

    /* The master adapter must check the consistency of its team's configuration
       and appropriately activate/de-activate the team once per timeout. */
    Main_teaming_check_consistency(ctxtp);

    /* count down time left for blocking ARPs */

    NdisAcquireSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */

    /* Age out the local cache of identities. This must run even if identity
       heartbeats are disabled so we can age out entries after we turn it
       off. */
    Main_age_identity_cache(ctxtp);

    if (*toutp > univ_changing_ip)
        univ_changing_ip = 0;
    else
        univ_changing_ip -= *toutp;

    converging = Load_timeout (& ctxtp -> load, toutp, & conns);

    /* moving release to the end of the function locks up one of the testbeds.
       guessing because of some reentrancy problem with NdisSend that is being
       called by ctxtp_frame_send */

    if (! ctxtp -> convoy_enabled && ! ctxtp -> stopping)
    {
        UNIV_ASSERT (! ctxtp -> draining);
        NdisReleaseSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */
        send_heartbeat   = FALSE;
    }

    /* V2.1 if draining and no more connections - stop cluster mode */

    if (send_heartbeat)
    {
        if (ctxtp->draining)
        {
            /* We check whether or not we are teaming without grabbing the global teaming
               lock in an effort to minimize the common case - teaming is a special mode
               of operation that is only really useful in a clustered firewall scenario.
               So, if we don't think we're teaming, don't bother to check for sure, just
               use our own load module and go with it. */
            if (ctxtp->bda_teaming.active) 
            {
                /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
                   assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
                PLOAD_CTXT      pLoad = &ctxtp->load;
                PNDIS_SPIN_LOCK pLock = &ctxtp->load_lock;
                BOOLEAN         bRefused = FALSE;
                BOOLEAN         bTeaming = FALSE;
            
                /* Temporarily release our load lock.  Since we're draining, the only possible
                   side effect is that the connection count may decrease before we reacquire 
                   the lock.  This is not a big deal - we'll correct any discrepencies the 
                   next time this timer expires. */
                NdisReleaseSpinLock(&ctxtp->load_lock);

                /* Check the teaming configuration and add a reference to the load module before consulting the load module. */
                bTeaming = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bRefused);
            
                /* If we're part of a BDA team, we need to make sure that the number of active 
                   connections we use when making a draining decision is based on the number of
                   active connections on the master, on which ALL connections for the team are
                   maintained. */
                if (bTeaming)
                {
                    /* If we are the team's master, then we don't need to squirrel around with 
                       the connection count - continue to do things the way they always have 
                       regarding draining. */
                    if (pLoad != &ctxtp->load)
                    {
                        /* If we're a slave, we depend on the master to know when to complete
                           draining; so long as the master is active, continue to drain. 

                           NOTE: we are checking the "active" flag on the load module without
                           holding the load lock.  In the case where all members of a team 
                           are being drainstopped or stopped at roughly the same time (which
                           is a reasonable assumption), this shouldn't be a problem - we may
                           miss our chance to stop this time around, but we'll check again
                           during the next periodic timeout and we'll take care of it then. */
                        if (pLoad->active)
                            conns = 1;
                        /* Otherwise, if the master is stopped, we can transition to stopped as well. */
                        else
                            conns = 0;
                    }
                
                    /* If we were teaming, master or otherwise, release the reference on the 
                       master's load module. */
                    Main_teaming_release_load(pLoad, pLock, bTeaming);
                }

                NdisAcquireSpinLock(&ctxtp->load_lock);
            }
        }

        if (ctxtp -> draining && conns == 0 && ! converging)
        {
            IOCTL_CVY_BUF     buf;
            
            ctxtp -> draining = FALSE;
            NdisReleaseSpinLock (& ctxtp -> load_lock);
            
            Main_ctrl (ctxtp, IOCTL_CVY_CLUSTER_OFF, &buf, NULL, NULL, NULL);
        }
        else
            NdisReleaseSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */

    /* V2.1 clear stopping flag here since we are going to send out the frame
       that will initiate convergence */

        ctxtp -> stopping = FALSE;
    }

    /* Add the elapsed time to the descriptor cleanup timeout. */
    ctxtp->conn_purge += ctxtp->curr_tout;
    
    /* If its time to cleanup potentially stale connection descriptors, schedule a work item to do so. */
    if (ctxtp->conn_purge >= CVY_DEF_DSCR_PURGE_INTERVAL) {
        
        /* Reset the elapsed time since the last cleanup. */
        ctxtp->conn_purge = 0;
        
        /* Schedule an NDIS work item to clean out stale connection state. */
        (VOID)Main_schedule_work_item(ctxtp, Main_purge_connection_state);
    }

    /* V1.3.2b */

    if (! ctxtp -> media_connected || ! MAIN_PNP_DEV_ON(ctxtp))
    {
        return;
    }

    /* V1.1.2 do not send pings if the card below is resetting */

    if (ctxtp -> reset_state != MAIN_RESET_NONE)
    {
        return;
    }

    if (send_heartbeat)
    {
        packet = Main_frame_get (ctxtp, & len, MAIN_PACKET_TYPE_PING);

        if (packet == NULL)
        {
            UNIV_PRINT_CRIT(("Main_ping: Error getting frame packet"));
            TRACE_CRIT("%!FUNC! Error getting frame packet failed");
        }
        else
        {
            NdisSend (& status, ctxtp -> mac_handle, packet);

            if (status != NDIS_STATUS_PENDING)
                Main_send_done (ctxtp, packet, status);
        }
    }

    /* Check to see if igmp message needs to be sent out.  If the cluster IP address is 0.0.0.0, we 
       don't want to join the multicast IGMP group.  Likewise, in multicast or unicast mode. */
    if (ctxtp -> params . mcast_support && ctxtp -> params . igmp_support && ctxtp -> params . cl_ip_addr != 0)
    {
        ctxtp -> igmp_sent += ctxtp -> curr_tout;

        if (ctxtp -> igmp_sent >= CVY_DEF_IGMP_INTERVAL)
        {
            ctxtp -> igmp_sent = 0;
            packet = Main_frame_get (ctxtp, & len, MAIN_PACKET_TYPE_IGMP);

            if (packet == NULL)
            {
                UNIV_PRINT_CRIT(("Main_ping: Error getting igmp packet"));
                TRACE_CRIT("%!FUNC! Error getting igmp packet failed");
            }
            else
            {
                NdisSend (& status, ctxtp -> mac_handle, packet);

                if (status != NDIS_STATUS_PENDING)
                    Main_send_done (ctxtp, packet, status);
            }
        }
    }

    if (ctxtp->params.identity_enabled)
    {
        /* Check to see if it is time to send an identity heartbeat */
        ctxtp->idhb_sent += ctxtp->curr_tout;

        if (ctxtp->idhb_sent >= ctxtp->params.identity_period)
        {
            ctxtp->idhb_sent = 0;
            packet = Main_frame_get (ctxtp, & len, MAIN_PACKET_TYPE_IDHB);

            if (packet == NULL)
            {
                UNIV_PRINT_CRIT(("Main_ping: Error getting identity heartbeat packet"));
                TRACE_CRIT("%!FUNC! Error getting identity heartbeat failed");
            }
            else
            {
                NdisSend (& status, ctxtp -> mac_handle, packet);

                if (status != NDIS_STATUS_PENDING)
                    Main_send_done (ctxtp, packet, status);
            }
        }
    }

} /* Main_ping */


VOID Main_send_done (
    PVOID                   cp,
    PNDIS_PACKET            packetp,
    NDIS_STATUS             status)
{
    PMAIN_CTXT              ctxtp = (PMAIN_CTXT) cp;
    PMAIN_FRAME_DSCR        dscrp;

    /* This function is only called for ping and IGMP messages, so
       we can continue to allow it to access the protocol reserved field. */
    PMAIN_PROTOCOL_RESERVED resp = MAIN_PROTOCOL_FIELD (packetp);

    UNIV_ASSERT_VAL (resp -> type == MAIN_PACKET_TYPE_PING ||
                     resp -> type == MAIN_PACKET_TYPE_IGMP ||
                     resp -> type == MAIN_PACKET_TYPE_IDHB,
                     resp -> type);

    /* attempt to see if this packet is part of our frame descriptor */

    dscrp = (PMAIN_FRAME_DSCR) resp -> miscp;

    if (status != NDIS_STATUS_SUCCESS)
        UNIV_PRINT_CRIT(("Main_send_done: Error sending %x error 0x%x", resp -> type, status));

    Main_frame_put (ctxtp, packetp, dscrp);

} /* end Main_send_done */

/*
 * Function: Main_spoof_mac
 * Description: This function spoofs the source/destination MAC address(es) of incoming
 *              and/or outgoing packets.  Incoming packets in multicast mode must change
 *              the cluster multicast MAC to the NIC's permanent MAC address before sending
 *              the packet up the protocol stack.  Outgoing packets in unicast mode must
 *              mask the source MAC address to prevent switches from learning the cluster
 *              MAC address and associating it with a particular switch port.
 * Parameters: ctxtp - pointer the the main NLB context structure for this adapter.
 *             pPacketInfo - the previously parse packet information structure, which, 
 *                           among other things, contains a pointer to the MAC header.
 *             send - boolean indication of send v. receive.
 * Returns: Nothing.
 * Author: shouse, 3.4.02
 * Notes: 
 */
VOID Main_spoof_mac (PMAIN_CTXT ctxtp, PMAIN_PACKET_INFO pPacketInfo, ULONG send)
{
    /* Cast the MAC header to a PUCHAR. */
    PUCHAR memp = (PUCHAR)pPacketInfo->Ethernet.pHeader;

    /* Be paranoid about the network medium. */
    UNIV_ASSERT(ctxtp->medium == NdisMedium802_3);
    UNIV_ASSERT(pPacketInfo->Medium == NdisMedium802_3);
    
    /* If this cluster is in multicast mode, then check to see whether its necessary
       to overwrite the cluster multicast MAC address in the packet. */
    if (ctxtp->params.mcast_support)
    {
        /* Get the destination MAC address offset, in bytes. */
        ULONG offset = CVY_MAC_DST_OFF(ctxtp->medium);
    
        /* If this is a receive and the destination MAC address is the cluster 
           multicast MAC address, then replace it with the NIC's permanent MAC. */
        if (!send && CVY_MAC_ADDR_COMP(ctxtp->medium, memp + offset, &ctxtp->cl_mac_addr))
            CVY_MAC_ADDR_COPY(ctxtp->medium, memp + offset, &ctxtp->ded_mac_addr);
    }
    /* Otherwise, if the cluster is in unicast mode, and we're sending out a 
       packet, then check to see whether or not its necessary to mask the 
       cluster MAC address. */
    else if (send && ctxtp->params.mask_src_mac)
    {
        /* Get the source MAC address offset, in bytes. */ 
        ULONG offset = CVY_MAC_SRC_OFF(ctxtp->medium);
        
        /* If the source MAC address is the cluster unicast MAC address, then we 
           have to mask the source MAC address, which we do by altering one byte
           of the MAC address: 02-bf-xx-xx-xx-xx to 02-ID-xx-xx-xx-xx, where ID
           is this host's host priority.  Note: This really should be computed at 
           init time and simply copied here. */
        if (CVY_MAC_ADDR_COMP(ctxtp->medium, memp + offset, &ctxtp->cl_mac_addr))
        {
            ULONG byte[4];

            /* Set the LAA bit in the MAC address. */
            CVY_MAC_ADDR_LAA_SET(ctxtp->medium, memp + offset);
            
            /* Change the second byte to the host priority. */
            *((PUCHAR)(memp + offset + 1)) = (UCHAR)ctxtp->params.host_priority;
            
            /* Break the cluster IP address up in octets. */
            IP_GET_ADDR(ctxtp->cl_ip_addr, &byte[0], &byte[1], &byte[2], &byte[3]);
            
            /* Copy the cluster IP address octects into the other four bytes
               of the source MAC address. */
            *((PUCHAR)(memp + offset + 2)) = (UCHAR)byte[0];
            *((PUCHAR)(memp + offset + 3)) = (UCHAR)byte[1];
            *((PUCHAR)(memp + offset + 4)) = (UCHAR)byte[2];
            *((PUCHAR)(memp + offset + 5)) = (UCHAR)byte[3];
            
            // ctxtp->mac_modified++;
        }
    }
}

/*
 * Function: Main_recv_frame_parse
 * Description: This function parses an NDIS_PACKET and carefully extracts the information 
 *              necessary to handle the packet.  The information extracted includes pointers 
 *              to all relevant headers and payloads as well as the packet type (EType), IP 
 *              protocol (if appropriate), etc.  This function does all necessary validation 
 *              to ensure that all pointers are accessible for at least the specified number 
 *              of bytes; i.e., if this function returns successfully, the pointer to the IP 
 *              header is guaranteed to be accessible for at LEAST the length of the IP header.  
 *              No contents inside headers or payloads is validated, except for header lengths, 
 *              and special cases, such as NLB heartbeats or remote control packets.  If this
 *              function returns unsuccessfully, the contents of MAIN_PACKET_INFO cannot be 
 *              trusted and the packet should be discarded.  See the definition of MAIN_PACKET_INFO 
 *              in main.h for more specific indications of what fields are filled in and under 
 *              what circumstances.
 * Parameters: ctxtp - pointer to the main NLB context structure for this adapter.
 *             pPacket - pointer to an NDIS_PACKET.
 *             pPacketInfo - pointer to a MAIN_PACKET_INFO structure to hold the information
 *                           parsed from the packet.
 * Returns: BOOLEAN - TRUE if successful, FALSE if not.
 * Author: shouse, 3.4.02
 * Notes: 
 */
BOOLEAN Main_recv_frame_parse (
    PMAIN_CTXT            ctxtp,        /* the context for this adapter */
    IN PNDIS_PACKET       pPacket,      /* pointer to an NDIS_PACKET */
    OUT PMAIN_PACKET_INFO pPacketInfo   /* pointer to an NLB packet information structure to hold the output */
)
{
    PNDIS_BUFFER          bufp = NULL;
    PUCHAR                memp = NULL;
    PUCHAR                hdrp = NULL;
    ULONG                 len = 0;
    UINT                  buf_len = 0;
    UINT                  packet_len = 0;
    ULONG                 curr_len = 0;
    ULONG                 hdr_len = 0;
    ULONG                 offset = 0;

    UNIV_ASSERT(pPacket);
    UNIV_ASSERT(pPacketInfo);

    /* Store a pointer to the original packet. */
    pPacketInfo->pPacket = pPacket;

    /* By default, this packet does not require post filtering special attention. */
    pPacketInfo->Operation = MAIN_FILTER_OP_NONE;                    

    /* Ask NDIS for the first buffer (bufp), the virtual address of the beginning of that buffer,
       (memp) the length of that buffer (buf_len) and the length of the entire packet (packet_len). */
    NdisGetFirstBufferFromPacket(pPacket, &bufp, &memp, &buf_len, &packet_len);
    
    if (bufp == NULL)
    {
        UNIV_PRINT_CRIT(("Main_recv_frame_parse: NdisGetFirstBufferFromPacket returned NULL!"));
        TRACE_CRIT("%!FUNC! NdisGetFirstBufferFromPacket returned NULL!");
        return FALSE;
    }

    if (memp == NULL)
    {
        UNIV_PRINT_CRIT(("Main_recv_frame_parse: NDIS buffer virtual memory address is NULL!"));
        TRACE_CRIT("%!FUNC! NDIS buffer virtual memory address is NULL!");
        return FALSE;
    }

    UNIV_ASSERT(ctxtp->medium == NdisMedium802_3);

    /* Get the destination MAC address offset, in bytes. */
    offset = CVY_MAC_DST_OFF(ctxtp->medium);

    /* The Ethernet header is memp, the beginning of the buffer and the length of contiguous
       memory accessible from that pointer is buf_len - the entire buffer. */
    pPacketInfo->Ethernet.pHeader = (PCVY_ETHERNET_HDR)memp;
    pPacketInfo->Ethernet.Length = buf_len;

    /* Note: NDIS will ensure that the buf_len is at least the size of an ethernet header, 
       so we don't have to check that here.  Assert it, just in case. */
    UNIV_ASSERT(buf_len >= sizeof(CVY_ETHERNET_HDR));

    /* This variable accumulates the lengths of the headers that we've successfully "found". */
    hdr_len = sizeof(CVY_ETHERNET_HDR);
    
    /* Set the medium and retrieve the Ethernet packet type from the header. */
    pPacketInfo->Medium = NdisMedium802_3;
    pPacketInfo->Type = CVY_ETHERNET_ETYPE_GET(pPacketInfo->Ethernet.pHeader);

    /* Categorize this packet as unicast, multicast or broadcast by looking at the destination 
       MAC address and store the "group" in the packet information structure.  This is used
       for statistical purposes later. */
    if (!CVY_MAC_ADDR_MCAST(ctxtp->medium, (PUCHAR)pPacketInfo->Ethernet.pHeader + offset))
    {
        pPacketInfo->Group = MAIN_FRAME_DIRECTED;
    }
    else
    {
        if (CVY_MAC_ADDR_BCAST(ctxtp->medium, (PUCHAR)pPacketInfo->Ethernet.pHeader + offset))
            pPacketInfo->Group = MAIN_FRAME_BROADCAST;
        else
            pPacketInfo->Group = MAIN_FRAME_MULTICAST;
    }

    /* A length indication from an NDIS_PACKET includes the MAC header, 
       so subtract that to get the length of the payload. */
    pPacketInfo->Length = packet_len - hdr_len;

    /* Hmmmm... If the packet length is larger than we expect, print a trace statement.
       This is peculiar, but not impossible with hardware accelleration and IpLargeXmit. 
       This should probably NOT happen on a receive, however - just a send. */
    if (pPacketInfo->Length > ctxtp->max_frame_size)
    {
        UNIV_PRINT_CRIT(("Main_recv_frame_parse: Length of the packet (%u) is greater than the maximum size of a frame (%u)", pPacketInfo->Length, ctxtp->max_frame_size));
        TRACE_CRIT("%!FUNC! Length of the packet (%u) is greater than the maximum size of a frame (%u)", pPacketInfo->Length, ctxtp->max_frame_size);
    }

    /* As long as the byte offset we're looking for is NOT in the current buffer,
       keep looping through the available NDIS buffers. */
    while (curr_len + buf_len <= hdr_len)
    {
        /* Before we get the next buffer, accumulate the length of the buffer
           we're done with by adding its length to curr_len. */
        curr_len += buf_len;
        
        /* Get the next buffer in the chain. */
        NdisGetNextBuffer(bufp, &bufp);
        
        /* At this point, we expect to be able to successfully find the offset we're
           looking for, so if we've run out of buffers, fail. */
        if (bufp == NULL)
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: NdisGetNextBuffer returned NULL when more data was expected!"));
            TRACE_CRIT("%!FUNC! NdisGetNextBuffer returned NULL when more data was expected!");
            return FALSE;
        }
        
        /* Query the buffer for the virtual address of the buffer and its length. */
        NdisQueryBufferSafe(bufp, &memp, &buf_len, NormalPagePriority);
        
        if (memp == NULL)
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: NDIS buffer virtual memory address is NULL!"));
            TRACE_CRIT("%!FUNC! NDIS buffer virtual memory address is NULL!");
            return FALSE;
        }
    }
    
    /* The pointer to the header we're looking for is the beginning of the buffer,
       plus the offset of the header within this buffer.  Likewise, the contiguous
       memory accessible from this pointer is the length of this buffer, minus
       the byte offset at which the header begins. */        
    hdrp = memp + (hdr_len - curr_len);
    len = buf_len - (hdr_len - curr_len);

    /* Based on the packet type, enforce some restrictions and setup any further
       information we need to find in the packet. */
    switch (pPacketInfo->Type)
    {
    case TCPIP_IP_SIG: /* IP packets. */

        /* If the contiguous memory accessible from the IP header is not at 
           LEAST the minimum length of an IP header, bail out now. */
        if (len < sizeof(IP_HDR))
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: Length of the IP buffer (%u) is less than the size of an IP header (%u)", len, sizeof(IP_HDR)));
            TRACE_CRIT("%!FUNC! Length of the IP buffer (%u) is less than the size of an IP header (%u)", len, sizeof(IP_HDR));
            return FALSE;
        }
        
        /* Save a pointer to the IP header and its "length". */
        pPacketInfo->IP.pHeader = (PIP_HDR)hdrp;
        pPacketInfo->IP.Length = len;

        /* Extract the IP protocol from the IP header. */
        pPacketInfo->IP.Protocol = IP_GET_PROT(pPacketInfo->IP.pHeader);

        /* Calculate the actual IP header length by extracting the hlen field
           from the IP header and multiplying by the size of a DWORD. */
        len = sizeof(ULONG) * IP_GET_HLEN(pPacketInfo->IP.pHeader);

        /* If this calculated header length is not at LEAST the minimum IP 
           header length, bail out now. */
        if (len < sizeof(IP_HDR))
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: Calculated IP header length (%u) is less than the size of an IP header (%u)", len, sizeof(IP_HDR)));
            TRACE_CRIT("%!FUNC! Calculated IP header length (%u) is less than the size of an IP header (%u)", len, sizeof(IP_HDR));
            return FALSE;
        }

#if 0 /* Because the options can be in separate buffers (at least in sends), don't bother to 
         enforce this condition; NLB never looks at the options anyway, so we don't really care. */

        /* If the contiguous memory accessible from the IP header is not at
           LEAST the calculated size of the IP header, bail out now. */
        if (pPacketInfo->IP.Length < len)
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: Length of the IP buffer (%u) is less than the size of the IP header (%u)", pPacketInfo->IP.Length, len));
            TRACE_CRIT("%!FUNC! Length of the IP buffer (%u) is less than the size of the IP header (%u)", pPacketInfo->IP.Length, len);
            return FALSE;
        }
#endif

        /* The total packet length, in bytes, specified in the header, which includes
           both the IP header and payload, can be no more than the packet length that 
           NDIS told us, which is the entire network packet, minus the media header. */
        if (IP_GET_PLEN(pPacketInfo->IP.pHeader) > pPacketInfo->Length)
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: IP packet length (%u) is greater than the indicated packet length (%u)", IP_GET_PLEN(pPacketInfo->IP.pHeader), pPacketInfo->Length));
            TRACE_CRIT("%!FUNC! IP packet length (%u) is greater than the indicated packet length (%u)", IP_GET_PLEN(pPacketInfo->IP.pHeader), pPacketInfo->Length);
            return FALSE;
        }
		
        /* If this packet is a subsequent IP fragment, note that in the packet
           information structure and leave now, successfully. */
        if (IP_GET_FRAG_OFF(pPacketInfo->IP.pHeader) != 0)
        {
            pPacketInfo->IP.bFragment = TRUE;
            return TRUE;
        }
        /* Otherwise, mark the packet as NOT a subsequent fragment and continue. */
        else
        {
            pPacketInfo->IP.bFragment = FALSE;
        }

        /* Add the length of the IP header to the offset we're now looking
           for in the packet; in this case, the TCP/UDP/etc. header. */
        hdr_len += len;

        break;

    case MAIN_FRAME_SIG:
    case MAIN_FRAME_SIG_OLD: /* Heartbeats. */

        /* If the contiguous memory accessible from the heartbeat header is not at 
           LEAST the length of an NLB heartbeat header, bail out now. */
        if (len < sizeof(MAIN_FRAME_HDR))
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: Length of the PING buffer (%u) is less than the size of an PING header (%u)", len, sizeof(MAIN_FRAME_HDR)));
            TRACE_CRIT("%!FUNC! Length of the PING buffer (%u) is less than the size of an PING header (%u)", len, sizeof(MAIN_FRAME_HDR));
            return FALSE;
        }

        /* Save a pointer to the heartbeat header and its "length". */
        pPacketInfo->Heartbeat.pHeader = (PMAIN_FRAME_HDR)hdrp;
        pPacketInfo->Heartbeat.Length = len;

        /* Verify the "magic number" in the heartbeat header.  If it's corrupt, 
           bail out now. */
        if (pPacketInfo->Heartbeat.pHeader->code != MAIN_FRAME_CODE &&
            pPacketInfo->Heartbeat.pHeader->code != MAIN_FRAME_EX_CODE)
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: Wrong code found (%u) in PING header (%u)", pPacketInfo->Heartbeat.pHeader->code, MAIN_FRAME_CODE));
            TRACE_CRIT("%!FUNC! Wrong code found (%u) in PING header (%u)", pPacketInfo->Heartbeat.pHeader->code, MAIN_FRAME_CODE);
            return FALSE;
        }

        /* Old frame types don't support extended heartbeats */
        if (pPacketInfo->Heartbeat.pHeader->code == MAIN_FRAME_EX_CODE &&
            pPacketInfo->Type == MAIN_FRAME_SIG_OLD)
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: Extended heartbeats are not supported for the old frame type"));
            TRACE_CRIT("%!FUNC! Extended heartbeats are not supported for the old frame type");
            return FALSE;
        }

        /* Add the length of the heartbeat header to the offset we're now looking
           for in the packet; in this case, the heartbeat payload. */
        hdr_len += sizeof(MAIN_FRAME_HDR);

        break;

    case TCPIP_ARP_SIG: /* ARPs. */

        /* If the contiguous memory accessible from the ARP header is not at 
           LEAST the length of an ARP header, bail out now. */        
        if (len < sizeof(ARP_HDR))
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: Length of the ARP buffer (%u) is less than the size of an ARP header (%u)", len, sizeof(ARP_HDR)));
            TRACE_CRIT("%!FUNC! Length of the ARP buffer (%u) is less than the size of an ARP header (%u)", len, sizeof(ARP_HDR));
            return FALSE;
        }

        /* Save a pointer to the ARP header and its "length". */
        pPacketInfo->ARP.pHeader = (PARP_HDR)hdrp;
        pPacketInfo->ARP.Length = len;

        /* Nothing more to look for in an ARP.  Leave now, successfully. */
        return TRUE;
        
    default: /* Any Ethernet type other than IP, NLB Heartbeat and ARP. */

        /* Store a pointer to the unknown header and its "length". */
        pPacketInfo->Unknown.pHeader = hdrp;
        pPacketInfo->Unknown.Length = len;

        /* Nothing more to look for in this packet.  Leave now, successfully. */
        return TRUE;
    }

    /* As long as the byte offset we're looking for is NOT in the current buffer,
       keep looping through the available NDIS buffers. */
    while (curr_len + buf_len <= hdr_len)
    {
        /* Before we get the next buffer, accumulate the length of the buffer
           we're done with by adding its length to curr_len. */
        curr_len += buf_len;
        
        /* Get the next buffer in the chain. */
        NdisGetNextBuffer(bufp, &bufp);
        
        /* At this point, we expect to be able to successfully find the offset we're
           looking for, so if we've run out of buffers, fail. */
        if (bufp == NULL)
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: NdisGetNextBuffer returned NULL when more data was expected!"));
            TRACE_CRIT("%!FUNC! NdisGetNextBuffer returned NULL when more data was expected!");
            return FALSE;
        }
        
        /* Query the buffer for the virtual address of the buffer and its length. */
        NdisQueryBufferSafe(bufp, &memp, &buf_len, NormalPagePriority);
        
        if (memp == NULL)
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: NDIS buffer virtual memory address is NULL!"));
            TRACE_CRIT("%!FUNC! NDIS buffer virtual memory address is NULL!");
            return FALSE;
        }
    } 
        
    /* The pointer to the header we're looking for is the beginning of the buffer,
       plus the offset of the header within this buffer.  Likewise, the contiguous
       memory accessible from this pointer is the length of this buffer, minus
       the byte offset at which the header begins. */        
    hdrp = memp + (hdr_len - curr_len);
    len = buf_len - (hdr_len - curr_len);

    /* Based on the packet type, enforce some restrictions and setup any further
       information we need to find in the packet. */
    switch (pPacketInfo->Type)
    {
    case MAIN_FRAME_SIG:
    case MAIN_FRAME_SIG_OLD: /* Heartbeats. */
        
        /* Make sure that the length of the buffer is at LEAST as large as an NLB heartbeat payload. */
        if (pPacketInfo->Heartbeat.pHeader->code == MAIN_FRAME_CODE)
        {
            if (len < sizeof(PING_MSG))
            {
                UNIV_PRINT_CRIT(("Main_recv_frame_parse: Length of the PING buffer (%u) is less than the size of a PING message (%u)", len, sizeof(PING_MSG)));
                TRACE_CRIT("%!FUNC! Length of the PING buffer (%u) is less than the size of a PING message (%u)", len, sizeof(PING_MSG));
                return FALSE;
            }
        
            /* Save a pointer to the heartbeat payload and its "length". */
            pPacketInfo->Heartbeat.Payload.pPayload = (PPING_MSG)hdrp;
            pPacketInfo->Heartbeat.Payload.Length = len;
        
        }
        else if (pPacketInfo->Heartbeat.pHeader->code == MAIN_FRAME_EX_CODE)
        {
            /* PPING_MSG_EX is a variable length structure so we compare this size against the smallest
               allowed value which is sizeof(TLV_HEADER). */
            if (len < sizeof(TLV_HEADER))
            {
                UNIV_PRINT_CRIT(("Main_recv_frame_parse: Length of the received buffer (%u) is less than the size of an extended heartbeat message (%u)", len, sizeof(TLV_HEADER)));
                TRACE_CRIT("%!FUNC! Length of the received buffer (%u) is less than the size of an extended heartbeat message (%u)", len, sizeof(TLV_HEADER));
                return FALSE;
            }

            /* Save a pointer to the identity heartbeat payload and its "length". */
            pPacketInfo->Heartbeat.Payload.pPayloadEx = (PTLV_HEADER) hdrp;
            pPacketInfo->Heartbeat.Payload.Length = len;
        }

        /* Nothing more to look for in heartbeats.  Leave now, successfully. */
        return TRUE;

    case TCPIP_IP_SIG: /* IP packets. */
    
        /* For some protocols, we have more to look for in the packet. */
        switch (pPacketInfo->IP.Protocol)
        { 
        case TCPIP_PROTOCOL_TCP: /* TCP. */
            
            /* If the contiguous memory accessible from the TCP header is not at 
               LEAST the minimum length of a TCP header, bail out now. */        
            if (len < sizeof(TCP_HDR))
            {
                UNIV_PRINT_CRIT(("Main_recv_frame_parse: Length of the TCP buffer (%u) is less than the size of an TCP header (%u)", len, sizeof(TCP_HDR)));
                TRACE_CRIT("%!FUNC! Length of the TCP buffer (%u) is less than the size of an TCP header (%u)", len, sizeof(TCP_HDR));
                return FALSE;
            }
            
            /* Save a pointer to the TCP header and its "length". */
            pPacketInfo->IP.TCP.pHeader = (PTCP_HDR)hdrp;
            pPacketInfo->IP.TCP.Length = len;
            
            /* Calculate the actual TCP header length by extracting the hlen field
               from the TCP header and multiplying by the size of a DWORD. */
            len = sizeof(ULONG) * TCP_GET_HLEN(pPacketInfo->IP.TCP.pHeader);

            /* If this calculated header length is not at LEAST the minimum TCP 
               header length, bail out now. */
            if (len < sizeof(TCP_HDR))
            {
                UNIV_PRINT_CRIT(("Main_recv_frame_parse: Calculated TCP header length (%u) is less than the size of an TCP header (%u)", len, sizeof(TCP_HDR)));
                TRACE_CRIT("%!FUNC! Calculated TCP header length (%u) is less than the size of an TCP header (%u)", len, sizeof(TCP_HDR));
                return FALSE;
            }
            
#if 0 /* Because the options can be in separate buffers (at least in sends), don't bother to 
         enforce this condition; NLB never looks at the options anyway, so we don't really care. */

            /* If the contiguous memory accessible from the TCP header is not at
               LEAST the calculated size of the TCP header, bail out now. */
            if (pPacketInfo->IP.TCP.Length < len)
            {
                UNIV_PRINT_CRIT(("Main_recv_frame_parse: Length of the TCP buffer (%u) is less than the size of the TCP header (%u)", pPacketInfo->IP.TCP.Length, len));
                TRACE_CRIT("%!FUNC! Length of the TCP buffer (%u) is less than the size of the TCP header (%u)", pPacketInfo->IP.TCP.Length, len);
                return FALSE;
            }
#endif

            /* Add the length of the TCP header to the offset we're now looking
               for in the packet; in this case, the TCP payload. */
            hdr_len += len;

            break;

        case TCPIP_PROTOCOL_UDP:
            
            /* If the contiguous memory accessible from the UDP header is not at 
               LEAST the length of a UDP header, bail out now. */
            if (len < sizeof(UDP_HDR))
            {
                UNIV_PRINT_CRIT(("Main_recv_frame_parse: Length of the UDP buffer (%u) is less than the size of an UDP header (%u)", len, sizeof(UDP_HDR)));
                TRACE_CRIT("%!FUNC! Length of the UDP buffer (%u) is less than the size of an UDP header (%u)", len, sizeof(UDP_HDR));
                return FALSE;
            }
            
            /* Save a pointer to the UDP header and its "length". */
            pPacketInfo->IP.UDP.pHeader = (PUDP_HDR)hdrp;
            pPacketInfo->IP.UDP.Length = len;
            
            /* Add the length of the UDP header to the offset we're now looking
               for in the packet; in this case, the UDP payload. */
            hdr_len += sizeof(UDP_HDR);
            
            break;

        case TCPIP_PROTOCOL_GRE:
        case TCPIP_PROTOCOL_IPSEC1:
        case TCPIP_PROTOCOL_IPSEC2:
        case TCPIP_PROTOCOL_ICMP:
        default:

            /* For any other IP protocol, we have nothing in particular to do.
               Leave now, successfully. */
            return TRUE;
        }

        break;

    default:

        return TRUE;
    }

    /* As long as the byte offset we're looking for is NOT in the current buffer,
       keep looping through the available NDIS buffers. */
     while (curr_len + buf_len <= hdr_len)
     {
        /* Before we get the next buffer, accumulate the length of the buffer
           we're done with by adding its length to curr_len. */
        curr_len += buf_len;
        
        /* Get the next buffer in the chain. */
        NdisGetNextBuffer(bufp, &bufp);
        
        /* At this point, it is OK if we can't get to the payload of the packet.  Not 
           all TCP/UDP packets will actually HAVE a payload (such as TCP SYNs), so if
           we can't find it, leave successfully now, and the calling function will have
           to check the pointer value for NULL before accessing the payload if necessary. */
        if (bufp == NULL)
        {
            /* If this is a TCP packet, note the absence of the TCP payload. */
            if (pPacketInfo->IP.Protocol == TCPIP_PROTOCOL_TCP) 
            {
                pPacketInfo->IP.TCP.Payload.pPayload = NULL;
                pPacketInfo->IP.TCP.Payload.Length = 0;
                pPacketInfo->IP.TCP.Payload.pPayloadBuffer = NULL;
            } 
            /* If this is a UDP packet, note the absence of the UDP payload. */
            else if (pPacketInfo->IP.Protocol == TCPIP_PROTOCOL_UDP) 
            {
                pPacketInfo->IP.UDP.Payload.pPayload = NULL;
                pPacketInfo->IP.UDP.Payload.Length = 0;
                pPacketInfo->IP.UDP.Payload.pPayloadBuffer = NULL;
            }

            return TRUE;
        }
        
        /* Query the buffer for the virtual address of the buffer and its length. */
        NdisQueryBufferSafe(bufp, &memp, &buf_len, NormalPagePriority);
        
        if (memp == NULL)
        {
            UNIV_PRINT_CRIT(("Main_recv_frame_parse: NDIS buffer virtual memory address is NULL!"));
            TRACE_CRIT("%!FUNC! NDIS buffer virtual memory address is NULL!");
            return FALSE;
        }
     }
     
     /* The pointer to the payload we're looking for is the beginning of the buffer,
        plus the offset of the payload within this buffer.  Likewise, the contiguous
        memory accessible from this pointer is the length of this buffer, minus
        the byte offset at which the payload begins. */
     hdrp = memp + (hdr_len - curr_len);
     len = buf_len - (hdr_len - curr_len);

    /* Some special UDP and TCP packets require identification, so check to see whether
       this particular packet is one of those special types; NLB remote control or NetBT. */
    switch (pPacketInfo->IP.Protocol)
    { 
    case TCPIP_PROTOCOL_TCP: /* TCP. */

        /* If NetBT support is not enabled, then this is not an interesting NetBT packet 
           for sure.  Otherwise, look to see if it is. */
        if (ctxtp->params.nbt_support)
        {
            /* If this is a TCP data packet and its to the NBT session TCP port, mark it for 
               post-processing.  Since this is a receive, the server information is the
               destination.  NBT packets will be non-control (SYN, FIN, RST) packets. */
            if (!(TCP_GET_FLAGS(pPacketInfo->IP.TCP.pHeader) & (TCP_FLAG_SYN | TCP_FLAG_FIN | TCP_FLAG_RST)) && 
                (TCP_GET_DST_PORT(pPacketInfo->IP.TCP.pHeader) == NBT_SESSION_PORT)) 
            {
                UNIV_ASSERT(len > 0);

                /* We need to check the NetBT packet type field to make sure this is a 
                   packet we're interested.  The type is the first byte of a NetBT packet,
                   so if the payload length is AT LEAST one byte, check the NetBT packet
                   type and mark the packet if its a session request.  If it is not a 
                   session request, or there is no payload, do NOT mark the packet and 
                   let TCP/IP deal with it. */                
                if ((NBT_GET_PKT_TYPE((PNBT_HDR)hdrp) == NBT_SESSION_REQUEST))
                {
                    /* Found a NetBT session request. */
                    pPacketInfo->Operation = MAIN_FILTER_OP_NBT;
                    
                    UNIV_PRINT_VERB(("Main_recv_frame_parse: Found an NBT packet - NBT session packet"));
                    TRACE_VERB("%!FUNC! Found an NBT packet - NBT session packet");
                }
            }
        }

        /* If we did find an interesting NetBT packet, make sure that any restrictions 
           on the packet contents are satisfied. */
        if (pPacketInfo->Operation == MAIN_FILTER_OP_NBT)
        {
            /* We require that the entire NetBT header is contiguously accessible, or we will
               not process it.  Further, in the lookahead case, if not enough lookahead is 
               available to see the entire NetBT header, we will fail here and improperly 
               handle this NetBT packet.  This CAN BE FIXED if necessary, but for now, it 
               appears that TCP/IPs lookahead requirement of 128 bytes will ensure that this
               won't happen for now. */
            if (len < sizeof(NBT_HDR))
            {
                UNIV_PRINT_CRIT(("Main_recv_frame_parse: Length of the NBT buffer (%u) is less than the size of an NBT header (%u)", len, sizeof(NBT_HDR)));
                TRACE_CRIT("%!FUNC! Length of the NBT buffer (%u) is less than the size of an NBT header (%u)", len, sizeof(NBT_HDR));
                return FALSE;
            }                
        }

        /* Save a pointer to the TCP payload and its "length". */
        pPacketInfo->IP.TCP.Payload.pPayload = hdrp;
        pPacketInfo->IP.TCP.Payload.Length = len;
        
        /* Store a pointer to the buffer in which the payload resides in case
           it becomes necessary to retrieve subsequent buffers later. */
        pPacketInfo->IP.TCP.Payload.pPayloadBuffer = bufp;
        
        break;

    case TCPIP_PROTOCOL_UDP: /* UDP. */
    {
        ULONG clt_addr;
        ULONG svr_addr;
        ULONG clt_port;
        ULONG svr_port;
        
        /* Server address is the destination IP and client address is the source IP. */
        svr_addr = IP_GET_DST_ADDR_64(pPacketInfo->IP.pHeader);
        clt_addr = IP_GET_SRC_ADDR_64(pPacketInfo->IP.pHeader);
        
        /* If this is a receieve, then the server information is in the destination. */
        clt_port = UDP_GET_SRC_PORT(pPacketInfo->IP.UDP.pHeader);
        svr_port = UDP_GET_DST_PORT(pPacketInfo->IP.UDP.pHeader);
        
        /* Check for remote control responses. */
        if (clt_port == ctxtp->params.rct_port || clt_port == CVY_DEF_RCT_PORT_OLD) 
        {
            /* Only check for the magic word if the buffer is long enough to do so. 
               THIS SHOULD BE GUARANTEED ON THE PACKET RECEIVE PATH, except that it
               COULD be in a subsequent buffer (so its there, but we might not be 
               looking far enough into the packet)!!! */
            if (len >= NLB_MIN_RCTL_PAYLOAD_LEN)
            {
                PIOCTL_REMOTE_HDR rct_hdrp = (PIOCTL_REMOTE_HDR)hdrp;
                
                /* Check the remote control "magic word". */
                if (rct_hdrp->code == IOCTL_REMOTE_CODE) 
                {
                    /* Found a potential incoming remote control response. */
                    pPacketInfo->Operation = MAIN_FILTER_OP_CTRL_RESPONSE;
                    
                    UNIV_PRINT_VERB(("Main_recv_frame_parse: Found a remote control packet - incoming remote control response"));
                    TRACE_VERB("%!FUNC! Found a remote control packet - incoming remote control response");
                }
            } 
            else
            {
                /* Found a potential incoming remote control response. */
                pPacketInfo->Operation = MAIN_FILTER_OP_CTRL_RESPONSE;
                
                UNIV_PRINT_VERB(("Main_recv_frame_parse: Unable to verify remote control code - assuming this is a remote control packet"));
                TRACE_VERB("%!FUNC! Unable to verify remote control code - assuming this is a remote control packet");
            }
        }
        /* Check for remote control requests ONLY if remote control is turned ON. */
        else if (ctxtp->params.rct_enabled && 
                 (svr_port == ctxtp->params.rct_port || svr_port == CVY_DEF_RCT_PORT_OLD) && 
                 (svr_addr == ctxtp->cl_ip_addr      || svr_addr == TCPIP_BCAST_ADDR))
        {
            /* Only check for the magic word if the buffer is long enough to do so. 
               THIS SHOULD BE GUARANTEED ON THE PACKET RECEIVE PATH, except that it
               COULD be in a subsequent buffer (so its there, but we might not be 
               looking far enough into the packet)!!! */
            if (len >= NLB_MIN_RCTL_PAYLOAD_LEN)
            {
                PIOCTL_REMOTE_HDR rct_hdrp = (PIOCTL_REMOTE_HDR)hdrp;
                
                /* Check the remote control "magic word". */
                if (rct_hdrp->code == IOCTL_REMOTE_CODE) 
                {
                    /* Found a potential incoming remote control request. */
                    pPacketInfo->Operation = MAIN_FILTER_OP_CTRL_REQUEST;
                    
                    UNIV_PRINT_VERB(("Main_recv_frame_parse: Found a remote control packet - incoming remote control request"));
                    TRACE_VERB("%!FUNC! Found a remote control packet - incoming remote control request");
                }
            } 
            else
            {
                /* Found a potential incoming remote control request. */
                pPacketInfo->Operation = MAIN_FILTER_OP_CTRL_REQUEST;
                
                UNIV_PRINT_VERB(("Main_recv_frame_parse: Unable to verify remote control code - assuming this is a remote control packet"));
                TRACE_VERB("%!FUNC! Unable to verify remote control code - assuming this is a remote control packet");
            }
        }

        /* If we did find an NLB remote control packet, make sure that any restrictions 
           on the packet contents are satisfied. */
        if ((pPacketInfo->Operation == MAIN_FILTER_OP_CTRL_REQUEST) || (pPacketInfo->Operation == MAIN_FILTER_OP_CTRL_RESPONSE))
        {
            /* Make sure that the payload is at LEAST as long as the minimum remote control packet. */
            if (len < NLB_MIN_RCTL_PAYLOAD_LEN)
            {
                UNIV_PRINT_CRIT(("Main_recv_frame_parse: Length of the remote control buffer (%u) is less than the size of the minimum remote control packet (%u)", len, NLB_MIN_RCTL_PAYLOAD_LEN));
                TRACE_CRIT("%!FUNC! Length of the remote control buffer (%u) is less than the size of the minimum remote control packet (%u)", len, NLB_MIN_RCTL_PAYLOAD_LEN);
                return FALSE;
            }            
        }    

        if (pPacketInfo->Operation == MAIN_FILTER_OP_CTRL_REQUEST)
        {
            /* Note: It might be a good idea to further verify a remote control packet here, 
               rather than in Main_ctrl_recv, because in cases of failure, we would avoid
               the overhead of creating a new packet.  Some cases, such as a bad password,
               require creating the new packet anyway, because we reply with a "bad password"
               message.  The following are cases where we DROP a remote controln request:

               o Bad IP or UDP checksums
               o Bad remote control code (magic number)
               o Request not destined for this cluster
               o Remote control disabled
               o Request not destinted for this host
               o VR remote code not enabled (legacy crap that should be pulled out anyway)
               o Unsupported operations
               o Invalid request format (perhaps packet lengths, etc.)

               Many of these are not uncommon and we would be wise to reduce our overhead
               and risk for attack by not allocating resources in these cases. */
        }

        /* Save a pointer to the UDP payload and its "length". */
        pPacketInfo->IP.UDP.Payload.pPayload = hdrp;
        pPacketInfo->IP.UDP.Payload.Length = len;

        /* Store a pointer to the buffer in which the payload resides in case
           it becomes necessary to retrieve subsequent buffers later. */
        pPacketInfo->IP.UDP.Payload.pPayloadBuffer = bufp;

        break;
    }
    default:

        /* Nothing to verify.  Leave successfully now. */
        return TRUE;
    }

    /* Leave succesfully. */
    return TRUE;
}

/*
 * Function: Main_send_frame_parse
 * Description: This function parses an NDIS_PACKET and carefully extracts the information 
 *              necessary to handle the packet.  The information extracted includes pointers 
 *              to all relevant headers and payloads as well as the packet type (EType), IP 
 *              protocol (if appropriate), etc.  This function does all necessary validation 
 *              to ensure that all pointers are accessible for at least the specified number 
 *              of bytes; i.e., if this function returns successfully, the pointer to the IP 
 *              header is guaranteed to be accessible for at LEAST the length of the IP header.  
 *              No contents inside headers or payloads is validated, except for header lengths, 
 *              and special cases, such as NLB heartbeats or remote control packets.  If this
 *              function returns unsuccessfully, the contents of MAIN_PACKET_INFO cannot be 
 *              trusted and the packet should be discarded.  See the definition of MAIN_PACKET_INFO 
 *              in main.h for more specific indications of what fields are filled in and under 
 *              what circumstances.
 * Parameters: ctxtp - pointer to the main NLB context structure for this adapter.
 *             pPacket - pointer to an NDIS_PACKET.
 *             pPacketInfo - pointer to a MAIN_PACKET_INFO structure to hold the information
 *                           parsed from the packet.
 * Returns: BOOLEAN - TRUE if successful, FALSE if not.
 * Author: shouse, 3.4.02
 * Notes: 
 */
BOOLEAN Main_send_frame_parse (
    PMAIN_CTXT            ctxtp,        /* the context for this adapter */
    IN PNDIS_PACKET       pPacket,      /* pointer to an NDIS_PACKET */
    OUT PMAIN_PACKET_INFO pPacketInfo   /* pointer to an NLB packet information structure to hold the output */
)
{
    PNDIS_BUFFER          bufp = NULL;
    PUCHAR                memp = NULL;
    PUCHAR                hdrp = NULL;
    ULONG                 len = 0;
    UINT                  buf_len = 0;
    UINT                  packet_len = 0;
    ULONG                 curr_len = 0;
    ULONG                 hdr_len = 0;
    ULONG                 offset = 0;

    UNIV_ASSERT(pPacket);
    UNIV_ASSERT(pPacketInfo);

    /* Store a pointer to the original packet. */
    pPacketInfo->pPacket = pPacket;

    /* By default, this packet does not require post filtering special attention. */
    pPacketInfo->Operation = MAIN_FILTER_OP_NONE;                    

    /* Ask NDIS for the first buffer (bufp), the virtual address of the beginning of that buffer,
       (memp) the length of that buffer (buf_len) and the length of the entire packet (packet_len). */
    NdisGetFirstBufferFromPacketSafe(pPacket, &bufp, &memp, &buf_len, &packet_len, NormalPagePriority);
    
    if (bufp == NULL)
    {
        UNIV_PRINT_CRIT(("Main_send_frame_parse: NdisGetFirstBufferFromPacket returned NULL!"));
        TRACE_CRIT("%!FUNC! NdisGetFirstBufferFromPacket returned NULL!");
        return FALSE;
    }

    if (memp == NULL)
    {
        UNIV_PRINT_CRIT(("Main_send_frame_parse: NDIS buffer virtual memory address is NULL!"));
        TRACE_CRIT("%!FUNC! NDIS buffer virtual memory address is NULL!");
        return FALSE;
    }

    UNIV_ASSERT(ctxtp->medium == NdisMedium802_3);

    /* Get the destination MAC address offset, in bytes. */
    offset = CVY_MAC_DST_OFF(ctxtp->medium);

    /* The Ethernet header is memp, the beginning of the buffer and the length of contiguous
       memory accessible from that pointer is buf_len - the entire buffer. */
    pPacketInfo->Ethernet.pHeader = (PCVY_ETHERNET_HDR)memp;
    pPacketInfo->Ethernet.Length = buf_len;

    /* If, somehow, that length is not at least the size of an Ethernet header, bail out. */
    if (buf_len < sizeof(CVY_ETHERNET_HDR))
    {
        UNIV_PRINT_CRIT(("Main_send_frame_parse: Length of ethernet buffer (%u) is less than the size of an ethernet header (%u)", buf_len, sizeof(CVY_ETHERNET_HDR)));
        TRACE_CRIT("%!FUNC! Length of ethernet buffer (%u) is less than the size of an ethernet header (%u)", buf_len, sizeof(CVY_ETHERNET_HDR));
        return FALSE;
    }

    /* This variable accumulates the lengths of the headers that we've successfully "found". */
    hdr_len = sizeof(CVY_ETHERNET_HDR);

    /* Set the medium and retrieve the Ethernet packet type from the header. */
    pPacketInfo->Medium = NdisMedium802_3;
    pPacketInfo->Type = CVY_ETHERNET_ETYPE_GET(pPacketInfo->Ethernet.pHeader);

    /* Categorize this packet as unicast, multicast or broadcast by looking at the destination 
       MAC address and store the "group" in the packet information structure.  This is used
       for statistical purposes later. */
    if (!CVY_MAC_ADDR_MCAST(ctxtp->medium, (PUCHAR)pPacketInfo->Ethernet.pHeader + offset))
    {
        pPacketInfo->Group = MAIN_FRAME_DIRECTED;
    }
    else
    {
        if (CVY_MAC_ADDR_BCAST(ctxtp->medium, (PUCHAR)pPacketInfo->Ethernet.pHeader + offset))
            pPacketInfo->Group = MAIN_FRAME_BROADCAST;
        else
            pPacketInfo->Group = MAIN_FRAME_MULTICAST;
    }

    /* A length indication from an NDIS_PACKET includes the MAC header, 
       so subtract that to get the length of the payload. */
    pPacketInfo->Length = packet_len - hdr_len;

    /* As long as the byte offset we're looking for is NOT in the current buffer,
       keep looping through the available NDIS buffers. */
    while (curr_len + buf_len <= hdr_len)
    {
        /* Before we get the next buffer, accumulate the length of the buffer
           we're done with by adding its length to curr_len. */
        curr_len += buf_len;
        
        /* Get the next buffer in the chain. */
        NdisGetNextBuffer(bufp, &bufp);
        
        /* At this point, we expect to be able to successfully find the offset we're
           looking for, so if we've run out of buffers, fail. */
        if (bufp == NULL)
        {
            UNIV_PRINT_CRIT(("Main_send_frame_parse: NdisGetNextBuffer returned NULL when more data was expected!"));
            TRACE_CRIT("%!FUNC! NdisGetNextBuffer returned NULL when more data was expected!");
            return FALSE;
        }
        
        /* Query the buffer for the virtual address of the buffer and its length. */
        NdisQueryBufferSafe(bufp, &memp, &buf_len, NormalPagePriority);
        
        if (memp == NULL)
        {
            UNIV_PRINT_CRIT(("Main_send_frame_parse: NDIS buffer virtual memory address is NULL!"));
            TRACE_CRIT("%!FUNC! NDIS buffer virtual memory address is NULL!");
            return FALSE;
        }
    }
    
    /* The pointer to the header we're looking for is the beginning of the buffer,
       plus the offset of the header within this buffer.  Likewise, the contiguous
       memory accessible from this pointer is the length of this buffer, minus
       the byte offset at which the header begins. */        
    hdrp = memp + (hdr_len - curr_len);
    len = buf_len - (hdr_len - curr_len);

    /* Based on the packet type, enforce some restrictions and setup any further
       information we need to find in the packet. */
    switch (pPacketInfo->Type)
    {
    case TCPIP_IP_SIG: /* IP packets. */

        /* If the contiguous memory accessible from the IP header is not at 
           LEAST the minimum length of an IP header, bail out now. */
        if (len < sizeof(IP_HDR))
        {
            UNIV_PRINT_CRIT(("Main_send_frame_parse: Length of the IP buffer (%u) is less than the size of an IP header (%u)", len, sizeof(IP_HDR)));
            TRACE_CRIT("%!FUNC! Length of the IP buffer (%u) is less than the size of an IP header (%u)", len, sizeof(IP_HDR));
            return FALSE;
        }
        
        /* Save a pointer to the IP header and its "length". */
        pPacketInfo->IP.pHeader = (PIP_HDR)hdrp;
        pPacketInfo->IP.Length = len;

        /* Extract the IP protocol from the IP header. */
        pPacketInfo->IP.Protocol = IP_GET_PROT(pPacketInfo->IP.pHeader);

        /* Calculate the actual IP header length by extracting the hlen field
           from the IP header and multiplying by the size of a DWORD. */
        len = sizeof(ULONG) * IP_GET_HLEN(pPacketInfo->IP.pHeader);
		
        /* If this calculated header length is not at LEAST the minimum IP 
           header length, bail out now. */
        if (len < sizeof(IP_HDR))
        {
            UNIV_PRINT_CRIT(("Main_send_frame_parse: Calculated IP header length (%u) is less than the size of an IP header (%u)", len, sizeof(IP_HDR)));
            TRACE_CRIT("%!FUNC! Calculated IP header length (%u) is less than the size of an IP header (%u)", len, sizeof(IP_HDR));
            return FALSE;
        }

#if 0 /* Because the options can be in separate buffers (at least in sends), don't bother to 
         enforce this condition; NLB never looks at the options anyway, so we don't really care. */

        /* If the contiguous memory accessible from the IP header is not at
           LEAST the calculated size of the IP header, bail out now. */
        if (pPacketInfo->IP.Length < len)
        {
            UNIV_PRINT_CRIT(("Main_send_frame_parse: Length of the IP buffer (%u) is less than the size of the IP header (%u)", pPacketInfo->IP.Length, len));
            TRACE_CRIT("%!FUNC! Length of the IP buffer (%u) is less than the size of the IP header (%u)", pPacketInfo->IP.Length, len);
            return FALSE;
        }
#endif

        /* The total packet length, in bytes, specified in the header, which includes
           both the IP header and payload, can be no more than the packet length that 
           NDIS told us, which is the entire network packet, minus the media header. */
        if (IP_GET_PLEN(pPacketInfo->IP.pHeader) > pPacketInfo->Length)
        {
            UNIV_PRINT_CRIT(("Main_send_frame_parse: IP packet length (%u) is greater than the indicated packet length (%u)", IP_GET_PLEN(pPacketInfo->IP.pHeader), pPacketInfo->Length));
            TRACE_CRIT("%!FUNC! IP packet length (%u) is greater than the indicated packet length (%u)", IP_GET_PLEN(pPacketInfo->IP.pHeader), pPacketInfo->Length);
            return FALSE;
        }

        /* If this packet is a subsequent IP fragment, note that in the packet
           information structure and leave now, successfully. */
        if (IP_GET_FRAG_OFF(pPacketInfo->IP.pHeader) != 0)
        {
            pPacketInfo->IP.bFragment = TRUE;
            return TRUE;
        }
        /* Otherwise, mark the packet as NOT a subsequent fragment and continue. */
        else
        {
            pPacketInfo->IP.bFragment = FALSE;
        }

        /* Add the length of the IP header to the offset we're now looking
           for in the packet; in this case, the TCP/UDP/etc. header. */
        hdr_len += len;

        break;

    case TCPIP_ARP_SIG: /* ARPs. */

        /* If the contiguous memory accessible from the ARP header is not at 
           LEAST the length of an ARP header, bail out now. */        
        if (len < sizeof(ARP_HDR))
        {
            UNIV_PRINT_CRIT(("Main_send_frame_parse: Length of the ARP buffer (%u) is less than the size of an ARP header (%u)", len, sizeof(ARP_HDR)));
            TRACE_CRIT("%!FUNC! Length of the ARP buffer (%u) is less than the size of an ARP header (%u)", len, sizeof(ARP_HDR));
            return FALSE;
        }

        /* Save a pointer to the ARP header and its "length". */
        pPacketInfo->ARP.pHeader = (PARP_HDR)hdrp;
        pPacketInfo->ARP.Length = len;

        /* Nothing more to look for in an ARP.  Leave now, successfully. */
        return TRUE;
        
    default: /* Any Ethernet type other than IP and ARP. */

        /* Store a pointer to the unknown header and its "length". */
        pPacketInfo->Unknown.pHeader = hdrp;
        pPacketInfo->Unknown.Length = len;

        /* Nothing more to look for in this packet.  Leave now, successfully. */
        return TRUE;
    }

    /* As long as the byte offset we're looking for is NOT in the current buffer,
       keep looping through the available NDIS buffers. */
    while (curr_len + buf_len <= hdr_len)
    {
        /* Before we get the next buffer, accumulate the length of the buffer
           we're done with by adding its length to curr_len. */
        curr_len += buf_len;
        
        /* Get the next buffer in the chain. */
        NdisGetNextBuffer(bufp, &bufp);
        
        /* At this point, we expect to be able to successfully find the offset we're
           looking for, so if we've run out of buffers, fail. */
        if (bufp == NULL)
        {
            UNIV_PRINT_CRIT(("Main_send_frame_parse: NdisGetNextBuffer returned NULL when more data was expected!"));
            TRACE_CRIT("%!FUNC! NdisGetNextBuffer returned NULL when more data was expected!");
            return FALSE;
        }
        
        /* Query the buffer for the virtual address of the buffer and its length. */
        NdisQueryBufferSafe(bufp, &memp, &buf_len, NormalPagePriority);
        
        if (memp == NULL)
        {
            UNIV_PRINT_CRIT(("Main_send_frame_parse: NDIS buffer virtual memory address is NULL!"));
            TRACE_CRIT("%!FUNC! NDIS buffer virtual memory address is NULL!");
            return FALSE;
        }
    }
    
    /* The pointer to the header we're looking for is the beginning of the buffer,
       plus the offset of the header within this buffer.  Likewise, the contiguous
       memory accessible from this pointer is the length of this buffer, minus
       the byte offset at which the header begins. */        
    hdrp = memp + (hdr_len - curr_len);
    len = buf_len - (hdr_len - curr_len);

    /* Based on the packet type, enforce some restrictions and setup any further
       information we need to find in the packet. */
    switch (pPacketInfo->Type)
    {
    case TCPIP_IP_SIG: /* IP packets. */
    
        /* For some protocols, we have more to look for in the packet. */
        switch (pPacketInfo->IP.Protocol)
        { 
        case TCPIP_PROTOCOL_TCP: /* TCP. */
            
            /* If the contiguous memory accessible from the TCP header is not at 
               LEAST the minimum length of a TCP header, bail out now. */        
            if (len < sizeof(TCP_HDR))
            {
                UNIV_PRINT_CRIT(("Main_send_frame_parse: Length of the TCP buffer (%u) is less than the size of an TCP header (%u)", len, sizeof(TCP_HDR)));
                TRACE_CRIT("%!FUNC! Length of the TCP buffer (%u) is less than the size of an TCP header (%u)", len, sizeof(TCP_HDR));
                return FALSE;
            }
            
            /* Save a pointer to the TCP header and its "length". */
            pPacketInfo->IP.TCP.pHeader = (PTCP_HDR)hdrp;
            pPacketInfo->IP.TCP.Length = len;
            
            /* Calculate the actual TCP header length by extracting the hlen field
               from the TCP header and multiplying by the size of a DWORD. */
            len = sizeof(ULONG) * TCP_GET_HLEN(pPacketInfo->IP.TCP.pHeader);

            /* If this calculated header length is not at LEAST the minimum TCP 
               header length, bail out now. */
            if (len < sizeof(TCP_HDR))
            {
                UNIV_PRINT_CRIT(("Main_send_frame_parse: Calculated TCP header length (%u) is less than the size of an TCP header (%u)", len, sizeof(TCP_HDR)));
                TRACE_CRIT("%!FUNC! Calculated TCP header length (%u) is less than the size of an TCP header (%u)", len, sizeof(TCP_HDR));
                return FALSE;
            }
            
#if 0 /* Because the options can be in separate buffers (at least in sends), don't bother to 
         enforce this condition; NLB never looks at the options anyway, so we don't really care. */

            /* If the contiguous memory accessible from the TCP header is not at
               LEAST the calculated size of the TCP header, bail out now. */
            if (pPacketInfo->IP.TCP.Length < len)
            {
                UNIV_PRINT_CRIT(("Main_send_frame_parse: Length of the TCP buffer (%u) is less than the size of the TCP header (%u)", pPacketInfo->IP.TCP.Length, len));
                TRACE_CRIT("%!FUNC! Length of the TCP buffer (%u) is less than the size of the TCP header (%u)", pPacketInfo->IP.TCP.Length, len);
                return FALSE;
            }
#endif

            /* Since we never look into TCP payloads on the packet send path,
               note in the packet information structure that the TCP payload
               has not been parsed, and exit now. */
            pPacketInfo->IP.TCP.Payload.pPayload = NULL;
            pPacketInfo->IP.TCP.Payload.Length = 0;
            pPacketInfo->IP.TCP.Payload.pPayloadBuffer = NULL;
            
            /* Nothing more to look for in this packet.  Leave now, successfully. */
            return TRUE;

        case TCPIP_PROTOCOL_UDP:
            
            /* If the contiguous memory accessible from the UDP header is not at 
               LEAST the length of a UDP header, bail out now. */
            if (len < sizeof(UDP_HDR))
            {
                UNIV_PRINT_CRIT(("Main_send_frame_parse: Length of the UDP buffer (%u) is less than the size of an UDP header (%u)", len, sizeof(UDP_HDR)));
                TRACE_CRIT("%!FUNC! Length of the UDP buffer (%u) is less than the size of an UDP header (%u)", len, sizeof(UDP_HDR));
                return FALSE;
            }
            
            /* Save a pointer to the UDP header and its "length". */
            pPacketInfo->IP.UDP.pHeader = (PUDP_HDR)hdrp;
            pPacketInfo->IP.UDP.Length = len;
            
            /* Add the length of the UDP header to the offset we're now looking
               for in the packet; in this case, the UDP payload. */
            hdr_len += sizeof (UDP_HDR);
            
            break;

        case TCPIP_PROTOCOL_GRE:
        case TCPIP_PROTOCOL_IPSEC1:
        case TCPIP_PROTOCOL_IPSEC2:
        case TCPIP_PROTOCOL_ICMP:
        default:

            /* For any other IP protocol, we have nothing in particular to do.
               Leave now, successfully. */
            return TRUE;
        }

        break;

    default:

        return TRUE;
    }

    /* As long as the byte offset we're looking for is NOT in the current buffer,
       keep looping through the available NDIS buffers. */
    while (curr_len + buf_len <= hdr_len)
    {
        /* Before we get the next buffer, accumulate the length of the buffer
           we're done with by adding its length to curr_len. */
        curr_len += buf_len;
        
        /* Get the next buffer in the chain. */
        NdisGetNextBuffer(bufp, &bufp);
        
        /* At this point, it is OK if we can't get to the payload of the packet.  Not 
           all TCP/UDP packets will actually HAVE a payload (such as TCP SYNs), so if
           we can't find it, leave successfully now, and the calling function will have
           to check the pointer value for NULL before accessing the payload if necessary. */
        if (bufp == NULL)
        {
            if (pPacketInfo->IP.Protocol == TCPIP_PROTOCOL_UDP)
            {
                /* If this is a UDP packet, note the absence of the UDP payload. */
                pPacketInfo->IP.UDP.Payload.pPayload = NULL;
                pPacketInfo->IP.UDP.Payload.Length = 0;
                pPacketInfo->IP.UDP.Payload.pPayloadBuffer = NULL;
            }

            return TRUE;
        }
        
        /* Query the buffer for the virtual address of the buffer and its length. */
        NdisQueryBufferSafe(bufp, &memp, &buf_len, NormalPagePriority);
        
        if (memp == NULL)
        {
            /* At this point, it is OK if we can't get to the payload of the packet.  Not 
               all TCP/UDP packets will actually HAVE a payload (such as TCP SYNs), so if
               we can't find it, leave successfully now, and the calling function will have
               to check the pointer value for NULL before accessing the payload if necessary. */
            if (pPacketInfo->IP.Protocol == TCPIP_PROTOCOL_UDP)
            {
                /* If this is a UDP packet, note the absence of the UDP payload. */
                pPacketInfo->IP.UDP.Payload.pPayload = NULL;
                pPacketInfo->IP.UDP.Payload.Length = 0;
                pPacketInfo->IP.UDP.Payload.pPayloadBuffer = NULL;
            }

            return TRUE;
        }
    }
    
    /* The pointer to the header we're looking for is the beginning of the buffer,
       plus the offset of the header within this buffer.  Likewise, the contiguous
       memory accessible from this pointer is the length of this buffer, minus
       the byte offset at which the header begins. */        
    hdrp = memp + (hdr_len - curr_len);
    len = buf_len - (hdr_len - curr_len);

    /* Some special UDP and TCP packets require identification, so check to see whether
       this particular packet is one of those special types; NLB remote control or NetBT. */
    switch (pPacketInfo->IP.Protocol)
    { 
    case TCPIP_PROTOCOL_UDP: /* UDP. */
    {
        ULONG clt_addr;
        ULONG clt_port;

        /* Note that the only outgoing remote control traffic seen here is outgoing requests.
           Outgoing replies do NOT traverse the normal packet send path. */
            
        /* If this is a send request, then the client (peer) is in the destination. */
        clt_addr = IP_GET_DST_ADDR_64(pPacketInfo->IP.pHeader);
        clt_port = UDP_GET_DST_PORT(pPacketInfo->IP.UDP.pHeader);
        
        /* IP broadcast UDP packets generated by wlbs.exe. */
        if ((clt_port == ctxtp->params.rct_port || clt_port == CVY_DEF_RCT_PORT_OLD) && clt_addr == TCPIP_BCAST_ADDR) 
        {
            /* Only check for the magic word if the buffer is long enough to do so. 
               THIS SHOULD BE GUARANTEED ON THE SEND PATH, except that it COULD
               be in a subsequent buffer (so its there, but we might not be looking 
               far enough into the packet)!!! */
            if (len >= NLB_MIN_RCTL_PAYLOAD_LEN)
            {
                PIOCTL_REMOTE_HDR rct_hdrp = (PIOCTL_REMOTE_HDR)hdrp;
                
                /* Check the remote control "magic word". */
                if (rct_hdrp->code == IOCTL_REMOTE_CODE) 
                {
                    /* Found an outgoing remote control request. */
                    pPacketInfo->Operation = MAIN_FILTER_OP_CTRL_REQUEST;
                    
                    UNIV_PRINT_VERB(("Main_send_frame_parse: Found a remote control packet - outgoing remote control request"));
                    TRACE_VERB("%!FUNC! Found a remote control packet - outgoing remote control request");
                }
            } 
            else
            {
                /* Found a potential outgoing remote control request. */
                pPacketInfo->Operation = MAIN_FILTER_OP_CTRL_REQUEST;
                
                UNIV_PRINT_VERB(("Main_send_frame_parse: Unable to verify remote control code - assuming this is a remote control packet"));
                TRACE_VERB("%!FUNC! Unable to verify remote control code - assuming this is a remote control packet");
            }
        }

        /* If we did find an NLB remote control packet, make sure that any restrictions 
           on the packet contents are satisfied. */
        if (pPacketInfo->Operation == MAIN_FILTER_OP_CTRL_REQUEST)
        {
            /* Make sure that the payload is at LEAST as long as the minimum remote control packet. */
            if (len < NLB_MIN_RCTL_PAYLOAD_LEN)
            {
                UNIV_PRINT_CRIT(("Main_send_frame_parse: Length of the remote control buffer (%u) is less than the size of the minimum remote control packet (%u)", len, NLB_MIN_RCTL_PAYLOAD_LEN));
                TRACE_CRIT("%!FUNC! Length of the remote control buffer (%u) is less than the size of the minimum remote control packet (%u)", len, NLB_MIN_RCTL_PAYLOAD_LEN);
                return FALSE;
            }            
        }    

        /* Save a pointer to the UDP payload and its "length". */
        pPacketInfo->IP.UDP.Payload.pPayload = hdrp;
        pPacketInfo->IP.UDP.Payload.Length = len;

        /* Store a pointer to the buffer in which the payload resides in case
           it becomes necessary to retrieve subsequent buffers later. */
        pPacketInfo->IP.UDP.Payload.pPayloadBuffer = bufp;

        break;
    }
    default:

        /* Nothing to verify.  Leave successfully now. */
        return TRUE;
    }

    /* Leave succesfully. */
    return TRUE;
}

/* 
 * Function: Main_query_params
 * Desctription: This function queries the current state of the NLB registry parameters
 *               in the driver, which can be useful to ensure that the driver is properly
 *               receiving parameter changes made in user-space.  Under normal circumstances,
 *               the registry parameters retrievable from user-space (WlbsReadReg) will be
 *               identical to those retrieved here.  Possible exceptions include when the 
 *               registry parameters are invalid, in which case they will be rejected by a
 *               "wlbs reload" operation and the registry and driver will be out of sync.
 * Parameters: ctxtp - a pointer to the appropriate NLB context structure. 
 *             pParams - a pointer to a buffer into which the parameters are placed.
 * Returns: Nothing.
 * Author: shouse, 5.18.01
 * Notes: Of course, this function should NOT change parameters, just copy them into the buffer.
 */
VOID Main_query_params (PMAIN_CTXT ctxtp, PNLB_OPTIONS_PARAMS pParams)
{
    ULONG index;

    UNIV_ASSERT(ctxtp);
    UNIV_ASSERT(pParams);

    /* copy the parameters from this NLB instance's params strucutre into the IOCTL buffer. */
    pParams->Version                   = ctxtp->params.parms_ver;
    pParams->EffectiveVersion          = ctxtp->params.effective_ver;
    pParams->HostPriority              = ctxtp->params.host_priority;
    pParams->HeartbeatPeriod           = ctxtp->params.alive_period;
    pParams->HeartbeatLossTolerance    = ctxtp->params.alive_tolerance;
    pParams->NumActionsAlloc           = ctxtp->params.num_actions;
    pParams->NumPacketsAlloc           = ctxtp->params.num_packets;
    pParams->NumHeartbeatsAlloc        = ctxtp->params.num_send_msgs;
    pParams->InstallDate               = ctxtp->params.install_date;
    pParams->RemoteMaintenancePassword = ctxtp->params.rmt_password;
    pParams->RemoteControlPassword     = ctxtp->params.rct_password;
    pParams->RemoteControlPort         = ctxtp->params.rct_port;
    pParams->RemoteControlEnabled      = ctxtp->params.rct_enabled;
    pParams->NumPortRules              = ctxtp->params.num_rules;
    pParams->ConnectionCleanUpDelay    = ctxtp->params.cleanup_delay;
    pParams->ClusterModeOnStart        = ctxtp->params.cluster_mode;
    pParams->HostState                 = ctxtp->params.init_state;
    pParams->PersistedStates           = ctxtp->params.persisted_states;
    pParams->DescriptorsPerAlloc       = ctxtp->params.dscr_per_alloc;
    pParams->MaximumDescriptorAllocs   = ctxtp->params.max_dscr_allocs;
    pParams->TCPConnectionTimeout      = ctxtp->params.tcp_dscr_timeout;
    pParams->IPSecConnectionTimeout    = ctxtp->params.ipsec_dscr_timeout;
    pParams->FilterICMP                = ctxtp->params.filter_icmp;
    pParams->ScaleClient               = ctxtp->params.scale_client;
    pParams->NBTSupport                = ctxtp->params.nbt_support;
    pParams->MulticastSupport          = ctxtp->params.mcast_support;
    pParams->MulticastSpoof            = ctxtp->params.mcast_spoof;
    pParams->IGMPSupport               = ctxtp->params.igmp_support;
    pParams->MaskSourceMAC             = ctxtp->params.mask_src_mac;
    pParams->NetmonReceiveHeartbeats   = ctxtp->params.netmon_alive;
    pParams->ClusterIPToMAC            = ctxtp->params.convert_mac;
    pParams->IPChangeDelay             = ctxtp->params.ip_chg_delay;
    pParams->IdentityHeartbeatPeriod   = ctxtp->params.identity_period;
    pParams->IdentityHeartbeatEnabled  = ctxtp->params.identity_enabled;
    
    /* Copy the strings into the IOCTL buffer. */
    NdisMoveMemory(pParams->ClusterIPAddress,       ctxtp->params.cl_ip_addr,   (CVY_MAX_CL_IP_ADDR + 1) * sizeof(WCHAR));
    NdisMoveMemory(pParams->ClusterNetmask,         ctxtp->params.cl_net_mask,  (CVY_MAX_CL_NET_MASK + 1) * sizeof(WCHAR));
    NdisMoveMemory(pParams->DedicatedIPAddress,     ctxtp->params.ded_ip_addr,  (CVY_MAX_DED_IP_ADDR + 1) * sizeof(WCHAR));
    NdisMoveMemory(pParams->DedicatedNetmask,       ctxtp->params.ded_net_mask, (CVY_MAX_DED_NET_MASK + 1) * sizeof(WCHAR));
    NdisMoveMemory(pParams->ClusterMACAddress,      ctxtp->params.cl_mac_addr,  (CVY_MAX_NETWORK_ADDR + 1) * sizeof(WCHAR));
    NdisMoveMemory(pParams->DomainName,             ctxtp->params.domain_name,  (CVY_MAX_DOMAIN_NAME + 1) * sizeof(WCHAR));
    NdisMoveMemory(pParams->IGMPMulticastIPAddress, ctxtp->params.cl_igmp_addr, (CVY_MAX_CL_IGMP_ADDR + 1) * sizeof(WCHAR));
    NdisMoveMemory(pParams->HostName,               ctxtp->params.hostname,     (CVY_MAX_FQDN + 1) * sizeof(WCHAR));
 
    /* Copy the BDA teaming parameters into the IOCTL buffer. */
    NdisMoveMemory(pParams->BDATeaming.TeamID, ctxtp->params.bda_teaming.team_id, (CVY_MAX_BDA_TEAM_ID + 1) * sizeof(WCHAR));
    pParams->BDATeaming.Active      = ctxtp->params.bda_teaming.active;
    pParams->BDATeaming.Master      = ctxtp->params.bda_teaming.master;
    pParams->BDATeaming.ReverseHash = ctxtp->params.bda_teaming.reverse_hash;

    /* Loop throgh and copy all port rules into the IOCTL buffer. */
    for (index = 0; index < ctxtp->params.num_rules; index++) {
        pParams->PortRules[index].Valid            = ctxtp->params.port_rules[index].valid;
        pParams->PortRules[index].Code             = ctxtp->params.port_rules[index].code;
        pParams->PortRules[index].VirtualIPAddress = ctxtp->params.port_rules[index].virtual_ip_addr;
        pParams->PortRules[index].StartPort        = ctxtp->params.port_rules[index].start_port;
        pParams->PortRules[index].EndPort          = ctxtp->params.port_rules[index].end_port;
        pParams->PortRules[index].Protocol         = ctxtp->params.port_rules[index].protocol;
        pParams->PortRules[index].Mode             = ctxtp->params.port_rules[index].mode;

        switch (ctxtp->params.port_rules[index].mode) {
        case CVY_SINGLE:
            pParams->PortRules[index].SingleHost.Priority     = ctxtp->params.port_rules[index].mode_data.single.priority;
            break;
        case CVY_MULTI:
            pParams->PortRules[index].MultipleHost.Equal      = ctxtp->params.port_rules[index].mode_data.multi.equal_load;
            pParams->PortRules[index].MultipleHost.Affinity   = ctxtp->params.port_rules[index].mode_data.multi.affinity;
            pParams->PortRules[index].MultipleHost.LoadWeight = ctxtp->params.port_rules[index].mode_data.multi.load;
            break;
        case CVY_NEVER:
        default:
            break;
        }
    }

    /* Query the load module for some relevant statistics.  Don't bother to lock the load module - its not strictly necessary. */
    if (!Load_query_statistics(&ctxtp->load, &pParams->Statistics.ActiveConnections, &pParams->Statistics.DescriptorsAllocated)) {
        /* This function returns FALSE if the load module is inactive.  In that case, return
           zero for both the number of active connections and descriptors allocated. */
        pParams->Statistics.ActiveConnections = 0;
        pParams->Statistics.DescriptorsAllocated = 0;
    }
}

/* 
 * Function: Main_query_bda_teaming
 * Desctription: This function retrieves the state of a given BDA team, including the
 *               current state of operation, the configuration and a list of the team
 *               members.  Because the teaming information is global, this function
 *               can be run in the context (MAIN_CTXT) of ANY adapter - it doesn't 
 *               even need to be a member of the team being queried.  User level 
 *               applications should choose a cluster on which to perform the IOCTL,
 *               which can be an arbitrary decision.  This function attempts to find
 *               the specified team, and if successful then loops through the global
 *               array of adapters attempting to find the members of the team.  This
 *               is necessary because there is no "link" from the global teaming state
 *               back to the members - only from members to their teams.  Because this
 *               state is global, this function MUST grab the global teaming lock and
 *               hold it until it returns.
 * Parameters: ctxtp - a pointer to an NLB instance (which instance is irrelevant).
 *             pTeam - a pointer to a buffer into which the results are placed. 
 * Returns: ULONG - IOCTL_CVY_NOT_FOUND if the specified team cannot be found.
 *                - IOCTL_CVY_GENERIC_FAILURE if we can't find all of the team members.
 *                - IOCTL_CVY_OK if all goes well.
 * Author: shouse, 5.18.01
 * Notes: This function grabs the global teaming lock.  Because it is a query operation,
 *        NO changes are made to the actual state of NLB or BDA teaming. 
 */
ULONG Main_query_bda_teaming (PMAIN_CTXT ctxtp, PNLB_OPTIONS_BDA_TEAMING pTeam)
{
    PBDA_MEMBER memberp;
    PBDA_TEAM   teamp;
    ULONG       index;
    ULONG       count;

    UNIV_ASSERT(ctxtp);
    UNIV_ASSERT(pTeam);
    
    /* Because the teaming state can change at any time, we have to grab the global 
       team lock first and hold until we're done to prevent ourselves from running
       off the end of linked lists, or accessing invalid memory, etc. */
    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* Try to find the specified team.  If it's not in the list, bail out. */
    if (!(teamp = Main_find_team(ctxtp, pTeam->TeamID))) {
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return IOCTL_CVY_NOT_FOUND;
    }

    /* If we found it, fill in the team's state and configuration. */
    pTeam->Team.Active                = teamp->active;
    pTeam->Team.MembershipCount       = teamp->membership_count;
    pTeam->Team.MembershipFingerprint = teamp->membership_fingerprint;
    pTeam->Team.MembershipMap         = teamp->membership_map;
    pTeam->Team.ConsistencyMap        = teamp->consistency_map;
    
    /* Because the team structure does not contain a "list" of members, we need to
       loop through all NLB instances and try to match members to their teams. */
    for (index = 0, count = 0; index < CVY_MAX_ADAPTERS; index++) {
        /* If the global adapter structure is not in used, or isn't initialized, no need to do anything. */
        if (univ_adapters[index].used && univ_adapters[index].bound && univ_adapters[index].inited && univ_adapters[index].ctxtp) {
            /* If this adapter is in use, then grab a pointer to its teaming configuration. */
            memberp = &(univ_adapters[index].ctxtp->bda_teaming);

            /* If the member is active, then we need to check what team it belongs to.
               If its not active, then we can skip it. */
            if (memberp->active) {
                /* If this adapter is actively teaming, it HAD BETTER have a pointer to its team. */
                UNIV_ASSERT(memberp->bda_team);
                    
                /* Check to see if the team we are querying is the same team that this adapter belongs to. */
                if (memberp->bda_team == teamp) {
                    /* If it is, fill in the state and configuration of this member. */
                    pTeam->Team.Members[count].ClusterIPAddress = univ_adapters[index].ctxtp->cl_ip_addr;
                    pTeam->Team.Members[count].ReverseHash      = memberp->reverse_hash;
                    pTeam->Team.Members[count].MemberID         = memberp->member_id;
                    pTeam->Team.Members[count].Master           = memberp->master;

                    /* If this team member is the team's master, fill in the master field
                       with the cluster IP address of this adapter. */
                    if (memberp->master) 
                        pTeam->Team.Master = univ_adapters[index].ctxtp->cl_ip_addr;

                    /* Increment the number of members that we have found so far. */
                    count++;
                }
            }
        }
    }

    /* If we were unable to find all of the members, or if we found to many, then
       return failure.  There is a small time window during which this can happen,
       but that's not worth worrying about - users can simply try again.  For 
       instance, if a member is joining its team during a bind operation, it could 
       grab the global lock and update its configuration and that of the team, before 
       the adapter.init flag is set.  Therefore, if we execute in between those two
       events, we will miss a member when we loop through the adapter strucutres 
       (because the init flag is FALSE).  So what - we fail and they try again, at 
       which point the call will (should) succeed. */
    if (count != teamp->membership_count) {
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        TRACE_CRIT("%!FUNC! expected team membership count=%u, but counted %u", teamp->membership_count, count);
        return IOCTL_CVY_GENERIC_FAILURE;
    }

    /* Now that we're done, we can release the global teaming lock. */
    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    return IOCTL_CVY_OK;
}

NDIS_STATUS Main_dispatch (PVOID DeviceObject, PVOID Irp) 
{
    NDIS_STATUS             status = NDIS_STATUS_SUCCESS;
    PIRP                    pIrp = Irp;
    PIO_STACK_LOCATION      pIrpStack;
    
    UNIV_PRINT_VERB(("Main_dispatch: Device=%p, Irp=%p \n", DeviceObject, Irp));

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    
    switch (pIrpStack->MajorFunction) {
    case IRP_MJ_CREATE:
        /* Security fix: Verify that the user mode app is NOT attempting to do a "file" open (ie. \\.\Wlbs\) 
                         as opposed to a "device" open (ie. \\.\Wlbs). On a "file" open, note that there is a trailing 
                         backslash ("\"). Only devices that have namespaces support "file" open. NLB does not.
        */
        if (pIrpStack->FileObject->FileName.Length != 0)
        {
            UNIV_PRINT_CRIT(("Main_dispatch: Attempt to open wlbs device object as a file (instead of as a device), File name length (%d) is non-zero, Returning STATUS_ACCESS_DENIED\n", pIrpStack->FileObject->FileName.Length));
            TRACE_CRIT("%!FUNC! Attempt to open wlbs device object as a file (instead of as a device), File name length (%d) is non-zero, Returning STATUS_ACCESS_DENIED\n", pIrpStack->FileObject->FileName.Length);
            status = STATUS_ACCESS_DENIED;
        }
        break;        

    case IRP_MJ_DEVICE_CONTROL:
        status = Main_ioctl(DeviceObject, Irp);
        break;        

    case IRP_MJ_SYSTEM_CONTROL:
        return (NDIS_STATUS)NlbWmi_System_Control(DeviceObject, pIrp);
        break;

    default:
        break;
    }
    
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    return status;
} 

#if defined (NLB_HOOK_ENABLE)
/* 
 * Function: Main_register_hook
 * Desctription: This function handles hook register and de-register requests from other
 *               components.  It processes the input buffer received via an IOCTL and 
 *               performs the requested operation GLOBALLY.
 * Parameters: 
 * Returns: NDIS_STATUS - indicates whether or not the operation succeeded.  See ntddnlb.h
 *          for a list of return values and their meanings.
 * Author: shouse, 12.10.01
 * Notes: This function may sleep as a result of waiting for references on a registered
 *        hook to be relinquished.
 */
NDIS_STATUS Main_register_hook (PVOID DeviceObject, PVOID Irp)
{
    PNLB_IOCTL_REGISTER_HOOK_REQUEST pRequest;
    PIO_STACK_LOCATION               pIrpStack;
    PIRP                             pIrp = Irp;
    ULONG                            ilen, olen = 0;
    ULONG                            ioctl;
    ULONG                            index;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    ioctl = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

    /* This function handles ONLY the hook (de)register IOCTL. */
    UNIV_ASSERT(ioctl == NLB_IOCTL_REGISTER_HOOK);

    /* This IOCTL does not return a buffer, only a status code. */
    pIrp->IoStatus.Information = 0;

    /* Make sure that the entity requesting this hook came from kernel-mode. */
    if (pIrp->RequestorMode != KernelMode) {
        UNIV_PRINT_CRIT(("Main_register_hook: User-level entities may NOT register hooks with NLB"));
        TRACE_CRIT("%!FUNC! User-level entities may NOT register hooks with NLB");
        return STATUS_ACCESS_DENIED;
    }

    ilen = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
    olen = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    pRequest = pIrp->AssociatedIrp.SystemBuffer;

    /* Check the lengths of the input buffer specified by the kernel-space application. */
    if ((ilen < sizeof(NLB_IOCTL_REGISTER_HOOK_REQUEST)) || (olen != 0) || !pRequest) {
        UNIV_PRINT_CRIT(("Main_register_hook: Buffer is missing or not the (expected) size: input=%d (%d), output=%d (%d)", ilen, sizeof(NLB_IOCTL_REGISTER_HOOK_REQUEST), olen, 0));
        TRACE_CRIT("%!FUNC! Buffer is missing or not the (expected) size: input=%d (%d), output=%d (%d)", ilen, sizeof(NLB_IOCTL_REGISTER_HOOK_REQUEST), olen, 0);
        return STATUS_INVALID_PARAMETER;
    }
    
    UNIV_PRINT_VERB(("Main_register_hook: Processing Ioctl 0x%08x globally on wlbs.sys", ioctl));
    TRACE_VERB("%!FUNC! Processing Ioctl 0x%08x globally on wlbs.sys", ioctl);

    /* Forcefully null terminate HookIdentifier, just in case */
    pRequest->HookIdentifier[(sizeof(pRequest->HookIdentifier)/sizeof(WCHAR)) - 1] = UNICODE_NULL;

    /* Is this a (de)registration for the NLB packet filter hook? */
    if (Univ_equal_unicode_string(pRequest->HookIdentifier, NLB_FILTER_HOOK_INTERFACE, wcslen(NLB_FILTER_HOOK_INTERFACE))) {
        PFILTER_HOOK_TABLE pFilterHook = &univ_hooks.FilterHook;

        /* Is this a register operation? */
        if (pRequest->HookTable) {
            NLB_FILTER_HOOK_TABLE RequestTable;

            /* Copy the hook table into local memory, just in case the memory the application is 
               using to hold this table is in pageable memory (once we grab the spinlock, we're 
               at DISPATCH_LEVEL, and we can't touch memory that's paged out). */
            NdisMoveMemory(&RequestTable, pRequest->HookTable, sizeof(NLB_FILTER_HOOK_TABLE));

            UNIV_PRINT_VERB(("Main_register_hook: Attempting to register the NLB_FILTER_HOOK_INTERFACE"));
            TRACE_VERB("%!FUNC! Attempting to register the NLB_FILTER_HOOK_INTERFACE");

            /* If this is a registration, but no de-register callback was provided, return failure. */
            if (!pRequest->DeregisterCallback) {
                UNIV_PRINT_CRIT(("Main_register_hook: (NLB_FILTER_HOOK_INTERFACE) Required de-register callback is missing"));
                TRACE_CRIT("%!FUNC! (NLB_FILTER_HOOK_INTERFACE) Required de-register callback is missing");
                return STATUS_INVALID_PARAMETER;
            }

            /* If this is a registration, but no hook callbacks were provided, return failure.  Since
               we don't allow registration of the query hook without at least one of send or receive,
               we don't need to include the query hook in this check. */
            if (!RequestTable.SendHook && !RequestTable.ReceiveHook) {
                UNIV_PRINT_CRIT(("Main_register_hook: (NLB_FILTER_HOOK_INTERFACE) No hook callbacks provided"));
                TRACE_CRIT("%!FUNC! (NLB_FILTER_HOOK_INTERFACE) No hook callbacks provided");
                return STATUS_INVALID_PARAMETER;
            }

            /* If this is a registration, but no query hook callback was provided, return failure. */
            if (!RequestTable.QueryHook) {
                UNIV_PRINT_CRIT(("Main_register_hook: (NLB_FILTER_HOOK_INTERFACE) No query hook callback provided"));
                TRACE_CRIT("%!FUNC! (NLB_FILTER_HOOK_INTERFACE) No query hook callback provided");
                return STATUS_INVALID_PARAMETER;
            }

            /* Grab the filter hook spin lock to protect access to the filter hook. */
            NdisAcquireSpinLock(&pFilterHook->Lock);
            
            /* Make sure that another (de)register operation isn't in progress before proceeding. */
            while (pFilterHook->Operation != HOOK_OPERATION_NONE) {
                /* Release the filter hook spin lock. */
                NdisReleaseSpinLock(&pFilterHook->Lock);
                
                /* Sleep while some other operation is in progress. */
                Nic_sleep(10);
                
                /* Grab the filter hook spin lock to protect access to the filter hook. */
                NdisAcquireSpinLock(&pFilterHook->Lock);                
            }

            /* If this hook interface has already been registered (by this entity or otherwise),
               this hook registration request must be failed.  Only one component can own the
               NLB filter hook at any given time. */
            if (pFilterHook->Interface.Registered) {
                /* Release the filter hook spin lock. */
                NdisReleaseSpinLock(&pFilterHook->Lock);

                UNIV_PRINT_CRIT(("Main_register_hook: (NLB_FILTER_HOOK_INTERFACE) This hook interface is already registered"));
                TRACE_CRIT("%!FUNC! (NLB_FILTER_HOOK_INTERFACE) This hook interface is already registered");
                return STATUS_ACCESS_DENIED;
            }

            /* If the hook is unregistered, but has an owner, then we forcefully de-registered a 
               filter hook owner, but presumably they did not close their IOCTL handle in time for
               us to destroy the NLB IOCTL interface, resulting in our driver NOT being properly
               unloaded.  If that SAME entity tries to come back and register, they will NOT be 
               allowed to do so.  Only new IOCTL handles will be allowed to register now. */
            if ((pFilterHook->Interface.Owner != 0) && (pRequest->RegisteringEntity == pFilterHook->Interface.Owner)) {
                /* Release the filter hook spin lock. */
                NdisReleaseSpinLock(&pFilterHook->Lock);

                UNIV_PRINT_CRIT(("Main_register_hook: (NLB_FILTER_HOOK_INTERFACE) Registering entity attempting to re-use IOCTL interface after a forceful de-register"));
                TRACE_CRIT("%!FUNC! (NLB_FILTER_HOOK_INTERFACE) Registering entity attempting to re-use IOCTL interface after a forceful de-register");
                return STATUS_ACCESS_DENIED;
            }

            /* Set the state to registering. */
            pFilterHook->Operation = HOOK_OPERATION_REGISTERING;

            /* Set the hook interface information which includes the identity of the component 
               registering the hook, the callback context and the de-register callback function. */
            pFilterHook->Interface.Registered = TRUE;
            pFilterHook->Interface.References = 0;
            pFilterHook->Interface.Owner      = pRequest->RegisteringEntity;
            pFilterHook->Interface.Deregister = pRequest->DeregisterCallback;
            
            /* If a send filter hook has been provided, note that it has been registered
               and store the callback function pointer. */
            if (RequestTable.SendHook) {
                pFilterHook->SendHook.Registered            = TRUE;
                pFilterHook->SendHook.Hook.SendHookFunction = RequestTable.SendHook;
            }

            /* If a receive filter hook has been provided, note that it has been registered
               and store the callback function pointer. */
            if (RequestTable.ReceiveHook) {
                pFilterHook->ReceiveHook.Registered               = TRUE;
                pFilterHook->ReceiveHook.Hook.ReceiveHookFunction = RequestTable.ReceiveHook;
            }
            
            /* Note the registration of the query hook, which is REQUIRED, and store the
               callback function pointer. */
            pFilterHook->QueryHook.Registered             = TRUE;
            pFilterHook->QueryHook.Hook.QueryHookFunction = RequestTable.QueryHook;

            /* Set the state to none. */
            pFilterHook->Operation = HOOK_OPERATION_NONE;

            /* Release the filter hook spin lock. */
            NdisReleaseSpinLock(&pFilterHook->Lock);

            UNIV_PRINT_VERB(("Main_register_hook: (NLB_FILTER_HOOK_INTERFACE) This hook interface was successfully registered"));
            TRACE_VERB("%!FUNC! (NLB_FILTER_HOOK_INTERFACE) This hook interface was successfullly registered");

            return STATUS_SUCCESS;

        /* Or is this a de-register operation? */
        } else {

            UNIV_PRINT_VERB(("Main_register_hook: Attempting to de-register the NLB_FILTER_HOOK_INTERFACE"));
            TRACE_VERB("%!FUNC! Attempting to de-register the NLB_FILTER_HOOK_INTERFACE");

            /* Grab the filter hook spin lock to protect access to the filter hook. */
            NdisAcquireSpinLock(&pFilterHook->Lock);
            
            /* Make sure that another (de)register operation isn't in progress before proceeding. */
            while (pFilterHook->Operation != HOOK_OPERATION_NONE) {
                /* Release the filter hook spin lock. */
                NdisReleaseSpinLock(&pFilterHook->Lock);
                
                /* Sleep while some other operation is in progress. */
                Nic_sleep(10);
                
                /* Grab the filter hook spin lock to protect access to the filter hook. */
                NdisAcquireSpinLock(&pFilterHook->Lock);                
            }
            
            /* If this hook interface has not been registered (by this entity or otherwise),
               this hook registration request must be failed.  NLB filter hooks can only be
               de-registered if they have been previously registered. */
            if (!pFilterHook->Interface.Registered) {
                /* Release the filter hook spin lock. */
                NdisReleaseSpinLock(&pFilterHook->Lock);

                UNIV_PRINT_CRIT(("Main_register_hook: (NLB_FILTER_HOOK_INTERFACE) This hook interface is not registered"));
                TRACE_CRIT("%!FUNC! (NLB_FILTER_HOOK_INTERFACE) This hook interface is not registered");
                return STATUS_INVALID_PARAMETER;
            }            

            /* If a component other than the one that originally registered this interface
               is trying to de-register it, do NOT allow the operation to succeed. */
            if (pRequest->RegisteringEntity != pFilterHook->Interface.Owner) {
                /* Release the filter hook spin lock. */
                NdisReleaseSpinLock(&pFilterHook->Lock);

                UNIV_PRINT_CRIT(("Main_register_hook: (NLB_FILTER_HOOK_INTERFACE) This hook interface is not owned by this component"));
                TRACE_CRIT("%!FUNC! (NLB_FILTER_HOOK_INTERFACE) This hook interface is not owned by this component");
                return STATUS_ACCESS_DENIED;
            }

            /* Set the state to de-registering. */
            pFilterHook->Operation = HOOK_OPERATION_DEREGISTERING;

            /* Mark these hooks as NOT registered to keep any more references from accumulating. */
            pFilterHook->SendHook.Registered    = FALSE;
            pFilterHook->QueryHook.Registered   = FALSE;
            pFilterHook->ReceiveHook.Registered = FALSE;
            
            /* Release the filter hook spin lock. */
            NdisReleaseSpinLock(&pFilterHook->Lock);

#if defined (NLB_HOOK_TEST_ENABLE)
            Nic_sleep(500);
#endif

            /* Wait for all references on the filter hook interface to disappear. */
            while (pFilterHook->Interface.References) {                
                /* Sleep while there are references on the interface we're de-registering. */
                Nic_sleep(10);
            }

            /* Assert that the de-register callback MUST be non-NULL. */
            UNIV_ASSERT(pFilterHook->Interface.Deregister);

            /* Call the provided de-register callback to notify the de-registering component 
               that we have indeed de-registered the specified hook. */
            (*pFilterHook->Interface.Deregister)(NLB_FILTER_HOOK_INTERFACE, pFilterHook->Interface.Owner, 0);

            /* Grab the filter hook spin lock to protect access to the filter hook. */
            NdisAcquireSpinLock(&pFilterHook->Lock);       

            /* Reset the send filter hook information. */
            Main_hook_init(&univ_hooks.FilterHook.SendHook);

            /* Reset the query filter hook information. */
            Main_hook_init(&univ_hooks.FilterHook.QueryHook);
            
            /* Reset the receive filter hook information. */
            Main_hook_init(&univ_hooks.FilterHook.ReceiveHook);

            /* Reset the hook interface information. */
            Main_hook_interface_init(&univ_hooks.FilterHook.Interface);

            /* Set the state to none. */
            pFilterHook->Operation = HOOK_OPERATION_NONE;

            /* Release the filter hook spin lock. */
            NdisReleaseSpinLock(&pFilterHook->Lock);

            UNIV_PRINT_VERB(("Main_register_hook: (NLB_FILTER_HOOK_INTERFACE) This hook interface was successfully de-registered"));
            TRACE_VERB("%!FUNC! (NLB_FILTER_HOOK_INTERFACE) This hook interface was successfullly de-registered");

            return STATUS_SUCCESS;
        }

    /* This (de)registration is for an unknown hook.  Exit. */
    } else {
        /* We should be at PASSIVE_LEVEL - %ls is OK.  However, be extra paranoid, just in case.  If 
           we're at DISPATCH_LEVEL, then just log an unknown adapter print - don't specify the GUID. */
        if (KeGetCurrentIrql() <= PASSIVE_LEVEL) {
            UNIV_PRINT_CRIT(("Main_register_hook: Unknown hook -> %ls", pRequest->HookIdentifier));
        } else {
            UNIV_PRINT_CRIT(("Main_register_hook: Unknown hook -> IRQ level too high to print hook GUID"));
        }

        TRACE_CRIT("%!FUNC! Unknown hook -> %ls", pRequest->HookIdentifier);

        return STATUS_INVALID_PARAMETER;
    }
}
#endif

NDIS_STATUS Main_ioctl (PVOID DeviceObject, PVOID Irp)
{
    NDIS_STATUS             status = NDIS_STATUS_SUCCESS;
    PIRP                    pIrp = Irp;
    PIO_STACK_LOCATION      pIrpStack;
    ULONG                   ilen, olen = 0;
    ULONG                   ioctl;
    PMAIN_CTXT              ctxtp;
    PIOCTL_LOCAL_HDR        pLocalHeader;
    ULONG                   adapter_index;

    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

    ioctl = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

#if defined (NLB_HOOK_ENABLE)
    /* If this IOCTL is our public interface for hook registration, which uses 
       different (public) data strucutres and return values, handle it separately 
       in another IOCTL function. */
    if (ioctl == NLB_IOCTL_REGISTER_HOOK)
        return Main_register_hook(DeviceObject, Irp);
#endif

    ilen = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
    olen = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    pLocalHeader = pIrp->AssociatedIrp.SystemBuffer;

    /* Check the lengths of the input and output buffers specified by the user-space application. */
    if (ilen != sizeof (IOCTL_LOCAL_HDR) || olen != sizeof (IOCTL_LOCAL_HDR) || !pLocalHeader) {
        UNIV_PRINT_CRIT(("Main_ioctl: Buffer is missing or not the expected (%d) size: input=%d, output=%d", sizeof(IOCTL_LOCAL_HDR), ilen, olen));
        TRACE_CRIT("%!FUNC! Buffer is missing or not the expected (%d) size: input=%d, output=%d", sizeof(IOCTL_LOCAL_HDR), ilen, olen);
        return STATUS_INVALID_PARAMETER;
    }
    
    /* Fill in the number of bytes written.  This IOCTL always writes the same number of bytes that it 
       reads.  That is, the input and output buffers should be identical structures. */
    pIrp->IoStatus.Information = sizeof(IOCTL_LOCAL_HDR);

    /* Security fix: Forcefully null terminate device_name, just in case */
    pLocalHeader->device_name[(sizeof(pLocalHeader->device_name)/sizeof(WCHAR)) - 1] = UNICODE_NULL;
    
    NdisAcquireSpinLock(&univ_bind_lock);

    /* Map from the GUID to the adapter index. */
    if ((adapter_index = Main_adapter_get(pLocalHeader->device_name)) == MAIN_ADAPTER_NOT_FOUND) {
        NdisReleaseSpinLock(&univ_bind_lock);
        pLocalHeader->ctrl.ret_code = IOCTL_CVY_NOT_FOUND;

        /* Since we just released the spinlock, we should be at PASSIVE_LEVEL - %ls is OK. 
           However, be extra paranoid, just in case.  If we're at DISPATCH_LEVEL, then
           just log an unknown adapter print - don't specify the GUID. */
        if (KeGetCurrentIrql() <= PASSIVE_LEVEL) {
            UNIV_PRINT_INFO(("Main_ioctl: Unknown adapter: %ls", pLocalHeader->device_name));
        } else {
            UNIV_PRINT_INFO(("Main_ioctl: Unknown adapter: IRQ level too high to print adapter GUID"));
        }

        TRACE_INFO("%!FUNC! Unknown adapter: %ls", pLocalHeader->device_name);
        return NDIS_STATUS_SUCCESS;
    }
    
    /* Retrieve the context pointer from the global arrary of adapters. */
    ctxtp = univ_adapters[adapter_index].ctxtp;

    /* Add a reference on this context structure while we hold the bind/unbind lock. This
       will make sure that this context cannot go away until after we are done with it. 
       The adapter MUST be inited at this point, or Main_adapter_get would not have 
       returned a valid adapter, so its OK to increment this reference count. */
    Main_add_reference(ctxtp);

    NdisReleaseSpinLock(&univ_bind_lock);

    /* Since we just released the spinlock, we should be at PASSIVE_LEVEL - %ls is OK. 
       However, be extra paranoid, just in case.  If we're at DISPATCH_LEVEL, then
       just log an unknown adapter print - don't specify the GUID. */
    if (KeGetCurrentIrql() <= PASSIVE_LEVEL) {
        UNIV_PRINT_VERB(("Main_ioctl: Ioctl %08x for adapter: %ls", ioctl, pLocalHeader->device_name));
    } else {
        UNIV_PRINT_VERB(("Main_ioctl: Ioctl %08x for adapter: IRQ level too high to print adapter GUID"));
    }

    TRACE_VERB("%!FUNC! Ioctl 0x%08x for adapter %ls", ioctl, pLocalHeader->device_name);

    switch (ioctl) {
    case IOCTL_CVY_CLUSTER_ON:
    case IOCTL_CVY_CLUSTER_OFF:
    case IOCTL_CVY_PORT_ON:
    case IOCTL_CVY_PORT_OFF:
    case IOCTL_CVY_QUERY:
    case IOCTL_CVY_RELOAD:
    case IOCTL_CVY_PORT_DRAIN:
    case IOCTL_CVY_CLUSTER_DRAIN:
    case IOCTL_CVY_CLUSTER_SUSPEND:
    case IOCTL_CVY_CLUSTER_RESUME:
    case IOCTL_CVY_QUERY_FILTER:
    case IOCTL_CVY_QUERY_PORT_STATE:
    case IOCTL_CVY_QUERY_PARAMS:
    case IOCTL_CVY_QUERY_BDA_TEAMING:
    case IOCTL_CVY_CONNECTION_NOTIFY:
    case IOCTL_CVY_QUERY_MEMBER_IDENTITY:
        /* Process the IOCTL.  The information for most IOCTLs is in the IOCTL_CVY_BUF, including
           the return code, but for backward compatability reasons, new IOCTL information is in a
           separate buffer - the options buffer. */
        status = Main_ctrl(ctxtp, ioctl, &(pLocalHeader->ctrl), &(pLocalHeader->options.common), &(pLocalHeader->options), NULL);

        break;
    default:
        UNIV_PRINT_CRIT(("Main_ioctl: Unknown Ioctl code: %x", ioctl));
        TRACE_CRIT("%!FUNC! Unknown Ioctl code: 0x%x", ioctl);
        status = STATUS_INVALID_PARAMETER;
        break;
    }
    
    /* Release the reference on the context block. */
    Main_release_reference(ctxtp);

    return status;
}

/* 
 * Function: Main_set_host_state
 * Desctription: This function queues a work item to set the current host
 *               state registry key, HostState.  This MUST be done in a work
 *               item, rather than inline because if the state of the host
 *               changes as a result of the reception of a remote control
 *               request, that code will be running at DISPATCH_LEVEL; 
 *               registry manipulation MUST be done at PASSIVE_LEVEL.  Work
 *               items are complete at PASSIVE_LEVEL.
 * Parameters: ctxtp - a pointer to the main context structure for this adapter.
 *             state - the new host state; one of started, stopped, suspended.
 * Returns: Nothing
 * Author: shouse, 7.13.01
 * Notes: Because this callback will occur at some later time in the context
 *        of a kernel worker thread, there is a possibility that the adapter
 *        context (ctxtp) could disappear in the meantime, as the result of
 *        an unbind for instance.  To prevent this from happening, we will 
 *        increment the reference count on the context to keep it from being
 *        freed until we are done.  The unbind code will sleep until this
 *        reference count reaches zero, so the unbind will be certain NOT to
 *        complete until all callbacks are processed.  Other checking is in
 *        place to prevent this reference count from continuing to increase
 *        once an unbind has started.  Note that that callback function is 
 *        responsible for both freeing the memory we allocate here, and 
 *        releasing the reference on the context.
 */
VOID Main_set_host_state (PMAIN_CTXT ctxtp, ULONG state) {
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    UNIV_ASSERT(ctxtp->code == MAIN_CTXT_CODE);

    /* If the host state is already correct, don't bother to do anything. */
    if (ctxtp->params.init_state == state)
        return;
        
    /* Set the desired state - this is the "cached" value. */
    ctxtp->cached_state = state;
    
    /* Schedule and NDIS work item to set the host state in the registry. */
    status = Main_schedule_work_item(ctxtp, Params_set_host_state);
    
    /* If we can't schedule the work item, bail out. */
    if (status != NDIS_STATUS_SUCCESS) {
        UNIV_PRINT_CRIT(("Main_set_host_state: Error 0x%08x -> Unable to allocate work item", status));
        LOG_MSG(MSG_WARN_HOST_STATE_UPDATE, CVY_NAME_HOST_STATE);
    }        

    return;
}

/*
 * Function: Main_find_first_in_cache
 * Description: Traverses cached identity information, to find the host with the smallest host_id.
 * Parameters: PMAIN_CTXT ctxtp - the context for this NLB instance.
 * Returns: The host_id of the found host or IOCTL_NO_SUCH_HOST if there was no valid entry in the cache.
 * Author: ChrisDar - 20 May 2002
 * Notes: 
 */
ULONG Main_find_first_in_cache(
    PMAIN_CTXT  ctxtp
)
{
    ULONG host_id = IOCTL_NO_SUCH_HOST;
    ULONG i       = 0;

    /* Find the host in the cache with the smallest host_id */
    for (i = 0; i < CVY_MAX_HOSTS; i++)
    {
        if (ctxtp->identity_cache[i].ttl > 0)
        {
            UNIV_ASSERT(i == ctxtp->identity_cache[i].host_id);
            host_id = ctxtp->identity_cache[i].host_id;

            break;
        }
    }

    return host_id;
}

/*
 * Function: Main_get_cached_hostmap
 * Description: Builds a bitmap of the hosts with valid entries in the identity cache.
 * Parameters: PMAIN_CTXT ctxtp - the context for this NLB instance.
 * Returns: 32-bit bitmap of the host ids with valid identity cache entries.
 * Author: ChrisDar - 20 May 2002
 * Notes: 
 */
ULONG Main_get_cached_hostmap(
    PMAIN_CTXT  ctxtp
)
{
    ULONG host_map  = 0;
    ULONG i         = 0;

    for (i = 0; i < CVY_MAX_HOSTS; i++)
    {
        if (ctxtp->identity_cache[i].ttl > 0)
        {
            UNIV_ASSERT(i == ctxtp->identity_cache[i].host_id);

            host_map |= (1<<i);
        }
    }

    return host_map;
}

/*
 * Function: Main_ctrl
 * Description: This function performs a control function on a given NLB instance, such as
 *              RELOAD, STOP, START, etc.  
 * Parameters: ctxtp - a pointer to the adapter context for the operation.
 *             ioctl - the operation to be performed.
 *             pBuf - the (legacy) control buffer (input and output in some cases).
 *             pCommon - the input/output buffer for operations common to both local and remote control.
 *             pLocal - the input/output buffer for operations that can be executed locally only.
 *             pRemote - the input/output buffer for operations that can be executed remotely only.
 * Returns: NDIS_STATUS - the status of the operation; NDIS_STATUS_SUCCESS if successful.
 * Author: shouse, 3.29.01
 * Notes: 
 */
NDIS_STATUS Main_ctrl (
    PMAIN_CTXT            ctxtp,    /* The context for the adapter on which to operate. */
    ULONG                 ioctl,    /* The IOCTL code. */
    PIOCTL_CVY_BUF        pBuf,     /* Pointer to the CVY buf - should NEVER be NULL. */
    PIOCTL_COMMON_OPTIONS pCommon,  /* Pointer to the COMMON buf - CAN be NULL, but only for internal cluster control. */
    PIOCTL_LOCAL_OPTIONS  pLocal,   /* Pointer to the LOCAL options - CAN be NULL if this is a remote control operation. */
    PIOCTL_REMOTE_OPTIONS pRemote)  /* Pointer to the REMOTE options - CAN be NULL if this is a local control operation. */
{
    WCHAR                 num[20];
    PMAIN_ADAPTER         pAdapter;
    BOOLEAN               bConvergenceInitiated = FALSE;
    NDIS_STATUS           status = NDIS_STATUS_SUCCESS;

    UNIV_ASSERT(ctxtp);
    UNIV_ASSERT(pBuf);

    UNIV_ASSERT(!(pLocal && pRemote));

    TRACE_VERB("->%!FUNC! Enter, ctxtp=%p, IOCTL=0x%x", ctxtp, ioctl);

    /* Extract the MAIN_ADAPTER structure given the MAIN_CTXT. */
    pAdapter = &(univ_adapters[ctxtp->adapter_id]);

    NdisAcquireSpinLock(&univ_bind_lock);

    /* Make sure that the adapter has been initialized before executing any control operations. */
    if (!pAdapter->inited) {
        NdisReleaseSpinLock(&univ_bind_lock);
        UNIV_PRINT_CRIT(("Main_ctrl: Unbound from all NICs"));
        TRACE_CRIT("%!FUNC! Unbound from all NICs");
        TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_FAILURE");
        return NDIS_STATUS_FAILURE;
    }

    /* Check to make sure another control operation is not already in progress.  If so, then we 
       must fail; only one control operation can be in progress at a time.  If this is remote 
       control, we will assume the next request to arrive (five are sent) will succeed. */
    if (ctxtp->ctrl_op_in_progress) {
        NdisReleaseSpinLock(&univ_bind_lock);
        UNIV_PRINT_CRIT(("Main_ctrl: Another control operation is in progress"));
        TRACE_CRIT("%!FUNC! Another control operation is in progress");
        TRACE_VERB("<-%!FUNC! return=NDIS_STATUS_FAILURE");
        return NDIS_STATUS_FAILURE;
    }

    /* Mark the operation in progress flag.  This MUST be re-set upon exit. */
    ctxtp->ctrl_op_in_progress = TRUE;

    NdisReleaseSpinLock(&univ_bind_lock);

    /* Make sure data is written into pBuf/pCommon/pLocal/pRemote AFTER taking everything we need out of it. */
    switch (ioctl) {
    /* Reload the NLB parameters from the registry on a live cluster. */
    case IOCTL_CVY_RELOAD:
    {
        PCVY_PARAMS old_params;
        PCVY_PARAMS new_params;
        ULONG       old_ip;
        ULONG       mode;
        CVY_MAC_ADR old_mac_addr;
        BOOLEAN     bHostPriorityChanged, bClusterIPChanged;

        if (KeGetCurrentIrql() > PASSIVE_LEVEL) {
            KIRQL currentIrql = KeGetCurrentIrql();

            UNIV_PRINT_CRIT(("Main_ctrl: IRQL (%u) > PASSIVE_LEVEL (%u)", currentIrql, PASSIVE_LEVEL));
            TRACE_CRIT("%!FUNC! IRQL (%u) > PASSIVE_LEVEL (%u)", currentIrql, PASSIVE_LEVEL);

            status = NDIS_STATUS_FAILURE;
            break;
        }

        /* Allocate memory to hold a cached copy of our current parameters. */
        status = NdisAllocateMemoryWithTag(&old_params, sizeof(CVY_PARAMS), UNIV_POOL_TAG);

        if (status != NDIS_STATUS_SUCCESS) {
            UNIV_PRINT_CRIT(("Main_ctrl: Unable to allocate memory"));
            TRACE_CRIT("%!FUNC! Unable to allocate memory");

            LOG_MSG2(MSG_ERROR_MEMORY, MSG_NONE, sizeof(CVY_PARAMS), status);

            status = NDIS_STATUS_FAILURE;
            break;
        }

        /* Take a snapshot of the old parameter set for later comparison. */
        RtlCopyMemory(old_params, &ctxtp->params, sizeof(CVY_PARAMS));

        /* Allocate memory to hold the new parameters - we don't want to clobber
           our current parameters, just in case the new ones are invalid. */
        status = NdisAllocateMemoryWithTag(&new_params, sizeof(CVY_PARAMS), UNIV_POOL_TAG);

        if (status != NDIS_STATUS_SUCCESS) {
            UNIV_PRINT_CRIT(("Main_ctrl: Unable to allocate memory"));
            TRACE_CRIT("%!FUNC! Unable to allocate memory");

            LOG_MSG2(MSG_ERROR_MEMORY, MSG_NONE, sizeof(CVY_PARAMS), status);

            /* Free the memory we allocated for the cached parameters. */
            NdisFreeMemory((PUCHAR)old_params, sizeof(CVY_PARAMS), 0);

            status = NDIS_STATUS_FAILURE;
            break;
        }

        /* Spin locks can not be acquired when we are calling Params_init
           since it will be doing registry access operations that depend on
           running at PASSIVEL_IRQL_LEVEL.  Therefore, we gather the new
           parameters into a temporary structure and copy them in the NLB
           context protected by a spin lock. */
        if (Params_init(ctxtp, univ_reg_path, pAdapter->device_name + 8, new_params) != NDIS_STATUS_SUCCESS) {
            UNIV_PRINT_CRIT(("Main_ctrl: Error retrieving registry parameters"));
            TRACE_CRIT("%!FUNC! Error retrieving registry parameters");

            /* Alert the user to the bad parameters, but do not mark our parameters
               as invalid because we are keeping the old set, which may or may not
               be invalid, but regardless, there is no need to mark them - they should
               have already been properly marked valid or invalid. */
            pBuf->ret_code = IOCTL_CVY_BAD_PARAMS;

            /* Free the memory we allocated for the cached parameters. */
            NdisFreeMemory((PUCHAR)old_params, sizeof(CVY_PARAMS), 0);

            /* Free the memory we allocated for the new parameters. */
            NdisFreeMemory((PUCHAR)new_params, sizeof(CVY_PARAMS), 0);

            break;
        }
            
        NdisAcquireSpinLock(&ctxtp->load_lock);

        /* At this point, we have verified that the new parameters are valid,
           so copy them into the permanent parameters structure. */
        RtlCopyMemory(&ctxtp->params, new_params, sizeof(CVY_PARAMS));
        ctxtp->params_valid = TRUE;

        /* Extract the host priority to a string for the purpose of event logging. */
        Univ_ulong_to_str(ctxtp->params.host_priority, num, 10);

        /* Check to see, by comparing the old parameters and the new parameters, whether
           or not we can apply these changes without stopping and starting the load module. */
        if (ctxtp->convoy_enabled && Main_apply_without_restart(ctxtp, old_params, &ctxtp->params)) {
            NdisReleaseSpinLock(&ctxtp->load_lock); 

            pBuf->ret_code = IOCTL_CVY_OK;

            /* Free the memory we allocated for the cached parameters. */
            NdisFreeMemory((PUCHAR)old_params, sizeof(CVY_PARAMS), 0);

            /* Free the memory we allocated for the new parameters. */
            NdisFreeMemory((PUCHAR)new_params, sizeof(CVY_PARAMS), 0);

            break;
        }

        /* Has the host priority changed ? */
        bHostPriorityChanged = (new_params->host_priority != old_params->host_priority);

        /* Free the memory we allocated for the cached parameters. */
        NdisFreeMemory((PUCHAR)old_params, sizeof(CVY_PARAMS), 0);
        
        /* Free the memory we allocated for the new parameters. */
        NdisFreeMemory((PUCHAR)new_params, sizeof(CVY_PARAMS), 0);

        /* Note the current on/off status of NLB. */
        mode = ctxtp->convoy_enabled;

        /* At this point, set the return value assuming success. */
        pBuf->ret_code = IOCTL_CVY_OK;

        /* If the cluster is currently running, we need to stop the load module. */
        if (ctxtp->convoy_enabled) {
            /* Turn off NLB. */
            ctxtp->convoy_enabled = FALSE;

            /* Stop the load module.  Note: this destroys all connections in service. */
            Load_stop(&ctxtp->load);

            /* Take care of the case where we've interrupted draining. */
            if (ctxtp->draining) {
                /* If we were in the process of draining, stop. */
                ctxtp->draining = FALSE;

                NdisReleaseSpinLock(&ctxtp->load_lock);

                UNIV_PRINT_VERB(("Main_ctrl: Connection draining interrupted"));
                TRACE_VERB("%!FUNC! Connection draining interrupted");

                LOG_MSG(MSG_INFO_DRAINING_STOPPED, MSG_NONE);

                /* Notify the user that we have interrupted draining. */
                pBuf->ret_code = IOCTL_CVY_DRAINING_STOPPED;
            } else {
                NdisReleaseSpinLock(&ctxtp->load_lock);
            }

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode stopped"));
            TRACE_VERB("%!FUNC! Cluster mode stopped");

            LOG_MSG(MSG_INFO_STOPPED, MSG_NONE);
        } else {
            NdisReleaseSpinLock(&ctxtp->load_lock);
        }

        /* Note our current cluster IP address. */
        old_ip = ctxtp->cl_ip_addr;

        /* Note our current cluster MAC address. */
        CVY_MAC_ADDR_COPY(ctxtp->medium, &old_mac_addr, &ctxtp->cl_mac_addr);

        /* Initialize the IP addresses and MAC addresses.  If either of these fail, 
           consider this a parameter error and do NOT restart the cluster. */
        if (!Main_ip_addr_init(ctxtp) || !Main_mac_addr_init(ctxtp)) {
            /* Mark the parameters invalid. */
            ctxtp->params_valid = FALSE;

            UNIV_PRINT_CRIT(("Main_ctrl: Parameter error: Main_ip_addr_init and/or Main_mac_addr_init failed"));
            TRACE_CRIT("%!FUNC! Parameter error: Main_ip_addr_init and/or Main_mac_addr_init failed");

            LOG_MSG(MSG_ERROR_DISABLED, MSG_NONE);

            /* Notify the user that the supplied parameters are invalid. */
            pBuf->ret_code = IOCTL_CVY_BAD_PARAMS;

            break;
        }

#if defined (NLB_TCP_NOTIFICATION)
        /* Now that the cluster IP address is set, try to map this adapter to its IP interface index. */
        Main_set_interface_index(NULL, ctxtp);
#endif

        /* Turn reverse-hashing off.  If we're part of a BDA team, the teaming configuration
           that is setup by the call to Main_teaming_init will over-write this setting. */
        ctxtp->reverse_hash = FALSE;

        /* Initialize BDA teaming.  If this fails, consider this a parameter error and do NOT restart the cluster. */
        if (!Main_teaming_init(ctxtp)) {
            /* Mark the parameters invalid. */
            ctxtp->params_valid = FALSE;

            UNIV_PRINT_CRIT(("Main_ctrl: Parameter error: Main_teaming_init failed"));
            TRACE_CRIT("parameter error: Main_teaming_init failed");

            LOG_MSG(MSG_ERROR_DISABLED, MSG_NONE);

            /* Notify the user that the supplied parameters are invalid. */
            pBuf->ret_code = IOCTL_CVY_BAD_PARAMS;

            break;
        }

        /* If this cluster is operating in IGMP multicast mode, initialize IGMP. */
        if (ctxtp->params.mcast_support && ctxtp->params.igmp_support)
            Main_igmp_init(ctxtp, TRUE);

        /* Look for changes to cluster name, machine name */
        Tcpip_init (& ctxtp -> tcpip, & ctxtp -> params);

        /* If our cluster IP address has changed, we block ARPs for a short period of 
           time until TCP/IP gets updated and has the correct information in order to
           avoid ARP conflicts. */
        if (old_ip != ctxtp->cl_ip_addr) {

            bClusterIPChanged = TRUE;

            NdisAcquireSpinLock(&ctxtp->load_lock);

            /* Set the timer, which is decremented by each heartbeat timer. */
            univ_changing_ip = ctxtp->params.ip_chg_delay;

            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Changing IP address with delay %d", univ_changing_ip));
            TRACE_VERB("%!FUNC! Changing IP address with delay %d", univ_changing_ip);
        }
        else
        {
            bClusterIPChanged = FALSE;
        }

        LOG_MSG(MSG_INFO_RELOADED, MSG_NONE);

        // If enabled, fire wmi event indicating reloading of nlb on this node
        if (NlbWmiEvents[NodeControlEvent].Enable)
        {
            NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_RELOADED);
        }
        else 
        {
            TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_NODE_RELOADED 'cos NodeControlEvent generation disabled");
        }

        /* If NLB was initially running, re-start the load module. */
        if (mode) {
            NdisAcquireSpinLock(&ctxtp->load_lock);

            /* Start the load module. */
            bConvergenceInitiated = Load_start(&ctxtp->load);

            /* Turn on NLB. */
            ctxtp->convoy_enabled = TRUE;

            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode started"));
            TRACE_VERB("%!FUNC! Cluster mode started");

            LOG_MSG(MSG_INFO_STARTED, num);

            if (bConvergenceInitiated) 
            {
                if (NlbWmiEvents[ConvergingEvent].Enable)
                {
                   // If the host priority or cluster ip or cluster mac (among other things) has changed, 
                   // fire a new member event, else fire a modified params event
                   if (bHostPriorityChanged 
                    || bClusterIPChanged 
                    || !CVY_MAC_ADDR_COMP(ctxtp->medium, &old_mac_addr, &ctxtp->cl_mac_addr)
                      )
                   {
                       NlbWmi_Fire_ConvergingEvent(ctxtp, 
                                                   NLB_EVENT_CONVERGING_NEW_MEMBER, 
                                                   ctxtp->params.ded_ip_addr,
                                                   ctxtp->params.host_priority);
                   }
                   else // Host priority, Cluster IP, Cluster MAC have not changed
                   {
                       NlbWmi_Fire_ConvergingEvent(ctxtp, 
                                                   NLB_EVENT_CONVERGING_MODIFIED_PARAMS, 
                                                   ctxtp->params.ded_ip_addr,
                                                   ctxtp->params.host_priority);
                   }
                }
                else 
                {
                    TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_CONVERGING_NEW_MEMBER/MODIFIED_PARAMS, Convergnce NOT Initiated by Load_start() OR ConvergingEvent generation disabled");
                }
            }
        }

        /* Repopulate this host's identity heartbeat information */
        NdisAcquireSpinLock(&ctxtp->load_lock);
        Main_idhb_init(ctxtp);
        NdisReleaseSpinLock(&ctxtp->load_lock);

        /* Turn off the bad host ID warning, in case it was turned on. */
        ctxtp->bad_host_warned = FALSE;

        UNIV_PRINT_VERB(("Main_ctrl: Parameters reloaded"));

        break;
    }
    /* Resume a suspended cluster. */
    case IOCTL_CVY_CLUSTER_RESUME:
    {
        NdisAcquireSpinLock(&ctxtp->load_lock);

        /* If the cluster is not currently suspended, then this is a no-op. */
        if (!ctxtp->suspended) {
            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode already resumed"));

            /* Tell the user that the cluster is alrady resumed. */
            pBuf->ret_code = IOCTL_CVY_ALREADY;
            
            break;
        }

        UNIV_ASSERT(!ctxtp->convoy_enabled);
        UNIV_ASSERT(!ctxtp->draining);

        /* Resume the cluster by turning the suspend flag off. */
        ctxtp->suspended = FALSE;

        NdisReleaseSpinLock(&ctxtp->load_lock);

        /* Update the intial state registry key to STOPPED. */
        Main_set_host_state(ctxtp, CVY_HOST_STATE_STOPPED);

        UNIV_PRINT_VERB(("Main_ctrl: Cluster mode resumed"));
        TRACE_VERB("%!FUNC! Cluster mode resumed");

        LOG_MSG(MSG_INFO_RESUMED, MSG_NONE);

        // If enabled, fire wmi event indicating resuming of nlb on this node
        if (NlbWmiEvents[NodeControlEvent].Enable)
        {
            NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_RESUMED);
        }
        else 
        {
            TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_NODE_RESUMED 'cos NodeControlEvent generation disabled");
        }

        /* Return success. */
        pBuf->ret_code = IOCTL_CVY_OK;

        break;
    }
    /* Start a stopped or draining cluster. */
    case IOCTL_CVY_CLUSTER_ON:
    {
        /* Store the host priority in a string for the purpose of event logging. */
        Univ_ulong_to_str(ctxtp->params.host_priority, num, 10);

        NdisAcquireSpinLock(&ctxtp->load_lock);

        /* If the cluster is suspended, it ignores all control operations except resume. */
        if (ctxtp->suspended) {
            UNIV_ASSERT(!ctxtp->convoy_enabled);
            UNIV_ASSERT(!ctxtp->draining);

            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode is suspended"));

            /* Alert the user that the cluster is currently suspended. */
            pBuf->ret_code = IOCTL_CVY_SUSPENDED;

            break;
        }

        /* Otherwise, if the cluster is draining, stop draining connections. */
        if (ctxtp->draining) {
            UNIV_ASSERT(ctxtp->convoy_enabled);
            UNIV_PRINT_VERB(("Main_ctrl: START: Calling Load_port_change -> VIP=%08x, port=%d, load=%d\n", IOCTL_ALL_VIPS, IOCTL_ALL_PORTS, 0));

            /* Call Load_port_change to "plug" draining - that is, restore the original load 
               balancing policy on ALL port rules (ALL VIPs, ALL ports). */
            pBuf->ret_code = Load_port_change(&ctxtp->load, IOCTL_ALL_VIPS, IOCTL_ALL_PORTS, IOCTL_CVY_CLUSTER_PLUG, 0);

            /* Turn draining off. */
            ctxtp->draining = FALSE;

            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Connection draining interrupted"));
            TRACE_VERB("%!FUNC! Connection draining interrupted");

            LOG_MSG(MSG_INFO_DRAINING_STOPPED, MSG_NONE);

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode started"));
            TRACE_VERB("%!FUNC! Cluster mode started");

            LOG_MSG(MSG_INFO_STARTED, num);

            /* Alert the user that draining was interrupted. */
            pBuf->ret_code = IOCTL_CVY_DRAINING_STOPPED;

            break;
        }

        /* Otherwise, if the cluster is running, this is a no-op. */
        if (ctxtp->convoy_enabled) {
            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode already started"));

            /* Alert the user that the cluster is already started. */
            pBuf->ret_code = IOCTL_CVY_ALREADY;

            break;
        }

        /* Otherwise, if the cluster is stopped because of invalid parameters, we WILL
           NOT restart the cluster until the parameters are fixed and reloaded. */
        if (!ctxtp->params_valid) {
            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Parameter error"));
            TRACE_VERB("%!FUNC! Parameter error");

            LOG_MSG(MSG_ERROR_DISABLED, MSG_NONE);

            /* Alert the user that the parameters are bad. */
            pBuf->ret_code = IOCTL_CVY_BAD_PARAMS;

            break;
        }

        /* Otherwise, we are starting a stopped cluster - start the load module. */
        bConvergenceInitiated = Load_start(&ctxtp->load);

        /* Turn on NLB. */
        ctxtp->convoy_enabled = TRUE;

        NdisReleaseSpinLock(&ctxtp->load_lock);

        /* Update the intial state registry key to STARTED. */
        Main_set_host_state(ctxtp, CVY_HOST_STATE_STARTED);

        /* Turn off the bad host ID warning, in case it was turned on. */
        ctxtp->bad_host_warned = FALSE;

        UNIV_PRINT_VERB(("Main_ctrl: Cluster mode started"));
        TRACE_VERB("%!FUNC! Cluster mode started");

        LOG_MSG(MSG_INFO_STARTED, num);

        // If enabled, fire wmi event indicating "start" nlb
        if (NlbWmiEvents[NodeControlEvent].Enable)
        {
            NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_STARTED);
        }
        else 
        {
            TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_NODE_STARTED 'cos NodeControlEvent generation disabled");
        }

        if (bConvergenceInitiated && NlbWmiEvents[ConvergingEvent].Enable)
        {
            NlbWmi_Fire_ConvergingEvent(ctxtp, 
                                        NLB_EVENT_CONVERGING_NEW_MEMBER, 
                                        ctxtp->params.ded_ip_addr,
                                        ctxtp->params.host_priority);
        }
        else 
        {
            TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_CONVERGING_NEW_MEMBER, Convergnce NOT Initiated by Load_start() OR ConvergingEvent generation disabled");
        }

        /* Return success. */
        pBuf->ret_code = IOCTL_CVY_OK;

        break;
    }
    /* Suspend a running cluster.  Suspend differs from stop in that suspended cluster will
       further ignore ALL control message (remote and local) until a resume is issued. */
    case IOCTL_CVY_CLUSTER_SUSPEND:
    {
        NdisAcquireSpinLock(&ctxtp->load_lock);

        /* If the cluster is already suspended, this is a no-op. */
        if (ctxtp->suspended) {
            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode already suspended"));

            /* Alert the user that the cluster is already suspended. */
            pBuf->ret_code = IOCTL_CVY_ALREADY;

            break;
        }

        /* Set the suspended flag, effectively suspending the cluster operations. */
        ctxtp->suspended = TRUE;

        /* If the cluster is running, stop it. */
        if (ctxtp->convoy_enabled) {
            /* Turn NLB off. */
            ctxtp->convoy_enabled = FALSE;

            /* Set the stopping flag, which is used to allow one last heartbeat to go
               out before a host stops in order to expedite convergence. */
            ctxtp->stopping = TRUE;

            /* Stop the load module and release all connections. */
            Load_stop(&ctxtp->load);

            /* If the cluster was draining, stop draining - we've already kill all 
               connection state anyway (in Load_stop). */
            if (ctxtp->draining) {
                /* Turn off the draining flag. */
                ctxtp->draining = FALSE;

                NdisReleaseSpinLock(&ctxtp->load_lock);

                UNIV_PRINT_VERB(("Main_ctrl: Connection draining interrupted"));
                TRACE_VERB("%!FUNC! Connection draining interrupted");

                LOG_MSG(MSG_INFO_DRAINING_STOPPED, MSG_NONE);

                /* Alert the user that draining was interrupted. */
                pBuf->ret_code = IOCTL_CVY_DRAINING_STOPPED;
            } else {
                NdisReleaseSpinLock(&ctxtp->load_lock);

                /* Alert the user that the cluster was stopped. */
                pBuf->ret_code = IOCTL_CVY_STOPPED;
            }

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode stopped"));
            TRACE_VERB("%!FUNC! Cluster mode stopped");

            LOG_MSG(MSG_INFO_STOPPED, MSG_NONE);
        } else {
            NdisReleaseSpinLock(&ctxtp->load_lock);

            /* Return success - the cluster was already stopped. */
            pBuf->ret_code = IOCTL_CVY_OK;
        }

        /* Update the intial state registry key to SUSPENDED. */
        Main_set_host_state(ctxtp, CVY_HOST_STATE_SUSPENDED);

        UNIV_PRINT_VERB(("Main_ctrl: Cluster mode suspended"));
        TRACE_VERB("%!FUNC! Cluster mode suspended");

        LOG_MSG(MSG_INFO_SUSPENDED, MSG_NONE);

        // If enabled, fire wmi event indicating suspending of nlb on this node
        if (NlbWmiEvents[NodeControlEvent].Enable)
        {
            NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_SUSPENDED);
        }
        else 
        {
            TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_NODE_SUSPENDED 'cos NodeControlEvent generation disabled");
        }

        break;
    }
    /* Stop a running cluster. */
    case IOCTL_CVY_CLUSTER_OFF:
    {
        NdisAcquireSpinLock(&ctxtp->load_lock);

        /* If the cluster is suspended, ignore this request. */
        if (ctxtp->suspended) {
            UNIV_ASSERT(!ctxtp->convoy_enabled);
            UNIV_ASSERT(!ctxtp->draining);

            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode is suspended"));

            /* Alert the user that the cluster is in the suspended state. */
            pBuf->ret_code = IOCTL_CVY_SUSPENDED;

            break;
        }

        /* If the cluster is already stopped, this is a no-op. */
        if (!ctxtp->convoy_enabled) {
            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode already stopped"));

            /* Alert the user that the cluster is already stopped. */
            pBuf->ret_code = IOCTL_CVY_ALREADY;

            break;
        }

        /* Turn NLB off. */
        ctxtp->convoy_enabled = FALSE;

        /* Set the stopping flag, which is used to allow one last heartbeat to go
           out before a host stops in order to expedite convergence. */
        ctxtp->stopping = TRUE;

        /* Stop the load module. */
        Load_stop(&ctxtp->load);

        /* If we were in the process of draining, stop draining because all
           existing connection state was just trashed by Load_stop. */
        if (ctxtp->draining) {
            /* Turn off the draining flag. */
            ctxtp->draining = FALSE;

            NdisReleaseSpinLock(&ctxtp->load_lock); 

            UNIV_PRINT_VERB(("Main_ctrl: Connection draining interrupted"));
            TRACE_VERB("%!FUNC! Connection draining interrupted");

            LOG_MSG(MSG_INFO_DRAINING_STOPPED, MSG_NONE);

            /* Alert the user that we have interrupted draining. */
            pBuf->ret_code = IOCTL_CVY_DRAINING_STOPPED;
        } else {
            NdisReleaseSpinLock(&ctxtp->load_lock);

            /* Return success. */
            pBuf->ret_code = IOCTL_CVY_OK;
        }

        /* Update the intial state registry key to STOPPED. */
        Main_set_host_state(ctxtp, CVY_HOST_STATE_STOPPED);

        UNIV_PRINT_VERB(("Main_ctrl: Cluster mode stopped"));
        TRACE_VERB("%!FUNC! Cluster mode stopped");

        LOG_MSG(MSG_INFO_STOPPED, MSG_NONE);

        // If enabled, fire wmi event indicating stopping of nlb
        if (NlbWmiEvents[NodeControlEvent].Enable)
        {
            NlbWmi_Fire_NodeControlEvent(ctxtp, NLB_EVENT_NODE_STOPPED);
        }
        else 
        {
            TRACE_VERB("%!FUNC! NOT generating NLB_EVENT_NODE_STOPPED 'cos NodeControlEvent generation disabled");
        }

        break;
    }
    /* Drain a running cluster.  Draining differs from a stop in that the cluster
       will continue to server existing connections (TCP and IPSec), but not take
       any new connections. */
    case IOCTL_CVY_CLUSTER_DRAIN:
    {
        NdisAcquireSpinLock(&ctxtp->load_lock);

        /* If the cluster is suspended, ignore this request. */
        if (ctxtp->suspended) {
            UNIV_ASSERT(!ctxtp->convoy_enabled);
            UNIV_ASSERT(!ctxtp->draining);

            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode is suspended"));

            /* Alert the user that the cluster is in a suspended state. */
            pBuf->ret_code = IOCTL_CVY_SUSPENDED;

            break;
        }

        /* If the cluster is already stopped, this is a no-op. */
        if (!ctxtp->convoy_enabled) {
            UNIV_ASSERT(!ctxtp->draining);

            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cannot drain connections while cluster is stopped"));

            /* Alert the user that the cluster is already stopped. */
            pBuf->ret_code = IOCTL_CVY_STOPPED;

            break;
        }
        
        /* If the cluster is already draining, then this is a no-op. */
        if (ctxtp->draining) {
            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Already draining"));

            /* Alert the user the the cluster is in the process of draining. */
            pBuf->ret_code = IOCTL_CVY_ALREADY;

            break;
        }

        /* Turn on the draining flag, which is used during Main_ping to 
           turn the cluster off once all connections have been completed. */
        ctxtp->draining = TRUE;

        UNIV_PRINT_VERB(("Main_ctrl: DRAIN: Calling Load_port_change -> VIP=%08x, port=%d, load=%d\n", IOCTL_ALL_VIPS, IOCTL_ALL_PORTS, 0));

        /* Change the load weight of ALL port rules to zero, so that this
           host will not accept any NEW connections.  Existing connections
           will be serviced because this host will have descriptors for 
           those connections in the load module. */
        pBuf->ret_code = Load_port_change(&ctxtp->load, IOCTL_ALL_VIPS, IOCTL_ALL_PORTS, ioctl, 0);

        NdisReleaseSpinLock(&ctxtp->load_lock);

        /* If the load module successfully drained the port rules, log an event. */
        if (pBuf->ret_code == IOCTL_CVY_OK) {
            UNIV_PRINT_VERB(("Main_ctrl: Connection draining started"));
            TRACE_VERB("%!FUNC! Connection draining started");

            LOG_MSG(MSG_INFO_CLUSTER_DRAINED, MSG_NONE);
        }

        break;
    }
    /* Restore a port rule to its original load balancing scheme (enable) or
       specifically set the load weight of a port rule.  Note: _SET is no 
       longer supported by user-level NLB applications, but the notification
       to the load module is still used internally. */
    case IOCTL_CVY_PORT_ON:
    case IOCTL_CVY_PORT_SET:
    {
        /* Extract this host's ID for the sake of event logging. */
        Univ_ulong_to_str(pBuf->data.port.num, num, 10);

        NdisAcquireSpinLock(&ctxtp->load_lock);

        /* If the cluster is suspended, then all control operations are ignored. */
        if (ctxtp->suspended) {
            UNIV_ASSERT(!ctxtp->convoy_enabled);
            UNIV_ASSERT(!ctxtp->draining);

            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode is suspended"));

            /* Alert the user that the cluster is in the suspended state. */
            pBuf->ret_code = IOCTL_CVY_SUSPENDED;

            break;
        }

        /* If the cluster is stopped, then the load module is turned off,
           so we should ignore this request as well. */
        if (!ctxtp->convoy_enabled) {
            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cannot enable/disable port while cluster is stopped"));
            TRACE_VERB("%!FUNC! Cannot enable/disable port while cluster is stopped");

            LOG_MSG(MSG_WARN_CLUSTER_STOPPED, MSG_NONE);

            /* Alert the user that the cluster is stopped. */
            pBuf->ret_code = IOCTL_CVY_STOPPED;

            break;
        }

        /* If there is no common buffer, which can happen if this is a remote control request from a down-level
           client, then we hard-code the VIP to 0xffffffff.  If the cluster is operating in a mode that is 
           compatible with down-level clients, i.e. no per-VIP port rules, no BDA, etc, then hardcoding this
           parameter will not matter (the affect is not altered by its value), otherwise we shouldn't get to 
           here because Main_ctrl_recv is supposed to block those requests. */
        if (!pCommon) {
            UNIV_PRINT_VERB(("Main_ctrl: ENABLE: Calling Load_port_change -> VIP=%08x, port=%d, load=%d\n", IOCTL_ALL_VIPS, pBuf->data.port.num, pBuf->data.port.load));
                
            pBuf->ret_code = Load_port_change(&ctxtp->load, IOCTL_ALL_VIPS, pBuf->data.port.num, ioctl, pBuf->data.port.load);
        /* If there is a common buffer, then we can extract the VIP from there. */
        } else {
            UNIV_PRINT_VERB(("Main_ctrl: ENABLE: Calling Load_port_change -> VIP=%08x, port=%d, load=%d\n", pCommon->port.vip, pBuf->data.port.num, pBuf->data.port.load));
            
            pBuf->ret_code = Load_port_change(&ctxtp->load, pCommon->port.vip, pBuf->data.port.num, ioctl, pBuf->data.port.load);
        }

        NdisReleaseSpinLock(&ctxtp->load_lock);

        /* spew the result to an event log. */
        if (pBuf->ret_code == IOCTL_CVY_NOT_FOUND) {
            UNIV_PRINT_VERB(("Main_ctrl: Port %d not found in any of the valid port rules", pBuf->data.port.num));
            TRACE_VERB("%!FUNC! Port %d not found in any of the valid port rules", pBuf->data.port.num);

            LOG_MSG(MSG_WARN_PORT_NOT_FOUND, num);
        } else if (pBuf->ret_code == IOCTL_CVY_OK) {
            if (ioctl == IOCTL_CVY_PORT_ON) {
                if (pBuf->data.port.num == IOCTL_ALL_PORTS) {
                    UNIV_PRINT_VERB(("Main_ctrl: All port rules enabled"));
                    TRACE_VERB("%!FUNC! All port rules enabled");

                    LOG_MSG(MSG_INFO_PORT_ENABLED_ALL, MSG_NONE);
                } else {
                    UNIV_PRINT_VERB(("Main_ctrl: Rule for port %d enabled", pBuf->data.port.num));
                    TRACE_VERB("%!FUNC! Rule for port %d enabled", pBuf->data.port.num);

                    LOG_MSG(MSG_INFO_PORT_ENABLED, num);
                }
            } else {
                if (pBuf->data.port.num == IOCTL_ALL_PORTS) {
                    UNIV_PRINT_VERB(("Main_ctrl: All port rules adjusted"));
                    TRACE_VERB("%!FUNC! All port rules adjusted");

                    LOG_MSG(MSG_INFO_PORT_ADJUSTED_ALL, MSG_NONE);
                } else {
                    UNIV_PRINT_VERB(("Main_ctrl: Rule for port %d adjusted to %d", pBuf->data.port.num, pBuf->data.port.load));
                    TRACE_VERB("%!FUNC! Rule for port %d adjusted to %d", pBuf->data.port.num, pBuf->data.port.load);

                    LOG_MSG(MSG_INFO_PORT_ADJUSTED, num);
                }
            }
        } else {
            UNIV_PRINT_VERB(("Main_ctrl: Port %d already enabled", pBuf->data.port.num));
        }

        break;
    }
    /* Shut-off (disable) or drain the connections on a port rule.  Disabling a port rule
       will destroy all connection information about currently active TCP connections and
       cause convergence so that this host will not handle any more connections on this 
       port rule.  Draining also sets the load weigh to zero, but does not destroy the 
       connection descriptors, such that this host continues to handle existing connections. */
    case IOCTL_CVY_PORT_OFF:
    case IOCTL_CVY_PORT_DRAIN:
    {
        /* Extract this host's ID for the sake of event logging. */
        Univ_ulong_to_str(pBuf->data.port.num, num, 10);

        NdisAcquireSpinLock(&ctxtp->load_lock);

        /* If the cluster is suspended, then all control operations are ignored. */
        if (ctxtp->suspended) {
            UNIV_ASSERT(!ctxtp->convoy_enabled);
            UNIV_ASSERT(!ctxtp->draining);

            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cluster mode is suspended"));

            /* Alert the user that the cluster is in the suspended state. */
            pBuf->ret_code = IOCTL_CVY_SUSPENDED;

            break;
        }

        /* If the cluster is stopped, then the load module is turned off,
           so we should ignore this request as well. */
        if (!ctxtp->convoy_enabled) {
            NdisReleaseSpinLock(&ctxtp->load_lock);

            UNIV_PRINT_VERB(("Main_ctrl: Cannot enable/disable port while cluster is stopped"));
            TRACE_VERB("%!FUNC! Cannot enable/disable port while cluster is stopped");

            LOG_MSG(MSG_WARN_CLUSTER_STOPPED, MSG_NONE);

            /* Alert the user that the cluster is stopped. */
            pBuf->ret_code = IOCTL_CVY_STOPPED;

            break;
        }

        /* If there is no common buffer, which can happen if this is a remote control request from a down-level
           client, then we hard-code the VIP to 0xffffffff.  If the cluster is operating in a mode that is 
           compatible with down-level clients, i.e. no per-VIP port rules, no BDA, etc, then hardcoding this
           parameter will not matter (the affect is not altered by its value), otherwise we shouldn't get to 
           here because Main_ctrl_recv is supposed to block those requests. */
        if (!pCommon) {
            UNIV_PRINT_VERB(("Main_ctrl: DISABLE: Calling Load_port_change -> VIP=%08x, port=%d, load=%d\n", IOCTL_ALL_VIPS, pBuf->data.port.num, pBuf->data.port.load));

            pBuf->ret_code = Load_port_change(&ctxtp->load, IOCTL_ALL_VIPS, pBuf->data.port.num, ioctl, pBuf->data.port.load);
        /* If there is a common buffer, then we can extract the VIP from there. */
        } else {
            UNIV_PRINT_VERB(("Main_ctrl: DISABLE: Calling Load_port_change -> VIP=%08x, port=%d, load=%d\n", pCommon->port.vip, pBuf->data.port.num, pBuf->data.port.load));
            
            pBuf->ret_code = Load_port_change(&ctxtp->load, pCommon->port.vip, pBuf->data.port.num, ioctl, pBuf->data.port.load);
        }

        NdisReleaseSpinLock(&ctxtp->load_lock);

        /* spew the result to an event log. */
        if (pBuf->ret_code == IOCTL_CVY_NOT_FOUND) {
            UNIV_PRINT_VERB(("Main_ctrl: Port %d not found in any of the valid port rules", pBuf->data.port.num));
            TRACE_VERB("%!FUNC! Port %d not found in any of the valid port rules", pBuf->data.port.num);

            LOG_MSG(MSG_WARN_PORT_NOT_FOUND, num);
        } else if (pBuf->ret_code == IOCTL_CVY_OK) {
            if (ioctl == IOCTL_CVY_PORT_OFF) {
                if (pBuf->data.port.num == IOCTL_ALL_PORTS) {
                    UNIV_PRINT_VERB(("Main_ctrl: All port rules disabled"));
                    TRACE_VERB("%!FUNC! All port rules disabled");

                    LOG_MSG(MSG_INFO_PORT_DISABLED_ALL, MSG_NONE);
                } else {
                    UNIV_PRINT_VERB(("Main_ctrl: Rule for port %d disabled", pBuf->data.port.num));
                    TRACE_VERB("%!FUNC! Rule for port %d disabled", pBuf->data.port.num);

                    LOG_MSG(MSG_INFO_PORT_DISABLED, num);
                }
            } else {
                if (pBuf->data.port.num == IOCTL_ALL_PORTS) {
                    UNIV_PRINT_VERB(("Main_ctrl: All port rules drained"));
                    TRACE_VERB("%!FUNC! All port rules drained");

                    LOG_MSG(MSG_INFO_PORT_DRAINED_ALL, MSG_NONE);
                } else {
                    UNIV_PRINT_VERB(("Main_ctrl: Rule for port %d drained", pBuf->data.port.num));
                    TRACE_VERB("%!FUNC! Rule for port %d drained", pBuf->data.port.num);

                    LOG_MSG(MSG_INFO_PORT_DRAINED, num);
                }
            }
        } else {
            UNIV_PRINT_VERB(("Main_ctrl: Port %d already disabled", pBuf->data.port.num));
        }

        break;
    }
    /* Query this host for its current state and the membership of the cluster. */
    case IOCTL_CVY_QUERY:
    {
        NdisAcquireSpinLock(&ctxtp->load_lock);

        /* If this is a local query, by default, indicate no convergence information. */
        if (pLocal)
            pLocal->query.flags &= ~NLB_OPTIONS_QUERY_CONVERGENCE;

        /* If the cluster is suspended, then it won't actually be an active member of
           the cluster, so we can't provide a membership map - just alert the user to
           the fact that this host is suspended. */
        if (ctxtp->suspended) {
            UNIV_PRINT_VERB(("Main_ctrl: Cannot query status - this host is suspended"));
            pBuf->data.query.state = IOCTL_CVY_SUSPENDED;
        /* If the cluster is stopped, then we are not part of the cluster and cannot
           provide any membership information, so just let the user know that this
           host is stopped. */
        } else if (!ctxtp->convoy_enabled) {
            UNIV_PRINT_VERB(("Main_ctrl: Cannot query status - this host is not part of the cluster"));
            pBuf->data.query.state = IOCTL_CVY_STOPPED;
        /* If the adapter is disconnected from the network, then we aren't sending or
           receiving heartbeats, so we are again not part of the cluster - just let 
           the user know that the media is disconnected. */
        } else if (!ctxtp->media_connected || !MAIN_PNP_DEV_ON(ctxtp)) {
            UNIV_PRINT_VERB(("Main_ctrl: Cannot query status - this host is not connected to the network"));
            pBuf->data.query.state = IOCTL_CVY_DISCONNECTED;
        } else {
            ULONG tmp_host_map;

            /* Query the load module for the state of convergence and the cluster membership. */
            pBuf->data.query.state = (USHORT)Load_hosts_query(&ctxtp->load, FALSE, &tmp_host_map);

            /* Return the host map to the request initiator. */
            pBuf->data.query.host_map = tmp_host_map;

            /* If this is a local query, then we may have to include convergence information. */
            if (pLocal) {
                ULONG num_cvgs;
                ULONG last_cvg;
                
                /* If the load module is active, this function returns TRUE and fills
                   in the total number of convergences and the last time convergence
                   completed.  If the load module is inactive, it returns FALSE. */
                if (Load_query_convergence_info(&ctxtp->load, &num_cvgs, &last_cvg)) {
                    pLocal->query.flags |= NLB_OPTIONS_QUERY_CONVERGENCE;
                    pLocal->query.NumConvergences = num_cvgs;
                    pLocal->query.LastConvergence = last_cvg;                    
                } else {
                    pLocal->query.flags &= ~NLB_OPTIONS_QUERY_CONVERGENCE;
                }
            }

            /* If we are draining connections and the load module is converged, then
               tell the user that we are draining; otherwise the notification that the
               cluster is converging should supercede draining notification. */
            if (ctxtp->draining && pBuf->data.query.state != IOCTL_CVY_CONVERGING)
                pBuf->data.query.state = IOCTL_CVY_DRAINING;
        }

        /* Return our host ID to the requestee. */
        pBuf->data.query.host_id = (USHORT)ctxtp->params.host_priority;

        NdisReleaseSpinLock(&ctxtp->load_lock);

        /* If the request is from a host that supports the hostname in the remote
           control protocol (versions >= Win XP), copy the hostname and set the 
           hostname flag to let the request initiator that we have filled it in. */
        if (pRemote) {
            if (ctxtp->params.hostname[0] != UNICODE_NULL) {
                /* Since ctxtp->params.hostname can be larger than the space available
                   in the remote control packet, assume it's too big and do a truncate */
                NdisMoveMemory(pRemote->query.hostname, ctxtp->params.hostname, (CVY_MAX_HOST_NAME) * sizeof(WCHAR));
                pRemote->query.hostname[CVY_MAX_HOST_NAME] = UNICODE_NULL;
                pRemote->query.flags |= NLB_OPTIONS_QUERY_HOSTNAME;
            } else {
                pRemote->query.flags &= ~NLB_OPTIONS_QUERY_HOSTNAME;
            }
        }

        break;
    }       
    case IOCTL_CVY_QUERY_BDA_TEAMING:
    {
        UNIV_ASSERT(pLocal);

        /* Security fix: Forcefully null terminate BDA Team Id, just in case */
        pLocal->state.bda.TeamID[(sizeof(pLocal->state.bda.TeamID)/sizeof(WCHAR)) - 1] = UNICODE_NULL;

        /* Query NLB for the current state of a given BDA team.  This function will attempt
           to find the given team in the global linked list of teams.  If it finds the spec-
           ified team, it will fill in the state of the team as well as information about 
           the configuration of each member. */
        pBuf->ret_code = Main_query_bda_teaming(ctxtp, &pLocal->state.bda);

        break;
    }
    /* Query the given NLB instance for its current parameter set, basically copying the 
       contents of our CVY_PARAMS structure into the provided IOCTL_REG_PARAMS structure. */
    case IOCTL_CVY_QUERY_PARAMS:
    {
        UNIV_ASSERT(pLocal);

        /* Query NLB for the current parameter set for this adapter - this essentially just
           copies the parameters in the driver data structures to the IOCTL buffer, and in 
           most instances the parameters will match what is set in the registry. */
        Main_query_params(ctxtp, &pLocal->state.params);
        
        /* This operation ALWAYS returns success because it CAN'T really fail. */
        pBuf->ret_code = IOCTL_CVY_OK;
        
        break;
    }
    /* Given a port number, query the load module for its state, including whether the port
       rule is enabled, disabled or in the act of draining.  This also gathers some packet 
       handling statistics including bytes and packets handled and dropped on this port rule. */
    case IOCTL_CVY_QUERY_PORT_STATE:
    {
        UNIV_ASSERT(pCommon);

        /* Query the load module for the state of the specified rule.  The load module will
           look up the port rule and fill in the buffer we pass it with the applicable state
           and statistical data. */
        Load_query_port_state(&ctxtp->load, &pCommon->state.port, pCommon->state.port.VirtualIPAddress, pCommon->state.port.Num);
        
        /* This operation ALWAYS returns success because it CAN'T really fail. */
        pBuf->ret_code = IOCTL_CVY_OK;
        
        break;
    }
    /* Given a IP tuple (client IP, client port, server IP, server port) and a protocol, 
       determine whether or not this host would accept the packet and why or why not. It
       is important that this is performed completely unobtrusively and has no side-effects
       on the actual operation of NLB and the load module. */
    case IOCTL_CVY_QUERY_FILTER:
    {
        UNIV_ASSERT(pCommon);

        /* Query NLB for packet filter information for this IP tuple and protocol.  Main_query_packet_filter
           checks the NDIS driver information for filtering issues such as DIP traffic, BDA teaming and 
           NLB driver state (on/off due to wlbs.exe commands and parameter errors).  If necessary, it then
           consults the load module to perform the actual port rule lookup and determine packet acceptance. */
        Main_query_packet_filter(ctxtp, &pCommon->state.filter);

        /* This operation ALWAYS returns success because it CAN'T really fail. */
        pBuf->ret_code = IOCTL_CVY_OK;

        break;
    }
    case IOCTL_CVY_CONNECTION_NOTIFY:
    {
        PNLB_OPTIONS_CONN_NOTIFICATION pConn;
        BOOLEAN                        bRet     = TRUE;

        UNIV_ASSERT(pLocal);

        /* This function is only supported locally. */
        pConn = &pLocal->notification.conn;
        
        /* Make sure that the parameters from the input buffer are valid. */
        if (pConn->Protocol != TCPIP_PROTOCOL_IPSEC1) {
            TRACE_PACKET("%!FUNC! Bad connection notification params");

            /* Use the return code in the IOCTL buffer to relay a parameter error. */
            pBuf->ret_code = IOCTL_CVY_BAD_PARAMS;
            
            break;
        }
   
        switch (pConn->Operation) {
        case NLB_CONN_UP:
        {
#if defined (NLB_HOOK_ENABLE)
            NLB_FILTER_HOOK_DIRECTIVE filter = NLB_FILTER_HOOK_PROCEED_WITH_HASH;
#endif

            TRACE_PACKET("%!FUNC! Got a CONN_UP for 0x%08x:%u -> 0x%08x:%u (%u)", pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol);

#if defined (NLB_HOOK_ENABLE)
            /* Invoke the packet query hook, if one has been registered. */
            filter = Main_query_hook(ctxtp, pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol);
            
            /* Process some of the hook responses. */
            if (filter == NLB_FILTER_HOOK_REJECT_UNCONDITIONALLY) 
            {
                /* If the hook asked us to reject this packet, then we can do so here. */
                TRACE_INFO("%!FUNC! Packet receive filter hook: REJECT packet");
                
                /* Return REFUSED to notify the caller that a call to WlbsConnectionDown/Reset is NOT necessary. */
                pBuf->ret_code = IOCTL_CVY_REQUEST_REFUSED;

                TRACE_PACKET("%!FUNC! Returning %u", pBuf->ret_code);
                break;
            }
            else if (filter == NLB_FILTER_HOOK_ACCEPT_UNCONDITIONALLY) 
            {
                /* If the hook asked us to accept this packet, then break out and don't create state. */
                TRACE_INFO("%!FUNC! Packet receive filter hook: ACCEPT packet");
                
                /* Return REFUSED to notify the caller that a call to WlbsConnectionDown/Reset is NOT necessary. */
                pBuf->ret_code = IOCTL_CVY_REQUEST_REFUSED;

                TRACE_PACKET("%!FUNC! Returning %u", pBuf->ret_code);
                break;
            }
#endif

            /* Notify the load module of the upcoming connection. */
#if defined (NLB_TCP_NOTIFICATION)
            if (NLB_NOTIFICATIONS_ON())
            {
#if defined (NLB_HOOK_ENABLE)
                bRet = Main_conn_up(ctxtp, pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol, filter);
#else
                bRet = Main_conn_up(ctxtp, pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol);
#endif
            }
            else
            {
#endif
#if defined (NLB_HOOK_ENABLE)
                bRet = Main_conn_notify(ctxtp, pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol, CVY_CONN_UP, filter);
#else
                bRet = Main_conn_notify(ctxtp, pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol, CVY_CONN_UP);
#endif
#if defined (NLB_TCP_NOTIFICATION)
            }
#endif


            /* If the packet was refused by BDA or rejected by the load module, return refusal error, otherwise, it succeeded. */
            if (!bRet) 
                pBuf->ret_code = IOCTL_CVY_REQUEST_REFUSED;
            else 
                pBuf->ret_code = IOCTL_CVY_OK;

            TRACE_PACKET("%!FUNC! Returning %u", pBuf->ret_code);

            break;
        }
        case NLB_CONN_DOWN:
        {
            TRACE_PACKET("%!FUNC! Got a CONN_DOWN for 0x%08x:%u -> 0x%08x:%u (%u)", pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol);

            /* Notify the load module that a connection is being torn down. */
#if defined (NLB_TCP_NOTIFICATION)
            if (NLB_NOTIFICATIONS_ON())
            {
                bRet = Main_conn_down(pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol, CVY_CONN_DOWN);
            }
            else
            {
#endif
#if defined (NLB_HOOK_ENABLE)
                bRet = Main_conn_notify(ctxtp, pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol, CVY_CONN_DOWN, NLB_FILTER_HOOK_PROCEED_WITH_HASH);
#else
                bRet = Main_conn_notify(ctxtp, pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol, CVY_CONN_DOWN);
#endif
#if defined (NLB_TCP_NOTIFICATION)
            }
#endif
            
            /* If the packet was refused by BDA or rejected by the load module, return refusal error, otherwise, it succeeded. */
            if (!bRet) 
                pBuf->ret_code = IOCTL_CVY_REQUEST_REFUSED;
            else
                pBuf->ret_code = IOCTL_CVY_OK;

            TRACE_PACKET("%!FUNC! Returning %u", pBuf->ret_code);

            break;
        }
        case NLB_CONN_RESET:
        {
            TRACE_PACKET("%!FUNC! Got a CONN_RESET for 0x%08x:%u -> 0x%08x:%u (%u)", pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol);

            /* Notify the load module that a connection is being reset. */
#if defined (NLB_TCP_NOTIFICATION)
            if (NLB_NOTIFICATIONS_ON())
            {
                bRet = Main_conn_down(pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol, CVY_CONN_RESET);
            }
            else
            {
#endif
#if defined (NLB_HOOK_ENABLE)
                bRet = Main_conn_notify(ctxtp, pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol, CVY_CONN_RESET, NLB_FILTER_HOOK_PROCEED_WITH_HASH);
#else
                bRet = Main_conn_notify(ctxtp, pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol, CVY_CONN_RESET);
#endif
#if defined (NLB_TCP_NOTIFICATION)
            }
#endif
       
            /* If the packet was refused by BDA or rejected by the load module, return refusal error, otherwise, it succeeded. */
            if (!bRet) 
                pBuf->ret_code = IOCTL_CVY_REQUEST_REFUSED;
            else
                pBuf->ret_code = IOCTL_CVY_OK;

            TRACE_PACKET("%!FUNC! Returning %u", pBuf->ret_code);

            break;
        }
        default:
            TRACE_PACKET("%!FUNC! Unknown connection notification operation: %d", pConn->Operation);
            
            /* This should never, ever happen, but if it does, signal a generic NLB error and fail. */
            pBuf->ret_code = IOCTL_CVY_GENERIC_FAILURE;

            TRACE_PACKET("%!FUNC! Returning %u", pBuf->ret_code);
            
            break;
        }
        
        break;
    }
    case IOCTL_CVY_QUERY_MEMBER_IDENTITY:
        NdisAcquireSpinLock(&ctxtp->load_lock);

        pBuf->ret_code = IOCTL_CVY_GENERIC_FAILURE;

        UNIV_ASSERT(pLocal);

        if (pLocal != NULL)
        {
            /* Get the input host_id from the caller, which has range 1-32. */
            ULONG user_host_id = pLocal->identity.host_id;
            /* The driver's host id has range 0-31 */
            ULONG driver_host_id = IOCTL_NO_SUCH_HOST;

            /* Zero the response structure and initialize the host property to "not found" */
            NdisZeroMemory(&pLocal->identity.cached_entry, sizeof(pLocal->identity.cached_entry));
            pLocal->identity.cached_entry.host = IOCTL_NO_SUCH_HOST;

            /* Fill in the host map */
            pLocal->identity.host_map = Main_get_cached_hostmap(ctxtp);

            /* Validate the host id the user is requesting information on */
            if (((user_host_id > CVY_MAX_HOSTS) || (user_host_id < CVY_MIN_MAX_HOSTS)) &&
                (user_host_id != IOCTL_FIRST_HOST))
            {
                pBuf->ret_code = IOCTL_CVY_BAD_PARAMS;
                UNIV_PRINT_CRIT(("Main_ctrl: Illegal host_id [1, 32] %d from user while requesting cached identity information", user_host_id));
                TRACE_CRIT("%!FUNC! Illegal host_id [1, 32] %d from user while requesting cached identity information", user_host_id);
                goto endcase_identity;
            }

            /* Any response after this is a success */
            pBuf->ret_code = IOCTL_CVY_OK;

            /* Special case if the caller wants the first in the list */
            if (user_host_id == IOCTL_FIRST_HOST)
            {
                driver_host_id = Main_find_first_in_cache(ctxtp);

                /* Main_find_first_in_cache returns CVY_MAX_HOSTS if the cache is empty, so not an error if leaving case here. */
                if (driver_host_id >= CVY_MAX_HOSTS)
                {
                    UNIV_PRINT_VERB(("Main_ctrl: Identity cache is empty"));
                    TRACE_VERB("%!FUNC! No host information in the identity cache");
                    goto endcase_identity;
                }
            }
            else
            {
                /* Already verified that user_host_id is valid (1-32). Convert to driver-based host id (0-31) */
                driver_host_id = user_host_id - 1;
            }

            /* We have a legal driver_host_id (0-31 range). Retrieve the cache information if it is currently valid. Return "not found" otherwise. */
            if (ctxtp->identity_cache[driver_host_id].ttl > 0)
            {
                ULONG ulFqdnCB = min(sizeof(pLocal->identity.cached_entry.fqdn) - sizeof(WCHAR),
                                     sizeof(WCHAR)*wcslen(ctxtp->identity_cache[driver_host_id].fqdn)
                                     );

                /* Convert host id back to range 1-32 for the user */
                pLocal->identity.cached_entry.host        = ctxtp->identity_cache[driver_host_id].host_id + 1;
                pLocal->identity.cached_entry.ded_ip_addr = ctxtp->identity_cache[driver_host_id].ded_ip_addr;

                if (ulFqdnCB > 0)
                {
                    NdisMoveMemory(&pLocal->identity.cached_entry.fqdn, &ctxtp->identity_cache[driver_host_id].fqdn, ulFqdnCB);
                }
            }
        }

endcase_identity:

        NdisReleaseSpinLock(&ctxtp->load_lock);

        break;
    default:
        UNIV_PRINT_CRIT(("Main_ctrl: Bad IOCTL %x", ioctl));
        status = NDIS_STATUS_FAILURE;
        break;
    }

    /* Re-set the control operation in progress flag.  Note that it is not strictly
       necessary to hold the lock while re-setting this flag; the worst that will 
       happen is that we cause another thread to fail to start a control operation 
       when it might have been able to enter the critical section.  To avoid that 
       possiblilty, hold the univ_bind_lock while re-setting this flag. */
    ctxtp->ctrl_op_in_progress = FALSE;

    TRACE_VERB("<-%!FUNC! return=0x%x", status);
    return status;
}

/*
 * Function: 
 * Description: 
 * Parameters: 
 * Returns: 
 * Author: 
 * Notes: 
 */
NDIS_STATUS Main_ctrl_recv (
    PMAIN_CTXT          ctxtp,
    PMAIN_PACKET_INFO   pPacketInfo)
{
    NDIS_STATUS         status = NDIS_STATUS_SUCCESS;
    PIP_HDR             ip_hdrp;
    PUDP_HDR            udp_hdrp;
    PUCHAR              mac_hdrp;
    ULONG               soff, doff;
    CVY_MAC_ADR         tmp_mac;
    PIOCTL_REMOTE_HDR   rct_hdrp = NULL;              // we'll check for null when deleting.
    ULONG               rct_allocated_length = 0;
    ULONG               state, host_map;
    USHORT              checksum, group;
    ULONG               i;
    ULONG               tmp_src_addr, tmp_dst_addr;   
    USHORT              tmp_src_port, tmp_dst_port;   

    UNIV_PRINT_VERB(("Main_ctrl_recv: Processing"));

    UNIV_ASSERT((pPacketInfo->Type == TCPIP_IP_SIG) && (pPacketInfo->IP.Protocol == TCPIP_PROTOCOL_UDP));

    /* Extract the necessary information from information parsed by Main_recv_frame_parse. */
    ip_hdrp = pPacketInfo->IP.pHeader;
    udp_hdrp = pPacketInfo->IP.UDP.pHeader;
    mac_hdrp = (PUCHAR)pPacketInfo->Ethernet.pHeader;

    checksum = Tcpip_chksum(&ctxtp->tcpip, pPacketInfo, TCPIP_PROTOCOL_IP);

    if (IP_GET_CHKSUM (ip_hdrp) != checksum)
    {
        UNIV_PRINT_CRIT(("Main_ctrl_recv: Bad IP checksum %x vs %x\n", IP_GET_CHKSUM (ip_hdrp), checksum))
        TRACE_CRIT("%!FUNC! Bad IP checksum 0x%x vs 0x%x", IP_GET_CHKSUM (ip_hdrp), checksum);
        goto quit;
    }

    checksum = Tcpip_chksum(&ctxtp->tcpip, pPacketInfo, TCPIP_PROTOCOL_UDP);

    if (UDP_GET_CHKSUM (udp_hdrp) != checksum)
    {
        UNIV_PRINT_CRIT(("Main_ctrl_recv: Bad UDP checksum %x vs %x\n", UDP_GET_CHKSUM (udp_hdrp), checksum))
        TRACE_CRIT("%!FUNC! Bad UDP checksum 0x%x vs 0x%x", UDP_GET_CHKSUM (udp_hdrp), checksum);
        goto quit;
    }

    /* Create an aligned version of the structure.  Allocate and populate an IOCTL_REMOTE_HDR 
       buffer.  This guarantees that the information is 8-byte aligned. */
    status = NdisAllocateMemoryWithTag(&rct_hdrp, pPacketInfo->IP.UDP.Payload.Length, UNIV_POOL_TAG);
    
    if (status != NDIS_STATUS_SUCCESS)
    {
        TRACE_CRIT("failed to allocate rct_hdrp buffer = 0x%x", status);
        rct_hdrp = NULL;
        goto quit;
    }
    
    NdisMoveMemory(rct_hdrp, pPacketInfo->IP.UDP.Payload.pPayload, pPacketInfo->IP.UDP.Payload.Length);

    /* double-check the code */
    if (rct_hdrp -> code != IOCTL_REMOTE_CODE)
    {
        UNIV_PRINT_CRIT(("Main_ctrl_recv: Bad RCT code %x\n", rct_hdrp -> code));
        TRACE_CRIT("%!FUNC! Bad RCT code 0x%x", rct_hdrp -> code);
        goto quit;
    }

    /* might want to take appropriate actions for a message from a host
       running different version number of software */

    if (rct_hdrp -> version != CVY_VERSION_FULL)
    {
        UNIV_PRINT_VERB(("Main_ctrl_recv: Version mismatch %x vs %x", rct_hdrp -> version, CVY_VERSION_FULL));
        TRACE_VERB("%!FUNC! Version mismatch 0x%x vs 0x%x", rct_hdrp -> version, CVY_VERSION_FULL);
    }

    /* see if this message is destined for this cluster */

    if (rct_hdrp -> cluster != ctxtp -> cl_ip_addr)
    {
        UNIV_PRINT_VERB(("Main_ctrl_recv: Message for cluster %08X rejected on cluster %08X", rct_hdrp -> cluster, ctxtp -> cl_ip_addr));
        TRACE_VERB("%!FUNC! Message for cluster 0x%08X rejected on cluster 0x%08X", rct_hdrp -> cluster, ctxtp -> cl_ip_addr);
        goto quit;
    }

    /* Set "access bits" in IOCTL code to use local settings ie. FILE_WRITE_ACCESS */
    SET_IOCTL_ACCESS_BITS_TO_LOCAL(rct_hdrp->ioctrl)

    /* 64-bit -- ramkrish */

    tmp_src_addr = IP_GET_SRC_ADDR_64(ip_hdrp);
    tmp_dst_addr = IP_GET_DST_ADDR_64(ip_hdrp);

    /* do not trust src addr in header, since winsock does not resolve
       multihomed addresses properly */

    rct_hdrp -> addr = tmp_src_addr;

    /* If remote control is disabled, we drop the requests. */
    if (!ctxtp->params.rct_enabled)
        goto quit;

    /* query load to see if we are the master, etc. */

    if (! ctxtp -> convoy_enabled)
        state = IOCTL_CVY_STOPPED;
    else
        state = Load_hosts_query (& ctxtp -> load, FALSE, & host_map);

    /* check if this message is destined to us */

    //
    // The host id in the remote control packet could be
    //      IOCTL_MASTER_HOST (0) for master host
    //      IOCTL_ALL_HOSTS (FFFFFFFF) for all hosts
    //      Host ID, for one host
    //      Dedicated IP, for one host
    //      Cluster IP, for all hosts in the cluster
    //
    
    if (rct_hdrp -> host == IOCTL_MASTER_HOST)
    {
        if (state != IOCTL_CVY_MASTER)
        {
            UNIV_PRINT_VERB(("Main_ctrl_recv: RCT request for MASTER host rejected"));
            TRACE_VERB("%!FUNC! RCT request for MASTER host rejected");
            goto quit;
        }
    }
    else if (rct_hdrp -> host != IOCTL_ALL_HOSTS)
    {
        if (rct_hdrp -> host > CVY_MAX_HOSTS)
        {
            if (! ((ctxtp -> ded_ip_addr != 0 &&
                    rct_hdrp -> host == ctxtp -> ded_ip_addr) ||
                    rct_hdrp -> host == ctxtp -> cl_ip_addr))
            {
                UNIV_PRINT_VERB(("Main_ctrl_recv: RCT request for host IP %x rejected", rct_hdrp -> host));
                TRACE_VERB("%!FUNC! RCT request for host IP 0x%x rejected", rct_hdrp -> host);
                goto quit;
            }
        }
        else
        {
            if (! (rct_hdrp -> host == ctxtp -> params . host_priority ||
                   rct_hdrp -> host == 0))
            {
                UNIV_PRINT_VERB(("Main_ctrl_recv: RCT request for host ID %d rejected", rct_hdrp -> host));
                TRACE_VERB("%!FUNC! RCT request for host ID %d rejected", rct_hdrp -> host);
                goto quit;
            }
        }
    }

    /* if this is VR remote maintenance password */

    if (rct_hdrp -> password == IOCTL_REMOTE_VR_CODE)
    {
        /* if user disabled this function - drop the packet */

        if (ctxtp -> params . rmt_password == 0)
        {
            UNIV_PRINT_CRIT(("Main_ctrl_recv: VR remote password rejected"));
            TRACE_CRIT("%!FUNC! VR remote password rejected");
            goto quit;
        }
        else
        {
            UNIV_PRINT_VERB(("Main_ctrl_recv: VR remote password accepted"));
            TRACE_VERB("%!FUNC! VR remote password accepted");
        }
    }

    //
    // This is a new remote control request, with a different source IP 
    //  or newer ID.
    // Log an event if the password does not match or if the command is not query
    //
    if (! (rct_hdrp -> addr == ctxtp -> rct_last_addr &&
           rct_hdrp -> id   <= ctxtp -> rct_last_id))
    {
        PWCHAR              buf;
        PWCHAR              ptr;

        /* Allocate memory to hold a string buffer containing the source IP
           address and UDP port of the initiator of this remote control request. */
        status = NdisAllocateMemoryWithTag(&buf, 256 * sizeof(WCHAR), UNIV_POOL_TAG);

        if (status != NDIS_STATUS_SUCCESS) {
            UNIV_PRINT_CRIT(("Main_ctrl_recv: Unable to allocate memory.  Exiting..."));
            TRACE_CRIT("%!FUNC! Unable to allocate memory");
            LOG_MSG2(MSG_ERROR_MEMORY, MSG_NONE, 256 * sizeof(WCHAR), status);
            goto quit;
        }

        ptr = buf;

        //
        // Generate string "SourceIp:SourcePort"
        //
        for (i = 0; i < 4; i ++)
        {
            ptr = Univ_ulong_to_str (IP_GET_SRC_ADDR (ip_hdrp, i), ptr, 10);

            * ptr = L'.';
            ptr ++;
        }

        ptr --;
        * ptr = L':';
        ptr ++;

        ptr = Univ_ulong_to_str (UDP_GET_SRC_PORT (udp_hdrp), ptr, 10);
        * ptr = 0;

        if (ctxtp -> params . rct_password != 0 &&
            rct_hdrp -> password != ctxtp -> params . rct_password)
        {
            LOG_MSG (MSG_WARN_RCT_HACK, buf);

            UNIV_PRINT_CRIT(("Main_ctrl_recv: RCT hack attempt on port %d from %u.%u.%u.%u:%d",
                                                UDP_GET_DST_PORT (udp_hdrp),
                                                IP_GET_SRC_ADDR (ip_hdrp, 0),
                                                IP_GET_SRC_ADDR (ip_hdrp, 1),
                                                IP_GET_SRC_ADDR (ip_hdrp, 2),
                                                IP_GET_SRC_ADDR (ip_hdrp, 3),
                                                UDP_GET_SRC_PORT (udp_hdrp)));
            TRACE_CRIT("%!FUNC! RCT hack attempt on port %d from %u.%u.%u.%u:%u",
                                                UDP_GET_DST_PORT (udp_hdrp),
                                                IP_GET_SRC_ADDR (ip_hdrp, 0),
                                                IP_GET_SRC_ADDR (ip_hdrp, 1),
                                                IP_GET_SRC_ADDR (ip_hdrp, 2),
                                                IP_GET_SRC_ADDR (ip_hdrp, 3),
                                                UDP_GET_SRC_PORT (udp_hdrp));
        }

        /* only log error commands and commands that affect cluster state */

        else if ((rct_hdrp -> ioctrl != IOCTL_CVY_QUERY) &&
                 (rct_hdrp -> ioctrl != IOCTL_CVY_QUERY_FILTER) &&
                 (rct_hdrp -> ioctrl != IOCTL_CVY_QUERY_PORT_STATE))
        {
            PWSTR           cmd;

            switch (rct_hdrp -> ioctrl)
            {
                case IOCTL_CVY_CLUSTER_ON:
                    cmd = L"START";
                    break;

                case IOCTL_CVY_CLUSTER_OFF:
                    cmd = L"STOP";
                    break;

                case IOCTL_CVY_CLUSTER_DRAIN:
                    cmd = L"DRAINSTOP";
                    break;

                case IOCTL_CVY_PORT_ON:
                    cmd = L"ENABLE";
                    break;

                case IOCTL_CVY_PORT_SET:
                    cmd = L"ADJUST";
                    break;

                case IOCTL_CVY_PORT_OFF:
                    cmd = L"DISABLE";
                    break;

                case IOCTL_CVY_PORT_DRAIN:
                    cmd = L"DRAIN";
                    break;

                case IOCTL_CVY_CLUSTER_SUSPEND:
                    cmd = L"SUSPEND";
                    break;

                case IOCTL_CVY_CLUSTER_RESUME:
                    cmd = L"RESUME";
                    break;

                default:
                    cmd = L"UNKNOWN";
                    break;
            }


            LOG_MSGS (MSG_INFO_RCT_RCVD, cmd, buf);

            UNIV_PRINT_VERB(("Main_ctrl_recv: RCT command %x port %d from %u.%u.%u.%u:%d",
                                                rct_hdrp -> ioctrl,
                                                UDP_GET_DST_PORT (udp_hdrp),
                                                IP_GET_SRC_ADDR (ip_hdrp, 0),
                                                IP_GET_SRC_ADDR (ip_hdrp, 1),
                                                IP_GET_SRC_ADDR (ip_hdrp, 2),
                                                IP_GET_SRC_ADDR (ip_hdrp, 3),
                                                UDP_GET_SRC_PORT (udp_hdrp)));
            TRACE_VERB("%!FUNC! RCT command 0x%x port %d from %u.%u.%u.%u:%u",
                                                rct_hdrp -> ioctrl,
                                                UDP_GET_DST_PORT (udp_hdrp),
                                                IP_GET_SRC_ADDR (ip_hdrp, 0),
                                                IP_GET_SRC_ADDR (ip_hdrp, 1),
                                                IP_GET_SRC_ADDR (ip_hdrp, 2),
                                                IP_GET_SRC_ADDR (ip_hdrp, 3),
                                                UDP_GET_SRC_PORT (udp_hdrp));

        }

        /* Free the memory we used for the initiator string. */
        NdisFreeMemory((PUCHAR)buf, 256 * sizeof(WCHAR), 0);
    }

    ctxtp -> rct_last_addr = rct_hdrp -> addr;
    ctxtp -> rct_last_id   = rct_hdrp -> id;

    /* make sure remote control password matches ours */

    if (ctxtp -> params . rct_password != 0 &&
        rct_hdrp -> password != ctxtp -> params . rct_password)
    {
        rct_hdrp -> ctrl . ret_code = IOCTL_CVY_BAD_PASSWORD;
        goto send;
    }

    /* The following operations are not valid if invoked remotely,
       so bail out if, somehow, a remote control request arrived
       with one of the following IOCTLs in the header. */
    if (rct_hdrp->ioctrl == IOCTL_CVY_RELOAD                 ||
        rct_hdrp->ioctrl == IOCTL_CVY_QUERY_PARAMS           ||
        rct_hdrp->ioctrl == IOCTL_CVY_QUERY_BDA_TEAMING      ||
        rct_hdrp->ioctrl == IOCTL_CVY_CONNECTION_NOTIFY      ||
        rct_hdrp->ioctrl == IOCTL_CVY_QUERY_MEMBER_IDENTITY
        )
        goto quit;

    if (rct_hdrp->version == CVY_NT40_VERSION_FULL) {
        /* Make sure that the packet length is what we expect, or we may fault. */
        if (pPacketInfo->IP.UDP.Length < NLB_NT40_RCTL_PACKET_LEN) {
            UNIV_PRINT_CRIT(("Version 0x%08x remote control packet not expected length: got %d bytes, expected %d bytes\n", CVY_NT40_VERSION_FULL, pPacketInfo->IP.UDP.Length, NLB_NT40_RCTL_PACKET_LEN));
            TRACE_CRIT("%!FUNC! Version %ls remote control packet not expected length: got %d bytes, expected %d bytes", CVY_NT40_VERSION, pPacketInfo->IP.UDP.Length, NLB_NT40_RCTL_PACKET_LEN);
            goto quit;
        }

        /* If this remote control packet came from an NT 4.0 host, check our current effective version
           and drop it if we are operating in a Whistler-specific mode (virtual clusters, BDA, etc.). */
        if (ctxtp->params.effective_ver == CVY_VERSION_FULL &&
            (rct_hdrp->ioctrl == IOCTL_CVY_PORT_ON          ||
             rct_hdrp->ioctrl == IOCTL_CVY_PORT_OFF         ||
             rct_hdrp->ioctrl == IOCTL_CVY_PORT_SET         ||
             rct_hdrp->ioctrl == IOCTL_CVY_PORT_DRAIN))
            goto quit;
        /* Otherwise, perform the operation.  NT 4.0 remote control packets do not contain options buffers, 
           so all three options pointers are NULL and Main_ctrl must handle the fact that they can be NULL. */
        else
            status = Main_ctrl(ctxtp, rct_hdrp->ioctrl, &(rct_hdrp->ctrl), NULL, NULL, NULL);
    } else if (rct_hdrp->version == CVY_WIN2K_VERSION_FULL) {
        /* Make sure that the packet length is what we expect, or we may fault. */
        if (pPacketInfo->IP.UDP.Length < NLB_WIN2K_RCTL_PACKET_LEN) {
            UNIV_PRINT_CRIT(("Version 0x%08x remote control packet not expected length: got %d bytes, expected %d bytes\n", CVY_WIN2K_VERSION_FULL, pPacketInfo->IP.UDP.Length, NLB_WIN2K_RCTL_PACKET_LEN));
            TRACE_CRIT("%!FUNC! Version %ls remote control packet not expected length: got %d bytes, expected %d bytes", CVY_WIN2K_VERSION, pPacketInfo->IP.UDP.Length, NLB_WIN2K_RCTL_PACKET_LEN);
            goto quit;
        }

        /* If this remote control packet came from an Win2k host, check our current effective version
           and drop it if we are operating in a Whistler-specific mode (virtual clusters, BDA, etc.). */
        if (ctxtp->params.effective_ver == CVY_VERSION_FULL &&
            (rct_hdrp->ioctrl == IOCTL_CVY_PORT_ON          ||
             rct_hdrp->ioctrl == IOCTL_CVY_PORT_OFF         ||
             rct_hdrp->ioctrl == IOCTL_CVY_PORT_SET         ||
             rct_hdrp->ioctrl == IOCTL_CVY_PORT_DRAIN))           
            goto quit;
        /* Otherwise, perform the operation.  Win2K remote control packets do not contain options buffers, 
           so all three options pointers are NULL and Main_ctrl must handle the fact that they can be NULL. */
        else
            status = Main_ctrl(ctxtp, rct_hdrp->ioctrl, &(rct_hdrp->ctrl), NULL, NULL, NULL);
    } else if (rct_hdrp->version == CVY_VERSION_FULL) {
        /* Make sure that the packet length is what we expect, or we may fault. */
        if (pPacketInfo->IP.UDP.Length < NLB_WINXP_RCTL_PACKET_LEN) {
            UNIV_PRINT_CRIT(("Version 0x%08x remote control packet not expected length: got %d bytes, expected %d bytes\n", CVY_VERSION_FULL, pPacketInfo->IP.UDP.Length, NLB_WINXP_RCTL_PACKET_LEN));
            TRACE_CRIT("%!FUNC! Version %ls remote control packet not expected length: got %d bytes, expected %d bytes", CVY_VERSION, pPacketInfo->IP.UDP.Length, NLB_WINXP_RCTL_PACKET_LEN);
            goto quit;
        }
        
        /* Perform the requested operation.  Local options is NULL - Main_ctrl will handle this. */
        status = Main_ctrl(ctxtp, rct_hdrp->ioctrl, &(rct_hdrp->ctrl), &(rct_hdrp->options.common), NULL, &(rct_hdrp->options));
    } else {
        goto quit;
    }

    /* if did not succeed - just drop the packet - client will timeout and
       resend the request */

    if (status != NDIS_STATUS_SUCCESS)
        goto quit;

send:

    rct_hdrp -> version = CVY_VERSION_FULL;
    rct_hdrp -> host    = ctxtp -> params . host_priority;
    rct_hdrp -> addr    = ctxtp -> ded_ip_addr;

    /* flip source and destination MAC, IP addresses and UDP ports to prepare
       for sending this message back */

    soff = CVY_MAC_SRC_OFF (ctxtp -> medium);
    doff = CVY_MAC_DST_OFF (ctxtp -> medium);

    /* V2.0.6 recoded for clarity */

    if (ctxtp -> params . mcast_support)
    {
        if (CVY_MAC_ADDR_BCAST (ctxtp -> medium, mac_hdrp + doff))
            CVY_MAC_ADDR_COPY (ctxtp -> medium, & tmp_mac, & ctxtp -> ded_mac_addr);
        else
            CVY_MAC_ADDR_COPY (ctxtp -> medium, & tmp_mac, mac_hdrp + doff);

        CVY_MAC_ADDR_COPY (ctxtp -> medium, mac_hdrp + doff, mac_hdrp + soff);
        CVY_MAC_ADDR_COPY (ctxtp -> medium, mac_hdrp + soff, & tmp_mac);
    }
    else
    {
        if (! CVY_MAC_ADDR_BCAST (ctxtp -> medium, mac_hdrp + doff))
        {
            CVY_MAC_ADDR_COPY (ctxtp -> medium, & tmp_mac, mac_hdrp + doff);
            CVY_MAC_ADDR_COPY (ctxtp -> medium, mac_hdrp + doff, mac_hdrp + soff);
        }
        else
            CVY_MAC_ADDR_COPY (ctxtp -> medium, & tmp_mac, & ctxtp -> ded_mac_addr);

        /* V2.0.6 spoof source mac to prevent switches from getting confused */

        if (ctxtp -> params . mask_src_mac &&
            CVY_MAC_ADDR_COMP (ctxtp -> medium, & tmp_mac, & ctxtp -> cl_mac_addr))
        {
            ULONG byte [4];

            CVY_MAC_ADDR_LAA_SET (ctxtp -> medium, mac_hdrp + soff);

            * ((PUCHAR) (mac_hdrp + soff + 1)) = (UCHAR) ctxtp -> params . host_priority;

            IP_GET_ADDR(ctxtp->cl_ip_addr, &byte[0], &byte[1], &byte[2], &byte[3]);

            * ((PUCHAR) (mac_hdrp + soff + 2)) = (UCHAR) byte[0];
            * ((PUCHAR) (mac_hdrp + soff + 3)) = (UCHAR) byte[1];
            * ((PUCHAR) (mac_hdrp + soff + 4)) = (UCHAR) byte[2];
            * ((PUCHAR) (mac_hdrp + soff + 5)) = (UCHAR) byte[3];  
        }
        else
            CVY_MAC_ADDR_COPY (ctxtp -> medium, mac_hdrp + soff, & tmp_mac);
    }

    /* Set "access bits" in IOCTL code to use remote (control) settings ie. FILE_ANY_ACCESS */
    SET_IOCTL_ACCESS_BITS_TO_REMOTE(rct_hdrp->ioctrl)

    /* Copy back the datagram contents from our aligned version. We must do this BEFORE
       we compute the checksums. */
    NdisMoveMemory(pPacketInfo->IP.UDP.Payload.pPayload, rct_hdrp, pPacketInfo->IP.UDP.Payload.Length);

    if (tmp_dst_addr == TCPIP_BCAST_ADDR)
    {
        tmp_dst_addr = ctxtp -> cl_ip_addr;

        if (ctxtp -> params . mcast_support)
            IP_SET_DST_ADDR_64 (ip_hdrp, tmp_src_addr);
    }
    else
        IP_SET_DST_ADDR_64 (ip_hdrp, tmp_src_addr);

    IP_SET_SRC_ADDR_64 (ip_hdrp, tmp_dst_addr);

    checksum = Tcpip_chksum(&ctxtp->tcpip, pPacketInfo, TCPIP_PROTOCOL_IP);

    IP_SET_CHKSUM (ip_hdrp, checksum);

    tmp_src_port = (USHORT) UDP_GET_SRC_PORT (udp_hdrp);
    tmp_dst_port = (USHORT) UDP_GET_DST_PORT (udp_hdrp);

    UDP_SET_SRC_PORT_64 (udp_hdrp, tmp_dst_port);
    UDP_SET_DST_PORT_64 (udp_hdrp, tmp_src_port);

    checksum = Tcpip_chksum(&ctxtp->tcpip, pPacketInfo, TCPIP_PROTOCOL_UDP);

    UDP_SET_CHKSUM (udp_hdrp, checksum);

#if defined(TRACE_RCT)
    DbgPrint ("(RCT) sending reply to %u.%u.%u.%u:%d [%02x-%02x-%02x-%02x-%02x-%02x]\n",
              IP_GET_DST_ADDR (ip_hdrp, 0),
              IP_GET_DST_ADDR (ip_hdrp, 1),
              IP_GET_DST_ADDR (ip_hdrp, 2),
              IP_GET_DST_ADDR (ip_hdrp, 3),
              UDP_GET_DST_PORT (udp_hdrp),
              * (mac_hdrp + doff + 0),
              * (mac_hdrp + doff + 1),
              * (mac_hdrp + doff + 2),
              * (mac_hdrp + doff + 3),
              * (mac_hdrp + doff + 4),
              * (mac_hdrp + doff + 5));
    DbgPrint ("                  from %u.%u.%u.%u:%d [%02x-%02x-%02x-%02x-%02x-%02x]\n",
              IP_GET_SRC_ADDR (ip_hdrp, 0),
              IP_GET_SRC_ADDR (ip_hdrp, 1),
              IP_GET_SRC_ADDR (ip_hdrp, 2),
              IP_GET_SRC_ADDR (ip_hdrp, 3),
              UDP_GET_SRC_PORT (udp_hdrp),
              * (mac_hdrp + soff + 0),
              * (mac_hdrp + soff + 1),
              * (mac_hdrp + soff + 2),
              * (mac_hdrp + soff + 3),
              * (mac_hdrp + soff + 4),
              * (mac_hdrp + soff + 5));
    TRACE_INFO("(RCT) sending reply to %u.%u.%u.%u:%d [0x%02x-0x%02x-0x%02x-0x%02x-0x%02x-0x%02x]",
               IP_GET_DST_ADDR (ip_hdrp, 0),
               IP_GET_DST_ADDR (ip_hdrp, 1),
               IP_GET_DST_ADDR (ip_hdrp, 2),
               IP_GET_DST_ADDR (ip_hdrp, 3),
               UDP_GET_DST_PORT (udp_hdrp),
               * (mac_hdrp + doff + 0),
               * (mac_hdrp + doff + 1),
               * (mac_hdrp + doff + 2),
               * (mac_hdrp + doff + 3),
               * (mac_hdrp + doff + 4),
               * (mac_hdrp + doff + 5));
    TRACE_INFO("                  from %u.%u.%u.%u:%d [0x%02x-0x%02x-0x%02x-0x%02x-0x%02x-0x%02x]",
               IP_GET_SRC_ADDR (ip_hdrp, 0),
               IP_GET_SRC_ADDR (ip_hdrp, 1),
               IP_GET_SRC_ADDR (ip_hdrp, 2),
               IP_GET_SRC_ADDR (ip_hdrp, 3),
               UDP_GET_SRC_PORT (udp_hdrp),
               * (mac_hdrp + soff + 0),
               * (mac_hdrp + soff + 1),
               * (mac_hdrp + soff + 2),
               * (mac_hdrp + soff + 3),
               * (mac_hdrp + soff + 4),
               * (mac_hdrp + soff + 5));
#endif

    if (rct_hdrp != NULL)
    {
        NdisFreeMemory(rct_hdrp, pPacketInfo->IP.UDP.Payload.Length, 0);
    }

    return NDIS_STATUS_SUCCESS;

 quit:

    if (rct_hdrp != NULL)
    {
        NdisFreeMemory(rct_hdrp, pPacketInfo->IP.UDP.Payload.Length, 0);
    }

    return NDIS_STATUS_FAILURE;

} /* end Main_ctrl_recv */

INT Main_adapter_alloc (PNDIS_STRING device_name)
{
    NDIS_STATUS status;
    INT         i;

    /* Called from Prot_bind at PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_VERB(("Main_adapter_alloc: Called for %ls", device_name->Buffer));

    NdisAcquireSpinLock(&univ_bind_lock);

    /* If we have already allocated the maximum allowed, return failure. */
    if (univ_adapters_count == CVY_MAX_ADAPTERS) {
        NdisReleaseSpinLock(&univ_bind_lock);
        TRACE_CRIT("%!FUNC! max adapters=%u allocated already", univ_adapters_count);
        return MAIN_ADAPTER_NOT_FOUND;
    }

    NdisReleaseSpinLock(&univ_bind_lock);

    /* Loop through all adapter structures in the global array, looking for
       one that is free; mark it as used and increment the adapter count. */
    for (i = 0 ; i < CVY_MAX_ADAPTERS; i++) {
        NdisAcquireSpinLock(&univ_bind_lock);

        /* If this one is unused, grab it. */
        if (univ_adapters[i].used == FALSE) {
            /* Mark it as in-use. */
            univ_adapters[i].used = TRUE;

            /* Increment the global count of adapters in-use. */
            univ_adapters_count++;

            NdisReleaseSpinLock(&univ_bind_lock);

            break;
        }

        NdisReleaseSpinLock(&univ_bind_lock);
    }

    /* If we looped through the entire array and found jack, return failure. */
    if (i >= CVY_MAX_ADAPTERS) return MAIN_ADAPTER_NOT_FOUND;

    NdisAcquireSpinLock(&univ_bind_lock);

    /* Reset the binding flags, which will be filled in by the binding code. */
    univ_adapters[i].bound = FALSE;
    univ_adapters[i].inited = FALSE;
    univ_adapters[i].announced = FALSE;

#if defined (NLB_TCP_NOTIFICATION)
    /* Invalidate the IP interface index and idle the operation in progress. */
    univ_adapters[i].if_index = 0;
    univ_adapters[i].if_index_operation = IF_INDEX_OPERATION_NONE;
#endif

    NdisReleaseSpinLock(&univ_bind_lock);

    /* Allocate room for the device name. */
    status = NdisAllocateMemoryWithTag(&univ_adapters[i].device_name, device_name->MaximumLength, UNIV_POOL_TAG);

    /* If this allocation failed, call Main_adapter_put to release the adapter structure. */
    if (status != NDIS_STATUS_SUCCESS) {
        UNIV_PRINT_CRIT(("Main_adapter_alloc: Error allocating memory %d %x", device_name->MaximumLength * sizeof(WCHAR), status));
        TRACE_CRIT("%!FUNC! Error allocating memory %d 0x%x", device_name->MaximumLength * sizeof(WCHAR), status);
        __LOG_MSG2(MSG_ERROR_MEMORY, MSG_NONE, device_name->MaximumLength * sizeof(WCHAR), status);
        //
        // 22 July 2002 - chrisdar
        // Added this event because it is needed for reporting consistency with other memory allocation failures in this code path (see below).
        // Left it commented out so as not to cause a code behavior change per SHouse request.
        //
        // __LOG_MSG(MSG_ERROR_BIND_FAIL, MSG_NONE);

        Main_adapter_put(&univ_adapters[i]);

        return MAIN_ADAPTER_NOT_FOUND;
    }

    /* Allocate the context strucutre. */
    status = NdisAllocateMemoryWithTag(&univ_adapters[i].ctxtp, sizeof(MAIN_CTXT), UNIV_POOL_TAG);

    /* If this allocation failed, call Main_adapter_put to release the adapter structure. */
    if (status != NDIS_STATUS_SUCCESS) {
        UNIV_PRINT_CRIT(("Main_adapter_alloc: Error allocating memory %d %x", sizeof(MAIN_CTXT), status));
        TRACE_CRIT("%!FUNC! Error allocating memory %d 0x%x", sizeof(MAIN_CTXT), status);
        __LOG_MSG2(MSG_ERROR_MEMORY, MSG_NONE, sizeof(MAIN_CTXT), status);
        __LOG_MSG(MSG_ERROR_BIND_FAIL, MSG_NONE);

        Main_adapter_put(&univ_adapters[i]);

        return MAIN_ADAPTER_NOT_FOUND;
    }

    return i;
}

INT Main_adapter_get (PWSTR device_name)
{
    INT i;

    if (device_name == NULL)
    {
        TRACE_CRIT("%!FUNC! no device name provided");
        return MAIN_ADAPTER_NOT_FOUND;
    }

    TRACE_INFO("%!FUNC! device_name=%ls", device_name);

    /* Loop through all adapters in use, looking for the device specified.  If we find it,
       return the index of that adapter in the global array; otherwise, return NOT_FOUND. */
    for (i = 0 ; i < CVY_MAX_ADAPTERS; i++) {
        if (univ_adapters[i].used && univ_adapters[i].bound && univ_adapters[i].inited && univ_adapters[i].device_name_len) {
            /* This function compares two unicode strings, insensitive to case. */
            if (Univ_equal_unicode_string(univ_adapters[i].device_name, device_name, wcslen(univ_adapters[i].device_name)))
            {
                return i;
            }
        }
    }

    return MAIN_ADAPTER_NOT_FOUND;
}

INT Main_adapter_put (PMAIN_ADAPTER adapterp)
{
    INT adapter_id = -1;
    INT i;

    UNIV_ASSERT(adapterp -> code == MAIN_ADAPTER_CODE);

    /* Loop through all adapter structures, looking for the specified pointer. 
       If we find that the address specified matches the address of one of the
       global adapter structures (it should), save the adapter index in the array. */
    for (i = 0 ; i < CVY_MAX_ADAPTERS; i++) {
        if (adapterp == (univ_adapters + i)) {
            adapter_id = i;

            UNIV_PRINT_VERB(("Main_adapter_put: For adapter id 0x%x\n", adapter_id));
            TRACE_VERB("%!FUNC! For adapter id 0x%x\n", adapter_id);

            break;
        }
    }

    UNIV_ASSERT(adapter_id != -1);

    if (!adapterp->used || adapter_id == -1) return adapter_id;

    UNIV_ASSERT(univ_adapters_count > 0);

    NdisAcquireSpinLock(&univ_bind_lock);

    /* Reset the binding state flags. */
    univ_adapters[adapter_id].bound           = FALSE;
    univ_adapters[adapter_id].inited          = FALSE;
    univ_adapters[adapter_id].announced       = FALSE;
    univ_adapters[adapter_id].used            = FALSE;

#if defined (NLB_TCP_NOTIFICATION)
    /* Invalidate the IP interface index and idle the operation in progress. */
    univ_adapters[adapter_id].if_index = 0;
    univ_adapters[adapter_id].if_index_operation = IF_INDEX_OPERATION_NONE;
#endif

    /* If the context pointer has been allocated, free that memory - this may not
       be non-NULL, i.e., in the case that allocation failed, Main_adapter_alloc()
       will call this function to clean up, but ctxtp will be (can be) NULL. */
    if (univ_adapters[adapter_id].ctxtp != NULL)
        NdisFreeMemory(univ_adapters[adapter_id].ctxtp, sizeof (MAIN_CTXT), 0);

    /* NULLL the context pointer out. */
    univ_adapters[adapter_id].ctxtp           = NULL;

    /* If the device name pointer has been allocated, free that memory - this may not
       be non-NULL, i.e., in the case that allocation failed, Main_adapter_alloc()
       will call this function to clean up, but this pointer will be (can be) NULL. */
    if (univ_adapters[adapter_id].device_name != NULL)
        NdisFreeMemory(univ_adapters[adapter_id].device_name, univ_adapters[adapter_id].device_name_len, 0);
    
    /* Reset the device name pointer and the length counter. */
    univ_adapters[adapter_id].device_name_len = 0;
    univ_adapters[adapter_id].device_name     = NULL;

    /* Decrement the number of "outstanding" adapters - i.e. adapter structures in use. */
    univ_adapters_count--;

    NdisReleaseSpinLock(&univ_bind_lock);

    return adapter_id;
}

INT Main_adapter_selfbind (PWSTR device_name) {
    INT i;

    /* Called from Prot_bind at PASSIVE_LEVEL - %ls is OK. */
    UNIV_PRINT_VERB(("Main_adapter_selfbind: %ls", device_name));

    if (device_name == NULL)
    {
        TRACE_CRIT("%!FUNC! no device name provided");
        return MAIN_ADAPTER_NOT_FOUND;
    }

    TRACE_INFO("%!FUNC! device_name=%ls", device_name);

    /* Loop through all adapter structures in use, looking for one already
       bound to the device specified.  If we find it, return the index of
       that adapter in the array; if not, return NOT_FOUND. */
    for (i = 0 ; i < CVY_MAX_ADAPTERS; i++) {
        if (univ_adapters[i].used && univ_adapters[i].bound && univ_adapters[i].inited) {

            /* Called from Prot_bind at PASSIVE_LEVEL - %ls is OK. */
            UNIV_PRINT_VERB(("Main_adapter_selfbind: Comparing %ls %ls", univ_adapters[i].ctxtp->virtual_nic_name, device_name));

            /* This function compares two unicode strings, insensitive to case. */
            if (Univ_equal_unicode_string(univ_adapters[i].ctxtp->virtual_nic_name, device_name, wcslen(univ_adapters[i].ctxtp->virtual_nic_name)))
            {
                return i;
            }
        }
    }

    return MAIN_ADAPTER_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\wlbs\driver\main.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    main.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - packet handing

Author:

    kyrilf

--*/


#ifndef _Main_h_
#define _Main_h_

#define NDIS_MINIPORT_DRIVER    1
#define NDIS50                  1
#define NDIS51_MINIPORT       