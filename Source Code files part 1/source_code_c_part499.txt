     *pszReason = "Block trailer does not point back to the block header";
            goto err;
        }
    }

    if (pdbgmem->cbExtra) {
        ULONG UNALIGNED * pul = (ULONG UNALIGNED *)(pblk->pblktail + 1);
        int n = pdbgmem->cbExtra;
        for (; --n >= 0; ++pul)
            if (*pul != 0xAEAEAEAE) {
                *pszReason = "Block trailer spiddle-zone has been overwritten";
                goto err;
            }
    }

    return(TRUE);

err:
    return(FALSE);
}

/* DBGMEM_ValidatePv -------------------------------------------------------- */

BOOL DBGMEM_ValidatePv(PDBGMEM pdbgmem, void * pv, char * pszFunc)
{
    char *  pszReason;

    if (DBGMEM_DidAlloc(pdbgmem, pv) == 0) {
        TrapSz3("DBGMEM_ValidatePv(subsys=%s,pv=%08lX) [via %s]\nDetected a memory block which was not allocated by this allocator",
            pdbgmem->szSubsys, pv, pszFunc);
        return(FALSE);
    }

    if (DBGMEM_ValidatePblk(pdbgmem,PvToPblk(pv),&pszReason))
        return(TRUE);

    TrapSz4("DBGMEM_ValidatePv(%s,pv=%08lX) [via %s]\n%s",
        pdbgmem->szSubsys, pv, pszFunc, pszReason);

    return(FALSE);
}

/* DBGMEM_ReportLeak -------------------------------------------------------- */

#if defined(_WIN32) && defined(_X86_)
void EXPORTDBG __cdecl DBGMEM_LeakHook(FARPROC pfn)
{
    /* Dummy function so that you can set a breakpoint with command   */
    /* "ln ecx;g", in order to get the debugger to print out the name */
    /* of the function which allocated the leaked memory block        */
}
#endif

void DBGMEM_ReportLeak(PDBGMEM pdbgmem, PBLK pblk)
{
    int i = 0;

    DebugTrace("%s Memory Leak: @%08lX, allocation #%ld, size %ld\n",
        pdbgmem->szSubsys, PblkToPv(pblk), pblk->ulAllocNum, PblkClientSize(pblk));

    #if defined(_WIN32) && defined(_X86_)
    for (i = 0; i < NCALLERS && pblk->pfnCallers[i] != 0; i++) {
        DebugTrace("[%d] %08lX ", i, pblk->pfnCallers[i]);
        DBGMEM_LeakHook(pblk->pfnCallers[i]);
    }
    DebugTrace("\n");
    #endif
}

/* DBGMEM_NoLeakDetectFn ---------------------------------------------------- */

void EXPORTDBG __cdecl DBGMEM_NoLeakDetectFn(void * pmalloc, void *pv)
{
    PDBGMEM pdbgmem = (PDBGMEM)pmalloc;

    DBGMEM_EnterCriticalSection(pdbgmem);

    if (pv == 0)
        pdbgmem->fUnleakable = TRUE;
    else if (DBGMEM_ValidatePv(pdbgmem, pv, "DBGMEM_NoLeakDetectFn"))
        PvToPblk(pv)->fUnleakable = TRUE;

    DBGMEM_LeaveCriticalSection(pdbgmem);
}

/* DBGMEM_SetFailureAtFn ---------------------------------------------------- */

void EXPORTDBG __cdecl DBGMEM_SetFailureAtFn(void * pmalloc, ULONG ulFailureAt)
{
    PDBGMEM pdbgmem = (PDBGMEM)pmalloc;

    DBGMEM_EnterCriticalSection(pdbgmem);

    pdbgmem->ulFailureAt = ulFailureAt;

    DBGMEM_LeaveCriticalSection(pdbgmem);
}

/* DBGMEM_CheckMemFn -------------------------------------------------------- */

void EXPORTDBG __cdecl DBGMEM_CheckMemFn(void * pmalloc, BOOL fReportOrphans)
{
    PDBGMEM pdbgmem = (PDBGMEM)pmalloc;
    PBLK    pblk;
    int     cLeaks = 0;

    DBGMEM_EnterCriticalSection(pdbgmem);

    for (pblk = pdbgmem->pblkHead; pblk; pblk = pblk->pblkNext) {
        if (!DBGMEM_ValidatePv(pdbgmem, PblkToPv(pblk), "DBGMEM_CheckMemFn"))
            break;

        if (fReportOrphans && !pdbgmem->fUnleakable && !pblk->fUnleakable) {
            DBGMEM_ReportLeak(pdbgmem, pblk);
            cLeaks += 1;
        }
    }

    #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
    if (fAssertLeaks == -1)
    {
        fAssertLeaks = GetPrivateProfileIntA(szSectionDebug, szKeyAssertLeaks,
            0, szDebugIni);
    }
    #endif

    if (cLeaks > 0)
    {
        #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
        if (fAssertLeaks)
        {
            TrapSz3("DBGMEM detected %d memory leak%s in subsystem %s",
                cLeaks, cLeaks == 1 ? "" : "s", pdbgmem->szSubsys);
        }
        else
        {
            TraceSz3("DBGMEM detected %d memory leak%s in subsystem %s",
                cLeaks, cLeaks == 1 ? "" : "s", pdbgmem->szSubsys);
        }
        #else
        TraceSz3("DBGMEM detected %d memory leak%s in subsystem %s",
            cLeaks, cLeaks == 1 ? "" : "s", pdbgmem->szSubsys);
        #endif
    }

    DBGMEM_LeaveCriticalSection(pdbgmem);
}

/* vtblDBGMEM --------------------------------------------------------------- */

DBGMEM_Vtbl BASED_DEBUG vtblDBGMEM =
{
    VTABLE_FILL
    DBGMEM_QueryInterface,
    DBGMEM_AddRef,
    DBGMEM_Release,
    DBGMEM_Alloc,
    DBGMEM_Realloc,
    DBGMEM_Free,
    DBGMEM_GetSize,
    DBGMEM_DidAlloc,
    DBGMEM_HeapMinimize
};

/* DBGMEM_EncapsulateFn ----------------------------------------------------- */

void * EXPORTDBG __cdecl DBGMEM_EncapsulateFn(void * pvmalloc, char *pszSubsys, BOOL fCheckOften)
{
    LPMALLOC    pmalloc = (LPMALLOC)pvmalloc;
    PDBGMEM     pdbgmem;
    LPMALLOC    pmallocBase;
    ULONG       cbVirtual = 0;
    BOOL        fFillRandom = FALSE;
    HRESULT     hr;

    hr = pmalloc->lpVtbl->QueryInterface(pmalloc, &DBGMEM_IID_IBaseMalloc, &pmallocBase);
    if (hr) {
        pmallocBase = pmalloc;
        pmallocBase->lpVtbl->AddRef(pmallocBase);
    }

    pdbgmem = (PDBGMEM)pmallocBase->lpVtbl->Alloc(pmallocBase, sizeof(DBGMEM));

    if (pdbgmem == 0) {
        TrapSz("DBGMEM: Failed trying to allocate memory for the first time!\n");
        return(pmallocBase);
    }

    #if defined(WIN16) || (defined(_WIN32) && defined(_X86_))
    cbVirtual = GetPrivateProfileIntA(szSectionDebug, szKeyUseVirtual, 0,
        szDebugIni);

    if (cbVirtual != 0 && cbVirtual != 1 && cbVirtual != 4)
        cbVirtual = 1;

    if (cbVirtual)
        DebugTrace("DBGMEM: Subsystem '%s' using virtual memory allocator -"
            " align %d.\n", pszSubsys, cbVirtual);

    if (!fCheckOften)
        fCheckOften = GetPrivateProfileIntA(szSectionDebug, szKeyCheckOften, 0,
            szDebugIni);

    fFillRandom = GetPrivateProfileIntA(szSectionDebug, szKeyFillRandom, 0,
        szDebugIni);

    #endif

    memset(pdbgmem, 0, sizeof(DBGMEM));

    pdbgmem->lpVtbl         = &vtblDBGMEM;
    pdbgmem->cRef           = 1;
    pdbgmem->pmalloc        = pmallocBase;
    pdbgmem->fCheckOften    = fCheckOften;
    pdbgmem->fUnleakable    = FALSE;
    pdbgmem->cbVirtual      = cbVirtual;
    pdbgmem->fFillRandom    = fFillRandom;
    pdbgmem->cbExtra        = 0;
    pdbgmem->ulAllocAt      = 1L;
    pdbgmem->ulFailureAt    = 0L;

    if (pdbgmem->cbVirtual)
        pdbgmem->cbTail     = 0;
    else
        pdbgmem->cbTail     = sizeof(BLKTAIL) + pdbgmem->cbExtra * sizeof(ULONG);

    lstrcpyn(pdbgmem->szSubsys, pszSubsys, sizeof(pdbgmem->szSubsys));

    #if defined(_WIN32) && defined(_X86_)
    InitializeCriticalSection(&pdbgmem->cs);
    #endif

    return(pdbgmem);
}

/* DBGMEM_ShutdownFn -------------------------------------------------------- */

void EXPORTDBG __cdecl DBGMEM_ShutdownFn(void *pvmalloc)
{
    LPMALLOC    pmalloc = (LPMALLOC)pvmalloc;
    PDBGMEM     pdbgmem = (PDBGMEM)pvmalloc;
    LPMALLOC    pmallocBase;
    HRESULT     hr;

    hr = pmalloc->lpVtbl->QueryInterface(pmalloc, &DBGMEM_IID_IBaseMalloc, &pmallocBase);
    if (hr == 0) {
        pmallocBase->lpVtbl->Release(pmallocBase);
        if (pdbgmem->cRef != 1) {
            TrapSz2("DBGMEM_Shutdown: Expected a cRef of 1; instead have %ld for %s",
                pdbgmem->cRef, pdbgmem->szSubsys);
            pdbgmem->cRef = 1;
        }
    }

    pmalloc->lpVtbl->Release(pmalloc);
}

/* -------------------------------------------------------------------------- */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\sample.cli\client.h ===
/*
 -  C L I E N T . H
 -
 *  Purpose:
 *      Header file for the sample mail client based on Simple MAPI.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */


#include "smapi.h"

/* Menu Item IDs */

#define IDM_LOGON       100
#define IDM_LOGOFF      101
#define IDM_EXIT        102
#define IDM_COMPOSE     103
#define IDM_READ        104
#define IDM_SEND        105
#define IDM_ADDRBOOK    106
#define IDM_DETAILS     107
#define IDM_ABOUT       108

/* Resource IDs */

#define ICON_NOMAIL     200
#define ICON_MAIL       201
#define IDB_ENVELOPE    300


/* Address Book Control IDs */

#define IDT_ADDRESS     101
#define IDC_ADDRESS     102
#define IDT_LIST        103
#define IDC_LIST        104
#define IDC_ADD         105
#define IDC_REMOVE      106


/* Compose Note Control IDs */

#define IDC_SEND        101
#define IDC_RESOLVE     102
#define IDC_ATTACH      103
#define IDC_OPTIONS     104
#define IDC_ADDRBOOK    105
#define IDT_TO          106
#define IDC_TO          107
#define IDT_CC          108
#define IDC_CC          109
#define IDT_SUBJECT     110
#define IDC_SUBJECT     111
#define IDC_NOTE        112
#define IDC_CATTACHMENT 113
#define IDT_CATTACHMENT 114
#define IDC_LINE1       -1
#define IDC_LINE2       -1


/* InBox Control IDs */

#define IDT_MSG         101
#define IDC_MSG         102
#define IDC_NEW         103
#define IDC_READ        104
#define IDC_DELETE      105
#define IDC_CLOSE       106


/* ReadNote Control IDs */

#define IDC_SAVECHANGES 101
#define IDC_SAVEATTACH  102
#define IDC_REPLY       103
#define IDC_REPLYALL    104
#define IDC_FORWARD     105
#define IDT_RFROM       106
#define IDT_RDATE       107
#define IDT_RTO         108
#define IDT_RCC         109
#define IDT_RSUBJECT    110
#define IDC_RFROM       111
#define IDC_RDATE       112
#define IDC_RTO         113
#define IDC_RCC         114
#define IDC_RSUBJECT    115
#define IDC_READNOTE    116
#define IDT_ATTACHMENT  117
#define IDC_ATTACHMENT  118


/* Options Control IDs */

#define IDC_RETURN      101


/* Details Control IDs */

#define IDT_NAME        100
#define IDC_NAME        101
#define IDT_TYPE        102
#define IDC_TYPE        103
#define IDT_ADDR        104
#define IDC_ADDR        105

/* About Box Control IDs */

#define IDC_VERSION     101


/* String Table IDs */

#define MAPI_ERROR_MAX          30

#define IDS_LOGONFAIL           (MAPI_ERROR_MAX + 1)
#define IDS_ADDRBOOKFAIL        (MAPI_ERROR_MAX + 2)
#define IDS_RESOLVEFAIL         (MAPI_ERROR_MAX + 3)
#define IDS_UNRESOLVEDNAMES     (MAPI_ERROR_MAX + 4)
#define IDS_SENDERROR           (MAPI_ERROR_MAX + 5)
#define IDS_DETAILS_TOO_MANY    (MAPI_ERROR_MAX + 6)
#define IDS_DETAILSFAIL         (MAPI_ERROR_MAX + 7)
#define IDS_NORECIPS            (MAPI_ERROR_MAX + 8)
#define IDS_SAVEATTACHERROR     (MAPI_ERROR_MAX + 9)
#define IDS_READFAIL            (MAPI_ERROR_MAX + 10)
#define IDS_DIALOGACTIVE        (MAPI_ERROR_MAX + 11)

#define IDS_FILTER              (MAPI_ERROR_MAX + 50)

/* Manifest Constants */

#define ADDR_MAX            128
#define MAXUSERS            10
#define TO_EDIT_MAX         512
#define CC_EDIT_MAX         512
#define SUBJECT_EDIT_MAX    128
#define NOTE_LINE_MAX       1024
#define FILE_ATTACH_MAX     32

/* Message Box styles */

#define MBS_ERROR           (MB_ICONSTOP | MB_OK)
#define MBS_INFO            (MB_ICONINFORMATION | MB_OK)
#define MBS_OOPS            (MB_ICONEXCLAMATION | MB_OK)

/* Structure Definitions */

typedef struct _msgid *LPMSGID;

typedef struct _msgid
{
    LPSTR       lpszMsgID;
    BOOL        fHasAttach;
    BOOL        fUnRead;
    LPSTR       lpszFrom;
    LPSTR       lpszSubject;
    LPSTR       lpszDateRec;
    LPMSGID     lpPrev;
    LPMSGID     lpNext;
} MSGID;



/* Function Prototypes */

int  PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
void DeinitApplication(void);
long FAR PASCAL MainWndProc(HWND, UINT, UINT, LPARAM);
BOOL FAR PASCAL AboutDlgProc(HWND, UINT, UINT, LONG);
BOOL FAR PASCAL ComposeDlgProc(HWND, UINT, UINT, LONG);
BOOL FAR PASCAL InBoxDlgProc(HWND, UINT, UINT, LONG);
BOOL FAR PASCAL ReadMailDlgProc(HWND, UINT, UINT, LONG);
BOOL FAR PASCAL OptionsDlgProc(HWND, UINT, UINT, LONG);
BOOL FAR PASCAL DetailsDlgProc(HWND, UINT, UINT, LONG);
void    MakeMessageBox(HWND, ULONG, UINT, UINT);
ULONG   ResolveFriendlyNames(HWND, LPSTR, ULONG, ULONG *, lpMapiRecipDesc *);
ULONG   CopyRecipient(lpMapiRecipDesc, lpMapiRecipDesc, lpMapiRecipDesc);
ULONG   GetNextFile(HWND, ULONG, ULONG *, lpMapiFileDesc *);
ULONG   CopyAttachment(lpMapiFileDesc, lpMapiFileDesc, lpMapiFileDesc);
BOOL    FNameInList(LPSTR, ULONG, lpMapiRecipDesc);
LPMSGID MakeMsgNode(lpMapiMessage, LPSTR);
LPMSGID FindNode(LPMSGID, LPSTR);
void    InsertMsgNode(LPMSGID, LPMSGID *);
void    DeleteMsgNode(LPMSGID, LPMSGID *);
void    FreeMsgList(LPMSGID);
void    MakeDisplayNameStr(LPSTR, ULONG, ULONG, lpMapiRecipDesc);
ULONG   SaveMsgChanges(HWND, lpMapiMessage, LPSTR);
ULONG   MakeNewMessage(lpMapiMessage, UINT);
void    LogSendMail(ULONG);
void    SaveFileAttachments(HWND, lpMapiFileDesc);
void    ToggleMenuState(HWND, BOOL);   
BOOL    fSMAPIInstalled(void);
void SecureMenu(HWND hWnd, BOOL fBeforeLogon);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\sample.cli\client.c ===
/*
 -  C L I E N T . C
 -
 *  Purpose:
 *      Sample mail client for the MAPI 1.0 PDK.
 *              Exclusively uses the Simple MAPI interface.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <commdlg.h>
#include <mapiwin.h>
#include <mapidbg.h>
#include "client.h"
#include "bitmap.h"
#include "pvalloc.h"

HANDLE hInst;
HINSTANCE hlibMAPI = 0;

LPMAPILOGON lpfnMAPILogon = NULL;
LPMAPILOGOFF lpfnMAPILogoff = NULL;
LPMAPISENDMAIL lpfnMAPISendMail = NULL;
LPMAPISENDDOCUMENTS lpfnMAPISendDocuments = NULL;
LPMAPIFINDNEXT lpfnMAPIFindNext = NULL;
LPMAPIREADMAIL lpfnMAPIReadMail = NULL;
LPMAPISAVEMAIL lpfnMAPISaveMail = NULL;
LPMAPIDELETEMAIL lpfnMAPIDeleteMail = NULL;
LPMAPIFREEBUFFER lpfnMAPIFreeBuffer = NULL;
LPMAPIADDRESS lpfnMAPIAddress = NULL;
LPMAPIDETAILS lpfnMAPIDetails = NULL;
LPMAPIRESOLVENAME lpfnMAPIResolveName = NULL;

/* Static Data */

static BOOL fDialogIsActive = FALSE;
static DWORD cUsers = 0;
static ULONG flSendMsgFlags = 0;
static LHANDLE lhSession = 0L;
static HBITMAP hReadBmp = 0;
static HBITMAP hReadABmp = 0;
static HBITMAP hUnReadBmp = 0;
static HBITMAP hUnReadABmp = 0;
static HCURSOR hWaitCur;
static LPMSGID lpReadMsgNode;
static lpMapiMessage lpmsg = NULL;

#ifdef _WIN32
#define szMAPIDLL       "MAPI32.DLL"
#else
#define szMAPIDLL       "MAPI.DLL"
#endif

int WINAPI
WinMain (HINSTANCE hInstance, HINSTANCE hPrevInst, LPSTR lpszCmd, int nCmdShow)
{
    MSG msg;

    if (!hPrevInst)
    if (!InitApplication (hInstance))
        return (FALSE);

    if (!InitInstance (hInstance, nCmdShow))
    return (FALSE);

    while (GetMessage (&msg, 0, 0, 0))
    {
    TranslateMessage (&msg);
    DispatchMessage (&msg);
    }

    DeinitApplication ();

    return (msg.wParam);
}

/*
 -  InitApplication
 -
 *  Purpose:
 *      Initialize the application.
 *
 *  Parameters:
 *      hInstance   - Instance handle
 *
 *  Returns:
 *      True/False
 *
 */

BOOL
InitApplication (HANDLE hInstance)
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon (hInstance, "NoMail");
    wc.hCursor = LoadCursor (0, IDC_ARROW);
    wc.hbrBackground = GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName = "MailMenu";
    wc.lpszClassName = "Client";

    return (RegisterClass (&wc));
}

/*
 -  InitInstance
 -
 *  Purpose:
 *      Initialize this instance.
 *
 *  Parameters:
 *      hInstance   - Instance handle
 *      nCmdShow    - Do we show the window?
 *
 *  Returns:
 *      True/False
 *
 */

BOOL
InitInstance (HANDLE hInstance, int nCmdShow)
{
    HWND hWnd;
    BOOL fInit;
    ULONG ulResult;

    hInst = hInstance;

    hWnd = CreateWindow ("Client", "MAPI Sample Mail Client",
        WS_OVERLAPPEDWINDOW, 5, 5, 300, 75, 0, 0, hInst, NULL);

    if (!hWnd)
    return (FALSE);

    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);

    hWaitCur = LoadCursor(0, IDC_WAIT);

    if (fInit = InitSimpleMAPI ())
    {
    
        /* MAPILogon might yield control to Windows. So to prevent the user
        from clicking "logon" while we are in the process of loggin on we
        have to disable it*/
        SecureMenu(hWnd, TRUE);
        
        if ((ulResult = MAPILogon ((ULONG) hWnd, NULL, NULL,
            MAPI_LOGON_UI | MAPI_NEW_SESSION,
            0, &lhSession)) == SUCCESS_SUCCESS)
        {
            ToggleMenuState (hWnd, TRUE);
        }
        else
        {
            SecureMenu(hWnd, FALSE);
            lhSession = 0;
            MakeMessageBox (hWnd, ulResult, IDS_LOGONFAIL, MBS_ERROR);
        }
    }

    return (fInit);
}

/*
 -  InitSimpleMAPI
 -
 *  Purpose:
 *      Loads the DLL containing the simple MAPI functions and sets
 *      up a pointer to each. Wrappers for the  function pointers
 *      are declared in SMAPI.H.
 *
 *  Returns:
 *      TRUE if sucessful, else FALSE
 *
 *  Side effects:
 *      Loads a DLL and sets up function pointers
 */
BOOL
InitSimpleMAPI (void)
{
    UINT fuError;

    /*
     *Check if MAPI is installed on the system
     */
    if(!fSMAPIInstalled())
        return FALSE;

    fuError = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hlibMAPI = LoadLibrary(szMAPIDLL);
    SetErrorMode(fuError);

#ifdef _WIN32
    if (!hlibMAPI)
#else
    if (hlibMAPI < 32)
#endif
    return (FALSE);

    if (!(lpfnMAPILogon = (LPMAPILOGON) GetProcAddress (hlibMAPI, "MAPILogon")))
    return (FALSE);
    if (!(lpfnMAPILogoff = (LPMAPILOGOFF) GetProcAddress (hlibMAPI, "MAPILogoff")))
    return (FALSE);
    if (!(lpfnMAPISendMail = (LPMAPISENDMAIL) GetProcAddress (hlibMAPI, "MAPISendMail")))
    return (FALSE);
    if (!(lpfnMAPISendDocuments = (LPMAPISENDDOCUMENTS) GetProcAddress (hlibMAPI, "MAPISendDocuments")))
    return (FALSE);
    if (!(lpfnMAPIFindNext = (LPMAPIFINDNEXT) GetProcAddress (hlibMAPI, "MAPIFindNext")))
    return (FALSE);
    if (!(lpfnMAPIReadMail = (LPMAPIREADMAIL) GetProcAddress (hlibMAPI, "MAPIReadMail")))
    return (FALSE);
    if (!(lpfnMAPISaveMail = (LPMAPISAVEMAIL) GetProcAddress (hlibMAPI, "MAPISaveMail")))
    return (FALSE);
    if (!(lpfnMAPIDeleteMail = (LPMAPIDELETEMAIL) GetProcAddress (hlibMAPI, "MAPIDeleteMail")))
    return (FALSE);
    if (!(lpfnMAPIFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress (hlibMAPI, "MAPIFreeBuffer")))
    return (FALSE);
    if (!(lpfnMAPIAddress = (LPMAPIADDRESS) GetProcAddress (hlibMAPI, "MAPIAddress")))
    return (FALSE);
    if (!(lpfnMAPIDetails = (LPMAPIDETAILS) GetProcAddress (hlibMAPI, "MAPIDetails")))
    return (FALSE);
    if (!(lpfnMAPIResolveName = (LPMAPIRESOLVENAME) GetProcAddress (hlibMAPI, "MAPIResolveName")))
    return (FALSE);

    return (TRUE);
}

/*
 -  fSMAPIInstalled
 -
 *  Purpose:
 *      Checks the appropriate win.ini/registry value to see if Simple MAPI is
 *      installed in the system. 
 *  
 *  Returns:
 *      TRUE if Simple MAPI is installed, else FALSE
 *
 */
BOOL
fSMAPIInstalled(void)
{
#ifdef _WIN32
    /* on win32, if it's NT 3.51 or lower the value to check is 
        win.ini \ [Mail] \ MAPI, otherwise it's a registry value
        HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Messaging Subsystem\MAPI
    */
    
    OSVERSIONINFO osvinfo;
    LONG lr;
    HKEY hkWMS;
    
    #define MAPIVSize 8
    char szMAPIValue[MAPIVSize];
    DWORD dwType;
    DWORD cbMAPIValue = MAPIVSize;

    osvinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if(!GetVersionEx(&osvinfo))
        return FALSE;

    if( osvinfo.dwMajorVersion > 3 ||
        (osvinfo.dwMajorVersion == 3 && osvinfo.dwMinorVersion > 51))
    { //check the registry value
        lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        "SOFTWARE\\Microsoft\\Windows Messaging Subsystem",
                         0, KEY_READ, &hkWMS);
        if(ERROR_SUCCESS == lr)
        {
            lr = RegQueryValueEx(hkWMS, "MAPI", 0, &dwType, szMAPIValue, &cbMAPIValue);
            RegCloseKey(hkWMS);
            if(ERROR_SUCCESS == lr)
            {
                Assert(dwType == REG_SZ);
                if(lstrcmp(szMAPIValue, "1") == 0)
                    return TRUE;
            }
        }
        
        return FALSE;
    }

    /* fall through*/
#endif /*_WIN32*/
    
    /*check the win.ini value*/
    return GetProfileInt("Mail", "MAPI", 0);
    
}


void
DeinitApplication ()
{
    DeinitSimpleMAPI ();
}

void
DeinitSimpleMAPI ()
{
    if (hlibMAPI)
    {
    FreeLibrary (hlibMAPI);
    hlibMAPI = 0;
    }
}

/*
 -  MainWndProc
 -
 *  Purpose:
 *      Main Window Procedure for test program.
 *
 *  Parameters:
 *      hWnd
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *
 *
 */

LONG FAR PASCAL
MainWndProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    ULONG ulResult;

    switch (msg)
    {
    case WM_COMMAND:
    switch (LOWORD (wParam))
    {
    case IDM_LOGON:
        if (!lhSession)
        {
        /* MAPILogon might yield control to Windows. So to prevent the user
        from clicking "logon" while we are in the process of loggin on we
        have to disable it*/
        SecureMenu(hWnd, TRUE);

        if ((ulResult = MAPILogon ((ULONG) hWnd, NULL, NULL,
                MAPI_LOGON_UI | MAPI_NEW_SESSION,
                0, &lhSession)) == SUCCESS_SUCCESS)
        {
            ToggleMenuState (hWnd, TRUE);
        }
        else
        {
            SecureMenu(hWnd, FALSE);
            lhSession = 0;
            MakeMessageBox (hWnd, ulResult, IDS_LOGONFAIL, MBS_ERROR);
        }
        }
        break;

    case IDM_LOGOFF:
        if (lhSession)
        {
        MAPILogoff (lhSession, (ULONG) hWnd, 0, 0);
        ToggleMenuState (hWnd, FALSE);
        lhSession = 0;
        }
        break;

    case IDM_COMPOSE:
            fDialogIsActive = TRUE; 
        DialogBox (hInst, "ComposeNote", hWnd, ComposeDlgProc);
            fDialogIsActive = FALSE;        
        break;

    case IDM_READ:
            fDialogIsActive = TRUE; 
        DialogBox (hInst, "InBox", hWnd, InBoxDlgProc);
            fDialogIsActive = FALSE;        
        break;

    case IDM_SEND:
        if(lhSession)
            {
                MapiMessage msgSend;

                memset(&msgSend, 0, sizeof(MapiMessage));
                fDialogIsActive = TRUE; 
                MAPISendMail(lhSession, (ULONG)hWnd, &msgSend, MAPI_DIALOG, 0L);
                fDialogIsActive = FALSE;        
            }
        break;

    case IDM_ADDRBOOK:
        if (lhSession)
        {
                fDialogIsActive = TRUE; 
        if ((ulResult = MAPIAddress (lhSession, (ULONG) hWnd,
                NULL, 0, NULL, 0, NULL, 0, 0, NULL, NULL)))
        {
            if (ulResult != MAPI_E_USER_ABORT)
            MakeMessageBox (hWnd, ulResult, IDS_ADDRBOOKFAIL, MBS_ERROR);
        }
                fDialogIsActive = FALSE;        
        }
        break;

    case IDM_DETAILS:
        if (lhSession)
            {
                fDialogIsActive = TRUE; 
        DialogBox(hInst, "Details", hWnd, DetailsDlgProc);
                fDialogIsActive = FALSE;        
            }
        break;

    case IDM_ABOUT:
            fDialogIsActive = TRUE; 
        DialogBox (hInst, "AboutBox", hWnd, AboutDlgProc);
            fDialogIsActive = FALSE;        
        break;

    case IDM_EXIT:
        if (lhSession)
        MAPILogoff (lhSession, (ULONG) hWnd, 0, 0);

        PostQuitMessage (0);
        break;

    default:
        return (DefWindowProc (hWnd, msg, wParam, lParam));
    }
    break;

    case WM_QUERYENDSESSION:
    {       

        /*
         *      If we have a modal dialog open (all our dialogs are modal, so
         *      just see if we have a dialog open), veto the shutdown.
         */

        if (fDialogIsActive)
        {
            LPCSTR szTitle = "MAPI Sample Mail Client"; 
            char szText[256]; 

        LoadString (hInst, IDS_DIALOGACTIVE, szText, 255);

        #ifdef WIN16
            MessageBox((HWND)NULL, szText, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
        #else
            MessageBoxA(NULL, szText, szTitle, MB_OK | MB_ICONSTOP | MB_TASKMODAL | MB_SETFOREGROUND);
        #endif
        return FALSE;
        }

        else
        {
        return TRUE;
        }
    }

    case WM_ENDSESSION:

        if (wParam)
        {
        DestroyWindow (hWnd);
        }

    break;

    case WM_CLOSE:
    case WM_DESTROY:
    if (lhSession)
        MAPILogoff (lhSession, (ULONG) hWnd, 0, 0);

    PostQuitMessage (0);
    break;

    default:
    return (DefWindowProc (hWnd, msg, wParam, lParam));
    }
    return FALSE;
}

/*
 -  AboutDlgProc
 -
 *  Purpose:
 *      About box dialog procedure
 *
 *  Parameters:
 *      hDlg
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *      True/False
 *
 */

BOOL FAR PASCAL
AboutDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam)
{

#include <pdkver.h>

    char    rgchVersion[80];

    switch (msg)
    {
    case WM_INITDIALOG:
        wsprintf(rgchVersion, "Version %d.%d.%d (%s)", rmj, rmm, rup,
            szVerName && *szVerName ? szVerName : "BUDDY");
        SetDlgItemText(hDlg, IDC_VERSION, rgchVersion);
    return TRUE;

    case WM_COMMAND:
    if (wParam == IDOK || wParam == IDCANCEL)
    {
        EndDialog (hDlg, TRUE);
        return TRUE;
    }
    break;
    }
    return FALSE;
}

/*
 -  OptionsDlgProc
 -
 *  Purpose:
 *      Message Options dialog procedure
 *
 *  Parameters:
 *      hDlg
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *      True/False
 *
 */

BOOL FAR PASCAL
OptionsDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam)
{
    switch (msg)
    {
    case WM_INITDIALOG:
    CheckDlgButton (hDlg, IDC_RETURN,
        !!(flSendMsgFlags & MAPI_RECEIPT_REQUESTED));
    return TRUE;

    case WM_COMMAND:
    switch (LOWORD (wParam))
    {
    case IDOK:
        if (IsDlgButtonChecked (hDlg, IDC_RETURN))
        flSendMsgFlags |= MAPI_RECEIPT_REQUESTED;
        else
        flSendMsgFlags &= ~MAPI_RECEIPT_REQUESTED;

    case IDCANCEL:
        EndDialog (hDlg, TRUE);
        return TRUE;
    }
    break;
    }
    return FALSE;
}

/*
 -  DetailsDlgProc
 -
 *  Purpose:
 *      User Details dialog procedure
 *
 *  Parameters:
 *      hDlg
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *      True/False
 *
 */

BOOL FAR PASCAL
DetailsDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam)
{
    LPSTR lpszType = NULL;
    LPSTR lpszAddr = NULL;
    LPSTR lpszName;
    ULONG cRecips;
    ULONG ulResult;
    lpMapiRecipDesc lpRecip = NULL;

    switch (msg)
    {
    case WM_INITDIALOG:
    while(!lpRecip)
    {
        if ((ulResult = MAPIAddress (lhSession, (ULONG) hDlg,
            "Select One User", 1, "User:", 0, NULL, 0, 0,
            &cRecips, &lpRecip)))
        {
        if (ulResult != MAPI_E_USER_ABORT)
            MakeMessageBox (hDlg, ulResult, IDS_ADDRBOOKFAIL, MBS_ERROR);

        EndDialog (hDlg, TRUE);
        return TRUE;
        }

        if (cRecips == 0)
        {
        EndDialog (hDlg, TRUE);
        return TRUE;
        }

        if (cRecips > 1)
        {
        cRecips = 0;
        MAPIFreeBuffer (lpRecip);
        lpRecip = NULL;
        MakeMessageBox (hDlg, 0, IDS_DETAILS_TOO_MANY, MBS_OOPS);
        }
    }
    lpszName = lpRecip->lpszName;
    if(lpRecip->lpszAddress)
    {
        lpszType = strtok(lpRecip->lpszAddress, ":");
        lpszAddr = strtok(NULL, "\n");
    }

    SetDlgItemText(hDlg, IDC_NAME, lpszName);
    SetDlgItemText(hDlg, IDC_TYPE, (lpszType ? lpszType : "MSPEER"));
    SetDlgItemText(hDlg, IDC_ADDR, (lpszAddr ? lpszAddr : ""));

    MAPIFreeBuffer (lpRecip);
    return TRUE;

    case WM_COMMAND:
    if(LOWORD(wParam) == IDC_CLOSE || LOWORD(wParam) ==IDCANCEL)
    {
        EndDialog (hDlg, TRUE);
        return TRUE;
    }
    break;
    }
    return FALSE;
}

/*
 -  ComposeDlgProc
 -
 *  Purpose:
 *      Dialog procedure for the ComposeNote dialog.
 *
 *  Parameters:
 *      hDlg
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *      True/False
 *
 */

BOOL FAR PASCAL
ComposeDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam)
{
    char szUnResNames[TO_EDIT_MAX];
    char szDisplayNames[TO_EDIT_MAX];
   /* char szAttach[FILE_ATTACH_MAX];*/
    BOOL fUnResTo, fUnResCc;
    LONG cb, cLines;
    ULONG ulResult;
    HCURSOR hOldCur;
    static LPSTR lpszSubject;
    static LPSTR lpszNoteText;
    static ULONG cRecips;
    static ULONG cNewRecips;
    static ULONG cAttach;
    static lpMapiRecipDesc lpRecips;
    static lpMapiRecipDesc lpNewRecips;
    static lpMapiFileDesc lpAttach;
    ULONG idx;

    switch (msg)
    {
    case WM_INITDIALOG:
    if (lpmsg)
    {
        /* ComposeNote is being called to either forward or reply */
        /* to a message in the Inbox.  So, we'll initialize the   */
        /* ComposeNote form with data from the global MapiMessage */

        lpszSubject = lpmsg->lpszSubject;
        lpszNoteText = lpmsg->lpszNoteText;
        cRecips = lpmsg->nRecipCount;
        cAttach = lpmsg->nFileCount;
        lpRecips = lpmsg->lpRecips;
        lpAttach = lpmsg->lpFiles;

        if (cRecips)
        {
        MakeDisplayNameStr (szDisplayNames, MAPI_TO,
            cRecips, lpRecips);
        if (*szDisplayNames)
            SetDlgItemText (hDlg, IDC_TO, szDisplayNames);

        MakeDisplayNameStr (szDisplayNames, MAPI_CC,
            cRecips, lpRecips);
        if (*szDisplayNames)
            SetDlgItemText (hDlg, IDC_CC, szDisplayNames);
        }
        SetDlgItemText (hDlg, IDC_SUBJECT, lpmsg->lpszSubject);
        SetDlgItemText (hDlg, IDC_NOTE, lpmsg->lpszNoteText);
        if (!cAttach)
        {
            EnableWindow (GetDlgItem (hDlg, IDC_CATTACHMENT), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDT_CATTACHMENT), FALSE);
        }
        else
        {
            for(idx = 0; idx < cAttach; idx++)
            if (lpAttach[idx].lpszFileName)
                SendDlgItemMessage(hDlg, IDC_CATTACHMENT, LB_ADDSTRING, 0,
                (LPARAM)lpAttach[idx].lpszFileName);

           /*SendDlgItemMessage(hDlg, IDC_CATTACHMENT, LB_SETCURSEL, 0, 0L);*/
        }

        SendDlgItemMessage (hDlg, IDC_TO, EM_SETMODIFY, FALSE, 0);
        SendDlgItemMessage (hDlg, IDC_CC, EM_SETMODIFY, FALSE, 0);
        SendDlgItemMessage (hDlg, IDC_SUBJECT, EM_SETMODIFY, FALSE, 0);
        SendDlgItemMessage (hDlg, IDC_NOTE, EM_SETMODIFY, FALSE, 0);
        if(cRecips)
        SetFocus (GetDlgItem (hDlg, IDC_NOTE));
        else
        SetFocus (GetDlgItem (hDlg, IDC_TO));
    }
    else
    {
        lpmsg = (lpMapiMessage)PvAlloc(sizeof(MapiMessage));

        if (!lpmsg)
        goto cleanup;

            memset (lpmsg, 0, sizeof (MapiMessage));

        lpszSubject = NULL;
        lpszNoteText = NULL;
        cRecips = 0;
        cAttach = 0;
        lpRecips = NULL;
        lpNewRecips = NULL;
        lpAttach = NULL;

        lpmsg->flFlags = flSendMsgFlags;
        SetFocus (GetDlgItem (hDlg, IDC_TO));
    }
    return FALSE;

    case WM_COMMAND:
    switch (LOWORD (wParam))
    {
    case IDC_ATTACH:
        if (GetNextFile (hDlg, (ULONG) -1, &cAttach, &lpAttach) == SUCCESS_SUCCESS)
        {
                /* if the first attachment */
                if (cAttach == 1)
                {
                    EnableWindow (GetDlgItem (hDlg, IDC_CATTACHMENT), TRUE);
            EnableWindow (GetDlgItem (hDlg, IDT_CATTACHMENT), TRUE);
                }

                if (lpAttach[cAttach - 1].lpszFileName)
            SendDlgItemMessage(hDlg, IDC_CATTACHMENT, LB_ADDSTRING, 0,
            (LPARAM)lpAttach[cAttach -1].lpszFileName);

             /* Now, send a little render message to the NoteText edit */

        /*wsprintf (szAttach, "<<File: %s>>",
            lpAttach[cAttach - 1].lpszFileName);

        SendDlgItemMessage (hDlg, IDC_NOTE, EM_REPLACESEL, 0,
            (LPARAM) ((LPSTR) szAttach));*/
        }
        break;

    case IDC_ADDRBOOK:
            SendMessage(hDlg, WM_COMMAND, MAKELONG(IDC_RESOLVE,0), 0);
        ulResult = MAPIAddress (lhSession, (ULONG) hDlg, NULL,
        2, NULL, cRecips, lpRecips, 0, 0,
        &cNewRecips, &lpNewRecips);
        if (ulResult)
        {
        if (ulResult != MAPI_E_USER_ABORT)
            MakeMessageBox (hDlg, ulResult, IDS_ADDRBOOKFAIL, MBS_ERROR);
        }
        else
        {
        if (cNewRecips)
        {
            PvFree(lpRecips);
            lpRecips = (lpMapiRecipDesc)PvAlloc(cNewRecips*sizeof(MapiRecipDesc));
            cRecips = cNewRecips;

                    while(cNewRecips--)
                        CopyRecipient(lpRecips, &lpRecips[cNewRecips],
                                &lpNewRecips[cNewRecips]);

            MAPIFreeBuffer(lpNewRecips);
            lpNewRecips = NULL;
            cNewRecips = 0;

            MakeDisplayNameStr (szDisplayNames, MAPI_TO,
            cRecips, lpRecips);
            if (*szDisplayNames)
            SetDlgItemText (hDlg, IDC_TO, szDisplayNames);

            MakeDisplayNameStr (szDisplayNames, MAPI_CC,
            cRecips, lpRecips);
            if (*szDisplayNames)
            SetDlgItemText (hDlg, IDC_CC, szDisplayNames);

            SendDlgItemMessage (hDlg, IDC_TO, EM_SETMODIFY, FALSE, 0);
            SendDlgItemMessage (hDlg, IDC_CC, EM_SETMODIFY, FALSE, 0);
        }
        }
        break;

    case IDC_OPTIONS:
        DialogBox (hInst, "Options", hDlg, OptionsDlgProc);
        break;

    case IDC_SEND:
    case IDC_RESOLVE:
        fUnResTo = FALSE;
        fUnResCc = FALSE;

        hOldCur = SetCursor(hWaitCur);

        
        /* Get the names from the To: field and resolve them first */

        /*if (SendDlgItemMessage (hDlg, IDC_TO, EM_GETMODIFY, 0, 0) && */
         if (cb = SendDlgItemMessage (hDlg, IDC_TO, WM_GETTEXT,
            (WPARAM)sizeof(szUnResNames), (LPARAM)szUnResNames))
        {
        if (!ResolveFriendlyNames (hDlg, szUnResNames, MAPI_TO,
            &cRecips, &lpRecips))
        {
            MakeDisplayNameStr (szDisplayNames, MAPI_TO,
            cRecips, lpRecips);
            if (*szDisplayNames)
            {
            if (*szUnResNames)
            {
                lstrcat (szDisplayNames, "; ");
                lstrcat (szDisplayNames, szUnResNames);
                fUnResTo = TRUE;
            }

            SetDlgItemText (hDlg, IDC_TO, szDisplayNames);
            }
            else
            {
            if (*szUnResNames)
            {
                SetDlgItemText (hDlg, IDC_TO, szUnResNames);
                fUnResTo = TRUE;
            }
            }
        }
        /*SendDlgItemMessage (hDlg, IDC_TO, EM_SETMODIFY, FALSE, 0);*/
        }

        /* Now, get the names from the Cc: field and resolve them */

        /*if (SendDlgItemMessage (hDlg, IDC_CC, EM_GETMODIFY, 0, 0) &&*/
        if (cb = SendDlgItemMessage (hDlg, IDC_CC, WM_GETTEXT,
            (WPARAM)sizeof(szUnResNames), (LPARAM)szUnResNames))
        {
        if (!ResolveFriendlyNames (hDlg, szUnResNames, MAPI_CC,
            &cRecips, &lpRecips))
        {
            MakeDisplayNameStr (szDisplayNames, MAPI_CC,
            cRecips, lpRecips);
            if (*szDisplayNames)
            {
            if (*szUnResNames)
            {
                lstrcat (szDisplayNames, "; ");
                lstrcat (szDisplayNames, szUnResNames);
                fUnResCc = TRUE;
            }

            SetDlgItemText (hDlg, IDC_CC, szDisplayNames);
            }
            else
            {
            if (*szUnResNames)
            {
                SetDlgItemText (hDlg, IDC_CC, szUnResNames);
                fUnResCc = TRUE;
            }
            }
        }
        /*SendDlgItemMessage (hDlg, IDC_CC, EM_SETMODIFY, FALSE, 0);*/
        }

        /* If we were just Resolving Names then we can leave now */

        if (LOWORD (wParam) == IDC_RESOLVE)
        {
        SetCursor(hOldCur);
        break;
        }

        if (cRecips == 0 || fUnResTo || fUnResCc)
        {
        if (!cRecips)
            MakeMessageBox (hDlg, 0, IDS_NORECIPS, MBS_OOPS);

        if (fUnResTo)
            SetFocus (GetDlgItem (hDlg, IDC_TO));
        else if (fUnResCc)
            SetFocus (GetDlgItem (hDlg, IDC_CC));
        else
            SetFocus (GetDlgItem (hDlg, IDC_TO));

        SetCursor(hOldCur);
        break;
        }

        /* Everything is OK so far, lets get the Subject */
        /* and the NoteText and try to send the message. */

        /* Get Subject from Edit */

        if (SendDlgItemMessage (hDlg, IDC_SUBJECT, EM_GETMODIFY, 0, 0))
        {
        cb = SendDlgItemMessage (hDlg, IDC_SUBJECT, EM_LINELENGTH, 0, 0L);

        PvFree(lpszSubject);
        lpszSubject = (LPTSTR)PvAlloc(cb + 1);

        if (!lpszSubject)
            goto cleanup;

        GetDlgItemText (hDlg, IDC_SUBJECT, lpszSubject, (int)cb+1);
        }

        /* Get the NoteText from Edit */

        if (SendDlgItemMessage (hDlg, IDC_NOTE, EM_GETMODIFY, 0, 0))
        {
        cLines = SendDlgItemMessage (hDlg, IDC_NOTE,
            EM_GETLINECOUNT, 0, 0L);

        if (cLines)
        {
            /* Get the total number of bytes in the multi-line */

            cb = SendDlgItemMessage (hDlg, IDC_NOTE, EM_LINEINDEX,
            (UINT)cLines - 1, 0L);
            cb += SendDlgItemMessage (hDlg, IDC_NOTE, EM_LINELENGTH,
            (UINT)cb, 0L);

            /* The next line is to account for CR-LF pairs per line. */

            cb += cLines * 2;

                    PvFree(lpszNoteText);
            lpszNoteText = (LPTSTR)PvAlloc(cb + 1);

            if (!lpszNoteText)
            goto cleanup;

            /* Get the Note Text from the edit */

            GetDlgItemText (hDlg, IDC_NOTE, lpszNoteText, (int)cb);
        }
        else
        {
            /* Make an empty string for NoteText */

            lpszNoteText = (LPTSTR)PvAlloc(1);
            if (!lpszNoteText)
            goto cleanup;
            *lpszNoteText = '\0';
        }
        }

        lpmsg->lpszSubject = lpszSubject;
        lpmsg->lpszNoteText = lpszNoteText;
        lpmsg->nRecipCount = cRecips;
        lpmsg->lpRecips = lpRecips;
        lpmsg->nFileCount = cAttach;
        lpmsg->lpFiles = lpAttach;
        lpmsg->flFlags = flSendMsgFlags;

        ulResult = MAPISendMail (lhSession, (ULONG) hDlg, lpmsg, 0, 0);

        LogSendMail(ulResult);

        if (ulResult)
        {
        MakeMessageBox (hDlg, ulResult, IDS_SENDERROR, MBS_ERROR);
        SetCursor(hOldCur);
        break;
        }
cleanup:
        SetCursor(hOldCur);

    case IDCANCEL:
        PvFree(lpmsg->lpszMessageType);
        PvFree(lpmsg->lpszConversationID);
        PvFree(lpmsg);
        PvFree(lpRecips);
        PvFree(lpAttach);
        PvFree(lpszSubject);
        PvFree(lpszNoteText);
        lpmsg = NULL;

        EndDialog (hDlg, TRUE);
        return TRUE;
        break;

    default:
        break;
    }
    break;
    }
    return FALSE;
}

/*
 -  InBoxDlgProc
 -
 *  Purpose:
 *      Dialog procedure for the InBox dialog.
 *
 *  Parameters:
 *      hDlg
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *      True/False
 *
 */

BOOL FAR PASCAL
InBoxDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam)
{
    char szMsgID[512];
    char szSeedMsgID[512];
    LPMSGID lpMsgNode;
    static LPMSGID lpMsgIdList = NULL;
    lpMapiMessage lpMessage;
    ULONG ulResult;
    DWORD nIndex;
    RECT Rect;
    HCURSOR hOldCur;

    switch (msg)
    {
    case WM_INITDIALOG:
    hOldCur = SetCursor(hWaitCur);

        InitBmps(hDlg, IDC_MSG);

    /* Populate List Box with all messages in InBox. */
    /* This is a painfully slow process for now.     */

    ulResult = MAPIFindNext (lhSession, (ULONG) hDlg, NULL, NULL,
        MAPI_GUARANTEE_FIFO | MAPI_LONG_MSGID, 0, szMsgID);

    while (ulResult == SUCCESS_SUCCESS)
    {
        ulResult = MAPIReadMail (lhSession, (ULONG) hDlg, szMsgID,
        MAPI_PEEK | MAPI_ENVELOPE_ONLY,
        0, &lpMessage);

        if (!ulResult)
        {
        lpMsgNode = MakeMsgNode (lpMessage, szMsgID);

        if (lpMsgNode)
        {
            InsertMsgNode (lpMsgNode, &lpMsgIdList);

            SendDlgItemMessage (hDlg, IDC_MSG, LB_ADDSTRING,
            0, (LONG) lpMsgNode);
        }
        MAPIFreeBuffer (lpMessage);
        }

        lstrcpy (szSeedMsgID, szMsgID);
        ulResult = MAPIFindNext (lhSession, (ULONG) hDlg, NULL, szSeedMsgID,
        MAPI_GUARANTEE_FIFO | MAPI_LONG_MSGID, 0, szMsgID);
    }

    SetCursor(hOldCur);
    SetFocus (GetDlgItem (hDlg, IDC_MSG));
    return TRUE;
    break;

    case WM_SETFOCUS:
    SetFocus (GetDlgItem (hDlg, IDC_MSG));
    break;

    case WM_MEASUREITEM:
    /* Sets the height of the owner-drawn List-Box */
        MeasureItem(hDlg, (MEASUREITEMSTRUCT *)lParam);
    break;

    case WM_DRAWITEM:
    DrawItem((DRAWITEMSTRUCT *)lParam);
    break;

    case WM_DELETEITEM:
    /* This message is handled by the IDC_DELETE message */
    return TRUE;
    break;

    case WM_COMMAND:
    switch (LOWORD (wParam))
    {
    case IDC_NEW:
        hOldCur = SetCursor(hWaitCur);

        ulResult = MAPIFindNext (lhSession, (ULONG) hDlg, NULL, NULL,
        MAPI_UNREAD_ONLY | MAPI_LONG_MSGID, 0, szMsgID);

        while (ulResult == SUCCESS_SUCCESS)
        {
        if (!FindNode (lpMsgIdList, szMsgID))
        {
            ulResult = MAPIReadMail (lhSession, (ULONG) hDlg, szMsgID,
            MAPI_PEEK | MAPI_ENVELOPE_ONLY, 0, &lpMessage);

            if (!ulResult)
            {
            lpMsgNode = MakeMsgNode (lpMessage, szMsgID);
            InsertMsgNode (lpMsgNode, &lpMsgIdList);

            SendDlgItemMessage (hDlg, IDC_MSG, LB_ADDSTRING,
                0, (LONG) lpMsgNode);

            MAPIFreeBuffer (lpMessage);
            }
        }

        lstrcpy (szSeedMsgID, szMsgID);
        ulResult = MAPIFindNext (lhSession, (ULONG) hDlg, NULL, szSeedMsgID,
            MAPI_UNREAD_ONLY | MAPI_LONG_MSGID, 0, szMsgID);
        }
        SetCursor(hOldCur);
        break;

    case IDC_MSG:
        if(HIWORD(wParam) != LBN_DBLCLK)
        break;

    case IDC_READ:
        nIndex = SendDlgItemMessage (hDlg, IDC_MSG, LB_GETCURSEL, 0, 0);

        if (nIndex == LB_ERR)
        break;

        lpReadMsgNode = (LPMSGID) SendDlgItemMessage (hDlg, IDC_MSG,
        LB_GETITEMDATA, (UINT)nIndex, 0L);

        if (lpReadMsgNode)
        DialogBox (hInst, "ReadNote", hDlg, ReadMailDlgProc);

        /* Update the Messages List-Box with new icon */

        SendDlgItemMessage (hDlg, IDC_MSG, LB_GETITEMRECT, (UINT)nIndex, (LPARAM) &Rect);
        InvalidateRect(GetDlgItem(hDlg, IDC_MSG), &Rect, FALSE);
        break;

    case IDC_DELETE:
        nIndex = SendDlgItemMessage (hDlg, IDC_MSG, LB_GETCURSEL, 0, 0);

        if (nIndex == LB_ERR)
        break;

        lpMsgNode = (LPMSGID) SendDlgItemMessage (hDlg, IDC_MSG,
        LB_GETITEMDATA, (UINT)nIndex, 0);

        if (lpMsgNode)
        {
        MAPIDeleteMail (lhSession, (ULONG) hDlg, lpMsgNode->lpszMsgID, 0, 0);
        DeleteMsgNode (lpMsgNode, &lpMsgIdList);
        }

        SendDlgItemMessage (hDlg, IDC_MSG, LB_DELETESTRING, (UINT)nIndex, 0);
        break;

    case IDC_CLOSE:
    case IDCANCEL:
        FreeMsgList (lpMsgIdList);
        lpMsgIdList = NULL;

            DeInitBmps();

        EndDialog (hDlg, TRUE);
        return TRUE;
        break;

    default:
        break;
    }
    break;
    }

    return FALSE;
}

/*
 -  ReadMailDlgProc
 -
 *  Purpose:
 *      Dialog procedure for the ReadMail dilaog.
 *
 *  Parameters:
 *      hDlg
 *      message
 *      wParam
 *      lParam
 *
 *  Returns:
 *      True/False
 *
 */

BOOL FAR PASCAL
ReadMailDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam)
{
    ULONG ulResult;
    char szTo[TO_EDIT_MAX];
    char szCc[TO_EDIT_MAX];
    char szChangeMsg[512];
    ULONG idx;
    static lpMapiMessage lpReadMsg;

    switch (msg)
    {
    case WM_INITDIALOG:
    if (ulResult = MAPIReadMail (lhSession, (LONG) hDlg, lpReadMsgNode->lpszMsgID,
        0, 0, &lpReadMsg))
    {
        MakeMessageBox(hDlg, ulResult, IDS_READFAIL, MBS_ERROR);
        EndDialog (hDlg, TRUE);
        return TRUE;
    }

    lpReadMsgNode->fUnRead = FALSE;

    szTo[0] = '\0';
    szCc[0] = '\0';

    for (idx = 0; idx < lpReadMsg->nRecipCount; idx++)
    {
        if (lpReadMsg->lpRecips[idx].ulRecipClass == MAPI_TO)
        {
        lstrcat (szTo, lpReadMsg->lpRecips[idx].lpszName);
        lstrcat (szTo, "; ");
        }
        else if (lpReadMsg->lpRecips[idx].ulRecipClass == MAPI_CC)
        {
        lstrcat (szCc, lpReadMsg->lpRecips[idx].lpszName);
        lstrcat (szCc, "; ");
        }
        else
        {
        /* Must be Bcc, lets ignore it! */
        }
    }

    if(*szTo)
        szTo[lstrlen (szTo) - 2] = '\0';
    if(*szCc)
        szCc[lstrlen (szCc) - 2] = '\0';

    SetDlgItemText (hDlg, IDC_RFROM,
        (lpReadMsg->lpOriginator && lpReadMsg->lpOriginator->lpszName ?
                lpReadMsg->lpOriginator->lpszName : ""));
    SetDlgItemText (hDlg, IDC_RDATE,
        (lpReadMsg->lpszDateReceived ? lpReadMsg->lpszDateReceived : ""));
    SetDlgItemText (hDlg, IDC_RTO, szTo);
    SetDlgItemText (hDlg, IDC_RCC, szCc);
    SetDlgItemText (hDlg, IDC_RSUBJECT,
        (lpReadMsg->lpszSubject ? lpReadMsg->lpszSubject : ""));
    SetDlgItemText (hDlg, IDC_READNOTE,
        (lpReadMsg->lpszNoteText ? lpReadMsg->lpszNoteText : ""));

    if (!lpReadMsg->nFileCount)
    {
        EnableWindow (GetDlgItem (hDlg, IDC_SAVEATTACH), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_ATTACHMENT), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDT_ATTACHMENT), FALSE);
    }
    else
    {
        for(idx = 0; idx < lpReadMsg->nFileCount; idx++)
        if (lpReadMsg->lpFiles[idx].lpszFileName)
            SendDlgItemMessage(hDlg, IDC_ATTACHMENT, LB_ADDSTRING, 0,
            (LPARAM)lpReadMsg->lpFiles[idx].lpszFileName);

        SendDlgItemMessage(hDlg, IDC_ATTACHMENT, LB_SETCURSEL, 0, 0L);
    }

    SetFocus (GetDlgItem (hDlg, IDC_READNOTE));
    return FALSE;

    case WM_COMMAND:
    switch (LOWORD (wParam))
    {
    case IDC_SAVECHANGES:
        if (SendDlgItemMessage (hDlg, IDC_READNOTE, EM_GETMODIFY, 0, 0))
        ulResult = SaveMsgChanges (hDlg, lpReadMsg, lpReadMsgNode->lpszMsgID);
        SendDlgItemMessage (hDlg, IDC_READNOTE, EM_SETMODIFY, 0, 0);
        break;

    case IDC_ATTACHMENT:
        if(HIWORD(wParam) != LBN_DBLCLK)
        break;

    case IDC_SAVEATTACH:
        idx = SendDlgItemMessage(hDlg, IDC_ATTACHMENT, LB_GETCURSEL, 0, 0L);

        if(idx != LB_ERR)
        {
        SaveFileAttachments(hDlg, &lpReadMsg->lpFiles[idx]);
        SetFocus(GetDlgItem (hDlg, IDC_ATTACHMENT));
        return FALSE;

        }
        break;

    case IDC_REPLY:
    case IDC_REPLYALL:
    case IDC_FORWARD:
        MakeNewMessage (lpReadMsg, LOWORD (wParam));
        DialogBox (hInst, "ComposeNote", hDlg, ComposeDlgProc);
        break;

    case IDCANCEL:
        if (SendDlgItemMessage (hDlg, IDC_READNOTE, EM_GETMODIFY, 0, 0))
        {
        wsprintf (szChangeMsg, "Save changes to: '%s' in Inbox?",
            (lpReadMsg->lpszSubject ? lpReadMsg->lpszSubject : ""));

        if (MessageBox (hDlg, szChangeMsg, "Mail", MB_YESNO) == IDYES)
        {
            ulResult = SaveMsgChanges (hDlg, lpReadMsg, lpReadMsgNode->lpszMsgID);
        }
        }

        /* If there were file attachments, then delete the temps */

        for(idx = 0; idx < lpReadMsg->nFileCount; idx++)
        if (lpReadMsg->lpFiles[idx].lpszPathName)
            DeleteFile(lpReadMsg->lpFiles[idx].lpszPathName);

        MAPIFreeBuffer (lpReadMsg);
        lpReadMsg = NULL;
        EndDialog (hDlg, TRUE);
        return TRUE;
    }
    break;
    }
    return FALSE;
}

/*
 -  MakeMessageBox
 -
 *  Purpose:
 *      Gets resource string and displays an error message box.
 *
 *  Parameters:
 *      hWnd            - Handle to parent window
 *      idString        - Resource ID of message in StringTable
 *
 *  Returns:
 *      Void
 *
 */

void
MakeMessageBox (HWND hWnd, ULONG ulResult, UINT idString, UINT fStyle)
{
    char szMessage[256];
    char szMapiReturn[64];

    LoadString (hInst, idString, szMessage, 255);

    if (ulResult)
    {
    LoadString (hInst, (UINT)ulResult, szMapiReturn, 64);
    lstrcat (szMessage, "\nReturn Code: ");
    lstrcat (szMessage, szMapiReturn);
    }

    MessageBox (hWnd, szMessage, "Problem", fStyle);
}

/*
 -  ResolveFriendlyNames
 -
 *  Purpose:
 *      Helper function to convert a string of ';' delimited friendly
 *      names into an array of MapiRecipDescs.
 *
 *  Side Effects:                                             
 *      The display string passed in is modified to contain the
 *      friendly names of the mail users as found in the sample
 *      address book.
 *
 *  Note:
 *      Duplicate names in the address book will result in undefined
 *      behavior.
 *
 *  Parameters:
 *      hWnd                - Handle to parent window
 *      lpszDisplayNames    - string of ';' delimited user names
 *      ulRecipClass        - either MAPI_TO, MAPI_CC, or MAPI_BCC
 *      lpcRecips           - Address of recipient count to be returned
 *      lppRecips           - Address of recipient array to be returned
 *
 *  Return:
 *      ulResult
 */

ULONG
ResolveFriendlyNames (HWND hWnd, LPSTR lpszDisplayNames, ULONG ulRecipClass,
    ULONG * lpcRecips, lpMapiRecipDesc * lppRecips)
{
    char szResolve[TO_EDIT_MAX];
    LPSTR lpszNameToken;
    ULONG cRecips = 0;
    ULONG cFails = 0;
    ULONG ulResult;
    lpMapiRecipDesc lpRecip;
    lpMapiRecipDesc lpRecipList;

    *szResolve = '\0';
    lpszNameToken = strtok (lpszDisplayNames, ";\n");

    while (lpszNameToken)
    {
    /* Strip leading blanks from name */

    while (*lpszNameToken == ' ')
        lpszNameToken++;

    /* Check if name has already been resolved */

    if (!FNameInList (lpszNameToken, *lpcRecips, *lppRecips))
    {
        lstrcat (szResolve, lpszNameToken);
        lstrcat (szResolve, "; ");
        cRecips++;
    }

    /* Get Next Token */

    lpszNameToken = strtok (NULL, ";\n");
    }

    *lpszDisplayNames = '\0';

    if (!szResolve[0])
    {
    ulResult = SUCCESS_SUCCESS;
    goto err;
    }

    szResolve[lstrlen (szResolve) - 2] = '\0';

    lpRecipList = (lpMapiRecipDesc)PvAlloc((cRecips + *lpcRecips) * sizeof (MapiRecipDesc));

    if (!lpRecipList)
    {
    ulResult = MAPI_E_INSUFFICIENT_MEMORY;
    goto err;
    }
    memset (lpRecipList, 0, (size_t)(cRecips+*lpcRecips)*sizeof(MapiRecipDesc));

    cRecips = 0;

    while (cRecips < *lpcRecips)
    {
    ulResult = CopyRecipient (lpRecipList, &lpRecipList[cRecips],
        *lppRecips + cRecips);

    if (ulResult)
    {
        PvFree(lpRecipList);
        goto err;
    }

    cRecips++;
    }

    PvFree(*lppRecips);

    lpszNameToken = strtok (szResolve, ";\n");

    while (lpszNameToken)
    {
    /* Strip leading blanks (again) */

    while (*lpszNameToken == ' ')
        lpszNameToken++;

    ulResult = MAPIResolveName (lhSession, (ULONG) hWnd, lpszNameToken,
        MAPI_DIALOG, 0, &lpRecip);

    if (ulResult == SUCCESS_SUCCESS)
    {
        lpRecip->ulRecipClass = ulRecipClass;
        ulResult = CopyRecipient (lpRecipList, &lpRecipList[cRecips], lpRecip);

        MAPIFreeBuffer (lpRecip);

        if (ulResult)
        goto cleanup;

        cRecips++;
    }
    else
    {
        lstrcat (lpszDisplayNames, lpszNameToken);
        lstrcat (lpszDisplayNames, "; ");
        cFails++;
    }
    lpszNameToken = strtok (NULL, ";\n");
    }

    /* if cFails > 0 then we have partial success */

    ulResult = SUCCESS_SUCCESS;

    if (cFails)
    MakeMessageBox (hWnd, 0, IDS_UNRESOLVEDNAMES, MBS_INFO);

cleanup:
    *lpcRecips = cRecips;
    *lppRecips = lpRecipList;
err:
    if (*lpszDisplayNames)
    lpszDisplayNames[lstrlen (lpszDisplayNames) - 2] = '\0';

    return ulResult;
}

/*
 -  CopyRecipient
 -
 *  Purpose:
 *      Called in support of ResolveFriendlyNames() to build an array
 *      of chained MapiRecipDescs.
 *
 *  Parameters:
 *      lpParent        - Parent memory that allocations get chained to
 *      lpDest          - Destination Recipient
 *      lpSrc           - Source Recipient
 *
 *  Return:
 *      ulResult
 */

ULONG
CopyRecipient (lpMapiRecipDesc lpParent,
    lpMapiRecipDesc lpDest,
    lpMapiRecipDesc lpSrc)
{
    lpDest->ulReserved = lpSrc->ulReserved;
    lpDest->ulRecipClass = lpSrc->ulRecipClass;
    lpDest->ulEIDSize = lpSrc->ulEIDSize;

    if (lpSrc->lpszName)
    {
    lpDest->lpszName = (LPTSTR)PvAllocMore(lstrlen(lpSrc->lpszName) + 1,
            (LPVOID)lpParent);

    if (!lpDest->lpszName)
        return MAPI_E_INSUFFICIENT_MEMORY;

    lstrcpy (lpDest->lpszName, lpSrc->lpszName);
    }
    else
    lpDest->lpszName = NULL;

    if (lpSrc->lpszAddress)
    {
    lpDest->lpszAddress = (LPTSTR)PvAllocMore(lstrlen (lpSrc->lpszAddress) + 1,
            (LPVOID)lpParent);

    if (!lpDest->lpszAddress)
        return MAPI_E_INSUFFICIENT_MEMORY;

    lstrcpy (lpDest->lpszAddress, lpSrc->lpszAddress);
    }
    else
    lpDest->lpszAddress = NULL;

    if (lpSrc->lpEntryID)
    {
    lpDest->lpEntryID = (LPBYTE)PvAllocMore(lpSrc->ulEIDSize,
            (LPVOID)lpParent);

    if (!lpDest->lpEntryID)
        return MAPI_E_INSUFFICIENT_MEMORY;

        if (lpSrc->ulEIDSize)
            memcpy (lpDest->lpEntryID, lpSrc->lpEntryID, (size_t)lpSrc->ulEIDSize);
    }
    else
    lpDest->lpEntryID = NULL;

    return SUCCESS_SUCCESS;

}

/*
 -  GetNextFile
 -
 *  Purpose:
 *      Called when user clicks 'Attach' button in Compose Note form.
 *      We will build a chained memory chunk for mmore than one file
 *      attachment so the memory can be freed with a single call to
 *      PvFree.
 *
 *  Parameters:
 *      hWnd            - Window handle of Compose Note dialog
 *      nPos            - Render position of attachment in Notetext.
 *      lpcAttach       - Pointer to the count of attachments.
 *      lppAttach       - Pointer to the MapiFileDesc array.
 *
 *  Return:
 *      ulResult.
 */

ULONG
GetNextFile (HWND hWnd, ULONG nPos, ULONG * lpcAttach,
    lpMapiFileDesc * lppAttach)
{
    lpMapiFileDesc lpAttach;
    lpMapiFileDesc lpAttachT;
    OPENFILENAME ofn;
    char szFileName[256] = "";
    char szFilter[256];
    static char szFileTitle[16];
    static char szDirName[256] = "";
    LPSTR lpszEndPath;
    ULONG idx;
    ULONG ulResult = SUCCESS_SUCCESS;

    if (!szDirName[0])
    GetSystemDirectory ((LPSTR) szDirName, 255);
    else
    lstrcpy (szFileName, szFileTitle);

    LoadString(hInst, IDS_FILTER, szFilter, sizeof(szFilter));

    for (idx = 0; szFilter[idx] != '\0'; idx++)
    if (szFilter[idx] == '|')
        szFilter[idx] = '\0';

    ofn.lStructSize = sizeof (OPENFILENAME);
    ofn.hwndOwner = 0;
    ofn.hInstance = 0;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0L;
    ofn.nFilterIndex = 1L;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = 256;
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = 16;
    ofn.lpstrInitialDir = szDirName;
    ofn.lpstrTitle = "Attach";
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;

    if (!GetOpenFileName (&ofn))
    return MAPI_USER_ABORT;

    /* Save the directory for the next time we call this */

    lstrcpy (szDirName, szFileName);
    if (lpszEndPath = strstr (szDirName, szFileTitle))
    *(--lpszEndPath) = '\0';

    lpAttach = (lpMapiFileDesc)PvAlloc(((*lpcAttach) + 1) * sizeof (MapiFileDesc));

    if(!lpAttach)
    goto err;

    memset (lpAttach, 0, (size_t)(*lpcAttach + 1) * sizeof (MapiFileDesc));

    lpAttachT = *lppAttach;

    for (idx = 0; idx < *lpcAttach; idx++)
    if(ulResult = CopyAttachment (lpAttach, &lpAttach[idx], &lpAttachT[idx]))
        goto err;

    lpAttach[idx].ulReserved = 0;
    lpAttach[idx].flFlags = 0;
    lpAttach[idx].nPosition = (ULONG)(-1);
    lpAttach[idx].lpFileType = NULL;

    lpAttach[idx].lpszPathName = (LPTSTR)PvAllocMore(lstrlen (szFileName) + 1,
        (LPVOID)lpAttach);

    if(!lpAttach[idx].lpszPathName)
    goto err;

    lpAttach[idx].lpszFileName = (LPTSTR)PvAllocMore(lstrlen (szFileTitle) + 1,
        (LPVOID)lpAttach);

    if(!lpAttach[idx].lpszFileName)
    goto err;

    lstrcpy (lpAttach[idx].lpszPathName, szFileName);
    lstrcpy (lpAttach[idx].lpszFileName, szFileTitle);

    PvFree(lpAttachT);

    *lppAttach = lpAttach;
    (*lpcAttach)++;

err:
    if(ulResult)
    PvFree(lpAttach);

    return ulResult;
}

/*
 -  CopyAttachment
 -
 *  Purpose:
 *      Called in support of GetNextFile() to re-build an array
 *      of chained MapiFileDescs.
 *
 *  Parameters:
 *      lpParent        - Parent memory that allocations get chained to
 *      lpDest          - Destination Recipient
 *      lpSrc           - Source Recipient
 *
 *  Return:
 *      Void.
 */

ULONG
CopyAttachment (lpMapiFileDesc lpParent,
    lpMapiFileDesc lpDest,
    lpMapiFileDesc lpSrc)
{
    lpDest->ulReserved = lpSrc->ulReserved;
    lpDest->flFlags = lpSrc->flFlags;
    lpDest->nPosition = lpSrc->nPosition;
    lpDest->lpFileType = lpSrc->lpFileType;

    if (lpSrc->lpszPathName)
    {
    lpDest->lpszPathName = (LPTSTR)PvAllocMore(lstrlen (lpSrc->lpszPathName) + 1,
            (LPVOID)lpParent);

    if (!lpDest->lpszPathName)
        return MAPI_E_INSUFFICIENT_MEMORY;

    lstrcpy (lpDest->lpszPathName, lpSrc->lpszPathName);
    }
    else
    lpDest->lpszPathName = NULL;

    if (lpSrc->lpszFileName)
    {
    lpDest->lpszFileName = (LPTSTR)PvAllocMore(lstrlen (lpSrc->lpszFileName) + 1,
            (LPVOID)lpParent);

    if (!lpDest->lpszFileName)
        return MAPI_E_INSUFFICIENT_MEMORY;

    lstrcpy (lpDest->lpszFileName, lpSrc->lpszFileName);
    }
    else
    lpDest->lpszFileName = NULL;

    return SUCCESS_SUCCESS;

}

/*
 -  FNameInList
 -
 *  Purpose:
 *      To find lpszName in an array of recipients.  Used to determine
 *      if user name has already been resolved.
 *
 *  Parameters:
 *      lpszName        - Friendly name to search for
 *      cRecips         - Count of recipients in lpRecips
 *      lpRecips        - Array of MapiRecipDescs
 *
 *  Return:
 *      TRUE/FALSE
 */

BOOL
FNameInList (LPSTR lpszName, ULONG cRecips, lpMapiRecipDesc lpRecips)
{
    /* Case sensitive compare of each friendly name in list.  */

    if (!cRecips || !lpRecips)
    return FALSE;

    while (cRecips--)
    if (!lstrcmp (lpszName, lpRecips[cRecips].lpszName))
        return TRUE;

    return FALSE;
}


/*
 -  MakeMsgNode
 -
 *  Purpose:
 *      Allocate memory for a new MSGID node and initialize its
 *      data members to the values passed in.
 *
 *  Parameters:
 *      lpMsg           - Pointer to a MapiMessage
 *      lpszMsgID       - Opaque message identifier
 *
 *  Return:
 *      lpMsgNode       - Pointer to new node
 */

LPMSGID
MakeMsgNode (lpMapiMessage lpMsg, LPSTR lpszMsgID)
{
    LPMSGID lpMsgNode = NULL;

    if (!lpMsg || !lpszMsgID)
    goto err;

    lpMsgNode = (LPMSGID)PvAlloc(sizeof (MSGID));

    if (!lpMsgNode)
    goto err;

    memset (lpMsgNode, 0, sizeof (MSGID));

    if (lpMsg->nFileCount)
    lpMsgNode->fHasAttach = TRUE;

    if (lpMsg->flFlags & MAPI_UNREAD)
    lpMsgNode->fUnRead = TRUE;

    lpMsgNode->lpszMsgID = (LPTSTR)PvAllocMore(lstrlen (lpszMsgID) + 1,
        (LPVOID)lpMsgNode);

    if (!lpMsgNode->lpszMsgID)
    goto err;

    lstrcpy (lpMsgNode->lpszMsgID, lpszMsgID);

    if (lpMsg->lpOriginator && lpMsg->lpOriginator->lpszName)
    {
    lpMsgNode->lpszFrom = (LPTSTR)PvAllocMore(lstrlen(lpMsg->lpOriginator->lpszName) + 1,
            (LPVOID)lpMsgNode);

    if (!lpMsgNode->lpszFrom)
        goto err;

    lstrcpy (lpMsgNode->lpszFrom, lpMsg->lpOriginator->lpszName);
    }

    if (lpMsg->lpszSubject)
    {
    lpMsgNode->lpszSubject = (LPTSTR)PvAllocMore(lstrlen (lpMsg->lpszSubject) + 1,
            (LPVOID)lpMsgNode);

    if (!lpMsgNode->lpszSubject)
        goto err;

    lstrcpy (lpMsgNode->lpszSubject, lpMsg->lpszSubject);
    }

    if (lpMsg->lpszDateReceived)
    {
    lpMsgNode->lpszDateRec = (LPTSTR)PvAllocMore(lstrlen (lpMsg->lpszDateReceived) + 1,
            (LPVOID)lpMsgNode);

    if (!lpMsgNode->lpszDateRec)
        goto err;

    lstrcpy (lpMsgNode->lpszDateRec, lpMsg->lpszDateReceived);
    }

    return lpMsgNode;

err:
    PvFree(lpMsgNode);
    return NULL;
}

/*
 -  InsertMsgNode
 -
 *  Purpose:
 *      Currently (for simplicity) we will insert the nodes
 *      at the beginning of the list.  This can later be
 *      replaced with a routine that can insert sorted on
 *      different criteria, like DateReceived, From, or
 *      Subject.  But for now...
 *
 *  Parameters:
 *      lpMsgNode       - Pointer to a MSGID node
 *      lppMsgHead      - Pointer to the head of the list
 *
 *  Return:
 *      Void.
 */

void
InsertMsgNode (LPMSGID lpMsgNode, LPMSGID * lppMsgHead)
{
    if (*lppMsgHead)
    {
    lpMsgNode->lpNext = *lppMsgHead;
    (*lppMsgHead)->lpPrev = lpMsgNode;
    }
    else
    lpMsgNode->lpNext = NULL;

    /* The next 2 assignments are here in case the node came from somewhere */
    /* other than a call to MakeMsgNode () in which case we aren't sure */
    /* they're already NULL. */

    lpMsgNode->lpPrev = NULL;
    *lppMsgHead = lpMsgNode;
}

/*
 -  DeleteMsgNode
 -
 *  Purpose:
 *      Removes the node passed in from the list.  This
 *      may seem like a strange way to do this but it's
 *      not, because the Owner-Drawn List Box gives us
 *      direct access to elements in the list that makes
 *      it easier to do things this way.
 *
 *  Parameters:
 *      lpMsgNode       - Pointer to the MSGID node to delete
 *      lppMsgHead      - Pointer to the head of the list
 *
 *  Return:
 *      Void.
 */

void
DeleteMsgNode (LPMSGID lpMsgNode, LPMSGID * lppMsgHead)
{
    if (!lpMsgNode)
    return;

    /* Check if we are the first node */

    if (lpMsgNode->lpPrev)
    lpMsgNode->lpPrev->lpNext = lpMsgNode->lpNext;

    /* Check if we are the last node */

    if (lpMsgNode->lpNext)
    lpMsgNode->lpNext->lpPrev = lpMsgNode->lpPrev;

    /* check if we are the only node */

    if(lpMsgNode == *lppMsgHead)
    *lppMsgHead = NULL;

    PvFree(lpMsgNode);
    return;
}



/*
 -  FindNode
 -
 *  Purpose:
 *      Returns a pointer to the node containing lpszMsgID.
 *      Returns NULL if node doesn't exist or lpszMsgID is NULL.
 *
 *  Parameters:
 *      lpMsgHead       - Pointer to the head of the list
 *      lpszMsgID       - Message ID to search for
 *
 *  Return:
 *      lpMsgNode       - Pointer to the node returned
 */

LPMSGID
FindNode (LPMSGID lpMsgHead, LPSTR lpszMsgID)
{
    if (!lpszMsgID)
    return NULL;

    while (lpMsgHead)
    {
    if (!lstrcmp (lpMsgHead->lpszMsgID, lpszMsgID))
        break;

    lpMsgHead = lpMsgHead->lpNext;
    }

    return lpMsgHead;
}



/*
 -  FreeMsgList
 -
 *  Purpose:
 *      Walks down the MsgList and frees each node.
 *
 *  Parameters:
 *      lpMsgHead       - Pointer to the head of the list
 *
 *  Return:
 *      Void.
 */

void
FreeMsgList (LPMSGID lpMsgHead)
{
    LPMSGID lpT;

    while (lpMsgHead)
    {
    lpT = lpMsgHead;
    lpMsgHead = lpMsgHead->lpNext;
    PvFree(lpT);
    }
}

/*
 -  MakeDisplayNameStr
 -
 *  Purpose:
 *      Finds all recipients of type ulRecipClass in lpRecips and adds
 *      their friendly name to the display string.
 *
 *  Parameters:
 *      lpszDisplay         - Destination string for names
 *      ulRecipClass        - Recipient types to search for
 *      cRecips             - Count of recipients in lpRecips
 *      lpRecips            - Pointer to array of MapiRecipDescs
 *
 *  Return:
 *      Void.
 */

void
MakeDisplayNameStr (LPSTR lpszDisplay, ULONG ulRecipClass,
    ULONG cRecips, lpMapiRecipDesc lpRecips)
{
    ULONG idx;

    *lpszDisplay = '\0';

    for (idx = 0; idx < cRecips; idx++)
    {
    if (lpRecips[idx].ulRecipClass == ulRecipClass)
    {
        lstrcat (lpszDisplay, lpRecips[idx].lpszName);
        lstrcat (lpszDisplay, "; ");
    }
    }

    if (*lpszDisplay)
    lpszDisplay[lstrlen (lpszDisplay) - 2] = '\0';
}



/*
 -  SaveMsgChanges
 -
 *  Purpose:
 *      If while reading a message the user changes the notetext at all
 *      then this function is called to save those changes in the Inbox.
 *
 *  Parameters:
 *      hWnd            - handle to the window/dialog who called us
 *      lpMsg           - pointer to the MAPI message to be saved
 *      lpszMsgID       - ID of the message to save
 *
 *  Return:
 *      ulResult        - Indicating success/failure
 */

ULONG
SaveMsgChanges (HWND hWnd, lpMapiMessage lpMsg, LPSTR lpszMsgID)
{
    LPSTR lpszT;
    LPSTR lpszNoteText = NULL;
    LONG cLines, cb;
    ULONG ulResult = MAPI_E_INSUFFICIENT_MEMORY;

    lpszT = lpMsg->lpszNoteText;

    cLines = SendDlgItemMessage (hWnd, IDC_READNOTE, EM_GETLINECOUNT, 0, 0L);
    cb = SendDlgItemMessage (hWnd, IDC_READNOTE, EM_LINEINDEX, (UINT)cLines - 1, 0L);
    cb += SendDlgItemMessage (hWnd, IDC_READNOTE, EM_LINELENGTH, (UINT)cb, 0L);
    cb += cLines * 2;

    lpszNoteText = (LPTSTR)PvAlloc(cb + 1);

    if (!lpszNoteText)
    goto err;

    SendDlgItemMessage (hWnd, IDC_READNOTE, WM_GETTEXT,
    (WPARAM) cb, (LPARAM) lpszNoteText);

    lpMsg->lpszNoteText = lpszNoteText;
    ulResult = MAPISaveMail (lhSession, (ULONG) hWnd, lpMsg, MAPI_LONG_MSGID,
        0, lpReadMsgNode->lpszMsgID);

    PvFree(lpszNoteText);

err:
    lpMsg->lpszNoteText = lpszT;
    return ulResult;
}



/*
 -  MakeNewMessage
 -
 *  Purpose:
 *      This function is used to construct a new message for the
 *      ComposeNote UI.  This gets called as a result of a Reply,
 *      ReplyAll, or a Forward action on a message being read.
 *      The destination for the new message is lpmsg, the global
 *      MapiMessage struct pointer used by ComposeNoteDlgProc.
 *      ComposeNoteDlgProc always frees the memory consumed by
 *      this object whether it allocated it or not.
 *
 *  Parameters:
 *      lpSrcMsg            - MapiMessage to be copied
 *      flType              - Specifies the action that caused this call
 *                            either: IDC_REPLY, IDC_REPLYALL, or IDC_FORWARD
 *
 *  Return:
 *      ulResult            - Indicates success/failure
 */

ULONG
MakeNewMessage (lpMapiMessage lpSrcMsg, UINT flType)
{
    ULONG idx;
    ULONG ulResult = SUCCESS_SUCCESS;

    if (!lpSrcMsg)
    return MAPI_E_FAILURE;

    lpmsg = (lpMapiMessage)PvAlloc(sizeof (MapiMessage));

    if (!lpmsg)
    goto err;

    memset (lpmsg, 0, sizeof (MapiMessage));

    lpmsg->flFlags = flSendMsgFlags;

    if (lpSrcMsg->lpszSubject)
    {
    lpmsg->lpszSubject = (LPTSTR)PvAlloc(lstrlen(lpSrcMsg->lpszSubject) + 5);

    if (!lpmsg->lpszSubject)
        goto err;

    if (flType == IDC_FORWARD)
        lstrcpy (lpmsg->lpszSubject, "FW: ");
    else
        lstrcpy (lpmsg->lpszSubject, "RE: ");

    lstrcat (lpmsg->lpszSubject, lpSrcMsg->lpszSubject);
    }

    if (lpSrcMsg->lpszNoteText)
    {
    lpmsg->lpszNoteText = (LPTSTR)PvAlloc(lstrlen(lpSrcMsg->lpszNoteText) + 32);

    if (!lpmsg->lpszNoteText)
        goto err;

    lstrcpy (lpmsg->lpszNoteText, "\r\n--------------------------\r\n");
    lstrcat (lpmsg->lpszNoteText, lpSrcMsg->lpszNoteText);
    }

    if (lpSrcMsg->lpszMessageType)
    {
    lpmsg->lpszMessageType = (LPTSTR)PvAlloc(lstrlen (lpSrcMsg->lpszMessageType) + 1);

    if (!lpmsg->lpszMessageType)
        goto err;

    lstrcpy (lpmsg->lpszMessageType, lpSrcMsg->lpszMessageType);
    }

    if (lpSrcMsg->lpszConversationID)
    {
    lpmsg->lpszConversationID = (LPTSTR)PvAlloc(lstrlen(lpSrcMsg->lpszConversationID) + 1);

    if (!lpmsg->lpszConversationID)
        goto err;

    lstrcpy (lpmsg->lpszConversationID, lpSrcMsg->lpszConversationID);
    }

    if (lpSrcMsg->nFileCount && flType == IDC_FORWARD )
    {
    lpmsg->nFileCount = lpSrcMsg->nFileCount;

    lpmsg->lpFiles = (lpMapiFileDesc)PvAlloc(lpmsg->nFileCount * sizeof (MapiFileDesc));

    if (!lpmsg->lpFiles)
        goto err;
        memset (lpmsg->lpFiles, 0, (size_t)lpmsg->nFileCount * sizeof (MapiFileDesc));

        for (idx = 0; idx < lpmsg->nFileCount; idx++)
    {       
        CopyAttachment (lpmsg->lpFiles, &lpmsg->lpFiles[idx],
        &lpSrcMsg->lpFiles[idx]);
        
            if ((&lpmsg->lpFiles[idx])->nPosition != (ULONG) -1)
            {       
                /*lpmsg->lpszNoteText[(&lpmsg->lpFiles[idx])->nPosition 
                            + lstrlen("\r\n--------------------------\r\n")] = '+';*/
                (&lpmsg->lpFiles[idx])->nPosition = (ULONG) -1;
                
            }
                                
            
        }
    }

    if (flType == IDC_REPLY || flType == IDC_REPLYALL)
    {
        ULONG idxSrc;

    if(lpSrcMsg->lpOriginator)
        lpmsg->nRecipCount = 1;

    if (flType == IDC_REPLYALL)
        lpmsg->nRecipCount += lpSrcMsg->nRecipCount;

        if(!lpmsg->nRecipCount)
            return ulResult;

    lpmsg->lpRecips = (lpMapiRecipDesc)PvAlloc(lpmsg->nRecipCount * sizeof (MapiRecipDesc));

    if (!lpmsg->lpRecips)
        goto err;

        memset (lpmsg->lpRecips, 0, (size_t)lpmsg->nRecipCount * sizeof (MapiRecipDesc));
        idx = 0;

        if(lpSrcMsg->lpOriginator)
        {
        lpSrcMsg->lpOriginator->ulRecipClass = MAPI_TO;
        CopyRecipient (lpmsg->lpRecips, lpmsg->lpRecips,
                lpSrcMsg->lpOriginator);
        lpSrcMsg->lpOriginator->ulRecipClass = MAPI_ORIG;
            idx = 1;
        }

    for (idxSrc = 0; idx < lpmsg->nRecipCount; idxSrc++, idx++)
        CopyRecipient (lpmsg->lpRecips, &lpmsg->lpRecips[idx],
        &lpSrcMsg->lpRecips[idxSrc]);
    }

    return ulResult;

err:
    if(lpmsg)
    {
        PvFree(lpmsg->lpszSubject);
    PvFree(lpmsg->lpszNoteText);
        PvFree(lpmsg->lpszMessageType);
        PvFree(lpmsg->lpszConversationID);
        PvFree(lpmsg->lpRecips);
        PvFree(lpmsg->lpFiles);
        PvFree(lpmsg);
        lpmsg = NULL;
    }
    return ulResult;
}



/*
 -  LogSendMail
 -
 *  Purpose:
 *      Used to track how many messages were sent with this client.
 *      This information is used strictly for gathering stats on
 *      how many messages were pumped through the spooler/transport.
 *
 *  Usage:
 *      Add the following to the win.ini file:
 *          [MAPI Client]
 *          LogFile=filepath
 *
 *      where: filepath can be a full UNC path or some local path & file
 *
 *  Parameters:
 *      ulResult        - Currently unused; should be used to count errors
 *
 *  Result:
 *      Void.
 */

void LogSendMail(ULONG ulResult)
{
    char szLogFile[128];
    char szCount[32];
    OFSTRUCT ofs;
    HFILE hf = HFILE_ERROR;
    int cSent = 1;

    if(!GetProfileString("MAPI Client", "LogFile", "mapicli.log",
        szLogFile, sizeof(szLogFile)))
    return;

    if((hf = OpenFile(szLogFile, &ofs, OF_READWRITE)) == HFILE_ERROR)
    {
    if((hf = OpenFile(szLogFile, &ofs, OF_CREATE|OF_READWRITE)) == HFILE_ERROR)
        return;
    }
    else
    {
    if(!_lread(hf, szCount, sizeof(szCount)))
    {
        _lclose(hf);
        return;
    }

    cSent = atoi(szCount) + 1;
    }

    wsprintf(szCount, "%d", cSent);

    _llseek(hf, 0, 0);

    _lwrite(hf, szCount, lstrlen(szCount));
    _lclose(hf);

    return;
}



/*
 -  SaveFileAttachments
 -
 *  Purpose:
 *      Displays a 'Save As' common dialog to allow the user to save
 *      file attachments contained in the current message.
 *
 *  Parameters:
 *      hWnd            - Window handle of calling WndProc
 *      cFiles          - Count of the files in the file array
 *      lpFiles         - Array of MapiFileDescs
 *
 *  Return:
 *      Void.
 */

void SaveFileAttachments(HWND hWnd, lpMapiFileDesc lpFile)
{
    OPENFILENAME ofn;
    char szFileName[256] = "";
    char szFilter[256];
    static char szFileTitle[16];
    static char szDirName[256] = "";
    LPSTR lpszEndPath;
    ULONG idx;

    if (!lpFile)
    return;

    if (!szDirName[0])
    GetTempPath (sizeof(szDirName), szDirName);

    LoadString(hInst, IDS_FILTER, szFilter, sizeof(szFilter));

    for (idx = 0; szFilter[idx] != '\0'; idx++)
    if (szFilter[idx] == '|')
        szFilter[idx] = '\0';

    lstrcpy (szFileName, lpFile->lpszFileName);

    ofn.lStructSize = sizeof (OPENFILENAME);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = 0;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0L;
    ofn.nFilterIndex = 1L;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = sizeof(szFileName);
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = sizeof(szFileTitle);
    ofn.lpstrInitialDir = szDirName;
    ofn.lpstrTitle = "Save Attachment";
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.Flags = OFN_SHOWHELP | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY;

    if (!GetSaveFileName (&ofn))
    return;

    /* Save the directory for the next time we call this */

    lstrcpy (szDirName, szFileName);
    if (lpszEndPath = strstr (szDirName, szFileTitle))
    *(--lpszEndPath) = '\0';

    /* Use CopyFile to carry out the operation. */

    if(!CopyFile(lpFile->lpszPathName, szFileName, FALSE))
    MakeMessageBox (hWnd, 0, IDS_SAVEATTACHERROR, MBS_ERROR);
}



/*
 -  ToggleMenuState
 -
 *  Purpose:
 *      Enables/Disables menu items depending on the session state.
 *
 *  Parameters:
 *      hWnd            - handle to the window/dialog who called us
 *      fLoggedOn       - TRUE if logged on, FALSE if logged off
 *
 *  Return:
 *      Void.
 */

void ToggleMenuState(HWND hWnd, BOOL fLoggedOn)
{
    EnableMenuItem (GetMenu (hWnd), IDM_LOGOFF,   !fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_COMPOSE,  !fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_READ,     !fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_SEND,     !fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_ADDRBOOK, !fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_DETAILS,  !fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_LOGON,    fLoggedOn);
    EnableMenuItem (GetMenu (hWnd), IDM_EXIT,           FALSE);
}

//
//  SecureMenu
//
//  Purpose:
//      Enables/Disables Logon and Exit menu items.
//      CMCLogon might yield control to Windows, so the user might be able to
//      access the window menu (for example click Logon) after we call
//      MAPILogon, but before it returns.
//
//  Parameters:
//      hWnd            - handle to the window/dialog who called us
//      fBeforeLogon    - TRUE when this function is called when we are about
//                      to call MAPILogon, FALSE if called after logon (failed)
//                      if Logon succeddes ToggleMenuState is called instead of
//                      this function.
//
//  Return:
//      Void.
//


void SecureMenu(HWND hWnd, BOOL fBeforeLogon)
{
    EnableMenuItem (GetMenu (hWnd), IDM_LOGON, fBeforeLogon);
    EnableMenuItem (GetMenu (hWnd), IDM_EXIT,  fBeforeLogon);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\migrate\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\sample.cli\pvalloc.h ===
/*
 -  P V A L L O C . H
 -
 *  Purpose:
 *      Header file for sample memory manager.  Provides chained
 *      memory data structures.
 *
 */

#ifndef __PVALLOC_H__
#define __PVALLOC_H__

#ifdef __cplusplus
extern "C" {
#endif

#define pvNull NULL

typedef unsigned long CB;
typedef void FAR * PV;
typedef char FAR * SZ;
typedef BYTE FAR * PB;

/* Memory allocation node */

typedef struct
{
    HANDLE  hMem;
    CB      cbSize;
    PV      lpvNext;
    PV      lpvBuf;
    CB      ulBlockNum;
    unsigned long   ulAlignPad;
} PVINFO, * PPVINFO;

#define cbPvMax (65520L-sizeof(PVINFO))
#define cbPvMin (1024L-sizeof(PVINFO))

/* Memory manager function prototypes */

PV   PvAlloc(CB cbSize);
PV   PvAllocMore(CB cbSize, PV lpvParent);
BOOL PvFree(PV lpv);

#ifdef __cplusplus
}       /* extern "C" */
#endif

#endif  /* __PVALLOC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\sample.cli\pvalloc.c ===
/*
 -  P V A L L O C . C
 -
 *  Copyright (C) 1995 Microsoft Corporation
 *  Purpose:
 *      Implementation of a chained memory manager.
 *
 */

#include <string.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <pvalloc.h>

#undef _PVALLOC_LOG

#ifdef _PVALLOC_LOG
static CB       cbTotalAlloc    = 0;
static CB       ulTotalBlockNum = 0;
#endif




/*
 -  PvAlloc
 -
 *  Purpose:
 *      Allocates a chunk of memory on the global heap.
 *
 *  Parameters:
 *      cbSize          - Count of bytes requested.
 *
 *  Returns:
 *      lpv             - Pointer to the allocated memory
 *
 */

PV PvAlloc(CB cbSize)
{
    PV      lpv         = pvNull;
    HANDLE  hMem;
    PPVINFO ppvinfo;
#ifdef _PVALLOC_LOG
    char    szFileName[80];
    LPSTR   lpszTemp    = NULL;
    FILE    *pFile      = NULL;
    char    szBuff[128];
#endif

    /* Make sure allocations are in multiples of 4 */

    if(cbSize < 4)
        cbSize = 4;
    else if(cbSize & 3)
        cbSize += 4 - (cbSize & 3);

    /* Allocate the block */

    hMem = GlobalAlloc(GMEM_MOVEABLE, cbSize + sizeof(PVINFO));
    if(hMem)
    {
        ppvinfo = (PPVINFO)GlobalLock(hMem);
        ppvinfo->hMem    = hMem;
        ppvinfo->lpvNext = pvNull;
        ppvinfo->lpvBuf  = ((PB)ppvinfo) + sizeof(PVINFO);
#ifdef _PVALLOC_LOG
        ppvinfo->cbSize  = cbSize;
        ulTotalBlockNum++;
        ppvinfo->ulBlockNum = ulTotalBlockNum;
        cbTotalAlloc += cbSize;
        
        // log to file
        lpszTemp = getenv("TEMP");

        if(lpszTemp)
            strcpy(szFileName, lpszTemp);
        else
            strcpy(szFileName, "c:\\temp");

        strcat(szFileName, "\\pvalloc.log");

        
        pFile = fopen(szFileName,"a");
        if (pFile == NULL)     
            goto NoFile;      
//           return NULL;

        fprintf(pFile, "Block: \t%lu\tPvAlloc: %ld Bytes\t\tTotal: %ld Bytes\n",
                 ulTotalBlockNum, cbSize, cbTotalAlloc);

        if (pFile)
            fclose(pFile);
        
        // log to comm port
        wsprintf(szBuff,"Block: \t%lu\tPvAlloc: %ld Bytes\t\tTotal: %ld Bytes\n",
                 ulTotalBlockNum, cbSize, cbTotalAlloc);
        OutputDebugString(szBuff);
                        
NoFile:                           

#ifdef _WIN32
        memset(ppvinfo->lpvBuf, 0xaa, (size_t)cbSize);
#else
        _fmemset(ppvinfo->lpvBuf, 0xaa, (size_t)cbSize);
#endif  /* _WIN32 */

#endif  /* _PVALLOC_LOG */
        lpv = ppvinfo->lpvBuf;
    }

    return lpv;
}

/*
 -  PvAllocMore
 -
 *  Purpose:
 *      Allocates a chunk of memory and chains it to a parent block.
 *
 *  Parameters:
 *      cbSize          - Count of additional bytes to allocate
 *      lpvParent       - Pointer to parent in memory chain
 *
 *  Returns:
 *      lpv             - Pointer to the allocated memory
 *
 */

PV PvAllocMore(CB cbSize, PV lpvParent)
{
    PV          lpvStep = lpvParent;
    PV          lpv     = pvNull;
    PPVINFO     ppvinfoMore;
    HANDLE      hMem;
    PPVINFO     ppvinfo;

    /* Step to the last link */
    do
    {
        ppvinfoMore = (PPVINFO)(((PB)lpvStep) - sizeof(PVINFO));
        lpvStep = ppvinfoMore->lpvNext;
    }
    while(ppvinfoMore->lpvNext != pvNull);

    // beginning of section that was taken from PvAlloc

    if(cbSize < 4)
        cbSize = 4;
    else if(cbSize & 3)
        cbSize += 4 - (cbSize & 3);


    hMem = GlobalAlloc(GMEM_MOVEABLE, cbSize + sizeof(PVINFO));
    if(hMem)
    {
        ppvinfo = (PPVINFO)GlobalLock(hMem);
        ppvinfo->hMem       = hMem;
        ppvinfo->lpvNext    = pvNull;
        ppvinfo->lpvBuf     = ((PB)ppvinfo) + sizeof(PVINFO);
#ifdef _PVALLOC_LOG
        ppvinfo->cbSize     = cbSize;
        ppvinfo->ulBlockNum = ppvinfoMore->ulBlockNum;
        cbTotalAlloc += cbSize;

#ifdef _WIN32
        memset(ppvinfo->lpvBuf, 0xaa, (size_t)cbSize);
#else
        _fmemset(ppvinfo->lpvBuf, 0xaa, (size_t)cbSize);
#endif

#endif
        lpv = ppvinfo->lpvBuf;
    }
    else
        return lpv;
        
    // end of section taken from pvalloc

#ifdef _WIN32
        memset(lpv, 0xbb, (size_t)cbSize);
#else
        _fmemset(lpv, 0xbb, (size_t)cbSize);
#endif  /* _WIN32 */

    ppvinfoMore->lpvNext = lpv;

    return lpv;
}



/*
 -  PvFree
 -
 *  Purpose:
 *      This function frees memory allocated by PvAlloc or PvAllocMore.
 *      After the call, the pointer memory will be invalid and should
 *      not be referenced again.
 *      When memory is allocated by PvAlloc and PvAllocMore, which can
 *      contain several levels of pointers, all the application needs to
 *      do to free the entire structure is call this routine with the
 *      base pointer returned by the PvAlloc call.
 *
 *  Parameters:
 *      lpv             - Pointer to memory to be freed.
 *
 *  Returns:
 *      Void
 *
 */

BOOL PvFree(PV lpv)
{
    PPVINFO ppvinfo;
#ifdef _PVALLOC_LOG
    CB      cbSize;
    CB      ulBlockNum;
    FILE    *pFile  = NULL;
    CB      cbFree  = 0;
    CB      cbTotalBeforeFree = cbTotalAlloc;
    char    szFileName[80];
    LPSTR   lpszTemp    = NULL;
    char    szBuff[128];
#endif

    if(!lpv)
        return 0;

    ppvinfo = (PPVINFO)(((PB)lpv) - sizeof(PVINFO));

    while(ppvinfo)
    {
        lpv = ppvinfo->lpvNext;

#ifdef _PVALLOC_LOG
        cbSize      = ppvinfo->cbSize;
        cbFree      += ppvinfo->cbSize;
        ulBlockNum  = ppvinfo->ulBlockNum;

#ifdef _WIN32
        memset(ppvinfo->lpvBuf, 0xcc, (size_t)ppvinfo->cbSize);
#else
        _fmemset(ppvinfo->lpvBuf, 0xcc, (size_t)ppvinfo->cbSize);
#endif  /* _WIN32 */

#endif  /* _PVALLOC_LOG */

        if(GlobalUnlock(ppvinfo->hMem))
            goto err;  // Our lock count is non-zero

        if(GlobalFree(ppvinfo->hMem))
            goto err;  // Failure

#ifdef _PVALLOC_LOG
        cbTotalAlloc -= cbSize;
#endif

        if(lpv)
            ppvinfo = (PPVINFO)(((PB)lpv) - sizeof(PVINFO));
        else
            break;
    }


#ifdef _PVALLOC_LOG
    
    if((cbTotalBeforeFree - cbTotalAlloc) != cbFree)
       goto err;
       
    // log to file
    lpszTemp = getenv("TEMP");

    if(lpszTemp)
        strcpy(szFileName, lpszTemp);
    else
        strcpy(szFileName, "c:\\temp");

    strcat(szFileName, "\\pvalloc.log");
        
    pFile = fopen(szFileName,"a");
       
    if (pFile == NULL)
       goto err;

    fprintf(pFile, "Block: \t%lu\t\t***PvFree***,  Freeing  %lu Bytes(Alloc and AllocMore)\tUnFreed: %ld Bytes\n",
                    ulBlockNum, cbFree, cbTotalAlloc);
    if (pFile)
        fclose(pFile);

     // log to comm port
    wsprintf(szBuff,"Block: \t%lu\t\t***PvFree***,  Freeing  %lu Bytes(Alloc and AllocMore)\tUnFreed: %ld Bytes\n",
                    ulBlockNum, cbFree, cbTotalAlloc);
    OutputDebugString(szBuff);

#endif  /* _PVALLOC_LOG */

    return 0; // Success!

err:
#ifdef _PVALLOC_LOG

    // find file to open
    lpszTemp = getenv("TEMP");

    if(lpszTemp)
        strcpy(szFileName, lpszTemp);
    else
        strcpy(szFileName, "c:\\temp");

    strcat(szFileName, "\\pvalloc.log");

        
    pFile = fopen(szFileName,"a");

    if (pFile == NULL)
       return 1;

    fprintf(pFile, "Block: %lu Failure freeing: %ld Bytes\tUnFreed: %ld Bytes\n",
             ulBlockNum, cbSize, cbTotalAlloc);
    if (pFile)
        fclose(pFile);

#endif  /* _PVALLOC_LOG */

    return 1; // Failure!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\migrate\downoe5.cpp ===
// --------------------------------------------------------------------------------
// DownOE5.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "utility.h"
#include "migrate.h"
#include "migerror.h"
#include "structs.h"
#include "resource.h"
#include <oestore.h>
#include <mimeole.h>

const static BYTE rgbZero[4] = {0};

//--------------------------------------------------------------------------
// PFNREADTYPEDATA
//--------------------------------------------------------------------------
typedef void (APIENTRY *PFNREADTYPEDATA)(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs);

//--------------------------------------------------------------------------
// g_rgpfnReadTypeData
//--------------------------------------------------------------------------
extern const PFNREADTYPEDATA g_rgpfnReadTypeData[CDT_LASTTYPE];

//--------------------------------------------------------------------------
// ReadTypeData
//--------------------------------------------------------------------------
#define ReadTypeData(_pbSource, _cbLength, _pColumn, _pRecord, _pcPtrRefs) \
    (*(g_rgpfnReadTypeData[(_pColumn)->type]))(_pbSource, _cbLength, (_pColumn), _pRecord, _pcPtrRefs)

//--------------------------------------------------------------------------
inline void ReadTypeDataFILETIME(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(cbLength == sizeof(FILETIME));
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, sizeof(FILETIME));
}

//--------------------------------------------------------------------------
inline void ReadTypeDataFIXSTRA(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(cbLength == pColumn->cbSize);
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, pColumn->cbSize);
}

//--------------------------------------------------------------------------
inline void ReadTypeDataVARSTRA(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert((LPSTR)((LPBYTE)pbSource)[cbLength - 1] == '\0');
    *((LPSTR *)((LPBYTE)pRecord + pColumn->ofBinding)) = (LPSTR)((LPBYTE)pbSource);
    (*pcPtrRefs)++;
}

//--------------------------------------------------------------------------
inline void ReadTypeDataBYTE(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(cbLength == sizeof(BYTE));
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, sizeof(BYTE));
}

//--------------------------------------------------------------------------
inline void ReadTypeDataDWORD(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(cbLength == sizeof(DWORD));
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, sizeof(DWORD));
}

//--------------------------------------------------------------------------
inline void ReadTypeDataWORD(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(cbLength == sizeof(WORD));
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, sizeof(WORD));
}

//--------------------------------------------------------------------------
inline void ReadTypeDataSTREAM(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(cbLength == sizeof(FILEADDRESS));
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, sizeof(FILEADDRESS));
}

//--------------------------------------------------------------------------
inline void ReadTypeDataVARBLOB(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    LPBLOB pBlob = (LPBLOB)((LPBYTE)pRecord + pColumn->ofBinding);
    pBlob->cbSize = cbLength;
    if (pBlob->cbSize > 0) 
    { 
        pBlob->pBlobData = pbSource; 
        (*pcPtrRefs)++; 
    }
    else
        pBlob->pBlobData = NULL;
}

//--------------------------------------------------------------------------
inline void ReadTypeDataFIXBLOB(LPBYTE pbSource, DWORD cbLength, 
    LPCTABLECOLUMN pColumn, LPVOID pRecord, LPDWORD pcPtrRefs) 
{
    Assert(pColumn->cbSize == cbLength);
    CopyMemory((LPBYTE)pRecord + pColumn->ofBinding, pbSource, pColumn->cbSize);
}

//--------------------------------------------------------------------------
const PFNREADTYPEDATA g_rgpfnReadTypeData[CDT_LASTTYPE] = {
    (PFNREADTYPEDATA)ReadTypeDataFILETIME,
    (PFNREADTYPEDATA)ReadTypeDataFIXSTRA,
    (PFNREADTYPEDATA)ReadTypeDataVARSTRA,
    (PFNREADTYPEDATA)ReadTypeDataBYTE,
    (PFNREADTYPEDATA)ReadTypeDataDWORD,
    (PFNREADTYPEDATA)ReadTypeDataWORD,
    (PFNREADTYPEDATA)ReadTypeDataSTREAM,
    (PFNREADTYPEDATA)ReadTypeDataVARBLOB,
    (PFNREADTYPEDATA)ReadTypeDataFIXBLOB
};

// --------------------------------------------------------------------------------
// DowngradeReadMsgInfoV5
// --------------------------------------------------------------------------------
HRESULT DowngradeReadMsgInfoV5(LPRECORDBLOCKV5 pRecord, LPMESSAGEINFO pMsgInfo)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               i;
    DWORD               cColumns;
    DWORD               cbRead=0;
    DWORD               cbLength;
    DWORD               cbData;
    DWORD               cPtrRefs;
    LPBYTE              pbData;
    LPBYTE              pbSource;
    LPDWORD             prgdwOffset=(LPDWORD)((LPBYTE)pRecord + sizeof(RECORDBLOCKV5));

    // Trace
    TraceCall("DowngradeReadMsgInfoV5");

    // Set cbData
    cbData = (pRecord->cbRecord - sizeof(RECORDBLOCKV5) - (pRecord->cColumns * sizeof(DWORD)));

    // Allocate
    IF_NULLEXIT(pbData = (LPBYTE)g_pMalloc->Alloc(cbData));

    // Free This
    pMsgInfo->pvMemory = pbData;

    // Set pbData
    pbSource = (LPBYTE)((LPBYTE)pRecord + sizeof(RECORDBLOCKV5) + (pRecord->cColumns * sizeof(DWORD)));

    // Copy the data
    CopyMemory(pbData, pbSource, cbData);

    // Compute number of columns to read
    cColumns = min(pRecord->cColumns, MSGCOL_LASTID);

    // Read the Record
    for (i=0; i<cColumns; i++)
    {
        // Compute cbLength
        cbLength = (i + 1 == cColumns) ? (cbData - prgdwOffset[i]) : (prgdwOffset[i + 1] - prgdwOffset[i]);

        // Bad-Record
        if (prgdwOffset[i] != cbRead || cbRead + cbLength > cbData)
        {
            hr = TraceResult(MIGRATE_E_BADRECORDFORMAT);
            goto exit;
        }

        // ReadTypeData
        ReadTypeData(pbData + cbRead, cbLength, &g_MessageTableSchema.prgColumn[i], pMsgInfo, &cPtrRefs);

        // Increment cbRead
        cbRead += cbLength;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeLocalStoreFileV5
// --------------------------------------------------------------------------------
HRESULT DowngradeLocalStoreFileV5(MIGRATETOTYPE tyMigrate, LPFILEINFO pInfo, 
    LPMEMORYFILE pFile, LPPROGRESSINFO pProgress)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               cRecords=0;
    CHAR                szIdxPath[MAX_PATH + MAX_PATH];
    CHAR                szMbxPath[MAX_PATH + MAX_PATH];
    HANDLE              hIdxFile=NULL;
    HANDLE              hMbxFile=NULL;
    MESSAGEINFO         MsgInfo={0};
    IDXFILEHEADER       IdxHeader;
    MBXFILEHEADER       MbxHeader;
    MBXMESSAGEHEADER    MbxMessage;
    IDXMESSAGEHEADER    IdxMessage;
    LPRECORDBLOCKV5     pRecord;
    LPSTREAMBLOCK       pStmBlock;
    LPBYTE              pbData;
    DWORD               faRecord;
    DWORD               faIdxWrite;
    DWORD               faMbxWrite;
    DWORD               faStreamBlock;
    DWORD               cbAligned;
    DWORD               faMbxCurrent;
    LPTABLEHEADERV5     pHeader=(LPTABLEHEADERV5)pFile->pView;

    // Trace
    TraceCall("DowngradeLocalStoreFileV5");

    // Set idx path
    ReplaceExtension(pInfo->szFilePath, ".idx", szIdxPath, ARRAYSIZE(szIdxPath));

    // Set mbx path
    ReplaceExtension(pInfo->szFilePath, ".mbx", szMbxPath, ARRAYSIZE(szMbxPath));

    // Delete Both Files
    DeleteFile(szIdxPath);
    DeleteFile(szMbxPath);

    // Open the idx file
    hIdxFile = CreateFile(szIdxPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_FLAG_RANDOM_ACCESS | FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hIdxFile)
    {
        hIdxFile = NULL;
        hr = TraceResult(MIGRATE_E_CANTOPENFILE);
        goto exit;
    }

    // Initialize Idx Header
    ZeroMemory(&IdxHeader, sizeof(IDXFILEHEADER));
    IdxHeader.dwMagic = CACHEFILE_MAGIC;
    IdxHeader.ver = CACHEFILE_VER;
    IdxHeader.verBlob = 1; // this will force the .idx blobs to be rebuilt when imn 1.0 or oe v4.0 is run again

    // Write the header
    IF_FAILEXIT(hr = MyWriteFile(hIdxFile, 0, &IdxHeader, sizeof(IDXFILEHEADER)));

    // Open the mbx file
    hMbxFile = CreateFile(szMbxPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_FLAG_RANDOM_ACCESS | FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE == hMbxFile)
    {
        hMbxFile = NULL;
        hr = TraceResult(MIGRATE_E_CANTOPENFILE);
        goto exit;
    }

    // Initialize MBX Header
    ZeroMemory(&MbxHeader, sizeof(MBXFILEHEADER));
    MbxHeader.dwMagic = MSGFILE_MAGIC;
    MbxHeader.ver = MSGFILE_VER;

    // Write the header
    IF_FAILEXIT(hr = MyWriteFile(hMbxFile, 0, &MbxHeader, sizeof(MBXFILEHEADER)));

    // Set First Record
    faRecord = pHeader->faFirstRecord;

    // Set faIdxWrite
    faIdxWrite = sizeof(IDXFILEHEADER);

    // Set faMbxWrite
    faMbxWrite = sizeof(MBXFILEHEADER);

    // While we have a record
    while(faRecord)
    {
        // Bad Length
        if (faRecord + sizeof(RECORDBLOCKV5) > pFile->cbSize)
        {
            hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
            goto exit;
        }

        // Cast the Record
        pRecord = (LPRECORDBLOCKV5)((LPBYTE)pFile->pView + faRecord);

        // Invalid Record Signature
        if (faRecord != pRecord->faRecord)
        {
            hr = TraceResult(MIGRATE_E_BADRECORDSIGNATURE);
            goto exit;
        }

        // Bad Length
        if (faRecord + pRecord->cbRecord > pFile->cbSize)
        {
            hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
            goto exit;
        }

        // Load MsgInfo
        IF_FAILEXIT(hr = DowngradeReadMsgInfoV5(pRecord, &MsgInfo));

        // No Stream ?
        if (0 == MsgInfo.faStream)
            goto NextRecord;

        // Set msgidLast
        if ((DWORD)MsgInfo.idMessage > MbxHeader.msgidLast)
            MbxHeader.msgidLast = (DWORD)MsgInfo.idMessage;

        // Zero Out the Message Structures
        ZeroMemory(&MbxMessage, sizeof(MBXMESSAGEHEADER));
        ZeroMemory(&IdxMessage, sizeof(IDXMESSAGEHEADER));

        // Fill MbxMessage
        MbxMessage.dwMagic = MSGHDR_MAGIC;
        MbxMessage.msgid = (DWORD)MsgInfo.idMessage;

        // Fixup the Flags
        if (FALSE == ISFLAGSET(MsgInfo.dwFlags, ARF_READ))
            FLAGSET(IdxMessage.dwState, MSG_UNREAD);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_VOICEMAIL))
            FLAGSET(IdxMessage.dwState, MSG_VOICEMAIL);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_REPLIED))
            FLAGSET(IdxMessage.dwState, MSG_REPLIED);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_FORWARDED))
            FLAGSET(IdxMessage.dwState, MSG_FORWARDED);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_FLAGGED))
            FLAGSET(IdxMessage.dwState, MSG_FLAGGED);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_RCPTSENT))
            FLAGSET(IdxMessage.dwState, MSG_RCPTSENT);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_NOSECUI))
            FLAGSET(IdxMessage.dwState, MSG_NOSECUI);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_NEWSMSG))
            FLAGSET(IdxMessage.dwState, MSG_NEWSMSG);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_UNSENT))
            FLAGSET(IdxMessage.dwState, MSG_UNSENT);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_SUBMITTED))
            FLAGSET(IdxMessage.dwState, MSG_SUBMITTED);
        if (ISFLAGSET(MsgInfo.dwFlags, ARF_RECEIVED))
            FLAGSET(IdxMessage.dwState, MSG_RECEIVED);

        // Save faMbxCurrent
        faMbxCurrent = faMbxWrite;

        // Validate alignment
        Assert((faMbxCurrent % 4) == 0);

        // Write the mbx header
        IF_FAILEXIT(hr = MyWriteFile(hMbxFile, faMbxCurrent, &MbxMessage, sizeof(MBXMESSAGEHEADER)));

        // Increment faMbxWrite
        faMbxWrite += sizeof(MBXMESSAGEHEADER);

        // Initialize dwMsgSize
        MbxMessage.dwMsgSize = sizeof(MBXMESSAGEHEADER);

        // Set faStreamBlock
        faStreamBlock = MsgInfo.faStream;

        // While we have stream block
        while(faStreamBlock)
        {
            // Bad Length
            if (faStreamBlock + sizeof(STREAMBLOCK) > pFile->cbSize)
            {
                hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
                goto exit;
            }

            // Cast the Record
            pStmBlock = (LPSTREAMBLOCK)((LPBYTE)pFile->pView + faStreamBlock);

            // Invalid Record Signature
            if (faStreamBlock != pStmBlock->faThis)
            {
                hr = TraceResult(MIGRATE_E_BADSTREAMBLOCKSIGNATURE);
                goto exit;
            }

            // Bad Length
            if (faStreamBlock + pStmBlock->cbBlock > pFile->cbSize)
            {
                hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
                goto exit;
            }

            // Set pbData
            pbData = (LPBYTE)((LPBYTE)(pStmBlock) + sizeof(STREAMBLOCK));

            // Write into the stream
            IF_FAILEXIT(hr = MyWriteFile(hMbxFile, faMbxWrite, pbData, pStmBlock->cbData));

            // Increment dwBodySize
            MbxMessage.dwBodySize += pStmBlock->cbData;

            // Increment dwMsgSize
            MbxMessage.dwMsgSize += pStmBlock->cbData;

            // Increment faMbxWrite
            faMbxWrite += pStmBlock->cbData;

            // Goto Next Block
            faStreamBlock = pStmBlock->faNext;
        }

        // Pad the Message on a dword boundary
        cbAligned = (faMbxWrite % 4);

        // cbAligned ?
        if (cbAligned)
        {
            // Reset cbAligned
            cbAligned = 4 - cbAligned;

            // Write the mbx header
            IF_FAILEXIT(hr = MyWriteFile(hMbxFile, faMbxWrite, (LPVOID)rgbZero, cbAligned));

            // Increment faMbxWrite
            faMbxWrite += cbAligned;

            // Increment 
            MbxMessage.dwMsgSize += cbAligned;
        }

        // Validate alignment
        Assert((faMbxWrite % 4) == 0);

        // Write the mbx header again
        IF_FAILEXIT(hr = MyWriteFile(hMbxFile, faMbxCurrent, &MbxMessage, sizeof(MBXMESSAGEHEADER)));

        // Fill IdxMessage
        IdxMessage.dwLanguage = (DWORD)MAKELONG(MsgInfo.wLanguage, MsgInfo.wHighlight);
        IdxMessage.msgid = (DWORD)MsgInfo.idMessage;
        IdxMessage.dwOffset = faMbxCurrent;
        IdxMessage.dwMsgSize = MbxMessage.dwMsgSize;
        IdxMessage.dwHdrOffset = 0;
        IdxMessage.dwSize = sizeof(IDXMESSAGEHEADER);
        IdxMessage.dwHdrSize = 0;
        IdxMessage.rgbHdr[4] = 0;

        // Write the mbx header
        IF_FAILEXIT(hr = MyWriteFile(hIdxFile, faIdxWrite, &IdxMessage, sizeof(IDXMESSAGEHEADER)));

        // Increment faIdxWrite
        faIdxWrite += IdxMessage.dwSize;

        // Increment cRecords
        cRecords++;

NextRecord:
        // Progress
        IncrementProgress(pProgress, pInfo);

        // Cleanup
        SafeMemFree(MsgInfo.pvMemory);

        // Goto Next
        faRecord = pRecord->faNext;
    }

    // Set the Record Counts
    MbxHeader.cMsg = cRecords;
    IdxHeader.cMsg = cRecords;

    // Set the Flags
    IdxHeader.dwFlags = 1; // STOREINIT_MAIL
    MbxHeader.dwFlags = 1; // STOREINIT_MAIL

    // Get the Size of the idx file
    IdxHeader.cbValid = ::GetFileSize(hIdxFile, NULL);
    if (0xFFFFFFFF == IdxHeader.cbValid)
    {
        hr = TraceResult(MIGRATE_E_CANTGETFILESIZE);
        goto exit;
    }

    // Get the Size of the mbx file
    MbxHeader.cbValid = ::GetFileSize(hMbxFile, NULL);
    if (0xFFFFFFFF == MbxHeader.cbValid)
    {
        hr = TraceResult(MIGRATE_E_CANTGETFILESIZE);
        goto exit;
    }

    // Write the header
    IF_FAILEXIT(hr = MyWriteFile(hIdxFile, 0, &IdxHeader, sizeof(IDXFILEHEADER)));

    // Write the header
    IF_FAILEXIT(hr = MyWriteFile(hMbxFile, 0, &MbxHeader, sizeof(MBXFILEHEADER)));

exit:
    // Cleanup
    SafeCloseHandle(hIdxFile);
    SafeCloseHandle(hMbxFile);
    SafeMemFree(MsgInfo.pvMemory);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeRecordV5
// --------------------------------------------------------------------------------
HRESULT DowngradeRecordV5(MIGRATETOTYPE tyMigrate, LPFILEINFO pInfo, 
    LPMEMORYFILE pFile, LPCHAINNODEV5 pNode, LPDWORD pcbRecord)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               cbRecord=0;
    DWORD               cbOffsets;
    DWORD               cbData;
    DWORD               cb;
    LPBYTE              pbData;
    LPBYTE              pbStart;
    MESSAGEINFO             MsgInfo={0};
    RECORDBLOCKV5B1     RecordOld;
    LPRECORDBLOCKV5     pRecord;

    // Trace
    TraceCall("DowngradeRecordV5");

    // Invalid
    if (pNode->faRecord + sizeof(RECORDBLOCKV5) > pFile->cbSize || 0 == pNode->faRecord)
        return TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);

    // Access the Record
    pRecord = (LPRECORDBLOCKV5((LPBYTE)pFile->pView + pNode->faRecord));

    // Bad Record
    if (pRecord->faRecord != pNode->faRecord)
        return TraceResult(MIGRATE_E_BADRECORDSIGNATURE);

    // Invalid
    if (pNode->faRecord + sizeof(RECORDBLOCKV5) + pRecord->cbRecord > pFile->cbSize)
        return TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);

    // Fill an old record header
    RecordOld.faRecord = pRecord->faRecord;
    RecordOld.faNext = pRecord->faNext;
    RecordOld.faPrevious = pRecord->faPrevious;

    // Reformat the record
    if (FILE_IS_NEWS_MESSAGES == pInfo->tyFile || FILE_IS_IMAP_MESSAGES == pInfo->tyFile)
    {
        // Read the v5 record into a msginfo structure
        IF_FAILEXIT(hr = DowngradeReadMsgInfoV5(pRecord, &MsgInfo));
    }

    // Compute offset table length
    cbOffsets = (pRecord->cColumns * sizeof(DWORD));

    // Cast the datablock
    pbData = ((LPBYTE)pRecord + sizeof(RECORDBLOCKV5B1));

    // Set Size
    cbData = (pRecord->cbRecord - cbOffsets - sizeof(RECORDBLOCKV5));

    // Remove the Offset Table
    MoveMemory(pbData, ((LPBYTE)pRecord + sizeof(RECORDBLOCKV5) + cbOffsets), cbData);

    // Reformat the record
    if (FILE_IS_NEWS_MESSAGES == pInfo->tyFile || FILE_IS_IMAP_MESSAGES == pInfo->tyFile)
    {
        // Set pbStart
        pbStart = pbData;

        // DWORD - idMessage
        CopyMemory(pbData, &MsgInfo.idMessage, sizeof(MsgInfo.idMessage));
        pbData += sizeof(MsgInfo.idMessage);

        // VERSION - dwFlags
        if (IMSG_PRI_HIGH == MsgInfo.wPriority)
            FLAGSET(MsgInfo.dwFlags, 0x00000200);
        else if (IMSG_PRI_LOW == MsgInfo.wPriority)
            FLAGSET(MsgInfo.dwFlags, 0x00000100);

        // VERSION - Normalized Subject -  
        if (lstrcmpi(MsgInfo.pszSubject, MsgInfo.pszNormalSubj) != 0)
            MsgInfo.dwFlags = (DWORD)MAKELONG(MsgInfo.dwFlags, MAKEWORD(0, 4));

        // DWORD - dwFlags
        CopyMemory(pbData, &MsgInfo.dwFlags, sizeof(MsgInfo.dwFlags));
        pbData += sizeof(MsgInfo.dwFlags);

        // FILETIME - ftSent
        CopyMemory(pbData, &MsgInfo.ftSent, sizeof(MsgInfo.ftSent));
        pbData += sizeof(MsgInfo.ftSent);

        // DWORD - cLines
        CopyMemory(pbData, &MsgInfo.cLines, sizeof(MsgInfo.cLines));
        pbData += sizeof(MsgInfo.cLines);

        // DWORD - faStream
        CopyMemory(pbData, &MsgInfo.faStream, sizeof(MsgInfo.faStream));
        pbData += sizeof(MsgInfo.faStream);

        // VERSION - DWORD - cbArticle 
        CopyMemory(pbData, &MsgInfo.cbMessage, sizeof(MsgInfo.cbMessage));
        pbData += sizeof(MsgInfo.cbMessage);

        // FILETIME - ftDownloaded
        CopyMemory(pbData, &MsgInfo.ftDownloaded, sizeof(MsgInfo.ftDownloaded));
        pbData += sizeof(MsgInfo.ftDownloaded);

        // LPSTR - pszMessageId
        cb = lstrlen(MsgInfo.pszMessageId) + 1;
        CopyMemory(pbData, MsgInfo.pszMessageId, cb);
        pbData += cb;

        // LPSTR - pszSubject
        cb = lstrlen(MsgInfo.pszSubject) + 1;
        CopyMemory(pbData, MsgInfo.pszSubject, cb);
        pbData += cb;

        // LPSTR - pszFromHeader
        cb = lstrlen(MsgInfo.pszFromHeader) + 1;
        CopyMemory(pbData, MsgInfo.pszFromHeader, cb);
        pbData += cb;

        // LPSTR - pszReferences
        cb = lstrlen(MsgInfo.pszReferences) + 1;
        CopyMemory(pbData, MsgInfo.pszReferences, cb);
        pbData += cb;

        // LPSTR - pszXref
        cb = lstrlen(MsgInfo.pszXref) + 1;
        CopyMemory(pbData, MsgInfo.pszXref, cb);
        pbData += cb;

        // LPSTR - pszServer
        cb = lstrlen(MsgInfo.pszServer) + 1;
        CopyMemory(pbData, MsgInfo.pszServer, cb);
        pbData += cb;

        // LPSTR - pszDisplayFrom
        cb = lstrlen(MsgInfo.pszDisplayFrom) + 1;
        CopyMemory(pbData, MsgInfo.pszDisplayFrom, cb);
        pbData += cb;

        // LPSTR - pszEmailFrom
        cb = lstrlen(MsgInfo.pszEmailFrom) + 1;
        CopyMemory(pbData, MsgInfo.pszEmailFrom, cb);
        pbData += cb;

        // Going to V4 ?
        if (DOWNGRADE_V5_TO_V4 == tyMigrate)
        {
            // WORD - wLanguage
            CopyMemory(pbData, &MsgInfo.wLanguage, sizeof(MsgInfo.wLanguage));
            pbData += sizeof(MsgInfo.wLanguage);

            // WORD - wReserved
            MsgInfo.wHighlight = 0;
            CopyMemory(pbData, &MsgInfo.wHighlight, sizeof(MsgInfo.wHighlight));
            pbData += sizeof(MsgInfo.wHighlight);

            // DWORD - cbMessage
            CopyMemory(pbData, &MsgInfo.cbMessage, sizeof(MsgInfo.cbMessage));
            pbData += sizeof(MsgInfo.cbMessage);

            // DWORD - ftReceived
            CopyMemory(pbData, &MsgInfo.ftReceived, sizeof(MsgInfo.ftReceived));
            pbData += sizeof(MsgInfo.ftReceived);

            // LPSTR - pszDisplayTo
            cb = lstrlen(MsgInfo.pszDisplayTo) + 1;
            CopyMemory(pbData, MsgInfo.pszDisplayTo, cb);
            pbData += cb;
        }

        // Add on Reserved
        cbRecord = (40 + sizeof(RECORDBLOCKV5B1) + (pbData - pbStart));

        // Better be smaller
        Assert(cbRecord <= pRecord->cbRecord);
    }

    // Otherwise, much easier
    else
    {
        // Set Size
        cbRecord = (pRecord->cbRecord - cbOffsets - sizeof(RECORDBLOCKV5)) + sizeof(RECORDBLOCKV5B1);
    }

    // Set the Record Size
    RecordOld.cbRecord = cbRecord;

    // Write the new record header
    CopyMemory((LPBYTE)pRecord, &RecordOld, sizeof(RECORDBLOCKV5B1));

    // Return size
    *pcbRecord = cbRecord;

exit:
    // Cleanup
    SafeMemFree(MsgInfo.pvMemory);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeIndexV5
// --------------------------------------------------------------------------------
HRESULT DowngradeIndexV5(MIGRATETOTYPE tyMigrate, LPFILEINFO pInfo, 
    LPMEMORYFILE pFile, LPPROGRESSINFO pProgress, DWORD faRootChain, DWORD faChain)
{
    // Locals
    HRESULT             hr=S_OK;
    LONG                i;
    LPCHAINBLOCKV5      pChain;
    CHAINBLOCKV5B1      ChainOld;
    DWORD               cbRecord;

    // Trace
    TraceCall("DowngradeIndexV5");

    // Nothing to validate
    if (0 == faChain)
        return S_OK;

    // Out-of-bounds
    if (faChain + CB_CHAIN_BLOCKV5 > pFile->cbSize)
        return TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);

    // De-ref the block
    pChain = (LPCHAINBLOCKV5)((LPBYTE)pFile->pView + faChain);

    // Out-of-Bounds
    if (pChain->faStart != faChain)
        return TraceResult(MIGRATE_E_BADCHAINSIGNATURE);

    // Too many nodes
    if (pChain->cNodes > BTREE_ORDER)
        return TraceResult(MIGRATE_E_TOOMANYCHAINNODES);

    // Validate Minimum Filled Constraint
    if (pChain->cNodes < BTREE_MIN_CAP && pChain->faStart != faRootChain)
        return TraceResult(MIGRATE_E_BADMINCAPACITY);

    // Go to the left
    IF_FAILEXIT(hr = DowngradeIndexV5(tyMigrate, pInfo, pFile, pProgress, faRootChain, pChain->faLeftChain));

    // Convert pChain to ChainOld
    ChainOld.faStart = pChain->faStart;
    ChainOld.cNodes = pChain->cNodes;
    ChainOld.faLeftChain = pChain->faLeftChain;

    // Loop throug right chains
    for (i=0; i<pChain->cNodes; i++)
    {
        // Bump Progress
        IncrementProgress(pProgress, pInfo);

        /// Downgrad this record
        IF_FAILEXIT(hr = DowngradeRecordV5(tyMigrate, pInfo, pFile, &pChain->rgNode[i], &cbRecord));

        // Update Old Node
        ChainOld.rgNode[i].faRecord = pChain->rgNode[i].faRecord;
        ChainOld.rgNode[i].cbRecord = cbRecord;
        ChainOld.rgNode[i].faRightChain = pChain->rgNode[i].faRightChain;

        // Validate the Right Chain
        IF_FAILEXIT(hr = DowngradeIndexV5(tyMigrate, pInfo, pFile, pProgress, faRootChain, pChain->rgNode[i].faRightChain));
    }

    // Write this new chain
    CopyMemory((LPBYTE)pChain, &ChainOld, CB_CHAIN_BLOCKV5B1);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeFileV5
// --------------------------------------------------------------------------------
HRESULT DowngradeFileV5(MIGRATETOTYPE tyMigrate, LPFILEINFO pInfo, 
    LPPROGRESSINFO pProgress)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    TABLEHEADERV5       HeaderV5;
    LPTABLEHEADERV5B1   pHeaderV5B1;
    CHAR                szDstFile[MAX_PATH + MAX_PATH];

    // Trace
    TraceCall("DowngradeFileV5");

    // Local message file
    if (FILE_IS_LOCAL_MESSAGES == pInfo->tyFile)
    {
        // Get the File Header
        IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

        // UpgradeLocalStoreFileV5
        IF_FAILEXIT(hr = DowngradeLocalStoreFileV5(tyMigrate, pInfo, &File, pProgress));
    }

    // Old News or Imap file
    else
    {
        // Create xxx.nch file
        if (FILE_IS_POP3UIDL == pInfo->tyFile)
            ReplaceExtension(pInfo->szFilePath, ".dat", szDstFile, ARRAYSIZE(szDstFile));
        else
            ReplaceExtension(pInfo->szFilePath, ".nch", szDstFile, ARRAYSIZE(szDstFile));

        // Copy the file
        if (0 == CopyFile(pInfo->szFilePath, szDstFile, FALSE))
        {
            hr = TraceResult(MIGRATE_E_CANTCOPYFILE);
            goto exit;
        }

        // Get the File Header
        IF_FAILEXIT(hr = OpenMemoryFile(szDstFile, &File));

        // Copy Table Header
        CopyMemory(&HeaderV5, (LPBYTE)File.pView, sizeof(TABLEHEADERV5));

        // De-Ref the header
        pHeaderV5B1 = (LPTABLEHEADERV5B1)File.pView;

        // Fixup the Header
        ZeroMemory(pHeaderV5B1, sizeof(TABLEHEADERV5B1));
        pHeaderV5B1->dwSignature = HeaderV5.dwSignature;
        pHeaderV5B1->wMajorVersion = (WORD)HeaderV5.dwMajorVersion;
        pHeaderV5B1->faRootChain = HeaderV5.rgfaIndex[0];
        pHeaderV5B1->faFreeRecordBlock = HeaderV5.faFreeRecordBlock;
        pHeaderV5B1->faFirstRecord = HeaderV5.faFirstRecord;
        pHeaderV5B1->faLastRecord = HeaderV5.faLastRecord;
        pHeaderV5B1->cRecords = HeaderV5.cRecords;
        pHeaderV5B1->cbAllocated = HeaderV5.cbAllocated;
        pHeaderV5B1->cbFreed = HeaderV5.cbFreed;
        pHeaderV5B1->dwReserved1 = 0;
        pHeaderV5B1->dwReserved2 = 0;
        pHeaderV5B1->cbUserData = HeaderV5.cbUserData;
        pHeaderV5B1->cDeletes = 0;
        pHeaderV5B1->cInserts = 0;
        pHeaderV5B1->cActiveThreads = 0;
        pHeaderV5B1->dwReserved3 = 0;
        pHeaderV5B1->cbStreams = HeaderV5.cbStreams;
        pHeaderV5B1->faFreeStreamBlock = HeaderV5.faFreeStreamBlock;
        pHeaderV5B1->faFreeChainBlock = HeaderV5.faFreeChainBlock;
        pHeaderV5B1->faNextAllocate = HeaderV5.faNextAllocate;
        pHeaderV5B1->dwNextId = HeaderV5.dwNextId;
	    pHeaderV5B1->AllocateRecord = HeaderV5.AllocateRecord;
	    pHeaderV5B1->AllocateChain = HeaderV5.AllocateChain;
	    pHeaderV5B1->AllocateStream = HeaderV5.AllocateStream;
        pHeaderV5B1->fCorrupt = FALSE;
        pHeaderV5B1->fCorruptCheck = TRUE;

        // DowngradeIndexV5
        IF_FAILEXIT(hr = DowngradeIndexV5(tyMigrate, pInfo, &File, pProgress, pHeaderV5B1->faRootChain, pHeaderV5B1->faRootChain));

        // Reset the version
        pHeaderV5B1->wMajorVersion = OBJECTDB_VERSION_PRE_V5;

        // Set the Minor Version
        if (FILE_IS_NEWS_MESSAGES == pInfo->tyFile || FILE_IS_IMAP_MESSAGES == pInfo->tyFile)
            pHeaderV5B1->wMinorVersion = ACACHE_VERSION_PRE_V5;

        // Folder cache version
        else if (FILE_IS_LOCAL_FOLDERS == pInfo->tyFile || FILE_IS_IMAP_FOLDERS == pInfo->tyFile)
            pHeaderV5B1->wMinorVersion = FLDCACHE_VERSION_PRE_V5;

        // UIDL Cache Version
        else if (FILE_IS_POP3UIDL == pInfo->tyFile)
            pHeaderV5B1->wMinorVersion = UIDCACHE_VERSION_PRE_V5;

        // Bad mojo
        else
            Assert(FALSE);
    }

exit:
    // Cleanup
    CloseMemoryFile(&File);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeProcessFileListV5
// --------------------------------------------------------------------------------
HRESULT DowngradeProcessFileListV5(LPFILEINFO pHead, LPDWORD pcMax, LPDWORD pcbNeeded)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    LPFILEINFO          pCurrent;
    LPTABLEHEADERV5     pHeader;

    // Trace
    TraceCall("DowngradeProcessFileListV5");

    // Invalid Arg
    Assert(pHead);

    // Init
    *pcMax = 0;
    *pcbNeeded = 0;

    // Loop
    for (pCurrent=pHead; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Get the File Header
        hr = OpenMemoryFile(pCurrent->szFilePath, &File);

        // Failure ?
        if (FAILED(hr))
        {
            // Don't Migrate
            pCurrent->fMigrate = FALSE;

            // Set hrMigrate
            pCurrent->hrMigrate = hr;

            // Reset hr
            hr = S_OK;

            // Get the LastError
            pCurrent->dwLastError = GetLastError();

            // Goto Next
            goto NextFile;
        }

        // De-Ref the header
        pHeader = (LPTABLEHEADERV5)File.pView;

        // Check the Signature...
        if (File.cbSize < sizeof(TABLEHEADERV5) || OBJECTDB_SIGNATURE != pHeader->dwSignature || OBJECTDB_VERSION_V5 != pHeader->dwMajorVersion)
        {
            // Not a file that should be migrate
            pCurrent->fMigrate = FALSE;

            // Set hrMigrate
            pCurrent->hrMigrate = MIGRATE_E_BADVERSION;

            // Goto Next
            goto NextFile;
        }

        // Save the Number of record
        pCurrent->cRecords = pHeader->cRecords;

        // Initialize counters
        InitializeCounters(&File, pCurrent, pcMax, pcbNeeded, FALSE);

        // Yes, Migrate
        pCurrent->fMigrate = TRUE;

NextFile:
        // Close the File
        CloseMemoryFile(&File);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeDeleteFilesV5
// --------------------------------------------------------------------------------
void DowngradeDeleteFilesV5(LPFILEINFO pHeadFile)
{
    // Locals
    CHAR            szDstFile[MAX_PATH + MAX_PATH];
    LPFILEINFO      pCurrent;

    // Trace
    TraceCall("DowngradeDeleteFilesV5");

    // Delete all files
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Succeeded
        Assert(SUCCEEDED(pCurrent->hrMigrate));

        // Delete the file
        DeleteFile(pCurrent->szFilePath);
    }

    // Done
    return;
}

// --------------------------------------------------------------------------------
// DowngradeDeleteIdxMbxNchDatFilesV5
// --------------------------------------------------------------------------------
void DowngradeDeleteIdxMbxNchDatFilesV5(LPFILEINFO pHeadFile)
{
    // Locals
    CHAR            szDstFile[MAX_PATH + MAX_PATH];
    LPFILEINFO      pCurrent;

    // Trace
    TraceCall("DowngradeDeleteIdxMbxNchDatFilesV5");

    // Delete all old files
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // If local message file, need to delete the idx file
        if (FILE_IS_LOCAL_MESSAGES == pCurrent->tyFile)
        {
            // Replace file extension
            ReplaceExtension(pCurrent->szFilePath, ".idx", szDstFile, ARRAYSIZE(szDstFile));

            // Delete the file
            DeleteFile(szDstFile);

            // Replace file extension
            ReplaceExtension(pCurrent->szFilePath, ".mbx", szDstFile, ARRAYSIZE(szDstFile));

            // Delete the file
            DeleteFile(szDstFile);
        }

        // Otherwise, pop3uidl.dat
        else if (FILE_IS_POP3UIDL == pCurrent->tyFile)
        {
            // Replace file extension
            ReplaceExtension(pCurrent->szFilePath, ".dat", szDstFile, ARRAYSIZE(szDstFile));

            // Delete the file
            DeleteFile(szDstFile);
        }

        // Otherwise, it has a .nch extension
        else
        {
            // Replace file extension
            ReplaceExtension(pCurrent->szFilePath, ".nch", szDstFile, ARRAYSIZE(szDstFile));

            // Delete the file
            DeleteFile(szDstFile);
        }
    }

    // Done
    return;
}

// --------------------------------------------------------------------------------
// DowngradeV5
// --------------------------------------------------------------------------------
HRESULT DowngradeV5(MIGRATETOTYPE tyMigrate, LPCSTR pszStoreRoot,
    LPPROGRESSINFO pProgress, LPFILEINFO *ppHeadFile)
{
    // Locals
    HRESULT         hr=S_OK;
    ENUMFILEINFO    EnumInfo={0};
    LPFILEINFO      pCurrent;
    DWORD           cbNeeded;
    DWORDLONG       dwlFree;

    // Trace
    TraceCall("DowngradeV5");

    // Initialize
    *ppHeadFile = NULL;

    // Setup the EnumFile Info
    EnumInfo.pszExt = ".dbx";
    EnumInfo.pszFoldFile = "folders.dbx";
    EnumInfo.pszUidlFile = "pop3uidl.dbx";

    // Enumerate All ODB files in szStoreRoot...
    IF_FAILEXIT(hr = EnumerateStoreFiles(pszStoreRoot, DIR_IS_ROOT, NULL, &EnumInfo, ppHeadFile));

    // Compute some Counts, and validate that the files are valid to migrate...
    IF_FAILEXIT(hr = DowngradeProcessFileListV5(*ppHeadFile, &pProgress->cMax, &cbNeeded));

    // Delete all source files
    DowngradeDeleteIdxMbxNchDatFilesV5(*ppHeadFile);

    // Enought DiskSpace ?
    IF_FAILEXIT(hr = GetAvailableDiskSpace(pszStoreRoot, &dwlFree));

    // Not Enought Diskspace
    if (((DWORDLONG) cbNeeded) > dwlFree)
    {
        // cbNeeded is DWORD and in this case we can downgrade dwlFree to DWORD
        g_cbDiskNeeded = cbNeeded; g_cbDiskFree = ((DWORD) dwlFree);
        hr = TraceResult(MIGRATE_E_NOTENOUGHDISKSPACE);
        goto exit;
    }

    // Loop through the files and migrate each one
    for (pCurrent=*ppHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Migrate this file ?
        if (pCurrent->fMigrate)
        {
            // Set Progress File
            SetProgressFile(pProgress, pCurrent);

            // Downgrade the file
            hr = pCurrent->hrMigrate = DowngradeFileV5(tyMigrate, pCurrent, pProgress);

            // Failure ?
            if (FAILED(pCurrent->hrMigrate))
            {
                // Set Last Error
                pCurrent->dwLastError = GetLastError();

                // Done
                break;
            }
        }
    }

    // Failure, delete all destination files
    if (FAILED(hr))
    {
        // Delete.idx, .mbx and .nch fles
        DowngradeDeleteIdxMbxNchDatFilesV5(*ppHeadFile);
    }

    // Otherwise, delete source files
    else
    {
        // Delete all source files
        DowngradeDeleteFilesV5(*ppHeadFile);
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\sample.cli\smapi.h ===
/*
 -  S M A P I . H
 -
 *  Purpose:
 *      Header file for Simple MAPI definitions.
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPI_H
#include <mapi.h>
#endif

extern HINSTANCE    hlibMAPI;

extern LPMAPILOGON lpfnMAPILogon;
extern LPMAPILOGOFF lpfnMAPILogoff;
extern LPMAPISENDMAIL lpfnMAPISendMail;
extern LPMAPISENDDOCUMENTS lpfnMAPISendDocuments;
extern LPMAPIFINDNEXT lpfnMAPIFindNext;
extern LPMAPIREADMAIL lpfnMAPIReadMail;
extern LPMAPISAVEMAIL lpfnMAPISaveMail;
extern LPMAPIDELETEMAIL lpfnMAPIDeleteMail;
extern LPMAPIFREEBUFFER lpfnMAPIFreeBuffer;
extern LPMAPIADDRESS lpfnMAPIAddress;
extern LPMAPIDETAILS lpfnMAPIDetails;
extern LPMAPIRESOLVENAME lpfnMAPIResolveName;

#undef MAPILogon
#undef MAPILogoff
#undef MAPISendMail
#undef MAPISendDocuments
#undef MAPIFindNext
#undef MAPIReadMail
#undef MAPISaveMail
#undef MAPIDeleteMail
#undef MAPIFreeBuffer
#undef MAPIAddress
#undef MAPIDetails
#undef MAPIResolveName
#define MAPILogon           (*lpfnMAPILogon)
#define MAPILogoff          (*lpfnMAPILogoff)
#define MAPISendMail        (*lpfnMAPISendMail)
#define MAPISendDocuments   (*lpfnMAPISendDocuments)
#define MAPIFindNext        (*lpfnMAPIFindNext)
#define MAPIReadMail        (*lpfnMAPIReadMail)
#define MAPISaveMail        (*lpfnMAPISaveMail)
#define MAPIDeleteMail      (*lpfnMAPIDeleteMail)
#define MAPIFreeBuffer      (*lpfnMAPIFreeBuffer)
#define MAPIAddress         (*lpfnMAPIAddress)
#define MAPIDetails         (*lpfnMAPIDetails)
#define MAPIResolveName     (*lpfnMAPIResolveName)

extern BOOL InitSimpleMAPI(void);
extern void DeinitSimpleMAPI(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\migrate\migrate.h ===
// --------------------------------------------------------------------------------
// Migrate.h
// --------------------------------------------------------------------------------
#ifndef __MIGRATE_H
#define __MIGRATE_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "utility.h"

// --------------------------------------------------------------------------------
// MIGRATETOTYPE
// --------------------------------------------------------------------------------
typedef enum tagMIGRATETOTYPE {
    DOWNGRADE_V5B1_TO_V1,
    DOWNGRADE_V5B1_TO_V4,
    UPGRADE_V1_OR_V4_TO_V5,
    DOWNGRADE_V5_TO_V1,
    DOWNGRADE_V5_TO_V4
} MIGRATETOTYPE;

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern IMalloc          *g_pMalloc;
extern HINSTANCE         g_hInst;
extern DWORD             g_cbDiskNeeded;
extern DWORD             g_cbDiskFree;
extern ACCOUNTTABLE      g_AcctTable;

#endif // __MIGRATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\sample.cli\_scode.h ===
/*
 *  _ S C O D E . H
 *
 *  Status Codes returned by MAPI routines
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _SCODE_H
#define _SCODE_H

/* Define S_OK and ITF_* */

#ifdef _WIN32
#include <winerror.h>
#endif

/*
 *  MAPI Status codes follow the style of OLE 2.0 sCodes as defined in the
 *  OLE 2.0 Programmer's Reference and header file scode.h (Windows 3.x)
 *  or winerror.h (Windows NT and Windows 95).
 *
 */

/*  On Windows 3.x, status codes have 32-bit values as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+---------------------+-------+-------------------------------+
 *  |S|       Context       | Facil |               Code            |
 *  +-+---------------------+-------+-------------------------------+
 *
 *  where
 *
 *      S - is the severity code
 *
 *          0 - SEVERITY_SUCCESS
 *          1 - SEVERITY_ERROR
 *
 *      Context - context info
 *
 *      Facility - is the facility code
 *
 *          0x0 - FACILITY_NULL     generally useful errors ([SE]_*)
 *          0x1 - FACILITY_RPC      remote procedure call errors (RPC_E_*)
 *          0x2 - FACILITY_DISPATCH late binding dispatch errors
 *          0x3 - FACILITY_STORAGE  storage errors (STG_E_*)
 *          0x4 - FACILITY_ITF      interface-specific errors
 *
 *      Code - is the facility's status code
 *
 *
 */

/*
 *  On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *  laid out as follows:
 *  
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *  
 *   where
 *  
 *      S - Severity - indicates success/fail
 *  
 *          0 - Success
 *          1 - Fail (COERROR)
 *  
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *  
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *  
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *  
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *  
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *  
 *      Code - is the facility's status code
 *  
 */




/*
 *  We can't use OLE 2.0 macros to build sCodes because the definition has
 *  changed and we wish to conform to the new definition.
 */

/* The following two macros are used to build OLE 2.0 style sCodes */


#ifdef  SUCCESS_SUCCESS
#undef  SUCCESS_SUCCESS
#endif
#define SUCCESS_SUCCESS     0L

/* General errors (used by more than one MAPI object) */


Sc(MAPI_E_NO_SUPPORT),
Sc(MAPI_E_BAD_CHARWIDTH),
Sc(MAPI_E_STRING_TOO_LONG),
Sc(MAPI_E_UNKNOWN_FLAGS),
Sc(MAPI_E_INVALID_ENTRYID),
Sc(MAPI_E_INVALID_OBJECT),
Sc(MAPI_E_OBJECT_CHANGED),
Sc(MAPI_E_OBJECT_DELETED),
Sc(MAPI_E_BUSY),
Sc(MAPI_E_NOT_ENOUGH_DISK),
Sc(MAPI_E_NOT_ENOUGH_RESOURCES),
Sc(MAPI_E_NOT_FOUND),
Sc(MAPI_E_VERSION),
Sc(MAPI_E_LOGON_FAILED),
Sc(MAPI_E_SESSION_LIMIT),
Sc(MAPI_E_USER_CANCEL),
Sc(MAPI_E_UNABLE_TO_ABORT),
Sc(MAPI_E_NETWORK_ERROR),
Sc(MAPI_E_DISK_ERROR),
Sc(MAPI_E_TOO_COMPLEX),
Sc(MAPI_E_BAD_COLUMN),
Sc(MAPI_E_EXTENDED_ERROR),
Sc(MAPI_E_COMPUTED),
Sc(MAPI_E_CORRUPT_DATA),
Sc(MAPI_E_UNCONFIGURED),
Sc(MAPI_E_FAILONEPROVIDER),
Sc(MAPI_E_UNKNOWN_CPID),
Sc(MAPI_E_UNKNOWN_LCID),

/* MAPI base function and status object specific errors and warnings */

Sc(MAPI_E_END_OF_SESSION),
Sc(MAPI_E_UNKNOWN_ENTRYID),
Sc(MAPI_E_MISSING_REQUIRED_COLUMN),
Sc(MAPI_W_NO_SERVICE),

/* Property specific errors and warnings */

Sc(MAPI_E_BAD_VALUE),
Sc(MAPI_E_INVALID_TYPE),
Sc(MAPI_E_TYPE_NO_SUPPORT),
Sc(MAPI_E_UNEXPECTED_TYPE),
Sc(MAPI_E_TOO_BIG),
Sc(MAPI_E_DECLINE_COPY),
Sc(MAPI_E_UNEXPECTED_ID),

Sc(MAPI_W_ERRORS_RETURNED),

/* Table specific errors and warnings */

Sc(MAPI_E_UNABLE_TO_COMPLETE),
Sc(MAPI_E_TIMEOUT),
Sc(MAPI_E_TABLE_EMPTY),
Sc(MAPI_E_TABLE_TOO_BIG),

Sc(MAPI_E_INVALID_BOOKMARK),

Sc(MAPI_W_POSITION_CHANGED),
Sc(MAPI_W_APPROX_COUNT),

/* Transport specific errors and warnings */

Sc(MAPI_E_WAIT),
Sc(MAPI_E_CANCEL),
Sc(MAPI_E_NOT_ME),

Sc(MAPI_W_CANCEL_MESSAGE),

/* Message Store, Folder, and Message specific errors and warnings */

Sc(MAPI_E_CORRUPT_STORE),
Sc(MAPI_E_NOT_IN_QUEUE),
Sc(MAPI_E_NO_SUPPRESS),
Sc(MAPI_E_COLLISION),
Sc(MAPI_E_NOT_INITIALIZED),
Sc(MAPI_E_NON_STANDARD),
Sc(MAPI_E_NO_RECIPIENTS),
Sc(MAPI_E_SUBMITTED),
Sc(MAPI_E_HAS_FOLDERS),
Sc(MAPI_E_HAS_MESSAGES),
Sc(MAPI_E_FOLDER_CYCLE),

Sc(MAPI_W_PARTIAL_COMPLETION),

/* Address Book specific errors and warnings */

Sc(MAPI_E_AMBIGUOUS_RECIP),

/* The range 0x0800 to 0x08FF is reserved */

/* Obsolete typing shortcut that will go away eventually. */
#ifndef MakeResult
#endif

/* We expect these to eventually be defined by OLE, but for now,
 * here they are.  When OLE defines them they can be much more
 * efficient than these, but these are "proper" and don't make
 * use of any hidden tricks.
 */
#ifndef HR_SUCCEEDED
#endif

#endif  /* _SCODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mapitest\sample.cli\_tags.h ===
/*
 *  _ T A G S . H
 *
 *  Property tag definitions for standard properties of MAPI
 *  objects.
 *
 *  The following ranges should be used for all property IDs. Note that
 *  property IDs for objects other than messages and recipients should
 *  all fall in the range 0x3000 to 0x3FFF:
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  0001    0BFF    MAPI_defined envelope property
 *  0C00    0DFF    MAPI_defined per-recipient property
 *  1000    2FFF    MAPI_defined message content property
 *
 *  3000    3FFF    MAPI_defined property (usually not message or recipient)
 *
 *  4000    57FF    Transport-defined envelope property
 *  5800    5FFF    Transport-defined per-recipient property
 *  6800    7BFF    Message class-defined content property
 *                  property
 *
 *  8000    FFFE    User-defined Name-to-id mapped property
 *
 *  The 3000-3FFF range is further subdivided as follows:
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    33FF    Common property such as display name, entry ID
 *  3400    35FF    Message store object
 *  3600    36FF    Folder or AB container
 *  3700    38FF    Attachment
 *  3900    39FF    Address book object
 *  3A00    3BFF    Mail user
 *  3C00    3CFF    Distribution list
 *  3D00    3DFF    Profile section
 *  3E00    3FFF    Status object
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _TAGS_H
#define _TAGS_H



/*
 *  Message envelope properties
 */

Pt(PR_ACKNOWLEDGEMENT_MODE),
Pt(PR_ALTERNATE_RECIPIENT_ALLOWED),
Pt(PR_AUTHORIZING_USERS),
Pt(PR_AUTO_FORWARD_COMMENT),
Pt(PR_AUTO_FORWARD_COMMENT_W),
Pt(PR_AUTO_FORWARD_COMMENT_A),
Pt(PR_AUTO_FORWARDED),
Pt(PR_CONTENT_CONFIDENTIALITY_ALGORITHM_ID),
Pt(PR_CONTENT_CORRELATOR),
Pt(PR_CONTENT_IDENTIFIER),
Pt(PR_CONTENT_IDENTIFIER_W),
Pt(PR_CONTENT_IDENTIFIER_A),
Pt(PR_CONTENT_LENGTH),
Pt(PR_CONTENT_RETURN_REQUESTED),



Pt(PR_CONVERSATION_KEY),

Pt(PR_CONVERSION_EITS),
Pt(PR_CONVERSION_WITH_LOSS_PROHIBITED),
Pt(PR_CONVERTED_EITS),
Pt(PR_DEFERRED_DELIVERY_TIME),
Pt(PR_DELIVER_TIME),
Pt(PR_DISCARD_REASON),
Pt(PR_DISCLOSURE_OF_RECIPIENTS),
Pt(PR_DL_EXPANSION_HISTORY),
Pt(PR_DL_EXPANSION_PROHIBITED),
Pt(PR_EXPIRY_TIME),
Pt(PR_IMPLICIT_CONVERSION_PROHIBITED),
Pt(PR_IMPORTANCE),
Pt(PR_IPM_ID),
Pt(PR_LATEST_DELIVERY_TIME),
Pt(PR_MESSAGE_CLASS),
Pt(PR_MESSAGE_CLASS_W),
Pt(PR_MESSAGE_CLASS_A),
Pt(PR_MESSAGE_DELIVERY_ID),





Pt(PR_MESSAGE_SECURITY_LABEL),
Pt(PR_OBSOLETED_IPMS),
Pt(PR_ORIGINALLY_INTENDED_RECIPIENT_NAME),
Pt(PR_ORIGINAL_EITS),
Pt(PR_ORIGINATOR_CERTIFICATE),
Pt(PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED),
Pt(PR_ORIGINATOR_RETURN_ADDRESS),



Pt(PR_PARENT_KEY),
Pt(PR_PRIORITY),



Pt(PR_ORIGIN_CHECK),
Pt(PR_PROOF_OF_SUBMISSION_REQUESTED),
Pt(PR_READ_RECEIPT_REQUESTED),
Pt(PR_RECEIPT_TIME),
Pt(PR_RECIPIENT_REASSIGNMENT_PROHIBITED),
Pt(PR_REDIRECTION_HISTORY),
Pt(PR_RELATED_IPMS),
Pt(PR_ORIGINAL_SENSITIVITY),
Pt(PR_LANGUAGES),
Pt(PR_LANGUAGES_W),
Pt(PR_LANGUAGES_A),
Pt(PR_REPLY_TIME),
Pt(PR_REPORT_TAG),
Pt(PR_REPORT_TIME),
Pt(PR_RETURNED_IPM),
Pt(PR_SECURITY),
Pt(PR_INCOMPLETE_COPY),
Pt(PR_SENSITIVITY),
Pt(PR_SUBJECT),
Pt(PR_SUBJECT_W),
Pt(PR_SUBJECT_A),
Pt(PR_SUBJECT_IPM),
Pt(PR_CLIENT_SUBMIT_TIME),
Pt(PR_REPORT_NAME),
Pt(PR_REPORT_NAME_W),
Pt(PR_REPORT_NAME_A),
Pt(PR_SENT_REPRESENTING_SEARCH_KEY),
Pt(PR_X400_CONTENT_TYPE),
Pt(PR_SUBJECT_PREFIX),
Pt(PR_SUBJECT_PREFIX_W),
Pt(PR_SUBJECT_PREFIX_A),
Pt(PR_NON_RECEIPT_REASON),
Pt(PR_RECEIVED_BY_ENTRYID),
Pt(PR_RECEIVED_BY_NAME),
Pt(PR_RECEIVED_BY_NAME_W),
Pt(PR_RECEIVED_BY_NAME_A),
Pt(PR_SENT_REPRESENTING_ENTRYID),
Pt(PR_SENT_REPRESENTING_NAME),
Pt(PR_SENT_REPRESENTING_NAME_W),
Pt(PR_SENT_REPRESENTING_NAME_A),
Pt(PR_RCVD_REPRESENTING_ENTRYID),
Pt(PR_RCVD_REPRESENTING_NAME),
Pt(PR_RCVD_REPRESENTING_NAME_W),
Pt(PR_RCVD_REPRESENTING_NAME_A),
Pt(PR_REPORT_ENTRYID),
Pt(PR_READ_RECEIPT_ENTRYID),
Pt(PR_MESSAGE_SUBMISSION_ID),
Pt(PR_PROVIDER_SUBMIT_TIME),
Pt(PR_ORIGINAL_SUBJECT),
Pt(PR_ORIGINAL_SUBJECT_W),
Pt(PR_ORIGINAL_SUBJECT_A),
Pt(PR_DISC_VAL),
Pt(PR_ORIG_MESSAGE_CLASS),
Pt(PR_ORIG_MESSAGE_CLASS_W),
Pt(PR_ORIG_MESSAGE_CLASS_A),
Pt(PR_ORIGINAL_AUTHOR_ENTRYID),
Pt(PR_ORIGINAL_AUTHOR_NAME),
Pt(PR_ORIGINAL_AUTHOR_NAME_W),
Pt(PR_ORIGINAL_AUTHOR_NAME_A),
Pt(PR_ORIGINAL_SUBMIT_TIME),
Pt(PR_REPLY_RECIPIENT_ENTRIES),
Pt(PR_REPLY_RECIPIENT_NAMES),
Pt(PR_REPLY_RECIPIENT_NAMES_W),
Pt(PR_REPLY_RECIPIENT_NAMES_A),

Pt(PR_RECEIVED_BY_SEARCH_KEY),
Pt(PR_RCVD_REPRESENTING_SEARCH_KEY),
Pt(PR_READ_RECEIPT_SEARCH_KEY),
Pt(PR_REPORT_SEARCH_KEY),
Pt(PR_ORIGINAL_DELIVERY_TIME),
Pt(PR_ORIGINAL_AUTHOR_SEARCH_KEY),

Pt(PR_MESSAGE_TO_ME),
Pt(PR_MESSAGE_CC_ME),
Pt(PR_MESSAGE_RECIP_ME),

Pt(PR_ORIGINAL_SENDER_NAME),
Pt(PR_ORIGINAL_SENDER_NAME_W),
Pt(PR_ORIGINAL_SENDER_NAME_A),
Pt(PR_ORIGINAL_SENDER_ENTRYID),
Pt(PR_ORIGINAL_SENDER_SEARCH_KEY),
Pt(PR_ORIGINAL_SENT_REPRESENTING_NAME),
Pt(PR_ORIGINAL_SENT_REPRESENTING_NAME_W),
Pt(PR_ORIGINAL_SENT_REPRESENTING_NAME_A),
Pt(PR_ORIGINAL_SENT_REPRESENTING_ENTRYID),
Pt(PR_ORIGINAL_SENT_REPRESENTING_SEARCH_KEY),

Pt(PR_START_DATE),
Pt(PR_END_DATE),
Pt(PR_OWNER_APPT_ID),
Pt(PR_RESPONSE_REQUESTED),

Pt(PR_SENT_REPRESENTING_ADDRTYPE),
Pt(PR_SENT_REPRESENTING_ADDRTYPE_W),
Pt(PR_SENT_REPRESENTING_ADDRTYPE_A),
Pt(PR_SENT_REPRESENTING_EMAIL_ADDRESS),
Pt(PR_SENT_REPRESENTING_EMAIL_ADDRESS_W),
Pt(PR_SENT_REPRESENTING_EMAIL_ADDRESS_A),

Pt(PR_ORIGINAL_SENDER_ADDRTYPE),
Pt(PR_ORIGINAL_SENDER_ADDRTYPE_W),
Pt(PR_ORIGINAL_SENDER_ADDRTYPE_A),
Pt(PR_ORIGINAL_SENDER_EMAIL_ADDRESS),
Pt(PR_ORIGINAL_SENDER_EMAIL_ADDRESS_W),
Pt(PR_ORIGINAL_SENDER_EMAIL_ADDRESS_A),

Pt(PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE),
Pt(PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_W),
Pt(PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_A),
Pt(PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS),
Pt(PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_W),
Pt(PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_A),

Pt(PR_CONVERSATION_TOPIC),
Pt(PR_CONVERSATION_TOPIC_W),
Pt(PR_CONVERSATION_TOPIC_A),
Pt(PR_CONVERSATION_INDEX),

Pt(PR_ORIGINAL_DISPLAY_BCC),
Pt(PR_ORIGINAL_DISPLAY_BCC_W),
Pt(PR_ORIGINAL_DISPLAY_BCC_A),
Pt(PR_ORIGINAL_DISPLAY_CC),
Pt(PR_ORIGINAL_DISPLAY_CC_W),
Pt(PR_ORIGINAL_DISPLAY_CC_A),
Pt(PR_ORIGINAL_DISPLAY_TO),
Pt(PR_ORIGINAL_DISPLAY_TO_W),
Pt(PR_ORIGINAL_DISPLAY_TO_A),

Pt(PR_RECEIVED_BY_ADDRTYPE),
Pt(PR_RECEIVED_BY_ADDRTYPE_W),
Pt(PR_RECEIVED_BY_ADDRTYPE_A),
Pt(PR_RECEIVED_BY_EMAIL_ADDRESS),
Pt(PR_RECEIVED_BY_EMAIL_ADDRESS_W),
Pt(PR_RECEIVED_BY_EMAIL_ADDRESS_A),

Pt(PR_RCVD_REPRESENTING_ADDRTYPE),
Pt(PR_RCVD_REPRESENTING_ADDRTYPE_W),
Pt(PR_RCVD_REPRESENTING_ADDRTYPE_A),
Pt(PR_RCVD_REPRESENTING_EMAIL_ADDRESS),
Pt(PR_RCVD_REPRESENTING_EMAIL_ADDRESS_W),
Pt(PR_RCVD_REPRESENTING_EMAIL_ADDRESS_A),

Pt(PR_ORIGINAL_AUTHOR_ADDRTYPE),
Pt(PR_ORIGINAL_AUTHOR_ADDRTYPE_W),
Pt(PR_ORIGINAL_AUTHOR_ADDRTYPE_A),
Pt(PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS),
Pt(PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_W),
Pt(PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_A),

Pt(PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE),
Pt(PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_W),
Pt(PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_A),
Pt(PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS),
Pt(PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_W),
Pt(PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_A),

Pt(PR_TRANSPORT_MESSAGE_HEADERS),
Pt(PR_TRANSPORT_MESSAGE_HEADERS_W),
Pt(PR_TRANSPORT_MESSAGE_HEADERS_A),

Pt(PR_DELEGATION),



/*
 *  Message content properties
 */

Pt(PR_BODY),
Pt(PR_BODY_W),
Pt(PR_BODY_A),
Pt(PR_REPORT_TEXT),
Pt(PR_REPORT_TEXT_W),
Pt(PR_REPORT_TEXT_A),
Pt(PR_ORIGINATOR_AND_DL_EXPANSION_HISTORY),
Pt(PR_REPORTING_DL_NAME),
Pt(PR_REPORTING_MTA_CERTIFICATE),

/*  Removed PR_REPORT_ORIGIN_AUTHENTICATION_CHECK with DCR 3865, use PR_ORIGIN_CHECK */

Pt(PR_RTF_SYNC_BODY_CRC),
Pt(PR_RTF_SYNC_BODY_COUNT),
Pt(PR_RTF_SYNC_BODY_TAG),
Pt(PR_RTF_SYNC_BODY_TAG_W),
Pt(PR_RTF_SYNC_BODY_TAG_A),
Pt(PR_RTF_COMPRESSED),
Pt(PR_RTF_SYNC_PREFIX_COUNT),
Pt(PR_RTF_SYNC_TRAILING_COUNT),
Pt(PR_ORIGINALLY_INTENDED_RECIP_ENTRYID),

/*
 *  Message recipient properties
 */

Pt(PR_CONTENT_INTEGRITY_CHECK),
Pt(PR_EXPLICIT_CONVERSION),
Pt(PR_IPM_RETURN_REQUESTED),
Pt(PR_MESSAGE_TOKEN),
Pt(PR_NDR_REASON_CODE),
Pt(PR_NDR_DIAG_CODE),
Pt(PR_NON_RECEIPT_NOTIFICATION_REQUESTED),
Pt(PR_DELIVERY_POINT),

Pt(PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED),
Pt(PR_ORIGINATOR_REQUESTED_ALTERNATE_RECIPIENT),
Pt(PR_PHYSICAL_DELIVERY_BUREAU_FAX_DELIVERY),
Pt(PR_PHYSICAL_DELIVERY_MODE),
Pt(PR_PHYSICAL_DELIVERY_REPORT_REQUEST),
Pt(PR_PHYSICAL_FORWARDING_ADDRESS),
Pt(PR_PHYSICAL_FORWARDING_ADDRESS_REQUESTED),
Pt(PR_PHYSICAL_FORWARDING_PROHIBITED),
Pt(PR_PHYSICAL_RENDITION_ATTRIBUTES),
Pt(PR_PROOF_OF_DELIVERY),
Pt(PR_PROOF_OF_DELIVERY_REQUESTED),
Pt(PR_RECIPIENT_CERTIFICATE),
Pt(PR_RECIPIENT_NUMBER_FOR_ADVICE),
Pt(PR_RECIPIENT_NUMBER_FOR_ADVICE_W),
Pt(PR_RECIPIENT_NUMBER_FOR_ADVICE_A),
Pt(PR_RECIPIENT_TYPE),
Pt(PR_REGISTERED_MAIL_TYPE),
Pt(PR_REPLY_REQUESTED),
Pt(PR_REQUESTED_DELIVERY_METHOD),
Pt(PR_SENDER_ENTRYID),
Pt(PR_SENDER_NAME),
Pt(PR_SENDER_NAME_W),
Pt(PR_SENDER_NAME_A),
Pt(PR_SUPPLEMENTARY_INFO),
Pt(PR_SUPPLEMENTARY_INFO_W),
Pt(PR_SUPPLEMENTARY_INFO_A),
Pt(PR_TYPE_OF_MTS_USER),
Pt(PR_SENDER_SEARCH_KEY),
Pt(PR_SENDER_ADDRTYPE),
Pt(PR_SENDER_ADDRTYPE_W),
Pt(PR_SENDER_ADDRTYPE_A),
Pt(PR_SENDER_EMAIL_ADDRESS),
Pt(PR_SENDER_EMAIL_ADDRESS_W),
Pt(PR_SENDER_EMAIL_ADDRESS_A),

/*
 */

/*
 * The two tags, PR_MESSAGE_RECIPIENTS and PR_MESSAGE_ATTACHMENTS,
 * are to be used in the exclude list passed to
 * IMessage::CopyTo when the caller wants either the recipients or attachments
 * of the message to not get copied.  It is also used in the ProblemArray
 * return from IMessage::CopyTo when an error is encountered copying them
 */

Pt(PR_CURRENT_VERSION),
Pt(PR_DELETE_AFTER_SUBMIT),
Pt(PR_DISPLAY_BCC),
Pt(PR_DISPLAY_BCC_W),
Pt(PR_DISPLAY_BCC_A),
Pt(PR_DISPLAY_CC),
Pt(PR_DISPLAY_CC_W),
Pt(PR_DISPLAY_CC_A),
Pt(PR_DISPLAY_TO),
Pt(PR_DISPLAY_TO_W),
Pt(PR_DISPLAY_TO_A),
Pt(PR_PARENT_DISPLAY),
Pt(PR_PARENT_DISPLAY_W),
Pt(PR_PARENT_DISPLAY_A),
Pt(PR_MESSAGE_DELIVERY_TIME),
Pt(PR_MESSAGE_FLAGS),
Pt(PR_MESSAGE_SIZE),
Pt(PR_PARENT_ENTRYID),
Pt(PR_SENTMAIL_ENTRYID),
Pt(PR_CORRELATE),
Pt(PR_CORRELATE_MTSID),
Pt(PR_DISCRETE_VALUES),
Pt(PR_RESPONSIBILITY),
Pt(PR_SPOOLER_STATUS),
Pt(PR_TRANSPORT_STATUS),
Pt(PR_MESSAGE_RECIPIENTS),
Pt(PR_MESSAGE_ATTACHMENTS),
Pt(PR_SUBMIT_FLAGS),
Pt(PR_RECIPIENT_STATUS),
Pt(PR_TRANSPORT_KEY),
Pt(PR_MSG_STATUS),
Pt(PR_MESSAGE_DOWNLOAD_TIME),
Pt(PR_CREATION_VERSION),
Pt(PR_MODIFY_VERSION),
Pt(PR_HASATTACH),
Pt(PR_BODY_CRC),
Pt(PR_NORMALIZED_SUBJECT),
Pt(PR_NORMALIZED_SUBJECT_W),
Pt(PR_NORMALIZED_SUBJECT_A),
Pt(PR_RTF_IN_SYNC),
Pt(PR_ATTACH_SIZE),
Pt(PR_ATTACH_NUM),
Pt(PR_PREPROCESS),

/* PR_ORIGINAL_DISPLAY_TO, _CC, and _BCC moved to transmittible range 03/09/95 */

Pt(PR_ORIGINATING_MTA_CERTIFICATE),
Pt(PR_PROOF_OF_SUBMISSION),


/*
 * The range of non-message and non-recipient property IDs (0x3000 - 0x3FFF) is
 * further broken down into ranges to make assigning new property IDs easier.
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    32FF    MAPI_defined common property
 *  3200    33FF    MAPI_defined form property
 *  3400    35FF    MAPI_defined message store property
 *  3600    36FF    MAPI_defined Folder or AB Container property
 *  3700    38FF    MAPI_defined attachment property
 *  3900    39FF    MAPI_defined address book property
 *  3A00    3BFF    MAPI_defined mailuser property
 *  3C00    3CFF    MAPI_defined DistList property
 *  3D00    3DFF    MAPI_defined Profile Section property
 *  3E00    3EFF    MAPI_defined Status property
 *  3F00    3FFF    MAPI_defined display table property
 */

/*
 *  Properties common to numerous MAPI objects.
 *
 *  Those properties that can appear on messages are in the
 *  end of that range and work down.
 *
 *  Properties that never appear on messages are defined in the common
 *  property range (see above).
 */

/*
 * properties that are common to multiple objects (including message objects)
 */

Pt(PR_ENTRYID),
Pt(PR_OBJECT_TYPE),
Pt(PR_ICON),
Pt(PR_MINI_ICON),
Pt(PR_STORE_ENTRYID),
Pt(PR_STORE_RECORD_KEY),
Pt(PR_RECORD_KEY),
Pt(PR_MAPPING_SIGNATURE),
Pt(PR_ACCESS_LEVEL),
Pt(PR_INSTANCE_KEY),
Pt(PR_ROW_TYPE),
Pt(PR_ACCESS),

/*
 * properties that are common to multiple objects (usually not including message objects)
 */

Pt(PR_ROWID),
Pt(PR_DISPLAY_NAME),
Pt(PR_DISPLAY_NAME_W),
Pt(PR_DISPLAY_NAME_A),
Pt(PR_ADDRTYPE),
Pt(PR_ADDRTYPE_W),
Pt(PR_ADDRTYPE_A),
Pt(PR_EMAIL_ADDRESS),
Pt(PR_EMAIL_ADDRESS_W),
Pt(PR_EMAIL_ADDRESS_A),
Pt(PR_COMMENT),
Pt(PR_COMMENT_W),
Pt(PR_COMMENT_A),
Pt(PR_DEPTH),
Pt(PR_PROVIDER_DISPLAY),
Pt(PR_PROVIDER_DISPLAY_W),
Pt(PR_PROVIDER_DISPLAY_A),
Pt(PR_CREATION_TIME),
Pt(PR_LAST_MODIFICATION_TIME),
Pt(PR_RESOURCE_FLAGS),
Pt(PR_PROVIDER_DLL_NAME),
Pt(PR_PROVIDER_DLL_NAME_W),
Pt(PR_PROVIDER_DLL_NAME_A),
Pt(PR_SEARCH_KEY),
Pt(PR_PROVIDER_UID),
Pt(PR_PROVIDER_ORDINAL),

/*
 *  MAPI Form properties
 */
Pt(PR_FORM_VERSION),
Pt(PR_FORM_VERSION_W),
Pt(PR_FORM_VERSION_A),
Pt(PR_FORM_CLSID),
Pt(PR_FORM_CONTACT_NAME),
Pt(PR_FORM_CONTACT_NAME_W),
Pt(PR_FORM_CONTACT_NAME_A),
Pt(PR_FORM_CATEGORY),
Pt(PR_FORM_CATEGORY_W),
Pt(PR_FORM_CATEGORY_A),
Pt(PR_FORM_CATEGORY_SUB),
Pt(PR_FORM_CATEGORY_SUB_W),
Pt(PR_FORM_CATEGORY_SUB_A),
Pt(PR_FORM_HOST_MAP),
Pt(PR_FORM_HIDDEN),
Pt(PR_FORM_DESIGNER_NAME),
Pt(PR_FORM_DESIGNER_NAME_W),
Pt(PR_FORM_DESIGNER_NAME_A),
Pt(PR_FORM_DESIGNER_GUID),
Pt(PR_FORM_MESSAGE_BEHAVIOR),

/*
 *  Message store properties
 */

Pt(PR_DEFAULT_STORE),
Pt(PR_STORE_SUPPORT_MASK),
Pt(PR_STORE_STATE),

Pt(PR_IPM_SUBTREE_SEARCH_KEY),
Pt(PR_IPM_OUTBOX_SEARCH_KEY),
Pt(PR_IPM_WASTEBASKET_SEARCH_KEY),
Pt(PR_IPM_SENTMAIL_SEARCH_KEY),
Pt(PR_MDB_PROVIDER),
Pt(PR_RECEIVE_FOLDER_SETTINGS),

Pt(PR_VALID_FOLDER_MASK),
Pt(PR_IPM_SUBTREE_ENTRYID),

Pt(PR_IPM_OUTBOX_ENTRYID),
Pt(PR_IPM_WASTEBASKET_ENTRYID),
Pt(PR_IPM_SENTMAIL_ENTRYID),
Pt(PR_VIEWS_ENTRYID),
Pt(PR_COMMON_VIEWS_ENTRYID),
Pt(PR_FINDER_ENTRYID),

/* Proptags 35E8-35FF reserved for folders "guaranteed" by PR_VALID_FOLDER_MASK */


/*
 *  Folder and AB Container properties
 */

Pt(PR_CONTAINER_FLAGS),
Pt(PR_FOLDER_TYPE),
Pt(PR_CONTENT_COUNT),
Pt(PR_CONTENT_UNREAD),
Pt(PR_CREATE_TEMPLATES),
Pt(PR_DETAILS_TABLE),
Pt(PR_SEARCH),
Pt(PR_SELECTABLE),
Pt(PR_SUBFOLDERS),
Pt(PR_STATUS),
Pt(PR_ANR),
Pt(PR_ANR_W),
Pt(PR_ANR_A),
Pt(PR_CONTENTS_SORT_ORDER),
Pt(PR_CONTAINER_HIERARCHY),
Pt(PR_CONTAINER_CONTENTS),
Pt(PR_FOLDER_ASSOCIATED_CONTENTS),
Pt(PR_DEF_CREATE_DL),
Pt(PR_DEF_CREATE_MAILUSER),
Pt(PR_CONTAINER_CLASS),
Pt(PR_CONTAINER_CLASS_W),
Pt(PR_CONTAINER_CLASS_A),
Pt(PR_CONTAINER_MODIFY_VERSION),
Pt(PR_AB_PROVIDER_ID),
Pt(PR_DEFAULT_VIEW_ENTRYID),
Pt(PR_ASSOC_CONTENT_COUNT),

/* Don't use 36FE and 36FF */

/*
 *  Attachment properties
 */

Pt(PR_ATTACHMENT_X400_PARAMETERS),
Pt(PR_ATTACH_DATA_OBJ),
Pt(PR_ATTACH_DATA_BIN),
Pt(PR_ATTACH_ENCODING),
Pt(PR_ATTACH_EXTENSION),
Pt(PR_ATTACH_EXTENSION_W),
Pt(PR_ATTACH_EXTENSION_A),
Pt(PR_ATTACH_FILENAME),
Pt(PR_ATTACH_FILENAME_W),
Pt(PR_ATTACH_FILENAME_A),
Pt(PR_ATTACH_METHOD),
Pt(PR_ATTACH_LONG_FILENAME),
Pt(PR_ATTACH_LONG_FILENAME_W),
Pt(PR_ATTACH_LONG_FILENAME_A),
Pt(PR_ATTACH_PATHNAME),
Pt(PR_ATTACH_PATHNAME_W),
Pt(PR_ATTACH_PATHNAME_A),
Pt(PR_ATTACH_RENDERING),
Pt(PR_ATTACH_TAG),
Pt(PR_RENDERING_POSITION),
Pt(PR_ATTACH_TRANSPORT_NAME),
Pt(PR_ATTACH_TRANSPORT_NAME_W),
Pt(PR_ATTACH_TRANSPORT_NAME_A),
Pt(PR_ATTACH_LONG_PATHNAME),
Pt(PR_ATTACH_LONG_PATHNAME_W),
Pt(PR_ATTACH_LONG_PATHNAME_A),
Pt(PR_ATTACH_MIME_TAG),
Pt(PR_ATTACH_MIME_TAG_W),
Pt(PR_ATTACH_MIME_TAG_A),

/*
 *  AB Object properties
 */

Pt(PR_DISPLAY_TYPE),
Pt(PR_TEMPLATEID),
Pt(PR_PRIMARY_CAPABILITY),

/*
 *  Mail user properties
 */

Pt(PR_ACCOUNT),
Pt(PR_ACCOUNT_W),
Pt(PR_ACCOUNT_A),
Pt(PR_ALTERNATE_RECIPIENT),
Pt(PR_CALLBACK_TELEPHONE_NUMBER),
Pt(PR_CALLBACK_TELEPHONE_NUMBER_W),
Pt(PR_CALLBACK_TELEPHONE_NUMBER_A),
Pt(PR_CONVERSION_PROHIBITED),
Pt(PR_DISCLOSE_RECIPIENTS),
Pt(PR_GENERATION),
Pt(PR_GENERATION_W),
Pt(PR_GENERATION_A),
Pt(PR_GIVEN_NAME),
Pt(PR_GIVEN_NAME_W),
Pt(PR_GIVEN_NAME_A),
Pt(PR_GOVERNMENT_ID_NUMBER),
Pt(PR_GOVERNMENT_ID_NUMBER_W),
Pt(PR_GOVERNMENT_ID_NUMBER_A),
Pt(PR_BUSINESS_TELEPHONE_NUMBER),
Pt(PR_BUSINESS_TELEPHONE_NUMBER_W),
Pt(PR_BUSINESS_TELEPHONE_NUMBER_A),
Pt(PR_OFFICE_TELEPHONE_NUMBER),
Pt(PR_OFFICE_TELEPHONE_NUMBER_W),
Pt(PR_OFFICE_TELEPHONE_NUMBER_A),
Pt(PR_HOME_TELEPHONE_NUMBER),
Pt(PR_HOME_TELEPHONE_NUMBER_W),
Pt(PR_HOME_TELEPHONE_NUMBER_A),
Pt(PR_INITIALS),
Pt(PR_INITIALS_W),
Pt(PR_INITIALS_A),
Pt(PR_KEYWORD),
Pt(PR_KEYWORD_W),
Pt(PR_KEYWORD_A),
Pt(PR_LANGUAGE),
Pt(PR_LANGUAGE_W),
Pt(PR_LANGUAGE_A),
Pt(PR_LOCATION),
Pt(PR_LOCATION_W),
Pt(PR_LOCATION_A),
Pt(PR_MAIL_PERMISSION),
Pt(PR_MHS_COMMON_NAME),
Pt(PR_MHS_COMMON_NAME_W),
Pt(PR_MHS_COMMON_NAME_A),
Pt(PR_ORGANIZATIONAL_ID_NUMBER),
Pt(PR_ORGANIZATIONAL_ID_NUMBER_W),
Pt(PR_ORGANIZATIONAL_ID_NUMBER_A),
Pt(PR_SURNAME),
Pt(PR_SURNAME_W),
Pt(PR_SURNAME_A),
Pt(PR_ORIGINAL_ENTRYID),
Pt(PR_ORIGINAL_DISPLAY_NAME),
Pt(PR_ORIGINAL_DISPLAY_NAME_W),
Pt(PR_ORIGINAL_DISPLAY_NAME_A),
Pt(PR_ORIGINAL_SEARCH_KEY),
Pt(PR_POSTAL_ADDRESS),
Pt(PR_POSTAL_ADDRESS_W),
Pt(PR_POSTAL_ADDRESS_A),
Pt(PR_COMPANY_NAME),
Pt(PR_COMPANY_NAME_W),
Pt(PR_COMPANY_NAME_A),
Pt(PR_TITLE),
Pt(PR_TITLE_W),
Pt(PR_TITLE_A),
Pt(PR_DEPARTMENT_NAME),
Pt(PR_DEPARTMENT_NAME_W),
Pt(PR_DEPARTMENT_NAME_A),
Pt(PR_OFFICE_LOCATION),
Pt(PR_OFFICE_LOCATION_W),
Pt(PR_OFFICE_LOCATION_A),
Pt(PR_PRIMARY_TELEPHONE_NUMBER),
Pt(PR_PRIMARY_TELEPHONE_NUMBER_W),
Pt(PR_PRIMARY_TELEPHONE_NUMBER_A),
Pt(PR_BUSINESS2_TELEPHONE_NUMBER),
Pt(PR_BUSINESS2_TELEPHONE_NUMBER_W),
Pt(PR_BUSINESS2_TELEPHONE_NUMBER_A),
Pt(PR_OFFICE2_TELEPHONE_NUMBER),
Pt(PR_OFFICE2_TELEPHONE_NUMBER_W),
Pt(PR_OFFICE2_TELEPHONE_NUMBER_A),
Pt(PR_MOBILE_TELEPHONE_NUMBER),
Pt(PR_MOBILE_TELEPHONE_NUMBER_W),
Pt(PR_MOBILE_TELEPHONE_NUMBER_A),
Pt(PR_CELLULAR_TELEPHONE_NUMBER),
Pt(PR_CELLULAR_TELEPHONE_NUMBER_W),
Pt(PR_CELLULAR_TELEPHONE_NUMBER_A),
Pt(PR_RADIO_TELEPHONE_NUMBER),
Pt(PR_RADIO_TELEPHONE_NUMBER_W),
Pt(PR_RADIO_TELEPHONE_NUMBER_A),
Pt(PR_CAR_TELEPHONE_NUMBER),
Pt(PR_CAR_TELEPHONE_NUMBER_W),
Pt(PR_CAR_TELEPHONE_NUMBER_A),
Pt(PR_OTHER_TELEPHONE_NUMBER),
Pt(PR_OTHER_TELEPHONE_NUMBER_W),
Pt(PR_OTHER_TELEPHONE_NUMBER_A),
Pt(PR_TRANSMITABLE_DISPLAY_NAME),
Pt(PR_TRANSMITABLE_DISPLAY_NAME_W),
Pt(PR_TRANSMITABLE_DISPLAY_NAME_A),
Pt(PR_PAGER_TELEPHONE_NUMBER),
Pt(PR_PAGER_TELEPHONE_NUMBER_W),
Pt(PR_PAGER_TELEPHONE_NUMBER_A),
Pt(PR_BEEPER_TELEPHONE_NUMBER),
Pt(PR_BEEPER_TELEPHONE_NUMBER_W),
Pt(PR_BEEPER_TELEPHONE_NUMBER_A),
Pt(PR_USER_CERTIFICATE),
Pt(PR_PRIMARY_FAX_NUMBER),
Pt(PR_PRIMARY_FAX_NUMBER_W),
Pt(PR_PRIMARY_FAX_NUMBER_A),
Pt(PR_BUSINESS_FAX_NUMBER),
Pt(PR_BUSINESS_FAX_NUMBER_W),
Pt(PR_BUSINESS_FAX_NUMBER_A),
Pt(PR_HOME_FAX_NUMBER),
Pt(PR_HOME_FAX_NUMBER_W),
Pt(PR_HOME_FAX_NUMBER_A),
Pt(PR_COUNTRY),
Pt(PR_COUNTRY_W),
Pt(PR_COUNTRY_A),
Pt(PR_LOCALITY),
Pt(PR_LOCALITY_W),
Pt(PR_LOCALITY_A),
Pt(PR_STATE_OR_PROVINCE),
Pt(PR_STATE_OR_PROVINCE_W),
Pt(PR_STATE_OR_PROVINCE_A),
Pt(PR_STREET_ADDRESS),
Pt(PR_STREET_ADDRESS_W),
Pt(PR_STREET_ADDRESS_A),
Pt(PR_POSTAL_CODE),
Pt(PR_POSTAL_CODE_W),
Pt(PR_POSTAL_CODE_A),
Pt(PR_POST_OFFICE_BOX),
Pt(PR_POST_OFFICE_BOX_W),
Pt(PR_POST_OFFICE_BOX_A),
Pt(PR_TELEX_NUMBER),
Pt(PR_TELEX_NUMBER_W),
Pt(PR_TELEX_NUMBER_A),
Pt(PR_ISDN_NUMBER),
Pt(PR_ISDN_NUMBER_W),
Pt(PR_ISDN_NUMBER_A),
Pt(PR_ASSISTANT_TELEPHONE_NUMBER),
Pt(PR_ASSISTANT_TELEPHONE_NUMBER_W),
Pt(PR_ASSISTANT_TELEPHONE_NUMBER_A),
Pt(PR_HOME2_TELEPHONE_NUMBER),
Pt(PR_HOME2_TELEPHONE_NUMBER_W),
Pt(PR_HOME2_TELEPHONE_NUMBER_A),
Pt(PR_ASSISTANT),
Pt(PR_ASSISTANT_W),
Pt(PR_ASSISTANT_A),
Pt(PR_SEND_RICH_INFO),

/*
 *  Profile section properties
 */

Pt(PR_STORE_PROVIDERS),
Pt(PR_AB_PROVIDERS),
Pt(PR_TRANSPORT_PROVIDERS),

Pt(PR_DEFAULT_PROFILE),
Pt(PR_AB_SEARCH_PATH),
Pt(PR_AB_DEFAULT_DIR),
Pt(PR_AB_DEFAULT_PAB),
Pt(PR_FILTERING_HOOKS),
Pt(PR_SERVICE_NAME),
Pt(PR_SERVICE_NAME_W),
Pt(PR_SERVICE_NAME_A),
Pt(PR_SERVICE_DLL_NAME),
Pt(PR_SERVICE_DLL_NAME_W),
Pt(PR_SERVICE_DLL_NAME_A),
Pt(PR_SERVICE_ENTRY_NAME),
Pt(PR_SERVICE_UID),
Pt(PR_SERVICE_EXTRA_UIDS),
Pt(PR_SERVICES),
Pt(PR_SERVICE_SUPPORT_FILES),
Pt(PR_SERVICE_SUPPORT_FILES_W),
Pt(PR_SERVICE_SUPPORT_FILES_A),
Pt(PR_SERVICE_DELETE_FILES),
Pt(PR_SERVICE_DELETE_FILES_W),
Pt(PR_SERVICE_DELETE_FILES_A),
Pt(PR_AB_SEARCH_PATH_UPDATE),
Pt(PR_PROFILE_NAME),
Pt(PR_PROFILE_NAME_A),
Pt(PR_PROFILE_NAME_W),

/*
 *  Status object properties
 */

Pt(PR_IDENTITY_DISPLAY),
Pt(PR_IDENTITY_DISPLAY_W),
Pt(PR_IDENTITY_DISPLAY_A),
Pt(PR_IDENTITY_ENTRYID),
Pt(PR_RESOURCE_METHODS),
Pt(PR_RESOURCE_TYPE),
Pt(PR_STATUS_CODE),
Pt(PR_IDENTITY_SEARCH_KEY),
Pt(PR_OWN_STORE_ENTRYID),
Pt(PR_RESOURCE_PATH),
Pt(PR_RESOURCE_PATH_W),
Pt(PR_RESOURCE_PATH_A),
Pt(PR_STATUS_STRING),
Pt(PR_STATUS_STRING_W),
Pt(PR_STATUS_STRING_A),
Pt(PR_X400_DEFERRED_DELIVERY_CANCEL),
Pt(PR_HEADER_FOLDER_ENTRYID),
Pt(PR_REMOTE_PROGRESS),
Pt(PR_REMOTE_PROGRESS_TEXT),
Pt(PR_REMOTE_PROGRESS_TEXT_W),
Pt(PR_REMOTE_PROGRESS_TEXT_A),
Pt(PR_REMOTE_VALIDATE_OK),

/*
 * Display table properties
 */

Pt(PR_CONTROL_FLAGS),
Pt(PR_CONTROL_STRUCTURE),
Pt(PR_CONTROL_TYPE),
Pt(PR_DELTAX),
Pt(PR_DELTAY),
Pt(PR_XPOS),
Pt(PR_YPOS),
Pt(PR_CONTROL_ID),
Pt(PR_INITIAL_DETAILS_PANE),

/*
 * Secure property id range
 */



#endif  /* _TAGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\migrate\migrate.cpp ===
// --------------------------------------------------------------------------------
// Migrate.cpp
// --------------------------------------------------------------------------------
#define INITGUID
#include "pch.hxx"
#include <initguid.h>
#define DEFINE_STRCONST
#include <mimeole.h>
#include "migrate.h"
#include "utility.h"
#include "resource.h"
#include "migerror.h"
#include <oestore.h>
#include "structs.h"
#include "strparse.h"
#include "msident.h"
              
// --------------------------------------------------------------------------------
// Debug Strings
// --------------------------------------------------------------------------------
#ifdef DEBUG
static const TCHAR c_szDebug[]      = "mshtmdbg.dll";
static const TCHAR c_szDebugUI[]    = "DoTracePointsDialog";
static const TCHAR c_szRegSpy[]     = "DbgRegisterMallocSpy";
static const TCHAR c_szInvokeUI[]   = "/d";
#endif

// --------------------------------------------------------------------------------
// MSHTMDBG.DLL Prototypes
// --------------------------------------------------------------------------------
#ifdef DEBUG
typedef void (STDAPICALLTYPE *PFNDEBUGUI)(BOOL);
typedef void (STDAPICALLTYPE *PFNREGSPY)(void);
#endif

// --------------------------------------------------------------------------------
// Debug Prototypes
// --------------------------------------------------------------------------------
#ifdef DEBUG
HINSTANCE g_hInstDebug=NULL;
void LoadMSHTMDBG(LPSTR pszCmdLine);
#endif

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
IMalloc             *g_pMalloc=NULL;
HINSTANCE            g_hInst=NULL;
DWORD                g_dwTlsMsgBuffIndex=0xffffffff;
DWORD                g_cbDiskNeeded=0;
DWORD                g_cbDiskFree=0;
ACCOUNTTABLE         g_AcctTable={0};
BOOL                 g_fQuiet = FALSE;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
HRESULT DowngradeV5B1(MIGRATETOTYPE tyMigrate, LPCSTR pszStoreRoot, LPPROGRESSINFO pProgress, LPFILEINFO *ppHeadFile);
INT_PTR CALLBACK MigrageErrorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT UpgradeV5(MIGRATETOTYPE tyMigrate, LPCSTR pszStoreSrc, LPCSTR pszStoreDst, LPPROGRESSINFO pProgress, LPFILEINFO *ppHeadFile);
HRESULT ParseCommandLine(LPCSTR pszCmdLine, LPSTR pszMigrate, DWORD cbMigrateMax,
    LPSTR pszStoreSrc, DWORD cbStoreSrc, LPSTR pszStoreDst, DWORD cbStoreDst,
    LPSTR pszUserKey, DWORD cbUserKey);
HRESULT RemapUsersKey(LPSTR pszUsersKey);
void ThreadAllocateTlsMsgBuffer(void);
void ThreadFreeTlsMsgBuffer(void);

// --------------------------------------------------------------------------------
// How big is the thread local storage string buffer
// -------------------------------------------------------------------------------
#define CBMAX_THREAD_TLS_BUFFER 512

#define ICC_FLAGS (ICC_PROGRESS_CLASS|ICC_NATIVEFNTCTL_CLASS)

// --------------------------------------------------------------------------------
// WinMain
//
// Command Line Format:
// --------------------
// /type:V1+V4-V5 /src:"Source Store Root" /dst:"Destination Store Root"
// --------------------------------------------------------------------------------
int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, LPSTR pszCmdLine, int nCmdShow)
{
    // Locals
    HRESULT                 hr=S_OK;
    PROGRESSINFO            Progress={0};
    CHAR                    szMigrate[50];
    CHAR                    szStoreSrc[MAX_PATH];
    CHAR                    szStoreDst[MAX_PATH];
    CHAR                    szUsersKey[MAX_PATH];
    LPFILEINFO              pHeadFile=NULL;
    MIGRATETOTYPE           tyMigrate;
    CHAR                    szMsg[512];
    HANDLE                  hMutex=NULL;
    INITCOMMONCONTROLSEX    icex = { sizeof(icex), ICC_FLAGS };

    // Tracing
    TraceCall("WinMain");

    // Validation
    Assert(sizeof(TABLEHEADERV5B1) == sizeof(TABLEHEADERV5));

    // Create Mutex
    IF_NULLEXIT(hMutex = CreateMutex(NULL, FALSE, "OutlookExpressMigration"));

    // Wait for the Mutex
    if (WAIT_FAILED == WaitForSingleObject(hMutex, INFINITE))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Initialzie OLE
    IF_FAILEXIT(hr = CoInitialize(NULL));
   
    // Save hInst
    g_hInst = hInst;

    // Load Debug DLL
    IF_DEBUG(LoadMSHTMDBG(pszCmdLine);)

    szUsersKey[0] = 0;

    // Crack the command line
    IF_FAILEXIT(hr = ParseCommandLine(pszCmdLine, szMigrate, ARRAYSIZE(szMigrate), szStoreSrc, ARRAYSIZE(szStoreSrc), szStoreDst, ARRAYSIZE(szStoreDst), szUsersKey, ARRAYSIZE(szUsersKey)));

    // Load the user hive, if needed
    IF_FAILEXIT(RemapUsersKey(szUsersKey));

    // Initialzie Common Controls
    InitCommonControlsEx(&icex);

    // Get the task allocator
    IF_FAILEXIT(hr = CoGetMalloc(MEMCTX_TASK, &g_pMalloc));

    // Tlsalloc
    g_dwTlsMsgBuffIndex = TlsAlloc();

    // allocat
    ThreadAllocateTlsMsgBuffer();

    // Create Dialog
    if(!g_fQuiet)
    {
        Progress.hwndProgress = CreateDialog(g_hInst, MAKEINTRESOURCE(IDD_PROGRESS), GetDesktopWindow(), MigrageDlgProc);

        // Bad Mojo
        if (NULL == Progress.hwndProgress)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Center
        CenterDialog(Progress.hwndProgress);

        // Show the Window
        ShowWindow(Progress.hwndProgress, SW_NORMAL);
    }

    // V5-V4
    if (lstrcmpi(szMigrate, "V5-V4") == 0)
    {
        // Locals
        CHAR szRes[255];
        CHAR szCaption[255];

        // LoadString
        LoadString(g_hInst, IDS_IMPORTMSG, szRes, ARRAYSIZE(szRes));

        // LoadString
        LoadString(g_hInst, IDS_TITLE, szCaption, ARRAYSIZE(szCaption));
        
        // Message
        if(!g_fQuiet)
            MessageBox(NULL, szRes, szCaption, MB_OK | MB_ICONEXCLAMATION);

        // Done
        goto exit;
    }

    // V5-V1
    else if (lstrcmpi(szMigrate, "V5-V1") == 0)
    {
        // Locals
        CHAR szRes[255];
        CHAR szCaption[255];

        // LoadString
        LoadString(g_hInst, IDS_V1NYI, szRes, ARRAYSIZE(szRes));

        // LoadString
        LoadString(g_hInst, IDS_TITLE, szCaption, ARRAYSIZE(szCaption));
        
        // Message
        if(!g_fQuiet)
            MessageBox(NULL, szRes, szCaption, MB_OK | MB_ICONEXCLAMATION);

        // Done
        goto exit;
    }

    // V1-V5 or V4-V5
    else if (lstrcmpi(szMigrate, "V1+V4-V5") == 0)
    {
        // Build the Account Table - Takes path to accounts not IAM
        IF_FAILEXIT(hr = BuildAccountTable(HKEY_CURRENT_USER, "Software\\Microsoft\\Internet Account Manager\\Accounts", szStoreSrc, &g_AcctTable));

        // Set tyMigrate
        tyMigrate = UPGRADE_V1_OR_V4_TO_V5;

        // RegressFromV5ToV4orV1
        hr = UpgradeV5(tyMigrate, szStoreSrc, szStoreDst, &Progress, &pHeadFile);
    }

    // V5B1-V1
    else if (lstrcmpi(szMigrate, "V5B1-V1") == 0)
    {
        // Set tyMigrate
        tyMigrate = DOWNGRADE_V5B1_TO_V4;

        hr = DowngradeV5B1(tyMigrate, szStoreSrc, &Progress, &pHeadFile);
    }

    // V5B1-V4 
    else if (lstrcmpi(szMigrate, "V5B1-V4") == 0)
    {
        // Set tyMigrate
        tyMigrate = DOWNGRADE_V5B1_TO_V4;

        hr = DowngradeV5B1(tyMigrate, szStoreSrc, &Progress, &pHeadFile);
    }

    // Bad Command Line
    else
    {
        // Bad Command Line
        AssertSz(FALSE, "Invalid Command line arguments passed into oemig50.exe");

        // Failure
        hr = TraceResult(E_FAIL);

        // Done
        goto exit;
    }

    // Kill the Window
    if(!g_fQuiet)
        DestroyWindow(Progress.hwndProgress);
    Progress.hwndProgress = NULL;

    // Write Migration Log File
    WriteMigrationLogFile(hr, GetLastError(), szStoreSrc, szMigrate, pszCmdLine, pHeadFile);

    // Trace It
    if (FAILED(hr))
    {
        // Trace It
        TraceResult(hr);

        // Handle the Error message
        if (MIGRATE_E_NOTENOUGHDISKSPACE == hr)
        {
            // Locals
            CHAR        szRes[255];
            CHAR        szScratch1[50];
            CHAR        szScratch2[50];

            // LoadString
            LoadString(g_hInst, IDS_DISKSPACEERROR, szRes, ARRAYSIZE(szRes));

            // Format the Error
            wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, StrFormatByteSize64A(g_cbDiskNeeded, szScratch1, ARRAYSIZE(szScratch1)), StrFormatByteSize64A(g_cbDiskFree, szScratch2, ARRAYSIZE(szScratch2)));
        }

        // Sharing Violation...
        else if (MIGRATE_E_SHARINGVIOLATION == hr)
        {
            // LoadString
            LoadString(g_hInst, IDS_SHARINGVIOLATION, szMsg, ARRAYSIZE(szMsg));
        }

        // General Failure
        else
        {
            // LoadString
            LoadString(g_hInst, IDS_GENERALERROR, szMsg, ARRAYSIZE(szMsg));
        }

        // Do the dialog
        if(!g_fQuiet)           
            hr = (HRESULT) DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_MIGRATEERROR), NULL, MigrageErrorDlgProc, (LPARAM)szMsg);
    }

    // Otherwise, success
    else
        hr = MIGRATE_S_SUCCESS;

exit:
    // Cleanup
    SafeMemFree(g_AcctTable.prgAccount);
    FreeFileList(&pHeadFile);
    if (Progress.hwndProgress)
        DestroyWindow(Progress.hwndProgress);
    ThreadFreeTlsMsgBuffer();
    if (0xffffffff != g_dwTlsMsgBuffIndex)
        TlsFree(g_dwTlsMsgBuffIndex);
    SafeRelease(g_pMalloc);

    IF_DEBUG(if (g_hInstDebug) FreeLibrary(g_hInstDebug);)

    // Cleanup
    CoUninitialize();

    // Release the mutex
    if (hMutex)
    {
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }

    // Done
    return (INT)hr;
}

// --------------------------------------------------------------------------------
// ParseCommandLine
// -------------------------------------------------------------------------------
HRESULT ParseCommandLine(LPCSTR pszCmdLine, LPSTR pszMigrate, DWORD cbMigrate,
    LPSTR pszStoreSrc, DWORD cbStoreSrc, LPSTR pszStoreDst, DWORD cbStoreDst, 
    LPSTR pszUsersKey, DWORD cbUsersKey)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                chToken;
    CStringParser       cParser;

    // Trace
    TraceCall("ParseCommandLine");

    // Initialize
    *pszMigrate = *pszStoreSrc = *pszStoreDst = '\0';

    // Init
    cParser.Init(pszCmdLine, lstrlen(pszCmdLine), PSF_DBCS | PSF_NOTRAILWS | PSF_NOFRONTWS);

    // Parse to first /
    chToken = cParser.ChParse("/");
    if ('/' != chToken)
        goto exit;

    // Parse to :
    chToken = cParser.ChParse(":");
    if (':' != chToken)
        goto exit;

    // Check parameter name
    if (0 != lstrcmpi(cParser.PszValue(), "type"))
        goto exit;

    // Parse to /
    chToken = cParser.ChParse("/");
    if ('/' != chToken)
        goto exit;

    // Copy the Value
    StrCpyN(pszMigrate, cParser.PszValue(), cbMigrate - 1);

    // Parse to :
    chToken = cParser.ChParse(":");
    if (':' != chToken)
        goto exit;

    // Check parameter name
    if (0 != lstrcmpi(cParser.PszValue(), "src"))
        goto exit;

    // Parse to /
    chToken = cParser.ChParse("/");
    if ('/' != chToken)
        goto exit;

    // Copy the Value
    StrCpyN(pszStoreSrc, cParser.PszValue(), cbStoreSrc - 1);

    // Parse to :
    chToken = cParser.ChParse(":");
    if (':' != chToken)
        goto exit;

    // Check parameter name
    if (0 != lstrcmpi(cParser.PszValue(), "dst"))
        goto exit;

    // Parse to /
    chToken = cParser.ChParse("/");
    if (('/' != chToken) && ('\0' != chToken))
        goto exit;

    // Copy the Value
    StrCpyN(pszStoreDst, cParser.PszValue(), cbStoreDst - 1);

    if ('/' == chToken)
    {
        chToken = cParser.ChParse("/");
        if ('\0' == chToken || '/' == chToken)
        {
            if (0 == lstrcmpi(cParser.PszValue(), "quiet"))
                g_fQuiet = TRUE;
        }
    }

    if ('/' == chToken)
    {
        // Parse to :
        chToken = cParser.ChParse(":");
        if (':' == chToken)
        {
            // Check parameter name
            if (0 == lstrcmpi(cParser.PszValue(), "key")) 
            {
                // Parse to end
                chToken = cParser.ChParse("");
                if ('\0' == chToken)
                {
                    // Copy the Value
                    StrCpyN(pszUsersKey, cParser.PszValue(), cbUsersKey - 1);
               }
           }
        }
    }

exit:
    // Failure Already
    if (FAILED(hr))
        return(hr);

    // Set hr
    hr = (*pszMigrate == '\0' || *pszStoreSrc == '\0' || *pszStoreDst == '\0') ? E_FAIL : S_OK;

    // Assert
    AssertSz(SUCCEEDED(hr), "Invalid Command line passed into oemig50.exe.");

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// LoadUserHive
// -------------------------------------------------------------------------------
HRESULT RemapUsersKey(LPSTR pszUsersKey)
{
    // Locals
    HRESULT     hr = S_OK;
    HKEY        hKey;

    if (pszUsersKey && *pszUsersKey) {
        // Open the user's key
        hr = RegOpenKey (HKEY_USERS, pszUsersKey, &hKey);

        if (SUCCEEDED(hr)) {
            // Remap HKCU to point to the user's key
            hr = RegOverridePredefKey (HKEY_CURRENT_USER, hKey);

            // Close the key
            RegCloseKey (hKey);
        }
    }

    return hr;
}

// --------------------------------------------------------------------------------
// ThreadAllocateTlsMsgBuffer
// -------------------------------------------------------------------------------
void ThreadAllocateTlsMsgBuffer(void)
{
    if (g_dwTlsMsgBuffIndex != 0xffffffff)
        TlsSetValue(g_dwTlsMsgBuffIndex, NULL);
}

// --------------------------------------------------------------------------------
// ThreadFreeTlsMsgBuffer
// -------------------------------------------------------------------------------
void ThreadFreeTlsMsgBuffer(void)
{
    if (g_dwTlsMsgBuffIndex != 0xffffffff)
    {
        LPSTR psz = (LPSTR)TlsGetValue(g_dwTlsMsgBuffIndex);
        SafeMemFree(psz);
        SideAssert(0 != TlsSetValue(g_dwTlsMsgBuffIndex, NULL));
    }
}

// --------------------------------------------------------------------------------
// PszGetTlsBuffer
// -------------------------------------------------------------------------------
LPSTR PszGetTlsBuffer(void)
{
    // Get the buffer
    LPSTR pszBuffer = (LPSTR)TlsGetValue(g_dwTlsMsgBuffIndex);

    // If buffer has not been allocated
    if (NULL == pszBuffer)
    {
        // Allocate it
        pszBuffer = (LPSTR)g_pMalloc->Alloc(CBMAX_THREAD_TLS_BUFFER);

        // Store it
        Assert(pszBuffer);
        SideAssert(0 != TlsSetValue(g_dwTlsMsgBuffIndex, pszBuffer));
    }

    // Done
    return pszBuffer;
}

// --------------------------------------------------------------------------------
// _MSG - Used to build a string from variable length args, thread-safe
// -------------------------------------------------------------------------------
LPCSTR _MSG(LPSTR pszFormat, ...)
{
    // Locals
    va_list     arglist;
    LPSTR       pszBuffer=NULL;

    // I use tls to hold the buffer
    if (g_dwTlsMsgBuffIndex != 0xffffffff)
    {
        // Setup the arglist
        va_start(arglist, pszFormat);

        // Get the Buffer
        pszBuffer = PszGetTlsBuffer();

        // If we have a buffer
        if (pszBuffer)
        {
            // Format the data
            wvnsprintf(pszBuffer, CBMAX_THREAD_TLS_BUFFER, pszFormat, arglist);
        }

        // End the arglist
        va_end(arglist);
    }

    return ((LPCSTR)pszBuffer);
}

// --------------------------------------------------------------------------------
// MigrageErrorDlgProc
// --------------------------------------------------------------------------------
INT_PTR CALLBACK MigrageErrorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        SetForegroundWindow(hwnd);
        CenterDialog(hwnd);
        SetDlgItemText(hwnd, IDS_MESSAGE, (LPSTR)lParam);
        CheckDlgButton(hwnd, IDR_DONTSTARTOE, BST_CHECKED);
        SetFocus(GetDlgItem(hwnd, IDR_DONTSTARTOE));
        return FALSE;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDOK:
        case IDCANCEL:
            if (IsDlgButtonChecked(hwnd, IDR_DONTSTARTOE))
                EndDialog(hwnd, MIGRATE_E_NOCONTINUE);
            else if (IsDlgButtonChecked(hwnd, IDR_STARTOE))
                EndDialog(hwnd, MIGRATE_S_SUCCESS);
            return 1;
        }
        break;
    }

    // Done
    return FALSE;
}

#ifdef DEBUG
// --------------------------------------------------------------------------------
// LoadMSHTMDBG
// --------------------------------------------------------------------------------
void LoadMSHTMDBG(LPSTR pszCmdLine)
{
    // Load mshtmdbg.dll
    HINSTANCE g_hInstDebug = LoadLibrary(c_szDebug);

    // Did it load ?
    if (NULL != g_hInstDebug)
    {
        // Locals
        PFNREGSPY  pfnRegSpy;

        // If the user passed /d on the command line, lets configure mshtmdbg.dll
        if (0 == lstrcmpi(pszCmdLine, c_szInvokeUI))
        {
            // Locals
            PFNDEBUGUI pfnDebugUI;

            // Get the proc address of the UI
            pfnDebugUI = (PFNDEBUGUI)GetProcAddress(g_hInstDebug, c_szDebugUI);
            if (NULL != pfnDebugUI)
            {
                (*pfnDebugUI)(TRUE);
                goto exit;
            }

            // Done
            exit(1);
        }

        // Get the process address of the registration
        pfnRegSpy = (PFNREGSPY)GetProcAddress(g_hInstDebug, c_szRegSpy);
        if (NULL != pfnRegSpy)
            (*pfnRegSpy)();
    }

exit:
    // Done
    return;
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\migrate\resource.h ===
// --------------------------------------------------------------------------------
// Resource.h
// --------------------------------------------------------------------------------
#ifndef __RESOURCE_H
#define __RESOURCE_H

// --------------------------------------------------------------------------------
// Dialog Ids
// --------------------------------------------------------------------------------
#define IDD_PROGRESS                    101
#define IDD_MIGRATEERROR                102

// --------------------------------------------------------------------------------
// Icon Ids
// --------------------------------------------------------------------------------
#define IDI_MIGRATE                     102

// --------------------------------------------------------------------------------
// Dialog Control Ids
// --------------------------------------------------------------------------------
#define IDC_STATIC                      -1
#define IDC_PROGRESS                    1000
#define IDS_STATUS                      1001
#define IDS_DESCRIPT                    1002
#define IDR_STARTOE                     1003
#define IDR_DONTSTARTOE                 1004
#define IDS_MESSAGE                     1005
#define IDS_NEWSOUTBOX                  1006
#define IDS_NEWSPOSTED                  1007
#define IDS_NEWSSAVED                   1008
#define IDS_POSTEDITEMS                 1009
#define IDS_SAVEDITEMS                  1010
#define IDS_COMPLETE                    1011
#define IDS_TITLE                       1012
#define IDS_MIGRATING                   1013
#define IDS_UPGRADEMESSAGE              1014
#define IDS_DISKSPACEERROR              1015
#define IDS_GENERALERROR                1016
#define IDS_IMPORTMSG                   1017
#define IDS_V1NYI                       1018
#define IDS_SHARINGVIOLATION            1019

#define IDS_INBOX                       5000
#define IDS_OUTBOX                      5001
#define IDS_SENTITEMS                   5002
#define IDS_DELETED                     5003
#define IDS_DRAFT                       5004

// --------------------------------------------------------------------------------
// Strings
// --------------------------------------------------------------------------------
#define IDS_BYTES                       0x103
#define IDS_ORDERKB                     0x104
#define IDS_ORDERMB                     0x105
#define IDS_ORDERGB                     0x106
#define IDS_ORDERTB                     0x107
#define IDS_ORDERPB                     0x108
#define IDS_ORDEREB                     0x109

#endif // __RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\migrate\oe5beta1.cpp ===
// --------------------------------------------------------------------------------
// oe5beta1.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "utility.h"
#include "migrate.h"
#include "migerror.h"
#include "structs.h"
#include "resource.h"

// --------------------------------------------------------------------------------
// DowngradeProcessFileListV5B1
// --------------------------------------------------------------------------------
HRESULT DowngradeProcessFileListV5B1(LPFILEINFO pHead, LPDWORD pcMax, LPDWORD pcbNeeded)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    LPFILEINFO          pCurrent;
    LPTABLEHEADERV5B1   pHeader;

    // Trace
    TraceCall("DowngradeProcessFileListV5B1");

    // Invalid Arg
    Assert(pHead);

    // Init
    *pcMax = 0;
    *pcbNeeded = 0;

    // Loop
    for (pCurrent=pHead; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Get the File Header
        hr = OpenMemoryFile(pCurrent->szFilePath, &File);

        // Failure ?
        if (FAILED(hr))
        {
            // Don't Migrate
            pCurrent->fMigrate = FALSE;

            // Set hrMigrate
            pCurrent->hrMigrate = hr;

            // Reset hr
            hr = S_OK;

            // Get the LastError
            pCurrent->dwLastError = GetLastError();

            // Goto Next
            goto NextFile;
        }

        // Don't need to migrate the file
        if (FILE_IS_NEWS_MESSAGES != pCurrent->tyFile && FILE_IS_IMAP_MESSAGES != pCurrent->tyFile)
        {
            // Not a file that should be migrate
            pCurrent->fMigrate = FALSE;

            // Set hrMigrate
            pCurrent->hrMigrate = S_OK;

            // Goto Next
            goto NextFile;
        }

        // De-Ref the header
        pHeader = (LPTABLEHEADERV5B1)File.pView;

        // Check the Signature...
        if (File.cbSize < sizeof(TABLEHEADERV5B1) || OBJECTDB_SIGNATURE != pHeader->dwSignature || OBJECTDB_VERSION_PRE_V5 != pHeader->wMajorVersion)
        {
            // Not a file that should be migrate
            pCurrent->fMigrate = FALSE;

            // Set hrMigrate
            pCurrent->hrMigrate = MIGRATE_E_BADVERSION;

            // Goto Next
            goto NextFile;
        }

        // Save the Number of record
        pCurrent->cRecords = pHeader->cRecords;

        // Initialize counters
        InitializeCounters(&File, pCurrent, pcMax, pcbNeeded, FALSE);

        // Yes, Migrate
        pCurrent->fMigrate = TRUE;

NextFile:
        // Close the File
        CloseMemoryFile(&File);
    }

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// DowngradeRecordV5B1
//--------------------------------------------------------------------------
HRESULT DowngradeRecordV5B1(MIGRATETOTYPE tyMigrate, LPMEMORYFILE pFile, 
    LPCHAINNODEV5B1 pNode)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               cbRecord=0;
    LPBYTE              pbData;
    LPRECORDBLOCKV5B1   pRecord;

    // Trace
    TraceCall("DowngradeRecordV5B1");

    // Invalid
    if (pNode->faRecord + sizeof(RECORDBLOCKV5B1) + pNode->cbRecord > pFile->cbSize || 0 == pNode->cbRecord)
        return TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);

    // Access the Record
    pRecord = (LPRECORDBLOCKV5B1((LPBYTE)pFile->pView + pNode->faRecord));

    // Cast the datablock
    pbData = ((LPBYTE)pRecord + sizeof(RECORDBLOCKV5B1));

    // Lets read the fields so that I can re-compute the records V2 length...
    cbRecord += sizeof(DWORD);     // dwMsgId
    cbRecord += sizeof(DWORD);     // dwFlags
    cbRecord += sizeof(FILETIME);  // ftSent
    cbRecord += sizeof(DWORD);     // cLines
    cbRecord += sizeof(DWORD);     // faStream
    cbRecord += sizeof(DWORD);     // cbArticle
    cbRecord += sizeof(FILETIME);  // ftDownloaded
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszMessageId
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszSubject;     
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszFromHeader;  
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszReferences;  
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszXref;        
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszServer;      
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszDisplayFrom; 
    cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1);   // pszEmailFrom;

    // Going to V4 ?
    if (DOWNGRADE_V5B1_TO_V4 == tyMigrate && cbRecord < pNode->cbRecord)
    {
        cbRecord += sizeof(WORD);       // wLanguage
        cbRecord += sizeof(WORD);       // wReserved
        cbRecord += sizeof(DWORD);      // cbMessage
        cbRecord += sizeof(FILETIME);   // ftReceived
        cbRecord += (lstrlen((LPSTR)(pbData + cbRecord)) + 1); // pszDisplayTo;   
    }

    // Add on Reserved
    cbRecord += (40 + sizeof(RECORDBLOCKV5B1));

    // Store the Size
    pRecord->cbRecord = cbRecord;

    // Update the Node
    pNode->cbRecord = cbRecord;

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// DowngradeIndexV5B1
//--------------------------------------------------------------------------
HRESULT DowngradeIndexV5B1(MIGRATETOTYPE tyMigrate, LPMEMORYFILE pFile, 
    LPFILEINFO pInfo, LPPROGRESSINFO pProgress, DWORD faChain)
{
    // Locals
    HRESULT             hr=S_OK;
    LONG                i;
    LPCHAINBLOCKV5B1    pChain;
    LPTABLEHEADERV5B1   pHeader;

    // Trace
    TraceCall("DowngradeIndexV5B1");

    // De-Ref the header
    pHeader = (LPTABLEHEADERV5B1)pFile->pView;

    // Nothing to validate
    if (0 == faChain)
        return S_OK;

    // Out-of-bounds
    if (faChain + CB_CHAIN_BLOCKV5B1 > pFile->cbSize)
        return TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);

    // De-ref the block
    pChain = (LPCHAINBLOCKV5B1)((LPBYTE)pFile->pView + faChain);

    // Out-of-Bounds
    if (pChain->faStart != faChain)
        return TraceResult(MIGRATE_E_BADCHAINSIGNATURE);

    // Too many nodes
    if (pChain->cNodes > BTREE_ORDER)
        return TraceResult(MIGRATE_E_TOOMANYCHAINNODES);

    // Validate Minimum Filled Constraint
    if (pChain->cNodes < BTREE_MIN_CAP && pChain->faStart != pHeader->faRootChain)
        return TraceResult(MIGRATE_E_BADMINCAPACITY);

    // Go to the left
    IF_FAILEXIT(hr = DowngradeIndexV5B1(tyMigrate, pFile, pInfo, pProgress, pChain->faLeftChain));

    // Loop throug right chains
    for (i=0; i<pChain->cNodes; i++)
    {
        // Bump Progress
        IncrementProgress(pProgress, pInfo);

        /// Downgrad this record
        IF_FAILEXIT(hr = DowngradeRecordV5B1(tyMigrate, pFile, &pChain->rgNode[i]));

        // Validate the Right Chain
        IF_FAILEXIT(hr = DowngradeIndexV5B1(tyMigrate, pFile, pInfo, pProgress, pChain->rgNode[i].faRightChain));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeFileV5B1
// --------------------------------------------------------------------------------
HRESULT DowngradeFileV5B1(MIGRATETOTYPE tyMigrate, LPFILEINFO pInfo, 
    LPPROGRESSINFO pProgress)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    LPTABLEHEADERV5B1   pHeader;

    // Trace
    TraceCall("DowngradeFileV5B1");

    // Get the File Header
    IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

    // De-Ref the header
    pHeader = (LPTABLEHEADERV5B1)File.pView;

    // Recurse Through the Index
    IF_FAILEXIT(hr = DowngradeIndexV5B1(tyMigrate, &File, pInfo, pProgress, pHeader->faRootChain));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DowngradeV5B1
// --------------------------------------------------------------------------------
HRESULT DowngradeV5B1(MIGRATETOTYPE tyMigrate, LPCSTR pszStoreRoot, 
    LPPROGRESSINFO pProgress, LPFILEINFO *ppHeadFile)
{
    // Locals
    HRESULT         hr=S_OK;
    ENUMFILEINFO    EnumInfo={0};
    LPFILEINFO      pCurrent;
    DWORD           cbNeeded;

    // Trace
    TraceCall("DowngradeV5B1");

    // Setup the EnumFile Info
    EnumInfo.pszExt = ".nch";
    EnumInfo.pszFoldFile = "folders.nch";
    EnumInfo.pszUidlFile = "pop3uidl.dat";

    // Initialize
    *ppHeadFile = NULL;

    // Enumerate All ODB files in szStoreRoot...
    IF_FAILEXIT(hr = EnumerateStoreFiles(pszStoreRoot, DIR_IS_ROOT, NULL, &EnumInfo, ppHeadFile));

    // Compute some Counts, and validate that the files are valid to migrate...
    IF_FAILEXIT(hr = DowngradeProcessFileListV5B1(*ppHeadFile, &pProgress->cMax, &cbNeeded));

    // Loop through the files and migrate each one
    for (pCurrent=*ppHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Migrate this file ?
        if (pCurrent->fMigrate)
        {
            // Set Progress File
            SetProgressFile(pProgress, pCurrent);

            // Downgrade the file
            pCurrent->hrMigrate = DowngradeFileV5B1(tyMigrate, pCurrent, pProgress);

            // Failure ?
            if (FAILED(pCurrent->hrMigrate))
                pCurrent->dwLastError = GetLastError();
        }
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\migrate\structs.h ===
//--------------------------------------------------------------------------
// Structs.h
//--------------------------------------------------------------------------
#ifndef __STRUCTS_H
#define __STRUCTS_H

//--------------------------------------------------------------------------
// OBJECTDB_SIGNATURE
//--------------------------------------------------------------------------
#define OBJECTDB_SIGNATURE 0xfe12adcf
#define BTREE_ORDER        40
#define BTREE_MIN_CAP      20

//--------------------------------------------------------------------------
// OBJECTDB_VERSION_V5B1
//--------------------------------------------------------------------------
#define OBJECTDB_VERSION_PRE_V5     2
#define OBJECTDB_VERSION_V5         5
#define ACACHE_VERSION_PRE_V5       9
#define	FLDCACHE_VERSION_PRE_V5     2
#define UIDCACHE_VERSION_PRE_V5     4

//--------------------------------------------------------------------------
// ALLOCATEPAGE
//--------------------------------------------------------------------------
typedef struct tagALLOCATEPAGE {
	DWORD			    faPage;
	DWORD				cbPage;
	DWORD				cbUsed;
} ALLOCATEPAGE, *LPALLOCATEPAGE;

//--------------------------------------------------------------------------
// TABLEHEADERV5B1
//--------------------------------------------------------------------------
typedef struct tagTABLEHEADERV5B1 {
    DWORD               dwSignature;            // 4
    WORD                wMinorVersion;          // 6
    WORD                wMajorVersion;          // 8
    DWORD               faRootChain;            // 12
    DWORD               faFreeRecordBlock;      // 16
    DWORD               faFirstRecord;          // 20
    DWORD               faLastRecord;           // 24
    DWORD               cRecords;               // 28
    DWORD               cbAllocated;            // 32
    DWORD               cbFreed;                // 34
    DWORD               dwReserved1;            // 38
    DWORD               dwReserved2;            // 42
    DWORD               cbUserData;             // 46
    DWORD               cDeletes;               // 50
    DWORD               cInserts;               // 54
    LONG                cActiveThreads;         // 58
    DWORD               dwReserved3;            // 62
    DWORD               cbStreams;              // 66
    DWORD               faFreeStreamBlock;      // 70
    DWORD               faFreeChainBlock;       // 74
    DWORD               faNextAllocate;         // 78
    DWORD               dwNextId;               // 82
	ALLOCATEPAGE	    AllocateRecord;         // 94
	ALLOCATEPAGE	    AllocateChain;          // 106
	ALLOCATEPAGE	    AllocateStream;         // 118
    BYTE                fCorrupt;               // 119
    BYTE                fCorruptCheck;          // 120
    BYTE                rgReserved[190];        // 310
} TABLEHEADERV5B1, *LPTABLEHEADERV5B1;

//--------------------------------------------------------------------------
// TABLEHEADERV5
//--------------------------------------------------------------------------
typedef struct tagTABLEHEADERV5 {
    DWORD               dwSignature;          // 4
    CLSID               clsidExtension;       // 20
    DWORD               dwMinorVersion;       // 24
    DWORD               dwMajorVersion;       // 28
    DWORD               cbUserData;           // 32
    DWORD               rgfaIndex[32];        // 160
    DWORD               faFirstRecord;        // 164
    DWORD               faLastRecord;         // 168
	ALLOCATEPAGE		AllocateRecord;       // 180
	ALLOCATEPAGE		AllocateChain;        // 192
	ALLOCATEPAGE		AllocateStream;       // 204
    DWORD               faFreeRecordBlock;    // 208
    DWORD               faFreeStreamBlock;    // 212
    DWORD               faFreeChainBlock;     // 216
    DWORD               faNextAllocate;       // 220
    DWORD               cbAllocated;          // 224
    DWORD               cbFreed;              // 228
    DWORD               cbStreams;            // 232
    DWORD               cRecords;             // 236
    DWORD               dwNextId;             // 240
    DWORD               fCorrupt;             // 244
    DWORD               fCorruptCheck;        // 248
    DWORD               cActiveThreads;       // 252
    BYTE                rgReserved[58];       // 310
} TABLEHEADERV5, *LPTABLEHEADERV5;

//--------------------------------------------------------------------------
// CHAINNODEV5B1
//--------------------------------------------------------------------------
typedef struct tagCHAINNODEV5B1 {
    DWORD               faRecord;
    DWORD               cbRecord;
    DWORD               faRightChain;
} CHAINNODEV5B1, *LPCHAINNODEV5B1;

//--------------------------------------------------------------------------
// CHAINBLOCKV5B1
//--------------------------------------------------------------------------
typedef struct tagCHAINBLOCKV5B1 {
    DWORD               faStart;
    LONG                cNodes;
    DWORD               faLeftChain;
    CHAINNODEV5B1       rgNode[BTREE_ORDER + 1];
} CHAINBLOCKV5B1, *LPCHAINBLOCKV5B1;

#define CB_CHAIN_BLOCKV5B1 (sizeof(CHAINBLOCKV5B1) - sizeof(CHAINNODEV5B1))

//--------------------------------------------------------------------------
// CHAINNODEV5 - 492 bytes
//--------------------------------------------------------------------------
typedef struct tagCHAINNODEV5 {
    DWORD               faRecord;
    DWORD               faRightChain;
    DWORD               cRightNodes;                /* $V2$ */ 
} CHAINNODEV5, *LPCHAINNODEV5;

//--------------------------------------------------------------------------
// CHAINBLOCKV5 - 20 Bytes
//--------------------------------------------------------------------------
typedef struct tagCHAINBLOCKV5 {
    DWORD               faStart;
    DWORD               faLeftChain;
    DWORD               faParent;                   /* $V2$ */ 
    BYTE                iParent;                    /* $V2$ */ 
    BYTE                cNodes;
    WORD                wReserved;                  /* $V2$ */ 
    DWORD               cLeftNodes;                 /* $V2$ */ 
    CHAINNODEV5         rgNode[BTREE_ORDER + 1];
} CHAINBLOCKV5, *LPCHAINBLOCKV5;

#define CB_CHAIN_BLOCKV5 (sizeof(CHAINBLOCKV5))

//--------------------------------------------------------------------------
// RECORDBLOCKV5B1
//--------------------------------------------------------------------------
typedef struct tagRECORDBLOCKV5B1 {
    DWORD               faRecord;
    DWORD               cbRecord;
    DWORD               faNext;
    DWORD               faPrevious;
} RECORDBLOCKV5B1, *LPRECORDBLOCKV5B1;

//--------------------------------------------------------------------------
// RECORDBLOCKV5
//--------------------------------------------------------------------------
typedef struct tagRECORDBLOCKV5 {
    DWORD               faRecord;
    DWORD               cbRecord;
    DWORD               dwVersion;                  /* $V2$ */
    WORD                wFlags;                     /* $V2$ */
    WORD                cColumns;                   /* $V2$ */
    WORD                wFormat;                    /* $V2$ */
    WORD                wReserved;                  /* $V2$ */
    DWORD               faNext;
    DWORD               faPrevious;
} RECORDBLOCKV5, *LPRECORDBLOCKV5;

//--------------------------------------------------------------------------
// STREAMBLOCK
//--------------------------------------------------------------------------
typedef struct tagSTREAMBLOCK {
    DWORD               faThis;
    DWORD               cbBlock;
    DWORD               cbData;
    DWORD               faNext;
} STREAMBLOCK, *LPSTREAMBLOCK;

// --------------------------------------------------------------------------------
// Old Storage Migration Version and Signatures
// --------------------------------------------------------------------------------
#define MSGFILE_VER     0x00010003 // 1.0003
#define MSGFILE_MAGIC   0x36464d4a
#define CACHEFILE_VER   0x00010004 // 1.0004
#define CACHEFILE_MAGIC 0x39464d4a
#define MAIL_BLOB_VER   0x00010010 // 1.8 Opie Likes to change this a lot !!!
#define MSGHDR_MAGIC    0x7f007f00  // as bytes "0x00, 0x7f, 0x00, 0x7f"
#define MSG_HEADER_VERSISON ((WORD)1)

// --------------------------------------------------------------------------------
// MBXFILEHEADER
// --------------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagMBXFILEHEADER {
    DWORD               dwMagic;
    DWORD               ver;
    DWORD               cMsg;
    DWORD               msgidLast;
    DWORD               cbValid;
    DWORD               dwFlags;
    DWORD               dwReserved[15];
} MBXFILEHEADER, *LPMBXFILEHEADER;
#pragma pack()

// --------------------------------------------------------------------------------
// MBXMESSAGEHEADER
// --------------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagMBXMESSAGEHEADER {
    DWORD               dwMagic;
    DWORD               msgid;
    DWORD               dwMsgSize;
    DWORD               dwBodySize;
} MBXMESSAGEHEADER, *LPMBXMESSAGEHEADER;
#pragma pack()

// --------------------------------------------------------------------------------
// IDXFILEHEADER
// --------------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagIDXFILEHEADER {
    DWORD               dwMagic;
        DWORD               ver;
    DWORD               cMsg;
    DWORD               cbValid;
    DWORD               dwFlags;
    DWORD               verBlob;
    DWORD               dwReserved[14];
} IDXFILEHEADER, *LPIDXFILEHEADER;
#pragma pack()

// --------------------------------------------------------------------------------
// IDXMESSAGEHEADER
// --------------------------------------------------------------------------------
#pragma pack(4)
typedef struct tagIDXMESSAGEHEADER {
    DWORD               dwState;
    DWORD               dwLanguage;
    DWORD               msgid;
    DWORD               dwHdrOffset;
    DWORD               dwSize;
    DWORD               dwOffset;
    DWORD               dwMsgSize;
    DWORD               dwHdrSize;
    BYTE                rgbHdr[4];
} IDXMESSAGEHEADER, *LPIDXMESSAGEHEADER;
#pragma pack()

// --------------------------------------------------------------------------------
// FOLDERUSERDATAV4
// --------------------------------------------------------------------------------
typedef struct tagFOLDERUSERDATAV4 {
    DWORD           cbCachedArticles;
    DWORD           cCachedArticles;
    FILETIME        ftOldestArticle;
    DWORD           dwFlags;
    DWORD           dwNextArticleNumber;
    TCHAR           szServer[256];
    TCHAR           szGroup[256];
    DWORD           dwUIDValidity;
    BYTE            rgReserved[1020];
} FOLDERUSERDATAV4, *LPFOLDERUSERDATAV4;

// --------------------------------------------------------------------------------
// FLDINFO
// --------------------------------------------------------------------------------
#pragma pack(1)
typedef struct tagFLDINFO {
    DWORD       idFolder;
    CHAR        szFolder[259];
    CHAR        szFile[260];
    DWORD       idParent;
    DWORD       idChild;
    DWORD       idSibling;
    DWORD       tySpecial;
    DWORD       cChildren;
    DWORD       cMessages;
    DWORD       cUnread;
    DWORD       cbTotal;
    DWORD       cbUsed;
    BYTE        bHierarchy;
    DWORD       dwImapFlags;
    BYTE        bListStamp;
    BYTE        bReserved[3];
    DWORD_PTR   idNewFolderId;
} FLDINFO, *LPFLDINFO;
#pragma pack()

// --------------------------------------------------------------------------------
// IDXMESSAGEHEADER
// --------------------------------------------------------------------------------
#define GROUPLISTVERSION 0x3
#pragma pack(1)
typedef struct tagGRPLISTHEADER {
    DWORD               dwVersion;
    CHAR                szDate[14];
    DWORD               cGroups;
} GRPLISTHEADER, *LPGRPLISTHEADER;
#pragma pack()

// --------------------------------------------------------------------------------
// Sublist Structures
// --------------------------------------------------------------------------------
#define SUBFILE_VERSION5    0xFFEAEA05
#define SUBFILE_VERSION4    0xFFEAEA04
#define SUBFILE_VERSION3    0xFFEAEA03
#define SUBFILE_VERSION2    0xFFEAEA02

typedef struct tagSUBLISTHEADER {
    DWORD               dwVersion;
    DWORD               cSubscribed;
} SUBLISTHEADER, *LPSUBLISTHEADER;

#define GSF_SUBSCRIBED      0x00000001
#define GSF_MARKDOWNLOAD    0x00000002      // We use this to persist the groups which have been marked for download
#define GSF_DOWNLOADHEADERS 0x00000004
#define GSF_DOWNLOADNEW     0x00000008
#define GSF_DOWNLOADALL     0x00000010
#define GSF_GROUPTYPEKNOWN  0x00000020
#define GSF_MODERATED       0x00000040
#define GSF_BLOCKED         0x00000080
#define GSF_NOPOSTING       0x00000100

typedef struct tagGROUPSTATUS5 {
    DWORD   dwFlags;            // subscription status, posting, etc.
    DWORD   dwReserved;         // reserved for future use
    ULONG   ulServerHigh;       // highest numbered article on server
    ULONG   ulServerLow;        // lowest numbered article on server
    ULONG   ulServerCount;      // count of articles on server
    ULONG   ulClientHigh;       // highest numbered article known to client
    ULONG   ulClientLow;        // lowest numbered article known to client
    ULONG   ulClientCount;      // count of articles known to client
    ULONG   ulClientUnread;     // count of unread articles known to client
    ULONG   cbName;             // length of group name string (including \0)
    ULONG   cbReadRange;        // length of read range data
    ULONG   cbKnownRange;       // length of known range data
    ULONG   cbMarkedRange;      // length of marked range data
    ULONG   cbRequestedRange;   // length of range of data req from server
    DWORD   dwCacheFileIndex;   // cache file number
} GROUPSTATUS5, * PGROUPSTATUS5;

typedef struct tagGROUPSTATUS4 {
    DWORD   dwFlags;            // subscription status, posting, etc.
    DWORD   dwReserved;         // reserved for future use
    ULONG   ulServerHigh;       // highest numbered article on server
    ULONG   ulServerLow;        // lowest numbered article on server
    ULONG   ulServerCount;      // count of articles on server
    ULONG   ulClientHigh;       // highest numbered article known to client
    ULONG   ulClientLow;        // lowest numbered article known to client
    ULONG   ulClientCount;      // count of articles known to client
    ULONG   ulClientUnread;     // count of unread articles known to client
    ULONG   cbName;             // length of group name string (including \0)
    ULONG   cbReadRange;        // length of read range data
    ULONG   cbKnownRange;       // length of known range data
    ULONG   cbMarkedRange;      // length of marked range data
    ULONG   cbRequestedRange;   // length of range of data req from server
} GROUPSTATUS4, * PGROUPSTATUS4;

typedef struct tagGROUPSTATUS3 {
    DWORD   dwFlags;            // subscription status, posting, etc.
    DWORD   dwReserved;         // reserved for future use
    ULONG   ulServerHigh;       // highest numbered article on server
    ULONG   ulServerLow;        // lowest numbered article on server
    ULONG   ulServerCount;      // count of articles on server
    ULONG   ulClientHigh;       // highest numbered article known to client
    ULONG   ulClientLow;        // lowest numbered article known to client
    ULONG   ulClientCount;      // count of articles known to client
    ULONG   ulClientUnread;     // count of unread articles known to client
    ULONG   cbName;             // length of group name string (including \0)
    ULONG   cbReadRange;        // length of read range data
    ULONG   cbKnownRange;       // length of known range data
    ULONG   cbMarkedRange;      // length of marked range data
} GROUPSTATUS3, * PGROUPSTATUS3;

typedef struct tagGROUPSTATUS2 {
    BOOL    fSubscribed;        // subscription status
    BOOL    fPosting;           // posting allowed?
    ULONG   ulServerHigh;       // highest numbered article on server
    ULONG   ulServerLow;        // lowest numbered article on server
    ULONG   ulServerCount;      // count of articles on server
    ULONG   ulClientHigh;       // highest numbered article known to client
    ULONG   ulClientLow;        // lowest numbered article known to client
    ULONG   ulClientCount;      // count of articles known to client
    ULONG   ulClientUnread;     // count of unread articles known to client
    ULONG   cbName;             // length of group name string (including \0)
    ULONG   cbReadRange;        // length of read range data
    ULONG   cbKnownRange;       // length of known range data
} GROUPSTATUS2, * PGROUPSTATUS2;

#endif // __STRUCTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\migrate\utility.h ===
// --------------------------------------------------------------------------------
// Utility.h
// --------------------------------------------------------------------------------
#ifndef __UTILITY_H
#define __UTILITY_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include <shared.h>

// --------------------------------------------------------------------------------
// DWORDALIGN
// --------------------------------------------------------------------------------
#define DWORDALIGN(_cb) ((_cb % 4 != 0) ? (_cb += (4 - (_cb % 4))) : _cb)

// --------------------------------------------------------------------------------
// DIRTYPE
// --------------------------------------------------------------------------------
typedef enum tagDIRTYPE {
    DIR_IS_ROOT,
    DIR_IS_LOCAL,
    DIR_IS_NEWS,
    DIR_IS_IMAP
} DIRTYPE;

// --------------------------------------------------------------------------------
// ACCOUNTINFO
// --------------------------------------------------------------------------------
typedef struct tagACCOUNTINFO *LPACCOUNTINFO;
typedef struct tagACCOUNTINFO {
    CHAR            szAcctId[CCHMAX_ACCOUNT_NAME];
    CHAR            szAcctName[CCHMAX_ACCOUNT_NAME];
    CHAR            szDirectory[MAX_PATH];
    CHAR            szDataDir[MAX_PATH];
    CHAR            szServer[CCHMAX_SERVER_NAME];
    DWORD           dwServer;
} ACCOUNTINFO;

// --------------------------------------------------------------------------------
// ACCOUNTTABLE
// --------------------------------------------------------------------------------
typedef struct tagACCOUNTTABLE {
    DWORD           cAccounts;
    LPACCOUNTINFO   prgAccount;
} ACCOUNTTABLE, *LPACCOUNTTABLE;

// --------------------------------------------------------------------------------
// FILETYPE
// --------------------------------------------------------------------------------
typedef enum tagFILETYPE {
    FILE_IS_LOCAL_MESSAGES,
    FILE_IS_NEWS_MESSAGES,
    FILE_IS_IMAP_MESSAGES,
    FILE_IS_POP3UIDL,
    FILE_IS_LOCAL_FOLDERS,
    FILE_IS_IMAP_FOLDERS,
    FILE_IS_NEWS_SUBLIST,
    FILE_IS_NEWS_GRPLIST
} FILETYPE;

// --------------------------------------------------------------------------------
// ENUMFILEINFO
// --------------------------------------------------------------------------------
typedef struct tagENUMFILEINFO {
    LPSTR           pszExt;
    LPSTR           pszFoldFile;
    LPSTR           pszUidlFile;
    LPSTR           pszSubList;
    LPSTR           pszGrpList;
    BOOL            fFindV1News;
} ENUMFILEINFO, *LPENUMFILEINFO;

// --------------------------------------------------------------------------------
// FILEINFO
// --------------------------------------------------------------------------------
typedef struct tagFILEINFO *LPFILEINFO;
typedef struct tagFILEINFO {
    CHAR            szFilePath[MAX_PATH + MAX_PATH];
    CHAR            szDstFile[MAX_PATH + MAX_PATH];
    CHAR            szAcctId[CCHMAX_ACCOUNT_NAME];
    CHAR            szFolder[255];
    DWORD           fMigrate;
    HRESULT         hrMigrate;
    DWORD           dwLastError;
    DWORD           cbFile;
    DWORD           cRecords;
    DWORD           cProgInc;
    DWORD           cProgCur;
    DWORD           cProgMax;
    FILETYPE        tyFile;
    DWORD           dwServer;
    DWORD           idFolder;
    BOOL            fInStore;
    DWORD           cUnread;
    DWORD           cMessages;
    LPFILEINFO      pNext;
} FILEINFO;

// --------------------------------------------------------------------------------
// PROGRESSINFO
// --------------------------------------------------------------------------------
typedef struct tagPROGRESSINFO {
    HWND            hwndProgress;
    DWORD           cCurrent;
    DWORD           cMax;
    DWORD           cPercent;
} PROGRESSINFO, *LPPROGRESSINFO;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
HRESULT EnumerateStoreFiles(LPCSTR pszPath, DIRTYPE tyDir, LPCSTR pszSubDir, LPENUMFILEINFO pEnumInfo, LPFILEINFO *ppHead);
HRESULT FreeFileList(LPFILEINFO *ppHead);
INT_PTR CALLBACK MigrageDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void IncrementProgress(LPPROGRESSINFO pProgress, LPFILEINFO pInfo);
HRESULT WriteMigrationLogFile(HRESULT hrMigrate, DWORD dwLastError, LPCSTR pszStoreRoot, LPCSTR pszMigrate, LPCSTR pszCmdLine, LPFILEINFO pHeadFile);
HRESULT BlobReadData(LPBYTE lpbBlob, ULONG cbBlob, ULONG *pib, LPBYTE lpbData, ULONG cbData);
HRESULT GetAvailableDiskSpace(LPCSTR pszFilePath, DWORDLONG *pdwlFree);
void ReplaceExtension(LPCSTR pszFilePath, LPCSTR pszExtNew, LPSTR pszFilePathNew, int cchFilePathNew);
HRESULT MyWriteFile(HANDLE hFile, DWORD faAddress, LPVOID pData, DWORD cbData);
void SetProgressFile(LPPROGRESSINFO pProgress, LPFILEINFO pInfo);
UINT MigrateMessageBox(LPCSTR pszMsg, UINT uType);
void InitializeCounters(LPMEMORYFILE pFile, LPFILEINFO pInfo, LPDWORD pcMax, LPDWORD pcbNeeded, BOOL fInflate);
HRESULT BuildAccountTable(HKEY hkeyBase, LPCSTR pszRegRoot,  LPCSTR pszStoreRoot, LPACCOUNTTABLE pAcctTbl);

#endif // __UTILITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\migrate\upoe5.cpp ===
// --------------------------------------------------------------------------------
// upoe5.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "utility.h"
#include "migrate.h"
#include "migerror.h"
#include "structs.h"
#include "resource.h"
#define DEFINE_DIRECTDB
#include <shared.h>
#include <oestore.h>
#include <oerules.h>
#include <mimeole.h>
#include "msident.h"

// --------------------------------------------------------------------------------
// Linearly Incrementing Folder Id
// --------------------------------------------------------------------------------
static DWORD g_idFolderNext=1000;
extern BOOL g_fQuiet;

// --------------------------------------------------------------------------------
// FOLDERIDCHANGE
// --------------------------------------------------------------------------------
typedef struct tagFOLDERIDCHANGE {
    FOLDERID        idOld;
    FOLDERID        idNew;
} FOLDERIDCHANGE, *LPFOLDERIDCHANGE;

// --------------------------------------------------------------------------------
// Forward Declarations
// --------------------------------------------------------------------------------
HRESULT SetIMAPSpecialFldrType(LPSTR pszAcctID, LPSTR pszFldrName, SPECIALFOLDER *psfType);

// --------------------------------------------------------------------------------
// SplitMailCacheBlob
// --------------------------------------------------------------------------------
HRESULT SplitMailCacheBlob(IMimePropertySet *pNormalizer, LPBYTE pbCacheInfo, 
    DWORD cbCacheInfo, LPMESSAGEINFO pMsgInfo, LPSTR *ppszNormal, LPBLOB pOffsets)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           ib;
    ULONG           cbTree;
    ULONG           cbProps;
    WORD            wVersion;
    DWORD           dw;
    DWORD           cbMsg;
    DWORD           dwFlags;
    WORD            wPriority;
    PROPVARIANT     Variant;

    // Invalid Arg
    Assert(pbCacheInfo && cbCacheInfo && pMsgInfo);

    // Init
    ZeroMemory(pOffsets, sizeof(BLOB));

    // Read Version
    ib = 0;
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&wVersion, sizeof(wVersion)));

    // Version Check
    if (wVersion != MSG_HEADER_VERSISON)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Read Flags
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dwFlags, sizeof(dwFlags)));

    // IMF_ATTACHMENTS
    if (ISFLAGSET(dwFlags, IMF_ATTACHMENTS))
        FLAGSET(pMsgInfo->dwFlags, ARF_HASATTACH);

    // IMF_SIGNED
    if (ISFLAGSET(dwFlags, IMF_SIGNED))
        FLAGSET(pMsgInfo->dwFlags, ARF_SIGNED);

    // IMF_ENCRYPTED
    if (ISFLAGSET(dwFlags, IMF_ENCRYPTED))
        FLAGSET(pMsgInfo->dwFlags, ARF_ENCRYPTED);

    // IMF_VOICEMAIL
    if (ISFLAGSET(dwFlags, IMF_VOICEMAIL))
        FLAGSET(pMsgInfo->dwFlags, ARF_VOICEMAIL);

    // IMF_NEWS
    if (ISFLAGSET(dwFlags, IMF_NEWS))
        FLAGSET(pMsgInfo->dwFlags, ARF_NEWSMSG);

    // Read Reserved
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));

    // Read Message Size
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&cbMsg, sizeof(cbMsg)));

    // Read Byte Count for the content list
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&cbTree, sizeof(cbTree)));

    // Does the user want the tree ?
    if (cbTree)
    {
        pOffsets->pBlobData = (pbCacheInfo + ib);
        pOffsets->cbSize = cbTree;
    }

    // Increment passed the tree
    ib += cbTree;

    // Read Byte Count for the content list
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&cbProps, sizeof(cbProps)));

    // Partial Number
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&pMsgInfo->dwPartial, sizeof(pMsgInfo->dwPartial)));

    // Receive Time
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&pMsgInfo->ftReceived, sizeof(pMsgInfo->ftReceived)));

    // Sent Time
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&pMsgInfo->ftSent, sizeof(pMsgInfo->ftSent)));

    // Priority
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&wPriority, sizeof(wPriority)));

    // Pritority
    pMsgInfo->wPriority = wPriority;

    // Subject
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszSubject = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Init the Normalizer
    pNormalizer->InitNew();

    // Set the Subject
    Variant.vt = VT_LPSTR;
    Variant.pszVal = pMsgInfo->pszSubject;

    // Set the Property
    IF_FAILEXIT(hr = pNormalizer->SetProp(PIDTOSTR(PID_HDR_SUBJECT), 0, &Variant));

    // Get the Normalized Subject back out
    if (SUCCEEDED(pNormalizer->GetProp(PIDTOSTR(PID_ATT_NORMSUBJ), 0, &Variant)))
        *ppszNormal = pMsgInfo->pszNormalSubj = Variant.pszVal;

    // Otherwise, just use the subject
    else
        pMsgInfo->pszNormalSubj = pMsgInfo->pszSubject;

    // Display To
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszDisplayTo = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Display From
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszDisplayFrom = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Server
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszServer = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // UIDL
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszUidl = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // User Name
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    //pMsgInfo->pszUserName = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Account Name
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszAcctName = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Partial Id
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszPartialId = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Forward To
    IF_FAILEXIT(hr = BlobReadData(pbCacheInfo, cbCacheInfo, &ib, (LPBYTE)&dw, sizeof(dw)));
    pMsgInfo->pszForwardTo = (LPSTR)(pbCacheInfo + ib);
    ib += dw;

    // Sanity Check
    Assert(ib == cbCacheInfo);

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// GetMsgInfoFromPropertySet
//--------------------------------------------------------------------------
HRESULT GetMsgInfoFromPropertySet(
        /* in */        IMimePropertySet           *pPropertySet,
        /* in,out */    LPMESSAGEINFO                   pMsgInfo)
{
    // Locals
    HRESULT             hr=S_OK;
    IMSGPRIORITY        priority;
    PROPVARIANT         Variant;
    SYSTEMTIME          st;
    FILETIME            ftCurrent;
    IMimeAddressTable  *pAdrTable=NULL;

    // Trace
    TraceCall("GetMsgInfoFromPropertySet");

    // Invalid Args
    Assert(pPropertySet && pMsgInfo);

    // Default Sent and Received Times...
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ftCurrent);

    // Set Variant tyStore
    Variant.vt = VT_UI4;

    // Priority
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &Variant)))
    {
        // Set Priority
        pMsgInfo->wPriority = (WORD)Variant.ulVal;
    }

    // Partial Numbers...
    if (pPropertySet->IsContentType(STR_CNT_MESSAGE, STR_SUB_PARTIAL) == S_OK)
    {
        // Locals
        WORD cParts=0, iPart=0;

        // Get Total
        if (SUCCEEDED(pPropertySet->GetProp(STR_PAR_TOTAL, NOFLAGS, &Variant)))
            cParts = (WORD)Variant.ulVal;

        // Get Number
        if (SUCCEEDED(pPropertySet->GetProp(STR_PAR_NUMBER, NOFLAGS, &Variant)))
            iPart = (WORD)Variant.ulVal;

        // Set Parts
        pMsgInfo->dwPartial = MAKELONG(cParts, iPart);
    }

    // Otherwise, check for user property
    else if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_COMBINED), NOFLAGS, &Variant)))
    {
        // Set the Partial Id
        pMsgInfo->dwPartial = Variant.ulVal;
    }

    // Getting some file times
    Variant.vt = VT_FILETIME;

    // Get Received Time...
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &Variant)))
        pMsgInfo->ftReceived = Variant.filetime;
    else
        pMsgInfo->ftReceived = ftCurrent;

    // Get Sent Time...
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &Variant)))
        pMsgInfo->ftSent = Variant.filetime;
    else
        pMsgInfo->ftSent = ftCurrent;

    // Get Address Table
    IF_FAILEXIT(hr = pPropertySet->BindToObject(IID_IMimeAddressTable, (LPVOID *)&pAdrTable));

    // Display From
    pAdrTable->GetFormat(IAT_FROM, AFT_DISPLAY_FRIENDLY, &pMsgInfo->pszDisplayFrom);

    // Display To
    pAdrTable->GetFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &pMsgInfo->pszDisplayTo);

    // String Properties
    Variant.vt = VT_LPSTR;

    // pszDisplayFrom as newsgroups
    if (NULL == pMsgInfo->pszDisplayFrom && SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, &Variant)))
        pMsgInfo->pszDisplayFrom = Variant.pszVal;

    // pszMessageId
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &Variant)))
        pMsgInfo->pszMessageId = Variant.pszVal;

    // pszXref
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_XREF), NOFLAGS, &Variant)))
        pMsgInfo->pszXref = Variant.pszVal;

    // pszReferences
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(STR_HDR_REFS), NOFLAGS, &Variant)))
        pMsgInfo->pszReferences = Variant.pszVal;

    // pszSubject
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &Variant)))
        pMsgInfo->pszSubject = Variant.pszVal;

    // Normalized Subject
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_NORMSUBJ), NOFLAGS, &Variant)))
        pMsgInfo->pszNormalSubj = Variant.pszVal;

    // pszAccount
    if (SUCCEEDED(pPropertySet->GetProp(STR_ATT_ACCOUNTNAME, NOFLAGS, &Variant)))
        pMsgInfo->pszAcctName = Variant.pszVal;

    // pszServer
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_SERVER), NOFLAGS, &Variant)))
        pMsgInfo->pszServer = Variant.pszVal;

    // pszUidl
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_UIDL), NOFLAGS, &Variant)))
        pMsgInfo->pszUidl = Variant.pszVal;

    // pszPartialId
    if (pMsgInfo->dwPartial != 0 && SUCCEEDED(pPropertySet->GetProp(STR_PAR_ID, NOFLAGS, &Variant)))
        pMsgInfo->pszPartialId = Variant.pszVal;

    // ForwardTo
    if (SUCCEEDED(pPropertySet->GetProp(PIDTOSTR(PID_ATT_FORWARDTO), NOFLAGS, &Variant)))
        pMsgInfo->pszForwardTo = Variant.pszVal;

exit:
    // Cleanup
    SafeRelease(pAdrTable);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// GetMsgInfoFromMessage
//--------------------------------------------------------------------------
HRESULT GetMsgInfoFromMessage(IMimeMessage *pMessage, LPMESSAGEINFO pMsgInfo,
    LPBLOB pOffsets)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dwImf;
    IMSGPRIORITY        priority;
    PROPVARIANT         Variant;
    SYSTEMTIME          st;
    FILETIME            ftCurrent;
    CByteStream         cByteStm;
    IMimePropertySet   *pPropertySet=NULL;

    // Trace
    TraceCall("GetMsgInfoFromMessage");

    // Invalid Args
    Assert(pMessage && pMsgInfo);

    // Get the Root Property Set from the Message
    IF_FAILEXIT(hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pPropertySet));

    // File pMsgInfo from pPropertySet
    IF_FAILEXIT(hr = GetMsgInfoFromPropertySet(pPropertySet, pMsgInfo));

    // Get Message Flags
    if (SUCCEEDED(pMessage->GetFlags(&dwImf)))
    {
        // IMF_ATTACHMENTS
        if (ISFLAGSET(dwImf, IMF_ATTACHMENTS))
            FLAGSET(pMsgInfo->dwFlags, ARF_HASATTACH);

        // IMF_SIGNED
        if (ISFLAGSET(dwImf, IMF_SIGNED))
            FLAGSET(pMsgInfo->dwFlags, ARF_SIGNED);

        // IMF_ENCRYPTED
        if (ISFLAGSET(dwImf, IMF_ENCRYPTED))
            FLAGSET(pMsgInfo->dwFlags, ARF_ENCRYPTED);

        // IMF_VOICEMAIL
        if (ISFLAGSET(dwImf, IMF_VOICEMAIL))
            FLAGSET(pMsgInfo->dwFlags, ARF_VOICEMAIL);

        // IMF_NEWS
        if (ISFLAGSET(dwImf, IMF_NEWS))
            FLAGSET(pMsgInfo->dwFlags, ARF_NEWSMSG);
    }

    // Get the Message Size
    pMessage->GetMessageSize(&pMsgInfo->cbMessage, 0);

    // Create the offset table
    if (SUCCEEDED(pMessage->SaveOffsetTable(&cByteStm, 0)))
    {
        // pull the Bytes out of cByteStm
        cByteStm.AcquireBytes(&pOffsets->cbSize, &pOffsets->pBlobData, ACQ_DISPLACE);
    }

exit:
    // Cleanup
    SafeRelease(pPropertySet);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// FreeMsgInfo
//--------------------------------------------------------------------------
void FreeMsgInfo(
        /* in,out */    LPMESSAGEINFO                   pMsgInfo)
{
    // Trace
    TraceCall("FreeMsgInfo");

    // Invalid Args
    Assert(pMsgInfo && NULL == pMsgInfo->pAllocated);

    // Free The Dude
    g_pMalloc->Free(pMsgInfo->pszMessageId);
    g_pMalloc->Free(pMsgInfo->pszNormalSubj);
    g_pMalloc->Free(pMsgInfo->pszSubject);
    g_pMalloc->Free(pMsgInfo->pszFromHeader);
    g_pMalloc->Free(pMsgInfo->pszReferences);
    g_pMalloc->Free(pMsgInfo->pszXref);
    g_pMalloc->Free(pMsgInfo->pszServer);
    g_pMalloc->Free(pMsgInfo->pszDisplayFrom);
    g_pMalloc->Free(pMsgInfo->pszEmailFrom);
    g_pMalloc->Free(pMsgInfo->pszDisplayTo);
    g_pMalloc->Free(pMsgInfo->pszUidl);
    g_pMalloc->Free(pMsgInfo->pszPartialId);
    g_pMalloc->Free(pMsgInfo->pszForwardTo);
    g_pMalloc->Free(pMsgInfo->pszAcctName);
    g_pMalloc->Free(pMsgInfo->pszAcctId);

    // Zero It
    ZeroMemory(pMsgInfo, sizeof(MESSAGEINFO));
}

// --------------------------------------------------------------------------------
// UpgradeLocalStoreFileV5
// --------------------------------------------------------------------------------
HRESULT UpgradeLocalStoreFileV5(LPFILEINFO pInfo, LPMEMORYFILE pFile,
    IDatabase *pDB, LPPROGRESSINFO pProgress, BOOL *pfContinue)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                szIdxPath[MAX_PATH];
    DWORD               i;
    LPBYTE              pbStream;
    LPBYTE              pbCacheBlob;
    SYSTEMTIME          st;
    MESSAGEINFO         MsgInfo={0};
    LPSTR               pszNormal=NULL;
    MESSAGEINFO         MsgInfoFree={0};
    DWORD               faIdxRead;
    IStream            *pStream=NULL;
    IMimeMessage       *pMessage=NULL;
    BLOB                Offsets;
    LPBYTE              pbFree=NULL;
    MEMORYFILE          IdxFile;
    LPMEMORYFILE        pIdxFile=NULL;
    LPMEMORYFILE        pMbxFile=pFile;
    LPMBXFILEHEADER     pMbxHeader=NULL;
    LPIDXFILEHEADER     pIdxHeader=NULL;
    LPIDXMESSAGEHEADER  pIdxMessage=NULL;
    LPMBXMESSAGEHEADER  pMbxMessage=NULL;
    IMimePropertySet   *pNormalizer=NULL;
    LARGE_INTEGER       liOrigin={0,0};

    // Trace
    TraceCall("UpgradeLocalStoreFileV5");

    // Get System Time
    GetSystemTime(&st);

    // Create a Property Set for Normalizing Subjects
    IF_FAILEXIT(hr = CoCreateInstance(CLSID_IMimePropertySet, NULL, CLSCTX_INPROC_SERVER, IID_IMimePropertySet, (LPVOID *)&pNormalizer));

    // Split the Path
    ReplaceExtension(pInfo->szFilePath, ".idx", szIdxPath, ARRAYSIZE(szIdxPath));

    // Open the memory file
    hr = OpenMemoryFile(szIdxPath, &IdxFile);
    if (FAILED(hr))
    {
        *pfContinue = TRUE;
        TraceResult(hr);
        goto exit;
    }

    // Set pIdxFile
    pIdxFile = &IdxFile;

    // Don't use pFile
    pFile = NULL;

    // Read the Mbx File Header
    pMbxHeader = (LPMBXFILEHEADER)(pMbxFile->pView);

    // Read the Idx File Header
    pIdxHeader = (LPIDXFILEHEADER)(pIdxFile->pView);

    // Validate the Version of th idx file
    if (pIdxHeader->ver != CACHEFILE_VER || pIdxHeader->dwMagic != CACHEFILE_MAGIC)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_INVALIDIDXHEADER);
        goto exit;
    }

    // Setup faIdxRead
    faIdxRead = sizeof(IDXFILEHEADER);

    // Prepare to Loop
    for (i=0; i<pIdxHeader->cMsg; i++)
    {
        // Done
        if (faIdxRead >= pIdxFile->cbSize)
            break;

        // Read an idx message header
        pIdxMessage = (LPIDXMESSAGEHEADER)((LPBYTE)pIdxFile->pView + faIdxRead);

        // If this message is not marked as deleted...
        if (ISFLAGSET(pIdxMessage->dwState, MSG_DELETED))
            goto NextMessage;

        // Zero Out the MsgInfo Structure
        ZeroMemory(&MsgInfo, sizeof(MESSAGEINFO));

        // Start filling message
        MsgInfo.idMessage = (MESSAGEID)IntToPtr(pIdxMessage->msgid);

        // Fixup the Flags
        if (FALSE == ISFLAGSET(pIdxMessage->dwState, MSG_UNREAD))
            FLAGSET(MsgInfo.dwFlags, ARF_READ);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_VOICEMAIL))
            FLAGSET(MsgInfo.dwFlags, ARF_VOICEMAIL);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_REPLIED))
            FLAGSET(MsgInfo.dwFlags, ARF_REPLIED);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_FORWARDED))
            FLAGSET(MsgInfo.dwFlags, ARF_FORWARDED);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_FLAGGED))
            FLAGSET(MsgInfo.dwFlags, ARF_FLAGGED);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_RCPTSENT))
            FLAGSET(MsgInfo.dwFlags, ARF_RCPTSENT);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_NOSECUI))
            FLAGSET(MsgInfo.dwFlags, ARF_NOSECUI);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_NEWSMSG))
            FLAGSET(MsgInfo.dwFlags, ARF_NEWSMSG);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_UNSENT))
            FLAGSET(MsgInfo.dwFlags, ARF_UNSENT);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_SUBMITTED))
            FLAGSET(MsgInfo.dwFlags, ARF_SUBMITTED);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_RECEIVED))
            FLAGSET(MsgInfo.dwFlags, ARF_RECEIVED);

        // Zero Offsets
        ZeroMemory(&Offsets, sizeof(BLOB));

        // Do the Blob
        if (pIdxHeader->verBlob == MAIL_BLOB_VER)
        {
            // Get the blob
            pbCacheBlob = (LPBYTE)((LPBYTE)pIdxFile->pView + (faIdxRead + (sizeof(IDXMESSAGEHEADER) - 4)));

            // Split the Cache Blob
            if (FAILED(SplitMailCacheBlob(pNormalizer, pbCacheBlob, pIdxMessage->dwHdrSize, &MsgInfo, &pszNormal, &Offsets)))
                goto NextMessage;

            // Save the Language
            MsgInfo.wLanguage = LOWORD(pIdxMessage->dwLanguage);

            // Save the Highlight
            MsgInfo.wHighlight = HIWORD(pIdxMessage->dwLanguage);
        }

        // Bad
        if (pIdxMessage->dwOffset > pMbxFile->cbSize)
            goto NextMessage;

        // Lets read the message header in the mbx file to validate the msgids
        pMbxMessage = (LPMBXMESSAGEHEADER)((LPBYTE)pMbxFile->pView + pIdxMessage->dwOffset);

        // Set Sizes
        MsgInfo.cbMessage = pMbxMessage->dwBodySize;

        // Validate the Message Ids
        if (pMbxMessage->msgid != pIdxMessage->msgid)
            goto NextMessage;

        // Check for magic
        if (pMbxMessage->dwMagic != MSGHDR_MAGIC)
            goto NextMessage;

        // Has a Body
        FLAGSET(MsgInfo.dwFlags, ARF_HASBODY);

        // Create a Virtual Stream
        IF_FAILEXIT(hr = pDB->CreateStream(&MsgInfo.faStream));

        // Open the Stream
        IF_FAILEXIT(hr = pDB->OpenStream(ACCESS_WRITE, MsgInfo.faStream, &pStream));

        // Get the stream pointer
        pbStream = (LPBYTE)((LPBYTE)pMbxFile->pView + (pIdxMessage->dwOffset + sizeof(MBXMESSAGEHEADER)));

        // Write this
        IF_FAILEXIT(hr = pStream->Write(pbStream, pMbxMessage->dwBodySize, NULL));

        // Commit
        IF_FAILEXIT(hr = pStream->Commit(STGC_DEFAULT));

        // If not an OE4+ blob, then generate the msginfo from the message
        if (pIdxHeader->verBlob != MAIL_BLOB_VER)
        {
            // Create an IMimeMessage    
            IF_FAILEXIT(hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMessage));

            // Rewind
            if (FAILED(pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL)))
                goto NextMessage;

            // Load the Message
            if (FAILED(pMessage->Load(pStream)))
                goto NextMessage;

            // Get MsgInfo from the Message
            if (FAILED(GetMsgInfoFromMessage(pMessage, &MsgInfo, &Offsets)))
                goto NextMessage;

            // Free 
            pbFree = Offsets.pBlobData;

            // Free This MsgInfo
            CopyMemory(&MsgInfoFree, &MsgInfo, sizeof(MESSAGEINFO));
        }

        // Set MsgInfo Offsets
        MsgInfo.Offsets = Offsets;

        // Save Downloaded Time
        SystemTimeToFileTime(&st, &MsgInfo.ftDownloaded);

        // Lookup Account Id from the Account Name...
        if (MsgInfo.pszAcctName)
        {
            // Loop through the Accounts
            for (DWORD i=0; i<g_AcctTable.cAccounts; i++)
            {
                // Is this the Account
                if (lstrcmpi(g_AcctTable.prgAccount[i].szAcctName, MsgInfo.pszAcctName) == 0)
                {
                    MsgInfo.pszAcctId = g_AcctTable.prgAccount[i].szAcctId;
                    break;
                }
            }
        }

        // Count
        pInfo->cMessages++;
        if (!ISFLAGSET(MsgInfo.dwFlags, ARF_READ))
            pInfo->cUnread++;

        // Migrated
        FLAGSET(MsgInfo.dwFlags, 0x00000010);

        // Store the Record
        IF_FAILEXIT(hr = pDB->InsertRecord(&MsgInfo));

NextMessage:
        // Bump Progress
        if(!g_fQuiet)           
            IncrementProgress(pProgress, pInfo);

        // Cleanup
        SafeRelease(pStream);
        SafeRelease(pMessage);
        SafeMemFree(pszNormal);
        SafeMemFree(pbFree);
        FreeMsgInfo(&MsgInfoFree);

        // Goto Next Header
        Assert(pIdxMessage);

        // Update faIdxRead
        faIdxRead += pIdxMessage->dwSize;
    }

exit:
    // Cleanup
    SafeRelease(pStream);
    SafeRelease(pMessage);
    SafeRelease(pNormalizer);
    SafeMemFree(pszNormal);
    SafeMemFree(pbFree);
    FreeMsgInfo(&MsgInfoFree);
    if (pIdxFile)
        CloseMemoryFile(pIdxFile);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// GetRecordBlock
// --------------------------------------------------------------------------------
HRESULT GetRecordBlock(LPMEMORYFILE pFile, DWORD faRecord, LPRECORDBLOCKV5B1 *ppRecord,
    LPBYTE *ppbData, BOOL *pfContinue)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("GetRecordBlock");

    // Bad Length
    if (faRecord + sizeof(RECORDBLOCKV5B1) > pFile->cbSize)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
        goto exit;
    }

    // Cast the Record
    (*ppRecord) = (LPRECORDBLOCKV5B1)((LPBYTE)pFile->pView + faRecord);

    // Invalid Record Signature
    if (faRecord != (*ppRecord)->faRecord)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_BADRECORDSIGNATURE);
        goto exit;
    }

    // Bad Length
    if (faRecord + (*ppRecord)->cbRecord > pFile->cbSize)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
        goto exit;
    }

    // Set pbData
    *ppbData = (LPBYTE)((LPBYTE)(*ppRecord) + sizeof(RECORDBLOCKV5B1));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// GetStreamBlock
// --------------------------------------------------------------------------------
HRESULT GetStreamBlock(LPMEMORYFILE pFile, DWORD faBlock, LPSTREAMBLOCK *ppBlock,
    LPBYTE *ppbData, BOOL *pfContinue)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("GetStreamBlock");

    // Bad Length
    if (faBlock + sizeof(STREAMBLOCK) > pFile->cbSize)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
        goto exit;
    }

    // Cast the Record
    (*ppBlock) = (LPSTREAMBLOCK)((LPBYTE)pFile->pView + faBlock);

    // Invalid Record Signature
    if (faBlock != (*ppBlock)->faThis)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_BADSTREAMBLOCKSIGNATURE);
        goto exit;
    }

    // Bad Length
    if (faBlock + (*ppBlock)->cbBlock > pFile->cbSize)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
        goto exit;
    }

    // Set pbData
    *ppbData = (LPBYTE)((LPBYTE)(*ppBlock) + sizeof(STREAMBLOCK));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// UpgradePropTreeMessageFileV5
// --------------------------------------------------------------------------------
HRESULT UpgradePropTreeMessageFileV5(LPFILEINFO pInfo, LPMEMORYFILE pFile,
    IDatabase *pDB, LPPROGRESSINFO pProgress, BOOL *pfContinue)
{
    // Locals
    HRESULT             hr=S_OK;
    LPBYTE              pbStart;
    LPBYTE              pbData;
    DWORD               faRecord;
    DWORD               faStreamBlock;
    FILEADDRESS         faDstStream;
    MESSAGEINFO         MsgInfo;
    IStream            *pStream=NULL;
    FILEADDRESS         faStream;
    LPFOLDERUSERDATAV4  pUserDataV4;
    FOLDERUSERDATA      UserDataV5;
    LPSTREAMBLOCK       pStmBlock;
    LPRECORDBLOCKV5B1   pRecord;
    LPTABLEHEADERV5B1   pHeader=(LPTABLEHEADERV5B1)pFile->pView;

    // Trace
    TraceCall("UpgradePropTreeMessageFileV5");
    
    // Validate
    Assert(sizeof(FOLDERUSERDATAV4) == sizeof(FOLDERUSERDATA));

    // Get CacheInfo
    if (sizeof(FOLDERUSERDATA) != pHeader->cbUserData)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_USERDATASIZEDIFF);
        goto exit;
    }

    // Get V4 UserData
    pUserDataV4 = (LPFOLDERUSERDATAV4)((LPBYTE)pFile->pView + sizeof(TABLEHEADERV5B1));

    // If there is a Server Name and acctid is empty...
    if ('\0' != *pUserDataV4->szServer && '\0' == *pInfo->szAcctId)
    {
        // Loop through the Accounts
        for (DWORD i=0; i<g_AcctTable.cAccounts; i++)
        {
            // Is this the Account
            if (lstrcmpi(g_AcctTable.prgAccount[i].szServer, pUserDataV4->szServer) == 0)
            {
                StrCpyN(pInfo->szAcctId, g_AcctTable.prgAccount[i].szAcctId, ARRAYSIZE(pInfo->szAcctId));
                break;
            }
        }
    }

    // If there is a folder name, copy it
    if ('\0' != *pUserDataV4->szGroup)
    {
        // Copy
        StrCpyN(pInfo->szFolder, pUserDataV4->szGroup, ARRAYSIZE(pInfo->szFolder));
    }

    // Zero New
    ZeroMemory(&UserDataV5, sizeof(FOLDERUSERDATA));

    // Copy Over Relavent Stuff
    UserDataV5.dwUIDValidity = pUserDataV4->dwUIDValidity;

    // Set user data
    IF_FAILEXIT(hr = pDB->SetUserData(&UserDataV5, sizeof(FOLDERUSERDATA)));

    // Initialize faRecord to start
    faRecord = pHeader->faFirstRecord;

    // While we have a record
    while(faRecord)
    {
        // Get the Record
        IF_FAILEXIT(hr = GetRecordBlock(pFile, faRecord, &pRecord, &pbData, pfContinue));

        // Set pbStart
        pbStart = pbData;

        // Clear MsgInfo
        ZeroMemory(&MsgInfo, sizeof(MESSAGEINFO));

        // DWORD - idMessage
        CopyMemory(&MsgInfo.idMessage, pbData, sizeof(MsgInfo.idMessage));
        pbData += sizeof(MsgInfo.idMessage);

        // Null Message Id
        if (0 == MsgInfo.idMessage)
        {
            // Generate
            pDB->GenerateId((LPDWORD)&MsgInfo.idMessage);
        }

        // DWORD - dwFlags
        CopyMemory(&MsgInfo.dwFlags, pbData, sizeof(MsgInfo.dwFlags));
        pbData += sizeof(MsgInfo.dwFlags);

        // News ?
        if (FILE_IS_NEWS_MESSAGES == pInfo->tyFile)
            FLAGSET(MsgInfo.dwFlags, ARF_NEWSMSG);

        // Priority
        if (ISFLAGSET(MsgInfo.dwFlags, 0x00000200))
        {
            MsgInfo.wPriority = (WORD)IMSG_PRI_HIGH;
            FLAGCLEAR(MsgInfo.dwFlags, 0x00000200);
        }
        else if (ISFLAGSET(MsgInfo.dwFlags, 0x00000100))
        {
            MsgInfo.wPriority = (WORD)IMSG_PRI_LOW;
            FLAGCLEAR(MsgInfo.dwFlags, 0x00000100);
        }
        else
            MsgInfo.wPriority = (WORD)IMSG_PRI_NORMAL;

        // DWORD - ftSent
        CopyMemory(&MsgInfo.ftSent, pbData, sizeof(MsgInfo.ftSent));
        pbData += sizeof(MsgInfo.ftSent);
        MsgInfo.ftReceived = MsgInfo.ftSent;

        // DWORD - cLines
        CopyMemory(&MsgInfo.cLines, pbData, sizeof(MsgInfo.cLines));
        pbData += sizeof(MsgInfo.cLines);

        // DWORD - faStream
        CopyMemory(&faStream, pbData, sizeof(faStream));
        pbData += sizeof(faStream);

        // Has a Body
        if (faStream)
        {
            // It has a body
            FLAGSET(MsgInfo.dwFlags, ARF_HASBODY);
        }

        // DWORD - cbArticle / cbMessage (VERSION)
        CopyMemory(&MsgInfo.cbMessage, pbData, sizeof(MsgInfo.cbMessage));
        pbData += sizeof(MsgInfo.cbMessage);

        // DWORD - ftDownloaded
        CopyMemory(&MsgInfo.ftDownloaded, pbData, sizeof(MsgInfo.ftDownloaded));
        pbData += sizeof(MsgInfo.ftDownloaded);

        // LPSTR - pszMessageId
        MsgInfo.pszMessageId = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszMessageId) + 1);

        // LPSTR - pszSubject
        MsgInfo.pszSubject = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszSubject) + 1);

        // VERSION
        MsgInfo.pszNormalSubj = MsgInfo.pszSubject + HIBYTE(HIWORD(MsgInfo.dwFlags));

        // LPSTR - pszFromHeader
        MsgInfo.pszFromHeader = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszFromHeader) + 1);

        // LPSTR - pszReferences
        MsgInfo.pszReferences = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszReferences) + 1);

        // LPSTR - pszXref
        MsgInfo.pszXref = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszXref) + 1);

        // LPSTR - pszServer
        MsgInfo.pszServer = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszServer) + 1);

        // LPSTR - pszDisplayFrom
        MsgInfo.pszDisplayFrom = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszDisplayFrom) + 1);

        // No Display From and we have a from header
        if ('\0' == *MsgInfo.pszDisplayFrom && '\0' != MsgInfo.pszFromHeader)
            MsgInfo.pszDisplayFrom = MsgInfo.pszFromHeader;

        // LPSTR - pszEmailFrom
        MsgInfo.pszEmailFrom = (LPSTR)pbData;
        pbData += (lstrlen(MsgInfo.pszEmailFrom) + 1);

        // Going to V4 ?
        if (pRecord->cbRecord - (DWORD)(pbData - pbStart) - sizeof(RECORDBLOCKV5B1) > 40)
        {
            // WORD - wLanguage
            CopyMemory(&MsgInfo.wLanguage, pbData, sizeof(MsgInfo.wLanguage));
            pbData += sizeof(MsgInfo.wLanguage);

            // WORD - wReserved
            pbData += sizeof(WORD);

            // DWORD - cbMessage
            CopyMemory(&MsgInfo.cbMessage, pbData, sizeof(MsgInfo.cbMessage));
            pbData += sizeof(MsgInfo.cbMessage);

            // FILETIME - ftReceived
            CopyMemory(&MsgInfo.ftReceived, pbData, sizeof(MsgInfo.ftReceived));
            pbData += sizeof(MsgInfo.ftReceived);

            // SBAILEY: Raid-76295: News store corrupted when system dates are changed, Find dialog returns dates of 1900, 00 or blank
            if (0 == MsgInfo.ftReceived.dwLowDateTime && 0 == MsgInfo.ftReceived.dwHighDateTime)
                CopyMemory(&MsgInfo.ftReceived, &MsgInfo.ftSent, sizeof(FILETIME));

            // LPSTR - pszDisplayTo
            MsgInfo.pszDisplayTo = (LPSTR)pbData;
            pbData += (lstrlen(MsgInfo.pszDisplayTo) + 1);
        }

        // Otherwise
        else
        {
            // Set ftReceived
            CopyMemory(&MsgInfo.ftReceived, &MsgInfo.ftSent, sizeof(FILETIME));
        }

        // Copy over the stream...
        if (0 != faStream)
        {
            // Allocate a new stream
            IF_FAILEXIT(hr = pDB->CreateStream(&faDstStream));

            // Open the stream
            IF_FAILEXIT(hr = pDB->OpenStream(ACCESS_WRITE, faDstStream, &pStream));

            // Start Copying Message
            faStreamBlock = faStream;

            // While we have a stream block
            while(faStreamBlock)
            {
                // Get a stream block
                IF_FAILEXIT(hr = GetStreamBlock(pFile, faStreamBlock, &pStmBlock, &pbData, pfContinue));

                // Write into the stream
                IF_FAILEXIT(hr = pStream->Write(pbData, pStmBlock->cbData, NULL));

                // Goto Next Block
                faStreamBlock = pStmBlock->faNext;
            }

            // Commit
            IF_FAILEXIT(hr = pStream->Commit(STGC_DEFAULT));

            // Set new stream location
            MsgInfo.faStream = faDstStream;

            // Release the Stream
            SafeRelease(pStream);
        }

        // If No Account Id and we have a server
        if ('\0' == *pInfo->szAcctId && '\0' != *MsgInfo.pszServer)
        {
            // Loop through the Accounts
            for (DWORD i=0; i<g_AcctTable.cAccounts; i++)
            {
                // Is this the Account
                if (lstrcmpi(g_AcctTable.prgAccount[i].szServer, MsgInfo.pszServer) == 0)
                {
                    StrCpyN(pInfo->szAcctId, g_AcctTable.prgAccount[i].szAcctId, ARRAYSIZE(pInfo->szAcctId));
                    break;
                }
            }
        }

        // Default to szAcctId
        MsgInfo.pszAcctId = pInfo->szAcctId;

        // Lookup Account Id from the Account Name...
        if (MsgInfo.pszAcctName)
        {
            // Loop through the Accounts
            for (DWORD i=0; i<g_AcctTable.cAccounts; i++)
            {
                // Is this the Account
                if (lstrcmpi(g_AcctTable.prgAccount[i].szAcctName, MsgInfo.pszAcctName) == 0)
                {
                    MsgInfo.pszAcctId = g_AcctTable.prgAccount[i].szAcctId;
                    break;
                }
            }
        }

        // Otherwise, if we have an account Id, get the account name
        else if ('\0' != *pInfo->szAcctId)
        {
            // Loop through the Accounts
            for (DWORD i=0; i<g_AcctTable.cAccounts; i++)
            {
                // Is this the Account
                if (lstrcmpi(g_AcctTable.prgAccount[i].szAcctId, MsgInfo.pszAcctId) == 0)
                {
                    MsgInfo.pszAcctName = g_AcctTable.prgAccount[i].szAcctName;
                    break;
                }
            }
        }

        // Count
        pInfo->cMessages++;
        if (!ISFLAGSET(MsgInfo.dwFlags, ARF_READ))
            pInfo->cUnread++;

        // Migrated
        FLAGSET(MsgInfo.dwFlags, 0x00000010);

        // Insert the Record
        IF_FAILEXIT(hr = pDB->InsertRecord(&MsgInfo));

        // Bump Progress
        if(!g_fQuiet)
            IncrementProgress(pProgress, pInfo);

        // Goto the Next Record
        faRecord = pRecord->faNext;
    }

exit:
    // Cleanup
    SafeRelease(pStream);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// ParseFolderFileV5
// --------------------------------------------------------------------------------
HRESULT ParseFolderFileV5(LPMEMORYFILE pFile, LPFILEINFO pInfo, 
    LPPROGRESSINFO pProgress, LPDWORD pcFolders, 
    LPFLDINFO *pprgFolder)
{
    // Locals
    HRESULT             hr=S_OK;
    LPBYTE              pbData;
    DWORD               faRecord;
    LPFLDINFO           pFolder;
    LPFLDINFO           prgFolder=NULL;
    LPRECORDBLOCKV5B1   pRecord;
    LPTABLEHEADERV5B1   pHeader;
    BOOL                fContinue;
    DWORD               cFolders=0;

    // Trace
    TraceCall("ParseFolderFileV5");

    // De-ref the header
    pHeader = (LPTABLEHEADERV5B1)pFile->pView;

    // Get CacheInfo
    if (sizeof(STOREUSERDATA) != pHeader->cbUserData)
    {
        hr = TraceResult(MIGRATE_E_USERDATASIZEDIFF);
        goto exit;
    }

    // Allocate Folder Array
    IF_NULLEXIT(prgFolder = (LPFLDINFO)ZeroAllocate(sizeof(FLDINFO) * pHeader->cRecords));

    // Initialize faRecord to start
    faRecord = pHeader->faFirstRecord;

    // While we have a record
    while(faRecord)
    {
        // Readability
        pFolder = &prgFolder[cFolders];

        // Get the Record
        IF_FAILEXIT(hr = GetRecordBlock(pFile, faRecord, &pRecord, &pbData, &fContinue));

        // DWORD - hFolder
        CopyMemory(&pFolder->idFolder, pbData, sizeof(pFolder->idFolder));
        pbData += sizeof(pFolder->idFolder);

        // CHAR(MAX_FOLDER_NAME) - szFolder
        CopyMemory(pFolder->szFolder, pbData, sizeof(pFolder->szFolder));
        pbData += sizeof(pFolder->szFolder);

        // CHAR(260) - szFile
        CopyMemory(pFolder->szFile, pbData, sizeof(pFolder->szFile));
        pbData += sizeof(pFolder->szFile);

        // DWORD - idParent
        CopyMemory(&pFolder->idParent, pbData, sizeof(pFolder->idParent));
        pbData += sizeof(pFolder->idParent);

        // DWORD - idChild
        CopyMemory(&pFolder->idChild, pbData, sizeof(pFolder->idChild));
        pbData += sizeof(pFolder->idChild);

        // DWORD - idSibling
        CopyMemory(&pFolder->idSibling, pbData, sizeof(pFolder->idSibling));
        pbData += sizeof(pFolder->idSibling);

        // DWORD - tySpecial
        CopyMemory(&pFolder->tySpecial, pbData, sizeof(pFolder->tySpecial));
        pbData += sizeof(pFolder->tySpecial);

        // DWORD - cChildren
        CopyMemory(&pFolder->cChildren, pbData, sizeof(pFolder->cChildren));
        pbData += sizeof(pFolder->cChildren);

        // DWORD - cMessages
        CopyMemory(&pFolder->cMessages, pbData, sizeof(pFolder->cMessages));
        pbData += sizeof(pFolder->cMessages);

        // DWORD - cUnread
        CopyMemory(&pFolder->cUnread, pbData, sizeof(pFolder->cUnread));
        pbData += sizeof(pFolder->cUnread);

        // DWORD - cbTotal
        CopyMemory(&pFolder->cbTotal, pbData, sizeof(pFolder->cbTotal));
        pbData += sizeof(pFolder->cbTotal);

        // DWORD - cbUsed
        CopyMemory(&pFolder->cbUsed, pbData, sizeof(pFolder->cbUsed));
        pbData += sizeof(pFolder->cbUsed);

        // DWORD - bHierarchy
        CopyMemory(&pFolder->bHierarchy, pbData, sizeof(pFolder->bHierarchy));
        pbData += sizeof(pFolder->bHierarchy);

        // DWORD - dwImapFlags
        CopyMemory(&pFolder->dwImapFlags, pbData, sizeof(pFolder->dwImapFlags));
        pbData += sizeof(DWORD);

        // BLOB - bListStamp
        CopyMemory(&pFolder->bListStamp, pbData, sizeof(pFolder->bListStamp));
        pbData += sizeof(BYTE);

        // DWORD - bReserved[3]
        pbData += (3 * sizeof(BYTE));

        // DWORD - rgbReserved
        pbData += 40;

        // Increment Count
        cFolders++;

        // Bump Progress
        if(!g_fQuiet)
            IncrementProgress(pProgress, pInfo);

        // Goto the Next Record
        faRecord = pRecord->faNext;
    }

    // Return Folder Count
    *pcFolders = cFolders;

    // Return the Array
    *pprgFolder = prgFolder;

    // Don't Free It
    prgFolder = NULL;

exit:
    // Cleanup
    SafeMemFree(prgFolder);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// UpgradePop3UidlFileV5
// --------------------------------------------------------------------------------
HRESULT UpgradePop3UidlFileV5(LPFILEINFO pInfo, LPMEMORYFILE pFile,
    IDatabase *pDB, LPPROGRESSINFO pProgress, BOOL *pfContinue)
{
    // Locals
    HRESULT             hr=S_OK;
    LPBYTE              pbData;
    DWORD               faRecord;
    UIDLRECORD          UidlInfo;
    LPRECORDBLOCKV5B1   pRecord;
    LPTABLEHEADERV5B1   pHeader=(LPTABLEHEADERV5B1)pFile->pView;

    // Trace
    TraceCall("UpgradePop3UidlFileV5");

    // Initialize faRecord to start
    faRecord = pHeader->faFirstRecord;

    // While we have a record
    while(faRecord)
    {
        // Get the Record
        IF_FAILEXIT(hr = GetRecordBlock(pFile, faRecord, &pRecord, &pbData, pfContinue));

        // Clear UidlInfo
        ZeroMemory(&UidlInfo, sizeof(UIDLRECORD));

        // FILETIME - ftDownload
        CopyMemory(&UidlInfo.ftDownload, pbData, sizeof(UidlInfo.ftDownload));
        pbData += sizeof(UidlInfo.ftDownload);

        // BYTE - fDownloaded
        CopyMemory(&UidlInfo.fDownloaded, pbData, sizeof(UidlInfo.fDownloaded));
        pbData += sizeof(UidlInfo.fDownloaded);

        // BYTE - fDeleted
        CopyMemory(&UidlInfo.fDeleted, pbData, sizeof(UidlInfo.fDeleted));
        pbData += sizeof(UidlInfo.fDeleted);

        // LPSTR - pszUidl
        UidlInfo.pszUidl = (LPSTR)pbData;
        pbData += (lstrlen(UidlInfo.pszUidl) + 1);

        // LPSTR - pszServer
        UidlInfo.pszServer = (LPSTR)pbData;
        pbData += (lstrlen(UidlInfo.pszServer) + 1);

        // Insert the Record
        IF_FAILEXIT(hr = pDB->InsertRecord(&UidlInfo));

        // Bump Progress
        if(!g_fQuiet)
            IncrementProgress(pProgress, pInfo);

        // Goto the Next Record
        faRecord = pRecord->faNext;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// UpgradeFileV5
// --------------------------------------------------------------------------------
HRESULT UpgradeFileV5(IDatabaseSession *pSession, MIGRATETOTYPE tyMigrate, 
    LPFILEINFO pInfo, LPPROGRESSINFO pProgress, BOOL *pfContinue)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    IDatabase     *pDB=NULL;

    // Trace
    TraceCall("UpgradeFileV5");

    // Local message file
    if (FILE_IS_LOCAL_MESSAGES == pInfo->tyFile)
    {
        // Create an ObjectDatabase (upgrade only runs when OE5 is installed)
        IF_FAILEXIT(hr = pSession->OpenDatabase(pInfo->szDstFile, 0, &g_MessageTableSchema, NULL, &pDB));

        // Get the File Header
        IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

        // UpgradeLocalStoreFileV5
        IF_FAILEXIT(hr = UpgradeLocalStoreFileV5(pInfo, &File, pDB, pProgress, pfContinue));
    }

    // Old News or Imap file
    else if (FILE_IS_NEWS_MESSAGES == pInfo->tyFile || FILE_IS_IMAP_MESSAGES == pInfo->tyFile)
    {
        // Create an ObjectDatabase (upgrade only runs when OE5 is installed)
        IF_FAILEXIT(hr = pSession->OpenDatabase(pInfo->szDstFile, 0, &g_MessageTableSchema, NULL, &pDB));

        // Get the File Header
        IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

        // UpgradePropTreeMessageFileV5
        IF_FAILEXIT(hr = UpgradePropTreeMessageFileV5(pInfo, &File, pDB, pProgress, pfContinue));
    }

    // pop3uidl file
    else if (FILE_IS_POP3UIDL == pInfo->tyFile)
    {
        // Create an ObjectDatabase (upgrade only runs when OE5 is installed)
        IF_FAILEXIT(hr = pSession->OpenDatabase(pInfo->szDstFile, 0, &g_UidlTableSchema, NULL, &pDB));

        // Get the File Header
        IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

        // UpgradePop3UidlFileV5
        IF_FAILEXIT(hr = UpgradePop3UidlFileV5(pInfo, &File, pDB, pProgress, pfContinue));
    }

exit:
    // Cleanup
    SafeRelease(pDB);
    CloseMemoryFile(&File);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// UpgradeProcessFileListV5
// --------------------------------------------------------------------------------
HRESULT UpgradeProcessFileListV5(LPCSTR pszStoreSrc, LPCSTR pszStoreDst, 
    LPFILEINFO pHead, LPDWORD pcMax, LPDWORD pcbNeeded)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    LPFILEINFO          pCurrent;
    LPTABLEHEADERV5B1   pHeader;

    // Trace
    TraceCall("UpgradeProcessFileListV5");

    // Init
    *pcMax = 0;
    *pcbNeeded = 0;

    // Loop
    for (pCurrent=pHead; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Get the File Header
        hr = OpenMemoryFile(pCurrent->szFilePath, &File);

        // Failure ?
        if (FAILED(hr) || 0 == File.cbSize)
        {
            // Don't Migrate
            pCurrent->fMigrate = FALSE;

            // Set hrMigrate
            pCurrent->hrMigrate = (0 == File.cbSize ? S_OK : hr);

            // Reset hr
            hr = S_OK;

            // Get the LastError
            pCurrent->dwLastError = GetLastError();

            // Goto Next
            goto NextFile;
        }

        // Local message file
        if (FILE_IS_LOCAL_MESSAGES == pCurrent->tyFile)
        {
            // Cast the Header
            LPMBXFILEHEADER pMbxHeader=(LPMBXFILEHEADER)File.pView;

            // Bad Version
            if (File.cbSize < sizeof(MBXFILEHEADER) || pMbxHeader->dwMagic != MSGFILE_MAGIC || pMbxHeader->ver != MSGFILE_VER)
            {
                // Not a file that should be migrate
                pCurrent->fMigrate = FALSE;

                // Set hrMigrate
                pCurrent->hrMigrate = MIGRATE_E_BADVERSION;

                // Goto Next
                goto NextFile;
            }

            // Save the Number of record
            pCurrent->cRecords = pMbxHeader->cMsg;
        }

        // Otherwise, if its a news group list
        else if (FILE_IS_NEWS_SUBLIST == pCurrent->tyFile)
        {
            // De-Ref the header
            LPSUBLISTHEADER pSubList = (LPSUBLISTHEADER)File.pView;

            // Check the Signature...
            if (File.cbSize < sizeof(SUBLISTHEADER) || 
                (SUBFILE_VERSION5 != pSubList->dwVersion &&
                 SUBFILE_VERSION4 != pSubList->dwVersion &&
                 SUBFILE_VERSION3 != pSubList->dwVersion &&
                 SUBFILE_VERSION2 != pSubList->dwVersion))
            {
                // Not a file that should be migrate
                pCurrent->fMigrate = FALSE;

                // Set hrMigrate
                pCurrent->hrMigrate = MIGRATE_E_BADVERSION;

                // Goto Next
                goto NextFile;
            }

            // Save the Number of record
            pCurrent->cRecords = pSubList->cSubscribed;
        }

        // Otherwise, if its a news sub list
        else if (FILE_IS_NEWS_GRPLIST == pCurrent->tyFile)
        {
            // De-Ref the header
            LPGRPLISTHEADER pGrpList = (LPGRPLISTHEADER)File.pView;

            // Check the Signature...
            if (File.cbSize < sizeof(GRPLISTHEADER) || GROUPLISTVERSION != pGrpList->dwVersion)
            {
                // Not a file that should be migrate
                pCurrent->fMigrate = FALSE;

                // Set hrMigrate
                pCurrent->hrMigrate = MIGRATE_E_BADVERSION;

                // Goto Next
                goto NextFile;
            }

            // Save the Number of record
            pCurrent->cRecords = pGrpList->cGroups;
        }

        // Otherwise, objectdb file
        else
        {
            // De-Ref the header
            pHeader = (LPTABLEHEADERV5B1)File.pView;

            // Check the Signature...
            if (File.cbSize < sizeof(TABLEHEADERV5B1) || OBJECTDB_SIGNATURE != pHeader->dwSignature || OBJECTDB_VERSION_PRE_V5 != pHeader->wMajorVersion)
            {
                // Not a file that should be migrate
                pCurrent->fMigrate = FALSE;

                // Set hrMigrate
                pCurrent->hrMigrate = MIGRATE_E_BADVERSION;

                // Goto Next
                goto NextFile;
            }

            // Save the Number of record
            pCurrent->cRecords = pHeader->cRecords;
        }

        // Special Case pop3uidl.dat
        if (FILE_IS_POP3UIDL == pCurrent->tyFile)
        {
            // Compute Real Destination File
            wnsprintf(pCurrent->szDstFile, ARRAYSIZE(pCurrent->szDstFile),"%s\\pop3uidl.dbx", pszStoreDst);
        }

        // Otherwise, generate a unqiue message file name
        else
        {
            // Save the Folder Id
            pCurrent->idFolder = g_idFolderNext;

            // Build New Path
            wnsprintf(pCurrent->szDstFile, ARRAYSIZE(pCurrent->szDstFile), "%s\\%08d.dbx", pszStoreDst, g_idFolderNext);

            // Increment id
            g_idFolderNext++;
        }

        // Initialize counters
        InitializeCounters(&File, pCurrent, pcMax, pcbNeeded, TRUE);

        // Yes, Migrate
        pCurrent->fMigrate = TRUE;

NextFile:
        // Close the File
        CloseMemoryFile(&File);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// UpgradeDeleteFilesV5
// --------------------------------------------------------------------------------
void UpgradeDeleteFilesV5(LPCSTR pszStoreDst)
{
    // Locals
    CHAR            szSearch[MAX_PATH + MAX_PATH];
    CHAR            szFilePath[MAX_PATH + MAX_PATH];
    HANDLE          hFind=INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;

    // Trace
    TraceCall("UpgradeDeleteFilesV5");

    // Do we have a sub dir
    wnsprintf(szSearch, ARRAYSIZE(szSearch),"%s\\*.dbx", pszStoreDst);

    // Find first file
    hFind = FindFirstFile(szSearch, &fd);

    // Did we find something
    if (INVALID_HANDLE_VALUE == hFind)
        goto exit;

    // Loop for ever
    while(1)
    {
        // Make File Path
        MakeFilePath(pszStoreDst, fd.cFileName, "", szFilePath, ARRAYSIZE(szFilePath));

        // Delete
        DeleteFile(szFilePath);

        // Find the Next File
        if (!FindNextFile(hFind, &fd))
            break;
    }

exit:
    // Cleanup
    if (hFind)
        FindClose(hFind);
}

// --------------------------------------------------------------------------------
// UpgradeDeleteIdxMbxNchDatFilesV5
// --------------------------------------------------------------------------------
void UpgradeDeleteIdxMbxNchDatFilesV5(LPFILEINFO pHeadFile)
{
    // Locals
    CHAR            szDstFile[MAX_PATH + MAX_PATH];
    LPFILEINFO      pCurrent;

    // Trace
    TraceCall("UpgradeDeleteOdbFilesV5");

    // Delete all old files
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Succeeded
        Assert(SUCCEEDED(pCurrent->hrMigrate));

        // Delete the file
        // DeleteFile(pCurrent->szFilePath);

        // If local message file, need to delete the idx file
        if (FILE_IS_LOCAL_MESSAGES == pCurrent->tyFile)
        {
            // Replace file extension
            ReplaceExtension(pCurrent->szFilePath, ".idx", szDstFile, ARRAYSIZE(szDstFile));

            // Delete the file
            // DeleteFile(szDstFile);
        }
    }

    // Done
    return;
}

// --------------------------------------------------------------------------------
// GetSpecialFolderInfo
// --------------------------------------------------------------------------------
HRESULT GetSpecialFolderInfo(LPCSTR pszFilePath, LPSTR pszFolder, 
    DWORD cchFolder, DWORD *ptySpecial)
{
    // Locals
    CHAR    szPath[_MAX_PATH];
    CHAR    szDrive[_MAX_DRIVE];
    CHAR    szDir[_MAX_DIR];
    CHAR    szFile[_MAX_FNAME];
    CHAR    szExt[_MAX_EXT];
    CHAR    szRes[255];
    DWORD   i;

    // Trace
    TraceCall("GetSpecialFolderInfo");

    // Initialize
    *ptySpecial = 0xffffffff;

    // Split the Path
    _splitpath(pszFilePath, szDrive, szDir, szFile, szExt);

    // Set Folder Name
    StrCpyN(pszFolder, szFile, cchFolder);

    // Loop through special folder
    for (i=FOLDER_INBOX; i<FOLDER_MAX; i++)
    {
        // Load the Special Folder Name
        LoadString(g_hInst, IDS_INBOX + (i - 1), szRes, ARRAYSIZE(szRes));

        // Compare with szFile
        if (lstrcmpi(szFile, szRes) == 0)
        {
            // Copy the Folder Name
            StrCpyN(pszFolder, szRes, cchFolder);

            // Return special folder type
            *ptySpecial = (i - 1);

            // Success
            return(S_OK);
        }
    }

    // Done
    return(E_FAIL);
}

// --------------------------------------------------------------------------------
// FixupFolderUserData
// --------------------------------------------------------------------------------
HRESULT FixupFolderUserData(IDatabaseSession *pSession, FOLDERID idFolder, 
    LPCSTR pszName, SPECIALFOLDER tySpecial, LPFILEINFO pCurrent)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERUSERDATA  UserData;
    IDatabase *pDB=NULL;

    // Trace
    TraceCall("FixupFolderUserData");

    // Better not be in the store yet
    Assert(FALSE == pCurrent->fInStore);

    // Its in the store
    pCurrent->fInStore = TRUE;

    // Create an Ojbect Database
    IF_FAILEXIT(hr = pSession->OpenDatabase(pCurrent->szDstFile, 0, &g_MessageTableSchema, NULL, &pDB));

    // Store the User Data
    IF_FAILEXIT(hr = pDB->GetUserData(&UserData, sizeof(FOLDERUSERDATA)));

    // Its Initialized
    UserData.fInitialized = TRUE;

    // UserData.clsidType
    if (ISFLAGSET(pCurrent->dwServer, SRV_POP3))
        UserData.tyFolder = FOLDER_LOCAL;
    else if (ISFLAGSET(pCurrent->dwServer, SRV_NNTP))
        UserData.tyFolder = FOLDER_NEWS;
    else if (ISFLAGSET(pCurrent->dwServer, SRV_IMAP))
        UserData.tyFolder = FOLDER_IMAP;

    // Copy the Account Id
    StrCpyN(UserData.szAcctId, pCurrent->szAcctId, ARRAYSIZE(UserData.szAcctId));

    // Save Folder Id
    UserData.idFolder = idFolder;

    // Save Special Folder Type
    UserData.tySpecial = tySpecial;

    // Copy the Folder name
    StrCpyN(UserData.szFolder, pszName, ARRAYSIZE(UserData.szFolder));

    // Must be Subscribed
    UserData.fSubscribed = TRUE;

    // Set the Sort Index Information
    UserData.idSort = COLUMN_RECEIVED;

    // Not Ascending
    UserData.fAscending = FALSE;

    // Not threaded
    UserData.fThreaded = FALSE;

    // Basic Filter
    UserData.ridFilter = RULEID_VIEW_ALL;

    // Add Welcome Message Again
    UserData.fWelcomeAdded = FALSE;

    // Show Deleted
    UserData.fShowDeleted = TRUE;

    // New thread model
    UserData.fNewThreadModel = TRUE;
    UserData.fTotalWatched = TRUE;
    UserData.fWatchedCounts = TRUE;

    // Store the User Data
    IF_FAILEXIT(hr = pDB->SetUserData(&UserData, sizeof(FOLDERUSERDATA)));

exit:
    // Cleanup
    SafeRelease(pDB);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// SetIMAPSpecialFldrType
// --------------------------------------------------------------------------------
HRESULT SetIMAPSpecialFldrType(LPSTR pszAcctID, LPSTR pszFldrName, SPECIALFOLDER *psfType)
{
    char                szPath[MAX_PATH + 1];
    SPECIALFOLDER       sfResult = FOLDER_NOTSPECIAL;

    TraceCall("SetIMAPSpecialFldrType");
    Assert(NULL != psfType);
    Assert(FOLDER_NOTSPECIAL == *psfType);

    LoadString(g_hInst, IDS_SENTITEMS, szPath, sizeof(szPath));
    if (0 == lstrcmp(szPath, pszFldrName))
    {
        sfResult = FOLDER_SENT;
        goto exit;
    }

    LoadString(g_hInst, IDS_DRAFT, szPath, sizeof(szPath));
    if (0 == lstrcmp(szPath, pszFldrName))
    {
        sfResult = FOLDER_DRAFT;
        goto exit;
    }


exit:
    *psfType = sfResult;
    return S_OK;
}

// --------------------------------------------------------------------------------
// InsertFolderIntoStore
// --------------------------------------------------------------------------------
HRESULT InsertFolderIntoStore(IDatabaseSession *pSession, IMessageStore *pStore, 
    LPFLDINFO pThis, DWORD cFolders, LPFLDINFO prgFolder, FOLDERID idParentNew, 
    LPFILEINFO pInfo, LPFILEINFO pFileHead, LPFOLDERID pidNew)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    CHAR            szPath[_MAX_PATH];
    CHAR            szDrive[_MAX_DRIVE];
    CHAR            szDir[_MAX_DIR];
    CHAR            szFile[_MAX_FNAME];
    CHAR            szExt[_MAX_EXT];
    CHAR            szFilePath[MAX_PATH];
    CHAR            szInbox[MAX_PATH];
    BOOL            fFound=FALSE;
    LPFILEINFO      pCurrent=NULL;
    FOLDERINFO      Folder={0};

    // Trace
    TraceCall("InsertFolderIntoStore");

    // Invalid Arg
    //Assert(FILE_IS_LOCAL_FOLDERS == pInfo->tyFile || FILE_IS_IMAP_FOLDERS == pInfo->tyFile);

    // Copy Stuff Over to Folder
    Folder.pszName = pThis->szFolder;
    Folder.idParent = idParentNew;
    Folder.bHierarchy = pThis->bHierarchy;
    Folder.dwFlags = FOLDER_SUBSCRIBED;    // $$TODO$$ May need to adjust and map to new flags
    Folder.tySpecial = (0xffffffff == pThis->tySpecial) ? FOLDER_NOTSPECIAL : (BYTE)(pThis->tySpecial + 1);
    Folder.cMessages = pThis->cMessages;
    Folder.cUnread = pThis->cUnread;
    Folder.pszFile = pThis->szFile;
    Folder.dwListStamp = pThis->bListStamp;

    // For IMAP folders, we have to set tySpecial based on registry folder paths
    if (pInfo && FILE_IS_IMAP_FOLDERS == pInfo->tyFile && NULL != pThis &&
        FOLDERID_ROOT == (FOLDERID)IntToPtr(pThis->idParent))
    {
        HRESULT hrTemp;

        if (FOLDER_NOTSPECIAL == Folder.tySpecial)
        {
            hrTemp = SetIMAPSpecialFldrType(pInfo->szAcctId, Folder.pszName, &Folder.tySpecial);
            TraceError(hrTemp);
            Assert(SUCCEEDED(hrTemp) || FOLDER_NOTSPECIAL == Folder.tySpecial);
        }
        else if (FOLDER_INBOX == Folder.tySpecial)
        {
            LoadString(g_hInst, IDS_INBOX, szInbox, ARRAYSIZE(szInbox));
            Folder.pszName = szInbox;
        }
    }

    // Look for Current
    if (pInfo && pFileHead)
    {
        // Locate the file...
        for (pCurrent=pFileHead; pCurrent!=NULL; pCurrent=pCurrent->pNext)
        {
            // Migrate
            if (pCurrent->fMigrate)
            {
                // Local Folder ?
                if (FILE_IS_LOCAL_FOLDERS == pInfo->tyFile && FILE_IS_LOCAL_MESSAGES == pCurrent->tyFile)
                {
                    // Get the File Name
                    _splitpath(pCurrent->szFilePath, szDrive, szDir, szFile, szExt);

                    // Test For File Name
                    if (lstrcmpi(szFile, pThis->szFile) == 0)
                    {
                        // This is It
                        fFound = TRUE;

                        // Adjust the Flags
                        FLAGSET(Folder.dwFlags, FOLDER_SUBSCRIBED);
                    }
                }
            
                // IMAP Folders ?
                else if (FILE_IS_IMAP_FOLDERS == pInfo->tyFile && FILE_IS_IMAP_MESSAGES == pCurrent->tyFile)
                {
                    // Same Account
                    if (lstrcmpi(pCurrent->szAcctId, pInfo->szAcctId) == 0)
                    {
                        // Get the File Name
                        _splitpath(pCurrent->szFilePath, szDrive, szDir, szFile, szExt);

                        // Build File
                        wnsprintf(szFilePath, ARRAYSIZE(szFilePath), "%s.nch", szFile);

                        // Test For File Name
                        if (lstrcmpi(szFilePath, pThis->szFile) == 0)
                        {
                            // This is It
                            fFound = TRUE;
                        }
                    }
                }

                // Found
                if (fFound)
                {
                    // Get the File Name
                    _splitpath(pCurrent->szDstFile, szDrive, szDir, szFile, szExt);

                    // Build File
                    wnsprintf(szFilePath, ARRAYSIZE(szFilePath), "%s.dbx", szFile);

                    // Local the File for this folder and set
                    Folder.pszFile = szFilePath;

                    // Set Folder Counts
                    Folder.cMessages = pCurrent->cMessages;
                    Folder.cUnread = pCurrent->cUnread;

                    // Done
                    break;
                }
            }
        }
    }

    // If this is a special folder, then lets try to see if it already exists...
    if (FOLDER_NOTSPECIAL != Folder.tySpecial)
    {
        // Locals
        FOLDERINFO Special;

        // pThis Parent should be invalid
        Assert(FOLDERID_ROOT == (FOLDERID)IntToPtr(pThis->idParent));

        // Try to get the special folder info
        if (FAILED(pStore->GetSpecialFolderInfo(idParentNew, Folder.tySpecial, &Special)))
        {
            // Create the Folder
            IF_FAILEXIT(hr = pStore->CreateFolder(NOFLAGS, &Folder, NOSTORECALLBACK));

            // Update pThis->dwServerHigh with new folderid
            pThis->idNewFolderId = (DWORD_PTR)Folder.idFolder;
        }

        // Otherwise...
        else
        {
            // Update pThis->dwServerHigh with new folderid
            pThis->idNewFolderId = (DWORD_PTR)Special.idFolder;

            // Update the Special folder
            Folder.idFolder = Special.idFolder;

            // Update Special
            Special.bHierarchy = Folder.bHierarchy;
            Special.dwFlags = Folder.dwFlags;    // $$TODO$$ May need to adjust and map to new flags
            Special.cMessages = Folder.cMessages;
            Special.cUnread = Folder.cUnread;
            Special.pszFile = Folder.pszFile;
            Special.dwListStamp = Folder.dwListStamp;

            // Update the Record
            IF_FAILEXIT(hr = pStore->UpdateRecord(&Special));

            // Free Special
            pStore->FreeRecord(&Special);
        }
    }

    // Otherwise, just try to create the folder
    else
    {
        // Create the Folder
        IF_FAILEXIT(hr = pStore->CreateFolder(NOFLAGS, &Folder, NOSTORECALLBACK));

        // Update pThis->dwServerHigh with new folderid
        pThis->idNewFolderId = (DWORD_PTR)Folder.idFolder;
    }

    // If We Found a folder...
    if (pCurrent)
    {
        // Update the Folder's UserData
        IF_FAILEXIT(hr = FixupFolderUserData(pSession, Folder.idFolder, pThis->szFolder, Folder.tySpecial, pCurrent));
    }

    // Walk Insert the children of pThis
    for (i=0; i<cFolders; i++)
    {
        // If Parent is equal to idParent, then lets insert this node under the new parent
        if (prgFolder[i].idParent == pThis->idFolder)
        {
            // Can't be null
            Assert(prgFolder[i].idFolder);

            // InsertFolderIntoStore
            IF_FAILEXIT(hr = InsertFolderIntoStore(pSession, pStore, &prgFolder[i], cFolders, prgFolder, Folder.idFolder, pInfo, pFileHead, NULL));
        }
    }

    // Return the New Folder
    if (pidNew)
        *pidNew = Folder.idFolder;

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// MergeFolderCacheIntoStore
// --------------------------------------------------------------------------------
HRESULT MergeFolderCacheIntoStore(IDatabaseSession *pSession, IMessageStore *pStore, 
    LPFILEINFO pInfo, LPFILEINFO pHeadFile, LPPROGRESSINFO pProgress)
{
    // Locals
    HRESULT             hr=S_OK;
    MEMORYFILE          File={0};
    FOLDERID            idServer;
    DWORD               cFolders;
    DWORD               i;
    LPFLDINFO           prgFolder=NULL;
    LPFLDINFO           pFolder;
    HKEY                hKey=NULL;
    DWORD               cbLength;
    LPBYTE              pbChange=NULL;
    LPFOLDERIDCHANGE    prgidChange;
    IUserIdentityManager    *pManager = NULL;
    IUserIdentity           *pIdentity = NULL;
    HKEY                    hkeyID = NULL;

    // Trace
    TraceCall("MergeFolderCacheIntoStore");

    // Find the Server Id
    if (FAILED(pStore->FindServerId(pInfo->szAcctId, &idServer)))
        goto exit;

    // Open the File
    IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

    // Parse the file
    IF_FAILEXIT(hr = ParseFolderFileV5(&File, pInfo, pProgress, &cFolders, &prgFolder));

    // Loop through the folders
    for (i=0; i<cFolders; i++)
    {
        // If this is the root folder node (OE4), remember to migrate the root hierarchy char
        if ((FOLDERID)IntToPtr(prgFolder[i].idFolder) == FOLDERID_ROOT)
        {
            FOLDERINFO  fiFolderInfo;

            IF_FAILEXIT(hr = pStore->GetFolderInfo(idServer, &fiFolderInfo));

            fiFolderInfo.bHierarchy = prgFolder[i].bHierarchy;
            hr = pStore->UpdateRecord(&fiFolderInfo);
            pStore->FreeRecord(&fiFolderInfo);
            IF_FAILEXIT(hr);
        }
        // If Parent is equal to idParent, then lets insert this node under the new parent
        else if ((FOLDERID)IntToPtr(prgFolder[i].idParent) == FOLDERID_ROOT)
        {
            // InsertFolderIntoStore
            IF_FAILEXIT(hr = InsertFolderIntoStore(pSession, pStore, &prgFolder[i], cFolders, prgFolder, idServer, pInfo, pHeadFile, NULL));
        }
    }

    // Local Folders
    if (FILE_IS_LOCAL_FOLDERS == pInfo->tyFile)
    {
        // cbLength
        cbLength = (sizeof(DWORD) + (sizeof(FOLDERIDCHANGE) * cFolders));

        // Allocate a folderidchange array
        IF_NULLEXIT(pbChange = (LPBYTE)g_pMalloc->Alloc(cbLength));

        // Store cLocalFolders
        CopyMemory(pbChange, &cFolders, sizeof(DWORD));

        // Set prgidChange
        prgidChange = (LPFOLDERIDCHANGE)(pbChange + sizeof(DWORD));

        // Walk through the list of files and merge the folders, sublist, group lists into pFolder
        for (i=0; i<cFolders; i++)
        {
            prgidChange[i].idOld = (FOLDERID)IntToPtr(prgFolder[i].idFolder);
            prgidChange[i].idNew = (FOLDERID)prgFolder[i].idNewFolderId;
        }

        // Get a user manager    
        if (FAILED(CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_IUserIdentityManager, (void **)&pManager)))
            goto exit;

        Assert(pManager);

        // Get Default Identity
        if (FAILED(pManager->GetIdentityByCookie((GUID*)&UID_GIBC_DEFAULT_USER, &pIdentity)))
            goto exit;

        Assert(pIdentity);

        // Ensure that we have an identity and can get to its registry
        if (FAILED(pIdentity->OpenIdentityRegKey(KEY_WRITE, &hkeyID)))
            goto exit;

        Assert(hkeyID);

        // Open the HKCU
        if (ERROR_SUCCESS != RegOpenKeyEx(hkeyID, "Software\\Microsoft\\Outlook Express\\5.0", 0, KEY_ALL_ACCESS, &hKey))
        {
            hr = TraceResult(MIGRATE_E_REGOPENKEY);
            goto exit;
        }

        // Write it to the registry
        if (ERROR_SUCCESS != RegSetValueEx(hKey, "FolderIdChange", 0, REG_BINARY, pbChange, cbLength))
        {
            hr = TraceResult(MIGRATE_E_REGSETVALUE);
            goto exit;
        }
    }

exit:
    // Cleanup
    if (hKey)
        RegCloseKey(hKey);
    if (hkeyID)
        RegCloseKey(hkeyID);
    SafeMemFree(pbChange);
    SafeMemFree(prgFolder);
    SafeRelease(pIdentity);
    SafeRelease(pManager);
 
    CloseMemoryFile(&File);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// MergeNewsGroupList
// --------------------------------------------------------------------------------
HRESULT MergeNewsGroupList(IDatabaseSession *pSession, IMessageStore *pStore, 
    LPFILEINFO pInfo, LPFILEINFO pHeadFile, LPPROGRESSINFO pProgress)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    FOLDERINFO      Folder={0};
    MEMORYFILE      File={0};
    FOLDERID        idServer;
    DWORD           cbRead;
    LPSTR           pszT;
    LPSTR           pszGroup;
    LPSTR           pszDescription;
    FOLDERID        idFolder;
    LPFILEINFO      pSubList=NULL;
    LPFILEINFO      pCurrent;
    LPSUBLISTHEADER pSubListHeader;
    IDatabase *pDB=NULL;
    CHAR            szPath[_MAX_PATH];
    CHAR            szDrive[_MAX_DRIVE];
    CHAR            szDir[_MAX_DIR];
    CHAR            szFile[_MAX_FNAME];
    CHAR            szExt[_MAX_EXT];
    LPGRPLISTHEADER pHeader;

    // Trace
    TraceCall("MergeNewsGroupList");

    // Find the Server Id
    if (FAILED(pStore->FindServerId(pInfo->szAcctId, &idServer)))
        goto exit;

    // Set Progress File
    SetProgressFile(pProgress, pInfo);

    // Open the Group List File
    IF_FAILEXIT(hr = OpenMemoryFile(pInfo->szFilePath, &File));

    // Get the Header
    pHeader = (LPGRPLISTHEADER)File.pView;

    // Initialize cb
    cbRead = sizeof(GRPLISTHEADER);

    // Loop
    for (i=0; i<pHeader->cGroups; i++)
    {
        // Set pszGroup
        pszT = pszGroup = (LPSTR)((LPBYTE)File.pView + cbRead);

        // Increment to end of pszGroup or end of file
        while (*pszT && cbRead < File.cbSize)
        {
            // Increment cb
            cbRead++;

            // End of String
            pszT = (LPSTR)((LPBYTE)File.pView + cbRead);
        }

        // Done
        if (cbRead >= File.cbSize)
            break;

        // Step Over the Null
        cbRead++;

        // Set pszDescription
        pszT = pszDescription = (LPSTR)((LPBYTE)File.pView + cbRead);

        // Increment to end of pszGroup or end of file
        while (*pszT && cbRead < File.cbSize)
        {
            // Increment cb
            cbRead++;

            // End of String
            pszT = (LPSTR)((LPBYTE)File.pView + cbRead);
        }

        // Done
        if (cbRead >= File.cbSize)
            break;

        // Increment over the null
        cbRead++;

        // Step over group type
        cbRead += sizeof(DWORD);

        // Not Empyt
        if ('\0' == *pszGroup)
            break;

        // Set the Folder Info
        Folder.pszName = pszGroup;
        Folder.pszDescription = pszDescription;
        Folder.idParent = idServer;
        Folder.tySpecial = FOLDER_NOTSPECIAL;

        // Create the Folder
        pStore->CreateFolder(0, &Folder, NOSTORECALLBACK);

        // Bump Progress
        if(!g_fQuiet)
            IncrementProgress(pProgress, pInfo);
    }

    // Walk through news message files and create folders for them.
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Find the Sublist for this group
        if (FILE_IS_NEWS_SUBLIST == pCurrent->tyFile && lstrcmpi(pCurrent->szAcctId, pInfo->szAcctId) == 0)
        {
            // Set pSubList
            pSubList = pCurrent;

            // Done
            break;
        }
    }

    // No Sub List
    if (NULL == pSubList)
        goto exit;

    // Close the File
    CloseMemoryFile(&File);

    // Set Progress File
    SetProgressFile(pProgress, pSubList);

    // Open the Group List File
    IF_FAILEXIT(hr = OpenMemoryFile(pSubList->szFilePath, &File));

    // De-Ref the header
    pSubListHeader = (LPSUBLISTHEADER)File.pView;

    // SUBFILE_VERSION5
    if (SUBFILE_VERSION5 == pSubListHeader->dwVersion)
    {
        // Locals
        PGROUPSTATUS5       pStatus;
        DWORD               cbRead;

        // Initialize cbRead
        cbRead = sizeof(SUBLISTHEADER) + sizeof(DWORD);

        // PGROUPSTATUS5
        for (i=0; i<pSubListHeader->cSubscribed; i++)
        {
            // De-Ref the Group Status
            pStatus = (PGROUPSTATUS5)((LPBYTE)File.pView + cbRead);

            // Increment cbRead
            cbRead += sizeof(GROUPSTATUS5);

            // Read the Name
            pszGroup = (LPSTR)((LPBYTE)File.pView + cbRead);

            // Increment cbRead
            cbRead += pStatus->cbName + pStatus->cbReadRange + pStatus->cbKnownRange + pStatus->cbMarkedRange + pStatus->cbRequestedRange;

            // Find The Folder...
            Folder.idParent = idServer;
            Folder.pszName = pszGroup;

            // Try to find this folder
            if (DB_S_FOUND == pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                // Locals
                CHAR szSrcFile[MAX_PATH];

                // Subscribe to It
                if (ISFLAGSET(pStatus->dwFlags, GSF_SUBSCRIBED))
                {
                    // Its SubScribed
                    FLAGSET(Folder.dwFlags, FOLDER_SUBSCRIBED);
                }

                // Format the original file name
                wnsprintf(szSrcFile, ARRAYSIZE(szSrcFile), "%08x", pStatus->dwCacheFileIndex);

                // Try to find the folder in the list of files
                for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
                {
                    // Find the Sublist for this group
                    if (pCurrent->fMigrate && FILE_IS_NEWS_MESSAGES == pCurrent->tyFile && lstrcmpi(pCurrent->szAcctId, pInfo->szAcctId) == 0)
                    {
                        // Get the File Name
                        _splitpath(pCurrent->szFilePath, szDrive, szDir, szFile, szExt);

                        // Correct file name
                        if (lstrcmpi(szFile, szSrcFile) == 0)
                        {
                            // Get the File Name
                            _splitpath(pCurrent->szDstFile, szDrive, szDir, szFile, szExt);

                            // Format the original file name
                            wnsprintf(szSrcFile, ARRAYSIZE(szSrcFile), "%s%s", szFile, szExt);

                            // Set the File Path
                            Folder.pszFile = szSrcFile;

                            // Set Folder Counts
                            Folder.cMessages = pCurrent->cMessages;
                            Folder.cUnread = pCurrent->cUnread;

                            // FixupFolderUserData(
                            FixupFolderUserData(pSession, Folder.idFolder, pszGroup, FOLDER_NOTSPECIAL, pCurrent);

                            // Done
                            break;
                        }
                    }
                }

                // Update the Record
                pStore->UpdateRecord(&Folder);

                // Free This
                pStore->FreeRecord(&Folder);
            }

            // Bump Progress
            if(!g_fQuiet)
                IncrementProgress(pProgress, pSubList);
        }
    }

    // SUBFILE_VERSION4
    else if (SUBFILE_VERSION4 == pSubListHeader->dwVersion)
    {
        // Locals
        PGROUPSTATUS4       pStatus;
        DWORD               cbRead;

        // Initialize cbRead
        cbRead = sizeof(SUBLISTHEADER);

        // PGROUPSTATUS5
        for (i=0; i<pSubListHeader->cSubscribed; i++)
        {
            // De-Ref the Group Status
            pStatus = (PGROUPSTATUS4)((LPBYTE)File.pView + cbRead);

            // Increment cbRead
            cbRead += sizeof(GROUPSTATUS4);

            // Read the Name
            pszGroup = (LPSTR)((LPBYTE)File.pView + cbRead);

            // Increment cbRead
            cbRead += pStatus->cbName + pStatus->cbReadRange + pStatus->cbKnownRange + pStatus->cbMarkedRange + pStatus->cbRequestedRange;

            // Find The Folder...
            Folder.idParent = idServer;
            Folder.pszName = pszGroup;

            // Try to find this folder
            if (DB_S_FOUND == pStore->FindRecord(IINDEX_ALL, COLUMNS_ALL, &Folder, NULL))
            {
                // Locals
                CHAR szSrcFile[MAX_PATH];

                // Subscribe to It
                if (ISFLAGSET(pStatus->dwFlags, GSF_SUBSCRIBED))
                {
                    // Its SubScribed
                    FLAGSET(Folder.dwFlags, FOLDER_SUBSCRIBED);
                }

                // Try to find the folder in the list of files
                for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
                {
                    // Find the Sublist for this group
                    if (pCurrent->fMigrate && FILE_IS_NEWS_MESSAGES == pCurrent->tyFile && lstrcmpi(pCurrent->szAcctId, pInfo->szAcctId) == 0)
                    {
                        // Correct file name
                        if (lstrcmpi(pszGroup, pCurrent->szFolder) == 0)
                        {
                            // Get the File Name
                            _splitpath(pCurrent->szDstFile, szDrive, szDir, szFile, szExt);

                            // Format the original file name
                            wnsprintf(szSrcFile, ARRAYSIZE(szSrcFile), "%s%s", szFile, szExt);

                            // Set the File Path
                            Folder.pszFile = szSrcFile;

                            // Set Folder Counts
                            Folder.cMessages = pCurrent->cMessages;
                            Folder.cUnread = pCurrent->cUnread;

                            // FixupFolderUserData(
                            FixupFolderUserData(pSession, Folder.idFolder, pszGroup, FOLDER_NOTSPECIAL, pCurrent);

                            // Done
                            break;
                        }
                    }
                }

                // Update the Record
                pStore->UpdateRecord(&Folder);

                // Free This
                pStore->FreeRecord(&Folder);
            }

            // Bump Progress
            if(!g_fQuiet)
                IncrementProgress(pProgress, pSubList);
        }
    }

    // SUBFILE_VERSION3
    else if (SUBFILE_VERSION3 == pSubListHeader->dwVersion)
    {
        Assert(FALSE);
    }

    // SUBFILE_VERSION2
    else if (SUBFILE_VERSION2 == pSubListHeader->dwVersion)
    {
        Assert(FALSE);
    }

exit:
    // Close the File
    CloseMemoryFile(&File);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// BuildUnifiedFolderManager
// --------------------------------------------------------------------------------
HRESULT BuildUnifiedFolderManager(IDatabaseSession *pSession, IMessageStore *pStore, 
    LPFILEINFO pHeadFile, LPPROGRESSINFO pProgress)
{
    // Locals
    HRESULT             hr=S_OK;
    LPFILEINFO          pCurrent;

    // Trace
    TraceCall("BuildUnifiedFolderManager");

    // Walk through the list of files and merge the folders, sublist, group lists into pFolder
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Handle Folders Type
        if (FILE_IS_LOCAL_FOLDERS == pCurrent->tyFile)
        {
            // Merge Local Folder Cache into new Folder Manager
            IF_FAILEXIT(hr = MergeFolderCacheIntoStore(pSession, pStore, pCurrent, pHeadFile, pProgress));
        }

        // IMAP Folder
        else if (FILE_IS_IMAP_FOLDERS == pCurrent->tyFile)
        {
            // Merge IMAP Folder Cache into new Folder Manager
            IF_FAILEXIT(hr = MergeFolderCacheIntoStore(pSession, pStore, pCurrent, pHeadFile, pProgress));
        }

        // News Group List
        else if (FILE_IS_NEWS_GRPLIST == pCurrent->tyFile)
        {
            // Merge IMAP Folder Cache into new Folder Manager
            IF_FAILEXIT(hr = MergeNewsGroupList(pSession, pStore, pCurrent, pHeadFile, pProgress));
        }
    }

    // Walk through any files that were not merged into the store
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Find the Sublist for this group
        if (TRUE == pCurrent->fMigrate && FALSE == pCurrent->fInStore)
        {
            // Local Message File...
            if (FILE_IS_LOCAL_MESSAGES == pCurrent->tyFile)
            {
                // Locals
                FLDINFO         Folder={0};
                SPECIALFOLDER   tySpecial;
                CHAR            szFolder[255];
                CHAR            szPath[_MAX_PATH];
                CHAR            szDrive[_MAX_DRIVE];
                CHAR            szDir[_MAX_DIR];
                CHAR            szFile[_MAX_FNAME];
                CHAR            szExt[_MAX_EXT];

                // Get Special Folder Info
                GetSpecialFolderInfo(pCurrent->szFilePath, szFolder, ARRAYSIZE(szFolder), &Folder.tySpecial);

                // Special Case for News Special Folders from v1
                if (0xffffffff == Folder.tySpecial && strstr(szFolder, "special folders") != NULL)
                {
                    // Locals
                    CHAR szRes[255];

                    // News Outbox
                    LoadString(g_hInst, IDS_POSTEDITEMS, szRes, ARRAYSIZE(szRes));

                    // Contains "Posted Items"
                    if (strstr(szFolder, szRes) != NULL)
                        LoadString(g_hInst, IDS_NEWSPOSTED, szFolder, ARRAYSIZE(szFolder));

                    // Contains "Saved Items"
                    else
                    {
                        // News Saved Items
                        LoadString(g_hInst, IDS_SAVEDITEMS, szRes, ARRAYSIZE(szRes));

                        // Contains "Saved Items"
                        if (strstr(szFolder, szRes) != NULL)
                            LoadString(g_hInst, IDS_NEWSSAVED, szFolder, ARRAYSIZE(szFolder));

                        // Otherwise
                        else
                        {
                            // News Outbox
                            LoadString(g_hInst, IDS_OUTBOX, szRes, ARRAYSIZE(szRes));

                            // Contains Outbox
                            if (strstr(szFolder, szRes) != NULL)
                                LoadString(g_hInst, IDS_NEWSOUTBOX, szFolder, ARRAYSIZE(szFolder));
                        }
                    }
                }

                // Compute the File Name
                _splitpath(pCurrent->szDstFile, szDrive, szDir, szFile, szExt);
                wnsprintf(Folder.szFile, ARRAYSIZE(Folder.szFile), "%s.dbx", szFile);

                // Set the Name
                if ('\0' != *pCurrent->szFolder)
                    StrCpyN(Folder.szFolder, pCurrent->szFolder, ARRAYSIZE(Folder.szFolder));
                else if ('\0' != *szFolder)
                    StrCpyN(Folder.szFolder, szFolder, ARRAYSIZE(Folder.szFolder));
                else
                    StrCpyN(Folder.szFolder, szFile, ARRAYSIZE(Folder.szFolder));

                // Set Message and Unread Count
                Folder.cMessages = pCurrent->cMessages;
                Folder.cUnread = pCurrent->cUnread;

                // Insert into Local Store
                InsertFolderIntoStore(pSession, pStore, &Folder, 0, NULL, FOLDERID_LOCAL_STORE, NULL, NULL, (LPFOLDERID)&Folder.idFolder);

                // Fixup special
                tySpecial = (Folder.tySpecial == 0xffffffff) ? FOLDER_NOTSPECIAL : (BYTE)(Folder.tySpecial + 1);

                // Update the Folder's UserData
                FixupFolderUserData(pSession, (FOLDERID)IntToPtr(Folder.idFolder), Folder.szFolder, tySpecial, pCurrent);
            }

            // Otherwise, just delete the file
            else if (FILE_IS_POP3UIDL != pCurrent->tyFile)
                DeleteFile(pCurrent->szDstFile);
        }
    }

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CleanupMessageStore
// --------------------------------------------------------------------------------
HRESULT CleanupMessageStore(LPCSTR pszStoreRoot, IMessageStore *pStore)
{
    // Locals
    HRESULT         hr=S_OK;
    FOLDERINFO      Folder={0};
    HROWSET         hRowset=NULL;
    CHAR            szFilePath[MAX_PATH + MAX_PATH];

    // Trace
    TraceCall("CleanupMessageStore");

    // Create a Rowset
    IF_FAILEXIT(hr = pStore->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

    // Walk the Rowset
    while(S_OK == pStore->QueryRowset(hRowset, 1, (LPVOID *)&Folder, NULL))
    {
        // If it has a file and no messags.
        if (Folder.pszFile && 0 == Folder.cMessages)
        {
            // Delete the file...
            IF_FAILEXIT(hr = MakeFilePath(pszStoreRoot, Folder.pszFile, "", szFilePath, ARRAYSIZE(szFilePath)));

            // Delete the File
            DeleteFile(szFilePath);

            // Reset the filename
            Folder.pszFile = NULL;

            // Update the Record
            IF_FAILEXIT(hr = pStore->UpdateRecord(&Folder));
        }

        // Otherwise, if there is a file, force a folder rename
        else if (Folder.pszFile)
        {
            // Rename the folder
            pStore->RenameFolder(Folder.idFolder, Folder.pszName, 0, NULL);
        }

        // Cleanup
        pStore->FreeRecord(&Folder);
    }

exit:
    // Cleanup
    pStore->FreeRecord(&Folder);
    pStore->CloseRowset(&hRowset);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// UpgradeV5
// --------------------------------------------------------------------------------
HRESULT UpgradeV5(MIGRATETOTYPE tyMigrate, LPCSTR pszStoreSrc, LPCSTR pszStoreDst,
    LPPROGRESSINFO pProgress, LPFILEINFO *ppHeadFile)
{
    // Locals
    HRESULT         hr=S_OK;
    ENUMFILEINFO    EnumInfo;
    LPFILEINFO      pCurrent;
    DWORD           cbNeeded;
    DWORDLONG       dwlFree;
    BOOL            fContinue;
    CHAR            szFolders[MAX_PATH + MAX_PATH];
    CHAR            szMsg[512];
    IMessageStore  *pStore=NULL;
    IDatabaseSession *pSession=NULL;

    // Trace
    TraceCall("UpgradeV5");

    // Initialize
    *ppHeadFile = NULL;

    // Setup the EnumFile Info
    ZeroMemory(&EnumInfo, sizeof(ENUMFILEINFO));
    EnumInfo.pszExt = ".nch";
    EnumInfo.pszFoldFile = "folders.nch";
    EnumInfo.pszUidlFile = "pop3uidl.dat";
    EnumInfo.pszSubList = "sublist.dat";
    EnumInfo.pszGrpList = "grplist.dat";
    EnumInfo.fFindV1News = TRUE;

    // Enumerate All ODB files in szStoreRoot...
    IF_FAILEXIT(hr = EnumerateStoreFiles(pszStoreSrc, DIR_IS_ROOT, NULL, &EnumInfo, ppHeadFile));

    // Setup the EnumFile Info
    ZeroMemory(&EnumInfo, sizeof(ENUMFILEINFO));
    EnumInfo.pszExt = ".mbx";
    EnumInfo.pszFoldFile = NULL;
    EnumInfo.pszUidlFile = NULL;

    // Enumerate All ODB files in szStoreRoot...
    IF_FAILEXIT(hr = EnumerateStoreFiles(pszStoreSrc, DIR_IS_ROOT, NULL, &EnumInfo, ppHeadFile));

    // Nothing to upgrade
    if (NULL == *ppHeadFile)
        goto exit;

    // Compute some Counts, and validate that the files are valid to migrate...
    IF_FAILEXIT(hr = UpgradeProcessFileListV5(pszStoreSrc, pszStoreDst, *ppHeadFile, &pProgress->cMax, &cbNeeded));

    // Message
    LoadString(g_hInst, IDS_UPGRADEMESSAGE, szMsg, ARRAYSIZE(szMsg));

    // Message
    if(!g_fQuiet)           
        MigrateMessageBox(szMsg, MB_OK | MB_ICONINFORMATION | MB_SETFOREGROUND);

    // Delete fles
    UpgradeDeleteFilesV5(pszStoreDst);

    // Create an Ojbect Database
    IF_FAILEXIT(hr = CoCreateInstance(CLSID_DatabaseSession, NULL, CLSCTX_INPROC_SERVER, IID_IDatabaseSession, (LPVOID *)&pSession));

    // Create an Ojbect Database
    IF_FAILEXIT(hr = CoCreateInstance(CLSID_MigrateMessageStore, NULL, CLSCTX_INPROC_SERVER, IID_IMessageStore, (LPVOID *)&pStore));

    // Build the Folders.odb File Path
    wnsprintf(szFolders, ARRAYSIZE(szFolders), "%s\\folders.dbx", pszStoreDst);

    // Delete It First
    DeleteFile(szFolders);

    // Initialize the Store
    IF_FAILEXIT(hr = pStore->Initialize(pszStoreDst));

    // Initialize the Store
    IF_FAILEXIT(hr = pStore->Validate(0));

    // Enought DiskSpace ?
    IF_FAILEXIT(hr = GetAvailableDiskSpace(pszStoreDst, &dwlFree));

    // Not Enought Diskspace
    if (((DWORDLONG) cbNeeded) > dwlFree)
    {
        // cbNeeded is DWORD and in this case we can downgrade dwlFree to DWORD
        g_cbDiskNeeded = cbNeeded; g_cbDiskFree = ((DWORD) dwlFree);
        hr = TraceResult(MIGRATE_E_NOTENOUGHDISKSPACE);
        goto exit;
    }

    // Loop through the files and migrate each one
    for (pCurrent=*ppHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Migrate this file ?
        if (pCurrent->fMigrate)
        {
            // Set Progress File
            SetProgressFile(pProgress, pCurrent);

            // Assume we will continue
            fContinue = FALSE;

            // Downgrade the file
            hr = pCurrent->hrMigrate = UpgradeFileV5(pSession, tyMigrate, pCurrent, pProgress, &fContinue);

            // Failure ?
            if (FAILED(pCurrent->hrMigrate))
            {
                // Set Last Error
                pCurrent->dwLastError = GetLastError();

                // Stop 
                if (FALSE == fContinue)
                    break;

                if(!g_fQuiet) {
                    // Fixup the progress
                    while (pCurrent->cProgCur < pCurrent->cProgMax)
                    {
                        IncrementProgress(pProgress, pCurrent);
                    }
                }

                // We are ok
                hr = S_OK;
            }
        }
    }

    // Process Folder Lists
    hr = BuildUnifiedFolderManager(pSession, pStore, *ppHeadFile, pProgress);

    // Failure, delete all destination files
    if (FAILED(hr))
    {
        // Delete fles
        UpgradeDeleteFilesV5(pszStoreDst);
    }

    // Otherwise, lets force a folder rename to build friendly file names
    else
    {
        // Rename all the folders...
        CleanupMessageStore(pszStoreDst, pStore);
    }

#if 0
    // Otherwise, delete source files
    else
    {
        // Delete all source files
        UpgradeDeleteIdxMbxNchDatFilesV5(*ppHeadFile);
    }
#endif

exit:
    // Cleanup
    SafeRelease(pStore);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\migrate\utility.cpp ===
// --------------------------------------------------------------------------------
// Utility.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "migrate.h"
#include "migerror.h"
#include "utility.h"
#include "resource.h"
#include <shared.h>

extern BOOL g_fQuiet;

/*
 *  CenterDialog
 *
 *  Purpose:
 *      This function centers a dialog with respect to its parent
 *      dialog.
 *
 *  Parameters:
 *      hwndDlg     hwnd of the dialog to center
 */
VOID CenterDialog(HWND hwndDlg)
{
    HWND    hwndOwner;
    RECT    rc;
    RECT    rcDlg;
    RECT    rcOwner;
    RECT    rcWork;
    INT     x;
    INT     y;
    INT     nAdjust;

    // Get the working area rectangle
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0);

    // Get the owner window and dialog box rectangles.
    //  The window rect of the destop window is in trouble on multimonitored
    //  macs. GetWindow only gets the main screen.
    if (hwndOwner = GetParent(hwndDlg))
        GetWindowRect(hwndOwner, &rcOwner);
    else
        rcOwner = rcWork;

    GetWindowRect(hwndDlg, &rcDlg);
    rc = rcOwner;

    // Offset the owner and dialog box rectangles so that
    // right and bottom values represent the width and
    // height, and then offset the owner again to discard
    // space taken up by the dialog box.
    OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);
    OffsetRect(&rc, -rc.left, -rc.top);
    OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);

    // The new position is the sum of half the remaining
    // space and the owner's original position.
    // But not less than Zero - jefbai

    x= rcOwner.left + (rc.right / 2);
    y= rcOwner.top + (rc.bottom / 2);

    // Make sure the dialog doesn't go off the right edge of the screen
    nAdjust = rcWork.right - (x + rcDlg.right);
    if (nAdjust < 0)
        x += nAdjust;

    //$ Raid 5128: Make sure the left edge is visible
    if (x < rcWork.left)
        x = rcWork.left;

    // Make sure the dialog doesn't go off the bottom edge of the screen
    nAdjust = rcWork.bottom - (y + rcDlg.bottom);
    if (nAdjust < 0)
        y += nAdjust;

    //$ Raid 5128: Make sure the top edge is visible
    if (y < rcWork.top)
        y = rcWork.top;
    SetWindowPos(hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

// --------------------------------------------------------------------------------
// CommifyString
// --------------------------------------------------------------------------------
#define WHOLENUM_LEN 30
#define LODWORD(_qw)    (DWORD)(_qw)
const short pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB, 
                          IDS_ORDERGB, IDS_ORDERTB, IDS_ORDERPB, IDS_ORDEREB};

// takes a DWORD add commas etc to it and puts the result in the buffer
LPSTR CommifyString(DWORD dw, LPSTR pszResult, UINT cchBuf)
{
    char  szTemp[30];
    char  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits = 0;
    nfmt.LeadingZero = 0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = atoi(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder = 0;

    wnsprintf(szTemp, ARRAYSIZE(szTemp), TEXT("%lu"), dw);


    if (GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt,pszResult, ARRAYSIZE(szTemp)) == 0)
        StrCpyN(pszResult, szTemp, cchBuf);

    return pszResult;
}

// --------------------------------------------------------------------------------
// MapDataDirToAcctId
// --------------------------------------------------------------------------------
HRESULT MapDataDirToAcctId(DWORD dwServer, LPCSTR pszSubDir, LPSTR pszAcctId, int cchAcctId)
{
    // Locals
    LPACCOUNTINFO   pAccount;
    DWORD           i;

    // Trace
    TraceCall("MapDataDirToAcctId");

    // Set Account Id
    for (i=0; i<g_AcctTable.cAccounts; i++)
    {
        // Redability
        pAccount = &g_AcctTable.prgAccount[i];

        // Looking for News Servers
        if (ISFLAGSET(pAccount->dwServer, dwServer))
        {
            // Same Sub directory
            if (lstrcmpi(pAccount->szDataDir, pszSubDir) == 0)
            {
                // Set Account Id
                StrCpyN(pszAcctId, pAccount->szAcctId, cchAcctId);

                // Done
                return(S_OK);
            }
        }
    }

    // Done
    return(E_FAIL);
}

// --------------------------------------------------------------------------------
// EnumerateStoreFiles
// --------------------------------------------------------------------------------
HRESULT EnumerateStoreFiles(LPCSTR pszPath, DIRTYPE tyDir, LPCSTR pszSubDir, 
    LPENUMFILEINFO pEnumInfo, LPFILEINFO *ppHead)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szFullPath[MAX_PATH + MAX_PATH];
    CHAR            szSearch[MAX_PATH + MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE          hFind=INVALID_HANDLE_VALUE;
    DWORD           i;
    LPACCOUNTINFO   pAccount;
    LPFILEINFO      pNew=NULL;

    // Trace
    TraceCall("EnumerateStoreFiles");

    // Invalid Args
    Assert(pszPath && pEnumInfo && pEnumInfo->pszExt && pEnumInfo->pszExt[0] == '.' && ppHead);

    // Build Base Path
    if (pszSubDir)
        wnsprintf(szFullPath, ARRAYSIZE(szFullPath), "%s\\%s", pszPath, pszSubDir);
    else
        StrCpyN(szFullPath, pszPath, ARRAYSIZE(szFullPath));

    // Do we have a sub dir
    wnsprintf(szSearch, ARRAYSIZE(szSearch), "%s\\*.*", szFullPath);

    // Find first file
    hFind = FindFirstFile(szSearch, &fd);

    // Did we find something
    if (INVALID_HANDLE_VALUE == hFind)
        goto exit;

    // Loop for ever
    while(1)
    {
        // If this is not a directory
        if (ISFLAGSET(fd.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
        {
            // Not . and not ..
            if (lstrcmpi(fd.cFileName, ".") != 0 && lstrcmpi(fd.cFileName, "..") != 0)
            {
                // Default Dirtype
                DIRTYPE tyDirNew=tyDir;

                // Decide new dir type
                if (lstrcmpi(fd.cFileName, "mail") == 0)
                    tyDirNew = DIR_IS_LOCAL;
                else if (lstrcmpi(fd.cFileName, "news") == 0)
                    tyDirNew = DIR_IS_NEWS;
                else if (lstrcmpi(fd.cFileName, "imap") == 0)
                    tyDirNew = DIR_IS_IMAP;

                // Recursive...
                IF_FAILEXIT(hr = EnumerateStoreFiles(szFullPath, tyDirNew, fd.cFileName, pEnumInfo, ppHead));
            }
        }

        // Otherwise... don't enumerate any files in the root directory...
        else if (DIR_IS_ROOT != tyDir)
        {
            // Locals
            BOOL    fIsFile=FALSE;
            CHAR    szPath[_MAX_PATH];
            CHAR    szDrive[_MAX_DRIVE];
            CHAR    szDir[_MAX_DIR];
            CHAR    szFile[_MAX_FNAME];
            CHAR    szExt[_MAX_EXT];

            // Split the Path
            _splitpath(fd.cFileName, szDrive, szDir, szFile, szExt);
   
            // Extension I'm looking for ?
            if ('\0' != *szExt)
            {
                // Ext1
                if (lstrcmpi(pEnumInfo->pszExt, szExt) == 0)
                    fIsFile = TRUE;

                // FoldFile
                if (pEnumInfo->pszFoldFile && lstrcmpi(pEnumInfo->pszFoldFile, fd.cFileName) == 0)
                    fIsFile = TRUE;

                // UidlFile
                if (pEnumInfo->pszUidlFile && lstrcmpi(pEnumInfo->pszUidlFile, fd.cFileName) == 0)
                    fIsFile = TRUE;

                // SubList
                if (pEnumInfo->pszSubList && lstrcmpi(pEnumInfo->pszSubList, fd.cFileName) == 0)
                    fIsFile = TRUE;

                // GrpList
                if (pEnumInfo->pszGrpList && lstrcmpi(pEnumInfo->pszGrpList, fd.cFileName) == 0)
                    fIsFile = TRUE;
            }

            // If Not is file, and caller wants to look for v1 news and I'm in the news directory
            if (FALSE == fIsFile && TRUE == pEnumInfo->fFindV1News && DIR_IS_NEWS == tyDir)
            {
                // If this is a .dat file or a .sub file
                if (lstrcmpi(szExt, ".dat") == 0)
                    fIsFile = TRUE;

                // .sub file
                else if (lstrcmpi(szExt, ".sub") == 0)
                    fIsFile = TRUE;
            }

            // Is File
            if (fIsFile)
            {
                // Allocate a FileInfo
                IF_NULLEXIT(pNew = (LPFILEINFO)g_pMalloc->Alloc(sizeof(FILEINFO)));

                // Zero alloc
                ZeroMemory(pNew, sizeof(FILEINFO));

                // Determine File Type
                if (DIR_IS_LOCAL == tyDir)
                {
                    // Default file type
                    pNew->tyFile = FILE_IS_LOCAL_MESSAGES;

                    // Set Server Type
                    pNew->dwServer = SRV_POP3;

                    // Set Account Id
                    StrCpyN(pNew->szAcctId, "LocalStore", ARRAYSIZE(pNew->szAcctId));

                    // Folders
                    if (pEnumInfo->pszFoldFile && lstrcmpi(pEnumInfo->pszFoldFile, fd.cFileName) == 0)
                        pNew->tyFile = FILE_IS_LOCAL_FOLDERS;

                    // pop3uidl
                    else if (pEnumInfo->pszUidlFile && lstrcmpi(pEnumInfo->pszUidlFile, fd.cFileName) == 0)
                        pNew->tyFile = FILE_IS_POP3UIDL;
                }
                
                // News
                else if (DIR_IS_NEWS == tyDir)
                {
                    // Default file type
                    pNew->tyFile = FILE_IS_NEWS_MESSAGES;

                    // Set Server Type
                    pNew->dwServer = SRV_NNTP;

                    // Map to An Account Id
                    MapDataDirToAcctId(SRV_NNTP, pszSubDir, pNew->szAcctId, ARRAYSIZE(pNew->szAcctId));

                    // sublist.dat
                    if (pEnumInfo->pszSubList && lstrcmpi(pEnumInfo->pszSubList, fd.cFileName) == 0)
                        pNew->tyFile = FILE_IS_NEWS_SUBLIST;

                    // grplist.dat
                    else if (pEnumInfo->pszGrpList && lstrcmpi(pEnumInfo->pszGrpList, fd.cFileName) == 0)
                        pNew->tyFile = FILE_IS_NEWS_GRPLIST;

                    // If this is a .dat file or a .sub file
                    else if (pEnumInfo->fFindV1News)
                    {
                        // Group List
                        if (lstrcmpi(szExt, ".dat") == 0)
                            pNew->tyFile = FILE_IS_NEWS_GRPLIST;
    
                        // .sub file
                        else if (lstrcmpi(szExt, ".sub") == 0)
                            pNew->tyFile = FILE_IS_NEWS_SUBLIST;

                        // Try to find the Account (szFile should equal the server name)
                        for (DWORD i=0; i<g_AcctTable.cAccounts; i++)
                        {
                            // Is this the Account
                            if (lstrcmpi(g_AcctTable.prgAccount[i].szServer, szFile) == 0)
                            {
                                StrCpyN(pNew->szAcctId, g_AcctTable.prgAccount[i].szAcctId, ARRAYSIZE(pNew->szAcctId));
                                break;
                            }
                        }
                    }
                }

                // IMAP
                else if (DIR_IS_IMAP == tyDir)
                {
                    // Default file type
                    pNew->tyFile = FILE_IS_IMAP_MESSAGES;

                    // Set Server Type
                    pNew->dwServer = SRV_IMAP;

                    // Map to An Account Id
                    MapDataDirToAcctId(SRV_IMAP, pszSubDir, pNew->szAcctId, ARRAYSIZE(pNew->szAcctId));

                    // Folders
                    if (pEnumInfo->pszFoldFile && lstrcmpi(pEnumInfo->pszFoldFile, fd.cFileName) == 0)
                        pNew->tyFile = FILE_IS_IMAP_FOLDERS;
                }

                // Format the filename
                wnsprintf(pNew->szFilePath, ARRAYSIZE(pNew->szFilePath), "%s\\%s", szFullPath, fd.cFileName);

                // Trace This
                TraceInfo(_MSG("MigFile: %s", pNew->szFilePath));

                // Link It In
                pNew->pNext = (*ppHead);

                // Set ppHead
                *ppHead = pNew;

                // Don't Free pNew
                pNew = NULL;
            }
        }

        // Find the Next File
        if (!FindNextFile(hFind, &fd))
            break;
    }

exit:
    // Cleanup
    SafeMemFree(pNew);
    if (hFind)
        FindClose(hFind);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// FreeFileList
// --------------------------------------------------------------------------------
HRESULT FreeFileList(LPFILEINFO *ppHead)
{
    // Locals
    LPFILEINFO pCurrent=(*ppHead);
    LPFILEINFO pNext;

    // Loop
    while (pCurrent)
    {
        // Save Next
        pNext = pCurrent->pNext;

        // Free Current
        g_pMalloc->Free(pCurrent);

        // Goto Next
        pCurrent = pNext;
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// MigrageDlgProc
// --------------------------------------------------------------------------------
INT_PTR CALLBACK MigrageDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Trace
    TraceCall("MigrageDlgProc");

    // Handle Message
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return TRUE;
    }

    // Done
    return 0;
}

// --------------------------------------------------------------------------------
// InitializeCounters
// --------------------------------------------------------------------------------
void InitializeCounters(LPMEMORYFILE pFile, LPFILEINFO pInfo, LPDWORD pcMax, 
    LPDWORD pcbNeeded, BOOL fInflate)
{
    // Increment pcMax
    (*pcMax) += pFile->cbSize;

    // Save Size
    pInfo->cbFile = pFile->cbSize;

    // Set Progress Max
    pInfo->cProgMax = pFile->cbSize;

    // Set cProgInc
    pInfo->cProgInc = pInfo->cRecords > 0 ? (pFile->cbSize / pInfo->cRecords) : pFile->cbSize;

    // Increment pcbNeeded
    (*pcbNeeded) += pInfo->cbFile;

    // Assume the file will be 8% bigger
    if (fInflate)
        (*pcbNeeded) += ((pInfo->cbFile * 8) / 100);
}

// --------------------------------------------------------------------------------
// IncrementProgress
// --------------------------------------------------------------------------------
void IncrementProgress(LPPROGRESSINFO pProgress, LPFILEINFO pInfo)
{
    // Locals
    MSG                 msg;
    ULARGE_INTEGER      uliCurrent;
    ULARGE_INTEGER      uliMax;

    // Trace
    TraceCall("IncrementProgress");

    // Increment
    pProgress->cCurrent += pInfo->cProgInc;

    // Increment per-file progress
    pInfo->cProgCur += pInfo->cProgInc;

    // If cur is now larget than max ?
    if (pProgress->cCurrent > pProgress->cMax)
        pProgress->cCurrent = pProgress->cMax;

    // Set 64
    uliCurrent.QuadPart = pProgress->cCurrent;
    uliMax.QuadPart = pProgress->cMax;

    // Compute percent
    DWORD cPercent = (DWORD)((uliCurrent.QuadPart) * 100 / uliMax.QuadPart);

    // Change
    if (cPercent != pProgress->cPercent)
    {
        // Locals
        CHAR    szRes[50];
        CHAR    szProgress[50];

        // Save It
        pProgress->cPercent = cPercent;

        // Load the String
        LoadString(g_hInst, IDS_COMPLETE, szRes, ARRAYSIZE(szRes));

        // Update status
        if(!g_fQuiet)
            SendMessage(GetDlgItem(pProgress->hwndProgress, IDC_PROGRESS), PBM_SETPOS, pProgress->cPercent, 0);

        // Format
        wnsprintf(szProgress, ARRAYSIZE(szProgress), szRes, cPercent);

        // Update Description...
        if(!g_fQuiet)
            SetDlgItemText(pProgress->hwndProgress, IDS_STATUS, szProgress);
    }

    // Pump messages until current cycle is complete
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        if (!IsDialogMessage(pProgress->hwndProgress, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
}

// --------------------------------------------------------------------------------
// SetProgressFile
// --------------------------------------------------------------------------------
void SetProgressFile(LPPROGRESSINFO pProgress, LPFILEINFO pInfo)
{
    // Locals
    CHAR            szRes[255];
    CHAR            szMsg[255 + MAX_PATH + MAX_PATH];
    CHAR            szScratch[50];

    // Load String
    LoadString(g_hInst, IDS_MIGRATING, szRes, ARRAYSIZE(szRes));

    // Format the String
    wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, pInfo->szFilePath, StrFormatByteSize64A(pInfo->cbFile, szScratch, ARRAYSIZE(szScratch)));

    // Update Description...
    if(!g_fQuiet)
        SetDlgItemText(pProgress->hwndProgress, IDS_DESCRIPT, szMsg);
}

// --------------------------------------------------------------------------------
// WriteMigrationLogFile
// --------------------------------------------------------------------------------
HRESULT WriteMigrationLogFile(HRESULT hrMigrate, DWORD dwLastError, 
    LPCSTR pszStoreRoot, LPCSTR pszMigrate, LPCSTR pszCmdLine, LPFILEINFO pHeadFile)
{
    // Locals
    HRESULT         hr=S_OK;
    HANDLE          hFile=NULL;
    DWORD           cbFile;
    CHAR            szWrite[2024];
    DWORD           cbWrote;
    CHAR            szLogFile[MAX_PATH];
    SYSTEMTIME      st;
    LPFILEINFO      pCurrent;

    // Trace
    TraceCall("WriteMigrationLogFile");

    // Invalid Args
    Assert(pszStoreRoot && pszCmdLine);

    // File name too long....
    wnsprintf(szLogFile, ARRAYSIZE(szLogFile), "%s\\%s.log", pszStoreRoot, pszMigrate);

    // Open the File
    hFile = CreateFile(szLogFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_FLAG_RANDOM_ACCESS | FILE_ATTRIBUTE_NORMAL, NULL);

    // Failure
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hFile = NULL;
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Get the Size
    cbFile = ::GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbFile)
    {
        hr = TraceResult(MIGRATE_E_CANTGETFILESIZE);
        goto exit;
    }

    // If file is getting kind of large
    if (cbFile >=  102400)
    {
        // Seek to the end of the file...
        if (0xffffffff == SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
        {
            hr = TraceResult(MIGRATE_E_CANTSETFILEPOINTER);
            goto exit;
        }

        // Set End Of File
        if (0 == SetEndOfFile(hFile))
        {
            hr = TraceResult(MIGRATE_E_CANTSETENDOFFILE);
            goto exit;
        }
    }

    // Seek to the end of the file...
    if (0xffffffff == SetFilePointer(hFile, 0, NULL, FILE_END))
    {
        hr = TraceResult(MIGRATE_E_CANTSETFILEPOINTER);
        goto exit;
    }

    // add a new line
    if (!WriteFile(hFile, pszCmdLine, lstrlen(pszCmdLine), &cbWrote, NULL))
    {
        hr = TraceResult(MIGRATE_E_WRITEFILE);
        goto exit;
    }

    // add a new line
    if (!WriteFile(hFile, "\r\n", lstrlen("\r\n"), &cbWrote, NULL))
    {
        hr = TraceResult(MIGRATE_E_WRITEFILE);
        goto exit;
    }

    // Write the Date
    GetLocalTime(&st);

    // Build the string
    wnsprintf(szWrite, ARRAYSIZE(szWrite), "Date: %.2d/%.2d/%.4d %.2d:%.2d:%.2d\r\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);

    // add a new line
    if (!WriteFile(hFile, szWrite, lstrlen(szWrite), &cbWrote, NULL))
    {
        hr = TraceResult(MIGRATE_E_WRITEFILE);
        goto exit;
    }

    // Set Text
    wnsprintf(szWrite, ARRAYSIZE(szWrite), "Store Root: %s\r\nGlobal Migrate Result: HRESULT = 0x%08X, GetLastError() = %d\r\n\r\n", pszStoreRoot, hrMigrate, dwLastError);

    // Write Store Root
    if (!WriteFile(hFile, szWrite, lstrlen(szWrite), &cbWrote, NULL))
    {
        hr = TraceResult(MIGRATE_E_WRITEFILE);
        goto exit;
    }

    // Loop through the files
    for (pCurrent=pHeadFile; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Format the string
        wnsprintf(szWrite, ARRAYSIZE(szWrite), "cbFile: %012d, cRecords: %08d, fMigrate: %d, hrMigrate: 0x%08X, GetLastError(): %05d, File: %s\r\n", 
            pCurrent->cbFile, pCurrent->cRecords, pCurrent->fMigrate, pCurrent->hrMigrate, pCurrent->dwLastError, pCurrent->szFilePath);

        // Write Store Root
        if (!WriteFile(hFile, szWrite, lstrlen(szWrite), &cbWrote, NULL))
        {
            hr = TraceResult(MIGRATE_E_WRITEFILE);
            goto exit;
        }
    }

    // Write Store Root
    if (!WriteFile(hFile, "\r\n\r\n", lstrlen("\r\n\r\n"), &cbWrote, NULL))
    {
        hr = TraceResult(MIGRATE_E_WRITEFILE);
        goto exit;
    }

exit:
    // Close the file
    if (hFile)
        CloseHandle(hFile);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// BlobReadData
// --------------------------------------------------------------------------------
HRESULT BlobReadData(LPBYTE lpbBlob, ULONG cbBlob, ULONG *pib, LPBYTE lpbData, ULONG cbData)
{
    // Check Parameters
    AssertSz(lpbBlob && cbBlob > 0 && pib && cbData > 0 && lpbData, "Bad Parameter");
    AssertReadWritePtr(lpbBlob, cbData);
    AssertReadWritePtr(lpbData, cbData);
    AssertSz(*pib + cbData <= cbBlob, "Blob overflow");

    // Copy Data Data
    CopyMemory (lpbData, lpbBlob + (*pib), cbData);
    *pib += cbData;

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// ReplaceExtension
// --------------------------------------------------------------------------------
void ReplaceExtension(LPCSTR pszFilePath, LPCSTR pszExtNew, LPSTR pszFilePathNew, int cchFilePathNew)
{
    // Locals
    CHAR szPath[_MAX_PATH];
    CHAR szDrive[_MAX_DRIVE];
    CHAR szDir[_MAX_DIR];
    CHAR szFile[_MAX_FNAME];
    CHAR szExt[_MAX_EXT];

    // Trace
    TraceCall("ReplaceExtension");

    // Split the Path
    _splitpath(pszFilePath, szDrive, szDir, szFile, szExt);

    // Build New File Path
    wnsprintf(pszFilePathNew, cchFilePathNew, "%s%s%s%s", szDrive, szDir, szFile, pszExtNew);

    // Done
    return;
}

// --------------------------------------------------------------------------------
// GetAvailableDiskSpace
// --------------------------------------------------------------------------------
HRESULT GetAvailableDiskSpace(LPCSTR pszFilePath, DWORDLONG *pdwlFree)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szDrive[5];
    DWORD       dwSectorsPerCluster;
    DWORD       dwBytesPerSector;
    DWORD       dwNumberOfFreeClusters;
    DWORD       dwTotalNumberOfClusters;

    // Trace
    TraceCall("GetAvailableDiskSpace");

    // Invalid Args
    Assert(pszFilePath && pszFilePath[1] == ':' && pdwlFree);

    // Split the path
    szDrive[0] = *pszFilePath;
    szDrive[1] = ':';
    szDrive[2] = '\\';
    szDrive[3] = '\0';
    
    // Get free disk space - if it fails, lets pray we have enought disk space
    if (!GetDiskFreeSpace(szDrive, &dwSectorsPerCluster, &dwBytesPerSector, &dwNumberOfFreeClusters, &dwTotalNumberOfClusters))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Return Amount of Free Disk Space
    *pdwlFree = (dwNumberOfFreeClusters * (dwSectorsPerCluster * dwBytesPerSector));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MyWriteFile
// --------------------------------------------------------------------------------
HRESULT MyWriteFile(HANDLE hFile, DWORD faAddress, LPVOID pData, DWORD cbData)
{  
    // Locals
    DWORD cbWrote;

    // Trace
    TraceCall("MyWriteFile");

    // Seek to the end of the file...
    if (0xffffffff == SetFilePointer(hFile, faAddress, NULL, FILE_BEGIN))
        return TraceResult(MIGRATE_E_CANTSETFILEPOINTER);

    // Write file
    if (0 == WriteFile(hFile, pData, cbData, &cbWrote, NULL))
        return TraceResult(MIGRATE_E_WRITEFILE);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// MigrateMessageBox
// --------------------------------------------------------------------------------
UINT MigrateMessageBox(LPCSTR pszMsg, UINT uType)
{
    // Locals
    CHAR        szTitle[100];

    // Load title
    LoadString(g_hInst, IDS_TITLE, szTitle, ARRAYSIZE(szTitle));

    // MessageBox
    return MessageBox(NULL, pszMsg, szTitle, uType);
}

// --------------------------------------------------------------------------------
// CreateAccountDirectory
// --------------------------------------------------------------------------------
HRESULT CreateAccountDirectory(LPCSTR pszStoreRoot, LPCSTR pszBase, DWORD iAccount,
    LPSTR pszPath, int cchPath)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szDir[MAX_PATH + MAX_PATH];

    // Trace
    TraceCall("CreateAccountDirectory");

    // Loop
    while(1)
    {
        // Format the path
        wnsprintf(pszPath, cchPath, "Acct%04d", iAccount);

        // Format the Path
        wnsprintf(szDir, ARRAYSIZE(szDir), "%s\\%s\\%s", pszStoreRoot, pszBase, pszPath);

        // Create the Directory
        if (CreateDirectory(szDir, NULL))
            break;

        // If not already exists, failure
        if (ERROR_ALREADY_EXISTS != GetLastError())
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Try Again
        iAccount++;
    }

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// BuildAccountTable
// --------------------------------------------------------------------------------
HRESULT BuildAccountTable(HKEY hkeyBase, LPCSTR pszRegRoot, LPCSTR pszStoreRoot,
    LPACCOUNTTABLE pTable)
{
    // Locals
    HRESULT         hr=S_OK;
    HKEY            hkeyRoot=NULL;
    HKEY            hkeyAcct=NULL;
    DWORD           i;
    DWORD           cb;
    DWORD           cAccounts=0;
    DWORD           dwType;
    LONG            lResult;
    LPACCOUNTINFO   pAccount;

    // Trace
    TraceCall("BuildAccountTable");

    // Validate Args
    Assert(hkeyBase && pszRegRoot && pTable);

    // Initialize
    ZeroMemory(pTable, sizeof(ACCOUNTTABLE));

    // Open the Root Key
    if (ERROR_SUCCESS != RegOpenKeyEx(hkeyBase, pszRegRoot, 0, KEY_ALL_ACCESS, &hkeyRoot))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Enumerate keys
    if (ERROR_SUCCESS != RegQueryInfoKey(hkeyRoot, NULL, NULL, 0, &pTable->cAccounts, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Allocate the Account Array
    IF_NULLEXIT(pTable->prgAccount = (LPACCOUNTINFO)ZeroAllocate(sizeof(ACCOUNTINFO) * pTable->cAccounts));

    // Start Enumerating the keys
    for (i=0; i<pTable->cAccounts; i++)
    {
        // Close Current hkeyAcct
        if (hkeyAcct)
        {
            RegCloseKey(hkeyAcct);
            hkeyAcct = NULL;
        }

        // Readability
        pAccount = &pTable->prgAccount[cAccounts];

        // Set the size of the account id field
        cb = sizeof(pAccount->szAcctId);

        // Enum the Key Info
        lResult = RegEnumKeyEx(hkeyRoot, i, pAccount->szAcctId, &cb, 0, NULL, NULL, NULL);

        // No more items
        if (lResult == ERROR_NO_MORE_ITEMS)
            break;

        // Error, lets move onto the next account
        if (lResult != ERROR_SUCCESS)
        {
            Assert(FALSE);
            continue;
        }

        // Open the Account Key
        if (ERROR_SUCCESS != RegOpenKeyEx(hkeyRoot, pAccount->szAcctId, 0, KEY_ALL_ACCESS, &hkeyAcct))
        {
            Assert(FALSE);
            continue;
        }

        // Set Length of Field
        cb = sizeof(pAccount->szAcctName);

        // Query the Account Name
        if (ERROR_SUCCESS != RegQueryValueEx(hkeyAcct, "Account Name", NULL, &dwType, (LPBYTE)pAccount->szAcctName, &cb))
        {
            Assert(FALSE);
            continue;
        }

        // Set Length of field
        cb = sizeof(pAccount->szServer);

        // Try to determine the account type
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyAcct, "POP3 Server", NULL, &dwType, (LPBYTE)pAccount->szServer, &cb))
        {
            // Its a pop3 server
            pAccount->dwServer = SRV_POP3;

            // Set the Directory
            wnsprintf(pAccount->szDirectory, ARRAYSIZE(pAccount->szDirectory), "%s\\Mail", pszStoreRoot);
        }

        // Otherwise - NNTP
        else if (ERROR_SUCCESS == RegQueryValueEx(hkeyAcct, "NNTP Server", NULL, &dwType, (LPBYTE)pAccount->szServer, &cb))
        {
            // Its an nntp account
            pAccount->dwServer = SRV_NNTP;

            // Set length of the field
            cb = sizeof(pAccount->szDataDir);

            // Query the Data Directory
            if (ERROR_SUCCESS != RegQueryValueEx(hkeyAcct, "NNTP Data Directory", NULL, &dwType, (LPBYTE)pAccount->szDataDir, &cb))
            {
                // CreateAccountDirectory
                if (FAILED(CreateAccountDirectory(pszStoreRoot, "News", i, pAccount->szDataDir, ARRAYSIZE(pAccount->szDataDir))))
                    continue;

                // Set the Data Directory
                if (ERROR_SUCCESS != RegSetValueEx(hkeyAcct, "NNTP Data Directory", 0, REG_SZ, (LPBYTE)pAccount->szDataDir, lstrlen(pAccount->szDataDir) + 1))
                    continue;
            }

            // Format the Directory
            wnsprintf(pAccount->szDirectory, ARRAYSIZE(pAccount->szDirectory), "%s\\News\\%s", pszStoreRoot, pAccount->szDataDir);
        }
        
        // Otherwise - IMAP
        else if (ERROR_SUCCESS == RegQueryValueEx(hkeyAcct, "IMAP Server", NULL, &dwType, (LPBYTE)pAccount->szServer, &cb))
        {
            // Its an IMAP Server
            pAccount->dwServer = SRV_IMAP;

            // Set length of the field
            cb = sizeof(pAccount->szDataDir);

            // Query the Data Directory
            if (ERROR_SUCCESS != RegQueryValueEx(hkeyAcct, "IMAP Data Directory", NULL, &dwType, (LPBYTE)pAccount->szDataDir, &cb))
            {
                // CreateAccountDirectory
                if (FAILED(CreateAccountDirectory(pszStoreRoot, "IMAP", i, pAccount->szDataDir, ARRAYSIZE(pAccount->szDataDir))))
                    continue;

                // Set the Data Directory
                if (ERROR_SUCCESS != RegSetValueEx(hkeyAcct, "IMAP Data Directory", 0, REG_SZ, (LPBYTE)pAccount->szDataDir, lstrlen(pAccount->szDataDir) + 1))
                    continue;
            }

            // Format the Directory
            wnsprintf(pAccount->szDirectory, ARRAYSIZE(pAccount->szDirectory), "%s\\IMAP\\%s", pszStoreRoot, pAccount->szDataDir);
        }

        // Othewise, skip the account
        else
            continue;

        // Make sure the directory exists
        if (0 == CreateDirectory(pAccount->szDirectory, NULL) && ERROR_ALREADY_EXISTS != GetLastError())
            continue;

        // Increment Valid Account Count
        cAccounts++;
    }

    // Set Actual Number of Accounts
    pTable->cAccounts = cAccounts;

exit:
    // Cleanup
    if (hkeyAcct)
        RegCloseKey(hkeyAcct);
    if (hkeyRoot)
        RegCloseKey(hkeyRoot);

    // Done
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mirlib\mirport.h ===
/****************************** mirport.h **********************************\
* Module Name: mirport.h                                                   *
*                                                                          *
* This file contains imported definitions and function prototypes for      *
* the Right-To-Left (RTL) Mirroring support API (NT5 and BiDi memphis      *
*                                                                          *
* This is a temp file and should be removed when the build is picking      * 
* the latest winuser.h and wingdi.h from the NT5 tree                      *
*                                                                          *
* Created: 16-Feb-1998 02:10:11 am                                         *
* Author:  Mohamed Sadek [a-msadek]                                        *
*                                                                          *
* Copyright (c) 1998 Microsoft Corporation                                 *
\**************************************************************************/


//winuser.h

#ifndef WS_EX_NOINHERITLAYOUT
#define WS_EX_NOINHERITLAYOUT          0x00100000L // Disable inheritence of mirroring by children
#else 
#error "WS_EX_NOINHERITLAYOUT is already defined in winuser.h"
#endif // WS_EX_NOINHERITLAYOUT


#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL                 0x00400000L // Right to left mirroring
#else
#error "WS_EX_LAYOUTRTL is already defined in winuser.h"
#endif // WS_EX_LAYOUTRTL

WINUSERAPI BOOL WINAPI GetProcessDefaultLayout(DWORD *pdwDefaultLayout);
WINUSERAPI BOOL WINAPI SetProcessDefaultLayout(DWORD dwDefaultLayout);


//wingdi.h
#ifndef NOMIRRORBITMAP
#define NOMIRRORBITMAP            (DWORD)0x80000000 /* Do not Mirror the bitmap in this call*/
#else
#error "NOMIRRORBITMAP is already defined in wingdi.h"
#endif // NOMIRRORBITMAP

WINGDIAPI DWORD WINAPI SetLayout(HDC, DWORD);
WINGDIAPI DWORD WINAPI GetLayout(HDC);


#ifndef LAYOUT_RTL
#define LAYOUT_RTL                       0x00000001 // Right to left
#else
#error "LAYOUT_RTL is already defined in wingdi.h"
#endif // LAYOUT_RTL

#ifndef LAYOUT_BTT
#define LAYOUT_BTT                        0x00000002 // Bottom to top
#else
#error "LAYOUT_BTT is already defined in wingdi.h"
#endif // LAYOUT_BTT

#ifndef LAYOUT_VBH
#define LAYOUT_VBH                        0x00000004 // Vertical before horizontal
#else
#error "LAYOUT_VBH is already defined in wingdi.h"
#endif // LAYOUT_VBH

#define LAYOUT_ORIENTATIONMASK             LAYOUT_RTL | LAYOUT_BTT | LAYOUT_VBH


#ifndef LAYOUT_BITMAPORIENTATIONPRESERVED
#define LAYOUT_BITMAPORIENTATIONPRESERVED  0x00000008
#else
#error "LAYOUT_BITMAPORIENTATIONPRESERVED is already defined in wingdi.h"
#endif // LAYOUT_BITMAPORIENTATIONPRESERVED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\acctimp.h ===
#ifndef _INC_ACCTIMP
#define _INC_ACCTIMP

#include <ras.h>

typedef struct tagIMPACCOUNTINFO
    {
    DWORD_PTR dwCookie;
    DWORD dwReserved;
    char szDisplay[CCHMAX_ACCOUNT_NAME];
    } IMPACCOUNTINFO;

// {39981122-C287-11D0-8D8C-00C04FD6202B}
DEFINE_GUID(IID_IEnumIMPACCOUNTS, 0x39981122L, 0xC287, 0x11D0, 0x8D, 0x8C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

interface IEnumIMPACCOUNTS : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(IMPACCOUNTINFO *pinfo) = 0;
        virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;
    };

// {39981123-C287-11D0-8D8C-00C04FD6202B}
DEFINE_GUID(IID_IAccountImport, 0x39981123L, 0xC287, 0x11D0, 0x8D, 0x8C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

interface IAccountImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AutoDetect(DWORD *pcAcct, DWORD dwFlags) = 0;
        virtual HRESULT STDMETHODCALLTYPE EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct) = 0;
    };

// {6F5900A1-4683-11d1-83BB-00C04FBD7C09}
DEFINE_GUID(IID_INewsGroupImport, 0x6f5900a1, 0x4683, 0x11d1, 0x83, 0xbb, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

interface INewsGroupImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(IImnAccount *pAccount) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportSubList(LPCSTR pListGroups) = 0;
    };

// {83782E60-39C6-11d1-83B8-00C04FBD7C09}
DEFINE_GUID(IID_IAccountImport2, 0x83782e60, 0x39c6, 0x11d1, 0x83, 0xb8, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

// IMPCONNINFO connect values
enum
    {
    CONN_NO_INFO = 0,
    CONN_USE_DEFAULT,
    CONN_USE_SETTINGS,
    CONN_CREATE_ENTRY
    };

typedef struct tagIMPCONNINFO
    {
    DWORD cbSize;
    DWORD dwConnect;
    DWORD flags;

    // if connect == CONN_USE_SETTINGS
    DWORD dwConnectType;                    // CONNECTION_TYPE_ value
    char szConnectoid[CCHMAX_CONNECTOID];   // if CONNECTION_TYPE_RAS

    // if connect == CONN_CREATE_ENTRY
    // values used to create new phonebook entry used to connect this account
    DWORD dwCountryID;
    DWORD dwCountryCode;
    char szAreaCode[RAS_MaxAreaCode + 1];
    char szLocalPhoneNumber[RAS_MaxPhoneNumber + 1];
    } IMPCONNINFO;

interface IAccountImport2 : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd, DWORD_PTR dwCookie) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo) = 0;
};

#endif // _INC_ACCTIMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\accthelp.h ===
//Generic text for all groupbox labels:
#define IDH_INETCOMM_GROUPBOX                 505  

//Internet Accounts Dialog box
#define IDH_NEWS_SERV_SERVERS                 510 //Accounts list
#define IDH_NEWS_SERV_ADD                     515 //Add button
#define IDH_NEWS_SERV_REMOVE                  520 //Remove button
#define IDH_NEWS_SERV_PROPERTIES              525 //Properties button
#define IDH_INETCOMM_SETASDEFAULT             527 //Set as default button
#define IDH_INETCOM_DS_SETORDER               529 //Set Order button
#define IDH_NEWS_SERV_IMPORT			501 //Import button
#define IDH_NEWS_SERV_EXPORT			502 //Export button

//General Tab
#define IDH_MAIL_ACCOUNT                      530 //Mail Account/News Account
#define IDH_NEWS_SERV_NAME                    535 //Name
#define IDH_NEWS_SERV_ORG                     540 //Organization
#define IDH_NEWS_SERV_EMAIL_ADD               545 //e-mail address
#define IDH_MAIL_SERV_ADV_REPLY_TO            550 //reply address
#define IDH_MAKE_DEF_EMAIL_ACCT               555 //make this my default acccount
#define IDH_INCLUDEACCT_IN_SENDREC            560 //Include this account  (mail)
#define IDH_INCLUDE_NEWS_ACCOUNT              557 //Include this account (news)

//Security tab
#define IDH_GENERAL_USE_CERTIFICATE           561 //Use certificate
#define IDH_GENERAL_SELECT_CERTIFICATE        562 //Select certificate 
#define IDH_INETCOM_MORE_ON_CERTIFICATES      563 //More on certificates
#define IDH_INETCOM_GET_DIGITAL_ID            564 //Get digital ID 
#define IDH_SECURITY_SIGNING_CERT             780 //Certificate
#define IDH_SECURITY_ENCRYPTING_CERT          784 //Encrypting preferences certificate
#define IDH_SECURITY_SELECT_ENCRYPTCERT       788 //Select encrypting certificate
#define IDH_SECURITY_ADV_ENCRYPTION           790 //Algorithm


//Servers Tab
#define IDH_MAIL_SERV_OUTGOING                565 //Mail: Outgoing Mail
#define IDH_MAIL_SERV_INCOMING                570 //Mail: Incoming Mail
#define IDH_INETCOMM_MY_INCOMING_SERVER_IS    575 //Mail: My Incoming Mail Server is a
#define IDH_NEWS_SERV_INCOMING                576 //News: Server Name
#define IDH_INETCOMM_SERVER_REQ_LOGON         577 //News: This server requires me to logon
#define IDH_MAIL_LOGON_USING                  580 //Mail/News: Logon using radio button
#define IDH_MAIL_SERV_POP3_ACCT               585 //Mail/News: Account Name
#define IDH_MAIL_SERV_PWORD                   590 //Mail/News: Password
#define IDH_MAIL_LOGON_USING_SICILY           595 //Mail/News: Logon using Secure Password
#define IDH_MAIL_OUT_AUTH			596 //Mail/News: My server requires authentication
#define IDH_MAIL_OUT_SETTINGS			597 //Mail/News: Settings
#define IDH_MAIL_OUT_SERV_SAME			598 //Mail/News/Settings/Use same settings as my Incoming mail server
#define IDH_MAIL_REMEMBER_PWORD			503 //Mail/News: REmember password

//Connection Tab
#define IDH_NEWS_SERV_CNKT_LAN                600 //I use a LAN
#define IDH_NEWS_SERV_CNKT_MAN                605 //I connect manually
#define IDH_NEWS_SERV_CNKT_DIALUP             610 //I use a modem
#define IDH_NEWS_SERV_CNKT_DIALUP_CONNECT     615 //Use the following DUN listbox
#define IDH_NEWS_SERV_CNKT_PROPS              620 //Properties button
#define IDH_NEWS_SERV_CNKT_ADD                625 //Add button
#define IDH_MAIL_DISCONNECT_AFTER_SENDNREC    630 //Mail: Disconnect when finished
#define IDH_INETCOMM_AUTO_CONNECT             680 //News: Automatically connect to this server
#define IDH_CONNECTION_VIA_MODEM              683 //Connect via modem if the LAN is not available
#define IDH_INETCOMM_CONNECT_USING		601 //Always connect to the account using

//Advanced Tab
#define IDH_MAIL_SERV_ADV_OUT_PORT            635 //Mail:Outgoing Mail
#define IDH_MAIL_SERV_ADV_INC_PORT            640 //Mail:Incoming Mail
#define IDH_NEWS_PORT_NUMBER                  747 //News port number
#define IDH_NEWS_SERV_ADV_USE_DEFAULTS        645 //Mail/News: Use Defaults button
#define IDH_MAIL_ADV_REQ_SSL                  650 //Mail/News:This server requires
#define IDH_MAIL_SERV_ADV_TIMEOUT             655 //Mail: Server Timeouts
#define IDH_NEWS_SERV_ADV_TIMEOUT             685 //News: Server Timeouts
#define IDH_MAIL_SERV_ADV_LEAVE_SERVER_COPY   660 //Mail: Leave a copy of messages on server
#define IDH_MAIL_SERV_ADV_REMOVE_AFTER5       665 //Mail: Remove from server after xx days
#define IDH_MAIL_SERV_ADV_REMOVE_WHEN_DELETED 670 //Mail: Remove from server when deleted
#define IDH_NEWSMAIL_SEND_ADVSET_BREAK_UP     675 //Mail: Break apart messages larger than
#define IDH_NEWS_SERV_ADV_DESC                690 //News: Use Newsgroup descriptions
#define IDH_INETCOMM_SHOW_SUBSCRIBED          759
#define IDH_NEWS_IGNORE_SEND_FORMAT                  691 //Ignore news sending format and post using
#define IDH_NEWS_USE_FORMAT                   692 //HTML or Plain Text

//IMAP tab
#define IDH_IMAP_BASE_ROOT                    757 //root folder path
#define IDH_IMAP_STORE_SPECIAL_FOLDERS        760 //store special folders on imap server
#define IDH_IMAP_SENT_ITEMS                   765 //sent items path
#define IDH_IMAP_DRAFTS	                      770 //drafts path
#define IDH_IMAP_NEW_MSGS                    775 //check for new msgs in all folders


//Directory Service Account Properties
//General Tab
#define IDH_WABLDAP_DIRSSERV_FRIENDLY_NAME    700 //Directory Service Account: Label and textbox
#define IDH_WABLDAP_DIRSSERV_NAME             705 //Server Name
#define IDH_WABLDAP_DIRSSERV_AUTH_PASS        715 //Logon using:
#define IDH_WABLDAP_DIRSSERV_AUTH_SICILY      720 //Logon using Secure Password
#define IDH_WABLDAP_DIRSSERV_AUTH_PASS_UNAME  725 //Account Name
#define IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS   730 //Password
#define IDH_WABLDAP_DIRSSERV_CHECK_AGAINST    735 //Check names against this server

//Advanced Tab
#define IDH_LDAP_PORT_NUMBER                  737 //Directory Service (LDAP) label and text box
#define IDH_WABLDAP_SEARCH_TIMEOUT            740 //Search timeout label and slider
#define IDH_WABLDAP_SEARCH_LIMIT              745 //Max number of matches to return
#define IDH_LDAP_SEARCH_BASE                  750 //Search Base
#define IDH_WABLDAP_USE_SIMPLE_SEARCH         755 //Use simple search filter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\mirlib\rtlmir.cpp ===
/****************************** Module*Header *****************************\
* Module Name: rtlmir.c                                                    *
*                                                                          *
* This module contains all the Right-To-Left (RTL) Mirroring support       *
* routines which are used across the whole IShell project. It abstracts    *
* platform-support routines of RTL mirroring (NT5 and Memphis) and removes *
* linkage depedenency with the Mirroring APIs.                             *
*                                                                          *
* Functions prefixed with Mirror, deal with the new Mirroring APIs         *
*                                                                          *
*                                                                          *
* Created: 01-Feb-1998 8:41:18 pm                                          *
* Author: Samer Arafeh [samera]                                            *
*                                                                          *
* Copyright (c) 1998 Microsoft Corporation                                 *
\**************************************************************************/


#include "pch.hxx"
#if WINVER < 0X0500
#include "mirport.h"
#endif
#include "mirror.h"

const DWORD dwNoMirrorBitmap = NOMIRRORBITMAP;
const DWORD dwExStyleRTLMirrorWnd = WS_EX_LAYOUTRTL;
const DWORD dwPreserveBitmap = LAYOUT_BITMAPORIENTATIONPRESERVED;

/*
 * Remove linkage dependecy for the RTL mirroring APIs, by retreiving
 * their addresses at runtime.
 */
typedef DWORD (*PFNGETLAYOUT)(HDC);                   // gdi32!GetLayout
typedef DWORD (*PFNSETLAYOUT)(HDC, DWORD);            // gdi32!SetLayout
typedef BOOL  (*PFNSETPROCESSDEFLAYOUT)(DWORD);       // user32!SetProcessDefaultLayout
typedef BOOL  (*PFNGETPROCESSDEFLAYOUT)(DWORD*);      // user32!GetProcessDefaultLayout
typedef LANGID (*PFNGETUSERDEFAULTUILANGUAGE)(void);  // kernel32!GetUserDefaultUILanguage

#define OS_WINDOWS      0           // windows vs. NT
#define OS_NT           1           // windows vs. NT
#define OS_WIN95        2
#define OS_NT4          3
#define OS_NT5          4
#define OS_MEMPHIS      5

/*----------------------------------------------------------
Purpose: Returns TRUE/FALSE if the platform is the given OS_ value.

*/
STDAPI_(BOOL) MirLibIsOS(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOA s_osvi;
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;

        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        GetVersionExA(&s_osvi);
    }

    switch (dwOS)
    {
    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
        break;

    case OS_WIN95:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_MEMPHIS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion > 4 || 
                 s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 10));
        break;

    case OS_NT4:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_NT5:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;

    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}   

/***************************************************************************\
* Mirror_GetUserDefaultUILanguage
*
* Reads the User UI language on NT5
*
* History:
* 22-June-1998 samera    Created
\***************************************************************************/
LANGID Mirror_GetUserDefaultUILanguage( void )
{
    LANGID langId=0;
    static PFNGETUSERDEFAULTUILANGUAGE pfnGetUserDefaultUILanguage=NULL;

    if( NULL == pfnGetUserDefaultUILanguage )
    {
        HMODULE hmod = GetModuleHandleA("KERNEL32");

        if( hmod )
            pfnGetUserDefaultUILanguage = (PFNGETUSERDEFAULTUILANGUAGE)
                                          GetProcAddress(hmod, "GetUserDefaultUILanguage");
    }

    if( pfnGetUserDefaultUILanguage )
        langId = pfnGetUserDefaultUILanguage();

    return langId;
}

/***************************************************************************\
* Mirror_EnableWindowLayoutInheritance
*
* returns TRUE if the window is RTL mirrored
*
* History:
* 14-April-1998 a-msadek    Created
\***************************************************************************/
LONG Mirror_EnableWindowLayoutInheritance( HWND hWnd )
{
    return SetWindowLongA(hWnd, GWL_EXSTYLE, GetWindowLongA( hWnd , GWL_EXSTYLE ) & ~WS_EX_NOINHERITLAYOUT );
}


/***************************************************************************\
* Mirror_DisableWindowLayoutInheritance
*
* returns TRUE if the window is RTL mirrored
*
* History:
* 14-April-1998 a-msadek    Created
\***************************************************************************/
LONG Mirror_DisableWindowLayoutInheritance( HWND hWnd )
{
    return SetWindowLongA(hWnd, GWL_EXSTYLE, GetWindowLongA( hWnd , GWL_EXSTYLE ) | WS_EX_NOINHERITLAYOUT );
}

/***************************************************************************\
* ConvertHexStringToInt
*
* Converts a hex numeric string into an integer.
*
* History:
* 04-Feb-1998 samera    Created
\***************************************************************************/
BOOL ConvertHexStringToInt( CHAR *pszHexNum , int *piNum )
{
    int   n=0L;
    CHAR  *psz=pszHexNum;

  
    for(n=0 ; ; psz=CharNextA(psz))
    {
        if( (*psz>='0') && (*psz<='9') )
            n = 0x10 * n + *psz - '0';
        else
        {
            CHAR ch = *psz;
            int n2;

            if(ch >= 'a')
                ch -= 'a' - 'A';

            n2 = ch - 'A' + 0xA;
            if (n2 >= 0xA && n2 <= 0xF)
                n = 0x10 * n + n2;
            else
                break;
        }
    }

    /*
     * Update results
     */
    *piNum = n;

    return (psz != pszHexNum);
}


/***************************************************************************\
* IsBiDiLocalizedSystem
*
* returns TRUE if running on a lozalized BiDi (Arabic/Hebrew) NT5 or Memphis.
* Should be called whenever SetProcessDefaultLayout is to be called.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL IsBiDiLocalizedSystem( void )
{
    HKEY        hKey;
    DWORD       dwType;
    CHAR        szResourceLocale[12];
    DWORD       dwSize = sizeof(szResourceLocale)/sizeof(CHAR);
    LANGID      langID;
    int         iLCID=0L;
    static BOOL bRet = (BOOL)(DWORD)-1;

    if (bRet != (BOOL)(DWORD)-1)
    {
        return bRet;
    }

    bRet = FALSE;
    if( MirLibIsOS( OS_NT5 ) )
    {
        /*
         * Need to use NT5 detection method (Multiligual UI ID)
         */
        langID = Mirror_GetUserDefaultUILanguage();

        if( langID )
        {
            WCHAR wchLCIDFontSignature[16];
            iLCID = MAKELCID( langID , SORT_DEFAULT );

            /*
             * Let's verify this is a RTL (BiDi) locale. Since reg value is a hex string, let's
             * convert to decimal value and call GetLocaleInfo afterwards.
             * LOCALE_FONTSIGNATURE always gives back 16 WCHARs.
             */

            if( GetLocaleInfoW( iLCID , 
                                LOCALE_FONTSIGNATURE , 
                                (WCHAR *) &wchLCIDFontSignature[0] ,
                                (sizeof(wchLCIDFontSignature)/sizeof(WCHAR))) )
            {
      
                /* Let's verify the bits we have a BiDi UI locale */
                if( wchLCIDFontSignature[7] & (WCHAR)0x0800 )
                {
                    bRet = TRUE;
                }
            }
        }
    } else {

        /*
         * Check if BiDi-Memphis is running with Lozalized Resources (
         * i.e. Arabic/Hebrew systems) -It should be enabled ofcourse-.
         */
        if( (MirLibIsOS(OS_MEMPHIS)) && (GetSystemMetrics(SM_MIDEASTENABLED)) )
        {

            if( RegOpenKeyExA( HKEY_CURRENT_USER , 
                               "Control Panel\\Desktop\\ResourceLocale" , 
                               0, 
                               KEY_READ, &hKey) == ERROR_SUCCESS) 
            {
                RegQueryValueExA( hKey , "" , 0 , &dwType , (LPBYTE)szResourceLocale , &dwSize );
                szResourceLocale[(sizeof(szResourceLocale)/sizeof(CHAR))-1] = 0;

                RegCloseKey(hKey);

                if( ConvertHexStringToInt( szResourceLocale , &iLCID ) )
                {
                    iLCID = PRIMARYLANGID(LANGIDFROMLCID(iLCID));
                    if( (LANG_ARABIC == iLCID) || (LANG_HEBREW == iLCID) )
                    {
                        bRet = TRUE;
                    }
                }
            }
        }
    }

    return bRet;
}



/***************************************************************************\
* Mirror_IsEnabledOS
*
* returns TRUE if the mirroring APIs are enabled on the current OS.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_IsEnabledOS( void )
{
    BOOL bRet = FALSE;

    if( MirLibIsOS(OS_NT5) )
    {
        bRet = TRUE;
    } else if( MirLibIsOS(OS_MEMPHIS) && GetSystemMetrics(SM_MIDEASTENABLED)) {
        bRet=TRUE;
    }

    return bRet;
}


/***************************************************************************\
* Mirror_IsWindowMirroredRTL
*
* returns TRUE if the window is RTL mirrored
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_IsWindowMirroredRTL( HWND hWnd )
{
    return (GetWindowLongA( hWnd , GWL_EXSTYLE ) & WS_EX_LAYOUTRTL );
}




/***************************************************************************\
* Mirror_GetLayout
*
* returns TRUE if the hdc is RTL mirrored
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
DWORD Mirror_GetLayout( HDC hdc )
{
    DWORD dwRet=0;
    static PFNGETLAYOUT pfnGetLayout=NULL;

    if( NULL == pfnGetLayout )
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnGetLayout = (PFNGETLAYOUT)GetProcAddress(hmod, "GetLayout");
    }

    if( pfnGetLayout )
        dwRet = pfnGetLayout( hdc );

    return dwRet;
}

DWORD Mirror_IsDCMirroredRTL( HDC hdc )
{
    return (Mirror_GetLayout( hdc ) & LAYOUT_RTL);
}



/***************************************************************************\
* Mirror_SetLayout
*
* RTL Mirror the hdc
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout )
{
    DWORD dwRet=0;
    static PFNSETLAYOUT pfnSetLayout=NULL;

    if( NULL == pfnSetLayout )
    {
        HMODULE hmod = GetModuleHandleA("GDI32");

        if( hmod )
            pfnSetLayout = (PFNSETLAYOUT)GetProcAddress(hmod, "SetLayout");
    }

    if( pfnSetLayout )
        dwRet = pfnSetLayout( hdc , dwLayout );

    return dwRet;
}

DWORD Mirror_MirrorDC( HDC hdc )
{
    return Mirror_SetLayout( hdc , LAYOUT_RTL );
}


/***************************************************************************\
* Mirror_SetProcessDefaultLayout
*
* Set the process-default layout.
*
* History:
* 02-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_SetProcessDefaultLayout( DWORD dwDefaultLayout )
{
    BOOL bRet=0;
    static PFNSETPROCESSDEFLAYOUT pfnSetProcessDefLayout=NULL;

    if( NULL == pfnSetProcessDefLayout )
    {
        HMODULE hmod = GetModuleHandleA("USER32");

        if( hmod )
            pfnSetProcessDefLayout = (PFNSETPROCESSDEFLAYOUT)
                                     GetProcAddress(hmod, "SetProcessDefaultLayout");
    }

    if( pfnSetProcessDefLayout )
        bRet = pfnSetProcessDefLayout( dwDefaultLayout );

    return bRet;
}

BOOL Mirror_MirrorProcessRTL( void )
{
    return Mirror_SetProcessDefaultLayout( LAYOUT_RTL );
}


/***************************************************************************\
* Mirror_GetProcessDefaultLayout
*
* Get the process-default layout.
*
* History:
* 26-Feb-1998 samera    Created
\***************************************************************************/
BOOL Mirror_GetProcessDefaultLayout( DWORD *pdwDefaultLayout )
{
    BOOL bRet=0;
    static PFNGETPROCESSDEFLAYOUT pfnGetProcessDefLayout=NULL;

    if( NULL == pfnGetProcessDefLayout )
    {
        HMODULE hmod = GetModuleHandleA("USER32");

        if( hmod )
            pfnGetProcessDefLayout = (PFNGETPROCESSDEFLAYOUT)
                                     GetProcAddress(hmod, "GetProcessDefaultLayout");
    }

    if( pfnGetProcessDefLayout )
        bRet = pfnGetProcessDefLayout( pdwDefaultLayout );

    return bRet;
}

BOOL Mirror_IsProcessRTL( void )
{
    DWORD dwDefLayout=0;
    static BOOL bRet = (BOOL)(DWORD)-1;

    if (bRet != (BOOL)(DWORD)-1)
    {
        return bRet;
    }

    bRet = FALSE;

    bRet = (Mirror_GetProcessDefaultLayout(&dwDefLayout) && (dwDefLayout&LAYOUT_RTL));

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\agntnews.h ===
#ifndef _INC_AGNTNEWSACT
#define _INC_AGNTNEWSACT

typedef struct tagAGNTNEWSACCTINFO
    {
    DWORD_PTR dwCookie;
    char szUserPath[MAX_PATH];
    char szDisplay[CCHMAX_ACCOUNT_NAME];
    } AGNTNEWSACCTINFO;

#define AGNTSUSERCOLS    512
#define AGNTSUSERROWS    4

// {911685D0-350F-11d1-83B3-00C04FBD7C09}
DEFINE_GUID(CLSID_CEnumAGNTACCT, 0x911685d0, 0x350f, 0x11d1, 0x83, 0xb3, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);


class CEnumAGNTACCT : public IEnumIMPACCOUNTS
    {
    private:
        ULONG           m_cRef;
        int             m_iInfo;
        UINT            m_cInfo;
        AGNTNEWSACCTINFO    *m_rgInfo;

    public:
        CEnumAGNTACCT(void);
        ~CEnumAGNTACCT(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE Next(IMPACCOUNTINFO *pinfo);
        HRESULT STDMETHODCALLTYPE Reset(void);

        HRESULT Init(AGNTNEWSACCTINFO *pinfo, int cinfo);
    };

// {911685D1-350F-11d1-83B3-00C04FBD7C09}
DEFINE_GUID(CLSID_CAgentAcctImport, 0x911685d1, 0x350f, 0x11d1, 0x83, 0xb3, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

class CAgentAcctImport : public IAccountImport, public IAccountImport2
    {
    private:
        ULONG           m_cRef;
        BOOL            m_fIni;
        TCHAR           m_szIni[MAX_PATH];
        UINT            m_cInfo;
        AGNTNEWSACCTINFO    *m_rgInfo;

        HRESULT GetUserPrefs(char *szUserPath, char szUserPrefs[][AGNTSUSERCOLS]);
        HRESULT GetSubListGroups(char *szHomeDir, char **ppListGroups);
        HRESULT IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);

    public:
        CAgentAcctImport(void);
        ~CAgentAcctImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE AutoDetect(DWORD *pcAcct, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum);
        HRESULT STDMETHODCALLTYPE GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct);

        // Methods from the IAccountImport2 interface.
        HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd, DWORD_PTR dwCookie);
        HRESULT STDMETHODCALLTYPE GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);
    };

#endif // _INC_AGNTNEWSACT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\acctman.cpp ===
// -----------------------------------------------------------------------------
// A C C T M A N . C P P - Steven J. Bailey - 8/17/96
// -----------------------------------------------------------------------------
#include "pch.hxx"
#include <prsht.h>
#include <ras.h>
#include "acctman.h"
#include "acctui.h"
#include "server.h"
#include <acctimp.h>
#include <icwacct.h>
#include "icwwiz.h"
#include "dllmain.h"
#include "resource.h"
#include <strconst.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <demand.h>     // must be last!

#ifdef  _UNICODE
#define _T(x)       L ## x
#else
#define _T(x)       x
#endif

// -----------------------------------------------------------------------------
// Registry Keys
// -----------------------------------------------------------------------------
const static TCHAR c_szAccountsKey[] = _T("Accounts");

const static TCHAR c_szDefaultNewsAccount[] = _T("Default News Account");
const static TCHAR c_szDefaultMailAccount[] = _T("Default Mail Account");
const static TCHAR c_szDefaultLDAPAccount[] = _T("Default LDAP Account");
const static TCHAR c_szRegServerID[] = _T("Server ID");
const static TCHAR c_szRegAccountName[] = _T("Account Name");

// -----------------------------------------------------------------------------
// Accout Property Set
// -----------------------------------------------------------------------------
#define ACCTMAN_PROPERTY_VERSION    1

const PROPINFO g_rgAcctPropSet[] = {
    { AP_ACCOUNT_NAME, _T("Account Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_ACCOUNT_NAME}},
    { AP_TEMP_ACCOUNT, _T("Temporary Account"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_LAST_UPDATED, _T("Last Updated"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_RAS_CONNECTION_TYPE, _T("Connection Type"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_RAS_CONNECTOID, _T("Connectoid"), PF_MINMAX, {0, 0}, {0, CCHMAX_CONNECTOID}},
    { AP_RAS_CONNECTION_FLAGS, _T("Connection Flags"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_ACCOUNT_ID, _T("Account ID"), PF_NOPERSIST|PF_MINMAX, {0, 0}, {0, CCHMAX_ACCOUNT_NAME}},
    { AP_RAS_BACKUP_CONNECTOID, _T("Backup Connectoid"), PF_MINMAX, {0, 0}, {0, CCHMAX_CONNECTOID}},
    { AP_SERVICE, _T("Service"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVICE}},
    { AP_AVAIL_OFFLINE, _T("Make Available Offline"), PF_DEFAULT, {1, 0}, {0, 0}},
    { AP_UNIQUE_ID, _T("Unique ID"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_SERVER_READ_ONLY, _T("Server Read Only"), NOFLAGS, {0, 0}, {0, 0}},

    { AP_IMAP_SERVER, _T("IMAP Server"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}},
    { AP_IMAP_USERNAME, _T("IMAP User Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_USERNAME}}, // new
    { AP_IMAP_PASSWORD, _T("IMAP Password2"), PF_ENCRYPTED|PF_MINMAX, {0, 0}, {0, CCHMAX_PASSWORD}}, // new
    { AP_IMAP_USE_SICILY, _T("IMAP Use Sicily"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_IMAP_PORT, _T("IMAP Port"), PF_MINMAX|PF_DEFAULT, {DEF_IMAPPORT, 0}, {1, 0xffffffff}},
    { AP_IMAP_SSL, _T("IMAP Secure Connection"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_IMAP_TIMEOUT, _T("IMAP Timeout"), PF_DEFAULT, {60, 0}, {0, 0}}, // new
    { AP_IMAP_ROOT_FOLDER, _T("IMAP Root Folder"), PF_MINMAX, {0, 0}, {0, MAX_PATH}},
    { AP_IMAP_DATA_DIR, _T("IMAP Data Directory"), PF_MINMAX, {0, 0}, {0, MAX_PATH}},
    { AP_IMAP_USE_LSUB, _T("IMAP Use LSUB"), PF_DEFAULT, {TRUE, 0}, {0, 0}},
    { AP_IMAP_POLL, _T("IMAP Polling"), PF_DEFAULT, {TRUE, 0}, {0, 0}},
    { AP_IMAP_FULL_LIST, _T("IMAP Full List"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_IMAP_NOOP_INTERVAL, _T("IMAP NOOP Interval"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_IMAP_SVRSPECIALFLDRS, _T("IMAP Svr-side Special Folders"), PF_DEFAULT, {TRUE, 0}, {0, 0}},
    { AP_IMAP_SENTITEMSFLDR, _T("IMAP Sent Items Folder"), PF_MINMAX|PF_DEFAULT, {idsIMAPSentItemsFldr, 0}, {0, MAX_PATH}},
    { AP_IMAP_DRAFTSFLDR, _T("IMAP Drafts Folder"), PF_MINMAX|PF_DEFAULT, {idsIMAPDraftsFldr, 0}, {0, MAX_PATH}},
    { AP_IMAP_PROMPT_PASSWORD, _T("IMAP Prompt for Password"), PF_DEFAULT, {FALSE, 0}, {0, 0}},
    { AP_IMAP_DIRTY, _T("IMAP Dirty"), PF_DEFAULT, {0, 0}, {0, 0}},
    { AP_IMAP_POLL_ALL_FOLDERS, _T("IMAP Poll All Folders"), PF_DEFAULT, {TRUE, 0}, {0, 0}},

    { AP_LDAP_SERVER, _T("LDAP Server"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}}, // new
    { AP_LDAP_USERNAME, _T("LDAP User Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_USERNAME}}, // new
    { AP_LDAP_PASSWORD, _T("LDAP Password2"), PF_ENCRYPTED|PF_MINMAX, {0, 0}, {0, CCHMAX_PASSWORD}}, // new
    { AP_LDAP_AUTHENTICATION, _T("LDAP Authentication"), PF_MINMAX|PF_DEFAULT, {LDAP_AUTH_ANONYMOUS, 0}, {0, LDAP_AUTH_MAX}}, // new
    { AP_LDAP_TIMEOUT, _T("LDAP Timeout"), PF_DEFAULT, {60, 0}, {0, 0}}, // new
    { AP_LDAP_SEARCH_RETURN, _T("LDAP Search Return"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_LDAP_SEARCH_BASE, _T("LDAP Search Base"), PF_MINMAX, {0, 0}, {0, CCHMAX_SEARCH_BASE}}, // new
    { AP_LDAP_SERVER_ID, _T("LDAP Server ID"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_LDAP_RESOLVE_FLAG, _T("LDAP Resolve Flag"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_LDAP_URL, _T("LDAP URL"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}}, // new
    { AP_LDAP_PORT, _T("LDAP Port"), PF_MINMAX|PF_DEFAULT, {DEF_LDAPPORT, 0}, {1, 0xffffffff}}, // new
    { AP_LDAP_SSL, _T("LDAP Secure Connection"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_LDAP_LOGO, _T("LDAP Logo"), PF_MINMAX, {0, 0}, {0, MAX_PATH}}, // new
    { AP_LDAP_USE_BIND_DN, _T("LDAP Bind DN"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_LDAP_SIMPLE_SEARCH, _T("LDAP Simple Search"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_LDAP_ADVANCED_SEARCH_ATTR, _T("LDAP Advanced Search Attributes"), PF_MINMAX, {0, 0}, {0, MAX_PATH}}, // new
    { AP_LDAP_PAGED_RESULTS, _T("LDAP Paged Result Support"), PF_MINMAX|PF_DEFAULT, {LDAP_PRESULT_UNKNOWN, 0}, {0, LDAP_PRESULT_MAX}}, // new
    { AP_LDAP_NTDS, _T("LDAP NTDS"), PF_MINMAX|PF_DEFAULT, {LDAP_NTDS_UNKNOWN, 0}, {0, LDAP_NTDS_MAX}}, // new

    { AP_NNTP_SERVER, _T("NNTP Server"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}},
    { AP_NNTP_USERNAME, _T("NNTP User Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_USERNAME}}, // new
    { AP_NNTP_PASSWORD, _T("NNTP Password2"), PF_ENCRYPTED|PF_MINMAX, {0, 0}, {0, CCHMAX_PASSWORD}}, // new
    { AP_NNTP_USE_SICILY, _T("NNTP Use Sicily"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_NNTP_PORT, _T("NNTP Port"), PF_MINMAX|PF_DEFAULT, {DEF_NNTPPORT, 0}, {1, 0xffffffff}},
    { AP_NNTP_SSL, _T("NNTP Secure Connection"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_NNTP_TIMEOUT, _T("NNTP Timeout"), PF_DEFAULT, {60, 0}, {0, 0}}, // new
    { AP_NNTP_DISPLAY_NAME, _T("NNTP Display Name"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_NNTP_ORG_NAME, _T("NNTP Organization Name"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_NNTP_EMAIL_ADDRESS, _T("NNTP Email Address"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_NNTP_REPLY_EMAIL_ADDRESS, _T("NNTP Reply To Email Address"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_NNTP_SPLIT_MESSAGES, _T("NNTP Split Messages"), PF_DEFAULT, {FALSE, 0}, {0, 0}}, // new
    { AP_NNTP_SPLIT_SIZE, _T("NNTP Split Message Size"), PF_DEFAULT, {64, 0}, {0, 0}}, // new
    { AP_NNTP_USE_DESCRIPTIONS, _T("Use Group Descriptions"), PF_DEFAULT, {FALSE, 0}, {0, 0}},
    { AP_NNTP_DATA_DIR, _T("NNTP Data Directory"), PF_MINMAX, {0, 0}, {0, MAX_PATH}},
    { AP_NNTP_POLL, _T("NNTP Polling"), PF_DEFAULT, {FALSE, 0}, {0, 0}},
    { AP_NNTP_POST_FORMAT, _T("NNTP Posting"), PF_DEFAULT, {POST_USE_DEFAULT, 0}, {0, 0}}, // new
    { AP_NNTP_SIGNATURE, _T("NNTP Signature"), PF_MINMAX, {0, 0}, {0, CCHMAX_SIGNATURE}}, // new
    { AP_NNTP_PROMPT_PASSWORD, _T("NNTP Prompt for Password"), PF_DEFAULT, {FALSE, 0}, {0, 0}},

    { AP_POP3_SERVER, _T("POP3 Server"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}},
    { AP_POP3_USERNAME, _T("POP3 User Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_USERNAME}}, // new
    { AP_POP3_PASSWORD, _T("POP3 Password2"), PF_ENCRYPTED|PF_MINMAX, {0, 0}, {0, CCHMAX_PASSWORD}}, // new
    { AP_POP3_USE_SICILY, _T("POP3 Use Sicily"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_POP3_PORT, _T("POP3 Port"), PF_MINMAX|PF_DEFAULT, {DEF_POP3PORT, 0}, {1, 0xffffffff}},
    { AP_POP3_SSL, _T("POP3 Secure Connection"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_POP3_TIMEOUT, _T("POP3 Timeout"), PF_DEFAULT, {60, 0}, {0, 0}}, // new
    { AP_POP3_LEAVE_ON_SERVER, _T("Leave Mail On Server"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_POP3_REMOVE_DELETED, _T("Remove When Deleted"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_POP3_REMOVE_EXPIRED, _T("Remove When Expired"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_POP3_EXPIRE_DAYS, _T("Expire Days"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_POP3_SKIP, _T("POP3 Skip Account"), PF_DEFAULT, {FALSE, 0}, {0, 0}},
    { AP_POP3_OUTLOOK_CACHE_NAME, _T("Outlook Cache Name"), PF_MINMAX, {0, 0}, {0, MAX_PATH}}, // new
    { AP_POP3_PROMPT_PASSWORD, _T("POP3 Prompt for Password"), PF_DEFAULT, {FALSE, 0}, {0, 0}},
    
    { AP_SMTP_SERVER, _T("SMTP Server"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}},
    { AP_SMTP_USERNAME, _T("SMTP User Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_USERNAME}}, // new
    { AP_SMTP_PASSWORD, _T("SMTP Password2"), PF_ENCRYPTED|PF_MINMAX, {0, 0}, {0, CCHMAX_PASSWORD}}, // new
    { AP_SMTP_USE_SICILY, _T("SMTP Use Sicily"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_SMTP_PORT, _T("SMTP Port"), PF_MINMAX|PF_DEFAULT, {DEF_SMTPPORT, 0}, {1, 0xffffffff}},
    { AP_SMTP_SSL, _T("SMTP Secure Connection"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_SMTP_TIMEOUT, _T("SMTP Timeout"), PF_DEFAULT, {60, 0}, {0, 0}}, // new
    { AP_SMTP_DISPLAY_NAME, _T("SMTP Display Name"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_SMTP_ORG_NAME, _T("SMTP Organization Name"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_SMTP_EMAIL_ADDRESS, _T("SMTP Email Address"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_SMTP_REPLY_EMAIL_ADDRESS, _T("SMTP Reply To Email Address"), NOFLAGS, {FALSE, 0}, {0, 0}}, // new
    { AP_SMTP_SPLIT_MESSAGES, _T("SMTP Split Messages"), PF_DEFAULT, {FALSE, 0}, {0, 0}}, // new
    { AP_SMTP_SPLIT_SIZE, _T("SMTP Split Message Size"), PF_DEFAULT, {64, 0}, {0, 0}}, // new
    { AP_SMTP_CERTIFICATE, _T("SMTP Certificate"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_SMTP_SIGNATURE, _T("SMTP Signature"), PF_MINMAX, {0, 0}, {0, CCHMAX_SIGNATURE}}, // new
    { AP_SMTP_PROMPT_PASSWORD, _T("SMTP Prompt for Password"), PF_DEFAULT, {FALSE, 0}, {0, 0}},
    { AP_SMTP_ENCRYPT_CERT, _T("SMTP Encryption Certificate"), NOFLAGS, {0, 0}, {0, 0}}, // new
    { AP_SMTP_ENCRYPT_ALGTH, _T("SMTP Encryption Algorithm"), NOFLAGS, {0, 0}, {0, 0}}, // new

    { AP_HTTPMAIL_SERVER, _T("HTTPMail Server"), PF_MINMAX, {0, 0}, {0, CCHMAX_SERVER_NAME}},
    { AP_HTTPMAIL_USERNAME, _T("HTTPMail User Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_USERNAME}},
    { AP_HTTPMAIL_PASSWORD, _T("HTTPMail Password2"), PF_ENCRYPTED|PF_MINMAX, {0, 0}, {0, CCHMAX_PASSWORD}},
    { AP_HTTPMAIL_PROMPT_PASSWORD, _T("HTTPMail Prompt for Password"), PF_DEFAULT, {FALSE, 0}, {0, 0}},  
    { AP_HTTPMAIL_USE_SICILY, _T("HTTPMail Use Sicily"), NOFLAGS, {0, 0}, {0, 0}}, 
    { AP_HTTPMAIL_FRIENDLY_NAME, _T("HTTPMail Friendly Name"), PF_MINMAX, {0, 0}, {0, CCHMAX_ACCOUNT_NAME}},
    { AP_HTTPMAIL_DOMAIN_MSN, _T("Domain is MSN.com"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_HTTPMAIL_POLL, _T("HTTPMail Polling"), PF_DEFAULT, {TRUE, 0}, {0, 0}},
    { AP_HTTPMAIL_ADURL, _T("AdBar Url"), NOFLAGS, {0, 0}, {0, INTERNET_MAX_URL_LENGTH}},
    { AP_HTTPMAIL_SHOW_ADBAR, _T("ShowAdBar"), PF_DEFAULT, {TRUE, 0}, {0, 1}},
    { AP_HTTPMAIL_MINPOLLINGINTERVAL, _T("MinPollingInterval"), PF_NOPERSIST | PF_DEFAULT, {0, sizeof(ULARGE_INTEGER)}, {0, 0}},
    { AP_HTTPMAIL_GOTPOLLINGINTERVAL, _T("GotPollingInterval"), PF_NOPERSIST | PF_DEFAULT, {FALSE, 0}, {0, 1}},
    { AP_HTTPMAIL_LASTPOLLEDTIME, _T("LastPolledTime"), PF_NOPERSIST | PF_DEFAULT, {0, sizeof(ULARGE_INTEGER)}, {0, 0}},
    { AP_HTTPMAIL_ROOTTIMESTAMP, _T("RootTimeStamp"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_HTTPMAIL_ROOTINBOXTIMESTAMP, _T("RootInboxTimeStamp"), NOFLAGS, {0, 0}, {0, 0}},
    { AP_HTTPMAIL_INBOXTIMESTAMP, _T("InboxTimeStamp"), NOFLAGS, {0, 0}, {0, 0}},
};

// Number of properties
const int NUM_ACCT_PROPS = ARRAYSIZE(g_rgAcctPropSet);

// Use in RegisterWindowMessage
#define ACCTMAN_NOTIF_WMSZ _T("## Athena_Account_Manager_Notification_Message ##")
UINT g_uMsgAcctManNotify = 0;

// -----------------------------------------------------------------------------
// Prototypes
// -----------------------------------------------------------------------------
VOID    AcctUtil_PostNotification(DWORD dwAN, ACTX *pactx);
static  VOID DecodeUserPassword(TCHAR *lpszPwd, ULONG *cb);
static  VOID EncodeUserPassword(TCHAR *lpszPwd, ULONG *cb);

// -----------------------------------------------------------------------------
// Export account manager creation function
// -----------------------------------------------------------------------------
IMNACCTAPI HrCreateAccountManager(IImnAccountManager **ppAccountManager)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&g_csAcctMan);

    // Init
    *ppAccountManager = NULL;

    // If there is already a global account manager, lets use it
    if (NULL == g_pAcctMan)
    {
        // Create a new one
        g_pAcctMan = new CAccountManager();
        if (NULL == g_pAcctMan)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }

        // Set Return
        *ppAccountManager = g_pAcctMan;
    }

    // Otherwise, addref the global
    else
    {
        // Return Global
        *ppAccountManager = g_pAcctMan;
        (*ppAccountManager)->AddRef();
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&g_csAcctMan);

    // Done
    return hr;
}


// -----------------------------------------------------------------------------
// CAccountManager::CAccountManager
// -----------------------------------------------------------------------------
CAccountManager::CAccountManager(void)
{
    DllAddRef();
    m_cRef = 1;
    m_pAcctPropSet = NULL;
    m_ppAdviseAccounts = NULL;
    m_cAdvisesAllocated = 0;
    m_pAccounts = NULL;
    m_cAccounts = 0;
    m_uMsgNotify = 0;
    m_fInit = FALSE;
    m_fOutlook = FALSE;
    m_fInitCalled = FALSE;
    m_fNoModifyAccts = FALSE;
    m_hkey = HKEY_CURRENT_USER;
    ZeroMemory(&m_rgAccountInfo, sizeof(m_rgAccountInfo));
    InitializeCriticalSection(&m_cs);
}

// -----------------------------------------------------------------------------
// CAccountManager::~CAccountManager
// -----------------------------------------------------------------------------
CAccountManager::~CAccountManager()
{
    EnterCriticalSection(&g_csAcctMan);
    if (this == g_pAcctMan)
        g_pAcctMan = NULL;
    LeaveCriticalSection(&g_csAcctMan);
    Assert(m_cRef == 0);
    EnterCriticalSection(&m_cs);

    // release all advises
    for(INT i=0; i<m_cAdvisesAllocated; i++)
        {
        SafeRelease(m_ppAdviseAccounts[i]);
        }
    SafeMemFree(m_ppAdviseAccounts);

    SafeRelease(m_pAcctPropSet);
    AcctUtil_FreeAccounts(&m_pAccounts, &m_cAccounts);
    if (m_hkey != HKEY_CURRENT_USER)
        RegCloseKey(m_hkey);
    
    LeaveCriticalSection(&m_cs);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// -----------------------------------------------------------------------------
// CAccountManager::QueryInterface
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IImnAccountManager
    if (IID_IImnAccountManager == riid)
        *ppv = (IImnAccountManager *)this;

    // IID_IImnAccountManager
    else if (IID_IImnAccountManager2 == riid)
        *ppv = (IImnAccountManager2 *)this;

    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // If not null, addref it and return
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TRAPHR(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccountManager::AddRef
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAccountManager::AddRef(VOID)
{
    return ++m_cRef;
}

// -----------------------------------------------------------------------------
// CAccountManager::Release
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAccountManager::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

/*
    In addition to removing LDAP servers from the destination which have the same server as an account
    from the source, this code also assigns LDAP Server IDs to source accounts so that v4 will see
    them on uninstall.
*/
void ProcessLDAPs(HKEY hkeySrc, HKEY hkeyDestRoot, HKEY hkeyDestAccts)
{
    HKEY hkeySrcSub, hkeyDestSub;
    TCHAR szKeyName[MAX_PATH], szKeyName2[MAX_PATH];
    DWORD dwIndex = 0, dwIndex2;
    TCHAR szServer[CCHMAX_SERVER_NAME], szServer2[CCHMAX_SERVER_NAME];
    DWORD cb, dwServerID=0;
    BOOL fDelete;

    // Parameter Validation    
    Assert(hkeySrc);
    Assert(hkeyDestRoot);
    Assert(hkeyDestAccts);
    Assert(hkeyDestRoot != hkeyDestAccts);
    
    // Calculate the next available LDAP Server ID
    cb = sizeof(dwServerID);
    RegQueryValueEx(hkeyDestRoot, c_szServerID, 0, NULL, (LPBYTE)&dwServerID, &cb);

    // Enumerate all source accounts
    while (TRUE) 
    {
        if (ERROR_SUCCESS != RegEnumKey(hkeySrc, dwIndex++, szKeyName, ARRAYSIZE(szKeyName)))
            break;

        // Open the account
        if (ERROR_SUCCESS == RegOpenKeyEx(hkeySrc, szKeyName, 0, KEY_READ, &hkeySrcSub)) 
        {
            // Get the server name
            cb = sizeof(szServer);
            if (ERROR_SUCCESS == RegQueryValueEx(hkeySrcSub, c_szRegLDAPSrv, 0, NULL, (LPBYTE)szServer, &cb))
            {
                dwIndex2 = 0;
                
                // Scan the destination for conflicts
                while (TRUE)
                {
                    if (ERROR_SUCCESS != RegEnumKey(hkeyDestAccts, dwIndex2++, szKeyName2, ARRAYSIZE(szKeyName2)))
                        break;

                    // Open an account
                    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyDestAccts, szKeyName2, 0, KEY_READ, &hkeyDestSub))
                    {
                        // Does it conflict?
                        fDelete = FALSE;

                        cb = sizeof(szServer2);
                        if (ERROR_SUCCESS == RegQueryValueEx(hkeyDestSub, c_szRegLDAPSrv, 0, NULL, (LPBYTE)szServer2, &cb))
                        {
                            fDelete = !lstrcmpi(szServer, szServer2);
                        }

                        RegCloseKey(hkeyDestSub);
                        
                        if (fDelete)
                            SHDeleteKey(hkeyDestAccts, szKeyName2);
                    }
                }

                // Invent a server id for this account
                if (ERROR_SUCCESS == RegCreateKeyEx(hkeyDestAccts, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                                    &hkeyDestSub, &cb))
                {
                    RegSetValueEx(hkeyDestSub, c_szLDAPSrvID, 0, REG_DWORD, (LPBYTE)&dwServerID, sizeof(dwServerID));
                    dwServerID++;
                    RegCloseKey(hkeyDestSub);
                }
            }
            RegCloseKey(hkeySrcSub);
        }
    }

    // Update the Server ID count
    RegSetValueEx(hkeyDestRoot, c_szServerID, 0, REG_DWORD, (LPBYTE)&dwServerID, sizeof(dwServerID));
}


void InitializeUser(HKEY hkey, LPCSTR pszUser)
{
    HKEY hkeySrc, hkeyDestRoot, hkeyDestAccts;
    DWORD dwDisp, dwVerMaster=1, dwVerIdentity = 0, cb;
    DWORD dwType, dwVerNTDSMaster=0, dwVerNTDSIdentity=0;
    
    // Open / Create IAM
    if (ERROR_SUCCESS == RegCreateKeyEx(hkey, c_szInetAcctMgrRegKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL,
                                        &hkeyDestRoot, &dwDisp))
    {
        // Open / Create accounts key
        if (ERROR_SUCCESS == RegCreateKeyEx(hkeyDestRoot, c_szAccounts, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL,
                                            &hkeyDestAccts, &dwDisp))
        {
            // Open Source key            
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegPreConfigAccts, 0, KEY_READ, &hkeySrc))
            {
                // Read the current user's version
                cb = sizeof(dwVerIdentity);
                RegQueryValueEx(hkeyDestAccts, c_szVerStamp, 0, &dwType, (LPBYTE)&dwVerIdentity, &cb);

                // Could accidentally be a string, if so, treat as 0
                if (REG_DWORD != dwType)
                    dwVerIdentity = 0;
            
                // Grab the master version (defaults to 1)
                cb = sizeof(dwVerMaster);
                RegQueryValueEx(hkeySrc, c_szVerStamp, 0, &dwType, (LPBYTE)&dwVerMaster, &cb);

                // Could accidentally be a string, if so, treat as 1
                if (REG_DWORD != dwType)
                    dwVerMaster = 1;

                // Grab the master NTDS version (defaults to 0)
                cb = sizeof(dwVerNTDSMaster);
                if ((ERROR_SUCCESS == RegQueryValueEx(hkeySrc, c_szVerStampNTDS, 0, &dwType, (LPBYTE)&dwVerNTDSMaster, &cb)) && dwVerNTDSMaster)
                {
                    // Read the current user's NTDS settings version
                    cb = sizeof(dwVerNTDSIdentity);
                    RegQueryValueEx(hkeyDestAccts, c_szVerStampNTDS, 0, &dwType, (LPBYTE)&dwVerNTDSIdentity, &cb);
                }

                // Update the Preconfig accounts if there are newer ones available
                if ((dwVerIdentity < dwVerMaster) || (dwVerNTDSIdentity < dwVerNTDSMaster))
                {
                    // Copy in preconfigured accounts, blowing away dest conflicts
                    // $$$Review: Could do with some optimization...
                    ProcessLDAPs(hkeySrc, hkeyDestRoot, hkeyDestAccts);
                    CopyRegistry(hkeySrc, hkeyDestAccts);

                    // Avoid doing this next run
                    RegSetValueEx(hkeyDestAccts, c_szVerStamp, 0, REG_DWORD, (LPBYTE)&dwVerMaster, cb);
                }
            
                RegCloseKey(hkeySrc);
            }

            // Apply Shared Accounts
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegSharedAccts, 0, KEY_READ, &hkeySrc))
            {
                CopyRegistry(hkeySrc, hkeyDestAccts);
                RegCloseKey(hkeySrc);
            }

            RegCloseKey(hkeyDestAccts);
        }

        RegCloseKey(hkeyDestRoot);
    }
}


STDMETHODIMP CAccountManager::Init(IImnAdviseMigrateServer *pMigrateServerAdvise)
    {
    return(InitEx(pMigrateServerAdvise, ACCT_INIT_ATHENA));
    }

STDMETHODIMP CAccountManager::InitEx(IImnAdviseMigrateServer *pMigrateServerAdvise, DWORD dwFlags)
    {
    HRESULT hr;
    char sz[MAX_PATH];
    DWORD cb, type;

    if (!!(dwFlags & ACCT_INIT_OUTLOOK))
        {
        cb = sizeof(sz);
        if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, c_szInetAcctMgrRegKey, c_szRegOutlook, &type, (LPVOID)sz, &cb))
            return(E_FAIL);
        m_fOutlook = TRUE;
        }
    else
        {
        StrCpyN(sz, c_szInetAcctMgrRegKey, ARRAYSIZE(sz));
        
        // Perform OE maintenance
        InitializeUser(HKEY_CURRENT_USER, c_szInetAcctMgrRegKey);
        }

    EnterCriticalSection(&m_cs);
    m_fInitCalled = TRUE;

    if (m_fInit)
        hr = S_OK;
    else
        hr = IInit(pMigrateServerAdvise, HKEY_CURRENT_USER, sz, dwFlags);

    LeaveCriticalSection(&m_cs);

    return(hr);
    }


STDMETHODIMP CAccountManager::InitUser(IImnAdviseMigrateServer *pMigrateServerAdvise, REFGUID rguidID, DWORD dwFlags)
{
    HRESULT hr=S_OK;
    HKEY hkey;
    DWORD cb;
    DWORD dwDisp;
    IUserIdentityManager *pIdentMan;
    IUserIdentity *pIdentity;
    IUserIdentity *pIdentity2;
    BOOL fInitCalled;
    GUID guid;
    LONG lErr;

    if (dwFlags)
        return TrapError(E_INVALIDARG);
    
    EnterCriticalSection(&m_cs);
    // Raid 44928 - don't allow InitUser to blow away account settings if the account manager  
    // has already been initialized.  This should not be an issue when the single instance
    // problem is solved.
    fInitCalled = m_fInitCalled;
    LeaveCriticalSection(&m_cs);
    
    if (fInitCalled)
        return S_AlreadyInitialized;

    if (SUCCEEDED(CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, IID_IUserIdentityManager, (LPVOID *)&pIdentMan)))
    {
        Assert(pIdentMan);
        
        if (SUCCEEDED(hr = pIdentMan->GetIdentityByCookie((GUID*)&rguidID, &pIdentity)))
        {
            Assert(pIdentity);
            
            // Use the cookie as reported by the Identity in case caller used a UID_GIBC_... value
            if (SUCCEEDED(hr = pIdentity->GetCookie(&guid)))
            {
                // Thread Safety - don't leave this function without Leaving the CS!
                EnterCriticalSection(&g_csAcctMan);

                // Have we already read the cached value at some point?
                if (!g_fCachedGUID)
                {
                    // Examine the value in the registry
                    lErr = RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegAccounts, 0, NULL, REG_OPTION_NON_VOLATILE, 
                                                 KEY_READ | KEY_WRITE, NULL, &hkey, NULL);
                    hr = HRESULT_FROM_WIN32(lErr);
                    if (SUCCEEDED(hr))
                    {
                        cb = sizeof(g_guidCached);
                        if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szAssocID, 0, &dwDisp, (LPBYTE)&g_guidCached, &cb))
                        {
                            // Couldn't read it, need to create it from Default User GUID
                            if (IsEqualGUID(rguidID, UID_GIBC_DEFAULT_USER))
                                // Save the trip if we can
                            {
                                g_guidCached = guid;
                                g_fCachedGUID = TRUE;
                            }
                            else if (SUCCEEDED(hr = pIdentMan->GetIdentityByCookie((GUID*)&UID_GIBC_DEFAULT_USER, &pIdentity2)))
                            {
                                Assert(pIdentity2);

                                if (SUCCEEDED(hr = pIdentity2->GetCookie(&g_guidCached)))
                                    g_fCachedGUID = TRUE;

                                pIdentity2->Release();
                            }
                        }
                        else
                        {
                            AssertSz(REG_BINARY == dwDisp, "Account Manager: Cached GUID format is incorrect!");
                            g_fCachedGUID = TRUE;
                        }

                        // Write the value out if we have it
                        if (g_fCachedGUID)
                        {
                            lErr = RegSetValueEx(hkey, c_szAssocID, 0, REG_BINARY, (LPBYTE)&g_guidCached, sizeof(g_guidCached));
                            hr = HRESULT_FROM_WIN32(lErr);
                        }

                        RegCloseKey(hkey);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    // Safe to carry on with the comparison
                    if (IsEqualGUID(g_guidCached, guid))
                    {
                        // Redirect to old HKCU\SW\MS\IAM Place
                        hkey = HKEY_CURRENT_USER;
                    }
                    else
                    {
                        // Try to use the identity's hkey
                        hr = pIdentity->OpenIdentityRegKey(KEY_ALL_ACCESS, &hkey);
                    }
                }


                // Thread Safety
                LeaveCriticalSection(&g_csAcctMan);
            }

            pIdentity->Release();
        }

        pIdentMan->Release();
    }
    else
    {
        hr = S_OK; //TrapError(E_NoIdentities);
        hkey = HKEY_CURRENT_USER;
    }
    // Only continue if we have been successful so far
    if (SUCCEEDED(hr))
    {
        // Perform OE maintenance
        InitializeUser(hkey, c_szInetAcctMgrRegKey);

        EnterCriticalSection(&m_cs);

        // Note: AcctManager will free hkey as long as it is not HKCU
        hr = IInit(pMigrateServerAdvise, hkey, c_szInetAcctMgrRegKey, dwFlags);

        LeaveCriticalSection(&m_cs);
    }

    return(hr);
}

HRESULT CAccountManager::IInit(IImnAdviseMigrateServer *pMigrateServerAdvise, HKEY hkey, LPCSTR pszSubKey, DWORD dwFlags)
    {
    DWORD cb, type, dw;
    HRESULT hr = S_OK;

    Assert(pszSubKey != NULL);

    if (!m_fInit)
        {
        // These should be null
        Assert(m_pAcctPropSet == NULL && m_pAccounts == NULL && m_cAccounts == 0);

        cb = sizeof(DWORD);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegFlat, c_szRegValNoModifyAccts, &type, &dw, &cb) &&
            dw != 0)
            m_fNoModifyAccts = TRUE;

        // Lets create the property set object used by account objects
        m_pAcctPropSet = new CPropertySet;
        if (m_pAcctPropSet == NULL)
            {
            hr = TRAPHR(E_OUTOFMEMORY);
            goto exit;
            }

        // Init the property set
        CHECKHR(hr = m_pAcctPropSet->HrInit(g_rgAcctPropSet, NUM_ACCT_PROPS));

        // Init the account information array structure
        m_rgAccountInfo[ACCT_NEWS].pszDefRegValue = (LPTSTR)c_szDefaultNewsAccount;
        m_rgAccountInfo[ACCT_MAIL].pszDefRegValue = (LPTSTR)c_szDefaultMailAccount;
        m_rgAccountInfo[ACCT_DIR_SERV].pszDefRegValue = (LPTSTR)c_szDefaultLDAPAccount;
        }

    if (m_hkey != HKEY_CURRENT_USER)
        RegCloseKey(m_hkey);

    m_hkey = hkey;
    StrCpyN(m_szRegRoot, pszSubKey, ARRAYSIZE(m_szRegRoot));
    wnsprintf(m_szRegAccts, ARRAYSIZE(m_szRegAccts), c_szPathFileFmt, m_szRegRoot, c_szAccountsKey);

    // Load the account list
    CHECKHR(hr = LoadAccounts());

    if (!m_fInit)
        {
        Assert(m_uMsgNotify == 0);

        // Create notify message
        if (g_uMsgAcctManNotify == 0)
            g_uMsgAcctManNotify = RegisterWindowMessage(ACCTMAN_NOTIF_WMSZ);

        // We don't start watching for notifications until we'ev migrated and loaded the accounts
        m_uMsgNotify = g_uMsgAcctManNotify;
        }

    // Were inited
    m_fInit = TRUE;

exit:
    // If we failed, free some stuff
    if (FAILED(hr))
        {
        if (!m_fInit)
            SafeRelease(m_pAcctPropSet);
        }

    return hr;
    }

// -----------------------------------------------------------------------------
// CAccountManager::Advise - Internal way to notify of new/deleted/changed accts
// -----------------------------------------------------------------------------
VOID CAccountManager::Advise(DWORD dwAction, ACTX* pactx)
{
    // Locals
    CAccount        *pAccount=NULL;
    ULONG            i=0;
    HRESULT          hr;
    BOOL             fExist=FALSE,
                     fDefault=FALSE;
    LPACCOUNT        pAccountsOld;
    ACCTTYPE         AcctType, at;
    ACTX             actx;
    LPTSTR           pszID;

    // Critsect
    EnterCriticalSection(&m_cs);
    m_uMsgNotify = 0;
    Assert(dwAction);
    Assert(pactx);

    AcctType = ACCT_UNDEFINED;

    // Only if we have a pszAccount
    pszID = pactx->pszAccountID;
    if (pszID)
    {
        // Lets get the index of this account
        for (i=0; i<m_cAccounts; i++)
        {
            if (lstrcmpi(m_pAccounts[i].szID, pszID) == 0)
            {
                fExist = TRUE;
                break;
            }
        }

        // Is this a default account ???
        if (fExist)
        {
            at = m_pAccounts[i].AcctType;
            if (lstrcmpi(m_rgAccountInfo[at].szDefaultID, pszID) == 0)
                fDefault = TRUE;

            AcctType = m_pAccounts[i].AcctType;
            Assert(AcctType < ACCT_LAST);
        }
    }

    // Handle lParam
    switch(dwAction)
    {
    // ----------------------------------------------------------------------------
    case AN_DEFAULT_CHANGED:
        GetDefaultAccounts();
        break;

    // ----------------------------------------------------------------------------
    case AN_ACCOUNT_DELETED:
        Assert(pszID != NULL);

        // If we didn't find it, bail
        if (!fExist)
        {
            Assert(FALSE);
            break;
        }

        // Release current account object
        SafeRelease(m_pAccounts[i].pAccountObject);

        // Memalloc
        pAccountsOld = m_pAccounts;
        if (FAILED(HrAlloc((LPVOID *)&m_pAccounts, (m_cAccounts - 1) * sizeof(ACCOUNT))))
        {
            m_cAccounts++;
            Assert(FALSE);
            break;
        }

        // Copy everything but i
        CopyMemory(m_pAccounts, pAccountsOld, i * sizeof(ACCOUNT));
        CopyMemory(m_pAccounts + i, pAccountsOld + i + 1, (m_cAccounts - (i + 1)) * sizeof(ACCOUNT));

        // Delete old accounts array
        SafeMemFree(pAccountsOld);

        // Lets duplicate the array - 1
        m_cAccounts--;

        m_rgAccountInfo[AcctType].cAccounts--;

        // Reset Default ???
        if (fDefault)
        {
            // Lets find first SrvType and set it as the default
            for (i=0; i<m_cAccounts; i++)
            {
                if (m_pAccounts[i].AcctType == AcctType)
                {
                    Assert(m_pAccounts[i].pAccountObject);
                    if (m_pAccounts[i].pAccountObject)
                        m_pAccounts[i].pAccountObject->SetAsDefault();
                    break;
                }
            }
        }
        break;

    // ----------------------------------------------------------------------------
    case AN_ACCOUNT_CHANGED:
        Assert(pszID != NULL);

        // If we didn't find it, bail
        if (!fExist)
        {
            Assert(FALSE);
            break;
        }

        // Lets release the old account object
        SafeRelease(m_pAccounts[i].pAccountObject);

        // Create a new account object
        if (FAILED(CreateAccountObject(AcctType, (IImnAccount **)&pAccount)))
        {
            Assert(FALSE);
            break;
        }

        // Lets open the new account
        if (FAILED(pAccount->Open(m_hkey, m_szRegAccts, pszID)))
        {
            Assert(FALSE);
            break;
        }

        // Save the new account
        pAccount->GetServerTypes(&m_pAccounts[i].dwSrvTypes);
        m_pAccounts[i].dwServerId = 0;
        if (m_pAccounts[i].AcctType == ACCT_DIR_SERV)
            pAccount->GetPropDw(AP_LDAP_SERVER_ID, &m_pAccounts[i].dwServerId);
        m_pAccounts[i].pAccountObject = pAccount;
        m_pAccounts[i].pAccountObject->AddRef();

        // Reset Default ???
        if (fDefault)
            m_pAccounts[i].pAccountObject->SetAsDefault();
        break;

    // ----------------------------------------------------------------------------
    case AN_ACCOUNT_ADDED:
        Assert(pszID != NULL);

        // If we didn't find it, bail
        if (fExist)
        {
            AssertSz(FALSE, "An account was added with a duplicate name.");
            break;
        }

        // Lets Open the new account
        if (FAILED(ICreateAccountObject(ACCT_UNDEFINED, (IImnAccount **)&pAccount)))
        {
            Assert(FALSE);
            break;
        }

        // Lets open the new account
        if (FAILED(pAccount->Open(m_hkey, m_szRegAccts, pszID)))
        {
            Assert(FALSE);
            break;
        }

        // Realloc my array
        if (FAILED(HrRealloc((LPVOID *)&m_pAccounts, (m_cAccounts + 1) * sizeof(ACCOUNT))))
        {
            Assert(FALSE);
            break;
        }

        // Increment the number of accounts
        m_cAccounts++;

        // Add this account into m_cAccounts - 1
        StrCpyN(m_pAccounts[m_cAccounts-1].szID, pszID, ARRAYSIZE(m_pAccounts[m_cAccounts-1].szID));
        pAccount->GetAccountType(&m_pAccounts[m_cAccounts-1].AcctType);
        pAccount->GetServerTypes(&m_pAccounts[m_cAccounts-1].dwSrvTypes);
        m_pAccounts[m_cAccounts-1].dwServerId = 0;
        if (m_pAccounts[m_cAccounts-1].AcctType == ACCT_DIR_SERV)
            pAccount->GetPropDw(AP_LDAP_SERVER_ID, &m_pAccounts[m_cAccounts-1].dwServerId);
        m_pAccounts[m_cAccounts-1].pAccountObject = pAccount;
        m_pAccounts[m_cAccounts-1].pAccountObject->AddRef();

        AcctType = m_pAccounts[m_cAccounts-1].AcctType;
        Assert(AcctType < ACCT_LAST);

        if (m_rgAccountInfo[AcctType].cAccounts == 0)
            {
            hr = SetDefaultAccount(AcctType, pszID, TRUE);
            Assert(SUCCEEDED(hr));
            }

        m_rgAccountInfo[AcctType].cAccounts++;
        break;
    }

    // Cleanup
    SafeRelease(pAccount);

    // Call client advises
    if(m_ppAdviseAccounts)
        {
        for(INT i=0; i<m_cAdvisesAllocated; i++)
            {
            if(NULL != m_ppAdviseAccounts[i])
                {
                m_ppAdviseAccounts[i]->AdviseAccount(dwAction, pactx);
                }
            }
        }

    // Critsect
    m_uMsgNotify = g_uMsgAcctManNotify;
    LeaveCriticalSection(&m_cs);
}

// -----------------------------------------------------------------------------
// CAccountManager::FProcessNotification - returns TRUE if window message was
// processed as a notification
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::ProcessNotification(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr=S_OK;

    // [PaulHi] 5/3/99  Raid 77490.  Normally this would be the right thing to do but this
    // is causing a thread hanging bug under Win9X.  The real problem is the CAccountManager::Advise()
    // that calls SetAsDefault, which in turn recursively calls Notification again.  But sincce
    // this was an late code addition the safest fix is to undo it.
//    EnterCriticalSection(&m_cs);

    // If not my window message, return FALSE
    if (m_uMsgNotify != uMsg)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Disable notifications
    m_uMsgNotify = 0;

    // Handle lParam
    switch(wParam)
    {
    // Yes this may look bad, or slow, but it is the safest thing to do. This is the
    // best way to do this because we basically abandon all account objects and
    // refresh our list. If someone has an enumeror on the accounts or has addref
    // account objects, they will be safe. I can not modify internal account objects
    // because someone may have a copy of it and if the are setting properties on it,
    // and I reload the properties, we will have a problem.
    case AN_DEFAULT_CHANGED:
        if ((DWORD)lParam != GetCurrentProcessId())
            GetDefaultAccounts();
        break;

    case AN_ACCOUNT_DELETED:
    case AN_ACCOUNT_ADDED:
    case AN_ACCOUNT_CHANGED:
        if ((DWORD)lParam != GetCurrentProcessId())
            LoadAccounts();
        break;
    }

    // Re-enable notifications
    m_uMsgNotify = g_uMsgAcctManNotify;

    hr = S_OK;

exit:
    // Raid 77490.  See above comment.
//    LeaveCriticalSection(&m_cs);
    return hr;
}

// -----------------------------------------------------------------------------
// CAccountManager::GetDefaultAccounts
// -----------------------------------------------------------------------------
VOID CAccountManager::GetDefaultAccounts(VOID)
    {
    ACCTINFO *pInfo;
    ULONG   at, cb;
    HKEY    hReg;

    // Open or Create root server key
    if (RegCreateKeyEx(m_hkey, m_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hReg, NULL) == ERROR_SUCCESS)
        {
        for (at = 0, pInfo = m_rgAccountInfo; at < ACCT_LAST; at++, pInfo++)
            {
            *pInfo->szDefaultID = 0;
            pInfo->fDefaultKnown = FALSE;

            if (pInfo->pszDefRegValue != NULL)
                {
                cb = sizeof(pInfo->szDefaultID);
                if (RegQueryValueEx(hReg, pInfo->pszDefRegValue, 0, NULL, (LPBYTE)pInfo->szDefaultID, &cb) == ERROR_SUCCESS)
                    {
                    if (FIsEmptyA(pInfo->szDefaultID))
                        *pInfo->szDefaultID = 0;
                    else
                        pInfo->fDefaultKnown = TRUE;
                    }
                }
            }

        RegCloseKey(hReg);
        }
    }

STDMETHODIMP CAccountManager::GetIncompleteAccount(ACCTTYPE AcctType, LPSTR pszAccountId, ULONG cchMax)
{
    DWORD type;
    HRESULT hr = S_FALSE;
    
    Assert(AcctType == ACCT_MAIL || AcctType == ACCT_NEWS);
    Assert(pszAccountId != NULL);

    if (ERROR_SUCCESS == SHGetValue(m_hkey, m_szRegAccts,
                                    AcctType == ACCT_MAIL ? c_szIncompleteMailAcct : c_szIncompleteNewsAcct,
                                    &type, (LPBYTE)pszAccountId, &cchMax) &&
        cchMax > 0)
    {
        hr = S_OK;
    }

    return(hr);
}

STDMETHODIMP CAccountManager::SetIncompleteAccount(ACCTTYPE AcctType, LPCSTR pszAccountId)
{
    Assert(AcctType == ACCT_MAIL || AcctType == ACCT_NEWS);

    if (pszAccountId == NULL)
    {
        SHDeleteValue(m_hkey, m_szRegAccts, AcctType == ACCT_MAIL ? c_szIncompleteMailAcct : c_szIncompleteNewsAcct);
    }
    else
    {
        SHSetValue(m_hkey, m_szRegAccts,
                    AcctType == ACCT_MAIL ? c_szIncompleteMailAcct : c_szIncompleteNewsAcct,
                    REG_SZ, pszAccountId, lstrlen(pszAccountId) + 1);
    }

    return(S_OK);
}

// -----------------------------------------------------------------------------
// CAccountManager::CreateAccountObject
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::CreateAccountObject(ACCTTYPE AcctType, IImnAccount **ppAccount)
    {
    if (AcctType < 0 || AcctType >= ACCT_LAST)
        return(E_INVALIDARG);

    return(ICreateAccountObject(AcctType, ppAccount));
    }

HRESULT CAccountManager::ICreateAccountObject(ACCTTYPE AcctType, IImnAccount **ppAccount)
{
    // Locals
    HRESULT             hr=S_OK;
    CAccount           *pAccount=NULL;

    // Check some state
    Assert(ppAccount && m_pAcctPropSet);
    if (ppAccount == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Allocate the object
    pAccount = new CAccount(AcctType);
    if (pAccount == NULL)
    {
        hr = TRAPHR(E_OUTOFMEMORY);
        goto exit;
    }

    // Init it
    CHECKHR(hr = pAccount->Init(this, m_pAcctPropSet));

    // Success
    *ppAccount = (IImnAccount *)pAccount;

exit:
    // Failed
    if (FAILED(hr))
    {
        SafeRelease(pAccount);
        *ppAccount = NULL;
    }

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccountManager::LoadAccounts
// -----------------------------------------------------------------------------
HRESULT CAccountManager::LoadAccounts(VOID)
    {
    // Locals
    ACCOUNT         *pAcct;
    DWORD           cbMaxSubKeyLen, cb, i, at, dwMaxId, cAccounts;
    LONG            lResult;
    HRESULT         hr=S_OK;
    HKEY            hRegRoot, hReg=NULL;

    // Critsect
    EnterCriticalSection(&m_cs);

    // Free current account list and assume news and mail are not configured
    AcctUtil_FreeAccounts(&m_pAccounts, &m_cAccounts);
    dwMaxId = 0;

    // Init account info
    for (at=0; at<ACCT_LAST; at++)
        {
        m_rgAccountInfo[at].pszFirstAccount = NULL;
        m_rgAccountInfo[at].cAccounts = 0;
        }

    // Load Default account information
    GetDefaultAccounts();

    // Open or Create root server key
    if (RegCreateKeyEx(m_hkey, m_szRegAccts, 0, NULL, REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, NULL, &hReg, NULL) != ERROR_SUCCESS)
        {
        hr = TRAPHR(E_RegCreateKeyFailed);
        goto exit;
        }

    // Enumerate keys
    if (RegQueryInfoKey(hReg, NULL, NULL, 0, &cAccounts, &cbMaxSubKeyLen, NULL, NULL, NULL, NULL,
                        NULL, NULL) != ERROR_SUCCESS)
        {
        hr = TRAPHR(E_RegQueryInfoKeyFailed);
        goto exit;
        }

    // No accounts ?
    if (cAccounts == 0)
        goto done;

    // quickcheck
    Assert(cbMaxSubKeyLen < CCHMAX_ACCOUNT_NAME);

    // Allocate the accounts array
    CHECKHR(hr = HrAlloc((LPVOID *)&m_pAccounts, sizeof(ACCOUNT) * cAccounts));

    // Zero init
    ZeroMemory(m_pAccounts, sizeof(ACCOUNT) * cAccounts);

    // Start Enumerating the keys
    for (i = 0; i < cAccounts; i++)
        {
        pAcct = &m_pAccounts[m_cAccounts];

        // Enumerate Friendly Names
        cb = sizeof(pAcct->szID);
        lResult = RegEnumKeyEx(hReg, i, pAcct->szID, &cb, 0, NULL, NULL, NULL);

        // No more items
        if (lResult == ERROR_NO_MORE_ITEMS)
            break;

        // Error, lets move onto the next account
        if (lResult != ERROR_SUCCESS)
            {
            Assert(FALSE);
            continue;
            }

        // Create the account object
        CHECKHR(hr = ICreateAccountObject(ACCT_UNDEFINED, &pAcct->pAccountObject));

        // Open the account
        if (FAILED(((CAccount *)pAcct->pAccountObject)->Open(m_hkey, m_szRegAccts, pAcct->szID)) ||
            FAILED(pAcct->pAccountObject->GetAccountType(&pAcct->AcctType)) ||
            FAILED(pAcct->pAccountObject->GetServerTypes(&pAcct->dwSrvTypes)))
            {
            pAcct->pAccountObject->Release();
            pAcct->pAccountObject = NULL;

            continue;
            }

        // Update account info
        at = pAcct->AcctType;
        Assert(at < ACCT_LAST);

        pAcct->dwServerId = 0;
        if (at == ACCT_DIR_SERV)
            {
            pAcct->pAccountObject->GetPropDw(AP_LDAP_SERVER_ID, &pAcct->dwServerId);

            if (pAcct->dwServerId > dwMaxId)
                dwMaxId = pAcct->dwServerId;
            }

        // Count servers
        m_rgAccountInfo[at].cAccounts++;

        // Have we found the first account yet ?
        if (!m_rgAccountInfo[at].pszFirstAccount)
            m_rgAccountInfo[at].pszFirstAccount = pAcct->szID;

        // Is this the default
        if (lstrcmpi(pAcct->szID, m_rgAccountInfo[at].szDefaultID) == 0)
            m_rgAccountInfo[at].fDefaultKnown = TRUE;

        m_cAccounts++;
        }

    // Update default accounts
    for (at=0; at<ACCT_LAST; at++)
        {
        // Doesn't have a default
        if (m_rgAccountInfo[at].pszDefRegValue == NULL)
            continue;

        // If default not found and we found a first account
        if (!m_rgAccountInfo[at].fDefaultKnown && m_rgAccountInfo[at].pszFirstAccount)
            {
            StrCpyN(m_rgAccountInfo[at].szDefaultID, m_rgAccountInfo[at].pszFirstAccount, CCHMAX_ACCOUNT_NAME);

            if (SUCCEEDED(SetDefaultAccount((ACCTTYPE)at, m_rgAccountInfo[at].szDefaultID, FALSE)))
                m_rgAccountInfo[at].fDefaultKnown = TRUE;
            }
        }

done:
    dwMaxId++;
    // Open or Create root server key
    if (RegCreateKeyEx(m_hkey, m_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE,
                       KEY_ALL_ACCESS, NULL, &hRegRoot, NULL) != ERROR_SUCCESS)
        {
        hr = TRAPHR(E_RegCreateKeyFailed);
        }
    else
        {
        RegSetValueEx(hRegRoot, c_szRegServerID, 0, REG_DWORD, (LPBYTE)&dwMaxId, sizeof(DWORD));
        RegCloseKey(hRegRoot);
        }

exit:
    // Cleanup
    if (hReg)
        RegCloseKey(hReg);

    // If failed
    if (FAILED(hr))
        AcctUtil_FreeAccounts(&m_pAccounts, &m_cAccounts);

    // Critsect
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
    }

// -----------------------------------------------------------------------------
// CAccountManager::Enumerate
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::Enumerate(DWORD dwSrvTypes, IImnEnumAccounts **ppEnumAccounts)
    {
    return(IEnumerate(dwSrvTypes, 0, ppEnumAccounts));
    }

HRESULT CAccountManager::IEnumerate(DWORD dwSrvTypes, DWORD dwFlags, IImnEnumAccounts **ppEnumAccounts)
{
    // Locals
    HRESULT         hr=S_OK;
    CEnumAccounts  *pEnumAccounts=NULL;

    // Critsect
    EnterCriticalSection(&m_cs);

    // Check Parama
    if (ppEnumAccounts == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // No Accounts
    if (m_pAccounts == NULL || m_cAccounts == 0)
    {
        hr = TRAPHR(E_NoAccounts);
        goto exit;
    }

    // check that the flags make sense
    // can't have sorting by name and resolution id
    // can't have resolve flags with no ldap servers
    if ((!!(dwFlags & ENUM_FLAG_SORT_BY_NAME) &&
        !!(dwFlags & ENUM_FLAG_SORT_BY_LDAP_ID)) ||
        (!!(dwFlags & (ENUM_FLAG_RESOLVE_ONLY | ENUM_FLAG_SORT_BY_LDAP_ID)) &&
        dwSrvTypes != SRV_LDAP))
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Create the enumerator object
    pEnumAccounts = new CEnumAccounts(dwSrvTypes, dwFlags);
    if (pEnumAccounts == NULL)
    {
        hr = TRAPHR(E_OUTOFMEMORY);
        goto exit;
    }

    // Init the object
    CHECKHR(hr = pEnumAccounts->Init(m_pAccounts, m_cAccounts));

    // Set outbound point
    *ppEnumAccounts = (IImnEnumAccounts *)pEnumAccounts;

exit:
    // Failed
    if (FAILED(hr))
    {
        SafeRelease(pEnumAccounts);
        *ppEnumAccounts = NULL;
    }

    // Critsect
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccountManager::ValidateDefaultSendAccount
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::ValidateDefaultSendAccount(VOID)
{
    // Locals
    IImnAccount     *pAccount=NULL;
    BOOL             fResetDefault=TRUE;
    ULONG            i;
    DWORD            dwSrvTypes;
    TCHAR            szServer[CCHMAX_SERVER_NAME];
    BOOL             fDefaultKnown=FALSE;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Open the default SMTP Account
    if (SUCCEEDED(GetDefaultAccount(ACCT_MAIL, &pAccount)))
    {
        if (SUCCEEDED(pAccount->GetPropSz(AP_SMTP_SERVER, szServer, ARRAYSIZE(szServer))) && !FIsEmptyA(szServer))
        {
            fResetDefault = FALSE;
            fDefaultKnown = TRUE;
        }
    }

    // Reset the default..
    if (fResetDefault)
    {
        // Loop Accounts until we find one that supports an smtp server
        for (i=0; i<m_cAccounts; i++)
        {
            if (m_pAccounts[i].pAccountObject != NULL &&
                m_pAccounts[i].AcctType == ACCT_MAIL &&
                SUCCEEDED(m_pAccounts[i].pAccountObject->GetServerTypes(&dwSrvTypes)))
            {
                // Supports SRV_SMTP
                if (dwSrvTypes & SRV_SMTP)
                {
                    // Lets make this dude the default
                    m_pAccounts[i].pAccountObject->SetAsDefault();

                    // We know the default
                    fDefaultKnown = TRUE;

                    // Were Done
                    break;
                }
            }
        }
    }

    // Unknown Default
    if (fDefaultKnown == FALSE)
    {
        m_rgAccountInfo[ACCT_MAIL].fDefaultKnown = FALSE;
        *m_rgAccountInfo[ACCT_MAIL].szDefaultID = _T('\0');
    }

    // Cleanup
    SafeRelease(pAccount);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// -----------------------------------------------------------------------------
// CAccountManager::GetDefaultAccount
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::GetDefaultAccountName(ACCTTYPE AcctType, LPTSTR pszAccount, ULONG cchMax)
{
    // Locals
    HRESULT         hr=S_OK;
    IImnAccount     *pAcct = NULL;

    hr = GetDefaultAccount(AcctType, &pAcct);
    if (!FAILED(hr))
        {
        Assert(pAcct != NULL);
        hr = pAcct->GetPropSz(AP_ACCOUNT_NAME, pszAccount, cchMax);

        pAcct->Release();
        }

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccountManager::GetDefaultAccount
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::GetDefaultAccount(ACCTTYPE AcctType, IImnAccount **ppAccount)
    {
    HRESULT         hr;
    ACCTINFO        *pinfo;
    ACCOUNT         *pAcct;
    ULONG           i;

    // Check Params
    Assert(AcctType >= 0 && AcctType < ACCT_LAST);
    if (ppAccount == NULL || AcctType >= ACCT_LAST)
        return(E_INVALIDARG);

    // Init
    *ppAccount = NULL;

    EnterCriticalSection(&m_cs);

    pinfo = &m_rgAccountInfo[AcctType];

    // Is default know for this account type
    if (!pinfo->fDefaultKnown)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Loop through accounts and try to find the default for AcctType
    for (i = 0, pAcct = m_pAccounts; i < m_cAccounts; i++, pAcct++)
        {
        // Match ?
        if (pAcct->AcctType == AcctType &&
            lstrcmpi(pAcct->szID, pinfo->szDefaultID) == 0)
            {
            // Better not be null
            Assert(pAcct->pAccountObject);

            // Copy and addref the account
            *ppAccount = pAcct->pAccountObject;
            (*ppAccount)->AddRef();
            hr = S_OK;
            goto exit;
            }
        }

    hr = E_FAIL;

exit:
    LeaveCriticalSection(&m_cs);
    return(hr);
    }

// -----------------------------------------------------------------------------
// CAccountManager::GetServerCount
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::GetAccountCount(ACCTTYPE AcctType, ULONG *pcAccounts)
{
    // Check Params
    Assert(AcctType >= 0 && AcctType < ACCT_LAST);

    // Bad Param
    if (AcctType >= ACCT_LAST || !pcAccounts)
        return TRAPHR(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set
    *pcAccounts = m_rgAccountInfo[AcctType].cAccounts;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // return server count
    return S_OK;
}

// -----------------------------------------------------------------------------
// CAccountManager::FindAccount
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::FindAccount(DWORD dwPropTag, LPCTSTR pszSearchData, IImnAccount **ppAccount)
{
    // Locals
    ACCOUNT         *pAcct;
    IImnAccount     *pAccount;
    HRESULT         hr=S_OK;
    LPTSTR          pszPropData=NULL;
    DWORD           cbAllocated=0,
                    cb;
    ULONG           i;

    // Thread Safety
    EnterCriticalSection(&m_cs);
    
    // Check Params
    if (pszSearchData == NULL || ppAccount == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppAccount = NULL;

    // No Accounts
    if (m_pAccounts == NULL || m_cAccounts == 0)
    {
        hr = TRAPHR(E_NoAccounts);
        goto exit;
    }

    // Proptag better represent a string data type
    Assert(PROPTAG_TYPE(dwPropTag) == TYPE_STRING || PROPTAG_TYPE(dwPropTag) == TYPE_WSTRING);

    // Loop throug the servers
    for (i = 0, pAcct = m_pAccounts; i < m_cAccounts; i++, pAcct++)
    {
        // We should have an account object, but if not
        Assert(pAcct->pAccountObject != NULL);

        // Get the size of the property
        hr = pAcct->pAccountObject->GetProp(dwPropTag, NULL, &cb);
        if (FAILED(hr))
            continue;

        // Reallocate my data buffer ?
        if (cb > cbAllocated)
        {
            // Increment allocated
            cbAllocated = cb + 512;

            // Realloc
            CHECKHR(hr = HrRealloc((LPVOID *)&pszPropData, cbAllocated));
        }

        // Ok, get the data
        CHECKHR(hr = pAcct->pAccountObject->GetProp(dwPropTag, (LPBYTE)pszPropData, &cb));

        // Does this match
        if (lstrcmpi(pszPropData, pszSearchData) == 0)
        {
            m_pAccounts[i].pAccountObject->AddRef();
            *ppAccount = m_pAccounts[i].pAccountObject;

            goto exit;
        }
    }

    // We failed
    hr = TRAPHR(E_FAIL);

exit:
    // Clenaup
    SafeMemFree(pszPropData);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccountManager::AccountListDialog
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::AccountListDialog(HWND hwnd, ACCTLISTINFO *pinfo)
    {
    HRESULT hr;
    int iRet;
    ACCTDLGINFO adi;
    INITCOMMONCONTROLSEX    icex = { sizeof(icex), ICC_FLAGS };

    if (pinfo == NULL ||
        0 == pinfo->dwAcctFlags ||
        0 != (pinfo->dwAcctFlags & ~ACCT_FLAG_ALL) ||
        0 != (pinfo->dwFlags & ~(ACCTDLG_ALL)))
        {
        hr = TRAPHR(E_INVALIDARG);
        return(hr);
        }

    if (m_fNoModifyAccts)
        return(S_OK);

    InitCommonControlsEx(&icex);

    adi.AcctTypeInit = pinfo->AcctTypeInit;
    adi.dwAcctFlags = pinfo->dwAcctFlags;
    adi.dwFlags = pinfo->dwFlags;

    iRet = (int) DialogBoxParam(g_hInstRes, MAKEINTRESOURCE(iddManageAccounts), hwnd,
                    ManageAccountsDlgProc, (LPARAM)&adi);

    return((iRet == -1) ? E_FAIL : S_OK);
    }

// -----------------------------------------------------------------------------
// CAccountManager::Advise
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::Advise(
        IImnAdviseAccount *pAdviseAccount,
        DWORD* pdwConnection)
{
    Assert(pAdviseAccount);
    Assert(pdwConnection);

    INT                 nIndex = -1;
    HRESULT             hr = S_OK;

    // Critsect
    EnterCriticalSection(&m_cs);

    if(NULL != m_ppAdviseAccounts)
        {
        Assert(m_cAdvisesAllocated > 0);
        for(INT i=0; i<m_cAdvisesAllocated; ++i)
            {
            if(NULL == m_ppAdviseAccounts[i])
                {
                // unused slot - use this one.
                nIndex = i;
                break;
                }
            }
        }
    else
        {
        Assert(0 == m_cAdvisesAllocated);
        hr = HrAlloc((LPVOID *)&m_ppAdviseAccounts, 
                sizeof(IImnAdviseAccount*) * ADVISE_BLOCK_SIZE);
        if(FAILED(hr) || (NULL == m_ppAdviseAccounts))
            {
            goto Error;
            }

        ZeroMemory(m_ppAdviseAccounts, 
                sizeof(IImnAdviseAccount*) * ADVISE_BLOCK_SIZE);

        m_cAdvisesAllocated = ADVISE_BLOCK_SIZE;
        nIndex = 0;
        }

    if(nIndex < 0)  // array is not big enough...
        {
        INT nNewSize = m_cAdvisesAllocated + ADVISE_BLOCK_SIZE;

        // reality check - connection will only support 64K advises
        Assert(nNewSize <= MAX_INDEX);

        hr = HrRealloc((LPVOID *)&m_ppAdviseAccounts, 
                sizeof(IImnAdviseAccount*) * nNewSize);
        if(FAILED(hr))
            {
            goto Error;
            }

        ZeroMemory(&m_ppAdviseAccounts[m_cAdvisesAllocated], 
                sizeof(IImnAdviseAccount*) * ADVISE_BLOCK_SIZE);

        nIndex = m_cAdvisesAllocated;
        m_cAdvisesAllocated = nNewSize;
        }

    Assert(m_ppAdviseAccounts);
    pAdviseAccount->AddRef();
    Assert(IS_VALID_INDEX(nIndex));
    m_ppAdviseAccounts[nIndex] = pAdviseAccount;
    *pdwConnection = CONNECTION_FROM_INDEX(nIndex);

Out:
    // Critsect
    LeaveCriticalSection(&m_cs);
    return hr;

Error:
    *pdwConnection = 0;
    goto Out;
}


// -----------------------------------------------------------------------------
// CAccountManager::Unadvise
// -----------------------------------------------------------------------------
STDMETHODIMP CAccountManager::Unadvise(DWORD dwConnection)
{
    HRESULT hr = S_OK;
    INT nIndex = -1;

    // Critsect
    EnterCriticalSection(&m_cs);

    if(IS_VALID_CONNECTION(dwConnection))
        {
        nIndex = INDEX_FROM_CONNECTION(dwConnection);
        Assert(IS_VALID_INDEX(nIndex));
        }

    if((nIndex >= 0) && (nIndex < m_cAdvisesAllocated) &&
            (NULL != m_ppAdviseAccounts[nIndex]))
        {
        IImnAdviseAccount* paa = m_ppAdviseAccounts[nIndex];
        m_ppAdviseAccounts[nIndex] = NULL;
        paa->Release();
        }
    else
        {
        AssertSz(fFalse, "CAccountManager::Unadvise - Bad Connection!");
        hr = E_INVALIDARG;
        }

    // Critsect
    LeaveCriticalSection(&m_cs);
    return hr;
}

// -----------------------------------------------------------------------------
// CAccount::CAccount
// -----------------------------------------------------------------------------
CAccount::CAccount(ACCTTYPE AcctType)
{
    m_cRef = 1;
    m_pAcctMgr = NULL;
    m_fAccountExist = FALSE;
    m_AcctType = AcctType;
    m_dwSrvTypes = 0;
    *m_szID = 0;
    *m_szName = 0;
    m_hkey = NULL;
    *m_szKey = 0;
    m_fNoModifyAccts = FALSE;
}

// -----------------------------------------------------------------------------
// CAccount::~CAccount
// -----------------------------------------------------------------------------
CAccount::~CAccount(void)
{
    ReleaseObj(m_pContainer);
}

// -----------------------------------------------------------------------------
// CAccount::QueryInterface
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // IID_IPropertyContainer
    else if (IID_IPropertyContainer == riid)
        *ppv = (IPropertyContainer *)this;

    // IID_ImnAccount
    else if (IID_IImnAccount == riid)
        *ppv = (IImnAccount *)this;

    // If not null, addref it and return
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
    }
    else
    {
        // No Interface
        hr = TRAPHR(E_NOINTERFACE);
    }

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccount::AddRef
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAccount::AddRef(VOID)
{
    m_pAcctMgr->AddRef();
    return ++m_cRef;
}

// -----------------------------------------------------------------------------
// CAccount::Release
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAccount::Release(VOID)
{
    ULONG   cRef = --m_cRef;
    
    if (cRef == 0)
    {
        delete this;
        return 0;
    }
    m_pAcctMgr->Release();

    return cRef;
}

// -----------------------------------------------------------------------------
// CAccount::SetAsDefault
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::Exist(VOID)
{
    return m_fAccountExist ? S_OK : S_FALSE;
}

// -----------------------------------------------------------------------------
// CAccount::SetAsDefault
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::SetAsDefault(VOID)
    {
    HRESULT hr;
    
    if (m_fAccountExist)
        hr = m_pAcctMgr->SetDefaultAccount(m_AcctType, m_szID, TRUE);
    else
        hr = E_FAIL;

    return(hr);
    }

// -----------------------------------------------------------------------------
// CAccount::Delete
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::Delete(VOID)
    {
    DWORD           dwSrvTypes;
    HRESULT         hr;

    // Should already exist
    Assert(m_fAccountExist);

    if (SUCCEEDED(hr = GetServerTypes(&dwSrvTypes)) &&
        SUCCEEDED(hr = m_pAcctMgr->DeleteAccount(m_szID, m_szName, m_AcctType, dwSrvTypes)))
        {
        // Doesn't exist anymore
        m_fAccountExist = FALSE;
        }

    return(hr);
    }

STDMETHODIMP CAccount::GetAccountType(ACCTTYPE *pAcctType)
    {
    HRESULT hr;

    if (pAcctType == NULL)
        {
        hr = TRAPHR(E_INVALIDARG);
        return(hr);
        }

    Assert(m_AcctType >= 0 && m_AcctType < ACCT_LAST);
    *pAcctType = m_AcctType;

    return(S_OK);
    }

// -----------------------------------------------------------------------------
// CAccount::DwGetServerTypes
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::GetServerTypes(DWORD *pdwSrvTypes)
{
    // Locals
    DWORD           dwSrvTypes=0;
    TCHAR           szServer[CCHMAX_SERVER_NAME];
    HRESULT         hr=S_OK;

    if (pdwSrvTypes == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        return(hr);
    }

    if (m_AcctType == ACCT_NEWS || m_AcctType == ACCT_UNDEFINED)
        {
        // NNTP Lets compute the servers supported by this account
        hr = GetPropSz(AP_NNTP_SERVER, szServer, sizeof(szServer));
        if (!FAILED(hr) && !FIsEmptyA(szServer))
            dwSrvTypes |= SRV_NNTP;
        }
    
    if (m_AcctType == ACCT_MAIL || m_AcctType == ACCT_UNDEFINED)
        {
        // SMTP Lets compute the servers supported by this account
        hr = GetPropSz(AP_SMTP_SERVER, szServer, sizeof(szServer));
        if (!FAILED(hr) && !FIsEmptyA(szServer))
            dwSrvTypes |= SRV_SMTP;

        // POP3 Lets compute the servers supported by this account
        hr = GetPropSz(AP_POP3_SERVER, szServer, sizeof(szServer));
        if (!FAILED(hr) && !FIsEmptyA(szServer))
            dwSrvTypes |= SRV_POP3;

        // IMAP Lets compute the servers supported by this account
        hr = GetPropSz(AP_IMAP_SERVER, szServer, sizeof(szServer));
        if (!FAILED(hr) && !FIsEmptyA(szServer))
            dwSrvTypes |= SRV_IMAP;

        // HTTPMail Lets compute the servers supported by this account
        hr = GetPropSz(AP_HTTPMAIL_SERVER, szServer, sizeof(szServer));
        if (!FAILED(hr) && !FIsEmptyA(szServer))
            dwSrvTypes |= SRV_HTTPMAIL;

        }
    
    if (m_AcctType == ACCT_DIR_SERV || m_AcctType == ACCT_UNDEFINED)
        {
        // LDAP Lets compute the servers supported by this account
        hr = GetPropSz(AP_LDAP_SERVER, szServer, sizeof(szServer));
        if (!FAILED(hr) && !FIsEmptyA(szServer))
            dwSrvTypes |= SRV_LDAP;
        }

    if (m_AcctType == ACCT_UNDEFINED)
        {
        if (!!(dwSrvTypes & SRV_POP3))
            {
            m_AcctType = ACCT_MAIL;
            dwSrvTypes = (dwSrvTypes & (SRV_POP3 | SRV_SMTP));
            }
        else if (!!(dwSrvTypes & SRV_IMAP))
            {
            m_AcctType = ACCT_MAIL;
            dwSrvTypes = (dwSrvTypes & (SRV_IMAP | SRV_SMTP));
            }
        else if (!!(dwSrvTypes & SRV_HTTPMAIL))
            {
            m_AcctType = ACCT_MAIL;
            }
        else if (!!(dwSrvTypes & SRV_SMTP))
            {
            m_AcctType = ACCT_MAIL;
            dwSrvTypes = (dwSrvTypes & (SRV_POP3 | SRV_SMTP));
            }
        else if (!!(dwSrvTypes & SRV_NNTP))
            {
            m_AcctType = ACCT_NEWS;
            dwSrvTypes = SRV_NNTP;
            }
        else if (!!(dwSrvTypes & SRV_LDAP))
            {
            m_AcctType = ACCT_DIR_SERV;
            dwSrvTypes = SRV_LDAP;
            }
        else
            {
            return(E_FAIL);
            }
        }

    *pdwSrvTypes = dwSrvTypes;

    // Done
    return(S_OK);
}

// -----------------------------------------------------------------------------
// CAccount::Init
// -----------------------------------------------------------------------------
HRESULT CAccount::Init(CAccountManager *pAcctMgr, CPropertySet *pPropertySet)
    {
    HRESULT hr = S_OK;

    Assert(pAcctMgr != NULL);
    Assert(m_pAcctMgr == NULL);

    m_pAcctMgr = pAcctMgr;

    // Create the property container
    hr = HrCreatePropertyContainer(pPropertySet, &m_pContainer);

    m_fNoModifyAccts = pAcctMgr->FNoModifyAccts();

    return(hr);
    }

STDMETHODIMP CAccount::Open(HKEY hkey, LPCSTR pszAcctsKey, LPCSTR pszID)
    {
    DWORD               cb;
    HRESULT             hr;
    HKEY                hkeyAccount = NULL;

    Assert(pszAcctsKey != NULL);
    Assert(pszID != NULL);

    m_hkey = hkey;
    wnsprintf(m_szKey, ARRAYSIZE(m_szKey), c_szPathFileFmt, pszAcctsKey, pszID);

    m_pContainer->EnterLoadContainer();

    if (RegOpenKeyEx(m_hkey, m_szKey, 0, KEY_ALL_ACCESS, &hkeyAccount) != ERROR_SUCCESS)
        {
        hr = TRAPHR(E_RegOpenKeyFailed);
        goto exit;
        }

    // Save friendly name
    StrCpyN(m_szID, pszID, ARRAYSIZE(m_szID));

    // Load properties from the registry
    CHECKHR(hr = PropUtil_HrLoadContainerFromRegistry(hkeyAccount, m_pContainer));

    // this is done to initialize m_AcctType
    // TODO: is there a better way to handle this????
    CHECKHR(hr = GetServerTypes(&m_dwSrvTypes));

    // Save ID
    m_pContainer->SetProp(AP_ACCOUNT_ID, (LPBYTE)pszID, lstrlen(pszID) + 1);

    hr = GetPropSz(AP_ACCOUNT_NAME, m_szName, ARRAYSIZE(m_szName));
    if (hr == E_NoPropData)
        {
        StrCpyN(m_szName, pszID, ARRAYSIZE(m_szName));
        cb = lstrlen(pszID) + 1;
        RegSetValueEx(hkeyAccount, "Account Name", 0, REG_SZ, (LPBYTE)pszID, cb);
        hr = m_pContainer->SetProp(AP_ACCOUNT_NAME, (LPBYTE)pszID, cb);
        }

    // It exist
    m_fAccountExist = TRUE;

exit:
    if (hkeyAccount != NULL)
        RegCloseKey(hkeyAccount);

    m_pContainer->LeaveLoadContainer();

    return hr;
    }

HRESULT CAccount::ValidProp(DWORD dwPropTag)
    {
    HRESULT hr = E_INVALIDARG;

    if (m_AcctType == ACCT_UNDEFINED)
        return(S_OK);

    Assert(m_AcctType >= 0 && m_AcctType < ACCT_LAST);

    if (dwPropTag >= AP_ACCOUNT_FIRST && dwPropTag <= AP_ACCOUNT_LAST)
        {
        hr = S_OK;
        }
    else if (m_AcctType == ACCT_NEWS)
        {
        if (dwPropTag >= AP_NNTP_FIRST && dwPropTag <= AP_NNTP_LAST)
            hr = S_OK;
        }
    else if (m_AcctType == ACCT_MAIL)
        {
        if ((dwPropTag >= AP_IMAP_FIRST && dwPropTag <= AP_IMAP_LAST) ||
            (dwPropTag >= AP_SMTP_FIRST && dwPropTag <= AP_SMTP_LAST) ||
            (dwPropTag >= AP_POP3_FIRST && dwPropTag <= AP_POP3_LAST) ||
            (dwPropTag >= AP_HTTPMAIL_FIRST && dwPropTag <= AP_HTTPMAIL_LAST))
            hr = S_OK;
        }
    else if (m_AcctType == ACCT_DIR_SERV)
        {
        if (dwPropTag >= AP_LDAP_FIRST && dwPropTag <= AP_LDAP_LAST)
            hr = S_OK;
        }

    return(hr);
    }

// -----------------------------------------------------------------------------
// CAccount::GetProp (CPropertyContainer)
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::GetProp(DWORD dwPropTag, LPBYTE pb, ULONG *pcb)
{
    // Locals
    HRESULT             hr;

    // Default Property fetcher
    if (!FAILED(hr = ValidProp(dwPropTag)))
        hr = m_pContainer->GetProp(dwPropTag, pb, pcb);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CAccount::GetPropDw
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::GetPropDw(DWORD dwPropTag, DWORD *pdw)
{
    ULONG cb = sizeof(DWORD);
    return GetProp(dwPropTag, (LPBYTE)pdw, &cb);
}

// -----------------------------------------------------------------------------
// CAccount::GetPropSz
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::GetPropSz(DWORD dwPropTag, LPSTR psz, ULONG cchMax)
{
    return GetProp(dwPropTag, (LPBYTE)psz, &cchMax);
}

// -----------------------------------------------------------------------------
// CAccount::SetProp
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::SetProp(DWORD dwPropTag, LPBYTE pb, ULONG cb)
{
    HRESULT hr;

    if (dwPropTag == AP_ACCOUNT_ID)
        return(E_INVALIDARG);

    if (!FAILED(hr = ValidProp(dwPropTag)))
        hr = m_pContainer->SetProp(dwPropTag, pb, cb);

    return(hr);
}

// -----------------------------------------------------------------------------
// CAccount::SetPropDw
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::SetPropDw(DWORD dwPropTag, DWORD dw)
{
    return SetProp(dwPropTag, (LPBYTE)&dw, sizeof(DWORD));
}

// -----------------------------------------------------------------------------
// CAccount::SetPropSz
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::SetPropSz(DWORD dwPropTag, LPSTR psz)
{
    HRESULT hr;

    if (psz == NULL)
        hr = SetProp(dwPropTag, NULL, 0);
    else
        hr = SetProp(dwPropTag, (LPBYTE)psz, lstrlen(psz)+1);

    return(hr);
}

// -----------------------------------------------------------------------------
// CAccount::SaveChanges (IPersistPropertyContainer)
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::SaveChanges()
{
    return(SaveChanges(TRUE));
}

STDMETHODIMP CAccount::WriteChanges()
{
    return(SaveChanges(FALSE));
}

STDMETHODIMP CAccount::SaveChanges(BOOL fSendNotify)
    {
    IImnAccount         *pAcct;
    TCHAR               szAccount[CCHMAX_ACCOUNT_NAME],
                        szID[CCHMAX_ACCOUNT_NAME];
    DWORD               dw, dwNotify, dwSrvTypes, dwLdapId;
    BOOL                fDup, fRename = FALSE;
    HRESULT             hr = S_OK;
    HKEY                hkeyAccount = NULL;
    ACTX                actx;
    BOOL                fPasswChanged = FALSE;
    
    if (!m_pContainer->FIsDirty())
        return(S_OK);

    dwSrvTypes = m_dwSrvTypes;
    dwLdapId = (DWORD)-1;
    fRename = FALSE;

    Assert(m_AcctType != ACCT_UNDEFINED);
    if (m_AcctType == ACCT_UNDEFINED)
        return(E_FAIL);

    // Lets get the friendly name
    hr = GetPropSz(AP_ACCOUNT_NAME, szAccount, sizeof(szAccount));
    if (FAILED(hr))
        {
        AssertSz(hr != E_NoPropData, "Someone forgot to set the friendly name.");
        return(E_FAIL);
        }

    if (m_AcctType == ACCT_DIR_SERV)
        {
        hr = GetPropDw(AP_LDAP_SERVER_ID, &dw);
        if (FAILED(hr) || dw == 0)
            CHECKHR(hr = m_pAcctMgr->GetNextLDAPServerID(0, &dwLdapId));
        }

    fRename = (m_fAccountExist && lstrcmpi(m_szName, szAccount) != 0);

    if (fRename || !m_fAccountExist)
        {
        // make sure that the name is unique
        hr = m_pAcctMgr->UniqueAccountName(szAccount, fRename ? m_szID : NULL);
        if (hr != S_OK)
            return(E_DuplicateAccountName);
        }

    // Determine notification type
    if (m_fAccountExist)
        {
        Assert(m_hkey != 0);
        Assert(*m_szKey != 0);

        dwNotify = AN_ACCOUNT_CHANGED;
        }
    else
        {
        Assert(m_hkey == 0);
        Assert(*m_szKey == 0);

        dwNotify = AN_ACCOUNT_ADDED;

        CHECKHR(hr = m_pAcctMgr->GetNextAccountID(szID, ARRAYSIZE(szID)));
        CHECKHR(hr = m_pContainer->SetProp(AP_ACCOUNT_ID, (LPBYTE)szID, lstrlen(szID) + 1));

        StrCpyN(m_szID, szID, ARRAYSIZE(m_szID));

        m_hkey = m_pAcctMgr->GetAcctHKey();
        wnsprintf(m_szKey, ARRAYSIZE(m_szKey), c_szPathFileFmt, m_pAcctMgr->GetAcctRegKey(), m_szID);
        }

    Assert(m_hkey != 0);
    Assert(*m_szKey != 0);

    if (RegCreateKeyEx(m_hkey, m_szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyAccount, &dw) != ERROR_SUCCESS)
        {
        hr = TRAPHR(E_RegCreateKeyFailed);
        goto exit;
        }

    // If account hadn't existed, the key should not have already existed
    Assert(m_fAccountExist || dw != REG_OPENED_EXISTING_KEY);

    if (dwLdapId != (DWORD)-1)    
        SetPropDw(AP_LDAP_SERVER_ID, dwLdapId);

    // Save to registry
    CHECKHR(hr = PropUtil_HrPersistContainerToRegistry(hkeyAccount, m_pContainer, &fPasswChanged));

    CHECKHR(hr = GetServerTypes(&m_dwSrvTypes));

    if(fPasswChanged && m_pAcctMgr->FOutlook())
    {
        // Outlook98 & OE5 problem (bug OE:66724, O2K - 227741)
        if(m_dwSrvTypes & SRV_POP3)
            SetPropDw(AP_POP3_PROMPT_PASSWORD, 0);
        else if(m_dwSrvTypes & SRV_IMAP)
            SetPropDw(AP_IMAP_PROMPT_PASSWORD, 0);
        else if(m_dwSrvTypes & SRV_SMTP)
            SetPropDw(AP_SMTP_PROMPT_PASSWORD, 0);
        else if(m_dwSrvTypes & SRV_NNTP)
            SetPropDw(AP_NNTP_PROMPT_PASSWORD, 0);
        else
            goto tooStrange;

        CHECKHR(hr = PropUtil_HrPersistContainerToRegistry(hkeyAccount, m_pContainer, &fPasswChanged));
    }

tooStrange:
    RegCloseKey(hkeyAccount);
    hkeyAccount = NULL;

    // Send notification
    ZeroMemory(&actx, sizeof(actx));
    actx.AcctType = m_AcctType;
    actx.pszAccountID = m_szID;
    actx.dwServerType = m_dwSrvTypes;
    actx.pszOldName = fRename ? m_szName : NULL;
    if(fSendNotify)
        AcctUtil_PostNotification(dwNotify, &actx);

    if (dwNotify == AN_ACCOUNT_CHANGED)
        {
        Assert(m_dwSrvTypes != 0);
        Assert(dwSrvTypes != 0);
        // in all cases except httpmail, it is not legal for
        // server types to change. the legal case with httpmail
        // is the addition or removal of an smtp server
        Assert((m_dwSrvTypes == dwSrvTypes) ||
            (!!(m_dwSrvTypes & SRV_HTTPMAIL) && 
            ((m_dwSrvTypes & ~SRV_SMTP) == (dwSrvTypes & ~SRV_SMTP))));
        }

    StrCpyN(m_szName, szAccount, ARRAYSIZE(m_szName));

    // The account exist now
    m_fAccountExist = TRUE;

exit:
    if (hkeyAccount != NULL)
        RegCloseKey(hkeyAccount);

    return(hr);
    }

// RETURNS:
// S_OK = valid value for the specified property
// S_NonStandardValue = won't break anything but value doesn't look kosher
// E_InvalidValue = invalid value
// S_FALSE = property not supported for validation
STDMETHODIMP CAccount::ValidateProperty(DWORD dwPropTag, LPBYTE pb, ULONG cb)
    {
    DWORD cbT;
    HRESULT hr;

    if (pb == NULL)
        return(E_INVALIDARG);

    if (FAILED(hr = ValidProp(dwPropTag)))
        return(hr);

    hr = E_InvalidValue;

    switch (dwPropTag)
        {
        case AP_ACCOUNT_NAME:
            hr = AcctUtil_ValidAccountName((TCHAR *)pb);
            break;

        case AP_IMAP_SERVER:
        case AP_LDAP_SERVER:
        case AP_NNTP_SERVER:
        case AP_POP3_SERVER:
        case AP_SMTP_SERVER:
            hr = ValidServerName((TCHAR *)pb);
            break;

        case AP_NNTP_EMAIL_ADDRESS:
        case AP_NNTP_REPLY_EMAIL_ADDRESS:
        case AP_SMTP_EMAIL_ADDRESS:
        case AP_SMTP_REPLY_EMAIL_ADDRESS:
            hr = ValidEmailAddress((TCHAR *)pb);
            break;

        default:
            hr = S_FALSE;
            break;
        }

    return(hr);
    }

STDMETHODIMP CAccount::DoWizard(HWND hwnd, DWORD dwFlags)
    {
    return(IDoWizard(hwnd, NULL, dwFlags));
    }

STDMETHODIMP CAccount::DoImportWizard(HWND hwnd, CLSID clsid, DWORD dwFlags)
    {
    return(IDoWizard(hwnd, &clsid, dwFlags));
    }

HRESULT CAccount::IDoWizard(HWND hwnd, CLSID *pclsid, DWORD dwFlags)
    {
    HRESULT hr;
    CICWApprentice *pApp;

    if (m_fNoModifyAccts)
        return(S_FALSE);

    pApp = new CICWApprentice;
    if (pApp == NULL)
        return(E_OUTOFMEMORY);

    hr = pApp->Initialize(m_pAcctMgr, this);
    if (SUCCEEDED(hr))
        hr = pApp->DoWizard(hwnd, pclsid, dwFlags);

    pApp->Release();

    return(hr);
    }

// -----------------------------------------------------------------------------
// CEnumAccounts::CEnumAccounts
// -----------------------------------------------------------------------------
CEnumAccounts::CEnumAccounts(DWORD dwSrvTypes, DWORD dwFlags)
{
    m_cRef = 1;
    m_pAccounts = NULL;
    m_cAccounts = 0;
    m_iAccount = -1;
    m_dwSrvTypes = dwSrvTypes;
    m_dwFlags = dwFlags;
}

// -----------------------------------------------------------------------------
// CEnumAccounts::~CEnumAccounts
// -----------------------------------------------------------------------------
CEnumAccounts::~CEnumAccounts()
{
    AcctUtil_FreeAccounts(&m_pAccounts, &m_cAccounts);
}

// -----------------------------------------------------------------------------
// CEnumAccounts::QueryInterface
// -----------------------------------------------------------------------------
STDMETHODIMP CEnumAccounts::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IImnAccountManager
    if (IID_IImnEnumAccounts == riid)
        *ppv = (IImnEnumAccounts *)this;

    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // If not null, addref it and return
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TRAPHR(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CEnumAccounts::AddRef
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumAccounts::AddRef(VOID)
{
    return ++m_cRef;
}

// -----------------------------------------------------------------------------
// CEnumAccounts::Release
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumAccounts::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// -----------------------------------------------------------------------------
// CEnumAccounts::Init
// -----------------------------------------------------------------------------
HRESULT CEnumAccounts::Init(LPACCOUNT pAccounts, ULONG cAccounts)
    {
    // Locals
    ULONG           i, cAcctNew;
    LPACCOUNT       pAcctNew;
    HRESULT         hr=S_OK;

    // Check Params
    Assert(m_pAccounts == NULL);
    Assert(m_cAccounts == 0);
    AssertReadPtr(pAccounts, cAccounts);

    // We should really have this stuff
    if (pAccounts && cAccounts)
        {
        CHECKHR(hr = HrAlloc((LPVOID *)&pAcctNew, sizeof(ACCOUNT) * cAccounts));

        // Zero init
        ZeroMemory(pAcctNew, sizeof(ACCOUNT) * cAccounts);

        // AddRef all of the account objects
        cAcctNew = 0;
        for (i = 0; i < cAccounts; i++)
            {
            Assert(pAccounts[i].pAccountObject != NULL);

            if (!FEnumerateAccount(&pAccounts[i]))
                {
                // we're not interested in this account
                continue;
                }

            // AddRef the account about object
            CopyMemory(&pAcctNew[cAcctNew], &pAccounts[i], sizeof(ACCOUNT));
            pAcctNew[cAcctNew].pAccountObject->AddRef();
            cAcctNew++;
            }

        if (cAcctNew == 0)
            {
            MemFree(pAcctNew);
            }
        else
            {
            m_pAccounts = pAcctNew;
            m_cAccounts = cAcctNew;
            AssertReadPtr(m_pAccounts, m_cAccounts);

            if (!!(m_dwFlags & (ENUM_FLAG_SORT_BY_NAME | ENUM_FLAG_SORT_BY_LDAP_ID)))
                QSort(0, m_cAccounts - 1);
            }
        }

exit:
    // Done
    return hr;
    }

// -----------------------------------------------------------------------------
// CEnumAccounts::GetCount
// -----------------------------------------------------------------------------
STDMETHODIMP CEnumAccounts::GetCount(ULONG *pcItems)
    {
    HRESULT hr;

    // Check Params
    if (pcItems == NULL)
        {
        hr = TRAPHR(E_INVALIDARG);
        return(hr);
        }

    Assert((m_cAccounts == 0) ? (m_pAccounts == NULL) : (m_pAccounts != NULL));

    // Set Count
    *pcItems = m_cAccounts;

    return(S_OK);
    }

// -----------------------------------------------------------------------------
// CEnumAccounts::SortByAccountName
// -----------------------------------------------------------------------------
STDMETHODIMP CEnumAccounts::SortByAccountName(VOID)
{
    if (m_cAccounts > 0)
        {
        Assert(m_pAccounts != NULL);

        // qsort the list
        QSort(0, m_cAccounts-1);
        }

    // Done
    return(S_OK);
}

inline int CompareAccounts(ACCOUNT *pAcct1, ACCOUNT *pAcct2, DWORD dwFlags)
{
    TCHAR sz1[CCHMAX_ACCOUNT_NAME], sz2[CCHMAX_ACCOUNT_NAME];

    if (!!(dwFlags & ENUM_FLAG_SORT_BY_LDAP_ID))
    {
        Assert(pAcct1->AcctType == ACCT_DIR_SERV);
        Assert(pAcct2->AcctType == ACCT_DIR_SERV);
        if (pAcct1->dwServerId == pAcct2->dwServerId)
        {
            return(lstrcmp(pAcct1->szID, pAcct2->szID));
        }
        else
        {
            if (pAcct1->dwServerId == 0)
                return(1);
            else if (pAcct2->dwServerId == 0)
                return(-1);
            else
                return((int)(pAcct1->dwServerId) - (int)(pAcct2->dwServerId));
        }
    }
    else
    {
        pAcct1->pAccountObject->GetPropSz(AP_ACCOUNT_NAME, sz1, ARRAYSIZE(sz1));
        pAcct2->pAccountObject->GetPropSz(AP_ACCOUNT_NAME, sz2, ARRAYSIZE(sz2));

        return(lstrcmpi(sz1, sz2));
    }
}

// -----------------------------------------------------------------------------
// CEnumAccounts::QSort - used to sort the array of accounts
// -----------------------------------------------------------------------------
VOID CEnumAccounts::QSort(LONG left, LONG right)
{
    register    long i, j;
    ACCOUNT     *k, y;

    i = left;
    j = right;
    k = &m_pAccounts[(left + right) / 2];

    do
    {
        while (CompareAccounts(&m_pAccounts[i], k, m_dwFlags) < 0 && i < right) 
            i++;
        while (CompareAccounts(&m_pAccounts[j], k, m_dwFlags) > 0 && j > left) 
            j--;

        if (i <= j)
        {
            CopyMemory(&y, &m_pAccounts[i], sizeof(ACCOUNT));
            CopyMemory(&m_pAccounts[i], &m_pAccounts[j], sizeof(ACCOUNT));
            CopyMemory(&m_pAccounts[j], &y, sizeof(ACCOUNT));
            i++; j--;
        }

    } while (i <= j);

    if (left < j)
        QSort(left, j);
    if (i < right)
        QSort(i, right);
}

BOOL CEnumAccounts::FEnumerateAccount(LPACCOUNT pAccount)
    {
    HRESULT hr;
    DWORD dw;

    Assert(pAccount != NULL);

    if (pAccount->dwSrvTypes & m_dwSrvTypes)
        {                                         
        // I hope there is an object
        Assert(pAccount->pAccountObject != NULL);

        if (!!(m_dwFlags & ENUM_FLAG_NO_IMAP) &&
            !!(pAccount->dwSrvTypes & SRV_IMAP))
            return(FALSE);
        if (!!(m_dwFlags & ENUM_FLAG_RESOLVE_ONLY) &&
            pAccount->AcctType == ACCT_DIR_SERV)
            {
            hr = pAccount->pAccountObject->GetPropDw(AP_LDAP_RESOLVE_FLAG, &dw);
            if (FAILED(hr))
                return(FALSE);
            if (dw == 0)
                return(FALSE);
            }

        if (SUCCEEDED(pAccount->pAccountObject->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dw)) && dw)
		{
			if(AcctUtil_HideHotmail())
				return(FALSE);
		}
        return(TRUE);
        }

    return(FALSE);
    }

// -----------------------------------------------------------------------------
// CEnumAccounts::GetNext
// -----------------------------------------------------------------------------
STDMETHODIMP CEnumAccounts::GetNext(IImnAccount **ppAccount)
    {
    HRESULT hr;

    // Bad Param
    if (ppAccount == NULL)
        {
        hr = TRAPHR(E_INVALIDARG);
        return(hr);
        }

    // No Data ?
    while (1)
        {
        m_iAccount++;

        // Are we done yet ?
        if (m_iAccount >= (LONG)m_cAccounts)
            return(E_EnumFinished);
                    
        m_pAccounts[m_iAccount].pAccountObject->AddRef();

        // Set return account - Could be NULL
        *ppAccount = m_pAccounts[m_iAccount].pAccountObject;

        // Done
        break;
        }

    return(S_OK);
    }

// -----------------------------------------------------------------------------
// CEnumAccounts::Reset
// -----------------------------------------------------------------------------
STDMETHODIMP CEnumAccounts::Reset(void)
{
    m_iAccount = -1;
    return S_OK;
}

// -----------------------------------------------------------------------------
// AcctUtil_ValidAccountName
// -----------------------------------------------------------------------------
HRESULT AcctUtil_ValidAccountName(LPTSTR pszAccount)
    {
    int         cbT;

    cbT = lstrlen(pszAccount);
    if (cbT == 0 ||
        cbT >= CCHMAX_ACCOUNT_NAME ||
        FIsEmptyA(pszAccount))
        {
        return(E_InvalidValue);
        }

    return(S_OK);
    }

VOID AcctUtil_FreeAccounts(LPACCOUNT *ppAccounts, ULONG *pcAccounts)
    {
    ULONG           i;

    Assert(ppAccounts && pcAccounts);

    // If there are accounts
    if (*ppAccounts != NULL)
        {
        // The counter better be positive
        for (i = 0; i < *pcAccounts; i++)
            {
            SafeRelease((*ppAccounts)[i].pAccountObject);
            }

        // Free the account array
        MemFree(*ppAccounts);
        *ppAccounts = NULL;
        }

    *pcAccounts = 0;
    }

HRESULT CAccountManager::SetDefaultAccount(ACCTTYPE AcctType, LPSTR szID, BOOL fNotify)
    {
    LPCSTR              psz;
    HRESULT             hr;
    ACTX                actx;
    HKEY                hReg;

    Assert(szID != NULL);

    hr = S_OK;

    switch (AcctType)
        {
        case ACCT_MAIL:
            psz = c_szDefaultMailAccount;
            break;

        case ACCT_NEWS:
            psz = c_szDefaultNewsAccount;
            break;

        case ACCT_DIR_SERV:
            psz = c_szDefaultLDAPAccount;
            break;

        default:
            Assert(FALSE);
            break;
        }

    if (RegCreateKeyEx(m_hkey, m_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hReg, NULL) != ERROR_SUCCESS)
        {
        hr = TRAPHR(E_RegCreateKeyFailed);
        }
    else
        {
        if (RegSetValueEx(hReg, psz, 0, REG_SZ, (LPBYTE)szID, lstrlen(szID) + 1) != ERROR_SUCCESS)
            {
            hr = TRAPHR(E_RegSetValueFailed);
            }
        else if (fNotify)
            {
            ZeroMemory(&actx, sizeof(actx));
            actx.AcctType = AcctType;
            actx.pszAccountID = szID;// the new default accountID
            AcctUtil_PostNotification(AN_DEFAULT_CHANGED, &actx);
            }

        RegCloseKey(hReg);
        }

    return(hr);
    }

HRESULT CAccountManager::DeleteAccount(LPSTR pszID, LPSTR pszName, ACCTTYPE AcctType, DWORD dwSrvTypes)
    {
    HKEY            hkeyReg;
    HRESULT         hr = S_OK;
    ACTX            actx;

    Assert(pszID != NULL);
    Assert(pszName != NULL);

    // Open / Create Reg Key
    if (RegOpenKeyEx(m_hkey, m_szRegAccts, 0, KEY_ALL_ACCESS, &hkeyReg) != ERROR_SUCCESS)
        return(E_RegOpenKeyFailed);

	ZeroMemory(&actx, sizeof(actx));
	actx.AcctType = AcctType;
	actx.pszAccountID = pszID;
    actx.pszOldName = pszName;
	actx.dwServerType = dwSrvTypes;
    AcctUtil_PostNotification(AN_ACCOUNT_PREDELETE, &actx);

    // Delete friendly name key
    if (RegDeleteKey(hkeyReg, pszID) != ERROR_SUCCESS)
        {
        AssertSz(FALSE, "Deleting an account that does not exist.");
        hr = TRAPHR(E_RegDeleteKeyFailed);
        }
    else
        {
		ZeroMemory(&actx, sizeof(actx));
		actx.AcctType = AcctType;
		actx.pszAccountID = pszID;
        actx.pszOldName = pszName;
		actx.dwServerType = dwSrvTypes;
        AcctUtil_PostNotification(AN_ACCOUNT_DELETED, &actx);
        }

    RegCloseKey(hkeyReg);

    return(hr);
    }

// -----------------------------------------------------------------------------
// AcctUtil_PostNotification
// -----------------------------------------------------------------------------
VOID AcctUtil_PostNotification(DWORD dwAN, ACTX* pactx)
{
    // Thread Safety
    EnterCriticalSection(&g_csAcctMan);

    // Immediately update global pAcctMan
    if (g_pAcctMan)
        g_pAcctMan->Advise(dwAN, pactx);

    // Thread Safety
    LeaveCriticalSection(&g_csAcctMan);

    // Post a notification to other processes
    if (g_uMsgAcctManNotify)
    {
        // Tell other processes
        PostMessage(HWND_BROADCAST, g_uMsgAcctManNotify, dwAN, GetCurrentProcessId());
    }
}

HRESULT CAccountManager::GetNextLDAPServerID(DWORD dwSet, DWORD *pdwId)
    {
    DWORD dwNextID, dwType, cb;
    HKEY hKey;
    HRESULT hr;

    Assert(pdwId != NULL);

    hr = E_FAIL;

    // Open the WAB's reg key
    if (ERROR_SUCCESS == RegOpenKeyEx(m_hkey, m_szRegRoot, 0, KEY_ALL_ACCESS, &hKey))
        {
        dwNextID = 0;   // init in case registry gives < 4 bytes.

        if (dwSet)
            {
            dwNextID = dwSet;
            }
        else
            {
            // Read the next available server id
            cb = sizeof(DWORD);
            if (ERROR_SUCCESS != RegQueryValueEx(hKey, c_szRegServerID, NULL, &dwType, (LPBYTE)&dwNextID, &cb))
                {
                RegCloseKey(hKey);
                return(E_FAIL);
                }
            }

        *pdwId = dwNextID++;

        // Update the ID in the registry
        if (ERROR_SUCCESS == RegSetValueEx(hKey, c_szRegServerID, 0, REG_DWORD, (LPBYTE)&dwNextID, sizeof(DWORD)))
            hr = S_OK;

        RegCloseKey(hKey);
        }

    return(hr);
    }

HRESULT CAccountManager::GetNextAccountID(LPTSTR pszAccount, int cch)
    {
    DWORD dwID, dwNextID, dwType, cb;
    HKEY hKey;
    HRESULT hr;

    Assert(pszAccount != NULL);

    hr = E_FAIL;

    if (ERROR_SUCCESS == RegOpenKeyEx(m_hkey, m_szRegRoot, 0, KEY_ALL_ACCESS, &hKey))
        {
        // Read the next available server id
        cb = sizeof(DWORD);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, c_szRegAccountName, NULL, &dwType, (LPBYTE)&dwNextID, &cb))
            dwNextID = 1;

        dwID = dwNextID++;

        // Update the ID in the registry
        if (ERROR_SUCCESS == RegSetValueEx(hKey, c_szRegAccountName, 0, REG_DWORD, (LPBYTE)&dwNextID, sizeof(DWORD)))
            {
            wnsprintf(pszAccount, cch, "%08lx", dwID);
            hr = S_OK;
            }

        RegCloseKey(hKey);
        }

    return(hr);
    }

HRESULT CAccountManager::UniqueAccountName(char *szName, char *szID)
    {
    HRESULT         hr=S_OK;
    char            szT[CCHMAX_ACCOUNT_NAME];
    ACCOUNT         *pAcct;
    ULONG           i;

    Assert(szName != NULL);

    EnterCriticalSection(&m_cs);

    for (i = 0, pAcct = m_pAccounts; i < m_cAccounts; i++, pAcct++)
        {
        // We should have an account object, but if not
        Assert(pAcct->pAccountObject != NULL);

        if (szID == NULL || (0 != lstrcmpi(pAcct->szID, szID)))
            {
            hr = pAcct->pAccountObject->GetPropSz(AP_ACCOUNT_NAME, szT, ARRAYSIZE(szT));
            Assert(!FAILED(hr));

            if (0 == lstrcmpi(szT, szName))
                {
                hr = S_FALSE;
                goto exit;
                }
            }
        }

    hr = S_OK;

exit:
    LeaveCriticalSection(&m_cs);
    return(hr);
    }

const static char c_szNumFmt[] = " (%d)";

HRESULT CAccountManager::GetUniqueAccountName(char *szName, UINT cchMax)
    {
    char *sz;
    HRESULT hr;
    char szAcct[CCHMAX_ACCOUNT_NAME + 8];
    UINT i, cch;

    Assert(szName != NULL);
    Assert(cchMax >= CCHMAX_ACCOUNT_NAME);

    hr = UniqueAccountName(szName, NULL);
    Assert(!FAILED(hr));
    if (hr == S_FALSE)
        {
        hr = E_FAIL;

        StrCpyN(szAcct, szName, ARRAYSIZE(szAcct));
        cch = lstrlen(szAcct);
        sz = szAcct + cch;

        for (i = 1; i < 999; i++)
            {
            wnsprintf(sz, ARRAYSIZE(szAcct) - cch, c_szNumFmt, i);
            if (S_OK == UniqueAccountName(szAcct, NULL))
                {
                UINT cch2 = lstrlen(szAcct);
                if (cch2 < cchMax)
                    {
                    StrCpyN(szName, szAcct, cchMax);
                    hr = S_OK;
                    break;
                    }
                }
            }
        }

    return(hr);
    }


#define OBFUSCATOR              0x14151875;

#define PROT_SIZEOF_HEADER      0x02    // 2 bytes in the header
#define PROT_SIZEOF_XORHEADER   (PROT_SIZEOF_HEADER+sizeof(DWORD))

#define PROT_VERSION_1          0x01

#define PROT_PASS_XOR           0x01
#define PROT_PASS_PST           0x02

static BOOL FDataIsValidV1(BYTE *pb)
{ return pb && pb[0] == PROT_VERSION_1 && (pb[1] == PROT_PASS_XOR || pb[1] == PROT_PASS_PST); }

static BOOL FDataIsPST(BYTE *pb)
{ return pb && pb[1] == PROT_PASS_PST; }

///////////////////////////////////////////////////////////////////////////
// 
// NOTE - The functions for encoding the user passwords really should not 
//        be here.  Unfortunately, they are not anywhere else so for now,
//        this is where they will stay.  They are defined as static since
//        other code should not rely on them staying here, particularly the 
//        XOR stuff.
//
///////////////////////////////////////////////////////////////////////////
// 
// XOR functions
//
///////////////////////////////////////////////////////////////////////////

static HRESULT _XOREncodeProp(const BLOB *const pClear, BLOB *const pEncoded)
{
    DWORD       dwSize;
    DWORD       last, last2;
    UNALIGNED DWORD *pdwCypher;
    DWORD       dex;
#ifdef _WIN64
	UNALIGNED	DWORD * pSize = NULL;
#endif

    pEncoded->cbSize = pClear->cbSize+PROT_SIZEOF_XORHEADER;
    if (!MemAlloc((LPVOID *)&pEncoded->pBlobData, pEncoded->cbSize + 6))
        return E_OUTOFMEMORY;
    
    // set up header data
    Assert(2 == PROT_SIZEOF_HEADER);
    pEncoded->pBlobData[0] = PROT_VERSION_1;
    pEncoded->pBlobData[1] = PROT_PASS_XOR;
	
#ifdef _WIN64
	pSize = (DWORD *) &(pEncoded->pBlobData[2]);
	*pSize = pClear->cbSize;
#else //_WIN64
    *((DWORD *)&(pEncoded->pBlobData[2])) = pClear->cbSize;
#endif

    // nevermind that the pointer is offset by the header size, this is
    // where we start to write out the modified password
    pdwCypher = (DWORD *)&(pEncoded->pBlobData[PROT_SIZEOF_XORHEADER]);

    dex = 0;
    last = OBFUSCATOR;                              // 0' = 0 ^ ob
    if (dwSize = pClear->cbSize / sizeof(DWORD))
        {
        // case where data is >= 4 bytes
        for (; dex < dwSize; dex++)
            {
            last2 = ((UNALIGNED DWORD *)pClear->pBlobData)[dex];  // 1 
            pdwCypher[dex] = last2 ^ last;              // 1' = 1 ^ 0
            last = last2;                   // save 1 for the 2 round
            }
        }

    // if we have bits left over
    // note that dwSize is computed now in bits
    if (dwSize = (pClear->cbSize % sizeof(DWORD))*8)
        {
        // need to not munge memory that isn't ours
        last >>= sizeof(DWORD)*8-dwSize;
        pdwCypher[dex] &= ((DWORD)-1) << dwSize;
        pdwCypher[dex] |=
            ((((DWORD *)pClear->pBlobData)[dex] & (((DWORD)-1) >> (sizeof(DWORD)*8-dwSize))) ^ last);
        }

    return S_OK;
}

static HRESULT _XORDecodeProp(const BLOB *const pEncoded, BLOB *const pClear)
{
    DWORD       dwSize;
    DWORD       last;
    UNALIGNED   DWORD     *pdwCypher;
    DWORD       dex;

    // we use CoTaskMemAlloc to be in line with the PST implementation
    pClear->cbSize = pEncoded->pBlobData[2];
    MemAlloc((void **)&pClear->pBlobData, pClear->cbSize);
    if (!pClear->pBlobData)
        return E_OUTOFMEMORY;
    
    // should have been tested by now
    Assert(FDataIsValidV1(pEncoded->pBlobData));
    Assert(!FDataIsPST(pEncoded->pBlobData));

    // nevermind that the pointer is offset by the header size, this is
    // where the password starts
    pdwCypher = (DWORD *)&(pEncoded->pBlobData[PROT_SIZEOF_XORHEADER]);

    dex = 0;
    last = OBFUSCATOR;
    if (dwSize = pClear->cbSize / sizeof(DWORD))
        {
        // case where data is >= 4 bytes
        for (; dex < dwSize; dex++)
            last = ((UNALIGNED DWORD *)pClear->pBlobData)[dex] = pdwCypher[dex] ^ last;
        }

    // if we have bits left over
    if (dwSize = (pClear->cbSize % sizeof(DWORD))*8)
        {
        // need to not munge memory that isn't ours
        last >>= sizeof(DWORD)*8-dwSize;
        ((DWORD *)pClear->pBlobData)[dex] &= ((DWORD)-1) << dwSize;
        ((DWORD *)pClear->pBlobData)[dex] |=
                ((pdwCypher[dex] & (((DWORD)-1) >> (sizeof(DWORD)*8-dwSize))) ^ last);
        }

    return S_OK;
}

/*
    EncodeUserPassword

    Encrypt the passed in password.  This encryption seems to
    add an extra 6 bytes on to the beginning of the data
    that it passes back, so we need to make sure that the 
    lpszPwd is large enough to hold a few extra characters.
    *cb should be different on return than it was when it 
    was passed in.

    Parameters:
    lpszPwd - on entry, a c string containing the password.
    on exit, it is the encrypted data, plus some header info.

    cb - the size of lpszPwd on entry and exit.  Note that it should
    include the trailing null, so "foo" would enter with *cb == 4.
*/
static void EncodeUserPassword(TCHAR *lpszPwd, ULONG *cb)
{
    HRESULT         hr;
    BLOB            blobClient;
    BLOB            blobProp;

    blobClient.pBlobData= (BYTE *)lpszPwd;
    blobClient.cbSize   = *cb;
    blobProp.pBlobData  = NULL;
    blobProp.cbSize     = 0;
    
    _XOREncodeProp(&blobClient, &blobProp);
    
    if (blobProp.pBlobData)
    {
        memcpy(lpszPwd, blobProp.pBlobData, blobProp.cbSize);
        *cb = blobProp.cbSize;
        MemFree(blobProp.pBlobData);
    }
}

/*
    DecodeUserPassword

    Decrypt the passed in data and return a password.  This 
    encryption seems to add an extra 6 bytes on to the beginning 
    so decrupting will result in a using less of lpszPwd.
    .
    *cb should be different on return than it was when it 
    was passed in.

    Parameters:
    lpszPwd - on entry, the encrypted password plus some 
    header info. 
    on exit, a c string containing the password.

    cb - the size of lpszPwd on entry and exit.  Note that it should
    include the trailing null, so "foo" would leave with *cb == 4.
*/
static void DecodeUserPassword(TCHAR *lpszPwd, ULONG *cb)
{
    HRESULT         hr;
    BLOB            blobClient;
    BLOB            blobProp;

    blobClient.pBlobData= (BYTE *)lpszPwd;
    blobClient.cbSize   = *cb;
    blobProp.pBlobData  = NULL;
    blobProp.cbSize     = 0;
    
    _XORDecodeProp(&blobClient, &blobProp);

    if (blobProp.pBlobData)
    {
        memcpy(lpszPwd, blobProp.pBlobData, blobProp.cbSize);
        lpszPwd[blobProp.cbSize] = 0;
        *cb = blobProp.cbSize;
        MemFree(blobProp.pBlobData);
    }
}


const static DWORD c_mpAcctFlag[ACCT_LAST] = {ACCT_FLAG_NEWS, ACCT_FLAG_MAIL, ACCT_FLAG_DIR_SERV};
static TCHAR    g_pszDir[MAX_PATH] = "";

const DWORD     g_dwFileVersion = 0x00050000;
const DWORD     g_dwFileIndicator = 'IAMf';
#define WRITEDATA(pbData, cSize)    (WriteFile(hFile, pbData, cSize, &dwWritten, NULL))
#define READDATA(pbData, cSize)    (ReadFile(hFile, pbData, cSize, &dwRead, NULL))
void Server_ExportServer(HWND hwndDlg)
{
    ACCTTYPE    type;
    BOOL        fDefault;
    TCHAR       szAccount[CCHMAX_ACCOUNT_NAME],
        szRes[255],
        szMsg[255 + CCHMAX_ACCOUNT_NAME];
    TCHAR       rgch[MAX_PATH] = {0};
    LV_ITEM     lvi;
    LV_FINDINFO lvfi;
    int         iItemToExport;
    IImnAccount *pAccount = NULL;
    HWND        hwndFocus;
    BYTE        pbBuffer[MAX_PATH];
    HWND        hwndList = GetDlgItem(hwndDlg, IDLV_MAIL_ACCOUNTS);
    HANDLE      hFile = NULL;
    
    LoadString(g_hInstRes, idsImportFileFilter, rgch, MAX_PATH);
    ReplaceChars (rgch, _T('|'), _T('\0'));
    
    // Get the selected item to know which server the user wants to export
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVIS_SELECTED);
    lvi.iSubItem = 0;
    lvi.pszText = szAccount;
    lvi.cchTextMax = ARRAYSIZE(szAccount);
    if (ListView_GetItem(hwndList, &lvi))
    {    
        // Remember item to export
        iItemToExport = lvi.iItem;
        type = (ACCTTYPE)LOWORD(lvi.lParam);
        
        // Open the account
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
        {
            fDefault = (SUCCEEDED(g_pAcctMan->GetDefaultAccountName(type, szMsg, ARRAYSIZE(szMsg))) &&
                0 == lstrcmpi(szMsg, szAccount));
            
            hwndFocus = GetFocus();
            
            OPENFILENAME    ofn;
            TCHAR           szFile[MAX_PATH];
            TCHAR           szTitle[MAX_PATH];
            TCHAR           szDefExt[30];
            DWORD           nExtLen = 0;
            DWORD           nExtStart = 0;

            nExtLen = 1 + LoadString(g_hInstRes, idsExportFileExt, szDefExt, ARRAYSIZE(szDefExt)); // 1 for NULL
            LoadString(g_hInstRes, idsExport, szTitle, ARRAYSIZE(szTitle));
            
            // Try to suggest a reasonable name
            StrCpyN(szFile, szAccount, ARRAYSIZE(szFile));
            nExtStart = CleanupFileNameInPlaceA(CP_ACP, szFile);
            // Always cram the extension on the end
            Assert(ARRAYSIZE(szFile) >= ARRAYSIZE(szDefExt));
            DWORD cchIndex = (nExtStart < (ARRAYSIZE(szFile) - nExtLen)) ? nExtStart : (DWORD)(ARRAYSIZE(szFile) - nExtLen);
            StrCpyN(&szFile[cchIndex], szDefExt, ARRAYSIZE(szFile) - cchIndex);

            ZeroMemory (&ofn, sizeof (ofn));
            ofn.lStructSize = sizeof (ofn);
            ofn.hwndOwner = hwndDlg;
            ofn.lpstrFilter = rgch;
            ofn.nFilterIndex = 1;
            ofn.lpstrFile = szFile;
            ofn.lpstrInitialDir = (*g_pszDir ? g_pszDir : NULL);
            ofn.nMaxFile = sizeof (szFile);
            ofn.lpstrTitle = szTitle;
            ofn.lpstrDefExt = szDefExt;
            ofn.Flags = OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT;
            
            if (*szFile==NULL)
                goto exit;
            
            // Show OpenFile Dialog
            if (!GetSaveFileName(&ofn))
                goto exit;
            
            hFile = CreateFile(szFile, GENERIC_WRITE, 0, NULL, 
                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
            
            if (INVALID_HANDLE_VALUE == hFile)
                goto exit;
            
            *g_pszDir = 0;

            // store the last path
            StrCpyN(g_pszDir, ofn.lpstrFile, ARRAYSIZE(g_pszDir));
            if (!PathIsDirectoryA(g_pszDir))
                PathRemoveFileSpecA(g_pszDir);


            DWORD   dwIndex, dwWritten;
            
            WRITEDATA(&g_dwFileIndicator, sizeof(DWORD));
            WRITEDATA(&g_dwFileVersion, sizeof(DWORD));
            WRITEDATA(&type, sizeof(ACCTTYPE));
            
            for (dwIndex = 0; dwIndex < NUM_ACCT_PROPS; dwIndex++)
            {
                ULONG   cb = MAX_PATH;
                
                if (SUCCEEDED(pAccount->GetProp(g_rgAcctPropSet[dwIndex].dwPropTag, pbBuffer, &cb)))
                {
                    switch (g_rgAcctPropSet[dwIndex].dwPropTag)
                    {
                        case AP_SMTP_PASSWORD:
                        case AP_LDAP_PASSWORD:
                        case AP_NNTP_PASSWORD:
                        case AP_IMAP_PASSWORD:
                        case AP_POP3_PASSWORD:
                        case AP_HTTPMAIL_PASSWORD:
                            EncodeUserPassword((TCHAR *)pbBuffer, &cb);
                            break;
                    }
                    //write out the id, the size and the data
                    WRITEDATA(&g_rgAcctPropSet[dwIndex].dwPropTag, sizeof(DWORD));
                    WRITEDATA(&cb, sizeof(DWORD));
                    WRITEDATA(pbBuffer, cb);
                }
            }
        }        
    }
    
exit:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    
    if (pAccount)
        pAccount->Release();
}


void Server_ImportServer(HWND hwndDlg, ACCTDLGINFO *pinfo)
{
    OPENFILENAME    ofn;
    TCHAR           szOpenFileName[MAX_PATH]    = {0};
    TCHAR           rgch[MAX_PATH]              = {0};
    TCHAR           szDir[MAX_PATH]             = {0};
    TCHAR           szTitle[MAX_PATH]           = {0};
    HRESULT         hr                          = S_FALSE;
    HANDLE          hFile                       = INVALID_HANDLE_VALUE;
    IImnAccount    *pAccount                    = NULL;
    DWORD           dwVersion, dwRead;
    BOOL            fOK;
    ACCTTYPE        type;
    BYTE            pbBuffer[MAX_PATH];
    TC_ITEM         tci;
    int             nIndex;
    DWORD           dwAcctFlags, dw;
    HWND            hwndTab                     = GetDlgItem(hwndDlg, IDB_MACCT_TAB);
    HWND            hwndList                    = GetDlgItem(hwndDlg, IDLV_MAIL_ACCOUNTS);
    
    ZeroMemory(&ofn, sizeof(OPENFILENAME));
    LoadString(g_hInstRes, idsImportFileFilter, rgch, MAX_PATH);
    ReplaceChars (rgch, _T('|'), _T('\0'));
    *szOpenFileName ='\0';
    
    LoadString(g_hInstRes, idsImport, szTitle, MAX_PATH);
    
    ofn.lStructSize     = sizeof(OPENFILENAME);
    ofn.hwndOwner       = hwndDlg;
    ofn.hInstance       = g_hInst;
    ofn.lpstrFilter     = rgch;
    ofn.nFilterIndex    = 1;
    ofn.lpstrFile       = szOpenFileName;
    ofn.nMaxFile        = MAX_PATH;
    ofn.lpstrInitialDir = (*g_pszDir ? g_pszDir : NULL);
    ofn.lpstrTitle      = szTitle;
    ofn.Flags           = OFN_EXPLORER |
        OFN_HIDEREADONLY |
        OFN_FILEMUSTEXIST |
        OFN_NODEREFERENCELINKS|
        OFN_NOCHANGEDIR;
    
    if(GetOpenFileName(&ofn))
    {
        hFile = CreateFile(szOpenFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        
        *g_pszDir = 0;

        // store the last path
        StrCpyN(g_pszDir, ofn.lpstrFile, ARRAYSIZE(g_pszDir));
        if (!PathIsDirectoryA(g_pszDir))
            PathRemoveFileSpecA(g_pszDir);

        if (INVALID_HANDLE_VALUE == hFile)
            goto exit;
        
        // make sure its the right file type by checking the 
        // DWORD at the start of the file
        fOK = READDATA(&dwVersion, sizeof(DWORD));
        
        Assert(fOK);
        if (!fOK || g_dwFileIndicator != dwVersion)
            goto error;
        
        // Now check the version to see if the major version has changed
        fOK = READDATA(&dwVersion, sizeof(DWORD));
        Assert(fOK);
        if (!fOK || g_dwFileVersion < (dwVersion & 0xffff0000))
            goto error;
        
        // read the account type
        fOK = READDATA(&type, sizeof(ACCTTYPE));
        Assert(fOK);
        
        if (!fOK)
            goto error;
        
        if (FAILED(hr = g_pAcctMan->CreateAccountObject(type, &pAccount)) || (NULL == pAccount))
        {
            Assert(SUCCEEDED(hr) && (NULL != pAccount));
            goto error;
        }
        
        while (TRUE)
        {
            DWORD   dwPropId, dwSize;
            
            fOK = READDATA(&dwPropId, sizeof(DWORD));
            if (!fOK || dwRead != sizeof(DWORD))
                break;
            
            fOK = READDATA(&dwSize, sizeof(DWORD));
            if (!fOK || dwRead != sizeof(DWORD))
                break;
            
            if (dwSize > sizeof(pbBuffer)/sizeof(pbBuffer[0]))
                goto error;
            fOK = READDATA(pbBuffer, dwSize);
            Assert(fOK && dwRead == dwSize);
            if (!fOK || dwRead != dwSize)
                goto error;
            
            // don't write the old account id in
            if (dwPropId == AP_ACCOUNT_ID)
                continue;

            switch (dwPropId)
            {
                case AP_SMTP_PASSWORD:
                case AP_LDAP_PASSWORD:
                case AP_NNTP_PASSWORD:
                case AP_IMAP_PASSWORD:
                case AP_POP3_PASSWORD:
                case AP_HTTPMAIL_PASSWORD:
                    DecodeUserPassword((TCHAR *)pbBuffer, &dwSize);
                    break;
            }

            if (FAILED(hr = pAccount->SetProp(dwPropId, pbBuffer, dwSize)))
            {
                Assert(FALSE);
                goto error;
            }  
        }
        
        hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, rgch, ARRAYSIZE(rgch));
        Assert(!FAILED(hr));
        
        if (FAILED(hr = pAccount->SaveChanges()))
            goto error;
        
        nIndex = TabCtrl_GetCurSel(hwndTab);
        tci.mask = TCIF_PARAM;
        if (nIndex >= 0 && TabCtrl_GetItem(hwndTab, nIndex, &tci))
        {
            dwAcctFlags = (DWORD)tci.lParam;
            if (0 == (dwAcctFlags & c_mpAcctFlag[type]))
            {
                // the current page doesn't show this type of account,
                // so we need to force a switch to the all tab
#ifdef DEBUG
                tci.mask = TCIF_PARAM;
                Assert(TabCtrl_GetItem(hwndTab, 0, &tci));
                Assert(!!((DWORD)(tci.lParam) & c_mpAcctFlag[type]));
#endif // DEBUG
                
                TabCtrl_SetCurSel(hwndTab, 0);
                Server_InitServerList(hwndDlg, hwndList, hwndTab, pinfo, rgch);
            }
            else
            {
                Server_FAddAccount(hwndList, pinfo, 0, pAccount, TRUE);
            }
        }
        
    }
    
    goto exit;
error:
    if (hr == E_DuplicateAccountName)
        AcctMessageBox(hwndDlg, MAKEINTRESOURCE(idsAccountManager), MAKEINTRESOURCE(idsErrAccountExists), NULL, MB_OK | MB_ICONEXCLAMATION);    
    else
        AcctMessageBox(hwndDlg, MAKEINTRESOURCE(idsAccountManager), MAKEINTRESOURCE(idsErrImportFailed), NULL, MB_OK | MB_ICONEXCLAMATION);    
    
exit:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    
    if (pAccount)
        pAccount->Release();
}



// -----------------------------------------------------------------------------
// AcctUtil_IsHTTPMailEnabled
// HTTPMail accounts can only be created and accessed when a special
// registry value exists. This limitation exists during development of
// OE 5.0, and will probably be removed for release.
// -----------------------------------------------------------------------------
BOOL AcctUtil_IsHTTPMailEnabled(void)
{
#ifdef NOHTTPMAIL
    return FALSE;
#else
    DWORD   cb, bEnabled = FALSE;
    HKEY    hkey = NULL;

    // open the OE5.0 key
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(bEnabled);
        RegQueryValueEx(hkey, c_szEnableHTTPMail, 0, NULL, (LPBYTE)&bEnabled, &cb);

        RegCloseKey(hkey);
    }

    return bEnabled;
#endif
}

// -----------------------------------------------------------------------------
// AcctUtil_HideHotmail
// The IEAK can be configured to hide all evidence of the MSN brand. When
// this is the case, we don't populate the ISP combo boxes with MSN domains.
// -----------------------------------------------------------------------------
BOOL AcctUtil_HideHotmail()
{
    int cch;
    DWORD dw, cb, type;
    char sz[8];

    cb = sizeof(dw);
    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegFlat, c_szRegDisableHotmail, &type, &dw, &cb) &&
        dw == 2)
        return(FALSE);

    cb = sizeof(dw);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szRegFlat, c_szRegDisableHotmail, &type, &dw, &cb) &&
        dw == 2)
        return(FALSE);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\agntnews.cpp ===
#include "pch.hxx"
#include <imnact.h>
#include <acctimp.h>
#include <dllmain.h>
#include <resource.h>
#include <AgntNews.h> // Forte Agent
#include "newimp.h"

ASSERTDATA

#define MEMCHUNK    512

CAgentAcctImport::CAgentAcctImport()
    {
    m_cRef = 1;
    m_fIni = FALSE;
    *m_szIni = 0;
    m_cInfo = 0;
    m_rgInfo = NULL;
    }

CAgentAcctImport::~CAgentAcctImport()
    {
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
    }

STDMETHODIMP CAgentAcctImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if ((IID_IUnknown == riid) || (IID_IAccountImport == riid))
		*ppv = (IAccountImport *)this;
	else if (IID_IAccountImport2 == riid)
		*ppv = (IAccountImport2 *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
    }

STDMETHODIMP_(ULONG) CAgentAcctImport::AddRef()
    {
    return(++m_cRef);
    }

STDMETHODIMP_(ULONG) CAgentAcctImport::Release()
    {
    if (--m_cRef == 0)
        {
        delete this;
        return(0);
        }

    return(m_cRef);
    }

const static char c_szRegAgnt[] = "Software\\Forte\\Agent\\Paths";
const static char c_szDefPath[] = "c:\\Agent\\Data\\Agent.ini";
const static char c_szRegIni[] = "IniFile";
const static char c_szRegUninstall[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Forte Agent";
const static char c_szRegString[] = "UninstallString";

HRESULT STDMETHODCALLTYPE CAgentAcctImport::AutoDetect(DWORD *pcAcct, DWORD dwFlags)
{
    HRESULT hr  =   S_OK;
    DWORD   cb  =   MAX_PATH, dwType;
    char    szUserName[MAX_PATH];
    char    szUserIniPath[MAX_PATH];
    char    szExpanded[MAX_PATH];
    char    szNewsServer[MAX_PATH];
    char    szIniPath[] = "Data\\Agent.ini";
    char    *psz;
    int     nCount = 0;
    HKEY    hkey;
    
    Assert(m_cInfo == 0);
    if (pcAcct == NULL)
        return(E_INVALIDARG);
    
    *pcAcct = 0;

    // FIRST CHECK FOR FORTE AGENT
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegAgnt, 0, KEY_ALL_ACCESS, &hkey))
    {
        cb = sizeof(szUserIniPath);
        if(ERROR_SUCCESS == RegQueryValueEx(hkey, c_szRegIni, NULL, &dwType, (LPBYTE)szUserIniPath, &cb ))
        {
            if (REG_EXPAND_SZ == dwType)
            {
                DWORD nReturn = ExpandEnvironmentStrings(szUserIniPath, szExpanded, ARRAYSIZE(szExpanded));
                if (nReturn && nReturn <= ARRAYSIZE(szExpanded))
                    psz = szExpanded;
                else
                    psz = szUserIniPath;
            }
            else
                psz = szUserIniPath;
            
            GetPrivateProfileString("Profile", "FullName", "Default User", szUserName, MAX_PATH, psz);
            if(GetPrivateProfileString("Servers", "NewsServer", "", szNewsServer, MAX_PATH, psz))
            {
                if (!MemAlloc((void **)&m_rgInfo, 1*sizeof(AGNTNEWSACCTINFO)))
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }
                m_rgInfo[m_cInfo].dwCookie = m_cInfo;
                StrCpyN(m_rgInfo[m_cInfo].szUserPath, psz, ARRAYSIZE(m_rgInfo[m_cInfo].szUserPath));
                StrCpyN(m_rgInfo[m_cInfo].szDisplay, szUserName, ARRAYSIZE(m_rgInfo[m_cInfo].szDisplay));
                m_cInfo++;
            }
        }
    }

    // IF FORTE AGENT IS NOT FOUND, CHECK FOR FREE AGENT.

    // CHECK THE DEFAULT PATH "C:\AGENT\DATA " FOR THE "AGENT.INI" FILE
    else if(GetPrivateProfileString("Servers", "NewsServer", "", szNewsServer, MAX_PATH, c_szDefPath)) 
    {
        if (!MemAlloc((void **)&m_rgInfo, 1*sizeof(AGNTNEWSACCTINFO)))
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        GetPrivateProfileString("Profile", "FullName", "Default User", szUserName, MAX_PATH, c_szDefPath);
        m_rgInfo[m_cInfo].dwCookie = m_cInfo;
        StrCpyN(m_rgInfo[m_cInfo].szUserPath, c_szDefPath, ARRAYSIZE(m_rgInfo[m_cInfo].szUserPath));
        StrCpyN(m_rgInfo[m_cInfo].szDisplay, szUserName, ARRAYSIZE(m_rgInfo[m_cInfo].szDisplay));
        m_cInfo++;
    }

    // ELSE THE WORKAROUND FOR GETTING THE FREE AGENT INSTALL PATH i.e. RETRIEVE THE (UN)INSTALLATION PATH FOR (FREE?)-AGENT FROM THE REGISTRY.
    else 
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegUninstall, 0, KEY_ALL_ACCESS, &hkey))
        {
            cb = sizeof(szUserIniPath);
            if(ERROR_SUCCESS == RegQueryValueEx(hkey, c_szRegString, NULL, &dwType, (LPBYTE)szUserIniPath, &cb ))
            {
                // $$$Review: [NAB] Seems like this would break if there were a space in the the dir name!
                
                while(szUserIniPath[nCount] != ' ')
                    nCount++;

                // Come back now.
                while(szUserIniPath[nCount] != '\\')
                    nCount--;

                nCount++;
                szUserIniPath[nCount] = '\0';
                StrCatBuff(szUserIniPath, szIniPath, ARRAYSIZE(szUserIniPath));

                if (REG_EXPAND_SZ == dwType)
                {
                    ExpandEnvironmentStrings(szUserIniPath, szExpanded, ARRAYSIZE(szExpanded));
                    psz = szExpanded;
                }
                else
                    psz = szUserIniPath;

                GetPrivateProfileString("Profile", "FullName", "Default User", szUserName, MAX_PATH, psz);
                if(GetPrivateProfileString("Servers", "NewsServer", "", szNewsServer, MAX_PATH, psz))
                {
                    if (!MemAlloc((void **)&m_rgInfo, 1*sizeof(AGNTNEWSACCTINFO)))
                    {
                        hr = E_OUTOFMEMORY;
                        goto done;
                    }
                    m_rgInfo[m_cInfo].dwCookie = m_cInfo;
                    StrCpyN(m_rgInfo[m_cInfo].szUserPath, psz, ARRAYSIZE(m_rgInfo[m_cInfo].szUserPath));
                    StrCpyN(m_rgInfo[m_cInfo].szDisplay, szUserName, ARRAYSIZE(m_rgInfo[m_cInfo].szDisplay));
                    m_cInfo++;
                }
            }
        }
    }

    if (hr == S_OK)
    {
        *pcAcct = m_cInfo;
    }
done:
    RegCloseKey(hkey);
    return(hr);
}

HRESULT STDMETHODCALLTYPE CAgentAcctImport::InitializeImport(HWND hwnd, DWORD_PTR dwCookie)
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CAgentAcctImport::EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum)
    {
    CEnumAGNTACCT *penum;
    HRESULT hr;

    if (ppEnum == NULL)
        return(E_INVALIDARG);

    *ppEnum = NULL;

    if (m_cInfo == 0)
        return(S_FALSE);
    Assert(m_rgInfo != NULL);

    penum = new CEnumAGNTACCT;
    if (penum == NULL)
        return(E_OUTOFMEMORY);

    hr = penum->Init(m_rgInfo, m_cInfo);
    if (FAILED(hr))
        {
        penum->Release();
        penum = NULL;
        }

    *ppEnum = penum;

    return(hr);
    }

HRESULT STDMETHODCALLTYPE CAgentAcctImport::GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct)
{
    HRESULT hr;

    if (pAcct == NULL)
        return(E_INVALIDARG);

    hr = IGetSettings(dwCookie, pAcct, NULL);

    return(hr);
}

HRESULT CAgentAcctImport::IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
{
    HRESULT hr;
    AGNTNEWSACCTINFO *pinfo;
    char szUserPrefs[AGNTSUSERROWS][AGNTSUSERCOLS];
    char sz[512];
    DWORD cb, type;
    DWORD dwNewsPort = 119;


    ZeroMemory((void*)&szUserPrefs[0], AGNTSUSERCOLS*AGNTSUSERROWS*sizeof(char));

    Assert(((int) dwCookie) >= 0 && dwCookie < (DWORD_PTR)m_cInfo);
    pinfo = &m_rgInfo[dwCookie];
    
    Assert(pinfo->dwCookie == dwCookie);

    hr = GetUserPrefs(pinfo->szUserPath, szUserPrefs);
   
    Assert(0 < lstrlen(szUserPrefs[0]));

    hr = pAcct->SetPropSz(AP_ACCOUNT_NAME, szUserPrefs[0]);
    if (FAILED(hr))
        return(hr);

    hr = pAcct->SetPropSz(AP_NNTP_SERVER, szUserPrefs[0]);
    Assert(!FAILED(hr));

    if(lstrcmp(szUserPrefs[1], "119"))
    {
        int Len = lstrlen(szUserPrefs[1]);
        if(Len)
        {
            // Convert the string to a dw.
            DWORD dwMult = 1;
            dwNewsPort = 0;
            while(Len)
            {
                Len--;
                dwNewsPort += ((int)szUserPrefs[1][Len] - 48)*dwMult;
                dwMult *= 10;
            }
        }
    }
    hr = pAcct->SetPropDw(AP_NNTP_PORT, dwNewsPort);
    Assert(!FAILED(hr));

    if(lstrlen(szUserPrefs[2]))
    {
        hr = pAcct->SetPropSz(AP_NNTP_DISPLAY_NAME, szUserPrefs[2]);
        Assert(!FAILED(hr));
    }

    if(lstrlen(szUserPrefs[3]))
    {
        hr = pAcct->SetPropSz(AP_NNTP_EMAIL_ADDRESS, szUserPrefs[3]);
        Assert(!FAILED(hr));
    }

    if (pInfo != NULL)
    {
        // TODO: can we do any better than this???
        pInfo->dwConnect = CONN_USE_DEFAULT;
    }
    
    return(S_OK);
}

HRESULT CAgentAcctImport::GetUserPrefs(char *szUserPath, char szUserPrefs[][AGNTSUSERCOLS])
{
    HRESULT hr  =   E_FAIL;
    DWORD dwResult = 0;
    
    if(!GetPrivateProfileString("Servers", "NewsServer", "News", szUserPrefs[0], AGNTSUSERCOLS, szUserPath))
        hr  = S_FALSE;

    if(!GetPrivateProfileString("Servers", "NNTPPort", "119", szUserPrefs[1], AGNTSUSERCOLS, szUserPath))
        hr  = S_FALSE;

    if(!GetPrivateProfileString("Profile", "FullName", "Default User", szUserPrefs[2], AGNTSUSERCOLS, szUserPath))
        hr  = S_FALSE;

    if(!GetPrivateProfileString("Profile", "EMailAddress", "", szUserPrefs[3], AGNTSUSERCOLS, szUserPath))
        hr  = S_FALSE;
    return hr;
}

HRESULT CAgentAcctImport::GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved)
{
    // We can ignore the first parameter as we have only one server.
    HRESULT hr = S_OK;
    char *pListGroups = NULL;
    char szFilePath[AGNTSUSERCOLS];
    int nCounter;
    
    Assert(pImp != NULL);
    
    StrCpyNA(szFilePath, m_rgInfo[0].szUserPath, ARRAYSIZE(szFilePath));
    nCounter = lstrlen(szFilePath);
    if (nCounter)
    {
        while (nCounter)
        {
            if (szFilePath[nCounter] == '\\')
            {
                szFilePath[nCounter] = '\0';
                break;
            }
            nCounter--;
        }
    }
    else
    {
        return S_FALSE;
    }

    if (!FAILED(GetSubListGroups(szFilePath, &pListGroups)))
    {
        if (!SUCCEEDED(pImp->ImportSubList(pListGroups)))
            hr = S_FALSE;
    }

    if (pListGroups != NULL)
        MemFree(pListGroups);
    
    return hr;
}

const static char c_szGroupFile[] = "Groups.dat";
const static char c_szBakupFile[] = "Grpdat.bak";


HRESULT CAgentAcctImport::GetSubListGroups(char *szHomeDir, char **ppListGroups)
{
    return(E_FAIL);
}

STDMETHODIMP CAgentAcctImport::GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
    {
    if (pAcct == NULL ||
        pInfo == NULL)
        return(E_INVALIDARG);
    
    return(IGetSettings(dwCookie, pAcct, pInfo));
    }

CEnumAGNTACCT::CEnumAGNTACCT()
    {
    m_cRef = 1;
    // m_iInfo
    m_cInfo = 0;
    m_rgInfo = NULL;
    }

CEnumAGNTACCT::~CEnumAGNTACCT()
    {
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
    }

STDMETHODIMP CEnumAGNTACCT::QueryInterface(REFIID riid, LPVOID *ppv)
    {

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
	else if (IID_IEnumIMPACCOUNTS == riid)
		*ppv = (IEnumIMPACCOUNTS *)this;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();
    else
        return(E_NOINTERFACE);

    return(S_OK);
    }

STDMETHODIMP_(ULONG) CEnumAGNTACCT::AddRef()
    {
    return(++m_cRef);
    }

STDMETHODIMP_(ULONG) CEnumAGNTACCT::Release()
    {
    if (--m_cRef == 0)
        {
        delete this;
        return(0);
        }

    return(m_cRef);
    }

HRESULT STDMETHODCALLTYPE CEnumAGNTACCT::Next(IMPACCOUNTINFO *pinfo)
    {
    if (pinfo == NULL)
        return(E_INVALIDARG);

    m_iInfo++;
    if ((UINT)m_iInfo >= m_cInfo)
        return(S_FALSE);

    Assert(m_rgInfo != NULL);

    pinfo->dwCookie = m_rgInfo[m_iInfo].dwCookie;
    pinfo->dwReserved = 0;
    StrCpyNA(pinfo->szDisplay, m_rgInfo[m_iInfo].szDisplay, ARRAYSIZE(pinfo->szDisplay));

    return(S_OK);
    }

HRESULT STDMETHODCALLTYPE CEnumAGNTACCT::Reset()
    {
    m_iInfo = -1;

    return(S_OK);
    }

HRESULT CEnumAGNTACCT::Init(AGNTNEWSACCTINFO *pinfo, int cinfo)
    {
    DWORD cb;

    Assert(pinfo != NULL);
    Assert(cinfo > 0);

    cb = cinfo * sizeof(AGNTNEWSACCTINFO);
    
    if (!MemAlloc((void **)&m_rgInfo, cb))
        return(E_OUTOFMEMORY);

    m_iInfo = -1;
    m_cInfo = cinfo;
    CopyMemory(m_rgInfo, pinfo, cb);

    return(S_OK);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\acctman.h ===
// -----------------------------------------------------------------------------
// A C C T M A N . H - Steven J. Bailey - 8/17/96
// -----------------------------------------------------------------------------
#ifndef __ACCTMAN_H
#define __ACCTMAN_H

// -----------------------------------------------------------------------------
// Depends On...
// -----------------------------------------------------------------------------
#include "ipropobj.h"
#include "imnact.h"

#define ACCT_UNDEFINED  ((ACCTTYPE)-1)

#define ICC_FLAGS (ICC_WIN95_CLASSES|ICC_NATIVEFNTCTL_CLASS)

class CAccountManager;

extern const int NUM_ACCT_PROPS;
extern const PROPINFO g_rgAcctPropSet[];

// -----------------------------------------------------------------------------
// CAccount
// -----------------------------------------------------------------------------
class CAccount : public IImnAccount
{
private:
    ULONG               m_cRef;
    CAccountManager    *m_pAcctMgr;
    BOOL                m_fAccountExist;
    DWORD               m_dwSrvTypes;
    ACCTTYPE            m_AcctType;
    TCHAR               m_szID[CCHMAX_ACCOUNT_NAME];
    TCHAR               m_szName[CCHMAX_ACCOUNT_NAME];
    CPropertyContainer *m_pContainer;
    BOOL                m_fNoModifyAccts;

    HKEY                m_hkey;
    char                m_szKey[MAX_PATH];

    HRESULT IDoWizard(HWND hwnd, CLSID *pclsid, DWORD dwFlags);

public:
    DWORD               m_dwDlgFlags;

    // -------------------------------------------------------------------------
    // Standard Object Stuff
    // -------------------------------------------------------------------------
    CAccount(ACCTTYPE AcctType);
    ~CAccount(void);

    // -------------------------------------------------------------------------
    // IUnknown Methods
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    void SetAccountType(ACCTTYPE AcctType);
    HRESULT ValidProp(DWORD dwPropTag);

    // -------------------------------------------------------------------------
    // HrInit - initializes the container
    // -------------------------------------------------------------------------
    HRESULT Init(CAccountManager *pAcctMgr, CPropertySet *pPropertySet);

    // -------------------------------------------------------------------------
    // HrOpen - Read properties from the registry
    // -------------------------------------------------------------------------
    STDMETHODIMP Open(HKEY hkey, LPCSTR pszAcctKey, LPCSTR pszAccount);

    // -------------------------------------------------------------------------
    // Is this a new account or does it already exist?
    // -------------------------------------------------------------------------
    STDMETHODIMP Exist(VOID);

    // -------------------------------------------------------------------------
    // Make default account for support server types
    // -------------------------------------------------------------------------
    STDMETHODIMP SetAsDefault(VOID);

    // -------------------------------------------------------------------------
    // Delete this account
    // -------------------------------------------------------------------------
    STDMETHODIMP Delete(VOID);

    STDMETHODIMP GetAccountType(ACCTTYPE *pAcctType);

    STDMETHODIMP GetServerTypes(DWORD *pdwSrvTypes);

    // -------------------------------------------------------------------------
    // Save the container
    // -------------------------------------------------------------------------
    STDMETHODIMP SaveChanges();
    STDMETHODIMP SaveChanges(BOOL fSendMsg);

    // -------------------------------------------------------------------------
    // Write changes, without sending notifications message
    // -------------------------------------------------------------------------
    STDMETHODIMP WriteChanges();

    // -------------------------------------------------------------------------
    // IPropertyContainer Implementation (GetProperty)
    // -------------------------------------------------------------------------
    STDMETHODIMP GetProp(DWORD dwPropTag, LPBYTE pb, ULONG *pcb);
    STDMETHODIMP GetPropDw(DWORD dwPropTag, DWORD *pdw);
    STDMETHODIMP GetPropSz(DWORD dwPropTag, LPSTR psz, ULONG cchMax);
    STDMETHODIMP SetProp(DWORD dwPropTag, LPBYTE pb, ULONG cb);
    STDMETHODIMP SetPropDw(DWORD dwPropTag, DWORD dw);
    STDMETHODIMP SetPropSz(DWORD dwPropTag, LPSTR psz);

    STDMETHODIMP ShowProperties(HWND hwnd, DWORD dwFlags);

    STDMETHODIMP ValidateProperty(DWORD dwPropTag, BYTE *pb, ULONG cb);

    STDMETHODIMP DoWizard(HWND hwnd, DWORD dwFlags);
    STDMETHODIMP DoImportWizard(HWND hwnd, CLSID clsid, DWORD dwFlags);
};

// -----------------------------------------------------------------------------
// ACCOUNT
// -----------------------------------------------------------------------------
typedef struct tagACCOUNT {

    TCHAR               szID[CCHMAX_ACCOUNT_NAME];
    ACCTTYPE            AcctType;
    DWORD               dwSrvTypes;
    DWORD               dwServerId;     // for LDAP only
    IImnAccount        *pAccountObject;

} ACCOUNT, *LPACCOUNT;

#define ENUM_FLAG_SORT_BY_NAME      0x0001
#define ENUM_FLAG_RESOLVE_ONLY      0x0002
#define ENUM_FLAG_SORT_BY_LDAP_ID   0x0004
#define ENUM_FLAG_NO_IMAP           0x0008

// -----------------------------------------------------------------------------
// CEnumAccounts
// -----------------------------------------------------------------------------
class CEnumAccounts : public IImnEnumAccounts
{
private:
    ULONG               m_cRef;             // Reference Counting
    LPACCOUNT           m_pAccounts;        // Array of accounts and Account Objects
    ULONG               m_cAccounts;        // Number of accounts in m_pAccounts array
    LONG                m_iAccount;         // Index of current account (-1 if at beginning)
    DWORD               m_dwSrvTypes;       // Used for enumerating servers of a specific type
    DWORD               m_dwFlags;

private:
    VOID QSort(LONG left, LONG right);
    BOOL FEnumerateAccount(LPACCOUNT pAccount);

public:
    // -------------------------------------------------------------------------
    // Standard Object Stuff
    // -------------------------------------------------------------------------
    CEnumAccounts(DWORD dwSrvTypes, DWORD dwFlags);
    ~CEnumAccounts();

    // -------------------------------------------------------------------------
    // IUnknown Methods
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // Init - Initialize the enumerator, i.e. duplicate the Accounts array
    // -------------------------------------------------------------------------
    HRESULT Init(LPACCOUNT pAccounts, ULONG cAccounts);

    // -------------------------------------------------------------------------
    // GetCount - Get the number of items that the enumerator will process
    // -------------------------------------------------------------------------
    STDMETHODIMP GetCount(ULONG *pcItems);

    // -------------------------------------------------------------------------
    // SortByAccountName - sorts the enumerated accounts by name
    // -------------------------------------------------------------------------
    STDMETHODIMP SortByAccountName(void);

    // -------------------------------------------------------------------------
    // GetNext - Get the first or next enumerated account
    // Returns hrEnumFinished (*ppAccount = NULL) when no more accounts to enumerate
    // -------------------------------------------------------------------------
    STDMETHODIMP GetNext(IImnAccount **ppAccount);

    // -------------------------------------------------------------------------
    // Reset - This is like rewinding the enumerator
    // -------------------------------------------------------------------------
    STDMETHODIMP Reset(void);
};

// -----------------------------------------------------------------------------
// ACCTINFO - Account Inforation
// -----------------------------------------------------------------------------
typedef struct tagACCTINFO {

    TCHAR               szDefaultID[CCHMAX_ACCOUNT_NAME];
    BOOL                fDefaultKnown;
    DWORD               cAccounts;
    LPTSTR              pszDefRegValue;
    LPTSTR              pszFirstAccount;

} ACCTINFO;

#define ADVISE_BLOCK_SIZE               (16)

#define ADVISE_COOKIE                   ((WORD)0xAD5E)
// Advise connections will be generated by masking in this cookie with the 
// index into the CAccountManager array where the advise is stored.
#define MAX_INDEX                       (INT)(0xFFFF)

#define INDEX_FROM_CONNECTION(conn)     (INT)(LOWORD(conn))
#define CONNECTION_FROM_INDEX(indx)     (MAKELONG(LOWORD(indx), ADVISE_COOKIE))
#define IS_VALID_CONNECTION(conn)       (ADVISE_COOKIE == HIWORD(conn))
#define IS_VALID_INDEX(indx)            (((indx)>=0)&&((indx)<=MAX_INDEX))


// -----------------------------------------------------------------------------
// CAccountManager
// -----------------------------------------------------------------------------
class CAccountManager : public IImnAccountManager2
{
private:
    ULONG               m_cRef;             // Reference Counting
    LPACCOUNT           m_pAccounts;        // Array of accounts and Account Objects
    ULONG               m_cAccounts;        // Number of accounts in m_pAccounts array
    CPropertySet       *m_pAcctPropSet;     // Base account property set used to create CAccount
    BOOL                m_fInit;            // Has the object been successfully initialized
    UINT                m_uMsgNotify;       // Account Manager global notification message (0 means not processing)
    ACCTINFO            m_rgAccountInfo[ACCT_LAST]; // Array of known account informtaion
    CRITICAL_SECTION    m_cs;               // Thread Safety
    IImnAdviseAccount **m_ppAdviseAccounts; // Client Account Advise Handlers
    INT                 m_cAdvisesAllocated;
    BOOL                m_fNoModifyAccts;
    BOOL                m_fInitCalled;      // Avoid duplicate initialization
    BOOL                m_fOutlook;

    HKEY                m_hkey;
    char                m_szRegRoot[MAX_PATH];
    char                m_szRegAccts[MAX_PATH];

    HRESULT IInit(IImnAdviseMigrateServer *pMigrateServerAdvise, HKEY hkey, LPCSTR pszSubKey, DWORD dwFlags);

    // -------------------------------------------------------------------------
    // Reloads accounts (m_pAccounts) array from the registry
    // -------------------------------------------------------------------------
    HRESULT LoadAccounts(VOID);

    // -------------------------------------------------------------------------
    // Loading Default Account Information
    // -------------------------------------------------------------------------
    VOID GetDefaultAccounts(VOID);

public:
    // -------------------------------------------------------------------------
    // Standard Object Stuff
    // -------------------------------------------------------------------------
    CAccountManager();
    ~CAccountManager();

    // -------------------------------------------------------------------------
    // IUnknown Methods
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // Initialization of this object (only call it once)
    // -------------------------------------------------------------------------
    STDMETHODIMP Init(IImnAdviseMigrateServer *pAdviseMigrateServer);
    STDMETHODIMP InitEx(IImnAdviseMigrateServer *pAdviseMigrateServer, DWORD dwFlags);
    STDMETHODIMP InitUser(IImnAdviseMigrateServer *pAdviseMigrateServer, REFGUID rguidID, DWORD dwFlags);

    // -------------------------------------------------------------------------
    // FProcessNotification - returns TRUE if window message was
    // processed as a notification
    // -------------------------------------------------------------------------
    STDMETHODIMP ProcessNotification(UINT uMsg, WPARAM wParam, LPARAM lParam);
    VOID Advise(DWORD dwAction, ACTX* pactx);

    // -------------------------------------------------------------------------
    // Creating Account Objects
    // -------------------------------------------------------------------------
    STDMETHODIMP CreateAccountObject(ACCTTYPE AcctType, IImnAccount **ppAccount);
    HRESULT ICreateAccountObject(ACCTTYPE AcctType, IImnAccount **ppAccount);

    HRESULT DeleteAccount(LPSTR pszID, LPSTR pszName, ACCTTYPE AcctType, DWORD dwSrvTypes);

    // -------------------------------------------------------------------------
    // Enumerators - Always returns connected accounts first
    // -------------------------------------------------------------------------
    STDMETHODIMP Enumerate(DWORD dwSrvTypes, IImnEnumAccounts **ppEnumAccounts);
    HRESULT IEnumerate(DWORD dwSrvTypes, DWORD dwFlags, IImnEnumAccounts **ppEnumAccounts);

    // -------------------------------------------------------------------------
    // GetServerCount
    // -------------------------------------------------------------------------
    STDMETHODIMP GetAccountCount(ACCTTYPE AcctType, ULONG *pcServers);

    // -------------------------------------------------------------------------
    // FindAccount - used to find accounts by unique properties
    // -------------------------------------------------------------------------
    STDMETHODIMP FindAccount(DWORD dwPropTag, LPCTSTR pszSearchData, IImnAccount **ppAccount);

    // -------------------------------------------------------------------------
    // GetDefaultAccount - Opens the default account for the account type
    // -------------------------------------------------------------------------
    STDMETHODIMP GetDefaultAccount(ACCTTYPE AcctType, IImnAccount **ppAccount);
    STDMETHODIMP GetDefaultAccountName(ACCTTYPE AcctType, LPTSTR pszAccount, ULONG cchMax);
    HRESULT SetDefaultAccount(ACCTTYPE AcctType, LPSTR pszID, BOOL fNotify);

    STDMETHODIMP GetIncompleteAccount(ACCTTYPE AcctType, LPSTR pszAccountId, ULONG cchMax);
    STDMETHODIMP SetIncompleteAccount(ACCTTYPE AcctType, LPCSTR pszAccountId);

    // I wrote this function because I support accounts without an SMTP server. This
    // functions verifies that the default Send account truly contains an SMTP server,
    // and if it doesn't, resets the default Send Account to an account that does have
    // an SMTP server.
    STDMETHODIMP ValidateDefaultSendAccount(VOID);

    STDMETHODIMP AccountListDialog(HWND hwnd, ACCTLISTINFO *pinfo);

    STDMETHODIMP Advise(IImnAdviseAccount *pAdviseAccount, DWORD* pdwConnection);
    STDMETHODIMP Unadvise(DWORD dwConnection);

    STDMETHODIMP GetUniqueAccountName(LPTSTR szName, UINT cch);

    void UpgradeAccountProps(void);

    HRESULT GetNextLDAPServerID(DWORD dwSet, DWORD *pdwId);
    HRESULT GetNextAccountID(TCHAR *szID, int cch);
    
    HRESULT UniqueAccountName(char *szName, char *szID);

    inline LPCSTR   GetAcctRegKey(void)  {return(m_szRegAccts);};
    inline HKEY     GetAcctHKey(void)    {return(m_hkey);};
    inline BOOL     FNoModifyAccts(void) {return(m_fNoModifyAccts);}
    inline BOOL     FOutlook(void)       {return(m_fOutlook);}   

};

#define CCH_USERNAME_MAX_LENGTH         63

typedef struct tagOEUSERINFO {

    DWORD               dwUserId;
    TCHAR               szUsername[CCH_USERNAME_MAX_LENGTH+1];

} OEUSERINFO;

// -----------------------------------------------------------------------------
// AcctUtil Prototypes
// -----------------------------------------------------------------------------
HRESULT AcctUtil_ValidAccountName(LPTSTR pszAccount);
VOID    AcctUtil_FreeAccounts(LPACCOUNT *ppAccounts, ULONG *pcAccounts);
HRESULT AcctUtil_HrSetAsDefault(IImnAccount *pAccount, LPCTSTR pszRegRoot);
BOOL    AcctUtil_IsHTTPMailEnabled(void);
BOOL    AcctUtil_HideHotmail();

#endif // __ACCTMAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\autodiscovery.cpp ===
/*****************************************************************************\
    FILE: AutoDiscovery.cpp

    DESCRIPTION:
        This is AutoDiscovery progress UI for the Outlook Express's email
    configuration wizard.

    BryanSt 1/18/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "pch.hxx"
#include <prsht.h>
#include <imnact.h>
#include <icwacct.h>
#include <acctimp.h>
#include "icwwiz.h"
#include "acctui.h"
#include "acctman.h"
#include <dllmain.h>
#include <resource.h>
#include "server.h"
#include "connect.h"
#include <Shlwapi.h>
#include "shlwapip.h"
#include "strconst.h"
#include "demand.h"
#include "hotwiz.h"
#include "shared.h"
#include <AutoDiscovery.h>
#include "AutoDiscoveryUI.h"

ASSERTDATA

#define RECTWIDTH(rect)                 (rect.right - rect.left)
#define RECTHEIGHT(rect)                (rect.bottom - rect.top)

#define MAX_URL_STRING                  2048
#define SIZE_STR_AUTODISC_DESC          2048

// These are the wizard control IDs for the Back, Next, and Finished buttons.
#define IDD_WIZARD_BACK_BUTTON                0x3023
#define IDD_WIZARD_NEXT_BUTTON                0x3024
#define IDD_WIZARD_FINISH_BUTTON              0x3025

#define SZ_DLL_AUTODISC                       TEXT("autodisc.dll")
#define IDA_DOWNLOADINGSETTINGS               801         // In autodisc.dll

#define ATOMICRELEASE(punk)         {if (punk) { punk->Release(); punk = NULL;} }

WCHAR g_szInfoURL[MAX_URL_STRING] = {0};
WCHAR g_szWebMailURL[MAX_URL_STRING] = {0};


typedef struct
{
    // Default Protocol (POP3, IMAP, DAV, WEB)
    int         nProtocol;                 // What is the email protocol? POP3 vs. IMAP vs. DAV vs. WEB
    BSTR        bstrDisplayName;           // What is the user's display name.
    BSTR        bstrServer1Name;           // What is the downloading email server name (POP3, IMAP, DAV, or WEB)
    int         nServer1Port;              // What is that server's port number?
    BSTR        bstrLoginName;             // What is the login name for the POP3 server. (Normall the same as the email address w/out the domain)
    BOOL        fUsesSSL;                  // Use SSL when connecting to the POP3 or IMAP server?
    BOOL        fUsesSPA;                  // Use SPA when connecting to the POP3 or IMAP server?

    // SMTP Protocol (If used)
    BSTR        bstrServer2Name;           // What is the uploading email server name (SMTP)
    int         nServer2Port;              // What is that server's port number?
    BOOL        fSMTPUsesSSL;              // Use SSL when connecting to the SMTP server?
    BOOL        fAuthSMTP;                 // Does SMTP need Authentication?
    BOOL        fAuthSMTPPOP;              // Use POP3's auth for SMTP?
    BOOL        fAuthSMTPSPA;              // Use SPA auth for SMTP?
    BOOL        fUseWebMail;               // Is Web Bassed mail the only protocol we recognizer?
    BSTR        bstrSMTPLoginName;         // What is the login name for the SMTP server.
    BOOL        fDisplayInfoURL;           // Is there an URL for Info about the email server/services?
    BSTR        bstrInfoURL;               // If fDisplayInfoURL, this is the URL.
} EMAIL_SERVER_SETTINGS;



class CICWApprentice;

/*****************************************************************************\
    Class: CAutoDiscoveryHelper

    DESCRIPTION:

    StartAutoDiscovery: 
        hwndParent: This is the caller's hwnd.  If we need to display UI, we
            will parent it off this hwnd.  We also send this hwnd messages on
            progress.
\*****************************************************************************/
class CAutoDiscoveryHelper
{
public:
    // Public Methods
    HRESULT StartAutoDiscovery(IN CICWApprentice *pApp, IN HWND hDlg, IN BOOL fFirstInit);
    HRESULT OnCompleted(IN CICWApprentice *pApp, IN ACCTDATA * pData);
    HRESULT SetNextButton(HWND hwndButton);
    HRESULT RestoreNextButton(HWND hwndButton);

    CAutoDiscoveryHelper();
    ~CAutoDiscoveryHelper(void);

private:
    // Private Member Variables
    // Other internal state.
    HWND        _hwndDlgParent;             // parent window for message boxes
    TCHAR       _szNextText[MAX_PATH];      // 
    IMailAutoDiscovery * _pMailAutoDiscovery; // 
    HINSTANCE   _hInstAutoDisc;             // We use this to get the animation

    // Private Member Functions
    HRESULT _GetAccountInformation(EMAIL_SERVER_SETTINGS * pEmailServerSettings);
};




CAutoDiscoveryHelper * g_pAutoDiscoveryObject = NULL;  // This is the AutoDisc obj used while downloading the settings.
BOOL g_fRequestCancelled = TRUE;
UINT g_uNextPage = ORD_PAGE_AD_MAILNAME;        // ORD_PAGE_AD_MAILNAME, ORD_PAGE_AD_MAILSERVER, ORD_PAGE_AD_USEWEBMAIL, ORD_PAGE_AD_GOTOSERVERINFO

//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT FreeEmailServerSettings(EMAIL_SERVER_SETTINGS * pEmailServerSettings)
{
    SysFreeString(pEmailServerSettings->bstrDisplayName);    // It's okay to pass NULL to this API
    SysFreeString(pEmailServerSettings->bstrServer1Name);
    SysFreeString(pEmailServerSettings->bstrLoginName);
    SysFreeString(pEmailServerSettings->bstrServer2Name);
    SysFreeString(pEmailServerSettings->bstrSMTPLoginName);
    SysFreeString(pEmailServerSettings->bstrInfoURL);

    return S_OK;
}


BSTR SysAllocStringA(LPCSTR pszStr)
{
    BSTR bstrOut = NULL;

    if (pszStr)
    {
        DWORD cchSize = (lstrlenA(pszStr) + 1);
        LPWSTR pwszThunkTemp = (LPWSTR) LocalAlloc(LPTR, (sizeof(pwszThunkTemp[0]) * cchSize));  // assumes INFOTIPSIZE number of chars max

        if (pwszThunkTemp)
        {
            SHAnsiToUnicode(pszStr, pwszThunkTemp, cchSize);
            bstrOut = SysAllocString(pwszThunkTemp);
            LocalFree(pwszThunkTemp);
        }
    }

    return bstrOut;
}


HRESULT ADRestoreNextButton(CICWApprentice *pApp, HWND hDlg)
{
    HRESULT hr = S_OK;

    g_fRequestCancelled = TRUE;
    if (g_pAutoDiscoveryObject)
    {
        g_pAutoDiscoveryObject->RestoreNextButton(GetDlgItem(GetParent(hDlg), IDD_WIZARD_NEXT_BUTTON));
        delete g_pAutoDiscoveryObject;
        g_pAutoDiscoveryObject = NULL;
    }

    return hr;
}

HRESULT CreateAccountName(IN CICWApprentice *pApp, IN ACCTDATA * pData);

HRESULT OnADCompleted(CICWApprentice *pApp, HWND hDlg)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (g_pAutoDiscoveryObject)
    {
        ACCTDATA * pData = pApp->GetAccountData();

        hr = g_pAutoDiscoveryObject->OnCompleted(pApp, pData);
        if (SUCCEEDED(hr))
        {
            // Set the display name for the account.
            CreateAccountName(pApp, pData);
        }
        else
        {
            // TODO: If _fUseWebMail is set, we will probably want
            //   to navigate to a page telling the user to use a web
            //   page to get their email.
        }
    }

    return hr;
}


#define SZ_HOTMAILDOMAIN                "@hotmail.com"
#define CH_EMAILDOMAINSEPARATOR         '@'

HRESULT CAutoDiscoveryHelper::StartAutoDiscovery(IN CICWApprentice *pApp, IN HWND hDlg, IN BOOL fFirstInit)
{
    HRESULT hr = E_OUTOFMEMORY;

    ACCTDATA * pData = pApp->GetAccountData();
    if (pData && pData->szEmail)
    {
        LPCSTR pszEmailDomain = StrChrA(pData->szEmail, CH_EMAILDOMAINSEPARATOR);
        if (pszEmailDomain && !StrCmpI(SZ_HOTMAILDOMAIN, pszEmailDomain))   // Is this a HOTMAIL.COM account?
        {
            // Yes, so skip AutoDiscovery since we don't require the user
            // to enter hard settings in that case. (Protocol and server settings never
            // change)
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        else
        {
            WCHAR szEmail[1024];

            SHAnsiToUnicode(pData->szEmail, szEmail, ARRAYSIZE(szEmail));
            _hwndDlgParent = hDlg;

            // Set Animation.
            HWND hwndAnimation = GetDlgItem(hDlg, IDC_AUTODISCOVERY_ANIMATION);
            if (hwndAnimation)
            {
                _hInstAutoDisc = LoadLibrary(SZ_DLL_AUTODISC);

                if (_hInstAutoDisc)
                {
                    Animate_OpenEx(hwndAnimation, _hInstAutoDisc, IDA_DOWNLOADINGSETTINGS);
                }
            }

            HWND hwndWizard = GetParent(hDlg);
            if (hwndWizard)
            {
                SetNextButton(GetDlgItem(hwndWizard, IDD_WIZARD_NEXT_BUTTON));
            }


            ATOMICRELEASE(_pMailAutoDiscovery);
            // Start the background task.
            hr = CoCreateInstance(CLSID_MailAutoDiscovery, NULL, CLSCTX_INPROC_SERVER, IID_IMailAutoDiscovery, (void **)&_pMailAutoDiscovery);
            if (SUCCEEDED(hr))
            {
                hr = _pMailAutoDiscovery->WorkAsync(hDlg, WM_AUTODISCOVERY_FINISHED);
                if (SUCCEEDED(hr))
                {
                    BSTR bstrEmail = SysAllocString(szEmail);

                    if (bstrEmail)
                    {
                        hr = _pMailAutoDiscovery->DiscoverMail(bstrEmail);
                        if (SUCCEEDED(hr))
                        {
                            g_fRequestCancelled = FALSE;
                        }
                        SysFreeString(bstrEmail);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                }
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    if (FAILED(hr))
    {
        PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
    }

    return hr;
}


HRESULT CAutoDiscoveryHelper::SetNextButton(HWND hwndButton)
{
    HRESULT hr = S_OK;
    TCHAR szSkipButton[MAX_PATH];

    // First, change the "Next" button into "Skip"
    // Save the text on the next button before we rename it.
    if (hwndButton && !GetWindowText(hwndButton, _szNextText, ARRAYSIZE(_szNextText)))
    {
        _szNextText[0] = 0;    // terminate string in failure case.
    }

    // Set the next text.
    LoadString(g_hInstRes, idsADSkipButton, szSkipButton, ARRAYSIZE(szSkipButton));
    SetWindowText(hwndButton, szSkipButton);

    return hr;
}


HRESULT CAutoDiscoveryHelper::RestoreNextButton(HWND hwndButton)
{
    HRESULT hr = S_OK;

    if (_szNextText[0])
    {
        // Restore the Next button text.
        SetWindowText(hwndButton, _szNextText);
    }

    return hr;
}


/****************************************************\
    DESCRIPTION:
\****************************************************/
HRESULT CAutoDiscoveryHelper::OnCompleted(IN CICWApprentice *pApp, IN ACCTDATA *pData)
{
    // Step 1. Get all the settings from IMailAutoDiscovery to EMAIL_SERVER_SETTINGS
    EMAIL_SERVER_SETTINGS emailServerSettings = {0};

    emailServerSettings.nProtocol = -1;
    emailServerSettings.nServer1Port = -1;
    emailServerSettings.nServer2Port = -1;

    HRESULT hr = _GetAccountInformation(&emailServerSettings);
    
    g_uNextPage = ORD_PAGE_AD_MAILSERVER;       // Assume we fail and we need to ask for the server settings.

    // Did the AutoDiscovery process succeed?
    if (SUCCEEDED(hr))
    {
        if (emailServerSettings.fDisplayInfoURL)
        {
            g_uNextPage = ORD_PAGE_AD_GOTOSERVERINFO;
            StrCpyNW(g_szInfoURL, emailServerSettings.bstrInfoURL, ARRAYSIZE(g_szInfoURL));
        }
        else if (emailServerSettings.fUseWebMail)
        {
            g_uNextPage = ORD_PAGE_AD_USEWEBMAIL;
            StrCpyNW(g_szWebMailURL, emailServerSettings.bstrServer1Name, ARRAYSIZE(g_szWebMailURL));
        }
        else
        {
            g_uNextPage = ORD_PAGE_AD_MAILNAME;
            if (pApp && pData && pApp->m_pAcct)
            {
                // Step 2. Move all the settings from EMAIL_SERVER_SETTINGS to the OE mail account (ACCTDATA).
                IImnAccount * pAcct = pApp->m_pAcct;

                pData->fLogon = FALSE;      // BUGBUG: When is this needed? DAV?
                pData->fSPA = emailServerSettings.fUsesSPA;
                pData->fServerTypes = emailServerSettings.nProtocol;

                Assert(!pData->fCreateNewAccount);
                if (emailServerSettings.bstrDisplayName)
                {
                    SHUnicodeToAnsi(emailServerSettings.bstrDisplayName, pData->szName, ARRAYSIZE(pData->szName));
                }

                if (emailServerSettings.bstrServer1Name)
                {
                    SHUnicodeToAnsi(emailServerSettings.bstrServer1Name, pData->szSvr1, ARRAYSIZE(pData->szSvr1));
                }

                if (emailServerSettings.bstrLoginName)
                {
                    SHUnicodeToAnsi(emailServerSettings.bstrLoginName, pData->szUsername, ARRAYSIZE(pData->szUsername));
                }

                if (emailServerSettings.nProtocol & (SRV_POP3 | SRV_IMAP))
                {
                    pAcct->SetPropDw(((emailServerSettings.nProtocol & SRV_POP3) ? AP_POP3_SSL : AP_IMAP_SSL), emailServerSettings.fUsesSSL);

                    if (-1 != emailServerSettings.nServer1Port)
                    {
                        pAcct->SetPropDw(((emailServerSettings.nProtocol & SRV_POP3) ? AP_POP3_PORT : AP_IMAP_PORT), emailServerSettings.nServer1Port);
                    }
                }

                if (emailServerSettings.nProtocol & SRV_SMTP)
                {
                    if (emailServerSettings.bstrServer2Name)
                    {
                        SHUnicodeToAnsi(emailServerSettings.bstrServer2Name, pData->szSvr2, ARRAYSIZE(pData->szSvr2));
                    }
                    if (-1 != emailServerSettings.nServer2Port)
                    {
                        pAcct->SetPropDw(AP_SMTP_PORT, emailServerSettings.nServer2Port);
                    }

                    pAcct->SetPropDw(AP_SMTP_SSL, emailServerSettings.fSMTPUsesSSL);

                    if (!emailServerSettings.fAuthSMTP)
                    {
                        pAcct->SetPropDw(AP_SMTP_USE_SICILY, SMTP_AUTH_NONE);
                    }
                    else
                    {
                        if (emailServerSettings.fAuthSMTPPOP)
                        {
                            pAcct->SetPropDw(AP_SMTP_USE_SICILY, SMTP_AUTH_USE_POP3ORIMAP_SETTINGS);
                        }
                        else
                        {
                            if (emailServerSettings.fAuthSMTPSPA)
                            {
                                pAcct->SetPropDw(AP_SMTP_USE_SICILY, SMTP_AUTH_SICILY);
                            }
                            else
                            {
                                pAcct->SetPropDw(AP_SMTP_USE_SICILY, SMTP_AUTH_USE_SMTP_SETTINGS);
                            }

                            if (emailServerSettings.bstrSMTPLoginName)
                            {
                                TCHAR szSMTPUserName[CCHMAX_ACCT_PROP_SZ];

                                WideCharToMultiByte(CP_ACP, 0, emailServerSettings.bstrSMTPLoginName, -1, szSMTPUserName, ARRAYSIZE(szSMTPUserName), NULL, NULL);
                                pAcct->SetPropSz(AP_SMTP_USERNAME, szSMTPUserName);
                            }

                            pAcct->SetPropDw(AP_SMTP_PROMPT_PASSWORD, TRUE);
                        }
                    }
                }
            }
        }

        // Step 3. Free all the memory in EMAIL_SERVER_SETTINGS
        FreeEmailServerSettings(&emailServerSettings);
    }

    return hr;
}


/****************************************************\
    DESCRIPTION:
\****************************************************/
HRESULT CAutoDiscoveryHelper::_GetAccountInformation(EMAIL_SERVER_SETTINGS * pEmailServerSettings)
{
    BSTR bstrPreferedProtocol;
    HRESULT hr = S_OK;
    
    // We ignore hr because getting the display name is optinal.
    _pMailAutoDiscovery->get_DisplayName(&pEmailServerSettings->bstrDisplayName);

    hr = _pMailAutoDiscovery->get_PreferedProtocolType(&bstrPreferedProtocol);

    // Loop thru the list looking for the first instance of a protocol
    // that we support.
    if (StrCmpIW(bstrPreferedProtocol, STR_PT_POP) && 
        StrCmpIW(bstrPreferedProtocol, STR_PT_IMAP) && 
        StrCmpIW(bstrPreferedProtocol, STR_PT_DAVMAIL))
    {
        long nSize;

        hr = _pMailAutoDiscovery->get_length(&nSize);
        if (SUCCEEDED(hr))
        {
            VARIANT varIndex;

            varIndex.vt = VT_I4;
            SysFreeString(bstrPreferedProtocol);

            for (long nIndex = 1; (nIndex < nSize); nIndex++)
            {
                IMailProtocolADEntry * pMailProtocol;

                varIndex.lVal = nIndex;
                if (SUCCEEDED(_pMailAutoDiscovery->get_item(varIndex, &pMailProtocol)))
                {
                    hr = pMailProtocol->get_Protocol(&bstrPreferedProtocol);
                    
                    pMailProtocol->Release();
                    pMailProtocol = NULL;
                    if (SUCCEEDED(hr))
                    {
                        // Is this protocol one of the ones we support?
                        if (!StrCmpIW(bstrPreferedProtocol, STR_PT_POP) || 
                            !StrCmpIW(bstrPreferedProtocol, STR_PT_IMAP) || 
                            !StrCmpIW(bstrPreferedProtocol, STR_PT_DAVMAIL))
                        {
                            hr = S_OK;
                            break;
                        }

                        SysFreeString(bstrPreferedProtocol);
                        bstrPreferedProtocol = NULL;
                    }
                }
            }
        }
    }

    // TODO: Handle the Web Based mail case.

    if (!StrCmpIW(bstrPreferedProtocol, STR_PT_POP))  pEmailServerSettings->nProtocol = (SRV_POP3 | SRV_SMTP);
    else if (!StrCmpIW(bstrPreferedProtocol, STR_PT_IMAP))  pEmailServerSettings->nProtocol = (SRV_IMAP | SRV_SMTP);
    else if (!StrCmpIW(bstrPreferedProtocol, STR_PT_DAVMAIL))  pEmailServerSettings->nProtocol = SRV_HTTPMAIL;

    // We need to reject Web Base Mail.  In the future, we may want to give a page
    // for them to launch the web browser to read their mail.
    if (SUCCEEDED(hr) && bstrPreferedProtocol &&
        (!StrCmpIW(bstrPreferedProtocol, STR_PT_POP) ||
         !StrCmpIW(bstrPreferedProtocol, STR_PT_IMAP) ||
         !StrCmpIW(bstrPreferedProtocol, STR_PT_DAVMAIL)))
    {
        VARIANT varIndex;
        IMailProtocolADEntry * pMailProtocol;

        varIndex.vt = VT_BSTR;
        varIndex.bstrVal = bstrPreferedProtocol;

        hr = _pMailAutoDiscovery->get_item(varIndex, &pMailProtocol);
        if (SUCCEEDED(hr))
        {
            hr = pMailProtocol->get_ServerName(&pEmailServerSettings->bstrServer1Name);
            if (SUCCEEDED(hr))
            {
                BSTR bstrPortNum;

                // Having a custom port number is optional.
                if (SUCCEEDED(pMailProtocol->get_ServerPort(&bstrPortNum)))
                {
                    pEmailServerSettings->nServer1Port = StrToIntW(bstrPortNum);
                    SysFreeString(bstrPortNum);
                }

                if (SUCCEEDED(hr))
                {
                    VARIANT_BOOL vfSPA = VARIANT_FALSE;

                    if (SUCCEEDED(pMailProtocol->get_UseSPA(&vfSPA)))
                    {
                        pEmailServerSettings->fUsesSPA = (VARIANT_TRUE == vfSPA);
                    }

                    pMailProtocol->get_LoginName(&pEmailServerSettings->bstrLoginName);
                }

                VARIANT_BOOL vfSSL = VARIANT_FALSE;
                if (SUCCEEDED(pMailProtocol->get_UseSSL(&vfSSL)))
                {
                    pEmailServerSettings->fUsesSSL = (VARIANT_TRUE == vfSSL);
                }
            }

            pMailProtocol->Release();
        }

        // Is this one of the protocols that requires a second server?
        if (!StrCmpIW(bstrPreferedProtocol, STR_PT_POP) ||
            !StrCmpIW(bstrPreferedProtocol, STR_PT_IMAP))
        {
            varIndex.bstrVal = STR_PT_SMTP;

            hr = _pMailAutoDiscovery->get_item(varIndex, &pMailProtocol);
            if (SUCCEEDED(hr))
            {
                hr = pMailProtocol->get_ServerName(&pEmailServerSettings->bstrServer2Name);
                if (SUCCEEDED(hr))
                {
                    BSTR bstrPortNum;

                    // Having a custom port number is optional.
                    if (SUCCEEDED(pMailProtocol->get_ServerPort(&bstrPortNum)))
                    {
                        pEmailServerSettings->nServer2Port = StrToIntW(bstrPortNum);
                        SysFreeString(bstrPortNum);
                    }

                    // TODO: Read in _fAuthSMTP and _fAuthSMTPPOP
                    VARIANT_BOOL vfSPA = VARIANT_FALSE;
                    if (SUCCEEDED(pMailProtocol->get_UseSPA(&vfSPA)))
                    {
                        pEmailServerSettings->fAuthSMTPSPA = (VARIANT_TRUE == vfSPA);
                    }

                    VARIANT_BOOL vfAuthSMTP = VARIANT_FALSE;
                    if (SUCCEEDED(pMailProtocol->get_IsAuthRequired(&vfAuthSMTP)))
                    {
                        pEmailServerSettings->fAuthSMTP = (VARIANT_TRUE == vfAuthSMTP);
                    }

                    VARIANT_BOOL vfAuthFromPOP = VARIANT_FALSE;
                    if (SUCCEEDED(pMailProtocol->get_SMTPUsesPOP3Auth(&vfAuthFromPOP)))
                    {
                        pEmailServerSettings->fAuthSMTPPOP = (VARIANT_TRUE == vfAuthFromPOP);
                    }

                    VARIANT_BOOL vfSSL = VARIANT_FALSE;
                    if (SUCCEEDED(pMailProtocol->get_UseSSL(&vfSSL)))
                    {
                        pEmailServerSettings->fSMTPUsesSSL = (VARIANT_TRUE == vfSSL);
                    }

                    pMailProtocol->get_LoginName(&pEmailServerSettings->bstrSMTPLoginName);
                }

                pMailProtocol->Release();
            }
        }

        SysFreeString(bstrPreferedProtocol);
    }

    if (SUCCEEDED(hr) && (-1 == pEmailServerSettings->nProtocol))
    {
        hr = E_FAIL;
    }

    if (FAILED(hr) && (-1 == pEmailServerSettings->nProtocol))
    {
        // Does this email account work with web based email?
        VARIANT varIndex;
        
        varIndex.vt = VT_BSTR;
        varIndex.bstrVal = SysAllocString(STR_PT_WEBBASED);

        if (varIndex.bstrVal)
        {
            IMailProtocolADEntry * pMailProtocol;

            if (SUCCEEDED(_pMailAutoDiscovery->get_item(varIndex, &pMailProtocol)))
            {
                // Yes, web bases mail is supported.  So remember that for later.
                pEmailServerSettings->fUseWebMail = TRUE;
                hr = pMailProtocol->get_ServerName(&pEmailServerSettings->bstrServer1Name);

                pMailProtocol->Release();
            }

            VariantClear(&varIndex);
        }
    }

    if (FAILED(hr) && (-1 == pEmailServerSettings->nProtocol))
    {
        // Did the server provide an INFO URL for the user?
        hr = _pMailAutoDiscovery->get_InfoURL(&pEmailServerSettings->bstrInfoURL);
        if (SUCCEEDED(hr))
        {
            pEmailServerSettings->fDisplayInfoURL = TRUE;
        }
    }

    return hr;
}





/****************************************************\
    Constructor
\****************************************************/
CAutoDiscoveryHelper::CAutoDiscoveryHelper()
{
    DllAddRef();

    // ASSERT zero initialized because we can only be created in the heap. (Private destructor)
    _hwndDlgParent = NULL;
    _szNextText[0] = 0;
    _pMailAutoDiscovery = NULL;
    _hInstAutoDisc = NULL;
}


/****************************************************\
    Destructor
\****************************************************/
CAutoDiscoveryHelper::~CAutoDiscoveryHelper()
{
    if (_pMailAutoDiscovery)
    {
        _pMailAutoDiscovery->Release();
        _pMailAutoDiscovery = NULL;
    }

    if (_hInstAutoDisc)
    {
        FreeLibrary(_hInstAutoDisc);
    }

    DllRelease();
}


//===========================
// *** Public APIs ***
//===========================


BOOL CALLBACK AutoDiscoveryInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
{
    if (fFirstInit)
    {
        g_fRequestCancelled = TRUE;
        g_uNextPage = ORD_PAGE_AD_MAILSERVER;       // Assume we fail and we need to ask for the server settings.
    }

    if (!g_pAutoDiscoveryObject)
    {
        Assert(!g_pAutoDiscoveryObject);
        g_pAutoDiscoveryObject = new CAutoDiscoveryHelper();
        if (g_pAutoDiscoveryObject)
        {
            g_pAutoDiscoveryObject->StartAutoDiscovery(pApp, hDlg, fFirstInit);
        }
    }
    
    return TRUE;
}


BOOL CALLBACK AutoDiscoveryOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
{
    g_fRequestCancelled = TRUE;

    if (fForward)
    {
        *puNextPage = g_uNextPage;
    }
    else
    {
        // If we have the passifier page turned off, we want to skip that page.
        if (!SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_AUTODISCOVERY_PASSIFIER, FALSE, TRUE))
        {
            *puNextPage = ORD_PAGE_AD_MAILADDRESS;
        }
    }

    ADRestoreNextButton(pApp, hDlg);
    g_uNextPage = ORD_PAGE_AD_MAILSERVER;       // Assume we fail and we need to ask for the server settings.

    return(TRUE);
}


BOOL CALLBACK AutoDiscoveryCmdProc(CICWApprentice *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    return(TRUE);
}


BOOL CALLBACK AutoDiscoveryWMUserProc(CICWApprentice *pApp, HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_AUTODISCOVERY_FINISHED:
    if (FALSE == g_fRequestCancelled)
    {
        // This is WM_AUTODISCOVERY_FINISHED
        BSTR bstXML = (BSTR) lParam;
        HRESULT hrAutoDiscoverySucceeded = (HRESULT) wParam;

        if (bstXML)
        {
            SysFreeString(bstXML);      // We don't need the XML.  This works if NULL
        }

        if (SUCCEEDED(hrAutoDiscoverySucceeded))
        {
            OnADCompleted(pApp, hDlg);
        }

        // Go to the next page.
        ADRestoreNextButton(pApp, hDlg);
        PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
    }
    break;
    case WM_AUTODISCOVERY_STATUSMSG:
    {
        // This is WM_AUTODISCOVERY_STATUSMSG
        LPWSTR pwzStatusMsg = (BSTR) wParam;

        if (pwzStatusMsg)
        {
            HWND hwndStatusText = GetDlgItem(hDlg, IDC_AUTODISCOVERY_STATUS);
    
            if (hwndStatusText)
            {
                SetWindowTextW(hwndStatusText, pwzStatusMsg);
            }

            LocalFree(pwzStatusMsg);
        }
    }
    break;
    }

    return(TRUE);
}




BOOL CALLBACK AutoDiscoveryCancelProc(CICWApprentice *pApp, HWND hDlg)
{
    // This call will clean up our state and retore the back button.
    ADRestoreNextButton(pApp, hDlg);
    g_uNextPage = ORD_PAGE_AD_MAILSERVER;       // Assume we fail and we need to ask for the server settings.
    return TRUE;
}










typedef BOOL (* PFN_LINKWINDOW_REGISTERCLASS) (void);
typedef BOOL (* PFN_LINKWINDOW_UNREGISTERCLASS) (IN HINSTANCE hInst);

#define ORD_LINKWINDOW_REGISTERCLASS            258
#define ORD_LINKWINDOW_UNREGISTERCLASS          259

BOOL LinkWindow_RegisterClass_DelayLoad(void)
{
    BOOL returnValue = FALSE;
    // Delay load the SHELL32.DLL export (ordinal #258). This only works on Win2k and later.
    HINSTANCE hInstSHELL32 = LoadLibrary(TEXT("SHELL32.DLL"));

    if (hInstSHELL32)
    {
        PFN_LINKWINDOW_REGISTERCLASS pfnDelayLoad = (PFN_LINKWINDOW_REGISTERCLASS)GetProcAddress(hInstSHELL32, (LPCSTR)ORD_LINKWINDOW_REGISTERCLASS);
        
        if (pfnDelayLoad)
        {
            returnValue = pfnDelayLoad();
        }

        FreeLibrary(hInstSHELL32);
    }

    return returnValue;
}


void LinkWindow_UnregisterClass_DelayLoad(IN HINSTANCE hInst)
{
    // Delay load the SHELL32.DLL export (ordinal #259). This only works on Win2k and later.
    HINSTANCE hInstSHELL32 = LoadLibrary(TEXT("SHELL32.DLL"));

    if (hInstSHELL32)
    {
        PFN_LINKWINDOW_UNREGISTERCLASS pfnDelayLoad = (PFN_LINKWINDOW_UNREGISTERCLASS)GetProcAddress(hInstSHELL32, (LPCSTR)ORD_LINKWINDOW_UNREGISTERCLASS);
        
        if (pfnDelayLoad)
        {
            BOOL returnValue = pfnDelayLoad(hInst);
        }

        FreeLibrary(hInstSHELL32);
    }
}

#define LINKWINDOW_CLASSW       L"Link Window"

BOOL IsOSNT(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.

    return (VER_PLATFORM_WIN32_NT == osVerInfoA.dwPlatformId);
}


DWORD GetOSVer(void)
{
    OSVERSIONINFOA osVerInfoA;

    osVerInfoA.dwOSVersionInfoSize = sizeof(osVerInfoA);
    if (!GetVersionExA(&osVerInfoA))
        return VER_PLATFORM_WIN32_WINDOWS;   // Default to this.

    return osVerInfoA.dwMajorVersion;
}



HRESULT ConvertTextToLinkWindow(HWND hDlg, int idControl, int idStringID)
{
    WCHAR szTempString[MAX_URL_STRING];
    HRESULT hr = S_OK;
    HWND hwndText = GetDlgItem(hDlg, idControl);
    RECT rcWindow;
    HMENU hMenu = (HMENU)IntToPtr(idControl + 10);

    LoadStringW(g_hInstRes, idStringID, szTempString, ARRAYSIZE(szTempString));
    GetClientRect(hwndText, &rcWindow);
    MapWindowPoints(hwndText, hDlg, (POINT*)&rcWindow, 2);

    HWND hwndLink = CreateWindowW(LINKWINDOW_CLASSW, szTempString, (WS_TABSTOP | WS_CHILDWINDOW),
            rcWindow.left, rcWindow.top, RECTWIDTH(rcWindow), RECTHEIGHT(rcWindow), hDlg, hMenu, g_hInstRes, NULL);

    DWORD dwError = GetLastError(); //todo;
    if (hwndLink)
    {
        SetWindowTextW(hwndLink, szTempString);
        ShowWindow(hwndLink, SW_SHOW);
    }

    EnableWindow(hwndText, FALSE);
    ShowWindow(hwndText, SW_HIDE);

    return hr;
}


HRESULT GetEmailAddress(CICWApprentice *pApp, LPSTR pszEmailAddress, int cchSize)
{
    ACCTDATA * pData = pApp->GetAccountData();

    StrCpyNA(pszEmailAddress, "", cchSize); // Initialize the string to empty.
    if (pData && pData->szEmail)
    {
        StrCpyNA(pszEmailAddress, pData->szEmail, cchSize); // Initialize the string to empty.
    }

    return S_OK;
}


HRESULT GetEmailAddressDomain(CICWApprentice *pApp, LPSTR pszEmailAddress, int cchSize)
{
    ACCTDATA * pData = pApp->GetAccountData();

    StrCpyNA(pszEmailAddress, "", cchSize); // Initialize the string to empty.
    if (pData && pData->szEmail)
    {
        LPCSTR pszEmailDomain = StrChrA(pData->szEmail, CH_EMAILDOMAINSEPARATOR);

        if (pszEmailDomain)
        {
            StrCpyNA(pszEmailAddress, CharNext(pszEmailDomain), cchSize); // Initialize the string to empty.
        }
    }

    return S_OK;
}


BOOL CALLBACK TheInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit, int idControlFirst, LPWSTR pszURL, int cchURLSize)
{
    BOOL fReset = fFirstInit;

    if (!fReset)
    {
        WCHAR szPreviousURL[MAX_URL_STRING];

        GetWindowTextW(GetDlgItem(hDlg, idControlFirst+1), szPreviousURL, ARRAYSIZE(szPreviousURL));
        // If the URL has changed, we need to reload the info.
        if (StrCmpIW(pszURL, szPreviousURL))
        {
            DestroyWindow(GetDlgItem(hDlg, idControlFirst+1+10));
            DestroyWindow(GetDlgItem(hDlg, idControlFirst+2+10));
            fReset = TRUE;
        }
    }

    if (fReset)
    {
        // TODO: This won't work on downlevel.  So use plain text.
        BOOL fLinksSupported = LinkWindow_RegisterClass_DelayLoad();
        TCHAR szTempStr1[MAX_URL_STRING*3];
        TCHAR szTempStr2[MAX_URL_STRING*3];
        CHAR szTempStr3[MAX_PATH];

        // Replace the %s in the first line to the domain name.
        GetWindowText(GetDlgItem(hDlg, idControlFirst), szTempStr1, ARRAYSIZE(szTempStr1));
        GetEmailAddress(pApp, szTempStr3, ARRAYSIZE(szTempStr3));
        wnsprintf(szTempStr2, ARRAYSIZE(szTempStr2), szTempStr1, szTempStr3, szTempStr3);
        SetWindowText(GetDlgItem(hDlg, idControlFirst), szTempStr2);

        SetWindowTextW(GetDlgItem(hDlg, idControlFirst+1), pszURL);

        // We only support Win2k and later because we don't want to worry about
        // the fact that the "LinkWindow" class doesn't have an "W" and "A" version.
        if (fLinksSupported && IsOSNT() && (5 <= GetOSVer()))
        {
            ConvertTextToLinkWindow(hDlg, idControlFirst+1, idsADURLLink);
            ConvertTextToLinkWindow(hDlg, idControlFirst+2, idsADUseWebMsg);

            // Replace the %s in the second line to the URL.
            GetWindowText(GetDlgItem(hDlg, idControlFirst+1+10), szTempStr1, ARRAYSIZE(szTempStr1));
            wnsprintf(szTempStr2, ARRAYSIZE(szTempStr2), szTempStr1, pszURL, pszURL);
            SetWindowText(GetDlgItem(hDlg, idControlFirst+1+10), szTempStr2);

            // Set the hyperlink URL in the Click here link.
            GetWindowText(GetDlgItem(hDlg, idControlFirst+2+10), szTempStr1, ARRAYSIZE(szTempStr1));
            wnsprintf(szTempStr2, ARRAYSIZE(szTempStr2), szTempStr1, pszURL);
            SetWindowText(GetDlgItem(hDlg, idControlFirst+2+10), szTempStr2);
        }
    }

    return TRUE;
}

BOOL CALLBACK UseWebMailInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
{
    return TheInitProc(pApp, hDlg, fFirstInit, IDC_USEWEB_LINE1, g_szWebMailURL, ARRAYSIZE(g_szWebMailURL));
}


BOOL CALLBACK UseWebMailOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
{
    if (fForward)
    {
        *puNextPage = ORD_PAGE_AD_MAILSERVER;
    }
    else
    {
        *puNextPage = ORD_PAGE_AD_MAILADDRESS;
    }

    LinkWindow_UnregisterClass_DelayLoad(g_hInstRes);
    return(TRUE);
}


BOOL CALLBACK UseWebMailCmdProc(CICWApprentice *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    LinkWindow_UnregisterClass_DelayLoad(g_hInstRes);

    return(TRUE);
}










BOOL CALLBACK GotoServerInfoInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
{
    return TheInitProc(pApp, hDlg, fFirstInit, IDC_GETINFO_LINE1, g_szInfoURL, ARRAYSIZE(g_szInfoURL));
}


BOOL CALLBACK GotoServerInfoOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
{
    if (fForward)
    {
        *puNextPage = ORD_PAGE_AD_MAILSERVER;
    }
    else
    {
        *puNextPage = ORD_PAGE_AD_MAILADDRESS;
    }

    return(TRUE);
}


BOOL CALLBACK GotoServerInfoCmdProc(CICWApprentice *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    LinkWindow_UnregisterClass_DelayLoad(g_hInstRes);

    return(TRUE);
}





BOOL CALLBACK PassifierInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
{
    TCHAR szTemplate[1024];
    TCHAR szPrivacyText[1024];
    TCHAR szEmail[MAX_PATH];
    TCHAR szDomain[MAX_PATH];

    if (FAILED(GetEmailAddressDomain(pApp, szDomain, ARRAYSIZE(szDomain))))
    {
        szDomain[0] = 0;
    }

    // Set the next text.
    LoadString(g_hInstRes, ids_ADPassifier_Warning, szTemplate, ARRAYSIZE(szTemplate));
    wnsprintf(szPrivacyText, ARRAYSIZE(szPrivacyText), szTemplate, szDomain);
    SetWindowText(GetDlgItem(hDlg, IDC_PASSIFIER_PRIVACYWARNING), szPrivacyText);

    // Load up the list boxes
    IMailAutoDiscovery * pMailAutoDiscovery;
    HWND hwndListBox;

    if (FAILED(GetEmailAddress(pApp, szEmail, ARRAYSIZE(szEmail))))
    {
        szEmail[0] = 0;
    }


    HRESULT hr = CoCreateInstance(CLSID_MailAutoDiscovery, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMailAutoDiscovery, &pMailAutoDiscovery));
    if (SUCCEEDED(hr))
    {
        IAutoDiscoveryProvider * pProviders;
        BSTR bstrEmail = SysAllocStringA(szEmail);

        hr = pMailAutoDiscovery->getPrimaryProviders(bstrEmail, &pProviders);
        if (SUCCEEDED(hr))
        {
            long nTotal = 0;
            VARIANT varIndex;

            hwndListBox = GetDlgItem(hDlg, IDC_PASSIFIER_PRIMARYLIST);
            if (hwndListBox)
            {
                varIndex.vt = VT_I4;
                pProviders->get_length(&nTotal);
                for (varIndex.lVal = 0; (varIndex.lVal < nTotal) && (varIndex.lVal <= 3); varIndex.lVal++)
                {
                    BSTR bstrDomain;

                    if (SUCCEEDED(pProviders->get_item(varIndex, &bstrDomain)))
                    {
                        CHAR szDomain[MAX_PATH];

                        SHUnicodeToAnsi(bstrDomain, szDomain, ARRAYSIZE(szDomain));
                        SetWindowTextA(GetDlgItem(hDlg, IDC_PASSIFIER_PRIMARYLIST + varIndex.lVal), szDomain);

                        SysFreeString(bstrDomain);
                    }
                }
            }

            pProviders->Release();
        }

        hr = pMailAutoDiscovery->getSecondaryProviders(bstrEmail, &pProviders);
        if (SUCCEEDED(hr))
        {
            long nTotal = 0;
            VARIANT varIndex;
    
            hwndListBox = GetDlgItem(hDlg, IDC_PASSIFIER_SECONDARYLIST);
            if (hwndListBox)
            {
                varIndex.vt = VT_I4;
                pProviders->get_length(&nTotal);
                for (varIndex.lVal = 0; (varIndex.lVal < nTotal) && (varIndex.lVal <= 3); varIndex.lVal++)
                {
                    BSTR bstrURL;       // The secondary servers are URLs

                    if (SUCCEEDED(pProviders->get_item(varIndex, &bstrURL)))
                    {
                        CHAR szURL[MAX_PATH];
                        CHAR szDomain[MAX_PATH];
                        DWORD cchSize = ARRAYSIZE(szDomain);

                        SHUnicodeToAnsi(bstrURL, szURL, ARRAYSIZE(szURL));
                        UrlGetPart(szURL, szDomain, &cchSize, URL_PART_HOSTNAME, 0);
                        SetWindowTextA(GetDlgItem(hDlg, IDC_PASSIFIER_SECONDARYLIST + varIndex.lVal), szDomain);

                        SysFreeString(bstrURL);
                    }
                }
            }

            pProviders->Release();
        }

        SysFreeString(bstrEmail);
        pMailAutoDiscovery->Release();
    }

    // Set the manual checkbox
    BOOL fManuallyConfigure = SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_AUTODISCOVERY_OEMANUAL, FALSE, FALSE);
    CheckDlgButton(hDlg, IDC_PASSIFIER_SKIPCHECKBOX, (fManuallyConfigure ? BST_CHECKED : BST_UNCHECKED));

    return TRUE;
}


#define SZ_TRUE                 TEXT("TRUE")
#define SZ_FALSE                TEXT("FALSE")
BOOL CALLBACK PassifierOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
{
    if (fForward)
    {
        BOOL fManuallyConfigure = (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_PASSIFIER_SKIPCHECKBOX));

        SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_AUTODISCOVERY_OEMANUAL, REG_SZ, 
            (LPCVOID)(fManuallyConfigure ? SZ_TRUE : SZ_FALSE), (fManuallyConfigure ? sizeof(SZ_TRUE) : sizeof(SZ_FALSE)));

        *puNextPage = (fManuallyConfigure ? ORD_PAGE_AD_MAILSERVER : ORD_PAGE_AD_AUTODISCOVERY);
    }
    else
    {
        *puNextPage = ORD_PAGE_AD_MAILADDRESS;
    }

    return TRUE;
}


BOOL CALLBACK PassifierCmdProc(CICWApprentice *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\acctui.h ===
#ifndef _ACCTUI_H
#define _ACCTUI_H

// max CCHMAX value from imnact.h
#define CCHMAX_ACCT_PROP_SZ     256

#define OPTION_OFF          0xffffffff
#define PORT_CCHMAX         8

#define DEF_NNTPPORT        119
#define DEF_SNNTPPORT       563
#define DEF_IMAPPORT        143
#define DEF_SIMAPPORT       993
#define DEF_SMTPPORT        25
#define DEF_SSMTPPORT       25

#define DEF_POP3PORT        110
#define DEF_SPOP3PORT       995
#define DEF_LDAPPORT        389
#define DEF_SLDAPPORT       636

// $TODO - These constants will be moved later
#define EXPIRE_MAX          100
#define EXPIRE_MIN          1
#define EXPIRE_DEFAULT      5
#define DEF_BREAKSIZE       60
#define BREAKSIZE_MIN       16
#define BREAKSIZE_MAX       16000
#define MATCHES_MAX         9999
#define MATCHES_MIN         1
#define MATCHES_DEFAULT     100

enum 
    {
    iNewsServer = 0,
    iMailServer,
    iLDAPServer
    };


// query sibling messages
#define MSM_GETSERVERTYPE   WM_USER
#define SM_INITIALIZED      (WM_USER + 2)
#define SM_SETDIRTY         (WM_USER + 3)
#define SM_SAVECHANGES      (WM_USER + 4)
#define MSM_GETEMAILADDRESS (WM_USER + 5)
#define MSM_GETCERTDATA     (WM_USER + 6)
#define MSM_GETDISPLAYNAME  (WM_USER + 7)
    
enum tagPages {
    PAGE_READ   = 0x0001,
    PAGE_SEND   = 0x0002,
    PAGE_SERVER = 0x0004,
    PAGE_FONTS  = 0x0008,
    PAGE_SPELL  = 0x0010,
    PAGE_SIG    = 0x0020,
    PAGE_ADV    = 0x0040,
    PAGE_RAS    = 0x0080,
    PAGE_SEC    = 0x0100,
    PAGE_ADVSEC = 0x0200,
    PAGE_GEN    = 0x0400,
    PAGE_IMAP   = 0x0800
    };

typedef struct tagACCTDLGINFO
    {
    ACCTTYPE AcctTypeInit;
    DWORD dwAcctFlags;
    DWORD dwFlags;
    ACCTTYPE AcctType; // used by the dialog in single-type mode
    } ACCTDLGINFO;

INT_PTR CALLBACK ManageAccountsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int AcctMessageBox(HWND hwndOwner, LPTSTR szTitle, LPTSTR sz1, LPTSTR sz2, UINT fuStyle);
void InitTimeoutSlider(HWND hwndSlider, HWND hwndText, DWORD dwTimeout);
void SetTimeoutString(HWND hwnd, UINT pos);
DWORD GetTimeoutFromSlider(HWND hwnd);
void InitCheckCounter(DWORD dw, HWND hwnd, int idcCheck, int idcEdit, int idcSpin, int min, int max, int def);
BOOL InvalidAcctProp(HWND hwndPage, HWND hwndEdit, int idsError, UINT idPage);
BOOL Server_FAddAccount(HWND hwndList, ACCTDLGINFO *pinfo, UINT iItem, IImnAccount *pAccount, BOOL fSelect);
BOOL Server_InitServerList(HWND hwnd, HWND hwndList, HWND hwndTab, ACCTDLGINFO *pinfo, TCHAR *szSelect);
void Server_ImportServer(HWND hwndDlg, ACCTDLGINFO *pinfo);
void Server_ExportServer(HWND hwndDlg);

typedef struct _tagHELPMAP
    {
    DWORD   id; 
    DWORD   hid;
    } HELPMAP, *LPHELPMAP;

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap);

#endif //_ACCTUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\acctui.cpp ===
#include "pch.hxx"
#include <commctrl.h>
#include <ras.h>
#include "acctman.h"
#include "server.h"
#include "connect.h"
#include "acctui.h"
#include "strconst.h"
#include "dllmain.h"
#include "resource.h"
#include "accthelp.h"
#include "shared.h"
#include <demand.h>
ASSERTDATA

INT_PTR CALLBACK SetOrderDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
void MoveLDAPItemUpDown(HWND hDlg, BOOL bMoveUp);
void SetUpDownButtons(HWND hDlg, HWND hWndLV);
BOOL InitSetOrderList(HWND hwndList);
void SaveLDAPResolveOrder(HWND hwnd, HWND hwndList);
void DrawAddButton(HWND hwnd, LPDRAWITEMSTRUCT pdi, ACCTDLGINFO *pinfo);
void EnableAcctButtons(HWND hwnd, HWND hwndList, UINT iItem);

const static DWORD c_mpAcctFlag[ACCT_LAST] = {ACCT_FLAG_NEWS, ACCT_FLAG_MAIL, ACCT_FLAG_DIR_SERV};

void GetTypeString(TCHAR *sz, int cch, ACCTTYPE AcctType, BOOL fDefault)
{
    int cb;
    ULONG uType;
    
    if (AcctType == ACCT_NEWS)
        uType = idsNews;
    else if (AcctType == ACCT_MAIL)
        uType = idsMail;
    else
    {
        Assert(AcctType == ACCT_DIR_SERV);
        uType = idsDirectoryService;
    }
    
    cb = LoadString(g_hInstRes, uType, sz, cch);
    if (fDefault)
        LoadString(g_hInstRes, idsDefault, &sz[cb], cch - (cb + 1));
}

BOOL Server_FAddAccount(HWND hwndList, ACCTDLGINFO *pinfo, UINT iItem, IImnAccount *pAccount, BOOL fSelect)
{
    // Locals
    TCHAR   szAccount[CCHMAX_ACCOUNT_NAME],
            szT[CCHMAX_ACCOUNT_NAME],
            szConnectoid[CCHMAX_CONNECTOID],
            szConnection[CCHMAX_CONNECTOID + 255],
            szRes[CCHMAX_STRINGRES];
    DWORD       iConnectType;
    ACCTTYPE    AcctType;
    LV_ITEM     lvi;
    UINT        nIndex, uType;
    int         cb;
    BOOL        fDefault;
    
    if (FAILED(pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, ARRAYSIZE(szAccount))) ||
        FAILED(pAccount->GetAccountType(&AcctType)))
    {   
        Assert(FALSE);
        return FALSE;
    }
    
    fDefault = FALSE;
    if (AcctType != ACCT_DIR_SERV &&
        SUCCEEDED(g_pAcctMan->GetDefaultAccountName(AcctType, szT, ARRAYSIZE(szT))))
        fDefault = (0 == lstrcmpi(szAccount, szT));
    
    // Setup listview item
    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.pszText = szAccount;
    lvi.iImage = (int)AcctType;
    lvi.lParam = MAKELPARAM(AcctType, fDefault);
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    nIndex = ListView_InsertItem(hwndList, &lvi);
    if (nIndex == -1)
        return FALSE;
    
    // Insert account type
    GetTypeString(szRes, ARRAYSIZE(szRes), AcctType, fDefault);
    lvi.mask = LVIF_TEXT;
    lvi.iItem = nIndex;
    lvi.iSubItem = 1;
    lvi.pszText = szRes;
    ListView_SetItem(hwndList, &lvi);
    
    // Get Connect Type
    if (FAILED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &iConnectType)))
        iConnectType = CONNECTION_TYPE_LAN;
    
    // If RAS, get the connect oid
    if (iConnectType == CONNECTION_TYPE_RAS)
    {
        if (FAILED(pAccount->GetPropSz(AP_RAS_CONNECTOID, szConnectoid, ARRAYSIZE(szConnectoid))))
            iConnectType = CONNECTION_TYPE_LAN;
    }
    
    // Build Connection String
    if (iConnectType == CONNECTION_TYPE_RAS)
    {
        LoadString(g_hInstRes, idsConnectionRAS, szRes, ARRAYSIZE(szRes));
        wnsprintf(szConnection, ARRAYSIZE(szConnection), szRes, szConnectoid);
    }
    else if (iConnectType == CONNECTION_TYPE_MANUAL)
    {
        LoadString(g_hInstRes, idsConnectionManual, szConnection, ARRAYSIZE(szConnection));
    }
    else if (iConnectType == CONNECTION_TYPE_INETSETTINGS)
    {
        LoadString(g_hInstRes, idsConnectionInetSettings, szConnection, ARRAYSIZE(szConnection));
    }
    else  
    {
        if (!!(pinfo->dwFlags & ACCTDLG_BACKUP_CONNECT) &&
            SUCCEEDED(pAccount->GetPropSz(AP_RAS_BACKUP_CONNECTOID, szConnectoid, ARRAYSIZE(szConnectoid))))
        {
            LoadString(g_hInstRes, idsConnectionLANBackup, szRes, ARRAYSIZE(szRes));
            wnsprintf(szConnection, ARRAYSIZE(szConnection), szRes, szConnectoid);
        }
        else
        {
            LoadString(g_hInstRes, idsConnectionLAN, szConnection, ARRAYSIZE(szConnection));
        }
    }
    
    // Insert connection type
    lvi.mask = LVIF_TEXT;
    lvi.iItem = nIndex;
    lvi.iSubItem = 2;
    lvi.pszText = szConnection;
    ListView_SetItem(hwndList, &lvi);
    
    // Select It
    if (fSelect)
    {
        ListView_UnSelectAll(hwndList);
        ListView_SetItemState(hwndList, nIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);    
    }
    
    // Done
    return TRUE;
}

BOOL Server_InitServerList(HWND hwnd, HWND hwndList, HWND hwndTab, ACCTDLGINFO *pinfo, TCHAR *szSelect)
{
    // Locals
    TC_ITEM             tci;
    int                 nIndex, iSel;
    TCHAR               szAcct[CCHMAX_ACCOUNT_NAME];
    HRESULT             hr;
    ACCTTYPE            AcctType;
    DWORD               dwSrvTypes, dwAcctFlags;
    DWORD               dwIndex=0;
    IImnEnumAccounts   *pEnumAccounts=NULL;
    IImnAccount        *pAccount=NULL;
    
    Assert(hwndList != NULL);
    Assert(hwndTab != NULL);
    Assert(pinfo != NULL);
    
    iSel = -1;
    
    nIndex = TabCtrl_GetCurSel(hwndTab);
    tci.mask = TCIF_PARAM;
    if (nIndex == -1 || !TabCtrl_GetItem(hwndTab, nIndex, &tci))
        return(FALSE);
    dwAcctFlags = (DWORD)tci.lParam;
    
    // Delete all the current items
    ListView_DeleteAllItems(hwndList);
    
    dwSrvTypes = 0;
    if (!!(dwAcctFlags & ACCT_FLAG_NEWS))
        dwSrvTypes |= SRV_NNTP;
    if (!!(dwAcctFlags & ACCT_FLAG_MAIL))
        dwSrvTypes |= SRV_MAIL;
    if (!!(dwAcctFlags & ACCT_FLAG_DIR_SERV))
        dwSrvTypes |= SRV_LDAP;
    
    if (SUCCEEDED(g_pAcctMan->IEnumerate(dwSrvTypes,
        !!(pinfo->dwFlags & ACCTDLG_NO_IMAP) ? ENUM_FLAG_NO_IMAP : 0,
        &pEnumAccounts)))
    {
        // Enumerate accounts
        while (SUCCEEDED(pEnumAccounts->GetNext(&pAccount)))
        {
            // Get Account Name
            if (szSelect != NULL && iSel == -1)
            {
                if (!FAILED(pAccount->GetPropSz(AP_ACCOUNT_NAME, szAcct, ARRAYSIZE(szAcct))) && 
                    0 == lstrcmpi(szAcct, szSelect))
                    iSel = dwIndex;
            }
            
            if (Server_FAddAccount(hwndList, pinfo, dwIndex, pAccount, iSel == (int)dwIndex))
                dwIndex++;       
            
            // Release current account
            SafeRelease(pAccount);
        }
        
        pEnumAccounts->Release();
        
        if (iSel == -1)
        {
            // Select the first item if we haven't selected anything   
            ListView_SetItemState(hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);    
        }
    }
    
    iSel = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVIS_SELECTED);
    EnableAcctButtons(hwnd, hwndList, iSel);
    
    if (!!(pinfo->dwAcctFlags & ACCT_FLAG_DIR_SERV))
        EnableWindow(GetDlgItem(hwnd, IDB_MACCT_ORDER), !!(dwAcctFlags & ACCT_FLAG_DIR_SERV));
    
    // Done
    return TRUE;
}



void Server_RemoveServer(HWND hwndDlg)
{
    ACCTTYPE    type;
    BOOL        fDefault;
    TCHAR       szAccount[CCHMAX_ACCOUNT_NAME],
        szRes[255],
        szMsg[255 + CCHMAX_ACCOUNT_NAME];
    LV_ITEM     lvi;
    LV_FINDINFO lvfi;
    int         iItemToDelete;
    IImnAccount *pAccount;
    HWND        hwndFocus;
    HWND        hwndList = GetDlgItem(hwndDlg, IDLV_MAIL_ACCOUNTS);
    
    // Get the selected item to know which server the user want's to kill
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVIS_SELECTED);
    lvi.iSubItem = 0;
    lvi.pszText = szAccount;
    lvi.cchTextMax = ARRAYSIZE(szAccount);
    if (ListView_GetItem(hwndList, &lvi))
    {    
        // Remember item to delete
        iItemToDelete = lvi.iItem;
        type = (ACCTTYPE)LOWORD(lvi.lParam);
        
        // Open the account
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
        {
            fDefault = (SUCCEEDED(g_pAcctMan->GetDefaultAccountName(type, szMsg, ARRAYSIZE(szMsg))) &&
                0 == lstrcmpi(szMsg, szAccount));
            
            hwndFocus = GetFocus();
            
            // Prompt
            LoadString(g_hInstRes, idsWarnDeleteAccount, szRes, ARRAYSIZE(szRes));
            wnsprintf(szMsg, ARRAYSIZE(szMsg), szRes, szAccount);
            if (AcctMessageBox(hwndDlg, MAKEINTRESOURCE(idsAccountManager), szMsg, NULL, MB_ICONEXCLAMATION |MB_YESNO) == IDYES)
            {
                // Delete it
                pAccount->Delete();
                
                // Remove the item
                ListView_DeleteItem(hwndList, iItemToDelete);
                
                if (fDefault &&
                    SUCCEEDED(g_pAcctMan->GetDefaultAccountName(type, szMsg, ARRAYSIZE(szMsg))))
                {
                    lvfi.flags = LVFI_STRING;
                    lvfi.psz = szMsg;
                    lvi.iItem = ListView_FindItem(hwndList, -1, &lvfi);
                    if (lvi.iItem != -1)
                    {
                        lvi.mask = LVIF_PARAM;
                        lvi.iSubItem = 0;
                        lvi.lParam = MAKELPARAM(type, fDefault);
                        ListView_SetItem(hwndList, &lvi);
                        
                        GetTypeString(szMsg, ARRAYSIZE(szMsg), type, TRUE);
                        lvi.mask = LVIF_TEXT;
                        lvi.iSubItem = 1;
                        lvi.pszText = szMsg;
                        ListView_SetItem(hwndList, &lvi);
                    }
                }
                
                // Bug #21299 - Make sure something is selected when we delete.
                iItemToDelete--;
                if (iItemToDelete < 0)
                    iItemToDelete = 0;
                ListView_SetItemState(hwndList, iItemToDelete, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                
                SetFocus(hwndFocus);
            }
            
            pAccount->Release();
        }
    }
}

HRESULT  GetConnectInfoForOE(IImnAccount    *pAcct)
{
    if (pAcct)
    {
        pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, CONNECTION_TYPE_INETSETTINGS);
    }
    return S_OK;
}

static const TCHAR c_szInetGetAutodial[] = TEXT("InetGetAutodial");

typedef HRESULT (WINAPI *PFNGETAUTODIAL)(LPBOOL, LPSTR, DWORD);

HRESULT GetIEConnectInfo(IImnAccount *pAcct)
{
    HINSTANCE hlib;
    PFNGETAUTODIAL pfn;
    HRESULT hr;
    BOOL fEnable;
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];
    
    hr = E_FAIL;
    
    hlib = LoadLibrary(c_szInetcfgDll);
    if (hlib != NULL)
    {
        pfn = (PFNGETAUTODIAL)GetProcAddress(hlib, c_szInetGetAutodial);
        if (pfn != NULL)
        {
            *sz = 0;
            hr = pfn(&fEnable, sz, sizeof(sz));
            if (SUCCEEDED(hr))
            {
                if (fEnable && *sz != 0)
                {
                    pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, CONNECTION_TYPE_RAS);
                    pAcct->SetPropSz(AP_RAS_CONNECTOID, sz);
                }
                else
                {
                    pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, CONNECTION_TYPE_LAN);
                }
            }
        }
        
        FreeLibrary(hlib);
    }
    
    return(hr);
}


BOOL Server_Create(HWND hwndParent, ACCTTYPE AcctType, ACCTDLGINFO *pinfo)
{
    HRESULT hr;
    BOOL fMail;
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];
    TC_ITEM tci;
    int nIndex;
    DWORD dwAcctFlags, dw;
    IImnAccount *pAcctDef, *pAcct = NULL;
    HWND hwndTab = GetDlgItem(hwndParent, IDB_MACCT_TAB);
    HWND hwndList = GetDlgItem(hwndParent, IDLV_MAIL_ACCOUNTS);
    
    Assert(IsWindow(hwndParent));
    
    hr = g_pAcctMan->CreateAccountObject(AcctType, &pAcct);
    if (SUCCEEDED(hr))
    {
        if (AcctType != ACCT_DIR_SERV)
        {
            hr = g_pAcctMan->GetDefaultAccount(AcctType, &pAcctDef);
            fMail = AcctType == ACCT_MAIL;
            if (FAILED(hr))
            {
                hr = g_pAcctMan->GetDefaultAccount(fMail ? ACCT_NEWS : ACCT_MAIL, &pAcctDef);
                fMail = !fMail;
            }
            
            if (SUCCEEDED(hr))
            {
                hr = pAcctDef->GetPropSz(fMail ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME, sz, ARRAYSIZE(sz));
                if (SUCCEEDED(hr))
                    pAcct->SetPropSz(AcctType == ACCT_MAIL ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME, sz);
                
                hr = pAcctDef->GetPropSz(fMail ? AP_SMTP_EMAIL_ADDRESS : AP_NNTP_EMAIL_ADDRESS, sz, ARRAYSIZE(sz));
                if (SUCCEEDED(hr))
                    pAcct->SetPropSz(AcctType == ACCT_MAIL ? AP_SMTP_EMAIL_ADDRESS : AP_NNTP_EMAIL_ADDRESS, sz);
                
                hr = pAcctDef->GetPropDw(AP_RAS_CONNECTION_TYPE, &dw);
                if (SUCCEEDED(hr))
                {
                    pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, dw);
//                    if (dw == CONNECTION_TYPE_RAS || dw == CONNECTION_TYPE_INETSETTINGS)
                    if (dw == CONNECTION_TYPE_RAS)
                    {
                        hr = pAcctDef->GetPropSz(AP_RAS_CONNECTOID, sz, ARRAYSIZE(sz));
                        if (SUCCEEDED(hr))
                            pAcct->SetPropSz(AP_RAS_CONNECTOID, sz);
                    }
                }
                
                pAcctDef->Release();
            }
            else
            {
                GetIEConnectInfo(pAcct);
            }
        }
        
        DWORD  dwFlags = 0;
        if (pinfo->dwFlags & ACCTDLG_INTERNETCONNECTION)
            dwFlags |= ACCT_WIZ_INTERNETCONNECTION;
        if (pinfo->dwFlags & ACCTDLG_HTTPMAIL)
            dwFlags |= ACCT_WIZ_HTTPMAIL;
        if (pinfo->dwFlags & ACCTDLG_OE)
            dwFlags |= ACCT_WIZ_OE;
        
        (pinfo->dwFlags & ACCTDLG_NO_NEW_POP) ? (dwFlags | ACCT_WIZ_NO_NEW_POP) : dwFlags;
        
        hr = pAcct->DoWizard(hwndParent, dwFlags);
        if (hr == S_OK)
        {
            hr = pAcct->GetPropSz(AP_ACCOUNT_NAME, sz, ARRAYSIZE(sz));
            
            if (SUCCEEDED(hr))
            {
                nIndex = TabCtrl_GetCurSel(hwndTab);
                tci.mask = TCIF_PARAM;
                if (nIndex >= 0 && TabCtrl_GetItem(hwndTab, nIndex, &tci))
                {
                    dwAcctFlags = (DWORD)tci.lParam;
                    if (0 == (dwAcctFlags & c_mpAcctFlag[AcctType]))
                    {
                        // the current page doesn't show this type of account,
                        // so we need to force a switch to the all tab
#ifdef DEBUG
                        tci.mask = TCIF_PARAM;
                        Assert(TabCtrl_GetItem(hwndTab, 0, &tci));
                        Assert(!!((DWORD)(tci.lParam) & c_mpAcctFlag[AcctType]));
#endif // DEBUG
                    
                        TabCtrl_SetCurSel(hwndTab, 0);
                        Server_InitServerList(hwndParent, hwndList, hwndTab, pinfo, sz);
                    }
                    else
                    {
                        Server_FAddAccount(hwndList, pinfo, 0, pAcct, TRUE);
                    }
                }
            }
        }
        
        pAcct->Release();    
    }
    
    return(TRUE);
}

BOOL Server_Properties(HWND hwndDlg, ACCTDLGINFO *pinfo)
{
    HWND        hwndFocus;
    LV_ITEM     lvi;
    TCHAR       szAccount[CCHMAX_ACCOUNT_NAME];
    HWND        hwndList = GetDlgItem(hwndDlg, IDLV_MAIL_ACCOUNTS);
    IImnAccount   *pAccount;
    
    hwndFocus = GetFocus();
    
    // Find out which item is selected
    lvi.mask = LVIF_TEXT;
    lvi.pszText = szAccount;
    lvi.cchTextMax = ARRAYSIZE(szAccount);
    lvi.iSubItem = 0;
    lvi.iItem = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVNI_SELECTED);
    if (lvi.iItem == -1 ||
        !ListView_GetItem(hwndList, &lvi))
        return FALSE;
    
    // Display the property sheet
    if (ServerProp_Create(hwndDlg, pinfo->dwFlags, szAccount, &pAccount))
    {
        Assert(pAccount);
        
        ListView_DeleteItem(hwndList, lvi.iItem);
        Server_FAddAccount(hwndList, pinfo, 0, pAccount, TRUE);
        
        pAccount->Release();
    }
    
    SetFocus(hwndFocus);
    
    // Done
    return TRUE;
}

#if WINVER < 0X0500
#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring
#endif

void DoAddAccountMenu(HWND hwnd, ACCTDLGINFO *pinfo)
{
    RECT rc;
    HMENU hmenu, hmenuParent;
    
    hmenu = NULL;
    hmenuParent = LoadMenu(g_hInstRes, MAKEINTRESOURCE(idmrAddAccount));
    
    if (hmenuParent != NULL)
    {
        hmenu = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
    }
    
    if (hmenu != NULL)
    {
        if (0 == (pinfo->dwAcctFlags & ACCT_FLAG_NEWS))
            DeleteMenu(hmenu, idmAddNews, MF_BYCOMMAND);
        if (0 == (pinfo->dwAcctFlags & ACCT_FLAG_MAIL))
            DeleteMenu(hmenu, idmAddMail, MF_BYCOMMAND);
        if (0 == (pinfo->dwAcctFlags & ACCT_FLAG_DIR_SERV))
            DeleteMenu(hmenu, idmAddDirServ, MF_BYCOMMAND);
        
        GetWindowRect(GetDlgItem(hwnd, IDB_MACCT_ADD), &rc);
        
        TrackPopupMenuEx(hmenu, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, 
        (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)? rc.left : rc.right, rc.top, hwnd, NULL);
        DestroyMenu(hmenu);
    }
}

BOOL SetDefaultAccount(HWND hwnd, HWND hwndList)
{
    LV_ITEM         lvi;
    int             iSel, index;
    IImnAccount     *pAccount;
    BOOL            fRet;
    ACCTTYPE        AcctType;
    TCHAR           szRes[CCHMAX_ACCOUNT_NAME];
    
    fRet = FALSE;
    iSel = ListView_GetFirstSel(hwndList);
    
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = iSel;
    lvi.iSubItem = 0;
    lvi.pszText = szRes;
    lvi.cchTextMax = ARRAYSIZE(szRes);
    if (ListView_GetItem(hwndList, &lvi))
    {
        AcctType = (ACCTTYPE)LOWORD(lvi.lParam);
        Assert(0 == HIWORD(lvi.lParam));
        
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szRes, &pAccount)))
        {
            if (SUCCEEDED(pAccount->SetAsDefault()))
            {
                index = -1;
                lvi.mask = LVIF_PARAM;
                while (-1 != (index = ListView_GetNextItem(hwndList, index, LVNI_ALL)))
                {
                    lvi.iItem = index;
                    if (ListView_GetItem(hwndList, &lvi) &&
                        (ACCTTYPE)(LOWORD(lvi.lParam)) == AcctType &&
                        !!HIWORD(lvi.lParam))
                    {
                        lvi.lParam = MAKELPARAM(AcctType, FALSE);
                        ListView_SetItem(hwndList, &lvi);
                        
                        GetTypeString(szRes, ARRAYSIZE(szRes), AcctType, FALSE);
                        lvi.mask = LVIF_TEXT;
                        lvi.iSubItem = 1;
                        lvi.pszText = szRes;
                        ListView_SetItem(hwndList, &lvi);
                        break;
                    }
                }
                
                lvi.mask = LVIF_PARAM;
                lvi.iItem = iSel;
                lvi.iSubItem = 0;
                lvi.lParam = MAKELPARAM(AcctType, TRUE);
                ListView_SetItem(hwndList, &lvi);
                
                GetTypeString(szRes, ARRAYSIZE(szRes), AcctType, TRUE);
                lvi.mask = LVIF_TEXT;
                lvi.iSubItem = 1;
                lvi.pszText = szRes;
                ListView_SetItem(hwndList, &lvi);
                
                fRet = TRUE;
            }
            
            pAccount->Release();
        }
    }                    
    
    return(fRet);
}

void EnableAcctButtons(HWND hwnd, HWND hwndList, UINT iItem)
{
    BOOL fEnable;
    LV_ITEM lvi;
    
    fEnable = ListView_GetSelectedCount(hwndList);
    
    EnableWindow(GetDlgItem(hwnd, IDB_MACCT_REMOVE), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDB_MACCT_PROP), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDB_MACCT_EXPORT), fEnable);
    
    if (fEnable)
    {
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        fEnable = (
            ListView_GetItem(hwndList, &lvi) &&
            (ACCTTYPE)(LOWORD(lvi.lParam)) != ACCT_DIR_SERV &&
            0 == HIWORD(lvi.lParam));
    }
    
    EnableWindow(GetDlgItem(hwnd, IDB_MACCT_DEFAULT), fEnable);
}

typedef struct tagACCTTAB
{
    ACCTTYPE type;
    DWORD dwAcctFlag;
    UINT iText;
} ACCTTAB;

const static ACCTTAB c_rgAcctTab[ACCT_LAST] = {
    {ACCT_MAIL, ACCT_FLAG_MAIL, idsMailCap},
    {ACCT_NEWS, ACCT_FLAG_NEWS, idsNewsCap},
    {ACCT_DIR_SERV, ACCT_FLAG_DIR_SERV, idsDirectoryServiceCap}
};

const static c_rgAcctListHdrs[] = {idsAccount, idsType, idsConnection};

void InitAccountListDialog(HWND hwnd, HWND hwndList, ACCTDLGINFO *pinfo)
{
    int             i, cTab, nIndex, iTabInit;
    BOOL            fEnable;
    HFONT           hfont, hfontOld;
    POINT           point;
    TC_ITEM         tci;
    IImnAccount     *pAccount;
    LV_HITTESTINFO  lvh;
    LV_COLUMN       lvc;
    RECT            rc;
    TCHAR           szRes[CCHMAX_STRINGRES];
    HIMAGELIST      himl;    
    HWND            hwndTab;
    
    // this button is only interesting when LDAP servers are shown
    if (0 == (pinfo->dwAcctFlags & ACCT_FLAG_DIR_SERV))
        DestroyWindow(GetDlgItem(hwnd, IDB_MACCT_ORDER));
    
    // initialize the tabs
    hwndTab = GetDlgItem(hwnd, IDB_MACCT_TAB);
    cTab = 0;
    iTabInit = -1;
    tci.mask = TCIF_TEXT | TCIF_PARAM;
    tci.pszText = szRes;
    for (i = 0; i < ACCT_LAST; i++)
    {
        if (!!(pinfo->dwAcctFlags & c_rgAcctTab[i].dwAcctFlag))
        {
            LoadString(g_hInstRes, c_rgAcctTab[i].iText, szRes, ARRAYSIZE(szRes));
            tci.lParam = (LPARAM)(c_rgAcctTab[i].dwAcctFlag);
            nIndex = TabCtrl_InsertItem(hwndTab, cTab, &tci);
            Assert(nIndex == cTab);
            
            pinfo->AcctType = c_rgAcctTab[i].type;
            if (pinfo->AcctTypeInit == pinfo->AcctType)
                iTabInit = cTab;
            
            cTab++;
        }
    }
    
    Assert(cTab > 0);
    Assert(iTabInit < cTab);
    
    if (cTab > 1)
    {
        LoadString(g_hInstRes, idsAll, szRes, ARRAYSIZE(szRes));
        tci.lParam = (LPARAM)(pinfo->dwAcctFlags);
        // insert the all tab first
        nIndex = TabCtrl_InsertItem(hwndTab, 0, &tci);
        Assert(nIndex == 0);
        
        TabCtrl_SetCurSel(hwndTab, iTabInit + 1);
    }
    
    DestroyWindow(GetDlgItem(hwnd, cTab == 1 ? IDB_MACCT_ADD : IDB_MACCT_ADD_NOMENU));
    
    // Get client rect
    GetClientRect(hwndList, &rc);
    rc.right = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    
    for (i = 0; i < ARRAYSIZE(c_rgAcctListHdrs); i++)
    {
        LoadString(g_hInstRes, c_rgAcctListHdrs[i], szRes, ARRAYSIZE(szRes));
        lvc.mask = LVCF_WIDTH | LVCF_TEXT;
        lvc.cx = (rc.right / ARRAYSIZE(c_rgAcctListHdrs));
        lvc.pszText = szRes;
        lvc.cchTextMax = lstrlen(szRes);
        ListView_InsertColumn(hwndList, i, &lvc);
    }
    
    // Remove Import Export if not OE
    if (!!(pinfo->dwFlags & ACCT_WIZ_OUTLOOK))
    {
        ShowWindow(GetDlgItem(hwnd, IDB_MACCT_EXPORT), SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDB_MACCT_IMPORT), SW_HIDE);
    }
    
    // Add Folders Imagelist
    himl = ImageList_LoadBitmap(g_hInstRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));
    ListView_SetImageList(hwndList, himl, LVSIL_SMALL); 
    
    // Fill The list view with servers
    Server_InitServerList(hwnd, hwndList, hwndTab, pinfo, NULL);
}

const static HELPMAP g_rgCtxMapAccounts[] = {
    {IDLV_MAIL_ACCOUNTS, IDH_NEWS_SERV_SERVERS},
    {IDB_MACCT_ADD, IDH_NEWS_SERV_ADD},
    {IDB_MACCT_ADD_NOMENU, IDH_NEWS_SERV_ADD},
    {IDB_MACCT_REMOVE, IDH_NEWS_SERV_REMOVE},
    {IDB_MACCT_PROP, IDH_NEWS_SERV_PROPERTIES},
    {IDB_MACCT_DEFAULT, IDH_INETCOMM_SETASDEFAULT},
    {IDB_MACCT_ORDER, IDH_INETCOM_DS_SETORDER},
    {IDB_MACCT_EXPORT, 502},
    {IDB_MACCT_IMPORT, 501},
    {0, 0}};
    
    // This is a standalone dialog box now, it is not in the options property sheet
    INT_PTR CALLBACK ManageAccountsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        int             i, nIndex;
        BOOL            fEnable;
        LV_ITEM         lvi;
        POINT           point;
        LV_HITTESTINFO  lvh;
        ACCTDLGINFO     *pinfo;
        HWND            hwndList = GetDlgItem(hwnd, IDLV_MAIL_ACCOUNTS);
        
        pinfo = (ACCTDLGINFO *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
        
        switch (uMsg)
        {
        case WM_INITDIALOG:
            pinfo = (ACCTDLGINFO *)lParam;
            Assert(pinfo != NULL);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pinfo);
            
            SetIntlFont(hwndList);
            
            InitAccountListDialog(hwnd, hwndList, pinfo);
            return(TRUE);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapAccounts));
            
        case WM_DRAWITEM:
            if (wParam == IDB_MACCT_ADD)
            {
                DrawAddButton(hwnd, (LPDRAWITEMSTRUCT)lParam, pinfo);
                return(TRUE);
            }
            break;
            
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
            case IDOK:
            case IDCANCEL:
                EndDialog(hwnd, IDCANCEL);
                break;
                
            case IDB_MACCT_ADD:
                DoAddAccountMenu(hwnd, pinfo);
                break;
                
            case IDB_MACCT_ADD_NOMENU:
                // this should only get hit if we have only
                // one type of account in the dialog
                Server_Create(hwnd, pinfo->AcctType, pinfo);
                break;
                
            case IDB_MACCT_PROP:
                Server_Properties(hwnd, pinfo);
                break;
                
            case IDB_MACCT_ORDER:
                DialogBox(g_hInstRes, MAKEINTRESOURCE(iddSetOrder), hwnd, SetOrderDlgProc);
                break;
                
            case idmAddNews:
                Server_Create(hwnd, ACCT_NEWS, pinfo);
                break;
                
            case idmAddMail:
                Server_Create(hwnd, ACCT_MAIL, pinfo);
                break;
                
            case idmAddDirServ:
                Server_Create(hwnd, ACCT_DIR_SERV, pinfo);
                break;
                
            case IDB_MACCT_REMOVE:
                Server_RemoveServer(hwnd);
                break;
                
            case IDB_MACCT_EXPORT:
                Server_ExportServer(hwnd);
                break;
                
            case IDB_MACCT_IMPORT:
                Server_ImportServer(hwnd, pinfo);
                break;
                
            case IDB_MACCT_DEFAULT:
                if (SetDefaultAccount(hwnd, hwndList))
                {
                    SetFocus(hwndList);
                    EnableWindow(GetDlgItem(hwnd, IDB_MACCT_DEFAULT), FALSE);
                }
                else
                {
                    AcctMessageBox(hwnd, MAKEINTRESOURCE(idsAccountManager), MAKEINTRESOURCE(idsErrSetDefNoSmtp), NULL, MB_OK | MB_ICONEXCLAMATION);
                }
                break;
            }              
            break;
            
            case WM_NOTIFY:
                LPNMHDR pnmhdr = (LPNMHDR) lParam;
                
                switch (((NMHDR *)lParam)->code)
                {
                case NM_DBLCLK:
                    i = GetMessagePos();
                    point.x = LOWORD(i);
                    point.y = HIWORD(i);
                    ScreenToClient(hwndList, &point);
                    lvh.pt = point;
                    nIndex = ListView_HitTest(hwndList, &lvh);
                    if (nIndex >= 0 && lvh.flags & LVHT_ONITEMLABEL)
                        SendMessage(hwnd, WM_COMMAND, IDB_MACCT_PROP, 0L);
                    break;
                    
                case LVN_ITEMCHANGED:
                    EnableAcctButtons(hwnd, hwndList, ((NM_LISTVIEW *)pnmhdr)->iItem);
                    break;    
                    
                case TCN_SELCHANGE:
                    Server_InitServerList(hwnd, hwndList, pnmhdr->hwndFrom, pinfo, NULL);
                    break;
                }
                break;
        }
        return (FALSE);
    }
    
    void DrawArrow(HDC hdc, int x, int y, int dx, int dy, BOOL fPrev)
    {
        int i, iCount, sign, inc;
        HBRUSH hbrush;
        HGDIOBJ hbrushOld;
        
        hbrush = GetSysColorBrush(COLOR_BTNTEXT);
        hbrushOld = SelectObject(hdc, hbrush);
        
        iCount = (dy + 1) / 2;
        
        // draw arrow body
        // PatBlt(hdc, (fPrev ? x + iCount : x), y + 4, dx - iCount, dy - 8, PATCOPY); 
        
        if (fPrev)
        {
            sign = -1;
            dy = (dy % 2) ? 1 : 2;
            y += iCount - 1;
        }
        else
        {
            sign = 1;
        }
        inc = 2 * sign;
        
        if (!fPrev)
            x += dx - iCount;
        
        // draw arrow head
        for (i = 0; i < iCount; i++, dy -= inc, y += sign)
            PatBlt(hdc, x++, y, 1, dy, PATCOPY);
        
        SelectObject(hdc, hbrushOld);
    }
    
    void DrawAddButton(HWND hwnd, LPDRAWITEMSTRUCT pdi, ACCTDLGINFO *pinfo)
    {
        BOOL fPushed;
        TCHAR sz[32];
        RECT rcArrow, rcText, rcFocus;
        int d, cch;
        
        Assert(pdi->CtlType == ODT_BUTTON);
        Assert(pdi->CtlID == IDB_MACCT_ADD);
        
        fPushed = !!(pdi->itemState & ODS_SELECTED);
        
        rcArrow = pdi->rcItem;
        rcFocus = pdi->rcItem;
        if (fPushed)
        {
            rcArrow.left++;
            rcArrow.right++;
            rcArrow.top++;
            rcArrow.bottom++;
        }
        rcText = rcArrow;
        rcArrow.left = rcArrow.right - (rcArrow.bottom - rcArrow.top);
        rcText.right = rcArrow.left;
        d = GetSystemMetrics(SM_CXEDGE);
        rcText.left += d;
        rcArrow.right -= d;
        rcFocus.left += d;
        rcFocus.right -= d;
        d = GetSystemMetrics(SM_CYEDGE);
        rcArrow.top += d;
        rcArrow.bottom -= d;
        rcText.top = rcArrow.top;
        rcText.bottom  = rcArrow.bottom;
        rcFocus.top = rcArrow.top;
        rcFocus.bottom  = rcArrow.bottom;
        
        if (!!(pdi->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)))
        {
            cch = GetWindowText(pdi->hwndItem, sz, ARRAYSIZE(sz));
            
            DrawFrameControl(pdi->hDC, &pdi->rcItem, DFC_BUTTON, DFCS_BUTTONPUSH | (fPushed ? DFCS_PUSHED : 0));
            
            d = min(rcArrow.bottom - rcArrow.top - 4, 9);
            d = ((rcArrow.bottom - rcArrow.top) - d) / 2;
            rcArrow.top += d;
            rcArrow.bottom -= d;
            rcArrow.right -= d;
            DrawArrow(pdi->hDC, rcArrow.left, rcArrow.top, rcArrow.right - rcArrow.left, rcArrow.bottom - rcArrow.top, FALSE);
            
            DrawText(pdi->hDC, sz, cch, &rcText, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        }
        
        if (!!(pdi->itemAction & ODA_FOCUS) || !!(pdi->itemState & ODS_FOCUS))
        {
            rcFocus.left++;
            rcFocus.right--;
            rcFocus.top++;
            rcFocus.bottom--;
            DrawFocusRect(pdi->hDC, &rcFocus);
        }
    }
    
    int AcctMessageBox(HWND hwndOwner, LPTSTR szTitle, LPTSTR sz1, LPTSTR sz2, UINT fuStyle)
    {
        TCHAR rgchTitle[CCHMAX_STRINGRES];
        TCHAR rgchText[2 * CCHMAX_STRINGRES + 2];
        LPTSTR szText;
        int cch;
        
        Assert(sz1);
        Assert(szTitle != NULL);
        
        if (IS_INTRESOURCE(szTitle))
        {
            // its a string resource id
            cch = LoadString(g_hInstRes, PtrToUlong(szTitle), rgchTitle, CCHMAX_STRINGRES);
            if (cch == 0)
                return(0);
            
            szTitle = rgchTitle;
        }
        
        if (!(IS_INTRESOURCE(sz1)))
        {
            // its a pointer to a string
            Assert(lstrlen(sz1) < CCHMAX_STRINGRES);
            if (NULL == StrCpyN(rgchText, sz1, ARRAYSIZE(rgchText)))
                return(0);
            
            cch = lstrlen(rgchText);
        }
        else
        {
            // its a string resource id
            cch = LoadString(g_hInstRes, PtrToUlong(sz1), rgchText, 2 * CCHMAX_STRINGRES);
            if (cch == 0)
                return(0);
        }
        
        if (sz2)
        {
            //$$REVIEW is this right??
            //$$REVIEW will this work with both ANSI/UNICODE?
            
            // there's another string that we need to append to the
            // first string...
            DWORD cchSizeText = (ARRAYSIZE(rgchText) - cch);
            szText = &rgchText[cch];
            if (cchSizeText < 3)
            {
                Assert(0);      // Why is the buffer too small?
                return 0;
            }
            else
            {
                *szText = '\n';
                szText++;
                cchSizeText--;
                *szText = '\n';
                szText++;
                cchSizeText--;
            
                if (!(IS_INTRESOURCE(sz2)))
                {
                    // its a pointer to a string
                    Assert(lstrlen(sz2) < CCHMAX_STRINGRES);
                    if (NULL == StrCpyN(szText, sz2, cchSizeText))
                        return(0);
                }
                else
                {
                    Assert((2 * CCHMAX_STRINGRES - (szText - rgchText)) > 0);
                    if (0 == LoadString(g_hInstRes, PtrToUlong(sz2), szText, cchSizeText))
                        return(0);
                }
            }
        }
        
        return(MessageBox(hwndOwner, rgchText, szTitle, MB_SETFOREGROUND | fuStyle));
    }
    
#define OPTION_OFF  0xffffffff
    
    void InitCheckCounter(DWORD dw, HWND hwnd, int idcCheck, int idcEdit, int idcSpin, int min, int max, int def)
    {
        BOOL f;
        int digit;
        
        f = (dw != OPTION_OFF);
        CheckDlgButton(hwnd, idcCheck, f ? BST_CHECKED : BST_UNCHECKED);            
        SendDlgItemMessage(hwnd, idcSpin, UDM_SETRANGE, 0, MAKELONG(max, min));
        
        if (!f)
            dw = def;
        
        Assert(min <= (int)dw);
        Assert(max >= (int)dw);
        
        digit = 1;
        while (max >= 10)
        {
            max = max / 10;
            digit++;
        }
        SendDlgItemMessage(hwnd, idcEdit, EM_LIMITTEXT, (WPARAM)digit, 0);
        
        SetDlgItemInt(hwnd, idcEdit, dw, FALSE);
        EnableWindow(GetDlgItem(hwnd, idcEdit), f);
    }
    
    INT_PTR CALLBACK SetOrderDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
        NMHDR *pnmhdr;
        BOOL fRet;
        WORD id;
        HIMAGELIST himl;
        HWND hwndList;
        
        fRet = TRUE;
        
        switch (msg)
        {
        case WM_INITDIALOG:
            hwndList = GetDlgItem(hwnd, IDC_ORDER_LIST);
            SetIntlFont(hwndList);
            
            himl = ImageList_LoadBitmap(g_hInstRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));
            ListView_SetImageList(hwndList, himl, LVSIL_SMALL); 
            
            InitSetOrderList(hwndList);
            
            SetUpDownButtons(hwnd, hwndList);
            break;
            
        case WM_COMMAND:
            id = LOWORD(wParam);
            
            switch (id)
            {
            case IDOK:
                SaveLDAPResolveOrder(hwnd, GetDlgItem(hwnd, IDC_ORDER_LIST));
                
            case IDCANCEL:
                EndDialog(hwnd, id);
                break;
                
            case IDC_UP_BUTTON:
            case IDC_DOWN_BUTTON:
                MoveLDAPItemUpDown(hwnd, id == IDC_UP_BUTTON);
                break;
            }
            break;
            
            case WM_NOTIFY:
                pnmhdr = (NMHDR *)lParam;
                switch (pnmhdr->code)
                {
                case LVN_ITEMCHANGED:
                    SetUpDownButtons(hwnd, GetDlgItem(hwnd, IDC_ORDER_LIST));
                    break;
                }
                break;
                
                default:
                    fRet = FALSE;
                    break;
        }
        
        return(fRet);
    }
    
    void MoveLDAPItemUpDown(HWND hDlg, BOOL bMoveUp)
    {
        int iMoveToIndex;
        TCHAR szBufItem[CCHMAX_ACCOUNT_NAME];
        TCHAR szBufOtherItem[CCHMAX_ACCOUNT_NAME];
        HWND hWndLV = GetDlgItem(hDlg, IDC_ORDER_LIST);
        int iItemIndex = ListView_GetSelectedCount(hWndLV);
        int iListCount = ListView_GetItemCount(hWndLV);
        
        Assert(1 == ListView_GetSelectedCount(hWndLV));
        
        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);
        
        iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
        
        Assert(bMoveUp ? (iItemIndex != 0) : (iItemIndex != (iListCount - 1)));
        
        iMoveToIndex = (bMoveUp) ? (iItemIndex - 1) : (iItemIndex + 1);
        
        // Basically since these list view items have no parameters of interest
        // other than the text, we can swap the text (looks cleaner)
        
        // Get the selected item text
        ListView_GetItemText(hWndLV, iItemIndex, 0,szBufItem, ARRAYSIZE(szBufItem));
        ListView_GetItemText(hWndLV, iMoveToIndex, 0, szBufOtherItem, ARRAYSIZE(szBufOtherItem));
        
        ListView_SetItemText(hWndLV, iMoveToIndex, 0, szBufItem);
        ListView_SetItemText(hWndLV, iItemIndex, 0, szBufOtherItem);
        
        ListView_SetItemState(hWndLV, iMoveToIndex,	LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
        ListView_EnsureVisible (hWndLV, iMoveToIndex, FALSE);
        
        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM)TRUE, 0);
        
        SetUpDownButtons(hDlg, hWndLV);
    }
    
    void SaveLDAPResolveOrder(HWND hwnd, HWND hwndList)
    {
        LV_ITEM lvi;
        IImnAccount *pAcct;
        TCHAR szAcct[CCHMAX_ACCOUNT_NAME];
        int i, cItemCount = ListView_GetItemCount(hwndList);
        
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iSubItem = 0;
        lvi.pszText = szAcct;
        lvi.cchTextMax = ARRAYSIZE(szAcct);
        
        for (i = 0; i < cItemCount; i++)
        {
            lvi.iItem = i;
            if (ListView_GetItem(hwndList, &lvi))
            {
                if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAcct, &pAcct)))
                {
                    if (SUCCEEDED(pAcct->SetPropDw(AP_LDAP_SERVER_ID, (DWORD)lvi.lParam)))
                        pAcct->SaveChanges();
                    pAcct->Release();
                }
            }
        }
    }
    
    void SetUpDownButtons(HWND hDlg, HWND hWndLV)
    {
        HWND hwndUp, hwndDown, hwndFocus, hwndT;
        BOOL fEnable;
        int iItemCount = ListView_GetItemCount(hWndLV);
        int iSelectedItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
        
        hwndT = NULL;
        hwndFocus = GetFocus();
        
        hwndUp = GetDlgItem(hDlg, IDC_UP_BUTTON);
        hwndDown = GetDlgItem(hDlg, IDC_DOWN_BUTTON);
        
#ifdef DEBUG
        if (iItemCount <= 1)
            Assert(hwndFocus != hwndUp && hwndFocus != hwndDown);
#endif // DEBUG
        
        fEnable = (iItemCount > 1 && iSelectedItem >= 1);
        if (!fEnable && hwndUp == hwndFocus)
            hwndT = hwndDown;
        EnableWindow(hwndUp, fEnable);
        
        fEnable = (iItemCount > 1 && iSelectedItem <= (iItemCount - 2));
        if (!fEnable && hwndDown == hwndFocus)
            hwndT = hwndUp;
        EnableWindow(hwndDown, fEnable);
        
        if (hwndT != NULL)
            SetFocus(hwndT);
    }
    
    BOOL InitSetOrderList(HWND hwndList)
    {
        LV_ITEM             lvi;
        TCHAR               szAcct[CCHMAX_ACCOUNT_NAME];
        HRESULT             hr;
        DWORD               dwId, dwIndex=0;
        IImnEnumAccounts   *pEnumAccounts=NULL;
        IImnAccount        *pAccount=NULL;
        
        Assert(hwndList != NULL);
        
        if (FAILED(g_pAcctMan->IEnumerate(SRV_LDAP,
            ENUM_FLAG_RESOLVE_ONLY | ENUM_FLAG_SORT_BY_LDAP_ID,
            &pEnumAccounts)))
            return FALSE;
        
        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        lvi.pszText = szAcct;
        lvi.iImage = iLDAPServer;
        lvi.iSubItem = 0;
        
        // Enumerate accounts
        while (SUCCEEDED(pEnumAccounts->GetNext(&pAccount)))
        {
            if (!FAILED(pAccount->GetPropSz(AP_ACCOUNT_NAME, szAcct, ARRAYSIZE(szAcct))) &&
                !FAILED(pAccount->GetPropDw(AP_LDAP_SERVER_ID, &dwId)))
            {
                lvi.iItem = dwIndex++;
                lvi.lParam = (LPARAM)dwId;
                
                ListView_InsertItem(hwndList, &lvi);
            }
            
            // Release current account
            SafeRelease(pAccount);
        }
        
        // Select the first item if we haven't selected anything       
        ListView_SetItemState(hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);    
        
        // Cleanup
        SafeRelease(pEnumAccounts);
        
        // Done
        return TRUE;
    }
    
    BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap)
    {
        if (uMsg == WM_HELP)
        {
            LPHELPINFO lphi = (LPHELPINFO) lParam;
            if (lphi->iContextType == HELPINFO_WINDOW)   // must be for a control
            {
                OEWinHelp ((HWND)lphi->hItemHandle,
                    c_szAcctCtxHelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)rgCtxMap);
            }
            return (TRUE);
        }
        else if (uMsg == WM_CONTEXTMENU)
        {
            OEWinHelp ((HWND) wParam,
                c_szAcctCtxHelpFile,
                HELP_CONTEXTMENU,
                (ULONG_PTR)rgCtxMap);
            return (TRUE);
        }
        
        Assert(0);
        
        return FALSE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\commnews.h ===
#ifndef _INC_COMMNEWSACT
#define _INC_COMMNEWSACT

typedef struct tagCOMMNEWSACCTINFO
    {
    DWORD_PTR dwCookie;
    char szUserPath[MAX_PATH];
    char szDisplay[CCHMAX_ACCOUNT_NAME];
    } COMMNEWSACCTINFO;

typedef struct tagNEWSSERVERS
{
    struct  tagNEWSSERVERS *pNext;
    char    szServerName[MAX_PATH];
    char    szFilePath[MAX_PATH];
}NEWSSERVERS;

#define NEWSUSERCOLS    512
#define NEWSUSERROWS    4

// {0FF15AA0-2F93-11d1-83B0-00C04FBD7C09}
DEFINE_GUID(CLSID_CEnumCOMMNEWSACCT, 0xff15aa0, 0x2f93, 0x11d1, 0x83, 0xb0, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

class CEnumCOMMNEWSACCT : public IEnumIMPACCOUNTS
    {
    private:
        ULONG           m_cRef;
        int             m_iInfo;
        UINT            m_cInfo;
        COMMNEWSACCTINFO    *m_rgInfo;

    public:
        CEnumCOMMNEWSACCT(void);
        ~CEnumCOMMNEWSACCT(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE Next(IMPACCOUNTINFO *pinfo);
        HRESULT STDMETHODCALLTYPE Reset(void);

        HRESULT Init(COMMNEWSACCTINFO *pinfo, int cinfo);
    };

// {0FF15AA1-2F93-11d1-83B0-00C04FBD7C09}
DEFINE_GUID(CLSID_CCommNewsAcctImport, 0xff15aa1, 0x2f93, 0x11d1, 0x83, 0xb0, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

class CCommNewsAcctImport : public IAccountImport, public IAccountImport2
    {
    private:
        ULONG               m_cRef;
        BOOL                m_fIni;
        TCHAR               m_szIni[MAX_PATH];
        char                *m_szSubList;
        UINT                m_cInfo;
        COMMNEWSACCTINFO    *m_rgInfo;
        NEWSSERVERS         *m_rgServ;
        DWORD               m_nNumServ;
        DWORD               m_dwSelServ;

        HRESULT GetUserPrefs(char *szUserPath, char szUserPrefs[][NEWSUSERCOLS], int nInLoop, BOOL *pbPop);
        HRESULT GetSubListGroups(char *pFileName, char **pListGroups);
        HRESULT GetNumAccounts(DWORD_PTR dwCookie);
        HRESULT IsValidUser(char *pszFilePath);
        HRESULT IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);

    public:
        CCommNewsAcctImport(void);
        ~CCommNewsAcctImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        // Methods from the IAccountImport interface.        
        HRESULT STDMETHODCALLTYPE AutoDetect(DWORD *pcAcct, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum);
        HRESULT STDMETHODCALLTYPE GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct);

        // Methods from the IAccountImport2 interface.
        HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd, DWORD_PTR dwCookie);
        HRESULT STDMETHODCALLTYPE GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);
    };

#endif // _INC_COMMNEWSACT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\autodiscoveryui.h ===
/*****************************************************************************\
    FILE: AutoDiscoveryUI.h

    DESCRIPTION:
        This is AutoDiscovery progress UI for the Outlook Express's email
    configuration wizard.

    BryanSt 1/18/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef FILE_AUTODISCOVERY_H
#define FILE_AUTODISCOVERY_H



//  IID_PPV_ARG(IType, ppType) 
//      IType is the type of pType
//      ppType is the variable of type IType that will be filled
//
//      RESULTS in:  IID_IType, ppvType
//      will create a compiler error if wrong level of indirection is used.
//
//  macro for QueryInterface and related functions
//  that require a IID and a (void **)
//  this will insure that the cast is safe and appropriate on C++
//
//  IID_PPV_ARG_NULL(IType, ppType)
//
//      Just like IID_PPV_ARG, except that it sticks a NULL between the
//      IID and PPV (for IShellFolder::GetUIObjectOf).
//
//  IID_X_PPV_ARG(IType, X, ppType)
//
//      Just like IID_PPV_ARG, except that it sticks X between the
//      IID and PPV (for SHBindToObject).
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#define IID_X_PPV_ARG(IType, X, ppType) IID_##IType, X, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &IID_##IType, (void**)(ppType)
#define IID_X_PPV_ARG(IType, X, ppType) &IID_##IType, X, (void**)(ppType)
#endif
#define IID_PPV_ARG_NULL(IType, ppType) IID_X_PPV_ARG(IType, NULL, ppType)





#endif // FILE_AUTODISCOVERY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\conn_oe.h ===
//ICW help for setting up mail, news, and LDAP server accounts

//Setting up a mail account
#define ICW_SETUP_MAIL                    1000      //no screen-links from other Help topics
#define ICW_MAIL_NAME                       1005      //Your Name screen
#define ICW_MAIL_ADDRESS                 1010     //Internet e-mail Address screen
#define ICW_MAIL_SERVER                   1015       //E-mail Server Names screen
#define ICW_MAIL_LOGON                      1020      //Internet Mail Logon screen
#define ICW_MAIL_ACCOUNT_NAME     1025      //Friendly Name screen
#define ICW_MODIFY_MAIL                      1030      //confirm settings import (mail)
#define ICW_MAIL_MULTIPLE_ACCOUNTS    1032  //Multiple Internet Mail Accounts screen
#define ICW_MAIL_ACCOUNT             1034    //Internet Mail Account and Setting up Internet Mail screens

//Setting up a news server account
#define ICW_SETUP_NEWS                     1035    //overview topic; links from other Help topics
#define ICW_NEWS_NAME                        1040    //Your name screen
#define ICW_NEWS_ADDRESS                1045      //Internet News E-mail Address screen
#define ICW_NEWS_SERVER                   1050     //Internet News Server Name
#define ICW_NEWS_ACCOUNT_NAME     1055   //Friendly name screen
#define ICW_MODIFY_NEWS                       1060  //confirm settings import (news) screen
#define ICW_NEWS_ACCOUNT                   1062  //Internet News account screen

//Setting up an LDAP server account
#define ICW_SETUP_LDAP                           1065  //overview topic; links from other Help topics
#define ICW_LDAP_SERVER                        1070  //Internet Directory Server Name screen
#define ICW_LDAP_LOGON                           1075  //Internet Directory Server Logon screen
#define ICW_LDAP_RESOLVE                       1080  //Check E-mail Addresses screen
#define ICW_LDAP_ACCOUNT_NAME          1085  //Friendly Name screen
#define ICW_COMPLETE                               1090    //Congratulations screen; used on mail, news, and LDAP servers
#define ICW_LDAP_ACCOUNT                      1095  //Internet Directory Service screen
#define ICW_MODIFY_DIRECTORY_SERVICE      1098   //Confirm Settings Import (directory services)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\commact.h ===
#ifndef _INC_COMMACT
#define _INC_COMMACT

typedef struct tagCOMMACCTINFO
    {
    DWORD_PTR dwCookie;
    char szUserPath[MAX_PATH];
    char szDisplay[CCHMAX_ACCOUNT_NAME];
    } COMMACCTINFO;

#define USERCOLS    512
#define USERROWS    8

// {1AA06BA0-0E88-11d1-8391-00C04FBD7C09}
DEFINE_GUID(CLSID_CEnumCOMMACCTS, 0x1aa06ba0, 0xe88, 0x11d1, 0x83, 0x91, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

class CEnumCOMMACCTS : public IEnumIMPACCOUNTS
    {
    private:
        ULONG           m_cRef;
        int             m_iInfo;
        UINT            m_cInfo;
        COMMACCTINFO    *m_rgInfo;

    public:
        CEnumCOMMACCTS(void);
        ~CEnumCOMMACCTS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE Next(IMPACCOUNTINFO *pinfo);
        HRESULT STDMETHODCALLTYPE Reset(void);

        HRESULT Init(COMMACCTINFO *pinfo, int cinfo);
    };

// {1AA06BA1-0E88-11d1-8391-00C04FBD7C09}
DEFINE_GUID(CLSID_CCommAcctImport, 0x1aa06ba1, 0xe88, 0x11d1, 0x83, 0x91, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

class CCommAcctImport : public IAccountImport, public IAccountImport2
    {
    private:
        ULONG           m_cRef;
        BOOL            m_fIni;
        TCHAR           m_szIni[MAX_PATH];
        UINT            m_cInfo;
        COMMACCTINFO    *m_rgInfo;

        HRESULT GetUserPrefs(char *szUserPath, char szUserPrefs[][USERCOLS], int nInLoop, BOOL *pbPop);
        HRESULT STDMETHODCALLTYPE IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);

    public:
        CCommAcctImport(void);
        ~CCommAcctImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE AutoDetect(DWORD *pcAcct, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum);
        HRESULT STDMETHODCALLTYPE GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct);

        HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd, DWORD_PTR dwCookie);
        HRESULT STDMETHODCALLTYPE GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);
    };

#endif // _INC_COMMACT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\connect.h ===
/*
 *    c o n n e c t . h
 *    
 *    Purpose:
 *        Implements connection dialog tab page
 *    
 *    Owner:
 *        brettm.
 *    
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 */


#ifndef _CONNECT_H
#define _CONNECT_H

#include "ras.h"

INT_PTR CALLBACK ConnectPage_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL ConnectPage_EditConnection(HWND hDlg);
BOOL ConnectPage_MakeNewConnection(HWND hDlg);
void ConnectPage_InitDialog(HWND hwnd, LPSTR lpszEntryName, LPSTR lpszBackup, DWORD iConnectType, BOOL fFirstInit);
void ConnectPage_WMCommand(HWND hwnd, HWND hwndCmd, int id, WORD wCmd, IImnAccount *pAcct);

#endif //_CONNECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\connect.cpp ===
/*
 *    c o n n e c t . c p p
 *    
 *    Purpose:
 *        Implements connection dialog tab page
 *    
 *    Owner:
 *        brettm.
 *    
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 */
#include "pch.hxx"
#include <commctrl.h>
#include <imnxport.h>
#include "acctman.h"
#include "acctui.h"
#include "connect.h"
#include "dllmain.h"
#include "resource.h"
#include "accthelp.h"
#include "server.h"
#include "demand.h"

ASSERTDATA

/*
 *  p r o t o t y p e s
 *
 */

void EnableConnectoidWindows(HWND hwnd)
{
    BOOL fEnable, fLan;
    HWND hwndCombo, hwndModem;

    hwndModem = GetDlgItem(hwnd, IDC_MODEM_CHECK);

    fLan = (BST_CHECKED == IsDlgButtonChecked(hwnd, idcLan));
    if (hwndModem != NULL)
        EnableWindow(hwndModem, fLan);

    if (fLan &&
        hwndModem != NULL &&
        BST_CHECKED == Button_GetCheck(hwndModem))
        fEnable = TRUE;
    else if (BST_CHECKED == IsDlgButtonChecked(hwnd, idcRas))
        fEnable = TRUE;
    else
        fEnable = FALSE;

    hwndCombo = GetDlgItem(hwnd, idcRasConnection);
    EnableWindow(hwndCombo, fEnable);

    EnableWindow(GetDlgItem(hwnd, idcRasAdd), fEnable);
    EnableWindow(GetDlgItem(hwnd, idcRasDesc), fEnable);
    EnableWindow(GetDlgItem(hwnd, idchkConnectOnStartup), fEnable);
    
    if (fEnable)
        fEnable = (ComboBox_GetCurSel(hwndCombo) != CB_ERR);

    EnableWindow(GetDlgItem(hwnd, idcRasProp), fEnable);
}

void ConnectPage_InitDialog(HWND hwnd, LPSTR szEntryName, LPSTR szBackup, DWORD iConnectType, BOOL fFirstInit)
{
    HWND    hwndCombo, hwndModem;
    int     iSel;
    DWORD   dw;

    Assert(szEntryName != NULL);

    hwndCombo = GetDlgItem(hwnd, idcRasConnection);
    if (fFirstInit)
        {
        SetIntlFont(hwndCombo);

        HrFillRasCombo(hwndCombo, FALSE, NULL);
        }
    
    // Fill in the connection type and if the person already has a
    // RAS connection set up make the combo box select that one by 
    // default
    CheckRadioButton(hwnd, idcLan, idcRas, idcLan + iConnectType);

    hwndModem = GetDlgItem(hwnd, IDC_MODEM_CHECK);

    if (iConnectType == CONNECTION_TYPE_LAN &&
        hwndModem != NULL &&
        szBackup != NULL)
        {
        Button_SetCheck(hwndModem, BST_CHECKED);
        szEntryName = szBackup;
        }
    
    iSel = (*szEntryName != 0) ? ComboBox_FindStringExact(hwndCombo, -1, szEntryName) : 0;
    ComboBox_SetCurSel(hwndCombo, iSel);

    EnableConnectoidWindows(hwnd);
}

// if pAcct is NULL, we're in the wizard, otherwise we're in the prop sheet
void ConnectPage_WMCommand(HWND hwnd, HWND hwndCmd, int id, WORD wCmd, IImnAccount *pAcct)
    {
    BOOL fEnable;

    if (wCmd == BN_CLICKED)
        {
        switch (id)
            {
            case idcRasAdd:
                ConnectPage_MakeNewConnection(hwnd);
                EnableWindow(GetDlgItem(hwnd, idcRasProp), 
                         ComboBox_GetCurSel(GetDlgItem(hwnd, idcRasConnection)) != CB_ERR);
                break;
            
            case idcRasProp:
                ConnectPage_EditConnection(hwnd);
                break;
            
            default:
                EnableConnectoidWindows(hwnd);

                if (pAcct != NULL)
                    {
                    PropSheet_Changed(GetParent(hwnd), hwnd);
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SETDIRTY, PAGE_RAS);
                    }
                break;
            }
        }
    else if (wCmd == CBN_SELENDOK && id == idcRasConnection)    
        {
        EnableConnectoidWindows(hwnd);

        if (pAcct != NULL)
            {
            PropSheet_Changed(GetParent(hwnd), hwnd);
            PropSheet_QuerySiblings(GetParent(hwnd), SM_SETDIRTY, PAGE_RAS);
            }
        }
    }

const static HELPMAP g_rgCtxMapConnect[] = {
                               {idcLan, IDH_NEWS_SERV_CNKT_LAN},
                               {idcManual, IDH_NEWS_SERV_CNKT_MAN},
                               {idcRas, IDH_NEWS_SERV_CNKT_DIALUP},
                               {idcRasDesc, IDH_NEWS_SERV_CNKT_DIALUP_CONNECT},
                               {idcRasConnection, IDH_NEWS_SERV_CNKT_DIALUP_CONNECT},
                               {idcRasProp, IDH_NEWS_SERV_CNKT_PROPS},
                               {idcRasAdd, IDH_NEWS_SERV_CNKT_ADD},
                               {idchkConnectOnStartup, IDH_INETCOMM_AUTO_CONNECT},
                               {IDC_MODEM_CHECK, IDH_CONNECTION_VIA_MODEM},
                               {0,0}};

INT_PTR CALLBACK ConnectPage_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    ACCTTYPE        type;
    NMHDR          *pnmh;
    CAccount       *pAcct;
    BOOL            fModem;
    int             iSel;
    HWND            hwndModem, hwndCombo;
    SERVER_TYPE     sfType;
    char           *psz, szEntryName[CCHMAX_CONNECTOID], szBackup[CCHMAX_CONNECTOID];
    TCHAR           szRes[CCHMAX_STRINGRES];
    DWORD           dw, dwFlags;

    pAcct = (CAccount *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get the ServerParams and store them in our extra bytes
            pAcct = (CAccount *)((PROPSHEETPAGE *)lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pAcct);
            Assert(pAcct);
            
            pAcct->GetAccountType(&type);
            Assert(type == ACCT_MAIL || type == ACCT_NEWS);

            // Get the connection info    
            if (FAILED(pAcct->GetPropSz(AP_RAS_CONNECTOID, szEntryName, ARRAYSIZE(szEntryName))))
                szEntryName[0] = 0;
            if (FAILED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dw)))
                dw = CONNECTION_TYPE_LAN;

            if (!!(pAcct->m_dwDlgFlags & ACCTDLG_BACKUP_CONNECT) &&
                SUCCEEDED(pAcct->GetPropSz(AP_RAS_BACKUP_CONNECTOID, szBackup, ARRAYSIZE(szBackup))))
                {
                psz = szBackup;
                }
            else
                {
                psz = NULL;
                }

            ConnectPage_InitDialog(hwnd, szEntryName, psz, dw, TRUE);

            if (FAILED(pAcct->GetPropDw(AP_RAS_CONNECTION_FLAGS, &dw)))
                dw = 0;
            Button_SetCheck(GetDlgItem(hwnd, idchkConnectOnStartup), !!(dw & CF_AUTO_CONNECT) ? BST_CHECKED : BST_UNCHECKED);

            if (type == ACCT_MAIL)
                {
                LoadString(g_hInstRes, idsMailConDlgLabel, szRes, ARRAYSIZE(szRes));
                SetWindowText(GetDlgItem(hwnd, idcRasDlgLabel), szRes);

                // figure out what kind of server we are
                PropSheet_QuerySiblings(GetParent(hwnd), MSM_GETSERVERTYPE, (LPARAM)&sfType);

                if (sfType == SERVER_MAIL || sfType == SERVER_IMAP)
                    ShowWindow(GetDlgItem(hwnd, idchkConnectOnStartup), SW_HIDE);
                }

            PropSheet_QuerySiblings(GetParent(hwnd), SM_INITIALIZED, PAGE_RAS);
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            return (TRUE);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapConnect);

        case WM_COMMAND:
            ConnectPage_WMCommand(hwnd, GET_WM_COMMAND_HWND(wParam, lParam),
                                        GET_WM_COMMAND_ID(wParam, lParam),
                                        GET_WM_COMMAND_CMD(wParam, lParam),
                                        pAcct);
            return (TRUE);

        case WM_NOTIFY:
            pnmh = (NMHDR *)lParam;
            switch (pnmh->code)
                {
                case PSN_APPLY:
                    // BEGIN validation

                    hwndCombo = GetDlgItem(hwnd, idcRasConnection);
                    
                    fModem = FALSE;

                    if (IsDlgButtonChecked(hwnd, idcLan))
                        {
                        dw = CONNECTION_TYPE_LAN;

                        hwndModem = GetDlgItem(hwnd, IDC_MODEM_CHECK);
                        if (hwndModem != NULL)
                            fModem = Button_GetCheck(hwndModem);
                        }
                    else if (IsDlgButtonChecked(hwnd, idcManual))
                        {
                        dw = CONNECTION_TYPE_MANUAL;
                        }
                    else
                        {
                        dw = CONNECTION_TYPE_RAS;
                        }

                    if (dw == CONNECTION_TYPE_RAS || fModem)
                        {
                        iSel = ComboBox_GetCurSel(hwndCombo);
                        if (iSel == CB_ERR)
                            {
                            SetFocus(hwndCombo);
                            InvalidAcctProp(hwnd, NULL, idsErrChooseConnection, iddServerProp_Connect);
                            return(TRUE);
                            }

                        ComboBox_GetLBText(hwndCombo, iSel, szEntryName);
                        }

                    // END validation

                    pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, dw);

                    if (fModem)
                        pAcct->SetPropSz(AP_RAS_BACKUP_CONNECTOID, szEntryName);
                    else
                        pAcct->SetProp(AP_RAS_BACKUP_CONNECTOID, NULL, 0);

                    dwFlags = 0;
                    if (dw != CONNECTION_TYPE_RAS)
                        {
                        pAcct->SetProp(AP_RAS_CONNECTOID, NULL, 0);
                        }
                    else
                        {
                        pAcct->SetPropSz(AP_RAS_CONNECTOID, szEntryName);

                        // figure out what kind of server we are
                        pAcct->GetAccountType(&type);
                        if (type == ACCT_MAIL)
                            PropSheet_QuerySiblings(GetParent(hwnd), MSM_GETSERVERTYPE, (LPARAM)&sfType);
                        else
                            sfType = SERVER_NEWS;

                        if (sfType != SERVER_MAIL)
                            {
                            if (IsDlgButtonChecked(hwnd, idchkConnectOnStartup))
                                dwFlags = CF_AUTO_CONNECT;
                            }
                        }
                    pAcct->SetPropDw(AP_RAS_CONNECTION_FLAGS, dwFlags);
                
                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    dw = PAGE_RAS;
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SAVECHANGES, (LPARAM)&dw);
                    if (dw == -1)
                        {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return(TRUE);
                        }
                    break;
                }

            return(TRUE);
        }

    return (FALSE);
    }

/*******************************************************************

    NAME:       EditConnectoid

    SYNOPSIS:   Brings up RNA dialog for connectoid properties for
                selected connectoid

********************************************************************/
BOOL ConnectPage_EditConnection(HWND hDlg)
    {
    BOOL    fRet = FALSE;
    HWND    hwndCombo = GetDlgItem(hDlg, idcRasConnection);

    Assert(hwndCombo);
    // shouldn't get here unless there is selection in combo box
    Assert(ComboBox_GetCurSel(hwndCombo) >= 0);

    TCHAR szEntryName[RAS_MaxEntryName + 1] = "";
    ComboBox_GetText(hwndCombo, szEntryName, sizeof(szEntryName));

    if (lstrlen(szEntryName))
        {
        if (SUCCEEDED(HrEditPhonebookEntry(hDlg, szEntryName, NULL)))
            fRet = TRUE;
        }
    return fRet;
    }



/*******************************************************************

    NAME:       MakeNewConnectoid

    SYNOPSIS:   Launches RNA new connectoid wizard; selects newly
                created connectoid (if any) in combo box

********************************************************************/
BOOL ConnectPage_MakeNewConnection(HWND hDlg)
    {
    BOOL fRet=FALSE;
    
    if (SUCCEEDED(HrCreatePhonebookEntry(hDlg, NULL)))
        {
        HWND hwndCombo = GetDlgItem(hDlg, idcRasConnection);
        Assert(hwndCombo);
        HrFillRasCombo(hwndCombo, TRUE, NULL);
        fRet = TRUE;
        }
    else
        {
        // Bug #27986 - Let the user know why we failed do do anything, eh?
        AcctMessageBox(hDlg, MAKEINTRESOURCE(idsAccountManager), MAKEINTRESOURCE(idsErrNoRas1),
                      MAKEINTRESOURCE(idsErrNoRas2), MB_OK | MB_ICONINFORMATION);
        }
    return fRet;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\commact.cpp ===
#include "pch.hxx"
#include <imnact.h>
#include <acctimp.h>
#include <dllmain.h>
#include <resource.h>
#include "CommAct.h"

ASSERTDATA

CCommAcctImport::CCommAcctImport()
    {
    m_cRef = 1;
    m_fIni = FALSE;
    *m_szIni = 0;
    m_cInfo = 0;
    m_rgInfo = NULL;
    }

CCommAcctImport::~CCommAcctImport()
    {
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
    }

STDMETHODIMP CCommAcctImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IUnknown == riid)
		*ppv = (IAccountImport *)this;
	else if (IID_IAccountImport == riid)
		*ppv = (IAccountImport *)this;
	else if (IID_IAccountImport2 == riid)
		*ppv = (IAccountImport2 *)this;

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
    }

STDMETHODIMP_(ULONG) CCommAcctImport::AddRef()
    {
    return(++m_cRef);
    }

STDMETHODIMP_(ULONG) CCommAcctImport::Release()
    {
    if (--m_cRef == 0)
        {
        delete this;
        return(0);
        }

    return(m_cRef);
    }

const static char c_szRegNscp[] = "Software\\Netscape\\Netscape Navigator\\Users";
const static char c_szRegMail[] = "Mail";
const static char c_szRegUser[] = "User";
const static char c_szRegDirRoot[] = "DirRoot";

const static char c_szEmpty[] = "";
const static char c_szIni[] = "ini";
const static char c_szNetscape[] = "Netscape";

const static char c_szPopServer[] = "POP_Server";
const static char c_szSmtpServer[] = "SMTP_Server";
const static char c_szPopName[] = "POP Name";
const static char c_szUserName[] = "User_Name";
const static char c_szUserAddr[] = "User_Addr";

HRESULT STDMETHODCALLTYPE CCommAcctImport::AutoDetect(DWORD *pcAcct, DWORD dwFlags)
    {
    HRESULT hr;
    DWORD   dwNumSubKeys    =   0;
    DWORD   dwIndex         =   0;
    HRESULT hrUser          =   E_FAIL;
    DWORD   cb              =   MAX_PATH;
    char    szUserName[MAX_PATH];
    char    szUserProfile[MAX_PATH];
    char    szUserPrefs[2][USERCOLS];
    HKEY    hkey, 
            hkeyUsers;
    char    szPop[MAX_PATH], *psz, szExpanded[MAX_PATH];
    DWORD   dwType;
    long    lRetVal         =   0;


    Assert(m_cInfo == 0);
    if (pcAcct == NULL)
        return(E_INVALIDARG);

    hr = S_FALSE;
    *pcAcct = 0;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegNscp, 0, KEY_ALL_ACCESS, &hkey))
        {
//          TODO : Fill up the m_rgInfo array with the info of all 
//          the users who have accounts in Communicator.
            if(ERROR_SUCCESS == RegQueryInfoKey( hkey, NULL, NULL, 0, &dwNumSubKeys, 
                                  NULL, NULL, NULL, NULL, NULL, NULL, NULL ) && (dwNumSubKeys > 0))
            {
                if (!MemAlloc((void **)&m_rgInfo, dwNumSubKeys * sizeof(COMMACCTINFO)))
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }

                while(ERROR_SUCCESS == RegEnumKeyEx(hkey, dwIndex, szUserName, &cb, NULL, NULL, NULL, NULL))
                {
                    if(ERROR_SUCCESS == RegOpenKeyEx(hkey, szUserName, 0, KEY_ALL_ACCESS, &hkeyUsers))
                    {
                        cb = sizeof(szUserProfile);
                        if(ERROR_SUCCESS == (lRetVal = RegQueryValueEx(hkeyUsers, c_szRegDirRoot, NULL, &dwType, (LPBYTE)szUserProfile, &cb )))
                        {
                            if (REG_EXPAND_SZ == dwType)
                            {
                                ExpandEnvironmentStrings(szUserProfile, szExpanded, ARRAYSIZE(szExpanded));
                                psz = szExpanded;
                            }
                            else
                                psz = szUserProfile;
                            
                            //save vals into the m_rgInfo structure
                            hrUser = GetUserPrefs(psz, szUserPrefs, 2, NULL);
                            if(!FAILED(hrUser))
                            {
                                m_rgInfo[m_cInfo].dwCookie = m_cInfo;
                                StrCpyNA(m_rgInfo[m_cInfo].szUserPath, psz, ARRAYSIZE(m_rgInfo[m_cInfo].szUserPath));
                                StrCpyNA(m_rgInfo[m_cInfo].szDisplay, szUserName, ARRAYSIZE(m_rgInfo[m_cInfo].szDisplay));
                                m_cInfo++;
                            }
                        }
                        RegCloseKey(hkeyUsers);
                    }
                    dwIndex++;
                    if(dwIndex == dwNumSubKeys)
                        hr = S_OK;
                }
            }
        }

    if (hr == S_OK)
    {
        *pcAcct = m_cInfo;
    }

done:
//      Close the reg key now....
        RegCloseKey(hkey);

    return(hr);
    }

HRESULT STDMETHODCALLTYPE CCommAcctImport::EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum)
    {
    CEnumCOMMACCTS *penum;
    HRESULT hr;

    if (ppEnum == NULL)
        return(E_INVALIDARG);

    *ppEnum = NULL;

    if (m_cInfo == 0)
        return(S_FALSE);
    Assert(m_rgInfo != NULL);

    penum = new CEnumCOMMACCTS;
    if (penum == NULL)
        return(E_OUTOFMEMORY);

    hr = penum->Init(m_rgInfo, m_cInfo);
    if (FAILED(hr))
        {
        penum->Release();
        penum = NULL;
        }

    *ppEnum = penum;

    return(hr);
    }

HRESULT STDMETHODCALLTYPE CCommAcctImport::GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct)
{
    if (pAcct == NULL)
        return(E_INVALIDARG);
    
    return(IGetSettings(dwCookie, pAcct, NULL));
}

HRESULT STDMETHODCALLTYPE CCommAcctImport::GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
{
    if (pAcct == NULL ||
        pInfo == NULL)
        return(E_INVALIDARG);
    
    return(IGetSettings(dwCookie, pAcct, pInfo));
}

HRESULT STDMETHODCALLTYPE CCommAcctImport::IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
{
    HKEY hkey, hkeyT;
    COMMACCTINFO *pinfo;
    char szUserPrefs[USERROWS][USERCOLS];
    char sz[512];
    DWORD cb, type;
    HRESULT hr;
    BOOL bPop   =   TRUE;

    ZeroMemory(szUserPrefs, USERCOLS*USERROWS*sizeof(char));

    Assert(((int)dwCookie) >= 0 && dwCookie < (DWORD_PTR)m_cInfo);
    pinfo = &m_rgInfo[dwCookie];
    
    Assert(pinfo->dwCookie == dwCookie);

    hr = pAcct->SetPropSz(AP_ACCOUNT_NAME, pinfo->szDisplay);
    if (FAILED(hr))
        return(hr);

    hr = GetUserPrefs(pinfo->szUserPath, szUserPrefs, USERROWS, &bPop);
    Assert(!FAILED(hr));
   
    if(lstrlen(szUserPrefs[0]))
    {
        hr = pAcct->SetPropSz(AP_SMTP_SERVER, szUserPrefs[0]);
        Assert(!FAILED(hr));
    }

    if(lstrlen(szUserPrefs[1]))
    {
        hr = pAcct->SetPropSz(bPop ? AP_POP3_SERVER : AP_IMAP_SERVER, szUserPrefs[1]);
        Assert(!FAILED(hr));
    }

    if(lstrlen(szUserPrefs[3]))
    {
        hr = pAcct->SetPropSz(bPop ? AP_POP3_USERNAME : AP_IMAP_USERNAME, szUserPrefs[3]);
        Assert(!FAILED(hr));
    }

    if(lstrlen(szUserPrefs[4]))
    {
        hr = pAcct->SetPropSz(AP_SMTP_DISPLAY_NAME, szUserPrefs[4]);
        Assert(!FAILED(hr));
    }

    if(lstrlen(szUserPrefs[5]))
    {
        hr = pAcct->SetPropSz(AP_SMTP_EMAIL_ADDRESS, szUserPrefs[5]);
        Assert(!FAILED(hr));
    }

    if(!lstrcmp(szUserPrefs[6], "true"))
    {
        hr = pAcct->SetPropDw(AP_POP3_LEAVE_ON_SERVER, 1);
        Assert(!FAILED(hr));
    }

    if(lstrlen(szUserPrefs[7]))
    {
        hr = pAcct->SetPropSz(AP_SMTP_REPLY_EMAIL_ADDRESS, szUserPrefs[7]);
        Assert(!FAILED(hr));
    }

    if (pInfo != NULL)
    {
        // TODO: can we do any better than this???
        pInfo->dwConnect = CONN_USE_DEFAULT;
    }
    
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CCommAcctImport::InitializeImport(HWND hwnd, DWORD_PTR dwCookie)
{
    return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CCommAcctImport::GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved)
{
    return(E_NOTIMPL);
}

const static char c_szSearch[USERROWS][USERCOLS]  = {"user_pref(\"network.hosts.smtp_server\"", 
                                             "user_pref(\"network.hosts.pop_server\"",
                                             "user_pref(\"mail.server_type\"", 
                                             "user_pref(\"mail.pop_name\"",
                                             "user_pref(\"mail.identity.username\"", 
                                             "user_pref(\"mail.identity.useremail\"",
                                             "user_pref(\"mail.leave_on_server\"",
                                             "user_pref(\"mail.identity.reply_to\""}; 
const static char c_szPrefs[]             =  "\\prefs.js";

HRESULT CCommAcctImport::GetUserPrefs(char *szUserPath, char szUserPrefs[][USERCOLS], int nInLoop, BOOL *pbPop)
{
    HRESULT hr                      =   E_FAIL;
    char	szTemp[MAX_PATH * 2];
	char	szDirpath[250];
	char	szLine[1000];
	char	szCompare[1000];
	int		nLine					=	0;
    int     nFilled                 =   0;
	int		nPosition				=	0;
    int     nLoop                   =   nInLoop;
	HANDLE	hJSHandle				=	NULL;
	HANDLE	hJSFile					=	NULL;
	ULONG	cbJSFile				=	0;
	BYTE	*pBegin					=	NULL, 
			*pCurr					=	NULL, 
			*pEnd					=	NULL;
			
    Assert(nInLoop <= USERROWS);
	StrCpyN(szTemp, szUserPath, ARRAYSIZE(szTemp));
	StrCatBuff(szTemp, c_szPrefs, ARRAYSIZE(szTemp));

	hJSHandle = CreateFile( szTemp, GENERIC_READ, FILE_SHARE_READ, NULL, 
							OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

	if(hJSHandle == INVALID_HANDLE_VALUE)
		return hr;

	cbJSFile = GetFileSize(hJSHandle, NULL);

	hJSFile = CreateFileMapping(hJSHandle, NULL, PAGE_READONLY, 0, 0, NULL);

	if(hJSFile == NULL)
    {
        CloseHandle(hJSHandle);        
		return hr;
    }

    pBegin = (BYTE *)MapViewOfFile( hJSFile, FILE_MAP_READ, 0, 0, 0);

	if(pBegin == NULL)
    {
        CloseHandle(hJSHandle);
        CloseHandle(hJSFile);
		return hr;
    }

	pCurr = pBegin;
	pEnd = pCurr + cbJSFile;
	
    while (pCurr < pEnd)
	{
		szLine[nLine] = *pCurr; //keep storing here. will be used for comparing later. 
		if((pCurr[0] == 0x0D) && (pCurr[1] == 0x0A))
		{
            while(nLoop)
            {
                StrCpyN(szCompare, szLine, lstrlen(c_szSearch[nLoop - 1]) + 1);
				if(lstrcmp(szCompare, c_szSearch[nLoop - 1]) == 0)   
				{
                    //Found a UserPref one of the things we are looking for"!
					//Extract the stuff we want.
					nPosition	=	lstrlen(c_szSearch[nLoop - 1]);
					
					while (((szLine[nPosition] == '"')||(szLine[nPosition] == ' ')||(szLine[nPosition] == ',')) &&(nPosition < nLine))
						nPosition++;
					StrCpyN(szDirpath, &szLine[nPosition], nLine - nPosition);

					//Now trim the trailing edge!!!

					nPosition	=	lstrlen(szDirpath) - 1;
					while((szDirpath[nPosition] == '"') || (szDirpath[nPosition] == ')')||(szDirpath[nPosition] == ';')) 
					{
						szDirpath[nPosition] = '\0';
						nPosition	=	lstrlen(szDirpath) - 1;
					}
 
                    StrCpyN(szUserPrefs[nLoop - 1], szDirpath, USERCOLS);
                    nFilled++;
                    if(nFilled == nInLoop)
                        break;
				}
                nLoop--;
			}
            nLoop = nInLoop;
			nLine = -1; //the nLine++ that follows will make nLine zero.
			pCurr++;
		}
        if(nFilled == nInLoop)
            break;
		pCurr++;
		nLine++;
	}

    if(hJSHandle != INVALID_HANDLE_VALUE)
        CloseHandle(hJSHandle);

    if(pBegin)
        UnmapViewOfFile(pBegin);

    if(hJSFile)
        CloseHandle(hJSFile);

	if(nFilled == 0)
        return E_FAIL;
	else
    {
        if(nInLoop == 2)    //If this function was called only to check the server enties...
        {
            if(lstrlen(szUserPrefs[1]))
                return S_OK;
            else
                return E_FAIL;
        }
        else
        {
            if(lstrlen(szUserPrefs[2]))
            {
                if(lstrcmp(szUserPrefs[2], "1")) 
                    *pbPop = TRUE;
                else
                    *pbPop = FALSE;
            }
            else
                *pbPop = TRUE;
            return S_OK;
        }
    }
}

CEnumCOMMACCTS::CEnumCOMMACCTS()
    {
    m_cRef = 1;
    // m_iInfo
    m_cInfo = 0;
    m_rgInfo = NULL;
    }

CEnumCOMMACCTS::~CEnumCOMMACCTS()
    {
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
    }

STDMETHODIMP CEnumCOMMACCTS::QueryInterface(REFIID riid, LPVOID *ppv)
    {

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
	else if (IID_IEnumIMPACCOUNTS == riid)
		*ppv = (IEnumIMPACCOUNTS *)this;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();
    else
        return(E_NOINTERFACE);

    return(S_OK);
    }

STDMETHODIMP_(ULONG) CEnumCOMMACCTS::AddRef()
    {
    return(++m_cRef);
    }

STDMETHODIMP_(ULONG) CEnumCOMMACCTS::Release()
    {
    if (--m_cRef == 0)
        {
        delete this;
        return(0);
        }

    return(m_cRef);
    }

HRESULT STDMETHODCALLTYPE CEnumCOMMACCTS::Next(IMPACCOUNTINFO *pinfo)
    {
    if (pinfo == NULL)
        return(E_INVALIDARG);

    m_iInfo++;
    if ((UINT)m_iInfo >= m_cInfo)
        return(S_FALSE);

    Assert(m_rgInfo != NULL);

    pinfo->dwCookie = m_rgInfo[m_iInfo].dwCookie;
    pinfo->dwReserved = 0;
    StrCpyN(pinfo->szDisplay, m_rgInfo[m_iInfo].szDisplay, ARRAYSIZE(pinfo->szDisplay));

    return(S_OK);
    }

HRESULT STDMETHODCALLTYPE CEnumCOMMACCTS::Reset()
    {
    m_iInfo = -1;

    return(S_OK);
    }

HRESULT CEnumCOMMACCTS::Init(COMMACCTINFO *pinfo, int cinfo)
    {
    DWORD cb;

    Assert(pinfo != NULL);
    Assert(cinfo > 0);

    cb = cinfo * sizeof(COMMACCTINFO);
    
    if (!MemAlloc((void **)&m_rgInfo, cb))
        return(E_OUTOFMEMORY);

    m_iInfo = -1;
    m_cInfo = cinfo;
    CopyMemory(m_rgInfo, pinfo, cb);

    return(S_OK);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\commnews.cpp ===
#include "pch.hxx"
#include <imnact.h>
#include <acctimp.h>
#include <dllmain.h>
#include <resource.h>
#include "CommNews.h"
#include "newimp.h"
#include "ids.h"

ASSERTDATA

INT_PTR CALLBACK SelectServerDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
const static char c_szNescapeMapFile[]  = "netscape-newsrc-map-file";
#define MEMCHUNK    512

CCommNewsAcctImport::CCommNewsAcctImport()
    {
    m_cRef = 1;
    m_fIni = FALSE;
    *m_szIni = 0;
    m_cInfo = 0;
    m_rgInfo = NULL;
    m_szSubList = NULL;
    m_rgServ = NULL;
    m_nNumServ = 0;
    }

CCommNewsAcctImport::~CCommNewsAcctImport()
{
    NEWSSERVERS *pTempServ  = m_rgServ;
    NEWSSERVERS *pNextServ  = pTempServ;

    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
    
    if(m_szSubList != NULL)
        MemFree(m_szSubList);
    
    while(pTempServ)
    {
        pNextServ  = pTempServ->pNext;
        delete(pTempServ);
        pTempServ = pNextServ;
    }
}

STDMETHODIMP CCommNewsAcctImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IUnknown == riid || riid == IID_IAccountImport)
		*ppv = (IAccountImport *)this;
    else if (IID_IAccountImport2 == riid)
        *ppv = (IAccountImport2 *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
    }

STDMETHODIMP_(ULONG) CCommNewsAcctImport::AddRef()
    {
    return(++m_cRef);
    }

STDMETHODIMP_(ULONG) CCommNewsAcctImport::Release()
    {
    if (--m_cRef == 0)
        {
        delete this;
        return(0);
        }

    return(m_cRef);
    }

const static char c_szRegNscp[] = "Software\\Netscape\\Netscape Navigator\\Users";
const static char c_szRegMail[] = "Mail";
const static char c_szRegUser[] = "User";
const static char c_szRegDirRoot[] = "DirRoot";

HRESULT STDMETHODCALLTYPE CCommNewsAcctImport::AutoDetect(DWORD *pcAcct, DWORD dwFlags)
    {
    HRESULT hr;
    DWORD   dwNumSubKeys    =   0;
    DWORD   dwIndex         =   0;
    HRESULT hrUser          =   E_FAIL;
    DWORD   cb              =   MAX_PATH;
    char    szUserName[MAX_PATH];
    char    szUserProfile[MAX_PATH];
    char    szUserPrefs[2][NEWSUSERCOLS], szExpanded[MAX_PATH], *psz;
    HKEY    hkey, 
            hkeyUsers;
    char    szPop[MAX_PATH];
    DWORD   dwType;
    long    lRetVal         =   0;


    Assert(m_cInfo == 0);
    if (pcAcct == NULL)
        return(E_INVALIDARG);

    hr = S_FALSE;
    *pcAcct = 0;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegNscp, 0, KEY_ALL_ACCESS, &hkey))
        {
//          TODO : Fill up the m_rgInfo array with the info of all 
//          the users who have accounts in Communicator.
            if(ERROR_SUCCESS == RegQueryInfoKey( hkey, NULL, NULL, 0, &dwNumSubKeys, 
                                  NULL, NULL, NULL, NULL, NULL, NULL, NULL ) && (dwNumSubKeys > 0))
            {
                if (!MemAlloc((void **)&m_rgInfo, dwNumSubKeys * sizeof(COMMNEWSACCTINFO)))
                {
                    hr = E_OUTOFMEMORY;
                    goto done;
                }

                while(ERROR_SUCCESS == RegEnumKeyEx(hkey, dwIndex, szUserName, &cb, NULL, NULL, NULL, NULL))
                {
                    if(ERROR_SUCCESS == RegOpenKeyEx(hkey, szUserName, 0, KEY_ALL_ACCESS, &hkeyUsers))
                    {
                        cb = sizeof(szUserProfile);
                        if(ERROR_SUCCESS == (lRetVal = RegQueryValueEx(hkeyUsers, c_szRegDirRoot, NULL, &dwType, (LPBYTE)szUserProfile, &cb )))
                        {
                            if (REG_EXPAND_SZ == dwType)
                            {
                                ExpandEnvironmentStrings(szUserProfile, szExpanded, ARRAYSIZE(szExpanded));
                                psz = szExpanded;
                            }
                            else 
                                psz = szUserProfile;
                            
                            //save vals into the m_rgInfo structure
                            hrUser = GetUserPrefs(psz, szUserPrefs, 1, NULL);
                            if(!FAILED(hrUser))
                            {
                                hrUser = IsValidUser(psz);
                                if(!FAILED(hrUser))
                                {
                                    m_rgInfo[m_cInfo].dwCookie = m_cInfo;
                                    StrCpyN(m_rgInfo[m_cInfo].szUserPath, psz, ARRAYSIZE(m_rgInfo[m_cInfo].szUserPath));
                                    StrCpyN(m_rgInfo[m_cInfo].szDisplay, szUserName, ARRAYSIZE(m_rgInfo[m_cInfo].szDisplay));
                                    m_cInfo++;
                                }
                            }
                        }
                        RegCloseKey(hkeyUsers);
                    }
                    dwIndex++;
                    if(dwIndex == dwNumSubKeys)
                        hr = S_OK;
                }
            }
        }

    if (hr == S_OK)
    {
        *pcAcct = m_cInfo;
    }

done:
//      Close the reg key now....
        RegCloseKey(hkey);

    return(hr);
    }

typedef struct tagSELSERVER
{
    NEWSSERVERS *prgList;
    DWORD       *dwSelServ;

}SELSERVER;

// This function is called after we select a user profile (in case more than one is present)
// but before the 'GetSettings' finction is called. In case this profile has more than one 
// servers configured, we need to display a dialog box asking the user to select a server 
// account to import.

HRESULT STDMETHODCALLTYPE CCommNewsAcctImport::InitializeImport(HWND hwnd, DWORD_PTR dwCookie)
{
    HRESULT hr;
    SELSERVER ss;
    int nRetVal = 0;

    GetNumAccounts(dwCookie);

    if(m_rgServ == NULL)
    {
        m_dwSelServ = 0;
        return S_OK;
    }
    ss.prgList = m_rgServ;
    ss.dwSelServ = &m_dwSelServ;

    if(m_nNumServ > 1)
    {
        nRetVal = (int) DialogBoxParam(g_hInstRes, MAKEINTRESOURCE(IDD_PAGE_NEWSSERVERSELECT), hwnd, SelectServerDlgProc, (LPARAM)&ss);
        if (nRetVal == IDCANCEL)
            hr = E_FAIL;
        else if (nRetVal == IDOK)
            hr = S_OK;
        else
            hr = E_FAIL;
    }
    else
    {
        m_dwSelServ = 0;
        hr = S_OK;
    }
    return hr;
}

INT_PTR CALLBACK SelectServerDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndT;
    WORD id;
    DWORD iSubKey, cb;
    char sz[MAX_PATH];
    SELSERVER   *pss;
    NEWSSERVERS *pTempServ = NULL;
    int index;
    
    switch (msg)
    {
    case WM_INITDIALOG:
        Assert(lParam != NULL);
        pss = (SELSERVER *)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pss);
        
        hwndT = GetDlgItem(hwnd, IDC_ACCTLIST);
        
        // fill list
        pTempServ = pss->prgList;
        while(pTempServ != NULL)
        {
            if(lstrlen(pTempServ->szServerName) && lstrlen(pTempServ->szFilePath))
            {
                SendMessage(hwndT, LB_ADDSTRING, 0, (LPARAM)pTempServ->szServerName);
            }
            pTempServ = pTempServ->pNext;
        }
        
        SendMessage(hwndT, LB_SETCURSEL, 0, 0);
        return(TRUE);
        
    case WM_COMMAND:
        id = LOWORD(wParam);
        switch (id)
        {
        case IDOK:
            pss = (SELSERVER *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            Assert(pss != NULL);
            
            hwndT = GetDlgItem(hwnd, IDC_ACCTLIST);
            index = (int) SendMessage(hwndT, LB_GETCURSEL, 0, 0);
            Assert(index >= 0);
            *(pss->dwSelServ) = (long)index;
            
            // fall through
            
        case IDCANCEL:
            EndDialog(hwnd, id);
            return(TRUE);
        }
        break;
    }
    
    return(FALSE);
}

HRESULT STDMETHODCALLTYPE CCommNewsAcctImport::EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum)
    {
    CEnumCOMMNEWSACCT *penum;
    HRESULT hr;

    if (ppEnum == NULL)
        return(E_INVALIDARG);

    *ppEnum = NULL;

    if (m_cInfo == 0)
        return(S_FALSE);
    Assert(m_rgInfo != NULL);

    penum = new CEnumCOMMNEWSACCT;
    if (penum == NULL)
        return(E_OUTOFMEMORY);

    hr = penum->Init(m_rgInfo, m_cInfo);
    if (FAILED(hr))
        {
        penum->Release();
        penum = NULL;
        }

    *ppEnum = penum;

    return(hr);
    }

HRESULT CCommNewsAcctImport::IsValidUser(char *pszFilePath)
{
    char szNewsPath[MAX_PATH * 2];    
    HANDLE hFatFile = NULL;
    DWORD dwFatFileSize = 0;
    HRESULT hr = E_FAIL;

    StrCpyN(szNewsPath, pszFilePath, ARRAYSIZE(szNewsPath));
    StrCatBuff(szNewsPath, "\\News\\fat", ARRAYSIZE(szNewsPath));

    hFatFile = CreateFile(szNewsPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL); 
    
    if(INVALID_HANDLE_VALUE == hFatFile)
        return hr;
    
    dwFatFileSize = GetFileSize(hFatFile, NULL);

    if(dwFatFileSize > 0)
        hr = S_OK;

    CloseHandle(hFatFile);

    return hr;
}

// The following two functions have been added to handle the importing of subscribed newsgroups

HRESULT CCommNewsAcctImport::GetNumAccounts(DWORD_PTR dwCookie)
{
    COMMNEWSACCTINFO    *pinfo;
    NEWSSERVERS         *pTempServ = NULL;
    NEWSSERVERS         *pPrevServ = NULL;
    HRESULT hr = S_FALSE;
    char szNewsPath[MAX_PATH * 2];
    char szLineHolder[MAX_PATH * 2];
    HANDLE hFatFile = NULL;
    HANDLE hFatFileMap = NULL;
    BYTE *pFatViewBegin  = NULL,
         *pFatViewCurr   = NULL,
         *pFatViewEnd    = NULL;
    char *pParse = NULL;
    char *pServName = NULL;
    DWORD dwFatFileSize = 0;
    UINT uLine  =   0;
    char cPlaceHldr = 1;
    int nCount = 0;

    Assert(((int)dwCookie) >= 0 && dwCookie < (DWORD)m_cInfo);
    pinfo = &m_rgInfo[dwCookie];
    Assert(pinfo->dwCookie == dwCookie);

    StrCpyN(szNewsPath, pinfo->szUserPath, ARRAYSIZE(szNewsPath));
    StrCatBuff(szNewsPath, "\\News\\fat", ARRAYSIZE(szNewsPath));

    hFatFile = CreateFile(szNewsPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL); 
    
    if(INVALID_HANDLE_VALUE == hFatFile)
        return hr;
    
    dwFatFileSize = GetFileSize(hFatFile, NULL);
    
    hFatFileMap = CreateFileMapping(hFatFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if(NULL == hFatFileMap)
    {
        CloseHandle(hFatFile);
        return hr;
    }

    pFatViewBegin = (BYTE*)MapViewOfFile(hFatFileMap, FILE_MAP_READ, 0, 0, 0);

    if(pFatViewBegin  == NULL)
    {
       CloseHandle(hFatFileMap);
       CloseHandle(hFatFile);
       return hr;
    }

    pFatViewCurr = pFatViewBegin;
    pFatViewEnd  = pFatViewCurr + dwFatFileSize;

    pTempServ = m_rgServ;
    while(pTempServ)
    {
        pPrevServ = pTempServ->pNext;
        ZeroMemory(pTempServ, sizeof(NEWSSERVERS));
        pTempServ->pNext = pPrevServ;
        pTempServ = pTempServ->pNext;
    }
    pTempServ = NULL;
    pPrevServ = NULL;

    // We will skip the first line in the "fat" file as it contains a comment.
    // m_szSubList is a null separated list of 
    while(pFatViewCurr < pFatViewEnd)
    {
        uLine = 0;
        while(!((pFatViewCurr[uLine] == 0x0D) && (pFatViewCurr[uLine + 1] == 0x0A)) && (pFatViewCurr + uLine < pFatViewEnd))
            uLine++;

        if(pFatViewCurr + uLine > pFatViewEnd)
            break;

        StrCpyN(szLineHolder, (char*)pFatViewCurr, uLine + 1);
        pServName = szLineHolder;
        pParse = szLineHolder;

        if(!lstrcmp(szLineHolder, c_szNescapeMapFile))
        {
            pFatViewCurr += (uLine + 2);
            nCount = 0;
            continue;
        }

        while((*pServName != '-') && (*pServName != '\0'))
            pServName++;
        pServName++;

        // Go to the first char '9' position
        while((*pParse != '\0') && ((*pParse) != 9))
            pParse++;
        *pParse = '\0'; 
        // pass over what was originally the first char '9' position
        pParse++;

        // Trim the remaining string to the second char '9' position.
        while(pParse[nCount] != '\0')
        {
            if((int)pParse[nCount] == 9)
            {
                pParse[nCount] = '\0';
                break;
            }
            nCount++;
        }
                
        if(0 == pPrevServ)
        {
            if(!m_rgServ)
            {
                m_rgServ = (NEWSSERVERS*)new NEWSSERVERS;
                ZeroMemory((void*)m_rgServ, sizeof(NEWSSERVERS));
            }
            StrCpyN(m_rgServ->szServerName, pServName, ARRAYSIZE(m_rgServ->szServerName));
            StrCpyN(m_rgServ->szFilePath, pParse, ARRAYSIZE(m_rgServ->szFilePath));
            pPrevServ = m_rgServ;
        }
        else
        {
            if(!pPrevServ->pNext)
            {
                pPrevServ->pNext = (NEWSSERVERS*)new NEWSSERVERS;
                ZeroMemory((void*)pPrevServ->pNext, sizeof(NEWSSERVERS));
            }
            StrCpyN(pPrevServ->pNext->szServerName, pServName, ARRAYSIZE(pPrevServ->pNext->szServerName));
            StrCpyN(pPrevServ->pNext->szFilePath, pParse, ARRAYSIZE(pPrevServ->pNext->szFilePath));
            pPrevServ = pPrevServ->pNext;
        }

        pFatViewCurr += (uLine + 2);
        nCount = 0;
    }

    //replace the cPlaceHldr placeholder by nulls.

    hr = S_OK;

    pTempServ = m_rgServ;
    m_nNumServ = 0;
    while(pTempServ != NULL)
    {
        if(lstrlen(pTempServ->szServerName) && lstrlen(pTempServ->szFilePath))
        {
            m_nNumServ += 1;
        }
        pTempServ = pTempServ->pNext;
    }

//  Done: 
    CloseHandle(hFatFileMap);
    CloseHandle(hFatFile);
    UnmapViewOfFile(pFatViewBegin); 
    return hr;
}

HRESULT CCommNewsAcctImport::GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved) //char *szServerName, char *szAccountName)
{
    HRESULT hr = S_OK;
    HINSTANCE hInstance = NULL;
    char *pListGroups = NULL;
    NEWSSERVERS *pTempServ = NULL;
    NEWSSERVERS *pPrevServ = NULL;
    char        szTempString[NEWSUSERCOLS];
    char        szFilePath[NEWSUSERCOLS];
    int         nReach = 0;

    szFilePath[0] = '\0';
    Assert(m_nNumServ > m_dwSelServ);
    Assert(pImp != NULL);

    pTempServ = m_rgServ;
    for(DWORD nTemp1 = 0; nTemp1 < m_dwSelServ; nTemp1++)
    {
        pTempServ = pTempServ->pNext;
        if(pTempServ == NULL)
            return S_FALSE;
    }
    
    if(!FAILED(GetSubListGroups(pTempServ->szFilePath, &pListGroups)))
    {
        if(!SUCCEEDED(pImp->ImportSubList(pListGroups)))
            hr = S_FALSE;
    }
    if(pListGroups != NULL)
        MemFree(pListGroups);

    return hr;
}

HRESULT CCommNewsAcctImport::GetSubListGroups(char *pFileName, char **ppListGroups)
{
    HRESULT hr                      =   E_FAIL;
    HANDLE	hRCHandle				=	NULL;
	HANDLE	hRCFile					=	NULL;
	ULONG	cbRCFile				=	0;
	BYTE	*pBegin					=	NULL, 
			*pCurr					=	NULL, 
			*pEnd					=	NULL;
    int     nBalMem                 =   MEMCHUNK;
    int     nLine                   =   0,
            nCount                  =   0;
    char    cPlaceHolder            =   1;
    char    szLineHolder[MEMCHUNK];
    char    *pListGroups            =   NULL;
    
    Assert(lstrlen(pFileName));
    Assert(ppListGroups);
    *ppListGroups = NULL;

    hRCHandle = CreateFile( pFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
							OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

	if(hRCHandle == INVALID_HANDLE_VALUE)
		return hr;

	cbRCFile = GetFileSize(hRCHandle, NULL);

    if(!cbRCFile) // Empty File.
        goto Done;

	hRCFile = CreateFileMapping(hRCHandle, NULL, PAGE_READONLY, 0, 0, NULL);

	if(hRCFile == NULL)
    {
        CloseHandle(hRCHandle);
		return hr;
    }

    pBegin = (BYTE *)MapViewOfFile( hRCFile, FILE_MAP_READ, 0, 0, 0);

	if(pBegin == NULL)
    {
        CloseHandle(hRCHandle);
        CloseHandle(hRCFile);
		return hr;
    }

	pCurr = pBegin;
	pEnd = pCurr + cbRCFile;

    if (!MemAlloc((void **)&pListGroups, MEMCHUNK))
    {
        hr = E_OUTOFMEMORY;
        goto Done;
    }

    DWORD cchSizeListGroups = MEMCHUNK;
    ZeroMemory((void*)pListGroups, (cchSizeListGroups * sizeof(pListGroups[0])));
	
    while (pCurr < pEnd)
    {
        nLine = 0;
        while(!((pCurr[nLine] == ':') || (pCurr[nLine] == '!')) && (pCurr + nLine < pEnd))
            nLine++;

        if(pCurr + nLine > pEnd)
            break;

        if(pCurr[nLine] == '!')
            goto LineEnd;

        nLine++;
        if(nLine < MEMCHUNK)
            StrCpyN(szLineHolder, (char*)pCurr, nLine);
        else
            continue;

        if(nLine + 2 < nBalMem)
        {
            StrCatBuff(pListGroups, szLineHolder, cchSizeListGroups);
            StrCatBuff(pListGroups, "\1", cchSizeListGroups);
            nBalMem -= (nLine + 2);
        }
        else
        {
            cchSizeListGroups += (lstrlen(pListGroups) + 1 + MEMCHUNK);
            if(!MemRealloc((void **)&pListGroups, (cchSizeListGroups * sizeof(pListGroups[0]))))
            {
                hr = E_OUTOFMEMORY;
                goto Done;
            }
            nBalMem += MEMCHUNK;
            StrCatBuff(pListGroups, szLineHolder, cchSizeListGroups);
            StrCatBuff(pListGroups, "\1", cchSizeListGroups);
            nBalMem -= (nLine + 2);
        }

LineEnd:
        while(!((pCurr[nLine] == 0x0D) && (pCurr[nLine + 1] == 0x0A)) && (pCurr + nLine < pEnd))
            nLine++;
        pCurr += (nLine + 2);
    }

    if(lstrlen(pListGroups))
    {
        while(pListGroups[nCount] != '\0')
        {
            if(pListGroups[nCount] == cPlaceHolder)
            {
                pListGroups[nCount] = '\0';
            }
            nCount++;
        }
        *ppListGroups = pListGroups;
        hr = S_OK;
    }

Done:
    if(pBegin)
        UnmapViewOfFile(pBegin);
    if(hRCHandle != INVALID_HANDLE_VALUE)
        CloseHandle(hRCHandle);
    if(hRCFile)
        CloseHandle(hRCFile);

    return hr;
}

const static char c_szSearch[][NEWSUSERCOLS]  = {"user_pref(\"network.hosts.nntp_server\"", 
                                                 "user_pref(\"news.server_port\"", 
                                                 "user_pref(\"mail.identity.username\"", // This is the same for NNTP also.
                                                 "user_pref(\"mail.identity.useremail\""};
const static char c_szPrefs[]                 =  "\\prefs.js";

HRESULT CCommNewsAcctImport::GetUserPrefs(char *szUserPath, char szUserPrefs[][NEWSUSERCOLS], int nInLoop, BOOL *pbPop)
{
    HRESULT hr                      =   E_FAIL;
    char	szTemp[MAX_PATH * 2];
	char	szDirpath[250];
	char	szLine[1000];
	char	szCompare[1000];
	int		nLine					=	0;
    int     nFilled                 =   0;
	int		nPosition				=	0;
    int     nLoop                   =   nInLoop;
	HANDLE	hJSHandle				=	NULL;
	HANDLE	hJSFile					=	NULL;
	ULONG	cbJSFile				=	0;

	BYTE	*pBegin					=	NULL, 
			*pCurr					=	NULL, 
			*pEnd					=	NULL;
			
    Assert(nInLoop <= NEWSUSERROWS);
	StrCpyN(szTemp, szUserPath, ARRAYSIZE(szTemp));
	StrCatBuff(szTemp, c_szPrefs, ARRAYSIZE(szTemp));

	hJSHandle = CreateFile( szTemp, GENERIC_READ, FILE_SHARE_READ, NULL, 
							OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

	if(hJSHandle == INVALID_HANDLE_VALUE)
		return hr;

	cbJSFile = GetFileSize(hJSHandle, NULL);

	hJSFile = CreateFileMapping(hJSHandle, NULL, PAGE_READONLY, 0, 0, NULL);

	if(hJSFile == NULL)
    {
        CloseHandle(hJSHandle);        
		return hr;
    }

    pBegin = (BYTE *)MapViewOfFile( hJSFile, FILE_MAP_READ, 0, 0, 0);

	if(pBegin == NULL)
    {
        CloseHandle(hJSHandle);
        CloseHandle(hJSFile);
		return hr;
    }

	pCurr = pBegin;
	pEnd = pCurr + cbJSFile;
	
    while (pCurr < pEnd)
	{
		szLine[nLine] = *pCurr; //keep storing here. will be used for comparing later. 
		if((pCurr[0] == 0x0D) && (pCurr[1] == 0x0A))
		{
            while(nLoop)
            {
                StrCpyN(szCompare, szLine, lstrlen(c_szSearch[nLoop - 1]) + 1);
				if(lstrcmp(szCompare, c_szSearch[nLoop - 1]) == 0)   
				{
                    //Found a UserPref one of the things we are looking for"!
					//Extract the stuff we want.
					nPosition	=	lstrlen(c_szSearch[nLoop - 1]);
					
					while (((szLine[nPosition] == '"')||(szLine[nPosition] == ' ')||(szLine[nPosition] == ',')) &&(nPosition < nLine))
						nPosition++;
					StrCpyN(szDirpath, &szLine[nPosition], nLine - nPosition);

					//Now trim the trailing edge!!!

					nPosition	=	lstrlen(szDirpath) - 1;
					while((szDirpath[nPosition] == '"') || (szDirpath[nPosition] == ')')||(szDirpath[nPosition] == ';')) 
					{
						szDirpath[nPosition] = '\0';
						nPosition	=	lstrlen(szDirpath) - 1;
					}
 
                    StrCpyN(szUserPrefs[nLoop - 1], szDirpath, NEWSUSERCOLS);
                    nFilled++;
                    if(nFilled == nInLoop)
                        break;
				}
                nLoop--;
			}
            nLoop = nInLoop;
			nLine = -1; //the nLine++ that follows will make nLine zero.
			pCurr++;
		}
        if(nFilled == nInLoop)
            break;
		pCurr++;
		nLine++;
	}

    if(pBegin)
        UnmapViewOfFile(pBegin);

    if(hJSHandle != INVALID_HANDLE_VALUE)
        CloseHandle(hJSHandle);

    if(hJSFile)
        CloseHandle(hJSFile);

	if(nFilled == 0)
        return E_FAIL;
	else
    {
        if(nInLoop == 1)    //If this function was called only to check the server enties...
        {
            if(lstrlen(szUserPrefs[0]))
                return S_OK;
            else
                return E_FAIL;
        }
        return S_OK;
    }
}

HRESULT CCommNewsAcctImport::GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct)
{
    HRESULT hr;

    if (pAcct == NULL)
        return(E_INVALIDARG);    

    hr = IGetSettings(dwCookie, pAcct, NULL);

    return(hr);
}

HRESULT CCommNewsAcctImport::IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
{
    NEWSSERVERS *pPrevServ = m_rgServ;
    COMMNEWSACCTINFO *pinfo;
    char szUserPrefs[NEWSUSERROWS][NEWSUSERCOLS];
    char sz[512];
    DWORD cb, type;
    HRESULT hr;
    BOOL bPop   =   TRUE;
    char szNntpServ[NEWSUSERCOLS];
    char szNntpPort[NEWSUSERCOLS];
    szNntpPort[0] = '\0';
    int nReach = 0;
    DWORD dwNewsPort = 119;
    
    Assert(pPrevServ);
    Assert(m_dwSelServ < m_nNumServ);
            
    for(DWORD nCount = 0; nCount < m_dwSelServ; nCount++)
        pPrevServ = pPrevServ->pNext;

    StrCpyN(szNntpServ, pPrevServ->szServerName, ARRAYSIZE(szNntpServ));
    while(szNntpServ[nReach] != '\0')
    {
        if(szNntpServ[nReach] == ':')
        {
            szNntpServ[nReach] = '\0';
            StrCpyN(szNntpPort, &szNntpServ[nReach+1], ARRAYSIZE(szNntpPort));
            break;
        }
        nReach++;
    }

    Assert(lstrlen(szNntpServ) > 0);

    ZeroMemory((void*)&szUserPrefs[0], NEWSUSERCOLS*NEWSUSERROWS*sizeof(char));

    Assert(((int) dwCookie) >= 0 && dwCookie < (DWORD_PTR)m_cInfo);
    pinfo = &m_rgInfo[dwCookie];
    
    Assert(pinfo->dwCookie == dwCookie);

    hr = GetUserPrefs(pinfo->szUserPath, szUserPrefs, NEWSUSERROWS, &bPop);
    Assert(!FAILED(hr));
   
    hr = pAcct->SetPropSz(AP_ACCOUNT_NAME, szNntpServ);
    if (FAILED(hr))
        return(hr);

    hr = pAcct->SetPropSz(AP_NNTP_SERVER, szNntpServ);
    Assert(!FAILED(hr));

    int Len = lstrlen(szNntpPort);
    if(Len)
    {
        // Convert the string to a dw.
        DWORD dwMult = 1;
        dwNewsPort = 0;
        while(Len)
        {
            Len--;
            dwNewsPort += ((int)szNntpPort[Len] - 48)*dwMult;
            dwMult *= 10;
        }
    }

    hr = pAcct->SetPropDw(AP_NNTP_PORT, dwNewsPort);
    Assert(!FAILED(hr));
 
    if(lstrlen(szUserPrefs[2]))
    {
        hr = pAcct->SetPropSz(AP_NNTP_DISPLAY_NAME, szUserPrefs[2]);
        Assert(!FAILED(hr));
    }

    if(lstrlen(szUserPrefs[3]))
    {
        hr = pAcct->SetPropSz(AP_NNTP_EMAIL_ADDRESS, szUserPrefs[3]);
        Assert(!FAILED(hr));
    }

    if (pInfo != NULL)
    {
        // TODO: can we do any better than this???
        pInfo->dwConnect = CONN_USE_DEFAULT;
    }
    
    return(S_OK);
}

STDMETHODIMP CCommNewsAcctImport::GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
{
    if (pAcct == NULL ||
        pInfo == NULL)
        return(E_INVALIDARG);
    
    return(IGetSettings(dwCookie, pAcct, pInfo));
}

CEnumCOMMNEWSACCT::CEnumCOMMNEWSACCT()
    {
    m_cRef = 1;
    // m_iInfo
    m_cInfo = 0;
    m_rgInfo = NULL;
    }

CEnumCOMMNEWSACCT::~CEnumCOMMNEWSACCT()
    {
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
    }

STDMETHODIMP CEnumCOMMNEWSACCT::QueryInterface(REFIID riid, LPVOID *ppv)
    {

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
	else if (IID_IEnumIMPACCOUNTS == riid)
		*ppv = (IEnumIMPACCOUNTS *)this;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();
    else
        return(E_NOINTERFACE);

    return(S_OK);
    }

STDMETHODIMP_(ULONG) CEnumCOMMNEWSACCT::AddRef()
    {
    return(++m_cRef);
    }

STDMETHODIMP_(ULONG) CEnumCOMMNEWSACCT::Release()
    {
    if (--m_cRef == 0)
        {
        delete this;
        return(0);
        }

    return(m_cRef);
    }

HRESULT STDMETHODCALLTYPE CEnumCOMMNEWSACCT::Next(IMPACCOUNTINFO *pinfo)
    {
    if (pinfo == NULL)
        return(E_INVALIDARG);

    m_iInfo++;
    if ((UINT)m_iInfo >= m_cInfo)
        return(S_FALSE);

    Assert(m_rgInfo != NULL);

    pinfo->dwCookie = m_rgInfo[m_iInfo].dwCookie;
    pinfo->dwReserved = 0;
    StrCpyN(pinfo->szDisplay, m_rgInfo[m_iInfo].szDisplay, ARRAYSIZE(pinfo->szDisplay));

    return(S_OK);
    }

HRESULT STDMETHODCALLTYPE CEnumCOMMNEWSACCT::Reset()
    {
    m_iInfo = -1;

    return(S_OK);
    }

HRESULT CEnumCOMMNEWSACCT::Init(COMMNEWSACCTINFO *pinfo, int cinfo)
    {
    DWORD cb;

    Assert(pinfo != NULL);
    Assert(cinfo > 0);

    cb = cinfo * sizeof(COMMNEWSACCTINFO);
    
    if (!MemAlloc((void **)&m_rgInfo, cb))
        return(E_OUTOFMEMORY);

    m_iInfo = -1;
    m_cInfo = cinfo;
    CopyMemory(m_rgInfo, pinfo, cb);

    return(S_OK);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\defguid.cpp ===
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
#include "pch.hxx"
#include <initguid.h>
#include <ole2.h>
#define INITGUID
#include <msoeprop.h>
#include <msoeopt.h>
#include <imnact.h>
#include "acctimp.h"
#include "eudora.h"
#include "netscape.h"
#include "CommAct.h"
#include "CommNews.h"
#include "navnews.h"
#include "exchacct.h"
#include <prsht.h>
#include <icwacct.h>
#include <msoert.h>
#include "AgntNews.h"
#include "NExpress.h"
#include <msident.h>
#include <mimeole.h>
#include <hotwiz.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\dllmain.cpp ===
// --------------------------------------------------------------------------------
// Dllmain.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include <shfusion.h>
#define DEFINE_STRING_CONSTANTS
#include "strconst.h"
#include "dllmain.h"
#include "demand.h"
#include "shared.h"

// --------------------------------------------------------------------------------
// Globals - Object count and lock count
// --------------------------------------------------------------------------------
HINSTANCE               g_hInst=NULL;
HINSTANCE               g_hInstRes=NULL;
LONG                    g_cRef=0;
LONG                    g_cLock=0;
CRITICAL_SECTION        g_csDllMain={0};
CRITICAL_SECTION        g_csAcctMan={0};
BOOL                    g_fAttached = FALSE;
CAccountManager        *g_pAcctMan=NULL;
IMalloc                *g_pMalloc=NULL;
BOOL                    g_fCachedGUID=FALSE;
GUID                    g_guidCached;
SYSTEM_INFO                     g_SystemInfo={0};
OSVERSIONINFO					g_OSInfo={0};

#ifdef DEBUG
DWORD                   dwDOUTLevel;
DWORD                   dwDOUTLMod;
DWORD                   dwDOUTLModLevel;
#endif

inline BOOL fIsNT5()        { return((g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_OSInfo.dwMajorVersion >= 5)); }

void InitDemandMimeole(void);
void FreeDemandMimeOle(void);

// --------------------------------------------------------------------------------
// GetDllMajorVersion
// --------------------------------------------------------------------------------
OEDLLVERSION WINAPI GetDllMajorVersion(void)
{
    return OEDLL_VERSION_CURRENT;
}

// --------------------------------------------------------------------------------
// Dll Entry Point
// --------------------------------------------------------------------------------
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Handle Attach - detach reason
    switch (dwReason)                 
    {
    case DLL_PROCESS_ATTACH:
        SHFusionInitialize(NULL);
	    g_hInst = hInst;

        CoGetMalloc(1, &g_pMalloc);
        InitializeCriticalSection(&g_csAcctMan);
        InitializeCriticalSection(&g_csDllMain);
        g_fAttached = TRUE;
        InitDemandLoadedLibs();

        InitDemandMimeole();

        DisableThreadLibraryCalls(hInst);

        // Get System & OS Info
        GetPCAndOSTypes(&g_SystemInfo, &g_OSInfo);

        // Get Resources from Lang DLL
        g_hInstRes = LoadLangDll(g_hInst, c_szAcctResDll, fIsNT5());
        if(g_hInstRes == NULL)
        {
            Assert(FALSE);
            return FALSE;
        }

#ifdef DEBUG
        dwDOUTLevel=GetPrivateProfileInt("Debug", "ICLevel", 0, "athena.ini");
        dwDOUTLMod=GetPrivateProfileInt("Debug", "Mod", 0, "athena.ini");
        dwDOUTLModLevel=GetPrivateProfileInt("Debug", "ModLevel", 0, "athena.ini");
#endif
        break;

    case DLL_PROCESS_DETACH:
        FreeDemandLoadedLibs();

        FreeDemandMimeOle();

        SafeFreeLibrary(g_hInstRes);
        g_fAttached = FALSE;
        DeleteCriticalSection(&g_csAcctMan);
        DeleteCriticalSection(&g_csDllMain);
        // Don't release anything but g_pMalloc here or suffer at the hands of kernel
        SafeRelease(g_pMalloc);
        SHFusionUninitialize();
	    break;
    }

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// DllAddRef
// --------------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    return (ULONG)InterlockedIncrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllRelease
// --------------------------------------------------------------------------------
ULONG DllRelease(void)
{
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    HRESULT hr = S_OK;
    if(!g_fAttached)    // critacal sections was deleted (or not created): we defently can be unloaded
        return S_OK;

    EnterCriticalSection(&g_csDllMain);
    // DebugTrace("DllCanUnloadNow: %s - Reference Count: %d, LockServer Count: %d\n", __FILE__, g_cRef, g_cLock);
    hr = (0 == g_cRef && 0 == g_cLock) ? S_OK : S_FALSE;
    LeaveCriticalSection(&g_csDllMain);
    return hr;
}

// --------------------------------------------------------------------------------
// DllRegisterServer
// --------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    // Trace This
    DebugTrace("MSOEACCT.DLL: DllRegisterServer called\n");

    // Register my self
    hr = CallRegInstall(g_hInst, g_hInst, c_szReg, NULL);

#if !defined(NOHTTPMAIL)    
    // Register HTTPMAIL Domains in InternetDomains
    if (SUCCEEDED(hr))
        hr = CallRegInstall(g_hInst, g_hInst, c_szRegHTTPDomains, NULL);
#endif

    return(hr);
}

// --------------------------------------------------------------------------------
// DllUnregisterServer
// --------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    // Trace This
    DebugTrace("MSOEACCT.DLL: DllUnregisterServer called\n");

    hr = CallRegInstall(g_hInst, g_hInst, c_szUnReg, NULL);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\crypt16.h ===
// --------------------------------------------------------------------------------
// Crypt16.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
//                  From 16bit Mail3.0 project.
// --------------------------------------------------------------------------------

#ifndef __CRYPT16_H
#define __CRYPT16_H

#ifdef __cplusplus
extern "C" {
#endif

typedef unsigned char des_cblock[8];
typedef struct des_ks_struct
	{
	des_cblock _;
	} des_key_schedule[16];

#define DES_KEY_SZ 	(sizeof(des_cblock))
#define DES_ENCRYPT	1
#define DES_DECRYPT	0

#define DES_CBC_MODE	0
#define DES_PCBC_MODE	1
extern int des_rw_mode;

#define C_Block des_cblock
#define Key_schedule des_key_schedule
#define ENCRYPT DES_ENCRYPT
#define DECRYPT DES_DECRYPT
#define KEY_SZ DES_KEY_SZ
#define string_to_key des_string_to_key
#define read_pw_string des_read_pw_string
#define random_key des_random_key
#define pcbc_encrypt des_pcbc_encrypt
#define set_key des_set_key
#define key_sched des_key_sched
#define cbc_encrypt des_cbc_encrypt
#define cbc_cksum des_cbc_cksum
#define quad_cksum des_quad_cksum
typedef struct des_ks_struct bit_64; /* MIT compat. */

void des_string_to_key();
void des_random_key();
unsigned long des_cbc_cksum();
unsigned long des_quad_cksum();
int des_enc_read();
int des_enc_write();
char *crypt(); 
int des_encrypt();  
int des_pcbc_encrypt();
int des_cbc_encrypt(C_Block *,C_Block *,long,des_key_schedule,C_Block *,int);
int des_set_key();
int des_key_sched(C_Block *,des_key_schedule);

extern int des_check_key; /* default is false */

// From deslocal.h file.
typedef unsigned char uchar;
typedef unsigned long ulong;

#define ITERATIONS 16

#define c2l(c,l)	(l =((ulong)(*((c)++)))    , \
			 l|=((ulong)(*((c)++)))<< 8, \
			 l|=((ulong)(*((c)++)))<<16, \
			 l|=((ulong)(*((c)++)))<<24)

/* NOTE - c is not incremented as per c2l */
#define c2ln(c,l1,l2,n)	{ \
			c+=n; \
			l1=l2=0; \
			switch (n) { \
			case 7: l2|=((ulong)(*(--(c))))<<16; \
			case 6: l2|=((ulong)(*(--(c))))<< 8; \
			case 5: l2|=((ulong)(*(--(c))));     \
			case 4: l1|=((ulong)(*(--(c))))<<24; \
			case 3: l1|=((ulong)(*(--(c))))<<16; \
			case 2: l1|=((ulong)(*(--(c))))<< 8; \
			case 1: l1|=((ulong)(*(--(c))));     \
				} \
			}

#define l2c(l,c)	(*((c)++)=(uchar)(((l)    )&0xff), \
			 *((c)++)=(uchar)(((l)>> 8)&0xff), \
			 *((c)++)=(uchar)(((l)>>16)&0xff), \
			 *((c)++)=(uchar)(((l)>>24)&0xff))

/* NOTE - c is not incremented as per l2c */
#define l2cn(l1,l2,c,n)	{ \
			c+=n; \
			switch (n) { \
			case 7: *(--(c))=(uchar)(((l2)>>16)&0xff); \
			case 6: *(--(c))=(uchar)(((l2)>> 8)&0xff); \
			case 5: *(--(c))=(uchar)(((l2)    )&0xff); \
			case 4: *(--(c))=(uchar)(((l1)>>24)&0xff); \
			case 3: *(--(c))=(uchar)(((l1)>>16)&0xff); \
			case 2: *(--(c))=(uchar)(((l1)>> 8)&0xff); \
			case 1: *(--(c))=(uchar)(((l1)    )&0xff); \
				} \
			}

// From podd.h file
static unsigned char odd_parity[256]={
  1,  1,  2,  2,  4,  4,  7,  7,  8,  8, 11, 11, 13, 13, 14, 14,
 16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,
 32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,
 49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,
 64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,
 81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,
 97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,
112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,
128,128,131,131,133,133,134,134,137,137,138,138,140,140,143,143,
145,145,146,146,148,148,151,151,152,152,155,155,157,157,158,158,
161,161,162,162,164,164,167,167,168,168,171,171,173,173,174,174,
176,176,179,179,181,181,182,182,185,185,186,186,188,188,191,191,
193,193,194,194,196,196,199,199,200,200,203,203,205,205,206,206,
208,208,211,211,213,213,214,214,217,217,218,218,220,220,223,223,
224,224,227,227,229,229,230,230,233,233,234,234,236,236,239,239,
241,241,242,242,244,244,247,247,248,248,251,251,253,253,254,254};

// From sk.h file
static unsigned long des_skb[8][64]={
/* for C bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
0x00000000,0x00000010,0x20000000,0x20000010,
0x00010000,0x00010010,0x20010000,0x20010010,
0x00000800,0x00000810,0x20000800,0x20000810,
0x00010800,0x00010810,0x20010800,0x20010810,
0x00000020,0x00000030,0x20000020,0x20000030,
0x00010020,0x00010030,0x20010020,0x20010030,
0x00000820,0x00000830,0x20000820,0x20000830,
0x00010820,0x00010830,0x20010820,0x20010830,
0x00080000,0x00080010,0x20080000,0x20080010,
0x00090000,0x00090010,0x20090000,0x20090010,
0x00080800,0x00080810,0x20080800,0x20080810,
0x00090800,0x00090810,0x20090800,0x20090810,
0x00080020,0x00080030,0x20080020,0x20080030,
0x00090020,0x00090030,0x20090020,0x20090030,
0x00080820,0x00080830,0x20080820,0x20080830,
0x00090820,0x00090830,0x20090820,0x20090830,
/* for C bits (numbered as per FIPS 46) 7 8 10 11 12 13 */
0x00000000,0x02000000,0x00002000,0x02002000,
0x00200000,0x02200000,0x00202000,0x02202000,
0x00000004,0x02000004,0x00002004,0x02002004,
0x00200004,0x02200004,0x00202004,0x02202004,
0x00000400,0x02000400,0x00002400,0x02002400,
0x00200400,0x02200400,0x00202400,0x02202400,
0x00000404,0x02000404,0x00002404,0x02002404,
0x00200404,0x02200404,0x00202404,0x02202404,
0x10000000,0x12000000,0x10002000,0x12002000,
0x10200000,0x12200000,0x10202000,0x12202000,
0x10000004,0x12000004,0x10002004,0x12002004,
0x10200004,0x12200004,0x10202004,0x12202004,
0x10000400,0x12000400,0x10002400,0x12002400,
0x10200400,0x12200400,0x10202400,0x12202400,
0x10000404,0x12000404,0x10002404,0x12002404,
0x10200404,0x12200404,0x10202404,0x12202404,
/* for C bits (numbered as per FIPS 46) 14 15 16 17 19 20 */
0x00000000,0x00000001,0x00040000,0x00040001,
0x01000000,0x01000001,0x01040000,0x01040001,
0x00000002,0x00000003,0x00040002,0x00040003,
0x01000002,0x01000003,0x01040002,0x01040003,
0x00000200,0x00000201,0x00040200,0x00040201,
0x01000200,0x01000201,0x01040200,0x01040201,
0x00000202,0x00000203,0x00040202,0x00040203,
0x01000202,0x01000203,0x01040202,0x01040203,
0x08000000,0x08000001,0x08040000,0x08040001,
0x09000000,0x09000001,0x09040000,0x09040001,
0x08000002,0x08000003,0x08040002,0x08040003,
0x09000002,0x09000003,0x09040002,0x09040003,
0x08000200,0x08000201,0x08040200,0x08040201,
0x09000200,0x09000201,0x09040200,0x09040201,
0x08000202,0x08000203,0x08040202,0x08040203,
0x09000202,0x09000203,0x09040202,0x09040203,
/* for C bits (numbered as per FIPS 46) 21 23 24 26 27 28 */
0x00000000,0x00100000,0x00000100,0x00100100,
0x00000008,0x00100008,0x00000108,0x00100108,
0x00001000,0x00101000,0x00001100,0x00101100,
0x00001008,0x00101008,0x00001108,0x00101108,
0x04000000,0x04100000,0x04000100,0x04100100,
0x04000008,0x04100008,0x04000108,0x04100108,
0x04001000,0x04101000,0x04001100,0x04101100,
0x04001008,0x04101008,0x04001108,0x04101108,
0x00020000,0x00120000,0x00020100,0x00120100,
0x00020008,0x00120008,0x00020108,0x00120108,
0x00021000,0x00121000,0x00021100,0x00121100,
0x00021008,0x00121008,0x00021108,0x00121108,
0x04020000,0x04120000,0x04020100,0x04120100,
0x04020008,0x04120008,0x04020108,0x04120108,
0x04021000,0x04121000,0x04021100,0x04121100,
0x04021008,0x04121008,0x04021108,0x04121108,
/* for D bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
0x00000000,0x10000000,0x00010000,0x10010000,
0x00000004,0x10000004,0x00010004,0x10010004,
0x20000000,0x30000000,0x20010000,0x30010000,
0x20000004,0x30000004,0x20010004,0x30010004,
0x00100000,0x10100000,0x00110000,0x10110000,
0x00100004,0x10100004,0x00110004,0x10110004,
0x20100000,0x30100000,0x20110000,0x30110000,
0x20100004,0x30100004,0x20110004,0x30110004,
0x00001000,0x10001000,0x00011000,0x10011000,
0x00001004,0x10001004,0x00011004,0x10011004,
0x20001000,0x30001000,0x20011000,0x30011000,
0x20001004,0x30001004,0x20011004,0x30011004,
0x00101000,0x10101000,0x00111000,0x10111000,
0x00101004,0x10101004,0x00111004,0x10111004,
0x20101000,0x30101000,0x20111000,0x30111000,
0x20101004,0x30101004,0x20111004,0x30111004,
/* for D bits (numbered as per FIPS 46) 8 9 11 12 13 14 */
0x00000000,0x08000000,0x00000008,0x08000008,
0x00000400,0x08000400,0x00000408,0x08000408,
0x00020000,0x08020000,0x00020008,0x08020008,
0x00020400,0x08020400,0x00020408,0x08020408,
0x00000001,0x08000001,0x00000009,0x08000009,
0x00000401,0x08000401,0x00000409,0x08000409,
0x00020001,0x08020001,0x00020009,0x08020009,
0x00020401,0x08020401,0x00020409,0x08020409,
0x02000000,0x0A000000,0x02000008,0x0A000008,
0x02000400,0x0A000400,0x02000408,0x0A000408,
0x02020000,0x0A020000,0x02020008,0x0A020008,
0x02020400,0x0A020400,0x02020408,0x0A020408,
0x02000001,0x0A000001,0x02000009,0x0A000009,
0x02000401,0x0A000401,0x02000409,0x0A000409,
0x02020001,0x0A020001,0x02020009,0x0A020009,
0x02020401,0x0A020401,0x02020409,0x0A020409,
/* for D bits (numbered as per FIPS 46) 16 17 18 19 20 21 */
0x00000000,0x00000100,0x00080000,0x00080100,
0x01000000,0x01000100,0x01080000,0x01080100,
0x00000010,0x00000110,0x00080010,0x00080110,
0x01000010,0x01000110,0x01080010,0x01080110,
0x00200000,0x00200100,0x00280000,0x00280100,
0x01200000,0x01200100,0x01280000,0x01280100,
0x00200010,0x00200110,0x00280010,0x00280110,
0x01200010,0x01200110,0x01280010,0x01280110,
0x00000200,0x00000300,0x00080200,0x00080300,
0x01000200,0x01000300,0x01080200,0x01080300,
0x00000210,0x00000310,0x00080210,0x00080310,
0x01000210,0x01000310,0x01080210,0x01080310,
0x00200200,0x00200300,0x00280200,0x00280300,
0x01200200,0x01200300,0x01280200,0x01280300,
0x00200210,0x00200310,0x00280210,0x00280310,
0x01200210,0x01200310,0x01280210,0x01280310,
/* for D bits (numbered as per FIPS 46) 22 23 24 25 27 28 */
0x00000000,0x04000000,0x00040000,0x04040000,
0x00000002,0x04000002,0x00040002,0x04040002,
0x00002000,0x04002000,0x00042000,0x04042000,
0x00002002,0x04002002,0x00042002,0x04042002,
0x00000020,0x04000020,0x00040020,0x04040020,
0x00000022,0x04000022,0x00040022,0x04040022,
0x00002020,0x04002020,0x00042020,0x04042020,
0x00002022,0x04002022,0x00042022,0x04042022,
0x00000800,0x04000800,0x00040800,0x04040800,
0x00000802,0x04000802,0x00040802,0x04040802,
0x00002800,0x04002800,0x00042800,0x04042800,
0x00002802,0x04002802,0x00042802,0x04042802,
0x00000820,0x04000820,0x00040820,0x04040820,
0x00000822,0x04000822,0x00040822,0x04040822,
0x00002820,0x04002820,0x00042820,0x04042820,
0x00002822,0x04002822,0x00042822,0x04042822,
};


// From spr.h file
static unsigned long des_SPtrans[8][64]={
/* nibble 0 */
0x00820200, 0x00020000, 0x80800000, 0x80820200,
0x00800000, 0x80020200, 0x80020000, 0x80800000,
0x80020200, 0x00820200, 0x00820000, 0x80000200,
0x80800200, 0x00800000, 0x00000000, 0x80020000,
0x00020000, 0x80000000, 0x00800200, 0x00020200,
0x80820200, 0x00820000, 0x80000200, 0x00800200,
0x80000000, 0x00000200, 0x00020200, 0x80820000,
0x00000200, 0x80800200, 0x80820000, 0x00000000,
0x00000000, 0x80820200, 0x00800200, 0x80020000,
0x00820200, 0x00020000, 0x80000200, 0x00800200,
0x80820000, 0x00000200, 0x00020200, 0x80800000,
0x80020200, 0x80000000, 0x80800000, 0x00820000,
0x80820200, 0x00020200, 0x00820000, 0x80800200,
0x00800000, 0x80000200, 0x80020000, 0x00000000,
0x00020000, 0x00800000, 0x80800200, 0x00820200,
0x80000000, 0x80820000, 0x00000200, 0x80020200,

/* nibble 1 */
0x10042004, 0x00000000, 0x00042000, 0x10040000,
0x10000004, 0x00002004, 0x10002000, 0x00042000,
0x00002000, 0x10040004, 0x00000004, 0x10002000,
0x00040004, 0x10042000, 0x10040000, 0x00000004,
0x00040000, 0x10002004, 0x10040004, 0x00002000,
0x00042004, 0x10000000, 0x00000000, 0x00040004,
0x10002004, 0x00042004, 0x10042000, 0x10000004,
0x10000000, 0x00040000, 0x00002004, 0x10042004,
0x00040004, 0x10042000, 0x10002000, 0x00042004,
0x10042004, 0x00040004, 0x10000004, 0x00000000,
0x10000000, 0x00002004, 0x00040000, 0x10040004,
0x00002000, 0x10000000, 0x00042004, 0x10002004,
0x10042000, 0x00002000, 0x00000000, 0x10000004,
0x00000004, 0x10042004, 0x00042000, 0x10040000,
0x10040004, 0x00040000, 0x00002004, 0x10002000,
0x10002004, 0x00000004, 0x10040000, 0x00042000,

/* nibble 2 */
0x41000000, 0x01010040, 0x00000040, 0x41000040,
0x40010000, 0x01000000, 0x41000040, 0x00010040,
0x01000040, 0x00010000, 0x01010000, 0x40000000,
0x41010040, 0x40000040, 0x40000000, 0x41010000,
0x00000000, 0x40010000, 0x01010040, 0x00000040,
0x40000040, 0x41010040, 0x00010000, 0x41000000,
0x41010000, 0x01000040, 0x40010040, 0x01010000,
0x00010040, 0x00000000, 0x01000000, 0x40010040,
0x01010040, 0x00000040, 0x40000000, 0x00010000,
0x40000040, 0x40010000, 0x01010000, 0x41000040,
0x00000000, 0x01010040, 0x00010040, 0x41010000,
0x40010000, 0x01000000, 0x41010040, 0x40000000,
0x40010040, 0x41000000, 0x01000000, 0x41010040,
0x00010000, 0x01000040, 0x41000040, 0x00010040,
0x01000040, 0x00000000, 0x41010000, 0x40000040,
0x41000000, 0x40010040, 0x00000040, 0x01010000,

/* nibble 3 */
0x00100402, 0x04000400, 0x00000002, 0x04100402,
0x00000000, 0x04100000, 0x04000402, 0x00100002,
0x04100400, 0x04000002, 0x04000000, 0x00000402,
0x04000002, 0x00100402, 0x00100000, 0x04000000,
0x04100002, 0x00100400, 0x00000400, 0x00000002,
0x00100400, 0x04000402, 0x04100000, 0x00000400,
0x00000402, 0x00000000, 0x00100002, 0x04100400,
0x04000400, 0x04100002, 0x04100402, 0x00100000,
0x04100002, 0x00000402, 0x00100000, 0x04000002,
0x00100400, 0x04000400, 0x00000002, 0x04100000,
0x04000402, 0x00000000, 0x00000400, 0x00100002,
0x00000000, 0x04100002, 0x04100400, 0x00000400,
0x04000000, 0x04100402, 0x00100402, 0x00100000,
0x04100402, 0x00000002, 0x04000400, 0x00100402,
0x00100002, 0x00100400, 0x04100000, 0x04000402,
0x00000402, 0x04000000, 0x04000002, 0x04100400,

/* nibble 4 */
0x02000000, 0x00004000, 0x00000100, 0x02004108,
0x02004008, 0x02000100, 0x00004108, 0x02004000,
0x00004000, 0x00000008, 0x02000008, 0x00004100,
0x02000108, 0x02004008, 0x02004100, 0x00000000,
0x00004100, 0x02000000, 0x00004008, 0x00000108,
0x02000100, 0x00004108, 0x00000000, 0x02000008,
0x00000008, 0x02000108, 0x02004108, 0x00004008,
0x02004000, 0x00000100, 0x00000108, 0x02004100,
0x02004100, 0x02000108, 0x00004008, 0x02004000,
0x00004000, 0x00000008, 0x02000008, 0x02000100,
0x02000000, 0x00004100, 0x02004108, 0x00000000,
0x00004108, 0x02000000, 0x00000100, 0x00004008,
0x02000108, 0x00000100, 0x00000000, 0x02004108,
0x02004008, 0x02004100, 0x00000108, 0x00004000,
0x00004100, 0x02004008, 0x02000100, 0x00000108,
0x00000008, 0x00004108, 0x02004000, 0x02000008,

/* nibble 5 */
0x20000010, 0x00080010, 0x00000000, 0x20080800,
0x00080010, 0x00000800, 0x20000810, 0x00080000,
0x00000810, 0x20080810, 0x00080800, 0x20000000,
0x20000800, 0x20000010, 0x20080000, 0x00080810,
0x00080000, 0x20000810, 0x20080010, 0x00000000,
0x00000800, 0x00000010, 0x20080800, 0x20080010,
0x20080810, 0x20080000, 0x20000000, 0x00000810,
0x00000010, 0x00080800, 0x00080810, 0x20000800,
0x00000810, 0x20000000, 0x20000800, 0x00080810,
0x20080800, 0x00080010, 0x00000000, 0x20000800,
0x20000000, 0x00000800, 0x20080010, 0x00080000,
0x00080010, 0x20080810, 0x00080800, 0x00000010,
0x20080810, 0x00080800, 0x00080000, 0x20000810,
0x20000010, 0x20080000, 0x00080810, 0x00000000,
0x00000800, 0x20000010, 0x20000810, 0x20080800,
0x20080000, 0x00000810, 0x00000010, 0x20080010,

/* nibble 6 */
0x00001000, 0x00000080, 0x00400080, 0x00400001,
0x00401081, 0x00001001, 0x00001080, 0x00000000,
0x00400000, 0x00400081, 0x00000081, 0x00401000,
0x00000001, 0x00401080, 0x00401000, 0x00000081,
0x00400081, 0x00001000, 0x00001001, 0x00401081,
0x00000000, 0x00400080, 0x00400001, 0x00001080,
0x00401001, 0x00001081, 0x00401080, 0x00000001,
0x00001081, 0x00401001, 0x00000080, 0x00400000,
0x00001081, 0x00401000, 0x00401001, 0x00000081,
0x00001000, 0x00000080, 0x00400000, 0x00401001,
0x00400081, 0x00001081, 0x00001080, 0x00000000,
0x00000080, 0x00400001, 0x00000001, 0x00400080,
0x00000000, 0x00400081, 0x00400080, 0x00001080,
0x00000081, 0x00001000, 0x00401081, 0x00400000,
0x00401080, 0x00000001, 0x00001001, 0x00401081,
0x00400001, 0x00401080, 0x00401000, 0x00001001,

/* nibble 7 */
0x08200020, 0x08208000, 0x00008020, 0x00000000,
0x08008000, 0x00200020, 0x08200000, 0x08208020,
0x00000020, 0x08000000, 0x00208000, 0x00008020,
0x00208020, 0x08008020, 0x08000020, 0x08200000,
0x00008000, 0x00208020, 0x00200020, 0x08008000,
0x08208020, 0x08000020, 0x00000000, 0x00208000,
0x08000000, 0x00200000, 0x08008020, 0x08200020,
0x00200000, 0x00008000, 0x08208000, 0x00000020,
0x00200000, 0x00008000, 0x08000020, 0x08208020,
0x00008020, 0x08000000, 0x00000000, 0x00208000,
0x08200020, 0x08008020, 0x08008000, 0x00200020,
0x08208000, 0x00000020, 0x00200020, 0x08008000,
0x08208020, 0x00200000, 0x08200000, 0x08000020,
0x00208000, 0x00008020, 0x08008020, 0x08200000,
0x00000020, 0x08208000, 0x00208020, 0x00000000,
0x08000000, 0x08200020, 0x00008000, 0x00208020};


#ifdef __cplusplus
}
#endif

#endif //__CRYPT16_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\eudora.h ===
#ifndef _INC_EUDORA
#define _INC_EUDORA

typedef struct tagEUDORAACCTINFO
    {
    DWORD_PTR dwCookie;
    char szSection[MAX_PATH];
    char szDisplay[CCHMAX_ACCOUNT_NAME];
    } EUDORAACCTINFO;

// {39981124-C287-11D0-8D8C-00C04FD6202B}
DEFINE_GUID(CLSID_CEnumEUDORAACCTS, 0x39981124L, 0xC287, 0x11D0, 0x8D, 0x8C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

class CEnumEUDORAACCTS : public IEnumIMPACCOUNTS
    {
    private:
        ULONG           m_cRef;
        int             m_iInfo;
        UINT            m_cInfo;
        EUDORAACCTINFO  *m_rgInfo;

    public:
        CEnumEUDORAACCTS(void);
        ~CEnumEUDORAACCTS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE Next(IMPACCOUNTINFO *pinfo);
        HRESULT STDMETHODCALLTYPE Reset(void);

        HRESULT Init(EUDORAACCTINFO *pinfo, int cinfo);
    };

// {39981125-C287-11D0-8D8C-00C04FD6202B}
DEFINE_GUID(CLSID_CEudoraAcctImport, 0x39981125L, 0xC287, 0x11D0, 0x8D, 0x8C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

class CEudoraAcctImport : public IAccountImport, public IAccountImport2
    {
    private:
        ULONG           m_cRef;
        TCHAR           m_szIni[MAX_PATH];
        UINT            m_cInfo;
        EUDORAACCTINFO  *m_rgInfo;

        HRESULT     InitAccounts(char *szIni);
        HRESULT     IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);

    public:
        CEudoraAcctImport(void);
        ~CEudoraAcctImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE AutoDetect(DWORD *pcAcct, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum);
        HRESULT STDMETHODCALLTYPE GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct);

        HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd, DWORD_PTR dwCookie);
        HRESULT STDMETHODCALLTYPE GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);
    };

#endif // _INC_EUDORA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\crypt16.c ===
// ------------------------------------------------------------------------
// Crypt16.c
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
//
// ------------------------------------------------------------------------

#include "crypt16.h"

static int check_parity();

int des_check_key=0;

void des_set_odd_parity(key)
des_cblock *key;
	{
	int i;

	for (i=0; i<DES_KEY_SZ; i++)
		(*key)[i]=odd_parity[(*key)[i]];
	}

static int check_parity(key)
des_cblock *key;
	{
	int i;

	for (i=0; i<DES_KEY_SZ; i++)
		{
		if ((*key)[i] != odd_parity[(*key)[i]])
			return(0);
		}
	return(1);
	}

/* Weak and semi week keys as take from
 * %A D.W. Davies
 * %A W.L. Price
 * %T Security for Computer Networks
 * %I John Wiley & Sons
 * %D 1984
 * Many thanks to smb@ulysses.att.com (Steven Bellovin) for the reference
 * (and actual cblock values).
 */
#define NUM_WEAK_KEY	16
static des_cblock weak_keys[NUM_WEAK_KEY]={
	/* weak keys */
	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
	0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,
	0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,
	0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,
	/* semi-weak keys */
	0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE,
	0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01,
	0x1F,0xE0,0x1F,0xE0,0x0E,0xF1,0x0E,0xF1,
	0xE0,0x1F,0xE0,0x1F,0xF1,0x0E,0xF1,0x0E,
	0x01,0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1,
	0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1,0x01,
	0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E,0xFE,
	0xFE,0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E,
	0x01,0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E,
	0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E,0x01,
	0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE,
	0xFE,0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1};

int des_is_weak_key(key)
des_cblock *key;
	{
	ulong *lp;
	register ulong l,r;
	int i;

	c2l(key,l);
	c2l(key,r);
	/* the weak_keys bytes should be aligned */
	lp=(ulong *)weak_keys;
	for (i=0; i<NUM_WEAK_KEY; i++)
		{
		if ((l == lp[0]) && (r == lp[1]))
			return(1);
		lp+=2;
		}
	return(0);
	}

/* See ecb_encrypt.c for a pseudo description of these macros. */
#define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
	(b)^=(t),\
	(a)^=((t)<<(n)))

#define HPERM_OP(a,t,n,m) ((t)=((((a)<<(16-(n)))^(a))&(m)),\
	(a)=(a)^(t)^(t>>(16-(n))))\

static char shifts2[16]={0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0};

/* return 0 if key parity is odd (correct),
 * return -1 if key parity error,
 * return -2 if illegal weak key.
 */
int des_set_key(key,schedule)
des_cblock *key;
des_key_schedule schedule;
	{
	register ulong c,d,t,s;
	register uchar *in;
	register ulong *k;
	register int i;

	if (des_check_key)
		{
		if (!check_parity(key))
			return(-1);

		if (des_is_weak_key(key))
			return(-2);
		}

	k=(ulong *)schedule;
	in=(uchar *)key;

	c2l(in,c);
	c2l(in,d);

	/* do PC1 in 60 simple operations */ 
	PERM_OP(d,c,t,4,0x0f0f0f0f);
	HPERM_OP(c,t,-2, 0xcccc0000);
	HPERM_OP(c,t,-1, 0xaaaa0000);
	HPERM_OP(c,t, 8, 0x00ff0000);
	HPERM_OP(c,t,-1, 0xaaaa0000);
	HPERM_OP(d,t,-8, 0xff000000);
	HPERM_OP(d,t, 8, 0x00ff0000);
	HPERM_OP(d,t, 2, 0x33330000);
	d=((d&0x00aa00aa)<<7)|((d&0x55005500)>>7)|(d&0xaa55aa55);
	d=(d>>8)|((c&0xf0000000)>>4);
	c&=0x0fffffff;

	for (i=0; i<ITERATIONS; i++)
		{
		if (shifts2[i])
			{ c=((c>>2)|(c<<26)); d=((d>>2)|(d<<26)); }
		else
			{ c=((c>>1)|(c<<27)); d=((d>>1)|(d<<27)); }
		c&=0x0fffffff;
		d&=0x0fffffff;
		/* could be a few less shifts but I am to lazy at this
		 * point in time to investigate */
		s=	des_skb[0][ (c    )&0x3f                ]|
			des_skb[1][((c>> 6)&0x03)|((c>> 7)&0x3c)]|
			des_skb[2][((c>>13)&0x0f)|((c>>14)&0x30)]|
			des_skb[3][((c>>20)&0x01)|((c>>21)&0x06) |
			                      ((c>>22)&0x38)];
		t=	des_skb[4][ (d    )&0x3f                ]|
			des_skb[5][((d>> 7)&0x03)|((d>> 8)&0x3c)]|
			des_skb[6][ (d>>15)&0x3f                ]|
			des_skb[7][((d>>21)&0x0f)|((d>>22)&0x30)];

		/* table contained 0213 4657 */
		*(k++)=((t<<16)|(s&0x0000ffff));
		s=     ((s>>16)|(t&0xffff0000));
		
		s=(s<<4)|(s>>28);
		*(k++)=s;
		}
	return(0);
	}

int des_key_sched(key,schedule)
des_cblock *key;
des_key_schedule schedule;
	{
	return(des_set_key(key,schedule));
	}


/* The changes to this macro may help or hinder, depending on the
 * compiler and the achitecture.  gcc2 always seems to do well :-).
 * Inspired by Dana How <how@isl.stanford.edu> */
#ifdef ALT_ECB
#define D_ENCRYPT(L,R,S) \
	u=((R^s[S  ])<<2);	\
	t= R^s[S+1]; \
	t=((t>>2)+(t<<30)); \
	L^= \
	*(ulong *)(des_SP+0x0100+((t    )&0xfc))+ \
	*(ulong *)(des_SP+0x0300+((t>> 8)&0xfc))+ \
	*(ulong *)(des_SP+0x0500+((t>>16)&0xfc))+ \
	*(ulong *)(des_SP+0x0700+((t>>24)&0xfc))+ \
	*(ulong *)(des_SP+       ((u    )&0xfc))+ \
  	*(ulong *)(des_SP+0x0200+((u>> 8)&0xfc))+ \
  	*(ulong *)(des_SP+0x0400+((u>>16)&0xfc))+ \
 	*(ulong *)(des_SP+0x0600+((u>>24)&0xfc));
#else /* original version */
#define D_ENCRYPT(L,R,S)	\
	u=(R^s[S  ]); \
	t=R^s[S+1]; \
	t=((t>>4)+(t<<28)); \
	L^=	des_SPtrans[1][(t    )&0x3f]| \
		des_SPtrans[3][(t>> 8)&0x3f]| \
		des_SPtrans[5][(t>>16)&0x3f]| \
		des_SPtrans[7][(t>>24)&0x3f]| \
		des_SPtrans[0][(u    )&0x3f]| \
		des_SPtrans[2][(u>> 8)&0x3f]| \
		des_SPtrans[4][(u>>16)&0x3f]| \
		des_SPtrans[6][(u>>24)&0x3f];
#endif

	/* IP and FP
	 * The problem is more of a geometric problem that random bit fiddling.
	 0  1  2  3  4  5  6  7      62 54 46 38 30 22 14  6
	 8  9 10 11 12 13 14 15      60 52 44 36 28 20 12  4
        16 17 18 19 20 21 22 23      58 50 42 34 26 18 10  2
	24 25 26 27 28 29 30 31  to  56 48 40 32 24 16  8  0

	32 33 34 35 36 37 38 39      63 55 47 39 31 23 15  7
	40 41 42 43 44 45 46 47      61 53 45 37 29 21 13  5
	48 49 50 51 52 53 54 55      59 51 43 35 27 19 11  3
	56 57 58 59 60 61 62 63      57 49 41 33 25 17  9  1

	The output has been subject to swaps of the form
	0 1 -> 3 1 but the odd and even bits have been put into
	2 3    2 0 
	different words.  The main trick is to remember that
	t=((l>>size)^r)&(mask);
	r^=t;
	l^=(t<<size);
	can be used to swap and move bits between words.

	So l =  0  1  2  3  r = 16 17 18 19
	        4  5  6  7      20 21 22 23
	        8  9 10 11      24 25 26 27
	       12 13 14 15      28 29 30 31
	becomes (for size == 2 and mask == 0x3333)
	   t =   2^16  3^17 -- --   l =  0  1 16 17  r =  2  3 18 19
		 6^20  7^21 -- --        4  5 20 21       6  7 22 23
		10^24 11^25 -- --        8  9 24 25      10 11 24 25
                14^28 15^29 -- --       12 13 28 29      14 15 28 29

	Thanks for hints from Richard Outerbridge - he told me IP&FP
	could be done in 15 xor, 10 shifts and 5 ands.
	When I finally started to think of the problem in 2D
	I first got ~42 operations without xors.  When I remembered
	how to use xors :-) I got it to its final state.
	*/
#define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
	(b)^=(t),\
	(a)^=((t)<<(n)))

int des_encrypt(input,output,ks,encrypt)
ulong *input;
ulong *output;
des_key_schedule ks;
int encrypt;
	{
	register ulong l,r,t,u;
#ifdef ALT_ECB
	register uchar *des_SP=(uchar *)des_SPtrans;
#endif
	register int i;
	register ulong *s;

	l=input[0];
	r=input[1];

	/* do IP */
	PERM_OP(r,l,t, 4,0x0f0f0f0f);
	PERM_OP(l,r,t,16,0x0000ffff);
	PERM_OP(r,l,t, 2,0x33333333);
	PERM_OP(l,r,t, 8,0x00ff00ff);
	PERM_OP(r,l,t, 1,0x55555555);
	/* r and l are reversed - remember that :-) - fix
	 * it in the next step */

	/* Things have been modified so that the initial rotate is
	 * done outside the loop.  This required the 
	 * des_SPtrans values in sp.h to be rotated 1 bit to the right.
	 * One perl script later and things have a 5% speed up on a sparc2.
	 * Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
	 * for pointing this out. */
	t=(r<<1)|(r>>31);
	r=(l<<1)|(l>>31); 
	l=t;

	s=(ulong *)ks;
	/* I don't know if it is worth the effort of loop unrolling the
	 * inner loop */
	if (encrypt)
		{
		for (i=0; i<32; i+=4)
			{
			D_ENCRYPT(l,r,i+0); /*  1 */
			D_ENCRYPT(r,l,i+2); /*  2 */
			}
		}
	else
		{
		for (i=30; i>0; i-=4)
			{
			D_ENCRYPT(l,r,i-0); /* 16 */
			D_ENCRYPT(r,l,i-2); /* 15 */
			}
		}
	l=(l>>1)|(l<<31);
	r=(r>>1)|(r<<31);

	/* swap l and r
	 * we will not do the swap so just remember they are
	 * reversed for the rest of the subroutine
	 * luckily FP fixes this problem :-) */

	PERM_OP(r,l,t, 1,0x55555555);
	PERM_OP(l,r,t, 8,0x00ff00ff);
	PERM_OP(r,l,t, 2,0x33333333);
	PERM_OP(l,r,t,16,0x0000ffff);
	PERM_OP(r,l,t, 4,0x0f0f0f0f);

	output[0]=l;
	output[1]=r;
	return(0);
	}




int des_cbc_encrypt(input,output,length,schedule,ivec,encrypt)
des_cblock *input;
des_cblock *output;
long length;
des_key_schedule schedule;
des_cblock *ivec;
int encrypt;
	{
	register ulong tin0,tin1;
	register ulong tout0,tout1,xor0,xor1;
	register uchar *in,*out;
	register long l=length;
	ulong tout[2],tin[2];
	uchar *iv;

	in=(uchar *)input;
	out=(uchar *)output;
	iv=(uchar *)ivec;

	if (encrypt)
		{
		c2l(iv,tout0);
		c2l(iv,tout1);
		for (; l>0; l-=8)
			{
			if (l >= 8)
				{
				c2l(in,tin0);
				c2l(in,tin1);
				}
			else
				c2ln(in,tin0,tin1,l);
			tin0^=tout0;
			tin1^=tout1;
			tin[0]=tin0;
			tin[1]=tin1;
			des_encrypt((ulong *)tin,(ulong *)tout,
				schedule,encrypt);
			tout0=tout[0];
			tout1=tout[1];
			l2c(tout0,out);
			l2c(tout1,out);
			}
		}
	else
		{
		c2l(iv,xor0);
		c2l(iv,xor1);
		for (; l>0; l-=8)
			{
			c2l(in,tin0);
			c2l(in,tin1);
			tin[0]=tin0;
			tin[1]=tin1;
			des_encrypt((ulong *)tin,(ulong *)tout,
				schedule,encrypt);
			tout0=tout[0]^xor0;
			tout1=tout[1]^xor1;
			if (l >= 8)
				{
				l2c(tout0,out);
				l2c(tout1,out);
				}
			else
				l2cn(tout0,tout1,out,l);
			xor0=tin0;
			xor1=tin1;
			}
		}
	tin0=tin1=tout0=tout1=xor0=xor1=0;
	return(0);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\dllmain.h ===
// --------------------------------------------------------------------------------
// Dllmain.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __DLLMAIN_H
#define __DLLMAIN_H
#include "msident.h"
// --------------------------------------------------------------------------------
// Forward-Decls
// --------------------------------------------------------------------------------
class CAccountManager;

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern HINSTANCE               g_hInst;
extern HINSTANCE               g_hInstRes;
extern LONG                    g_cRef;
extern LONG                    g_cLock;
extern CRITICAL_SECTION        g_csDllMain;
extern CRITICAL_SECTION        g_csAcctMan;
extern CAccountManager        *g_pAcctMan;
extern BOOL                    g_fCachedGUID;
extern GUID                    g_guidCached;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
ULONG DllAddRef(void);
ULONG DllRelease(void);

#endif // __DLLMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\eudora.cpp ===
#include "pch.hxx"
#include <imnact.h>
#include <acctimp.h>
#include <dllmain.h>
#include <resource.h>
#include "eudora.h"
#include "demand.h"

ASSERTDATA

CEudoraAcctImport::CEudoraAcctImport()
    {
    m_cRef = 1;
    *m_szIni = 0;
    m_cInfo = 0;
    m_rgInfo = NULL;
    }

CEudoraAcctImport::~CEudoraAcctImport()
    {
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
    }

STDMETHODIMP CEudoraAcctImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IUnknown == riid)
		*ppv = (IAccountImport *)this;
	else if (IID_IAccountImport == riid)
		*ppv = (IAccountImport *)this;
	else if (IID_IAccountImport2 == riid)
		*ppv = (IAccountImport2 *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
    }

STDMETHODIMP_(ULONG) CEudoraAcctImport::AddRef()
    {
    return(++m_cRef);
    }

STDMETHODIMP_(ULONG) CEudoraAcctImport::Release()
    {
    if (--m_cRef == 0)
        {
        delete this;
        return(0);
        }

    return(m_cRef);
    }

const static char c_szRegEudora[] = "Software\\Qualcomm\\Eudora\\CommandLine";
const static char c_szCmdValue[] = "Current";

HRESULT STDMETHODCALLTYPE CEudoraAcctImport::AutoDetect(DWORD *pcAcct, DWORD dwFlags)
    {
    HRESULT hr;
    HKEY hkey;
    char *szCmdLine, *sz, *psz, szExpanded[MAX_PATH];
    DWORD type, cb;

    if (pcAcct == NULL)
        return(E_INVALIDARG);

    hr = S_FALSE;
    *pcAcct = 0;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegEudora, 0, KEY_ALL_ACCESS, &hkey))
        {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szCmdValue, NULL, &type, NULL, &cb) &&
            cb > 0 &&
            ((type == REG_SZ) || (type == REG_EXPAND_SZ)))
            {
            if (MemAlloc((void **)&szCmdLine, cb))
                {
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szCmdValue, NULL, &type, (LPBYTE)szCmdLine, &cb))
                    {
                    sz = szCmdLine;
                    sz = PszSkipWhiteA(sz);

                    sz = PszScanToWhiteA(sz);
                    sz = PszSkipWhiteA(sz);

                    sz = PszScanToWhiteA(sz);
                    sz = PszSkipWhiteA(sz);

                    if (REG_EXPAND_SZ == type)
                    {
                        DWORD nReturn = ExpandEnvironmentStrings(sz, szExpanded, ARRAYSIZE(szExpanded));

                        if (nReturn && nReturn <= ARRAYSIZE(szExpanded))
                            psz = szExpanded;
                        else
                            psz = sz;
                    }
                    else
                        psz = sz;

                    if (*psz != 0 && 0xffffffff != GetFileAttributes(psz))
                        hr = InitAccounts(psz);
                    }

                MemFree(szCmdLine);
                }
            else
                {
                hr = E_OUTOFMEMORY;
                }
            }

        RegCloseKey(hkey);
        }

    // TODO: if we haven't found the ini file in the reg,
    // let's search for it...

    if (hr == S_OK)
        *pcAcct = m_cInfo;

    return(hr);
    }

HRESULT STDMETHODCALLTYPE CEudoraAcctImport::EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum)
    {
    CEnumEUDORAACCTS *penum;
    HRESULT hr;

    if (ppEnum == NULL)
        return(E_INVALIDARG);

    *ppEnum = NULL;

    if (m_cInfo == 0)
        return(S_FALSE);
    Assert(m_rgInfo != NULL);

    penum = new CEnumEUDORAACCTS;
    if (penum == NULL)
        return(E_OUTOFMEMORY);

    hr = penum->Init(m_rgInfo, m_cInfo);
    if (FAILED(hr))
        {
        penum->Release();
        penum = NULL;
        }

    *ppEnum = penum;

    return(hr);
    }

HRESULT STDMETHODCALLTYPE CEudoraAcctImport::GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct)
    {
    if (pAcct == NULL)
        return(E_INVALIDARG);

    return(IGetSettings(dwCookie, pAcct, NULL));
    }

HRESULT STDMETHODCALLTYPE CEudoraAcctImport::GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
    {
    if (pAcct == NULL ||
        pInfo == NULL)
        return(E_INVALIDARG);

    return(IGetSettings(dwCookie, pAcct, pInfo));
    }

const static char c_szEmpty[] = "";
const static char c_szRealName[] = "RealName";
const static char c_szSmtpServer[] = "SMTPServer";
const static char c_szReturnAddress[] = "ReturnAddress";
const static char c_szPopAccount[] = "POPAccount";
const static char c_szLeaveMailOnServer[] = "LeaveMailOnServer";
const static char c_szUsesIMAP[] = "UsesIMAP";
const static char c_szUsesPOP[] = "UsesPOP";
const static char c_sz1[] = "1";
const static char c_szConnName[] = "AutoConnectionName";

HRESULT CEudoraAcctImport::IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
    {
    BOOL fSMTP, fEmail, fPop;
    EUDORAACCTINFO *pinfo;
    char sz[512], *szT;
    DWORD cb;
    HRESULT hr;

    Assert(pAcct != NULL);

    fSMTP = FALSE;
    fEmail = FALSE;

    Assert(((int) dwCookie) >= 0 && dwCookie < (DWORD_PTR)m_cInfo);
    pinfo = &m_rgInfo[dwCookie];
    
    Assert(pinfo->dwCookie == dwCookie);

    hr = pAcct->SetPropSz(AP_ACCOUNT_NAME, pinfo->szDisplay);
    if (FAILED(hr))
        return(hr);

    cb = GetPrivateProfileString(pinfo->szSection, c_szRealName, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
    if (cb > 0 && !FIsEmpty(sz))
        {
        hr = pAcct->SetPropSz(AP_SMTP_DISPLAY_NAME, sz);
        Assert(!FAILED(hr));
        }

    cb = GetPrivateProfileString(pinfo->szSection, c_szSmtpServer, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
    if (cb > 0 && !FIsEmpty(sz))
        {
        hr = pAcct->SetPropSz(AP_SMTP_SERVER, sz);
        Assert(!FAILED(hr));

        fSMTP = TRUE;
        }

    cb = GetPrivateProfileString(pinfo->szSection, c_szReturnAddress, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
    if (cb > 0 && !FIsEmpty(sz))
        {
        hr = pAcct->SetPropSz(AP_SMTP_EMAIL_ADDRESS, sz);
        Assert(!FAILED(hr));

        fEmail = TRUE;
        }

    fPop = TRUE;
    cb = GetPrivateProfileString(pinfo->szSection, c_szUsesPOP, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
    if (cb == 0 || 0 != lstrcmp(sz, c_sz1))
        {
        cb = GetPrivateProfileString(pinfo->szSection, c_szUsesIMAP, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0 && 0 == lstrcmp(sz, c_sz1))
            fPop = FALSE;
        }
    
    cb = GetPrivateProfileString(pinfo->szSection, c_szPopAccount, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
    if (cb > 0 && !FIsEmpty(sz))
        {
        if (!fEmail)
            {
            hr = pAcct->SetPropSz(AP_SMTP_EMAIL_ADDRESS, sz);
            Assert(!FAILED(hr));
            }

        szT = PszScanToCharA(sz, '@');
        if (*szT)
            {
            *szT = 0;
            szT++;

            hr = pAcct->SetPropSz(fPop ? AP_POP3_USERNAME : AP_IMAP_USERNAME, sz);
            Assert(!FAILED(hr));

            hr = pAcct->SetPropSz(fPop ? AP_POP3_SERVER : AP_IMAP_SERVER, szT);
            Assert(!FAILED(hr));
            if (!fSMTP)
                {
                hr = pAcct->SetPropSz(AP_SMTP_SERVER, szT);
                Assert(!FAILED(hr));
                }
            }
        }

    if (fPop)
        {
        cb = GetPrivateProfileString(pinfo->szSection, c_szLeaveMailOnServer, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0 && 0 == lstrcmp(sz, c_sz1))
            {
            hr = pAcct->SetPropDw(AP_POP3_LEAVE_ON_SERVER, 1);
            Assert(!FAILED(hr));
            }
        }

    if (pInfo != NULL)
        {
        cb = GetPrivateProfileString(pinfo->szSection, c_szConnName, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0 && !FIsEmpty(sz))
            {
            pInfo->dwConnect = CONN_USE_SETTINGS;
            pInfo->dwConnectType = CONNECTION_TYPE_RAS;
            StrCpyN(pInfo->szConnectoid, sz, ARRAYSIZE(pInfo->szConnectoid));
            }
        else
            {
            // TODO: determine if we need to create a connectoid
            pInfo->dwConnect = CONN_USE_DEFAULT;
            }
        }

    return(S_OK);
    }

const static char c_szPersona[] = "Personalities";
const static char c_szSettings[] = "Settings";

#define CALLOCINFO      8
#define CALLOCSETTINGS  0x07fff

HRESULT CEudoraAcctImport::InitAccounts(char *szIni)
    {
    HRESULT hr;
    DWORD cch, cInfoBuf;
    char *szBuf, *szKey, *szVal;

    Assert(m_cInfo == 0);
    Assert(m_rgInfo == NULL);

    if (!MemAlloc((void **)&szBuf, CALLOCSETTINGS))
        return(E_OUTOFMEMORY);

    hr = E_FAIL;

    cch = GetPrivateProfileSection(c_szSettings, szBuf, 0x07fff, szIni);
    if (cch != 0)
        {
        if (!MemAlloc((void **)&m_rgInfo, CALLOCINFO * sizeof(EUDORAACCTINFO)))
            {
            hr = E_OUTOFMEMORY;
            goto done;
            }
        cInfoBuf = CALLOCINFO;
        
        m_rgInfo[m_cInfo].dwCookie = m_cInfo;
        StrCpyN(m_rgInfo[m_cInfo].szSection, c_szSettings, ARRAYSIZE(m_rgInfo[m_cInfo].szSection));
        LoadString(g_hInstRes, idsDefaultAccount, m_rgInfo[m_cInfo].szDisplay, ARRAYSIZE(m_rgInfo[m_cInfo].szDisplay));
        m_cInfo++;

        cch = GetPrivateProfileSection(c_szPersona, szBuf, 0x07fff, szIni);
        if ((cch != 0) && (cch != (0x07fff - 2)))
            {
            szKey = szBuf;

            while (TRUE)
                {
                if (m_cInfo == cInfoBuf)
                    {
                    cInfoBuf += CALLOCINFO;
                    if (!MemRealloc((void **)&m_rgInfo, cInfoBuf * sizeof(EUDORAACCTINFO)))
                        {
                        hr = E_OUTOFMEMORY;
                        goto done;
                        }
                    }

                szVal = PszScanToCharA(szKey, '=');
                if (*szVal != 0)
                    {
                    szVal++;
                    m_rgInfo[m_cInfo].dwCookie = m_cInfo;
                    StrCpyN(m_rgInfo[m_cInfo].szSection, szVal, ARRAYSIZE(m_rgInfo[m_cInfo].szSection));
                    StrCpyN(m_rgInfo[m_cInfo].szDisplay, szVal, ARRAYSIZE(m_rgInfo[m_cInfo].szDisplay));
                    m_cInfo++;
                    }

                szKey = szVal;
                while (*szKey != 0)
                    szKey++;
                szKey++;
                if (*szKey == 0)
                    break;
                }

            }

        StrCpyN(m_szIni, szIni, ARRAYSIZE(m_szIni));

        hr = S_OK;
        }

done:
    MemFree(szBuf);

    return(hr);
    }

HRESULT STDMETHODCALLTYPE CEudoraAcctImport::InitializeImport(HWND hwnd, DWORD_PTR dwCookie)
    {
    return(E_NOTIMPL);
    }

HRESULT STDMETHODCALLTYPE CEudoraAcctImport::GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved)
    {
    return(E_NOTIMPL);
    }

CEnumEUDORAACCTS::CEnumEUDORAACCTS()
    {
    m_cRef = 1;
    // m_iInfo
    m_cInfo = 0;
    m_rgInfo = NULL;
    }

CEnumEUDORAACCTS::~CEnumEUDORAACCTS()
    {
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
    }

STDMETHODIMP CEnumEUDORAACCTS::QueryInterface(REFIID riid, LPVOID *ppv)
    {

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
	else if (IID_IEnumIMPACCOUNTS == riid)
		*ppv = (IEnumIMPACCOUNTS *)this;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();
    else
        return(E_NOINTERFACE);

    return(S_OK);
    }

STDMETHODIMP_(ULONG) CEnumEUDORAACCTS::AddRef()
    {
    return(++m_cRef);
    }

STDMETHODIMP_(ULONG) CEnumEUDORAACCTS::Release()
    {
    if (--m_cRef == 0)
        {
        delete this;
        return(0);
        }

    return(m_cRef);
    }

HRESULT STDMETHODCALLTYPE CEnumEUDORAACCTS::Next(IMPACCOUNTINFO *pinfo)
    {
    if (pinfo == NULL)
        return(E_INVALIDARG);

    m_iInfo++;
    if ((UINT)m_iInfo >= m_cInfo)
        return(S_FALSE);

    Assert(m_rgInfo != NULL);

    pinfo->dwCookie = m_rgInfo[m_iInfo].dwCookie;
    pinfo->dwReserved = 0;
    StrCpyN(pinfo->szDisplay, m_rgInfo[m_iInfo].szDisplay, ARRAYSIZE(pinfo->szDisplay));

    return(S_OK);
    }

HRESULT STDMETHODCALLTYPE CEnumEUDORAACCTS::Reset()
    {
    m_iInfo = -1;

    return(S_OK);
    }

HRESULT CEnumEUDORAACCTS::Init(EUDORAACCTINFO *pinfo, int cinfo)
    {
    DWORD cb;

    Assert(pinfo != NULL);
    Assert(cinfo > 0);

    cb = cinfo * sizeof(EUDORAACCTINFO);
    
    if (!MemAlloc((void **)&m_rgInfo, cb))
        return(E_OUTOFMEMORY);

    m_iInfo = -1;
    m_cInfo = cinfo;
    CopyMemory(m_rgInfo, pinfo, cb);

    return(S_OK);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\exchacct.cpp ===
#include "pch.hxx"
#include <imnact.h>
#include <acctimp.h>
#include <dllmain.h>
#include <resource.h>
#include "exchacct.h"
#include "acctman.h"
#include "strconst.h"
#include "demand.h"

ASSERTDATA

HKEY InetMailProfile(HKEY hkey);

CMAPIAcctImport::CMAPIAcctImport()
    {
    m_cRef = 1;
    m_cInfo = 0;
    m_rgInfo = NULL;
    m_pAcctMan = NULL;
    }

CMAPIAcctImport::~CMAPIAcctImport()
    {
    UINT i;

    if (m_rgInfo != NULL)
        {
        for (i = 0; i < m_cInfo; i++)
            {
            if (m_rgInfo[i].hkey != NULL)
                RegCloseKey(m_rgInfo[i].hkey);
            if (m_rgInfo[i].pAccount != NULL)
                m_rgInfo[i].pAccount->Release();
            }

        MemFree(m_rgInfo);
        }

    if (m_pAcctMan != NULL)
        m_pAcctMan->Release();
    }

STDMETHODIMP CMAPIAcctImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IUnknown == riid)
		*ppv = (IAccountImport *)this;
	else if (IID_IAccountImport == riid)
		*ppv = (IAccountImport *)this;
	else if (IID_IAccountImport2 == riid)
		*ppv = (IAccountImport2 *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
    }

STDMETHODIMP_(ULONG) CMAPIAcctImport::AddRef()
    {
    return(++m_cRef);
    }

STDMETHODIMP_(ULONG) CMAPIAcctImport::Release()
    {
    if (--m_cRef == 0)
        {
        delete this;
        return(0);
        }

    return(m_cRef);
    }

const static char c_szRegNT[] = "Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows Messaging Subsystem\\Profiles";
const static char c_szRegWin[] = "Software\\Microsoft\\Windows Messaging Subsystem\\Profiles";

HRESULT STDMETHODCALLTYPE CMAPIAcctImport::AutoDetect(DWORD *pcAcct, DWORD dwFlags)
    {
    LONG lRet;
    TCHAR szProfile[MAX_PATH];
    HKEY hkey, hkeyProfile, hkeyInet;
    HRESULT hr;
    DWORD i, type, cb, cProfiles, dwMax;
    OSVERSIONINFO osinfo;
    BOOL fNT;
    IImnEnumAccounts *pEnumAccounts;
    IImnAccount *pAccount;

    if (pcAcct == NULL)
        return(E_INVALIDARG);

    hr = S_OK;
    *pcAcct = 0;
    cProfiles = 0;

    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osinfo);
    fNT = (osinfo.dwPlatformId == VER_PLATFORM_WIN32_NT);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, fNT ? c_szRegNT : c_szRegWin, 0, KEY_ALL_ACCESS, &hkey))
        {
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey, NULL, NULL, NULL, &cProfiles, &dwMax, NULL, NULL, NULL, NULL, NULL, NULL) &&
            cProfiles > 0)
            {
            Assert(dwMax < MAX_PATH);
            cb = cProfiles * sizeof(MAPIACCTINFO);
            if (MemAlloc((void **)&m_rgInfo, cb))
                {
                ZeroMemory(m_rgInfo, cb);

                for (i = 0; i < cProfiles; i++)
                    {
                    cb = sizeof(szProfile);
                    lRet = RegEnumKeyEx(hkey, i, szProfile, &cb, NULL, NULL, NULL, NULL);
                    if (lRet == ERROR_NO_MORE_ITEMS)
                        break;
                    else if (lRet != ERROR_SUCCESS)
                        continue;

                    if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szProfile, 0, KEY_ALL_ACCESS, &hkeyProfile))
                        {
                        hkeyInet = InetMailProfile(hkeyProfile);
                        if (hkeyInet != NULL)
                            {
                            m_rgInfo[m_cInfo].dwCookie = m_cInfo;
                            m_rgInfo[m_cInfo].hkey = hkeyInet;
                            StrCpyN(m_rgInfo[m_cInfo].szDisplay, szProfile, ARRAYSIZE(m_rgInfo[m_cInfo].szDisplay));
                            m_cInfo++;
                            }

                        RegCloseKey(hkeyProfile);
                        }
                    }
                }
            else
                {
                hr = E_OUTOFMEMORY;
                }
            }

        RegCloseKey(hkey);
        }

    if (0 == (dwFlags & ACCT_WIZ_OUTLOOK) &&
        ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szInetAcctMgrRegKey, 0, KEY_READ, &hkey))
    {
        cb = sizeof(szProfile);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szRegOutlook, NULL, &type, (LPBYTE)szProfile, &cb))
        {
            m_pAcctMan = new CAccountManager();
            if (m_pAcctMan == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = m_pAcctMan->InitEx(NULL, ACCT_INIT_OUTLOOK);
                if (SUCCEEDED(hr))
                {
                    if (SUCCEEDED(m_pAcctMan->Enumerate(SRV_IMAP | SRV_POP3 | SRV_SMTP, &pEnumAccounts)))
                    {
                        if (SUCCEEDED(pEnumAccounts->GetCount(&i)) && i > 0)
                        {
                            cb = (m_cInfo + i) * sizeof(MAPIACCTINFO);
                            if (MemRealloc((void **)&m_rgInfo, cb))
                            {
                                ZeroMemory(&m_rgInfo[m_cInfo], i * sizeof(MAPIACCTINFO));

                                while (SUCCEEDED(pEnumAccounts->GetNext(&pAccount)))
                                {
                                    if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_NAME, m_rgInfo[m_cInfo].szDisplay, ARRAYSIZE(m_rgInfo[m_cInfo].szDisplay))))
                                    {
                                        m_rgInfo[m_cInfo].dwCookie = m_cInfo;
                                        m_rgInfo[m_cInfo].pAccount = pAccount;
                                        pAccount->AddRef();
                                        m_cInfo++;
                                    }

                                    pAccount->Release();
                                }
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
        
                        pEnumAccounts->Release();
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

    if (SUCCEEDED(hr))
        {
        if (m_cInfo == 0)
            hr = S_FALSE;
        }

    *pcAcct = m_cInfo;

    return(hr);
    }

HRESULT STDMETHODCALLTYPE CMAPIAcctImport::EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum)
    {
    CEnumMAPIACCTS *penum;
    HRESULT hr;

    if (ppEnum == NULL)
        return(E_INVALIDARG);

    *ppEnum = NULL;

    if (m_cInfo == 0)
        return(S_FALSE);
    Assert(m_rgInfo != NULL);

    penum = new CEnumMAPIACCTS;
    if (penum == NULL)
        return(E_OUTOFMEMORY);

    hr = penum->Init(m_rgInfo, m_cInfo);
    if (FAILED(hr))
        {
        penum->Release();
        penum = NULL;
        }

    *ppEnum = penum;

    return(hr);
    }

HRESULT STDMETHODCALLTYPE CMAPIAcctImport::GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct)
    {
    if (pAcct == NULL)
        return(E_INVALIDARG);

    return(IGetSettings(dwCookie, pAcct, NULL));
    }

HRESULT STDMETHODCALLTYPE CMAPIAcctImport::GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
    {
    if (pAcct == NULL ||
        pInfo == NULL)
        return(E_INVALIDARG);

    return(IGetSettings(dwCookie, pAcct, pInfo));
    }

const static TCHAR c_szPopSvr[] = TEXT("001e6600");
const static TCHAR c_szAddr[] = TEXT("001e6605");
const static TCHAR c_szMAPIUsername[] = TEXT("001e6606");
const static TCHAR c_szName[] = TEXT("001e6607");
const static TCHAR c_szSmtpSvr[] = TEXT("001e6611");

typedef struct tagMAPISETTINGS
    {
    LPCTSTR sz;
    DWORD dwProp;
    } MAPISETTINGS;

const static MAPISETTINGS c_rgSet[] =
    {
    {c_szPopSvr, AP_POP3_SERVER},
    {c_szAddr, AP_SMTP_EMAIL_ADDRESS},
    {c_szMAPIUsername, AP_POP3_USERNAME},
    {c_szName, AP_SMTP_DISPLAY_NAME},
    {c_szSmtpSvr, AP_SMTP_SERVER}
    };

#define CMAPISETTINGS   ARRAYSIZE(c_rgSet)

HRESULT STDMETHODCALLTYPE CMAPIAcctImport::IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
{
    MAPIACCTINFO *pinfo;
    char sz[MAX_PATH];
    DWORD cb, srv, dw;
    HRESULT hr;
    BOOL fIMAP;
    const MAPISETTINGS *pset;
    int i;
    LPCPROPINFO pProp;

    if (pAcct == NULL)
        return(E_INVALIDARG);
    
    Assert(((int) dwCookie) >= 0 && dwCookie < (DWORD_PTR)m_cInfo);
    pinfo = &m_rgInfo[dwCookie];
    
    Assert(pinfo->dwCookie == dwCookie);
    
    hr = pAcct->SetPropSz(AP_ACCOUNT_NAME, pinfo->szDisplay);
    if (FAILED(hr))
        return(hr);
    
    if (pinfo->hkey != NULL)
    {
        for (i = 0, pset = c_rgSet; i < CMAPISETTINGS; i++, pset++)
        {
            cb = sizeof(sz);
            if (ERROR_SUCCESS == RegQueryValueEx(pinfo->hkey, pset->sz, NULL, NULL, (LPBYTE)sz, &cb) &&
                !FIsEmpty(sz))
            {
                pAcct->SetPropSz(pset->dwProp, sz);
                
                // in exchange if no SMTP server is specified, then the SMTP server
                // is the same as the POP3 server
                // ASSUMPTION: pop server MUST come before smtp server in c_rgSet
                if (pset->dwProp == AP_POP3_SERVER)
                    pAcct->SetPropSz(AP_SMTP_SERVER, sz);
            }
        }
    }
    else
    {
        Assert(pinfo->pAccount != NULL);

        hr = pinfo->pAccount->GetServerTypes(&srv);
        if (SUCCEEDED(hr) && !!(srv & (SRV_POP3 | SRV_IMAP)))
        {
            fIMAP = (srv & SRV_IMAP);

            for (i = 0, pProp = g_rgAcctPropSet; i < NUM_ACCT_PROPS; i++, pProp++)
            {
                if ((fIMAP && pProp->dwPropTag >= AP_IMAP_FIRST && pProp->dwPropTag <= AP_IMAP_LAST) ||
                    (!fIMAP && pProp->dwPropTag >= AP_POP3_FIRST && pProp->dwPropTag <= AP_POP3_LAST) ||
                    (pProp->dwPropTag >= AP_SMTP_FIRST && pProp->dwPropTag <= AP_SMTP_LAST))
                {
                    cb = sizeof(sz);
                    hr = pinfo->pAccount->GetProp(pProp->dwPropTag, (LPBYTE)sz, &cb);
                    if (hr == S_OK)
                        pAcct->SetProp(pProp->dwPropTag, (LPBYTE)sz, cb);
                }
            }

            if (pInfo != NULL)
            {
                hr = pinfo->pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dw);
                if (hr == S_OK)
                {
                    if (dw == CONNECTION_TYPE_RAS)
                    {
                        cb = sizeof(sz);
                        hr = pinfo->pAccount->GetProp(AP_RAS_CONNECTOID, (LPBYTE)sz, &cb);
                        if (SUCCEEDED(hr))
                        {
                            StrCpyN(pInfo->szConnectoid, sz, ARRAYSIZE(pInfo->szConnectoid));

                            pInfo->dwConnect = CONN_USE_SETTINGS;
                            pInfo->dwConnectType = dw;
                        }
                    }
                    else
                    {
                        pInfo->dwConnect = CONN_USE_SETTINGS;
                        pInfo->dwConnectType = dw;
                    }
                }
            }
        }
    }
    
    return(S_OK);
}

CEnumMAPIACCTS::CEnumMAPIACCTS()
    {
    m_cRef = 1;
    // m_iInfo
    m_cInfo = 0;
    m_rgInfo = NULL;
    }

CEnumMAPIACCTS::~CEnumMAPIACCTS()
    {
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
    }

STDMETHODIMP CEnumMAPIACCTS::QueryInterface(REFIID riid, LPVOID *ppv)
    {

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
	else if (IID_IEnumIMPACCOUNTS == riid)
		*ppv = (IEnumIMPACCOUNTS *)this;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();
    else
        return(E_NOINTERFACE);

    return(S_OK);
    }

STDMETHODIMP_(ULONG) CEnumMAPIACCTS::AddRef()
    {
    return(++m_cRef);
    }

STDMETHODIMP_(ULONG) CEnumMAPIACCTS::Release()
    {
    if (--m_cRef == 0)
        {
        delete this;
        return(0);
        }

    return(m_cRef);
    }

HRESULT STDMETHODCALLTYPE CEnumMAPIACCTS::Next(IMPACCOUNTINFO *pinfo)
    {
    if (pinfo == NULL)
        return(E_INVALIDARG);

    m_iInfo++;
    if ((UINT)m_iInfo >= m_cInfo)
        return(S_FALSE);

    Assert(m_rgInfo != NULL);

    pinfo->dwCookie = m_rgInfo[m_iInfo].dwCookie;
    pinfo->dwReserved = 0;
    StrCpyN(pinfo->szDisplay, m_rgInfo[m_iInfo].szDisplay, ARRAYSIZE(pinfo->szDisplay));

    return(S_OK);
    }

HRESULT STDMETHODCALLTYPE CEnumMAPIACCTS::Reset()
    {
    m_iInfo = -1;

    return(S_OK);
    }

HRESULT CEnumMAPIACCTS::Init(MAPIACCTINFO *pinfo, int cinfo)
    {
    DWORD cb;

    Assert(pinfo != NULL);
    Assert(cinfo > 0);

    cb = cinfo * sizeof(MAPIACCTINFO);
    
    if (!MemAlloc((void **)&m_rgInfo, cb))
        return(E_OUTOFMEMORY);

    m_iInfo = -1;
    m_cInfo = cinfo;
    CopyMemory(m_rgInfo, pinfo, cb);

    return(S_OK);
    }

BOOL MatchingPrefix(LPCTSTR sz, LPCTSTR szPrefix)
    {
    Assert(sz != NULL);
    Assert(szPrefix != NULL);

    while (*szPrefix != 0)
        {
        if (*sz == 0 ||
            *sz != *szPrefix)
            return(FALSE);

        szPrefix++;
        sz++;
        }

    return(TRUE);
    }

void SzFromBinary(BYTE *pb, TCHAR *sz, int cb)
    {
    int i;

    Assert(pb != NULL);
    Assert(sz != NULL);

    for (i = 0; i < cb; i++)
        {
        wnsprintf(sz, (cb / sizeof(sz[0])), TEXT("%0.2x"), *pb);
        pb++;
        sz += 2;
        }

    *sz = 0;
    }

#define CBTURD 16

const static TCHAR c_sz9207[] = TEXT("9207");
const static TCHAR c_szBullshit[] = TEXT("01023d02");
const static TCHAR c_szImailValue[] = TEXT("001e3d09");
const static TCHAR c_szGarbage[] = TEXT("01023d0c");
const static TCHAR c_szImail[] = TEXT("IMAIL");
const static TCHAR c_szImep[] = TEXT("001e661f");

HKEY InetMailProfile(HKEY hkey)
    {
    HKEY hkeyInet, hkey9207, hkeyTurd;
    TCHAR szKey[MAX_PATH], szTurd[CBTURD * 2 + 1];
    BYTE *pb, *pbT, rgbGarbage[CBTURD];
    LONG lRet;
    DWORD cb, i, iTurd, cTurds, iByte;

    hkeyInet = NULL;

    i = 0;
    while (hkeyInet == NULL)
        {
        cb = sizeof(szKey);
        lRet = RegEnumKeyEx(hkey, i++, szKey, &cb, NULL, NULL, NULL, NULL);
        if (lRet == ERROR_NO_MORE_ITEMS)
            break;
        else if (lRet != ERROR_SUCCESS)
            continue;

        if (!MatchingPrefix(szKey, c_sz9207))
            continue;

        if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szKey, 0, KEY_ALL_ACCESS, &hkey9207))
            {
            if (ERROR_SUCCESS == RegQueryValueEx(hkey9207, c_szBullshit, NULL, NULL, NULL, &cb) && cb > 0)
                {
                if (MemAlloc((void **)&pb, cb))
                    {
                    if (ERROR_SUCCESS == RegQueryValueEx(hkey9207, c_szBullshit, NULL, NULL, pb, &cb))
                        {
                        cTurds = cb / CBTURD;
                        pbT = pb;
                        for (iTurd = 0; iTurd < cTurds && hkeyInet == NULL; iTurd++)
                            {
                            SzFromBinary(pbT, szTurd, CBTURD);
                            pbT += CBTURD;

                            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szTurd, 0, KEY_ALL_ACCESS, &hkeyTurd))
                                {
                                cb = sizeof(szKey);
                                if (ERROR_SUCCESS == RegQueryValueEx(hkeyTurd, c_szImailValue, NULL, NULL, (LPBYTE)szKey, &cb) &&
                                    0 == lstrcmpi(szKey, c_szImail))
                                    {
                                    cb = sizeof(rgbGarbage);
                                    if (ERROR_SUCCESS == RegQueryValueEx(hkeyTurd, c_szGarbage, NULL, NULL, rgbGarbage, &cb))
                                        {
                                        Assert(cb == CBTURD);
                                        SzFromBinary(rgbGarbage, szTurd, CBTURD);

                                        if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szTurd, 0, KEY_ALL_ACCESS, &hkeyInet))
                                            {
                                            if (ERROR_SUCCESS == RegQueryValueEx(hkeyInet, c_szImep, NULL, NULL, NULL, &cb))
                                                {
                                                RegCloseKey(hkeyInet);
                                                hkeyInet = NULL;
                                                }
                                            }
                                        }
                                    }

                                RegCloseKey(hkeyTurd);
                                }
                            }
                        }

                    MemFree(pb);
                    }
                }

            RegCloseKey(hkey9207);
            }
        }

    return(hkeyInet);
    }

HRESULT STDMETHODCALLTYPE CMAPIAcctImport::InitializeImport(HWND hwnd, DWORD_PTR dwCookie)
    {
    return(E_NOTIMPL);
    }

HRESULT STDMETHODCALLTYPE CMAPIAcctImport::GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved)
    {
    return(E_NOTIMPL);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\factory.cpp ===
// --------------------------------------------------------------------------------
// Factory.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include <mshtml.h>
#include <mshtmhst.h>
#include <prsht.h>
#include "dllmain.h"
#include "factory.h"
#include <imnact.h>
#include "acctman.h"
#include <icwacct.h>
#include <acctimp.h>
#include <icwwiz.h>
#include <eudora.h>
#include <netscape.h>
#include <exchacct.h>
#include "navnews.h"
#include <CommAct.h>  // Netscape Communicator - Mail Account Import
#include <CommNews.h> // Netscape Communicator - News Account Import
#include <AgntNews.h> // Forte Agent - News Account Import
#include <NExpress.h> // News Express - News Account Import
#include <hotwiz.h>
#include "hotwizui.h"

// --------------------------------------------------------------------------------
// Pretty
// --------------------------------------------------------------------------------
#define OBJTYPE0        0
#define OBJTYPE1        OIF_ALLOWAGGREGATION

// --------------------------------------------------------------------------------
// Global Object Info Table
// --------------------------------------------------------------------------------
static CClassFactory g_rgFactory[] = {
    CClassFactory(&CLSID_ImnAccountManager,   OBJTYPE0, (PFCREATEINSTANCE)IImnAccountManager_CreateInstance),
    CClassFactory(&CLSID_ApprenticeAcctMgr,   OBJTYPE0, (PFCREATEINSTANCE)IICWApprentice_CreateInstance),
    CClassFactory(&CLSID_CEudoraAcctImport,   OBJTYPE0, (PFCREATEINSTANCE)CEudoraAcctImport_CreateInstance),
    CClassFactory(&CLSID_CNscpAcctImport,     OBJTYPE0, (PFCREATEINSTANCE)CNscpAcctImport_CreateInstance),
    CClassFactory(&CLSID_CCommAcctImport,     OBJTYPE0, (PFCREATEINSTANCE)CCommAcctImport_CreateInstance),
    CClassFactory(&CLSID_CMAPIAcctImport,     OBJTYPE0, (PFCREATEINSTANCE)CMAPIAcctImport_CreateInstance),
    CClassFactory(&CLSID_CCommNewsAcctImport, OBJTYPE0, (PFCREATEINSTANCE)CCommNewsAcctImport_CreateInstance), // Netscape Communicator
    CClassFactory(&CLSID_CNavNewsAcctImport,  OBJTYPE0, (PFCREATEINSTANCE)CNavNewsAcctImport_CreateInstance), // Netscape Navigator
    CClassFactory(&CLSID_CAgentAcctImport,    OBJTYPE0, (PFCREATEINSTANCE)CCAgentAcctImport_CreateInstance), // Forte Agent
    CClassFactory(&CLSID_CNExpressAcctImport, OBJTYPE0, (PFCREATEINSTANCE)CNExpressAcctImport_CreateInstance), // News Express
    CClassFactory(&CLSID_OEHotMailWizard,     OBJTYPE0, (PFCREATEINSTANCE)CHotMailWizard_CreateInstance) // HoTMaiL Wizard
};
                 
// --------------------------------------------------------------------------------
// DllGetClassObject
// --------------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // No memory allocator
    if (NULL == g_pMalloc)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Find Object Class
    for (i=0; i<ARRAYSIZE(g_rgFactory); i++)
    {
        // Compare for clsids
        if (IsEqualCLSID(rclsid, *g_rgFactory[i].m_pclsid))
        {
            // Delegate to the factory
            CHECKHR(hr = g_rgFactory[i].QueryInterface(riid, ppv));

            // Done
            goto exit;
        }
    }

    // Otherwise, no class
    hr = TrapError(CLASS_E_CLASSNOTAVAILABLE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::CClassFactory
// --------------------------------------------------------------------------------
CClassFactory::CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance)
    : m_pclsid(pclsid), m_dwFlags(dwFlags), m_pfCreateInstance(pfCreateInstance)
{
}

// --------------------------------------------------------------------------------
// CClassFactory::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    // Invalid Arg
    if (NULL == ppvObj)
        return TrapError(E_INVALIDARG);

    // IClassFactory or IUnknown
    if (!IsEqualIID(riid, IID_IClassFactory) && !IsEqualIID(riid, IID_IUnknown))
        return TrapError(E_NOINTERFACE);

    // Return the Class Facotry
    *ppvObj = (LPVOID)this;

    // Add Ref the dll
    DllAddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CClassFactory::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    DllAddRef();
    return 2;
}

// --------------------------------------------------------------------------------
// CClassFactory::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    DllRelease();
    return 1;
}

// --------------------------------------------------------------------------------
// CClassFactory::CreateInstance
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Locals
    HRESULT         hr=S_OK;
    IUnknown       *pObject=NULL;

    // Bad param
    if (ppvObj == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter && IID_IUnknown != riid)
        return TrapError(CLASS_E_NOAGGREGATION);

    // No memory allocator
    if (NULL == g_pMalloc)
        return TrapError(E_OUTOFMEMORY);

    // Can I do aggregaton
    if (pUnkOuter !=NULL && !(m_dwFlags & OIF_ALLOWAGGREGATION))  
        return TrapError(CLASS_E_NOAGGREGATION);

    // Create the object...
    CHECKHR(hr = CreateObjectInstance(pUnkOuter, &pObject));

    // Aggregated, then we know we're looking for an IUnknown, return pObject, otherwise, QI
    if (pUnkOuter)
    {
        // Matches Release after Exit
        pObject->AddRef();

        // Return pObject::IUnknown
        *ppvObj = (LPVOID)pObject;
    }

    // Otherwise
    else
    {
        // Get the interface requested from pObj
        CHECKHR(hr = pObject->QueryInterface(riid, ppvObj));
    }
   
exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    Assert(FAILED(hr) ? NULL == *ppvObj : TRUE);
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::LockServer
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock) InterlockedIncrement(&g_cLock);
    else       InterlockedDecrement(&g_cLock);
    return NOERROR;
}

// --------------------------------------------------------------------------------
// IImnAccountManager_CreateInstance
// --------------------------------------------------------------------------------
HRESULT APIENTRY IImnAccountManager_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CAccountManager *pNew;
    HrCreateAccountManager((IImnAccountManager **)&pNew);
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IImnAccountManager *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IICWApprentice_CreateInstance
// --------------------------------------------------------------------------------
HRESULT APIENTRY IICWApprentice_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CICWApprentice *pNew = new CICWApprentice();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IICWApprentice *);

    // Done
    return S_OK;
}

HRESULT APIENTRY CEudoraAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CEudoraAcctImport *pNew = new CEudoraAcctImport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IAccountImport *);

    // Done
    return S_OK;
}

HRESULT APIENTRY CNscpAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CNscpAcctImport *pNew = new CNscpAcctImport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IAccountImport *);

    // Done
    return S_OK;
}

HRESULT APIENTRY CCommAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CCommAcctImport *pNew = new CCommAcctImport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IAccountImport *);

    // Done
    return S_OK;
}


HRESULT APIENTRY CMAPIAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMAPIAcctImport *pNew = new CMAPIAcctImport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IAccountImport *);

    // Done
    return S_OK;
}

HRESULT APIENTRY CCommNewsAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CCommNewsAcctImport *pNew = new CCommNewsAcctImport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IAccountImport *);

    // Done
    return S_OK;
}

HRESULT APIENTRY CNavNewsAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CNavNewsAcctImport *pNew = new CNavNewsAcctImport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IAccountImport *);

    // Done
    return S_OK;
}

HRESULT APIENTRY CCAgentAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CAgentAcctImport *pNew = new CAgentAcctImport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IAccountImport *);

    // Done
    return S_OK;
}

HRESULT APIENTRY CNExpressAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CNExpressAcctImport *pNew = new CNExpressAcctImport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IAccountImport *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHotMailWizard_CreateInstance
// --------------------------------------------------------------------------------
HRESULT APIENTRY CHotMailWizard_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CHotMailWizard *pNew;
    pNew = new CHotMailWizard();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IHotWizard *);

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\hotwizom.h ===
#pragma once
/*
 *    h o t w i z o m . h
 *    
 *    Purpose:
 *          HotMail Wizard Object Model
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

interface IOEHotWizardOM;
interface IHashTable;

class COEHotWizOm :
    public IOEHotWizardOM,
    public IElementBehavior
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // ---------------------------------------------------------------------------
    // IDispatch members
    // ---------------------------------------------------------------------------
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // ---------------------------------------------------------------------------
    // IOEAcctWizardOM members
    // ---------------------------------------------------------------------------
    virtual HRESULT STDMETHODCALLTYPE setPropSz(BSTR bstrProp, BSTR bstrVal);
    virtual HRESULT STDMETHODCALLTYPE getPropSz(BSTR bstrProp, BSTR *pbstrVal);
    virtual HRESULT STDMETHODCALLTYPE clearProps();
    virtual HRESULT STDMETHODCALLTYPE createAccount(BSTR bstrINS);
    virtual HRESULT STDMETHODCALLTYPE close(VARIANT_BOOL fPrompt);
    virtual HRESULT STDMETHODCALLTYPE get_width(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE put_width(LONG l);
    virtual HRESULT STDMETHODCALLTYPE get_height(LONG *pl);
    virtual HRESULT STDMETHODCALLTYPE put_height(LONG l);

    // ---------------------------------------------------------------------------
    // IElementBehavior members
    // ---------------------------------------------------------------------------
    virtual HRESULT STDMETHODCALLTYPE Init(IElementBehaviorSite *pBehaviorSite);
    virtual HRESULT STDMETHODCALLTYPE Notify(LONG lEvent, VARIANT *pVar);
    virtual HRESULT STDMETHODCALLTYPE Detach();

    
    COEHotWizOm();
    virtual ~COEHotWizOm();

    HRESULT Init(HWND hwndDlg, IHotWizardHost *pWizHost);

private:
    ULONG           m_cRef;
    LPTYPEINFO      m_pTypeInfo;
    HWND            m_hwndDlg;
    IHashTable      *m_pHash;
    IHotWizardHost  *m_pWizHost;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\hotwizui.h ===
#pragma once 
/*
 *    h o t w i z u i . h 
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

interface IHotWizard;
interface IHotWizardHost;
interface IElementBehaviorFactory;
interface IDocHostUIHandler;

#define HWM_SETDIRTY    (WM_USER + 1)

class CHotMailWizard :
    public IServiceProvider,
    public IElementBehaviorFactory,
    public IDocHostUIHandler,
    public IHotWizard
{
public:

    CHotMailWizard();
    virtual ~CHotMailWizard();

    // IUnknown methods
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IServiceProvider
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    // IElementBehaviorFactory
    virtual HRESULT STDMETHODCALLTYPE FindBehavior(LPOLESTR pchBehavior, LPOLESTR pchBehaviorUrl, IElementBehaviorSite* pSite, IElementBehavior** ppBehavior);

    // IDocHostUIHandler methods
    virtual HRESULT STDMETHODCALLTYPE ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
    virtual HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO *pInfo);
    virtual HRESULT STDMETHODCALLTYPE ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc);
    virtual HRESULT STDMETHODCALLTYPE HideUI();
    virtual HRESULT STDMETHODCALLTYPE UpdateUI();
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw);
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    virtual HRESULT STDMETHODCALLTYPE GetExternal(IDispatch **ppDispatch);
    virtual HRESULT STDMETHODCALLTYPE TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    virtual HRESULT STDMETHODCALLTYPE FilterDataObject( IDataObject *pDO, IDataObject **ppDORet);

    // IHotWizard
    virtual HRESULT STDMETHODCALLTYPE Show(HWND hwndOwner, LPWSTR pszUrl, LPWSTR pszCaption, IHotWizardHost *pHost, RECT *prc);

    static INT_PTR CALLBACK ExtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT Init();
    HRESULT Show();
    
    HRESULT TranslateAccelerator(MSG *lpmsg);

private:
    ULONG               m_cRef;
    HWND                m_hwnd,
                        m_hwndOC,
                        m_hwndOwner;
    BOOL                m_fPrompt;
    RECT                *m_prc;
    IElementBehavior    *m_pXTag;
    IHotWizardHost      *m_pWizHost;
    LPWSTR              m_pszUrlW,
                        m_pszFriendlyW;

    HRESULT _CreateOCHost();
    HRESULT _OnInitDialog(HWND hwnd);
    HRESULT _OnNCDestroy();
    HRESULT _LoadPage(LPWSTR pszUrlW);

    BOOL _DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\hotwizom.cpp ===
/*
 *    w i z o m. c p p 
 *    
 *    Purpose:
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "dllmain.h"
#include <mshtml.h>
#include <mshtmhst.h>
#include <mimeole.h>
#include "icwacct.h"

#include "hotwiz.h"
#include "hotwizom.h"
#include "hotwizui.h"

#define HASH_GROW_SIZE  32



COEHotWizOm::COEHotWizOm()
{
    m_pTypeInfo = NULL;
    m_cRef = 1;
    m_hwndDlg = NULL;
    m_pHash = NULL;
    m_pWizHost = NULL;

    DllAddRef();
}

COEHotWizOm::~COEHotWizOm()
{
    clearProps();

    ReleaseObj(m_pTypeInfo);
    ReleaseObj(m_pWizHost);

    AssertSz(m_pHash == NULL, "clearPops catches this");
    DllRelease();
}

HRESULT COEHotWizOm::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IOEHotWizardOM *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)this;
    else if (IsEqualIID(riid, IID_IOEHotWizardOM))
        *lplpObj = (LPVOID)(IOEHotWizardOM *)this;
    else if (IsEqualIID(riid, IID_IElementBehavior))
        *lplpObj = (LPVOID)(IElementBehavior *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

ULONG COEHotWizOm::AddRef()
{
    return ++m_cRef;
}

ULONG COEHotWizOm::Release()
{
    if (0 == --m_cRef)
    {
        delete this;
        return 0;
    }
    else
        return m_cRef;
}
 
HRESULT COEHotWizOm::Init(HWND hwndDlg, IHotWizardHost *pWizHost)
{
    TCHAR       szDll[MAX_PATH];
    LPWSTR      pszW=NULL;
    HRESULT     hr = E_FAIL;
    ITypeLib    *pTypeLib=NULL;


    ReplaceInterface(m_pWizHost, pWizHost);

    // see who we are
    if (!GetModuleFileName(g_hInst, szDll, ARRAYSIZE(szDll)))
    {
        hr = TraceResult(E_FAIL);
        goto error;
    }

    pszW = PszToUnicode(CP_ACP, szDll);
    if (!pszW)
    {
        hr = TraceResult (E_OUTOFMEMORY);
        goto error;
    }

    // load the MSOE.DLL typelibrary
    hr = LoadTypeLib(pszW, &pTypeLib);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // load our type-info data
    hr = pTypeLib->GetTypeInfoOfGuid(IID_IOEHotWizardOM, &m_pTypeInfo);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    m_hwndDlg = hwndDlg;

error:
    SafeMemFree(pszW);
    ReleaseObj(pTypeLib);
    return hr;
}

// *** IDispatch ***
HRESULT COEHotWizOm::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

HRESULT COEHotWizOm::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    if (!m_pTypeInfo)
        return E_FAIL;
        
    if (!pptinfo)
        return E_INVALIDARG;

    if (itinfo)
        return DISP_E_BADINDEX;

    m_pTypeInfo->AddRef();
    *pptinfo = m_pTypeInfo;
    return S_OK;
}

HRESULT COEHotWizOm::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    if (!m_pTypeInfo)
        return E_FAIL;

    return DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);
}

HRESULT COEHotWizOm::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    if (!m_pTypeInfo)
        return E_FAIL;

    return DispInvoke(this, m_pTypeInfo, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}

HRESULT COEHotWizOm::setPropSz(BSTR bstrProp, BSTR bstrVal)
{
    LPSTR   pszPropA=NULL;
    BSTR    bstr=NULL;
    HRESULT hr=S_OK;
    
    // make sure we have a valid property
    if (bstrProp == NULL || *bstrProp == NULL)
        return E_INVALIDARG;

    // make sure we have a hash
    if (!m_pHash)
    {
        hr = CoCreateInstance(CLSID_IHashTable, NULL, CLSCTX_INPROC_SERVER, IID_IHashTable, (LPVOID*)&m_pHash);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto error;
        }

        hr = m_pHash->Init(HASH_GROW_SIZE, TRUE);
        if (FAILED(hr))
        {
            SafeRelease(m_pHash);
            TraceResult(hr);
            goto error;
        }
    }

    // convert property to ANSI to work with our hashtable
    pszPropA = PszToANSI(CP_ACP, bstrProp);
    if (!pszPropA)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }
    
    // see if this property already exists, if so we're going to replace it
    if (m_pHash->Find(pszPropA, TRUE, (LPVOID *)&bstr)==S_OK)
    {
        SysFreeString(bstr);
        bstr = NULL;
    }

    // bstrVal might be NULL if they just want to remove the prop
    if (bstrVal)
    {
        // dupe our own BSTR to hold onto
        bstr = SysAllocString(bstrVal);
        if (!bstr)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto error;
        }

        // insert the new property
        hr = m_pHash->Insert(pszPropA, (LPVOID)bstr, NOFLAGS);
        if (FAILED(hr))
        {
            TraceResult(hr);
            goto error;
        }
    
        bstr = NULL;    // release when destroying the hash
    }

error:
    SafeMemFree(pszPropA);
    SysFreeString(bstr);
    return hr;
}

HRESULT COEHotWizOm::getPropSz(BSTR bstrProp, BSTR *pbstrVal)
{
    LPSTR   pszPropA=NULL;
    BSTR    bstr;
    
    // make sure we have a valid property
    if (bstrProp == NULL || *bstrProp == NULL)
        return E_INVALIDARG;

    *pbstrVal = NULL;

    // if we have no hash then there are no props
    if (m_pHash)
    {
        // convert property to ANSI to work with our hashtable
        pszPropA = PszToANSI(CP_ACP, bstrProp);
        if (!pszPropA)
            return TraceResult(E_OUTOFMEMORY);
    
        // see if this property exists
        if (m_pHash->Find(pszPropA, FALSE, (LPVOID *)&bstr)==S_OK)
            *pbstrVal = SysAllocString(bstr);
    }

    // if we failed to find, try and return a NULL string, so that the script
    // engine doesn't barf with errors
    if (*pbstrVal == NULL)
        *pbstrVal = SysAllocString(L"");

    SafeMemFree(pszPropA);
    return *pbstrVal ? S_OK : E_OUTOFMEMORY;
}


HRESULT COEHotWizOm::clearProps()
{
    ULONG   cFound;
    BSTR    bstr;
    LPVOID  *rgpv;

    if (m_pHash)
    {
        m_pHash->Reset();

        // free all the strings
        while (SUCCEEDED(m_pHash->Next(HASH_GROW_SIZE, &rgpv, &cFound)))
        {
            while (cFound--)
                SysFreeString((BSTR)rgpv[cFound]);
            
            MemFree(rgpv);
        }        
        m_pHash->Release();
        m_pHash = NULL;
    }
    return S_OK;
}


HRESULT COEHotWizOm::createAccount(BSTR bstrINS)
{   
    HRESULT hr;
    LPSTR   pszInsA=NULL;
    LPSTR   pszPathA=NULL;
    HANDLE  hFile=NULL;
    ULONG   cbWritten=0;

    TraceCall("COEHotWizOm::createAccount");

    // if we have a wizard host (possibly outlook in the future), delegate...
    if (m_pWizHost)
        return m_pWizHost->CreateAccountFromINS(bstrINS);

    // convert to ANSI
    pszInsA = PszToANSI(CP_ACP, bstrINS);
    if (!pszInsA)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // create temp INS file for account manager
    hr = CreateTempFile("oeacct", ".ins", &pszPathA, &hFile);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // write the data to the file
    if (!WriteFile(hFile, pszInsA, lstrlen(pszInsA), &cbWritten, NULL))
    {
        hr = TraceResult(E_FAIL);
        goto error;
    }

    CloseHandle(hFile);
    hFile = NULL;

    // create the account from the temp file
    hr = CreateAccountsFromFile(pszPathA, 6);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }
    
error:
    if (hFile)
        CloseHandle(hFile);

    if (pszPathA)
    {
        DeleteFile(pszPathA);
        MemFree(pszPathA);
    }

    SafeMemFree(pszInsA);
    return hr;
}

HRESULT COEHotWizOm::close(VARIANT_BOOL fPrompt)
{
    // send message to set the prompt flag
    SendMessage(m_hwndDlg, HWM_SETDIRTY, (fPrompt == VARIANT_TRUE), 0);
    
    // do the close
    SendMessage(m_hwndDlg, WM_CLOSE, 0, 0);
    return S_OK;
}

HRESULT COEHotWizOm::get_width(LONG *pl)
{
    RECT    rc;

    GetWindowRect(m_hwndDlg, &rc);

    *pl = rc.right - rc.left;
    return S_OK;
}

HRESULT COEHotWizOm::put_width(LONG l)
{
    LONG    lHeight=NULL;

    get_height(&lHeight);
    SetWindowPos(m_hwndDlg, 0, 0, 0, l, lHeight, SWP_NOMOVE|SWP_NOZORDER);
    return S_OK;
}

HRESULT COEHotWizOm::get_height(LONG *pl)
{
    RECT    rc;

    GetWindowRect(m_hwndDlg, &rc);

    *pl = rc.bottom - rc.top;
    return S_OK;
}

HRESULT COEHotWizOm::put_height(LONG l)
{
    LONG    lWidth=NULL;

    get_width(&lWidth);
    SetWindowPos(m_hwndDlg, 0, 0, 0, lWidth, l, SWP_NOMOVE|SWP_NOZORDER);
    return S_OK;
}



HRESULT COEHotWizOm::Init(IElementBehaviorSite *pBehaviorSite)
{
    return S_OK;
}

HRESULT COEHotWizOm::Notify(LONG lEvent, VARIANT *pVar)
{
    return S_OK;
}

HRESULT COEHotWizOm::Detach()
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\exchacct.h ===
#ifndef _INC_EXCHACCT
#define _INC_EXCHACCT

class CAccountManager;

typedef struct tagMAPIACCTINFO
    {
    DWORD_PTR dwCookie;
    HKEY hkey;
    IImnAccount *pAccount;
    char szDisplay[CCHMAX_ACCOUNT_NAME];
    } MAPIACCTINFO;

// {39981128-C287-11D0-8D8C-00C04FD6202B}
DEFINE_GUID(CLSID_CEnumMAPIACCTS, 0x39981128L, 0xC287, 0x11D0, 0x8D, 0x8C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

class CEnumMAPIACCTS : public IEnumIMPACCOUNTS
    {
    private:
        ULONG           m_cRef;
        int             m_iInfo;
        UINT            m_cInfo;
        MAPIACCTINFO    *m_rgInfo;

    public:
        CEnumMAPIACCTS(void);
        ~CEnumMAPIACCTS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE Next(IMPACCOUNTINFO *pinfo);
        HRESULT STDMETHODCALLTYPE Reset(void);

        HRESULT Init(MAPIACCTINFO *pinfo, int cinfo);
    };

// {39981129-C287-11D0-8D8C-00C04FD6202B}
DEFINE_GUID(CLSID_CMAPIAcctImport, 0x39981129L, 0xC287, 0x11D0, 0x8D, 0x8C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

class CMAPIAcctImport : public IAccountImport, public IAccountImport2
    {
    private:
        ULONG           m_cRef;
        UINT            m_cInfo;
        MAPIACCTINFO    *m_rgInfo;
        CAccountManager *m_pAcctMan;

        HRESULT STDMETHODCALLTYPE IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);

    public:
        CMAPIAcctImport(void);
        ~CMAPIAcctImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE AutoDetect(DWORD *pcAcct, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum);
        HRESULT STDMETHODCALLTYPE GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct);

        HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd, DWORD_PTR dwCookie);
        HRESULT STDMETHODCALLTYPE GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);
    };

#endif // _INC_EXCHACCT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\hotwizui.cpp ===
/*
 *    h o t w i z u i . c p p 
 *    
 *    Purpose:
 *          HotMail Wizard UI
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include <mshtml.h>
#include <mshtmhst.h>
#include <mimeole.h>
#include "dllmain.h"
#include <hotwiz.h>
#include "hotwizui.h"
#include "hotwizom.h"
#include "shlwapi.h"
#include "resource.h"

#define CX_DEF_WIZARD       503
#define CY_DEF_WIZARD       400

typedef BOOL (WINAPI *PFNDLLREGWNDCLASS)(const SHDRC * pshdrc);


//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CHotMailWizard::CHotMailWizard()
{
    m_hwnd=NULL;
    m_hwndOC=NULL;
    m_hwndOwner = NULL;

    m_cRef=1;
    m_pXTag = NULL;

    m_prc = NULL;
    m_pszFriendlyW = NULL;
    m_pszUrlW = NULL;
    m_fPrompt = TRUE;

    m_pWizHost = NULL;

    DllAddRef();
}

//+---------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CHotMailWizard::~CHotMailWizard()
{
    ReleaseObj(m_pXTag);
    DllRelease();
}

ULONG CHotMailWizard::AddRef()
{
    return ++m_cRef;
}

ULONG CHotMailWizard::Release()
{
    m_cRef--;
    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


HRESULT CHotMailWizard::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)this;
    else if (IsEqualIID(riid, IID_IElementBehaviorFactory))
        *lplpObj = (LPVOID)(IElementBehaviorFactory*)this;
    else if (IsEqualIID(riid, IID_IServiceProvider))
        *lplpObj = (LPVOID)(IServiceProvider*)this;
    else if (IsEqualIID(riid, IID_IDocHostUIHandler))
        *lplpObj = (LPVOID)(IDocHostUIHandler *)this;
    else if (IsEqualIID(riid, IID_IHotWizard))
        *lplpObj = (LPVOID)(IHotWizard *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}



INT_PTR CALLBACK CHotMailWizard::ExtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CHotMailWizard *pThis;

    if(msg==WM_INITDIALOG)
    {
        pThis=(CHotMailWizard *)lParam;
        if(!pThis)
            return -1;

        if(FAILED(pThis->_OnInitDialog(hwnd)))
            return -1;
    }
    
    pThis = (CHotMailWizard *)GetWindowLongPtr(hwnd, DWLP_USER);
    return pThis ? pThis->_DlgProc(hwnd, msg, wParam, lParam) : FALSE;
}


HRESULT CHotMailWizard::_OnInitDialog(HWND hwnd)
{
    LPRECT      prc;
    RECT        rc;
    HRESULT     hr = S_OK;
    TCHAR       rgch[CCHMAX_STRINGRES + 100],
                rgchFmt[CCHMAX_STRINGRES];
    LPSTR       pszFriendly=NULL;

    // setup local vars
    m_hwnd = hwnd;
    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)this);

    // figure out initial size, use default if non specified
    if (!m_prc)
    {
        SetRect(&rc, 0, 0, CX_DEF_WIZARD, CY_DEF_WIZARD);
        prc = &rc;
    }
    else
        prc = m_prc;

    // create WebOC
    IF_FAILEXIT(hr = _CreateOCHost());

    // load our page
    _LoadPage(m_pszUrlW);

    // size the dialog
    SetWindowPos(hwnd, 0, prc->left, prc->top, prc->right - prc->left, prc->bottom - prc->top, SWP_NOZORDER);

    // if no rect was passed in then center the dialog
    if (!m_prc)
        CenterDialog(hwnd);


    // if the dialog passed in a friendly name, set the dialog title to reflect this
    if (m_pszFriendlyW)
    {
        IF_NULLEXIT(pszFriendly = PszToANSI(CP_ACP, m_pszFriendlyW));
        if (LoadString(g_hInstRes, idsFmtSetupAccount, rgchFmt, ARRAYSIZE(rgchFmt)))
        {
            wnsprintf(rgch, ARRAYSIZE(rgch), rgchFmt, pszFriendly);
            SetWindowText(hwnd, rgch);
        }
    }

    // success - addref ourselves (released in NCDESTROY)
    AddRef();

    // disable parent window if we are modal
    if (m_hwndOwner)
        EnableWindow(m_hwndOwner, FALSE);


exit:
    MemFree(pszFriendly);
    return hr;
}

HRESULT CHotMailWizard::_OnNCDestroy()
{
    SetWindowLongPtr(m_hwnd, DWLP_USER, NULL);
    m_hwnd = NULL;
    Release();
    PostQuitMessage(0);
    return S_OK;
}


BOOL CHotMailWizard::_DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    RECT    rc;
    LPSTR   psz;
    HRESULT hr;
    TCHAR   rgch[CCHMAX_STRINGRES];

    switch (msg)
    {
        
        case WM_SIZE:
            if (m_hwndOC)
            {
                RECT    rc;

                GetClientRect(hwnd, &rc);
                SetWindowPos(m_hwndOC, NULL, 0, 0, rc.right, rc.bottom, SWP_NOZORDER|SWP_NOMOVE);
            }
            break;

        case HWM_SETDIRTY:
            m_fPrompt = (BOOL) wParam;
            break;

        case WM_CLOSE:
            *rgch=0;
            GetWindowText(hwnd, rgch, ARRAYSIZE(rgch));

            if (m_fPrompt && 
                MessageBoxInst(g_hInstRes, m_hwnd, rgch, MAKEINTRESOURCE(idsPromptCloseWiz), NULL, MB_OKCANCEL)==IDCANCEL)
                return 0; 

            if (m_hwndOwner)
                EnableWindow(m_hwndOwner, TRUE);

            DestroyWindow(hwnd);
            break;

        case WM_DESTROY:
            m_hwndOC = NULL;
            break;

        case WM_NCDESTROY:
            _OnNCDestroy();
            break;
    }

    return FALSE;
};



HRESULT CHotMailWizard::TranslateAccelerator(MSG *lpmsg)
{
    IOleInPlaceActiveObject *pIPAO=0;
    HRESULT     hr = S_FALSE;

    if (m_hwndOC &&
        OCHost_QueryInterface(m_hwndOC, IID_IOleInPlaceActiveObject, (LPVOID*)&pIPAO)==S_OK)
    {
        hr = pIPAO->TranslateAccelerator(lpmsg);
        pIPAO->Release();
    }

    return hr;
}



HRESULT CHotMailWizard::_CreateOCHost()
{
    HRESULT hr = E_FAIL;

    // Create an OCHost window
    m_hwndOC = CreateWindow(OCHOST_CLASS, NULL,
                        WS_CHILD|WS_TABSTOP|WS_VISIBLE,
                        0, 0, 300, 300,
                        m_hwnd, NULL, g_hInst, NULL);
    if (m_hwndOC)
    {
        OCHINITSTRUCT ocs;
        
        ocs.cbSize = sizeof(OCHINITSTRUCT);
        ocs.clsidOC  = CLSID_WebBrowser;
        ocs.punkOwner = (IUnknown *)(IServiceProvider *)this;

        hr = OCHost_InitOC(m_hwndOC, (LPARAM)&ocs);
        if (!FAILED(hr))
        {
            OCHost_DoVerb(m_hwndOC, OLEIVERB_INPLACEACTIVATE, FALSE);
            OCHost_DoVerb(m_hwndOC, OLEIVERB_UIACTIVATE, FALSE);
            OCHost_DoVerb(m_hwndOC, OLEIVERB_SHOW, FALSE);
        }
    }
    return hr;
}


HRESULT CHotMailWizard::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    // don't show a default menu
    if (dwID == CONTEXT_MENU_DEFAULT)
        return S_OK;

    return E_NOTIMPL;
}

HRESULT CHotMailWizard::ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,IOleInPlaceUIWindow *pDoc)
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::HideUI()
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::UpdateUI()
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::EnableModeless(BOOL fActivate)
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::OnDocWindowActivate(BOOL fActivate)
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::OnFrameWindowActivate(BOOL fActivate)
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw)
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::GetExternal(IDispatch **ppDispatch)
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::FilterDataObject( IDataObject *pDO, IDataObject **ppDORet)
{
    return E_NOTIMPL;
}

HRESULT CHotMailWizard::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    if (IsEqualGUID(guidService, SID_SElementBehaviorFactory))
        return QueryInterface(riid, ppvObject);

    return E_NOTIMPL;
}

HRESULT CHotMailWizard::FindBehavior(LPOLESTR pchBehavior, LPOLESTR pchBehaviorUrl, IElementBehaviorSite* pSite, IElementBehavior** ppBehavior)
{
    HRESULT         hr=S_OK;
    COEHotWizOm    *pWizOM=NULL;

    if ((StrCmpIW(pchBehavior, L"WIZARD")==0 && StrCmpIW(pchBehaviorUrl, L"#DEFAULT#WIZARD")==0))
    {
        if (m_pXTag == NULL)
        {
            pWizOM = new COEHotWizOm();
            if (!pWizOM)
                return E_OUTOFMEMORY;

            hr = pWizOM->Init(m_hwnd, m_pWizHost);
            if (FAILED(hr))
                goto error;

            hr = pWizOM->QueryInterface(IID_IElementBehavior, (LPVOID *)&m_pXTag);
            if (FAILED(hr))
                goto error;

            // Now that we have IElementBehaviour, release the "IUnknown" we got from new COEHotWizOm()
            pWizOM->Release();
        }

        if (m_pXTag)
        {
            *ppBehavior = m_pXTag;
            m_pXTag->AddRef();
            return S_OK;
        }
    }

        
error:
    ReleaseObj(pWizOM);
    return hr;
}

HRESULT CHotMailWizard::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    pInfo->dwDoubleClick    = DOCHOSTUIDBLCLK_DEFAULT;
    pInfo->dwFlags          = DOCHOSTUIFLAG_SCROLL_NO|DOCHOSTUIFLAG_ACTIVATE_CLIENTHIT_ONLY|DOCHOSTUIFLAG_NO3DBORDER;
    
    //This sets the flags that match the browser's encoding
    fGetBrowserUrlEncoding(&pInfo->dwFlags);

    pInfo->pchHostCss       = PszDupW(L"OE\\:WIZARD { behavior:url(#DEFAULT#WIZARD) }");
    pInfo->pchHostNS        = PszDupW(L"OE");
    return S_OK;
}
 


HRESULT CHotMailWizard::Show(HWND hwndOwner, LPWSTR pszUrl, LPWSTR pszCaption, IHotWizardHost *pWizHost, RECT *prc)
{
    HRESULT             hr=E_FAIL;
    MSG                 msg;
    HINSTANCE           hShDocVw=NULL;
    PFNDLLREGWNDCLASS   pfnRegisterClass;
    SHDRC               shdrc;
    HWND                hwnd;

    if (pszUrl == NULL)
        return E_INVALIDARG;
    
    hShDocVw = LoadLibrary("SHDOCVW.DLL");
    if (!hShDocVw)
        goto error;
    
    pfnRegisterClass = (PFNDLLREGWNDCLASS)GetProcAddress(hShDocVw, "DllRegisterWindowClasses");
    if (!pfnRegisterClass)
        goto error;

    shdrc.cbSize = sizeof(SHDRC);
    shdrc.dwFlags = SHDRCF_OCHOST;
    
    if (!pfnRegisterClass(&shdrc))
        goto error;

    // stuff the data we care about into members
    m_prc = prc;
    m_hwndOwner = hwndOwner;
    m_pszUrlW = pszUrl;
    m_pszFriendlyW = pszCaption;
    m_pWizHost = pWizHost;  // Modal, so no need to AddRef

    // show the dialog
    hwnd = CreateDialogParam(g_hInstRes, MAKEINTRESOURCE(iddHotWizDlg), m_hwndOwner, CHotMailWizard::ExtDlgProc, (LONG_PTR)this);
    if (!hwnd)
        return E_FAIL;

    while (GetMessage(&msg, NULL, 0, 0))
    {
        if(TranslateAccelerator(&msg) == S_OK)
            continue;
        
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    hr = S_OK;

error:
    if (hShDocVw)
        FreeLibrary(hShDocVw);
    return hr;
}



HRESULT CHotMailWizard::_LoadPage(LPWSTR pszUrlW)
{
    IWebBrowser     *pWebOC;
    HRESULT         hr = E_FAIL;

    if (m_hwndOC &&
        OCHost_QueryInterface(m_hwndOC, IID_IWebBrowser, (LPVOID*)&pWebOC)==S_OK)
    {
        hr = pWebOC->Navigate(pszUrlW, 0, 0, 0, 0);
        pWebOC->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\factory.h ===
// --------------------------------------------------------------------------------
// Factory.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __FACTORY_H
#define __FACTORY_H

class CClassFactory; // Forward

// --------------------------------------------------------------------------------
// Object Flags
// --------------------------------------------------------------------------------
#define OIF_ALLOWAGGREGATION  0x0001

// --------------------------------------------------------------------------------
// Object Creation Prototypes
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFCREATEINSTANCE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);
#define CreateObjectInstance (*m_pfCreateInstance)

// --------------------------------------------------------------------------------
// InetComm ClassFactory
// --------------------------------------------------------------------------------
class CClassFactory : public IClassFactory
{
public:
    CLSID const        *m_pclsid;
    DWORD               m_dwFlags;
    PFCREATEINSTANCE    m_pfCreateInstance;

    // Construction
    CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance);

    // IUnknown members
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory members
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};

// --------------------------------------------------------------------------------
// Object Creators
// --------------------------------------------------------------------------------
HRESULT APIENTRY IImnAccountManager_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT APIENTRY IICWApprentice_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT APIENTRY CEudoraAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT APIENTRY CNscpAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT APIENTRY CCommAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT APIENTRY CMAPIAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT APIENTRY CCommNewsAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT APIENTRY CNavNewsAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT APIENTRY CCAgentAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT APIENTRY CNExpressAcctImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT APIENTRY CHotMailWizard_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);

#endif // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\ids.h ===
#ifndef _INC_IDS_H
#define _INC_IDS_H

// dialog size
#define MY_CXDLG                      304
#define MY_CYDLG                      163
#define MY_CXBMP                      79
#define MY_CYBMP                      160

// these need to stay contiguous
enum
    {
    ORD_PAGE_MAILPROMPT = 0,
    ORD_PAGE_MAILACCT,       
    ORD_PAGE_MIGRATE,        
    ORD_PAGE_MAILACCTIMPORT, 
    ORD_PAGE_MIGRATESELECT,  
    ORD_PAGE_MAILCONFIRM,    
    ORD_PAGE_MAILNAME,       
    ORD_PAGE_MAILADDRESS,    
    ORD_PAGE_MAILSERVER,     
    ORD_PAGE_MAILLOGON,
    ORD_PAGE_MAILCONNECT,    
    ORD_PAGE_MAILCOMPLETE,   
    ORD_PAGE_NEWSMIGRATE,    
    ORD_PAGE_NEWSACCTIMPORT, 
    ORD_PAGE_NEWSACCTSELECT, 
    ORD_PAGE_NEWSCONFIRM,    
    ORD_PAGE_NEWSNAME,       
    ORD_PAGE_NEWSADDRESS,    
    ORD_PAGE_NEWSINFO,       
    ORD_PAGE_NEWSLOGON,      
    ORD_PAGE_NEWSCONNECT,    
    ORD_PAGE_NEWSCOMPLETE,   
    ORD_PAGE_LDAPINFO,       
    ORD_PAGE_LDAPLOGON,      
    ORD_PAGE_LDAPRESOLVE,    
    ORD_PAGE_LDAPCOMPLETE,   
    ORD_PAGE_AD_MAILADDRESS,    
    ORD_PAGE_AD_PASSIFIER,    
    ORD_PAGE_AD_AUTODISCOVERY,     
    ORD_PAGE_AD_USEWEBMAIL,     
    ORD_PAGE_AD_GOTOSERVERINFO,     
    ORD_PAGE_AD_MAILSERVER,     
    ORD_PAGE_AD_MAILNAME,       
    ORD_PAGE_AD_MAILLOGON,
    ORD_PAGE_AD_MAILCONNECT,    
    ORD_PAGE_AD_MAILCOMPLETE,   
    NUM_WIZARD_PAGES        
    };

#define ICW_FIRST_PAGE  ORD_PAGE_MAILPROMPT
#define ICW_LAST_PAGE   ORD_PAGE_MAILLOGON

#endif // _INC_IDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\makefile.inc ===
$O\imnacct.res : $(O)\selfreg.inf

selfreg.src : reg.src reg2.src strings.src

$(O)\selfreg.inx : selfreg.src
	cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\mimedem.cpp ===
/*
**	m i m e d e m . c p p
**	
**	Purpose: implement the loader functions for defer/demand -loaded libraries
**
**  Creators: yst
**  Created: 2/10/99
**	
**	Copyright (C) Microsoft Corp. 1999
*/


#include "pch.hxx"
#include "imnact.h"
#include <acctimp.h>
#include "resource.h"


// W4 stuff
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

#define IMPLEMENT_LOADER_FUNCTIONS
#include "mimedem.h"

// --------------------------------------------------------------------------------
// CRIT_GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
    temp = (TYP_##fn) GetProcAddress(h, #fn);   \
    if (temp)                                   \
        VAR_##fn = temp;                        \
    else                                        \
        {                                       \
        AssertSz(0, VAR_##fn" failed to load"); \
        goto error;                             \
        }

// --------------------------------------------------------------------------------
// RESET
// --------------------------------------------------------------------------------
#define RESET(fn) VAR_##fn = LOADER_##fn;

// --------------------------------------------------------------------------------
// GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR(h, fn) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
    Assert(VAR_##fn != NULL); \
    if(NULL == VAR_##fn ) { \
        VAR_##fn  = LOADER_##fn; \
    }


// --------------------------------------------------------------------------------
// GET_PROC_ADDR_ORDINAL
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR_ORDINAL(h, fn, ord) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, MAKEINTRESOURCE(ord));  \
    Assert(VAR_##fn != NULL);  \
    if(NULL == VAR_##fn ) { \
        VAR_##fn  = LOADER_##fn; \
    }


// --------------------------------------------------------------------------------
// GET_PROC_ADDR3
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR3(h, fn, varname) \
    VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
    Assert(VAR_##varname != NULL);

////////////////////////////////////////////////////////////////////////////
//
//  Variables
////////////////////////////////////////////////////////////////////////////

static HMODULE          s_hMimeOle = 0;

static CRITICAL_SECTION g_csDefMimeLoad = {0};

// --------------------------------------------------------------------------------
// InitDemandLoadedLibs
// --------------------------------------------------------------------------------
void InitDemandMimeole(void)
{
    InitializeCriticalSection(&g_csDefMimeLoad);
}

// --------------------------------------------------------------------------------
// FreeDemandLoadedLibs
// --------------------------------------------------------------------------------
void FreeDemandMimeOle(void)
{
    EnterCriticalSection(&g_csDefMimeLoad);

    SafeFreeLibrary(s_hMimeOle);

    LeaveCriticalSection(&g_csDefMimeLoad);
    DeleteCriticalSection(&g_csDefMimeLoad);

}

// --------------------------------------------------------------------------------
// DemandLoadCrypt32
// --------------------------------------------------------------------------------
BOOL DemandLoadMimeOle(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefMimeLoad);

    if (0 == s_hMimeOle)
        {
        s_hMimeOle = LoadLibrary("INETCOMM.DLL");
        AssertSz((NULL != s_hMimeOle), TEXT("LoadLibrary failed on INETCOMM.DLL"));

        if (0 == s_hMimeOle)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hMimeOle, MimeOleSMimeCapsToDlg);
            GET_PROC_ADDR(s_hMimeOle, MimeOleSMimeCapsFromDlg);
            GET_PROC_ADDR(s_hMimeOle, MimeOleSMimeCapsFull);
            GET_PROC_ADDR(s_hMimeOle, MimeOleSMimeCapInit);

            }
        }

    LeaveCriticalSection(&g_csDefMimeLoad);
    return fRet;
}

HRESULT HrGetHighestSymcaps(LPBYTE * ppbSymcap, ULONG *pcbSymcap);


const BYTE c_RC2_40_ALGORITHM_ID[] =
      {0x30, 0x0F, 0x30, 0x0D, 0x06, 0x08, 0x2A, 0x86,
       0x48, 0x86, 0xF7, 0x0D, 0x03, 0x02, 0x02, 0x01,
       0x28};
const ULONG cbRC2_40_ALGORITHM_ID = 0x11;     // Must be 11 hex to match size!

BOOL AdvSec_FillEncAlgCombo(HWND hwnd, IImnAccount *pAcct, PCCERT_CONTEXT * prgCerts)
{
    HRESULT hr;
    THUMBBLOB   tb = {0,0};

    // Get the default caps blob from the registry
    // hr = poi->pOpt->GetProperty(MAKEPROPSTRING(OPT_MAIL_DEFENCRYPTSYMCAPS), &var, 0);
    if (SUCCEEDED(hr = pAcct->GetProp(AP_SMTP_ENCRYPT_ALGTH, NULL, &tb.cbSize)))
    {
        if (!MemAlloc((void**)&tb.pBlobData, tb.cbSize))
            tb.pBlobData = NULL;
        else
            hr = pAcct->GetProp(AP_SMTP_ENCRYPT_ALGTH, tb.pBlobData, &tb.cbSize);
    }

    if (FAILED(hr) || ! tb.cbSize || ! tb.pBlobData)
    {
        HrGetHighestSymcaps(&tb.pBlobData, &tb.cbSize);
    }
    
    if (tb.pBlobData && tb.cbSize)
    {
        // Init the caps->dlg engine
        if (FAILED(hr = MimeOleSMimeCapsToDlg(
            tb.pBlobData,
            tb.cbSize,
            (prgCerts ? 1 : 0),
            prgCerts,
            hwnd,
            IDC_ALGCOMBO,       // combo box for encryption algorithms
            0,                  // combo box for signing algorithms (we combine encrypt and signing)
            0)))                // id of checkbox for pkcs7-opaque.  We handle this elsewhere.
        {
            DOUTL(1024, "MimeOleSMimeCapsToDlg -> %x\n", hr);
        }
        
        SafeMemFree(tb.pBlobData);
    }
    
    return(SUCCEEDED(hr));
}

// Largest symcap is currently 0x4E with 3DES, RC2/128, RC2/64, DES, RC2/40 and SHA-1.
// You may want to bump up the size when FORTEZZA algorithms are supported.
#define CCH_BEST_SYMCAP 0x50

HRESULT HrGetHighestSymcaps(LPBYTE * ppbSymcap, ULONG *pcbSymcap) 
{
    HRESULT hr=S_OK;
    LPVOID pvSymCapsCookie = NULL;
    LPBYTE pbEncode = NULL;
    ULONG cbEncode = 0;
    DWORD dwBits;
    // The MimeOleSMimeCapsFull call is quite expensive.  The results are always
    // the same during a session.  (They can only change with software upgrade.)
    // Cache the results here for better performance.
    static BYTE szSaveBestSymcap[CCH_BEST_SYMCAP];
    static ULONG cbSaveBestSymcap = 0;

    if (cbSaveBestSymcap == 0) 
    {
        // Init with no symcap gives max allowed by providers
        hr = MimeOleSMimeCapInit(NULL, NULL, &pvSymCapsCookie);
        if (FAILED(hr)) 
            goto exit;

        if (pvSymCapsCookie) 
        {
            // Finish up with SymCaps
            MimeOleSMimeCapsFull(pvSymCapsCookie, TRUE, FALSE, pbEncode, &cbEncode);

            if (cbEncode) 
            {
                if (! MemAlloc((LPVOID *)&pbEncode, cbEncode)) 
                    cbEncode = 0;
                else 
                {
                    hr = MimeOleSMimeCapsFull(pvSymCapsCookie, TRUE, FALSE, pbEncode, &cbEncode);
                    if (SUCCEEDED(hr)) 
                    {
                        // Save this symcap in the static array for next time
                        // Only if we have room!
                        if (cbEncode <= CCH_BEST_SYMCAP) 
                        {
                            memcpy(szSaveBestSymcap, pbEncode, cbEncode);
                            cbSaveBestSymcap = cbEncode;
                        }
                    }
                }
            }
            SafeMemFree(pvSymCapsCookie);
        }

    } 
    else 
    {
        // We have saved the best in the static array.  Avoid the time intensive
        // MimeOle query.
        cbEncode = cbSaveBestSymcap;
        if (! MemAlloc((LPVOID *)&pbEncode, cbEncode))
            cbEncode = 0;
        else 
            memcpy(pbEncode, szSaveBestSymcap, cbEncode);
    }

exit:
    if (! pbEncode) 
    {
        // Hey, there should ALWAYS be at least RC2 (40 bit).  What happened?
        AssertSz(cbEncode, "MimeOleSMimeCapGetEncAlg gave us no encoding algorithm");

        // Try to fix it up as best you can.  Stick in the RC2 value.
        cbEncode = cbRC2_40_ALGORITHM_ID;
        if (MemAlloc((LPVOID *)&pbEncode, cbEncode)) 
        {
            memcpy(pbEncode, (LPBYTE)c_RC2_40_ALGORITHM_ID, cbEncode);
            hr = S_OK;
        }
    }
    if (cbEncode && pbEncode) 
    {
        *pcbSymcap = cbEncode;
        *ppbSymcap = pbEncode;
    }
    return(hr);
}


BOOL AdvSec_GetEncryptAlgCombo(HWND hwnd, IImnAccount *pAcct)
{
    HRESULT hr;
    LPBYTE pbSymCaps = NULL;
    ULONG cbSymCaps = 0;
    
    // How big a buffer do I need?
    hr = MimeOleSMimeCapsFromDlg(hwnd,
        IDC_ALGCOMBO,          // idEncryptAlgs
        0,                     // idSignAlgs,
        0,                     // idBlob,
        NULL,
        &cbSymCaps);
    
    // Never mind the hr, it's screwy.  Do we have a size?
    if (cbSymCaps)
    {
        if (MemAlloc((void **)&pbSymCaps, cbSymCaps))
        {
            if (hr = MimeOleSMimeCapsFromDlg(hwnd,
                IDC_ALGCOMBO,          // idEncryptAlgs
                0,                     // idSignAlgs,
                0,                     // idBlob,
                pbSymCaps, &cbSymCaps))
            {
                DOUTL(1024, "MimeOleSMimeCapsFromDlg -> %x", hr);
            }
            else
            {
                LPBYTE pbBestSymcaps = NULL;
                ULONG cbBestSymcaps = 0;
                
                // Compare symcaps to highest available.
                if (SUCCEEDED(HrGetHighestSymcaps(&pbBestSymcaps, &cbBestSymcaps)) &&
                    (cbBestSymcaps == cbSymCaps && (0 == memcmp(pbBestSymcaps, pbSymCaps, cbBestSymcaps)))) {
                    // Best available symcaps.  Set it to default value of NULL (which should delete the prop.)
                    SafeMemFree(pbSymCaps);
                    cbSymCaps = 0;
                    pbSymCaps = NULL;
                }
                SafeMemFree(pbBestSymcaps);
                
                pAcct->SetProp(AP_SMTP_ENCRYPT_ALGTH, pbSymCaps, cbSymCaps);
            }
        }
        else
        {
            DOUTL(1024, "MemAlloc of SymCaps blob failed");
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        DOUTL(1024, "BAD NEWS: First MimeOleSMimeCapsFromDlg didn't return size", hr);
        Assert(hr);     // Weird, maybe there isn't a symcaps?
        hr = E_FAIL;
    }
    
    SafeMemFree(pbSymCaps);
    
    return(SUCCEEDED(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\ipropobj.cpp ===
// --------------------------------------------------------------------------------
// IPropObj.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "ipropobj.h"
#include "propcryp.h"
#include "pstore.h"
#include "dllmain.h"
#include "qstrcmpi.h"
#include "demand.h"

// -----------------------------------------------------------------------------
// Prototypes
// -----------------------------------------------------------------------------
HRESULT PropUtil_HrValidatePropInfo(LPPROPINFO prgPropInfo, ULONG cProperties);
BOOL    PropUtil_FIsValidPropTagType(DWORD dwPropTag);
HRESULT PropUtil_HrDupPropInfoArray(LPCPROPINFO prgPropInfoSrc, ULONG cPropsSrc, LPPSETINFO pPsetInfo);
VOID    PropUtil_FreePropValueArrayItems(LPPROPVALUE prgPropValue, ULONG cProperties);
VOID    PropUtil_FreeVariant(DWORD dwPropTag, LPXVARIANT pVariant, DWORD cbValue);
VOID    PropUtil_FreePropInfoArrayItems(LPPROPINFO prgPropInfo, ULONG cProperties);
HRESULT PropUtil_HrCopyVariant(DWORD dwPropTag, LPCXVARIANT pVariantSrc, DWORD cbSrc, LPXVARIANT pVariantDest, DWORD *pcbDest);
HRESULT PropUtil_HrBinaryFromVariant(DWORD dwPropTag, LPXVARIANT pVariant, DWORD cbValue, LPBYTE pb, DWORD *pcb);

// -----------------------------------------------------------------------------
// HrCreatePropertyContainer
// -----------------------------------------------------------------------------
HRESULT HrCreatePropertyContainer(CPropertySet *pPropertySet, CPropertyContainer **ppPropertyContainer)
{
    // Locals
    HRESULT                 hr=S_OK;
    CPropertyContainer     *pPropertyContainer=NULL;

    // check params
    Assert(pPropertySet != NULL);
	Assert(ppPropertyContainer != NULL);

    // Create Container
    pPropertyContainer = new CPropertyContainer();
    if (NULL == pPropertyContainer)
    {
        hr = TRAPHR(E_OUTOFMEMORY);
        goto exit;
    }

    // Init
    CHECKHR(hr = pPropertyContainer->HrInit(pPropertySet));

    // Set Container
    *ppPropertyContainer = pPropertyContainer;

exit:
    // Failed
    if (FAILED(hr))
    {
        SafeRelease(pPropertyContainer);
        *ppPropertyContainer = NULL;
    }

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::CPropertyContainer
// -----------------------------------------------------------------------------
CPropertyContainer::CPropertyContainer(void)
{
    m_cRef = 1;
    m_pPropertySet = NULL;
    m_prgPropValue = 0;
    m_cDirtyProps = 0;
    m_cProperties = 0;
    m_fLoading = FALSE;
    m_pPropCrypt = NULL;
    InitializeCriticalSection(&m_cs);
}

// -----------------------------------------------------------------------------
// CPropertyContainer::~CPropertyContainer
// -----------------------------------------------------------------------------
CPropertyContainer::~CPropertyContainer()
{
    Assert(m_cRef == 0);
    ResetContainer();
    SafeMemFree(m_prgPropValue);
    SafeRelease(m_pPropertySet);
    SafeRelease(m_pPropCrypt);
    DeleteCriticalSection(&m_cs);
}

// -----------------------------------------------------------------------------
// CPropertyContainer::QueryInterface
// -----------------------------------------------------------------------------
STDMETHODIMP CPropertyContainer::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
		(IUnknown *)this;

	// IID_IPropertyContainer
	else if (IID_IPropertyContainer == riid)
		(IPropertyContainer *)this;

    // If not null, addref it and return
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TRAPHR(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::AddRef
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropertyContainer::AddRef(VOID)
{
    return ++m_cRef;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::Release
// -----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropertyContainer::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::ResetContainer
// -----------------------------------------------------------------------------
VOID CPropertyContainer::ResetContainer(VOID)
{
    // I hope we don't have any dirty properties
#ifdef DEBUG
    if (m_cDirtyProps)
        DebugTrace("CPropertyContainer::ResetContainer - %d Dirty Properties.\n", m_cDirtyProps);
#endif

    // Crit Sect
    EnterCriticalSection(&m_cs);

    // Free prop data
    if (m_prgPropValue)
    {
        Assert(m_cProperties);
        PropUtil_FreePropValueArrayItems(m_prgPropValue, m_cProperties);
    }

    // Reset variables
    m_cDirtyProps = 0;

    // Leave Crit Sect
    LeaveCriticalSection(&m_cs);
}

// -----------------------------------------------------------------------------
// CPropertyContainer::HrEnumProps
// -----------------------------------------------------------------------------
HRESULT CPropertyContainer::HrEnumProps(CEnumProps **ppEnumProps)
{
    // Locals
    HRESULT         hr=S_OK;

    // Check Params
    Assert(ppEnumProps != NULL);

    // Allocate memory for object
    *ppEnumProps = new CEnumProps(this);
    if (*ppEnumProps == NULL)
    {
        hr = TRAPHR(E_OUTOFMEMORY);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::HrInit
// -----------------------------------------------------------------------------
HRESULT CPropertyContainer::HrInit(CPropertySet *pPropertySet)
{
    // Locals
    HRESULT         hr=S_OK;

    // Leave Crit Sect
    EnterCriticalSection(&m_cs);

	// Bad Parameter
	Assert(pPropertySet != NULL);

	// Save the property set
	m_pPropertySet = pPropertySet;
    m_pPropertySet->AddRef();

    // Do we have the property data array yet ?
    Assert(m_prgPropValue == NULL);
    Assert(m_cProperties == 0);
    CHECKHR(hr = m_pPropertySet->HrGetPropValueArray(&m_prgPropValue, &m_cProperties));
    AssertReadWritePtr(m_prgPropValue, sizeof(PROPVALUE) * m_cProperties);

exit:
    // Leave Crit Sect
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::HrEncryptProp
// -----------------------------------------------------------------------------
HRESULT CPropertyContainer::HrEncryptProp(LPBYTE pbClientData, DWORD cbClientData,
                                          LPBYTE *ppbPropData, DWORD *pcbPropData)
{
    HRESULT hr;
    BLOB    blobClient;
    BLOB    blobProp;

    // Create Encoder?
    if (NULL == m_pPropCrypt)
        CHECKHR(hr = HrCreatePropCrypt(&m_pPropCrypt));

    blobClient.pBlobData= pbClientData;
    blobClient.cbSize   = cbClientData;
    blobProp.pBlobData  = *ppbPropData;
    blobProp.cbSize     = *pcbPropData;

    if (pbClientData)
    {
        // Client has data to save

        if (!*ppbPropData)
        {
            LPSTR       szName;
            ULONG       dexAcct;

            // Build the seed name if possible
            if SUCCEEDED(m_pPropertySet->HrIndexFromPropTag(AP_ACCOUNT_NAME, &dexAcct) &&
                (TYPE_STRING == PROPTAG_TYPE(m_prgPropValue[dexAcct].dwPropTag)))
            {
                szName = (LPSTR)m_prgPropValue[dexAcct].pbValue;
            }
            else
            {
                szName = NULL;
            }

            hr = m_pPropCrypt->HrEncodeNewProp(szName, &blobClient, &blobProp);
        }
        else
        {
            hr = m_pPropCrypt->HrEncode(&blobClient, &blobProp);
        }

        // We need to (possibly) update this, regardless.  HrEncode
        // can change the data if PST is not installed
        *ppbPropData = blobProp.pBlobData;
        *pcbPropData = blobProp.cbSize;
    }
    else if (*ppbPropData)
    {
        // If we had a property, the client has no data so hose it.

        DOUTL(DOUTL_CPROP, "EncryptedProp: attempting to delete.");
        hr = m_pPropCrypt->HrDelete(&blobProp);
        if (SUCCEEDED(hr) || PST_E_ITEM_NO_EXISTS == hr)
        {
            DOUTL(DOUTL_CPROP, "EncryptedProp:  deleted.");
            hr = S_PasswordDeleted;
        }
    }
    else
    {
        hr = S_OK;
        DOUTL(DOUTL_CPROP, "EncryptedProp:  noop in EncodeProp.  no handle, no data.");
    }

exit:
    return hr;
}


// -----------------------------------------------------------------------------
// CPropertyContainer::HrDecryptProp
// -----------------------------------------------------------------------------
HRESULT CPropertyContainer::HrDecryptProp(BLOB *pIn, BLOB *pOut)
{
    // Locals
    HRESULT     hr;

    Assert(pIn && pOut);

    pOut->pBlobData = NULL;

    // Create Encryptor ?
    if (m_pPropCrypt == NULL)
        CHECKHR(hr = HrCreatePropCrypt(&m_pPropCrypt));

    // Decode it
    hr = m_pPropCrypt->HrDecode(pIn, pOut);
#ifdef DEBUG
    if (FAILED(hr))
    {
        Assert(!pOut->pBlobData);
    }
#endif

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::SetOriginalPropsToDirty
// -----------------------------------------------------------------------------
VOID CPropertyContainer::SetOriginalPropsToDirty(VOID)
{
	PROPVALUE *pProp;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Loop through properties
	pProp = m_prgPropValue;
    for (ULONG i=0; i<m_cProperties; i++)
    {
        // If property was set during load and its not already dirty
        if ((pProp->dwValueFlags & PV_SetOnLoad) && !(pProp->dwValueFlags & PV_WriteDirty))
        {
            m_cDirtyProps++;
            pProp->dwValueFlags |= PV_WriteDirty;
            Assert(m_cDirtyProps <= m_cProperties);
        }

		pProp++;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// -----------------------------------------------------------------------------
// CPropertyContainer::FIsBeingLoaded
// -----------------------------------------------------------------------------
BOOL CPropertyContainer::FIsBeingLoaded(VOID)
{
    return m_fLoading;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::EnterLoadContainer
// -----------------------------------------------------------------------------
VOID CPropertyContainer::EnterLoadContainer(VOID)
{
    Assert(m_fLoading == FALSE);
    m_fLoading = TRUE;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::LeaveLoadContainer
// -----------------------------------------------------------------------------
VOID CPropertyContainer::LeaveLoadContainer(VOID)
{
    Assert(m_fLoading == TRUE);
    m_fLoading = FALSE;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::FIsDirty
// -----------------------------------------------------------------------------
BOOL CPropertyContainer::FIsDirty(VOID)
{
    return m_cDirtyProps ? TRUE : FALSE;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::HrIsPropDirty
// -----------------------------------------------------------------------------
HRESULT CPropertyContainer::HrIsPropDirty(DWORD dwPropTag, BOOL *pfDirty)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;

	Assert(pfDirty != NULL);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Bad Parameter
	Assert(m_pPropertySet != NULL);
	Assert(m_prgPropValue != NULL);
	Assert(dwPropTag != 0);

    // Get Propety Index
    CHECKHR(hr = m_pPropertySet->HrIndexFromPropTag(dwPropTag, &i));

    // check proptags
    Assert(dwPropTag == m_prgPropValue[i].dwPropTag);

    // If property has not be set, get its default from the property set
    *pfDirty = (m_prgPropValue[i].dwValueFlags & PV_WriteDirty);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::HrSetAllPropsDirty
// -----------------------------------------------------------------------------
HRESULT CPropertyContainer::HrSetAllPropsDirty(BOOL fDirty)
{
    // Locals
	PROPVALUE		*pProp;
    HRESULT         hr=S_OK;
    ULONG           i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Verify container
	Assert(m_pPropertySet != NULL);
	Assert(m_prgPropValue != NULL);

    // Assume no dirty props
    m_cDirtyProps = fDirty ? m_cDirtyProps : 0;

    // Loop throug properties
	pProp = m_prgPropValue;
    if (fDirty)
    {
        for (i=0; i<m_cProperties; i++)
		{
            pProp->dwValueFlags |= PV_WriteDirty;
			pProp++;
		}
    }

    // Remove write dirty flags
    else
    {
        for (i=0; i<m_cProperties; i++)
		{
			pProp->dwValueFlags &= ~(pProp->dwValueFlags & PV_WriteDirty);
			pProp++;
		}
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::HrSetPropDirty
// -----------------------------------------------------------------------------
HRESULT CPropertyContainer::HrSetPropDirty(DWORD dwPropTag, BOOL fDirty)
{
    // Locals
	PROPVALUE		*pProp;
    HRESULT         hr=S_OK;
    ULONG           i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Verify container
    Assert(m_pPropertySet != NULL);
	Assert(m_prgPropValue != NULL);
	Assert(dwPropTag != 0);

    // Get Propety Index
    CHECKHR(hr = m_pPropertySet->HrIndexFromPropTag(dwPropTag, &i));

    // check proptags
    Assert(dwPropTag == m_prgPropValue[i].dwPropTag);

	pProp = &m_prgPropValue[i];

    // Decrement dirty ?
    if ((pProp->dwValueFlags & PV_WriteDirty) && !fDirty)
    {
        Assert(m_cDirtyProps > 0);
        m_cDirtyProps--;
    }

    // Otherwise, increment dirty
    else if (!(pProp->dwValueFlags & PV_WriteDirty) && fDirty)
    {
        m_cDirtyProps++;
        Assert(m_cDirtyProps <= m_cProperties);
    }

    // Clear dirty flag
    if (fDirty)
        pProp->dwValueFlags |= PV_WriteDirty;
    else
        pProp->dwValueFlags &= ~(pProp->dwValueFlags & PV_WriteDirty);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::HrGetPropInfo
// -----------------------------------------------------------------------------
HRESULT CPropertyContainer::HrGetPropInfo(DWORD dwPropTag, LPPROPINFO pPropInfo)
{
    // No property set
    Assert(m_pPropertySet != NULL);
	Assert(pPropInfo != NULL);

    // Go through the property set
    return m_pPropertySet->HrGetPropInfo(dwPropTag, pPropInfo);
}

// -----------------------------------------------------------------------------
// CPropertyContainer::HrGetPropInfo
// -----------------------------------------------------------------------------
HRESULT CPropertyContainer::HrGetPropInfo(LPTSTR pszName, LPPROPINFO pPropInfo)
{
    // No property set
	Assert(m_pPropertySet != NULL);
	Assert(pPropInfo != NULL);
	Assert(pszName != NULL);

    // Go through the property set
    return m_pPropertySet->HrGetPropInfo(pszName, pPropInfo);
}

// -----------------------------------------------------------------------------
// CPropertyContainer::GetPropDw
// -----------------------------------------------------------------------------
STDMETHODIMP CPropertyContainer::GetPropDw(DWORD dwPropTag, DWORD *pdw)
{
    ULONG cb = sizeof(DWORD);
    return GetProp(dwPropTag, (LPBYTE)pdw, &cb);
}

// -----------------------------------------------------------------------------
// CPropertyContainer::GetPropSz
// -----------------------------------------------------------------------------
STDMETHODIMP CPropertyContainer::GetPropSz(DWORD dwPropTag, LPSTR psz, ULONG cchMax)
{
    return GetProp(dwPropTag, (LPBYTE)psz, &cchMax);
}

// -----------------------------------------------------------------------------
// CPropertyContainer::HrGetProp (BYTE)
// -----------------------------------------------------------------------------
STDMETHODIMP CPropertyContainer::GetProp(DWORD dwPropTag, LPBYTE pb, ULONG *pcb)
{
    // Locals
	PROPVALUE		*pProp;
    HRESULT         hr=S_OK;
    ULONG           i;
    PROPINFO        rPropInfo;
    PROPTYPE        PropType;
    DWORD           cbStream;
    LPBYTE          pbDefault=NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check params
    Assert(pcb);
    Assert(m_pPropertySet && m_prgPropValue && dwPropTag);

    // Get Propety Index
    CHECKHR(hr = m_pPropertySet->HrIndexFromPropTag(dwPropTag, &i));

    // check proptags
    Assert(dwPropTag == m_prgPropValue[i].dwPropTag);

	pProp = &m_prgPropValue[i];

    // If property has not be set, get its default from the property set
    if (!(pProp->dwValueFlags & PV_ValueSet))
    {
        // Locals
        BYTE    rgbDefault[512];
        LPBYTE  pb=NULL;
        ULONG   cb;

        // Should not every be dirty at this point
        Assert(!(pProp->dwValueFlags & PV_WriteDirty));

        // If no default, then bail out
        if (!(pProp->dwPropFlags & PF_DEFAULT))
        {
            hr = E_NoPropData;
            goto exit;
        }

        // Get propinfo item
        CHECKHR(hr = m_pPropertySet->HrGetPropInfo(dwPropTag, &rPropInfo));

        // Do we need to allocate a local buffer
        if (rPropInfo.Default.cbValue > sizeof (rgbDefault))
        {
            // Allocate memory
            CHECKHR(hr = HrAlloc((LPVOID *)&pbDefault, rPropInfo.Default.cbValue));

            // Set local default buff
            pb = pbDefault;
            cb = rPropInfo.Default.cbValue;
        }

        // Cool, I can use a local buffer and not allocate memory
        else
        {
            pb = rgbDefault;
            cb = sizeof(rgbDefault);
        }

#ifdef DEBUG
        ULONG cDirty;
        cDirty = m_cDirtyProps;
#endif

        // Get the size of the default value
        CHECKHR(hr = PropUtil_HrBinaryFromVariant(rPropInfo.dwPropTag, &rPropInfo.Default.Variant,
                                                  rPropInfo.Default.cbValue, pb, &cb));

        // Set the property
        CHECKHR(hr = SetProp(dwPropTag, pb, cb));

        // This does not cause the propety to be dirty
        pProp->dwValueFlags &= ~(pProp->dwValueFlags & PV_WriteDirty);

        // Decrement dirty props since I don't really consider this dirty since it is only using the default value
        Assert(m_cDirtyProps > 0);
        m_cDirtyProps--;

        // Using Default
        pProp->dwValueFlags |= PV_UsingDefault;

        // The number of dirty properties should not have increased
        Assert(cDirty == m_cDirtyProps);
    }

    // Get Prop Type
    AssertSz(pProp->dwValueFlags & PV_ValueSet, "Fetching Uninitialized properties from container");

    // Get Property Type
    PropType = PROPTAG_TYPE(dwPropTag);

#ifdef DEBUG
    if (pProp->pbValue == NULL)
        Assert(pProp->cbValue == 0);
    if (pProp->cbValue == 0)
        Assert(pProp->pbValue == NULL);
#endif

    if (pProp->pbValue == NULL || pProp->cbValue == 0)
    {
        if (pProp->dwPropFlags & PF_ENCRYPTED)
            {
            // if the acct settings haven't been committed yet, then pbValue and cbValue are NULL
            // for new accts, but the value is actually set, so let's give it a chance to handle
            // that case
            hr = GetEncryptedProp(pProp, pb, pcb);
            }
        else
            {
            hr = E_NoPropData;
            }

        goto exit;
    }

    if (pProp->dwPropFlags & PF_ENCRYPTED)
        GetEncryptedProp(pProp, pb, pcb);
    else
    {
        // Just want the size ?
        if (pb == NULL)
        {
            *pcb = pProp->cbValue;
            goto exit;
        }

        // Is it big enough
        if (pProp->cbValue > *pcb)
        {
            Assert(FALSE);
            hr = TRAPHR(E_BufferTooSmall);
            goto exit;
        }

        // Check Buffer
        AssertWritePtr(pb, pProp->cbValue);

        // Set outbound size
        *pcb = pProp->cbValue;

        // Copy Data from stream
        if (TYPE_STREAM == PropType)
        {
            Assert(pProp->Variant.Lpstream);
            CHECKHR(hr = HrCopyStreamToByte(pProp->Variant.Lpstream, pb, &cbStream));
            Assert(cbStream == *pcb);
        }

        // Otherwise, simple copy
        else
        {
            AssertReadPtr(pProp->pbValue, pProp->cbValue);
            CopyMemory(pb, pProp->pbValue, pProp->cbValue);
        }
    }

exit:
    // Cleanup
    SafeMemFree(pbDefault);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::GetEncryptedProp
// -----------------------------------------------------------------------------
HRESULT CPropertyContainer::GetEncryptedProp(PROPVALUE *ppv, LPBYTE pb, ULONG *pcb)
{
    HRESULT hr = S_OK;
    BLOB    blobCleartext;
    BLOB    blobName;
    BYTE    *pbData = NULL;
    ULONG   cbData;

    Assert(ppv != NULL);

    if (TYPE_PASS != PROPTAG_TYPE(ppv->dwPropTag))
        return E_FAIL;

    if (!!(ppv->dwValueFlags & PV_WriteDirty))
        {
        Assert(ppv->Variant.pPass != NULL);

        cbData = ppv->Variant.pPass->blobPassword.cbSize;
        
        if (pb == NULL)
            {
            *pcb = cbData;
            return(S_OK);
            }

        // Is it big enough
        if (cbData > *pcb)
            {
            Assert(FALSE);
            return(E_BufferTooSmall);
            }

        if (cbData > 0)
            CopyMemory(pb, ppv->Variant.pPass->blobPassword.pBlobData, cbData);
        else if (*pcb > 0)
            *pb = 0;
        *pcb = cbData;

        return(S_OK);
        }

    Assert(ppv->pbValue != NULL);

    blobName.pBlobData = ppv->pbValue;
    blobName.cbSize = ppv->cbValue;
    if (FAILED(HrDecryptProp(&blobName, &blobCleartext)))
        {
        hr = E_NoPropData;
        goto exit;
        }

    // Just want the size ?
    if (pb == NULL)
    {
        *pcb = blobCleartext.cbSize;
        goto exit;
    }

    // Is it big enough
    if (blobCleartext.cbSize > *pcb)
    {
        Assert(FALSE);
        hr = TRAPHR(E_BufferTooSmall);
        goto exit;
    }

    // Check Buffer
    AssertWritePtr(pb, blobCleartext.cbSize);

    // Set outbound size
    *pcb = blobCleartext.cbSize;

    if (blobCleartext.pBlobData)
    {
        Assert(blobCleartext.cbSize);
        DOUTL(DOUTL_CPROP, "EncryptedProp:  requested (tag: %lx)", ppv->dwPropTag);
        // change the dout level to be a little random so I don't spew peoples passwords as easily
        DOUTL(DOUTL_CPROP|2048, "EncryptedProp:  data is \"%s\"", (LPSTR)blobCleartext.pBlobData);
        AssertReadPtr(blobCleartext.pBlobData, blobCleartext.cbSize);
        CopyMemory(pb, blobCleartext.pBlobData, blobCleartext.cbSize);
    }
#ifdef DEBUG
    else
    {
        DOUTL(DOUTL_CPROP, "EncryptedProp:  requested (tag: %lx) -- NULL (hr = %lx)", ppv->dwPropTag, hr);
    }
#endif

exit:
    if (blobCleartext.pBlobData)
        CoTaskMemFree(blobCleartext.pBlobData);
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::SetProp (DWORD)
// -----------------------------------------------------------------------------
STDMETHODIMP CPropertyContainer::SetPropDw(DWORD dwPropTag, DWORD dw)
{
    return SetProp(dwPropTag, (LPBYTE)&dw, sizeof(DWORD));
}

// -----------------------------------------------------------------------------
// CPropertyContainer::SetPropSz (SBCS/DBCS)
// -----------------------------------------------------------------------------
STDMETHODIMP CPropertyContainer::SetPropSz(DWORD dwPropTag, LPSTR psz)
{
    return SetProp(dwPropTag, (LPBYTE)psz, lstrlen(psz)+1);
}

// -----------------------------------------------------------------------------
// CPropertyContainer::SetProp (BYTE)
// -----------------------------------------------------------------------------
STDMETHODIMP CPropertyContainer::SetProp(DWORD dwPropTag, LPBYTE pb, ULONG cb)
{
    // Locals
	PROPVALUE		*pProp;
    HRESULT         hr=S_OK;
    ULONG           i;
    PROPTYPE        PropType;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // check params
    Assert(m_pPropertySet && m_prgPropValue && dwPropTag);

#ifdef ATHENA_RTM_RELEASE
#error This migration code should be removed (t-erikne)
#else
    if (dwPropTag == PROPTAG(TYPE_STRING, AP_FIRST+102) || // old IMAP pass
        dwPropTag == PROPTAG(TYPE_STRING, AP_FIRST+202) || // old LDAP pass
        dwPropTag == PROPTAG(TYPE_STRING, AP_FIRST+302) || // old NNTP pass
        dwPropTag == PROPTAG(TYPE_STRING, AP_FIRST+402) || // old POP3 pass
        dwPropTag == PROPTAG(TYPE_STRING, AP_FIRST+502))   // old SMTP pass
        {
        dwPropTag = PROPTAG(TYPE_PASS, PROPTAG_ID(dwPropTag));
        }
#endif

    // Get Propety Index
    CHECKHR(hr = m_pPropertySet->HrIndexFromPropTag(dwPropTag, &i));

    // check proptags
    Assert(dwPropTag == m_prgPropValue[i].dwPropTag);
    PropType = PROPTAG_TYPE(dwPropTag);
	pProp = &m_prgPropValue[i];

    // DEBUG validate string null terminated
#ifdef DEBUG
    if (pb && (PropType == TYPE_STRING || PropType == TYPE_WSTRING))
        AssertSz(pb[cb-1] == '\0', "String is not null terminated - I suspect a Page Fault is eminent.");
#endif

    // Validate data minmax
    CHECKHR(hr = HrValidateSetProp(PropType, pProp, pb, cb, &pProp->rMinMax));

    //N too many special cases.. own fn?
    //N besides, doesn't this make things out of sync in failure cases?
    if (TYPE_PASS != PropType)
        // Assume data is not set
        pProp->cbValue = 0;

    // Handle data type
    switch(PropType)
    {
    // ----------------------------------------------------------------
    case TYPE_BOOL:
        pProp->pbValue = (LPBYTE)&pProp->Variant.Bool;
        break;

    // ----------------------------------------------------------------
    case TYPE_FLAGS:
        pProp->pbValue = (LPBYTE)&pProp->Variant.Flags;
        break;

    // ----------------------------------------------------------------
    case TYPE_DWORD:
        pProp->pbValue = (LPBYTE)&pProp->Variant.Dword;
        break;

    // ----------------------------------------------------------------
    case TYPE_LONG:
        pProp->pbValue = (LPBYTE)&pProp->Variant.Long;
        break;

    // ----------------------------------------------------------------
    case TYPE_WORD:
        pProp->pbValue = (LPBYTE)&pProp->Variant.Word;
        break;

    // ----------------------------------------------------------------
    case TYPE_SHORT:
        pProp->pbValue = (LPBYTE)&pProp->Variant.Short;
        break;

    // ----------------------------------------------------------------
    case TYPE_BYTE:
        pProp->pbValue = (LPBYTE)&pProp->Variant.Byte;
        break;

    // ----------------------------------------------------------------
    case TYPE_CHAR:
        pProp->pbValue = (LPBYTE)&pProp->Variant.Char;
        break;

    // ----------------------------------------------------------------
    case TYPE_FILETIME:
        pProp->pbValue = (LPBYTE)&pProp->Variant.Filetime;
        break;

    // ----------------------------------------------------------------
    case TYPE_ULARGEINTEGER:
        pProp->pbValue = (LPBYTE)&pProp->Variant.uhVal;
        break;

    // ----------------------------------------------------------------
    case TYPE_STRING:
        CHECKHR(hr = HrGrowDynamicProperty(cb, &pProp->cbAllocated, (LPBYTE *)&pProp->Variant.Lpstring, sizeof(BYTE)));
        pProp->pbValue = (LPBYTE)pProp->Variant.Lpstring;
        break;

    // ----------------------------------------------------------------
    case TYPE_WSTRING:
        CHECKHR(hr = HrGrowDynamicProperty(cb, &pProp->cbAllocated, (LPBYTE *)&pProp->Variant.Lpwstring, sizeof(WCHAR)));
        pProp->pbValue = (LPBYTE)pProp->Variant.Lpwstring;
        break;

    // ----------------------------------------------------------------
    case TYPE_BINARY:
        CHECKHR(hr = HrGrowDynamicProperty(cb, &pProp->cbAllocated, (LPBYTE *)&pProp->Variant.Lpbyte, sizeof(BYTE)));
        pProp->pbValue = (LPBYTE)pProp->Variant.Lpbyte;
        break;

    // ----------------------------------------------------------------
    case TYPE_STREAM:
        SafeRelease(pProp->Variant.Lpstream);
        break;

    // ----------------------------------------------------------------
    case TYPE_PASS:
        if (!pProp->Variant.pPass)
        {
            CHECKHR(hr = HrAlloc((LPVOID *)&pProp->Variant.pPass, sizeof(PROPPASS)));
            ZeroMemory(pProp->Variant.pPass, sizeof(PROPPASS));
            DOUTL(DOUTL_CPROP, "EncryptedProp:  created (tag: %lx) -- %lx", dwPropTag, pProp->Variant.pPass);
        }

        // if this case changes, look at the special casing for TYPE_PASS done below
        if (FIsBeingLoaded())
        {
            // if this set is done during a load, the caller must be setting
            // the registry -- that's all he has

            CHECKHR(hr = HrGrowDynamicProperty(cb, &pProp->cbAllocated,
                &pProp->Variant.pPass->pbRegData, sizeof(BYTE)));
            pProp->pbValue = pProp->Variant.pPass->pbRegData;
            DOUTL(DOUTL_CPROP, "EncryptedProp:  regdata set (tag: %lx) (%d bytes, %c%c%c)", dwPropTag, cb,
                LPWSTR(pb)[2], LPWSTR(pb)[3], LPWSTR(pb)[4]);

        }
        else
        {
            // the data incoming is the password -- that's all he knows about

            if (pb && cb)
            {
                CHECKHR(hr = HrRealloc((LPVOID *)&pProp->Variant.pPass->blobPassword.pBlobData, cb));
                AssertWritePtr(pProp->Variant.pPass->blobPassword.pBlobData, cb);
                CopyMemory(pProp->Variant.pPass->blobPassword.pBlobData, pb, cb);
            }
            else
            {
                // why doesn't our realloc take 0 for a size?!?!!
                SafeMemFree(pProp->Variant.pPass->blobPassword.pBlobData);
            }
            pProp->Variant.pPass->blobPassword.cbSize = cb;
            DOUTL(DOUTL_CPROP, "EncryptedProp:  value set (tag: %lx) (%d bytes)", dwPropTag, cb);
        }
        break;

    // ----------------------------------------------------------------
    default:
        AssertSz(FALSE, "Hmmm, bad property type, this should have failed earlier.");
        hr = TRAPHR(E_BadPropType);
        goto exit;
    }

    // Property Set
    pProp->dwValueFlags |= PV_ValueSet;

    // Not using default
    pProp->dwValueFlags &= ~PV_UsingDefault;

    if (TYPE_PASS != PropType || FIsBeingLoaded())
    {
        // Set data size
        pProp->cbValue = cb;

        // Copy Data from stream
        if (pb)
        {
            if (TYPE_STREAM == PropType)
            {
                CHECKHR(hr = HrByteToStream(&pProp->Variant.Lpstream, pb, cb));
            }

            // Otherwise, just copy
            else
            {
                AssertWritePtr(pProp->pbValue, cb);
                CopyMemory(pProp->pbValue, pb, cb);
            }
        }
        else
            pProp->pbValue = NULL;
    }

    if (FIsBeingLoaded())
        // If loading container, set the flag
        pProp->dwValueFlags |= PV_SetOnLoad;

    // Otherwise, Its dirty
    else if (!(pProp->dwValueFlags & PV_WriteDirty))
    {
        pProp->dwValueFlags |= PV_WriteDirty;
        m_cDirtyProps++;
        Assert(m_cDirtyProps <= m_cProperties);
    }


exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertyContainer::HrGrowDynamicProperty
// -----------------------------------------------------------------------------
HRESULT CPropertyContainer::HrGrowDynamicProperty(DWORD cbNewSize, DWORD *pcbAllocated, LPBYTE *ppbData, DWORD dwUnitSize)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cb;

    // Check Params
    Assert(pcbAllocated && ppbData);

    // Do we need to re allocate ?
    if (cbNewSize > *pcbAllocated)
    {
        // Grow the buffer

        //N what about the following alloc code:
        // if (*pcbAllocated)
        //     *pcbAllocated = (cbNewSize + 256);
        // else
        //     *pcbAllocated = cbNewSize;
        // it would work better for passwords, I think

        *pcbAllocated = (cbNewSize + 256);

        // Compute number of bytes to allocate
        cb = (*pcbAllocated) * dwUnitSize;

        // Allocate some memory
        CHECKHR(hr = HrRealloc((LPVOID *)ppbData, cb));
    }

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertySet::CPropertySet
// -----------------------------------------------------------------------------
HRESULT CPropertyContainer::HrValidateSetProp(PROPTYPE PropType, LPPROPVALUE pPropValue, LPBYTE pb, ULONG cb, LPMINMAX pMinMax)
{
    // Locals
    HRESULT             hr=S_OK;
    XVARIANT            Variant;

    // Check Params
    Assert(pPropValue && pMinMax);

    // Validate min max
#ifdef DEBUG
    if (pPropValue->dwPropFlags & PF_MINMAX)
        Assert(pMinMax->dwMin < pMinMax->dwMax);
#endif

    if (pb == NULL && cb == 0)
        return(S_OK);

    //N this array of Copymemories is not needed
    //N with some casts and memcmps, the same end
    //N could be achieved.

    // Handle data type
    switch(PropType)
    {
    // ----------------------------------------------------------------
    case TYPE_BOOL:
        Assert(pb && cb);
        if (cb != sizeof(DWORD))
        {
            hr = TRAPHR(E_BufferSizeMismatch);
            goto exit;
        }
        Assert(!(pPropValue->dwPropFlags & PF_MINMAX));
        CopyMemory(&Variant.Bool, pb, cb);
        if (Variant.Bool != 0 && Variant.Bool != 1)
            hr = TRAPHR(E_InvalidBooleanValue);
        break;

    // ----------------------------------------------------------------
    case TYPE_FLAGS:
        Assert(pb && cb);
        if (cb != sizeof(DWORD))
        {
            hr = TRAPHR(E_BufferSizeMismatch);
            goto exit;
        }
        if (pPropValue->dwPropFlags & PF_MINMAX)
        {
            CopyMemory(&Variant.Flags, pb, cb);
            if (Variant.Flags < (DWORD)pMinMax->dwMin || Variant.Flags > (DWORD)pMinMax->dwMax)
                hr = TRAPHR(E_InvalidMinMaxValue);
        }
        break;

    // ----------------------------------------------------------------
    case TYPE_DWORD:
        Assert(pb && cb);
        if (cb != sizeof(DWORD))
        {
            hr = TRAPHR(E_BufferSizeMismatch);
            goto exit;
        }
        if (pPropValue->dwPropFlags & PF_MINMAX)
        {
            CopyMemory(&Variant.Dword, pb, cb);
            if (Variant.Dword < (DWORD)pMinMax->dwMin || Variant.Dword > (DWORD)pMinMax->dwMax)
                hr = TRAPHR(E_InvalidMinMaxValue);
        }
        break;

    // ----------------------------------------------------------------
    case TYPE_LONG:
        Assert(pb && cb);
        if (cb != sizeof(LONG))
        {
            hr = TRAPHR(E_BufferSizeMismatch);
            goto exit;
        }
        if (pPropValue->dwPropFlags & PF_MINMAX)
        {
            CopyMemory(&Variant.Long, pb, cb);
            if (Variant.Long < (LONG)pMinMax->dwMin || Variant.Long > (LONG)pMinMax->dwMax)
                hr = TRAPHR(E_InvalidMinMaxValue);
        }
        break;

    // ----------------------------------------------------------------
    case TYPE_WORD:
        Assert(pb && cb);
        if (cb != sizeof(WORD))
        {
            hr = TRAPHR(E_BufferSizeMismatch);
            goto exit;
        }
        if (pPropValue->dwPropFlags & PF_MINMAX)
        {
            CopyMemory(&Variant.Word, pb, cb);
            if (Variant.Word < (WORD)pMinMax->dwMin || Variant.Word > (WORD)pMinMax->dwMax)
                hr = TRAPHR(E_InvalidMinMaxValue);
        }
        break;

    // ----------------------------------------------------------------
    case TYPE_SHORT:
        Assert(pb && cb);
        if (cb != sizeof(SHORT))
        {
            hr = TRAPHR(E_BufferSizeMismatch);
            goto exit;
        }
        if (pPropValue->dwPropFlags & PF_MINMAX)
        {
            CopyMemory(&Variant.Short, pb, cb);
            if (Variant.Short < (SHORT)pMinMax->dwMin || Variant.Short > (SHORT)pMinMax->dwMax)
                hr = TRAPHR(E_InvalidMinMaxValue);
        }
        break;

    // ----------------------------------------------------------------
    case TYPE_BYTE:
        Assert(pb && cb);
        if (cb != sizeof(BYTE))
        {
            hr = TRAPHR(E_BufferSizeMismatch);
            goto exit;
        }
        if (pPropValue->dwPropFlags & PF_MINMAX)
        {
            CopyMemory(&Variant.Byte, pb, cb);
            if (Variant.Byte < (BYTE)pMinMax->dwMin || Variant.Byte > (BYTE)pMinMax->dwMax)
                hr = TRAPHR(E_InvalidMinMaxValue);
        }
        break;

    // ----------------------------------------------------------------
    case TYPE_CHAR:
        Assert(pb && cb);
        if (cb != sizeof(CHAR))
        {
            hr = TRAPHR(E_BufferSizeMismatch);
            goto exit;
        }
        if (pPropValue->dwPropFlags & PF_MINMAX)
        {
            CopyMemory(&Variant.Char, pb, cb);
            if (Variant.Char < (CHAR)pMinMax->dwMin || Variant.Char > (CHAR)pMinMax->dwMax)
                hr = TRAPHR(E_InvalidMinMaxValue);
        }
        break;

    // ----------------------------------------------------------------
    case TYPE_STRING:
    case TYPE_WSTRING:
        if (cb)
            cb--;

    case TYPE_BINARY:
    case TYPE_PASS:
        if (pPropValue->dwPropFlags & PF_MINMAX)
        {
            if (cb < pMinMax->dwMin || cb > pMinMax->dwMax)
                hr = TRAPHR(E_InvalidMinMaxValue);
        }
        break;

    // ----------------------------------------------------------------
    case TYPE_FILETIME:
    case TYPE_STREAM:
    case TYPE_ULARGEINTEGER:
        Assert(!(pPropValue->dwPropFlags & PF_MINMAX));
        break;



    // ----------------------------------------------------------------
    default:
        AssertSz(FALSE, "Hmmm, bad property type, this should have failed earlier.");
        hr = TRAPHR(E_BadPropType);
        goto exit;
    }

exit:
    // Done
    return hr;
}

HRESULT CPropertyContainer::PersistEncryptedProp(DWORD dwPropTag, BOOL  *pfPasswChanged)
{
    ULONG       dex;
    HRESULT     hr;

    if (TYPE_PASS != PROPTAG_TYPE(dwPropTag))
        return E_FAIL;

    DOUTL(DOUTL_CPROP, "EncryptedProp:  persisted...");
    CHECKHR(hr = m_pPropertySet->HrIndexFromPropTag(dwPropTag, &dex));

    // better have a property by the time we get here
    Assert(m_prgPropValue[dex].Variant.pPass);

    Assert(pfPasswChanged);

    // [shaheedp] QFE for OUTLOOK. Refer to Bug# 82393 in IE database.
    // This is originally a hack we put in for Bug# 66724. For bug# 88393, we are just
    // refining the hack. Refer to the mail attached to the bug# 82393.
    if ((m_prgPropValue[dex].Variant.pPass->blobPassword.pBlobData) && (*m_prgPropValue[dex].Variant.pPass->blobPassword.pBlobData))
        *pfPasswChanged = TRUE;

    hr = HrEncryptProp(
        m_prgPropValue[dex].Variant.pPass->blobPassword.pBlobData,
        m_prgPropValue[dex].Variant.pPass->blobPassword.cbSize,
        &m_prgPropValue[dex].Variant.pPass->pbRegData,
        &m_prgPropValue[dex].cbValue);
    m_prgPropValue[dex].pbValue = m_prgPropValue[dex].Variant.pPass->pbRegData;

exit:
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertySet::CPropertySet
// -----------------------------------------------------------------------------
CPropertySet::CPropertySet()
{
    m_cRef = 1;
    m_cProperties = 0;
    m_ulPropIdMin = 0;
    m_ulPropIdMax = 0;
    m_fInit = FALSE;
    m_prgPropInfo = NULL;
    m_prgPropValue = NULL;
    m_rgpInfo = NULL;
    m_cpInfo = 0;
    InitializeCriticalSection(&m_cs);
}

// -----------------------------------------------------------------------------
// CPropertySet::~CPropertySet
// -----------------------------------------------------------------------------
CPropertySet::~CPropertySet()
{
    Assert(m_cRef == 0);
    ResetPropertySet();
    DeleteCriticalSection(&m_cs);
}

// -----------------------------------------------------------------------------
// CPropertySet::AddRef
// -----------------------------------------------------------------------------
ULONG CPropertySet::AddRef(VOID)
{
    return ++m_cRef;
}

// -----------------------------------------------------------------------------
// CPropertySet::Release
// -----------------------------------------------------------------------------
ULONG CPropertySet::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// -----------------------------------------------------------------------------
// CPropertySet::ResetPropertySet
// -----------------------------------------------------------------------------
VOID CPropertySet::ResetPropertySet(VOID)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Free prgPropValue array
    if (m_prgPropValue)
    {
        PropUtil_FreePropValueArrayItems(m_prgPropValue, m_cProperties);
        SafeMemFree(m_prgPropValue);
    }

    // Free prgPropInfo array
    if (m_prgPropInfo)
    {
        PropUtil_FreePropInfoArrayItems(m_prgPropInfo, m_cProperties);
        SafeMemFree(m_prgPropInfo);
    }

    if (m_rgpInfo != NULL)
        {
        MemFree(m_rgpInfo);
        m_rgpInfo = NULL;
        }

    // Reset the rest of the properset information
    m_cProperties = 0;
    m_ulPropIdMin = 0;
    m_ulPropIdMax = 0;
    m_cpInfo = 0;
    m_fInit = FALSE;

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// -----------------------------------------------------------------------------
// CPropertySet::HrInit
// -----------------------------------------------------------------------------
HRESULT CPropertySet::HrInit(LPCPROPINFO prgPropInfo, ULONG cProperties)
{
    // Locals
    HRESULT         hr = S_OK;
    PSETINFO        rPsetInfo;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check Params
    Assert(prgPropInfo && cProperties);
    AssertReadPtr(prgPropInfo, sizeof(PROPINFO) * cProperties);

    // free current data
    ResetPropertySet();

    // Duplicate and sort the propinfo array
    CHECKHR(hr = PropUtil_HrDupPropInfoArray(prgPropInfo, cProperties, &rPsetInfo));

    // Copy PsetInfo Items
    m_prgPropInfo = rPsetInfo.prgPropInfo;
    m_cProperties = rPsetInfo.cProperties;
    m_ulPropIdMin = rPsetInfo.ulPropIdMin;
    m_ulPropIdMax = rPsetInfo.ulPropIdMax;

	m_rgpInfo = rPsetInfo.rgpInfo;
	m_cpInfo = rPsetInfo.cpInfo;

    // Lets validate prgPropInfo
    CHECKHR(hr = PropUtil_HrValidatePropInfo(m_prgPropInfo, m_cProperties));

    // We are ready to go
    m_fInit = TRUE;

exit:
    // If failed, reset state
    if (FAILED(hr))
    {
        ResetPropertySet();
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertySet::HrGetPropInfo
// -----------------------------------------------------------------------------
HRESULT CPropertySet::HrGetPropInfo(LPTSTR pszName, LPPROPINFO pPropInfo)
{
    // Locals
    int                 cmp, left, right, x;
	PROPINFO            *pInfo;
    HRESULT             hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check Params
    Assert(pszName && m_fInit);
    AssertReadWritePtr(m_prgPropInfo, sizeof(PROPINFO) * m_cProperties);
    AssertWritePtr(pPropInfo, sizeof(PROPINFO));

    left = 0;
    right = m_cpInfo - 1;
    do
        {
        x = (left + right) / 2;
        pInfo = m_rgpInfo[x];
        cmp = OEMstrcmpi(pszName, pInfo->pszName);
        if (cmp == 0)
            {
            CopyMemory(pPropInfo, pInfo, sizeof(PROPINFO));
            goto exit;
            }
        else if (cmp < 0)
            right = x - 1;
        else
            left = x + 1;
        }
    while (right >= left);

    // If we make here, we failed
    hr = TRAPHR(E_PropNotFound);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertySet::HrGetPropInfo
// -----------------------------------------------------------------------------
HRESULT CPropertySet::HrGetPropInfo(DWORD dwPropTag, LPPROPINFO pPropInfo)
{
    // Locals
    HRESULT             hr = S_OK;
    ULONG               i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check Params
    Assert(dwPropTag && m_fInit);
    AssertReadWritePtr(m_prgPropInfo, sizeof(PROPINFO) * m_cProperties);
    AssertWritePtr(pPropInfo, sizeof(PROPINFO));

    // Compute array index based on proptag
    CHECKHR(hr = HrIndexFromPropTag(dwPropTag, &i));

    // Index into propinfo array
    CopyMemory(pPropInfo, &m_prgPropInfo[i], sizeof(PROPINFO));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertySet::HrGetPropValueArray
// -----------------------------------------------------------------------------
HRESULT CPropertySet::HrGetPropValueArray(LPPROPVALUE *pprgPropValue, ULONG *pcProperties)
{
    // Locals
	LPPROPINFO		pInfo;
	PROPVALUE		*pValue;
	HRESULT         hr=S_OK;
    ULONG           i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check Params
    Assert(pprgPropValue && pcProperties && m_fInit);

    // Set number of properties
    *pcProperties = m_cProperties;
    *pprgPropValue = NULL;

    // Have I created my private cached prop data array
    if (m_prgPropValue == NULL)
    {
        // Allocate it
        CHECKHR(hr = HrAlloc((LPVOID *)&m_prgPropValue, sizeof(PROPVALUE) * m_cProperties));

        // Zeroinit
        ZeroMemory(m_prgPropValue, sizeof(PROPVALUE) * m_cProperties);

        // Set Prop Tags
        AssertReadPtr(m_prgPropInfo, m_cProperties * sizeof(PROPINFO));

		pInfo = m_prgPropInfo;
		pValue = m_prgPropValue;
        for (i=0; i<m_cProperties; i++)
        {
            // Zero property tags are ok but undesireable
            if (pInfo->dwPropTag != 0)
				{
				// Property Tag
				if (FIsValidPropTag(pInfo->dwPropTag))
				{
					pValue->dwPropTag = pInfo->dwPropTag;
					pValue->dwPropFlags = pInfo->dwFlags;
					CopyMemory(&pValue->rMinMax, &pInfo->rMinMax, sizeof(MINMAX));
				}
			}

			pInfo++;
			pValue++;
        }
    }

    // Allocate outbound propdata array
    CHECKHR(hr = HrAlloc((LPVOID *)pprgPropValue, sizeof(PROPVALUE) * m_cProperties));

    // Lets valid some memory
    Assert(m_prgPropValue);
    AssertReadPtr(m_prgPropValue, m_cProperties * sizeof(PROPVALUE));
    AssertReadWritePtr(*pprgPropValue, m_cProperties * sizeof(PROPVALUE));

    // Copy Cached Prop Data Array
    CopyMemory(*pprgPropValue, m_prgPropValue, sizeof(PROPVALUE) * m_cProperties);

exit:
    // If we fail, free stuff and return
    if (FAILED(hr))
    {
        SafeMemFree((*pprgPropValue));
        *pcProperties = 0;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CPropertySet::FIsValidPropTag
// -----------------------------------------------------------------------------
BOOL CPropertySet::FIsValidPropTag(DWORD dwPropTag)
{
    // Locals
    DWORD dwPropId = PROPTAG_ID(dwPropTag);

    // If proptag is zero
    if (dwPropTag == 0)
        return FALSE;

    // Make sure prop id is in our range
    if (dwPropId < m_ulPropIdMin || dwPropId > m_ulPropIdMax)
        return FALSE;

    // Done
    return PropUtil_FIsValidPropTagType(dwPropTag);
}

// -----------------------------------------------------------------------------
// CPropertySet::HrIndexFromPropTag
// -----------------------------------------------------------------------------
HRESULT CPropertySet::HrIndexFromPropTag(DWORD dwPropTag, ULONG *pi)
{
    // Locals
    HRESULT             hr=S_OK;

    // Check Params
    Assert(pi && dwPropTag);

    // Valid Prop Tag ?
    if (!FIsValidPropTag(dwPropTag))
    {
        AssertSz(FALSE, "Invalid dwPropTag in CPropertyContainer::HrGetProp");
        hr = TRAPHR(E_InvalidPropTag);
        goto exit;
    }

    // Set index
    Assert(m_ulPropIdMin > 0 && PROPTAG_ID(dwPropTag) >= m_ulPropIdMin);
    *pi = PROPTAG_ID(dwPropTag) - m_ulPropIdMin;
    Assert(*pi < m_cProperties);

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CEnumProps::CEnumProps
// -----------------------------------------------------------------------------
CEnumProps::CEnumProps(CPropertyContainer *pPropertyContainer)
{
    Assert(pPropertyContainer);
    m_cRef = 1;
    m_iProperty = -1;
    m_pPropertyContainer = pPropertyContainer;
    if (m_pPropertyContainer)
        m_pPropertyContainer->AddRef();
}

// -----------------------------------------------------------------------------
// CEnumProps::~CEnumProps
// -----------------------------------------------------------------------------
CEnumProps::~CEnumProps()
{
    SafeRelease(m_pPropertyContainer);
}

// -----------------------------------------------------------------------------
// CEnumProps::AddRef
// -----------------------------------------------------------------------------
ULONG CEnumProps::AddRef(VOID)
{
    return ++m_cRef;
}

// -----------------------------------------------------------------------------
// CEnumProps::Release
// -----------------------------------------------------------------------------
ULONG CEnumProps::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// -----------------------------------------------------------------------------
// CEnumProps::~CEnumProps
// -----------------------------------------------------------------------------
HRESULT CEnumProps::HrGetCount(ULONG *pcItems)
{
    // Locals
    HRESULT     hr=S_OK;

    // Use Critical Section of AddRef'ed CPropertyContainer
    EnterCriticalSection(&m_pPropertyContainer->m_cs);

    // Bad Parameter
    if (pcItems == NULL || m_pPropertyContainer == NULL)
    {
        Assert(FALSE);
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Return number of properties
    *pcItems = m_pPropertyContainer->m_cProperties;

exit:
    // Use Critical Section of AddRef'ed CPropertyContainer
    LeaveCriticalSection(&m_pPropertyContainer->m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CEnumProps::HrGetNext
// -----------------------------------------------------------------------------
HRESULT CEnumProps::HrGetNext(LPPROPVALUE pPropValue, LPPROPINFO pPropInfo)
{
    // Locals
    HRESULT         hr=S_OK;

    // Bad Parameter
    if (m_pPropertyContainer == NULL)
    {
        Assert(FALSE);
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Use Critical Section of AddRef'ed CPropertyContainer
    EnterCriticalSection(&m_pPropertyContainer->m_cs);

    // We've got to skip empty propvalues
    do
    {
        // Have we reached the end ?
        //N + not needed if just do > ?
        if (m_iProperty + 1 >= (LONG)m_pPropertyContainer->m_cProperties)
        {
            hr = E_EnumFinished;
            goto exit;
        }

        // Increment m_iProperty
        m_iProperty++;

    } while(m_pPropertyContainer->m_prgPropValue[m_iProperty].dwPropTag == 0);

    // Copy propdata
    if (pPropValue)
        CopyMemory(pPropValue, &m_pPropertyContainer->m_prgPropValue[m_iProperty], sizeof(PROPVALUE));

    // propert info
    if (pPropInfo)
    {
        // Get the property info from the property set
        CHECKHR(hr = m_pPropertyContainer->m_pPropertySet->HrGetPropInfo(pPropValue->dwPropTag, pPropInfo));
    }

exit:
    // Use Critical Section of AddRef'ed CPropertyContainer
    LeaveCriticalSection(&m_pPropertyContainer->m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CEnumProps::HrGetCurrent
// -----------------------------------------------------------------------------
HRESULT CEnumProps::HrGetCurrent(LPPROPVALUE pPropValue, LPPROPINFO pPropInfo)
{
    // Locals
    HRESULT         hr=S_OK;

    // Bad Parameter
    if (m_pPropertyContainer == NULL)
    {
        Assert(FALSE);
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Use Critical Section of AddRef'ed CPropertyContainer
    EnterCriticalSection(&m_pPropertyContainer->m_cs);

    //N see other comment
    if (m_iProperty + 1 >= (LONG)m_pPropertyContainer->m_cProperties)
    {
        hr = E_EnumFinished;
        goto exit;
    }

    // Copy propdata
    if (pPropValue)
        CopyMemory(pPropValue, &m_pPropertyContainer->m_prgPropValue[m_iProperty], sizeof(PROPVALUE));

    // propert info
    if (pPropInfo)
    {
        // Get the property info from the property set
        CHECKHR(hr = m_pPropertyContainer->m_pPropertySet->HrGetPropInfo(pPropValue->dwPropTag, pPropInfo));
    }

exit:
    // Use Critical Section of AddRef'ed CPropertyContainer
    LeaveCriticalSection(&m_pPropertyContainer->m_cs);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// CEnumProps::Reset
// -----------------------------------------------------------------------------
VOID CEnumProps::Reset(VOID)
{
    m_iProperty = -1;
}

// -----------------------------------------------------------------------------
// PropUtil_FIsValidPropTagType
// -----------------------------------------------------------------------------
BOOL PropUtil_FIsValidPropTagType(DWORD dwPropTag)
{
    // Locals
    PROPTYPE PropType = PROPTAG_TYPE(dwPropTag);

    // Zero proptag
    if (dwPropTag == 0)
        return FALSE;

    // Check Data Type
    if (PropType <= TYPE_ERROR || PropType >= TYPE_LAST)
    {
        AssertSz(FALSE, "Invalid property data type.");
        return FALSE;
    }

    // Done
    return TRUE;
}

// -----------------------------------------------------------------------------
// PropUtil_FreePropValueArrayItems
// -----------------------------------------------------------------------------
VOID PropUtil_FreePropValueArrayItems(LPPROPVALUE prgPropValue, ULONG cProperties)
{
    // No array
    Assert(prgPropValue);

    // Validate memory
    AssertReadWritePtr(prgPropValue, sizeof(PROPVALUE) * cProperties);

    // Loop
    for (register ULONG i=0; i<cProperties; i++)
    {
        // No proptag, noop
        if (prgPropValue->dwPropTag != 0)
		{
			// Free variant value
			PropUtil_FreeVariant(prgPropValue->dwPropTag, &prgPropValue->Variant, prgPropValue->cbValue);

			// Zeroinit
			prgPropValue->dwValueFlags = 0;
			prgPropValue->cbAllocated = 0;
			prgPropValue->cbValue = 0;
			prgPropValue->pbValue = NULL;
		}

		prgPropValue++;
    }

    // Done
    return;
}

// -----------------------------------------------------------------------------
// PropUtil_FreeVariant
// -----------------------------------------------------------------------------
VOID PropUtil_FreeVariant(DWORD dwPropTag, LPXVARIANT pVariant, DWORD cbValue)
{
    // Locals
    PROPTYPE PropType = PROPTAG_TYPE(dwPropTag);

    // Check Params
    Assert(pVariant && dwPropTag);
    Assert(PropUtil_FIsValidPropTagType(dwPropTag));

	if (pVariant->Dword != NULL)
	{
		// Release Stream
		if (TYPE_STREAM == PropType)
		{
			if (pVariant->Lpstream)
			{
				AssertReadPtr(pVariant->Lpstream, sizeof(LPSTREAM));
				pVariant->Lpstream->Release();
			}
		}

		// String
		else if (TYPE_STRING == PropType)
		{
			if (pVariant->Lpstring)
			{
				AssertReadWritePtr(pVariant->Lpstring, cbValue);
				MemFree(pVariant->Lpstring);
			}
		}

		// Wide-String
		else if (TYPE_WSTRING == PropType)
		{
			if (pVariant->Lpwstring)
			{
				AssertReadWritePtr(pVariant->Lpwstring, cbValue);
				MemFree(pVariant->Lpwstring);
			}
		}

		// Binary
		else if (TYPE_BINARY == PropType)
		{
			if (pVariant->Lpbyte)
			{
				AssertReadWritePtr(pVariant->Lpbyte, cbValue);
				MemFree(pVariant->Lpbyte);
			}
		}

		// Password
		else if (TYPE_PASS == PropType)
		{
			if (pVariant->pPass)
			{
				DOUTL(DOUTL_CPROP, "EncryptedProp:  varient freed --  %lx", pVariant->pPass);
				AssertReadWritePtr(pVariant->pPass, sizeof(PROPPASS));
				if (pVariant->pPass->pbRegData)
				{
					AssertReadWritePtr(pVariant->pPass->pbRegData, cbValue);
					MemFree(pVariant->pPass->pbRegData);
				}
				if (pVariant->pPass->blobPassword.pBlobData)
				{
					AssertReadWritePtr(pVariant->pPass->blobPassword.pBlobData,
						pVariant->pPass->blobPassword.cbSize);
					MemFree(pVariant->pPass->blobPassword.pBlobData);
				}
				MemFree(pVariant->pPass);
			}
		}
	}

    // Reset data items so it can be re-used
    ZeroMemory(pVariant, sizeof(XVARIANT));
}

// -----------------------------------------------------------------------------
// PropUtil_FreePropInfoArrayItems
// -----------------------------------------------------------------------------
VOID PropUtil_FreePropInfoArrayItems(LPPROPINFO prgPropInfo, ULONG cProperties)
{
    // Locals
	LPPROPINFO		pInfo;
    ULONG           i;

    // Nothing to free ?
    if (prgPropInfo == NULL || cProperties == 0)
        return;

    // Check Params
    AssertReadWritePtr(prgPropInfo, sizeof(PROPINFO) * cProperties);

    // Loop
	pInfo = prgPropInfo;
    for (i=0; i<cProperties; i++)
    {
        // No prop
        if (pInfo->dwPropTag != 0)
		{
			// Free property name
			SafeMemFree(pInfo->pszName);

			// Free default value
			PropUtil_FreeVariant(pInfo->dwPropTag, &pInfo->Default.Variant, pInfo->Default.cbValue);
		}

		pInfo++;
    }

    // Zero it
    ZeroMemory(prgPropInfo, sizeof(PROPINFO) * cProperties);

    // Done
    return;
}

void qsort(PROPINFO **ppInfo, long left, long right)
    {
    long i, j;
    PROPINFO *pT, *k;

    i = left;
    j = right;
    k = ppInfo[(left + right) / 2];

    do
        {
        while (OEMstrcmpi(ppInfo[i]->pszName, k->pszName) < 0 && i < right)
            i++;
        while (OEMstrcmpi(ppInfo[j]->pszName, k->pszName) > 0 && j > left)
            j--;

        if (i <= j)
            {
            pT = ppInfo[i];
            ppInfo[i] = ppInfo[j];
            ppInfo[j] = pT;
            i++; j--;
            }
        }
    while (i <= j);

    if (left < j)
        qsort(ppInfo, left, j);
    if (i < right)
        qsort(ppInfo, i, right);
    }

// -----------------------------------------------------------------------------
// PropUtil_HrDupPropInfoArray
// -----------------------------------------------------------------------------
HRESULT PropUtil_HrDupPropInfoArray(LPCPROPINFO prgPropInfoSrc, ULONG cPropsSrc, LPPSETINFO pPsetInfo)
{
    // Locals
    LPCPROPINFO     pInfo;
	LPPROPINFO		pSet, *ppInfo;
    HRESULT         hr=S_OK;
    ULONG           i;
    ULONG           ulPropId,
                    nIndex;

    // Check Param
	Assert(cPropsSrc > 0);
	Assert(prgPropInfoSrc != NULL);
	Assert(pPsetInfo != NULL);
    AssertReadPtr(prgPropInfoSrc, sizeof(PROPINFO) * cPropsSrc);

    // Init
    ZeroMemory(pPsetInfo, sizeof(PSETINFO));

    // Lets find the min and max property ids
    pPsetInfo->ulPropIdMin = 0xffffffff;

	pInfo = prgPropInfoSrc;
    for(i=0; i<cPropsSrc; i++)
    {
        ulPropId = PROPTAG_ID(pInfo->dwPropTag);
        if (ulPropId > pPsetInfo->ulPropIdMax)
            pPsetInfo->ulPropIdMax = ulPropId;
        if (ulPropId < pPsetInfo->ulPropIdMin)
            pPsetInfo->ulPropIdMin = ulPropId;
		pInfo++;
    }

    Assert(pPsetInfo->ulPropIdMin <= pPsetInfo->ulPropIdMax);
    Assert((pPsetInfo->ulPropIdMax - pPsetInfo->ulPropIdMin) + 1 >= cPropsSrc);

    // Compute real number of properties
    pPsetInfo->cProperties = (pPsetInfo->ulPropIdMax - pPsetInfo->ulPropIdMin) + 1;

    // Allocate Dest
    CHECKHR(hr = HrAlloc((LPVOID *)&pPsetInfo->prgPropInfo, sizeof(PROPINFO) * pPsetInfo->cProperties));

    // Zero init
    ZeroMemory(pPsetInfo->prgPropInfo, sizeof(PROPINFO) * pPsetInfo->cProperties);

    CHECKHR(hr = HrAlloc((void **)&pPsetInfo->rgpInfo, sizeof(PROPINFO *) * cPropsSrc));
    pPsetInfo->cpInfo = cPropsSrc;

    // Loop through src propinfo
	pInfo = prgPropInfoSrc;
    ppInfo = pPsetInfo->rgpInfo;
    for(i=0; i<cPropsSrc; i++)
    {
        // Only if valid proptag
		Assert(PropUtil_FIsValidPropTagType(pInfo->dwPropTag));

        // Compute index into dest array in which the proptag should be
        nIndex = PROPTAG_ID(pInfo->dwPropTag) - pPsetInfo->ulPropIdMin;
		pSet = &pPsetInfo->prgPropInfo[nIndex];

        *ppInfo = pSet;

        // Duplicate ?
        Assert(pSet->dwPropTag == 0);

        // PropTag
        pSet->dwPropTag = pInfo->dwPropTag;

        // Flags
        pSet->dwFlags = pInfo->dwFlags;

        // Property Name
        pSet->pszName = PszDupA(pInfo->pszName);

        // Default Value
        if (pSet->dwFlags & PF_DEFAULT)
        {
            // Copy Default Value
            CHECKHR(hr = PropUtil_HrCopyVariant(pInfo->dwPropTag,
                                                &pInfo->Default.Variant,
                                                pInfo->Default.cbValue,
                                                &pSet->Default.Variant,
                                                &pSet->Default.cbValue));
        }

        // Copy minmax info
        CopyMemory(&pSet->rMinMax, &pInfo->rMinMax, sizeof(MINMAX));

        // Validate minmax
        //N should add code to make sure minmax struct is zeros if !PF_MINMAX, saves
        //N confusion should that ever get copied
        Assert(!!(pSet->dwFlags & PF_MINMAX) || (pSet->rMinMax.dwMax >= pSet->rMinMax.dwMin));

		pInfo++;
        ppInfo++;
    }

    qsort(pPsetInfo->rgpInfo, 0, pPsetInfo->cpInfo - 1);

exit:
    // If failed, free stuff
    if (FAILED(hr))
    {
        PropUtil_FreePropInfoArrayItems(pPsetInfo->prgPropInfo, pPsetInfo->cProperties);
        SafeMemFree(pPsetInfo->prgPropInfo);
        SafeMemFree(pPsetInfo->rgpInfo);
        ZeroMemory(pPsetInfo, sizeof(PSETINFO));
    }

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// PropUtil_HrBinaryFromVariant
// -----------------------------------------------------------------------------
HRESULT PropUtil_HrBinaryFromVariant(DWORD dwPropTag, LPXVARIANT pVariant, DWORD cbValue, LPBYTE pb, DWORD *pcb)
{
    // Locals
    HRESULT             hr=S_OK;
    PROPTYPE            PropType = PROPTAG_TYPE(dwPropTag);
    DWORD               cbStream;
    LPBYTE              pbValue=NULL;

    // Validate Parameters
    if (pVariant == NULL || pb == NULL || pcb == NULL || dwPropTag == 0)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Handle data type
    switch(PropType)
    {
    // ----------------------------------------------------------------
    case TYPE_BOOL:
        Assert(cbValue == sizeof(DWORD));
        pbValue = (LPBYTE)&pVariant->Bool;
        break;

    // ----------------------------------------------------------------
    case TYPE_FLAGS:
        Assert(cbValue == sizeof(DWORD));
        pbValue = (LPBYTE)&pVariant->Flags;
        break;

    // ----------------------------------------------------------------
    case TYPE_DWORD:
        Assert(cbValue == sizeof(DWORD));
        pbValue = (LPBYTE)&pVariant->Dword;
        break;

    // ----------------------------------------------------------------
    case TYPE_LONG:
        Assert(cbValue == sizeof(LONG));
        pbValue = (LPBYTE)&pVariant->Long;
        break;

    // ----------------------------------------------------------------
    case TYPE_WORD:
        Assert(cbValue == sizeof(WORD));
        pbValue = (LPBYTE)&pVariant->Word;
        break;

    // ----------------------------------------------------------------
    case TYPE_SHORT:
        Assert(cbValue == sizeof(SHORT));
        pbValue = (LPBYTE)&pVariant->Short;
        break;

    // ----------------------------------------------------------------
    case TYPE_BYTE:
        Assert(cbValue == sizeof(BYTE));
        pbValue = (LPBYTE)&pVariant->Byte;
        break;

    // ----------------------------------------------------------------
    case TYPE_CHAR:
        Assert(cbValue == sizeof(CHAR));
        pbValue = (LPBYTE)&pVariant->Char;
        break;

    // ----------------------------------------------------------------
    case TYPE_FILETIME:
        Assert(cbValue == sizeof(FILETIME));
        pbValue = (LPBYTE)&pVariant->Filetime;
        break;
    
    // ----------------------------------------------------------------
    case TYPE_ULARGEINTEGER:
        Assert(cbValue == sizeof(ULARGE_INTEGER));
        pbValue = (LPBYTE)&pVariant->uhVal;
        break;

    // ----------------------------------------------------------------
    case TYPE_STRING:
        Assert(cbValue == (DWORD)lstrlen(pVariant->Lpstring)+1);
        pbValue = (LPBYTE)pVariant->Lpstring;
        AssertSz(pbValue[cbValue-sizeof(char)] == '\0',
            "String is not null terminated - I suspect a Page Fault is eminent.");
        break;

    // ----------------------------------------------------------------
    case TYPE_WSTRING:
        Assert(cbValue == (DWORD)(lstrlenW(pVariant->Lpwstring)+1) * sizeof(WCHAR));
        pbValue = (LPBYTE)pVariant->Lpwstring;
        Assert(2 == sizeof(WCHAR)); // Next assert depends on this
        AssertSz(pbValue[cbValue-1] == '\0' && pbValue[cbValue-2] == '\0',
            "WString is not null terminated - I suspect a Page Fault is eminent.");
        break;

    // ----------------------------------------------------------------
    case TYPE_BINARY:
        pbValue = pVariant->Lpbyte;
        break;

    // ----------------------------------------------------------------
    case TYPE_PASS:
        pbValue = (pVariant->pPass) ? pVariant->pPass->pbRegData : NULL;
        break;

    // ----------------------------------------------------------------
    case TYPE_STREAM:
        if (pVariant->Lpstream)
            HrGetStreamSize(pVariant->Lpstream, &cbValue);
        break;

    // ----------------------------------------------------------------
    default:
        AssertSz(FALSE, "Hmmm, bad property type, this should have failed earlier.");
        hr = TRAPHR(E_BadPropType);
        goto exit;
    }

    // No Data ?
    if (cbValue == 0 || pbValue == NULL)
    {
        *pcb = cbValue;
        goto exit;
    }

    // Is it big enough
    if (cbValue > *pcb)
    {
        hr = TRAPHR(E_BufferTooSmall);
        goto exit;
    }

    // Check Buffer
    AssertWritePtr(pb, cbValue);

    // Set outbound size
    *pcb = cbValue;

    // Copy Data from stream
    if (TYPE_STREAM == PropType)
    {
        Assert(pVariant->Lpstream);
        CHECKHR(hr = HrCopyStreamToByte(pVariant->Lpstream, pb, &cbStream));
        Assert(cbStream == *pcb);
    }

    // Otherwise, simple copy
    else
    {
        AssertReadPtr(pbValue, cbValue);
        CopyMemory(pb, pbValue, cbValue);
    }

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// PropUtil_HrCopyVariant
// -----------------------------------------------------------------------------
HRESULT PropUtil_HrCopyVariant(DWORD dwPropTag, LPCXVARIANT pVariantSrc, DWORD cbSrc, LPXVARIANT pVariantDest, DWORD *pcbDest)
{
    // Locals
    HRESULT             hr=S_OK;
    PROPTYPE            PropType = PROPTAG_TYPE(dwPropTag);

    // Validate Parameters
    if (pVariantSrc == NULL || pVariantDest == NULL || pcbDest == NULL || dwPropTag == 0)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Handle data type
    switch(PropType)
    {
    // ----------------------------------------------------------------
    case TYPE_BOOL:
        *pcbDest = sizeof(DWORD);
        pVariantDest->Bool = pVariantSrc->Bool;
        break;

    // ----------------------------------------------------------------
    case TYPE_FLAGS:
        *pcbDest = sizeof(DWORD);
        pVariantDest->Flags = pVariantSrc->Flags;
        break;

    // ----------------------------------------------------------------
    case TYPE_DWORD:
        *pcbDest = sizeof(DWORD);
        pVariantDest->Dword = pVariantSrc->Dword;
        break;

    // ----------------------------------------------------------------
    case TYPE_LONG:
        *pcbDest = sizeof(LONG);
        pVariantDest->Long = pVariantSrc->Long;
        break;

    // ----------------------------------------------------------------
    case TYPE_WORD:
        *pcbDest = sizeof(WORD);
        pVariantDest->Word = pVariantSrc->Word;
        break;

    // ----------------------------------------------------------------
    case TYPE_SHORT:
        *pcbDest = sizeof(SHORT);
        pVariantDest->Short = pVariantSrc->Short;
        break;

    // ----------------------------------------------------------------
    case TYPE_BYTE:
        *pcbDest = sizeof(BYTE);
        pVariantDest->Byte = pVariantSrc->Byte;
        break;

    // ----------------------------------------------------------------
    case TYPE_CHAR:
        *pcbDest = sizeof(CHAR);
        pVariantDest->Char = pVariantSrc->Char;
        break;

    // ----------------------------------------------------------------
    case TYPE_FILETIME:
        Assert(cbSrc == sizeof(FILETIME));
        *pcbDest = sizeof(FILETIME);
        CopyMemory(&pVariantDest->Filetime, &pVariantSrc->Filetime, sizeof(FILETIME));
        break;
    
    // ----------------------------------------------------------------
    case TYPE_ULARGEINTEGER:
        Assert(cbSrc == sizeof(ULARGE_INTEGER));
        *pcbDest = sizeof(ULARGE_INTEGER);
        CopyMemory(&pVariantDest->uhVal, &pVariantSrc->uhVal, sizeof(ULARGE_INTEGER));
        break;

    // ----------------------------------------------------------------
    case TYPE_STRING:
    {
        LPSTR pszSrc;
        char sz[512];

        // Check if this is actually a string resource ID
        if (0 == HIWORD(pVariantSrc->Lpstring))
        {
            // Load the default from the string resource table
            cbSrc = LoadString(g_hInstRes, LOWORD(pVariantSrc->Lpstring),
                sz, sizeof(sz)) + 1; // Add 1 to cbSrc to null-term
            if (1 == cbSrc) // LoadString returns 0 on failure, + 1 == 1
            {
                // Rather than prevent OE from starting, just substitute blank string
                AssertSz(FALSE, "Could not load string resource default value");
                sz[0] = '\0';
            }
            pszSrc = sz;
        }
        else
        {
            Assert(cbSrc);
            AssertReadPtr(pVariantSrc->Lpstring, cbSrc);
            pszSrc = pVariantSrc->Lpstring;
        }

        CHECKHR(hr = HrAlloc((LPVOID *)&pVariantDest->Lpstring, cbSrc));
        AssertWritePtr(pVariantDest->Lpstring, cbSrc);
        *pcbDest = cbSrc;
        CopyMemory(pVariantDest->Lpstring, pszSrc, cbSrc);
        Assert(pVariantDest->Lpstring[cbSrc-1] == '\0');

    } // case TYPE_STRING
        break;

    // ----------------------------------------------------------------
    case TYPE_WSTRING:
        Assert(cbSrc);
        AssertReadPtr(pVariantSrc->Lpwstring, cbSrc);
        CHECKHR(hr = HrAlloc((LPVOID *)&pVariantDest->Lpwstring, cbSrc));
        AssertWritePtr(pVariantDest->Lpwstring, cbSrc);
        *pcbDest = cbSrc;
        CopyMemory(pVariantDest->Lpwstring, pVariantSrc->Lpwstring, cbSrc);
        Assert(2 == sizeof(WCHAR));
        Assert(pVariantDest->Lpwstring[cbSrc-1] == '\0' &&
            pVariantDest->Lpwstring[cbSrc-2] == '\0');
        break;

    // ----------------------------------------------------------------
    case TYPE_BINARY:
        Assert(cbSrc);
        AssertReadPtr(pVariantSrc->Lpbyte, cbSrc);
        CHECKHR(hr = HrAlloc((LPVOID *)&pVariantDest->Lpbyte, cbSrc));
        AssertWritePtr(pVariantDest->Lpbyte, cbSrc);
        *pcbDest = cbSrc;
        CopyMemory(pVariantDest->Lpbyte, pVariantSrc->Lpbyte, cbSrc);
        break;

    // ----------------------------------------------------------------
    case TYPE_PASS:
        Assert(cbSrc);
        if (pVariantSrc->pPass)
        {
            AssertReadPtr(pVariantSrc->pPass->pbRegData, cbSrc);

            CHECKHR(hr = HrAlloc((LPVOID *)&pVariantDest->pPass, sizeof(PROPPASS)));
            ZeroMemory(pVariantDest->pPass, sizeof(PROPPASS));
            CHECKHR(hr = HrAlloc((LPVOID *)&pVariantDest->pPass->pbRegData, cbSrc));

            AssertWritePtr(pVariantDest->pPass->pbRegData, cbSrc);
            *pcbDest = cbSrc;
            CopyMemory(pVariantDest->pPass->pbRegData, pVariantSrc->pPass->pbRegData, cbSrc);
        }
        else
        {
            *pcbDest = 0;
        }
        break;

    // ----------------------------------------------------------------
    case TYPE_STREAM:
        pVariantDest->Lpstream = pVariantSrc->Lpstream;
        if (pVariantDest->Lpstream)
            pVariantDest->Lpstream->AddRef();
        break;

    // ----------------------------------------------------------------
    default:
        AssertSz(FALSE, "Hmmm, bad property type, this should have failed earlier.");
        hr = TRAPHR(E_BadPropType);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// PropUtil_FRegCompatDataTypes
// -----------------------------------------------------------------------------
BOOL PropUtil_FRegCompatDataTypes(DWORD dwPropTag, DWORD dwRegType)
{
    // Locals
    BOOL            fResult=FALSE;

    // Check Params
    Assert(dwPropTag);

    // Map Property Type to registry type
    switch(PROPTAG_TYPE(dwPropTag))
    {
    case TYPE_BOOL:
    case TYPE_DWORD:
    case TYPE_LONG:
    case TYPE_WORD:
    case TYPE_SHORT:
    case TYPE_FLAGS:
        if (dwRegType == REG_DWORD)
            fResult = TRUE;
        break;

    case TYPE_CHAR:
    case TYPE_BINARY:
    case TYPE_BYTE:
    case TYPE_FILETIME:
    case TYPE_PASS:
    case TYPE_ULARGEINTEGER:
        if (dwRegType == REG_BINARY)
            fResult = TRUE;
        break;

    case TYPE_STRING:
    case TYPE_WSTRING:
        if (dwRegType == REG_SZ || dwRegType == REG_BINARY || dwRegType == REG_EXPAND_SZ)
            fResult = TRUE;
        break;

    default:
        AssertSz(FALSE, "Property type is not supported by the registry.");
        TRAPHR(E_FAIL);
        break;
    }

    // Done
    return fResult;
}

// -----------------------------------------------------------------------------
// PropUtil_HrRegTypeFromPropTag
// -----------------------------------------------------------------------------
HRESULT PropUtil_HrRegTypeFromPropTag(DWORD dwPropTag, DWORD *pdwRegType)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPTYPE        PropType = PROPTAG_TYPE(dwPropTag);

    // Check Params
    Assert(dwPropTag && pdwRegType);

    // Map Property Type to registry type
    switch(PROPTAG_TYPE(PropType))
    {
    case TYPE_BOOL:
    case TYPE_DWORD:
    case TYPE_LONG:
    case TYPE_WORD:
    case TYPE_SHORT:
    case TYPE_FLAGS:
        *pdwRegType = REG_DWORD;
        break;

    case TYPE_CHAR:
    case TYPE_BINARY:
    case TYPE_BYTE:
    case TYPE_FILETIME:
    case TYPE_PASS:
    case TYPE_ULARGEINTEGER:
        *pdwRegType = REG_BINARY;
        break;

    case TYPE_STRING:
    case TYPE_WSTRING:
        *pdwRegType = REG_SZ;
        break;

    default:
        AssertSz(FALSE, "Property type is not supported by the registry.");
        hr = TRAPHR(E_FAIL);
        *pdwRegType = 0;
        break;
    }

    // Done
    return hr;

}

// -----------------------------------------------------------------------------
// PropUtil_HrValidatePropInfo
// -----------------------------------------------------------------------------
HRESULT PropUtil_HrValidatePropInfo(LPPROPINFO prgPropInfo, ULONG cProperties)
{
#ifdef DEBUG
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;

    // Check Params
    Assert(prgPropInfo);
    AssertReadPtr(prgPropInfo, cProperties * sizeof(PROPINFO));

    // Loop through the propinfo array
    for (i=0; i<cProperties; i++)
    {
        // Empty proptags are okay, but undesireable
        if (prgPropInfo[i].dwPropTag == 0)
            continue;

        // This should never happen
        if (PROPTAG_ID(prgPropInfo[i].dwPropTag) > MAX_PROPID)
        {
            AssertSz(FALSE, "Property Tag Id is somehow greater than the MAX_PROPID.");
            hr = TRAPHR(E_InvalidPropertySet);
            goto exit;
        }

        // Validate Property data type
        if (PropUtil_FIsValidPropTagType(PROPTAG_TYPE(prgPropInfo[i].dwPropTag)) == FALSE)
        {
            AssertSz(FALSE, "Invalid Property Type.");
            hr = TRAPHR(E_InvalidPropertySet);
            goto exit;
        }

        // Propids should be in ascending order
        if (i > 0)
        {
            if (PROPTAG_ID(prgPropInfo[i].dwPropTag) <= PROPTAG_ID(prgPropInfo[i-1].dwPropTag))
            {
                AssertSz(FALSE, "Property Tag Ids are not in ascending order.");
                hr = TRAPHR(E_InvalidPropertySet);
                goto exit;
            }
        }
    }

exit:
    // Done
    return hr;
#else
	return(S_OK);
#endif // DEBUG
}

// -----------------------------------------------------------------------------
// PropUtil_HrPersistContainerToRegistry
// -----------------------------------------------------------------------------
HRESULT PropUtil_HrPersistContainerToRegistry(HKEY hkeyReg, CPropertyContainer *pPropertyContainer, BOOL *pfPasswChanged)
{
    // Locals
    HRESULT             hr=S_OK;
    CEnumProps         *pEnumProps=NULL;
    PROPVALUE           rPropValue;
    PROPINFO            rPropInfo;
    DWORD               dwType;

    // Check Parameters
    if (hkeyReg == NULL || pPropertyContainer == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    *pfPasswChanged = FALSE;
    // Enumerate CPropertyContainer
    CHECKHR(hr = pPropertyContainer->HrEnumProps(&pEnumProps));

    // Loop through all properties
    while(SUCCEEDED(pEnumProps->HrGetNext(&rPropValue, &rPropInfo)))
    {
        // Not Dirty
        if (!(rPropValue.dwValueFlags & PV_WriteDirty))
            continue;

        // In addition to having the registry value set, encrypted properties need
        // other info to be persisted on commit.
        // needs to happen before we continue the loop, even on delete, since this
        // function call will cause that to happen

        // [BUGBUG]. We should test for the proptag being equal to password prop.
        // This will cause a problem if we add another property that needs to be encrypted.
        if (rPropValue.dwPropFlags & PF_ENCRYPTED)
        {
            hr = pPropertyContainer->PersistEncryptedProp(rPropValue.dwPropTag, pfPasswChanged);
            if (S_PasswordDeleted == hr || FAILED(hr))
            {
                rPropInfo.dwFlags |= PF_NOPERSIST;
                if (hr != S_PasswordDeleted)
                {
                    hr = S_OK;
                }
            }
            else        // succeeded and not password deleted
            {
                // [shaheedp] QFE for OUTLOOK. Refer to Bug# 82393 in IE database.
                // This is originally a hack we put in for Bug# 66724. For bug# 88393, we are just
                // refining the hack. Refer to the mail attached to the bug# 82393.

                //*fPasswChanged = TRUE;

                // reload
                CHECKHR(hr = pEnumProps->HrGetCurrent(&rPropValue, &rPropInfo));
            }
        }

        // Not persist, or no data ?
        if (rPropInfo.dwFlags & PF_NOPERSIST || rPropValue.cbValue == 0 || rPropValue.pbValue == NULL)
        {
            // Make sure the value is not in the registry
            if (rPropInfo.pszName)
                RegDeleteValue(hkeyReg, rPropInfo.pszName);

            // Its not dirty
            pPropertyContainer->HrSetPropDirty(rPropValue.dwPropTag, FALSE);
            continue;
        }

        // The value should have been set
        Assert(rPropInfo.pszName && (rPropValue.dwValueFlags & PV_ValueSet));

        // Get property reg data type
        if (FAILED(PropUtil_HrRegTypeFromPropTag(rPropValue.dwPropTag, &dwType)))
        {
            AssertSz(FALSE, "We've got problems, my 24 inch pythons are shrinking.");
            continue;
        }

        // Set value into the registry
        AssertReadPtr(rPropValue.pbValue, rPropValue.cbValue);
        if (RegSetValueEx(hkeyReg, rPropInfo.pszName, 0, dwType, rPropValue.pbValue, rPropValue.cbValue) != ERROR_SUCCESS)
        {
            hr = TRAPHR(E_RegSetValueFailed);
            goto exit;
        }

        // Not dirty
        CHECKHR(hr = pPropertyContainer->HrSetPropDirty(rPropValue.dwPropTag, FALSE));
    }

    // Better not have any dirty properties
    Assert(pPropertyContainer->FIsDirty() == FALSE);

exit:
    // Cleanup
    SafeRelease(pEnumProps);

    // Done
    return hr;
}

// -----------------------------------------------------------------------------
// PropUtil_HrLoadContainerFromRegistry
// -----------------------------------------------------------------------------
HRESULT PropUtil_HrLoadContainerFromRegistry(HKEY hkeyReg, CPropertyContainer *pPropertyContainer)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               i=0,
                        cbValueName=0,
                        dwType,
                        cbData=0,
                        cbValueNameMax=0,
                        cbDataMax=0;
    LONG                lResult;
    LPTSTR              pszValueName=NULL;
    LPBYTE              pbDataT, pbData=NULL;
    PROPINFO            rPropInfo;

    // Check Parameters
    Assert(hkeyReg != NULL);
	Assert(pPropertyContainer != NULL);

    // Should be in the load state
    Assert(pPropertyContainer->FIsBeingLoaded());

    // Reset the container in case we are re-opening an account
    //N this is a waste if we are not... can we tell?
    //pPropertyContainer->ResetContainer();

    // Lets get max value name length and the max value data length
    if (RegQueryInfoKey (hkeyReg, NULL, NULL, 0, NULL, NULL, NULL, NULL,
                         &cbValueNameMax, &cbDataMax, NULL, NULL) != ERROR_SUCCESS)
    {
        hr = TRAPHR(E_RegQueryInfoKeyFailed);
        goto exit;
    }

    // Add One to length
    cbValueNameMax++;

    // Allocate local buffer for value names
    CHECKHR(hr = HrAlloc((LPVOID *)&pszValueName, cbValueNameMax));

    // Allocate local buffer for value data
    CHECKHR(hr = HrAlloc((LPVOID *)&pbData, cbDataMax));

    // Enumerate through values in the account
    for(i=0;;i++)
    {
        // Get the value name and data
        cbValueName = cbValueNameMax;
        cbData = cbDataMax;
        lResult = RegEnumValue(hkeyReg, i, pszValueName, &cbValueName, 0, &dwType, pbData, &cbData);

        // Done ?
        if (lResult == ERROR_NO_MORE_ITEMS)
            break;

        // Error
        if (lResult != ERROR_SUCCESS)
        {
            AssertSz(FALSE, "Why did RegEnumValue fail, I may be skipping values.");
            continue;
        }

        // Find property based on name
        if (FAILED(pPropertyContainer->HrGetPropInfo(pszValueName, &rPropInfo)))
            continue;

        // Compatible Data Types ?
        if (!PropUtil_FRegCompatDataTypes(rPropInfo.dwPropTag, dwType))
        {
            AssertSz(FALSE, "Registry data type is not compatible with the associated property.");
            continue;
        }

        if (dwType == REG_EXPAND_SZ)
            {
            DWORD cchNewLen;
            hr = HrAlloc((LPVOID *)&pbDataT, cbData * sizeof(TCHAR));
            IF_FAILEXIT(hr);
            cchNewLen = ExpandEnvironmentStrings((TCHAR *)pbData, (TCHAR *)pbDataT, cbData);
            if (cchNewLen > cbData)
            {
                // Not enough room for the expanded string, allocate more memory
                MemFree(pbDataT);
                hr = HrAlloc((LPVOID *)&pbDataT, cchNewLen * sizeof(TCHAR));
                IF_FAILEXIT(hr);

                cbData = ExpandEnvironmentStrings((TCHAR *)pbData, (TCHAR *)pbDataT, cchNewLen);

                if ((0 == cbData ) || (cbData > cchNewLen))
                {
                    AssertSz(0, "We gave ExpandEnvironmentStrings more mem, and it still failed!");
                    TraceResult(E_FAIL);
                    goto exit;
                }
            }
   
            cbData = (lstrlen((TCHAR *)pbDataT) + 1) * sizeof(TCHAR);
            CopyMemory(pbData, pbDataT, cbData);
            MemFree(pbDataT);
            }

        CHECKHR(hr = pPropertyContainer->SetProp(rPropInfo.dwPropTag, pbData, cbData));
    }

exit:
    // Cleanup
    if (pszValueName)
        MemFree(pszValueName);
    if (pbData)
        MemFree(pbData);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\ipropobj.h ===
// -----------------------------------------------------------------------------
// I P R O P O B J . H - Steven J. Bailey - 8/17/96
// -----------------------------------------------------------------------------
#ifndef __IPROPOBJ_H
#define __IPROPOBJ_H

// ------------------------------------------------------------------------------------------
// Depends On
// ------------------------------------------------------------------------------------------
#include "imnact.h"

// ------------------------------------------------------------------------------------------
// Forward Decls
// ------------------------------------------------------------------------------------------
class CPropCrypt;

// ------------------------------------------------------------------------------------------
// Macros for defining imn property tags
// ------------------------------------------------------------------------------------------
#define CCHMAX_PROPERTY_NAME            255

// ------------------------------------------------------------------------------------------
// Password structure
// ------------------------------------------------------------------------------------------
struct tagPROPPASS {
    LPBYTE              pbRegData;
    BLOB                blobPassword;
};
typedef struct tagPROPPASS PROPPASS;
typedef PROPPASS *LPPROPPASS;

// ------------------------------------------------------------------------------------------
// Union of property value types
// ------------------------------------------------------------------------------------------
typedef union tagXVARIANT {

    DWORD               Dword;      // TYPE_DWORD
    LONG                Long;       // TYPE_LONG
    WORD                Word;       // TYPE_WORD
    SHORT               Short;      // TYPE_SHORT
    BYTE                Byte;       // TYPE_BYTE
    CHAR                Char;       // TYPE_CHAR    
    FILETIME            Filetime;   // TYPE_FLETIME
    DWORD               Flags;      // TYPE_FLAGS
    LPSTR               Lpstring;   // TYPE_STRING
    LPWSTR              Lpwstring;  // TYPE_WSTRING;
    LPBYTE              Lpbyte;     // TYPE_BINARY
    LPSTREAM            Lpstream;   // TYPE_STREAM
    DWORD               Bool;       // TYPE_BOOL
    LPPROPPASS          pPass;      // TYPE_PASS
    ULARGE_INTEGER      uhVal;      // TYPE_ULARGEINTEGER
} XVARIANT, *LPXVARIANT;

typedef const XVARIANT *LPCXVARIANT;

// ------------------------------------------------------------------------------------------
// Min Max Data Type
// ------------------------------------------------------------------------------------------
typedef struct tagMINMAX {

    DWORD               dwMin;
    DWORD               dwMax;

} MINMAX, *LPMINMAX;

// ------------------------------------------------------------------------------------------
// Value Flags
// ------------------------------------------------------------------------------------------
#define PV_WriteDirty               FLAG01  // Has it been modified by a HrSetProperty
#define PV_ValueSet                 FLAG02  // Is the value set or is it un-initialized
#define PV_UsingDefault             FLAG03  // Are we using the default value for HrGetProperty
#define PV_CustomProperty           FLAG04  // Is this a custom property (i.e. not in known propset range)               
#define PV_SetOnLoad                FLAG05  // Value was set during a EnterLoadContainer

// ------------------------------------------------------------------------------------------
// PROPVALUE
// ------------------------------------------------------------------------------------------
typedef struct tagPROPVALUE {

    DWORD               dwPropTag;          // PropTag (id and type) of property
    DWORD               dwPropFlags;        // Property Flags, same as PROPINFO::dwFlags
    DWORD               dwValueFlags;       // Value Flags
    DWORD               cbAllocated;        // Number of bytes allocated for dynamic properties
    DWORD               cbValue;            // Length of property
    LPBYTE              pbValue;            // Pointer into Value union
    XVARIANT            Variant;            // Union of typed property values
    MINMAX              rMinMax;            // Valid range or size of property

} PROPVALUE, *LPPROPVALUE;

// ------------------------------------------------------------------------------------------
// Property Flags
// ------------------------------------------------------------------------------------------
#define NOFLAGS         0
#define PF_REQUIRED     1
#define PF_NOPERSIST    2
#define PF_READONLY     4
#define PF_VARLENGTH    8
#define PF_ENCRYPTED    16
#define PF_MINMAX       32
#define PF_DEFAULT      64

// ------------------------------------------------------------------------------------------
// Default for propinfo
// ------------------------------------------------------------------------------------------
typedef struct tagPROPDEFAULT {

    XVARIANT            Variant;            // Default Variant Type
    DWORD               cbValue;            // Size of default value

} PROPDEFAULT, *LPPROPDEFAULT;

// ------------------------------------------------------------------------------------------
// Property Info - Used to create Property Set Arrays
// ------------------------------------------------------------------------------------------
typedef struct tagPROPINFO {

    DWORD               dwPropTag;          // Property tag
    LPTSTR              pszName;            // Property name
    DWORD               dwFlags;            // Propety flags (above)
    PROPDEFAULT         Default;            // Default Value for property
    MINMAX              rMinMax;            // Valid range or size of property

} PROPINFO, *LPPROPINFO;

typedef const PROPINFO *LPCPROPINFO;

// -----------------------------------------------------------------------------
// PSETINFO
// -----------------------------------------------------------------------------
typedef struct tagPSETINFO {

    LPPROPINFO          prgPropInfo;
    ULONG               cProperties;
    ULONG               ulPropIdMin;
    ULONG               ulPropIdMax;

	PROPINFO            **rgpInfo;
	ULONG				cpInfo;

} PSETINFO, *LPPSETINFO;

// -----------------------------------------------------------------------------
// CPropertySet
// -----------------------------------------------------------------------------
class CPropertySet
{
private:
    ULONG               m_cRef;             // Reference Counting
    ULONG               m_cProperties;      // Number of properties in propset
    ULONG               m_ulPropIdMin;      // Lowest prop id
    ULONG               m_ulPropIdMax;      // Largest prop id
    BOOL                m_fInit;            // Has the object been initialized successfully
    LPPROPINFO          m_prgPropInfo;      // Property set inforation
    LPPROPVALUE         m_prgPropValue;     // Sorted propdata template array
    CRITICAL_SECTION    m_cs;               // Critical Section

	PROPINFO            **m_rgpInfo;
	ULONG				m_cpInfo;

private:
    // -------------------------------------------------------------------------
    // Prepare this object to be re-used - may be public someday
    // -------------------------------------------------------------------------
    VOID ResetPropertySet(VOID);

public:
    // -------------------------------------------------------------------------
    // Standard Object Stuff
    // -------------------------------------------------------------------------
    CPropertySet();
    ~CPropertySet();
    ULONG AddRef(VOID);
    ULONG Release(VOID);

    // -------------------------------------------------------------------------
    // Use to validate property tags
    // -------------------------------------------------------------------------
    BOOL FIsValidPropTag(DWORD dwPropTag);

    // -------------------------------------------------------------------------
    // Computes index into propinfo or propdata arrays
    // -------------------------------------------------------------------------
    HRESULT HrIndexFromPropTag(DWORD dwPropTag, ULONG *pi);

    // -------------------------------------------------------------------------
    // Initialize the property set with a know propset array
    // -------------------------------------------------------------------------
    HRESULT HrInit(LPCPROPINFO prgPropInfo, ULONG cProperties);

    // -------------------------------------------------------------------------
    // Lookup property info on a specific prop
    // -------------------------------------------------------------------------
    HRESULT HrGetPropInfo(DWORD dwPropTag, LPPROPINFO pPropInfo);
    HRESULT HrGetPropInfo(LPTSTR pszName, LPPROPINFO pPropInfo);

    // -------------------------------------------------------------------------
    // Generates propdata array used by CPropertyContainer. This object 
    // maintains a sorted template propdata array. These can be somewhat
    // expensive to create, that why a CPropertySet can live outside of a 
    // CPropertyContainer.
    // -------------------------------------------------------------------------
    HRESULT HrGetPropValueArray(LPPROPVALUE *pprgPropValue, ULONG *pcProperties);
};

// -----------------------------------------------------------------------------
// Forward Decl
// -----------------------------------------------------------------------------
class CEnumProps;

// -----------------------------------------------------------------------------
// CPropertyContainer
// -----------------------------------------------------------------------------
class CPropertyContainer : public IPropertyContainer
{
protected:
    ULONG               m_cRef;             // Reference Count
    CPropertySet       *m_pPropertySet;     // Base property set
    LPPROPVALUE         m_prgPropValue;     // Array of property data items
    ULONG               m_cDirtyProps;      // Number of current dirty properties
    ULONG               m_cProperties;      // Number of properties known to container
    BOOL                m_fLoading;         // Properties are being set from persisted source
    CPropCrypt         *m_pPropCrypt;       // Property Encryption Object
    CRITICAL_SECTION    m_cs;               // Critical Section

private:
    friend CEnumProps;

    // -------------------------------------------------------------------------
    // Used to group dynamic properties TYPE_STRING, TYPE_WSTRING and TYPE_BYTE
    // -------------------------------------------------------------------------
    HRESULT HrGrowDynamicProperty(DWORD cbNewSize, DWORD *pcbAllocated, LPBYTE *ppbData, DWORD dwUnitSize);

    // -------------------------------------------------------------------------
    // Property validation used during the base HrSetProp
    // -------------------------------------------------------------------------
    HRESULT HrValidateSetProp(PROPTYPE PropType, LPPROPVALUE pPropValue, LPBYTE pb, ULONG cb, LPMINMAX pMinMax);

    HRESULT GetEncryptedProp(PROPVALUE *ppv, LPBYTE pb, ULONG *pcb);

public:
    // -------------------------------------------------------------------------
    // Standard Object Stuff
    // -------------------------------------------------------------------------
    CPropertyContainer(void);
    virtual ~CPropertyContainer(void);

    // -------------------------------------------------------------------------
	// IUnknown Methods
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // Verify State of the object
    // -------------------------------------------------------------------------
    HRESULT HrInit(CPropertySet *pPropertySet);

    // -------------------------------------------------------------------------
    // LoadingContainer - When reading the props from a persisted location,
    // you should call this function with TRUE, and then with FALSE when your
    // completed. This tells the container that the props you are setting are
    // not dirty, and that they are initial properties.
    // -------------------------------------------------------------------------
    BOOL FIsBeingLoaded(VOID);
    VOID EnterLoadContainer(VOID);
    VOID LeaveLoadContainer(VOID);
    VOID SetOriginalPropsToDirty(VOID);

    // -------------------------------------------------------------------------
    // Are there dirty properties in the container
    // -------------------------------------------------------------------------
    BOOL FIsDirty(VOID);
    HRESULT HrIsPropDirty(DWORD dwPropTag, BOOL *pfDirty);
    HRESULT HrSetPropDirty(DWORD dwPropTag, BOOL fDirty);
    HRESULT HrSetAllPropsDirty(BOOL fDirty);

    // -------------------------------------------------------------------------
    // Blow away all changes
    // -------------------------------------------------------------------------
    VOID ResetContainer(VOID);

    // -------------------------------------------------------------------------
    // Property Enumeration
    // -------------------------------------------------------------------------
    HRESULT HrEnumProps(CEnumProps **ppEnumProps);
    
    // -------------------------------------------------------------------------
    // HrGetProperty
    // -------------------------------------------------------------------------
    STDMETHODIMP GetProp(DWORD dwPropTag, LPBYTE pb, ULONG *pcb);
    STDMETHODIMP GetPropDw(DWORD dwPropTag, DWORD *pdw);
    STDMETHODIMP GetPropSz(DWORD dwPropTag, LPSTR psz, ULONG cchMax);

    // -------------------------------------------------------------------------
    // HrSetProperty
    // -------------------------------------------------------------------------
    STDMETHODIMP SetProp(DWORD dwPropTag, LPBYTE pb, ULONG cb);
    STDMETHODIMP SetPropDw(DWORD dwPropTag, DWORD dw);
    STDMETHODIMP SetPropSz(DWORD dwPropTag, LPSTR psz);

    // -------------------------------------------------------------------------
    // Access to CPropertSet Stuff
    // -------------------------------------------------------------------------
    HRESULT HrGetPropInfo(DWORD dwPropTag, LPPROPINFO pPropInfo);
    HRESULT HrGetPropInfo(LPTSTR pszName, LPPROPINFO pPropInfo);

    // -------------------------------------------------------------------------
    // Encryption
    // -------------------------------------------------------------------------
    HRESULT HrEncryptProp(LPBYTE pbClientData, DWORD cbClientData, LPBYTE *ppbPropData, DWORD *pcbPropData);
    HRESULT HrDecryptProp(BLOB *pIn, BLOB *pOut);
    HRESULT PersistEncryptedProp(DWORD dwPropTag, BOOL    *pfPasswChanged);
};

// -----------------------------------------------------------------------------
// CEnumProps - In the future, when I support custom properties, this will
//              be very useful and will know how to enumerate known and
//              custom properties as if they were a single array.
// -----------------------------------------------------------------------------
class CEnumProps
{
private:
    ULONG               m_cRef;               // Reference Count
    LONG                m_iProperty;          // Current property index into m_pPropValue, -1 == first item is next
    CPropertyContainer *m_pPropertyContainer; // Container that were enumerating, were friends

public:
    // -------------------------------------------------------------------------
    // Standard Object Stuff
    // -------------------------------------------------------------------------
    CEnumProps(CPropertyContainer *pPropertyContainer);
    ~CEnumProps();
    ULONG AddRef(VOID);
    ULONG Release(VOID);

    // -------------------------------------------------------------------------
    // HrGetCount - Get the number of items that the enumerator will process
    // -------------------------------------------------------------------------
    HRESULT HrGetCount(ULONG *pcItems);

    // -------------------------------------------------------------------------
    // HrGetNext - Get the first or next enumerated propertiy
    // Returns hrEnumFinished when no more accounts to enumerate
    // -------------------------------------------------------------------------
    HRESULT HrGetNext(LPPROPVALUE pPropValue, LPPROPINFO pPropInfo);

    // -------------------------------------------------------------------------
    // HrGetCurrent - Get enumerated property that is the current one
    // Returns hrEnumFinished if no more accounts
    // -------------------------------------------------------------------------
    HRESULT HrGetCurrent(LPPROPVALUE pPropValue, LPPROPINFO pPropInfo);

    // -------------------------------------------------------------------------
    // Reset - This is like rewinding the enumerator
    // -------------------------------------------------------------------------
    VOID Reset(VOID);
};

// -----------------------------------------------------------------------------
// IPersistPropertyContainer
// -----------------------------------------------------------------------------
class IPersistPropertyContainer : public CPropertyContainer
{
public:
    IPersistPropertyContainer(void);
    // HRESULT HrOpenTaggedPropStream(LPSTREAM pStream);
    // HRESULT HrSaveTaggedPropStream(LPSTREAM pStream);
    // HRESULT HrGetPersistedSize(DWORD *pcb);
    // virtual HRESULT HrOpenPropertyStream(DWORD dwPropTag, LPSTREAM *ppStream);
    virtual HRESULT HrSaveChanges(VOID) PURE;
};

// ------------------------------------------------------------------------------------------
// Prototypes
// ------------------------------------------------------------------------------------------
HRESULT HrCreatePropertyContainer(CPropertySet *pPropertySet, CPropertyContainer **ppPropertyContainer);
HRESULT PropUtil_HrRegTypeFromPropTag(DWORD dwPropTag, DWORD *pdwRegType);
BOOL    PropUtil_FRegCompatDataTypes(DWORD dwPropTag, DWORD dwRegType);
HRESULT PropUtil_HrLoadContainerFromRegistry(HKEY hkeyReg, CPropertyContainer *pPropertyContainer);
HRESULT PropUtil_HrPersistContainerToRegistry(HKEY hkeyReg, CPropertyContainer *pPropertyContainer, BOOL *fPasswChanged);

#endif // __IPROPOBJ
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\icwwiz.h ===
#ifndef _INC_ICWWIZ_H
#define _INC_ICWWIZ_H

#include "ids.h"

class CICWApprentice;
interface IAccountImport;
interface IAccountImport2;
interface INewsGroupImport;
class CAccount;
class CAccountManager;
interface IUserIdentity;

#define WM_POSTSETFOCUS                 (WM_USER + 1)
#define WM_ENABLENEXT                   (WM_USER + 2)
#define WM_AUTODISCOVERY_FINISHED       (WM_USER + 3)
#define WM_AUTODISCOVERY_STATUSMSG      (WM_USER + 4)
// AutoDiscovery reserves (WM_USER+3) thru (WM_USER+13)
#define WM_AUTODISCOVERY_RANGEEND       (WM_USER + 13)

#define CONNECT_DLG ((UINT)-3)
#define EXTERN_DLG  ((UINT)-2)
#define INNER_DLG   ((UINT)-1)

#define NAME_PAGE       0x0001
#define ADDR_PAGE       0x0002
#define SRV_PAGE        0x0004
#define LOGON_PAGE      0x0008
#define RESOLVE_PAGE    0x0010
#define CONNECT_PAGE    0x0020
#define CONFIRM_PAGE    0x0040
#define ALL_PAGE        0x007f

#define SELECT_PAGE     0x0100

#define NOSEL           -2
#define CREATENEW       -1

typedef struct tagACCTDATA
{
    BOOL fLogon;
    BOOL fSPA;
    BOOL fResolve;          // ldap only
    DWORD fServerTypes;     // SRV_NNTP | SRV_IMAP | SRV_POP3 | SRV_SMTP | SRV_LDAP | SRV_HTTPMAIL
    char szAcctOrig[CCHMAX_ACCOUNT_NAME];
    char szAcct[CCHMAX_ACCOUNT_NAME];
    char szName[CCHMAX_DISPLAY_NAME];
    char szEmail[CCHMAX_EMAIL_ADDRESS];
    char szSvr1[CCHMAX_SERVER_NAME]; // pop3/imap, nntp, ldap
    char szSvr2[CCHMAX_SERVER_NAME]; // smtp
    char szUsername[CCHMAX_USERNAME];
    char szPassword[CCHMAX_PASSWORD];
    DWORD fAlwaysPromptPassword; // "Always Prompt for Password" option
    
    DWORD dwConnect;
    char szConnectoid[MAX_PATH];
    CAccount *pAcct;
    BOOL fCreateNewAccount;
    char szFriendlyServiceName[CCHMAX_ACCOUNT_NAME];
    BOOL fDomainMSN;
    int  iServiceIndex;
    int  iNewServiceIndex;
} ACCTDATA;

// CICWApprentice::m_dwFlags
// these shouldn't conflict with the ACCT_WIZ_ flags from imnact.h
#define ACCT_WIZ_IN_ICW         0x0100  // we are within the ICW (in apprentice mode)
                                        // if this isn't on, we own the wizard and ICW is within us

#define ACCT_WIZ_IMPORT_CLIENT  0x0200  // we are importing acct from specific client
                                        // outlook uses this (passes in clsid for desired client)


#define SZ_REGKEY_AUTODISCOVERY                 TEXT("SOFTWARE\\Microsoft\\Outlook Express\\5.0")
#define SZ_REGKEY_AUTODISCOVERY_POLICY          TEXT("SOFTWARE\\Policies\\Microsoft\\Windows")

#define SZ_REGVALUE_AUTODISCOVERY               TEXT("AutoDiscovery")
#define SZ_REGVALUE_AUTODISCOVERY_POLICY        TEXT("AutoDiscovery Policy")
#define SZ_REGVALUE_AUTODISCOVERY_PASSIFIER     TEXT("ADInform")
#define SZ_REGVALUE_AUTODISCOVERY_OEMANUAL      TEXT("OEManuallyConfigure")

HRESULT CreateNewsObject(void **ppNews);

typedef BOOL (CALLBACK* INITPROC)(CICWApprentice *,HWND,BOOL);
typedef BOOL (CALLBACK* OKPROC)(CICWApprentice *,HWND,BOOL,UINT *);
typedef BOOL (CALLBACK* CMDPROC)(CICWApprentice *,HWND,WPARAM,LPARAM);
typedef BOOL (CALLBACK* WMUSERPROC)(CICWApprentice *,HWND,UINT,WPARAM,LPARAM);
typedef BOOL (CALLBACK* CANCELPROC)(CICWApprentice *,HWND);

typedef struct tagPAGEINFO
{
    UINT        uDlgID;
    UINT        uHdrID; // string id for title
    
    // handler procedures for each page-- any of these can be
    // NULL in which case the default behavior is used
    INITPROC    InitProc;
    OKPROC      OKProc;
    CMDPROC     CmdProc;
    WMUSERPROC  WMUserProc;
    CANCELPROC  CancelProc;

    DWORD       dwHelp;
} PAGEINFO;

typedef struct tagDLGINITINFO
{
    CICWApprentice  *pApp;
    int             ord;
} DLGINITINFO;

typedef struct tagMIGRATEINFO
{
    IAccountImport  *pImp;
    IAccountImport2 *pImp2;
    int             cAccts;
    TCHAR           szDisplay[MAX_PATH];
} MIGRATEINFO;

#define CCHMAX_SERVICENAME  255

typedef struct tagHTTPMAILSERVICEINFO
{
    TCHAR           szFriendlyName[CCHMAX_SERVICENAME];
    TCHAR           szDomain[CCHMAX_SERVICENAME];
    TCHAR           szRootUrl[MAX_PATH];
    TCHAR           szSignupUrl[MAX_PATH];
    BOOL            fDomainMSN;
    BOOL            fHTTPEnabled;
    BOOL            fUseWizard;
} HTTPMAILSERVICE;

class CICWApprentice : public IICWApprentice, public IICWExtension
{
    private:
        ULONG               m_cRef;
        BOOL                m_fInit;
        BOOL                m_fReboot;
        IICWExtension       *m_pExt;
        const PAGEINFO      *m_pPageInfo;
        DLGINITINFO         *m_pInitInfo;

        UINT                m_cPages;
        UINT                m_idPrevPage;
        UINT                m_idNextPage;

        UINT                m_iCurrentPage;
        UINT                m_iPageHistory[NUM_WIZARD_PAGES];
        UINT                m_cPagesCompleted;

        HWND                m_hDlg;
        UINT                m_cPageBuf;
        HPROPSHEETPAGE      *m_rgPage;
        UINT                m_extFirstPage;
        UINT                m_extLastPage;

        CAccountManager     *m_pAcctMgr;
        DWORD               m_dwFlags;
        IICWApprentice      *m_pICW;
        ACCTTYPE            m_acctType;

        BOOL                m_fSave;
        BOOL                m_fSkipICW;
        DWORD               m_dwReload;
        int                 m_iSel;
        BOOL                m_fComplete;
        ACCTDATA            *m_pData;

        HTTPMAILSERVICE     *m_pHttpServices;
        UINT                m_cHttpServices;
        HTTPMAILSERVICE     *m_pServices;
        UINT                m_cServices;

        void InitializeICW(ACCTTYPE type, UINT uPrev, UINT uNext);
        HRESULT InitializeMigration(DWORD dwFlags);
        HRESULT InitializeImport(CLSID clsid, DWORD dwFlags);

    public:
        MIGRATEINFO         *m_pMigInfo;
        int                 m_cMigInfo;
        int                 m_iMigInfo;
        BOOL                m_fMigrate;
        CAccount            *m_pAcct;
        BOOL                m_fUseAutoDiscovery;        // Use AutoDiscovery to streamline the wizard

        CICWApprentice(void);
        ~CICWApprentice(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IICWApprentice
		HRESULT STDMETHODCALLTYPE Initialize(IICWExtension *pExt);
		HRESULT STDMETHODCALLTYPE AddWizardPages(DWORD dwFlags);
		HRESULT STDMETHODCALLTYPE GetConnectionInformation(CONNECTINFO *pInfo);
		HRESULT STDMETHODCALLTYPE SetConnectionInformation(CONNECTINFO *pInfo);
		HRESULT STDMETHODCALLTYPE Save(HWND hwnd, DWORD *pdwError);
        HRESULT STDMETHODCALLTYPE SetPrevNextPage(UINT uPrevPage, UINT uNextPage);

        // IICWExtension
		BOOL STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
		BOOL STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
		BOOL STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type);
		BOOL STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID);

        HRESULT Initialize(CAccountManager *pAcctMgr, CAccount *pAcct);
        HRESULT DoWizard(HWND hwnd, CLSID *pclsid, DWORD dwFlags);
        UINT    GetNextWizSection(void);
        HRESULT InitAccountData(CAccount *pAcct, IMPCONNINFO *pConnInfo, BOOL fMigrate);
        HRESULT SaveAccountData(CAccount *pAcct, BOOL fSetAsDefault);
        HRESULT HandleMigrationSelection(int index, UINT *puNextPage, HWND hDlg);
        HRESULT InitializeImportAccount(HWND hwnd, DWORD_PTR dwCookie);
        HRESULT InitHTTPMailServices();
        
        inline CAccountManager *GetAccountManager(void)     {return(m_pAcctMgr);}
        inline ACCTTYPE GetAccountType(void)                {return(m_acctType);}
        inline ACCTDATA *GetAccountData(void)               {return(m_pData);}
        inline DWORD GetFlags(void)                         {return(m_dwFlags);}
        inline BOOL GetComplete(void)                       {return(m_fComplete);}
        inline UINT GetMigrateCount(void)                   {return(m_cMigInfo);}
        inline IICWApprentice *GetICW(void)                 {return(m_pICW);}
        
        inline BOOL GetSave(void)                           {return(m_fSave);}
        inline void SetSave(BOOL fSave)                     {m_fSave = fSave;}
        inline int GetSelection(void)                       {return(m_iSel);}
        inline void SetSelection(int iSel)                  {m_iSel = iSel;}
        inline BOOL NeedToReloadPage(DWORD dwPage)          {return(!!(m_dwReload & dwPage));}
        inline void SetPageReloaded(DWORD dwPage)           {m_dwReload &= ~dwPage;}
        inline void SetPageUnloaded(DWORD dwPage)           {m_dwReload |= dwPage;}
        inline BOOL GetSkipICW(void)                        {return(m_fSkipICW);}
        inline void SetSkipICW(BOOL fSkip)                  {m_fSkipICW = fSkip;}
        inline DWORD CountHTTPMailServers(void)             {return(m_cHttpServices);}
        inline HTTPMAILSERVICE *GetHTTPMailServices(void)   {return(m_pHttpServices);}
        inline DWORD CountMailServers(void)                 {return(m_cServices);}
        inline HTTPMAILSERVICE *GetMailServices(void)       {return(m_pServices);}

        friend INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
        friend HRESULT GetMessageParams(HWND hDlg, CICWApprentice ** ppApp, LONG * pOrd, const PAGEINFO ** ppPageInfo);

        BOOLEAN IsInternetConnection(void)
        {
            BOOLEAN retval;

            ((m_dwFlags & ACCT_WIZ_INTERNETCONNECTION) == 0) ? (retval = FALSE) : (retval = TRUE);
            return retval;
        }
};

typedef HRESULT (*PFNSUBNEWSGROUP)(IUserIdentity *, IImnAccount *, LPCSTR);

class CNewsGroupImport : public INewsGroupImport
{
    private:
        IImnAccount    *m_pAcct;
        ULONG           m_cRef;

    public:
        CNewsGroupImport(void);
        ~CNewsGroupImport(void);

        // IUnknown methods.
        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //INewsAccountImport methods
        HRESULT STDMETHODCALLTYPE Initialize(IImnAccount *pAcct);
        HRESULT STDMETHODCALLTYPE ImportSubList(LPCSTR pListGroups);
};

INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
                 
BOOL CALLBACK MailPromptInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK MailPromptOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT * puNextPage);

BOOL CALLBACK AcctInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK AcctOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT * puNextPage);
BOOL CALLBACK AcctCmdProc(CICWApprentice *pApp,HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK NameInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK NameOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT* puNextPage);
BOOL CALLBACK NameCmdProc(CICWApprentice *pApp,HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK AddressInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK AddressOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT* puNextPage);
BOOL CALLBACK AddressCmdProc(CICWApprentice *pApp,HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK ServerInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ServerOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT* puNextPage);
BOOL CALLBACK ServerCmdProc(CICWApprentice *pApp,HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK LogonInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK LogonOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT* puNextPage);
BOOL CALLBACK LogonCmdProc(CICWApprentice *pApp,HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK ResolveInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit );
BOOL CALLBACK ResolveOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT * puNextPage);
BOOL CALLBACK ResolveCmdProc(CICWApprentice *pApp,HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK ConnectInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK ConnectOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT* puNextPage);
BOOL CALLBACK ConnectCmdProc(CICWApprentice *pApp,HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK CompleteInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit );
BOOL CALLBACK CompleteOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT * puNextPage);

BOOL CALLBACK MigrateInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK MigrateOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT* puNextPage);

BOOL CALLBACK SelectInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit );
BOOL CALLBACK SelectOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT * puNextPage);

BOOL CALLBACK ConfirmInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit );
BOOL CALLBACK ConfirmOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT * puNextPage);

BOOL CALLBACK AutoDiscoveryInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit);
BOOL CALLBACK AutoDiscoveryOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage);
BOOL CALLBACK AutoDiscoveryCmdProc(CICWApprentice *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK AutoDiscoveryWMUserProc(CICWApprentice *pApp, HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK AutoDiscoveryCancelProc(CICWApprentice *pApp, HWND hDlg);

BOOL CALLBACK UseWebMailInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK UseWebMailOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT* puNextPage);
BOOL CALLBACK UseWebMailCmdProc(CICWApprentice *pApp,HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK GotoServerInfoInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK GotoServerInfoOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT* puNextPage);
BOOL CALLBACK GotoServerInfoCmdProc(CICWApprentice *pApp,HWND hDlg,WPARAM wParam,LPARAM lParam);

BOOL CALLBACK PassifierInitProc(CICWApprentice *pApp,HWND hDlg,BOOL fFirstInit);
BOOL CALLBACK PassifierOKProc(CICWApprentice *pApp,HWND hDlg,BOOL fForward,UINT* puNextPage);
BOOL CALLBACK PassifierCmdProc(CICWApprentice *pApp,HWND hDlg,WPARAM wParam,LPARAM lParam);



DWORD CommctrlMajor(void);
HRESULT CreateAccountName(CICWApprentice *pApp, ACCTDATA * pData);

#endif // _INC_ICWWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\icwacct.cpp ===
#include "pch.hxx"
#include <prsht.h>
#include <prshtp.h>
#include <imnact.h>
#include <acctman.h>
#include <icwacct.h>
#include "dllmain.h"
#include <acctimp.h>
#include "icwwiz.h"
#include "acctui.h"
#include "server.h"
#include <resource.h>
#include <demand.h>
#include "strconst.h"
#include <msident.h>
#include <shlwapi.h>
#include <autodiscovery.h>

ASSERTDATA

BOOL FGetSystemShutdownPrivledge(void);

typedef struct tagACCTWIZINIT
{
    ACCTTYPE type;
    ULONG iFirstPage;
    ULONG iLastPage;
} ACCTWIZINIT;

const static ACCTWIZINIT c_rgAcctInit[ACCT_LAST] =
{
    {
        ACCT_NEWS,
        ORD_PAGE_NEWSNAME,
        ORD_PAGE_NEWSCOMPLETE
    },
    {
        ACCT_MAIL,
        ORD_PAGE_MAILNAME,
        ORD_PAGE_MAILCOMPLETE
    },
    {
        ACCT_DIR_SERV,
        ORD_PAGE_LDAPINFO,
        ORD_PAGE_LDAPCOMPLETE
    },
};

const static ACCTWIZINIT c_rgAutoDiscoveryAcctInit =
{
    ACCT_MAIL,
    ORD_PAGE_AD_MAILADDRESS,
    ORD_PAGE_AD_MAILCOMPLETE
};

const static int c_rgidsNewAcct[ACCT_LAST] = {idsNewNewsAccount, idsNewMailAccount, idsNewLdapAccount};

//If you change this table please verify that the #defines and enumerations are correct in ids.h
const static PAGEINFO g_pRequestedPageInfo[NUM_WIZARD_PAGES] =
{
    { IDD_PAGE_MAILPROMPT,      idsMailPromptHeader,    MailPromptInitProc, MailPromptOKProc,   NULL,           NULL,           NULL,           0}, // exit
    { IDD_PAGE_MAILACCT,        idsMailAcctHeader,      AcctInitProc,       AcctOKProc,         AcctCmdProc,    NULL,           NULL,           0},
    { IDD_PAGE_MIGRATE,         idsMailMigrateHeader,   MigrateInitProc,    MigrateOKProc,      AcctCmdProc,    NULL,           NULL,           0},
    { IDD_PAGE_MAILACCTIMPORT,  idsMailImportHeader,    MigrateInitProc,    MigrateOKProc,      AcctCmdProc,    NULL,           NULL,           0},
    { IDD_PAGE_MIGRATESELECT,   idsMailSelectHeader,    SelectInitProc,     SelectOKProc,       NULL,           NULL,           NULL,           0},
    { IDD_PAGE_MAILCONFIRM,     idsConfirmHeader,       ConfirmInitProc,    ConfirmOKProc,      NULL,           NULL,           NULL,           0}, // exit
    { IDD_PAGE_MAILNAME,        idsYourNameHeader,      NameInitProc,       NameOKProc,         NameCmdProc,    NULL,           NULL,           0},
    { IDD_PAGE_MAILADDRESS,     idsMailAddressHeader,   AddressInitProc,    AddressOKProc,      AddressCmdProc, NULL,           NULL,           0},
    { IDD_PAGE_MAILSERVER,      idsMailServerHeader,    ServerInitProc,     ServerOKProc,       ServerCmdProc,  NULL,           NULL,           0}, // exit
    { IDD_PAGE_MAILLOGON,       idsMailLogonHeader,     LogonInitProc,      LogonOKProc,        LogonCmdProc,   NULL,           NULL,           0}, // exit
    { IDD_PAGE_CONNECT,         0,                      ConnectInitProc,    ConnectOKProc,      ConnectCmdProc, NULL,           NULL,           0},
    { IDD_PAGE_COMPLETE,        idsCompleteHeader,      CompleteInitProc,   CompleteOKProc,     NULL,           NULL,           NULL,           0},
    
    { IDD_PAGE_NEWSMIGRATE,     idsNewsMigrateHeader,   MigrateInitProc,    MigrateOKProc,      AcctCmdProc,    NULL,           NULL,           0},
    { IDD_PAGE_NEWSACCTIMPORT,  idsNewsImportHeader,    MigrateInitProc,    MigrateOKProc,      AcctCmdProc,    NULL,           NULL,           0},
    { IDD_PAGE_NEWSACCTSELECT,  idsNewsSelectHeader,    SelectInitProc,     SelectOKProc,       NULL,           NULL,           NULL,           0},
    { IDD_PAGE_NEWSCONFIRM,     idsConfirmHeader,       ConfirmInitProc,    ConfirmOKProc,      NULL,           NULL,           NULL,           0}, // exit
    { IDD_PAGE_NEWSNAME,        idsYourNameHeader,      NameInitProc,       NameOKProc,         NameCmdProc,    NULL,           NULL,           0},
    { IDD_PAGE_NEWSADDRESS,     idsNewsAddressHeader,   AddressInitProc,    AddressOKProc,      AddressCmdProc, NULL,           NULL,           0},
    { IDD_PAGE_NEWSINFO,        idsNewsServerHeader,    ServerInitProc,     ServerOKProc,       ServerCmdProc,  NULL,           NULL,           0}, // exit
    { IDD_PAGE_MAILLOGON,       idsNewsLogonHeader,     LogonInitProc,      LogonOKProc,        LogonCmdProc,   NULL,           NULL,           0}, // exit
    { IDD_PAGE_CONNECT,         0,                      ConnectInitProc,    ConnectOKProc,      ConnectCmdProc, NULL,           NULL,           0},
    { IDD_PAGE_COMPLETE,        idsCompleteHeader,      CompleteInitProc,   CompleteOKProc,     NULL,           NULL,           NULL,           0},
    
    { IDD_PAGE_LDAPINFO,        idsLdapServerHeader,    ServerInitProc,     ServerOKProc,       ServerCmdProc,  NULL,           NULL,           0},
    { IDD_PAGE_LDAPLOGON,       idsLdapLogonHeader,     LogonInitProc,      LogonOKProc,        LogonCmdProc,   NULL,           NULL,           0},
    { IDD_PAGE_LDAPRESOLVE,     idsLdapResolveHeader,   ResolveInitProc,    ResolveOKProc,      NULL,           NULL,           NULL,           0}, // exit
    { IDD_PAGE_COMPLETE,        idsCompleteHeader,      CompleteInitProc,   CompleteOKProc,     NULL,           NULL,           NULL,           0},

    { IDD_PAGE_MAILADDRESS,     idsMailAddressHeader,   AddressInitProc,    AddressOKProc,      AddressCmdProc, NULL,           NULL,           0},
    { IDD_PAGE_PASSIFIER,       idsAutoDiscoveryDescTitle,   PassifierInitProc, PassifierOKProc, PassifierCmdProc,  NULL,       NULL,           0},
    { IDD_PAGE_AUTODISCOVERY,   idsAutoDiscoveryDescTitle,   AutoDiscoveryInitProc, AutoDiscoveryOKProc, AutoDiscoveryCmdProc,  AutoDiscoveryWMUserProc,           AutoDiscoveryCancelProc,           0},
    { IDD_PAGE_USEWEBMAIL,      idsAutoDiscoveryDescTitle,   UseWebMailInitProc, UseWebMailOKProc, UseWebMailCmdProc,  NULL,    NULL,           0},
    { IDD_PAGE_GOTOSERVERINFO,  idsAutoDiscoveryDescTitle,   GotoServerInfoInitProc, GotoServerInfoOKProc, GotoServerInfoCmdProc,  NULL, NULL,  0},
    { IDD_PAGE_MAILSERVER,      idsMailServerHeader,    ServerInitProc,     ServerOKProc,       ServerCmdProc,  NULL,           NULL,           0}, // exit
    { IDD_PAGE_MAILNAME,        idsYourNameHeader,      NameInitProc,       NameOKProc,         NameCmdProc,    NULL,           NULL,           0},
    { IDD_PAGE_MAILLOGON,       idsMailLogonHeader,     LogonInitProc,      LogonOKProc,        LogonCmdProc,   NULL,           NULL,           0}, // exit
    { IDD_PAGE_CONNECT,         0,                      ConnectInitProc,    ConnectOKProc,      ConnectCmdProc, NULL,           NULL,           0},
    { IDD_PAGE_COMPLETE,        idsCompleteHeader,      CompleteInitProc,   CompleteOKProc,     NULL,           NULL,           NULL,           0},
};

const static UINT c_rgOrdNewAcct[ACCT_LAST] =
{
    ORD_PAGE_NEWSCONNECT,
    ORD_PAGE_MAILCONNECT,
    ORD_PAGE_LDAPCOMPLETE
};

const static UINT c_rgOEOrdNewAcct[ACCT_LAST] =
{
    ORD_PAGE_NEWSCOMPLETE,
    ORD_PAGE_MAILCOMPLETE,
    ORD_PAGE_LDAPCOMPLETE
};


BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = (ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES | ICC_COOL_CLASSES | ICC_INTERNET_CLASSES | ICC_PAGESCROLLER_CLASS | ICC_NATIVEFNTCTL_CLASS | ICC_LISTVIEW_CLASSES);
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}


HRESULT GetAcctConnectInfo(CAccount *pAcct, ACCTDATA *pData)
{
    HRESULT hr;
    DWORD dw;
    
    hr = pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dw);
    if (SUCCEEDED(hr))
    {
        pData->dwConnect = dw;
//        if (dw == CONNECTION_TYPE_RAS || dw == CONNECTION_TYPE_INETSETTINGS)
        if (dw == CONNECTION_TYPE_RAS)
            hr = pAcct->GetPropSz(AP_RAS_CONNECTOID, pData->szConnectoid, ARRAYSIZE(pData->szConnectoid));
    }
    
    return(hr);
}

BOOL GetRequiredAccountProp(CAccount *pAcct, DWORD dwProp, char *psz, ULONG cch)
{
    HRESULT hr;
    
    Assert(pAcct != NULL);
    Assert(psz != NULL);
    
    hr = pAcct->GetPropSz(dwProp, psz, cch);
    
    return(SUCCEEDED(hr) && !FIsEmpty(psz));
}

CICWApprentice::CICWApprentice(void)
{
    DllAddRef();
    m_cRef = 1;
    m_fInit = FALSE;
    m_fReboot = FALSE;
    m_pExt = NULL;
    m_pPageInfo = NULL;
    m_pInitInfo = NULL;
    
    m_cPages = 0;
    m_idPrevPage = 0;
    m_idNextPage = 0;
    m_iCurrentPage = 0;
    ZeroMemory(m_iPageHistory, sizeof(m_iPageHistory));
    m_cPagesCompleted = 0;
    
    m_hDlg = NULL;
    m_rgPage = NULL;
    m_extFirstPage = 0;
    m_extLastPage = 0;
    
    m_pAcctMgr = NULL;
    m_pAcct = NULL;
    m_dwFlags = 0;
    m_pICW = 0;
    m_acctType = (ACCTTYPE)-1;
    
    m_fSave = FALSE;
    m_fSkipICW = FALSE;
    m_dwReload = 0;
    m_iSel = 0;
    m_fMigrate = FALSE;
    m_fComplete = FALSE;

    // The user can turn the feature on and off with the SZ_REGVALUE_AUTODISCOVERY regkey.
    // The admin can turn the policy blocking the feature on and off with SZ_REGVALUE_AUTODISCOVERY_POLICY.
    m_fUseAutoDiscovery = (SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_AUTODISCOVERY, FALSE, FALSE) &&
                           SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY_POLICY, SZ_REGVALUE_AUTODISCOVERY_POLICY, FALSE, TRUE));
    if (m_fUseAutoDiscovery)
    {
        IMailAutoDiscovery * pMailAutoDiscovery;

        // Let's make sure our API is installed and available.  I'm being robust because it's better safe than sorry.
        if (SUCCEEDED(CoCreateInstance(CLSID_MailAutoDiscovery, NULL, CLSCTX_INPROC_SERVER, IID_IMailAutoDiscovery, (void **)&pMailAutoDiscovery)))
        {
            pMailAutoDiscovery->Release();
        }
        else
        {
            m_fUseAutoDiscovery = FALSE;    // We can't use it.
        }
    }

    m_pData = NULL;
    
    m_pMigInfo = NULL;
    m_cMigInfo = 0;
    m_iMigInfo = -1;

    m_pHttpServices = NULL;
    m_cHttpServices = 0;

    m_pServices = NULL;
    m_cServices = 0;
}

CICWApprentice::~CICWApprentice()
{
    int i;
    
    if (m_pAcctMgr != NULL)
        m_pAcctMgr->Release();
    
    if (m_pAcct != NULL)
        m_pAcct->Release();
    
    if (m_pExt != NULL)
        m_pExt->Release();
    
    if (m_pData != NULL)
    {
        if (m_pData->pAcct != NULL)
            m_pData->pAcct->Release();
        
        MemFree(m_pData);
    }
    
    if (m_pInitInfo != NULL)
        MemFree(m_pInitInfo);
    
    if (m_pICW != NULL)
        m_pICW->Release();
    
    if (m_pMigInfo != NULL)
    {
        for (i = 0; i < m_cMigInfo; i++)
        {
            Assert(m_pMigInfo[i].pImp != NULL);
            m_pMigInfo[i].pImp->Release();
            if (m_pMigInfo[i].pImp2 != NULL)
                m_pMigInfo[i].pImp2->Release();
        }
        MemFree(m_pMigInfo);
    }

    if (m_pServices != NULL)
        MemFree(m_pServices);

    if (m_pHttpServices != NULL)
        MemFree(m_pHttpServices);

    DllRelease();
}

STDMETHODIMP CICWApprentice::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (ppv == NULL)
        return(E_INVALIDARG);
    
    *ppv = NULL;
    
    // IID_IICWApprentice
    if (IID_IICWApprentice == riid)
        *ppv = (void *)(IICWApprentice *)this;
    // IID_IICWExtension
    else if (IID_IICWExtension == riid)
        *ppv = (void *)(IICWExtension *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);
    
    ((LPUNKNOWN)*ppv)->AddRef();
    
    return(S_OK);
}

STDMETHODIMP_(ULONG) CICWApprentice::AddRef(VOID)
{
    return(++m_cRef);
}

STDMETHODIMP_(ULONG) CICWApprentice::Release(VOID)
{
    if (--m_cRef == 0)
    {
        delete this;
        return(0);
    }
    return(m_cRef);
}

// this Initialize is called only by the ICW (in apprentice mode)
HRESULT CICWApprentice::Initialize(IICWExtension *pExt)
{
    DWORD cb, dwUserID;
    HRESULT hr;
    IUserIdentityManager *pIdMan = NULL;
    IUserIdentity *pUser = NULL;
    GUID *pguid;

    if (pExt == NULL)
        return(E_INVALIDARG);
    
    if (m_fInit)
        return E_UNEXPECTED;

    Assert(m_pExt == NULL);
    
    Assert(!m_pData);
    Assert(!m_pInitInfo);
    Assert(m_pAcctMgr == NULL);
    
    cb = sizeof(ACCTDATA) * ACCT_LAST;
    if (!MemAlloc((void **)&m_pData, cb))
    {
        TrapError(hr = E_OUTOFMEMORY);
        goto exit;
    }
    ZeroMemory(m_pData, cb);
    
    cb = sizeof(DLGINITINFO) * NUM_WIZARD_PAGES;
    if (!MemAlloc((void **)&m_pInitInfo, cb))
    {
        TrapError(hr = E_OUTOFMEMORY);
        goto exit;
    }        
    ZeroMemory(m_pInitInfo, cb);
    
    hr = HrCreateAccountManager((IImnAccountManager **)&m_pAcctMgr);
    if (FAILED(hr))
        goto exit;

    Assert(m_pAcctMgr != NULL);

    if (m_pAcctMgr->FNoModifyAccts())
    {
       hr = E_FAIL;
       goto exit;
    }

    if (SUCCEEDED(CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, IID_IUserIdentityManager, (LPVOID *)&pIdMan)))
    {
        Assert(pIdMan != NULL);

        pguid = (GUID*)&UID_GIBC_CURRENT_USER;

        // Avoid showing UI so try current, if no current, use default
        if (SUCCEEDED(pIdMan->GetIdentityByCookie(pguid, &pUser)))
            pUser->Release();
        else
            pguid = (GUID*)&UID_GIBC_DEFAULT_USER;
        
        pIdMan->Release();

        hr = m_pAcctMgr->InitUser(NULL, *pguid, 0);
    }
    else
        hr = m_pAcctMgr->Init(NULL);
            
    if (FAILED(hr))
        goto exit;

    m_pExt = pExt;
    m_pExt->AddRef();
    
    m_pPageInfo = g_pRequestedPageInfo;
    
    Assert(m_dwFlags == 0);
    m_dwFlags = (ACCT_WIZ_IN_ICW | ACCT_WIZ_HTTPMAIL);
    
    m_acctType = ACCT_MAIL;
    m_fInit = TRUE;
    
    InitHTTPMailServices();

    return(S_OK);

// Only go here if something has gone wrong and function will fail
exit:
    Assert(FAILED(hr));
    SafeMemFree(m_pData);
    SafeMemFree(m_pInitInfo);
    SafeRelease(m_pAcctMgr);
    return hr;
}

HRESULT CICWApprentice::AddWizardPages(DWORD dwFlags)
{
    BOOL fRet;
    char sz[CCHMAX_STRINGRES];
    DWORD type;
    UINT rgid[NUM_WIZARD_PAGES];
    UINT idFirstPage, idLastPage;
    HPROPSHEETPAGE hWizPage[NUM_WIZARD_PAGES];
    PROPSHEETPAGE psPage;
    ULONG nPageIndex, dlgID;
    HRESULT hr;

    _InitComCtl32();    // So we can use the ICC_ANIMATE_CLASS common controls.
    if (m_pAcctMgr->FNoModifyAccts())
        return(E_FAIL);
 
    hr = m_pAcctMgr->GetAccountCount(ACCT_MAIL, &type);
    if (FAILED(hr))
        return(hr);
    else if (type == 0)
    {
        hr = InitializeMigration(0);
        if (FAILED(hr))
            return(hr);
    }
    
    hr = S_OK;
    
    ZeroMemory(hWizPage, sizeof(hWizPage));   // hWizPage is an array
    ZeroMemory(rgid, sizeof(rgid));
    ZeroMemory(&psPage, sizeof(PROPSHEETPAGE));
    
    psPage.dwSize = sizeof(psPage);
    psPage.dwFlags = PSP_DEFAULT | PSP_USEHEADERTITLE;
    psPage.hInstance = g_hInstRes;
    psPage.pfnDlgProc = GenDlgProc;
    
    idFirstPage = g_pRequestedPageInfo[ICW_FIRST_PAGE].uDlgID;
    idLastPage = g_pRequestedPageInfo[ICW_LAST_PAGE].uDlgID;
    
    // create a property sheet page for each page in the wizard
    for (nPageIndex = ICW_FIRST_PAGE; nPageIndex <= ICW_LAST_PAGE; nPageIndex++)
    {
        dlgID = g_pRequestedPageInfo[nPageIndex].uDlgID;
        Assert(dlgID >= EXTERNAL_DIALOGID_MINIMUM);
        Assert(dlgID <= EXTERNAL_DIALOGID_MAXIMUM);
        
        m_pInitInfo[m_cPages].pApp = this;
        m_pInitInfo[m_cPages].ord = nPageIndex;
        psPage.lParam = (LPARAM)&m_pInitInfo[m_cPages];
        psPage.pszTemplate = MAKEINTRESOURCE(dlgID);
        LoadString(g_hInstRes, g_pRequestedPageInfo[nPageIndex].uHdrID, sz, ARRAYSIZE(sz));
        psPage.pszHeaderTitle = sz;
        
        hWizPage[m_cPages] = CreatePropertySheetPage(&psPage);
        if (hWizPage[m_cPages] == NULL ||
            !m_pExt->AddExternalPage(hWizPage[m_cPages], dlgID))
        {
            hr = E_FAIL;
            break;
        }
        
        rgid[m_cPages] = dlgID;
        m_cPages++;
    }
    
    if (SUCCEEDED(hr))
    {
        m_pExt->SetFirstLastPage(idFirstPage, idLastPage);
    }
    else
    {
        for (nPageIndex = 0; nPageIndex <= m_cPages; nPageIndex++)
        {
            if (hWizPage[nPageIndex] != NULL)
            {
                DestroyPropertySheetPage(hWizPage[nPageIndex]);
                
                if (rgid[nPageIndex] != 0)
                    m_pExt->RemoveExternalPage(hWizPage[nPageIndex], rgid[nPageIndex]);
            }
        }
    }
    
    return(hr);
}

HRESULT CICWApprentice::SetPrevNextPage(UINT uPrevPage, UINT uNextPage)
{
    if (uPrevPage != 0)
        m_idPrevPage = uPrevPage;
    
    if (uNextPage != 0)
        m_idNextPage = uNextPage;
    
    Assert(m_idPrevPage != 0);
    Assert(m_idNextPage != 0);
    
    return(S_OK);
}

HRESULT CICWApprentice::GetConnectionInformation(CONNECTINFO *pInfo)
{
    return(E_NOTIMPL);
}

HRESULT CICWApprentice::SetConnectionInformation(CONNECTINFO *pInfo)
{
    ACCTDATA *pData;
    DWORD type;
    
    Assert(CONNECT_LAN == CONNECTION_TYPE_LAN);
    Assert(CONNECT_MANUAL == CONNECTION_TYPE_MANUAL);
    Assert(CONNECT_RAS == CONNECTION_TYPE_RAS);
    
    if (pInfo == NULL || pInfo->type > CONNECT_RAS)
        return(E_INVALIDARG);
    
    pData = m_pData;
    for (type = ACCT_NEWS; type < ACCT_LAST; type++)
    {
        pData->dwConnect = pInfo->type;
//        if (pData->dwConnect == CONNECTION_TYPE_RAS || pData->dwConnect == CONNECTION_TYPE_INETSETTINGS)
        if (pData->dwConnect == CONNECTION_TYPE_RAS)
            StrCpyN(pData->szConnectoid, pInfo->szConnectoid, ARRAYSIZE(pData->szConnectoid));
        pData++;
    }
    
    return(S_OK);
}

const static c_rgError[ACCT_LAST] =
{
    ERR_NEWS_ACCT,
    ERR_MAIL_ACCT,
    ERR_DIRSERV_ACCT
};

HRESULT CICWApprentice::Save(HWND hwnd, DWORD *pdwError)
{
    HRESULT hr;
    CAccount *pAcct;
    
    if (pdwError == NULL)
        return(E_INVALIDARG);
    
    hr = S_OK;
    *pdwError = 0;
    
    if (m_fSave)
    {
        if (m_fMigrate || m_pData->szAcctOrig[0] == 0)
            hr = m_pAcctMgr->CreateAccountObject(m_acctType, (IImnAccount **)&pAcct);
        else
            hr = m_pAcctMgr->FindAccount(AP_ACCOUNT_NAME, m_pData->szAcctOrig, (IImnAccount **)&pAcct);
        
        if (FAILED(hr))
        {
            *pdwError = c_rgError[m_acctType];
        }
        else
        {
            hr = SaveAccountData(pAcct, m_acctType != ACCT_DIR_SERV);
            if (FAILED(hr))
                *pdwError = c_rgError[m_acctType];
            
            pAcct->Release();
        }
        
        m_fSave = FALSE;
    }
    
    return(hr);
}

HRESULT CICWApprentice::InitHTTPMailServices()
{
    HKEY    hkey = NULL, hkeyT = NULL;
    LONG    lResult;
    HRESULT hr = S_OK;
    DWORD   cServices, cb, i, type, dwFlagsT;
    BOOL    fHideHotmail;

    m_cServices = 0;
    if (!AcctUtil_IsHTTPMailEnabled() || ((ACCT_WIZ_HTTPMAIL & m_dwFlags) == 0))
        return S_OK;

    fHideHotmail = AcctUtil_HideHotmail();

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szHTTPMailServiceRoot, 0, KEY_READ, &hkey))
    {
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey, NULL, NULL, 0, &cServices, NULL, NULL, NULL, NULL, NULL, NULL, NULL) &&
            cServices > 0)
        {
            HTTPMAILSERVICE     hmsNew;
            cb = sizeof(HTTPMAILSERVICE) * cServices;
            if (!MemAlloc((void **)&m_pServices, cb))
            {
                hr = E_OUTOFMEMORY;
                goto out;
            }

            if (!MemAlloc((void **)&m_pHttpServices, cb))
            {
                MemFree(m_pServices);
                hr = E_OUTOFMEMORY;
                goto out;
            }
                
            ZeroMemory(m_pServices, cb);
            ZeroMemory(m_pHttpServices, cb);

            // Start Enumerating the keys
            for (i = 0; i < cServices; i++)
            {
                BOOL    fHttp, fSignup;

                ZeroMemory(&hmsNew, sizeof(hmsNew));
                fHttp = fSignup = false;

                // Enumerate Friendly Names
                cb = sizeof(hmsNew.szDomain);
                lResult = RegEnumKeyEx(hkey, i, hmsNew.szDomain, &cb, 0, NULL, NULL, NULL);
        
                // No more items
                if (lResult == ERROR_NO_MORE_ITEMS)
                    break;
        
                // Error, lets move onto the next account
                if (lResult != ERROR_SUCCESS)
                {
                    Assert(FALSE);
                    continue;
                }
        
                if (ERROR_SUCCESS == RegOpenKeyEx(hkey, hmsNew.szDomain, 0, KEY_QUERY_VALUE, &hkeyT))
                {
                    cb = sizeof(DWORD);
                    dwFlagsT = 0;
                    RegQueryValueEx(hkeyT, c_szHTTPMailDomainMSN, NULL, &type, (LPBYTE)&dwFlagsT, &cb);
                    hmsNew.fDomainMSN = (dwFlagsT == 1);
                    
                    if (!fHideHotmail || !hmsNew.fDomainMSN)
                    {
                        cb = sizeof(DWORD);
                        dwFlagsT = 0;
                        RegQueryValueEx(hkeyT, c_szHTTPMailEnabled, NULL, &type, (LPBYTE)&dwFlagsT, &cb);
                    
                        fHttp = (dwFlagsT == 1);

                        cb = CCHMAX_SERVICENAME;
                        if (ERROR_SUCCESS != RegQueryValueEx(hkeyT, c_szHTTPMailServiceName, NULL, &type, (LPBYTE)&hmsNew.szFriendlyName, &cb) || hmsNew.szFriendlyName[0] == 0)
                            goto next;

                        fSignup = true;
                        cb = MAX_PATH;
                        if (ERROR_SUCCESS != RegQueryValueEx(hkeyT, c_szHTTPMailSignUp, NULL, &type, (LPBYTE)&hmsNew.szSignupUrl, &cb) || hmsNew.szSignupUrl[0] == 0)
                            fSignup = false;
                    
                        cb = MAX_PATH;
                        RegQueryValueEx(hkeyT, c_szHTTPMailServer, NULL, &type, (LPBYTE)&hmsNew.szRootUrl, &cb);
                        if (hmsNew.szRootUrl[0] == 0)
                            fHttp = false;
                    
                        hmsNew.fHTTPEnabled = fHttp;

                        cb = sizeof(DWORD);
                        dwFlagsT = 0;
                        RegQueryValueEx(hkeyT, c_szHTTPMailUseWizard, NULL, &type, (LPBYTE)&dwFlagsT, &cb);
                        hmsNew.fUseWizard = (dwFlagsT == 1);

                        if (fHttp)
                            m_pHttpServices[m_cHttpServices++] = hmsNew;

                        if (fSignup)
                            m_pServices[m_cServices++] = hmsNew;
                    }

next:
                    RegCloseKey(hkeyT);
                }
            }
        }
    }

out:
    if (NULL != hkey)
        RegCloseKey(hkey);

    return hr;
}

HRESULT CICWApprentice::Initialize(CAccountManager *pAcctMgr, CAccount *pAcct)
{
    Assert(pAcctMgr != NULL);
    Assert(pAcct != NULL);
    Assert(!m_fInit);
    
    Assert(m_pExt == NULL);
    Assert(m_pAcctMgr == NULL);
    Assert(m_pAcct == NULL);
    
    if (!MemAlloc((void **)&m_pData, sizeof(ACCTDATA)))
        return(E_OUTOFMEMORY);
    ZeroMemory(m_pData, sizeof(ACCTDATA));
    
    if (!MemAlloc((void **)&m_pInitInfo, sizeof(DLGINITINFO) * NUM_WIZARD_PAGES))
        return(E_OUTOFMEMORY);
    ZeroMemory(m_pInitInfo, sizeof(DLGINITINFO) * NUM_WIZARD_PAGES);
    
    m_pAcctMgr = pAcctMgr;
    m_pAcctMgr->AddRef();
    
    m_pAcct = pAcct;
    m_pAcct->AddRef();
    
    m_pAcct->GetAccountType(&m_acctType);
    
    m_pPageInfo = g_pRequestedPageInfo;
    
    m_fInit = TRUE;
    
    return(S_OK);
}

int CALLBACK AcctPropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    DLGTEMPLATE *pDlg;

    if (uMsg == PSCB_PRECREATE)
    {
        pDlg = (DLGTEMPLATE *)lParam;
        
        if (!!(pDlg->style & DS_CONTEXTHELP))
            pDlg->style &= ~DS_CONTEXTHELP;
    }

    return(0);
}

HRESULT CICWApprentice::DoWizard(HWND hwnd, CLSID *pclsid, DWORD dwFlags)
{
    TCHAR sz[CCHMAX_STRINGRES];
    int iRet;
    const ACCTWIZINIT *pinit;
    PROPSHEETPAGE psPage;
    PROPSHEETHEADER psHeader;
    UINT nPageIndex, cAccts, dlgID, szID;
    HRESULT hr;
    INITCOMMONCONTROLSEX    icex = { sizeof(icex), ICC_FLAGS };
    
    Assert(m_pAcct != NULL);
    
    if (m_acctType == ACCT_MAIL || m_acctType == ACCT_NEWS)
    {
        if (pclsid != NULL)
        {
            hr = InitializeImport(*pclsid, dwFlags);
            if (FAILED(hr))
                return(hr);
            
            Assert(m_cMigInfo == 1);
        }
        else if (!!(dwFlags & (ACCT_WIZ_MIGRATE | ACCT_WIZ_MAILIMPORT | ACCT_WIZ_NEWSIMPORT)))
        {
            hr = InitializeMigration(dwFlags);
            if (FAILED(hr))
                return(hr);
            
            if (!!(dwFlags & (ACCT_WIZ_MAILIMPORT | ACCT_WIZ_NEWSIMPORT)))
            {
                if (m_cMigInfo == 0)
                    return(E_NoAccounts);
            }
        }
    }
    
    if (!MemAlloc((void **)&m_rgPage, NUM_WIZARD_PAGES * sizeof(HPROPSHEETPAGE)))
        return(E_OUTOFMEMORY);
    m_cPageBuf = NUM_WIZARD_PAGES;
    
    InitCommonControlsEx(&icex);

    hr = InitAccountData(m_pAcct, NULL, FALSE);
    Assert(!FAILED(hr));
    
    ZeroMemory(&psPage, sizeof(PROPSHEETPAGE));
    ZeroMemory(&psHeader, sizeof(PROPSHEETHEADER));
    
    psPage.dwSize = sizeof(psPage);
    psPage.dwFlags = PSP_DEFAULT | PSP_USEHEADERTITLE;
    psPage.hInstance = g_hInstRes;
    psPage.pfnDlgProc = GenDlgProc;
    
    pinit = &c_rgAcctInit[m_acctType];
    Assert(pinit->type == m_acctType);
    
    if (m_cMigInfo > 0)
    {
        if (pclsid != NULL)
        {
            hr = HandleMigrationSelection(0, &nPageIndex, hwnd);
            if (FAILED(hr))
                goto exit;
            
            m_dwFlags |= ACCT_WIZ_IMPORT_CLIENT;
        }
        else if (!!(dwFlags & ACCT_WIZ_MAILIMPORT))
        {
            nPageIndex = ORD_PAGE_MAILACCTIMPORT;
        }
        else if (!!(dwFlags & ACCT_WIZ_NEWSIMPORT))
        {
            nPageIndex = ORD_PAGE_NEWSACCTIMPORT;
        }
        else
        {
            Assert(m_acctType == ACCT_MAIL || m_acctType == ACCT_NEWS);
            nPageIndex = (m_acctType == ACCT_MAIL) ? ORD_PAGE_MIGRATE : ORD_PAGE_NEWSMIGRATE;
        }
        
        m_dwFlags |= ACCT_WIZ_MIGRATE;
    }
    else
    {
        if ((ACCT_MAIL == m_acctType) && m_fUseAutoDiscovery)
        {
            // In this case, we want to change the range to
            // ORD_PAGE_AD_MAILNAME to ORD_PAGE_AD_MAILCOMPLETE;
            pinit = &c_rgAutoDiscoveryAcctInit;
        }

        nPageIndex = pinit->iFirstPage;
        m_dwFlags |= (dwFlags & ACCT_WIZ_NO_NEW_POP);
    }
    
    m_dwFlags |= (dwFlags & ACCT_WIZ_INTERNETCONNECTION);
    m_dwFlags |= (dwFlags & ACCT_WIZ_HTTPMAIL);
    m_dwFlags |= (dwFlags & ACCT_WIZ_OE);

    if (m_acctType == ACCT_MAIL)
        InitHTTPMailServices();
    
    // create a property sheet page for each page in the wizard
    for ( ; nPageIndex <= pinit->iLastPage; nPageIndex++)
    {
        dlgID = g_pRequestedPageInfo[nPageIndex].uDlgID;
        Assert(dlgID >= EXTERNAL_DIALOGID_MINIMUM);
        Assert(dlgID <= EXTERNAL_DIALOGID_MAXIMUM);
        
        m_pInitInfo[m_cPages].pApp = this;
        m_pInitInfo[m_cPages].ord = nPageIndex;
        psPage.lParam = (LPARAM)&m_pInitInfo[m_cPages];
        psPage.pszTemplate = MAKEINTRESOURCE(dlgID);
        
        if (dlgID == IDD_PAGE_CONNECT)
        {
            if (m_dwFlags & ACCT_WIZ_INTERNETCONNECTION)
                continue;
            else
                szID = ((m_acctType == ACCT_MAIL) ? idsMailConnectHeader : idsNewsConnectHeader);
        }
        else
            szID = g_pRequestedPageInfo[nPageIndex].uHdrID;
            
            LoadString(g_hInstRes, szID, sz, ARRAYSIZE(sz));
            psPage.pszHeaderTitle = sz;
            
            m_rgPage[m_cPages] = CreatePropertySheetPage(&psPage);
            if (m_rgPage[m_cPages] == NULL)
            {
                hr = E_FAIL;
                break;
            }
            m_cPages++;
    }
    
exit:
    if (!FAILED(hr))
    {
        DWORD dwMajor = CommctrlMajor();

        if (m_acctType != ACCT_DIR_SERV)
            InitializeICW(m_acctType, m_acctType == ACCT_MAIL ? IDD_PAGE_MAILLOGON : IDD_PAGE_NEWSINFO, IDD_PAGE_COMPLETE);
        
        m_idPrevPage = -1;
        m_idNextPage = -1;
        
        psHeader.dwSize = sizeof(PROPSHEETHEADER);
        
        // OE Bug 71023
        // Wiz97 app compat related
        if (dwMajor >= 4)
        {
            if (dwMajor >= 5)
                psHeader.dwFlags = PSH_WIZARD97IE5 | PSH_STRETCHWATERMARK | PSH_WATERMARK;
            else
                psHeader.dwFlags = PSH_WIZARD97IE4;

            psHeader.dwFlags |= PSH_USEPAGELANG | PSH_HEADER;
        }
        else
        {
            // Something has gone wrong
            AssertSz(FALSE, "Commctrl has a major ver of less than 4!");
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            // As long as commctrl was okay

            psHeader.hwndParent = hwnd;
            psHeader.hInstance = g_hInstRes;
            psHeader.nPages = m_cPages;
            psHeader.phpage = m_rgPage;
            psHeader.pszbmWatermark = MAKEINTRESOURCE(idbICW);
            psHeader.pszbmHeader = 0;
            psHeader.pfnCallback = AcctPropSheetProc;
        
        
            iRet = (int) PropertySheet(&psHeader);
            if (iRet == -1)
            {
                hr = E_FAIL;
            }
            else if (m_fReboot)
            {
                if (FGetSystemShutdownPrivledge() && ExitWindowsEx(EWX_REBOOT,0))
                    hr = S_FALSE;
                else
                    hr = E_FAIL;
            }
            else if (iRet == 0)
            {
                hr = S_FALSE;
            }
            else
            {
                hr = S_OK;
            }
        }
        
        if (m_pICW != NULL)
        {
            m_pICW->Release();
            m_pICW = NULL;
        }
    }
    else
    {
        for (nPageIndex = 0; nPageIndex < m_cPages; nPageIndex++)
        {
            if (m_rgPage[nPageIndex] != NULL)
                DestroyPropertySheetPage(m_rgPage[nPageIndex]);
        }
    }
    
    MemFree(m_rgPage);
    
    return(hr);
    }
    
BOOL STDMETHODCALLTYPE CICWApprentice::AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID)
{
    UINT cPages;
    
    Assert(m_hDlg == NULL);
    Assert(m_rgPage != NULL);
    Assert(m_cPages > 0);
    Assert(m_cPages <= m_cPageBuf);
    
    if (hPage == NULL || uDlgID == 0)
        return(FALSE);
    
    if (m_cPages == m_cPageBuf)
    {
        cPages = m_cPageBuf + NUM_WIZARD_PAGES;
        if (!MemRealloc((void **)&m_rgPage, cPages * sizeof(HPROPSHEETPAGE)))
            return(FALSE);
        m_cPageBuf = cPages;
    }
    
    m_rgPage[m_cPages] = hPage;
    m_cPages++;
    
    return(TRUE);
}

BOOL STDMETHODCALLTYPE CICWApprentice::RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID)
{
    Assert(m_hDlg == NULL);
    
    // TODO: implement this
    
    return(FALSE);
}

BOOL STDMETHODCALLTYPE CICWApprentice::ExternalCancel(CANCELTYPE type)
{
    BOOL fCancel;
    
    if (m_hDlg == NULL)
    {
        AssertSz(FALSE, "i don't think that this should be called yet");
        return(FALSE);
    }
    
    switch (type)
    {
        case CANCEL_PROMPT:
            fCancel = (IDYES == AcctMessageBox(m_hDlg, MAKEINTRESOURCE(idsConnectionWizard), MAKEINTRESOURCE(idsCancelWizard), NULL, MB_YESNO|MB_ICONEXCLAMATION |MB_DEFBUTTON2));
            break;
        
        case CANCEL_SILENT:
            PropSheet_PressButton(m_hDlg, PSBTN_CANCEL);
            fCancel = TRUE;
            break;
        
        case CANCEL_REBOOT:
            PropSheet_PressButton(m_hDlg, PSBTN_CANCEL);
            m_fReboot = TRUE;
            fCancel = TRUE;
            break;
        
        default:
            AssertSz(FALSE, "unexpected value");
            fCancel = FALSE;
            break;
    }
    
    return(fCancel);
}

BOOL STDMETHODCALLTYPE CICWApprentice::SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID)
{
    if (uFirstPageDlgID != 0)
        m_extFirstPage = uFirstPageDlgID;
    if (uLastPageDlgID != 0)
        m_extLastPage = uLastPageDlgID;
    
    Assert(m_extFirstPage != 0);
    Assert(m_extLastPage != 0);
    
    return(TRUE);
}

void CICWApprentice::InitializeICW(ACCTTYPE type, UINT uPrev, UINT uNext)
{
    HRESULT hr;
    CONNECTINFO info;
    IImnAccount *pAcct;
    
    Assert(m_pAcct != NULL);
    
    ZeroMemory(&info, sizeof(CONNECTINFO));
    info.cbSize = sizeof(CONNECTINFO);
    
    if (SUCCEEDED(m_pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &info.type)))
    {
        if (info.type == CONNECT_RAS)
            m_pAcct->GetPropSz(AP_RAS_CONNECTOID, info.szConnectoid, ARRAYSIZE(info.szConnectoid));
    }
    else
    {
        info.type = CONNECT_RAS;
        
        if (SUCCEEDED(m_pAcctMgr->GetDefaultAccount(type, &pAcct)))
        {
            if (SUCCEEDED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &info.type)))
            {
                if (info.type == CONNECT_RAS)
                    pAcct->GetPropSz(AP_RAS_CONNECTOID, info.szConnectoid, ARRAYSIZE(info.szConnectoid));
            }
            
            pAcct->Release();
        }
    }
    
    if ((m_dwFlags & ACCT_WIZ_INTERNETCONNECTION) == 0)
    {
        // get the ICW connection apprentice
        hr = CoCreateInstance(CLSID_ApprenticeICW, NULL, CLSCTX_INPROC_SERVER, IID_IICWApprentice, (void **)&m_pICW);
        if (SUCCEEDED(hr))
        {
            Assert(m_pICW != NULL);
            
            if (FAILED(m_pICW->Initialize((IICWExtension *)this)) ||
                FAILED(m_pICW->AddWizardPages(WIZ_USE_WIZARD97)))
            {
                m_pICW->Release();
                m_pICW = NULL;
            }
            
            hr = m_pICW->SetConnectionInformation(&info);
            Assert(!FAILED(hr));
            
            hr = m_pICW->SetPrevNextPage(uPrev, uNext);
            Assert(!FAILED(hr));
            
        }
    }
}

const static TCHAR c_szRegAcctImport[] = TEXT("Software\\Microsoft\\Internet Account Manager\\Import");
const static TCHAR c_szRegFlags[] = TEXT("Flags");

#define IMPORT_ONLY_OUTLOOK 0x0001
#define IMPORT_NO_OUTLOOK   0x0002
#define IMPORT_NEWS         0x0004

HRESULT CICWApprentice::InitializeMigration(DWORD dwFlags)
{
    HRESULT             hr = S_OK;
    LONG                lResult;
    BOOL                fOutlook, 
                        fMailAcct;
    DWORD               cImp, 
                        cb, 
                        i, 
                        cAcct, 
                        type, 
                        dwFlagsT;
    TCHAR               szCLSID[MAX_PATH];
    HKEY                hkey, 
                        hkeyT;
    LPWSTR              pwszCLSID = NULL;
    CLSID               clsid;
    IAccountImport     *pImp = NULL;
    IAccountImport2    *pImp2 = NULL;
    
    Assert(m_pMigInfo == NULL);
    Assert(m_cMigInfo == 0);
    Assert(m_pAcctMgr != NULL);
    
    hr = S_OK;
    fOutlook = !!(dwFlags & ACCT_WIZ_OUTLOOK);
    fMailAcct = (m_acctType == ACCT_MAIL);
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegAcctImport, 0, KEY_READ, &hkey))
    {
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey, NULL, NULL, 0, &cImp, NULL, NULL, NULL, NULL, NULL, NULL, NULL) &&
            cImp > 0)
        {
            cb = sizeof(MIGRATEINFO) * cImp;
            IF_NULLEXIT(MemAlloc((void **)&m_pMigInfo, cb));
            ZeroMemory(m_pMigInfo, cb);
            
            // Start Enumerating the keys
            for (i = 0; i < cImp; i++)
            {
                // Enumerate Friendly Names
                cb = sizeof(szCLSID);
                lResult = RegEnumKeyEx(hkey, i, szCLSID, &cb, 0, NULL, NULL, NULL);
                
                // No more items
                if (lResult == ERROR_NO_MORE_ITEMS)
                    break;
                
                // Error, lets move onto the next account
                if (lResult != ERROR_SUCCESS)
                {
                    Assert(FALSE);
                    continue;
                }
                
                if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szCLSID, 0, KEY_QUERY_VALUE, &hkeyT))
                {
                    cb = sizeof(DWORD);
                    dwFlagsT = 0;
                    if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szRegFlags, NULL, &type, (LPBYTE)&dwFlagsT, &cb))
                    {
                        if ((fOutlook && !!(dwFlagsT & IMPORT_NO_OUTLOOK)) ||
                            (!fOutlook && !!(dwFlagsT & IMPORT_ONLY_OUTLOOK)) ||
                            (fMailAcct && (dwFlagsT & IMPORT_NEWS)) ||
                            (!fMailAcct && !(dwFlagsT & IMPORT_NEWS)))
                        {
                            RegCloseKey(hkeyT);
                            continue;
                        }
                    }
                    else
                    {
                        if (!fMailAcct)
                        {
                            RegCloseKey(hkeyT);
                            continue;
                        }
                    }
                    
                    IF_NULLEXIT(pwszCLSID = PszToUnicode(CP_ACP, szCLSID));
                    
                    IF_FAILEXIT(hr = CLSIDFromString(pwszCLSID, &clsid));
                    
                    SafeMemFree(pwszCLSID);
                    
                    if (SUCCEEDED(CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IAccountImport, (void **)&pImp)))
                    {
                        hr = pImp->AutoDetect(&cAcct, dwFlags);
                        if (dwFlags && (hr == E_INVALIDARG))
                            hr = pImp->AutoDetect(&cAcct, 0);

                        if (S_OK == hr && cAcct > 0)
                        {
                            cb = sizeof(m_pMigInfo[m_cMigInfo].szDisplay);
                            RegQueryValueEx(hkeyT, NULL, NULL, &type, (LPBYTE)m_pMigInfo[m_cMigInfo].szDisplay, &cb);
                            
                            m_pMigInfo[m_cMigInfo].pImp = pImp;
                            pImp = NULL;
                            m_pMigInfo[m_cMigInfo].cAccts = cAcct;
                            if (SUCCEEDED(m_pMigInfo[m_cMigInfo].pImp->QueryInterface(IID_IAccountImport2, (void **)&pImp2)))
                            {
                                m_pMigInfo[m_cMigInfo].pImp2 = pImp2;
                                pImp2 = NULL;
                            }
                            m_cMigInfo++;
                        }
                        else
                        {
                            SafeRelease(pImp);
                        }
                    }
                    
                    RegCloseKey(hkeyT);
                }
            }
        }
    }

    hkeyT = 0;
    
exit:
    if (hkeyT)
        RegCloseKey(hkeyT);

    if (hkey)
        RegCloseKey(hkey);

    MemFree(pwszCLSID);
    return(hr);
}

HRESULT CICWApprentice::InitializeImport(CLSID clsid, DWORD dwFlags)
{
    HRESULT hr;
    DWORD cb, cAcct;
    IAccountImport *pImp;
    
    Assert(m_pMigInfo == NULL);
    Assert(m_cMigInfo == 0);
    Assert(m_pAcctMgr != NULL);
    
    hr = E_FAIL;
    
    cb = sizeof(MIGRATEINFO);
    if (!MemAlloc((void **)&m_pMigInfo, cb))
        return(E_OUTOFMEMORY);
    
    ZeroMemory(m_pMigInfo, cb);
    
    if (SUCCEEDED(CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IAccountImport, (void **)&pImp)))
    {
        hr = pImp->AutoDetect(&cAcct, dwFlags);
        if (dwFlags && (E_INVALIDARG == hr))
            // 72961 - OL98's OE importer will return E_INVALIDARG with non-zero flags
            hr = pImp->AutoDetect(&cAcct, 0);
        
        if (S_OK == hr && cAcct > 0)
        {
            m_pMigInfo[m_cMigInfo].pImp = pImp;
            m_pMigInfo[m_cMigInfo].cAccts = cAcct;
            m_cMigInfo++;
        }
        else
        {
            pImp->Release();
            hr = E_NoAccounts;
        }
    }
    
    return(hr);
}

UINT CICWApprentice::GetNextWizSection()
{
    ACCTTYPE type;
    
    if (0 == (m_dwFlags & ACCT_WIZ_IN_ICW))
    {
        if (0 == (m_dwFlags & ACCT_WIZ_INTERNETCONNECTION))
        {
            if (m_pICW != NULL)
                return(CONNECT_DLG);
            return(c_rgOrdNewAcct[m_acctType]);
        }
        else
        {
            return (c_rgOEOrdNewAcct[m_acctType]);
        }
    }
    
    return(EXTERN_DLG);
}

HRESULT CICWApprentice::InitAccountData(CAccount *pAcct, IMPCONNINFO *pConnInfo, BOOL fMigrate)
{
    DWORD dw;
    HRESULT hr;
    CAccount *pAcctDef = NULL;
    
    Assert(m_pAcctMgr != NULL);
    Assert((!fMigrate) ^ (pConnInfo != NULL));
    
#ifdef DEBUG
    if (fMigrate)
        Assert((m_acctType == ACCT_MAIL) || (m_acctType == ACCT_NEWS));
#endif // DEBUG
    
    m_fMigrate = fMigrate;
    m_dwReload |= ALL_PAGE;
    m_fComplete = TRUE;
    
    m_pData->fCreateNewAccount = false;
    m_pData->iServiceIndex = -1;
    m_pData->iNewServiceIndex = 0;

    m_pData->fDomainMSN = FALSE;

    if (m_pData->pAcct != NULL)
        m_pData->pAcct->Release();
    
    ZeroMemory(m_pData, sizeof(ACCTDATA));
    
    if (fMigrate)
    {
        Assert(pAcct != NULL);
        m_pData->pAcct = pAcct;
        m_pData->pAcct->AddRef();
    }
    
    if (pAcct == NULL)
    {
        Assert(!fMigrate);
        
        if (m_acctType == ACCT_DIR_SERV)
            return(S_OK);
        
        if (FAILED(m_pAcctMgr->GetDefaultAccount(m_acctType, (IImnAccount **)&pAcctDef)))
            return(S_OK);
        
        pAcct = pAcctDef;
    }
    else
    {
        hr = pAcct->GetPropSz(AP_ACCOUNT_NAME, m_pData->szAcctOrig, ARRAYSIZE(m_pData->szAcctOrig));
        if (fMigrate && *m_pData->szAcctOrig != 0)
        {
            hr = m_pAcctMgr->GetUniqueAccountName(m_pData->szAcctOrig, ARRAYSIZE(m_pData->szAcctOrig));
            Assert(SUCCEEDED(hr));
        }
        
        StrCpyN(m_pData->szAcct, m_pData->szAcctOrig, ARRAYSIZE(m_pData->szAcct));
    }
    
    if (m_acctType != ACCT_DIR_SERV)
    {
        if (fMigrate)
        {
            switch (pConnInfo->dwConnect)
            {
                case CONN_USE_DEFAULT:
                    if (!!(m_dwFlags & ACCT_WIZ_INTERNETCONNECTION))
                    {
                        hr = GetConnectInfoForOE(pAcct);
                    }
                    else
                    {
                        hr = GetIEConnectInfo(pAcct);
                    }
                    if (SUCCEEDED(hr))
                        hr = GetAcctConnectInfo(pAcct, m_pData);
                    break;
                
                case CONN_USE_SETTINGS:
                    m_pData->dwConnect = pConnInfo->dwConnectType;
                    if (m_pData->dwConnect == CONNECTION_TYPE_RAS)
                        StrCpyN(m_pData->szConnectoid, pConnInfo->szConnectoid, ARRAYSIZE(m_pData->szConnectoid));
                    hr = S_OK;
                    break;
                
                case CONN_NO_INFO:
                    // TODO: should we use IE connection in this case???
                case CONN_CREATE_ENTRY:
                    // TODO: handle this case
                default:
                    hr = E_FAIL;
                    break;
            }
        }
        else
        {
            hr = GetAcctConnectInfo(pAcct, m_pData);
            if (FAILED(hr))
            {
                if (!!(m_dwFlags & ACCT_WIZ_INTERNETCONNECTION))
                {
                    hr = GetConnectInfoForOE(pAcct);
                }
                else
                {
                    hr = GetIEConnectInfo(pAcct);
                }
                if (SUCCEEDED(hr))
                    hr = GetAcctConnectInfo(pAcct, m_pData);
            }
        }
        
        if (FAILED(hr))
            m_fComplete = FALSE;
    }
    
    switch (m_acctType)
    {
        case ACCT_NEWS:
            if (!GetRequiredAccountProp(pAcct, AP_NNTP_DISPLAY_NAME, m_pData->szName, ARRAYSIZE(m_pData->szName)))
                m_fComplete = FALSE;
            if (!GetRequiredAccountProp(pAcct, AP_NNTP_EMAIL_ADDRESS, m_pData->szEmail, ARRAYSIZE(m_pData->szEmail)))
                m_fComplete = FALSE;
        
            if (pAcctDef != NULL)
                break;
        
            if (!GetRequiredAccountProp(pAcct, AP_NNTP_SERVER, m_pData->szSvr1, ARRAYSIZE(m_pData->szSvr1)))
                m_fComplete = FALSE;
        
            hr = pAcct->GetPropSz(AP_NNTP_USERNAME, m_pData->szUsername, ARRAYSIZE(m_pData->szUsername));
            if (SUCCEEDED(hr))
                m_pData->fLogon = TRUE;

            hr = pAcct->GetPropDw(AP_NNTP_PROMPT_PASSWORD, &m_pData->fAlwaysPromptPassword);
            if (FAILED(hr) || !m_pData->fAlwaysPromptPassword)
                pAcct->GetPropSz(AP_NNTP_PASSWORD, m_pData->szPassword, ARRAYSIZE(m_pData->szPassword));

            hr = pAcct->GetPropDw(AP_NNTP_USE_SICILY, &dw);
            if (SUCCEEDED(hr) && dw != 0)
            {
                m_pData->fSPA = TRUE;
                m_pData->fLogon = TRUE;
            }
            break;
        
        case ACCT_MAIL:
            if (!GetRequiredAccountProp(pAcct, AP_SMTP_DISPLAY_NAME, m_pData->szName, ARRAYSIZE(m_pData->szName)))
                m_fComplete = FALSE;
            if (!GetRequiredAccountProp(pAcct, AP_SMTP_EMAIL_ADDRESS, m_pData->szEmail, ARRAYSIZE(m_pData->szEmail)))
                m_fComplete = FALSE;
        
            if (pAcctDef != NULL)
                break;
        
            hr = pAcct->GetServerTypes(&dw);
            if (SUCCEEDED(hr))
                m_pData->fServerTypes = dw;
        
            if (!GetRequiredAccountProp(pAcct, (m_pData->fServerTypes & SRV_IMAP) ? AP_IMAP_SERVER : AP_POP3_SERVER,
                m_pData->szSvr1, ARRAYSIZE(m_pData->szSvr1)))
                m_fComplete = FALSE;
            if (!GetRequiredAccountProp(pAcct, AP_SMTP_SERVER, m_pData->szSvr2, ARRAYSIZE(m_pData->szSvr2)))
                m_fComplete = FALSE;
        
            hr = pAcct->GetPropSz((m_pData->fServerTypes & SRV_IMAP) ? AP_IMAP_USERNAME : AP_POP3_USERNAME,
                m_pData->szUsername, ARRAYSIZE(m_pData->szUsername));
            if (SUCCEEDED(hr))
                m_pData->fLogon = TRUE;

            hr = pAcct->GetPropDw((m_pData->fServerTypes & SRV_IMAP) ? AP_IMAP_PROMPT_PASSWORD : AP_POP3_PROMPT_PASSWORD,
                &m_pData->fAlwaysPromptPassword);
            if (FAILED(hr) || !m_pData->fAlwaysPromptPassword)
                pAcct->GetPropSz((m_pData->fServerTypes & SRV_IMAP) ? AP_IMAP_PASSWORD : AP_POP3_PASSWORD,
                m_pData->szPassword, ARRAYSIZE(m_pData->szPassword));

            hr = pAcct->GetPropDw((m_pData->fServerTypes & SRV_IMAP) ? AP_IMAP_USE_SICILY : AP_POP3_USE_SICILY, &dw);
            if (SUCCEEDED(hr) && dw != 0)
            {
                m_pData->fSPA = TRUE;
                m_pData->fLogon = TRUE;
            }
        
            if (!m_pData->fLogon)
            {
                // for mail we have to have logon
                m_fComplete = FALSE;
            }
            break;
        
        case ACCT_DIR_SERV:
            if (!GetRequiredAccountProp(pAcct, AP_LDAP_SERVER, m_pData->szSvr1, ARRAYSIZE(m_pData->szSvr1)))
                m_fComplete = FALSE;
        
            hr = pAcct->GetPropDw(AP_LDAP_AUTHENTICATION, &dw);
            if (SUCCEEDED(hr))
            {
                if (dw == LDAP_AUTH_PASSWORD)
                {
                    m_pData->fLogon = TRUE;
                    hr = pAcct->GetPropSz(AP_LDAP_USERNAME, m_pData->szUsername, ARRAYSIZE(m_pData->szUsername));
                    if (SUCCEEDED(hr))
                        pAcct->GetPropSz(AP_LDAP_PASSWORD, m_pData->szPassword, ARRAYSIZE(m_pData->szPassword));
                }
                else if (dw == LDAP_AUTH_MEMBER_SYSTEM)
                {
                    m_pData->fLogon = TRUE;
                    m_pData->fSPA = TRUE;
                    hr = pAcct->GetPropSz(AP_LDAP_USERNAME, m_pData->szUsername, ARRAYSIZE(m_pData->szUsername));
                    if (SUCCEEDED(hr))
                        pAcct->GetPropSz(AP_LDAP_PASSWORD, m_pData->szPassword, ARRAYSIZE(m_pData->szPassword));
                }
            }
        
            hr = pAcct->GetPropDw(AP_LDAP_RESOLVE_FLAG, &dw);
            if (SUCCEEDED(hr))
                m_pData->fResolve = (dw != 0);
            break;
    }
    
    if (pAcctDef != NULL)
        pAcctDef->Release();
    
    return(S_OK);
}

// TODO: how about some error handling???
HRESULT CICWApprentice::SaveAccountData(CAccount *pAcct, BOOL fSetAsDefault)
{
    HRESULT hr;
    DWORD dw;
    LPMAILSERVERPROPSINFO pProps = NULL;
    
    if (pAcct == NULL)
        pAcct = m_pAcct;
    
    if (m_pData->pAcct != NULL)
    {
        Assert(m_fMigrate);
        pAcct = m_pData->pAcct;
    }
    
    pAcct->SetPropSz(AP_ACCOUNT_NAME, m_pData->szAcct);
    
    pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, m_pData->dwConnect);
//    if (m_pData->dwConnect == CONNECTION_TYPE_RAS || m_pData->dwConnect == CONNECTION_TYPE_INETSETTINGS)
    if (m_pData->dwConnect == CONNECTION_TYPE_RAS)
        pAcct->SetPropSz(AP_RAS_CONNECTOID, m_pData->szConnectoid);
    else
        pAcct->SetProp(AP_RAS_CONNECTOID, NULL, 0);
    
    switch (m_acctType)
    {
        case ACCT_NEWS:
            pAcct->SetPropSz(AP_NNTP_DISPLAY_NAME, m_pData->szName);
            pAcct->SetPropSz(AP_NNTP_EMAIL_ADDRESS, m_pData->szEmail);
        
            pAcct->SetPropSz(AP_NNTP_SERVER, m_pData->szSvr1);
        
            pAcct->SetProp(AP_NNTP_USERNAME, NULL, 0);
            pAcct->SetProp(AP_NNTP_PASSWORD, NULL, 0);
            pAcct->SetProp(AP_NNTP_USE_SICILY, NULL, 0);
        
            if (m_pData->fLogon)
            {
                pAcct->SetPropDw(AP_NNTP_USE_SICILY, m_pData->fSPA);
                pAcct->SetPropSz(AP_NNTP_USERNAME, m_pData->szUsername);
                pAcct->SetPropDw(AP_NNTP_PROMPT_PASSWORD, m_pData->fAlwaysPromptPassword);
                if (!m_pData->fAlwaysPromptPassword)
                    pAcct->SetPropSz(AP_NNTP_PASSWORD, m_pData->szPassword);
            }
            break;
        
        case ACCT_MAIL:
            pAcct->SetPropSz(AP_SMTP_DISPLAY_NAME, m_pData->szName);
            pAcct->SetPropSz(AP_SMTP_EMAIL_ADDRESS, m_pData->szEmail);
        
            if (0 == (m_pData->fServerTypes & SRV_HTTPMAIL))
                pAcct->SetProp(AP_HTTPMAIL_SERVER, NULL, 0);
            if (0 == (m_pData->fServerTypes & SRV_IMAP))
                pAcct->SetProp(AP_IMAP_SERVER, NULL, 0);
            if (0 == (m_pData->fServerTypes & SRV_POP3))
                pAcct->SetProp(AP_POP3_SERVER, NULL, 0);

            if (m_pData->fServerTypes & SRV_SMTP)
                pAcct->SetPropSz(AP_SMTP_SERVER, m_pData->szSvr2);
            else
                pAcct->SetProp(AP_SMTP_SERVER, NULL, 0);

            if (m_pData->fServerTypes & SRV_HTTPMAIL)
            {    
                GetServerProps(SERVER_HTTPMAIL, &pProps);
                pAcct->SetPropSz(AP_HTTPMAIL_FRIENDLY_NAME, m_pData->szFriendlyServiceName);
                if (m_pData->fDomainMSN)
                    pAcct->SetPropDw(AP_HTTPMAIL_DOMAIN_MSN, m_pData->fDomainMSN);
            }
            else if (m_pData->fServerTypes & SRV_IMAP)
                GetServerProps(SERVER_IMAP, &pProps);
            else
                GetServerProps(SERVER_MAIL, &pProps);
        
            Assert(pProps);
        
            pAcct->SetPropSz(pProps->server, m_pData->szSvr1); 
            pAcct->SetPropDw(pProps->useSicily, m_pData->fSPA);
        
            pAcct->SetPropSz(pProps->userName, m_pData->szUsername);
            pAcct->SetPropDw(pProps->promptPassword, m_pData->fAlwaysPromptPassword);
            if (m_pData->fAlwaysPromptPassword)
                pAcct->SetProp(pProps->password, NULL, 0);
            else
                pAcct->SetPropSz(pProps->password, m_pData->szPassword);
            break;
        
        case ACCT_DIR_SERV:
            pAcct->SetPropSz(AP_LDAP_SERVER, m_pData->szSvr1);
        
            pAcct->SetProp(AP_LDAP_USERNAME, NULL, 0);
            pAcct->SetProp(AP_LDAP_PASSWORD, NULL, 0);
        
            if (m_pData->fLogon)
            {
                pAcct->SetPropSz(AP_LDAP_USERNAME, m_pData->szUsername);
                pAcct->SetPropSz(AP_LDAP_PASSWORD, m_pData->szPassword);

                if (m_pData->fSPA)
                {
                    dw = LDAP_AUTH_MEMBER_SYSTEM;
                }
                else
                {
                    dw = LDAP_AUTH_PASSWORD;
                }
            }
            else
            {
                dw = LDAP_AUTH_ANONYMOUS;
            }
        
            pAcct->SetPropDw(AP_LDAP_AUTHENTICATION, dw);
        
            pAcct->SetPropDw(AP_LDAP_RESOLVE_FLAG, m_pData->fResolve);
            break;
    }
    
    hr = pAcct->SaveChanges();
    if (SUCCEEDED(hr) && fSetAsDefault)
        pAcct->SetAsDefault();
    
    // OE Bug 67399 
    // Make sure this account does not remain marked as Incomplete

    // We currently only mark mail and news account as incomplete
    if ((ACCT_MAIL == m_acctType) || (ACCT_NEWS == m_acctType))
    {
        char szIncomplete[CCHMAX_ACCOUNT_NAME];
        char szCurrID    [CCHMAX_ACCOUNT_NAME];
            
        // Need to exclusively check for S_OK...
        if (S_OK == m_pAcctMgr->GetIncompleteAccount(m_acctType, szIncomplete, ARRAYSIZE(szIncomplete)))
        {
            // Is the incomplete account, this account?
            if (SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_ID, szCurrID, ARRAYSIZE(szCurrID))))
            {
                if (!lstrcmpi(szIncomplete, szCurrID))
                {
                    m_pAcctMgr->SetIncompleteAccount(m_acctType, NULL);
                }
            }
            else
                AssertSz(0, "Account with no ID?!");
        }
    }

    return(hr);
}

HRESULT CICWApprentice::InitializeImportAccount(HWND hwnd, DWORD_PTR dwCookie)
{
    HRESULT hr;
    IAccountImport *pImp;
    IAccountImport2 *pImp2;
    IMPCONNINFO conninfo;
    CAccount *pAcct;
    
    pImp = m_pMigInfo[m_iMigInfo].pImp;
    Assert(pImp != NULL);
    pImp2 = m_pMigInfo[m_iMigInfo].pImp2;
    
    // TODO: verify that the user profile selection works properly
    if (m_acctType == ACCT_NEWS && pImp2 != NULL) 
    {
        // This is where we handle the possibility of a news account having subscribed to multiple servers.
        if (FAILED(hr = pImp2->InitializeImport(hwnd, dwCookie)))
            return(hr);
    }
    
    if (SUCCEEDED(hr = m_pAcctMgr->CreateAccountObject(m_acctType, (IImnAccount **)&pAcct)))
    {
        ZeroMemory(&conninfo, sizeof(IMPCONNINFO));
        conninfo.cbSize = sizeof(IMPCONNINFO);
        
        if (pImp2 != NULL)
            hr = pImp2->GetSettings2(dwCookie, pAcct, &conninfo);
        else
            hr = pImp->GetSettings(dwCookie, pAcct);
        
        if (SUCCEEDED(hr))
        {
            hr = InitAccountData(pAcct, &conninfo, TRUE);
            Assert(!FAILED(hr));
        }
        
        pAcct->Release();
    }
    
    return(hr);
}

HRESULT CICWApprentice::HandleMigrationSelection(int index, UINT *puNextPage, HWND hDlg)
{
    HRESULT hr;
    IAccountImport *pImp;
    IEnumIMPACCOUNTS *pEnum;
    IMPACCOUNTINFO impinfo;
    
    Assert(m_cMigInfo > 0);
    
    if (m_iMigInfo != index)
    {
        m_iMigInfo = index;
        
        if (m_pMigInfo[index].cAccts > 1)
        {
            m_dwReload |= SELECT_PAGE;
        }
        else
        {
            pImp = m_pMigInfo[index].pImp;
            Assert(pImp != NULL);
            
            if (S_OK == (hr = pImp->EnumerateAccounts(&pEnum)))
            {
                Assert(pEnum != NULL);
                
                if (SUCCEEDED(hr = pEnum->Next(&impinfo)))
                    hr = InitializeImportAccount(hDlg, impinfo.dwCookie);
                
                pEnum->Release();
            }
            
            if (FAILED(hr))
                return(hr);
        }
    }
    
    if (m_pMigInfo[index].cAccts > 1)
    {
        if (m_acctType == ACCT_MAIL)
            *puNextPage = ORD_PAGE_MIGRATESELECT;
        else
            *puNextPage = ORD_PAGE_NEWSACCTSELECT;
    }
    else
    {
        if (m_acctType == ACCT_MAIL)
        {
            if (m_fComplete)
                *puNextPage = ORD_PAGE_MAILCONFIRM;
            else
                *puNextPage = ORD_PAGE_MAILNAME;
        }
        else
        {
            if (m_fComplete)
                *puNextPage = ORD_PAGE_NEWSCONFIRM;
            else
                *puNextPage = ORD_PAGE_NEWSNAME;
        }
    }
    
    return(S_OK);
}

BOOL FGetSystemShutdownPrivledge()
{
    OSVERSIONINFO osinfo;
    TOKEN_PRIVILEGES tkp;
    HANDLE hToken = NULL;
    BOOL bRC = FALSE;
    
    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osinfo);
    if (osinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) 
        {
            Assert(hToken != NULL);
            
            ZeroMemory(&tkp, sizeof(tkp));
            LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid); 
            
            tkp.PrivilegeCount = 1;  /* one privilege to set    */ 
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
            
            AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES) NULL, 0); 
            if (ERROR_SUCCESS == GetLastError())
                bRC = TRUE;
            
            CloseHandle(hToken);
        }
    }
    else
    {
        bRC = TRUE;
    }
    
    return(bRC);
}

CNewsGroupImport::CNewsGroupImport()
{
    m_cRef = 1;
    m_pAcct = NULL;
}

CNewsGroupImport::~CNewsGroupImport()
{
    if (m_pAcct != NULL)
        m_pAcct->Release();
}

STDMETHODIMP CNewsGroupImport::QueryInterface(REFIID riid, LPVOID *pNews)
{
    if (pNews == NULL)
        return(E_INVALIDARG);
    
    *pNews = NULL;
    
    if (riid == IID_INewsGroupImport || riid == IID_IUnknown)
        *pNews = (void*)(INewsGroupImport*)this;
    else
        return(E_NOINTERFACE);
    
    ((LPUNKNOWN)*pNews)->AddRef();
    
    return(S_OK);
}

ULONG CNewsGroupImport::AddRef(void)
{
    return ++m_cRef;
}

ULONG CNewsGroupImport::Release(void)
{
    if(--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    
    return m_cRef;
}

HRESULT CNewsGroupImport::Initialize(IImnAccount *pAcct)
{
    m_pAcct = pAcct;
    m_pAcct->AddRef();
    
    return S_OK;
}

HRESULT CNewsGroupImport::ImportSubList(LPCSTR pListGroups)
{
    PFNSUBNEWSGROUP lpfnNewsGroup = NULL;
    HINSTANCE hInstance;
    HRESULT hr = S_FALSE;
    
    hInstance = LoadLibrary(c_szMainDll);
    
    if (hInstance != NULL)
    {
        if ((lpfnNewsGroup = (PFNSUBNEWSGROUP)GetProcAddress(hInstance, MAKEINTRESOURCE(17))) != NULL)
        {
            if (!SUCCEEDED(lpfnNewsGroup(NULL, m_pAcct, pListGroups)))
                hr = S_FALSE;
            else
                hr = S_OK;
        }
        
        FreeLibrary(hInstance);
    }
    
    return hr;
}

static const char c_szComctl32Dll[] = "comctl32.dll";
static const char c_szDllGetVersion[] = "DllGetVersion";

DWORD CommctrlMajor()
{
    HINSTANCE hinst;
    DLLGETVERSIONPROC pfnVersion;
    DLLVERSIONINFO info;
    static BOOL  s_fInit = FALSE;
    static DWORD s_dwMajor = 0;
    
    if (!s_fInit)
    {
        s_fInit = TRUE;

        hinst = LoadLibrary(c_szComctl32Dll);
        if (hinst != NULL)
        {
            pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinst, c_szDllGetVersion);
            if (pfnVersion != NULL)
            {
                info.cbSize = sizeof(DLLVERSIONINFO);
                if (SUCCEEDED(pfnVersion(&info)))
                {
                    s_dwMajor = info.dwMajorVersion;
                }
            }

            FreeLibrary(hinst);
        }
    }
    
    return(s_dwMajor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\mimedem.h ===
/*
**	m i m e d e m . h
**	
**	Purpose: implement the loader functions for defer/demand -loaded libraries
**
**  Creators: yst
**  Created: 2/10/99
**	
**	Copyright (C) Microsoft Corp. 1999
*/

//
// IF YOU #INCLUDE A FILE HERE YOU PROBABLY ARE CONFUSED.
// THIS FILE IS INCLUDED BY LOTS OF PEOPLE.  THINK THRICE
// BEFORE #INCLUDING *ANYTHING* HERE.  MAKE GOOD USE
// OF FORWARD REFS INSTEAD.
//

#define USE_CRITSEC

#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return;     \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;			\
        extern TYP_##name VAR_##name;                   

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;			\
        extern TYP_##name VAR_##name;

#endif // IMPLEMENT_LOADER_FUNCTIONS

void InitDemandMimeole(void);
void FreeDemandMimeOle(void);

/////////////////////////////////////
// INETCOMM.DLL

#include "mimeole.h"
#define _INETCOMM_

BOOL DemandLoadMimeOle(void);

LOADER_FUNCTION( HRESULT, MimeOleSMimeCapsToDlg,
                (LPBYTE pbSMimeCaps, DWORD cbSMimeCaps, DWORD cCerts, PCX509CERT * rgCerts, HWND hwndDlg,  DWORD idEncAlgs, DWORD idSignAlgs, DWORD idBlob),
                (pbSMimeCaps, cbSMimeCaps, cCerts, rgCerts, hwndDlg, idEncAlgs, idSignAlgs,idBlob),
                E_FAIL, MimeOle)
#define MimeOleSMimeCapsToDlg VAR_MimeOleSMimeCapsToDlg


LOADER_FUNCTION( HRESULT, MimeOleSMimeCapsFromDlg,
                (HWND hwnd, DWORD idEncAlgs, DWORD idSignAlgs, DWORD idBlob, LPBYTE pbSMimeCaps, DWORD * pcbSmimeCaps),
                (hwnd, idEncAlgs, idSignAlgs, idBlob, pbSMimeCaps, pcbSmimeCaps),
                E_FAIL, MimeOle)
#define MimeOleSMimeCapsFromDlg VAR_MimeOleSMimeCapsFromDlg


LOADER_FUNCTION( HRESULT, MimeOleSMimeCapsFull,
		        (LPVOID pv, BOOL fFullEncryption, BOOL fFullSigning, LPBYTE pbSymCaps, DWORD * pcbSymCaps),
                (pv, fFullEncryption, fFullSigning, pbSymCaps, pcbSymCaps),
                E_FAIL, MimeOle)
#define MimeOleSMimeCapsFull VAR_MimeOleSMimeCapsFull
                

LOADER_FUNCTION( HRESULT, MimeOleSMimeCapInit,
                (LPBYTE pbSMimeCap, DWORD cbSMimeCap, LPVOID * ppv),
                (pbSMimeCap, cbSMimeCap, ppv),
                E_FAIL, MimeOle)
#define MimeOleSMimeCapInit VAR_MimeOleSMimeCapInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\navnews.h ===
#ifndef _INC_NAVNEWS
#define _INC_NAVNEWS

// {33102458-4B30-11d2-A6DC-00C04F79E7C8}
DEFINE_GUID(CLSID_CEnumNAVNEWSACCTS, 0x33102458, 0x4b30, 0x11d2, 0xa6, 0xdc, 0x0, 0xc0, 0x4f, 0x79, 0xe7, 0xc8);

class CEnumNAVNEWSACCTS : public IEnumIMPACCOUNTS
    {
    private:
        ULONG           m_cRef;
        int             m_iInfo;
        UINT            m_cInfo;
        NSCPACCTINFO    *m_rgInfo;

    public:
        CEnumNAVNEWSACCTS(void);
        ~CEnumNAVNEWSACCTS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE Next(IMPACCOUNTINFO *pinfo);
        HRESULT STDMETHODCALLTYPE Reset(void);

        HRESULT Init(NSCPACCTINFO *pinfo, int cinfo);
    };

// {33102459-4B30-11d2-A6DC-00C04F79E7C8}
DEFINE_GUID(CLSID_CNavNewsAcctImport, 0x33102459, 0x4b30, 0x11d2, 0xa6, 0xdc, 0x0, 0xc0, 0x4f, 0x79, 0xe7, 0xc8);

class CNavNewsAcctImport : public IAccountImport, public IAccountImport2
    {
    private:
        ULONG           m_cRef;
        BOOL            m_fIni;
        TCHAR           m_szIni[MAX_PATH];
        UINT            m_cInfo;
        NSCPACCTINFO    *m_rgInfo;

        HRESULT InitAccounts(void);
        HRESULT IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);

    public:
        CNavNewsAcctImport(void);
        ~CNavNewsAcctImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE AutoDetect(DWORD *pcAcct, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum);
        HRESULT STDMETHODCALLTYPE GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct);

        HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd, DWORD_PTR dwCookie);
        HRESULT STDMETHODCALLTYPE GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);
    };

#endif // _INC_NAVNEWS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\netscape.cpp ===
#include "pch.hxx"
#include <imnact.h>
#include <acctimp.h>
#include <dllmain.h>
#include <resource.h>
#include "netscape.h"
#include "strconst.h"
#include "demand.h"

ASSERTDATA

CNscpAcctImport::CNscpAcctImport()
{
    m_cRef = 1;
    m_fIni = FALSE;
    *m_szIni = 0;
    m_cInfo = 0;
    m_rgInfo = NULL;
}

CNscpAcctImport::~CNscpAcctImport()
{
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
}

STDMETHODIMP CNscpAcctImport::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (ppv == NULL)
        return(E_INVALIDARG);
    
    *ppv = NULL;
    
    if (IID_IUnknown == riid)
        *ppv = (IAccountImport *)this;
    else if (IID_IAccountImport == riid)
        *ppv = (IAccountImport *)this;
    else if (IID_IAccountImport2 == riid)
        *ppv = (IAccountImport2 *)this;
    else
        return(E_NOINTERFACE);
    
    ((LPUNKNOWN)*ppv)->AddRef();
    
    return(S_OK);
}

STDMETHODIMP_(ULONG) CNscpAcctImport::AddRef()
{
    return(++m_cRef);
}

STDMETHODIMP_(ULONG) CNscpAcctImport::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return(0);
    }
    
    return(m_cRef);
}

HRESULT STDMETHODCALLTYPE CNscpAcctImport::AutoDetect(DWORD *pcAcct, DWORD dwFlags)
{
    HRESULT hr;
    HKEY hkey, hkeyServices;
    char szPop[MAX_PATH];
    DWORD type, cb;
    
    if (pcAcct == NULL)
        return(E_INVALIDARG);
    
    hr = S_FALSE;
    *pcAcct = 0;
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegNscp, 0, KEY_READ, &hkey))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(hkey, c_szRegServices, 0, KEY_READ, &hkeyServices))
        {
            cb = sizeof(szPop);
            if (ERROR_SUCCESS == RegQueryValueEx(hkeyServices, c_szNscpPopServer, NULL, &type, (LPBYTE)szPop, &cb) &&
                cb > 0 &&
                type == REG_SZ)
            {
                hr = S_OK;
            }
            
            RegCloseKey(hkeyServices);
        }
        
        RegCloseKey(hkey);
    }
    
    if (hr == S_FALSE)
    {
        cb = GetProfileString(c_szNetscape, c_szIni, c_szEmpty, m_szIni, ARRAYSIZE(m_szIni));
        if (cb > 0)
        {
            cb = GetPrivateProfileString(c_szRegServices, c_szNscpPopServer, c_szEmpty,
                szPop, ARRAYSIZE(szPop), m_szIni);
            if (cb > 0)
            {
                m_fIni = TRUE;
                hr = S_OK;
            }
        }
    }
    
    if (hr == S_OK)
    {
        if (!MemAlloc((void **)&m_rgInfo, sizeof(NSCPACCTINFO)))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            m_rgInfo->dwCookie = 0;
            LoadString(g_hInstRes, idsDefaultAccount, m_rgInfo->szDisplay, ARRAYSIZE(m_rgInfo->szDisplay));
            m_cInfo = 1;
            
            *pcAcct = 1;
        }
    }
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE CNscpAcctImport::EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum)
{
    CEnumNSCPACCTS *penum;
    HRESULT hr;
    
    if (ppEnum == NULL)
        return(E_INVALIDARG);
    
    *ppEnum = NULL;
    
    if (m_cInfo == 0)
        return(S_FALSE);
    Assert(m_rgInfo != NULL);
    
    penum = new CEnumNSCPACCTS;
    if (penum == NULL)
        return(E_OUTOFMEMORY);
    
    hr = penum->Init(m_rgInfo, m_cInfo);
    if (FAILED(hr))
    {
        penum->Release();
        penum = NULL;
    }
    
    *ppEnum = penum;
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE CNscpAcctImport::GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct)
{
    if (pAcct == NULL)
        return(E_INVALIDARG);
    
    return(IGetSettings(dwCookie, pAcct, NULL));
}

HRESULT STDMETHODCALLTYPE CNscpAcctImport::GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
{
    if (pAcct == NULL ||
        pInfo == NULL)
        return(E_INVALIDARG);
    
    return(IGetSettings(dwCookie, pAcct, pInfo));
}

HRESULT CNscpAcctImport::IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
{
    HKEY hkey, hkeyT;
    NSCPACCTINFO *pinfo;
    char sz[512];
    DWORD cb, type;
    HRESULT hr;
    
    Assert(pAcct != NULL);
    
    Assert(((int) dwCookie) >= 0 && dwCookie < (DWORD_PTR)m_cInfo);
    pinfo = &m_rgInfo[dwCookie];
    
    Assert(pinfo->dwCookie == dwCookie);
    
    hr = pAcct->SetPropSz(AP_ACCOUNT_NAME, pinfo->szDisplay);
    if (FAILED(hr))
        return(hr);
    
    if (m_fIni)
    {
        cb = GetPrivateProfileString(c_szRegMail, c_szPopName, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0)
        {
            hr = pAcct->SetPropSz(AP_POP3_USERNAME, sz);
            Assert(!FAILED(hr));
        }
        
        cb = GetPrivateProfileString(c_szRegServices, c_szNscpSmtpServer, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0)
        {
            hr = pAcct->SetPropSz(AP_SMTP_SERVER, sz);
            Assert(!FAILED(hr));
        }
        
        cb = GetPrivateProfileString(c_szRegServices, c_szNscpPopServer, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0)
        {
            hr = pAcct->SetPropSz(AP_POP3_SERVER, sz);
            Assert(!FAILED(hr));
        }
        
        cb = GetPrivateProfileString(c_szRegUser, c_szNscpUserName, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0)
        {
            hr = pAcct->SetPropSz(AP_SMTP_DISPLAY_NAME, sz);
            Assert(!FAILED(hr));
        }
        
        cb = GetPrivateProfileString(c_szRegUser, c_szUserAddr, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0)
        {
            hr = pAcct->SetPropSz(AP_SMTP_EMAIL_ADDRESS, sz);
            Assert(!FAILED(hr));
        }

        cb = GetPrivateProfileString(c_szRegUser, c_szReplyTo, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0)
        {
            hr = pAcct->SetPropSz(AP_SMTP_REPLY_EMAIL_ADDRESS, sz);
            Assert(!FAILED(hr));
        }
        
        cb = GetPrivateProfileString(c_szRegMail, c_szLeaveServer, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0)
        {
            if (lstrcmpi(sz, c_szYes))
            {
                hr = pAcct->SetPropDw(AP_POP3_LEAVE_ON_SERVER, 1);
                Assert(!FAILED(hr));
            }
        }
    }
    else
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegNscp, 0, KEY_READ, &hkey))
        {
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, c_szRegMail, 0, KEY_READ, &hkeyT))
            {
                cb = sizeof(sz);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szPopName, NULL, &type, (LPBYTE)sz, &cb) &&
                    !FIsEmpty(sz))
                {
                    hr = pAcct->SetPropSz(AP_POP3_USERNAME, sz);
                    Assert(!FAILED(hr));
                }
                
                cb = sizeof(sz);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szLeaveServer, NULL, &type, (LPBYTE)sz, &cb) &&
                    !FIsEmpty(sz))
                {
                    hr = pAcct->SetPropDw(AP_POP3_LEAVE_ON_SERVER, 1);
                    Assert(!FAILED(hr));
                }
                
                RegCloseKey(hkeyT);
            }
            
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, c_szRegServices, 0, KEY_READ, &hkeyT))
            {
                cb = sizeof(sz);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szNscpSmtpServer, NULL, &type, (LPBYTE)sz, &cb) &&
                    !FIsEmpty(sz))
                {
                    hr = pAcct->SetPropSz(AP_SMTP_SERVER, sz);
                    Assert(!FAILED(hr));
                }
                
                cb = sizeof(sz);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szNscpPopServer, NULL, &type, (LPBYTE)sz, &cb) &&
                    !FIsEmpty(sz))
                {
                    hr = pAcct->SetPropSz(AP_POP3_SERVER, sz);
                    Assert(!FAILED(hr));
                }
                
                RegCloseKey(hkeyT);
            }
            
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, c_szRegUser, 0, KEY_READ, &hkeyT))
            {
                cb = sizeof(sz);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szNscpUserName, NULL, &type, (LPBYTE)sz, &cb) &&
                    !FIsEmpty(sz))
                {
                    hr = pAcct->SetPropSz(AP_SMTP_DISPLAY_NAME, sz);
                    Assert(!FAILED(hr));
                }
                
                cb = sizeof(sz);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szUserAddr, NULL, &type, (LPBYTE)sz, &cb) &&
                    !FIsEmpty(sz))
                {
                    hr = pAcct->SetPropSz(AP_SMTP_EMAIL_ADDRESS, sz);
                    Assert(!FAILED(hr));
                }

                cb = sizeof(sz);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szReplyTo, NULL, &type, (LPBYTE)sz, &cb) &&
                    !FIsEmpty(sz))
                {
                    hr = pAcct->SetPropSz(AP_SMTP_REPLY_EMAIL_ADDRESS, sz);
                    Assert(!FAILED(hr));
                }
                
                RegCloseKey(hkeyT);
            }
            
            RegCloseKey(hkey);
        }
    }
    
    if (pInfo != NULL)
    {
        // TODO: can we do any better than this???
        pInfo->dwConnect = CONN_USE_DEFAULT;
    }
    
    return(S_OK);
}
    
HRESULT STDMETHODCALLTYPE CNscpAcctImport::InitializeImport(HWND hwnd, DWORD_PTR dwCookie)
{
    return(E_NOTIMPL);
}

HRESULT STDMETHODCALLTYPE CNscpAcctImport::GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved)
{
    return(E_NOTIMPL);
}

CEnumNSCPACCTS::CEnumNSCPACCTS()
{
    m_cRef = 1;
    // m_iInfo
    m_cInfo = 0;
    m_rgInfo = NULL;
}

CEnumNSCPACCTS::~CEnumNSCPACCTS()
{
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
}

STDMETHODIMP CEnumNSCPACCTS::QueryInterface(REFIID riid, LPVOID *ppv)
{
    
    if (ppv == NULL)
        return(E_INVALIDARG);
    
    *ppv = NULL;
    
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IEnumIMPACCOUNTS == riid)
        *ppv = (IEnumIMPACCOUNTS *)this;
    
    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();
    else
        return(E_NOINTERFACE);
    
    return(S_OK);
}

STDMETHODIMP_(ULONG) CEnumNSCPACCTS::AddRef()
{
    return(++m_cRef);
}

STDMETHODIMP_(ULONG) CEnumNSCPACCTS::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return(0);
    }
    
    return(m_cRef);
}

HRESULT STDMETHODCALLTYPE CEnumNSCPACCTS::Next(IMPACCOUNTINFO *pinfo)
{
    if (pinfo == NULL)
        return(E_INVALIDARG);
    
    m_iInfo++;
    if ((UINT)m_iInfo >= m_cInfo)
        return(S_FALSE);
    
    Assert(m_rgInfo != NULL);
    
    pinfo->dwCookie = m_rgInfo[m_iInfo].dwCookie;
    pinfo->dwReserved = 0;
    StrCpyN(pinfo->szDisplay, m_rgInfo[m_iInfo].szDisplay, ARRAYSIZE(pinfo->szDisplay));
    
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CEnumNSCPACCTS::Reset()
{
    m_iInfo = -1;
    
    return(S_OK);
}

HRESULT CEnumNSCPACCTS::Init(NSCPACCTINFO *pinfo, int cinfo)
{
    DWORD cb;
    
    Assert(pinfo != NULL);
    Assert(cinfo > 0);
    
    cb = cinfo * sizeof(NSCPACCTINFO);
    
    if (!MemAlloc((void **)&m_rgInfo, cb))
        return(E_OUTOFMEMORY);
    
    m_iInfo = -1;
    m_cInfo = cinfo;
    CopyMemory(m_rgInfo, pinfo, cb);
    
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\nexpress.h ===
#ifndef _INC_NEXPRESSACT
#define _INC_NEXPRESSACT

typedef struct tagNXACCTINFO
    {
    DWORD_PTR dwCookie;
    char szUserPath[MAX_PATH];
    char szDisplay[CCHMAX_ACCOUNT_NAME];
    } NXACCTINFO;

// {17869500-36C8-11d1-83B7-00C04FBD7C09}
DEFINE_GUID(CLSID_CEnumNXACCT, 0x17869500, 0x36c8, 0x11d1, 0x83, 0xb7, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

class CEnumNXACCT : public IEnumIMPACCOUNTS
    {
    private:
        ULONG           m_cRef;
        int             m_iInfo;
        UINT            m_cInfo;
        NXACCTINFO    *m_rgInfo;

    public:
        CEnumNXACCT(void);
        ~CEnumNXACCT(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE Next(IMPACCOUNTINFO *pinfo);
        HRESULT STDMETHODCALLTYPE Reset(void);

        HRESULT Init(NXACCTINFO *pinfo, int cinfo);
    };

// {17869501-36C8-11d1-83B7-00C04FBD7C09}
DEFINE_GUID(CLSID_CNExpressAcctImport, 0x17869501, 0x36c8, 0x11d1, 0x83, 0xb7, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);


class CNExpressAcctImport : public IAccountImport, public IAccountImport2
    {
    private:
        ULONG           m_cRef;
        BOOL            m_fIni;
        TCHAR           m_szIni[MAX_PATH];
        UINT            m_cInfo;
        NXACCTINFO    *m_rgInfo;

        HRESULT GetSubListGroups(char *szHomeDir, char **ppListGroups);
        HRESULT IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);

    public:
        CNExpressAcctImport(void);
        ~CNExpressAcctImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE AutoDetect(DWORD *pcAcct, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum);
        HRESULT STDMETHODCALLTYPE GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct);

        // Methods from the IAccountImport2 interface.
        HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd, DWORD_PTR dwCookie);
        HRESULT STDMETHODCALLTYPE GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);
    };

#endif // _INC_NEXPRESSACT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\navnews.cpp ===
#include "pch.hxx"
#include <imnact.h>
#include <acctimp.h>
#include <dllmain.h>
#include <resource.h>
#include "netscape.h"
#include "navnews.h"
#include "strconst.h"
#include "demand.h"

ASSERTDATA

CNavNewsAcctImport::CNavNewsAcctImport()
{
    m_cRef = 1;
    m_fIni = FALSE;
    *m_szIni = 0;
    m_cInfo = 0;
    m_rgInfo = NULL;
}

CNavNewsAcctImport::~CNavNewsAcctImport()
{
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
}

STDMETHODIMP CNavNewsAcctImport::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (ppv == NULL)
        return(E_INVALIDARG);
    
    *ppv = NULL;
    
    if (IID_IUnknown == riid)
        *ppv = (IAccountImport *)this;
    else if (IID_IAccountImport == riid)
        *ppv = (IAccountImport *)this;
    else if (IID_IAccountImport2 == riid)
        *ppv = (IAccountImport2 *)this;
    else
        return(E_NOINTERFACE);
    
    ((LPUNKNOWN)*ppv)->AddRef();
    
    return(S_OK);
}

STDMETHODIMP_(ULONG) CNavNewsAcctImport::AddRef()
{
    return(++m_cRef);
}

STDMETHODIMP_(ULONG) CNavNewsAcctImport::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return(0);
    }
    
    return(m_cRef);
}

HRESULT STDMETHODCALLTYPE CNavNewsAcctImport::AutoDetect(DWORD *pcAcct, DWORD dwFlags)
{
    HRESULT hr;
    HKEY hkey, hkeyServices;
    char szPop[MAX_PATH];
    DWORD type, cb;
    
    if (pcAcct == NULL)
        return(E_INVALIDARG);
    
    hr = S_FALSE;
    *pcAcct = 0;
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegNscp, 0, KEY_READ, &hkey))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(hkey, c_szRegServices, 0, KEY_READ, &hkeyServices))
        {
            cb = sizeof(szPop);
            if (ERROR_SUCCESS == RegQueryValueEx(hkeyServices, c_szNNTPServer, NULL, &type, (LPBYTE)szPop, &cb) &&
                cb > 0 &&
                type == REG_SZ)
            {
                hr = S_OK;
            }
            
            RegCloseKey(hkeyServices);
        }
        
        RegCloseKey(hkey);
    }
    
    if (hr == S_FALSE)
    {
        cb = GetProfileString(c_szNetscape, c_szIni, c_szEmpty, m_szIni, ARRAYSIZE(m_szIni));
        if (cb > 0)
        {
            cb = GetPrivateProfileString(c_szRegServices, c_szNNTPServer, c_szEmpty,
                szPop, ARRAYSIZE(szPop), m_szIni);
            if (cb > 0)
            {
                m_fIni = TRUE;
                hr = S_OK;
            }
        }
    }
    
    if (hr == S_OK)
    {
        if (!MemAlloc((void **)&m_rgInfo, sizeof(NSCPACCTINFO)))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            m_rgInfo->dwCookie = 0;
            LoadString(g_hInstRes, idsDefaultNewsAccount, m_rgInfo->szDisplay, ARRAYSIZE(m_rgInfo->szDisplay));
            m_cInfo = 1;
            
            *pcAcct = 1;
        }
    }
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE CNavNewsAcctImport::EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum)
{
    CEnumNAVNEWSACCTS *penum;
    HRESULT hr;
    
    if (ppEnum == NULL)
        return(E_INVALIDARG);
    
    *ppEnum = NULL;
    
    if (m_cInfo == 0)
        return(S_FALSE);
    Assert(m_rgInfo != NULL);
    
    penum = new CEnumNAVNEWSACCTS;
    if (penum == NULL)
        return(E_OUTOFMEMORY);
    
    hr = penum->Init(m_rgInfo, m_cInfo);
    if (FAILED(hr))
    {
        penum->Release();
        penum = NULL;
    }
    
    *ppEnum = penum;
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE CNavNewsAcctImport::GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct)
{
    if (pAcct == NULL)
        return(E_INVALIDARG);
    
    return(IGetSettings(dwCookie, pAcct, NULL));
}

HRESULT STDMETHODCALLTYPE CNavNewsAcctImport::GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
{
    if (pAcct == NULL ||
        pInfo == NULL)
        return(E_INVALIDARG);
    
    return(IGetSettings(dwCookie, pAcct, pInfo));
}

HRESULT CNavNewsAcctImport::IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
{
    HKEY hkey, hkeyT;
    NSCPACCTINFO *pinfo;
    char sz[512];
    DWORD cb, type;
    HRESULT hr;
    
    Assert(pAcct != NULL);
    
    Assert(((int) dwCookie) >= 0 && dwCookie < (DWORD_PTR)m_cInfo);
    pinfo = &m_rgInfo[dwCookie];
    
    Assert(pinfo->dwCookie == dwCookie);
    
    hr = pAcct->SetPropSz(AP_ACCOUNT_NAME, pinfo->szDisplay);
    if (FAILED(hr))
        return(hr);
    
    if (m_fIni)
    {
        cb = GetPrivateProfileString(c_szRegServices, c_szNNTPServer, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0)
        {
            hr = pAcct->SetPropSz(AP_NNTP_SERVER, sz);
            Assert(!FAILED(hr));
        }

        cb = GetPrivateProfileString(c_szRegUser, c_szNscpUserName, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0)
        {
            hr = pAcct->SetPropSz(AP_NNTP_DISPLAY_NAME, sz);
            Assert(!FAILED(hr));
        }
        
        cb = GetPrivateProfileString(c_szRegUser, c_szUserAddr, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0)
        {
            hr = pAcct->SetPropSz(AP_NNTP_EMAIL_ADDRESS, sz);
            Assert(!FAILED(hr));
        }

        cb = GetPrivateProfileString(c_szRegUser, c_szReplyTo, c_szEmpty, sz, ARRAYSIZE(sz), m_szIni); 
        if (cb > 0)
        {
            hr = pAcct->SetPropSz(AP_NNTP_REPLY_EMAIL_ADDRESS, sz);
            Assert(!FAILED(hr));
        }
    }
    else
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegNscp, 0, KEY_READ, &hkey))
        {
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, c_szRegServices, 0, KEY_READ, &hkeyT))
            {
                cb = sizeof(sz);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szNNTPServer, NULL, &type, (LPBYTE)sz, &cb) &&
                    !FIsEmpty(sz))
                {
                    hr = pAcct->SetPropSz(AP_NNTP_SERVER, sz);
                    Assert(!FAILED(hr));
                }
            }
            
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, c_szRegUser, 0, KEY_READ, &hkeyT))
            {
                cb = sizeof(sz);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szNscpUserName, NULL, &type, (LPBYTE)sz, &cb) &&
                    !FIsEmpty(sz))
                {
                    hr = pAcct->SetPropSz(AP_NNTP_DISPLAY_NAME, sz);
                    Assert(!FAILED(hr));
                }
                
                cb = sizeof(sz);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szUserAddr, NULL, &type, (LPBYTE)sz, &cb) &&
                    !FIsEmpty(sz))
                {
                    hr = pAcct->SetPropSz(AP_NNTP_EMAIL_ADDRESS, sz);
                    Assert(!FAILED(hr));
                }

                cb = sizeof(sz);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szReplyTo, NULL, &type, (LPBYTE)sz, &cb) &&
                    !FIsEmpty(sz))
                {
                    hr = pAcct->SetPropSz(AP_NNTP_REPLY_EMAIL_ADDRESS, sz);
                    Assert(!FAILED(hr));
                }
                
                RegCloseKey(hkeyT);
            }
            
            RegCloseKey(hkey);
        }
    }
    
    if (pInfo != NULL)
    {
        // TODO: can we do any better than this???
        pInfo->dwConnect = CONN_USE_DEFAULT;
    }
    
    return(S_OK);
}
    
HRESULT STDMETHODCALLTYPE CNavNewsAcctImport::InitializeImport(HWND hwnd, DWORD_PTR dwCookie)
{
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CNavNewsAcctImport::GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved)
{
    HRESULT hr;

    Assert(pImp != NULL);

    hr = E_FAIL;

    // TODO: handle ini file case...

    return(hr);
}

CEnumNAVNEWSACCTS::CEnumNAVNEWSACCTS()
{
    m_cRef = 1;
    // m_iInfo
    m_cInfo = 0;
    m_rgInfo = NULL;
}

CEnumNAVNEWSACCTS::~CEnumNAVNEWSACCTS()
{
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
}

STDMETHODIMP CEnumNAVNEWSACCTS::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (ppv == NULL)
        return(E_INVALIDARG);
    
    *ppv = NULL;
    
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IEnumIMPACCOUNTS == riid)
        *ppv = (IEnumIMPACCOUNTS *)this;
    
    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();
    else
        return(E_NOINTERFACE);
    
    return(S_OK);
}

STDMETHODIMP_(ULONG) CEnumNAVNEWSACCTS::AddRef()
{
    return(++m_cRef);
}

STDMETHODIMP_(ULONG) CEnumNAVNEWSACCTS::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return(0);
    }
    
    return(m_cRef);
}

HRESULT STDMETHODCALLTYPE CEnumNAVNEWSACCTS::Next(IMPACCOUNTINFO *pinfo)
{
    if (pinfo == NULL)
        return(E_INVALIDARG);
    
    m_iInfo++;
    if ((UINT)m_iInfo >= m_cInfo)
        return(S_FALSE);
    
    Assert(m_rgInfo != NULL);
    
    pinfo->dwCookie = m_rgInfo[m_iInfo].dwCookie;
    pinfo->dwReserved = 0;
    StrCpyN(pinfo->szDisplay, m_rgInfo[m_iInfo].szDisplay, ARRAYSIZE(pinfo->szDisplay));
    
    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CEnumNAVNEWSACCTS::Reset()
{
    m_iInfo = -1;
    
    return(S_OK);
}

HRESULT CEnumNAVNEWSACCTS::Init(NSCPACCTINFO *pinfo, int cinfo)
{
    DWORD cb;
    
    Assert(pinfo != NULL);
    Assert(cinfo > 0);
    
    cb = cinfo * sizeof(NSCPACCTINFO);
    
    if (!MemAlloc((void **)&m_rgInfo, cb))
        return(E_OUTOFMEMORY);
    
    m_iInfo = -1;
    m_cInfo = cinfo;
    CopyMemory(m_rgInfo, pinfo, cb);
    
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\oeconprp.cpp ===
/*
 *    oeconprp . c p p
 *    
 *    Purpose:
 *        Implements connection dialog tab page for OE
 *    
 *    Owner:
 *        shaheedp.
 *    
 *    Copyright (C) Microsoft Corp. 1998.
 */

#include "pch.hxx"
#include <commctrl.h>
#include <imnxport.h>
#include <Shlwapi.h>
#include "acctman.h"
#include "acctui.h"
#include "connect.h"
#include "dllmain.h"
#include "resource.h"
#include "accthelp.h"
#include "server.h"
#include "strconst.h"
#include "oeconprp.h"
#include "demand.h"

ASSERTDATA

/*
 *  p r o t o t y p e s
 *
 */
 TCHAR  szLanConn[CCHMAX_CONNECTOID];

void UpdateControlStates(HWND hwnd)
{
    BOOL    fEnable, fLan;
    HWND    hwndCombo;
    TCHAR   szEntryName[CCHMAX_CONNECTOID];
    int     iSel;


    hwndCombo = GetDlgItem(hwnd, idcRasConnection);
    
    if (BST_CHECKED == IsDlgButtonChecked(hwnd, idcRasAndLan))
        fEnable = TRUE;
    else
        fEnable = FALSE;

    EnableWindow(hwndCombo, fEnable);

    EnableWindow(GetDlgItem(hwnd, idcRasAdd), fEnable);
    
    if (fEnable)
        fEnable = ((iSel = ComboBox_GetCurSel(hwndCombo)) != CB_ERR);

    if (fEnable)
    {
        ComboBox_GetLBText(hwndCombo, iSel, szEntryName);
        //If it is Lan we don't want to enable props        
        if (lstrcmp(szEntryName, szLanConn) == 0)
            fEnable = false;
    }
    EnableWindow(GetDlgItem(hwnd, idcRasProp), fEnable);
}

void OEConnProp_InitDialog(HWND hwnd, LPSTR szEntryName, DWORD iConnectType, BOOL fFirstInit)
{
    HWND    hwndCombo;
    int     iSel;

    Assert(szEntryName != NULL);


    hwndCombo = GetDlgItem(hwnd, idcRasConnection);
    if (fFirstInit)
        {

        SetIntlFont(hwndCombo);

        HrFillRasCombo(hwndCombo, FALSE, NULL);
        //Add the the Local Area Network to the combo box
        ComboBox_AddString(hwndCombo, szLanConn);

        }

    if (iConnectType == CONNECTION_TYPE_LAN || iConnectType == CONNECTION_TYPE_RAS)
    {
        //CheckRadioButton(hwnd, idcInetSettings, idcRasAndLan, idcRasAndLan);
        CheckDlgButton(hwnd, idcRasAndLan, BST_CHECKED);
        if (iConnectType == CONNECTION_TYPE_LAN)
        {
            iSel = (*szLanConn != 0) ? ComboBox_FindStringExact(hwndCombo, -1, szLanConn) : 0;
        }
        else
        {
            iSel = (*szEntryName != 0) ? ComboBox_FindStringExact(hwndCombo, -1, szEntryName) : 0;
        }

        ComboBox_SetCurSel(hwndCombo, iSel);

    }
    else
    {
        Assert(iConnectType == CONNECTION_TYPE_INETSETTINGS);
        ComboBox_SetCurSel(hwndCombo, 0);

    }

    UpdateControlStates(hwnd);
}

// if pAcct is NULL, we're in the wizard, otherwise we're in the prop sheet
void OEConnProp_WMCommand(HWND hwnd, HWND hwndCmd, int id, WORD wCmd, IImnAccount *pAcct)
    {
    BOOL fEnable;

    if (wCmd == BN_CLICKED)
        {
        switch (id)
            {
            case idcRasAdd:
                ConnectPage_MakeNewConnection(hwnd);
                EnableWindow(GetDlgItem(hwnd, idcRasProp), 
                         ComboBox_GetCurSel(GetDlgItem(hwnd, idcRasConnection)) != CB_ERR);
                UpdateControlStates(hwnd);
                break;
            
            case idcRasProp:
                ConnectPage_EditConnection(hwnd);
                break;
            
            default:
                UpdateControlStates(hwnd);

                if (pAcct != NULL)
                    {
                    PropSheet_Changed(GetParent(hwnd), hwnd);
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SETDIRTY, PAGE_RAS);
                    }
                break;
            }
        }
    else if (wCmd == CBN_SELENDOK && id == idcRasConnection)    
        {
        UpdateControlStates(hwnd);

        if (pAcct != NULL)
            {
            PropSheet_Changed(GetParent(hwnd), hwnd);
            PropSheet_QuerySiblings(GetParent(hwnd), SM_SETDIRTY, PAGE_RAS);
            }
        }
    }

//****
//Need to change these.
const static HELPMAP g_rgCtxMapConnect[] = {
                               {idcRasAndLan, 601},
                               {idcRasProp, IDH_NEWS_SERV_CNKT_PROPS},
                               {idcRasConnection, IDH_NEWS_SERV_CNKT_DIALUP_CONNECT},
                               {idcRasAdd, IDH_NEWS_SERV_CNKT_ADD},
                               {IDC_STATIC0, IDH_INETCOMM_GROUPBOX},
                               {IDC_STATIC1, IDH_INETCOMM_GROUPBOX},
                               {IDC_STATIC2, IDH_INETCOMM_GROUPBOX},
                               {IDC_STATIC3, IDH_INETCOMM_GROUPBOX},
                               {0,0}};

INT_PTR CALLBACK OEConnProp_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    ACCTTYPE        type;
    NMHDR          *pnmh;
    CAccount       *pAcct;
    BOOL            fModem;
    int             iSel;
    HWND            hwndModem, hwndCombo;
    SERVER_TYPE     sfType;
    char           *psz, szEntryName[CCHMAX_CONNECTOID], szBackup[CCHMAX_CONNECTOID];
    TCHAR           szRes[CCHMAX_STRINGRES];
    DWORD           dw;

    pAcct = (CAccount *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (uMsg)
        {
        case WM_INITDIALOG:

            LoadString(g_hInstRes, idsConnectionLAN, szLanConn, ARRAYSIZE(szLanConn));

            // Get the ServerParams and store them in our extra bytes
            pAcct = (CAccount *)((PROPSHEETPAGE *)lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pAcct);
            Assert(pAcct);
            
            pAcct->GetAccountType(&type);
            Assert(type == ACCT_MAIL || type == ACCT_NEWS);

            // Get the connection info    
            if (FAILED(pAcct->GetPropSz(AP_RAS_CONNECTOID, szEntryName, ARRAYSIZE(szEntryName))))
                szEntryName[0] = 0;

            if (FAILED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dw)))
            {
                dw = CONNECTION_TYPE_INETSETTINGS;
            }

            OEConnProp_InitDialog(hwnd, szEntryName, dw, TRUE);

            if (FAILED(pAcct->GetPropDw(AP_RAS_CONNECTION_FLAGS, &dw)))
                dw = 0;


            PropSheet_QuerySiblings(GetParent(hwnd), SM_INITIALIZED, PAGE_RAS);
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            return (TRUE);
            
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapConnect);

        case WM_COMMAND:
            OEConnProp_WMCommand(hwnd, GET_WM_COMMAND_HWND(wParam, lParam),
                                        GET_WM_COMMAND_ID(wParam, lParam),
                                        GET_WM_COMMAND_CMD(wParam, lParam),
                                        pAcct);
            return (TRUE);

        case WM_NOTIFY:
            pnmh = (NMHDR *)lParam;
            switch (pnmh->code)
                {
                case PSN_APPLY:

                    hwndCombo = GetDlgItem(hwnd, idcRasConnection);
                    if (IsDlgButtonChecked(hwnd, idcRasAndLan))
                    {
                        iSel = ComboBox_GetCurSel(hwndCombo);
                        if (iSel != CB_ERR)
                        {
                            ComboBox_GetLBText(hwndCombo, iSel, szEntryName);
                            if (lstrcmp(szLanConn, szEntryName) == 0)
                            {
                                dw = CONNECTION_TYPE_LAN;
                                EnableWindow(GetDlgItem(hwnd, idcRasProp), FALSE);
                            }
                            else
                            {
                                dw = CONNECTION_TYPE_RAS;
                                pAcct->SetPropSz(AP_RAS_CONNECTOID, szEntryName);
                            }
                        }
                        else
                        {
                            dw = CONNECTION_TYPE_INETSETTINGS;
                            CheckDlgButton(hwnd, idcRasAndLan, BST_UNCHECKED);
                        }
                    }
                    else
                    {
                        dw = CONNECTION_TYPE_INETSETTINGS;
                    }

                    if ((dw == CONNECTION_TYPE_LAN) || (dw == CONNECTION_TYPE_INETSETTINGS))
                    {
                        pAcct->SetPropSz(AP_RAS_CONNECTOID, NULL);
                    }

                    pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, dw);
                    
                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    dw = PAGE_RAS;
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SAVECHANGES, (LPARAM)&dw);
                    if (dw == -1)
                        {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return(TRUE);
                        }
                    break;
                }

            return(TRUE);
        }

    return (FALSE);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\netscape.h ===
#ifndef _INC_NETSCAPE
#define _INC_NETSCAPE

typedef struct tagNSCPACCTINFO
    {
    DWORD_PTR dwCookie;
    char szDisplay[CCHMAX_ACCOUNT_NAME];
    } NSCPACCTINFO;

// {39981126-C287-11D0-8D8C-00C04FD6202B}
DEFINE_GUID(CLSID_CEnumNSCPACCTS, 0x39981126L, 0xC287, 0x11D0, 0x8D, 0x8C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

class CEnumNSCPACCTS : public IEnumIMPACCOUNTS
    {
    private:
        ULONG           m_cRef;
        int             m_iInfo;
        UINT            m_cInfo;
        NSCPACCTINFO    *m_rgInfo;

    public:
        CEnumNSCPACCTS(void);
        ~CEnumNSCPACCTS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE Next(IMPACCOUNTINFO *pinfo);
        HRESULT STDMETHODCALLTYPE Reset(void);

        HRESULT Init(NSCPACCTINFO *pinfo, int cinfo);
    };

// {39981127-C287-11D0-8D8C-00C04FD6202B}
DEFINE_GUID(CLSID_CNscpAcctImport, 0x39981127L, 0xC287, 0x11D0, 0x8D, 0x8C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

class CNscpAcctImport : public IAccountImport, public IAccountImport2
    {
    private:
        ULONG           m_cRef;
        BOOL            m_fIni;
        TCHAR           m_szIni[MAX_PATH];
        UINT            m_cInfo;
        NSCPACCTINFO    *m_rgInfo;

        HRESULT InitAccounts(void);
        HRESULT IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);

    public:
        CNscpAcctImport(void);
        ~CNscpAcctImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);
        
        HRESULT STDMETHODCALLTYPE AutoDetect(DWORD *pcAcct, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum);
        HRESULT STDMETHODCALLTYPE GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct);

        HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd, DWORD_PTR dwCookie);
        HRESULT STDMETHODCALLTYPE GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved);
        HRESULT STDMETHODCALLTYPE GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo);
    };

#endif // _INC_NETSCAPE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\propcryp.h ===
// --------------------------------------------------------------------------------
// Propcryp.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __PROPCRYP_H
#define __PROPCRYP_H

interface IPStore;

// --------------------------------------------------------------------------------
// CPropCrypt
// --------------------------------------------------------------------------------
class CPropCrypt
{
public:
    CPropCrypt(void);
    ~CPropCrypt(void);
    ULONG AddRef();
    ULONG Release();
    HRESULT HrInit(void);

    HRESULT HrEncodeNewProp(LPSTR szAccountName, BLOB *pClear, BLOB *pEncoded);
    HRESULT HrEncode(BLOB *pClear, BLOB *pEncoded);
    HRESULT HrDecode(BLOB *pEncoded, BLOB *pClear);
    HRESULT HrDelete(BLOB *pEncoded);

private:
    ULONG           m_cRef;
    BOOL            m_fInit;
    IPStore         *m_pISecProv;
};

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
HRESULT HrCreatePropCrypt(CPropCrypt **ppPropCrypt);

#define DOUTL_CPROP (512)

#endif // __PROPCRYP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\oeconprp.h ===
/*
 *    c o n n e c t . h
 *    
 *    Purpose:
 *        Implements connection dialog tab page
 *    
 *    Owner:
 *        brettm.
 *    
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 */


#ifndef _OECONPRP_H
#define _OECONPRP_H

#include "ras.h"


void UpdateControlStates(HWND hwnd);
void OEConnProp_InitDialog(HWND hwnd, LPSTR szEntryName, DWORD iConnectType, BOOL fFirstInit);
void OEConnProp_WMCommand(HWND hwnd, HWND hwndCmd, int id, WORD wCmd, IImnAccount *pAcct);
INT_PTR CALLBACK OEConnProp_DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


#endif //_OECONPRP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\nexpress.cpp ===
#include "pch.hxx"
#include <imnact.h>
#include <acctimp.h>
#include <dllmain.h>
#include <resource.h>
#include <nexpress.h>
#include "newimp.h"
#include <shlwapi.h>
#include "strconst.h"

ASSERTDATA

#define MEMCHUNK    512

CNExpressAcctImport::CNExpressAcctImport()
{
    m_cRef = 1;
    m_fIni = FALSE;
    *m_szIni = 0;
    m_cInfo = 0;
    m_rgInfo = NULL;
}

CNExpressAcctImport::~CNExpressAcctImport()
{
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
}

STDMETHODIMP CNExpressAcctImport::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (ppv == NULL)
        return(E_INVALIDARG);
    
    *ppv = NULL;
    
    if ((IID_IUnknown == riid) || (IID_IAccountImport == riid))
        *ppv = (IAccountImport *)this;
    else if (IID_IAccountImport2 == riid)
        *ppv = (IAccountImport2 *)this;
    else
        return(E_NOINTERFACE);
    
    ((LPUNKNOWN)*ppv)->AddRef();
    
    return(S_OK);
}

STDMETHODIMP_(ULONG) CNExpressAcctImport::AddRef()
{
    return(++m_cRef);
}

STDMETHODIMP_(ULONG) CNExpressAcctImport::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return(0);
    }
    
    return(m_cRef);
}

const static char c_szConfig[] = "Config";
const static char c_szAuth[] = "Auth";
const static char c_szNxNNTPServer[] = "NNTPServer";
const static char c_szFullname[] = "Fullname";
const static char c_szOrganization[] = "Organization";
const static char c_szEmail[] = "Email";
const static char c_szNxUsername[] = "Username";
const static char c_szNNTPPort[] = "NNTPPort";
const static char c_szHomeDir[] = "HomeDir";
const static char c_szNewsrc[] = "NewsRC";
const static char c_szNxIni[] = "\\nx.ini";
const static char c_szNx[] = "nx";

const static char c_szRegServicesDef[] = "Software\\NewsXpress\\Services\\Default";
const static char c_szRegAuth[] = "Software\\NewsXpress\\Services\\Default\\Authorization";
const static char c_szRegNxUser[] = "Software\\NewsXpress\\User";
const static char c_szRegNxRoot[] = "Software\\NewsXpress";
const static char c_szRegNNTPServer[] = "NNTP Server";
const static char c_szRegNNTPPort[] = "NNTP Port";
const static char c_szRegHomeDir[] = "Home Dir";

HRESULT STDMETHODCALLTYPE CNExpressAcctImport::AutoDetect(DWORD *pcAcct, DWORD dwFlags)
{
    HKEY hkey;
    DWORD type, cb, dw;
    char szNewsServer[MAX_PATH], szWinPath[MAX_PATH];
    
    Assert(m_cInfo == 0);

    if (pcAcct == NULL)
        return(E_INVALIDARG);
    
    *pcAcct = 0;

    cb = sizeof(szNewsServer);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szRegServicesDef, c_szRegNNTPServer, &type, (LPBYTE)szNewsServer, &cb))
    {
        if (!MemAlloc((void **)&m_rgInfo, sizeof(NXACCTINFO)))
            return(E_OUTOFMEMORY);
        m_rgInfo->dwCookie = 0;
        *m_rgInfo->szUserPath = 0;
        StrCpyN(m_rgInfo->szDisplay, szNewsServer, ARRAYSIZE(m_rgInfo->szDisplay));
        m_cInfo = 1;
    }
    else
    {
        if (0 == GetEnvironmentVariable(c_szNx, szWinPath, ARRAYSIZE(szWinPath)))
        {
            if (0 == GetWindowsDirectory(szWinPath, ARRAYSIZE(szWinPath)))
                return(S_OK);

            StrCatBuff(szWinPath, c_szNxIni, ARRAYSIZE(szWinPath));
        }

        dw = GetFileAttributes(szWinPath);
        if (dw != -1 && dw != FILE_ATTRIBUTE_DIRECTORY)
        {
            if (GetPrivateProfileString(c_szConfig, c_szNxNNTPServer, c_szEmpty, szNewsServer, ARRAYSIZE(szNewsServer), szWinPath))
            {
                if (!MemAlloc((void **)&m_rgInfo, sizeof(NXACCTINFO)))
                    return(E_OUTOFMEMORY);
                m_rgInfo->dwCookie = 0;
                StrCpyN(m_rgInfo->szUserPath, szWinPath, ARRAYSIZE(m_rgInfo->szUserPath));
                StrCpyN(m_rgInfo->szDisplay, szNewsServer, ARRAYSIZE(m_rgInfo->szDisplay));
                m_cInfo = 1;
            }
        }
    }

    *pcAcct = m_cInfo;

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CNExpressAcctImport::InitializeImport(HWND hwnd, DWORD_PTR dwCookie)
{
    Assert(dwCookie == 0);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CNExpressAcctImport::EnumerateAccounts(IEnumIMPACCOUNTS **ppEnum)
{
    CEnumNXACCT *penum;
    HRESULT hr;
    
    if (ppEnum == NULL)
        return(E_INVALIDARG);
    
    *ppEnum = NULL;
    
    if (m_cInfo == 0)
        return(S_FALSE);
    Assert(m_rgInfo != NULL);
    
    penum = new CEnumNXACCT;
    if (penum == NULL)
        return(E_OUTOFMEMORY);
    
    hr = penum->Init(m_rgInfo, m_cInfo);
    if (FAILED(hr))
    {
        penum->Release();
        penum = NULL;
    }
    
    *ppEnum = penum;
    
    return(hr);
}

HRESULT STDMETHODCALLTYPE CNExpressAcctImport::GetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct)
{
    HRESULT hr;

    if (pAcct == NULL)
        return(E_INVALIDARG);

    hr = IGetSettings(dwCookie, pAcct, NULL);

    return(hr);
}

HRESULT CNExpressAcctImport::IGetSettings(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
{
    HRESULT hr;
    HKEY hkey;
    UINT port;
    NXACCTINFO *pinfo;
    char sz[512];
    DWORD cb, type;

    Assert(((int) dwCookie) >= 0 && dwCookie < (DWORD_PTR)m_cInfo);
    pinfo = &m_rgInfo[dwCookie];
    
    Assert(pinfo->dwCookie == dwCookie);

    hr = pAcct->SetPropSz(AP_ACCOUNT_NAME, pinfo->szDisplay);
    if (FAILED(hr))
        return(hr);

    if (*pinfo->szUserPath != 0)
    {
        // ini file

        if (GetPrivateProfileString(c_szConfig, c_szNxNNTPServer, c_szEmpty, sz, ARRAYSIZE(sz), pinfo->szUserPath))
        {
            hr = pAcct->SetPropSz(AP_NNTP_SERVER, sz);
            Assert(!FAILED(hr));
        }

        port = GetPrivateProfileInt(c_szConfig, c_szNNTPPort, 0, pinfo->szUserPath);
        if (port != 0)
        {
            hr = pAcct->SetPropDw(AP_NNTP_PORT, port);
            Assert(!FAILED(hr));
        }

        if (GetPrivateProfileString(c_szConfig, c_szFullname, c_szEmpty, sz, ARRAYSIZE(sz), pinfo->szUserPath))
        {
            hr = pAcct->SetPropSz(AP_NNTP_DISPLAY_NAME, sz);
            Assert(!FAILED(hr));
        }

        if (GetPrivateProfileString(c_szConfig, c_szEmail, c_szEmpty, sz, ARRAYSIZE(sz), pinfo->szUserPath))
        {
            hr = pAcct->SetPropSz(AP_NNTP_EMAIL_ADDRESS, sz);
            Assert(!FAILED(hr));
        }

        if (GetPrivateProfileString(c_szConfig, c_szOrganization, c_szEmpty, sz, ARRAYSIZE(sz), pinfo->szUserPath))
        {
            hr = pAcct->SetPropSz(AP_NNTP_ORG_NAME, sz);
            Assert(!FAILED(hr));
        }

        if (GetPrivateProfileString(c_szAuth, c_szNxUsername, c_szEmpty, sz, ARRAYSIZE(sz), pinfo->szUserPath))
        {
            hr = pAcct->SetPropSz(AP_NNTP_USERNAME, sz);
            Assert(!FAILED(hr));
        }
    }
    else
    {
        // registry

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegServicesDef, 0, KEY_READ, &hkey))
        {
            cb = sizeof(sz);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szRegNNTPServer, NULL, &type, (LPBYTE)sz, &cb))
            {
                hr = pAcct->SetPropSz(AP_NNTP_SERVER, sz);
                Assert(!FAILED(hr));
            }

            cb = sizeof(port);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szRegNNTPPort, NULL, &type, (LPBYTE)&port, &cb) && port != 0)
            {
                hr = pAcct->SetPropDw(AP_NNTP_PORT, port);
                Assert(!FAILED(hr));
            }

            RegCloseKey(hkey);
        }

        cb = sizeof(sz);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szRegAuth, c_szNxUsername, &type, (LPBYTE)sz, &cb) && cb > 1)
        {
            hr = pAcct->SetPropSz(AP_NNTP_USERNAME, sz);
            Assert(!FAILED(hr));
        }

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegNxUser, 0, KEY_READ, &hkey))
        {
            cb = sizeof(sz);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szEmail, NULL, &type, (LPBYTE)sz, &cb))
            {
                hr = pAcct->SetPropSz(AP_NNTP_EMAIL_ADDRESS, sz);
                Assert(!FAILED(hr));
            }

            cb = sizeof(sz);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szFullname, NULL, &type, (LPBYTE)sz, &cb))
            {
                hr = pAcct->SetPropSz(AP_NNTP_DISPLAY_NAME, sz);
                Assert(!FAILED(hr));
            }

            cb = sizeof(sz);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szOrganization, NULL, &type, (LPBYTE)sz, &cb))
            {
                hr = pAcct->SetPropSz(AP_NNTP_ORG_NAME, sz);
                Assert(!FAILED(hr));
            }

            RegCloseKey(hkey);
        }
    }

    if (pInfo != NULL)
    {
        // TODO: can we do any better than this???
        pInfo->dwConnect = CONN_USE_DEFAULT;
    }

    return(S_OK);
}

HRESULT CNExpressAcctImport::GetNewsGroup(INewsGroupImport *pImp, DWORD dwReserved)
{
    BOOL fRet;
    DWORD cb, type;
    char szHomeDir[MAX_PATH], szRCFile[MAX_PATH];
    HRESULT hr = S_OK;
    char *pListGroups = NULL;

    Assert(pImp != NULL);

    *szHomeDir = 0;
    fRet = FALSE;

    if (*m_rgInfo->szUserPath != 0)
    {
        if (GetPrivateProfileString(c_szConfig, c_szHomeDir, c_szEmpty, szHomeDir, MAX_PATH, m_rgInfo->szUserPath) &&
            GetPrivateProfileString(c_szConfig, c_szNewsrc, c_szEmpty, szRCFile, MAX_PATH, m_rgInfo->szUserPath))
        {
            fRet = TRUE;
        }
    }
    else
    {
        cb = sizeof(szHomeDir);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szRegNxRoot, c_szRegHomeDir, &type, (LPBYTE)szHomeDir, &cb) && cb > 1)
        {
            cb = sizeof(szRCFile);
            if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szRegServicesDef, c_szNewsrc, &type, (LPBYTE)szRCFile, &cb) && cb > 1)
            {
                fRet = TRUE;
            }
        }
    }

    if (fRet)
    {
        PathAppend(szHomeDir, szRCFile);

        if (SUCCEEDED(hr = GetSubListGroups(szHomeDir, &pListGroups)))
        {
            hr = pImp->ImportSubList(pListGroups);

            MemFree(pListGroups);
        }
    }

    return hr;
}

HRESULT CNExpressAcctImport::GetSubListGroups(char *szHomeDir, char **ppListGroups)
{
    HRESULT hr                      =   E_FAIL;
    HANDLE	hRCHandle				=	NULL;
    HANDLE	hRCFile					=	NULL;
    ULONG	cbRCFile				=	0;
    BYTE	*pBegin					=	NULL, 
            *pCurr					=	NULL, 
            *pEnd					=	NULL;
    int     nBalMem                 =   MEMCHUNK;
    int     nLine                   =   0,
            nCount                  =   0;
    char    cPlaceHolder            =   1;
    char    szLineHolder[MEMCHUNK];
    char    *pListGroups            =   NULL;
    
    Assert(szHomeDir);
    Assert(ppListGroups);
    *ppListGroups = NULL;

    hRCHandle = CreateFile( szHomeDir, GENERIC_READ, FILE_SHARE_READ, NULL, 
							OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

	if(hRCHandle == INVALID_HANDLE_VALUE)
		return hr;

	cbRCFile = GetFileSize(hRCHandle, NULL);

    if(!cbRCFile) // Empty File.
        goto Done;

	hRCFile = CreateFileMapping(hRCHandle, NULL, PAGE_READONLY, 0, 0, NULL);

	if(hRCFile == NULL)
    {
        CloseHandle(hRCHandle);
		return hr;
    }

    pBegin = (BYTE *)MapViewOfFile( hRCFile, FILE_MAP_READ, 0, 0, 0);

	if(pBegin == NULL)
    {
        CloseHandle(hRCHandle);
        CloseHandle(hRCFile);
		return hr;
    }

	pCurr = pBegin;
	pEnd = pCurr + cbRCFile;

    if (!MemAlloc((void **)&pListGroups, MEMCHUNK))
    {
        hr = E_OUTOFMEMORY;
        goto Done;
    }

    DWORD cchSizeListGroups = MEMCHUNK;
    ZeroMemory((void*)pListGroups, (cchSizeListGroups * sizeof(pListGroups[0])));
	
    while (pCurr < pEnd)
    {
        nLine = 0;
        while(!((pCurr[nLine] == ':') || (pCurr[nLine] == '!')) && (pCurr + nLine < pEnd))
            nLine++;

        if(pCurr + nLine > pEnd)
            break;

        if(pCurr[nLine] == '!')
            goto LineEnd;

        nLine++;
        if(nLine < MEMCHUNK)
            StrCpyN(szLineHolder, (char*)pCurr, nLine);
        else
            continue;

        if(nLine + 2 < nBalMem)
        {
            StrCatBuff(pListGroups, szLineHolder, cchSizeListGroups);
            StrCatBuff(pListGroups, "\1", cchSizeListGroups);
            nBalMem -= (nLine + 2);
        }
        else
        {
            cchSizeListGroups += (lstrlen(pListGroups) + 1 + MEMCHUNK);
            if(!MemRealloc((void **)&pListGroups, (cchSizeListGroups * sizeof(pListGroups[0]))))
            {
                hr = E_OUTOFMEMORY;
                goto Done;
            }
            nBalMem += MEMCHUNK;
            StrCatBuff(pListGroups, szLineHolder, cchSizeListGroups);
            StrCatBuff(pListGroups, "\1", cchSizeListGroups);
            nBalMem -= (nLine + 2);
        }

LineEnd:
        while(!((pCurr[nLine] == 0x0D) && (pCurr[nLine + 1] == 0x0A)) && (pCurr + nLine < pEnd))
            nLine++;
        pCurr += (nLine + 2);
    }

    if(lstrlen(pListGroups))
    {
        while(pListGroups[nCount] != '\0')
        {
            if(pListGroups[nCount] == cPlaceHolder)
            {
                pListGroups[nCount] = '\0';
            }
            nCount++;
        }
        *ppListGroups = pListGroups;
        hr = S_OK;
    }

Done:
    if(hRCHandle != INVALID_HANDLE_VALUE)
        CloseHandle(hRCHandle);
    if(pBegin)
        UnmapViewOfFile(pBegin);
    if(hRCFile)
        CloseHandle(hRCFile);

    return hr;
}

STDMETHODIMP CNExpressAcctImport::GetSettings2(DWORD_PTR dwCookie, IImnAccount *pAcct, IMPCONNINFO *pInfo)
    {
    if (pAcct == NULL ||
        pInfo == NULL)
        return(E_INVALIDARG);
    
    return(IGetSettings(dwCookie, pAcct, pInfo));
    }

CEnumNXACCT::CEnumNXACCT()
    {
    m_cRef = 1;
    // m_iInfo
    m_cInfo = 0;
    m_rgInfo = NULL;
    }

CEnumNXACCT::~CEnumNXACCT()
    {
    if (m_rgInfo != NULL)
        MemFree(m_rgInfo);
    }

STDMETHODIMP CEnumNXACCT::QueryInterface(REFIID riid, LPVOID *ppv)
    {

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
	else if (IID_IEnumIMPACCOUNTS == riid)
		*ppv = (IEnumIMPACCOUNTS *)this;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();
    else
        return(E_NOINTERFACE);

    return(S_OK);
    }

STDMETHODIMP_(ULONG) CEnumNXACCT::AddRef()
    {
    return(++m_cRef);
    }

STDMETHODIMP_(ULONG) CEnumNXACCT::Release()
    {
    if (--m_cRef == 0)
        {
        delete this;
        return(0);
        }

    return(m_cRef);
    }

HRESULT STDMETHODCALLTYPE CEnumNXACCT::Next(IMPACCOUNTINFO *pinfo)
    {
    if (pinfo == NULL)
        return(E_INVALIDARG);

    m_iInfo++;
    if ((UINT)m_iInfo >= m_cInfo)
        return(S_FALSE);

    Assert(m_rgInfo != NULL);

    pinfo->dwCookie = m_rgInfo[m_iInfo].dwCookie;
    pinfo->dwReserved = 0;
    StrCpyN(pinfo->szDisplay, m_rgInfo[m_iInfo].szDisplay, ARRAYSIZE(pinfo->szDisplay));

    return(S_OK);
    }

HRESULT STDMETHODCALLTYPE CEnumNXACCT::Reset()
    {
    m_iInfo = -1;

    return(S_OK);
    }

HRESULT CEnumNXACCT::Init(NXACCTINFO *pinfo, int cinfo)
    {
    DWORD cb;

    Assert(pinfo != NULL);
    Assert(cinfo > 0);

    cb = cinfo * sizeof(NXACCTINFO);
    
    if (!MemAlloc((void **)&m_rgInfo, cb))
        return(E_OUTOFMEMORY);

    m_iInfo = -1;
    m_cInfo = cinfo;
    CopyMemory(m_rgInfo, pinfo, cb);

    return(S_OK);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\resource.h ===
// --------------------------------------------------------------------------------
// Resource.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// Strings
// --------------------------------------------------------------------------------
#define IDS_FIRST                       40016

#define idsAccount                      (IDS_FIRST + 200)
#define idsConnection                   (IDS_FIRST + 201)
#define idsConnectionLAN                (IDS_FIRST + 202)
#define idsConnectionRAS                (IDS_FIRST + 203)
#define idsConnectionManual             (IDS_FIRST + 204)
#define idsWarnDeleteAccount            (IDS_FIRST + 205)
#define idsAccountManager               (IDS_FIRST + 206)
#define idsErrSetDefNoSmtp              (IDS_FIRST + 207)
#define idsErrChooseConnection          (IDS_FIRST + 208)
#define idsConnectionLANBackup          (IDS_FIRST + 209)
#define idsMailConDlgLabel              (IDS_FIRST + 210)
#define idsErrNoRas1                    (IDS_FIRST + 211)
#define idsErrNoRas2                    (IDS_FIRST + 212)
#define idsMailAcctProperties           (IDS_FIRST + 214)
#define idsNewsAcctProperties           (IDS_FIRST + 215)
#define idsDirSrvAcctProperties         (IDS_FIRST + 216)
#define idsEnterLdapServer              (IDS_FIRST + 217)
#define idsEnterNntpServer              (IDS_FIRST + 218)
#define idsEnterDisplayName             (IDS_FIRST + 219)
#define idsEnterSmtpServer              (IDS_FIRST + 220)
#define idsEnterPop3Server              (IDS_FIRST + 221)
#define idsEnterIMAPServer              (IDS_FIRST + 222)
#define idsInvalidNntpServer            (IDS_FIRST + 223)
#define idsInvalidPop3Server            (IDS_FIRST + 224)
#define idsInvalidSmtpServer            (IDS_FIRST + 225)
#define idsInvalidIMAPServer            (IDS_FIRST + 226)
#define idsEnterEmailAddress            (IDS_FIRST + 230)
#define idsInvalidLdapServer            (IDS_FIRST + 231)
#define idsXSeconds                     (IDS_FIRST + 234)
#define ids1Minute                      (IDS_FIRST + 235)
#define idsXMinutes                     (IDS_FIRST + 236)
#define idsInvalidAccountName           (IDS_FIRST + 238)
#define idsErrPortNum                   (IDS_FIRST + 239)
#define idsInvalidEmailAddress          (IDS_FIRST + 240)
#define idsPOP                          (IDS_FIRST + 242)
#define idsIMAP                         (IDS_FIRST + 243)
#define idsIncomingMailPOP              (IDS_FIRST + 244)
#define idsIncomingMailIMAP             (IDS_FIRST + 245)
#define idsDelivery                     (IDS_FIRST + 246)
#define idsEnterRemoveFromServerDays    (IDS_FIRST + 248)
#define idsEnterBreakSize               (IDS_FIRST + 255)
#define idsType                         (IDS_FIRST + 266)
#define idsMail                         (IDS_FIRST + 267)
#define idsNews                         (IDS_FIRST + 268)
#define idsDirectoryService             (IDS_FIRST + 269)
#define idsDefault                      (IDS_FIRST + 270)
#define idsMailCap                      (IDS_FIRST + 271)
#define idsNewsCap                      (IDS_FIRST + 272)
#define idsDirectoryServiceCap          (IDS_FIRST + 273)
#define idsAll                          (IDS_FIRST + 274)
#define idsInvalidReplyToAddress        (IDS_FIRST + 275)
#define idsErrMatches                   (IDS_FIRST + 277)
#define idsNeedUniqueAccountName        (IDS_FIRST + 278)
#define idsAcctPropsFmt                 (IDS_FIRST + 279)
#define idsEnterAcctName                (IDS_FIRST + 280)
#define idsConnectionWizard             (IDS_FIRST + 284)
#define IDS_MAILLOGON_DESC              (IDS_FIRST + 285)
#define IDS_NEWSLOGON_DESC              (IDS_FIRST + 286)
#define IDS_LDAPLOGON_DESC              (IDS_FIRST + 287)
#define idsNewMailAccount               (IDS_FIRST + 288)
#define idsNewNewsAccount               (IDS_FIRST + 289)
#define idsNewLdapAccount               (IDS_FIRST + 290)
#define IDS_MAILACCT_DESC               (IDS_FIRST + 291)
#define IDS_NEWSACCT_DESC               (IDS_FIRST + 292)
#define IDS_MAIL_DESC                   (IDS_FIRST + 299)
#define idsCancelWizard                 (IDS_FIRST + 302)
#define idsDefaultAccount               (IDS_FIRST + 305)
#define idsDefaultNewsAccount           (IDS_FIRST + 306)
#define idsLogonUsingSPA                (IDS_FIRST + 308)
#define idsNoLogonRequired              (IDS_FIRST + 309)
#define idsNeedEmailForCert             (IDS_FIRST + 317)
#define idsSelectCertTitle              (IDS_FIRST + 318)
#define idsMustChooseCert               (IDS_FIRST + 319)
#define idsBadCertChoice                (IDS_FIRST + 320)
#define idsGetCertURL                   (IDS_FIRST + 321)
#define idsIMAPPollForUnread            (IDS_FIRST + 322)
#define idsIMAPPollInbox                (IDS_FIRST + 323)
#define idsIMAPBlankSpecialFldrs        (IDS_FIRST + 324)
#define idsIMAPSentItemsFldr            (IDS_FIRST + 325)
#define idsIMAPDraftsFldr               (IDS_FIRST + 326)
#define idsMailPromptHeader             (IDS_FIRST + 328)
#define idsMailAcctHeader               (IDS_FIRST + 329)
#define idsYourNameHeader               (IDS_FIRST + 330)
#define idsMailAddressHeader            (IDS_FIRST + 331)
#define idsMailServerHeader             (IDS_FIRST + 332)
#define idsMailLogonHeader              (IDS_FIRST + 333)
#define idsNewsServerHeader             (IDS_FIRST + 334)
#define idsNewsLogonHeader              (IDS_FIRST + 335)
#define idsNewsAddressHeader            (IDS_FIRST + 336)
#define idsLdapServerHeader             (IDS_FIRST + 337)
#define idsLdapLogonHeader              (IDS_FIRST + 338)
#define idsLdapResolveHeader            (IDS_FIRST + 339)
#define idsMailMigrateHeader            (IDS_FIRST + 340)
#define idsMailImportHeader             (IDS_FIRST + 341)
#define idsMailSelectHeader             (IDS_FIRST + 342)
#define idsConfirmHeader                (IDS_FIRST + 343)
#define idsNewsMigrateHeader            (IDS_FIRST + 344)
#define idsNewsImportHeader             (IDS_FIRST + 345)
#define idsNewsSelectHeader             (IDS_FIRST + 346)
#define idsMailFolderHeader             (IDS_FIRST + 347)
#define idsCompleteHeader               (IDS_FIRST + 348)
#define idsMailConnectHeader            (IDS_FIRST + 349)
#define idsNewsConnectHeader            (IDS_FIRST + 350)
#define idsConnectionInetSettings       (IDS_FIRST + 352)
#define idsHTTPMail                     (IDS_FIRST + 353)
#define idsEnterHTTPMailServer          (IDS_FIRST + 354)
#define idsInvalidHTTPMailServer        (IDS_FIRST + 355)
#define idsImportFileFilter             (IDS_FIRST + 356)
#define idsImport                       (IDS_FIRST + 357)
#define idsExportFileExt                (IDS_FIRST + 358)
#define idsExport                       (IDS_FIRST + 359)
#define idsErrAccountExists             (IDS_FIRST + 360)
#define idsErrImportFailed              (IDS_FIRST + 361)
#define idsHTTPMailOther                (IDS_FIRST + 362)
#define idsHTTPCreateFinishTag          (IDS_FIRST + 363)
#define idsHTTPCreateFinishMsg          (IDS_FIRST + 364)
#define idsNormalFinishTag              (IDS_FIRST + 365)
#define idsNormalFinishMsg              (IDS_FIRST + 366)
#define idsIMAPSpecialFldr_InboxDup     (IDS_FIRST + 367)
#define idsIMAPSpecialFldr_Duplicate    (IDS_FIRST + 368)
#define idsMailSignature                (IDS_FIRST + 370)
#define idsNewsSignature                (IDS_FIRST + 371)
#define idsIncomingPopImapHttp          (IDS_FIRST + 372)
#define idsIMAPNoHierarchyChars         (IDS_FIRST + 373)
#define idsPromptCloseWiz               (IDS_FIRST + 374)
#define idsFmtSetupAccount              (IDS_FIRST + 375)
#define idsAccountNameErr               (IDS_FIRST + 376)
#define idsAutoDiscoveryDescTitle       (IDS_FIRST + 377)
#define idsADURLLink                    (IDS_FIRST + 378)
#define idsADSkipButton                 (IDS_FIRST + 379)
#define idsADUseWebMsg                  (IDS_FIRST + 380)
#define idsADGetInfoMsg                 (IDS_FIRST + 381)

#define ids_ADStatus_ConnectingTo       (IDS_FIRST + 382)
#define ids_ADStatus_Downloading        (IDS_FIRST + 383)
#define ids_ADPassifier_Warning         (IDS_FIRST + 384)

// --------------------------------------------------------------------------------
// Dialogs
// --------------------------------------------------------------------------------
#define iddManageAccounts               101
#define iddServerProp_General           102
#define iddServerProp_Advanced          103
#define iddServerProp_Connect           104
#define iddMailSvrProp_General          105
#define iddMailSvrProp_Advanced         106
#define iddMailSvrProp_Servers          107
#define iddServerProp_Server            108
#define iddDirServProp_General          109
#define iddDirServProp_Advanced         110
#define iddSetOrder                     111
#define iddSmtpServerLogon              112
#define iddMailSvrProp_Security         113
#define iddCertAddressError             114
#define iddServerProp_Connect2          115
#define iddMailSvrProp_IMAP             116
#define iddServerProp_ConnectOE         117
#define iddMailSvrProp_HttpServer       118
#define iddHotWizDlg                    119

// --------------------------------------------------------------------------------
// Icons
// --------------------------------------------------------------------------------
#define idiMailServer                   100
#define idiNewsServer                   101
#define idiPhone                        102
#define idiLDAPServer                   103
#define idiMsnServer                    104

// --------------------------------------------------------------------------------
// Bitmaps
// --------------------------------------------------------------------------------
#define idbFolders                      101
#define idbICW                          102

// menus
#define idmrAddAccount                  100

// acctui.h
// dialog controls
#define IDC_STATIC                              -1
#define IDC_MAILACCOUNT_EDIT                    2000
#define IDC_SERVERNAME_EDIT                     2001
#define IDC_USEMAILSETTINGS                     2002
#define IDC_SPECIFYSETTINGS                     2003
#define IDC_LOGONSSPI_CHECK                     2004
#define IDC_ACCTNAME_EDIT                       2005
#define IDC_ACCTPASS_EDIT                       2006
#define IDC_NNTPPORT_EDIT                       2007
#define IDC_SECURECONNECT_BUTTON                2008
#define IDC_TIMEOUT_SLIDER                      2009
#define IDC_TIMEOUT_STATIC                      2010
#define IDC_USEDESC_CHECK                       2011
#define IDC_NEWSNAME_EDIT                       2012
#define IDC_ACCTNAME_STATIC                     2013
#define IDC_ACCTPASS_STATIC                     2014
#define IDC_IMAP_EDIT                           2015
#define IDC_IMAPPORT_EDIT                       2016
#define IDC_DEFAULT_SEND_CHECK                  2017
#define IDC_RECVFULL_INCLUDE                    2018
#define IDB_MACCT_ADD                           2019
#define IDB_MACCT_REMOVE                        2020
#define IDB_MACCT_PROP                          2021
#define IDLV_MAIL_ACCOUNTS                      2022   
#define IDB_MACCT_TAB                           2023
#define IDB_MACCT_IMPORT                        2024
#define IDB_MACCT_EXPORT                        2025
#define IDC_SECURECONNECT_POP3_BUTTON           2026
#define IDC_SECURECONNECT_SMTP_BUTTON           2027
#define IDB_MACCT_DEFAULT                       2028
#define IDE_DISPLAY_NAME                        2029
#define IDE_ORG_NAME                            2030
#define IDE_EMAIL_ADDRESS                       2031
#define IDE_REPLYTO_EMAIL_ADDRESS               2032
#define IDC_SPLIT_CHECK                         2033
#define IDC_SPLIT_EDIT                          2034
#define IDC_SPLIT_SPIN                          2035
#define IDC_SMTP_PORT_EDIT                      2036
#define IDC_POP3_PORT_EDIT                      2037
#define IDC_USEDEFAULTS_BUTTON                  2038
#define IDC_OPIE                                2039
#define IDC_RESET                               2040
#define IDB_MACCT_ORDER                         2041
#define IDC_ORDER_LIST                          2042
#define IDC_UP_BUTTON                           2043
#define IDC_DOWN_BUTTON                         2044
#define IDC_LDAP_PORT_EDIT                      2045
#define IDC_SPLIT_GROUPBOX                      2046
#define IDC_SPLIT_STATIC                        2047
#define IDB_MACCT_ADD_NOMENU                    2048
#define IDC_SERVER_STATIC                       2049
#define IDC_SERVER1_STATIC                      2050
#define IDC_NEWSPOLL_CHECK                      2051
#define IDC_MAILSERVER_ICON                     2052

#define IDC_NAME_EDIT               1000
#define IDC_POP3_EDIT               1002
#define IDC_SMTP_EDIT               1003
#define IDC_ADDRESS_EDIT            1004
#define IDC_PASSWORD_EDIT           1005
#define IDC_PASSWORD_CHECK          1006
#define IDC_SERVER_EDIT             1007
#define IDC_LOGON_CHECK             1008
#define IDC_ACCOUNT_EDIT            1009
#define IDC_ORG_EDIT                1010
#define IDC_LEAVE_CHECK             1012
#define IDC_REMOVE_CHECK            1013
#define IDC_REMOVE_EDIT             1014
#define IDC_REMOVE_SPIN             1015
#define IDC_REMOVEDELETE_CHECK      1016
#define IDC_REPLYTO_EDIT            1017
#define IDC_DOWNLOAD_CHECK          1018
#define IDC_DOWNLOAD_EDIT           1019
#define IDC_DOWNLOAD_SPIN           1020
#define IDC_DEFAULT_YES             1021
#define IDC_DEFAULT_NO              1022
#define IDC_LOGON_ACCT_RADIO        1023
#define IDC_LOGON_SICILY_RADIO      1024
#define idcPOP_OR_IMAP              1025
#define IDC_IN_MAIL_STATIC          1026
#define IDC_DELIVERY_GROUPBOX       1027
#define IDC_ROOT_FOLDER_STATIC      1028
#define IDC_ROOT_FOLDER_EDIT        1029
#define IDC_RESOLVE_CHECK           1030
#define IDC_TIMEOUT_EDIT            1031
#define IDC_MATCHES_EDIT            1032
#define IDC_SEARCHBASE_EDIT         1033
#define IDC_MATCHES_STATIC          1034
#define IDC_MATCHES_SPIN            1035
#define IDC_GROUPBOX1               1036
#define IDC_GROUPBOX2               1037
#define IDC_GROUPBOX3               1038
#define IDC_GROUPBOX4               1039
#define idcCertCheck                1040
#define idcCertButton               1041
#define idcCertEdit                 1042
#define IDC_IMAP_POLL_ALL_FOLDERS           1043
#define IDC_GETCERT                 1044
#define IDC_MOREINFO                1045
#define idcCertAddress              1046

#define IDC_ERR_STATIC              1047
#define IDC_CHANGE_ADDR             1048
#define IDC_NEW_CERT                1049
#define IDC_SIMPLESEARCH_BUTTON     1050

#define IDC_IMAPFLDRS_GROUPBOX      1051
#define IDC_IMAPSPECIALFLDRS_GB     1052
#define IDC_IMAP_SVRSPECIALFLDRS    1053
#define IDC_IMAPSENT_STATIC         1054
#define IDC_IMAPSENT_EDIT           1055
#define IDC_IMAPDRAFT_STATIC        1056
#define IDC_IMAPDRAFT_EDIT          1057

#define IDC_FORMAT_CHECK            1062
#define IDC_HTML_RADIO              1063
#define IDC_TEXT_RADIO              1064
#define IDC_REMEMBER_PASSWORD       1065


#define idmAddMail                  3000
#define idmAddNews                  3001
#define idmAddDirServ               3002
#define IDC_SMTP_SASL               3003
#define IDC_SMTPLOGON               3004

//These are only used by connect2 dialog brought up by account wizard. 
//Will be used by Outlook only
#define idcLan                                  1019        // don't reorder
#define idcManual                               1020        // don't reorder
#define idcRas                                  1021        // don't reorder
#define idcRasDesc                              1022
#define idcRasConnection                        1023
#define idcRasProp                              1024
#define idcRasAdd                               1025
#define idcRasDlgLabel                          1026
#define idchkDisconnectOnSend                   1027
#define idchkConnectOnStartup                   1028
#define IDC_MODEM_CHECK                         1029
#define idc

#define idcInetSettings                         1030        //don't reorder
#define idcRasAndLan                            1031        //don't reorder
#define idcConnPropDlgLabel                     1033

// ids.h
// Dialog IDs
#define IDD_PAGE_MAILPROMPT         2200
#define IDD_PAGE_MIGRATE            2201
#define IDD_PAGE_MAILACCTIMPORT     2202
#define IDD_PAGE_MIGRATESELECT      2203
#define IDD_PAGE_MAILCONFIRM        2204
#define IDD_PAGE_MAILACCT           2205
#define IDD_PAGE_MAILNAME           2207
#define IDD_PAGE_MAILADDRESS        2208
#define IDD_PAGE_MAILSERVER         2209
#define IDD_PAGE_MAILLOGON          2210
#define IDD_PAGE_AUTODISCOVERY      2211
#define IDD_PAGE_USEWEBMAIL         2212
#define IDD_PAGE_GOTOSERVERINFO     2213
#define IDD_PAGE_PASSIFIER          2214

#define IDD_PAGE_NEWSMIGRATE        2220
#define IDD_PAGE_NEWSACCTIMPORT     2221
#define IDD_PAGE_NEWSACCTSELECT     2222
#define IDD_PAGE_NEWSCONFIRM        2223
#define IDD_PAGE_NEWSNAME           2224
#define IDD_PAGE_NEWSADDRESS        2225
#define IDD_PAGE_NEWSINFO           2226
#define IDD_PAGE_NEWSSERVERSELECT   2227

#define IDD_PAGE_LDAPINFO           2230
#define IDD_PAGE_LDAPLOGON          2231
#define IDD_PAGE_LDAPRESOLVE        2232

#define IDD_PAGE_COMPLETE           2240
#define IDD_PAGE_CONNECT            2241

// dialog control IDs
#define IDC_BMPFRAME                  2100
#define IDC_USERNAME                  2110
#define IDC_PASSWORD                  2111
#define IDC_CONFIRMPASSWORD           2112
#define IDC_TX_SEPARATOR              2182
#define IDC_INSTALL                   2184
#define IDC_NOINSTALL                 2185
#define IDC_NAME                      2186
#define IDC_ADDRESS                   2187
#define IDC_INCOMINGSERVER            2188
#define IDC_INCOMINGSERVER_DESC       2289
#define IDC_SMTPSERVER                2190
#define IDC_SERVER                    2192
#define IDC_LOGON                     2195
#define IDC_SECURE                    2197
#define IDC_TX_ACCOUNT                2198
#define IDC_TX_PASSWORD               2199
#define IDC_HAVEACCOUNT               2200
#define IDC_CREATEACCOUNT             2201
#define IDC_ACCOUNTCOMBO              2202
#define IDC_AUTODISCOVERY_DESC        2203
#define IDC_AUTODISCOVERY_STATUS      2204
#define IDC_AUTODISCOVERY_ANIMATION   2205
#define IDC_USEWEB_LINE1              2205
#define IDC_USEWEB_LINE2              2206
#define IDC_USEWEB_LINE3              2207
#define IDC_GETINFO_LINE1             2208
#define IDC_GETINFO_LINE2             2209
#define IDC_GETINFO_LINE3             2210

#define IDC_PASSIFIER_PRIVACYWARNING  2215
#define IDC_PASSIFIER_SKIPCHECKBOX    2216
#define IDC_PASSIFIER_PRIMARYLIST     2217
#define IDC_PASSIFIER_SECONDARYLIST   2220

#define IDC_INCOMINGMAILTYPE          2226
#define IDC_HTTPSERVCOMBO             2227
#define IDC_HTTPSERVTAG               2228

#define IDC_NEWACCT                   2230
#define IDC_EXISTINGACCT              2231
#define IDC_ACCTNAME                  2232
#define IDC_ACCTLIST                  2233
#define IDC_LBLMODIFYACCT             2234
#define IDC_MODIFYACCT                2235
#define IDC_NOMODIFYACCT              2236

#define IDC_CANCEL                    2240
#define IDC_DISABLELCP                2241
#define IDC_NODISABLELCP              2242

#define IDC_DESC                      2250
#define IDC_LOGONSSPI                 2253
#define IDC_LBLUSERNAME               2254
#define IDC_LBLPASSWORD               2255
#define IDC_PASSWORD_DESC             2256
#define IDC_ACCOUNTNAME_EXAMPLE       2257

#define IDC_RESOLVE                   2259
#define IDC_NORESOLVE                 2260

#define IDC_NAME_STATIC               2261
#define IDC_USERNAME_STATIC           2262
#define IDC_POP3_STATIC               2265
#define IDC_ADDRESS_STATIC            2266
#define IDC_SMTP_STATIC               2267
#define IDC_RESOLVE_STATIC            2268
#define IDC_SVR_STATIC                2269
#define IDC_CONNECTION_STATIC         2270
#define IDC_STATICTEXT                2273
#define IDC_CHECK1                    2274

#define IDC_FINISH_TITLE              2280
#define IDC_FINISH_MSG                2281
#define IDC_BEGINREGISTRATION         2282
#define IDC_SMTP_DESC                 2283
#define IDC_SMTP_TAG                  2284

#define IDC_ALGCOMBO                  2300
#define idcCryptButton                2301
#define idcCryptEdit                  2302

#define IDC_STATIC0                 4000
#define IDC_STATIC1                 4001
#define IDC_STATIC2                 4002
#define IDC_STATIC3                 4003
#define IDC_STATIC4                 4004
#define IDC_STATIC5                 4005
#define IDC_STATIC6                 4006
#define IDC_STATIC7                 4007
#define IDC_STATIC8                 4008
#define IDC_STATIC9                 4009
#define IDC_STATIC10                4010
#define IDC_STATIC11                4011
#define IDC_STATIC12                4012
#define IDC_STATIC13                4013
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\attrun1.h ===
#define IDC_SAFEOPEN_ALWAYS             1001
#define IDC_SAFEOPEN_ICON               1002
#define IDC_SAFEOPEN_EXPL               1003
#define IDC_SAFEOPEN_AUTOOPEN           1004
#define IDC_SAFEOPEN_AUTOSAVE           1005
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\propcryp.cpp ===
/*
**  p r o p c r y p . c p p
**   
**  Purpose:
**      Functions to provide blob-level access to the pstore
**
**  History
**       3/04/97: (t-erikne) support for non-pstore systems
**       2/15/97: (t-erikne) rewritten for pstore
**      12/04/96: (sbailey)  created
**   
**    Copyright (C) Microsoft Corp. 1996, 1997.
*/

#include "pch.hxx"
#include "propcryp.h"
#include <imnact.h>
#include <demand.h>

///////////////////////////////////////////////////////////////////////////
// 
// Structures, definitions
//

#define OBFUSCATOR              0x14151875;

#define PROT_SIZEOF_HEADER      0x02    // 2 bytes in the header
#define PROT_SIZEOF_XORHEADER   (PROT_SIZEOF_HEADER+sizeof(DWORD))

#define PROT_VERSION_1          0x01

#define PROT_PASS_XOR           0x01
#define PROT_PASS_PST           0x02

// Layout of registry data (v0)
//
// /--------------------------------
// | protected store name, a LPWSTR
// \--------------------------------
//
//
// Layout of registry data (v1)
//
// /----------------------------------------------------------------------
// | version (1 b) =0x01 |  type (1 b) =PROT_PASS_*  | data (see below)
// \----------------------------------------------------------------------
//
// data for PROT_PASS_PST
//  struct _data
//  {  LPWSTR szPSTItemName; }
// data for PROT_PASS_XOR
//  struct _data
//  {  DWORD cb;  BYTE pb[cb]; }
//

///////////////////////////////////////////////////////////////////////////
// 
// Prototypes
//

static inline BOOL FDataIsValidV0(BLOB *pblob);
static BOOL FDataIsValidV1(BYTE *pb);
static inline BOOL FDataIsPST(BYTE *pb);
static HRESULT XOREncodeProp(const BLOB *const pClear, BLOB *const pEncoded);
static HRESULT XORDecodeProp(const BLOB *const pEncoded, BLOB *const pClear);

///////////////////////////////////////////////////////////////////////////
// 
// Admin functions (init, addref, release, ctor, dtor)
//

HRESULT HrCreatePropCrypt(CPropCrypt **ppPropCrypt)
{
    *ppPropCrypt = new CPropCrypt();
    if (NULL == *ppPropCrypt)
        return TRAPHR(E_OUTOFMEMORY);
    return (*ppPropCrypt)->HrInit();
}

CPropCrypt::CPropCrypt(void) :  m_cRef(1), m_fInit(FALSE),
                                m_pISecProv(NULL)
{ }

CPropCrypt::~CPropCrypt(void)
{
    ReleaseObj(m_pISecProv);
}

ULONG CPropCrypt::AddRef(void)
{ return ++m_cRef; }

ULONG CPropCrypt::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

HRESULT CPropCrypt::HrInit(void)
{
    HRESULT hr;
    PST_PROVIDERID  provId = MS_BASE_PSTPROVIDER_ID;

    Assert(!m_pISecProv);
    if (FAILED(hr = PStoreCreateInstance(&m_pISecProv, &provId, NULL, 0)))
    {
        // this is true because we will now handle
        // all transactions without the protected store
        m_fInit = TRUE;
        hr = S_OK;
    }
    else if (SUCCEEDED(hr = PSTCreateTypeSubType_NoUI(
        m_pISecProv,
        &PST_IDENT_TYPE_GUID,
        PST_IDENT_TYPE_STRING,
        &PST_IMNACCT_SUBTYPE_GUID,
        PST_IMNACCT_SUBTYPE_STRING)))
        {
        m_fInit = TRUE;
        }

    return hr;
}

///////////////////////////////////////////////////////////////////////////
// 
//  Public encode/decode/delete functions
//
///////////////////////////////////////////////////////////////////////////

HRESULT CPropCrypt::HrEncodeNewProp(LPSTR szAccountName, BLOB *pClear, BLOB *pEncoded)
{
    HRESULT         hr = S_OK;
    const int       cchFastbuf = 50;
    WCHAR           szWfast[cchFastbuf];
    LPWSTR          szWalloc = NULL;
    LPWSTR          wszCookie = NULL;
    BLOB            blob;
    DWORD           dwErr;
    int             cchW;

    AssertSz (pClear && pEncoded, "Null Parameter");

    pEncoded->pBlobData = NULL;

    if (m_fInit == FALSE)
        return TRAPHR(E_FAIL);

    if (!m_pISecProv)
        {
        // protected store does not exist
        hr = XOREncodeProp(pClear, pEncoded);
        goto exit;
        }

    if (szAccountName)
        {
        if (!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szAccountName, -1,
            szWfast, cchFastbuf))
            {
            dwErr = GetLastError();

            if (ERROR_INSUFFICIENT_BUFFER == dwErr)
                {
                // get proper size and alloc buffer
                cchW = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                    szAccountName, -1, NULL, 0);
                if (FAILED(hr = HrAlloc((LPVOID *)&szWalloc, cchW*sizeof(WCHAR))))
                    goto exit;

                if (!(MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                    szAccountName, -1, szWalloc, cchW)))
                    {
                    hr = GetLastError();
                    goto exit;
                    }
                }
            else
                {
                hr = dwErr;
                goto exit;
                }
            }
        }
    else
        {
        szWfast[0] = '\000';
        }

    if (SUCCEEDED(hr = PSTSetNewData(m_pISecProv, &PST_IDENT_TYPE_GUID,
        &PST_IMNACCT_SUBTYPE_GUID, szWalloc?szWalloc:szWfast, pClear, pEncoded)))
        {
        BYTE *pb = pEncoded->pBlobData;
        DWORD sz = pEncoded->cbSize;

        Assert(pb);
        pEncoded->cbSize += PROT_SIZEOF_HEADER;
        //N This realloc is annoying.  If we assume the memory allocator used
        //N by the PST function, we could be smarter....
        if (FAILED(hr = HrAlloc((LPVOID *)&pEncoded->pBlobData, pEncoded->cbSize)))
            goto exit;
        pEncoded->pBlobData[0] = PROT_VERSION_1;
        pEncoded->pBlobData[1] = PROT_PASS_PST;
        Assert(2 == PROT_SIZEOF_HEADER);
        CopyMemory(&pEncoded->pBlobData[PROT_SIZEOF_HEADER], pb, sz);
        PSTFreeHandle(pb);
        }

exit:
    if (szWalloc)
        MemFree(szWalloc);
    if (FAILED(hr) && pEncoded->pBlobData)
        MemFree(pEncoded->pBlobData);

    return hr;
}

HRESULT CPropCrypt::HrEncode(BLOB *pClear, BLOB *pEncoded)
{
    HRESULT         hr;
    PST_PROMPTINFO  PromptInfo = { sizeof(PST_PROMPTINFO), 0, NULL, L""};

    AssertSz (pClear && pEncoded && 
        pClear->pBlobData && pClear->cbSize, "Null Parameter");
    
    if (m_fInit == FALSE)
        return TRAPHR(E_FAIL);

    if (m_pISecProv)
        {
        if (FDataIsValidV1(pEncoded->pBlobData) && FDataIsPST(pEncoded->pBlobData))
            {
            Assert(pEncoded->cbSize-PROT_SIZEOF_HEADER == 
                (lstrlenW((LPWSTR)(pEncoded->pBlobData+PROT_SIZEOF_HEADER))+1)*sizeof(WCHAR));

tryagain:
            hr = m_pISecProv->WriteItem(
                PST_KEY_CURRENT_USER,
                &PST_IDENT_TYPE_GUID,
                &PST_IMNACCT_SUBTYPE_GUID,
                (LPCWSTR)&pEncoded->pBlobData[PROT_SIZEOF_HEADER],
                (DWORD)pClear->cbSize,
                pClear->pBlobData,
                &PromptInfo,
                PST_CF_NONE,
                0);

            if (PST_E_TYPE_NO_EXISTS == hr)
                {
                DOUTL(DOUTL_CPROP, "PropCryp: somebody ruined my type or subtype");
                hr = PSTCreateTypeSubType_NoUI(
                    m_pISecProv,
                    &PST_IDENT_TYPE_GUID,
                    PST_IDENT_TYPE_STRING,
                    &PST_IMNACCT_SUBTYPE_GUID,
                    PST_IMNACCT_SUBTYPE_STRING);
                if (SUCCEEDED(hr))
                    goto tryagain;
                }
            }
        else
            {
#ifdef DEBUG
            if (FDataIsValidV0(pEncoded))
                DOUTL(DOUTL_CPROP, "PropCryp: V0 to V1 upgrade");
            else if (!FDataIsValidV1(pEncoded->pBlobData))
                DOUTL(DOUTL_CPROP, "PropCryp: invalid data on save");
#endif
            // now we have XOR data in a PST environment
            hr = HrEncodeNewProp(NULL, pClear, pEncoded);
            }
        }
    else
        {
        // protected store does not exist
        hr = XOREncodeProp(pClear, pEncoded);
        }

    return TrapError(hr);
}

/*  HrDecode:
**
**  Purpose:
**      Uses the protstor functions to retrieve a piece of secure data
**      unless the data is not pstore, then it maps to the XOR function
**  Takes:
**      IN     pEncoded - blob containing name to pass to PSTGetData
**         OUT pClear   - blob containing property data
**  Notes:
**      pBlobData in pClear must be freed with a call to CoTaskMemFree()
**  Returns:
**      hresult
*/
HRESULT CPropCrypt::HrDecode(BLOB *pEncoded, BLOB *pClear)
{
    HRESULT     hr;

    AssertSz(pEncoded && pEncoded->pBlobData && pClear, TEXT("Null Parameter"));

    pClear->pBlobData = NULL;

    if (m_fInit == FALSE)
        return TRAPHR(E_FAIL);
    if (!FDataIsValidV1(pEncoded->pBlobData))
        {
        if (FDataIsValidV0(pEncoded))
            {
            DOUTL(DOUTL_CPROP, "PropCryp: obtaining v0 value");
            // looks like we might have a v0 blob: the name string
            hr = PSTGetData(m_pISecProv, &PST_IDENT_TYPE_GUID, &PST_IMNACCT_SUBTYPE_GUID,
                (LPCWSTR)pEncoded->pBlobData, pClear);
            }
        else
            hr = E_InvalidValue;
        }
    else if (FDataIsPST(pEncoded->pBlobData))
        {
        Assert(pEncoded->cbSize-PROT_SIZEOF_HEADER == 
            (lstrlenW((LPWSTR)(pEncoded->pBlobData+PROT_SIZEOF_HEADER))+1)*sizeof(WCHAR));
        hr = PSTGetData(m_pISecProv, &PST_IDENT_TYPE_GUID, &PST_IMNACCT_SUBTYPE_GUID,
            (LPCWSTR)&pEncoded->pBlobData[PROT_SIZEOF_HEADER], pClear);
        }
    else
        {
        hr = XORDecodeProp(pEncoded, pClear);
        }

    return hr;
}

HRESULT CPropCrypt::HrDelete(BLOB *pProp)
{
    HRESULT hr;
    PST_PROMPTINFO  PromptInfo = { sizeof(PST_PROMPTINFO), 0, NULL, L""};

    if (m_fInit == FALSE)
        return TRAPHR(E_FAIL);

    if (m_pISecProv && FDataIsValidV1(pProp->pBlobData) && FDataIsPST(pProp->pBlobData))
        {
        Assert(pProp->cbSize-PROT_SIZEOF_HEADER == 
            (lstrlenW((LPWSTR)(pProp->pBlobData+PROT_SIZEOF_HEADER))+1)*sizeof(WCHAR));
        hr = m_pISecProv->DeleteItem(
            PST_KEY_CURRENT_USER,
            &PST_IDENT_TYPE_GUID,
            &PST_IMNACCT_SUBTYPE_GUID,
            (LPCWSTR)&pProp->pBlobData[PROT_SIZEOF_HEADER],
            &PromptInfo,
            0);
        }
    else
        // nothing to do
        hr = S_OK;

    return hr;
}

///////////////////////////////////////////////////////////////////////////
// 
// XOR functions
//
///////////////////////////////////////////////////////////////////////////

HRESULT XOREncodeProp(const BLOB *const pClear, BLOB *const pEncoded)
{
    DWORD       dwSize;
    DWORD       last, last2;
    DWORD       *pdwCypher;
    DWORD       dex;

    pEncoded->cbSize = pClear->cbSize+PROT_SIZEOF_XORHEADER;
    if (!MemAlloc((LPVOID *)&pEncoded->pBlobData, pEncoded->cbSize))
        return E_OUTOFMEMORY;
    
    // set up header data
    Assert(2 == PROT_SIZEOF_HEADER);
    pEncoded->pBlobData[0] = PROT_VERSION_1;
    pEncoded->pBlobData[1] = PROT_PASS_XOR;
    *((DWORD *)&(pEncoded->pBlobData[2])) = pClear->cbSize;

    // nevermind that the pointer is offset by the header size, this is
    // where we start to write out the modified password
    pdwCypher = (DWORD *)&(pEncoded->pBlobData[PROT_SIZEOF_XORHEADER]);

    dex = 0;
    last = OBFUSCATOR;                              // 0' = 0 ^ ob
    if (dwSize = pClear->cbSize / sizeof(DWORD))
        {
        // case where data is >= 4 bytes
        for (; dex < dwSize; dex++)
            {
            last2 = ((DWORD *)pClear->pBlobData)[dex];  // 1 
            pdwCypher[dex] = last2 ^ last;              // 1' = 1 ^ 0
            last = last2;                   // save 1 for the 2 round
            }
        }

    // if we have bits left over
    // note that dwSize is computed now in bits
    if (dwSize = (pClear->cbSize % sizeof(DWORD))*8)
        {
        // need to not munge memory that isn't ours
        last >>= sizeof(DWORD)*8-dwSize;
		pdwCypher[dex] &= ((DWORD)-1) << dwSize;
        pdwCypher[dex] |=
			((((DWORD *)pClear->pBlobData)[dex] & (((DWORD)-1) >> (sizeof(DWORD)*8-dwSize))) ^ last);
        }

    return S_OK;
}

HRESULT XORDecodeProp(const BLOB *const pEncoded, BLOB *const pClear)
{
    DWORD       dwSize;
    DWORD       last;
    DWORD       *pdwCypher;
    DWORD       dex;

    // we use CoTaskMemAlloc to be in line with the PST implementation
    pClear->cbSize = pEncoded->pBlobData[2];
    if (!(pClear->pBlobData = (BYTE *)CoTaskMemAlloc(pClear->cbSize)))
        return E_OUTOFMEMORY;
    
    // should have been tested by now
    Assert(FDataIsValidV1(pEncoded->pBlobData));
    Assert(!FDataIsPST(pEncoded->pBlobData));

    // nevermind that the pointer is offset by the header size, this is
    // where the password starts
    pdwCypher = (DWORD *)&(pEncoded->pBlobData[PROT_SIZEOF_XORHEADER]);

    dex = 0;
    last = OBFUSCATOR;
    if (dwSize = pClear->cbSize / sizeof(DWORD))
        {
        // case where data is >= 4 bytes
        for (; dex < dwSize; dex++)
            last = ((DWORD *)pClear->pBlobData)[dex] = pdwCypher[dex] ^ last;
        }

    // if we have bits left over
    if (dwSize = (pClear->cbSize % sizeof(DWORD))*8)
        {
        // need to not munge memory that isn't ours
        last >>= sizeof(DWORD)*8-dwSize;
        ((DWORD *)pClear->pBlobData)[dex] &= ((DWORD)-1) << dwSize;
        ((DWORD *)pClear->pBlobData)[dex] |=
				((pdwCypher[dex] & (((DWORD)-1) >> (sizeof(DWORD)*8-dwSize))) ^ last);
        }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////
// 
// Other static functions
//
///////////////////////////////////////////////////////////////////////////

BOOL FDataIsValidV1(BYTE *pb)
{ return pb && pb[0] == PROT_VERSION_1 && (pb[1] == PROT_PASS_XOR || pb[1] == PROT_PASS_PST); }

BOOL FDataIsValidV0(BLOB *pblob)
{ return ((lstrlenW((LPWSTR)pblob->pBlobData)+1)*sizeof(WCHAR) == pblob->cbSize); }

BOOL FDataIsPST(BYTE *pb)
#ifdef DEBUG
{
    if (pb)
        if (pb[1] == PROT_PASS_PST)
            {
            DOUTL(DOUTL_CPROP, "PropCryp: Data is PST");
            return TRUE;
            }
        else
            {
            DOUTL(DOUTL_CPROP, "PropCryp: Data is XOR");
            return FALSE;
            }
    else
        return FALSE;
}
#else
{ return pb && pb[1] == PROT_PASS_PST; }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\server.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     Server.h
//
//  PURPOSE:    Contains defines and prototypes for the Add/Remove News 
//              server dialog.
//
#ifndef _SERVER_H
#define _SERVER_H

interface IImnAccount;

typedef enum 
    {
    SERVER_NEWS = 0,
    SERVER_MAIL,    // pop3
    SERVER_IMAP,
    SERVER_LDAP,
    SERVER_HTTPMAIL,
    SERVER_TYPEMAX
    } SERVER_TYPE;

typedef struct tagMAILSERVERPROPSINFO
{
    DWORD server;
    DWORD userName;
    DWORD password;
    DWORD promptPassword;
    DWORD useSicily;
} MAILSERVERPROPSINFO, *LPMAILSERVERPROPSINFO;

BOOL GetServerProps(SERVER_TYPE serverType, LPMAILSERVERPROPSINFO *psp);
BOOL ServerProp_Create(HWND hwndParent, DWORD dwFlags, LPTSTR pszName, IImnAccount **ppAccount);
HRESULT ValidServerName(LPSTR szServer);
HRESULT GetIEConnectInfo(IImnAccount *pAcct);
HRESULT GetConnectInfoForOE(IImnAccount *pAcct);
IMNACCTAPI ValidEmailAddressParts(LPSTR lpAddress, LPSTR lpszAcct, DWORD cchSizeAcct, LPSTR lpszDomain, DWORD cchSizeDomain);

#endif //_SERVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\silent.cpp ===
#include "pch.hxx"
#include <prsht.h>
#include <msident.h>
#include "acctman.h"
#include <icwacct.h>
#include <strconst.h>
#include "dllmain.h"
#include "acctui.h"
#include "server.h"
#include <shlwapi.h>
#include "acctimp.h"
#include <icwwiz.h>
#include <wininet.h>
#include "resource.h"
#include "demand.h"

ASSERTDATA

enum
{
    NNTP = 0,
    POP3,
    IMAP,
    HTTP,
    LDAP
};

HRESULT HandleIdentity(LPCSTR pszSection, LPCSTR pszFile, CONNECTINFO *pci, DWORD dwFlags, IUserIdentityManager *pIdMan);
HRESULT HandleGlobalSettings(LPCSTR lpFile);

HRESULT CreateMailAccount(CAccountManager *pAcctMgr, LPCSTR szFile, LPCSTR szMailSection, CONNECTINFO *pci, HKEY hkey, LPSTR pszAcctId, DWORD cchSizeAcctID, DWORD dwFlags);
HRESULT CreateNewsAccount(CAccountManager *pAcctMgr, LPCSTR szFile, LPCSTR szNewsSection, LPCSTR szMailSection, CONNECTINFO *pci, HKEY hkey, IUserIdentity *pId, LPSTR pszAcctId, DWORD cchSizeAcctId, DWORD dwFlags);
HRESULT CreateLDAPAccount(CAccountManager *pAcctMgr, LPCSTR szFile, LPCSTR szLDAPSection, CONNECTINFO *pci);
HRESULT GetAccount(DWORD type, CAccountManager *pAcctMgr, LPCSTR szSection, LPCSTR szFile, IImnAccount **ppAcct);
HRESULT DeleteAccount(DWORD type, CAccountManager *pAcctMgr, LPCSTR szSection, LPCSTR szFile);
void HandleMultipleAccounts(ACCTTYPE type, CAccountManager *pAcctMgr, LPCSTR pszFile, LPCSTR szSection, CONNECTINFO *pci, HKEY hkey, IUserIdentity *pId, DWORD dwFlags);

void SetSignature(LPCSTR szMailSigSection, LPCSTR szNewsSigSection, LPCSTR pszMailId, LPCSTR pszNewsId, LPCSTR szFile, HKEY hkey, CAccountManager *pAcctMgr);
void DoDefaultClient(LPCSTR szFile, BOOL fMail);
void DoMailBranding(LPCSTR szFile, LPCSTR szMailSection, HKEY hkey);
void DoNewsBranding(LPCSTR szFile, LPCSTR szNewsSection, HKEY hkey);
void DoBranding(LPCSTR szFile, LPCSTR szOESection, HKEY hkey);
void SetHelp(LPCSTR szFile, LPCSTR szURLSection, HKEY hkey);
void SubscribeNewsgroups(IImnAccount *pAcct, LPCSTR szSection, LPCSTR szFile, HKEY hkey);
void SetRegDw(LPCSTR szFile, LPCSTR szSection, LPCSTR szValue, HKEY hkey, LPCSTR szRegValue);
void SetRegProp(LPCSTR szFile, LPCSTR szSection, LPCSTR szValue, HKEY hkey, LPCSTR szRegValue);
void SetRegLockPropLM(LPCSTR szFile, LPCSTR szSection, LPCSTR szValue, HKEY hkeyLM, LPCSTR szRegValue, HKEY hkeyCU);
BOOL GetSectionNames(LPSTR psz, DWORD cch, char chSep, DWORD *pcNames);

static const char c_sz1[] = "1";
static const char c_szRegRootMail[] = STR_REG_PATH_ROOT "\\Mail";
static const char c_szRegRootNews[] = STR_REG_PATH_ROOT "\\News";
static const char c_szRegRootRules[] = STR_REG_PATH_ROOT "\\Rules";
static const char c_szRegRootSigs[] = STR_REG_PATH_ROOT "\\Signatures";

///////////////////////////////////////////////////////////////////////////////
// INS file section names

static const char c_szIdentitySection[] = "Identities";
static const char c_szMailSection[] = "Internet_Mail";
static const char c_szNewsSection[] = "Internet_News";
static const char c_szLDAPSection[] = "LDAP";
static const char c_szMailSigSection[] = "Mail_Signature";
static const char c_szNewsSigSection[] = "Signature";
static const char c_szURLSection[] = "URL";
static const char c_szOESection[] = "Outlook_Express";
static const char c_szGlobalSection[] = "Outlook_Express_Global";

//
///////////////////////////////////////////////////////////////////////////////

static const char c_szAcctName[] = "Account_Name";
static const char c_szReplyAddr[] = "Reply_To_Address";
static const char c_szIEConnect[] = "Use_IE_Connection";
static const char c_szUseSSL[] = "Use_SSL";
static const char c_szOldServer[] = "Server_Old";
static const char c_szMultiAccounts[] = "Multiple_Accounts";
static const char c_szNone[] = "none";
static const char c_szBase64[] = "base 64";
static const char c_szQuotedPrintable[] = "quoted printable";
static const char c_szMime[] = "mime";
static const char c_szUuencode[] = "uuencode";
static const char c_szDeleteAccount[] = "Delete_Account";

///////////////////////////////////////////////////////////////////////////////
// identity values

static const char c_szGUID[] = "GUID";
static const char c_szUserName[] = "User_Name";
static const char c_szRegInsGUID[] = "INS File GUID";

//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// [URL] section values

static const char c_szHelpPage[] = "Help_Page";

//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// [Internet_Mail] section values

static const char c_szMailName[] = "Email_Name";
static const char c_szMailAddr[] = "Email_Address";
static const char c_szPopServer[] = "POP_Server";
static const char c_szPopPort[] = "POP_Server_Port_Number";
static const char c_szMailLogon[] = "POP_Logon_Name";
static const char c_szMailPassword[] = "POP_Logon_Password";
static const char c_szPopLeaveOnServer[] = "POP_Leave_On_Server";
static const char c_szPopRemoveOnDelete[] = "POP_Remove_When_Deleted";
static const char c_szSmtpServer[] = "SMTP_Server";
static const char c_szSmtpPort[] = "SMTP_Server_Port_Number";
static const char c_szSmtpUseSSL[] = "Use_SSL_Send";
static const char c_szSmtpLogonReq[] = "SMTP_Logon_Required";
static const char c_szSmtpLogon[] = "SMTP_Logon_Name";
static const char c_szSmtpPassword[] = "SMTP_Logon_Password";
static const char c_szSmtpLogonUsingSPA[] = "SMTP_Logon_Using_SPA";
static const char c_szLogonUsingSPA[] = "Logon_Using_SPA";
static const char c_szUseImap[] = "Use_IMAP";
static const char c_szImapServer[] = "IMAP_Server";
static const char c_szImapPort[] = "IMAP_Server_Port_Number";
static const char c_szImapLogon[] = "IMAP_Logon_Name";
static const char c_szImapPassword[] = "IMAP_Logon_Password";
static const char c_szImapRoot[] = "IMAP_Root_Folder";
static const char c_szImapSentItems[] = "IMAP_Sent_Items";
static const char c_szImapDrafts[] = "IMAP_Drafts";
static const char c_szImapPoll[] = "Poll_Subscribed_Folders";
static const char c_szService[] = "Service";
static const char c_szHttpUrl[] = "HTTP_Mail_Root_URL";
static const char c_szHttpLogon[] = "HTTP_Mail_Logon_Name";
static const char c_szHttpPassword[] = "HTTP_Mail_Logon_Password";
static const char c_szHttpPoll[] = "HTTP_Poll_Folders";
static const char c_szMsnCom[] = "MSN_COM";

static const char c_szWinTitle[] = "Window_Title";
static const char c_szInfopane[] = "Infopane";
static const char c_szWelcomeMsg[] = "Welcome_Message";
static const char c_szProfWelcomeName[] = "Welcome_Name";
static const char c_szProfWelcomeEmail[] = "Welcome_Address";
static const char c_szPollTime[] = "PollTime";
static const char c_szStartAtInbox[] = "Start_at_Inbox";
static const char c_szJunkMail[] = "Junk_Mail_Filtering";
static const char c_szHTMLMsgs[] = "HTML_Msgs";

//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// [Internet_News] section values

static const char c_szNewsName[] = "News_Name";
static const char c_szNewsAddr[] = "News_Address";
static const char c_szNewsServer[] = "NNTP_Server";
static const char c_szNewsPort[] = "NNTP_Server_Port_Number";
static const char c_szNewsLogon[] = "NNTP_Logon_Name";
static const char c_szNewsPassword[] = "NNTP_Logon_Password";
static const char c_szNewsLogonRequired[] = "Logon_Required";
static const char c_szNewsgroups[] = "Newsgroups";

//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// [LDAP] section values

static const char c_szLDAPServer[] = "Server";
static const char c_szLDAPFriendlyName[] = "FriendlyName";
static const char c_szLDAPHomePage[] = "HomePage";
static const char c_szLDAPSearchBase[] = "SearchBase";
static const char c_szLDAPAuthType[] = "AuthType";
static const char c_szLDAPCheckNames[] = "CheckNames";
static const char c_szLDAPUserName[] = "UserName";
static const char c_szLDAPPassword[] = "Password";
static const char c_szLDAPLogo[] = "Bitmap";
static const char c_szLDAPPort[] = "LDAP_Server_Port_Number";
static const char c_szLDAPResults[] = "Maximum_Results";
static const char c_szLDAPTimeout[] = "Search_Timeout";

//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// [Outlook_Express] section values

static const char c_szFolderBar[] = "Folder_Bar";
static const char c_szFolderList[] = "Folder_List";
static const char c_szOutlookBar[] = "Outlook_Bar";
static const char c_szStatusBar[] = "Status_Bar";
static const char c_szContacts[] = "Contacts";
static const char c_szTipOfTheDay[] = "Tip_Day";
static const char c_szToolbar[] = "Toolbar";
static const char c_szToolbarText[] = "Show_Toolbar_Text";
static const char c_szPreviewPane[] = "Preview_Pane";
static const char c_szPreviewHeader[] = "Show_Preview_Header";
static const char c_szPreviewSide[] = "Show_Preview_Beside_Msgs";
static const char c_szMigration[] = "Migration";
static const char c_szSecZone[] = "Security_Zone";
static const char c_szSecZoneLocked[] = "Security_Zone_Locked";
static const char c_szMapiWarn[] = "Warn_on_Mapi_Send";
static const char c_szMapiWarnLocked[] = "Warn_on_Mapi_Send_Locked";
static const char c_szSafeAttach[] = "Safe_Attachments";
static const char c_szSafeAttachLocked[] = "Safe_Attachments_Locked";
static const char c_szSendEncoding[] = "Send_Language_Encoding";
static const char c_szReadEncoding[] = "Read_Language_Encoding";
static const char c_szMailEncoding[] = "HTML_Mail_Encoding";
static const char c_szNewsEncoding[] = "HTML_News_Encoding";
static const char c_szMailEnglishHeader[] = "HTML_Mail_Allow_English_Mail_Headers";
static const char c_szNewsEnglishHeader[] = "HTML_News_Allow_English_Mail_Headers";
static const char c_szMailPlainEncoding[] = "Plain_Text_Mail_Encoding";
static const char c_szNewsPlainEncoding[] = "Plain_Text_News_Encoding";
static const char c_szMailPlainEnglishHeader[]  = "Plain_Text_Allow_English_Mail_Headers";
static const char c_szNewsPlainEnglishHeader[]  = "Plain_Text_Allow_English_News_Headers";
static const char c_szRequestReadReceipts[]         = "Request_read_receipts";
static const char c_szReadReceiptResponse[]         = "Read_receipt_response";
static const char c_szSendReceiptsToList[]          = "Send_receipts_to_list";
static const char c_szRequestReadReceiptsLocked[]   = "Request_read_receipts_locked";
static const char c_szReadReceiptResponseLocked[]   = "Read_receipt_response_locked";
static const char c_szSendReceiptsToListLocked[]    = "Send_receipts_to_list_locked";

//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// [Outlook_Express_Global] section values

static const char c_szReadOnlyAccts[] = "Read_Only";
static const char c_szDisableAccts[] = "Disable_Account_Access";
static const char c_szInsHideMessenger[] = "Hide_Messenger";
static const char c_szHideMSN[] = "Hide_MSN";
static const char c_szServiceName[] = "Service_Name";
static const char c_szServiceURL[] = "Service_URL";
static const char c_szAccountNumber[] = "Account_Number";
static const char c_szInsEnableHttpmail[] = "Enable_HTTPMail";

//
///////////////////////////////////////////////////////////////////////////////

static const char c_szUseSig[] = "Use_Signature";
static const char c_szProfSigText[] = "Signature_Text";
static const char c_szUseMailForNews[] = "Use_Mail_For_News";
static const char c_szMailSigKey[] = "MailIEAK";
static const char c_szNewsSigKey[] = "NewsIEAK";
static const char c_szDefClient[] = "Default_Client";

static const char c_szRegProfile[] = "InternetProfile";

#define CBPROFILEBUF    0x07fff

// From mailnews\inc\goptions.h
#define SIGFLAG_AUTONEW         0x0001  // automatically add sig to new messages
#define SIGFLAG_AUTOREPLY       0x0002  // automatically add sig to reply/forward messages

HRESULT WINAPI CreateAccountsFromFile(LPSTR lpFile, DWORD dwFlags)
{
    return(CreateAccountsFromFileEx(lpFile, NULL, dwFlags));
}

HRESULT WINAPI CreateAccountsFromFileEx(LPSTR lpFile, CONNECTINFO *pci, DWORD dwFlags)
{
    GUID guid;
    IUserIdentityManager *pIdMan;
    IUserIdentity *pId;
    HKEY hkey;
    CAccountManager *pAcctMgr;
    LPSTR sz, psz;
    LPCSTR pszMailSig, pszNewsSig;
    CONNECTINFO ci;
    DWORD cch, type, dw, cb, i;
    HRESULT hr;
    char szMailId[CCHMAX_ACCOUNT_NAME], szNewsId[CCHMAX_ACCOUNT_NAME];

    hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        if (!g_pMalloc || !MemAlloc((void **)&sz, CBPROFILEBUF))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {    
            hr = CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, IID_IUserIdentityManager, (LPVOID *)&pIdMan);
            if (SUCCEEDED(hr))
            {
                if (!!(dwFlags & CAFF_USE_AUTODIAL))
                {
                    cb = sizeof(DWORD);
                    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szEnableAutoDialPath, c_RegKeyEnableAutoDial, &type, &dw, &cb) &&
                        !!dw &&
#pragma prefast(suppress:282, "the value of cb has to be changed between the first and second calls to SHGetValue")
                        (cb = sizeof(ci.szConnectoid)) &&
                        ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szDefConnPath, c_szRegProfile, &type, ci.szConnectoid, &cb) &&
                        !FIsEmpty(ci.szConnectoid))
                    {
                        ci.cbSize = sizeof(CONNECTINFO);
                        ci.type = CONNECT_RAS;
                        pci = &ci;
                    }
                }

                cch = GetPrivateProfileSection(c_szIdentitySection, sz, CBPROFILEBUF, lpFile);
                if ((cch != 0) && (cch != (CBPROFILEBUF - 2)))
                {
                    if (GetSectionNames(sz, cch, 0, &dw))
                    {
                        for (i = 0, psz = sz; i < dw; i++)
                        {
                            HandleIdentity(psz, lpFile, pci, dwFlags, pIdMan);
                            psz += (lstrlen(psz) + 1);
                        }
                    }
                }
                else
                {
                    cch = GetPrivateProfileSectionNames(sz, CBPROFILEBUF, lpFile);
                    if (cch != 0)
                    {
                        if (!!(dwFlags & CAFF_CURRENT_USER))
                            guid = UID_GIBC_CURRENT_USER;
                        else
                            guid = UID_GIBC_DEFAULT_USER;

                        hr = pIdMan->GetIdentityByCookie(&guid, &pId);
                        if (SUCCEEDED(hr))
                        {
                            hr = pId->OpenIdentityRegKey(KEY_READ | KEY_WRITE, &hkey);
                            if (SUCCEEDED(hr))
                            {
                                hr = HrCreateAccountManager((IImnAccountManager **)&pAcctMgr);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pAcctMgr->InitUser(NULL, guid, 0);
                                    if (SUCCEEDED(hr))
                                    {
                                        *szMailId = 0;
                                        *szNewsId = 0;
                                        pszMailSig = NULL;
                                        pszNewsSig = NULL;

                                        psz = sz;
        
                                        while (*psz != 0)
                                        {
                                            if (0 == lstrcmpi(psz, c_szMailSection))
                                            {
                                                CreateMailAccount(pAcctMgr, lpFile, c_szMailSection, pci, hkey, szMailId, ARRAYSIZE(szMailId), dwFlags);
                                                DoMailBranding(lpFile, c_szMailSection, hkey);

                                                HandleMultipleAccounts(ACCT_MAIL, pAcctMgr, lpFile, c_szMailSection, pci, hkey, pId, dwFlags);
                                            }
                                            else if (0 == lstrcmpi(psz, c_szNewsSection))
                                            {
                                                CreateNewsAccount(pAcctMgr, lpFile, c_szNewsSection, c_szMailSection, pci, hkey, pId, szNewsId, ARRAYSIZE(szNewsId), dwFlags);
                                                DoNewsBranding(lpFile, c_szNewsSection, hkey);

                                                HandleMultipleAccounts(ACCT_NEWS, pAcctMgr, lpFile, c_szNewsSection, pci, hkey, pId, dwFlags);
                                            }
                                            else if (0 == lstrcmpi(psz, c_szLDAPSection))
                                            {
                                                CreateLDAPAccount(pAcctMgr, lpFile, c_szLDAPSection, pci);

                                                HandleMultipleAccounts(ACCT_DIR_SERV, pAcctMgr, lpFile, c_szLDAPSection, pci, hkey, pId, dwFlags);
                                            }
                                            else if (0 == lstrcmpi(psz, c_szURLSection))
                                            {
                                                SetHelp(lpFile, c_szURLSection, hkey);
                                            }
                                            else if (0 == lstrcmpi(psz, c_szOESection))
                                            {
                                                DoBranding(lpFile, c_szOESection, hkey);
                                            }
                                            else if (0 == lstrcmpi(psz, c_szMailSigSection))
                                            {
                                                pszMailSig = c_szMailSigSection;
                                            }
                                            else if (0 == lstrcmpi(psz, c_szNewsSigSection))
                                            {
                                                pszNewsSig = c_szNewsSigSection;
                                            }
            
                                            psz += (lstrlen(psz) + 1);
                                        }

                                        SetSignature(pszMailSig, pszNewsSig, (*szMailId != 0) ? szMailId : NULL,
                                                        (*szNewsId != 0) ? szNewsId : NULL, lpFile, hkey, pAcctMgr);
                                    }

                                    pAcctMgr->Release();
                                }

                                RegCloseKey(hkey);
                            }

                            pId->Release();
                        }
                    }
                }

                HandleGlobalSettings(lpFile);

                DoDefaultClient(lpFile, TRUE);
                DoDefaultClient(lpFile, FALSE);

                pIdMan->Release();
            }

            MemFree(sz);
        }

        CoUninitialize();
    }

    return(hr);
}

HRESULT HandleGlobalSettings(LPCSTR lpFile)
{
    HKEY hkey;
    HRESULT hr;
    DWORD dw, disp, cb;
    char sz[512], szT[512], szKey[MAX_PATH];

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw))
    {
        SetRegProp(lpFile, c_szGlobalSection, c_szDisableAccts, hkey, c_szRegValNoModifyAccts);

        dw = GetPrivateProfileString(c_szGlobalSection, c_szInsEnableHttpmail, c_szEmpty, sz, ARRAYSIZE(sz), lpFile);
        if (dw > 0)
        {
            dw = (0 == lstrcmpi(sz, c_szYes) || 0 == lstrcmpi(sz, c_sz1));
            RegSetValueEx(hkey, c_szEnableHTTPMail, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
        }

        RegCloseKey(hkey);
    }

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegFlat, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw))
    {
        SetRegDw(lpFile, c_szGlobalSection, c_szInsHideMessenger, hkey, c_szHideMessenger);
        SetRegProp(lpFile, c_szGlobalSection, c_szHideMSN, hkey, c_szRegDisableHotmail);

        RegCloseKey(hkey);
    }

    dw = GetPrivateProfileString(c_szGlobalSection, c_szServiceURL, c_szEmpty, sz, ARRAYSIZE(sz), lpFile);
    if (dw > 0)
    {
        cb = ARRAYSIZE(szT);
        hr = UrlGetPart(sz, szT, &cb, URL_PART_HOSTNAME, 0);
        if (FAILED(hr))
            StrCpyN(szT, sz, ARRAYSIZE(szT));
        wnsprintf(szKey, ARRAYSIZE(szKey), c_szPathFileFmt, c_szHTTPMailServiceRoot, szT);
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &disp))
        {
            RegSetValueEx(hkey, c_szHTTPMailSignUp, 0, REG_SZ, (LPBYTE)sz, dw + 1);

            dw = GetPrivateProfileString(c_szGlobalSection, c_szServiceName, c_szEmpty, sz, ARRAYSIZE(sz), lpFile);
            if (dw > 0)
                RegSetValueEx(hkey, c_szHTTPMailServiceName, 0, REG_SZ, (LPBYTE)sz, dw + 1);

            SetRegDw(lpFile, c_szGlobalSection, c_szAccountNumber, hkey, c_szHTTPMailAcctNumber);

            RegCloseKey(hkey);
        }
    }

    return(S_OK);
}

void HandleConnectInfo(IImnAccount *pAcct, CONNECTINFO *pci, BOOL fUseIEConnection)
{
    DWORD type;
    
    Assert(pAcct != NULL);
    
    if (fUseIEConnection)
    {
        pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, CONNECTION_TYPE_INETSETTINGS);
        return;
    }
    
    if (pci != NULL)
        type = pci->type;
    else
        type = CONNECT_LAN;
    
    pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, type);
    if (type == CONNECT_RAS)
    {
        Assert(pci != NULL);
        pAcct->SetPropSz(AP_RAS_CONNECTOID, pci->szConnectoid);
    }
}

void GetPropSz(LPCSTR szSection, LPCSTR szValue, LPCSTR szSection2, LPCSTR szValue2, LPCSTR szFile, IImnAccount *pAcct, DWORD prop, BOOL *pfComplete)
{
    char sz[512];
    DWORD dw;
    HRESULT hr;
    
    Assert(szSection != NULL);
    Assert(szValue != NULL);
    Assert(szFile != NULL);
    Assert(pAcct != NULL);
    
    dw = GetPrivateProfileString(szSection, szValue, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
    if (dw == 0 && szSection2 != NULL)
    {
        Assert(szValue2 != NULL);
        dw = GetPrivateProfileString(szSection2, szValue2, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
    }
    
    if (dw > 0)
    {
        pAcct->SetPropSz(prop, sz);
    }
    else if (pfComplete != NULL)
    {
        dw = 0;
        hr = pAcct->GetProp(prop, NULL, &dw);
        if (dw == 0)
            *pfComplete = FALSE;
    }
}

void GetPropDw(LPCSTR szSection, LPCSTR szValue, LPCSTR szFile, IImnAccount *pAcct, DWORD prop)
{
    DWORD dw;
    
    dw = GetPrivateProfileInt(szSection, szValue, -1, szFile);
    if (dw != -1)
        pAcct->SetPropDw(prop, dw);
}

void GetPropBool(LPCSTR szSection, LPCSTR szValue, LPCSTR szFile, IImnAccount *pAcct, DWORD prop)
{
    DWORD dw;
    char sz[512];
    
    dw = GetPrivateProfileString(szSection, szValue, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
    if (dw > 0)
    {
        dw = (0 == lstrcmpi(sz, c_szYes) || 0 == lstrcmpi(sz, c_sz1));
        pAcct->SetPropDw(prop, dw);
    }
}

BOOL GetBool(LPCSTR szSection, LPCSTR szValue, LPCSTR szFile)
{
    DWORD dw;
    char sz[512];
    
    dw = GetPrivateProfileString(szSection, szValue, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
    
    return(dw > 0 && (0 == lstrcmpi(sz, c_szYes) || 0 == lstrcmpi(sz, c_sz1)));
}

void SetRegProp(LPCSTR szFile, LPCSTR szSection, LPCSTR szValue, HKEY hkey, LPCSTR szRegValue)
{
    char sz[16];
    DWORD dw;

    dw = GetPrivateProfileString(szSection, szValue, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
    if (dw > 0)
    {
        dw = (0 == lstrcmpi(sz, c_szYes) || 0 == lstrcmpi(sz, c_sz1));
        RegSetValueEx(hkey, szRegValue, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
    }
}

void SetRegDw(LPCSTR szFile, LPCSTR szSection, LPCSTR szValue, HKEY hkey, LPCSTR szRegValue)
{
    DWORD dw;
    
    dw = GetPrivateProfileInt(szSection, szValue, -1, szFile);
    if (dw != -1)
        RegSetValueEx(hkey, szRegValue, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
}

HRESULT CreateMailAccount(CAccountManager *pAcctMgr, LPCSTR szFile, LPCSTR szMailSection, CONNECTINFO *pci, HKEY hkey, LPSTR pszAcctId, DWORD cchSizeAcctID, DWORD dwFlags)
{
    IImnAccount *pAcct;
    HRESULT hr;
    DWORD dw;
    char sz[512];
    int type;
    BOOL fSicily, fDelete, fComplete = TRUE;
    
    Assert(pAcctMgr != NULL);
    Assert(szFile != NULL);
    
    if (GetBool(szMailSection, c_szUseImap, szFile))
        type = IMAP;
    else if (GetPrivateProfileString(szMailSection, c_szHttpUrl, c_szEmpty, sz, ARRAYSIZE(sz), szFile) > 0)
        type = HTTP;
    else
        type = POP3;
    
    fDelete = (BOOL)GetPrivateProfileInt(szMailSection, c_szDeleteAccount, 0, szFile);
    if (fDelete)
    {
        DeleteAccount(type, pAcctMgr, szMailSection, szFile);
        return(S_OK);
    }

    if (SUCCEEDED(hr = GetAccount(type, pAcctMgr, szMailSection, szFile, &pAcct)))
    {
        Assert(pAcct != NULL);
        
        if (type == POP3)
        {
            GetPropDw(szMailSection, c_szPopPort, szFile, pAcct, AP_POP3_PORT);
            GetPropBool(szMailSection, c_szUseSSL, szFile, pAcct, AP_POP3_SSL);

            GetPropBool(szMailSection, c_szPopLeaveOnServer, szFile, pAcct, AP_POP3_LEAVE_ON_SERVER);
            GetPropBool(szMailSection, c_szPopRemoveOnDelete, szFile, pAcct, AP_POP3_REMOVE_DELETED);

            fSicily = GetBool(szMailSection, c_szLogonUsingSPA, szFile);
            pAcct->SetPropDw(AP_POP3_USE_SICILY, fSicily);

            // IE5 Bug #65821: Even if SPA (Sicily) is turned on, we store the account name and password
            GetPropSz(szMailSection, c_szMailLogon, NULL, NULL, szFile, pAcct, AP_POP3_USERNAME, &fComplete);
            GetPropSz(szMailSection, c_szMailPassword, NULL, NULL, szFile, pAcct, AP_POP3_PASSWORD, NULL);
        }
        else if (type == IMAP)
        {
            GetPropDw(szMailSection, c_szImapPort, szFile, pAcct, AP_IMAP_PORT);
            GetPropBool(szMailSection, c_szUseSSL, szFile, pAcct, AP_IMAP_SSL);

            GetPropSz(szMailSection, c_szImapRoot, NULL, NULL, szFile, pAcct, AP_IMAP_ROOT_FOLDER, NULL);
            GetPropSz(szMailSection, c_szImapSentItems, NULL, NULL, szFile, pAcct, AP_IMAP_SENTITEMSFLDR, NULL);
            GetPropSz(szMailSection, c_szImapDrafts, NULL, NULL, szFile, pAcct, AP_IMAP_DRAFTSFLDR, NULL);
            GetPropBool(szMailSection, c_szImapPoll, szFile, pAcct, AP_IMAP_POLL);

            fSicily = GetBool(szMailSection, c_szLogonUsingSPA, szFile);
            pAcct->SetPropDw(AP_IMAP_USE_SICILY, fSicily);

            // IE5 Bug #65821: Even if SPA (Sicily) is turned on, we store the account name and password
            GetPropSz(szMailSection, c_szImapLogon, NULL, NULL, szFile, pAcct, AP_IMAP_USERNAME, &fComplete);
            GetPropSz(szMailSection, c_szImapPassword, NULL, NULL, szFile, pAcct, AP_IMAP_PASSWORD, NULL);
        }
        else
        {
            fSicily = GetBool(szMailSection, c_szLogonUsingSPA, szFile);
            pAcct->SetPropDw(AP_HTTPMAIL_USE_SICILY, fSicily);

            // IE5 Bug #65821: Even if SPA (Sicily) is turned on, we store the account name and password
            GetPropSz(szMailSection, c_szHttpLogon, NULL, NULL, szFile, pAcct, AP_HTTPMAIL_USERNAME, &fComplete);
            GetPropSz(szMailSection, c_szHttpPassword, NULL, NULL, szFile, pAcct, AP_HTTPMAIL_PASSWORD, NULL);

            GetPropBool(c_szMailSection, c_szHttpPoll, szFile, pAcct, AP_HTTPMAIL_POLL); 
            GetPropBool(szMailSection, c_szMsnCom, szFile, pAcct, AP_HTTPMAIL_DOMAIN_MSN);
        }
        
        GetPropSz(szMailSection, c_szMailName, NULL, NULL, szFile, pAcct, AP_SMTP_DISPLAY_NAME, &fComplete);
        GetPropSz(szMailSection, c_szMailAddr, NULL, NULL, szFile, pAcct, AP_SMTP_EMAIL_ADDRESS, &fComplete);
        GetPropSz(szMailSection, c_szReplyAddr, NULL, NULL, szFile, pAcct, AP_SMTP_REPLY_EMAIL_ADDRESS, NULL);

        if (type != HTTP)
        {
            GetPropSz(szMailSection, c_szSmtpServer, NULL, NULL, szFile, pAcct, AP_SMTP_SERVER, &fComplete);
            GetPropDw(szMailSection, c_szSmtpPort, szFile, pAcct, AP_SMTP_PORT);
            GetPropBool(szMailSection, c_szSmtpUseSSL, szFile, pAcct, AP_SMTP_SSL);

            dw = GetPrivateProfileString(szMailSection, c_szSmtpLogonReq, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
            if (dw > 0)
            {
                if (0 == lstrcmpi(sz, c_szYes) || 0 == lstrcmpi(sz, c_sz1))
                {
                    // IE5 Bug #67153: If SMTP logon required, but SPA not set, assume username/pass is provided
                    fSicily = GetBool(szMailSection, c_szSmtpLogonUsingSPA, szFile);
                    pAcct->SetPropDw(AP_SMTP_USE_SICILY, fSicily ?
                        SMTP_AUTH_SICILY : SMTP_AUTH_USE_SMTP_SETTINGS);

                    // IE5 Bug #67153: Even if SPA (Sicily) is turned on, we store the account name and password
                    GetPropSz(szMailSection, c_szSmtpLogon, NULL, NULL, szFile, pAcct, AP_SMTP_USERNAME, NULL);
                    GetPropSz(szMailSection, c_szSmtpPassword, NULL, NULL, szFile, pAcct, AP_SMTP_PASSWORD, NULL);
                }
                else
                {
                    pAcct->SetPropDw(AP_SMTP_USE_SICILY, SMTP_AUTH_NONE);
                    pAcct->SetPropSz(AP_SMTP_USERNAME, NULL);
                    pAcct->SetPropSz(AP_SMTP_PASSWORD, NULL);
                }
            }
        }

        GetPropSz(szMailSection, c_szService, NULL, NULL, szFile, pAcct, AP_SERVICE, NULL);

        GetPropDw(c_szGlobalSection, c_szReadOnlyAccts, szFile, pAcct, AP_SERVER_READ_ONLY);

        HandleConnectInfo(pAcct, pci, GetBool(szMailSection, c_szIEConnect, szFile));
        
        hr = pAcct->SaveChanges();
        if (SUCCEEDED(hr))
        {
            if (0 == (dwFlags & CAFF_NO_SET_DEFAULT))
                pAcct->SetAsDefault();
            
            if (SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_ID, sz, ARRAYSIZE(sz))))
            {
                if (pszAcctId != NULL)
                    StrCpyN(pszAcctId, sz, cchSizeAcctID);

                if (!fComplete)
                    pAcctMgr->SetIncompleteAccount(ACCT_MAIL, sz);
            }
        }
        
        pAcct->Release();
    }
    
    return(hr);
}

HRESULT CreateNewsAccount(CAccountManager *pAcctMgr, LPCSTR szFile, LPCSTR szNewsSection, LPCSTR szMailSection, CONNECTINFO *pci, HKEY hkey, IUserIdentity *pId, LPSTR pszAcctId, DWORD cchSizeAcctId, DWORD dwFlags)
{
    IImnAccount *pAcct;
    HRESULT hr;
    DWORD dw;
    char sz[512];
    BOOL fSPA, fDelete, fComplete = TRUE;
    
    Assert(pAcctMgr != NULL);
    Assert(szFile != NULL);
    
    fDelete = (BOOL)GetPrivateProfileInt(szNewsSection, c_szDeleteAccount, 0, szFile);
    if (fDelete)
    {
        DeleteAccount(NNTP, pAcctMgr, szNewsSection, szFile);
        return(S_OK);
    }

    if (SUCCEEDED(hr = GetAccount(NNTP, pAcctMgr, szNewsSection, szFile, &pAcct)))
    {
        Assert(pAcct != NULL);
        
        GetPropSz(szNewsSection, c_szNewsName, szMailSection, c_szMailName, szFile, pAcct,
            AP_NNTP_DISPLAY_NAME, &fComplete);
        GetPropSz(szNewsSection, c_szNewsAddr, szMailSection, c_szMailAddr, szFile, pAcct,
            AP_NNTP_EMAIL_ADDRESS, &fComplete);
        GetPropSz(szNewsSection, c_szReplyAddr, szMailSection, c_szReplyAddr, szFile, pAcct,
            AP_NNTP_REPLY_EMAIL_ADDRESS, NULL);
        GetPropDw(szNewsSection, c_szNewsPort, szFile, pAcct, AP_NNTP_PORT);
        GetPropBool(szNewsSection, c_szUseSSL, szFile, pAcct, AP_NNTP_SSL);
        
        fSPA = FALSE;
        if (GetBool(szNewsSection, c_szNewsLogonRequired, szFile))
        {
            fSPA = GetBool(szNewsSection, c_szLogonUsingSPA, szFile);

            // IE5 Bug #65821: Even if SPA (Sicily) is turned on, we store the account name and password
            GetPropSz(szNewsSection, c_szNewsLogon, NULL, NULL, szFile, pAcct, AP_NNTP_USERNAME, &fComplete);
            GetPropSz(szNewsSection, c_szNewsPassword, NULL, NULL, szFile, pAcct, AP_NNTP_PASSWORD, NULL);
        }
        pAcct->SetPropDw(AP_NNTP_USE_SICILY, fSPA);
        
        GetPropDw(c_szGlobalSection, c_szReadOnlyAccts, szFile, pAcct, AP_SERVER_READ_ONLY);

        HandleConnectInfo(pAcct, pci, GetBool(szNewsSection, c_szIEConnect, szFile));

        hr = pAcct->SaveChanges();
        if (SUCCEEDED(hr))
        {
            if (0 == (dwFlags & CAFF_NO_SET_DEFAULT))
                pAcct->SetAsDefault();
            
            if (SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_ID, sz, ARRAYSIZE(sz))))
            {
                if (pszAcctId != NULL)
                    StrCpyN(pszAcctId, sz, cchSizeAcctId);

                if (!fComplete)
                    pAcctMgr->SetIncompleteAccount(ACCT_NEWS, sz);
            }
            
            dw = GetPrivateProfileString(szNewsSection, c_szNewsgroups, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
            if (dw > 0)
                SubscribeNewsgroups(pAcct, sz, szFile, hkey);
        }
        
        pAcct->Release();
    }
    
    return(hr);
}

HRESULT CreateLDAPAccount(CAccountManager *pAcctMgr, LPCSTR szFile, LPCSTR szLDAPSection, CONNECTINFO *pci)
{
    IImnAccount *pAcct;
    HRESULT hr;
    int i;
    char sz[512];
    DWORD dw;
    BOOL fDelete;
    
    Assert(pAcctMgr != NULL);
    Assert(szFile != NULL);
    
    fDelete = (BOOL)GetPrivateProfileInt(szLDAPSection, c_szDeleteAccount, 0, szFile);
    if (fDelete)
    {
        DeleteAccount(LDAP, pAcctMgr, szLDAPSection, szFile);
        return(S_OK);
    }

    if (SUCCEEDED(hr = GetAccount(LDAP, pAcctMgr, szLDAPSection, szFile, &pAcct)))
    {
        Assert(pAcct != NULL);
        
        GetPropSz(szLDAPSection, c_szLDAPSearchBase, NULL, NULL, szFile, pAcct, AP_LDAP_SEARCH_BASE, NULL);
        GetPropSz(szLDAPSection, c_szLDAPHomePage, NULL, NULL, szFile, pAcct, AP_LDAP_URL, NULL);
        GetPropSz(szLDAPSection, c_szLDAPLogo, NULL, NULL, szFile, pAcct, AP_LDAP_LOGO, NULL);
        GetPropDw(szLDAPSection, c_szLDAPPort, szFile, pAcct, AP_LDAP_PORT);
        GetPropBool(szLDAPSection, c_szUseSSL, szFile, pAcct, AP_LDAP_SSL);
        GetPropDw(szLDAPSection, c_szLDAPResults, szFile, pAcct, AP_LDAP_SEARCH_RETURN);
        GetPropDw(szLDAPSection, c_szLDAPTimeout, szFile, pAcct, AP_LDAP_TIMEOUT);

        dw = GetBool(szLDAPSection, c_szLDAPCheckNames, szFile);
        pAcct->SetPropDw(AP_LDAP_RESOLVE_FLAG, dw);
        
        i = GetPrivateProfileInt(szLDAPSection, c_szLDAPAuthType, -1, szFile);
        if (i >= LDAP_AUTH_ANONYMOUS && i <= LDAP_AUTH_MAX)
        {
            if (i > LDAP_AUTH_ANONYMOUS)
            {
                GetPropSz(szLDAPSection, c_szLDAPUserName, NULL, NULL, szFile, pAcct, AP_LDAP_USERNAME, NULL);
                GetPropSz(szLDAPSection, c_szLDAPPassword, NULL, NULL, szFile, pAcct, AP_LDAP_PASSWORD, NULL);
            }
            
            pAcct->SetPropDw(AP_LDAP_AUTHENTICATION, (DWORD)i);
        }

        GetPropDw(c_szGlobalSection, c_szReadOnlyAccts, szFile, pAcct, AP_SERVER_READ_ONLY);

        hr = pAcct->SaveChanges();
        
        pAcct->Release();
    }
    
    return(hr);
}

typedef struct tagACCTPROPS
    {
    ACCTTYPE type;
    DWORD   dwSrv;
    DWORD   dwPropSrv;
    LPCSTR  szSrv;
    DWORD   dwMatch;
    LPCSTR  szMatch;
    } ACCTPROPS;

static const ACCTPROPS g_rgProps[LDAP + 1] = {
    {
    ACCT_NEWS,
    SRV_NNTP,
    AP_NNTP_SERVER,
    c_szNewsServer,
    AP_NNTP_USERNAME,
    c_szNewsLogon
    },
    {
    ACCT_MAIL,
    SRV_POP3,
    AP_POP3_SERVER,
    c_szPopServer,
    AP_SMTP_EMAIL_ADDRESS,
    c_szMailAddr,
    },
    {
    ACCT_MAIL,
    SRV_IMAP,
    AP_IMAP_SERVER,
    c_szImapServer,
    AP_SMTP_EMAIL_ADDRESS,
    c_szMailAddr,
    },
    {
    ACCT_MAIL,
    SRV_HTTPMAIL,
    AP_HTTPMAIL_SERVER,
    c_szHttpUrl,
    AP_SMTP_EMAIL_ADDRESS,
    c_szMailAddr,
    },
    {
    ACCT_DIR_SERV,
    SRV_LDAP,
    AP_LDAP_SERVER,
    c_szLDAPServer,
    AP_LDAP_USERNAME,
    c_szLDAPUserName,
    }
    };

HRESULT GetAccount(DWORD type, CAccountManager *pAcctMgr, LPCSTR szSection, LPCSTR szFile, IImnAccount **ppAcct)
{
    IImnEnumAccounts *pEnum;
    HRESULT hr;
    DWORD dw;
    BOOL fOldSrv;
    const ACCTPROPS *pProps;
    IImnAccount *pAcct;
    char szSrv[CCHMAX_SERVER_NAME], szMatch[CCHMAX_ACCT_PROP_SZ], sz[CCHMAX_ACCT_PROP_SZ], szOldSrv[CCHMAX_SERVER_NAME];
    LPSTR pszSrv;
    
    Assert(pAcctMgr != NULL);
    Assert(szSection != NULL);
    Assert(szFile != NULL);
    Assert(ppAcct != NULL);
    
    *ppAcct = NULL;
    
    pProps = &g_rgProps[type];

    *szSrv = 0;
    dw = GetPrivateProfileString(szSection, pProps->szSrv, c_szEmpty, szSrv, ARRAYSIZE(szSrv), szFile);
    if (*szSrv == 0)
        return(E_FAIL);

    *szOldSrv = 0;
    dw = GetPrivateProfileString(szSection, c_szOldServer, c_szEmpty, szOldSrv, ARRAYSIZE(szOldSrv), szFile);
    if (fOldSrv = (*szOldSrv != 0))
        pszSrv = szOldSrv;
    else
        pszSrv = szSrv;
    
    *szMatch = 0;
    dw = GetPrivateProfileString(szSection, pProps->szMatch, c_szEmpty, szMatch, ARRAYSIZE(szMatch), szFile);
    
    hr = S_FALSE;
    
    if (S_OK == pAcctMgr->Enumerate(pProps->dwSrv, &pEnum))
    {
        Assert(pEnum != NULL);
        
        // try to find a duplicate account
        while (S_OK == pEnum->GetNext(&pAcct))
        {
            Assert(pAcct != NULL);
            
            *sz = 0;
            pAcct->GetPropSz(pProps->dwPropSrv, sz, ARRAYSIZE(sz));
            
            if (0 == lstrcmpi(sz, pszSrv))
            {
                // the servers are the same for the accounts so this may be a match
                *sz = 0;
                pAcct->GetPropSz(pProps->dwMatch, sz, ARRAYSIZE(sz));
          
                if (fOldSrv)
                {
                    hr = S_OK;
                }
                else if (*szMatch != 0 && *sz != 0)
                {
                    if (0 == lstrcmpi(sz, szMatch))
                        hr = S_OK;
                }
                else if (*szMatch == 0)
                {
                    if (*sz == 0)
                        hr = S_OK;
                    else
                        hr = E_FAIL;
                }
                else
                {
                    Assert(*sz == 0);
                    hr = S_OK;
                }
            }
            
            if (hr == S_OK)
            {
                *ppAcct = pAcct;
                break;
            }
            
            pAcct->Release();
            
            if (hr != S_FALSE)
                break;
        }
        
        pEnum->Release();
    }
    
    if (hr == S_FALSE)
    {
        Assert(*ppAcct == NULL);
        if (SUCCEEDED(hr = pAcctMgr->CreateAccountObject(pProps->type, &pAcct)))
        {
            pAcct->SetPropSz(pProps->dwPropSrv, szSrv);
            
            dw = GetPrivateProfileString(szSection, (type == LDAP) ? c_szLDAPFriendlyName : c_szAcctName,
                    c_szEmpty, sz, ARRAYSIZE(sz), szFile);
            if (dw == 0)
                StrCpyN(sz, szSrv, ARRAYSIZE(sz));
            
            hr = pAcctMgr->GetUniqueAccountName(sz, ARRAYSIZE(sz));
            if (SUCCEEDED(hr))
            {
                pAcct->SetPropSz(AP_ACCOUNT_NAME, sz);
                
                *ppAcct = pAcct;
            }
        }
    }
    else if (hr == S_OK)
    {
        Assert(pAcct != NULL);

        if (fOldSrv)
            pAcct->SetPropSz(pProps->dwPropSrv, szSrv);

        dw = GetPrivateProfileString(szSection, (type == LDAP) ? c_szLDAPFriendlyName : c_szAcctName,
                c_szEmpty, sz, ARRAYSIZE(sz), szFile);
        if (dw > 0)
        {
            if (SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_NAME, szMatch, ARRAYSIZE(szMatch))))
            {
                if (0 != lstrcmp(sz, szMatch))
                {
                    if (SUCCEEDED(pAcctMgr->GetUniqueAccountName(sz, ARRAYSIZE(sz))))
                        pAcct->SetPropSz(AP_ACCOUNT_NAME, sz);
                }
            }
        }
    }
    
    return(hr);
}

HRESULT DeleteAccount(DWORD type, CAccountManager *pAcctMgr, LPCSTR szSection, LPCSTR szFile)
{
    IImnEnumAccounts *pEnum;
    DWORD dw;
    const ACCTPROPS *pProps;
    IImnAccount *pAcct;
    char szSrv[CCHMAX_SERVER_NAME], sz[CCHMAX_ACCT_PROP_SZ];
    
    Assert(pAcctMgr != NULL);
    Assert(szSection != NULL);
    Assert(szFile != NULL);
    
    pProps = &g_rgProps[type];

    *szSrv = 0;
    dw = GetPrivateProfileString(szSection, pProps->szSrv, c_szEmpty, szSrv, ARRAYSIZE(szSrv), szFile);
    if (*szSrv == 0)
        return(E_FAIL);
    
    if (S_OK == pAcctMgr->Enumerate(pProps->dwSrv, &pEnum))
    {
        Assert(pEnum != NULL);
        
        // try to find a duplicate account
        while (S_OK == pEnum->GetNext(&pAcct))
        {
            Assert(pAcct != NULL);
            
            *sz = 0;
            pAcct->GetPropSz(pProps->dwPropSrv, sz, ARRAYSIZE(sz));
            
            if (0 == lstrcmpi(sz, szSrv))
            {
                pAcct->Delete();
            }
            
            pAcct->Release();
        }
        
        pEnum->Release();
    }

    return(S_OK);
}

void FixSignature(LPSTR psz)
{
    Assert(psz != NULL);

    while (*psz != 0)
    {
        if (!IsDBCSLeadByte(*psz) && *psz == '\\' && *(psz + 1) == 'n')
        {
            *psz = 0x0d;
            psz++;
            *psz = 0x0a;
            psz++;
        }
        else
        {
            psz = CharNextA(psz);
        }
    }
}

void SetSignature(LPCSTR szMailSigSection, LPCSTR szNewsSigSection, LPCSTR pszMailId, LPCSTR pszNewsId, LPCSTR szFile, HKEY hkey, CAccountManager *pAcctMgr)
{
    BOOL fMailForNews;
    HKEY hkeyT;
    IImnAccount *pAcct;
    char sz[1024], szKey[MAX_PATH], szT[CCHMAX_STRINGRES];
    DWORD dw, cb;

    if (szMailSigSection != NULL)
    {
        if (GetBool(szMailSigSection, c_szUseSig, szFile))
        {
            dw = GetPrivateProfileString(szMailSigSection, c_szProfSigText, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
            if (dw > 0)
            {
                FixSignature(sz);
                fMailForNews = GetBool(szMailSigSection, c_szUseMailForNews, szFile);

                wnsprintf(szKey, ARRAYSIZE(szKey), c_szPathFileFmt, c_szRegRootSigs, c_szMailSigKey);
                if (ERROR_SUCCESS == RegCreateKeyEx(hkey, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyT, &dw))
                {
                    LoadString(g_hInstRes, idsMailSignature, szT, ARRAYSIZE(szT));
                    RegSetValueEx(hkeyT, c_szSigName, 0, REG_SZ, (LPBYTE)szT, lstrlen(szT) + 1);
                    RegSetValueEx(hkeyT, c_szSigText, 0, REG_SZ, (LPBYTE)sz, lstrlen(sz) + 1);
                    dw = 1;
                    RegSetValueEx(hkeyT, c_szSigType, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));

                    RegCloseKey(hkeyT);

                    if (fMailForNews)
                    {
                        SHSetValue(hkey, c_szRegRootSigs, c_szRegDefSig, REG_SZ, (LPBYTE)c_szMailSigKey, lstrlen(c_szMailSigKey) + 1);
                    }
                    else if (pszMailId != NULL)
                    {
                        if (SUCCEEDED(pAcctMgr->FindAccount(AP_ACCOUNT_ID, pszMailId, &pAcct)))
                        {
                            pAcct->SetPropSz(AP_SMTP_SIGNATURE, (LPSTR)c_szMailSigKey);
                            pAcct->SaveChanges();

                            pAcct->Release();
                        }
                    }
                }

                if (fMailForNews)
                {
                    // Turn on "Add signatures to all outgoing messages"
                    if (ERROR_SUCCESS == RegCreateKeyEx(hkey, c_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE, NULL, &hkeyT, &dw))
                    {
                        dw = 0;

                        // Read any existing value
                        cb = sizeof(dw);
                        RegQueryValueEx(hkeyT, c_szSigFlags, 0, NULL, (LPBYTE)&dw, &cb);

                        // Turn on checkbox
                        dw |= SIGFLAG_AUTONEW;

                        // Write back new value
                        RegSetValueEx(hkeyT, c_szSigFlags, 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));

                        RegCloseKey(hkeyT);
                    }
                    
                    // Per spec, don't even worry about News Sig section
                    return;
                }
            }
        }
    }

    if (szNewsSigSection != NULL)
    {
        if (GetBool(szNewsSigSection, c_szUseSig, szFile))
        {
            dw = GetPrivateProfileString(szNewsSigSection, c_szProfSigText, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
            if (dw > 0)
            {
                FixSignature(sz);

                wnsprintf(szKey, ARRAYSIZE(szKey), c_szPathFileFmt, c_szRegRootSigs, c_szNewsSigKey);
                if (ERROR_SUCCESS == RegCreateKeyEx(hkey, szKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyT, &dw))
                {
                    LoadString(g_hInstRes, idsNewsSignature, szT, ARRAYSIZE(szT));
                    RegSetValueEx(hkeyT, c_szSigName, 0, REG_SZ, (LPBYTE)szT, lstrlen(szT) + 1);
                    RegSetValueEx(hkeyT, c_szSigText, 0, REG_SZ, (LPBYTE)sz, lstrlen(sz) + 1);
                    dw = 1;
                    RegSetValueEx(hkeyT, c_szSigType, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));

                    RegCloseKey(hkeyT);

                    if (pszNewsId != NULL)
                    {
                        if (SUCCEEDED(pAcctMgr->FindAccount(AP_ACCOUNT_ID, pszNewsId, &pAcct)))
                        {
                            pAcct->SetPropSz(AP_NNTP_SIGNATURE, (LPSTR)c_szNewsSigKey);
                            pAcct->SaveChanges();

                            pAcct->Release();
                        }
                    }
                }
            }
        }
    }
}

static const char c_szRegClient[] = "Software\\Clients\\Mail\\Outlook Express";
static const char c_szDllPath[] = "DLLPath";
static const char c_szSetDefMail[] = "SetDefaultMailHandler";
static const char c_szSetDefNews[] = "SetDefaultNewsHandler";

typedef HRESULT (WINAPI *PFN_SETDEFCLIENT)(DWORD);
 
void DoDefaultClient(LPCSTR szFile, BOOL fMail)
{
    HINSTANCE hlib;
    PFN_SETDEFCLIENT pfn;
    char szDll[MAX_PATH];
    DWORD dw, type;
    
    if (GetBool(fMail ? c_szMailSection : c_szNewsSection, c_szDefClient, szFile))
    {
        dw = sizeof(szDll);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegClient, c_szDllPath, &type, (LPVOID)szDll, &dw))
        {
            hlib = LoadLibrary(szDll);
            if (hlib != NULL)
            {
                pfn = (PFN_SETDEFCLIENT)GetProcAddress(hlib, fMail ? c_szSetDefMail : c_szSetDefNews);
                if (pfn != NULL)
                    pfn(0);
                
                FreeLibrary(hlib);
            }
        }
    }
}

void DoMailBranding(LPCSTR szFile, LPCSTR szMailSection, HKEY hkeyUser)
{
    HKEY hkey;
    DWORD dw;
    int i;
    char sz[1024];
    
    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyUser, c_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_WRITE, NULL, &hkey, &dw))
    {
        dw = GetPrivateProfileString(szMailSection, c_szWinTitle, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
        if (dw > 0 && !FIsEmpty(sz))
            RegSetValueEx(hkey, c_szWindowTitle, 0, REG_SZ, (LPBYTE)sz, dw + 1);
        
        dw = GetPrivateProfileString(szMailSection, c_szInfopane, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
        if (dw > 0 && !FIsEmpty(sz))
        {
            RegSetValueEx(hkey, c_szRegBodyBarPath, 0, REG_SZ, (LPBYTE)sz, dw + 1);
            
            dw = 1;
            RegSetValueEx(hkey, c_szShowBodyBar, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
        }
        
        SetRegProp(szFile, szMailSection, c_szStartAtInbox, hkey, c_szRegLaunchInbox);

        RegCloseKey(hkey);
    }
    
    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyUser, c_szRegRootMail, 0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_WRITE, NULL, &hkey, &dw))
    {
        dw = GetPrivateProfileString(szMailSection, c_szWelcomeMsg, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
        if (dw > 0 && !FIsEmpty(sz))
        {
            RegSetValueEx(hkey, c_szWelcomeHtm, 0, REG_SZ, (LPBYTE)sz, dw + 1);
            
            dw = GetPrivateProfileString(szMailSection, c_szProfWelcomeName, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
            if (dw > 0 && !FIsEmpty(sz))
                RegSetValueEx(hkey, c_szWelcomeName, 0, REG_SZ, (LPBYTE)sz, dw + 1);
            
            dw = GetPrivateProfileString(szMailSection, c_szProfWelcomeEmail, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
            if (dw > 0 && !FIsEmpty(sz))
                RegSetValueEx(hkey, c_szWelcomeEmail, 0, REG_SZ, (LPBYTE)sz, dw + 1);

            // Tell OE we need a welcome msg...
            dw = 1;
            RegSetValueEx(hkey, c_szNeedWelcomeMsg, 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));
        }
        
        dw = GetPrivateProfileString(szMailSection, c_szPollTime, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
        if (dw > 0 && !FIsEmpty(sz))
        {
            i = StrToInt(sz);
            if (i <= 0)
            {
                dw = 0xffffffff;
            }
            else
            {
                if (i > 120)
                    i = 120;
                dw = (DWORD)i * 60 * 1000;
            }
            
            RegSetValueEx(hkey, c_szRegPollForMail, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
        }

        // Turn on Sending HTML msgs for Mail?
        SetRegDw(szFile, szMailSection, c_szHTMLMsgs, hkey, c_szMsgSendHtml);
        
        RegCloseKey(hkey);
    }

    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyUser, c_szRegRootRules, 0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_WRITE, NULL, &hkey, &dw))
    {
        SetRegProp(szFile, szMailSection, c_szJunkMail, hkey, c_szRegFilterJunk);

        RegCloseKey(hkey);
    }
}

void DoNewsBranding(LPCSTR szFile, LPCSTR szNewsSection, HKEY hkeyUser)
{
    HKEY hkey;
    DWORD dw;
    
    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyUser, c_szRegRootNews, 0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_WRITE, NULL, &hkey, &dw))
    {
        // Turn on Sending HTML msgs for News?
        SetRegDw(szFile, szNewsSection, c_szHTMLMsgs, hkey, c_szMsgSendHtml);
        
        RegCloseKey(hkey);
    }
}

void SubscribeNewsgroups(IImnAccount *pAcct, LPCSTR szSection, LPCSTR szFile, HKEY hkey)
{
    char *sz, szPath[MAX_PATH], szId[CCHMAX_ACCOUNT_NAME];
    DWORD dw, cGroups, type;
    
    Assert(pAcct != NULL);
    Assert(szSection != NULL);
    Assert(szFile != NULL);
    
    if (SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_ID, szId, ARRAYSIZE(szId))))
    {
        if (MemAlloc((void **)&sz, CBPROFILEBUF))
        {
            dw = GetPrivateProfileSection(szSection, sz, CBPROFILEBUF, szFile);
            if ((dw > 0) && (dw != (CBPROFILEBUF - 2)))
            {
                if (GetSectionNames(sz, dw, ',', &cGroups) && cGroups > 0)
                {
                    wnsprintf(szPath, ARRAYSIZE(szPath), c_szPathFileFmt, c_szRegRootSubscribe, szId);
                    RegSetValue(hkey, szPath, REG_SZ, sz, lstrlen(sz) + 1);
                }
            }
    
            MemFree(sz);
        }
    }
}

void SetHelp(LPCSTR szFile, LPCSTR szURLSection, HKEY hkey)
{
    char sz[INTERNET_MAX_URL_LENGTH];
    DWORD dw;
    
    dw = GetPrivateProfileString(szURLSection, c_szHelpPage, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
    if (dw > 0)
    {
        SHSetValue(hkey, c_szRegRoot, c_szRegHelpUrl, REG_SZ, (LPBYTE)sz, lstrlen(sz) + 1);
    }
}

HRESULT HandleIdentity(LPCSTR pszSection, LPCSTR pszFile, CONNECTINFO *pci, DWORD dwFlags, IUserIdentityManager *pIdMan)
{
    HRESULT hr;
    CAccountManager *pAcctMgr;
    IPrivateIdentityManager *pPrivIdMgr;
    IEnumUserIdentity *pEnum;
    IUserIdentity *pId;
    HKEY hkey;
    char sz[256], szT[256], szGuid[256], szMailId[CCHMAX_ACCOUNT_NAME], szNewsId[CCHMAX_ACCOUNT_NAME];
    DWORD dw, dwT, type, cb;
    WCHAR szwUserName[CCH_USERNAME_MAX_LENGTH + 1];

    Assert(pszSection != NULL);
    Assert(pszFile != NULL);
    Assert(pIdMan != NULL);

    dw = GetPrivateProfileString(pszSection, c_szGUID, c_szEmpty, szGuid, ARRAYSIZE(szGuid), pszFile);
    if (dw > 0)
    {
        dw = GetPrivateProfileString(pszSection, c_szUserName, c_szEmpty, sz, ARRAYSIZE(sz), pszFile);
        if (dw > 0)
        {
            // try to find this identity
            hr = pIdMan->EnumIdentities(&pEnum);
            if (FAILED(hr))
                return(hr);

            pId = NULL;
            hkey = NULL;

            while (hr == S_OK)
            {
                hr = pEnum->Next(1, (IUnknown **)&pId, &dw);
                if (hr == S_OK)
                {
                    Assert(pId != NULL);

                    hr = pId->OpenIdentityRegKey(KEY_READ | KEY_WRITE, &hkey);
                    if (SUCCEEDED(hr))
                    {
                        // check if it matches
                        cb = sizeof(szT);
                        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szRegInsGUID, NULL, &type, (LPBYTE)szT, &cb))
                        {
                            if (0 == lstrcmp(szT, szGuid))
                                break;
                        }

                        RegCloseKey(hkey);
                        hkey = NULL;
                    }

                    pId->Release();
                    pId = NULL;
                }
            }

            pEnum->Release();

            // if we can't find the user, create a new identity
            if (pId == NULL)
            {
                if (MultiByteToWideChar(CP_ACP, 0, sz, -1, szwUserName, CCH_USERNAME_MAX_LENGTH) == 0)
                    return(E_FAIL);

                hr = pIdMan->QueryInterface(IID_IPrivateIdentityManager, (void **)&pPrivIdMgr);
                if (FAILED(hr))
                    return(hr);

                hr = pPrivIdMgr->CreateIdentity(szwUserName, &pId);
                if (SUCCEEDED(hr))
                {
                    hr = pId->OpenIdentityRegKey(KEY_READ | KEY_WRITE, &hkey);
                    if (SUCCEEDED(hr))
                        RegSetValueEx(hkey, c_szRegInsGUID, 0, REG_SZ, (LPBYTE)szGuid, lstrlen(szGuid) + 1);
                }

                pPrivIdMgr->Release();
            }

            // set values for the identity
            Assert(pId != NULL);
            Assert(hkey != NULL);

            GUID guid;

            hr = HrCreateAccountManager((IImnAccountManager **)&pAcctMgr);
            if (SUCCEEDED(hr) && SUCCEEDED(pId->GetCookie(&guid)))
            {
                hr = pAcctMgr->InitUser(NULL, guid, 0);
                if (SUCCEEDED(hr))
                {
                    *szMailId = 0;
                    *szNewsId = 0;

                    dw = GetPrivateProfileString(pszSection, c_szMailSection, c_szEmpty, sz, ARRAYSIZE(sz), pszFile);
                    if (dw > 0)
                    {
                        CreateMailAccount(pAcctMgr, pszFile, sz, pci, hkey, szMailId, ARRAYSIZE(szMailId), dwFlags);
                        DoMailBranding(pszFile, sz, hkey);

                        HandleMultipleAccounts(ACCT_MAIL, pAcctMgr, pszFile, sz, pci, hkey, pId, dwFlags);
                    }

                    dwT = GetPrivateProfileString(pszSection, c_szNewsSection, c_szEmpty, szT, ARRAYSIZE(szT), pszFile);
                    if (dwT > 0)
                    {
                        CreateNewsAccount(pAcctMgr, pszFile, szT, (dw > 0) ? sz : NULL, pci, hkey, pId, szNewsId, ARRAYSIZE(szNewsId), dwFlags);
                        
                        HandleMultipleAccounts(ACCT_NEWS, pAcctMgr, pszFile, sz, pci, hkey, pId, dwFlags);
                    }

                    dw = GetPrivateProfileString(pszSection, c_szLDAPSection, c_szEmpty, sz, ARRAYSIZE(sz), pszFile);
                    if (dw > 0)
                    {
                        CreateLDAPAccount(pAcctMgr, pszFile, sz, pci);

                        HandleMultipleAccounts(ACCT_DIR_SERV, pAcctMgr, pszFile, sz, pci, hkey, pId, dwFlags);
                    }

                    dw = GetPrivateProfileString(pszSection, c_szMailSigSection, c_szEmpty, sz, ARRAYSIZE(sz), pszFile);
                    dwT = GetPrivateProfileString(pszSection, c_szNewsSigSection, c_szEmpty, szT, ARRAYSIZE(szT), pszFile);
                    SetSignature((dw > 0) ? sz : NULL, (dw > 0) ? szT : NULL, (*szMailId != 0) ? szMailId : NULL,
                                    (*szNewsId != 0) ? szNewsId : NULL, pszFile, hkey, pAcctMgr);

                    SetHelp(pszFile, c_szURLSection, hkey);

                    dw = GetPrivateProfileString(pszSection, c_szOESection, c_szEmpty, sz, ARRAYSIZE(sz), pszFile);
                    if (dw > 0)
                        DoBranding(pszFile, sz, hkey);
                }

                pAcctMgr->Release();
            }

            RegCloseKey(hkey);
            pId->Release();
        }
    }

    return(S_OK);
}

void SetHtmlEncoding(LPCSTR szFile, LPCSTR szSection, LPCSTR szValue, HKEY hkey, LPCSTR szRegValue)
{
    char sz[32];
    DWORD dw;

    dw = GetPrivateProfileString(szSection, szValue, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
    if (dw > 0)
    {
        dw = 0;
        if (0 == lstrcmpi(sz, c_szNone))
            dw = 4;
        else if (0 == lstrcmpi(sz, c_szBase64))
            dw = 1;
        else if (0 == lstrcmpi(sz, c_szQuotedPrintable))
            dw = 3;

        if (dw != 0)
            RegSetValueEx(hkey, szRegValue, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
    }
}

void SetPlainEncoding(LPCSTR szFile, LPCSTR szSection, LPCSTR szValue, HKEY hkey, LPCSTR szRegValue)
{
    char sz[32];
    DWORD dw;

    dw = GetPrivateProfileString(szSection, szValue, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
    if (dw > 0)
    {
        dw = -1;
        if (0 == lstrcmpi(sz, c_szMime))
            dw = 1;
        else if (0 == lstrcmpi(sz, c_szUuencode))
            dw = 0;

        if (dw != -1)
            RegSetValueEx(hkey, szRegValue, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
    }
}

void DoBranding(LPCSTR szFile, LPCSTR szOESection, HKEY hkeyUser)
{
    HKEY    hkey;
    DWORD   dw;
    int     i;
    char    sz[1024];
    HKEY    hkeyLM;
    
    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyUser, c_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_WRITE, NULL, &hkey, &dw))
    {
        dw = GetPrivateProfileString(szOESection, c_szFolderBar, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
        if (dw > 0)
        {
            dw = (0 != lstrcmpi(sz, c_szYes) && 0 != lstrcmpi(sz, c_sz1));
            RegSetValueEx(hkey, c_szRegHideFolderBar, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
        }
        
        SetRegProp(szFile, szOESection, c_szFolderList, hkey, c_szShowTree);
        SetRegProp(szFile, szOESection, c_szOutlookBar, hkey, c_szRegShowOutlookBar);
        SetRegProp(szFile, szOESection, c_szStatusBar, hkey, c_szShowStatus);
        SetRegProp(szFile, szOESection, c_szContacts, hkey, c_szRegShowContacts);
        SetRegProp(szFile, szOESection, c_szTipOfTheDay, hkey, c_szRegTipOfTheDay);
        SetRegProp(szFile, szOESection, c_szToolbar, hkey, c_szShowToolbarIEAK);
        SetRegProp(szFile, szOESection, c_szMigration, hkey, c_szMigrationPerformed);

        //Keys for Return Receipts admin
        SetRegProp(szFile, szOESection, c_szRequestReadReceipts, hkey, c_szRequestMDN);
        SetRegProp(szFile, szOESection, c_szReadReceiptResponse, hkey, c_szSendMDN);
        SetRegProp(szFile, szOESection, c_szSendReceiptsToList,  hkey, c_szSendReceiptToList);

        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, STR_REG_PATH_POLICY, 0, NULL, REG_OPTION_NON_VOLATILE,
                                            KEY_WRITE, NULL, &hkeyLM, &dw))
        {
            //Lock Keys for Return Receipts admin
            SetRegLockPropLM(szFile, szOESection, c_szReadReceiptResponseLocked,  hkeyLM, c_szSendMDNLocked, hkey);
            SetRegLockPropLM(szFile, szOESection, c_szSendReceiptsToListLocked,   hkeyLM, c_szSendReceiptToListLocked, hkey);
            SetRegLockPropLM(szFile, szOESection,  c_szRequestReadReceiptsLocked, hkeyLM, c_szRequestMDNLocked, hkey);
            RegCloseKey(hkeyLM);
        }


        dw = GetPrivateProfileInt(szOESection, c_szToolbarText, 666, szFile);
        if (dw == 0 || dw == 1)
        {
            if (dw == 0)
                dw = 2;
            RegSetValueEx(hkey, c_szRegToolbarText, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
        }

        dw = GetPrivateProfileInt(szOESection, c_szSecZone, 666, szFile);
        if (dw == 0 || dw == 1)
        {
            dw += 3;
            RegSetValueEx(hkey, c_szRegSecurityZone, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));
        }

        dw = GetPrivateProfileInt(szOESection, c_szSecZoneLocked, 666, szFile);
        if (dw == 0 || dw == 1)
            RegSetValueEx(hkey, c_szRegSecurityZoneLocked, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD));

        RegCloseKey(hkey);
    }
    
    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyUser, c_szRegRootMail, 0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_WRITE, NULL, &hkey, &dw))
    {
        SetRegProp(szFile, szOESection, c_szPreviewPane, hkey, c_szRegShowHybrid);
        SetRegProp(szFile, szOESection, c_szPreviewHeader, hkey, c_szMailShowHeaderInfo);
        SetRegProp(szFile, szOESection, c_szPreviewSide, hkey, c_szRegSplitDir);
        
        SetRegDw(szFile, szOESection, c_szSendEncoding, hkey, c_szDefaultCodePage);

        SetHtmlEncoding(szFile, szOESection, c_szMailEncoding, hkey, c_szMsgHTMLEncoding);
        SetRegProp(szFile, szOESection, c_szMailEnglishHeader, hkey, c_szMsgHTMLAllow8bit);
        SetPlainEncoding(szFile, szOESection, c_szMailPlainEncoding, hkey, c_szMsgPlainMime);
        SetRegProp(szFile, szOESection, c_szMailPlainEnglishHeader, hkey, c_szMsgPlainAllow8bit);

        SetRegProp(szFile, szOESection, c_szMapiWarn, hkey, c_szRegAppSend);
        SetRegProp(szFile, szOESection, c_szMapiWarnLocked, hkey, c_szRegAppSendLocked);
        SetRegProp(szFile, szOESection, c_szSafeAttach, hkey, c_szRegSafeAttachments);
        SetRegProp(szFile, szOESection, c_szSafeAttachLocked, hkey, c_szRegSafeAttachmentsLocked);

        RegCloseKey(hkey);
    }

    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyUser, c_szRegRootNews, 0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_WRITE, NULL, &hkey, &dw))
    {
        SetRegProp(szFile, szOESection, c_szPreviewPane, hkey, c_szRegShowHybrid);
        SetRegProp(szFile, szOESection, c_szPreviewHeader, hkey, c_szNewsShowHeaderInfo);
        SetRegProp(szFile, szOESection, c_szPreviewSide, hkey, c_szRegSplitDir);
        
        SetHtmlEncoding(szFile, szOESection, c_szNewsEncoding, hkey, c_szMsgHTMLEncoding);
        SetRegProp(szFile, szOESection, c_szNewsEnglishHeader, hkey, c_szMsgHTMLAllow8bit);
        SetPlainEncoding(szFile, szOESection, c_szNewsPlainEncoding, hkey, c_szMsgPlainMime);
        SetRegProp(szFile, szOESection, c_szNewsPlainEnglishHeader, hkey, c_szMsgPlainAllow8bit);

        RegCloseKey(hkey);
    }

    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyUser, c_szRegInternational, 0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_WRITE, NULL, &hkey, &dw))
    {
        SetRegDw(szFile, szOESection, c_szReadEncoding, hkey, c_szDefaultCodePage);
        
        RegCloseKey(hkey);
    }
}

void SetRegLockPropLM(LPCSTR szFile, LPCSTR szSection, LPCSTR szValue, HKEY hkeyLM, LPCSTR szRegValue, HKEY hkeyCU)
{ 
    char    sz[16];
    DWORD   dw;

    dw = GetPrivateProfileString(szSection, szValue, c_szEmpty, sz, ARRAYSIZE(sz), szFile);
    if (dw > 0)
    {
        dw = (0 == lstrcmpi(sz, c_szYes) || 0 == lstrcmpi(sz, c_sz1));
        if (ERROR_SUCCESS != RegSetValueEx(hkeyLM, szRegValue, 0, REG_DWORD, (LPBYTE)&dw, sizeof(DWORD)))
        {
            //Try to set in HKCU
            SetRegProp(szFile, szSection, szValue, hkeyCU, szRegValue);
        }
    }
}

BOOL GetSectionNames(LPSTR psz, DWORD cch, char chSep, DWORD *pcNames)
{
    LPSTR pszT, pszNames;
    BOOL fEOL;

    Assert(psz != NULL);
    Assert(cch > 0);
    Assert(pcNames != NULL);

    *pcNames = 0;

    pszNames = psz;
    while (*psz != 0)
    {
        pszT = psz;
        while (*psz != 0 && *psz != '=')
        {
            *pszNames = *psz;
            psz++;
            pszNames++;
        }

        fEOL = (*psz == 0);

        if (psz > pszT)
        {
            *pszNames = chSep;
            pszNames++;
            (*pcNames)++;
        }

        if (!fEOL)
        {
            psz++;
            while (*psz != 0)
                psz++;
        }

        psz++;
    }

    *pszNames = 0;
    pszNames++;

    return(*pcNames > 0);
}

void HandleMultipleAccounts(ACCTTYPE type, CAccountManager *pAcctMgr, LPCSTR pszFile, LPCSTR szSection, CONNECTINFO *pci, HKEY hkey, IUserIdentity *pId, DWORD dwFlags)
{
    DWORD dw, cch, i;
    char sz[1024], *psz, *pszT;

    dw = GetPrivateProfileString(szSection, c_szMultiAccounts, c_szEmpty, sz, ARRAYSIZE(sz), pszFile);
    if (dw > 0)
    {
        if (MemAlloc((void **)&psz, CBPROFILEBUF))
        {
            cch = GetPrivateProfileSection(sz, psz, CBPROFILEBUF, pszFile);
            if ((cch != 0) && (cch != (CBPROFILEBUF - 2)))
            {
                if (GetSectionNames(psz, cch, 0, &dw))
                {
                    for (i = 0, pszT = psz; i < dw; i++)
                    {
                        switch (type)
                        {
                            case ACCT_MAIL:
                                CreateMailAccount(pAcctMgr, pszFile, pszT, pci, hkey, NULL, 0, dwFlags);
                                break;

                            case ACCT_NEWS:
                                CreateNewsAccount(pAcctMgr, pszFile, pszT, NULL, pci, hkey, pId, NULL, 0, dwFlags);
                                break;

                            case ACCT_DIR_SERV:
                                CreateLDAPAccount(pAcctMgr, pszFile, pszT, pci);
                                break;

                            default:
                                Assert(FALSE);
                                break;
                        }
                        
                        pszT += (lstrlen(pszT) + 1);
                    }
                }
            }

            MemFree(psz);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\decode.h ===
#define idcDecodeAVI                    1007
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\server.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     Server.cpp
//
//  PURPOSE:    Contains the dialog callback and supporting functions for
//              the Add/Remove news server dialog.
//

#include "pch.hxx"
#include <mimeole.h>
#include <commctrl.h>
#include <wininet.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <ras.h>
#include "imnact.h"
#include "acctman.h"
#include "connect.h"
#include "acctui.h"
#include "server.h"
#include "strconst.h"
#include "dllmain.h"
#include <icwcfg.h>
#include "resource.h"
#include "accthelp.h"
#include <icwacct.h>
#include <acctimp.h>
#include "icwwiz.h"
#include <wincrypt.h>
#include <wintrust.h>
#include <cryptdlg.h>
#include "htmlhelp.h"
#include "shared.h"
#include "oeconprp.h"
#include "demand.h"

#ifdef  _UNICODE
#define _T(x)       L ## x
#else
#define _T(x)       x
#endif

ASSERTDATA

typedef struct tagFilterInfo
{
    TCHAR   *szEmail;
    BOOL    fEncryption;
    DWORD   dwFlags;
} ACCTFILTERINFO;

typedef struct tagSVRDLGINFO
    {
    SERVER_TYPE     sfType;
    DWORD           dwDirty;
    BOOL            dwInit;
    BOOL            fNoValidate;
    } SVRDLGINFO;

typedef struct tagSECPAGEINFO
    {
    PCCERT_CONTEXT  pCert;
    HCERTSTORE      hCertStore;
    PCCERT_CONTEXT  pEncryptCert;
    } SECPAGEINFO;

typedef struct tagSMTPAUTHINFO
    {
    BOOL            fDirty;
    SMTPAUTHTYPE    authtype;
    CHAR            szUserName[CCHMAX_USERNAME];
    CHAR            szPassword[CCHMAX_PASSWORD];
    BOOL            fPromptPassword;
    } SMTPAUTHINFO, *LPSMTPAUTHINFO;

INT_PTR CALLBACK ServerProp_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ServerProp_ServerDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ServerProp_AdvancedDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK SmtpLogonSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK MailServer_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK MailServer_ServersDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK MailServer_SecurityDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK MailServer_AdvancedDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK MailServer_IMAPDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
                                                                                                                                                               
INT_PTR CALLBACK DirServer_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DirServer_AdvancedDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void ImapRemoveTrailingHC(LPSTR pszPath, UINT uiLen);
BOOL ValidateAccountName(HWND hwnd, HWND hwndEdit, IImnAccount *pAcct, int *pidsError);
void GetAccountName(HWND hwndEdit, IImnAccount *pAcct);

void InitUserInformation(HWND hwnd, IImnAccount *pAcct, BOOL fNews);
BOOL ValidateUserInformation(HWND hwnd, IImnAccount *pAcct, BOOL fNews, HWND *phwndErr, int *puIdsErr, BOOL fApply);
void GetUserInformation(HWND hwnd, IImnAccount *pAcct, BOOL fNews);

BOOL ValidateServerName(HWND hwnd, HWND hwndEdit, IImnAccount *pAcct, DWORD dwPropSvr, int *pidsError, BOOL fApply);
void GetServerName(HWND hwndEdit, IImnAccount *pAcct, DWORD dwPropSvr);

BOOL ValidateLogonSettings(HWND hwnd, DWORD dwDlgFlags, HWND *phwndError, int *pidsError);
void GetLogonSettings(HWND hwnd, IImnAccount *pAcct, BOOL fLogon, DWORD srv);

BOOL    fWarnDomainName(HWND hwnd, DWORD dwDlgFlags, LPTSTR   pszPreviousLoginName);

int CALLBACK PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam);

BOOL ValidateCertificate(HWND hwnd, IImnAccount *pAcct, SVRDLGINFO *psdi, HWND *phwndErr, int *puIdsErr);
BOOL DoCertDialog(HWND hwndOwner, HWND hwndEmail, PCCERT_CONTEXT *ppCert, HCERTSTORE hCertStore, int *pidsError, DWORD dwFlags, BOOL fEncription);
BOOL CertFilterFunction(PCCERT_CONTEXT pCertContext, LPARAM dwEmailAddr, DWORD dwFlags, DWORD);
void GetCertificate(HWND hwnd, IImnAccount *pAcct, SVRDLGINFO *psdi);
DWORD InitCertificateData(TCHAR * szEmail, SVRDLGINFO *psdi, IImnAccount *pAcct);

DWORD InitEncryptData(TCHAR * szEmail, SECPAGEINFO *psdi, IImnAccount *pAcct);
int CheckKeyUsage(PCCERT_CONTEXT  pCert, DWORD dwFlag);
HRESULT HrGetHighestSymcaps(LPBYTE * ppbSymcap, ULONG *pcbSymcap);
BOOL AdvSec_FillEncAlgCombo(HWND hwnd, IImnAccount *pAcct, PCCERT_CONTEXT * prgCerts);
BOOL AdvSec_GetEncryptAlgCombo(HWND hwnd, IImnAccount *pAcct);

void GetDigitalID(HWND hwnd);

DWORD DwGenerateTrustedChain(
    HWND                hwnd,
    DWORD               dwFlags,
    PCCERT_CONTEXT      pcCertToTest,
    DWORD               dwToIgnore,
    BOOL                fFullSearch,
    DWORD *             pcChain,
    PCCERT_CONTEXT **   prgChain);


#define SERVERPROP_PAGEMAX  7

typedef struct tagSERVERPROP_PAGE
    {
    UINT uDlgId;
    DLGPROC pfnDlg;
    } SERVERPROP_PAGE;

typedef struct tagSERVERPROP_PARAMS
    {
    UINT uIcon;
    UINT idsCaption;
    SERVERPROP_PAGE rgPage[SERVERPROP_PAGEMAX];
    } SERVERPROP_PARAMS;

static const SERVERPROP_PARAMS c_rgServerPropParams[ACCT_LAST] = {
    // news
    { idiNewsServer,
      idsNewsAcctProperties,
      {{iddServerProp_General, ServerProp_GeneralDlgProc},
       {iddServerProp_Server, ServerProp_ServerDlgProc},
       {iddServerProp_Connect, ConnectPage_DlgProc},
       {iddServerProp_Advanced, ServerProp_AdvancedDlgProc},
       {0, NULL},
       {0, NULL},
       {0, NULL}}
    },

    // mail
    { idiMailServer,
      idsMailAcctProperties,
      {{iddMailSvrProp_General, MailServer_GeneralDlgProc},
       {iddMailSvrProp_Servers, MailServer_ServersDlgProc},
       {iddMailSvrProp_HttpServer, MailServer_ServersDlgProc},
       {iddServerProp_Connect, ConnectPage_DlgProc},
       {iddMailSvrProp_Security, MailServer_SecurityDlgProc},
       {iddMailSvrProp_Advanced, MailServer_AdvancedDlgProc},
       {iddMailSvrProp_IMAP, MailServer_IMAPDlgProc}}
    },

    // directory service
    { idiLDAPServer,
      idsDirSrvAcctProperties,
      {{iddDirServProp_General, DirServer_GeneralDlgProc},
       {iddDirServProp_Advanced, DirServer_AdvancedDlgProc},
       {0, NULL},
       {0, NULL},
       {0, NULL},
       {0, NULL},
       {0, NULL}}
    }
};

// generate static prop tables for each of the protocols

#define GEN_PROPS(type)                 \
    {                                   \
        AP_##type##_SERVER,             \
        AP_##type##_USERNAME,           \
        AP_##type##_PASSWORD,           \
        AP_##type##_PROMPT_PASSWORD,    \
        AP_##type##_USE_SICILY          \
    }

static MAILSERVERPROPSINFO c_rgMailServerProps[] =
{
    GEN_PROPS(POP3),
    GEN_PROPS(IMAP),
    GEN_PROPS(HTTPMAIL),
    GEN_PROPS(NNTP),
    { AP_LDAP_SERVER, AP_LDAP_USERNAME, AP_LDAP_PASSWORD, 0, AP_LDAP_AUTHENTICATION }
};

#undef GEN_PROPS

// Public constants

BOOL GetServerProps(SERVER_TYPE serverType, LPMAILSERVERPROPSINFO *psp)
{
    Assert(psp);

    switch (serverType)
    {
    case SERVER_MAIL:
        *psp = &c_rgMailServerProps[0];
        break;

    case SERVER_IMAP:
        *psp = &c_rgMailServerProps[1];
        break;

    case SERVER_HTTPMAIL:
        *psp = &c_rgMailServerProps[2];
        break;

    case SERVER_NEWS:
        *psp = &c_rgMailServerProps[3];
        break;

    case SERVER_LDAP:
        *psp = &c_rgMailServerProps[4];
        break;

    default:
        *psp = NULL;
        break;
    }

    return (NULL != *psp);
}

void MarkPageDirty(HWND hwnd, LPARAM page)
    {
    PropSheet_QuerySiblings(GetParent(hwnd), SM_SETDIRTY, page);
    PropSheet_Changed(GetParent(hwnd), hwnd);
    }

int HandleQuerySiblings(HWND hwnd, SVRDLGINFO *psdi, IImnAccount *pAcct, WPARAM wParam, LPARAM lParam)
    {
    int fRet;
    DWORD dwPage, *pdw;
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];
    HWND hwndT, hwndPage;
    ULONG uidsError, idCtrl, idd;

    Assert(psdi != NULL);
    Assert(pAcct != NULL);

    fRet = TRUE;

    switch (wParam)
        {
        case MSM_GETSERVERTYPE:
            Assert(lParam != NULL);
            Assert(psdi->sfType == SERVER_MAIL || psdi->sfType == SERVER_IMAP || psdi->sfType == SERVER_HTTPMAIL);
            *((SERVER_TYPE *)lParam) = psdi->sfType;
            break;

        case MSM_GETEMAILADDRESS:
            GetDlgItemText(hwnd, IDE_EMAIL_ADDRESS, sz, ARRAYSIZE(sz));
            StrCpyN((LPTSTR)lParam, sz, CCHMAX_EMAIL_ADDRESS);
            break;

        case MSM_GETDISPLAYNAME:
            GetDlgItemText(hwnd, IDE_DISPLAY_NAME, sz, ARRAYSIZE(sz));
            StrCpyN((LPTSTR)lParam, sz, CCHMAX_DISPLAY_NAME);
            break;

        case SM_SETDIRTY:
            if (!!(psdi->dwInit & lParam))
                psdi->dwDirty = (psdi->dwDirty | (DWORD) lParam);
            break;

        case SM_SAVECHANGES:
            pdw = (DWORD *)lParam;
            if (!!(psdi->dwInit & *pdw) && psdi->dwDirty != 0)
                {
                psdi->dwDirty = (psdi->dwDirty & ~(*pdw));
                if (psdi->dwDirty == 0)
                    {
                    uidsError = 0;
                    dwPage = PAGE_SERVER;

                    if (psdi->sfType == SERVER_MAIL || psdi->sfType == SERVER_IMAP)
                        {
                        if (FAILED(pAcct->GetPropSz(AP_SMTP_SERVER, sz, ARRAYSIZE(sz))))
                            {
                            uidsError = idsEnterSmtpServer;
                            idCtrl = IDC_SMTP_EDIT;
                            idd = iddMailSvrProp_Servers;
                            }
                        else if (psdi->sfType == SERVER_MAIL &&
                            FAILED(pAcct->GetPropSz(AP_POP3_SERVER, sz, ARRAYSIZE(sz))))
                            {
                            uidsError = idsEnterPop3Server;
                            idCtrl = IDC_POP3_EDIT;
                            idd = iddMailSvrProp_Servers;
                            }
                        else if (psdi->sfType == SERVER_IMAP &&
                            FAILED(pAcct->GetPropSz(AP_IMAP_SERVER, sz, ARRAYSIZE(sz))))
                            {
                            uidsError = idsEnterIMAPServer;
                            idCtrl = IDC_POP3_EDIT;
                            idd = iddMailSvrProp_Servers;
                            }
                        else if (psdi->sfType == SERVER_HTTPMAIL &&
                            FAILED(pAcct->GetPropSz(AP_HTTPMAIL_SERVER, sz, ARRAYSIZE(sz))))
                            {
                            uidsError = idsEnterHTTPMailServer;
                            idCtrl = IDC_POP3_EDIT;
                            idd = iddMailSvrProp_Servers;
                            }
                        }
                    else if (psdi->sfType == SERVER_NEWS)
                        {
                        if (FAILED(pAcct->GetPropSz(AP_NNTP_SERVER, sz, ARRAYSIZE(sz))))
                            {
                            uidsError = idsEnterIMAPServer;
                            idCtrl = IDC_NEWSNAME_EDIT;
                            idd = iddServerProp_Server;
                            }
                        }

                    if (uidsError != 0)
                        {
                        AcctMessageBox(hwnd, MAKEINTRESOURCE(idsAccountManager),
                                      MAKEINTRESOURCE(uidsError), 0, MB_ICONEXCLAMATION | MB_OK);

                        SendMessage(GetParent(hwnd), PSM_SETCURSELID, 0, (LPARAM)idd);
                        hwndPage = PropSheet_GetCurrentPageHwnd(GetParent(hwnd));

                        psdi->dwDirty = (psdi->dwDirty | dwPage);
                        PropSheet_Changed(GetParent(hwnd), hwndPage);

                        hwndT = GetDlgItem(hwndPage, idCtrl);
                        SendMessage(hwndT, EM_SETSEL, 0, -1);
                        SetFocus(hwndT);

                        *pdw = (DWORD)-1;

                        break;
                        }

                    pAcct->SaveChanges();
                    }
                }
            break;

        case SM_INITIALIZED:
            psdi->dwInit = (psdi->dwInit | (DWORD) lParam);
            break;

        default:
            fRet = FALSE;
            break;
        }

    return(fRet);
    }

BOOL InvalidAcctProp(HWND hwndPage, HWND hwndEdit, int idsError, UINT idPage)
    {
    HWND hwndCurr, hwndParent;

    Assert(hwndPage != NULL);
    Assert(idPage != 0);

    hwndParent = GetParent(hwndPage);

    if (idsError != 0)
        AcctMessageBox(hwndPage, MAKEINTRESOURCE(idsAccountManager), MAKEINTRESOURCE(idsError), 0, MB_ICONEXCLAMATION | MB_OK);

    hwndCurr = PropSheet_GetCurrentPageHwnd(hwndParent);
    if (hwndCurr != hwndPage)
        SendMessage(hwndParent, PSM_SETCURSELID, 0, (LPARAM)idPage);

    if (hwndEdit != NULL)
        {
        SendMessage(hwndEdit, EM_SETSEL, 0, -1);
        SetFocus(hwndEdit);
        }

    SetWindowLongPtr(hwndPage, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);

    return(TRUE);
    }

void InitAcctPropEdit(HWND hwnd, IImnAccount *pAcct, DWORD dwProp, UINT cchMax)
    {
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];

    Assert(pAcct != NULL);

    SetIntlFont(hwnd);
    if (SUCCEEDED(pAcct->GetPropSz(dwProp, sz, ARRAYSIZE(sz))))
        SetWindowText(hwnd, sz);
    SendMessage(hwnd, EM_LIMITTEXT, cchMax, 0L);
    }

// -----------------------------------------------------------------------------
// CAccount::ShowProperties
// -----------------------------------------------------------------------------
STDMETHODIMP CAccount::ShowProperties(HWND hwndParent, DWORD dwFlags)
    {
    HRESULT hr;
    int i, iReturn;
    PROPSHEETPAGE *ppsp, psp[SERVERPROP_PAGEMAX];
    PROPSHEETHEADER psh;
    SERVERPROP_PARAMS *pProp;
    SERVERPROP_PAGE *pPage;
    TCHAR szFmt[256], sz[512];
    DWORD dw = 0;
    BOOL fIMAP;
    BOOL fHttp;
    INITCOMMONCONTROLSEX    icex = { sizeof(icex), ICC_FLAGS };

    Assert(m_AcctType < ACCT_LAST);

    // Find out if we're an IMAP server
    GetServerTypes(&dw);
    fIMAP = !!(dw & SRV_IMAP);
    fHttp = !!(dw & SRV_HTTPMAIL);

    if (0 != (dwFlags & ~ACCTDLG_ALL))
        return(E_INVALIDARG);

    if (m_fNoModifyAccts)
        return(S_FALSE);

    InitCommonControlsEx(&icex);

    pProp = (SERVERPROP_PARAMS *)&c_rgServerPropParams[m_AcctType];

    psh.nPages = 0;

    ppsp = psp;
    ZeroMemory(psp, sizeof(PROPSHEETPAGE) * 4);

    for (pPage = pProp->rgPage, i = 0; i < SERVERPROP_PAGEMAX; pPage++, i++)
        {
        if (pPage->pfnDlg == NULL)
            break;

        if (pPage->uDlgId == iddMailSvrProp_Security &&
            !!(dwFlags & ACCTDLG_NO_SECURITY))
            continue;

        if (pPage->uDlgId == iddMailSvrProp_IMAP && FALSE == fIMAP)
            continue;

        if (pPage->uDlgId == iddMailSvrProp_Advanced && fHttp)
            continue;

        if (pPage->uDlgId == iddMailSvrProp_Servers && fHttp)
            continue;

        if (pPage->uDlgId == iddMailSvrProp_HttpServer && !fHttp)
            continue;

        ppsp->dwSize = sizeof(PROPSHEETPAGE);
        ppsp->dwFlags = PSP_DEFAULT;
        ppsp->hInstance = g_hInstRes;
        if ((pPage->uDlgId == iddServerProp_Connect) &&
            (!!(dwFlags & ACCTDLG_BACKUP_CONNECT)))
            {
                ppsp->pszTemplate = MAKEINTRESOURCE(iddServerProp_Connect2);
            }
        else
            {
            ppsp->pszTemplate = MAKEINTRESOURCE(pPage->uDlgId);
            }
        ppsp->pfnDlgProc = pPage->pfnDlg;

        //swap out the dialog id and the function proc if 
        if (((pPage->uDlgId == iddServerProp_Connect) ||
            (pPage->uDlgId == iddServerProp_Connect2)) &&
            (!!(dwFlags & ACCTDLG_INTERNETCONNECTION)))
        {
            ppsp->pszTemplate = MAKEINTRESOURCE(iddServerProp_ConnectOE);
            ppsp->pfnDlgProc =  OEConnProp_DlgProc;
        }


        ppsp->lParam = (LPARAM)this;
        ppsp++;
        psh.nPages++;
        }

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_USEICONID | PSH_PROPSHEETPAGE;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hInstRes;
    psh.pszIcon = MAKEINTRESOURCE(pProp->uIcon);
    if (*m_szName != 0)
        {
        LoadString(g_hInstRes, idsAcctPropsFmt, szFmt, ARRAYSIZE(szFmt));
        wnsprintf(sz, ARRAYSIZE(sz), szFmt, m_szName);
        psh.pszCaption = sz;
        }
    else
        {
        psh.pszCaption = (LPTSTR)IntToPtr(pProp->idsCaption);
        }
    psh.nStartPage = 0;
    psh.ppsp = psp;

    // bug 21535
    psh.dwFlags |= PSH_USECALLBACK;
    psh.pfnCallback = PropSheetProc;

    m_dwDlgFlags = dwFlags;

    iReturn = (int) PropertySheet(&psh);

    if (iReturn < 0)
        hr = E_FAIL;
    else if (iReturn == 0)
        hr = S_FALSE;
    else
        hr = S_OK;

    return(hr);
    }

//
//  FUNCTION:   ServerProp_Create()
//
//  PURPOSE:    Invokes the news server property sheet.
//
//  PARAMETERS:
//      <in> hwndParent - Handle that will be the parent of this dialog.
//      <in> stType     - Type of server.  Must be in the SERVER_TYPE enum.
//      <in> pszName    - Friendly name for the server.
//      <in> fNew       - TRUE to add a new server.
//
//  RETURN VALUE:
//      TRUE if successful, or FALSE otherwise.
//
BOOL ServerProp_Create(HWND hwndParent, DWORD dwFlags, LPTSTR pszName, IImnAccount **ppAccount)
    {
    TCHAR szServer[CCHMAX_SERVER_NAME];
    IImnAccount *pAcct;
    BOOL fReturn = FALSE;

    Assert(IsWindow(hwndParent));
    Assert(pszName != NULL);

    // Get the server object from the account manager
    if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, pszName, &pAcct)))
        return (FALSE);

    Assert(pAcct != NULL);

    if (S_OK == pAcct->ShowProperties(hwndParent, dwFlags))
        {
        fReturn = TRUE;

        if (ppAccount)
            {
            *ppAccount = pAcct;
            (*ppAccount)->AddRef();
            }
        }

    SafeRelease(pAcct);

    return (fReturn);
    }

void UpdateAcctTitle(HWND hwnd, int idCtrl, ACCTTYPE AcctType)
    {
    TCHAR sz[512], szAcct[CCHMAX_ACCOUNT_NAME], szFmt[256];
    int id, cch;

    cch = GetDlgItemText(hwnd, idCtrl, szAcct, ARRAYSIZE(szAcct));
    if (cch == 0)
        {
        LoadString(g_hInstRes, c_rgServerPropParams[AcctType].idsCaption, sz, ARRAYSIZE(sz));
        }
    else
        {
        LoadString(g_hInstRes, idsAcctPropsFmt, szFmt, ARRAYSIZE(szFmt));
        wnsprintf(sz, ARRAYSIZE(sz), szFmt, szAcct);
        }

    PropSheet_SetTitle(GetParent(hwnd), 0, sz);
    }

const static HELPMAP g_rgCtxMapNewsGen[] = {
                       {IDC_SERVERNAME_EDIT, IDH_MAIL_ACCOUNT},
                       {IDE_DISPLAY_NAME, IDH_NEWS_SERV_NAME},
                       {IDE_ORG_NAME, IDH_NEWS_SERV_ORG},
                       {IDE_EMAIL_ADDRESS, IDH_NEWS_SERV_EMAIL_ADD},
                       {IDE_REPLYTO_EMAIL_ADDRESS, IDH_MAIL_SERV_ADV_REPLY_TO},
                       {IDC_NEWSPOLL_CHECK, IDH_INCLUDE_NEWS_ACCOUNT},
                       {IDC_STATIC0, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC1, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC2, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC3, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC4, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC5, IDH_INETCOMM_GROUPBOX},
                       {0, 0}};

INT_PTR CALLBACK ServerProp_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                        LPARAM lParam)
    {
    BOOL fRet;
    DWORD dw;
    int idsError;
    HWND hwndT;
    NMHDR *pnmhdr;
    SVRDLGINFO *psdi;
    CAccount *pAcct;
    TCHAR szBuffer[CCHMAX_ACCOUNT_NAME];

    pAcct = (CAccount *)GetWindowLongPtr(hwnd, DWLP_USER);
    psdi = (SVRDLGINFO *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            if (!MemAlloc((void **)&psdi, sizeof(SVRDLGINFO)))
                return(-1);
            ZeroMemory(psdi, sizeof(SVRDLGINFO));
            psdi->sfType = SERVER_NEWS;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)psdi);

            // Get the ServerParams and store them in our extra bytes
            pAcct = (CAccount*) ((PROPSHEETPAGE*) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pAcct);

            InitUserInformation(hwnd, pAcct, TRUE);

            InitAcctPropEdit(GetDlgItem(hwnd, IDC_SERVERNAME_EDIT), pAcct, AP_ACCOUNT_NAME, CCHMAX_ACCOUNT_NAME - 1);

            // Poll this account...
            if (!!(pAcct->m_dwDlgFlags & ACCTDLG_NO_NEWSPOLL))
                ShowWindow(GetDlgItem(hwnd, IDC_NEWSPOLL_CHECK), SW_HIDE);

            if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_POLL, &dw)))
                CheckDlgButton(hwnd, IDC_NEWSPOLL_CHECK, dw ? BST_CHECKED : BST_UNCHECKED);
            else
                CheckDlgButton(hwnd, IDC_NEWSPOLL_CHECK, BST_UNCHECKED);

            psdi->dwInit = (psdi->dwInit | PAGE_GEN);
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            return(TRUE);

        case WM_DESTROY:
            psdi = (SVRDLGINFO *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (psdi != NULL)
                MemFree(psdi);
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:
            return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapNewsGen));

        case WM_COMMAND:
            if (LOWORD(wParam) == IDC_NEWSPOLL_CHECK)
                {
                MarkPageDirty(hwnd, PAGE_GEN);
                }
            else if (HIWORD(wParam) == EN_CHANGE)
                {
                if (LOWORD(wParam) == IDC_SERVERNAME_EDIT)
                    UpdateAcctTitle(hwnd, IDC_SERVERNAME_EDIT, ACCT_NEWS);
                MarkPageDirty(hwnd, PAGE_GEN);
                }
            return (TRUE);

        case PSM_QUERYSIBLINGS:
            return(HandleQuerySiblings(hwnd, psdi, pAcct, wParam, lParam));

        case WM_NOTIFY:
            pnmhdr = (NMHDR *)lParam;
            switch (pnmhdr->code)
                {
                case PSN_APPLY:
                    // BEGIN validation

                    hwndT = GetDlgItem(hwnd, IDC_SERVERNAME_EDIT);
                    if (!ValidateAccountName(hwnd, hwndT, pAcct, &idsError))
                        return(InvalidAcctProp(hwnd, hwndT, idsError, iddServerProp_General));

                    fRet = ValidateUserInformation(hwnd, pAcct, TRUE, &hwndT, &idsError, pnmhdr->code == PSN_APPLY);
                    if (!fRet)
                        return(InvalidAcctProp(hwnd, hwndT, idsError, iddServerProp_General));

                    // END validation

                    hwndT = GetDlgItem(hwnd, IDC_SERVERNAME_EDIT);
                    GetAccountName(hwndT, pAcct);

                    GetUserInformation(hwnd, pAcct, TRUE);

                    // News Polling
                    pAcct->SetPropDw(AP_NNTP_POLL, (DWORD) IsDlgButtonChecked(hwnd, IDC_NEWSPOLL_CHECK));

                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    dw = PAGE_GEN;
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SAVECHANGES, (LPARAM)&dw);
                    if (dw == -1)
                        {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return(TRUE);
                        }
                    break;
                }
            return(TRUE);
        }

    return (FALSE);
    }

BOOL ValidateServerName(HWND hwnd, HWND hwndEdit, IImnAccount *pAcct, DWORD dwPropSvr, int *pidsError, BOOL fApply)
    {
    HRESULT hr;
    int idsSvr, idsPrompt;
    ULONG cbSize;
    TCHAR sz[CCHMAX_SERVER_NAME];
    DWORD dw;

    Assert(hwndEdit != NULL);
    Assert(pAcct != NULL);
    Assert(pidsError != NULL);

    *pidsError = 0;

    switch(dwPropSvr)
        {
        case AP_LDAP_SERVER:
            idsSvr = idsEnterLdapServer;
            idsPrompt = idsInvalidLdapServer;
            break;
        case AP_IMAP_SERVER:
            idsSvr = idsEnterIMAPServer;
            idsPrompt = idsInvalidIMAPServer;
            break;
        case AP_NNTP_SERVER:
            idsSvr = idsEnterNntpServer;
            idsPrompt = idsInvalidNntpServer;
            break;
        case AP_POP3_SERVER:
            idsSvr = idsEnterPop3Server;
            idsPrompt = idsInvalidPop3Server;
            break;
        case AP_SMTP_SERVER:
            idsSvr = idsEnterSmtpServer;
            idsPrompt = idsInvalidSmtpServer;
            break;
        case AP_HTTPMAIL_SERVER:
            idsSvr = idsEnterHTTPMailServer;
            idsPrompt = idsInvalidHTTPMailServer;
            break;
        default:
            Assert(FALSE);
            break;
        }

    cbSize = GetWindowText(hwndEdit, sz, ARRAYSIZE(sz));
    UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
    if (cbSize == 0)
        {
            // it is legal to have no smtp server with httpmail
            if (dwPropSvr != AP_SMTP_SERVER || FAILED(pAcct->GetServerTypes(&dw)) || !(dw & SRV_HTTPMAIL))
            {
                *pidsError = idsSvr;
                return(FALSE);
            }
        }
    // if the server hasn't changed, we don't need to validate it
    if (0 == SendMessage(hwndEdit, EM_GETMODIFY, 0, 0))
        return(TRUE);
    hr = pAcct->ValidateProperty(dwPropSvr, (LPBYTE)sz, 0);
    if (FAILED(hr))
        {
        *pidsError = idsSvr;
        return(FALSE);
        }
    else if (hr == S_NonStandardValue && fApply)
        {
        if (IDNO == AcctMessageBox(hwnd, MAKEINTRESOURCE(idsAccountManager), MAKEINTRESOURCE(idsPrompt),
                                  NULL, MB_YESNO | MB_ICONEXCLAMATION  | MB_DEFBUTTON2))
            return(FALSE);
        }

    return(TRUE);
    }

void GetServerName(HWND hwndEdit, IImnAccount *pAcct, DWORD dwPropSvr)
    {
    ULONG cbSize;
    TCHAR sz[CCHMAX_SERVER_NAME];

    Assert(hwndEdit != NULL);
    Assert(pAcct != NULL);

    if (0 != SendMessage(hwndEdit, EM_GETMODIFY, 0, 0))
        {
        cbSize = GetWindowText(hwndEdit, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
        if (cbSize == 0)
            pAcct->SetProp(dwPropSvr, NULL, 0);
        else
            pAcct->SetPropSz(dwPropSvr, sz);

        if (dwPropSvr == AP_POP3_SERVER)
            pAcct->SetProp(AP_IMAP_SERVER, NULL, 0);
        else if (dwPropSvr == AP_IMAP_SERVER)
        {
            DWORD dw;

            pAcct->SetProp(AP_POP3_SERVER, NULL, 0);
            if (FAILED(pAcct->GetPropDw(AP_IMAP_DIRTY, &dw)))
                dw = 0;

            dw |= IMAP_FLDRLIST_DIRTY;
            pAcct->SetPropDw(AP_IMAP_DIRTY, dw);
        }

        SendMessage(hwndEdit, EM_SETMODIFY, 0, 0);
        }
    }

BOOL ValidateLogonSettings(HWND hwnd, DWORD dwDlgFlags, 
                           HWND *phwndError, int *pidsError)
{
    TCHAR       sz[CCHMAX_ACCT_PROP_SZ];
    HWND        hwndT;
    ULONG       cbSize;    

    Assert(hwnd != NULL);
    Assert(phwndError != NULL);
    Assert(pidsError != NULL);

    BOOL fOE = ISFLAGSET(dwDlgFlags, ACCTDLG_OE);
    BOOL fSPA = IsDlgButtonChecked(hwnd, IDC_LOGONSSPI_CHECK);

    *phwndError = NULL;
    *pidsError = 0;

    hwndT = GetDlgItem(hwnd, IDC_ACCTNAME_EDIT);
    cbSize = GetWindowText(hwndT, sz, ARRAYSIZE(sz));
    UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
    if (fOE && cbSize == 0)
    {
        *phwndError = hwndT;
        *pidsError = idsEnterAcctName;
        return (FALSE);
    }

    return (TRUE);
}

BOOL    fWarnDomainName(HWND hwnd, DWORD dwDlgFlags, LPTSTR   pszPreviousLoginName)
{
    TCHAR       sz[CCHMAX_ACCT_PROP_SZ];
    HWND        hwndT;
    ULONG       cbSize;
    BOOL        fret = TRUE;
    BOOL        fOE = TRUE;
        
    fOE = ISFLAGSET(dwDlgFlags, ACCTDLG_OE);

    hwndT = GetDlgItem(hwnd, IDC_ACCTNAME_EDIT);
    cbSize = GetWindowText(hwndT, sz, ARRAYSIZE(sz));
    UlStripWhitespace(sz, TRUE, TRUE, &cbSize);

    if (fOE && 
       (lstrcmp(pszPreviousLoginName, sz) != 0))
    {
        if (ValidEmailAddressParts(sz, NULL, 0, NULL, 0) != S_OK)
        {
            if (IDNO == AcctMessageBox(hwnd, MAKEINTRESOURCE(idsAccountManager), 
                                             MAKEINTRESOURCE(idsAccountNameErr), 
                                             NULL, MB_YESNO))
            {
                fret = FALSE;
                goto exit;
            }
        }
    }

exit:
    return fret;
}


void GetLogonSettings(HWND hwnd, IImnAccount *pAcct, BOOL fLogon, DWORD srv)
    {
    HWND hwndT;
    ULONG cbSize;
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];
    DWORD dw, fOldSicily = FALSE;
    LPMAILSERVERPROPSINFO pServerProps = NULL;
    BOOL fIMAPDirty = FALSE;

    Assert(pAcct != NULL);

    switch (srv)
    {
        case SRV_POP3:
            GetServerProps(SERVER_MAIL, &pServerProps);
            break;

        case SRV_IMAP:
            GetServerProps(SERVER_IMAP, &pServerProps);
            break;

        case SRV_HTTPMAIL:
            GetServerProps(SERVER_HTTPMAIL, &pServerProps);
            break;

        case SRV_NNTP:
            GetServerProps(SERVER_NEWS, &pServerProps);
            break;

        case SRV_LDAP:
            GetServerProps(SERVER_LDAP, &pServerProps);
            break;

        default:
            break;
    }

    Assert(NULL != pServerProps);

    // Record old SPA setting so we can tell if user went between cleartext/SPA (IMAP dirty)
    pAcct->GetPropDw(pServerProps->useSicily, &fOldSicily);

    pAcct->SetProp(pServerProps->userName, NULL, 0);
    pAcct->SetProp(pServerProps->password, NULL, 0);
    pAcct->SetProp(pServerProps->useSicily, NULL, 0);
    if (0 != pServerProps->promptPassword)
        pAcct->SetProp(pServerProps->promptPassword, NULL, 0);

    if (fLogon)
        {
        // Get User Account Name
        hwndT = GetDlgItem(hwnd, IDC_ACCTNAME_EDIT);

        // For IMAP, set dirty flag if username changed or went from SPA to cleartext
        if (fOldSicily || (SRV_IMAP == srv && SendMessage(hwndT, EM_GETMODIFY, 0, 0)))
            fIMAPDirty = TRUE;

        cbSize = GetWindowText(hwndT, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
        pAcct->SetPropSz(pServerProps->userName, sz);

        // Get Password if user didn't tell us to always prompt for it
        if (0 != pServerProps->promptPassword)
            {
            dw = !IsDlgButtonChecked(hwnd, IDC_REMEMBER_PASSWORD);
            pAcct->SetPropDw(pServerProps->promptPassword, dw);
            }
        else
            // There is no LDAP setting to always prompt for password
            dw = FALSE;

        if (FALSE == dw)
            {
            cbSize = GetDlgItemText(hwnd, IDC_ACCTPASS_EDIT, sz, ARRAYSIZE(sz));
            if (cbSize > 0)
                pAcct->SetPropSz(pServerProps->password, sz);
            }

        if (!IsDlgButtonChecked(hwnd, IDC_LOGONSSPI_CHECK))
            {
            dw = LDAP_AUTH_PASSWORD;
            }

        else
            {
            if (srv != SRV_LDAP)
                pAcct->SetPropDw(pServerProps->useSicily, TRUE);

            // For IMAP, set dirty flag if we went from cleartext to SPA
            if (FALSE == fOldSicily)
                fIMAPDirty = TRUE;

            dw = LDAP_AUTH_MEMBER_SYSTEM;
            }
        }
    else
        {
        dw = LDAP_AUTH_ANONYMOUS;
        }

    if (srv == SRV_LDAP)
        pAcct->SetPropDw(pServerProps->useSicily, dw);

    if (fIMAPDirty)
        {
        if (FAILED(pAcct->GetPropDw(AP_IMAP_DIRTY, &dw)))
            dw = 0;

        dw |= IMAP_FLDRLIST_DIRTY;
        pAcct->SetPropDw(AP_IMAP_DIRTY, dw);
        }
    }

void Server_EnableLogonWindows(HWND hwnd, BOOL fEnable)
    {
    HWND hwndT;
    BOOL fPromptPassword;

    hwndT = GetDlgItem(hwnd, IDC_REMEMBER_PASSWORD);
    if (hwndT != NULL)
        {
        fPromptPassword = (BST_CHECKED != SendMessage(hwndT, BM_GETCHECK, 0, 0));
        EnableWindow(hwndT, fEnable);
        }
    else
        {
        fPromptPassword = FALSE;
        }
    
    EnableWindow(GetDlgItem(hwnd, IDC_LOGONSSPI_CHECK), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_ACCTNAME_EDIT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_ACCTNAME_STATIC), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_EDIT), fEnable && !fPromptPassword);
    EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_STATIC), fEnable);
    }

const static HELPMAP g_rgCtxMapNewsSvr[] = {
                       {IDC_NEWSNAME_EDIT, IDH_NEWS_SERV_INCOMING},
                       {IDC_LOGON_CHECK, IDH_INETCOMM_SERVER_REQ_LOGON},
                       {IDC_ACCTNAME_EDIT, IDH_MAIL_SERV_POP3_ACCT},
                       {IDC_ACCTNAME_STATIC, IDH_MAIL_SERV_POP3_ACCT},
                       {IDC_ACCTPASS_EDIT, IDH_MAIL_SERV_PWORD},
                       {IDC_ACCTPASS_STATIC, IDH_MAIL_SERV_PWORD},
                       {IDC_LOGONSSPI_CHECK, IDH_MAIL_LOGON_USING_SICILY},
                       {IDC_REMEMBER_PASSWORD, 503},
                       {IDC_STATIC0, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC1, IDH_INETCOMM_GROUPBOX},
                       {0, 0}};

INT_PTR CALLBACK ServerProp_ServerDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT     hr;
    int         idsError;
    WORD        wNotifyCode, wID;
	BOOL        fRet, fLogon, fValid;
    TCHAR       sz[CCHMAX_ACCT_PROP_SZ];
    CAccount    *pAcct;
    DWORD       flag;
    HWND        hwndT;
    ULONG       cbSize;
    NMHDR       *pnmhdr;

    fRet = TRUE;
    pAcct = (CAccount *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get the ServerParams and store them in our extra bytes
            pAcct = (CAccount *)((PROPSHEETPAGE *) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pAcct);

            InitAcctPropEdit(GetDlgItem(hwnd, IDC_NEWSNAME_EDIT), pAcct, AP_NNTP_SERVER, CCHMAX_SERVER_NAME - 1);

            fLogon = FALSE;

            if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_USE_SICILY, (LPDWORD)&flag)) && flag)
                {
                CheckDlgButton(hwnd, IDC_LOGONSSPI_CHECK, BST_CHECKED);
                fLogon = TRUE;
                }

            if (SUCCEEDED(pAcct->GetPropSz(AP_NNTP_USERNAME, sz, ARRAYSIZE(sz))) && *sz != 0)
                {
                SetDlgItemText(hwnd, IDC_ACCTNAME_EDIT, sz);

                if (SUCCEEDED(pAcct->GetPropSz(AP_NNTP_PASSWORD, sz, ARRAYSIZE(sz))))
                    SetDlgItemText(hwnd, IDC_ACCTPASS_EDIT, sz);

                fLogon = TRUE;
                }

            if (FAILED(pAcct->GetPropDw(AP_NNTP_PROMPT_PASSWORD, &flag)))
                flag = FALSE;
            CheckDlgButton(hwnd, IDC_REMEMBER_PASSWORD, flag ? BST_UNCHECKED : BST_CHECKED);

            hwndT = GetDlgItem(hwnd, IDC_ACCTNAME_EDIT);
            SetIntlFont(hwndT);
            SendMessage(hwndT, EM_LIMITTEXT, CCHMAX_USERNAME - 1, 0L);

            SendDlgItemMessage(hwnd, IDC_ACCTPASS_EDIT, EM_LIMITTEXT, CCHMAX_PASSWORD - 1, 0L);

            CheckDlgButton(hwnd, IDC_LOGON_CHECK, fLogon);
            Server_EnableLogonWindows(hwnd, fLogon);

            if (SUCCEEDED(pAcct->GetPropDw(AP_SERVER_READ_ONLY, &flag)) && flag)
                EnableWindow(GetDlgItem(hwnd, IDC_NEWSNAME_EDIT), FALSE);

            PropSheet_QuerySiblings(GetParent(hwnd), SM_INITIALIZED, PAGE_SERVER);
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:
            return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapNewsSvr));

        case WM_COMMAND:
            wNotifyCode = HIWORD(wParam);
            wID = LOWORD(wParam);

            switch (wID)
                {
                case IDC_LOGON_CHECK:
                case IDC_LOGONSSPI_CHECK:
                    Server_EnableLogonWindows(hwnd, IsDlgButtonChecked(hwnd, IDC_LOGON_CHECK));

                    MarkPageDirty(hwnd, PAGE_SERVER);
                    break;

                case IDC_REMEMBER_PASSWORD:
                    flag = IsDlgButtonChecked(hwnd, IDC_REMEMBER_PASSWORD);
                    EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_EDIT), flag);
                    MarkPageDirty(hwnd, PAGE_SERVER);
                    break;

                default:
                    if (wNotifyCode == EN_CHANGE)
                        MarkPageDirty(hwnd, PAGE_SERVER);
                    break;
                }
            break;

        case WM_NOTIFY:
            pnmhdr = (NMHDR *)lParam;
            switch (pnmhdr->code)
            {
                case PSN_APPLY:
                    // BEGIN validation

                    hwndT = GetDlgItem(hwnd, IDC_NEWSNAME_EDIT);
                    if (!ValidateServerName(hwnd, hwndT, pAcct, AP_NNTP_SERVER, &idsError, pnmhdr->code == PSN_APPLY))
                        return(InvalidAcctProp(hwnd, hwndT, idsError, iddServerProp_Server));

                    if (IsDlgButtonChecked(hwnd, IDC_LOGON_CHECK) &&
                        !ValidateLogonSettings(hwnd, pAcct->m_dwDlgFlags, &hwndT, &idsError))
                        return(InvalidAcctProp(hwnd, hwndT, idsError, iddServerProp_Server));

                    // END validation

                    hwndT = GetDlgItem(hwnd, IDC_NEWSNAME_EDIT);
                    GetServerName(hwndT, pAcct, AP_NNTP_SERVER);

                    GetLogonSettings(hwnd, pAcct, IsDlgButtonChecked(hwnd, IDC_LOGON_CHECK), SRV_NNTP);

                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    flag = PAGE_SERVER;
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SAVECHANGES, (LPARAM)&flag);
                    if (flag == -1)
                        {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return(TRUE);
                        }
                    break;
            }
            return(TRUE);

        default:
            fRet = FALSE;
            break;
        }

    return(fRet);
    }

BOOL ValidateAccountName(HWND hwnd, HWND hwndT, IImnAccount *pAcct, int *pidsError)
    {
    ULONG cbSize;
    TCHAR szAccount[CCHMAX_ACCOUNT_NAME], szAcctOld[CCHMAX_ACCOUNT_NAME];
    IImnAccount *pAcctT;

    Assert(IsWindow(hwndT));
    Assert(pAcct != NULL);
    Assert(pidsError != NULL);

    *pidsError = 0;

    cbSize = GetWindowText(hwndT, szAccount, ARRAYSIZE(szAccount));
    if (cbSize == 0)
        {
        *pidsError = idsInvalidAccountName;
        return(FALSE);
        }

    if (0 == SendMessage(hwndT, EM_GETMODIFY, 0, 0))
        return(TRUE);

    if (FAILED(pAcct->ValidateProperty(AP_ACCOUNT_NAME, (LPBYTE)szAccount, 0)))
        {
        *pidsError = idsInvalidAccountName;
        return(FALSE);
        }

    *szAcctOld = 0;
    pAcct->GetPropSz(AP_ACCOUNT_NAME, szAcctOld, ARRAYSIZE(szAcctOld));

    if (*szAcctOld == 0 || 0 != lstrcmpi(szAccount, szAcctOld))
        {
        // if we're changing the name, then we need to make sure it's unique
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAcctT)))
            {
            pAcctT->Release();
            *pidsError = idsNeedUniqueAccountName;
            return(FALSE);
            }
        }

    return(TRUE);
    }

void GetAccountName(HWND hwndEdit, IImnAccount *pAcct)
    {
    UINT cbSize;
    TCHAR szAccount[CCHMAX_ACCOUNT_NAME];

    Assert(IsWindow(hwndEdit));

    if (0 != SendMessage(hwndEdit, EM_GETMODIFY, 0, 0))
        {
        cbSize = GetWindowText(hwndEdit, szAccount, ARRAYSIZE(szAccount));
        Assert(cbSize > 0);

        pAcct->SetPropSz(AP_ACCOUNT_NAME, szAccount);

        SendMessage(hwndEdit, EM_SETMODIFY, 0, 0);
        }
    }

// TODO: move these to somewhere appropriate
#define TIMEOUT_SEC_MIN     30
#define TIMEOUT_SEC_MAX     5 * 60
#define TIMEOUT_DSEC        30

#define CTIMEOUT            (((TIMEOUT_SEC_MAX - TIMEOUT_SEC_MIN) / TIMEOUT_DSEC) + 1)

void InitTimeoutSlider(HWND hwndSlider, HWND hwndText, DWORD dwTimeout)
    {
    DWORD dw;

    if (dwTimeout < TIMEOUT_SEC_MIN)
        dwTimeout = TIMEOUT_SEC_MIN;
    else if (dwTimeout > TIMEOUT_SEC_MAX)
        dwTimeout = TIMEOUT_SEC_MAX;

    dw = (dwTimeout / TIMEOUT_DSEC) - 1;

    SendMessage(hwndSlider, TBM_SETRANGE, 0, (LPARAM)MAKELONG(0, CTIMEOUT - 1));
    SendMessage(hwndSlider, TBM_SETPOS, TRUE, (LPARAM)dw);
    SetTimeoutString(hwndText, dw);
    }

void SetTimeoutString(HWND hwnd, UINT pos)
    {
    UINT cch, csec, cmin;
    TCHAR szOut[128], sz[128];

    csec = TIMEOUT_SEC_MIN + (pos * TIMEOUT_DSEC);
    Assert(csec >= TIMEOUT_SEC_MIN && csec <= TIMEOUT_SEC_MAX);

    cmin = csec / 60;
    csec = csec % 60;
    if (cmin > 1)
        {
        LoadString(g_hInstRes, idsXMinutes, sz, ARRAYSIZE(sz));
        wnsprintf(szOut, ARRAYSIZE(szOut), sz, cmin);
        cch = lstrlen(szOut);
        }
    else if (cmin == 1)
        {
        cch = LoadString(g_hInstRes, ids1Minute, szOut, ARRAYSIZE(szOut));
        }
    else
        {
        cch = 0;
        }

    if (csec != 0)
        {
        if (cmin > 0)
            {
            szOut[cch] = ' ';
            cch++;
            }

        LoadString(g_hInstRes, idsXSeconds, sz, ARRAYSIZE(sz));
        wnsprintf(&szOut[cch], (ARRAYSIZE(szOut) - cch), sz, csec);
        }

    SetWindowText(hwnd, szOut);
    }

DWORD GetTimeoutFromSlider(HWND hwnd)
    {
    DWORD dw;

    dw = (DWORD) SendMessage(hwnd, TBM_GETPOS, 0, 0);
    dw = TIMEOUT_SEC_MIN + (dw * TIMEOUT_DSEC);

    return(dw);
    }

const static HELPMAP g_rgCtxMapNewsAdv[] = {
                       {IDC_USEDEFAULTS_BUTTON, IDH_NEWS_SERV_ADV_USE_DEFAULTS},
                       {IDC_SECURECONNECT_BUTTON, IDH_MAIL_ADV_REQ_SSL},
                       {IDC_TIMEOUT_SLIDER, IDH_NEWS_SERV_ADV_TIMEOUT},
                       {IDC_TIMEOUT_STATIC, IDH_NEWS_SERV_ADV_TIMEOUT},
                       {IDC_USEDESC_CHECK, IDH_NEWS_SERV_ADV_DESC},
                       {IDC_SPLIT_CHECK, IDH_NEWSMAIL_SEND_ADVSET_BREAK_UP},
                       {IDC_SPLIT_EDIT, IDH_NEWSMAIL_SEND_ADVSET_BREAK_UP},
                       {IDC_SPLIT_SPIN, IDH_NEWSMAIL_SEND_ADVSET_BREAK_UP},
                       {IDC_SPLIT_STATIC, IDH_NEWSMAIL_SEND_ADVSET_BREAK_UP},
                       {IDC_NNTPPORT_EDIT, IDH_NEWS_PORT_NUMBER},
                       {IDC_FORMAT_CHECK, 691},
                       {IDC_HTML_RADIO, 692},
                       {IDC_TEXT_RADIO, 692},
                       {IDC_STATIC0, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC1, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC2, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC3, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC4, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC5, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC6, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC7, IDH_INETCOMM_GROUPBOX},
                       {0, 0}};

INT_PTR CALLBACK ServerProp_AdvancedDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                         LPARAM lParam)
    {
    HWND hwndT;
    NMHDR *pnmhdr;
    DWORD dw, flag, dwPort, dwSplit;
    WORD code;
    BOOL fTrans, fSecure;
    TCHAR szBuffer[CCHMAX_ACCOUNT_NAME];
    CAccount *pAcct = (CAccount *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get the ServerParams and store them in our extra bytes
            pAcct = (CAccount *) ((PROPSHEETPAGE*) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pAcct);

            // Load the controls with what information we have
            if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_PORT, &dw)))
                SetDlgItemInt(hwnd, IDC_NNTPPORT_EDIT, dw, FALSE);
            SendDlgItemMessage(hwnd, IDC_NNTPPORT_EDIT, EM_LIMITTEXT, PORT_CCHMAX, 0);
            if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_SSL, (LPDWORD)  &fSecure)) && fSecure)
                {
                EnableWindow(GetDlgItem(hwnd, IDC_USEDEFAULTS_BUTTON), dw != DEF_SNNTPPORT);
                CheckDlgButton(hwnd, IDC_SECURECONNECT_BUTTON, TRUE);
                }
            else
                {
                EnableWindow(GetDlgItem(hwnd, IDC_USEDEFAULTS_BUTTON), dw != DEF_NNTPPORT);
                }

            dw = 0;
            pAcct->GetPropDw(AP_NNTP_TIMEOUT, &dw);
            InitTimeoutSlider(GetDlgItem(hwnd, IDC_TIMEOUT_SLIDER),
                              GetDlgItem(hwnd, IDC_TIMEOUT_STATIC), dw);

            if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_USE_DESCRIPTIONS, &dw)))
                CheckDlgButton(hwnd, IDC_USEDESC_CHECK, dw);

            if (!!(pAcct->m_dwDlgFlags & ACCTDLG_NO_BREAKMESSAGES))
                {
                ShowWindow(GetDlgItem(hwnd, IDC_SPLIT_CHECK), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_SPLIT_EDIT), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_SPLIT_SPIN), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_SPLIT_STATIC), SW_HIDE);
                }

            // Break Message Size
            dw = OPTION_OFF; // default
            if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_SPLIT_MESSAGES, (LPDWORD)&flag)) && flag)
                pAcct->GetPropDw(AP_NNTP_SPLIT_SIZE, (LPDWORD)&dw);
            InitCheckCounter(dw, hwnd, IDC_SPLIT_CHECK, IDC_SPLIT_EDIT, IDC_SPLIT_SPIN,
                             BREAKSIZE_MIN, BREAKSIZE_MAX, DEF_BREAKSIZE);

            pAcct->GetPropDw(AP_NNTP_POST_FORMAT, &flag);
            CheckDlgButton(hwnd, IDC_FORMAT_CHECK, flag != POST_USE_DEFAULT);
            CheckDlgButton(hwnd, flag == POST_USE_HTML ? IDC_HTML_RADIO : IDC_TEXT_RADIO, TRUE);
            if (flag == POST_USE_DEFAULT)
                {
                EnableWindow(GetDlgItem(hwnd, IDC_HTML_RADIO), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_TEXT_RADIO), FALSE);
                }

            PropSheet_QuerySiblings(GetParent(hwnd), SM_INITIALIZED, PAGE_ADV);
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            return (TRUE);

        case WM_HELP:
        case WM_CONTEXTMENU:
            return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapNewsAdv));

        case WM_HSCROLL:
            // Update the text beside the slider
            SetTimeoutString(GetDlgItem(hwnd, IDC_TIMEOUT_STATIC),
                             (UINT) SendMessage((HWND) lParam, TBM_GETPOS, 0, 0));

            MarkPageDirty(hwnd, PAGE_ADV);
            return (TRUE);

        case WM_COMMAND:
            // Any change to the edit controls would cause the "Apply" button
            // to enable.
            fSecure = IsDlgButtonChecked(hwnd, IDC_SECURECONNECT_BUTTON);
            code = HIWORD(wParam);

            switch (LOWORD(wParam))
                {
                case IDC_NNTPPORT_EDIT:
                    if (code == EN_CHANGE)
                        {
                        dw = GetDlgItemInt(hwnd, IDC_NNTPPORT_EDIT, &fTrans, FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_USEDEFAULTS_BUTTON),
                            !fTrans || (fSecure ? (dw != DEF_SNNTPPORT) : (dw != DEF_NNTPPORT)));

                        MarkPageDirty(hwnd, PAGE_ADV);
                        }
                    break;

                case IDC_USEDESC_CHECK:
                case IDC_TEXT_RADIO:
                case IDC_HTML_RADIO:
                    MarkPageDirty(hwnd, PAGE_ADV);
                    break;

                case IDC_SPLIT_EDIT:
                    if (code == EN_CHANGE)
                        MarkPageDirty(hwnd, PAGE_ADV);
                    break;

                case IDC_FORMAT_CHECK:
                    fTrans = IsDlgButtonChecked(hwnd, IDC_FORMAT_CHECK);
                    EnableWindow(GetDlgItem(hwnd, IDC_HTML_RADIO), fTrans);
                    EnableWindow(GetDlgItem(hwnd, IDC_TEXT_RADIO), fTrans);

                    MarkPageDirty(hwnd, PAGE_ADV);
                    break;

                case IDC_SPLIT_CHECK:
                    fTrans = IsDlgButtonChecked(hwnd, IDC_SPLIT_CHECK);
                    EnableWindow(GetDlgItem(hwnd, IDC_SPLIT_EDIT), fTrans);
                    EnableWindow(GetDlgItem(hwnd, IDC_SPLIT_SPIN), fTrans);

                    MarkPageDirty(hwnd, PAGE_ADV);
                    break;

                case IDC_SECURECONNECT_BUTTON:
                case IDC_USEDEFAULTS_BUTTON:
                    // Reset the settings on this page to the default values.
                    SetDlgItemInt(hwnd, IDC_NNTPPORT_EDIT, fSecure ? DEF_SNNTPPORT : DEF_NNTPPORT, FALSE);
                    EnableWindow(GetDlgItem(hwnd, IDC_USEDEFAULTS_BUTTON), FALSE);

                    MarkPageDirty(hwnd, PAGE_ADV);

                    SetFocus(GetDlgItem(hwnd, IDC_NNTPPORT_EDIT));
                    break;
                }
            return (TRUE);

        case WM_NOTIFY:
            pnmhdr = (NMHDR *)lParam;
            switch (pnmhdr->code)
                {
                case PSN_APPLY:
                    // BEGIN validation

                    dwPort = GetDlgItemInt(hwnd, IDC_NNTPPORT_EDIT, &fTrans, FALSE);
                    if (!fTrans || dwPort == 0)
                        {
                        hwndT = GetDlgItem(hwnd, IDC_NNTPPORT_EDIT);
                        return(InvalidAcctProp(hwnd, hwndT, idsErrPortNum, iddServerProp_Advanced));
                        }

                    dwSplit = 0;
                    dw = IsDlgButtonChecked(hwnd, IDC_SPLIT_CHECK);
                    if (dw != 0)
                        {
                        dwSplit = GetDlgItemInt(hwnd, IDC_SPLIT_EDIT, &fTrans, FALSE);
                        if (!fTrans || dwSplit < BREAKSIZE_MIN || dwSplit > BREAKSIZE_MAX)
                            {
                            hwndT = GetDlgItem(hwnd, IDC_SPLIT_EDIT);
                            return(InvalidAcctProp(hwnd, hwndT, idsEnterBreakSize, iddServerProp_Advanced));
                            }
                        }

                    // END validation

                    pAcct->SetPropDw(AP_NNTP_PORT, dwPort);

                    dw = IsDlgButtonChecked(hwnd, IDC_SPLIT_CHECK);
                    pAcct->SetPropDw(AP_NNTP_SPLIT_MESSAGES, dw);
                    if (dw != 0)
                        {
                        Assert(dwSplit != 0);
                        pAcct->SetPropDw(AP_NNTP_SPLIT_SIZE, dwSplit);
                        }

                    dw = GetTimeoutFromSlider(GetDlgItem(hwnd, IDC_TIMEOUT_SLIDER));
                    pAcct->SetPropDw(AP_NNTP_TIMEOUT, dw);

                    dw = IsDlgButtonChecked(hwnd, IDC_USEDESC_CHECK);
                    pAcct->SetPropDw(AP_NNTP_USE_DESCRIPTIONS, dw);

                    dw = IsDlgButtonChecked(hwnd, IDC_SECURECONNECT_BUTTON);
                    pAcct->SetPropDw(AP_NNTP_SSL, dw);

                    dw = POST_USE_DEFAULT;
                    if (IsDlgButtonChecked(hwnd, IDC_FORMAT_CHECK))
                        {
                        if (IsDlgButtonChecked(hwnd, IDC_HTML_RADIO))
                            dw = POST_USE_HTML;
                        else
                            dw = POST_USE_PLAIN_TEXT;
                        }
                    pAcct->SetPropDw(AP_NNTP_POST_FORMAT, dw);

                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    dw = PAGE_ADV;
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SAVECHANGES, (LPARAM)&dw);
                    if (dw == -1)
                        {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return(TRUE);
                        }
                    break;
                }
            return (TRUE);
        }

    return (FALSE);
    }

void InitUserInformation(HWND hwnd, IImnAccount *pAcct, BOOL fNews)
    {
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];
    IImnAccount *pAccount;
    DWORD dwProp;
    HWND hwndT;

    Assert(pAcct != NULL);

    pAccount = NULL;

    Assert(g_pAcctMan);
    g_pAcctMan->GetDefaultAccount(fNews ? ACCT_NEWS : ACCT_MAIL, &pAccount);

    // Get Display Name
    hwndT = GetDlgItem(hwnd, IDE_DISPLAY_NAME);
    SetIntlFont(hwndT);
    dwProp = fNews ? AP_NNTP_DISPLAY_NAME : AP_SMTP_DISPLAY_NAME;
    if (SUCCEEDED(pAcct->GetPropSz(dwProp, sz, ARRAYSIZE(sz))) ||
        (pAccount != NULL && SUCCEEDED(pAccount->GetPropSz(dwProp, sz, ARRAYSIZE(sz)))))
        {
        SetWindowText(hwndT, sz);
        }
    SendMessage(hwndT, EM_LIMITTEXT, CCHMAX_DISPLAY_NAME - 1, 0L);

    // Org Name
    InitAcctPropEdit(GetDlgItem(hwnd, IDE_ORG_NAME), pAcct,
        fNews ? AP_NNTP_ORG_NAME : AP_SMTP_ORG_NAME, CCHMAX_ORG_NAME - 1);

    // Sender Email
    hwndT = GetDlgItem(hwnd, IDE_EMAIL_ADDRESS);
    SetIntlFont(hwndT);
    dwProp = fNews ? AP_NNTP_EMAIL_ADDRESS : AP_SMTP_EMAIL_ADDRESS;
    if (SUCCEEDED(pAcct->GetPropSz(dwProp, sz, ARRAYSIZE(sz))) ||
        (pAccount != NULL && SUCCEEDED(pAccount->GetPropSz(dwProp, sz, ARRAYSIZE(sz)))))
        {
        SetWindowText(hwndT, sz);
        }
    SendMessage(hwndT, EM_LIMITTEXT, CCHMAX_EMAIL_ADDRESS - 1, 0L);

    // Sender Reply Address
    InitAcctPropEdit(GetDlgItem(hwnd, IDE_REPLYTO_EMAIL_ADDRESS), pAcct,
        fNews ? AP_NNTP_REPLY_EMAIL_ADDRESS : AP_SMTP_REPLY_EMAIL_ADDRESS, CCHMAX_EMAIL_ADDRESS - 1);

    if (pAccount != NULL)
        pAccount->Release();
    }

BOOL ValidateUserInformation(HWND hwnd, IImnAccount *pAcct, BOOL fNews, HWND *phwndErr, int *puIdsErr, BOOL fApply)
    {
    HRESULT hr;
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];
    DWORD cbSize;
    HWND hwndT;

    *phwndErr = NULL;
    *puIdsErr = 0;

    // Display Name
    hwndT = GetDlgItem(hwnd, IDE_DISPLAY_NAME);
    cbSize = GetWindowText(hwndT, sz, ARRAYSIZE(sz));
    UlStripWhitespace(sz, FALSE, TRUE, &cbSize);
    if (cbSize == 0)
        {
        *phwndErr = hwndT;
        *puIdsErr = idsEnterDisplayName;
        return(FALSE);
        }

    // Email Address
    hwndT = GetDlgItem(hwnd, IDE_EMAIL_ADDRESS);
    cbSize = GetWindowText(hwndT, sz, ARRAYSIZE(sz));
    UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
    if (cbSize == 0)
        {
        *phwndErr = hwndT;
        *puIdsErr = idsEnterEmailAddress;
        return(FALSE);
        }
    if (0 != SendMessage(hwndT, EM_GETMODIFY, 0, 0))
        {
        hr = pAcct->ValidateProperty(fNews ? AP_NNTP_EMAIL_ADDRESS : AP_SMTP_EMAIL_ADDRESS, (LPBYTE)sz, 0);
        if (hr != S_OK && fApply)
            {
            if (IDNO == AcctMessageBox(hwnd, MAKEINTRESOURCE(idsAccountManager), MAKEINTRESOURCE(idsInvalidEmailAddress), NULL, MB_YESNO|MB_ICONEXCLAMATION |MB_DEFBUTTON2))
                {
                *phwndErr = hwndT;
                return(FALSE);
                }
            }
        }

    // Reply Toaddress
    hwndT = GetDlgItem(hwnd, IDE_REPLYTO_EMAIL_ADDRESS);
    if (0 != SendMessage(hwndT, EM_GETMODIFY, 0, 0))
        {
        cbSize = GetWindowText(hwndT, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
        if (cbSize > 0)
            {
            hr = pAcct->ValidateProperty(fNews ? AP_NNTP_REPLY_EMAIL_ADDRESS : AP_SMTP_REPLY_EMAIL_ADDRESS, (LPBYTE)sz, 0);
            if (hr != S_OK && fApply)
                {
                if (IDNO == AcctMessageBox(hwnd, MAKEINTRESOURCE(idsAccountManager), MAKEINTRESOURCE(idsInvalidReplyToAddress), NULL, MB_YESNO|MB_ICONEXCLAMATION |MB_DEFBUTTON2))
                    {
                    *phwndErr = hwndT;
                    return(FALSE);
                    }
                }
            }
        }

    return(TRUE);
    }

void GetUserInformation(HWND hwnd, IImnAccount *pAcct, BOOL fNews)
    {
    DWORD cbSize;
    HWND hwndT;
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];

    // Display Name
    hwndT = GetDlgItem(hwnd, IDE_DISPLAY_NAME);
    if (0 != SendMessage(hwndT, EM_GETMODIFY, 0, 0))
        {
        cbSize = GetWindowText(hwndT, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, FALSE, TRUE, &cbSize);
        Assert(cbSize > 0);
        Assert(!FIsEmpty(sz));
        pAcct->SetPropSz(fNews ? AP_NNTP_DISPLAY_NAME : AP_SMTP_DISPLAY_NAME, sz);

        SendMessage(hwndT, EM_SETMODIFY, 0, 0);
        }

    // Organization
    hwndT = GetDlgItem(hwnd, IDE_ORG_NAME);
    if (0 != SendMessage(hwndT, EM_GETMODIFY, 0, 0))
        {
        cbSize = GetWindowText(hwndT, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, FALSE, TRUE, &cbSize);
        if (cbSize == 0)
            pAcct->SetProp(fNews ? AP_NNTP_ORG_NAME : AP_SMTP_ORG_NAME, NULL, 0);
        else
            pAcct->SetPropSz(fNews ? AP_NNTP_ORG_NAME : AP_SMTP_ORG_NAME, sz);

        SendMessage(hwndT, EM_SETMODIFY, 0, 0);
        }

    // Email Address
    hwndT = GetDlgItem(hwnd, IDE_EMAIL_ADDRESS);
    if (0 != SendMessage(hwndT, EM_GETMODIFY, 0, 0))
        {
        cbSize = GetWindowText(hwndT, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
        Assert(cbSize > 0);
        pAcct->SetPropSz(fNews ? AP_NNTP_EMAIL_ADDRESS : AP_SMTP_EMAIL_ADDRESS, sz);

        SendMessage(hwndT, EM_SETMODIFY, 0, 0);
        }

    // Reply Toaddress
    hwndT = GetDlgItem(hwnd, IDE_REPLYTO_EMAIL_ADDRESS);
    if (0 != SendMessage(hwndT, EM_GETMODIFY, 0, 0))
        {
        cbSize = GetWindowText(hwndT, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
        if (cbSize == 0)
            pAcct->SetProp(fNews ? AP_NNTP_REPLY_EMAIL_ADDRESS : AP_SMTP_REPLY_EMAIL_ADDRESS, NULL, 0);
        else
            pAcct->SetPropSz(fNews ? AP_NNTP_REPLY_EMAIL_ADDRESS : AP_SMTP_REPLY_EMAIL_ADDRESS, sz);

        SendMessage(hwndT, EM_SETMODIFY, 0, 0);
        }
    }

void EnableCertControls(HWND hwnd)
{
    EnableWindow(GetDlgItem(hwnd, idcCertButton), TRUE);
    EnableWindow(GetDlgItem(hwnd, idcCertEdit), TRUE);
    EnableWindow(GetDlgItem(hwnd, idcCryptEdit), TRUE);
    EnableWindow(GetDlgItem(hwnd, idcCryptButton), TRUE);
}

BOOL ValidateCertificate(HWND hwnd, IImnAccount *pAcct, SECPAGEINFO *psdi, HWND *phwndErr, int *puIdsErr)
{
    UINT    cbSize;
    BOOL    fRet = TRUE;
    TCHAR   sz[CCHMAX_ACCT_PROP_SZ];
    LPSTR   szCertEmail = NULL;
    
    *puIdsErr = 0;
    *phwndErr = NULL;
    cbSize = GetWindowTextLength(GetDlgItem(hwnd, idcCertEdit));
    if (cbSize)
    {
        GetDlgItemText(hwnd, idcCertAddress, sz, ARRAYSIZE(sz));
        Assert(psdi->pCert);
        szCertEmail = SzGetCertificateEmailAddress(psdi->pCert);
        if (!szCertEmail || lstrcmpi(szCertEmail, sz))
            goto ErrExit;
    }
    // More checkings for 2 keys
    
    if(!(psdi->pCert))
    {
        *puIdsErr = 0;
        return FALSE;
    }
    
    // Check that signing certificate is really signing certificate
    if(CheckKeyUsage(psdi->pCert, CERT_DIGITAL_SIGNATURE_KEY_USAGE) < 0)
        goto ErrExit;
    
    // Check email name in encryption certificate
    if(szCertEmail) 
    {
        MemFree(szCertEmail);
        szCertEmail = NULL;
    }
    
    if(psdi->pEncryptCert)
    {
        szCertEmail = SzGetCertificateEmailAddress(psdi->pEncryptCert);
        if (!szCertEmail || lstrcmpi(szCertEmail, sz))
            goto ErrExit;
        
        // Check that encryption certificate is really encryption certificate
        if(CheckKeyUsage(psdi->pEncryptCert, CERT_KEY_ENCIPHERMENT_KEY_USAGE) < 0)
        {
            if(CheckKeyUsage(psdi->pEncryptCert, CERT_KEY_AGREEMENT_KEY_USAGE) < 1)
                goto ErrExit;
        }
    }
    if(szCertEmail)
        MemFree(szCertEmail);
    return fRet;
ErrExit:
    // the certificate's email address does not match the
    // current choice for the account
    *puIdsErr = idsBadCertChoice;
    *phwndErr = GetDlgItem(hwnd, idcCertButton);
    if(szCertEmail)
        MemFree(szCertEmail);
    
    return FALSE;
}

void GetCertificate(HWND hwnd, IImnAccount *pAcct, SECPAGEINFO *psdi)
{
    THUMBBLOB tb = {0,0};
    
    if(psdi->pCert)
    {
        tb.pBlobData =(BYTE *)PVGetCertificateParam(psdi->pCert, CERT_HASH_PROP_ID, &tb.cbSize);
    }
    
    pAcct->SetProp(AP_SMTP_CERTIFICATE, tb.pBlobData, tb.cbSize);
    
    THUMBBLOB tbEncrypt = {0,0};
    if(psdi->pEncryptCert)
    {
        tbEncrypt.pBlobData =(BYTE *)PVGetCertificateParam(psdi->pEncryptCert, CERT_HASH_PROP_ID, &tbEncrypt.cbSize);
        AdvSec_GetEncryptAlgCombo(hwnd, pAcct);
    }
    pAcct->SetProp(AP_SMTP_ENCRYPT_CERT, tbEncrypt.pBlobData, tbEncrypt.cbSize);
    
    return;
}

/*  InitCertificateData:
**
**  Purpose:
**      determine if the account has a cert set on it and also initialize
**      the SVRDLGINFO.
**  Takes:
**      [in/out] psdi   - the hCertStore and pCert fields will be updated
**      [in] pAcct      - account to check for currently selected cert
**  Returns:
**      DWORD(-1)       - there was an error.  don't ever enable any UI
**      0               - no cert on the account, but no error
**      1               - cert set on account and placed in psdi->pCert
*/
DWORD InitCertificateData(TCHAR * szEmail, SECPAGEINFO *psdi, IImnAccount *pAcct)
{
    THUMBBLOB   tb;
    DWORD       dwRet = DWORD(-1);
    
    Assert(psdi && pAcct);
    
    if(!psdi->hCertStore)    
        psdi->hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
        X509_ASN_ENCODING, NULL, CERT_SYSTEM_STORE_CURRENT_USER, "My");
    if (psdi->hCertStore)
    {
        dwRet = 0;
        if (SUCCEEDED(pAcct->GetProp(AP_SMTP_CERTIFICATE, NULL, &tb.cbSize)))
        {
            if (MemAlloc((void**)&tb.pBlobData, tb.cbSize))
            {
                if (SUCCEEDED(pAcct->GetProp(AP_SMTP_CERTIFICATE, tb.pBlobData, &tb.cbSize)))
                {
                    psdi->pCert = CertFindCertificateInStore(
                        psdi->hCertStore,
                        X509_ASN_ENCODING,
                        0,
                        CERT_FIND_HASH,
                        (void *)(CRYPT_DIGEST_BLOB *)&tb,
                        NULL);
                    if (psdi->pCert)
                    {
                        // Double check, we must be sure that certificate is OK
                        ACCTFILTERINFO FilterInfo;

                        FilterInfo.fEncryption = FALSE;
                        FilterInfo.dwFlags = CRYPTDLG_REVOCATION_NONE; // No revocation checking
                        FilterInfo.szEmail = szEmail;

                        if(CertFilterFunction(psdi->pCert, (LPARAM)(&FilterInfo), 0, 0))
                        {
                            dwRet = 1;
                        }
                        else
                        {
                            CertFreeCertificateContext(psdi->pCert);
                            psdi->pCert = NULL;
                            // remove wrong certificate from property
                            pAcct->SetProp(AP_SMTP_CERTIFICATE, NULL, 0);
                        }

                    }
                }
            }
            MemFree(tb.pBlobData);
        }
        else if(psdi->pEncryptCert)
        {
            if(CheckKeyUsage(psdi->pEncryptCert, CERT_DIGITAL_SIGNATURE_KEY_USAGE) >= 0)
            {
             psdi->pCert = CertDuplicateCertificateContext(psdi->pEncryptCert);
             dwRet = 1;
            }

        }
    }
    return dwRet;
}

/*  InitEncryptData
**
**  Purpose:
**      determine if the account has a encryption cert set on it and also initialize
**      the SVRDLGINFO.
**  Takes:
**      [in/out] psdi   - the hCertStore and pCert fields will be updated
**      [in] pAcct      - account to check for currently selected cert
**  Returns:
**      DWORD(-1)       - there was an error.  don't ever enable any UI
**      0               - no cert on the account, but no error
**      1               - cert set on account and placed in psdi->pCert
*/
DWORD InitEncryptData(TCHAR *szEmail, SECPAGEINFO *psdi, IImnAccount *pAcct)
{
    THUMBBLOB   tb;
    DWORD       dwRet = DWORD(-1);
    DWORD   dwUsage = 0;
    
    if(!psdi->hCertStore)
        psdi->hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
            X509_ASN_ENCODING, NULL, CERT_SYSTEM_STORE_CURRENT_USER, "My");
    if (psdi->hCertStore)
    {
        dwRet = 0;
        if (SUCCEEDED(pAcct->GetProp(AP_SMTP_ENCRYPT_CERT, NULL, &tb.cbSize)))
        {
            if (MemAlloc((void**)&tb.pBlobData, tb.cbSize))
            {
                if (SUCCEEDED(pAcct->GetProp(AP_SMTP_ENCRYPT_CERT, tb.pBlobData, &tb.cbSize)))
                {
                    psdi->pEncryptCert = CertFindCertificateInStore(
                        psdi->hCertStore,
                        X509_ASN_ENCODING,
                        0,
                        CERT_FIND_HASH,
                        (void *)(CRYPT_DIGEST_BLOB *)&tb,
                        NULL);
                    if (psdi->pEncryptCert)
                    {
                        // Double check, we must be sure that certificate is OK
                        ACCTFILTERINFO FilterInfo;
                        FilterInfo.fEncryption = TRUE;
                        FilterInfo.dwFlags = CRYPTDLG_REVOCATION_NONE; // no revocation checking
                        FilterInfo.szEmail = szEmail;
                                                  
                        if(CertFilterFunction(psdi->pEncryptCert, (LPARAM)(&FilterInfo), 0, 0))
                        {
                            dwRet = 1;
                        }
                        else
                        {
                            CertFreeCertificateContext(psdi->pEncryptCert);
                            psdi->pEncryptCert = NULL;
                            // remove wrong certificate from property
                            pAcct->SetProp(AP_SMTP_ENCRYPT_CERT, NULL, 0);
                        }
                    }
                }
            }
            MemFree(tb.pBlobData);
        }
        // if encryption certificate was not set
        // check that current signing certificate can be used for encryption
        else if(psdi->pCert)
        {
            if((CheckKeyUsage(psdi->pCert, CERT_KEY_ENCIPHERMENT_KEY_USAGE) >= 0) ||
                    (CheckKeyUsage(psdi->pCert, CERT_KEY_AGREEMENT_KEY_USAGE) > 0))

            {
                psdi->pEncryptCert = CertDuplicateCertificateContext(psdi->pCert);
                dwRet = 1;
            }

        }
    }
    return dwRet;
    
}

// Check key usage field in certificate.
// Usage:
//  CheckKeyUsage(PCCERT_CONTEXT  pCert, DWORD dwFlag);
// where dwFlag is tested flaf of KeyUsage field
//
// Return 
//  1 - flag is set
//  0 - key usage field not found in certificate
//  -1 - flag is NOT set in key usage field.
int CheckKeyUsage(PCCERT_CONTEXT  pCert, DWORD dwFlag)
{
    DWORD dwUsage = 0;
    HRESULT hr = S_OK;

    hr = HrGetCertKeyUsage(pCert, &dwUsage);
    if(SUCCEEDED(hr))
    {
        if(dwUsage & dwFlag)
            return(1);
        else
            return(-1);
    }
    else   // Certificate doesn't have KeyUsage field (like VeriSign),
        return(0);        
}
BOOL DoCertDialog(HWND hwndOwner, HWND hwndEmail, PCCERT_CONTEXT *ppCert, HCERTSTORE hCertStore, int *puIdsErr, DWORD dwFlags, BOOL fEncription)
{
    TCHAR               szEmail[CCHMAX_ACCT_PROP_SZ];
    TCHAR               sz[CCHMAX_ACCT_PROP_SZ];
    DWORD               cchEmail;
    CERT_SELECT_STRUCT  css;
    PCCERT_CONTEXT      pCurCert;
    BOOL                fRet = FALSE;
    ACCTFILTERINFO      FilterInfo;

    *puIdsErr = 0;

    cchEmail = GetWindowText(hwndEmail, szEmail, ARRAYSIZE(szEmail));
    if (cchEmail)
        {
        memset(&css, 0, sizeof(css));

        pCurCert = CertDuplicateCertificateContext(*ppCert);

        LoadString(g_hInstRes, idsSelectCertTitle, sz, ARRAYSIZE(sz));

        css.dwSize = sizeof(css);
        css.hwndParent = hwndOwner;
        css.hInstance = g_hInstRes;
        css.szTitle = sz;
        css.dwFlags = dwFlags;
        // hack
        
        FilterInfo.fEncryption = fEncription;
        FilterInfo.dwFlags = dwFlags;
        FilterInfo.szEmail = szEmail;
        css.lCustData = (LPARAM)(&FilterInfo);
        css.arrayCertStore = &hCertStore;
        css.cCertStore = 1;
        css.szPurposeOid = szOID_PKIX_KP_EMAIL_PROTECTION;
        css.arrayCertContext = ppCert;
        css.cCertContext = 1;
#ifdef DEBUG
        if (GetAsyncKeyState(VK_SHIFT) & 0x8000)
            css.pfnFilter = NULL;
        else
            css.pfnFilter = CertFilterFunction;
#else
            css.pfnFilter = CertFilterFunction;
#endif

        if (CertSelectCertificate(&css) && (pCurCert != *ppCert))
            {
            fRet = TRUE;
            }
        CertFreeCertificateContext(pCurCert);
        }
    else
        *puIdsErr = idsNeedEmailForCert;

    return fRet;
}

#define FILETIME_SECOND    10000000     // 100ns intervals per second
#define TIME_DELTA_SECONDS 600          // 10 minutes in seconds

BOOL CertFilterFunction(PCCERT_CONTEXT pCertContext, LPARAM lParam, DWORD dwFlags, DWORD)
{
    // return TRUE to show, FALSE to hide
    BOOL fRet = FALSE;
    FILETIME FileTime;
    SYSTEMTIME SysTime;
    ACCTFILTERINFO * pFilterInfo = (ACCTFILTERINFO *) lParam;

    LONG    lRet = 0;

    PCCERT_CONTEXT *rgCertChain = NULL;
    DWORD           cCertChain = 0;
    const DWORD     dwIgnore = CERT_VALIDITY_NO_CRL_FOUND | CERT_VALIDITY_BEFORE_START |
                                CERT_VALIDITY_AFTER_END | CERT_VALIDITY_NO_TRUST_DATA;
    
    LPSTR szCertEmail = SzGetCertificateEmailAddress(pCertContext);
    
    GetSystemTime(&SysTime);
    if(SystemTimeToFileTime(&SysTime, &FileTime))
    {
        lRet = CertVerifyTimeValidity(&FileTime, pCertContext->pCertInfo);
        if(lRet < 0)
        {
            FILETIME ftNow;
            __int64  i64Offset;

            union 
            {
                 FILETIME ftDelta;
                __int64 i64Delta;
            };

            GetSystemTimeAsFileTime(&ftNow);

            i64Delta = ftNow.dwHighDateTime;
            i64Delta = i64Delta << 32;
            i64Delta += ftNow.dwLowDateTime;

            // Add the offset into the original time to get us a new time to check
            i64Offset = FILETIME_SECOND;
            i64Offset *= TIME_DELTA_SECONDS;
            i64Delta += i64Offset;

            lRet = CertVerifyTimeValidity(&ftDelta, pCertContext->pCertInfo);
        }
        if(lRet != 0)
            return FALSE;
    }
    
    
    if (szCertEmail)
    {
        fRet = !(BOOL(lstrcmpi(szCertEmail, pFilterInfo->szEmail)));
        
        MemFree(szCertEmail);
        if(!fRet)
            return(FALSE);
    }
    
    if(pFilterInfo->fEncryption)
    {
        if(CheckKeyUsage(pCertContext, CERT_KEY_ENCIPHERMENT_KEY_USAGE) < 0)
        {
            if(CheckKeyUsage(pCertContext, CERT_KEY_AGREEMENT_KEY_USAGE) < 1)
                return(FALSE);
        }
    }
    else {
        if(CheckKeyUsage(pCertContext, CERT_DIGITAL_SIGNATURE_KEY_USAGE) < 0)
            return(FALSE);
    }
    if(pFilterInfo->dwFlags)          // if flags != 0 check certificate
    {
        DWORD dwErr = DwGenerateTrustedChain(NULL, pFilterInfo->dwFlags, pCertContext, dwIgnore, TRUE, &cCertChain, &rgCertChain);
        
        if (rgCertChain) 
        {
            for (cCertChain--; int(cCertChain) >= 0; cCertChain--) 
                CertFreeCertificateContext(rgCertChain[cCertChain]);
            MemFree(rgCertChain);
        }
        
        if(dwErr != 0)
            return(FALSE);
    }
    
    return(fRet);
}

static const TCHAR c_szOpen[] = TEXT("open");
static const TCHAR c_szIexplore[] = TEXT("iexplore.exe");

const static HELPMAP g_rgCtxMapMailSec[] = 
{
    {idcCertCheck, IDH_GENERAL_USE_CERTIFICATE},
    {idcCertButton, IDH_GENERAL_SELECT_CERTIFICATE},
    {IDC_GETCERT, IDH_INETCOM_GET_DIGITAL_ID},
    {IDC_MOREINFO, IDH_INETCOM_MORE_ON_CERTIFICATES},
    {idcCertEdit, IDH_SECURITY_SIGNING_CERT},
    {idcCryptEdit, IDH_SECURITY_ENCRYPTING_CERT},
    {idcCryptButton, IDH_SECURITY_SELECT_ENCRYPTCERT},
    {IDC_ALGCOMBO, IDH_SECURITY_ADV_ENCRYPTION},
    {IDC_STATIC0, IDH_INETCOMM_GROUPBOX},
    {IDC_STATIC1, IDH_INETCOMM_GROUPBOX},
    {IDC_STATIC2, IDH_INETCOMM_GROUPBOX},
    {IDC_STATIC3, IDH_INETCOMM_GROUPBOX},
    {IDC_STATIC4, IDH_INETCOMM_GROUPBOX},
    {IDC_STATIC5, IDH_INETCOMM_GROUPBOX},
    {IDC_STATIC6, IDH_INETCOMM_GROUPBOX},
    {IDC_STATIC7, IDH_INETCOMM_GROUPBOX},
    {IDC_STATIC8, IDH_INETCOMM_GROUPBOX},
    {IDC_STATIC10, IDH_INETCOMM_GROUPBOX},
    {IDC_STATIC11, IDH_INETCOMM_GROUPBOX},
    {IDC_STATIC12, IDH_INETCOMM_GROUPBOX},
    {IDC_STATIC13, IDH_INETCOMM_GROUPBOX},

    {0, 0}
};

INT_PTR CALLBACK MailServer_SecurityDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR *pnmhdr;
    CAccount *pAcct;
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];
    DWORD dw;
    BOOL fRet;
    int idsError;
    HWND hwndT;
    SECPAGEINFO *pcpi;
    
    pAcct = (CAccount *)GetWindowLongPtr(hwnd, DWLP_USER);
    pcpi = (SECPAGEINFO *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Get the ServerParams and store them in our extra bytes
        pAcct = (CAccount *)((PROPSHEETPAGE *)lParam)->lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pAcct);
        
        Assert(pcpi == NULL);
        if (!MemAlloc((void **)&pcpi, sizeof(SECPAGEINFO)))
            return(-1);
        ZeroMemory(pcpi, sizeof(SECPAGEINFO));
        
        hwndT = GetDlgItem(hwnd, idcCertEdit);
        SetIntlFont(hwndT);
        
        PropSheet_QuerySiblings(GetParent(hwnd), MSM_GETEMAILADDRESS, (LPARAM)sz);
        SetDlgItemText(hwnd, idcCertAddress, sz);
        
        dw = InitCertificateData(sz, pcpi, pAcct);
        if (1 == dw)
        {
            Assert(pcpi->pCert);
            if (GetFriendlyNameOfCert(pcpi->pCert, sz, ARRAYSIZE(sz)))
                SendMessage(hwndT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)sz);
        }
        else if (-1 == dw)
        {
            EnableWindow(GetDlgItem(hwnd, idcCertCheck), FALSE);
        }
        
        GetDlgItemText(hwnd, idcCertAddress, sz, ARRAYSIZE(sz));
        
        dw = InitEncryptData(sz, pcpi, pAcct);
        if(dw == 1)
        {
            Assert(pcpi->pEncryptCert);
            hwndT = GetDlgItem(hwnd, idcCryptEdit);
            SetIntlFont(hwndT);
            if (GetFriendlyNameOfCert(pcpi->pEncryptCert, sz, ARRAYSIZE(sz)))
                SendMessage(hwndT, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)sz);
        }
        
        // Always fill this combo
        AdvSec_FillEncAlgCombo(hwnd, pAcct, (dw == 1) ? &pcpi->pEncryptCert : NULL );
        
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pcpi);
        
        EnableCertControls(hwnd);
        
        PropSheet_QuerySiblings(GetParent(hwnd), SM_INITIALIZED, PAGE_SEC);
        PropSheet_UnChanged(GetParent(hwnd), hwnd);
        return (TRUE);
        
    case WM_DESTROY:
        if (pcpi != NULL)
        {
            if (pcpi->pCert)
                CertFreeCertificateContext(pcpi->pCert);
            if (pcpi->pEncryptCert)
                CertFreeCertificateContext(pcpi->pEncryptCert);
            if (pcpi->hCertStore)
                CertCloseStore(pcpi->hCertStore, 0);
            MemFree(pcpi);
        }
        break;
        
    case PSM_QUERYSIBLINGS:
        if (wParam == MSM_GETCERTDATA)
        {
            if (IsDlgButtonChecked(hwnd, idcCertCheck))
            {
                ((SECPAGEINFO *)lParam)->pCert = pcpi->pCert;
                ((SECPAGEINFO *)lParam)->hCertStore = pcpi->hCertStore;
            }
            return(TRUE);
        }
        break;
        
    case WM_HELP:
    case WM_CONTEXTMENU:
        return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapMailSec));
        
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDC_ALGCOMBO:
            if(GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELENDOK)
                MarkPageDirty(hwnd, PAGE_SEC);
            break;

        case idcCertCheck:
            EnableCertControls(hwnd);
            
            MarkPageDirty(hwnd, PAGE_SEC);
            break;
                        
        case idcCertButton:
            hwndT = GetDlgItem(hwnd, idcCertAddress);
            if (DoCertDialog(hwnd, hwndT, &pcpi->pCert, pcpi->hCertStore, &idsError, 
                ((pAcct->m_dwDlgFlags & ACCTDLG_REVOCATION) ? CRYPTDLG_REVOCATION_ONLINE : CRYPTDLG_REVOCATION_NONE), FALSE))
            {
                if (GetFriendlyNameOfCert(pcpi->pCert, sz, ARRAYSIZE(sz)))
                    SetDlgItemText(hwnd, idcCertEdit, sz);
                MarkPageDirty(hwnd, PAGE_SEC);
            }
            else if (idsError)
                InvalidAcctProp(hwnd, hwndT, idsError, iddMailSvrProp_Security);
            break;
            
        case idcCryptButton:
            hwndT = GetDlgItem(hwnd, idcCertAddress);
            if (DoCertDialog(hwnd, hwndT, &pcpi->pEncryptCert, pcpi->hCertStore, &idsError, 
                ((pAcct->m_dwDlgFlags & ACCTDLG_REVOCATION) ? CRYPTDLG_REVOCATION_ONLINE : CRYPTDLG_REVOCATION_NONE), TRUE))
            {
                if (GetFriendlyNameOfCert(pcpi->pEncryptCert, sz, ARRAYSIZE(sz)))
                    SetDlgItemText(hwnd, idcCryptEdit, sz);
                MarkPageDirty(hwnd, PAGE_SEC);
            }
            else if (idsError)
                InvalidAcctProp(hwnd, hwndT, idsError, iddMailSvrProp_Security);
            
            EnableCertControls(hwnd);
            
            break;
            
        case IDC_GETCERT:
            GetDigitalID(hwnd);
            break;
            
        case IDC_MOREINFO:
            OEHtmlHelp(hwnd, "%SYSTEMROOT%\\help\\msoe.chm>large_context", HH_DISPLAY_TOPIC, (ULONG_PTR) (LPCSTR) "mail_overview_send_secure_messages.htm");
            break;
        }
        break;
        
    case WM_NOTIFY:
        pnmhdr = (NMHDR *)lParam;
        switch (pnmhdr->code)
        {
        case PSN_SETACTIVE:
            PropSheet_QuerySiblings(GetParent(hwnd), MSM_GETEMAILADDRESS, (LPARAM)sz);
            SetDlgItemText(hwnd, idcCertAddress, sz);
            break;
                
        case PSN_APPLY:
            // BEGIN validation
                
#ifdef DEBUG
            if (!(GetAsyncKeyState(VK_SHIFT) & 0x8000))
            {
#endif
            fRet = ValidateCertificate(hwnd, pAcct, pcpi, &hwndT, &idsError);
            if (!fRet)
            {
                if(idsError != 0)
                    return(InvalidAcctProp(hwnd, hwndT, idsError, iddMailSvrProp_Security));
                else
                    return FALSE;
            }
#ifdef DEBUG
            }
#endif
                
            // END validation
                
            GetCertificate(hwnd, pAcct, pcpi);
                
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            dw = PAGE_SEC;
            PropSheet_QuerySiblings(GetParent(hwnd), SM_SAVECHANGES, (LPARAM)&dw);
            if (dw == -1)
            {
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                return(TRUE);
            }
            break;
        }
        return(TRUE);
    }
        
    return (FALSE);
}

INT_PTR CALLBACK CertAddressErrorDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
    HICON hicon;
    BOOL fRet = TRUE;

    switch (msg)
        {
        case WM_INITDIALOG:
            hicon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_EXCLAMATION));
            if (hicon != NULL)
                SendDlgItemMessage(hwnd, IDC_ERR_STATIC, STM_SETICON, (WPARAM)hicon, 0);
            MessageBeep(MB_ICONEXCLAMATION);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
                EndDialog(hwnd, LOWORD(wParam));
            break;

        default:
            fRet = FALSE;
            break;
        }

    return(fRet);
    }

const static HELPMAP g_rgCtxMapMailGen[] = {
                       {IDC_SERVERNAME_EDIT, IDH_MAIL_ACCOUNT},
                       {IDE_DISPLAY_NAME, IDH_NEWS_SERV_NAME},
                       {IDE_ORG_NAME, IDH_NEWS_SERV_ORG},
                       {IDE_EMAIL_ADDRESS, IDH_NEWS_SERV_EMAIL_ADD},
                       {IDE_REPLYTO_EMAIL_ADDRESS, IDH_MAIL_SERV_ADV_REPLY_TO},
                       {IDC_RECVFULL_INCLUDE, IDH_INCLUDEACCT_IN_SENDREC},
                       {IDC_STATIC0, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC1, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC2, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC3, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC4, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC5, IDH_INETCOMM_GROUPBOX},
                       {0, 0}};

INT_PTR CALLBACK MailServer_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                         LPARAM lParam)
    {
    NMHDR *pnmhdr;
    CAccount *pAcct;
    TCHAR *pszEmail, sz[CCHMAX_ACCT_PROP_SZ];
    DWORD dw;
	BOOL fRet, fFree, fError;
    SVRDLGINFO *psdi;
    SECPAGEINFO cpi;
    INT idsError;
    HWND hwndT;

    pAcct = (CAccount *)GetWindowLongPtr(hwnd, DWLP_USER);
    psdi = (SVRDLGINFO *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get the ServerParams and store them in our extra bytes
            pAcct = (CAccount *)((PROPSHEETPAGE *)lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pAcct);

            Assert(psdi == NULL);
            if (!MemAlloc((void **)&psdi, sizeof(SVRDLGINFO)))
                return(-1);
            ZeroMemory(psdi, sizeof(SVRDLGINFO));

            // figure out if we're a mail or imap account
            psdi->sfType = SERVER_MAIL;   // mail will be default for now...
            if (SUCCEEDED(pAcct->GetServerTypes(&dw)))
            {
                if (!!(dw & SRV_IMAP))
                    psdi->sfType = SERVER_IMAP;
                else if (!!(dw & SRV_HTTPMAIL))
                    psdi->sfType = SERVER_HTTPMAIL;
            }

            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)psdi);

            InitUserInformation(hwnd, pAcct, FALSE);

            // Set Account Name
            InitAcctPropEdit(GetDlgItem(hwnd, IDC_SERVERNAME_EDIT), pAcct, AP_ACCOUNT_NAME, CCHMAX_ACCOUNT_NAME - 1);
            
            // if the account is an msn-related http account, swap in the msn icon
            if (SERVER_HTTPMAIL == psdi->sfType)
            {
                DWORD   dwMsnDomain = 0;
                if (SUCCEEDED(pAcct->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dwMsnDomain)) && dwMsnDomain)
                {
                    HICON hicon = LoadIcon(g_hInstRes, MAKEINTRESOURCE(idiMsnServer));
                    if (NULL != hicon)
                        SendDlgItemMessage(hwnd, IDC_MAILSERVER_ICON, STM_SETICON, (WPARAM)hicon, 0);
                }
            }

            // POP3 Skip Account/IMAP Poll Unread
            if (SERVER_IMAP == psdi->sfType)
                {
                int iIMAPStringRes;

                if (pAcct->m_dwDlgFlags & ACCTDLG_NO_IMAPPOLL)
                    iIMAPStringRes = idsIMAPPollInbox;
                else
                    iIMAPStringRes = idsIMAPPollForUnread;

                /*
                // Replace default POP3 text with text that better suits IMAP
                LoadString(g_hInstRes, iIMAPStringRes, sz, sizeof(sz));
                SetWindowText(GetDlgItem(hwnd, IDC_RECVFULL_INCLUDE), sz);
                */
                
                // Load current setting and set checkbox to indicate it
                if (FAILED(pAcct->GetPropDw(AP_IMAP_POLL, &dw)))
                    dw = FALSE; // By default, we don't poll for IMAP

                CheckDlgButton(hwnd, IDC_RECVFULL_INCLUDE, dw ? BST_CHECKED : BST_UNCHECKED);
                } // if
            else if (SERVER_HTTPMAIL == psdi->sfType)
                {
                    dw = FALSE;
                    pAcct->GetPropDw(AP_HTTPMAIL_POLL, &dw);
                    CheckDlgButton(hwnd, IDC_RECVFULL_INCLUDE, dw ? BST_CHECKED : BST_UNCHECKED);
                }
            else
                {
                if (!!(pAcct->m_dwDlgFlags & ACCTDLG_NO_SENDRECEIVE))
                    ShowWindow(GetDlgItem(hwnd, IDC_RECVFULL_INCLUDE), SW_HIDE);
                else
                    {
                    if (SUCCEEDED(pAcct->GetPropDw(AP_POP3_SKIP, &dw)))
                        CheckDlgButton(hwnd, IDC_RECVFULL_INCLUDE, dw ? BST_UNCHECKED : BST_CHECKED);
                    else
                        CheckDlgButton(hwnd, IDC_RECVFULL_INCLUDE, BST_CHECKED);
                    } // else
                } // else

            psdi->dwInit = (psdi->dwInit | PAGE_GEN);
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            return (TRUE);

        case WM_DESTROY:
            if (psdi != NULL)
                MemFree(psdi);
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:
            return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapMailGen));

        case PSM_QUERYSIBLINGS:
            Assert(psdi != NULL);
            Assert(pAcct != NULL);
            return(HandleQuerySiblings(hwnd, psdi, pAcct, wParam, lParam));

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
                {
                case IDC_RECVFULL_INCLUDE:
                    MarkPageDirty(hwnd, PAGE_GEN);
                    break;

                default:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                        {
                        if (LOWORD(wParam) == IDC_SERVERNAME_EDIT)
                            UpdateAcctTitle(hwnd, IDC_SERVERNAME_EDIT, ACCT_MAIL);
                        MarkPageDirty(hwnd, PAGE_GEN);
                        }
                    break;
                }
            break;

        case WM_NOTIFY:
            pnmhdr = (NMHDR *)lParam;
            switch (pnmhdr->code)
                {
                case PSN_APPLY:
                    // BEGIN validation
                    if (psdi->fNoValidate)
                        {
                        Assert(pnmhdr->code == PSN_KILLACTIVE);
                        break;
                        }

#ifdef DEBUG
                    if (!(GetAsyncKeyState(VK_SHIFT) & 0x8000))
                        {
#endif
                    hwndT = GetDlgItem(hwnd, IDC_SERVERNAME_EDIT);
                    if (!ValidateAccountName(hwnd, hwndT, pAcct, &idsError))
                        return(InvalidAcctProp(hwnd, hwndT, idsError, iddMailSvrProp_General));

                    fRet = ValidateUserInformation(hwnd, pAcct, FALSE, &hwndT, &idsError, pnmhdr->code == PSN_APPLY);
                    if (!fRet)
                        return(InvalidAcctProp(hwnd, hwndT, idsError, iddMailSvrProp_General));

                    if (0 == (pAcct->m_dwDlgFlags & ACCTDLG_NO_SECURITY))
                        {
                        fError = FALSE;
                        ZeroMemory(&cpi, sizeof(SECPAGEINFO));
                        hwndT = GetDlgItem(hwnd, IDE_EMAIL_ADDRESS);
                        GetWindowText(hwndT, sz, ARRAYSIZE(sz));
                        if (!!(psdi->dwInit & PAGE_SEC))
                            {
                            // the security page exists, so ask it for the cert info
                            PropSheet_QuerySiblings(GetParent(hwnd), MSM_GETCERTDATA, (LPARAM)&cpi);
                            fFree = FALSE;
                            }
                        else
                            {
                            // the security page hasn't been initialized yet,
                            // so we need to get this info from the acct
                            dw = InitCertificateData(sz, &cpi, pAcct);
                            Assert((dw != 1) ^ (cpi.pCert != NULL));
                            fFree = TRUE;
                            InitEncryptData(sz, &cpi, pAcct);
                            }

                        if (cpi.pCert != NULL)
                            {
                            pszEmail = SzGetCertificateEmailAddress(cpi.pCert);
                            if (lstrcmpi(pszEmail, sz) != 0)
                                {
                                idsError = (INT) DialogBox(g_hInstRes, MAKEINTRESOURCE(iddCertAddressError),
                                                    hwnd, CertAddressErrorDlgProc);
                                switch (idsError)
                                    {
                                    case IDCANCEL:
                                        SendMessage(hwndT, EM_SETSEL, 0, -1);
                                        SetFocus(hwndT);
                                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                        fError = TRUE;
                                        break;

                                    case IDC_CHANGE_ADDR:
                                        SetWindowText(hwndT, pszEmail);
                                        SendMessage(hwndT, EM_SETMODIFY, TRUE, 0);
                                        break;

                                    case IDC_NEW_CERT:
                                        psdi->fNoValidate = TRUE;
                                        SendMessage(GetParent(hwnd), PSM_SETCURSELID, 0, (LPARAM)iddMailSvrProp_Security);
                                        psdi->fNoValidate = FALSE;

                                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                        fError = TRUE;
                                        break;
                                    }
                                }
                                if(pszEmail)
                                    MemFree(pszEmail);
                            }

                        if (cpi.pCert != NULL && fFree)
                            CertFreeCertificateContext(cpi.pCert);
                        if (cpi.pEncryptCert != NULL && fFree)
                            CertFreeCertificateContext(cpi.pEncryptCert);
                        if (cpi.hCertStore != NULL && fFree)
                            CertCloseStore(cpi.hCertStore, 0);

                        if (fError)
                            return(TRUE);
                        }
#ifdef DEBUG
                        }
#endif

                    // END validation

                    hwndT = GetDlgItem(hwnd, IDC_SERVERNAME_EDIT);
                    GetAccountName(hwndT, pAcct);

                    GetUserInformation(hwnd, pAcct, FALSE);

                    // Skip During Send and Receive (POP) --OR--
                    // Poll for Unread Count (IMAP)
                    if (SERVER_IMAP == psdi->sfType)
                        pAcct->SetPropDw(AP_IMAP_POLL, (DWORD) IsDlgButtonChecked (hwnd, IDC_RECVFULL_INCLUDE));
                    else if (SERVER_HTTPMAIL == psdi->sfType)
                        pAcct->SetPropDw(AP_HTTPMAIL_POLL, (DWORD) IsDlgButtonChecked (hwnd, IDC_RECVFULL_INCLUDE));
                    else
                        pAcct->SetPropDw(AP_POP3_SKIP, (DWORD)!IsDlgButtonChecked(hwnd, IDC_RECVFULL_INCLUDE));

                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    dw = PAGE_GEN;
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SAVECHANGES, (LPARAM)&dw);
                    if (dw == -1)
                        {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return(TRUE);
                        }
                    break;
                }
            return(TRUE);
        }

    return (FALSE);
    }

const static HELPMAP g_rgCtxMapMailSvr[] = {
                       {IDC_SMTP_EDIT, IDH_MAIL_SERV_OUTGOING},
                       {IDC_POP3_EDIT, IDH_MAIL_SERV_INCOMING},
                       {IDC_IN_MAIL_STATIC, IDH_MAIL_SERV_INCOMING},
                       {idcPOP_OR_IMAP, IDH_INETCOMM_MY_INCOMING_SERVER_IS},
                       {IDC_SERVER_STATIC, IDH_INETCOMM_MY_INCOMING_SERVER_IS},
                       {IDC_SERVER1_STATIC, IDH_INETCOMM_MY_INCOMING_SERVER_IS},
                       {IDC_LOGON_CHECK, IDH_INETCOMM_SERVER_REQ_LOGON},
                       {IDC_ACCTNAME_EDIT, IDH_MAIL_SERV_POP3_ACCT},
                       {IDC_ACCTNAME_STATIC, IDH_MAIL_SERV_POP3_ACCT},
                       {IDC_ACCTPASS_EDIT, IDH_MAIL_SERV_PWORD},
                       {IDC_ACCTPASS_STATIC, IDH_MAIL_SERV_PWORD},
                       {IDC_LOGONSSPI_CHECK, IDH_MAIL_LOGON_USING_SICILY},
                       {IDC_SMTP_SASL, IDH_MAIL_OUT_AUTH},
                       {IDC_SMTPLOGON, IDH_MAIL_OUT_SETTINGS},
                       {IDC_REMEMBER_PASSWORD, 503},
                       {IDC_STATIC0, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC1, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC2, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC3, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC4, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC5, IDH_INETCOMM_GROUPBOX},
                       {0, 0}};

INT_PTR CALLBACK MailServer_ServersDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                         LPARAM lParam)
    {
    static SMTPAUTHINFO     s_rAuth;
    int                     idsError;
    HWND                    hwndT;
    ULONG                   cbSize;
    NMHDR                   *pnmhdr;
    TCHAR                   sz[CCHMAX_ACCT_PROP_SZ];
    DWORD                   dw, dwPromptForPassword;
    BOOL                    fEnable, fIMAP, fHTTPMail;
    SERVER_TYPE sfType,     sfTypeT;
    LPMAILSERVERPROPSINFO   pProps = NULL;
    CAccount                *pAcct = (CAccount *)GetWindowLongPtr(hwnd, DWLP_USER);
    TCHAR                   szPreviousLoginName[CCHMAX_ACCT_PROP_SZ];

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get the ServerParams and store them in our extra bytes
            pAcct = (CAccount *)((PROPSHEETPAGE *)lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pAcct);

            // figure out what kind of server we are
            PropSheet_QuerySiblings(GetParent(hwnd), MSM_GETSERVERTYPE, (LPARAM)&sfType);

            GetServerProps(sfType, &pProps);
            Assert(pProps);

            fIMAP = (sfType == SERVER_IMAP);
            fHTTPMail = (SERVER_HTTPMAIL == sfType);
            
            // Init
            ZeroMemory(&s_rAuth, sizeof(SMTPAUTHINFO));

            if (!fHTTPMail)
            {
                // Smtp Auth Type
                Assert(sizeof(s_rAuth.authtype) == sizeof(DWORD));
                if (FAILED(pAcct->GetPropDw(AP_SMTP_USE_SICILY, (LPDWORD)&s_rAuth.authtype)))
                    s_rAuth.authtype = SMTP_AUTH_NONE;

                // If smtp auth...
                if (SMTP_AUTH_NONE != s_rAuth.authtype)
                    {
                    // Check the button
                    CheckDlgButton(hwnd, IDC_SMTP_SASL, BST_CHECKED);

                    if (SUCCEEDED(pAcct->GetPropSz(AP_SMTP_USERNAME, sz, ARRAYSIZE(sz))))
                        StrCpyN(s_rAuth.szUserName, sz, ARRAYSIZE(s_rAuth.szUserName));

                    if (SUCCEEDED(pAcct->GetPropDw(AP_SMTP_PROMPT_PASSWORD, &dw)))
                        s_rAuth.fPromptPassword = dw;

                    if (SUCCEEDED(pAcct->GetPropSz(AP_SMTP_PASSWORD, sz, ARRAYSIZE(sz))))
                        StrCpyN(s_rAuth.szPassword, sz, ARRAYSIZE(s_rAuth.szPassword));
                    }
                else
                    EnableWindow(GetDlgItem(hwnd, IDC_SMTPLOGON), FALSE);
            }

            if (!!(pAcct->m_dwDlgFlags & ACCTDLG_NO_IMAP) && !fIMAP)
                {
                ShowWindow(GetDlgItem(hwnd, idcPOP_OR_IMAP), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_SERVER_STATIC), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_SERVER1_STATIC), SW_HIDE);
                }

            if (!fHTTPMail)
            {
                LoadString(g_hInstRes, fIMAP ? idsIMAP : idsPOP, sz, ARRAYSIZE(sz));
                SetDlgItemText(hwnd, idcPOP_OR_IMAP, sz);
            }

            // Set incoming Server
            InitAcctPropEdit(GetDlgItem(hwnd, IDC_POP3_EDIT), pAcct, pProps->server, CCHMAX_SERVER_NAME - 1);
            
            if (!fHTTPMail)
            {
                if (fIMAP)
                    LoadString(g_hInstRes, idsIncomingMailIMAP, sz, ARRAYSIZE(sz));
                else
                    LoadString(g_hInstRes, idsIncomingMailPOP, sz, ARRAYSIZE(sz));
                SetWindowText(GetDlgItem(hwnd, IDC_IN_MAIL_STATIC), sz);
            }

            if (!fHTTPMail)
            {
                // Set Smtp Server
                InitAcctPropEdit(GetDlgItem(hwnd, IDC_SMTP_EDIT), pAcct, AP_SMTP_SERVER, CCHMAX_SERVER_NAME - 1);
            }

            if (!fHTTPMail)
            {
                // If Saving password
                if (SUCCEEDED(pAcct->GetPropDw(pProps->useSicily, &dw)) && dw)
                    CheckDlgButton(hwnd, IDC_LOGONSSPI_CHECK, BST_CHECKED);
            }

            if (SUCCEEDED(pAcct->GetPropSz(pProps->userName, sz, ARRAYSIZE(sz))))
                SetDlgItemText(hwnd, IDC_ACCTNAME_EDIT, sz);
            if (SUCCEEDED(pAcct->GetPropSz(pProps->password, sz, ARRAYSIZE(sz))))
                SetDlgItemText(hwnd, IDC_ACCTPASS_EDIT, sz);

            if (FAILED(pAcct->GetPropDw(pProps->promptPassword, &dwPromptForPassword)))
                dwPromptForPassword = 0;
            CheckDlgButton(hwnd, IDC_REMEMBER_PASSWORD, dwPromptForPassword ? BST_UNCHECKED : BST_CHECKED);

            // Enable/Disable account windows
            Server_EnableLogonWindows(hwnd, TRUE);

            hwndT = GetDlgItem(hwnd, IDC_ACCTNAME_EDIT);
            SetIntlFont(hwndT);
            SendMessage(hwndT, EM_LIMITTEXT, CCHMAX_USERNAME - 1, 0L);

            if (fHTTPMail)
            {
                GetWindowText(hwndT, szPreviousLoginName, CCHMAX_ACCT_PROP_SZ);
            }

            SendDlgItemMessage(hwnd, IDC_ACCTPASS_EDIT, EM_LIMITTEXT, CCHMAX_PASSWORD - 1, 0L);

            if (SUCCEEDED(pAcct->GetPropDw(AP_SERVER_READ_ONLY, &dw)) && dw)
            {
                EnableWindow(GetDlgItem(hwnd, IDC_POP3_EDIT), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_SMTP_EDIT), FALSE);
            }

            PropSheet_QuerySiblings(GetParent(hwnd), SM_INITIALIZED, PAGE_SERVER);
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            return (TRUE);

        case WM_HELP:
        case WM_CONTEXTMENU:
            return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapMailSvr));

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
                {
                case IDC_LOGONSSPI_CHECK:
                    Server_EnableLogonWindows(hwnd, TRUE);
                    MarkPageDirty(hwnd, PAGE_SERVER);
                    break;

                case IDC_REMEMBER_PASSWORD:
                    fEnable = IsDlgButtonChecked(hwnd, IDC_REMEMBER_PASSWORD);
                    EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_EDIT), fEnable);
                    MarkPageDirty(hwnd, PAGE_SERVER);
                    break;

                case IDC_SMTP_SASL:
                    MarkPageDirty(hwnd, PAGE_SERVER);
                    EnableWindow(GetDlgItem(hwnd, IDC_SMTPLOGON), IsDlgButtonChecked(hwnd, IDC_SMTP_SASL));
                    if (!IsDlgButtonChecked(hwnd, IDC_SMTP_SASL) && SMTP_AUTH_NONE != s_rAuth.authtype)
                    {
                        s_rAuth.authtype = SMTP_AUTH_NONE;
                        s_rAuth.fDirty = TRUE;
                    }
                    else if (IsDlgButtonChecked(hwnd, IDC_SMTP_SASL) && SMTP_AUTH_NONE == s_rAuth.authtype)
                    {
                        s_rAuth.authtype = SMTP_AUTH_USE_POP3ORIMAP_SETTINGS;
                        s_rAuth.fDirty = TRUE;
                    }
                    break;

                case IDC_SMTPLOGON:
                    if (IDOK == DialogBoxParam(g_hInstRes, MAKEINTRESOURCE(iddSmtpServerLogon), hwnd, SmtpLogonSettingsDlgProc, (LPARAM)&s_rAuth))
                        MarkPageDirty(hwnd, PAGE_SERVER);
                    break;

                default:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                        MarkPageDirty(hwnd, PAGE_SERVER);
                    break;
                }
            break;

        case WM_NOTIFY:
            pnmhdr = (NMHDR *)lParam;
            switch (pnmhdr->code)
                {
                case PSN_APPLY:
                    // BEGIN validation
                    PropSheet_QuerySiblings(GetParent(hwnd), MSM_GETSERVERTYPE, (LPARAM)&sfType);
                    GetServerProps(sfType, &pProps);
                    Assert(pProps);
                    
                    fHTTPMail = (SERVER_HTTPMAIL == sfType);

                    if (!fHTTPMail)
                    {
                        hwndT = GetDlgItem(hwnd, IDC_SMTP_EDIT);
                        if (!ValidateServerName(hwnd, hwndT, pAcct, AP_SMTP_SERVER, &idsError, pnmhdr->code == PSN_APPLY))
                            return(InvalidAcctProp(hwnd, hwndT, idsError, iddMailSvrProp_Servers));
                    }

                    // gregfrie review (handle httpmail)
                    hwndT = GetDlgItem(hwnd, IDC_POP3_EDIT);
                    if (!ValidateServerName(hwnd, hwndT, pAcct,
                            pProps->server, &idsError, pnmhdr->code == PSN_APPLY))
                        return(InvalidAcctProp(hwnd, hwndT, idsError, iddMailSvrProp_Servers));

                    if (!ValidateLogonSettings(hwnd, pAcct->m_dwDlgFlags, &hwndT, &idsError))
                        return(InvalidAcctProp(hwnd, hwndT, idsError, iddMailSvrProp_Servers));
                    
                    if (fHTTPMail && !fWarnDomainName(hwnd, pAcct->m_dwDlgFlags, szPreviousLoginName)) 
                    {
                        //return (PSNRET_INVALID_NOCHANGEPAGE);                        
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return(TRUE);

                    }

                    // END validation
                    
                    if (!fHTTPMail)
                    {
                        // Save SMTP Auth Info
                        if (s_rAuth.fDirty)
                        {
                            // Save Authentication Type
                            pAcct->SetPropDw(AP_SMTP_USE_SICILY, s_rAuth.authtype);

                            // Clear user name and password
                            pAcct->SetProp(AP_SMTP_PROMPT_PASSWORD, NULL, 0);
                            pAcct->SetProp(AP_SMTP_PASSWORD, NULL, 0);

                            Assert(SMTP_AUTH_USE_SMTP_SETTINGS == s_rAuth.authtype ? !FIsEmptyA(s_rAuth.szUserName) : TRUE);
                            pAcct->SetPropSz(AP_SMTP_USERNAME, s_rAuth.szUserName);

                            pAcct->SetPropDw(AP_SMTP_PROMPT_PASSWORD, s_rAuth.fPromptPassword);
                            if (FALSE == s_rAuth.fPromptPassword)
                                pAcct->SetPropSz(AP_SMTP_PASSWORD, s_rAuth.szPassword);
                        }
                    }

                    if (!fHTTPMail)
                    {
                        hwndT = GetDlgItem(hwnd, IDC_SMTP_EDIT);
                        GetServerName(hwndT, pAcct, AP_SMTP_SERVER);
                    }
    
                    hwndT = GetDlgItem(hwnd, IDC_POP3_EDIT);
                    GetServerName(hwndT, pAcct, pProps->server);
                    
                    // gregfrie review (httpmail)
                    GetLogonSettings(hwnd, pAcct, TRUE,
                        (sfType == SERVER_IMAP) ? SRV_IMAP : (sfType == SERVER_HTTPMAIL) ? SRV_HTTPMAIL : SRV_POP3);

                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    dw = PAGE_SERVER;
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SAVECHANGES, (LPARAM)&dw);
                    if (dw == -1)
                        {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return(TRUE);
                        }
                    break;
                }
            return(TRUE);
        }

    return (FALSE);
    }

void UpdateIncomingMailControls(HWND hwnd, SERVER_TYPE sfType, DWORD dwDlgFlags)
    {
    TCHAR sz[CCHMAX_STRINGRES];
    int sw;
    BOOL fIMAP;

    Assert(sfType == SERVER_MAIL || sfType == SERVER_IMAP);
    fIMAP = sfType == SERVER_IMAP;

    LoadString(g_hInstRes, fIMAP ? idsIncomingMailIMAP : idsIncomingMailPOP, sz, ARRAYSIZE(sz));
    SetWindowText(GetDlgItem(hwnd, IDC_IN_MAIL_STATIC), sz);

    if (fIMAP)
        {
        ShowWindow(GetDlgItem(hwnd, IDC_STATIC6), SW_HIDE); // "Delivery" text
        ShowWindow(GetDlgItem(hwnd, IDC_STATIC7), SW_HIDE); // Horizontal line
        }
    else
        {
        LoadString(g_hInstRes, idsDelivery, sz, ARRAYSIZE(sz));
        SetWindowText(GetDlgItem(hwnd, IDC_STATIC6), sz);
        }

    ShowWindow(GetDlgItem(hwnd, IDC_LEAVE_CHECK), fIMAP ? SW_HIDE : SW_SHOW);

    sw = (fIMAP || !!(dwDlgFlags & ACCTDLG_NO_REMOVEAFTER)) ? SW_HIDE : SW_SHOW;
    ShowWindow(GetDlgItem(hwnd, IDC_REMOVE_CHECK), sw);
    ShowWindow(GetDlgItem(hwnd, IDC_REMOVE_EDIT), sw);
    ShowWindow(GetDlgItem(hwnd, IDC_REMOVE_SPIN), sw);
    ShowWindow(GetDlgItem(hwnd, IDC_OPIE), sw);

    ShowWindow(GetDlgItem(hwnd, IDC_REMOVEDELETE_CHECK), (fIMAP || !!(dwDlgFlags & ACCTDLG_NO_REMOVEDELETE)) ? SW_HIDE : SW_SHOW);
    }

void EnableDeliveryControls(HWND hwnd)
    {
    BOOL fEnable;

    fEnable = IsDlgButtonChecked(hwnd, IDC_LEAVE_CHECK);

    EnableWindow(GetDlgItem(hwnd, IDC_OPIE), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_REMOVEDELETE_CHECK), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_REMOVE_CHECK), fEnable);

    if (fEnable)
        fEnable = IsDlgButtonChecked(hwnd, IDC_REMOVE_CHECK);
    EnableWindow(GetDlgItem(hwnd, IDC_REMOVE_EDIT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_REMOVE_SPIN), fEnable);
    }

void EnableUseDefaultButton(HWND hwnd, SERVER_TYPE sfType)
    {
    BOOL fSecure, fTrans, fEnable;
    DWORD dw;

    Assert(sfType == SERVER_MAIL || sfType == SERVER_IMAP);

    fSecure = IsDlgButtonChecked(hwnd, IDC_SECURECONNECT_SMTP_BUTTON);
    dw = GetDlgItemInt(hwnd, IDC_SMTP_PORT_EDIT, &fTrans, FALSE);
    fEnable = (!fTrans || (fSecure ? (dw != DEF_SSMTPPORT) : (dw != DEF_SMTPPORT)));

    if (!fEnable)
        {
        fSecure = IsDlgButtonChecked(hwnd, IDC_SECURECONNECT_POP3_BUTTON);
        dw = GetDlgItemInt(hwnd, IDC_POP3_PORT_EDIT, &fTrans, FALSE);
        if (sfType == SERVER_IMAP)
            fEnable = (!fTrans || (fSecure ? (dw != DEF_SIMAPPORT) : (dw != DEF_IMAPPORT)));
        else
            fEnable = (!fTrans || (fSecure ? (dw != DEF_SPOP3PORT) : (dw != DEF_POP3PORT)));
        }

    EnableWindow(GetDlgItem(hwnd, IDC_USEDEFAULTS_BUTTON), fEnable);
    }

const static HELPMAP g_rgCtxMapMailAdv[] = {
                       {IDC_SMTP_PORT_EDIT, IDH_MAIL_SERV_ADV_OUT_PORT},
                       {IDC_POP3_PORT_EDIT, IDH_MAIL_SERV_ADV_INC_PORT},
                       {IDC_IN_MAIL_STATIC, IDH_MAIL_SERV_ADV_INC_PORT},
                       {IDC_USEDEFAULTS_BUTTON, IDH_NEWS_SERV_ADV_USE_DEFAULTS},
                       {IDC_SECURECONNECT_SMTP_BUTTON, IDH_MAIL_ADV_REQ_SSL},
                       {IDC_SECURECONNECT_POP3_BUTTON, IDH_MAIL_ADV_REQ_SSL},
                       {IDC_TIMEOUT_SLIDER, IDH_MAIL_SERV_ADV_TIMEOUT},
                       {IDC_TIMEOUT_STATIC, IDH_MAIL_SERV_ADV_TIMEOUT},
                       {IDC_LEAVE_CHECK, IDH_MAIL_SERV_ADV_LEAVE_SERVER_COPY},
                       {IDC_REMOVE_CHECK, IDH_MAIL_SERV_ADV_REMOVE_AFTER5},
                       {IDC_REMOVE_EDIT, IDH_MAIL_SERV_ADV_REMOVE_AFTER5},
                       {IDC_REMOVE_SPIN, IDH_MAIL_SERV_ADV_REMOVE_AFTER5},
                       {IDC_OPIE, IDH_MAIL_SERV_ADV_REMOVE_AFTER5},
                       {IDC_REMOVEDELETE_CHECK, IDH_MAIL_SERV_ADV_REMOVE_WHEN_DELETED},
                       {IDC_SPLIT_CHECK, IDH_NEWSMAIL_SEND_ADVSET_BREAK_UP},
                       {IDC_SPLIT_EDIT, IDH_NEWSMAIL_SEND_ADVSET_BREAK_UP},
                       {IDC_SPLIT_SPIN, IDH_NEWSMAIL_SEND_ADVSET_BREAK_UP},
                       {IDC_SPLIT_STATIC, IDH_NEWSMAIL_SEND_ADVSET_BREAK_UP},
                       {IDC_STATIC0, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC1, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC2, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC3, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC4, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC5, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC6, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC7, IDH_INETCOMM_GROUPBOX},
                       {0, 0}};

INT_PTR CALLBACK MailServer_AdvancedDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                         LPARAM lParam)
    {
    NMHDR *pnmhdr;
    TCHAR sz[MAX_PATH];
    DWORD dw, dwPortSmtp, dwPortIn, dwRemove, dwSplit;
    WORD code, id;
    SERVER_TYPE sfType;
    HWND hwndT;
    BOOL fTrans, fSecure, fEnable, flag, fIMAP;
    CAccount *pAcct = (CAccount *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get the ServerParams and store them in our extra bytes
            pAcct = (CAccount *)((PROPSHEETPAGE *) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pAcct);

            SendDlgItemMessage(hwnd, IDC_POP3_PORT_EDIT, EM_LIMITTEXT, PORT_CCHMAX, 0);
            SendDlgItemMessage(hwnd, IDC_SMTP_PORT_EDIT, EM_LIMITTEXT, PORT_CCHMAX, 0);

            // figure out what kind of server we are
            PropSheet_QuerySiblings(GetParent(hwnd), MSM_GETSERVERTYPE, (LPARAM)&sfType);

            Assert(sfType == SERVER_MAIL || sfType == SERVER_IMAP);
            fIMAP = sfType == SERVER_IMAP;

            UpdateIncomingMailControls(hwnd, sfType, pAcct->m_dwDlgFlags);

            // incoming server Secure connect
            if (FAILED(pAcct->GetPropDw(fIMAP ? AP_IMAP_SSL : AP_POP3_SSL, (LPDWORD)&fSecure)))
                fSecure = FALSE; // default
            CheckDlgButton(hwnd, IDC_SECURECONNECT_POP3_BUTTON, fSecure);

            // incoming server Port
            if (FAILED(pAcct->GetPropDw(fIMAP ? AP_IMAP_PORT : AP_POP3_PORT, &dw)))
                {
                // default
                if (fSecure)
                    dw = fIMAP ? DEF_SIMAPPORT : DEF_SPOP3PORT;
                else
                    dw = fIMAP ? DEF_IMAPPORT : DEF_POP3PORT;
                }
            SetDlgItemInt(hwnd, IDC_POP3_PORT_EDIT, dw, FALSE);

            // SMTP Secure connect
            if (FAILED(pAcct->GetPropDw(AP_SMTP_SSL, (LPDWORD) &fSecure)))
                fSecure = FALSE; // default
            CheckDlgButton(hwnd, IDC_SECURECONNECT_SMTP_BUTTON, fSecure);

            // SMTP Port
            if (FAILED(pAcct->GetPropDw(AP_SMTP_PORT, &dw)))
                dw = fSecure ? DEF_SSMTPPORT : DEF_SMTPPORT; // default
            SetDlgItemInt(hwnd, IDC_SMTP_PORT_EDIT, dw, FALSE);

            EnableUseDefaultButton(hwnd, sfType);

            // Server Timeout
            dw = 0;
            pAcct->GetPropDw(AP_SMTP_TIMEOUT, &dw);
            InitTimeoutSlider(GetDlgItem(hwnd, IDC_TIMEOUT_SLIDER),
                              GetDlgItem(hwnd, IDC_TIMEOUT_STATIC), dw);

            // Leave on Server
            if (FAILED(pAcct->GetPropDw(AP_POP3_LEAVE_ON_SERVER, &dw)))
                dw = FALSE; // default
            CheckDlgButton(hwnd, IDC_LEAVE_CHECK, dw);

            if (!!(pAcct->m_dwDlgFlags & ACCTDLG_NO_REMOVEAFTER))
                {
                ShowWindow(GetDlgItem(hwnd, IDC_REMOVE_CHECK), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_REMOVE_EDIT), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_REMOVE_SPIN), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_OPIE), SW_HIDE);
                }

            // Remove from Server after xxx days
            dw = OPTION_OFF; // default
            if (SUCCEEDED(pAcct->GetPropDw(AP_POP3_REMOVE_EXPIRED, (LPDWORD)&flag)) && flag)
                pAcct->GetPropDw(AP_POP3_EXPIRE_DAYS, &dw);
            InitCheckCounter(dw, hwnd, IDC_REMOVE_CHECK, IDC_REMOVE_EDIT, IDC_REMOVE_SPIN,
                             EXPIRE_MIN, EXPIRE_MAX, EXPIRE_DEFAULT);

            if (!!(pAcct->m_dwDlgFlags & ACCTDLG_NO_REMOVEDELETE))
                ShowWindow(GetDlgItem(hwnd, IDC_REMOVEDELETE_CHECK), SW_HIDE);

            // Remove when deleted locally
            if (FAILED(pAcct->GetPropDw(AP_POP3_REMOVE_DELETED, &dw)))
                dw = FALSE; // default
            CheckDlgButton(hwnd, IDC_REMOVEDELETE_CHECK, dw);

            EnableDeliveryControls(hwnd);

            if (!!(pAcct->m_dwDlgFlags & ACCTDLG_NO_BREAKMESSAGES))
                {
                ShowWindow(GetDlgItem(hwnd, IDC_SPLIT_GROUPBOX), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_SPLIT_CHECK), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_SPLIT_EDIT), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_SPLIT_SPIN), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_SPLIT_STATIC), SW_HIDE);
                }

            // Break Message Size
            dw = OPTION_OFF; // default
            if (SUCCEEDED(pAcct->GetPropDw(AP_SMTP_SPLIT_MESSAGES, (LPDWORD)&flag)) && flag)
                pAcct->GetPropDw(AP_SMTP_SPLIT_SIZE, (LPDWORD)&dw);
            InitCheckCounter(dw, hwnd, IDC_SPLIT_CHECK, IDC_SPLIT_EDIT, IDC_SPLIT_SPIN,
                             BREAKSIZE_MIN, BREAKSIZE_MAX, DEF_BREAKSIZE);


            PropSheet_QuerySiblings(GetParent(hwnd), SM_INITIALIZED, PAGE_ADV);
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            return (TRUE);

        case WM_HELP:
        case WM_CONTEXTMENU:
            return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapMailAdv));

        case WM_HSCROLL:
            // Update the text beside the slider
            SetTimeoutString(GetDlgItem(hwnd, IDC_TIMEOUT_STATIC),
                             (UINT) (SendMessage((HWND) lParam, TBM_GETPOS, 0, 0)));

            MarkPageDirty(hwnd, PAGE_ADV);
            return (TRUE);

        case WM_COMMAND:
            // Any change to the edit controls would cause the "Apply" button
            // to enable.
            PropSheet_QuerySiblings(GetParent(hwnd), MSM_GETSERVERTYPE, (LPARAM)&sfType);

            code = GET_WM_COMMAND_CMD(wParam, lParam);
            id = GET_WM_COMMAND_ID(wParam, lParam);


            switch (id)
                {
                case IDC_SMTP_PORT_EDIT:
                case IDC_POP3_PORT_EDIT:
                    if (code == EN_CHANGE)
                        {
                        EnableUseDefaultButton(hwnd, sfType);

                        MarkPageDirty(hwnd, PAGE_ADV);
                        }
                    break;

                case IDC_SECURECONNECT_POP3_BUTTON:
                case IDC_SECURECONNECT_SMTP_BUTTON:
                case IDC_USEDEFAULTS_BUTTON:
                    if (id != IDC_SECURECONNECT_POP3_BUTTON)
                        {
                        fSecure = IsDlgButtonChecked(hwnd, IDC_SECURECONNECT_SMTP_BUTTON);
                        SetDlgItemInt(hwnd, IDC_SMTP_PORT_EDIT, fSecure ? DEF_SSMTPPORT : DEF_SMTPPORT, FALSE);
                        }

                    if (id != IDC_SECURECONNECT_SMTP_BUTTON)
                        {
                        fSecure = IsDlgButtonChecked(hwnd, IDC_SECURECONNECT_POP3_BUTTON);
                        if (sfType == SERVER_MAIL)
                            dw = fSecure ? DEF_SPOP3PORT : DEF_POP3PORT;
                        else
                            dw = fSecure ? DEF_SIMAPPORT : DEF_IMAPPORT;
                        SetDlgItemInt(hwnd, IDC_POP3_PORT_EDIT, dw, FALSE);
                        }

                    EnableUseDefaultButton(hwnd, sfType);

                    MarkPageDirty(hwnd, PAGE_ADV);
                    break;

                case IDC_LEAVE_CHECK:
                case IDC_REMOVE_CHECK:
                    EnableDeliveryControls(hwnd);
                    // fall through...

                case IDC_REMOVEDELETE_CHECK:
                    MarkPageDirty(hwnd, PAGE_ADV);
                    break;

                case IDC_SPLIT_CHECK:
                    fEnable = IsDlgButtonChecked(hwnd, IDC_SPLIT_CHECK);
                    EnableWindow(GetDlgItem(hwnd, IDC_SPLIT_EDIT), fEnable);
                    EnableWindow(GetDlgItem(hwnd, IDC_SPLIT_SPIN), fEnable);

                    MarkPageDirty(hwnd, PAGE_ADV);
                    break;

                case IDC_SPLIT_EDIT:
                case IDC_REMOVE_EDIT:
                    if (code == EN_CHANGE)
                        MarkPageDirty(hwnd, PAGE_ADV);
                    break;
                }
            return (TRUE);

        case WM_NOTIFY:
            pnmhdr = (NMHDR *)lParam;
            switch (pnmhdr->code)
                {
                case PSN_APPLY:
                    // BEGIN validation

                    // figure out what kind of server we are
                    PropSheet_QuerySiblings(GetParent(hwnd), MSM_GETSERVERTYPE, (LPARAM)&sfType);

                    Assert(sfType == SERVER_MAIL || sfType == SERVER_IMAP);
                    fIMAP = sfType == SERVER_IMAP;

                    dwPortSmtp = GetDlgItemInt(hwnd, IDC_SMTP_PORT_EDIT, &fTrans, FALSE);
                    if (!fTrans || dwPortSmtp == 0)
                        {
                        hwndT = GetDlgItem(hwnd, IDC_SMTP_PORT_EDIT);
                        return(InvalidAcctProp(hwnd, hwndT, idsErrPortNum, iddMailSvrProp_Advanced));
                        }

                    dwPortIn = GetDlgItemInt(hwnd, IDC_POP3_PORT_EDIT, &fTrans, FALSE);
                    if (!fTrans || dwPortIn == 0)
                        {
                        hwndT = GetDlgItem(hwnd, IDC_POP3_PORT_EDIT);
                        return(InvalidAcctProp(hwnd, hwndT, idsErrPortNum, iddMailSvrProp_Advanced));
                        }

                    dwRemove = 0;
                    if (!fIMAP)
                        {
                        if (IsDlgButtonChecked(hwnd, IDC_LEAVE_CHECK) &&
                            IsDlgButtonChecked(hwnd, IDC_REMOVE_CHECK))
                            {
                            dwRemove = GetDlgItemInt(hwnd, IDC_REMOVE_EDIT, &fTrans, FALSE);
                            if (!fTrans || dwRemove < EXPIRE_MIN || dwRemove > EXPIRE_MAX)
                                {
                                hwndT = GetDlgItem(hwnd, IDC_REMOVE_EDIT);
                                return(InvalidAcctProp(hwnd, hwndT, idsEnterRemoveFromServerDays, iddMailSvrProp_Advanced));
                                }
                            }
                        }

                    dwSplit = 0;
                    if (IsDlgButtonChecked(hwnd, IDC_SPLIT_CHECK))
                        {
                        dwSplit = GetDlgItemInt(hwnd, IDC_SPLIT_EDIT, &fTrans, FALSE);
                        if (!fTrans || dwSplit < BREAKSIZE_MIN || dwSplit > BREAKSIZE_MAX)
                            {
                            hwndT = GetDlgItem(hwnd, IDC_SPLIT_EDIT);
                            return(InvalidAcctProp(hwnd, hwndT, idsEnterBreakSize, iddMailSvrProp_Advanced));
                            }
                        }

                    // END validation

                    pAcct->SetPropDw(AP_SMTP_PORT, dwPortSmtp);

                    if (fIMAP)
                        {
                        HRESULT hrTemp;

                        hrTemp = pAcct->GetPropDw(AP_IMAP_PORT, &dw);
                        if (FAILED(hrTemp) || dw != dwPortIn)
                            {
                            pAcct-> SetPropDw(AP_IMAP_PORT, dwPortIn);
                            if (FAILED(pAcct->GetPropDw(AP_IMAP_DIRTY, &dw)))
                                dw = 0;

                            dw |= IMAP_FLDRLIST_DIRTY;
                            pAcct->SetPropDw(AP_IMAP_DIRTY, dw);
                            }
                        }
                    else
                        {
                        pAcct->SetPropDw(AP_POP3_PORT, dwPortIn);
                        dw = IsDlgButtonChecked(hwnd, IDC_LEAVE_CHECK);
                        pAcct->SetPropDw(AP_POP3_LEAVE_ON_SERVER, dw);

                        if (dw != 0)
                            {
                            dw = IsDlgButtonChecked(hwnd, IDC_REMOVE_CHECK);
                            pAcct->SetPropDw(AP_POP3_REMOVE_EXPIRED, dw);

                            if (dw != 0)
                                {
                                Assert(dwRemove != 0);
                                pAcct->SetPropDw(AP_POP3_EXPIRE_DAYS, dwRemove);
                                }

                            dw = IsDlgButtonChecked(hwnd, IDC_REMOVEDELETE_CHECK);
                            pAcct->SetPropDw(AP_POP3_REMOVE_DELETED, dw);
                            }
                        }

                    dw = IsDlgButtonChecked(hwnd, IDC_SECURECONNECT_POP3_BUTTON);
                    pAcct->SetPropDw(fIMAP ? AP_IMAP_SSL : AP_POP3_SSL, dw);

                    dw = GetTimeoutFromSlider(GetDlgItem(hwnd, IDC_TIMEOUT_SLIDER));
                    pAcct->SetPropDw(AP_SMTP_TIMEOUT, dw);
                    pAcct->SetPropDw(fIMAP ? AP_IMAP_TIMEOUT : AP_POP3_TIMEOUT, dw);

                    dw = IsDlgButtonChecked(hwnd, IDC_SECURECONNECT_SMTP_BUTTON);
                    pAcct->SetPropDw(AP_SMTP_SSL, dw);

                    dw = IsDlgButtonChecked(hwnd, IDC_SPLIT_CHECK);
                    pAcct->SetPropDw(AP_SMTP_SPLIT_MESSAGES, dw);
                    if (dw != 0)
                        {
                        Assert(dwSplit != 0);
                        pAcct->SetPropDw(AP_SMTP_SPLIT_SIZE, dwSplit);
                        }

                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    dw = PAGE_ADV;
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SAVECHANGES, (LPARAM)&dw);
                    if (dw == -1)
                        {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return(TRUE);
                        }
                    break;
                }
            return (TRUE);
        }

    return (FALSE);
    }


BOOL FIsDuplicateIMAPSpecialFldrs(LPSTR pszSentItems, LPSTR pszDrafts,
                                  HWND hwnd, HWND *phwndOffender, int *piErrorStr)
{
    Assert(NULL != phwndOffender);
    Assert(NULL != piErrorStr);

    // First compare both special folders to INBOX
    if (0 == lstrcmpi(c_szInbox, pszSentItems))
    {
        *phwndOffender = GetDlgItem(hwnd, IDC_IMAPSENT_EDIT);
        *piErrorStr = idsIMAPSpecialFldr_InboxDup;
        return TRUE;
    }

    if (0 == lstrcmpi(c_szInbox, pszDrafts))
    {
        *phwndOffender = GetDlgItem(hwnd, IDC_IMAPDRAFT_EDIT);
        *piErrorStr = idsIMAPSpecialFldr_InboxDup;
        return TRUE;
    }

    // Now compare special folders to each other
    if (0 == lstrcmpi(pszSentItems, pszDrafts))
    {
        *phwndOffender = GetDlgItem(hwnd, IDC_IMAPSENT_EDIT);
        *piErrorStr = idsIMAPSpecialFldr_Duplicate;
        return TRUE;
    }

    // If we reached this point, no problems found
    *phwndOffender = NULL;
    *piErrorStr = 0;
    return FALSE;
}


BOOL FContainsHierarchyChars(LPSTR pszFldrName)
{
    BOOL    fSkipByte = FALSE;

    while ('\0' != *pszFldrName)
    {
        if (fSkipByte)
            fSkipByte = FALSE;
        else if (IsDBCSLeadByte(*pszFldrName))
            fSkipByte = TRUE; // Skip next byte (trail byte)
        else
        {
            if ('/' == *pszFldrName || '\\' == *pszFldrName || '.' == *pszFldrName)
                return TRUE;
        }

        // Advance char ptr
        pszFldrName += 1;
    }

    // If we reached this point, no hierarchy chars found
    return FALSE;
}


const static HELPMAP g_rgCtxMapIMAP[] = {
                       {IDC_ROOT_FOLDER_EDIT, IDH_IMAP_BASE_ROOT},
                       {IDC_IMAP_SVRSPECIALFLDRS, 760},
                       {IDC_IMAPSENT_EDIT, 765},
                       {IDC_IMAPSENT_STATIC, 765},
                       {IDC_IMAPDRAFT_EDIT, 770},
                       {IDC_IMAPDRAFT_STATIC, 770},
                       {IDC_IMAP_POLL_ALL_FOLDERS, 775},
                       {IDC_STATIC0, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC1, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC2, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC3, IDH_INETCOMM_GROUPBOX},
                       {0, 0}};

INT_PTR CALLBACK MailServer_IMAPDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    NMHDR *pnmhdr;
    TCHAR sz[MAX_PATH];
    DWORD dw, dw2;
    HWND hwndT;
    WORD code, id;
    UINT uiLen;
    CAccount *pAcct = (CAccount *)GetWindowLongPtr(hwnd, DWLP_USER);
    HRESULT hrTemp;

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get the ServerParams and store them in our extra bytes
            pAcct = (CAccount *)((PROPSHEETPAGE *) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pAcct);

            // Initialize edit controls
            InitAcctPropEdit(GetDlgItem(hwnd, IDC_ROOT_FOLDER_EDIT), pAcct,
                AP_IMAP_ROOT_FOLDER, CCHMAX_ROOT_FOLDER - 1);

            if (FAILED(pAcct->GetPropDw(AP_IMAP_POLL_ALL_FOLDERS, &dw)))
                dw = TRUE;
            CheckDlgButton(hwnd, IDC_IMAP_POLL_ALL_FOLDERS, dw != 0);

            // Initialize IMAP Special Folder Options IF we have the flag to do so
            if (pAcct->m_dwDlgFlags & ACCTDLG_SHOWIMAPSPECIAL)
                {
                // Init special folder edit controls
                InitAcctPropEdit(GetDlgItem(hwnd, IDC_IMAPSENT_EDIT), pAcct,
                    AP_IMAP_SENTITEMSFLDR, CCHMAX_ROOT_FOLDER - 1);
                InitAcctPropEdit(GetDlgItem(hwnd, IDC_IMAPDRAFT_EDIT), pAcct,
                    AP_IMAP_DRAFTSFLDR, CCHMAX_ROOT_FOLDER - 1);

                // IMAP server-side special folders
                if (FAILED(pAcct->GetPropDw(AP_IMAP_SVRSPECIALFLDRS, &dw)))
                    dw = TRUE; // default
                CheckDlgButton(hwnd, IDC_IMAP_SVRSPECIALFLDRS, dw);
                EnableWindow(GetDlgItem(hwnd, IDC_IMAPSENT_EDIT), dw);
                EnableWindow(GetDlgItem(hwnd, IDC_IMAPDRAFT_EDIT), dw);
                }
            else
                {
                // Hide all IMAP special folder options
                ShowWindow(GetDlgItem(hwnd, IDC_IMAPSENT_EDIT), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_IMAPDRAFT_EDIT), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_IMAP_SVRSPECIALFLDRS), SW_HIDE);
                
                ShowWindow(GetDlgItem(hwnd, IDC_STATIC2), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_STATIC3), SW_HIDE);

                ShowWindow(GetDlgItem(hwnd, IDC_IMAPSENT_STATIC), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_IMAPDRAFT_STATIC), SW_HIDE);
                }

            PropSheet_QuerySiblings(GetParent(hwnd), SM_INITIALIZED, PAGE_IMAP);
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            return (TRUE);

        case WM_HELP:
        case WM_CONTEXTMENU:
            return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapIMAP));

        case WM_COMMAND:
            // Any change to the edit controls would cause the "Apply" button
            // to enable.
            code = GET_WM_COMMAND_CMD(wParam, lParam);
            id = GET_WM_COMMAND_ID(wParam, lParam);

            switch (id)
                {
                //case IDC_IMAP_LISTLSUB:
                case IDC_IMAP_POLL_ALL_FOLDERS:
                    MarkPageDirty(hwnd, PAGE_IMAP);
                    break;

                case IDC_IMAP_SVRSPECIALFLDRS:
                    dw = IsDlgButtonChecked(hwnd, IDC_IMAP_SVRSPECIALFLDRS);
                    EnableWindow(GetDlgItem(hwnd, IDC_IMAPSENT_EDIT), dw);
                    EnableWindow(GetDlgItem(hwnd, IDC_IMAPDRAFT_EDIT), dw);
                    MarkPageDirty(hwnd, PAGE_IMAP);
                    break;

                case IDC_ROOT_FOLDER_EDIT:
                case IDC_IMAPSENT_EDIT:
                case IDC_IMAPDRAFT_EDIT:
                    if (code == EN_CHANGE)
                        MarkPageDirty(hwnd, PAGE_IMAP);
                    break;
                }
            return (TRUE);

        case WM_NOTIFY:
            pnmhdr = (NMHDR *)lParam;
            switch (pnmhdr->code)
                {
                case PSN_APPLY:
                    // BEGIN validation
                    // Check IMAP special folder paths
                    if (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_IMAP_SVRSPECIALFLDRS))
                    {
                        TCHAR   sz2[MAX_PATH];
                        int     iErrorStr;

                        // Check for 0-length special folder paths
                        if (0 == GetDlgItemText(hwnd, IDC_IMAPSENT_EDIT, sz, ARRAYSIZE(sz)) ||
                            FIsEmpty(sz))
                        {
                            hwndT = GetDlgItem(hwnd, IDC_IMAPSENT_EDIT);
                            return(InvalidAcctProp(hwnd, hwndT, idsIMAPBlankSpecialFldrs, iddMailSvrProp_IMAP));
                        }

                        if (0 == GetDlgItemText(hwnd, IDC_IMAPDRAFT_EDIT, sz2, ARRAYSIZE(sz2)) ||
                            FIsEmpty(sz))
                        {
                            hwndT = GetDlgItem(hwnd, IDC_IMAPDRAFT_EDIT);
                            return(InvalidAcctProp(hwnd, hwndT, idsIMAPBlankSpecialFldrs, iddMailSvrProp_IMAP));
                        }

                        // Check for duplicate special folder paths: these are not allowed
                        // If we got to this point, sz and sz2 are filled with sent items path
                        if (FIsDuplicateIMAPSpecialFldrs(sz, sz2, hwnd, &hwndT, &iErrorStr))
                            return(InvalidAcctProp(hwnd, hwndT, iErrorStr, iddMailSvrProp_IMAP));

                        // Check for hierarchy characters in special folder names
                        if (FContainsHierarchyChars(sz))
                        {
                            hwndT = GetDlgItem(hwnd, IDC_IMAPSENT_EDIT);
                            return(InvalidAcctProp(hwnd, hwndT, idsIMAPNoHierarchyChars, iddMailSvrProp_IMAP));
                        }

                        if (FContainsHierarchyChars(sz2))
                        {
                            hwndT = GetDlgItem(hwnd, IDC_IMAPDRAFT_EDIT);
                            return(InvalidAcctProp(hwnd, hwndT, idsIMAPNoHierarchyChars, iddMailSvrProp_IMAP));
                        }
                    }

                    // END validation

                    // Save IMAP root folder path, if it changed
                    if (0 != SendMessage(GetDlgItem(hwnd, IDC_ROOT_FOLDER_EDIT),
                        EM_GETMODIFY, 0, 0))
                    {
                        dw = GetDlgItemText(hwnd, IDC_ROOT_FOLDER_EDIT, sz, ARRAYSIZE(sz));
                        // TODO: figure out if it is a valid folder
                        UlStripWhitespace(sz, TRUE, TRUE, &dw);
                        pAcct->SetPropSz(AP_IMAP_ROOT_FOLDER, sz);
                        SendMessage(GetDlgItem(hwnd, IDC_ROOT_FOLDER_EDIT), EM_SETMODIFY, 0, 0);

                        if (FAILED(pAcct->GetPropDw(AP_IMAP_DIRTY, &dw)))
                            dw = 0;

                        dw |= IMAP_FLDRLIST_DIRTY;
                        pAcct->SetPropDw(AP_IMAP_DIRTY, dw);
                    }


                    dw = IsDlgButtonChecked(hwnd, IDC_IMAP_POLL_ALL_FOLDERS);
                    pAcct->SetPropDw(AP_IMAP_POLL_ALL_FOLDERS, dw);

                    // Save special folders checkbox
                    dw = IsDlgButtonChecked(hwnd, IDC_IMAP_SVRSPECIALFLDRS);
                    hrTemp = pAcct->GetPropDw(AP_IMAP_SVRSPECIALFLDRS, &dw2);
                    if (FAILED(hrTemp) || dw2 != dw)
                        {
                        pAcct->SetPropDw(AP_IMAP_SVRSPECIALFLDRS, dw);
                        if (FAILED(pAcct->GetPropDw(AP_IMAP_DIRTY, &dw2)))
                            dw2 = 0;

                        dw2 |= (IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY);
                        pAcct->SetPropDw(AP_IMAP_DIRTY, dw2);
                        }

                    if (dw != 0)
                    {
                        // Save IMAP Sent Items folder path, if it changed
                        if (0 != SendMessage(GetDlgItem(hwnd, IDC_IMAPSENT_EDIT),
                            EM_GETMODIFY, 0, 0))
                        {
                            uiLen = GetDlgItemText(hwnd, IDC_IMAPSENT_EDIT, sz, ARRAYSIZE(sz));
                            ImapRemoveTrailingHC(sz, uiLen);
                            // TODO: figure out if it is a valid folder
                            pAcct->SetPropSz(AP_IMAP_SENTITEMSFLDR, sz);
                            SendMessage(GetDlgItem(hwnd, IDC_IMAPSENT_EDIT), EM_SETMODIFY, 0, 0);

                            if (FAILED(pAcct->GetPropDw(AP_IMAP_DIRTY, &dw)))
                                dw = 0;

                            dw |= IMAP_SENTITEMS_DIRTY;
                            pAcct->SetPropDw(AP_IMAP_DIRTY, dw);
                        }

                        // Save IMAP Drafts folder path, if it changed
                        if (0 != SendMessage(GetDlgItem(hwnd, IDC_IMAPDRAFT_EDIT),
                            EM_GETMODIFY, 0, 0))
                        {
                            uiLen = GetDlgItemText(hwnd, IDC_IMAPDRAFT_EDIT, sz, ARRAYSIZE(sz));
                            ImapRemoveTrailingHC(sz, uiLen);
                            // TODO: figure out if it is a valid folder
                            pAcct->SetPropSz(AP_IMAP_DRAFTSFLDR, sz);
                            SendMessage(GetDlgItem(hwnd, IDC_IMAPDRAFT_EDIT), EM_SETMODIFY, 0, 0);

                            if (FAILED(pAcct->GetPropDw(AP_IMAP_DIRTY, &dw)))
                                dw = 0;

                            dw |= IMAP_DRAFTS_DIRTY;
                            pAcct->SetPropDw(AP_IMAP_DIRTY, dw);
                        }
                    }

                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    dw = PAGE_IMAP;
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SAVECHANGES, (LPARAM)&dw);
                    if (dw == -1)
                        {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return(TRUE);
                        }
                    break;
                }
            return (TRUE);
        }

    return (FALSE);
    } // MailServer_IMAPDlgProc


void ImapRemoveTrailingHC(LPSTR pszPath, UINT uiLen)
    {
    LPSTR pLastChar;

    if (0 == uiLen)
        return;

    pLastChar = pszPath + uiLen - 1;
    while (pLastChar >= pszPath && ('/' == *pLastChar || '\\' == *pLastChar || '.' == *pLastChar))
        {
        *pLastChar = '\0'; // Bye-bye, potential hierarchy char
        pLastChar -= 1;
        } // while

    } // ImapRemoveTrailingHC


#ifdef DEAD
BOOL IsValidServerName(TCHAR *sz)
    {
    Assert(sz != NULL);

    // bug 34513
    if (FIsEmpty(sz))
        return(FALSE);

    // Bug #32532 - If the server name is the IP address, ie 157.54.44.183, then
    //              don't use this grammar to parse it.
    if (-1 != inet_addr(sz))
        return (TRUE);

    while (*sz != 0)
        {
        if (!IsDBCSLeadByte(*sz))
            {
            if (*sz == _T(' '))
                return(FALSE);
            }
        else
            {
            return(FALSE);
            }

        sz = CharNext(sz);
        }

    return(TRUE);
    }
#endif // DEAD

/*
RFC 1034
<domain> ::=  <subdomain> | " "

<subdomain> ::=  <label> | <subdomain> "." <label>

<label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]

<ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>

<let-dig-hyp> ::= <let-dig> | "-"

<let-dig> ::= <letter> | <digit>

<letter> ::= any one of the 52 alphabetic characters A through Z
in upper case and a through z in lower case

<digit> ::= any one of the ten digits 0 through 9
*/

#define ST_BOGUS    -1
#define ST_LABEL    0
#define ST_DASH     1
#define ST_LD       2

#define ALPHABET    0
#define NUMERIC     1
#define DOT         2
#define DASH        3

static const int s_rgSvrState[4][3] =
    {
//   ST_LABEL   ST_DASH     ST_LD
// ALPHABET
    {ST_LD,     ST_LD,      ST_LD},
// NUMERIC
    {ST_LD,     ST_LD,      ST_LD},
// DOT
    {ST_BOGUS,  ST_BOGUS,   ST_LABEL},
// DASH
    {ST_BOGUS,  ST_DASH,    ST_DASH}
    };

BOOL IsValidServerName(LPSTR sz)
    {
    int state, curr;

    Assert(sz != NULL);

    // bug 34513
    if (FIsEmpty(sz))
        return(FALSE);

    // Bug #32532 - If the server name is the IP address, ie 157.54.44.183, then
    //              don't use this grammar to parse it.
    if (-1 != inet_addr(sz))
        return (TRUE);

    state = ST_LABEL;
    while (*sz != 0)
        {
        if (!IsDBCSLeadByte(*sz))
            {
            if (*sz == _T('.'))
                curr = DOT;
            else if (*sz == _T('-'))
                curr = DASH;
            else if ((*sz >= 'A' && *sz <= 'Z') || (*sz >= 'a' && *sz <= 'z'))
                curr = ALPHABET;
            else if (*sz >= '0' && *sz <= '9')
                curr = NUMERIC;
            else
                return(FALSE);

            state = s_rgSvrState[curr][state];
            if (state == ST_BOGUS)
                break;
            }
        else
            {
            state = ST_BOGUS;
            break;
            }

        sz = CharNext(sz);
        }

    return(state == ST_LD);
    }

HRESULT ValidServerName(LPSTR szServer)
    {
    HRESULT hr;
    int cbT;

    cbT = lstrlen(szServer);
    if (cbT == 0 || cbT >= CCHMAX_SERVER_NAME)
        return(E_InvalidValue);

    if (!IsValidServerName(szServer))
        hr = S_NonStandardValue;
    else
        hr = S_OK;

    return(hr);
    }

IMNACCTAPI ValidEmailAddressParts(LPSTR lpAddress, LPSTR lpszAcct, DWORD cchSizeAcct, LPSTR lpszDomain, DWORD cchSizeDomain)
    {
    int cbT;
    LPSTR   szAddr = lpAddress;
    // Step through the address looking for '@'.  If there's an at sign in the middle
    // of a string, this is close enough to being an internet address for me.

    Assert(lpAddress != NULL);

    cbT = lstrlen(lpAddress);
    if (cbT == 0 || cbT >= CCHMAX_EMAIL_ADDRESS)
        return(E_InvalidValue);

    // Can't start with '@'
    if (*lpAddress != '@')
    {
        while (*lpAddress)
        {
            // Internet addresses only allow pure ASCII.  No high bits!
            if (IsDBCSLeadByte(*lpAddress) || (*lpAddress & 0x80))
                break;

            if (*lpAddress == '@')
            {
                if (lpszAcct)
                {
                    StrCpyN(lpszAcct, szAddr, cchSizeAcct);
                    lpszAcct[(lpAddress - szAddr)] = 0;
                }
                if (lpszDomain)
                {
                    StrCpyN(lpszDomain, lpAddress +1, cchSizeDomain);
                }

                // Found the at sign.  Is there anything following?
                lpAddress++;
                if (!IsValidServerName(lpAddress))
                    break;
                else
                    return(S_OK);
            }

            lpAddress++;
        }
    }

    return(S_NonStandardValue);
}


IMNACCTAPI ValidEmailAddress(LPSTR lpAddress)
    {
    int cbT;

    // Step through the address looking for '@'.  If there's an at sign in the middle
    // of a string, this is close enough to being an internet address for me.

    Assert(lpAddress != NULL);

    cbT = lstrlen(lpAddress);
    if (cbT == 0 || cbT >= CCHMAX_EMAIL_ADDRESS)
        return(E_InvalidValue);

    // Can't start with '@'
    if (*lpAddress != '@')
    {
        while (*lpAddress)
        {
            // Internet addresses only allow pure ASCII.  No high bits!
            if (IsDBCSLeadByte(*lpAddress) || (*lpAddress & 0x80))
                break;

            if (*lpAddress == '@')
            {
                // Found the at sign.  Is there anything following?
                lpAddress++;
                if (!IsValidServerName(lpAddress))
                    break;
                else
                    return(S_OK);
            }

            lpAddress++;
        }
    }

    return(S_NonStandardValue);
}

const static HELPMAP g_rgCtxMapLdapGen[] = {
                       {IDC_ACCOUNT_EDIT, IDH_WABLDAP_DIRSSERV_FRIENDLY_NAME},
                       {IDC_SERVER_EDIT, IDH_WABLDAP_DIRSSERV_NAME},
                       {IDC_LOGON_CHECK, IDH_INETCOMM_SERVER_REQ_LOGON},
                       {IDC_LOGONSSPI_CHECK, IDH_WABLDAP_DIRSSERV_AUTH_SICILY},
                       {IDC_ACCTNAME_EDIT, IDH_WABLDAP_DIRSSERV_AUTH_PASS_UNAME},
                       {IDC_ACCTNAME_STATIC, IDH_WABLDAP_DIRSSERV_AUTH_PASS_UNAME},
                       {IDC_ACCTPASS_EDIT, IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS},
                       {IDC_ACCTPASS_STATIC, IDH_WABLDAP_DIRSSERV_AUTH_PASS_PASS},
                       {IDC_RESOLVE_CHECK, IDH_WABLDAP_DIRSSERV_CHECK_AGAINST},
                       {IDC_STATIC0, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC1, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC2, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC3, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC4, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC5, IDH_INETCOMM_GROUPBOX},
                       {0, 0}};

INT_PTR CALLBACK DirServer_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    BOOL fLogon;
    int idsError;
    ULONG cbSize;
    HWND hwndT;
    NMHDR *pnmhdr;
    CAccount *pAcct;
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];
    DWORD dw;
    SVRDLGINFO *psdi;

    pAcct = (CAccount *)GetWindowLongPtr(hwnd, DWLP_USER);
    psdi = (SVRDLGINFO *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get the ServerParams and store them in our extra bytes
            pAcct = (CAccount *) ((PROPSHEETPAGE*) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pAcct);

            Assert(psdi == NULL);
            if (!MemAlloc((void **)&psdi, sizeof(SVRDLGINFO)))
                return(-1);
            ZeroMemory(psdi, sizeof(SVRDLGINFO));
            psdi->sfType = SERVER_LDAP;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)psdi);

            // Set Account Name
            InitAcctPropEdit(GetDlgItem(hwnd, IDC_ACCOUNT_EDIT), pAcct, AP_ACCOUNT_NAME, CCHMAX_ACCOUNT_NAME - 1);

            // set server name
            InitAcctPropEdit(GetDlgItem(hwnd, IDC_SERVER_EDIT), pAcct, AP_LDAP_SERVER, CCHMAX_SERVER_NAME - 1);

            if (FAILED(pAcct->GetPropDw(AP_LDAP_AUTHENTICATION, &dw)))
                dw = LDAP_AUTH_ANONYMOUS;
            if (dw != LDAP_AUTH_ANONYMOUS)
                {
                CheckDlgButton(hwnd, IDC_LOGON_CHECK, BST_CHECKED);
                if (SUCCEEDED(pAcct->GetPropSz(AP_LDAP_USERNAME, sz, ARRAYSIZE(sz))))
                    SetDlgItemText(hwnd, IDC_ACCTNAME_EDIT, sz);

                if (SUCCEEDED(pAcct->GetPropSz(AP_LDAP_PASSWORD, sz, ARRAYSIZE(sz))))
                    SetDlgItemText(hwnd, IDC_ACCTPASS_EDIT, sz);

                if (dw != LDAP_AUTH_PASSWORD)
                    {
                    CheckDlgButton(hwnd, IDC_LOGONSSPI_CHECK, BST_CHECKED);
                    }

                fLogon = TRUE;
                }
            else
                fLogon = FALSE;

            Server_EnableLogonWindows(hwnd, fLogon);

            hwndT = GetDlgItem(hwnd, IDC_ACCTNAME_EDIT);
            SetIntlFont(hwndT);
            SendMessage(hwndT, EM_LIMITTEXT, CCHMAX_USERNAME - 1, 0L);

            SendDlgItemMessage(hwnd, IDC_ACCTPASS_EDIT, EM_LIMITTEXT, CCHMAX_PASSWORD - 1, 0L);

            if (SUCCEEDED(pAcct->GetPropDw(AP_LDAP_RESOLVE_FLAG, &dw)))
                CheckDlgButton(hwnd, IDC_RESOLVE_CHECK, dw ? BST_CHECKED : BST_UNCHECKED);

            if (SUCCEEDED(pAcct->GetPropDw(AP_SERVER_READ_ONLY, &dw)) && dw)
                EnableWindow(GetDlgItem(hwnd, IDC_SERVER_EDIT), FALSE);

            psdi->dwInit = (psdi->dwInit | PAGE_GEN);
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            return (TRUE);

        case WM_HELP:
        case WM_CONTEXTMENU:
            return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapLdapGen));

        case WM_DESTROY:
            if (psdi != NULL)
                MemFree(psdi);
            break;

        case PSM_QUERYSIBLINGS:
            Assert(psdi != NULL);
            Assert(pAcct != NULL);
            return(HandleQuerySiblings(hwnd, psdi, pAcct, wParam, lParam));

        case WM_COMMAND:
            switch(LOWORD(wParam))
                {
                case IDC_LOGONSSPI_CHECK:
                case IDC_LOGON_CHECK:
                    Server_EnableLogonWindows(hwnd, IsDlgButtonChecked(hwnd, IDC_LOGON_CHECK));

                    // fall through...

                case IDC_RESOLVE_CHECK:
                    MarkPageDirty(hwnd, PAGE_GEN);
                    break;

                default:
                    if (HIWORD(wParam) == EN_CHANGE)
                        {
                        if (LOWORD(wParam) == IDC_ACCOUNT_EDIT)
                            UpdateAcctTitle(hwnd, IDC_ACCOUNT_EDIT, ACCT_DIR_SERV);
                        MarkPageDirty(hwnd, PAGE_GEN);
                        }
                    break;
                }
            break;

        case WM_NOTIFY:
            pnmhdr = (NMHDR *)lParam;
            switch (pnmhdr->code)
                {
                case PSN_APPLY:
                    // BEGIN validation

                    hwndT = GetDlgItem(hwnd, IDC_ACCOUNT_EDIT);
                    if (!ValidateAccountName(hwnd, hwndT, pAcct, &idsError))
                        return(InvalidAcctProp(hwnd, hwndT, idsError, iddDirServProp_General));

                    hwndT = GetDlgItem(hwnd, IDC_SERVER_EDIT);
                    if (!ValidateServerName(hwnd, hwndT, pAcct, AP_LDAP_SERVER, &idsError, pnmhdr->code == PSN_APPLY))
                        return(InvalidAcctProp(hwnd, hwndT, idsError, iddDirServProp_General));

                    if (IsDlgButtonChecked(hwnd, IDC_LOGON_CHECK) &&
                        !ValidateLogonSettings(hwnd, pAcct->m_dwDlgFlags, &hwndT, &idsError))
                        return(InvalidAcctProp(hwnd, hwndT, idsError, iddDirServProp_General));

                    // END validation

                    hwndT = GetDlgItem(hwnd, IDC_ACCOUNT_EDIT);
                    GetAccountName(hwndT, pAcct);

                    hwndT = GetDlgItem(hwnd, IDC_SERVER_EDIT);
                    GetServerName(hwndT, pAcct, AP_LDAP_SERVER);

                    GetLogonSettings(hwnd, pAcct, IsDlgButtonChecked(hwnd, IDC_LOGON_CHECK), SRV_LDAP);

                    pAcct->SetPropDw(AP_LDAP_RESOLVE_FLAG, (DWORD)!!IsDlgButtonChecked(hwnd, IDC_RESOLVE_CHECK));

                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    dw = PAGE_GEN;
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SAVECHANGES, (LPARAM)&dw);
                    if (dw == -1)
                        {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return(TRUE);
                        }
                    break;
                }
            return(TRUE);
        }

    return (FALSE);
    }

const static HELPMAP g_rgCtxMapLdapAdv[] = {
                       {IDC_LDAP_PORT_EDIT, IDH_LDAP_PORT_NUMBER},
                       {IDC_USEDEFAULTS_BUTTON, IDH_NEWS_SERV_ADV_USE_DEFAULTS},
                       {IDC_TIMEOUT_SLIDER, IDH_WABLDAP_SEARCH_TIMEOUT},
                       {IDC_MATCHES_EDIT, IDH_WABLDAP_SEARCH_LIMIT},
                       {IDC_SEARCHBASE_EDIT, IDH_LDAP_SEARCH_BASE},
                       {IDC_SECURECONNECT_BUTTON, IDH_MAIL_ADV_REQ_SSL},
                       {IDC_SIMPLESEARCH_BUTTON, IDH_WABLDAP_USE_SIMPLE_SEARCH},
                       {IDC_STATIC0, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC1, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC2, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC3, IDH_INETCOMM_GROUPBOX},
                       {0, 0}};

INT_PTR CALLBACK DirServer_AdvancedDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    NMHDR *pnmhdr;
    TCHAR sz[CCHMAX_ACCT_PROP_SZ];
    DWORD dw, dwPort, dwMatches;
    WORD code, id;
    SERVER_TYPE sfType;
    HWND hwndT;
    BOOL fTrans, fSecure, fEnable, flag, fIMAP, fSimple;
    IImnAccount *pAcct = (IImnAccount *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get the ServerParams and store them in our extra bytes
            pAcct = (IImnAccount*) ((PROPSHEETPAGE*) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pAcct);

            // Load the controls with what information we have
            if (SUCCEEDED(pAcct->GetPropDw(AP_LDAP_PORT, &dw)))
                SetDlgItemInt(hwnd, IDC_LDAP_PORT_EDIT, dw, FALSE);
            SendDlgItemMessage(hwnd, IDC_LDAP_PORT_EDIT, EM_LIMITTEXT, PORT_CCHMAX, 0);
            if (SUCCEEDED(pAcct->GetPropDw(AP_LDAP_SIMPLE_SEARCH, (LPDWORD)&fSimple)) && fSimple)
                CheckDlgButton(hwnd, IDC_SIMPLESEARCH_BUTTON, TRUE);
            if (SUCCEEDED(pAcct->GetPropDw(AP_LDAP_SSL, (LPDWORD)&fSecure)) && fSecure)
                {
                EnableWindow(GetDlgItem(hwnd, IDC_USEDEFAULTS_BUTTON), dw != DEF_SLDAPPORT);
                CheckDlgButton(hwnd, IDC_SECURECONNECT_BUTTON, TRUE);
                }
            else
                {
                EnableWindow(GetDlgItem(hwnd, IDC_USEDEFAULTS_BUTTON), dw != DEF_LDAPPORT);
                }

            if (FAILED(pAcct->GetPropDw(AP_LDAP_SEARCH_RETURN, (LPDWORD)&dw)))
                dw = MATCHES_DEFAULT;
            if (dw < MATCHES_MIN)
                dw = MATCHES_MIN;
            else if (dw > MATCHES_MAX)
                dw = MATCHES_MAX;
            InitCheckCounter(dw, hwnd, NULL, IDC_MATCHES_EDIT, IDC_MATCHES_SPIN,
                             MATCHES_MIN, MATCHES_MAX, MATCHES_DEFAULT);

            // Server Timeout
            dw = 0;
            pAcct->GetPropDw(AP_LDAP_TIMEOUT, &dw);
            InitTimeoutSlider(GetDlgItem(hwnd, IDC_TIMEOUT_SLIDER),
                              GetDlgItem(hwnd, IDC_TIMEOUT_STATIC), dw);

            InitAcctPropEdit(GetDlgItem(hwnd, IDC_SEARCHBASE_EDIT), pAcct,
                AP_LDAP_SEARCH_BASE, CCHMAX_SEARCH_BASE - 1);

            PropSheet_QuerySiblings(GetParent(hwnd), SM_INITIALIZED, PAGE_ADV);
            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            return (TRUE);

        case WM_HELP:
        case WM_CONTEXTMENU:
            return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapLdapAdv));

        case WM_HSCROLL:
            // Update the text beside the slider
            SetTimeoutString(GetDlgItem(hwnd, IDC_TIMEOUT_STATIC),
                             (UINT) SendMessage((HWND) lParam, TBM_GETPOS, 0, 0));

            MarkPageDirty(hwnd, PAGE_ADV);
            return (TRUE);

        case WM_COMMAND:
            code = HIWORD(wParam);
            id = LOWORD(wParam);
            fSecure = IsDlgButtonChecked(hwnd, IDC_SECURECONNECT_BUTTON);
            fSimple = IsDlgButtonChecked(hwnd, IDC_SIMPLESEARCH_BUTTON);

            switch (id)
                {
                case IDC_MATCHES_EDIT:
                case IDC_SEARCHBASE_EDIT:
                    if (code == EN_CHANGE)
                        MarkPageDirty(hwnd, PAGE_ADV);
                    break;

                case IDC_LDAP_PORT_EDIT:
                    if (code == EN_CHANGE)
                        {
                        dw = GetDlgItemInt(hwnd, IDC_LDAP_PORT_EDIT, &fTrans, FALSE);
                        EnableWindow(GetDlgItem(hwnd, IDC_USEDEFAULTS_BUTTON),
                            !fTrans || (fSecure ? (dw != DEF_SLDAPPORT) : (dw != DEF_LDAPPORT)));

                        MarkPageDirty(hwnd, PAGE_ADV);
                        }
                    break;

                case IDC_SIMPLESEARCH_BUTTON:
                case IDC_SECURECONNECT_BUTTON:
                case IDC_USEDEFAULTS_BUTTON:
                    // Reset the settings on this page to the default values.
                    SetDlgItemInt(hwnd, IDC_LDAP_PORT_EDIT, fSecure ? DEF_SLDAPPORT : DEF_LDAPPORT, FALSE);
                    EnableWindow(GetDlgItem(hwnd, IDC_USEDEFAULTS_BUTTON), FALSE);

                    MarkPageDirty(hwnd, PAGE_ADV);

                    SetFocus(GetDlgItem(hwnd, IDC_LDAP_PORT_EDIT));
                    break;
                }
            return (TRUE);

        case WM_NOTIFY:
            pnmhdr = (NMHDR *)lParam;
            switch (pnmhdr->code)
                {
                case PSN_APPLY:
                    // BEGIN validation

                    dwPort = GetDlgItemInt(hwnd, IDC_LDAP_PORT_EDIT, &fTrans, FALSE);
                    if (!fTrans || dwPort == 0)
                        {
                        hwndT = GetDlgItem(hwnd, IDC_LDAP_PORT_EDIT);
                        return(InvalidAcctProp(hwnd, hwndT, idsErrPortNum, iddDirServProp_Advanced));
                        }

                    dwMatches = GetDlgItemInt(hwnd, IDC_MATCHES_EDIT, &fTrans, FALSE);
                    if (!fTrans || dwMatches < MATCHES_MIN || dwMatches > MATCHES_MAX)
                        {
                        hwndT = GetDlgItem(hwnd, IDC_MATCHES_EDIT);
                        return(InvalidAcctProp(hwnd, hwndT, idsErrMatches, iddDirServProp_Advanced));
                        }

                    // END validation

                    pAcct->SetPropDw(AP_LDAP_PORT, dwPort);
                    pAcct->SetPropDw(AP_LDAP_SEARCH_RETURN, dwMatches);

                    dw = IsDlgButtonChecked(hwnd, IDC_SECURECONNECT_BUTTON);
                    pAcct->SetPropDw(AP_LDAP_SSL, dw);

                    dw = IsDlgButtonChecked(hwnd, IDC_SIMPLESEARCH_BUTTON);
                    pAcct->SetPropDw(AP_LDAP_SIMPLE_SEARCH, dw);

                    dw = GetTimeoutFromSlider(GetDlgItem(hwnd, IDC_TIMEOUT_SLIDER));
                    pAcct->SetPropDw(AP_LDAP_TIMEOUT, dw);

                    dw = GetWindowText(GetDlgItem(hwnd, IDC_SEARCHBASE_EDIT), sz, ARRAYSIZE(sz));
                    UlStripWhitespace(sz, TRUE, TRUE, &dw);
                    if (dw == 0)
                        pAcct->SetProp(AP_LDAP_SEARCH_BASE, NULL, 0);
                    else
                        pAcct->SetPropSz(AP_LDAP_SEARCH_BASE, sz);

                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    dw = PAGE_ADV;
                    PropSheet_QuerySiblings(GetParent(hwnd), SM_SAVECHANGES, (LPARAM)&dw);
                    if (dw == -1)
                        {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return(TRUE);
                        }
                    break;
                }
            return (TRUE);
        }

    return (FALSE);
    }

// BEGIN bug 21535

// Used for modifying propsheet template
const TCHAR c_szComctl[] = TEXT("comctl32.dll");
#define DLG_PROPSHEET 1006 // Bad hack...assumes comctl's res id

typedef struct
{
    int inumLang;
    WORD wLang;
} ENUMLANGDATA;

//
// EnumResLangProc
//
// purpose: a callback function for EnumResourceLanguages().
//          look into the type passed in and if it is RT_DIALOG
//          copy the lang of the first resource to our buffer
//          this also counts # of lang if more than one of them
//          are passed in
//
// IN:      lparam: ENUMLANGDATA - defined at the top of this file
//
BOOL CALLBACK EnumResLangProc(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName, WORD wIdLang, LPARAM lparam)
{
    ENUMLANGDATA *pel = (ENUMLANGDATA *)lparam;

    Assert(pel);

    if (lpszType == RT_DIALOG)
    {
        if (pel->inumLang == 0)
            pel->wLang = wIdLang;

        pel->inumLang++;
    }
    return TRUE;   // continue until we get all langs...
}

//
// GetDialogLang
//
// purpose: fill out the ENUMLANGDATA (see top of this file) with the
//          # of available langs in the module passed in, and the langid
//          of what system enumerates first. i.e, the langid eq. to what
//          the module localized if the module is localized in single
//          language
//
// IN:      hinstCpl - this is supposed to be a instance handle of inetcpl.
//          pel - a pointer to the buffer we fill out
//
// RESULT:  TRUE  - everything cool, continue with adjusting property sheet
//          FALSE - somethings wrong, abort adjusting property sheet.
//
BOOL GetDialogLang(HMODULE hinstCpl, ENUMLANGDATA *pel)
{
    Assert(pel);

    // Get the possible languages the template localized in.
    EnumResourceLanguages(hinstCpl, RT_DIALOG, MAKEINTRESOURCE(iddMailSvrProp_General), (ENUMRESLANGPROC)EnumResLangProc, (LPARAM)pel);

    return TRUE;
}
//
// PropSheetProc
//
// purpose: the callback function to modify resource template
//          in order to make DLG_PROPSHEET's lang mathed with ours.
//          there could be a general way but for now this is
//          an ugly hack from inetcpl.
//
//
int CALLBACK PropSheetProc (HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    LPVOID pTemplate = (LPVOID)lParam;
    LPVOID pTmpInLang;
    ENUMLANGDATA el = {0,0};
    HINSTANCE hComctl;
    HRSRC hrsrc;
    HGLOBAL hgmem;
    DWORD cbNewTmp;

    // Comm ctrl gives us a chance to recreate resource by this msg.
    if (uMsg==PSCB_PRECREATE && pTemplate)
    {
        // enumrate any possible language used in this cpl for dialogs
        if (!GetDialogLang(g_hInstRes, &el))
            return 0; // failed to get resouce name

        if (el.inumLang > 1)
        {
            // we've got multi-language templates
            // let comctl load the one that matches our thread langid.
            return 0;
        }
        if (GetSystemDefaultLangID() != el.wLang)
        {
            // Get comctl32's module handle
            hComctl = GetModuleHandle(c_szComctl);
            if (hComctl)
            {
                // this is a horrible hack because we assume DLG_PROPSHEET
                hrsrc = FindResourceEx(hComctl, RT_DIALOG, MAKEINTRESOURCE(DLG_PROPSHEET), el.wLang);
                if (hrsrc)
                {
                    if (hgmem = LoadResource(hComctl, hrsrc))
                    {
                        pTmpInLang = LockResource(hgmem);
                    }
                    if (pTmpInLang)
                    {
                        cbNewTmp = SizeofResource(hComctl, hrsrc);
                        CopyMemory(pTemplate, pTmpInLang, cbNewTmp);
                    }
                    if (hgmem && pTmpInLang)
                    {
                        UnlockResource(hgmem);
                        return 1; // everything went ok.
                    }
                }
            }
        }
    }
    return 0;
}

// END bug 21535

const static HELPMAP g_rgCtxMapSmtpAuth[] = {
                       {IDC_USEMAILSETTINGS, IDH_MAIL_OUT_SERV_SAME},
                       {IDC_ACCTNAME_STATIC, IDH_MAIL_SERV_POP3_ACCT},
                       {IDC_ACCTNAME_EDIT, IDH_MAIL_SERV_POP3_ACCT},
                       {IDC_ACCTPASS_STATIC, IDH_MAIL_SERV_PWORD},
                       {IDC_ACCTPASS_EDIT, IDH_MAIL_SERV_PWORD},
                       {IDC_LOGONSSPI_CHECK, IDH_MAIL_LOGON_USING_SICILY},
                       {IDC_REMEMBER_PASSWORD, 503},
                       {IDC_STATIC0, IDH_INETCOMM_GROUPBOX},
                       {IDC_STATIC1, IDH_INETCOMM_GROUPBOX},
                       {0, 0}};

INT_PTR CALLBACK SmtpLogonSettingsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPSMTPAUTHINFO pInfo=(LPSMTPAUTHINFO)GetWndThisPtr(hwnd);
    CHAR szUserName[CCHMAX_USERNAME];
    CHAR szPassword[CCHMAX_PASSWORD];
    BOOL fPromptPassword, fEnable;
    DWORD cbSize;
    SMTPAUTHTYPE authtype;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        // Get pInfo
        pInfo = (LPSMTPAUTHINFO)lParam;
        Assert(pInfo && pInfo->authtype != SMTP_AUTH_NONE);

        // SMTP_AUTH_SICILY
        if (SMTP_AUTH_SICILY == pInfo->authtype)
        {
            CheckDlgButton(hwnd, IDC_SPECIFYSETTINGS, BST_CHECKED);
            CheckDlgButton(hwnd, IDC_LOGONSSPI_CHECK, BST_CHECKED);
            SetDlgItemText(hwnd, IDC_ACCTNAME_EDIT, pInfo->szUserName);
            SetDlgItemText(hwnd, IDC_ACCTPASS_EDIT, pInfo->szPassword);
            EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_EDIT), !pInfo->fPromptPassword);
        }

        // SMTP_AUTH_USE_POP3ORIMAP_SETTINGS
        else if (SMTP_AUTH_USE_POP3ORIMAP_SETTINGS == pInfo->authtype)
        {
            // Check Logon Using Radio
            CheckDlgButton(hwnd, IDC_USEMAILSETTINGS, BST_CHECKED);
            EnableWindow(GetDlgItem(hwnd, IDC_LOGONSSPI_CHECK), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_ACCTNAME_EDIT), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_EDIT), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_REMEMBER_PASSWORD), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_ACCTNAME_STATIC), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_STATIC), FALSE);
        }

        // SMTP_AUTH_USE_SMTP_SETTINGS
        else if (SMTP_AUTH_USE_SMTP_SETTINGS == pInfo->authtype)
        {
            CheckDlgButton(hwnd, IDC_SPECIFYSETTINGS, BST_CHECKED);
            SetDlgItemText(hwnd, IDC_ACCTNAME_EDIT, pInfo->szUserName);
            SetDlgItemText(hwnd, IDC_ACCTPASS_EDIT, pInfo->szPassword);
            EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_EDIT), !pInfo->fPromptPassword);
        }
        else
            Assert(FALSE);

        CheckDlgButton(hwnd, IDC_REMEMBER_PASSWORD, FALSE == pInfo->fPromptPassword);

        SetWndThisPtr(hwnd, pInfo);
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapSmtpAuth));

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDC_LOGONSSPI_CHECK:
        case IDC_SPECIFYSETTINGS:
        case IDC_USEMAILSETTINGS:
            if (IsDlgButtonChecked(hwnd, IDC_SPECIFYSETTINGS))
            {
                fPromptPassword = (FALSE == IsDlgButtonChecked(hwnd, IDC_REMEMBER_PASSWORD));
                EnableWindow(GetDlgItem(hwnd, IDC_LOGONSSPI_CHECK), TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_ACCTNAME_EDIT), TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_EDIT), (FALSE == fPromptPassword));
                EnableWindow(GetDlgItem(hwnd, IDC_REMEMBER_PASSWORD), TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_ACCTNAME_STATIC), TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_STATIC), TRUE);
            }
            else if (IsDlgButtonChecked(hwnd, IDC_USEMAILSETTINGS))
            {
                EnableWindow(GetDlgItem(hwnd, IDC_LOGONSSPI_CHECK), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_ACCTNAME_EDIT), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_EDIT), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_REMEMBER_PASSWORD), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_ACCTNAME_STATIC), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_STATIC), FALSE);
            }
            break;

        case IDC_REMEMBER_PASSWORD:
            EnableWindow(GetDlgItem(hwnd, IDC_ACCTPASS_EDIT),
                IsDlgButtonChecked(hwnd, IDC_REMEMBER_PASSWORD));
            break;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            return 1;

        case IDOK:
            // SMTP_AUTH_USE_POP3ORIMAP_SETTINGS
            if (IsDlgButtonChecked(hwnd, IDC_USEMAILSETTINGS))
            {
                // No Change
                if (SMTP_AUTH_USE_POP3ORIMAP_SETTINGS != pInfo->authtype)
                {
                    pInfo->authtype = SMTP_AUTH_USE_POP3ORIMAP_SETTINGS;
                    pInfo->fDirty = TRUE;
                    EndDialog(hwnd, IDOK);
                    return 1;
                }
            }

            // Otherwise, use specified settings
            else
            {
                // Get User Name and Password
                GetDlgItemText(hwnd, IDC_ACCTNAME_EDIT, szUserName, ARRAYSIZE(szUserName));

                // Cleanup szUserName
                cbSize = lstrlen(szUserName);
                UlStripWhitespace(szUserName, TRUE, TRUE, &cbSize);
                if (cbSize == 0)
                {
                    // Error
                    AcctMessageBox(hwnd, MAKEINTRESOURCE(idsAccountManager), MAKEINTRESOURCE(idsEnterAcctName), 0, MB_ICONEXCLAMATION | MB_OK);
                    SetFocus(GetDlgItem(hwnd, IDC_ACCTNAME_EDIT));
                    return 1;
                }

                // SMTP_AUTH_SICILY
                if (IsDlgButtonChecked(hwnd, IDC_LOGONSSPI_CHECK))
                    authtype = SMTP_AUTH_SICILY;
                else
                    authtype = SMTP_AUTH_USE_SMTP_SETTINGS;

                // Get the Password
                GetDlgItemText(hwnd, IDC_ACCTPASS_EDIT, szPassword, ARRAYSIZE(szPassword));
                fPromptPassword = (FALSE == IsDlgButtonChecked(hwnd, IDC_REMEMBER_PASSWORD));

                // No Change ?
                if (authtype != pInfo->authtype ||
                    lstrcmpi(pInfo->szUserName, szUserName) != 0 ||
                    fPromptPassword != pInfo->fPromptPassword ||
                    lstrcmpi(pInfo->szPassword, szPassword) != 0)
                {
                    pInfo->authtype = authtype;
                    StrCpyN(pInfo->szUserName, szUserName, ARRAYSIZE(pInfo->szUserName));
                    StrCpyN(pInfo->szPassword, szPassword, ARRAYSIZE(pInfo->szPassword));
                    pInfo->fPromptPassword = fPromptPassword;
                    pInfo->fDirty = TRUE;
                }
            }

            EndDialog(hwnd, IDOK);
            return 1;
        }
        break;
    }
    return 0;
}

HRESULT EscapeSpaces(LPCSTR psz, LPSTR pszOut, DWORD *pcch)
    {
    LPCSTR pch;
    LPSTR pchOut;
    DWORD cch, cchOut;

    pchOut = pszOut;
    cch = *pcch;
    cchOut = 0;

    for (pch = psz; *pch; pch++)
        {
        if (*pch == ' ')
            {
            cchOut += 3;
            if (cchOut > cch)
                return(E_FAIL);
            *pchOut++ = '%';
            *pchOut++ = '2';
            *pchOut++ = '0';
            }
        else
            {
            cchOut++;
            if (cchOut > cch)
                return(E_FAIL);
            *pchOut++ = *pch;
            }
        }

    cchOut++;
    if (cchOut > cch)
        return(E_FAIL);

    *pchOut = 0;
    *pcch = cchOut;

    return(S_OK);
    }

void GetDigitalID(HWND hwnd)
{
    HRESULT hr;
    TCHAR   szName[CCHMAX_DISPLAY_NAME];
    TCHAR   szEmail[CCHMAX_EMAIL_ADDRESS];
    TCHAR   szTemp[INTERNET_MAX_URL_LENGTH];
    TCHAR   szURL[INTERNET_MAX_URL_LENGTH];
    DWORD   cchOut = ARRAYSIZE(szURL);

    PropSheet_QuerySiblings(GetParent(hwnd), MSM_GETDISPLAYNAME, (LPARAM)szName);
    PropSheet_QuerySiblings(GetParent(hwnd), MSM_GETEMAILADDRESS, (LPARAM)szEmail);

    LoadString(g_hInstRes, idsGetCertURL, szURL, ARRAYSIZE(szURL));
    wnsprintf(szTemp, ARRAYSIZE(szTemp), szURL, szName, szEmail);

    // NOTE: we shellexec iexplore.exe here NOT the default handler for http://
    //       links. We have to make sure we launch this link with IE even if
    //       netscape is the browser. see georgeh for explanation of why.
    if (SUCCEEDED(EscapeSpaces(szTemp, szURL, &cchOut)))
        ShellExecuteA(NULL, c_szOpen, c_szIexplore, szURL, NULL, SW_SHOWNORMAL);
}

DWORD DwGenerateTrustedChain(
    HWND                hwnd,
    DWORD               dwFlags,
    PCCERT_CONTEXT      pcCertToTest,
    DWORD               dwToIgnore,
    BOOL                fFullSearch,
    DWORD *             pcChain,
    PCCERT_CONTEXT **   prgChain)
{
    DWORD       dwErr = 0;
    GUID        guidAction = CERT_CERTIFICATE_ACTION_VERIFY;
    CERT_VERIFY_CERTIFICATE_TRUST trust = {0};
    WINTRUST_BLOB_INFO blob = {0};
    WINTRUST_DATA data = {0};
    IMimeBody * pBody;
    PROPVARIANT var;
    HCERTSTORE  rgCAs[3] = {0};
    HCERTSTORE *pCAs = NULL;
    HCERTSTORE hMsg = NULL;

    Assert(pcCertToTest);

    data.cbStruct = sizeof(WINTRUST_DATA);
    data.pPolicyCallbackData = NULL;
    data.pSIPClientData = NULL;
    data.dwUIChoice = WTD_UI_NONE;
    data.fdwRevocationChecks = WTD_REVOKE_NONE;
    data.dwUnionChoice = WTD_CHOICE_BLOB;
    data.pBlob = &blob;

    blob.cbStruct = sizeof(WINTRUST_BLOB_INFO);
    blob.pcwszDisplayName = NULL;
    blob.cbMemObject = sizeof(trust);
    blob.pbMemObject = (LPBYTE)&trust;

    trust.cbSize = sizeof(trust);
    trust.pccert = pcCertToTest;
    trust.dwFlags = (fFullSearch ? CERT_TRUST_DO_FULL_SEARCH : 0);
    trust.pdwErrors = &dwErr;
    trust.pszUsageOid = szOID_PKIX_KP_EMAIL_PROTECTION;
    trust.pcChain = pcChain;
    trust.prgChain = prgChain;

    trust.dwFlags |= dwFlags; 
    
    //cvct.prgdwErrors
    trust.dwIgnoreErr = dwToIgnore;
    if (pCAs)
    {
        trust.dwFlags |= CERT_TRUST_ADD_CERT_STORES;
        trust.rghstoreCAs = pCAs;
        trust.cStores = 3;
    }

    LONG lr = WinVerifyTrust(hwnd, &guidAction, (void*)&data);

    if(((LRESULT) lr) == CERT_E_REVOKED)
        dwErr = CERT_VALIDITY_CERTIFICATE_REVOKED;

    else if(((LRESULT) lr) == CERT_E_REVOCATION_FAILURE)
    {
        Assert(FALSE);
        dwErr = CERT_VALIDITY_NO_CRL_FOUND;
    }
    else if (0 > lr)            // WinVerifyTrust(hwnd, &guidAction, (void*)&data))
        dwErr = CERT_VALIDITY_NO_TRUST_DATA;

    if (dwErr)
        DOUTL(DOUTL_CRYPT, "Trust provider returned 0x%.8lx", dwErr);

    // Filter these out since the trust provider isn't.
    dwErr &= ~dwToIgnore;

    CertCloseStore(rgCAs[0], 0);
    CertCloseStore(rgCAs[1], 0);
    CertCloseStore(rgCAs[2], 0);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\deterr.h ===
#define idbDetails                      1000
#define ideDetails                      1001
#define IDS_STATIC                      -1
#define idcMessage                      1003
#define idcSplit                        1004
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\fexist.h ===
#ifndef __FILEEXITST_H
#define __FILEEXISTS_H

#define idcYesToAll                    1000
#define idcFileNameExists              1001
#define idcContainer                   1002
#define idcNo                          1003

#endif //__FILEEXISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\strconst.h ===
// --------------------------------------------------------------------------
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------
#ifndef _ACCT_STRCONST_H
#define _ACCT_STRCONST_H

#include "../mailnews/inc/strconst.h"
 
// --------------------------------------------------------------------------
// Const Strings
// --------------------------------------------------------------------------
STR_GLOBAL(c_szRegOutlook,          "Outlook");
STR_GLOBAL(c_szAcctCtxHelpFile,     "msoeacct.hlp");

STR_GLOBAL(c_szMainDll,             "msoe.dll");

STR_GLOBAL(c_szRegSharedAccts,      STR_REG_IAM_FLAT "\\Shared");
STR_GLOBAL(c_szRegAccounts,         STR_REG_IAM_FLAT "\\Accounts");
STR_GLOBAL(c_szAssocID,             "AssociatedID");
STR_GLOBAL(c_szVerStamp,            "PreConfigVer");
STR_GLOBAL(c_szVerStampNTDS,        "PreConfigVerNTDS");
STR_GLOBAL(c_szRegLDAPSrv,          "LDAP Server");
STR_GLOBAL(c_szServerID,            "Server ID");
STR_GLOBAL(c_szLDAPSrvID,           "LDAP Server ID");
STR_GLOBAL(c_szAccounts,            "Accounts");

// Keep in sync with section name in selfreg.inx
STR_GLOBAL(c_szRegHTTPDomains,      "Reg.HTTPMAIL");

// --------------------------------------------------------------------------
// Netscape import strings
// --------------------------------------------------------------------------
STR_GLOBAL(c_szRegNscp,             "Software\\Netscape\\Netscape Navigator");
STR_GLOBAL(c_szRegNscpUsers,        "Software\\Netscape\\Netscape Navigator\\Users");
STR_GLOBAL(c_szRegNscpNews,         "Software\\Netscape\\Netscape Navigator\\News");
STR_GLOBAL(c_szRegMail,             "Mail");
STR_GLOBAL(c_szRegNews,             "News");
STR_GLOBAL(c_szRegUser,             "User");
STR_GLOBAL(c_szRegServices,         "Services");
STR_GLOBAL(c_szIni,                 "ini");
STR_GLOBAL(c_szNetscape,            "Netscape");
STR_GLOBAL(c_szNscpPopServer,       "POP_Server");
STR_GLOBAL(c_szNscpSmtpServer,      "SMTP_Server");
STR_GLOBAL(c_szNNTPServer,          "NNTP_Server");
STR_GLOBAL(c_szNscpUserName,        "User_Name");
STR_GLOBAL(c_szUserAddr,            "User_Addr");
STR_GLOBAL(c_szReplyTo,             "Reply_To");
STR_GLOBAL(c_szPopName,             "POP Name");
STR_GLOBAL(c_szLeaveServer,         "Leave on server");
STR_GLOBAL(c_szNewsDirectory,       "News Directory");
STR_GLOBAL(c_szRegDirRoot,          "DirRoot");

#endif // _ACCT_STRCONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeacct\wizproc.cpp ===
#include "pch.hxx"
#include <prsht.h>
#include <imnact.h>
#include <icwacct.h>
#include <acctimp.h>
#include "icwwiz.h"
#include "acctui.h"
#include "acctman.h"
#include <dllmain.h>
#include <resource.h>
#include "server.h"
#include <Shlwapi.h>
#include "connect.h"
#include "strconst.h"
#include "demand.h"
#include "hotwiz.h"
#include "shared.h"

ASSERTDATA

// combo box indexes for the mail server page
enum 
{
    iPop3CBIndex = 0,
    iIMAPCBIndex,
    iHTTPMailCBIndex
};

#define IDD_NEXT    0x3024

LPTSTR SplitAddress(LPTSTR szEmail);

HRESULT GetMessageParams(HWND hDlg, CICWApprentice ** ppApp, LONG * pOrd, const PAGEINFO ** ppPageInfo)
{
    *ppApp = (CICWApprentice *)GetWindowLongPtr(hDlg, DWLP_USER);
    Assert(*ppApp != NULL);

    *pOrd = (long) GetWindowLongPtr(hDlg, GWLP_USERDATA);
    *ppPageInfo = &((*ppApp)->m_pPageInfo[*pOrd]);

    return S_OK;
}


/*******************************************************************

  NAME:    GenDlgProc

  SYNOPSIS:  Generic dialog proc for all wizard pages

  NOTES:    This dialog proc provides the following default behavior:
          init:    back and next buttons enabled
          next btn:  switches to page following current page
          back btn:  switches to previous page
          cancel btn: prompts user to confirm, and cancels the wizard
          dlg ctrl:   does nothing (in response to WM_COMMANDs)
        Wizard pages can specify their own handler functions
        (in the PageInfo table) to override default behavior for
        any of the above actions.

********************************************************************/
INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    DLGINITINFO *pInitInfo;
    BOOL fRet, fCancel;
    LONG style, ord;
    HWND hwndParent;
    LPPROPSHEETPAGE lpsp;
    const PAGEINFO *pPageInfo;
    CICWApprentice *pApp;
    NMHDR *lpnm;
    UINT iNextPage, idPage, idPageExt;

    fRet = TRUE;
    hwndParent = GetParent(hDlg);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // get propsheet page struct passed in
            lpsp = (LPPROPSHEETPAGE)lParam;
            Assert(lpsp != NULL);

            // fetch our private page info from propsheet struct
            pInitInfo = (DLGINITINFO *)lpsp->lParam;
            Assert(pInitInfo != NULL);

            pApp = pInitInfo->pApp;
            Assert(pApp != NULL);
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pApp);

            if (pApp->m_hDlg == NULL)
                pApp->m_hDlg = hwndParent;

            ord = pInitInfo->ord;
            Assert(ord >= 0 && ord < NUM_WIZARD_PAGES);
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)ord);

            pPageInfo = &pApp->m_pPageInfo[ord];

            // initialize 'back' and 'next' wizard buttons, if
            // page wants something different it can fix in init proc below
            PropSheet_SetWizButtons(hwndParent, PSWIZB_NEXT | PSWIZB_BACK);

            // call init proc for this page if one is specified
            if (pPageInfo->InitProc != NULL)
                {
                if (!pPageInfo->InitProc(pApp, hDlg, TRUE))
                    {
                    // send a 'cancel' message to ourselves
                    // (to keep the prop.page mgr happy)
                    pApp->m_pExt->ExternalCancel(CANCEL_SILENT);
                    }
                }
            return(FALSE);

        case WM_POSTSETFOCUS:
            SetFocus((HWND)wParam);
            break;

        case WM_ENABLENEXT:
            EnableWindow(GetDlgItem(GetParent(hDlg), IDD_NEXT), (BOOL)wParam);
            break;

        case WM_NOTIFY:
            GetMessageParams(hDlg, &pApp, &ord, &pPageInfo);
            Assert(pApp != NULL);
            Assert(ord >= ORD_PAGE_MAILPROMPT && ord <= NUM_WIZARD_PAGES);
            lpnm = (NMHDR *)lParam;

            switch (lpnm->code)
                {
                case PSN_HELP:
                    AssertSz(FALSE, "Context sensitive help should not be accessible.");
                    break;

                case PSN_SETACTIVE:
                    // initialize 'back' and 'next' wizard buttons, if
                    // page wants something different it can fix in init proc below
                    PropSheet_SetWizButtons(hwndParent, PSWIZB_NEXT | PSWIZB_BACK);

                    // call init proc for this page if one is specified
                    if (pPageInfo->InitProc != NULL)
                        {
                        // TODO: what about the return value for this????
                        pPageInfo->InitProc(pApp, hDlg, FALSE);
                        }

                    pApp->m_iCurrentPage = ord;
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    Assert((ULONG)ord == pApp->m_iCurrentPage);

                    iNextPage = INNER_DLG;
                    idPage = 0;

                    // call OK proc for this page if one is specified
                    if (pPageInfo->OKProc != NULL) 
                        {
                        if (!pPageInfo->OKProc(pApp, hDlg, (lpnm->code != PSN_WIZBACK), &iNextPage))
                            {
                            // stay on this page
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                            }
                        }

                    if (lpnm->code != PSN_WIZBACK)
                        {
                        //'next' pressed.
                        Assert(pApp->m_cPagesCompleted < NUM_WIZARD_PAGES);

                        // if no next page specified or no OK proc,
                        // advance page by one
                        if (iNextPage == EXTERN_DLG)
                            {
                            idPage = pApp->m_idNextPage;

                            idPageExt = pApp->m_pPageInfo[pApp->m_iCurrentPage].uDlgID;
                            pApp->m_pExt->SetFirstLastPage(0, idPageExt);
                            }
                        else if (iNextPage == CONNECT_DLG)
                            {
                            Assert(pApp->m_pICW != NULL);
                            Assert(0 == (pApp->m_dwFlags & ACCT_WIZ_IN_ICW));

                            idPage = pApp->m_extFirstPage;

                            idPageExt = pApp->m_pPageInfo[pApp->m_iCurrentPage].uDlgID;
                            pApp->m_pICW->SetPrevNextPage(idPageExt, 0);
                            }
                        else
                            {
                            // save the current page index in the page history,
                            pApp->m_iPageHistory[pApp->m_cPagesCompleted] = pApp->m_iCurrentPage;
                            pApp->m_cPagesCompleted++;

                            if (iNextPage == INNER_DLG)
                                iNextPage = pApp->m_iCurrentPage + 1;
                            idPage = pApp->m_pPageInfo[iNextPage].uDlgID;
                            }
                        }
                    else
                    {
                        // 'back' pressed
                        if (iNextPage == CONNECT_DLG)
                        {
                            Assert(pApp->m_pICW != NULL);
                            Assert(0 == (pApp->m_dwFlags & ACCT_WIZ_IN_ICW));

                            idPage = pApp->m_extLastPage;

                            idPageExt = pApp->m_pPageInfo[pApp->m_iCurrentPage].uDlgID;
                            pApp->m_pICW->SetPrevNextPage(0, idPageExt);
                        }
                        else if (pApp->m_cPagesCompleted > 0)
                        {
                            // get the last page from the history list
                            pApp->m_cPagesCompleted--;
                            iNextPage = pApp->m_iPageHistory[pApp->m_cPagesCompleted];
                            idPage = pApp->m_pPageInfo[iNextPage].uDlgID;

                            if (ORD_PAGE_AD_AUTODISCOVERY == iNextPage)
                            {
                                // Since the AutoDiscovery page is just for progress, 
                                // the back button should skip over it.
                                pApp->m_cPagesCompleted--;
                                iNextPage = pApp->m_iPageHistory[pApp->m_cPagesCompleted];
                                idPage = pApp->m_pPageInfo[iNextPage].uDlgID;
                            }
                        }
                        else
                        {
                            // need to back into the main wizard
                            idPage = pApp->m_idPrevPage;
                        }
                    }

                    // set next page, only if 'next' or 'back' button was pressed
                    if (lpnm->code != PSN_WIZFINISH)
                        {
                        // tell the prop sheet mgr what the next page to display is
                        Assert(idPage != 0);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, idPage);
                        }
                    break;

                case PSN_QUERYCANCEL:
                    // default behavior: tell wizard that user requested to Cancel
                    if (pApp->m_pExt != NULL)
                    {
                        fCancel = pApp->m_pExt->ExternalCancel(CANCEL_PROMPT);

                        // return the value thru window data
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, !fCancel);
                    }
                    else
                    {
                        // We need to double check that the user really wants to cancel.
                        if (IDNO == AcctMessageBox(hDlg, MAKEINTRESOURCE(idsConnectionWizard), MAKEINTRESOURCE(idsCancelWizard), NULL, MB_YESNO|MB_ICONEXCLAMATION |MB_DEFBUTTON2)) 
                        {
                            // They decided to not cancel after all.
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        }
                        else
                        {
                            // They are going to go ahead and cancel so we need to give the
                            // page a chance to clean up it's data.  Do they have a CancelProc()?
                            if (pPageInfo && pPageInfo->CancelProc != NULL)
                                pPageInfo->CancelProc(pApp, hDlg);
                        }
                    }
                    break;
                }
            break;

        case WM_COMMAND:
            GetMessageParams(hDlg, &pApp, &ord, &pPageInfo);
            Assert(pApp != NULL);
            Assert(ord >= ORD_PAGE_MAILPROMPT && ord <= NUM_WIZARD_PAGES);

            // if this page has a command handler proc, call it
            if (pPageInfo->CmdProc != NULL)
                pPageInfo->CmdProc(pApp, hDlg, wParam, lParam);
            break;

        case WM_AUTODISCOVERY_FINISHED:
        case WM_AUTODISCOVERY_STATUSMSG:
            GetMessageParams(hDlg, &pApp, &ord, &pPageInfo);
            if ((ORD_PAGE_AD_AUTODISCOVERY == ord) && (pPageInfo->WMUserProc != NULL))
            {
                pPageInfo->WMUserProc(pApp, hDlg, uMsg, wParam, lParam);
            }
            break;

        default:
            fRet = FALSE;
            break;
        }

    return(fRet);
    }

BOOL CALLBACK MailPromptInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
    {
    TCHAR sz[1024];
    HWND hwnd;

    Assert(pApp != NULL);

    hwnd = GetDlgItem(hDlg, IDC_INSTALL);

    if (fFirstInit)
        {
        LoadString(g_hInstRes, IDS_MAIL_DESC, sz, ARRAYSIZE(sz));
        SetDlgItemText(hDlg, IDC_DESC, sz);

        SendMessage(hwnd, BM_SETCHECK, BST_CHECKED, 0);
        }

    if (BST_CHECKED != SendMessage(hwnd, BM_GETCHECK, 0, 0))
        hwnd = GetDlgItem(hDlg, IDC_NOINSTALL);
    PostMessage(hDlg, WM_POSTSETFOCUS, (WPARAM)hwnd, 0);

    return(TRUE);
    }

BOOL CALLBACK MailPromptOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
    {
    ULONG cAccts;
    HRESULT hr;
    CAccountManager *pAcctMgr;

    Assert(pApp != NULL);
    Assert(ACCT_MAIL == pApp->GetAccountType());

    if (fForward)
        {
        if (BST_CHECKED != SendDlgItemMessage(hDlg, IDC_INSTALL, BM_GETCHECK, 0, 0))
            {
            pApp->SetSave(FALSE);

            *puNextPage = pApp->GetNextWizSection();
            }
        else
            {
            pAcctMgr = pApp->GetAccountManager();
            Assert(pAcctMgr != NULL);

            hr = pAcctMgr->GetAccountCount(ACCT_MAIL, &cAccts);
            Assert(!FAILED(hr));
            if (cAccts > 0)
                {
                pApp->SetSave(FALSE);

                *puNextPage = ORD_PAGE_MAILACCT;
                }
            else if (pApp->GetMigrateCount() > 0)
                {
                pApp->SetSave(TRUE);

                *puNextPage = ORD_PAGE_MIGRATE;
                }
            else
                {
                pApp->SetSave(TRUE);

                *puNextPage = ORD_PAGE_MAILNAME;
                }
            }
        }

    return(TRUE);
    }

const static int c_rgidsAcct[ACCT_LAST] = {IDS_NEWSACCT_DESC, IDS_MAILACCT_DESC, 0};
const static DWORD c_rgEnum[ACCT_LAST] = {SRV_NNTP, SRV_MAIL, SRV_LDAP};

BOOL CALLBACK AcctInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
{
    HRESULT             hr;
    int                 index;
    ACCTTYPE            type;
    HWND                hwnd, hwndList;
    BOOL                fSelected;
    IImnEnumAccounts    *pEnum;
    IImnAccount         *pAcct;
    CAccountManager     *pAcctMgr;
    char szDefAcct[CCHMAX_ACCOUNT_NAME], szBuf[1024];

    Assert(pApp != NULL);
    Assert(pApp->GetAccountType() == ACCT_MAIL || pApp->GetAccountType() == ACCT_NEWS);

    hwnd = GetDlgItem(hDlg, IDC_EXISTINGACCT);
    if (fFirstInit)
    {
        fSelected = FALSE;

        type = pApp->GetAccountType();

        Assert(c_rgidsAcct[type] != 0);
        LoadString(g_hInstRes, c_rgidsAcct[type], szBuf, ARRAYSIZE(szBuf));
        SetDlgItemText(hDlg, IDC_DESC, szBuf);

        pAcctMgr = pApp->GetAccountManager();
        Assert(pAcctMgr != NULL);

        pEnum = NULL;
        hr = pAcctMgr->Enumerate(c_rgEnum[type], &pEnum);
        if (FAILED(hr))
        {
            Assert(hr != E_NoAccounts);
            return(FALSE);
        }

        Assert(pEnum != NULL);

        hwndList = GetDlgItem(hDlg, IDC_ACCTLIST);

        *szDefAcct = 0;
        hr = pAcctMgr->GetDefaultAccountName(type, szDefAcct, ARRAYSIZE(szDefAcct));
        Assert(!FAILED(hr));

        // Populate the account list box
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
        {
            hr = pAcct->GetPropSz(AP_ACCOUNT_NAME, szBuf, ARRAYSIZE(szBuf));
            if (SUCCEEDED(hr))
            {
                index = ListBox_AddString(hwndList, szBuf);
                if (0 == lstrcmpi(szBuf, szDefAcct))
                {
                    fSelected = TRUE;
                    ListBox_SetCurSel(hwndList, index);
                }
            }

            pAcct->Release();
        }

        pEnum->Release();

        if (!fSelected)
            ListBox_SetCurSel(hwndList, 0);

        SendMessage(hwnd, BM_SETCHECK, BST_CHECKED, 0);
        pApp->SetSelection(NOSEL);
    }
        
    if (BST_CHECKED != SendMessage(hwnd, BM_GETCHECK, 0, 0))
        hwnd = GetDlgItem(hDlg, IDC_NEWACCT);
    PostMessage(hDlg, WM_POSTSETFOCUS, (WPARAM)hwnd, 0);

    return(TRUE);
}

const static UINT c_rgOrdConfirm[ACCT_LAST] =
    {
    ORD_PAGE_NEWSCONFIRM,
    ORD_PAGE_MAILCONFIRM,
    0
    };

const static UINT c_rgOrdDispName[ACCT_LAST] = 
    {
    ORD_PAGE_NEWSNAME,
    ORD_PAGE_MAILNAME,
    ORD_PAGE_LDAPINFO
    };

BOOL CALLBACK AcctOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
    {
    ACCTTYPE type;
    int index;
    HWND hwndList;
    CAccountManager *pAcctMgr;
    HRESULT hr;
    char szBuf[CCHMAX_ACCOUNT_NAME];
    CAccount *pAcct;

    Assert(pApp != NULL);
    Assert(pApp->GetAccountType() == ACCT_MAIL || pApp->GetAccountType() == ACCT_NEWS);

    if (fForward)
        {
        pAcctMgr = pApp->GetAccountManager();
        Assert(pAcctMgr != NULL);

        type = pApp->GetAccountType();

        if (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_EXISTINGACCT, BM_GETCHECK, 0, 0))
            {
            hwndList = GetDlgItem(hDlg, IDC_ACCTLIST);
            index = ListBox_GetCurSel(hwndList);

            if (index != pApp->GetSelection())
                {
                SendMessage(hwndList, LB_GETTEXT, (WPARAM)index, (LPARAM)szBuf);

                hr = pAcctMgr->FindAccount(AP_ACCOUNT_NAME, szBuf, (IImnAccount **)&pAcct);
                if (FAILED(hr))
                    {
                    // TODO: error msg please
                    return(FALSE);
                    }

                // new account so we need to reload
                hr = pApp->InitAccountData(pAcct, NULL, FALSE);
                Assert(!FAILED(hr));

                pAcct->Release();

                pApp->SetSelection(index);
                }

            if (pApp->GetComplete())
                {
                pApp->SetSave(FALSE);

                *puNextPage = c_rgOrdConfirm[type];
                Assert(*puNextPage != 0);
                }
            else
                {
                pApp->SetSave(TRUE);

                *puNextPage = c_rgOrdDispName[type];
                }
            }
        else
            {
            if (CREATENEW != pApp->GetSelection())
                {
                hr = pApp->InitAccountData(NULL, NULL, FALSE);
                Assert(!FAILED(hr));
            
                pApp->SetSave(TRUE);
                pApp->SetSelection(CREATENEW);
                }

            *puNextPage = c_rgOrdDispName[type];
            }
        }

    return(TRUE);
    }

BOOL CALLBACK AcctCmdProc(CICWApprentice *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
    {
    switch (LOWORD(wParam))
        {
        case IDC_NEWACCT:
        case IDC_EXISTINGACCT:
            if (HIWORD(wParam) == BN_CLICKED)
                EnableWindow(GetDlgItem(hDlg, IDC_ACCTLIST),
                    BST_CHECKED == SendDlgItemMessage(hDlg, IDC_EXISTINGACCT, BM_GETCHECK, 0, 0));
            break;
        }

    return(TRUE);
    }

BOOL CALLBACK NameInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
    {
    ACCTDATA *pData;
    HWND hwnd;
    DWORD dwFlags, cbSize;
    TCHAR sz[CCHMAX_DISPLAY_NAME];

    Assert(pApp != NULL);

    dwFlags = pApp->GetFlags();
    if (0 == (dwFlags & ACCT_WIZ_IN_ICW) && 0 == (dwFlags & ACCT_WIZ_MIGRATE))
    {
        // If we are using AutoDiscovery, then this isn't the first page
        // so don't disable the BACK button.
        PropSheet_SetWizButtons(GetParent(hDlg), (pApp->m_fUseAutoDiscovery ? (PSWIZB_BACK | PSWIZB_NEXT) : PSWIZB_NEXT));
    }

    hwnd = GetDlgItem(hDlg, IDC_NAME);

    if (fFirstInit || pApp->NeedToReloadPage(NAME_PAGE))
        {
        if (fFirstInit)
            {
            SetIntlFont(hwnd);
            SendMessage(hwnd, EM_LIMITTEXT, CCHMAX_DISPLAY_NAME - 1, 0);
            }

        pData = pApp->GetAccountData();
        Assert(pData != NULL);

        SetWindowText(hwnd, pData->szName);

        pApp->SetPageReloaded(NAME_PAGE);
        }

    cbSize = GetWindowText(hwnd, sz, ARRAYSIZE(sz));
    UlStripWhitespace(sz, FALSE, TRUE, &cbSize);
    PostMessage(hDlg, WM_ENABLENEXT, (WPARAM)(cbSize != 0), 0);

    return(TRUE);
    }

BOOL CALLBACK NameOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
    {
    HRESULT hr;
    ULONG cbSize;
    HWND hwnd;
    ACCTDATA *pData;
    TCHAR sz[CCHMAX_DISPLAY_NAME];

    Assert(pApp != NULL);

    if (fForward)
        {
        hwnd = GetDlgItem(hDlg, IDC_NAME);
        cbSize = GetWindowText(hwnd, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, FALSE, TRUE, &cbSize);
        if (cbSize == 0)
            return(FALSE);

        pData = pApp->GetAccountData();
        Assert(pData != NULL);
        StrCpyN(pData->szName, sz, ARRAYSIZE(pData->szName));
        }

    return(TRUE);
    }

BOOL CALLBACK NameCmdProc(CICWApprentice *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
    {
    DWORD cbSize;
    TCHAR sz[CCHMAX_DISPLAY_NAME];

    if (LOWORD(wParam) == IDC_NAME &&
        HIWORD(wParam) == EN_UPDATE)
        {
        cbSize = GetWindowText((HWND)lParam, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, FALSE, TRUE, &cbSize);
        EnableWindow(GetDlgItem(GetParent(hDlg), IDD_NEXT), (cbSize != 0));
        }

    return(TRUE);
    }

BOOL CALLBACK AddressInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
{
    ACCTDATA *pData;
    TCHAR sz[CCHMAX_STRINGRES];
    HWND hwnd;
    DWORD cbSize;

    Assert(pApp != NULL);
    Assert(pApp->GetAccountType() == ACCT_MAIL || pApp->GetAccountType() == ACCT_NEWS);

    if (pApp->m_fUseAutoDiscovery)
    {
        // We are using AutoDiscovery, so this is the first page.  Therefore,
        // disable the BACK button because there is no where to go.
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
    }

    hwnd = GetDlgItem(hDlg, IDC_ADDRESS);

    if (fFirstInit || pApp->NeedToReloadPage(ADDR_PAGE))
    {
        if (fFirstInit)
        {
            SetIntlFont(hwnd);
            SendMessage(hwnd, EM_LIMITTEXT, CCHMAX_EMAIL_ADDRESS - 1, 0);
        }

        pData = pApp->GetAccountData();
        Assert(pData != NULL);

        if (pApp->GetAccountType() == ACCT_MAIL)
        {
            HTTPMAILSERVICE *pServices;
            DWORD            dwServiceCount, i;

            dwServiceCount = pApp->CountMailServers();
            pServices = pApp->GetMailServices();

            if (dwServiceCount > 0 && pServices && (!(ACCT_WIZ_IN_ICW & pApp->GetFlags())) && (!!(ACCT_WIZ_HTTPMAIL & pApp->GetFlags())))
            {
                HWND hwndCombo;

                CheckDlgButton(hDlg, IDC_HAVEACCOUNT, !pData->fCreateNewAccount);
                CheckDlgButton(hDlg, IDC_CREATEACCOUNT, pData->fCreateNewAccount);
                EnableWindow(GetDlgItem(hDlg, IDC_ACCOUNTCOMBO), pData->fCreateNewAccount);
                EnableWindow(GetDlgItem(hDlg, IDC_ADDRESS), !pData->fCreateNewAccount);

                hwndCombo = GetDlgItem(hDlg, IDC_ACCOUNTCOMBO);
                SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);
                for (i = 0; i < dwServiceCount; i++)
                {
                    if (pServices[i].szSignupUrl)
                        SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)pServices[i].szFriendlyName);
                }
                SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);
                pData->iNewServiceIndex = 0;
            }
            else
            {
                ShowWindow(GetDlgItem(hDlg, IDC_HAVEACCOUNT), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_CREATEACCOUNT), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_ACCOUNTCOMBO), SW_HIDE);
            }
        }
        
        SetWindowText(hwnd, pData->szEmail);
        
        SendMessage(hwnd, EM_SETMODIFY, FALSE, 0);
        
        pApp->SetPageReloaded(ADDR_PAGE);
    }

    cbSize = GetWindowText(hwnd, sz, ARRAYSIZE(sz));
    UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
    PostMessage(hDlg, WM_ENABLENEXT, (WPARAM)(cbSize != 0), 0);

    return(TRUE);
}


BOOL CALLBACK AddressOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
{
    ACCTDATA    *pData;
    HRESULT     hr;
    ULONG       cbSize;
    HWND        hwnd;
    TCHAR       sz[CCHMAX_EMAIL_ADDRESS];
    BOOL        fOE;

    Assert(pApp != NULL);

    fOE = (pApp->GetFlags() & ACCT_WIZ_OE);

    if (fForward)
    {
        hwnd = GetDlgItem(hDlg, IDC_ADDRESS);
        cbSize = GetWindowText(hwnd, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
        if (cbSize == 0 && !IsDlgButtonChecked(hDlg, IDC_CREATEACCOUNT))
            return(FALSE);

        if (!IsDlgButtonChecked(hDlg, IDC_CREATEACCOUNT) && SendMessage(hwnd, EM_GETMODIFY, 0, 0))
        {
            hr = ValidEmailAddress(sz);
            if (hr != S_OK)
            {
                if (IDNO == AcctMessageBox(hDlg, MAKEINTRESOURCE(idsConnectionWizard), MAKEINTRESOURCE(idsInvalidEmailAddress), NULL, MB_YESNO|MB_ICONEXCLAMATION |MB_DEFBUTTON2))
                {
                    SendMessage(hwnd, EM_SETSEL, 0, -1);
                    SetFocus(hwnd);

                    return(FALSE);
                }
            }
            
            SendMessage(hwnd, EM_SETMODIFY, FALSE, 0);
        }


        pData = pApp->GetAccountData();
        Assert(pData != NULL);

        HTTPMAILSERVICE *pServices;
        int            iServiceCount, i;

        iServiceCount = (int)pApp->CountHTTPMailServers();
        pServices = pApp->GetHTTPMailServices();

        if (pData->fCreateNewAccount)
        {
            *puNextPage = ORD_PAGE_MAILCOMPLETE;
            pData->szEmail[0] = 0;
            pData->iNewServiceIndex = (int) SendDlgItemMessage(hDlg, IDC_ACCOUNTCOMBO, CB_GETCURSEL, 0,0);
        }
        else
        {
            int i, oldIndex;
            TCHAR   szName[MAX_PATH], szDomain[MAX_PATH];
            
            hr = ValidEmailAddressParts(sz, szName, ARRAYSIZE(szName), szDomain, ARRAYSIZE(szDomain));
            if (FAILED(hr))
            {
                return (FALSE);
            }

            StrCpyN(pData->szEmail, sz, ARRAYSIZE(pData->szEmail));
            
            oldIndex = pData->iServiceIndex;
            pData->iServiceIndex = -1;

            for (i = 0; i < iServiceCount; i ++)
            {
                if (lstrcmpi(szDomain, pServices[i].szDomain) == 0)
                {   

                    if (!fOE || (!(pData->fServerTypes & SRV_HTTPMAIL)))
                    {
                        //If its OE, we copy the entire e-mail address, coz we need domanin name with the username
                        StrCpyN(pData->szUsername, pData->szEmail, ARRAYSIZE(pData->szUsername));
                    }
                    else
                    {
                        StrCpyN(pData->szUsername, szName, ARRAYSIZE(pData->szUsername));
                    }
                    StrCpyN(pData->szSvr1, pServices[i].szRootUrl, ARRAYSIZE(pData->szSvr1));
                    StrCpyN(pData->szFriendlyServiceName, pServices[i].szFriendlyName, ARRAYSIZE(pData->szFriendlyServiceName));
                    pData->fDomainMSN = pServices[i].fDomainMSN;
                    pData->fServerTypes = SRV_HTTPMAIL;
                    pData->iServiceIndex = i;
                    break;
                }
            }
            if (oldIndex != pData->iServiceIndex)
                pApp->SetPageUnloaded(SRV_PAGE);
        }

        // Are we in the AutoDiscovery case?  And is the Passifier page turned off?
        if (pApp && (ACCT_MAIL == pApp->GetAccountType()) && pApp->m_fUseAutoDiscovery &&
            !SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_AUTODISCOVERY_PASSIFIER, FALSE, TRUE))
        {
            // Yes, so skip the passifier page.
            *puNextPage = ORD_PAGE_AD_AUTODISCOVERY;
        }
   }

    return(TRUE);
}

BOOL CALLBACK AddressCmdProc(CICWApprentice *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    DWORD cbSize;
    TCHAR sz[CCHMAX_EMAIL_ADDRESS];
    ACCTDATA *pData;


    if (LOWORD(wParam) == IDC_ADDRESS &&
        HIWORD(wParam) == EN_UPDATE)
    {
        cbSize = GetWindowText((HWND)lParam, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
        EnableWindow(GetDlgItem(GetParent(hDlg), IDD_NEXT), (cbSize != 0));
    }

    if (LOWORD(wParam) == IDC_HAVEACCOUNT || LOWORD(wParam) == IDC_CREATEACCOUNT)
    {
        pData = pApp->GetAccountData();
        pData->fCreateNewAccount = (LOWORD(wParam) == IDC_CREATEACCOUNT);
        CheckDlgButton(hDlg, IDC_HAVEACCOUNT, !pData->fCreateNewAccount);
        CheckDlgButton(hDlg, IDC_CREATEACCOUNT, pData->fCreateNewAccount);
        EnableWindow(GetDlgItem(hDlg, IDC_ACCOUNTCOMBO), pData->fCreateNewAccount);
        EnableWindow(GetDlgItem(hDlg, IDC_ADDRESS), !pData->fCreateNewAccount);

        if (LOWORD(wParam) == IDC_CREATEACCOUNT)
        {
            EnableWindow(GetDlgItem(GetParent(hDlg), IDD_NEXT), TRUE);
        }
        else if (LOWORD(wParam) == IDC_HAVEACCOUNT)
        {
            cbSize = GetDlgItemText(hDlg, IDC_ADDRESS, sz, ARRAYSIZE(sz));
            UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
            EnableWindow(GetDlgItem(GetParent(hDlg), IDD_NEXT), (cbSize != 0));
        }
    }
    return(TRUE);
}

void EnableServerFields(CICWApprentice *pApp, HWND hDlg)
{
    if (pApp->GetAccountType() != ACCT_MAIL)
        return;

    BOOL    fOther = false;
    DWORD type = (DWORD) SendDlgItemMessage(hDlg, IDC_INCOMINGMAILTYPE, CB_GETCURSEL, 0,0);

    if (iHTTPMailCBIndex == SendDlgItemMessage(hDlg, IDC_INCOMINGMAILTYPE, CB_GETCURSEL, 0,0))
    {
        if (pApp->CountHTTPMailServers() > 0)
        {
            fOther = SendDlgItemMessage(hDlg, IDC_HTTPSERVCOMBO, CB_GETCURSEL, 0,0) == (SendDlgItemMessage(hDlg, IDC_HTTPSERVCOMBO, CB_GETCOUNT, 0, 0) -1);

            ShowWindow(GetDlgItem(hDlg, IDC_HTTPSERVCOMBO), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_HTTPSERVTAG), SW_SHOW);
            EnableWindow(GetDlgItem(hDlg, IDC_INCOMINGSERVER), fOther);
        }
        EnableWindow(GetDlgItem(hDlg, IDC_SMTPSERVER), false);
        EnableWindow(GetDlgItem(hDlg, IDC_SMTP_DESC), false);
        EnableWindow(GetDlgItem(hDlg, IDC_SMTP_TAG), false);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_INCOMINGSERVER), true);
        EnableWindow(GetDlgItem(hDlg, IDC_SMTPSERVER), true);
        EnableWindow(GetDlgItem(hDlg, IDC_SMTP_DESC), true);
        EnableWindow(GetDlgItem(hDlg, IDC_SMTP_TAG), true);
        ShowWindow(GetDlgItem(hDlg, IDC_HTTPSERVCOMBO), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_HTTPSERVTAG), SW_HIDE);
    }
}

BOOL CALLBACK ServerInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
    {
    HWND hwnd, hwndT;
    ACCTDATA *pData;
    ACCTTYPE type;
    DWORD dwFlags, cbSize;
    TCHAR sz[CCHMAX_STRINGRES];
    BOOL fEnable;

    Assert(pApp != NULL);

    type = pApp->GetAccountType();
    dwFlags = pApp->GetFlags();
 
    if (type == ACCT_DIR_SERV)
    {
        Assert(0 == (dwFlags & ACCT_WIZ_IN_ICW));
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
    }

    hwnd = GetDlgItem(hDlg, IDC_INCOMINGSERVER);
    if (fFirstInit || pApp->NeedToReloadPage(SRV_PAGE))
    {
        if (fFirstInit)
        {
            SetIntlFont(hwnd);
            SendMessage(hwnd, EM_LIMITTEXT, CCHMAX_SERVER_NAME - 1, 0);
        }

        pData = pApp->GetAccountData();
        Assert(pData != NULL);

        SetWindowText(hwnd, pData->szSvr1);
        SendMessage(hwnd, EM_SETMODIFY, FALSE, 0);

        if (type == ACCT_MAIL)
        {
            hwndT = GetDlgItem(hDlg, IDC_INCOMINGMAILTYPE);
            if (fFirstInit)
            {
                LoadString(g_hInstRes, idsPOP, sz, ARRAYSIZE(sz));
                SendMessage(hwndT, CB_ADDSTRING, 0, (LPARAM)sz);
                LoadString(g_hInstRes, idsIMAP, sz, ARRAYSIZE(sz));
                SendMessage(hwndT, CB_ADDSTRING, 0, (LPARAM)sz);
                if ((!!(ACCT_WIZ_HTTPMAIL & dwFlags)) && AcctUtil_IsHTTPMailEnabled())
                {
                    // add http to the protocol list
                    LoadString(g_hInstRes, idsHTTPMail, sz, ARRAYSIZE(sz));
                    SendMessage(hwndT, CB_ADDSTRING, 0, (LPARAM)sz);

                    // change the server description to include http
                    LoadString(g_hInstRes, idsIncomingPopImapHttp, sz, ARRAYSIZE(sz));
                    SetDlgItemText(hDlg, IDC_INCOMINGSERVER_DESC, sz);
                }
            }

            if (dwFlags & ACCT_WIZ_NO_NEW_POP)
            {
                // If this flag is set, IMAP server is the only option
                Assert((pData->fServerTypes & SRV_IMAP));
                EnableWindow(hwndT, FALSE);
            }

            HTTPMAILSERVICE *pServices;
            DWORD            dwServiceCount, i;
            HWND             hwndCombo;

            dwServiceCount = pApp->CountHTTPMailServers();
            pServices = pApp->GetHTTPMailServices();
            hwndCombo = GetDlgItem(hDlg, IDC_HTTPSERVCOMBO);

            if (pServices && (dwServiceCount > 0) && (!!(ACCT_WIZ_HTTPMAIL & dwFlags)))
            {
                TCHAR   szRes[255];

                SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);
                for (i = 0; i < dwServiceCount; i++)
                {
                    SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)pServices[i].szFriendlyName);
                }
                LoadString(g_hInstRes, idsHTTPMailOther, szRes, ARRAYSIZE(szRes));
    
                SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)szRes);
            }

            if ((pData->fServerTypes & SRV_HTTPMAIL) && pServices && (dwServiceCount > 0))
            {
                if (pData->iServiceIndex >= 0)
                    SendMessage(hwndCombo, CB_SETCURSEL, pData->iServiceIndex, 0);
                else
                    SendMessage(hwndCombo, CB_SETCURSEL, SendMessage(hwndCombo, CB_GETCOUNT, 0, 0) -1, 0);
            }

            if (pData->fServerTypes & SRV_HTTPMAIL)
                SendMessage(hwndT, CB_SETCURSEL, iHTTPMailCBIndex, 0);
            else if (pData->fServerTypes & SRV_IMAP)
                SendMessage(hwndT, CB_SETCURSEL, iIMAPCBIndex, 0);
            else
                SendMessage(hwndT, CB_SETCURSEL, 0, 0);

            hwndT = GetDlgItem(hDlg, IDC_SMTPSERVER);
            if (fFirstInit)
            {
                SetIntlFont(hwndT);
                SendMessage(hwndT, EM_LIMITTEXT, CCHMAX_SERVER_NAME - 1, 0);
            }
            SetWindowText(hwndT, pData->szSvr2);
            SendMessage(hwndT, EM_SETMODIFY, FALSE, 0);
        }
        else
        {
            SendDlgItemMessage(hDlg, IDC_LOGON, BM_SETCHECK, pData->fLogon ? BST_CHECKED : BST_UNCHECKED, 0);
        }

        pApp->SetPageReloaded(SRV_PAGE);
    }
    
    EnableServerFields(pApp, hDlg);

    PostMessage(hDlg, WM_POSTSETFOCUS, (WPARAM)hwnd, 0);

    cbSize = GetWindowText(hwnd, sz, ARRAYSIZE(sz));
    UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
    fEnable = (cbSize != 0);
    if (type == ACCT_MAIL)
    {
        cbSize = GetDlgItemText(hDlg, IDC_SMTPSERVER, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
        fEnable &= ((cbSize != 0) || (SendDlgItemMessage(hDlg, IDC_INCOMINGMAILTYPE, CB_GETCURSEL, 0, 0) == iHTTPMailCBIndex));
    }
    PostMessage(hDlg, WM_ENABLENEXT, (WPARAM)fEnable, 0);

    return(TRUE);
}

static HRESULT ValidHTTPMailServerName(TCHAR *pszServerName)
{
    return ((StrCmpNIA(pszServerName, "http://", 7) == 0) ? S_OK : E_FAIL);
}


BOOL GetServer(HWND hDlg, int idcEdit, ACCTTYPE type, ACCTDATA *pData, BOOL fSmtp)
{
    HRESULT hr=S_OK;
    ULONG cbSize;
    DWORD dw;
    int idsError;
    HWND hwnd;
    TCHAR sz[CCHMAX_SERVER_NAME];

    hwnd = GetDlgItem(hDlg, idcEdit);
    cbSize = GetWindowText(hwnd, sz, ARRAYSIZE(sz));
    UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
    if (cbSize == 0)
        return(FALSE);
    else if (SendMessage(hwnd, EM_GETMODIFY, 0, 0))
        hr = ValidServerName(sz);

    if (pData->fServerTypes & SRV_HTTPMAIL)
        hr = ValidHTTPMailServerName(sz);

    if (FAILED(hr))
    {
        if (fSmtp)
            idsError = idsEnterSmtpServer;
        else if (type == ACCT_NEWS)
            idsError = idsEnterNntpServer;
        else if (type == ACCT_MAIL)
        {
            if (pData->fServerTypes & SRV_HTTPMAIL)
                idsError = idsEnterHTTPMailServer;
            else
                idsError = (pData->fServerTypes & SRV_IMAP) ? idsEnterIMAPServer : idsEnterPop3Server;
        }
        else
            idsError = idsEnterLdapServer;

        AcctMessageBox(hDlg, MAKEINTRESOURCE(idsConnectionWizard), MAKEINTRESOURCE(idsError), 0, MB_ICONEXCLAMATION | MB_OK);
        SendMessage(hwnd, EM_SETSEL, 0, -1);
        SetFocus(hwnd);

        return(FALSE);
    }

    if (hr == S_NonStandardValue)
    {
        if (fSmtp)
            idsError = idsInvalidSmtpServer;
        else if (type == ACCT_NEWS)
            idsError = idsInvalidNntpServer;
        else if (type == ACCT_MAIL)
            idsError = (pData->fServerTypes & SRV_IMAP) ? idsInvalidIMAPServer : idsInvalidPop3Server;
        else
            idsError = idsInvalidLdapServer;

        if (IDNO == AcctMessageBox(hDlg, MAKEINTRESOURCE(idsConnectionWizard), MAKEINTRESOURCE(idsError),
                                  NULL, MB_YESNO | MB_ICONEXCLAMATION  | MB_DEFBUTTON2))
        {
            SendMessage(hwnd, EM_SETSEL, 0, -1);
            SetFocus(hwnd);

            return(FALSE);
        }
    }

    StrCpyN(fSmtp ? pData->szSvr2 : pData->szSvr1, sz, (int)(fSmtp ? ARRAYSIZE(pData->szSvr2) : ARRAYSIZE(pData->szSvr1)));
    SendMessage(hwnd, EM_SETMODIFY, FALSE, 0);

    return(TRUE);
}


HRESULT CreateAccountName(CICWApprentice *pApp, ACCTDATA * pData)
{
    CAccountManager *pAcctMgr;

    if (*pData->szAcctOrig == 0)
    {
        // create a unique name for the account. use the friendly name if we've got one.
        if (*pData->szFriendlyServiceName != 0)
            StrCpyN(pData->szAcct, pData->szFriendlyServiceName, ARRAYSIZE(pData->szAcct));
        else
            StrCpyN(pData->szAcct, pData->szSvr1, ARRAYSIZE(pData->szAcct));

        pAcctMgr = pApp->GetAccountManager();
        Assert(pAcctMgr != NULL);

        pAcctMgr->GetUniqueAccountName(pData->szAcct, ARRAYSIZE(pData->szAcct));
    }

    return S_OK;
}


BOOL CALLBACK ServerOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
{
    DWORD dw;
    HWND hwnd;
    ACCTTYPE type;
    CAccountManager *pAcctMgr;
    ACCTDATA *pData;

    Assert(pApp != NULL);

    if (fForward)
    {
        type = pApp->GetAccountType();
        pData = pApp->GetAccountData();

        if (type == ACCT_MAIL)
        {
            dw = (DWORD) SendMessage(GetDlgItem(hDlg, IDC_INCOMINGMAILTYPE), CB_GETCURSEL, 0, 0);

            if (iHTTPMailCBIndex == dw)
                pData->fServerTypes = SRV_HTTPMAIL;
            else if (iIMAPCBIndex == dw)
                pData->fServerTypes = SRV_IMAP | SRV_SMTP;
            else
                pData->fServerTypes = SRV_POP3 | SRV_SMTP;
        }
        else
        {
            pData->fLogon = (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_LOGON, BM_GETCHECK, 0, 0));
        }

        if (!GetServer(hDlg, IDC_INCOMINGSERVER, type, pData, FALSE))
            return(FALSE);
        
        // if the account is not an http mail account, validate the smtp server
        if (ACCT_MAIL == type && !(pData->fServerTypes & SRV_HTTPMAIL))
        {
            if (!GetServer(hDlg, IDC_SMTPSERVER, type, pData, TRUE))
                return(FALSE);
        }

        CreateAccountName(pApp, pData);
        if (type != ACCT_MAIL && !pData->fLogon)
        {
            if (type == ACCT_DIR_SERV)
                *puNextPage = ORD_PAGE_LDAPRESOLVE;
            else
                *puNextPage = pApp->GetNextWizSection();
        }
    }


    return(TRUE);
}

BOOL CALLBACK ServerCmdProc(CICWApprentice *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    HWND hwnd;
    DWORD cbSize;
    WORD id;
    BOOL fEnable = FALSE;
    TCHAR sz[CCHMAX_SERVER_NAME];
    DWORD dwCurSel;
    BOOL fIsHTTPMail = FALSE, fIsOther;
    ACCTDATA    *pData;

    id = LOWORD(wParam);

    if (((id == IDC_INCOMINGSERVER ||
        id == IDC_SMTPSERVER) &&
        HIWORD(wParam) == EN_UPDATE) || 
        (id == IDC_INCOMINGMAILTYPE && HIWORD(wParam) == CBN_SELCHANGE))
    {
        hwnd = GetDlgItem(hDlg, IDC_INCOMINGSERVER);
        cbSize = GetWindowText(hwnd, sz, ARRAYSIZE(sz));
        UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
        fEnable = (cbSize != 0);

        if (pApp->GetAccountType() == ACCT_MAIL)
        {
            if (NULL != (hwnd = GetDlgItem(hDlg, IDC_INCOMINGMAILTYPE)))
                if (iHTTPMailCBIndex == SendMessage(hwnd, CB_GETCURSEL, 0, 0))
                    fIsHTTPMail = TRUE;

            // if we aren't creating an httpmail account, require an smtp server
            if (!fIsHTTPMail)
            {
                hwnd = GetDlgItem(hDlg, IDC_SMTPSERVER);
                cbSize = GetWindowText(hwnd, sz, ARRAYSIZE(sz));
                UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
                fEnable &= (cbSize != 0);
            }
        }

        EnableWindow(GetDlgItem(GetParent(hDlg), IDD_NEXT), fEnable);
    }

    if ( (id == IDC_INCOMINGMAILTYPE) && HIWORD(wParam) == CBN_SELCHANGE)
    {
        if (SendDlgItemMessage(hDlg, id, CB_GETCURSEL, 0, 0) == iHTTPMailCBIndex)
            SendDlgItemMessage(hDlg, IDC_HTTPSERVCOMBO, CB_SETCURSEL,SendDlgItemMessage(hDlg, IDC_HTTPSERVCOMBO, CB_GETCOUNT, 0, 0) - 1, 0); 
    }

    if ( (id == IDC_HTTPSERVCOMBO) && HIWORD(wParam) == CBN_SELCHANGE)
    {
        HTTPMAILSERVICE *pServices;

        pData = pApp->GetAccountData();
        Assert(pData);

        fIsOther = SendDlgItemMessage(hDlg, IDC_HTTPSERVCOMBO, CB_GETCURSEL, 0,0) == (SendDlgItemMessage(hDlg, IDC_HTTPSERVCOMBO, CB_GETCOUNT, 0, 0) -1);
        SendDlgItemMessage(hDlg, IDC_SMTPSERVER, WM_SETTEXT, 0,(LPARAM)"");

        pServices = pApp->GetHTTPMailServices();
        pData->iServiceIndex = (int) SendDlgItemMessage(hDlg, IDC_HTTPSERVCOMBO, CB_GETCURSEL, 0,0);
        
        if (fIsOther || NULL == pServices || (pData->iServiceIndex > (int)pApp->CountHTTPMailServers() -1))
        {
            SendDlgItemMessage(hDlg, IDC_INCOMINGSERVER, WM_SETTEXT, 0,(LPARAM)"");
            pData->iServiceIndex = -1;
            *pData->szFriendlyServiceName = 0;
            pData->fDomainMSN = FALSE;
        }
        else
        {
            SendDlgItemMessage(hDlg, IDC_INCOMINGSERVER, WM_SETTEXT, 0,(LPARAM)pServices[pData->iServiceIndex].szRootUrl);
            StrCpyN(pData->szFriendlyServiceName, pServices[pData->iServiceIndex].szFriendlyName, ARRAYSIZE(pData->szFriendlyServiceName));
            pData->fDomainMSN = pServices[pData->iServiceIndex].fDomainMSN;
        }
    }

    EnableServerFields(pApp, hDlg);

    return(TRUE);
}

void EnableLogonWindows(HWND hDlg, BOOL fEnable)
    {
    HWND hwndT;
    BOOL fPromptPassword;

    hwndT = GetDlgItem(hDlg, IDC_REMEMBER_PASSWORD);
    if (hwndT != NULL)
        {
        fPromptPassword = (BST_CHECKED != SendMessage(hwndT, BM_GETCHECK, 0, 0));
        EnableWindow(hwndT, fEnable);
        }
    else
        {
        fPromptPassword = FALSE;
        }

    EnableWindow(GetDlgItem(hDlg, IDC_LOGONSSPI), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_USERNAME), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_LBLUSERNAME), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_PASSWORD), fEnable && !fPromptPassword);
    EnableWindow(GetDlgItem(hDlg, IDC_LBLPASSWORD), fEnable);
    }

const static c_rgidLogon[ACCT_LAST] =
    {
    IDS_NEWSLOGON_DESC,
    IDS_MAILLOGON_DESC,
    IDS_LDAPLOGON_DESC
    };

BOOL CALLBACK LogonInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
{
    HWND hwnd;
    BOOL fSPA, fEnable;
    DWORD cbSize;
    TCHAR sz[1024];
    ACCTTYPE type;
    ACCTDATA *pData;
    BOOL fOE;

    Assert(pApp != NULL);

    fOE = (pApp->GetFlags() & ACCT_WIZ_OE);
    pData = pApp->GetAccountData();
    Assert(pData != NULL);

    type = pApp->GetAccountType();

    if (fFirstInit || pApp->NeedToReloadPage(LOGON_PAGE))
    {
        if (fFirstInit)
        {
            LoadString(g_hInstRes, c_rgidLogon[type], sz, ARRAYSIZE(sz));
            SetDlgItemText(hDlg, IDC_DESC, sz);
        }

        SendDlgItemMessage(hDlg, IDC_LOGONSSPI, BM_SETCHECK, pData->fSPA ? BST_CHECKED : BST_UNCHECKED, 0);
        SendDlgItemMessage(hDlg, IDC_REMEMBER_PASSWORD, BM_SETCHECK, pData->fAlwaysPromptPassword ? BST_UNCHECKED : BST_CHECKED, 0);
        EnableLogonWindows(hDlg, TRUE);

        hwnd = GetDlgItem(hDlg, IDC_USERNAME);
        if (fFirstInit)
        {
            SetIntlFont(hwnd);
            SendMessage(hwnd, EM_LIMITTEXT, CCHMAX_USERNAME - 1, 0);
        }
        SetWindowText(hwnd, pData->szUsername);
        if (type != ACCT_DIR_SERV &&
            *pData->szUsername == 0 &&
            *pData->szEmail != 0)
        {
            StrCpyN(sz, pData->szEmail, ARRAYSIZE(sz));

            SplitAddress(sz);

            if (*sz != 0)
                SetWindowText(hwnd, sz);
        }

        hwnd = GetDlgItem(hDlg, IDC_PASSWORD);
        if (fFirstInit)
            SendMessage(hwnd, EM_LIMITTEXT, CCHMAX_PASSWORD - 1, 0);
        SetWindowText(hwnd, pData->szPassword);

        pApp->SetPageReloaded(LOGON_PAGE);

        if (!(pData->fServerTypes & SRV_HTTPMAIL))
        {
            ShowWindow(GetDlgItem(hDlg, IDC_ACCOUNTNAME_EXAMPLE), SW_HIDE);
        }
    }

    fSPA = (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_LOGONSSPI, BM_GETCHECK, 0, 0));

    hwnd = GetDlgItem(hDlg, IDC_USERNAME);
    SendMessage(hwnd, EM_SETSEL, 0, -1);
    cbSize = GetWindowText(hwnd, sz, ARRAYSIZE(sz));                    
    UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
    if (fOE)
        fEnable = (cbSize != 0);
    else
        fEnable = TRUE;

    PostMessage(hDlg, WM_POSTSETFOCUS, (WPARAM)hwnd, 0);
    PostMessage(hDlg, WM_ENABLENEXT, (WPARAM)fEnable, 0);

    return(TRUE);
}

BOOL CALLBACK LogonOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
{
    HWND hwnd;
    ACCTDATA *pData;
    ACCTTYPE type;
    ULONG cbSize;
    TCHAR sz[CCHMAX_USERNAME];

    Assert(pApp != NULL);

    if (fForward)
    {
        BOOL fOE = (pApp->GetFlags() & ACCT_WIZ_OE);

        pData = pApp->GetAccountData();
        Assert(pData != NULL);

        pData->fSPA = (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_LOGONSSPI, BM_GETCHECK, 0, 0));

        type = pApp->GetAccountType();

        hwnd = GetDlgItem(hDlg, IDC_USERNAME);
        cbSize = GetWindowText(hwnd, sz, ARRAYSIZE(sz));                    
        UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
        if (fOE && cbSize == 0)
            return(FALSE);

        if (fOE && (!!(pData->fServerTypes & SRV_HTTPMAIL)))
        {
            //Need to verify if the domain name is entered, only for OE and HOTMAIL.
            if (ValidEmailAddressParts(sz, NULL, 0, NULL, 0) != S_OK)
            {
                if (IDNO == AcctMessageBox(hDlg, MAKEINTRESOURCE(idsAccountManager), 
                                           MAKEINTRESOURCE(idsAccountNameErr), NULL, MB_YESNO))
                    goto exit;
            }
        }

        StrCpyN(pData->szUsername, sz, ARRAYSIZE(pData->szUsername));

        cbSize = GetDlgItemText(hDlg, IDC_PASSWORD, sz, ARRAYSIZE(sz));                    
        StrCpyN(pData->szPassword, sz, ARRAYSIZE(pData->szPassword));

        pData->fAlwaysPromptPassword = !IsDlgButtonChecked(hDlg, IDC_REMEMBER_PASSWORD);

        if (type == ACCT_NEWS || type == ACCT_MAIL)
            *puNextPage = pApp->GetNextWizSection();
    }

exit:

    return(TRUE);
}

BOOL CALLBACK LogonCmdProc(CICWApprentice *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
    {
    DWORD cbSize;
    TCHAR sz[CCHMAX_USERNAME];
    BOOL fEnable = TRUE;

    switch (LOWORD(wParam))
        {
        case IDC_LOGONSSPI:
            EnableLogonWindows(hDlg, TRUE);
            // fall through...

        case IDC_USERNAME:
            if (fEnable)
                {
                BOOL fOE = (pApp->GetFlags() & ACCT_WIZ_OE);
                BOOL fSPA = (IsDlgButtonChecked(hDlg, IDC_LOGONSSPI));

                if (fOE)
                    {
                    cbSize = GetDlgItemText(hDlg, IDC_USERNAME, sz, ARRAYSIZE(sz));                    
                    UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
                    fEnable = (cbSize != 0);
                    }
                }
            else
                {
                fEnable = TRUE;
                }
            EnableWindow(GetDlgItem(GetParent(hDlg), IDD_NEXT), fEnable);
            break;

        case IDC_REMEMBER_PASSWORD:
            fEnable = (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_REMEMBER_PASSWORD, BM_GETCHECK, 0, 0));
            EnableWindow(GetDlgItem(hDlg, IDC_PASSWORD), fEnable);
            break;
        }

    return(TRUE);
    }

BOOL CALLBACK ResolveInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
    {
    ACCTDATA *pData;
    HWND hwnd;

    Assert(pApp != NULL);

    pData = pApp->GetAccountData();
    Assert(pData != NULL);

    if (fFirstInit || pApp->NeedToReloadPage(RESOLVE_PAGE))
        {
        SendDlgItemMessage(hDlg, IDC_RESOLVE, BM_SETCHECK,
            pData->fResolve ? BST_CHECKED : BST_UNCHECKED, 0);
        SendDlgItemMessage(hDlg, IDC_NORESOLVE, BM_SETCHECK,
            !pData->fResolve ? BST_CHECKED : BST_UNCHECKED, 0);

        pApp->SetPageReloaded(RESOLVE_PAGE);
        }

    hwnd = GetDlgItem(hDlg, pData->fResolve ? IDC_RESOLVE : IDC_NORESOLVE);
    PostMessage(hDlg, WM_POSTSETFOCUS, (WPARAM)hwnd, 0);

    return(TRUE);
    }

BOOL CALLBACK ResolveOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
    {
    ACCTDATA *pData;

    Assert(pApp != NULL);

    if (fForward)
        {
        pData = pApp->GetAccountData();
        Assert(pData != NULL);
        pData->fResolve = (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_RESOLVE, BM_GETCHECK, 0, 0));
        }

    return(TRUE);
    }

BOOL CALLBACK ConnectInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
    {
    HWND hwnd;
    TCHAR sz[CCHMAX_STRINGRES];
    ACCTDATA *pData;

    Assert(pApp != NULL);
    Assert(pApp->GetAccountType() == ACCT_MAIL || pApp->GetAccountType() == ACCT_NEWS);

    if (fFirstInit || pApp->NeedToReloadPage(CONNECT_PAGE))
        {
        pData = pApp->GetAccountData();
        Assert(pData != NULL);
        ConnectPage_InitDialog(hDlg, pData->szConnectoid, NULL, pData->dwConnect, fFirstInit);

        pApp->SetPageReloaded(CONNECT_PAGE);
        }

    return(TRUE);
    }

BOOL CALLBACK ConnectOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
    {
    int iSel;
    HWND hwnd;
    ACCTDATA *pData;

    Assert(pApp != NULL);

    if (fForward)
        {
        pData = pApp->GetAccountData();
        Assert(pData != NULL);

        if (IsDlgButtonChecked(hDlg, idcRas))
            {
            hwnd = GetDlgItem(hDlg, idcRasConnection);
            iSel = ComboBox_GetCurSel(hwnd);
            if (iSel == CB_ERR)
                {
                AcctMessageBox(hDlg, MAKEINTRESOURCE(idsConnectionWizard), MAKEINTRESOURCE(idsErrChooseConnection), 0, MB_ICONEXCLAMATION | MB_OK);
                SetFocus(hwnd);
                return(FALSE);
                }

            pData->dwConnect = CONNECTION_TYPE_RAS;
            ComboBox_GetLBText(hwnd, iSel, pData->szConnectoid);
            }
        else if (IsDlgButtonChecked(hDlg, idcLan))
            pData->dwConnect = CONNECTION_TYPE_LAN;
        else if (IsDlgButtonChecked(hDlg, idcManual))
            pData->dwConnect = CONNECTION_TYPE_MANUAL;
        }

    return(TRUE);
    }

BOOL CALLBACK ConnectCmdProc(CICWApprentice *pApp, HWND hDlg, WPARAM wParam, LPARAM lParam)
    {
    ConnectPage_WMCommand(hDlg, GET_WM_COMMAND_HWND(wParam, lParam),
                                GET_WM_COMMAND_ID(wParam, lParam),
                                GET_WM_COMMAND_CMD(wParam, lParam),
                                NULL);

    return(TRUE);
    }

BOOL CALLBACK CompleteInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
{
    ACCTDATA *pData;
    TCHAR    sz[MAX_PATH];

    pData = pApp->GetAccountData();
    Assert(pData != NULL);

    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH | PSWIZB_BACK);

    LoadString(g_hInstRes,pData->fCreateNewAccount ? idsHTTPCreateFinishTag : idsNormalFinishTag, sz, ARRAYSIZE(sz));
    SendDlgItemMessage(hDlg, IDC_FINISH_TITLE, WM_SETTEXT, 0, (LPARAM)sz);
    LoadString(g_hInstRes, pData->fCreateNewAccount ? idsHTTPCreateFinishMsg : idsNormalFinishMsg, sz, ARRAYSIZE(sz));
    SendDlgItemMessage(hDlg, IDC_FINISH_MSG, WM_SETTEXT, 0, (LPARAM)sz);

    return(TRUE);
}

BOOL CALLBACK CompleteOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
{
    ACCTDATA *pData;
    HRESULT hr;
    DWORD dw;
    CONNECTINFO info;
    IAccountImport2 *pImp2;
    INewsGroupImport *pNews;
    IICWApprentice *pICW;

    Assert(pApp != NULL);

    pICW = pApp->GetICW();

    if (fForward)
    {
        pData = pApp->GetAccountData();
        Assert(pData != NULL);

        if (pData->fCreateNewAccount)
        {
            HTTPMAILSERVICE *pServices;
            int            iServiceCount, i;

            iServiceCount = (int)pApp->CountMailServers();
            pServices = pApp->GetMailServices();

            if (pData->iNewServiceIndex < iServiceCount && pServices[pData->iNewServiceIndex].szSignupUrl)
            {
                if (pServices[pData->iNewServiceIndex].fUseWizard)
                {
                    RECT            rc;
                    IHotWizardHost  *pHost = NULL;
                    HKEY            hkey;
                    TCHAR           rgchGUID[MAX_PATH];
                    LPWSTR          pszGuidW;
                    IID             iidOutlookHost;
                    ULONG           cb;
                    DWORD           type;

                    if (pApp->GetFlags() & ACCT_WIZ_OUTLOOK)
                    {
                        // if we are running in Outlook Mode, then CoCreate their IHotWizHost
                        // so that they can substitute an INS file parser
                        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, STR_REG_IAM_FLAT, 0, KEY_QUERY_VALUE, &hkey))
                        {
                            cb = MAX_PATH;
                            *rgchGUID = NULL;
                            
                            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szOutlookHotWizHost, NULL, &type, (LPBYTE)rgchGUID, &cb) && *rgchGUID)
                            {
                                pszGuidW = PszToUnicode(CP_ACP, rgchGUID);
                                if (pszGuidW)
                                {
                                    if (!FAILED(IIDFromString(pszGuidW, &iidOutlookHost)))
                                    {
                                        CoCreateInstance(iidOutlookHost, NULL, CLSCTX_INPROC_SERVER, IID_IHotWizardHost, (LPVOID*)&pHost);
                                    }
                                    MemFree(pszGuidW);
                                }
                                RegCloseKey(hkey);
                            }
                        }
                    }    

                    GetWindowRect(GetParent(hDlg), &rc);
                    DoHotMailWizard(GetParent(hDlg), pServices[pData->iNewServiceIndex].szSignupUrl, 
                                          pServices[pData->iNewServiceIndex].szFriendlyName, &rc, pHost);
                                          
                    ReleaseObj(pHost);
                }
                else
                {
                    ShellExecute(hDlg, "open", pServices[pData->iNewServiceIndex].szSignupUrl, NULL, NULL, SW_SHOWNORMAL);
                }
            }
        }
        else
        {
            if (pICW != NULL)
            {
                hr = pICW->Save(hDlg, &dw);
                if (FAILED(hr))
                    return(FALSE);
            
                info.cbSize = sizeof(CONNECTINFO);
                hr = pICW->GetConnectionInformation(&info);
                if (SUCCEEDED(hr))
                {
                    pData->dwConnect = info.type;
                    if (info.type == CONNECT_RAS)
                        StrCpyN(pData->szConnectoid, info.szConnectoid, ARRAYSIZE(pData->szConnectoid));
                }
            }
            else
            {
                //ICW is null.
                if (pApp->IsInternetConnection())
                {
                    pData->dwConnect = CONNECTION_TYPE_INETSETTINGS;
                }

            }

            hr = pApp->SaveAccountData(NULL, FALSE);
            Assert(!FAILED(hr));

            // Import the list of subscribed newsgroups after having created the newsgroup account.
            if (pApp->GetAccountType() == ACCT_NEWS &&
                pApp->m_fMigrate &&
                pApp->m_cMigInfo > 0)
            {
                Assert(pApp->m_iMigInfo >= 0 && pApp->m_iMigInfo < pApp->m_cMigInfo);

                pImp2 = pApp->m_pMigInfo[pApp->m_iMigInfo].pImp2;

                if (SUCCEEDED(CreateNewsObject((void **)&pNews)))
                {
                    if (SUCCEEDED(pNews->Initialize(pData->pAcct)))
                    {
                        pImp2->GetNewsGroup(pNews, 0);
                    }

                    pNews->Release();
                }
            }
        }
    }
    else if (pICW != NULL && !pApp->GetSkipICW())
    {
        *puNextPage = CONNECT_DLG;
    }

    return(TRUE);
}

BOOL CALLBACK MigrateInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
    {
    HWND hwnd, hwndList;
    int i, index;
    MIGRATEINFO *pMigInfo;

    Assert(pApp != NULL);
    Assert(pApp->GetAccountType() == ACCT_MAIL || pApp->GetAccountType() == ACCT_NEWS);

    if (0 == (pApp->GetFlags() & ACCT_WIZ_IN_ICW))
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);

    hwnd = GetDlgItem(hDlg, IDC_EXISTINGACCT);

    if (fFirstInit)
        {
        Assert(pApp->GetSave() || 0 == (pApp->GetFlags() & ACCT_WIZ_IN_ICW));

        if (hwnd != NULL)
            SendMessage(hwnd, BM_SETCHECK, BST_CHECKED, 0);

        hwndList = GetDlgItem(hDlg, IDC_ACCTLIST);
        pMigInfo = pApp->m_pMigInfo;
        for (i = 0; i < pApp->m_cMigInfo; i++, pMigInfo++)
            {
            index = ListBox_AddString(hwndList, pMigInfo->szDisplay);
            SendMessage(hwndList, LB_SETITEMDATA, (WPARAM)index, (LPARAM)i);
            }

        ListBox_SetCurSel(hwndList, 0);
        }

    if (hwnd != NULL)
        {
        if (BST_CHECKED != SendMessage(hwnd, BM_GETCHECK, 0, 0))
            hwnd = GetDlgItem(hDlg, IDC_NEWACCT);
        PostMessage(hDlg, WM_POSTSETFOCUS, (WPARAM)hwnd, 0);
        }

    return(TRUE);
    }

BOOL CALLBACK MigrateOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
    {
    int index;
    HWND hwndList, hwndBtn;
    HRESULT hr;

    Assert(pApp != NULL);
    Assert(pApp->GetAccountType() == ACCT_MAIL || pApp->GetAccountType() == ACCT_NEWS);

    if (fForward)
        {
        Assert(pApp->GetSave() || 0 == (pApp->GetFlags() & ACCT_WIZ_IN_ICW));

        hwndBtn = GetDlgItem(hDlg, IDC_EXISTINGACCT);
        if (hwndBtn == NULL || BST_CHECKED == SendMessage(hwndBtn, BM_GETCHECK, 0, 0))
            {
            hwndList = GetDlgItem(hDlg, IDC_ACCTLIST);
            index = ListBox_GetCurSel(hwndList);
            index = (int) SendMessage(hwndList, LB_GETITEMDATA, (WPARAM)index, 0);
            Assert(index < (int)pApp->GetMigrateCount());

            hr = pApp->HandleMigrationSelection(index, puNextPage, hDlg);
            if (FAILED(hr))
                return(FALSE);
            }
        else
            {
            hr = pApp->InitAccountData(pApp->m_pAcct, NULL, FALSE);
            Assert(!FAILED(hr));

            pApp->m_iMigInfo = -1;

            *puNextPage = c_rgOrdDispName[pApp->GetAccountType()];
            }
        }

    return(TRUE);
    }

BOOL CALLBACK SelectInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
    {
    HWND hwndList;
    int index;
    IAccountImport *pImp;
    HRESULT hr;
    IEnumIMPACCOUNTS *pEnum;
    IMPACCOUNTINFO impinfo;

    Assert(pApp != NULL);
    Assert(pApp->GetAccountType() == ACCT_MAIL || pApp->GetAccountType() == ACCT_NEWS);

    if (!!(pApp->GetFlags() & ACCT_WIZ_IMPORT_CLIENT))
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);

    if (fFirstInit || pApp->NeedToReloadPage(SELECT_PAGE))
        {
        pImp = pApp->m_pMigInfo[pApp->m_iMigInfo].pImp;

        hwndList = GetDlgItem(hDlg, IDC_ACCTLIST);
        SendMessage(hwndList, LB_RESETCONTENT, 0, 0);

        if (SUCCEEDED(hr = pImp->EnumerateAccounts(&pEnum)))
            {
            while (S_OK == pEnum->Next(&impinfo))
                {
                index = ListBox_AddString(hwndList, impinfo.szDisplay);
                SendMessage(hwndList, LB_SETITEMDATA, (WPARAM)index, (LPARAM)impinfo.dwCookie);
                }

            ListBox_SetCurSel(hwndList, 0);

            pEnum->Release();
            }

        pApp->SetSelection(NOSEL);

        pApp->SetPageReloaded(SELECT_PAGE);
        }

    return(TRUE);
    }

BOOL CALLBACK SelectOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
    {
    int index;
    HRESULT hr;
    DWORD_PTR dwCookie;
    HWND hwndList;
    ACCTTYPE type;

    Assert(pApp != NULL);
    Assert(pApp->m_cMigInfo > 0);

    if (fForward)
        {
        type = pApp->GetAccountType();

        hwndList = GetDlgItem(hDlg, IDC_ACCTLIST);

        index = ListBox_GetCurSel(hwndList);

        if (index != pApp->GetSelection())
            {
            dwCookie = (DWORD_PTR) SendMessage(hwndList, LB_GETITEMDATA, (WPARAM)index, 0);

            hr = pApp->InitializeImportAccount(hDlg, dwCookie);
            if (FAILED(hr))
                {
                // TODO: error message
                return(FALSE);
                }
                
            pApp->SetSelection(index);
            }

        if (type == ACCT_MAIL)
            {
            if (pApp->GetComplete())
                *puNextPage = ORD_PAGE_MAILCONFIRM;
            else
                *puNextPage = ORD_PAGE_MAILNAME;
            }
        else
            {
            if (pApp->GetComplete())
                *puNextPage = ORD_PAGE_NEWSCONFIRM;
            else
                *puNextPage = ORD_PAGE_NEWSNAME;
            }
        }

    return(TRUE);
    }

BOOL CALLBACK ConfirmInitProc(CICWApprentice *pApp, HWND hDlg, BOOL fFirstInit)
    {
    HWND hwnd;
    ACCTDATA *pData;
    TCHAR sz[CCHMAX_STRINGRES], szT[CCHMAX_STRINGRES];

    Assert(pApp != NULL);
    Assert(pApp->GetAccountType() == ACCT_MAIL || pApp->GetAccountType() == ACCT_NEWS);

    if (!!(pApp->GetFlags() & ACCT_WIZ_IMPORT_CLIENT))
        {
        Assert(pApp->m_cMigInfo == 1);
        Assert(pApp->m_iMigInfo == 0);
        Assert(pApp->m_pMigInfo[0].cAccts >= 1);

        if (pApp->m_pMigInfo[0].cAccts == 1)
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
        }

    hwnd = GetDlgItem(hDlg, IDC_NOMODIFYACCT);

    if (fFirstInit || pApp->NeedToReloadPage(CONFIRM_PAGE))
        {
        Assert(pApp->GetComplete());

        pData = pApp->GetAccountData();
        Assert(pData != NULL);

        SendMessage(hwnd, BM_SETCHECK, BST_CHECKED, 0);
        SendDlgItemMessage(hDlg, IDC_MODIFYACCT, BM_SETCHECK, BST_UNCHECKED, 0);

        SetDlgItemText(hDlg, IDC_SVR_STATIC, pData->szSvr1);

        if (pData->fLogon)
            {
            if (pData->szUsername[0] != 0)
                {
                StrCpyN(sz, pData->szUsername, ARRAYSIZE(sz));
                }
            else
                {
                Assert(pData->fSPA);
                LoadString(g_hInstRes, idsLogonUsingSPA, sz, ARRAYSIZE(sz));
                }
            }
        else
            {
            LoadString(g_hInstRes, idsNoLogonRequired, sz, ARRAYSIZE(sz));
            }
        SetDlgItemText(hDlg, IDC_USERNAME_STATIC, sz);

        SetDlgItemText(hDlg, IDC_NAME_STATIC, pData->szName);
        SetDlgItemText(hDlg, IDC_ADDRESS_STATIC, pData->szEmail);

        if (pApp->GetAccountType() == ACCT_MAIL)
            SetDlgItemText(hDlg, IDC_SMTP_STATIC, pData->szSvr2);

        if (pData->dwConnect == CONNECTION_TYPE_RAS)
            {
            LoadString(g_hInstRes, idsConnectionRAS, szT, ARRAYSIZE(szT));
            wnsprintf(sz, ARRAYSIZE(sz), szT, pData->szConnectoid);
            }
        else if (pData->dwConnect == CONNECTION_TYPE_MANUAL)
            {
            LoadString(g_hInstRes, idsConnectionManual, sz, ARRAYSIZE(sz));
            }
        else if (pData->dwConnect == CONNECTION_TYPE_INETSETTINGS)
            {
            LoadString(g_hInstRes, idsConnectionInetSettings, sz, ARRAYSIZE(sz));
            }
        else
            {
            Assert(pData->dwConnect == CONNECTION_TYPE_LAN);
            LoadString(g_hInstRes, idsConnectionLAN, sz, ARRAYSIZE(sz));
            }
        SetDlgItemText(hDlg, IDC_CONNECTION_STATIC, sz);

        pApp->SetPageReloaded(CONFIRM_PAGE);
        }

    if (BST_CHECKED != SendMessage(hwnd, BM_GETCHECK, 0, 0))
        hwnd = GetDlgItem(hDlg, IDC_MODIFYACCT);
    PostMessage(hDlg, WM_POSTSETFOCUS, (WPARAM)hwnd, 0);

    return(TRUE);
    }

BOOL CALLBACK ConfirmOKProc(CICWApprentice *pApp, HWND hDlg, BOOL fForward, UINT *puNextPage)
    {
    Assert(pApp != NULL);
    Assert(pApp->GetAccountType() == ACCT_MAIL || pApp->GetAccountType() == ACCT_NEWS);

    if (fForward)
        {
        if (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_NOMODIFYACCT, BM_GETCHECK, 0, 0))
            {
            if (!!(pApp->GetFlags() & ACCT_WIZ_IN_ICW))
                {
                *puNextPage = EXTERN_DLG;
                }
            else
                {
                *puNextPage = (pApp->GetAccountType() == ACCT_MAIL) ? ORD_PAGE_MAILCOMPLETE : ORD_PAGE_NEWSCOMPLETE;
                pApp->SetSkipICW(TRUE);
                }
            }
        else
            {
            pApp->SetSave(TRUE);
            
            *puNextPage = c_rgOrdDispName[pApp->GetAccountType()];
            pApp->SetSkipICW(FALSE);
            }
        }

    return(TRUE);
    }

LPTSTR SplitAddress(LPTSTR szEmail)
{
    Assert(szEmail != NULL);

    while (*szEmail != 0)
    {
        if (!IsDBCSLeadByte(*szEmail) && *szEmail == TEXT('@'))
        {
            *szEmail = 0;
            szEmail++;
            return(szEmail);
        }

        szEmail = CharNext(szEmail);
    }

    return(NULL);
}

HRESULT CreateNewsObject(void **pNews)
    {
    CNewsGroupImport *pTemp;
    
    Assert(pNews);

    *pNews = NULL;

    pTemp = new CNewsGroupImport;
    if (pTemp == NULL)
        return(E_OUTOFMEMORY);

    *pNews = (void *)pTemp;

    return(S_OK);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\mapidlg.h ===
#define IDC_TO_TEXT         1001
#define IDC_SUBJECT_TEXT    1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\makefile.inc ===
ATHENA_RC_DEPENDS = dot.gif                 \
                    hotmail.gif             \
                    infobeat.gif            \
                    verisign.gif            \
                    digsig.gif              \
                    encrypt.gif             \
                    $(O)\frntpage.htm       \
                    $(O)\inline.htm         \
                    $(O)\secwarn1.htm       \
                    $(O)\secwarn2.htm       \
                    $(O)\secrec.htm         \
                    $(O)\srecerr.htm        \
                    $(O)\srsentit.htm       \
                    $(O)\recerr2.htm        \
                    $(O)\recerr3.htm        \
                    $(O)\sighelp.htm        \
                    $(O)\enchelp.htm        \
                    $(O)\sandehlp.htm       \
                    $(O)\servpage.htm       \
                    $(O)\ticker.htm         \
                    $(O)\welcome.htm        \
                    $(O)\welcome2.htm       \
                    $(O)\frntnews.htm       \
                    fldrprop.dlg            \
                    newfldr.dlg             \
                    xputil.dlg              \
                    grplist.dlg             \
                    order.dlg               \
                    pickgrp.dlg             \
                    subscr.dlg              \
                    spoolui.dlg             \
                    certerr.dlg             \
                    deterr.dlg              \
                    findmsg.dlg             \
                    framedlg.dlg            \
                    inetmail.dlg            \
                    insfile.dlg             \
                    langpref.dlg            \
                    mailfldr.dlg            \
                    msgprop.dlg             \
                    options.dlg             \
                    para.dlg                \
                    passdlg.dlg             \
                    print.dlg               \
                    progress.dlg            \
                    ras.dlg                 \
                    rules.dlg               \
                    secwarn.dlg             \
                    spell.dlg               \
                    spooler.dlg             \
                    timeout.dlg             \
                    uidlerr.dlg             \
                    statwiz.dlg             \
                    badlg.dlg	            \
                    msoeres.rcv             \
                    16x16.bmp               \
                    16x16st.bmp             \
                    oesplash.bmp            \
                    hdrbtn.bmp              \
                    messtate.bmp            \
                    folders.bmp             \
                    folder32.bmp            \
                    spooler.bmp             \
                    brand38.bmp             \
                    brand26.bmp             \
                    brand22.bmp             \
                    tbdeflo.bmp             \
                    tbhotlo.bmp             \
                    tbdefhi.bmp             \
                    tbhothi.bmp             \
                    tbdef16.bmp             \
                    tbhot16.bmp             \
                    options.bmp	            \
                    rules.bmp               \
                    genmail.ico             \
                    newsbook.ico            \
                    keys.ico                \
                    newssvr.ico             \
                    newsgrp.ico             \
                    fileatt.ico             \
                    message.ico             \
                    default.ico             \
                    m_sent.ico              \
                    m_unsent.ico            \
                    error.ico               \
                    n_post.ico              \
                    n_unpost.ico            \
                    phone.ico               \
                    newmail.ico             \
                    pickrec.ico             \
                    folder.ico              \
                    dlnews.ico              \
                    secure.ico              \
                    nosecure.ico            \
                    s&r.ico                 \
                    window.ico              \
                    toolbar.ico             \
                    prepane.ico             \
                    offline.ico             \
                    inbox.avi               \
                    outbox.avi              \
                    DLGroups.avi            \
                    decode.avi              \
                    mini-in.avi             \
                    mini-out.avi            \
                    compact.avi             \
                    dlnews.avi              \
                    filecopy.avi            \
                    splithz.cur             \
                    splitvt.cur             \
                    hand.cur                \
                    pagerror.gif            \
                    $(O)\msgoff.htm         \
                    $(O)\expired.htm        \
                    $(O)\dlcancel.htm       \
                    $(O)\diskfull.htm       \
                    $(O)\notdown.htm        \
                    $(O)\genfail.htm        \
                    $(O)\mailbomb.htm       \
                    oelogo1.gif             \
                    oelogo2.gif             \
                    close.gif               \
                    closeup.gif             \
                    bodybg.jpg              \
                    $(O)\fldrfail.htm       \
                    oestyle.css             \
    	            $(O)\smime.htm          \
                    $(O)\denied.htm         \
                    example.eml             \
                    oelogo.gif              \
                    pmhead.gif              \
                    resource.h              

$O\msoeres.res : $(ATHENA_RC_DEPENDS)

.SUFFIXES: .htx

$(O)\frntpage.htm : dlg.pl
        -del *.htm
        perl dlg.pl < frntpage.htx >$@

.htx{$(O)}.htm:
        perl dlg.pl < $** >$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\impdlg.h ===
#ifndef _INC_IMPDLG_H
#define _INC_IMPDLG_H

#define IDC_IMPORTALL_RADIO             1000
#define IDC_SELECT_RADIO                1001
#define IDC_IMPFOLDER_LISTVIEW          1002
#define IDC_IMPFOLDER_EDIT              1003
#define IDC_SELECTFOLDER_BUTTON         1004
#define IDC_NEWIMPFOLDER_EDIT           1005
#define IDC_SKIPFOLDER_BUTTON           1008
#define IDC_ERROR_STATIC                1009
#define IDC_IMPORT_COMBO                1010
#define IDC_CMD_STATIC                  1011
#define IDC_IMPORT_PROGRESS             1012
#define IDC_MESSAGE_STATIC              1014
#define idcClientsListbox               1015
#define idcMessagesCheck                1016
#define idcAddrBookCheck                1017
#define IDC_LOCATION_STATIC             1018
#define IDC_USERLIST                    1020
#define IDC_BUTT1                       1021
#define IDC_EDT1                        1022
#define IDC_IMPORT_RADIO                1023
#define IDC_NO_IMPORT_RADIO             1024
#define IDC_MSGS_AB_RADIO               1025
#define IDC_MSGS_RADIO                  1026
#define IDC_AB_RADIO                    1027

#endif // _INC_IMPDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\findres.h ===
#define IDD_FIND_ADVANCED               601
#define IDD_FIND_NEXT                   602
#define IDD_FIND_GENERAL                603
#define IDD_FIND_DATE_SIZE              604
#define IDC_INCLUDE_SUBFOLDERS          1001
#define IDC_ATTCHMENTS                  1002
#define IDC_FLAGGED                     1003
#define IDC_FIND_ANIMATION              1004
#define IDC_SIZE_BEGIN                  1005
#define IDC_SEARCH_FIELDS               1006
#define IDC_SIZE_END                    1007
#define IDC_FOLDER_LIST                 1008
#define IDC_FIND_HISTORY                1009
#define IDC_FIND_NOW                    1010
#define IDC_NEW_SEARCH                  1011
#define IDC_DATE_CRITERIA               1012
#define IDC_SIZE_CRITERIA               1013
#define IDC_DATE_BEGIN                  1014
#define IDC_DATE_END                    1015
#define IDC_HIGH_PRIORITY               1016
#define IDC_MORE                        1017
#define IDC_BUTTON4                     1018
#define IDC_ADVANCED                    1019
#define IDC_ALL_TEXT                    1020
#define IDC_FOLDER                      1021
#define IDC_INCLUDE_SUB                 1022
#define IDC_BROWSE_FOLDER               1023
#define IDC_FROM                        1024
#define IDC_TO                          1025
#define IDC_SUBJECT                     1026
#define IDC_BODY                        1027
#define IDC_DATE_FROM                   1028
#define IDC_DATE_TO                     1029
#define IDC_HAS_FLAG                    1030
#define IDC_HAS_ATTACH                  1031
#define IDC_STOP                        1032
#define IDC_RESET                       1033
#define IDC_FIND_STATUS                 1034
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\langpref.h ===
#define idrgConstantLang                1004
#define idrgUseLangOrig                 1005
#define idchUseEnglishHead              1006
#define idchAttachOrig                  1009
#define idcbReceiving                   1010
#define idcbReplyForward                1011
#define idcbComposing                   1014
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\pttest.h ===
#define idlbNumbers                     1000
#define ideArticleNumber                1001
#define idbStats                        1002
#define ideFlags                        1003
#define ideDate                         1004
#define ideArticleSize                  1005
#define ideReferences                   1006
#define ideMessageId                    1007
#define ideXref                         1008
#define ideArticle                      1009
#define idbStreamInArticle              1010
#define idbSearch                       1010
#define ideStormRecs                    1011
#define ideSubject                      1012
#define ideFrom                         1013
#define idbNew                          1014
#define idbUpdate                       1015
#define idbCancel                       1016
#define idbClear                        1018
#define idbFillList                     1019
#define idbStormInsert                  1022
#define idsRecordCount                  1023
#define idbCompact                      1024
#define ideStormSeed                    1025
#define ideCacheFile                    1026
#define idbBrowse                       1027
#define idsInsertTime                   1029
#define idsStatus                       1030
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\oeres.h ===
// OERES.H

#ifndef __OERES__H
#define __OERES__H
#include <windows.h>
#endif // __OERES__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\secwarn.h ===
#pragma once

#define idcSecWarnMessage 1000
#define idcSecWarnAgain   1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\menures.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by menures.rc
//

#pragma once

#define MH(_mi)                         (_mi - ID_FIRST)

/////////////////////////////////////////////////////////////////////////////
// BEGIN MENU RESOURCES
//
#define IDR_BROWSER_MENU                    101
#define IDR_SEND_NOTE_MENU                  102
#define IDR_BA_DRAGDROP_POPUP               103
#define IDR_BA_POPUP                        104
#define IDR_ADDRESS_POPUP                   105
#define IDR_ATTACHMENT_POPUP                106
#define IDR_COLUMNS_POPUP                   107
#define IDR_TOOLBAR_POPUP                   108
#define IDR_SECURE_MESSAGE_POPUP            109
#define IDR_ATTACHMENT_DRAGDROP_POPUP       110
#define IDR_SERVER_POPUP                    111
#define IDR_FOLDER_POPUP                    112
#define IDR_PRIORITY_POPUP                  114
#define IDR_PREVIEW_POPUP                   115
#define IDR_VCARD_POPUP                     117
#define IDR_HELP_POPUP                      118
#define IDR_FIND_MENU                       120 
#define IDR_READ_NOTE_MENU                  121
#define IDR_NEW_MSG_POPUP                   122
#define IDR_COOLBAR_POPUP                   123
#define IDR_OUTLOOKBAR_ITEM_POPUP           124
#define IDR_OUTLOOKBAR_POPUP                125
#define IDR_BA_TITLE_POPUP                  126
#define IDR_SYNCHRONIZE_POPUP               127
#define IDR_SEND_RECEIEVE_POPUP             128
#define IDR_TBCHEV_MENU                     129
#define IDR_VIEW_POPUP                      130
#define IDR_FIND_POPUP                      131
#define IDR_LOCAL_MESSAGE_POPUP             132
#define IDR_IMAP_MESSAGE_POPUP              133
#define IDR_HTTP_MESSAGE_POPUP              134
#define IDR_NEWS_MESSAGE_POPUP              135
#define IDR_FIND_MESSAGE_POPUP              136

#define IDA_BROWSER_ACCEL                   200
#define IDA_READ_NOTE_ACCEL                 201
#define IDA_SEND_NOTE_ACCEL                 202
#define IDA_SEND_HDR_ACCEL                  203
#define IDA_FIND_ACCEL                      204

//
// END MENU RESOURCES
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// BEGIN SEPARATOR IDs
//

#define SEP_FIRST                           30000
#define SEP_MAILFOLDER                      (SEP_FIRST + 1)
#define SEP_SUBSCRIBE                       (SEP_FIRST + 2)
#define SEP_SYNCHRONIZE                     (SEP_FIRST + 3)
#define SEP_MESSENGER                       (SEP_FIRST + 4)
#define SEP_CATCH_UP                        (SEP_FIRST + 5)

//
// END SEPARATOR IDs
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// BEGIN COMMAND IDs
//
#define ID_FIRST                            40000
#define ID_POPUP_FILE                       (ID_FIRST + 1)
#define ID_POPUP_FOLDER                     (ID_FIRST + 2)
#define ID_POPUP_IMPORT                     (ID_FIRST + 3)
#define ID_POPUP_EXPORT                     (ID_FIRST + 4)
#define ID_POPUP_USERS                      (ID_FIRST + 5)
#define ID_POPUP_EDIT                       (ID_FIRST + 7)
#define ID_POPUP_FIND                       (ID_FIRST + 8)
#define ID_POPUP_VIEW                       (ID_FIRST + 9)
#define ID_POPUP_FILTER                     (ID_FIRST + 10)
#define ID_POPUP_SORT                       (ID_FIRST + 11)
#define ID_POPUP_NEXT                       (ID_FIRST + 12)
#define ID_POPUP_FONTS                      (ID_FIRST + 13)
#define ID_POPUP_GO                         (ID_FIRST + 14)
#define ID_POPUP_MESSAGE                    (ID_FIRST + 15)
#define ID_POPUP_NEW_MSG                    (ID_FIRST + 16)
#define ID_POPUP_NEW                        (ID_FIRST + 17)
#define ID_POPUP_RETRIEVE                   (ID_FIRST + 18)
#define ID_POPUP_TOOLS                      (ID_FIRST + 19)
#define ID_POPUP_SEND_AND_RECEIVE           (ID_FIRST + 20)
#define ID_POPUP_ADDRESS_BOOK               (ID_FIRST + 21)
#define ID_POPUP_HELP                       (ID_FIRST + 22)
#define ID_POPUP_MSWEB                      (ID_FIRST + 23)
#define ID_POPUP_INSERT                     (ID_FIRST + 24)
#define ID_POPUP_FORMAT                     (ID_FIRST + 25)
#define ID_POPUP_PRIORITY                   (ID_FIRST + 26)
#define ID_POPUP_STYLE                      (ID_FIRST + 27)
#define ID_POPUP_ALIGN                      (ID_FIRST + 28)
#define ID_POPUP_RULES                      (ID_FIRST + 29)
#define ID_POPUP_NEW_ACCOUNT                (ID_FIRST + 31)
#define ID_POPUP_LANGUAGE_DEFERRED          (ID_FIRST + 32)
#define ID_POPUP_LANGUAGE                   (ID_FIRST + 33)
#define ID_POPUP_STATIONERY                 (ID_FIRST + 34)
#define ID_POPUP_BACKGROUND_COLOR           (ID_FIRST + 35)
#define ID_POPUP_BACKGROUND                 (ID_FIRST + 36)
#define ID_POPUP_SYNCHRONIZE                (ID_FIRST + 37)
#define ID_POPUP_TOOLBAR                    (ID_FIRST + 39)
#define ID_POPUP_SECURITY                   (ID_FIRST + 40)
#define ID_POPUP_LANGUAGE_MORE              (ID_FIRST + 41)
#define ID_POPUP_INVITE                     (ID_FIRST + 42)
#define ID_POPUP_NEW_ACCT                   (ID_FIRST + 43)

#define ID_OPEN                             (ID_FIRST + 100)
#define ID_SAVE_AS                          (ID_FIRST + 101)
#define ID_SAVE_ATTACHMENTS                 (ID_FIRST + 102)
#define ID_SAVE_STATIONERY                  (ID_FIRST + 103)
#define ID_SAVE_ATTACH_AS                   (ID_FIRST + 104)
#define ID_RESET_LIST                       (ID_FIRST + 105)
#define ID_SUBSCRIBE                        (ID_FIRST + 106)
#define ID_UNSUBSCRIBE                      (ID_FIRST + 107)
#define ID_COMPACT                          (ID_FIRST + 108)
#define ID_COMPACT_ALL                      (ID_FIRST + 109)
#define ID_IMPORT_ADDRESS_BOOK              (ID_FIRST + 110)
#define ID_IMPORT_MESSAGES                  (ID_FIRST + 111)
#define ID_IMPORT_MAIL_ACCOUNTS             (ID_FIRST + 112)
#define ID_IMPORT_NEWS_ACCOUNTS             (ID_FIRST + 113)
#define ID_EXPORT_ADDRESS_BOOK              (ID_FIRST + 114)
#define ID_EXPORT_MESSAGES                  (ID_FIRST + 115)
#define ID_PRINT                            (ID_FIRST + 116)
#define ID_SWITCH_IDENTITY                  (ID_FIRST + 117)
#define ID_LOGOFF_IDENTITY                  (ID_FIRST + 118)
#define ID_NOOP                             (ID_FIRST + 119)
#define ID_NEW_IDENTITY                     (ID_FIRST + 120)
#define ID_WORK_OFFLINE                     (ID_FIRST + 121)
#define ID_PROPERTIES                       (ID_FIRST + 122)
#define ID_EXIT                             (ID_FIRST + 123)
#define ID_COPY                             (ID_FIRST + 124)
#define ID_SELECT_ALL                       (ID_FIRST + 125)
#define ID_COPY_TO_FOLDER                   (ID_FIRST + 126)
#define ID_MOVE_TO_FOLDER                   (ID_FIRST + 127)
#define ID_DELETE                           (ID_FIRST + 128)
#define ID_UNDELETE                         (ID_FIRST + 129)
#define ID_EMPTY_WASTEBASKET                (ID_FIRST + 130)
#define ID_PURGE_DELETED                    (ID_FIRST + 131)
#define ID_FIND_MESSAGE                     (ID_FIRST + 132)
#define ID_FIND_NEXT                        (ID_FIRST + 133)
#define ID_FIND_PEOPLE                      (ID_FIRST + 134)
#define ID_FIND_TEXT                        (ID_FIRST + 135)
#define ID_SORT_COLOR                       (ID_FIRST + 141)
#define ID_SORT_ASCENDING                   (ID_FIRST + 142)
#define ID_SORT_DESCENDING                  (ID_FIRST + 143)
#define ID_COLUMNS                          (ID_FIRST + 144)
#define ID_PREVIOUS                         (ID_FIRST + 145)
#define ID_NEXT_MESSAGE                     (ID_FIRST + 146)
#define ID_NEXT_UNREAD_MESSAGE              (ID_FIRST + 147)
#define ID_NEXT_UNREAD_THREAD               (ID_FIRST + 148)
#define ID_NEXT_UNREAD_FOLDER               (ID_FIRST + 149)
#define ID_EXPAND                           (ID_FIRST + 150)
#define ID_COLLAPSE                         (ID_FIRST + 151)
#define ID_FONTS_SMALLEST                   (ID_FIRST + 152)
#define ID_FONTS_SMALL                      (ID_FIRST + 153)
#define ID_FONTS_MEDIUM                     (ID_FIRST + 154)
#define ID_FONTS_LARGE                      (ID_FIRST + 155)
#define ID_FONTS_LARGEST                    (ID_FIRST + 156)
#define ID_STOP                             (ID_FIRST + 157)
#define ID_REFRESH                          (ID_FIRST + 158)
#define ID_UP_ONE_LEVEL                     (ID_FIRST + 159)
#define ID_GO_FOLDER                        (ID_FIRST + 160)
#define ID_GO_SELECTED                      (ID_FIRST + 161)
#define ID_GO_INBOX                         (ID_FIRST + 162)
#define ID_GO_NEWS                          (ID_FIRST + 163)
#define ID_GO_NETMEETING                    (ID_FIRST + 164)
#define ID_GO_OUTBOX                        (ID_FIRST + 165)
#define ID_GO_SENT_ITEMS                    (ID_FIRST + 166)
#define ID_GO_DRAFTS                        (ID_FIRST + 167)
#define ID_FIND_FOLDER                      (ID_FIRST + 169)
#define ID_NEW_MSG_DEFAULT                  (ID_FIRST + 170)
#define ID_SEND_MESSAGE                     (ID_FIRST + 171)
#define ID_MESSAGE_OPTS                     (ID_FIRST + 172)
#define ID_REPLY                            (ID_FIRST + 176)
#define ID_REPLY_ALL                        (ID_FIRST + 177)
#define ID_REPLY_GROUP                      (ID_FIRST + 178)
#define ID_SOURCE_EDIT                      (ID_FIRST + 179)
#define ID_FORWARD                          (ID_FIRST + 180)
#define ID_UNMARK_MESSAGE                   (ID_FIRST + 181)
#define ID_FLAG_MESSAGE                     (ID_FIRST + 182)
#define ID_MARK_RETRIEVE_MESSAGE            (ID_FIRST + 183)
#define ID_MARK_RETRIEVE_THREAD             (ID_FIRST + 184)
#define ID_MARK_RETRIEVE_ALL                (ID_FIRST + 185)
#define ID_MARK_READ                        (ID_FIRST + 186)
#define ID_MARK_UNREAD                      (ID_FIRST + 187)
#define ID_MARK_THREAD_READ                 (ID_FIRST + 188)
#define ID_MARK_ALL_READ                    (ID_FIRST + 189)
#define ID_CATCH_UP                         (ID_FIRST + 190)
#define ID_UNSCRAMBLE                       (ID_FIRST + 191)
#define ID_COMBINE_AND_DECODE               (ID_FIRST + 192)
#define ID_SEND_RECEIVE                     (ID_FIRST + 193)
#define ID_RECEIVE_ALL                      (ID_FIRST + 194)
#define ID_SEND_ALL                         (ID_FIRST + 195)
#define ID_SYNC_THIS_NOW                    (ID_FIRST + 196)
#define ID_SYNCHRONIZE                      (ID_FIRST + 197)
#define ID_GET_HEADERS                      (ID_FIRST + 198)
#define ID_ADDRESS_BOOK                     (ID_FIRST + 199)
#define ID_ADD_SENDER                       (ID_FIRST + 200)
#define ID_ADD_ALL_TO                       (ID_FIRST + 201)
#define ID_ACCOUNTS                         (ID_FIRST + 203)
#define ID_OPTIONS                          (ID_FIRST + 204)
#define ID_HELP_CONTENTS                    (ID_FIRST + 206)
#define ID_README                           (ID_FIRST + 207)
#define ID_MSWEB_BASE                       (ID_FIRST + 208)
#define ID_MSWEB_FREE_STUFF                 (ID_FIRST + 209)
#define ID_MSWEB_PRODUCT_NEWS               (ID_FIRST + 210)
#define ID_MSWEB_FAQ                        (ID_FIRST + 211)
#define ID_MSWEB_SUPPORT                    (ID_FIRST + 212)
#define ID_MSWEB_FEEDBACK                   (ID_FIRST + 213)
#define ID_MSWEB_BEST                       (ID_FIRST + 214)
#define ID_MSWEB_SEARCH                     (ID_FIRST + 215)
#define ID_MSWEB_HOME                       (ID_FIRST + 216)
#define ID_MSWEB_OUTLOOK                    (ID_FIRST + 217)
#define ID_MSWEB_PLACEHOLDER1               (ID_FIRST + 218)
#define ID_MSWEB_PLACEHOLDER2               (ID_FIRST + 219)
#define ID_MSWEB_PLACEHOLDER3               (ID_FIRST + 220)
#define ID_MSWEB_HOTMAIL                    (ID_FIRST + 221)
#define ID_MSWEB_PLACEHOLDER4               (ID_FIRST + 222)
#define ID_MSWEB_LAST                       (ID_FIRST + 223)
#define ID_SEND_NOW                         (ID_FIRST + 224)
#define ID_SEND_LATER                       (ID_FIRST + 225)
#define ID_ABOUT                            (ID_FIRST + 226)
#define ID_SAVE                             (ID_FIRST + 227)
#define ID_CLOSE                            (ID_FIRST + 228)
#define ID_UNDO                             (ID_FIRST + 229)
#define ID_CUT                              (ID_FIRST + 230)
#define ID_PASTE                            (ID_FIRST + 231)
#define ID_FULL_HEADERS                     (ID_FIRST + 232)
#define ID_STATUS_BAR                       (ID_FIRST + 233)
#define ID_FORMATTING_TOOLBAR               (ID_FIRST + 234)
#define ID_FONTS_DIALOG                     (ID_FIRST + 235)
#define ID_TOOLBAR                          (ID_FIRST + 236)
#define ID_INSERT_ATTACHMENT                (ID_FIRST + 237)
#define ID_INSERT_TEXT                      (ID_FIRST + 238)
#define ID_INSERT_PICTURE                   (ID_FIRST + 239)
#define ID_INSERT_CONTACT_INFO              (ID_FIRST + 240)
#define ID_INSERT_LINE                      (ID_FIRST + 241)
#define ID_INSERT_SIGNATURE                 (ID_FIRST + 242)
#define ID_INSERT_LINK                      (ID_FIRST + 243)
#define ID_PRIORITY_HIGH                    (ID_FIRST + 244)
#define ID_PRIORITY_NORMAL                  (ID_FIRST + 245)
#define ID_PRIORITY_LOW                     (ID_FIRST + 246)
#define ID_ALIGN_LEFT                       (ID_FIRST + 247)
#define ID_ALIGN_CENTER                     (ID_FIRST + 248)
#define ID_ALIGN_RIGHT                      (ID_FIRST + 249)
#define ID_ALIGN_JUSTIFIED                  (ID_FIRST + 250)
#define ID_NUMBERS                          (ID_FIRST + 251)
#define ID_BULLETS                          (ID_FIRST + 252)
#define ID_INDENT_INCREASE                  (ID_FIRST + 253)
#define ID_INDENT_DECREASE                  (ID_FIRST + 254)
#define ID_BACKGROUND_PICTURE               (ID_FIRST + 255)
#define ID_BACKGROUND_SOUND                 (ID_FIRST + 256)
#define ID_BACKGROUND_COLOR                 (ID_FIRST + 257)
#define ID_RICH_TEXT                        (ID_FIRST + 258)
#define ID_PLAIN_TEXT                       (ID_FIRST + 259)
#define ID_ENCRYPT                          (ID_FIRST + 260)
#define ID_REMOVE_LINK                      (ID_FIRST + 261)
#define ID_SEND_OBJECTS                     (ID_FIRST + 262)
#define ID_SPELLING                         (ID_FIRST + 263)
#define ID_CHECK_NAMES                      (ID_FIRST + 264)
#define ID_SELECT_RECIPIENTS                (ID_FIRST + 265)
#define ID_SAVE_ALL_ADDRESSES               (ID_FIRST + 266)
#define ID_CANCEL                           (ID_FIRST + 267)
#define ID_SEND_INSTANT_MESSAGE             (ID_FIRST + 268)
#define ID_NEW_CONTACT                      (ID_FIRST + 270)
#define ID_ADD_ADDRESS_BOOK                 (ID_FIRST + 271)
#define ID_QUICK_VIEW                       (ID_FIRST + 272)
#define ID_SAVE_ALL                         (ID_FIRST + 273)
#define ID_CUSTOMIZE                        (ID_FIRST + 274)
#define ID_TOOLBAR_TOP                      (ID_FIRST + 275)
#define ID_TOOLBAR_LEFT                     (ID_FIRST + 276)
#define ID_TOOLBAR_BOTTOM                   (ID_FIRST + 277)
#define ID_TOOLBAR_RIGHT                    (ID_FIRST + 278)
#define ID_SECURITY_PROPERTIES              (ID_FIRST + 279)
#define ID_DIGITAL_ID                       (ID_FIRST + 280)
#define ID_EDIT_TRUST                       (ID_FIRST + 281)
#define ID_HELP_SECURITY                    (ID_FIRST + 282)
#define ID_MOVE                             (ID_FIRST + 283)
#define ID_CREATE_SHORTCUT                  (ID_FIRST + 284)
#define ID_REMOVE_SERVER                    (ID_FIRST + 285)
#define ID_SET_DEFAULT_SERVER               (ID_FIRST + 286)
#define ID_RENAME                           (ID_FIRST + 287)
#define ID_NEW_FOLDER                       (ID_FIRST + 288)
#define ID_DOWNLOAD_MESSAGE                 (ID_FIRST + 291)
#define ID_CANCEL_MESSAGE                   (ID_FIRST + 292)
#define ID_BLOCK_SENDER                     (ID_FIRST + 294)
#define ID_PREVIEW_SHOW                     (ID_FIRST + 295)
#define ID_PREVIEW_BELOW                    (ID_FIRST + 296)
#define ID_PREVIEW_BESIDE                   (ID_FIRST + 297)
#define ID_PREVIEW_HEADER                   (ID_FIRST + 298)
#define ID_DIGITALLY_SIGN                   (ID_FIRST + 299)
#define ID_AVAILABLE_OFFLINE                (ID_FIRST + 300)
#define ID_APPLY_STATIONERY                 (ID_FIRST + 301)
#define ID_STATIONERY_LIST                  (ID_FIRST + 302)
#define ID_START_NETMETTING                 (ID_FIRST + 303)
#define ID_LANGUAGE                         (ID_FIRST + 312)
#define ID_NEWSGROUPS                       (ID_FIRST + 313)
#define ID_IMPORT_RULES                     (ID_FIRST + 314)
#define ID_EXPORT_RULES                     (ID_FIRST + 315)
#define ID_IMAP_FOLDERS                     (ID_FIRST + 316)
#define ID_ENV_BCC                          (ID_FIRST + 317)
#define ID_CREATE_RULE_FROM_MESSAGE         (ID_FIRST + 318)    
#define ID_FOLDER_LIST                      (ID_FIRST + 319)
#define ID_PREVIEW_PANE                     (ID_FIRST + 320)
#define ID_ADD                              (ID_FIRST + 322)
#define ID_REMOVE                           (ID_FIRST + 323)
#define ID_SEPARATOR_1                      (ID_FIRST + 324)
#define ID_SEPARATOR_2                      (ID_FIRST + 325)
#define ID_SEPARATOR_3                      (ID_FIRST + 326)
#define ID_NEW_HOTMAIL_ACCOUNT              (ID_FIRST + 327)
#define ID_NEW_ATT_ACCOUNT                  (ID_FIRST + 328)
#define ID_STATIONERY_NONE                  (ID_FIRST + 329)
#define ID_NEW_GROUP                        (ID_FIRST + 330)
#define ID_SEND_INSTANT_MESSAGE2            (ID_FIRST + 331)
#define ID_MARK_RETRIEVE_FLD_ALL_MSGS       (ID_FIRST + 332)   // not exposed in ui yet
#define ID_MARK_RETRIEVE_FLD_NEW_HDRS       (ID_FIRST + 333)   // not exposed in ui yet
#define ID_MARK_RETRIEVE_FLD_NEW_MSGS       (ID_FIRST + 334)   // not exposed in ui yet
#define ID_UNMARK_RETRIEVE_FLD              (ID_FIRST + 335)   // not exposed in ui yet
#define ID_TOGGLE_SUBSCRIBE                 (ID_FIRST + 336)   // internal only - no ui
#define ID_STATIONERY_RECENT_0              (ID_FIRST + 337)
#define ID_STATIONERY_RECENT_1              (ID_FIRST + 338)
#define ID_STATIONERY_RECENT_2              (ID_FIRST + 339)
#define ID_STATIONERY_RECENT_3              (ID_FIRST + 340)
#define ID_STATIONERY_RECENT_4              (ID_FIRST + 341)
#define ID_STATIONERY_RECENT_5              (ID_FIRST + 342)
#define ID_STATIONERY_RECENT_6              (ID_FIRST + 343)
#define ID_STATIONERY_RECENT_7              (ID_FIRST + 344)
#define ID_STATIONERY_RECENT_8              (ID_FIRST + 345)
#define ID_STATIONERY_RECENT_9              (ID_FIRST + 346)
#define ID_STATIONERY_MORE                  (ID_FIRST + 347)
#define ID_RESYNCHRONIZE                    (ID_FIRST + 348)
#define ID_WATCH_THREAD                     (ID_FIRST + 349)
#define ID_IGNORE_THREAD                    (ID_FIRST + 350)
#define ID_IDENTITIES                       (ID_FIRST + 361)
#define ID_MANAGE_IDENTITIES                (ID_FIRST + 362)
#define ID_SPACE_ACCEL                      (ID_FIRST + 363)
#define ID_IMPORT_WAB                       (ID_FIRST + 364)
#define ID_EMPTY_JUNKMAIL                   (ID_FIRST + 365)
#define ID_NEW_FOLDER2                      (ID_FIRST + 366)
#define ID_SELECT_NEWSGROUPS                (ID_FIRST + 367)
#define ID_REQUEST_READRCPT                 (ID_FIRST + 368)
#define ID_INCLUDE_LABEL                    (ID_FIRST + 369)
#define ID_LABEL_SETTINGS                   (ID_FIRST + 370)
#define ID_SEC_RECEIPT_REQUEST              (ID_FIRST + 371)
// Please use the ids available here....

#define ID_VIEW_SEPARATOR                   (ID_FIRST + 374)
#define ID_FORMAT_FONT                      (ID_FIRST + 375)
#define ID_FORMAT_SIZE                      (ID_FIRST + 376)
#define ID_FORMAT_COLOR                     (ID_FIRST + 377)
#define ID_FORMAT_COLORAUTO                 (ID_FIRST + 378)
#define ID_FORMAT_COLOR1                    (ID_FIRST + 379)
#define ID_FORMAT_COLOR2                    (ID_FIRST + 380)
#define ID_FORMAT_COLOR3                    (ID_FIRST + 381)
#define ID_FORMAT_COLOR4                    (ID_FIRST + 382)
#define ID_FORMAT_COLOR5                    (ID_FIRST + 383)
#define ID_FORMAT_COLOR6                    (ID_FIRST + 384)
#define ID_FORMAT_COLOR7                    (ID_FIRST + 385)
#define ID_FORMAT_COLOR8                    (ID_FIRST + 386)
#define ID_FORMAT_COLOR9                    (ID_FIRST + 387)
#define ID_FORMAT_COLOR10                   (ID_FIRST + 388)
#define ID_FORMAT_COLOR11                   (ID_FIRST + 389)
#define ID_FORMAT_COLOR12                   (ID_FIRST + 390)
#define ID_FORMAT_COLOR13                   (ID_FIRST + 391)
#define ID_FORMAT_COLOR14                   (ID_FIRST + 392)
#define ID_FORMAT_COLOR15                   (ID_FIRST + 393)
#define ID_FORMAT_COLOR16                   (ID_FIRST + 394)
#define ID_FORMAT_BOLD                      (ID_FIRST + 395)
#define ID_FORMAT_ITALIC                    (ID_FIRST + 396)
#define ID_FORMAT_UNDERLINE                 (ID_FIRST + 397)
#define ID_FORMAT_BULLETS                   (ID_FIRST + 398)
#define ID_FORMAT_DECREASEINDENT            (ID_FIRST + 399)
#define ID_FORMAT_INCREASEINDENT            (ID_FIRST + 400)
#define ID_FORMAT_LEFT                      (ID_FIRST + 401)
#define ID_FORMAT_CENTER                    (ID_FIRST + 402)
#define ID_FORMAT_RIGHT                     (ID_FIRST + 403)
#define ID_FORMAT_FONTDLG                   (ID_FIRST + 404)
#define ID_REDO                             (ID_FIRST + 405)
#define ID_INFOCOLUMN_CONTACTS              (ID_FIRST + 406)
#define ID_INFOCOLUMN_FOLDER_LIST           (ID_FIRST + 407)
#define ID_BACK_COLOR_AUTO                  (ID_FIRST + 408)
#define ID_OPEN_CONTAINING_FOLDER           (ID_FIRST + 409)
#define ID_PRINT_NOW                        (ID_FIRST + 410)
#define ID_SEND_DEFAULT                     (ID_FIRST + 411)
#define ID_SET_PRIORITY                     (ID_FIRST + 412)
#define ID_ENVELOPE_BCC                     (ID_FIRST + 413) // ~~~ This might go away
#define ID_NEXT_UNREAD_ARTICLE              (ID_FIRST + 414) // ~~~ This might go away
#define ID_EDIT_LINK                        (ID_FIRST + 415)
#define ID_UNLINK                           (ID_FIRST + 416)
#define ID_APPLY_STATIONERY_0               (ID_FIRST + 417)
#define ID_APPLY_STATIONERY_1               (ID_FIRST + 418)
#define ID_APPLY_STATIONERY_2               (ID_FIRST + 419)
#define ID_APPLY_STATIONERY_3               (ID_FIRST + 420)
#define ID_APPLY_STATIONERY_4               (ID_FIRST + 421)
#define ID_APPLY_STATIONERY_5               (ID_FIRST + 422)
#define ID_APPLY_STATIONERY_6               (ID_FIRST + 423)
#define ID_APPLY_STATIONERY_7               (ID_FIRST + 424)
#define ID_APPLY_STATIONERY_8               (ID_FIRST + 425)
#define ID_APPLY_STATIONERY_9               (ID_FIRST + 426)
#define ID_APPLY_STATIONERY_MORE            (ID_FIRST + 427)
#define ID_APPLY_STATIONERY_NONE            (ID_FIRST + 428)
#define ID_VIEW_SOURCE                      (ID_FIRST + 429)
#define ID_FORMAT_SETTINGS                  (ID_FIRST + 430)
#define ID_STATIONERY_SEPARATOR             (ID_FIRST + 431)
#define ID_VIEW_MSG_SOURCE                  (ID_FIRST + 432)
#define ID_DELETE_FOLDER                    (ID_FIRST + 433)
#define ID_DELETE_ACCEL                     (ID_FIRST + 434)
#define ID_DELETE_CONTACT                   (ID_FIRST + 435)
#define ID_OPEN_FOLDER                      (ID_FIRST + 436)
#define ID_OPEN_VCARD                       (ID_FIRST + 439)
#define ID_DELETE_VCARD                     (ID_FIRST + 440)
#define ID_MESSAGE_RULES_MAIL               (ID_FIRST + 442)
#define ID_MESSAGE_RULES_NEWS               (ID_FIRST + 443)
#define ID_MESSAGE_RULES_JUNK               (ID_FIRST + 444)
#define ID_MESSAGE_RULES_SENDERS            (ID_FIRST + 445)
#define ID_REMOVE_SHORTCUT                  (ID_FIRST + 446)
#define ID_RENAME_SHORTCUT                  (ID_FIRST + 447)
#define ID_LARGE_ICONS                      (ID_FIRST + 448)
#define ID_SMALL_ICONS                      (ID_FIRST + 449)
#define ID_NEW_SHORTCUT                     (ID_FIRST + 450)
#define ID_HIDE                             (ID_FIRST + 451)
#define ID_ADD_SHORTCUT                     (ID_FIRST + 452)
#define ID_FORMAT_PARADLG                   (ID_FIRST + 454)
#define ID_LAYOUT                           (ID_FIRST + 455)
#define ID_NEW_ONLINE_CONTACT               (ID_FIRST + 456)
#define ID_SORT_BY_NAME                     (ID_FIRST + 457)
#define ID_SORT_BY_STATUS                   (ID_FIRST + 458)
#define ID_ENCRYPT_ID                       (ID_FIRST + 459)
#define ID_CREATE_NEWS_ACCOUNT              (ID_FIRST + 460)
#define ID_CREATE_MAIL_ACCOUNT              (ID_FIRST + 461)
#define ID_DOCDIR_LTR                       (ID_FIRST + 462)
#define ID_DOCDIR_RTL                       (ID_FIRST + 463)
#define ID_WEB_PAGE                         (ID_FIRST + 464)
#define ID_NEW_MAIL_MESSAGE                 (ID_FIRST + 465)
#define ID_NEW_NEWS_MESSAGE                 (ID_FIRST + 466)
#define ID_SHOW_TOOLBAR                     (ID_FIRST + 468)
#define ID_CREATE_FILTER                    (ID_FIRST + 470)
#define ID_CONTACTS_LIST                    (ID_FIRST + 472)
#define ID_DELETE_NO_TRASH                  (ID_FIRST + 473)
#define ID_DELETE_NO_TRASH_ACCEL            (ID_FIRST + 474)
#define ID_FONTS_FIXED                      (ID_FIRST + 475)
#define ID_SET_ONLINE_CONTACT               (ID_FIRST + 476)
#define ID_NOTE_SAVE_AS                     (ID_FIRST + 477) // Items that are in Note and browser windows, but need different help text
#define ID_NOTE_SAVE_ATTACHMENTS            (ID_FIRST + 478)
#define ID_NOTE_SAVE_STATIONERY             (ID_FIRST + 479)
#define ID_NOTE_MOVE_TO_FOLDER              (ID_FIRST + 480)
#define ID_NOTE_COPY_TO_FOLDER              (ID_FIRST + 481)
#define ID_NOTE_DELETE                      (ID_FIRST + 482)
#define ID_NOTE_PROPERTIES                  (ID_FIRST + 483)
#define ID_NOTE_COPY                        (ID_FIRST + 484)
#define ID_SHOW_FILTERBAR                   (ID_FIRST + 485)
#define ID_REFRESH_INNER                    (ID_FIRST + 486)
#define ID_CONTACTS_MNEMONIC                (ID_FIRST + 487)
#define ID_FIND_IN_FOLDER                   (ID_FIRST + 489)
#define ID_FORWARD_AS_ATTACH                (ID_FIRST + 490)
#define ID_EXIT_LOGOFF                      (ID_FIRST + 491)

#define ID_LAST                             ID_FIRST + 2000
 

/////////////////////////////////////////////////////////////////////////////
// Reserved Blocks.
//

#define ID_RESERVED_BASE                    ID_LAST

// brettm: reserved a block of extra verbs for ole objects
// don't reassign these, without changing code, or you'll break things

// Used for the context menu on address objects in the note headers
#define ID_ADDROBJ_OLE_FIRST                (ID_RESERVED_BASE)
#define ID_ADDROBJ_OLE_LAST                 (ID_ADDROBJ_OLE_FIRST + 10)

#define ID_ADDROBJ_OLE_PROPERTIES           (ID_ADDROBJ_OLE_FIRST)
#define ID_ADDROBJ_OLE_ADD_ADDRESS_BOOK     (ID_ADDROBJ_OLE_FIRST + 1)
#define ID_ADDROBJ_OLE_FIND                 (ID_ADDROBJ_OLE_FIRST + 2)
#define ID_ADDROBJ_OLE_BLOCK_SENDER         (ID_ADDROBJ_OLE_FIRST + 3)

#define ID_SAVE_ADDRESS_FIRST               (ID_ADDROBJ_OLE_LAST + 1)
#define ID_SAVE_ADDRESS_LAST                (ID_SAVE_ADDRESS_FIRST + 50)

#define ID_SORT_MENU_FIRST                  (ID_SAVE_ADDRESS_LAST + 1)
#define ID_SORT_MENU_LAST                   (ID_SORT_MENU_FIRST + 20)

#define ID_SEND_NOW_ACCOUNT_FIRST           (ID_SORT_MENU_LAST + 1)
#define ID_SEND_NOW_ACCOUNT_LAST            (ID_SEND_NOW_ACCOUNT_FIRST + 50)

#define ID_SEND_LATER_ACCOUNT_FIRST         (ID_SEND_NOW_ACCOUNT_LAST + 1)
#define ID_SEND_LATER_ACCOUNT_LAST          (ID_SEND_LATER_ACCOUNT_FIRST + 50)

#define ID_ACCOUNT_FIRST                    (ID_SEND_LATER_ACCOUNT_LAST + 1)
#define ID_ACCOUNT_LAST                     (ID_ACCOUNT_FIRST + 50)

#define ID_FORMAT_FIRST                     (ID_ACCOUNT_LAST + 1)
#define ID_FORMAT_LAST                      (ID_FORMAT_FIRST + 50)

#define ID_ENVELOPE_HOST_FIRST              (ID_FORMAT_LAST + 1)
#define ID_POPUP_ENVELOPE_HOST              (ID_ENVELOPE_HOST_FIRST + 49)
#define ID_ENVELOPE_HOST_LAST               (ID_POPUP_ENVELOPE_HOST + 1)

#define ID_SIGNATURE_FIRST                  (ID_ENVELOPE_HOST_LAST + 1)
#define ID_SIGNATURE_LAST                   (ID_SIGNATURE_FIRST + 100)

#define ID_CONNECT_FIRST                    (ID_SIGNATURE_LAST + 1)
#define ID_CONNECT_LAST                     (ID_CONNECT_FIRST + 50)

#define ID_ADD_RECIPIENT_FIRST              (ID_CONNECT_LAST + 1)
#define ID_ADD_RECIPIENT_LAST               (ID_ADD_RECIPIENT_FIRST + 30)

#define ID_LANG_FIRST                       (ID_ADD_RECIPIENT_LAST + 1)
#define ID_LANG_USASCII                     ID_LANG_FIRST
#define ID_LANG_WESTERN_EUROPEAN            (ID_LANG_FIRST + 1)      
#define ID_LANG_CENTRAL_EUROPEAN_ISO        (ID_LANG_FIRST + 2)
#define ID_LANG_CENTRAL_EUROPEAN_WINDOWS    (ID_LANG_FIRST + 3)       
#define ID_LANG_RUSSIAN_KOI8R               (ID_LANG_FIRST + 4)
#define ID_LANG_RUSSIAN_WINDOWS             (ID_LANG_FIRST + 5)
#define ID_LANG_BALTIC_ISO                  (ID_LANG_FIRST + 6)
#define ID_LANG_BALTIC_WINDOWS              (ID_LANG_FIRST + 7)
#define ID_LANG_GREEK_ISO                   (ID_LANG_FIRST + 8)
#define ID_LANG_GREEK_WINDOWS               (ID_LANG_FIRST + 9)
#define ID_LANG_TURKISH_ISO                 (ID_LANG_FIRST + 10)      
#define ID_LANG_TURKISH_WINDOWS             (ID_LANG_FIRST + 11)
#define ID_LANG_JAPANESE_JIS_AUTO           (ID_LANG_FIRST + 12)
#define ID_LANG_JAPANESE_JIS                (ID_LANG_FIRST + 13)
#define ID_LANG_JAPANESE_SJIS_AUTO          (ID_LANG_FIRST + 14)
#define ID_LANG_JAPANESE_SJIS               (ID_LANG_FIRST + 15)
#define ID_LANG_JAPANESE_EUC_AUTO           (ID_LANG_FIRST + 16)
#define ID_LANG_JAPANESE_EUC                (ID_LANG_FIRST + 17)
#define ID_LANG_SIMPLE_CHINESE_CNGB         (ID_LANG_FIRST + 18)
#define ID_LANG_SIMPLE_CHINESE_HZGB         (ID_LANG_FIRST + 19)
#define ID_LANG_SIMPLE_CHINESE_GBK          (ID_LANG_FIRST + 20)
#define ID_LANG_TRAD_CHINESE_CNBIG5         (ID_LANG_FIRST + 21)
#define ID_LANG_TRAD_CHINESE_BIG5           (ID_LANG_FIRST + 22)
#define ID_LANG_KOREAN_KSC                  (ID_LANG_FIRST + 23)
#define ID_LANG_LAST                        (ID_LANG_FIRST + 50)

#define ID_VIEW_FILTER_FIRST                (ID_LANG_LAST + 1)
#define ID_VIEW_ALL                         ID_VIEW_FILTER_FIRST
#define ID_VIEW_UNREAD                      (ID_VIEW_FILTER_FIRST + 1)
#define ID_VIEW_DOWNLOADED                  (ID_VIEW_FILTER_FIRST + 2)
#define ID_VIEW_IGNORED                     (ID_VIEW_FILTER_FIRST + 3)
#define ID_VIEW_DEFAULT_SEPERATOR           (ID_VIEW_FILTER_FIRST + 4)
#define ID_VIEW_CURRENT                     (ID_VIEW_FILTER_FIRST + 5)
#define ID_VIEW_CURRENT_SEPERATOR           (ID_VIEW_FILTER_FIRST + 6)
#define ID_VIEW_RECENT_0                    (ID_VIEW_FILTER_FIRST + 7)
#define ID_VIEW_RECENT_1                    (ID_VIEW_FILTER_FIRST + 8)
#define ID_VIEW_RECENT_2                    (ID_VIEW_FILTER_FIRST + 9)
#define ID_VIEW_RECENT_3                    (ID_VIEW_FILTER_FIRST + 10)
#define ID_VIEW_RECENT_4                    (ID_VIEW_FILTER_FIRST + 11)
#define ID_VIEW_RECENT_SEPERATOR            (ID_VIEW_FILTER_FIRST + 12)
#define ID_VIEW_CUSTOMIZE                   (ID_VIEW_FILTER_FIRST + 13)
#define ID_VIEW_MANAGER                     (ID_VIEW_FILTER_FIRST + 14)
#define ID_SHOW_REPLIES                     (ID_VIEW_FILTER_FIRST + 15)
#define ID_SHOW_DELETED                     (ID_VIEW_FILTER_FIRST + 16)
#define ID_THREAD_MESSAGES                  (ID_VIEW_FILTER_FIRST + 17)
#define ID_VIEW_APPLY                       (ID_VIEW_FILTER_FIRST + 18)
#define ID_VIEW_FILTER_LAST                 (ID_VIEW_FILTER_FIRST + 50)

#define ID_NEW_ACCT_FIRST                   (ID_VIEW_FILTER_LAST + 1)
#define ID_NEW_ACCT_LAST                    (ID_NEW_ACCT_FIRST + 20)

#define ID_MESSENGER_FIRST                  (ID_NEW_ACCT_LAST + 1)
#define ID_POPUP_MESSENGER                  ID_MESSENGER_FIRST
#define ID_POPUP_MESSENGER_STATUS           (ID_MESSENGER_FIRST + 1)
#define ID_LOGIN_MESSENGER                  (ID_MESSENGER_FIRST + 2)
#define ID_MESSENGER_ONLINE                 (ID_MESSENGER_FIRST + 3)
#define ID_MESSENGER_INVISIBLE              (ID_MESSENGER_FIRST + 4)
#define ID_MESSENGER_BUSY                   (ID_MESSENGER_FIRST + 5)
#define ID_MESSENGER_BACK                   (ID_MESSENGER_FIRST + 6)
#define ID_MESSENGER_AWAY                   (ID_MESSENGER_FIRST + 7)
#define ID_MESSENGER_ON_PHONE               (ID_MESSENGER_FIRST + 8)
#define ID_MESSENGER_LUNCH                  (ID_MESSENGER_FIRST + 9)
#define ID_MESSENGER_OPTIONS                (ID_MESSENGER_FIRST + 10)
#define ID_LOGOFF_MESSENGER                 (ID_MESSENGER_FIRST + 11)
#define ID_MESSENGER_LAST                   (ID_MESSENGER_FIRST + 12)

//
// END COMMAND IDs
/////////////////////////////////////////////////////////////////////////////

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        118
#define _APS_NEXT_COMMAND_VALUE         (ID_FIRST + 349)
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\progress.h ===
#define idcANI       1000
#define idcProgBar   1001
#define idsMsg       1002
#define IDC_ACCOUNT_STATIC 1003
#define IDC_FOO_STATIC     1004
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\res.inc ===
ATHROOT=..
R=$(ATHROOT)\mailnews
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDOCOBJ -DDBCS_DIVIDE -DBCC -D_MSOEAPI_ -D_WINDLL
WIN32_IE_VERSION=0x0500

INCLUDES=\
    $(BASEDIR)\private\windows\inc; \
    $(ATHROOT)\msoeres; \
    $(R)\inc; \
    $(R)\inc\$(O); \
    $(R)\common; \
    $(R)\shell; \
    $(R)\objectdb; \
    $(R)\mail; \
    $(R)\news; \
    $(R)\rules; \
    $(R)\store; \
    $(R)\spooler; \
    $(R)\view; \
    $(R)\imap; \
    $(R)\bactrl; \
    $(R)\extinc; \
    $(ATHROOT)\inetcomm\mimeole; \
    $(ATHROOT)\directdb\inc; \
    $(ATHROOT)\directdb\inc\$(O); \
    $(ATHROOT)\common; \
    $(BASEDIR)\public\sdk\inc\atl21; \
    $(INCLUDES)

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

# NOTE: star below is replaced with platform by platform-specific .inc
# file in %_NTROOT%\public\oak\bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\resource.h ===
//
// resource.h
//
// contains global resource identifiers
//

#ifndef __RESOURCE_H
#define __RESOURCE_H

#define RT_FILE                         2110

/////////////////////////////////////////////////////////////////////////////
//
//  * * * RESOURCE NAMING CONVENTIONS * * *
//
/////////////////////////////////////////////////////////////////////////////
//
//  Resource Type       Prefix      Comments
//  -------------       ------      --------
//
//  String              ids         menu help strings should end in MH
//  Menu command        idm
//  Menu resource       idmr
//  Bitmap              idb
//  Icon                idi
//  Animation           idan
//  Dialog              idd
//  Dialog control      idc
//  Cursor              idcur
//  Raw RCDATA          idr
//  Accelerator         idac
//  Window              idw
//
/////////////////////////////////////////////////////////////////////////////

// #define MH_BASE                         1
// #define TT_BASE                         (IDM_LAST + MH_BASE + 1)
// #define STR_FIRST                       (IDM_LAST + TT_BASE + 1)
// #define IDM_FIRST                       100
// #define IDM_LAST                        (IDM_FIRST + 2000)

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN String Resource IDs
//

// TOOLTIP strings
#define TT_BASE                         2102
#define idsNewMsg                       (TT_BASE + 0)
#define idsPrint                        (TT_BASE + 2)
#define idsNextUnreadNewsgroup          (TT_BASE + 3)
#define idsNextUnreadArticle            (TT_BASE + 4)
#define idsNextUnreadTopic              (TT_BASE + 5)
#define idsMarkRead                     (TT_BASE + 6)
#define idsConnect                      (TT_BASE + 7)
#define idsMarkDownload                 (TT_BASE + 8)
#define idsFind                         (TT_BASE + 9)
#define idsNewArticleTT                 (TT_BASE + 11)
#define idsReplyPostTT                  (TT_BASE + 12)
#define idsForwardTT                    (TT_BASE + 14)
#define idsReplyTT                      (TT_BASE + 16)
#define idsReplyAllTT                   (TT_BASE + 17)
#define idsGotoInboxTT                  (TT_BASE + 18)
#define idsDeliverMailTT                (TT_BASE + 19)
#define idsUndoTT                       (TT_BASE + 20)
#define idsSendMsgTT                    (TT_BASE + 22)
#define idsCutTT                        (TT_BASE + 24)
#define idsCopyTT                       (TT_BASE + 25)
#define idsPasteTT                      (TT_BASE + 26)
#define idsCheckNamesTT                 (TT_BASE + 27)
#define idsPickRecipientsTT             (TT_BASE + 28)
#define idsInsertFileTT                 (TT_BASE + 29)
#define idsPreviousTT                   (TT_BASE + 30)
#define idsNextTT                       (TT_BASE + 31)
#define idsPostMsgTT                    (TT_BASE + 44)
#define idsMarkTopicReadTT              (TT_BASE + 46)
#define idsInsertSigTT                  (TT_BASE + 48)
#define idsAddressBookTT                (TT_BASE + 49)
#define idsDigSignTT                    (TT_BASE + 57)
#define idsEncryptTT                    (TT_BASE + 58)
#define idsLanguage                     (TT_BASE + 59)
#define idsFolderListTT                 (TT_BASE + 60)
#define idsDownloadNewsgroupTT          (TT_BASE + 64)
#define idsSendDefaultTT                (TT_BASE + 66)
#define idsViewRefreshTT                (TT_BASE + 67)
#define idsPurgeTT                      (TT_BASE + 68)
#define idsSetPriorityTT                (TT_BASE + 69)
#define idsSpellingTT                   (TT_BASE + 70)
#define idsBAControlTT                  (TT_BASE + 71)
#define idsEnvBccTT                     (TT_BASE + 72)
#define idsSynchronizeNowBtnTT          (TT_BASE + 73)

//
// regular strings (not tooltips and not menu help strings)
//

#define STR_FIRST                       4203
#define idsAthena                       (STR_FIRST + 8)
#define idsAthenaMail                   idsAthena
#define idsAthenaNews                   idsAthena
#define idsTo                           (STR_FIRST + 13)
#define idsFrom                         (STR_FIRST + 14)
#define idsSubject                      (STR_FIRST + 15)
#define idsReceived                     (STR_FIRST + 16)
#define idsSent                         (STR_FIRST + 17)
#define idsSize                         (STR_FIRST + 18)
//#define idsSimpleMAPI                 (STR_FIRST + 19)
//#define idsSmapichanged               (STR_FIRST + 20)

// keep the mailview column description string ids in sequence
#define idsFromField                    (STR_FIRST + 21)
#define idsToField                      (STR_FIRST + 22)
#define idsCcField                      (STR_FIRST + 23)
#define idsSubjectField                 (STR_FIRST + 24)
#define idsAddressBook                  (STR_FIRST + 25)
#define idsPostNews                     (STR_FIRST + 28)
#define idsReplyToNewsGroup             (STR_FIRST + 29)

// keep the color strings contiguous
#define idsAutoColor                    (STR_FIRST + 31)
#define idsColor1                       (STR_FIRST + 32)
#define idsColor2                       (STR_FIRST + 33)
#define idsColor3                       (STR_FIRST + 34)
#define idsColor4                       (STR_FIRST + 35)
#define idsColor5                       (STR_FIRST + 36)
#define idsColor6                       (STR_FIRST + 37)
#define idsColor7                       (STR_FIRST + 38)
#define idsColor8                       (STR_FIRST + 39)
#define idsColor9                       (STR_FIRST + 40)
#define idsColor10                      (STR_FIRST + 41)
#define idsColor11                      (STR_FIRST + 42)
#define idsColor12                      (STR_FIRST + 43)
#define idsColor13                      (STR_FIRST + 44)
#define idsColor14                      (STR_FIRST + 45)
#define idsColor15                      (STR_FIRST + 46)
#define idsColor16                      (STR_FIRST + 47)
// keep the color strings contiguous

//#define idsSmapiClose                 (STR_FIRST + 48)
#define idsHideHotmailMenu              (STR_FIRST + 49)
#define idsPostSentToServer             (STR_FIRST + 50)
#define idsPostInOutbox                 (STR_FIRST + 51)
#define idsNewsgroups                   (STR_FIRST + 52)
#define idsDescription                  (STR_FIRST + 53)
#define idsSavedMessage                 (STR_FIRST + 54)
#define idsSendMail                     (STR_FIRST + 55)
#define idsMailInOutbox                 (STR_FIRST + 56)
#define idsSavedInDrafts                (STR_FIRST + 57)
#define idsDelSentToServer              (STR_FIRST + 59)
#define idsEmptyTo                      (STR_FIRST + 60)
#define idsEmptyCc                      (STR_FIRST + 61)
#define idsEmptySubject                 (STR_FIRST + 62)
#define idsNoCcOrTo                     (STR_FIRST + 63)
#define idsNoSubject                    (STR_FIRST + 64)
#define idsTTTo                         (STR_FIRST + 65)
#define idsTTCc                         (STR_FIRST + 66)
#define idsTTSubject                    (STR_FIRST + 67)
#define idsTTRecipients                 (STR_FIRST + 68)
#define idsPostNewsMsg                  (STR_FIRST + 70)
#define idsSaveChangesMsg               (STR_FIRST + 71)
#define idsCantSaveMsg                  (STR_FIRST + 72)
#define idsDontShowMeAgain              (STR_FIRST + 74)
#define idsDontAskMeAgain               (STR_FIRST + 75)
#define idsNewsgroupsField              (STR_FIRST + 81)
#define idsEmptyNewsgroups              (STR_FIRST + 82)
#define idsDateField                    (STR_FIRST + 83)
#define idsShowingFolders               (STR_FIRST + 85)
#define idsHidingFolders                (STR_FIRST + 86)
#define idsWantToHideFolder             (STR_FIRST + 88)
#define idsWantToUnSubscribe            (STR_FIRST + 89)
#define idsWantToHideFolderN            (STR_FIRST + 90)
#define idsWantToUnSubscribeN           (STR_FIRST + 91)
#define idsHTMLErrNewsCantOpen          (STR_FIRST + 93)
#define idsErrAttmanLoadFail            (STR_FIRST + 94)
#define idsNewNote                      (STR_FIRST + 95)
#define idsAttachment                   (STR_FIRST + 96)
#define idsSaveAttachmentAs             (STR_FIRST + 97)
#define idsTTAttachment                 (STR_FIRST + 98)
#define idsNoFromField                  (STR_FIRST + 102)
#define idsTTNewsgroups                 (STR_FIRST + 103)
#define idsDownloadArtTitle             (STR_FIRST + 104)
#define idsDownloadArtMsg               (STR_FIRST + 105)
#define idsErrNoPoster                  (STR_FIRST + 106)
#define idsDownloadingGroups            (STR_FIRST + 110)
#define idsDownloadingDesc              (STR_FIRST + 112)
#define idsUnknown                      (STR_FIRST + 114)
#define idsShowDetails                  (STR_FIRST + 117)
#define idsHideDetails                  (STR_FIRST + 118)
#define idsFilterAttSave                (STR_FIRST + 129)
#define idsCompose                      (STR_FIRST + 139)
#define idsMailReply                    (STR_FIRST + 141)
#define idsForward                      (STR_FIRST + 142)
#define idsReply                        (STR_FIRST + 144)
#define idsReplyAll                     (STR_FIRST + 145)
#define idsDefMailExt                   (STR_FIRST + 148)
#define idsDefNewsExt                   (STR_FIRST + 149)
#define idsMailSaveAsTitle              (STR_FIRST + 151)
#define idsUnableToSaveMessage          (STR_FIRST + 152)
#define idsRequestingArt                (STR_FIRST + 153)
#define idsDownloadArtBytes             (STR_FIRST + 154)

#define idsDownloadingHeaders           (STR_FIRST + 172)
#define idsDownloadingArticle           (STR_FIRST + 173)
#define idsNewsStatus                   (STR_FIRST + 174)
#define idsErrPeerClosed                (STR_FIRST + 179)
#define idsErrAuthenticate              (STR_FIRST + 193)

// Options Spelling dialog strings
#define idsSpellClose                   (STR_FIRST + 201)
#define idsSpellCaption                 (STR_FIRST + 202)
#define idsSpellRepeatWord              (STR_FIRST + 203)
#define idsSpellWordNeedsCap            (STR_FIRST + 204)
#define idsSpellWordNotFound            (STR_FIRST + 205)
#define idsSpellNoSuggestions           (STR_FIRST + 206)
#define idsSpellDelete                  (STR_FIRST + 207)
#define idsSpellDeleteAll               (STR_FIRST + 208)
#define idsSpellChange                  (STR_FIRST + 209)
#define idsSpellChangeAll               (STR_FIRST + 210)
#define idsSpellMsgDone                 (STR_FIRST + 212)
#define idsSpellMsgContinue             (STR_FIRST + 213)
#define idsSpellMsgConfirm              (STR_FIRST + 214)
#define idsSpellMsgSendOK               (STR_FIRST + 215)

#define idsErrSpellGenericSpell         (STR_FIRST + 221)
#define idsErrSpellGenericLoad          (STR_FIRST + 222)
#define idsErrSpellMainDictLoad         (STR_FIRST + 223)
#define idsErrSpellVersion              (STR_FIRST + 224)
#define idsErrSpellUserDictLoad         (STR_FIRST + 226)
#define idsErrSpellUserDictOpenRO       (STR_FIRST + 227)
#define idsErrSpellCacheWordLen         (STR_FIRST + 230)
#define idsPrefixReply                  (STR_FIRST + 231)
#define idsPrefixForward                (STR_FIRST + 232)
#define idsErrSpellLangChanged          (STR_FIRST + 234)
#define idsErrSpellWarnDictionary       (STR_FIRST + 235)

// keep this contiguous please, or i'll kill you
#define idsInbox                        (STR_FIRST + 242)
#define idsOutbox                       (STR_FIRST + 243)
#define idsSentItems                    (STR_FIRST + 244)
#define idsDeletedItems                 (STR_FIRST + 245)
#define idsDraft                        (STR_FIRST + 246)
#define idsOfflineErrors                (STR_FIRST + 247)
#define idsJunkFolderName               (STR_FIRST + 248)
#define idsMsnPromo                     (STR_FIRST + 249)
// keep this contiguous please, or i'll kill you

#define idsTextFileFilter               (STR_FIRST + 250)
#define idsAllFilesFilter               (STR_FIRST + 251)
#define idsAttach                       (STR_FIRST + 252)
#define idsInsertAttachment             (STR_FIRST + 253)
#define idsDropLinkDirs                 (STR_FIRST + 255)
#define idsAttConfirmDeletion           (STR_FIRST + 256)
#define idsWarnEmptyJunkMail            (STR_FIRST + 257)
#define idsWarnSomePermDelete           (STR_FIRST + 258)
#define idsErrCreateNewFld              (STR_FIRST + 259)
#define idsErrRenameFld                 (STR_FIRST + 260)
#define idsWarnDeleteFolderN            (STR_FIRST + 261)
#define idsWarnDeleteFolder             (STR_FIRST + 262)
#define idsErrRenameSpecialFld          (STR_FIRST + 263)
#define idsErrFolderNameConflict        (STR_FIRST + 264)
#define idsErrBadFolderName             (STR_FIRST + 265)
#define idsErrDeleteSpecialFolder       (STR_FIRST + 266)
#define idsWarnEmptyDeletedItems        (STR_FIRST + 267)
#define idsWarnPermDelete               (STR_FIRST + 268)
#define idsPromptDeleteFolder           (STR_FIRST + 269)
#define idsPromptDeleteFolderN          (STR_FIRST + 270)
#define idsDoYouWantToSave              (STR_FIRST + 274)
#define idsXMsgsYUnread                 (STR_FIRST + 277)
#define idsXMsgs                        (STR_FIRST + 278)
#define idsErrNoRecipients              (STR_FIRST + 299)
#define idsMigrateMessagesODS           (STR_FIRST + 300)
#define idsPropPageSecurity             (STR_FIRST + 301)
#define idsPropPageGeneral              (STR_FIRST + 302)
#define idsPropPageDetails              (STR_FIRST + 303)
#define idsErrReplyForward              (STR_FIRST + 304)
#define idsShowFavorites                (STR_FIRST + 310)
#define idsErrCantResolveGroup          (STR_FIRST + 315)
#define idsEmptySubjectRO               (STR_FIRST + 316)
#define idsMailRundllFailed             (STR_FIRST + 319)
#define idsNewsRundllFailed             (STR_FIRST + 320)
#define idsRecipient                    (STR_FIRST + 322)
#define idsNoNewGroupsAvail             (STR_FIRST + 328)
#define idsNewGroups                    (STR_FIRST + 329)
#define idsErrNoSubject                 (STR_FIRST + 333)
#define idsEmlFileFilter                (STR_FIRST + 334)
#define idsNwsFileFilter                (STR_FIRST + 335)
#define idsBase64                       (STR_FIRST + 338)
#define idsQuotedPrintable              (STR_FIRST + 339)
#define idsEnterPollTime                (STR_FIRST + 342)
#define idsEnterSigText                 (STR_FIRST + 345)
#define idsEnterSigFile                 (STR_FIRST + 346)
#define idsOptions                      (STR_FIRST + 347)
#define idsWarnSigTruncated             (STR_FIRST + 348)
#define idsWarnSigNotFound              (STR_FIRST + 350)
#define idsWarnSigBinary                (STR_FIRST + 351)
#define idsWarnUnsentMail               (STR_FIRST + 355)
#define idsErrRemoveServer              (STR_FIRST + 358)
#define idsEnterPreviewTime             (STR_FIRST + 361)
#define idsEnterDownloadChunks          (STR_FIRST + 362)
#define idsSBSending                    (STR_FIRST + 367)
#define idsSBReceiving                  (STR_FIRST + 368)
#define idsSBConnecting                 (STR_FIRST + 369)
#define idsSBNoNewMsgs                  (STR_FIRST + 370)
#define idsSBNewMsgsControl             (STR_FIRST + 371)
#define idsSBChecking                   (STR_FIRST + 372)
#define idsPropAttachNone               (STR_FIRST + 373)
#define idsUnderComp                    (STR_FIRST + 375)
#define idsSortMenuHelpControl          (STR_FIRST + 377)
#define idsCharsetMapChange             (STR_FIRST + 380)

#define idsDisplayImapSubDlg            (STR_FIRST + 382)
#define idsDisplayNewsSubDlg            (STR_FIRST + 383)
#define idsNone                         (STR_FIRST + 387)
#define idsAuthorizing                  (STR_FIRST + 389)
#define idsRenameFolderTitle            (STR_FIRST + 398)
#define idsTabSubscribed                (STR_FIRST + 399)
#define idsTabAll                       (STR_FIRST + 400)
#define idsTabNew                       (STR_FIRST + 401)
#define idsFile                         (STR_FIRST + 402)
#define idsVersion                      (STR_FIRST + 403)
#define idsFollowupToField              (STR_FIRST + 404)
#define idsReplyToField                 (STR_FIRST + 405)
#define idsOrgField                     (STR_FIRST + 406)
#define idsDistributionField            (STR_FIRST + 407)
#define idsKeywordsField                (STR_FIRST + 408)
#define idsApprovedField                (STR_FIRST + 409)
#define idsFullPath                     (STR_FIRST + 410)
//#define idsNotLoaded                    (STR_FIRST + 411)

// Address Book Strings
#define idsGeneralWabError              (STR_FIRST + 412)

#define idsEmptyFollowupTo              (STR_FIRST + 415)
#define idsEmptyDistribution            (STR_FIRST + 416)
#define idsEmptyKeywords                (STR_FIRST + 417)
#define idsEmptyReplyTo                 (STR_FIRST + 418)
#define idsNotSpecified                 (STR_FIRST + 419)
#define idsCancelFailed                 (STR_FIRST + 422)
#define idsEnterAutoWrap                (STR_FIRST + 427)

#define idsMsgRecipients                (STR_FIRST + 441)
#define idsErrAddToWAB                  (STR_FIRST + 442)
#define idsErrAddrProps                 (STR_FIRST + 443)
#define idsErrBadRecipients             (STR_FIRST + 444)
#define idsErrDeleteMsg                 (STR_FIRST + 445)
#define idsErrPickNames                 (STR_FIRST + 446)
#define idsErrAddrDupe                  (STR_FIRST + 447)

#define idsControlField                 (STR_FIRST + 448)
#define idsTTControl                    (STR_FIRST + 449)

#define idsErrConfigureServer           (STR_FIRST + 450)
#define idsErrAddCertToWAB              (STR_FIRST + 452)
#define idsErrOpenManyMessages          (STR_FIRST + 453)
#define idsIgnoreResolveError           (STR_FIRST + 458)
#define idsConfirmResetAll              (STR_FIRST + 459)
#define idsConfirmResetStore            (STR_FIRST + 460)
#define idsConfirmReset                 (STR_FIRST + 461)
#define idsMigDBXTitle                  (STR_FIRST + 462)
#define idsErrSendMail                  (STR_FIRST + 473)
#define idsErrDelete                    (STR_FIRST + 478)
#define idsErrImport                    (STR_FIRST + 480)
#define idsErrImportLoad                (STR_FIRST + 481)
#define idsHTMLErrNewsExpired           (STR_FIRST + 483)
#define idsBack                         (STR_FIRST + 484)
#define idsNext                         (STR_FIRST + 485)

#define idsPropPageEncryption           (STR_FIRST + 486)

#define idsTTFollowup                   (STR_FIRST + 510)
#define idsTTDistribution               (STR_FIRST + 511)
#define idsTTKeywords                   (STR_FIRST + 512)
#define idsTTReplyTo                    (STR_FIRST + 513)
#define idsTTApproved                   (STR_FIRST + 514)
#define idsTTPickNewsgroups             (STR_FIRST + 515)
#define idsErrDeleteOnExit              (STR_FIRST + 518)
#define idsFolderLocked                 (STR_FIRST + 519)
#define idsGenericError                 (STR_FIRST + 520)
#define idsCcWell                       (STR_FIRST + 521)
#define idsErrOnlyOneReplyTo            (STR_FIRST + 522)
#define idsReplyToWell                  (STR_FIRST + 523)
#define idsWarnNewsEmptySubj            (STR_FIRST + 530)
#define idsWarnMailEmptySubj            (STR_FIRST + 531)
#define idsEnterDays                    (STR_FIRST + 532)
#define idsWastedKB                     (STR_FIRST + 536)
#define idsErrCreateExists              (STR_FIRST + 537)

#define idsEnterCompactPer              (STR_FIRST + 538)
#define idsDelete                       (STR_FIRST + 542)
#define idsCantLoadMapi32Dll            (STR_FIRST + 544)
#define idsErrBadFindParams             (STR_FIRST + 545)
#define idsErrNewsgroupLineTooLong      (STR_FIRST + 549)
#define idsNoteLangTitle                (STR_FIRST + 550)
#define idsCompacting                   (STR_FIRST + 551)
#define idsConfirmDelBodies             (STR_FIRST + 552)
#define idsConfirmDelBodiesStore        (STR_FIRST + 553)
#define idsConfirmDelBodiesAll          (STR_FIRST + 554)
#define idsConfirmDelMsgs               (STR_FIRST + 555)

// don't make me kill you for reordering the following ids...
#define idsNotConnected                 (STR_FIRST + 556)
#define idsReconnecting                 (STR_FIRST + 557)
#define idsFindingHost                  (STR_FIRST + 558)
#define idsFoundHost                    (STR_FIRST + 559)
#define idsConnecting                   (STR_FIRST + 560)
#define idsConnected                    (STR_FIRST + 561)
#define idsSecuring                     (STR_FIRST + 562)
// don't make me kill you for reordering the preceding ids...

#define idsBCcField                     (STR_FIRST + 563)
#define idsEmptyBCc                     (STR_FIRST + 564)
#define idsTTBCc                        (STR_FIRST + 565)
#define idsMemory                       (STR_FIRST + 567)
#define idsDiskFull                     (STR_FIRST + 568)
#define idsErrExport                    (STR_FIRST + 574)
#define idsCleaningUp                   (STR_FIRST + 575)
#define idsErrBadRecips                 (STR_FIRST + 576)
#define idsSaveAs                       (STR_FIRST + 577)
#define idsCancelArticle                (STR_FIRST + 578)
#define idsMarkAllRead                  (STR_FIRST + 579)
#define idsMarkUnread                   (STR_FIRST + 580)
#define idsGotoOutbox                   (STR_FIRST + 581)
#define idsHelp                         (STR_FIRST + 587)
#define idsProgDLPost                   (STR_FIRST + 588)
#define idsProgDLMessage                (STR_FIRST + 589)
#define idsProgDLGetLines               (STR_FIRST + 593)
#define idsGoToSentItems                (STR_FIRST + 598)
#define idsMarkReadTT                   (STR_FIRST + 599)
#define idsMaxCoolbarBtnWidth           (STR_FIRST + 619)
#define idsProgCombiningMsgs            (STR_FIRST + 620)
#define idsMaxOutbarBtnWidth            (STR_FIRST + 624)
#define idshrRasInitFailure             (STR_FIRST + 625)
#define idshrRasDialFailure             (STR_FIRST + 626)
#define idshrRasServerNotFound          (STR_FIRST + 627)
#define idsRasError                     (STR_FIRST + 628)

#define idshrGetDialParamsFailed        (STR_FIRST + 630)
#define idsPriLow                       (STR_FIRST + 634)
#define idsPriHigh                      (STR_FIRST + 635)
#define idsPriNormal                    (STR_FIRST + 636)
#define idsWarnUseMailCertInNews        (STR_FIRST + 637)
#define idsWarnHTMLToPlain              (STR_FIRST + 638)

#define idsMoveTo                       (STR_FIRST + 647)
#define idsCopyTo                       (STR_FIRST + 648)
#define idsDisconnect                   (STR_FIRST + 649)
#define IDS_BROWSE_FOLDER               (STR_FIRST + 650)
#define idsRasErrorGeneral              (STR_FIRST + 651)
#define idsRas_Dialing                  (STR_FIRST + 652)
#define idsRas_Authentication           (STR_FIRST + 653)
#define idsErrorText                    (STR_FIRST + 654)
#define idsRas_Authenticated            (STR_FIRST + 655)
#define idsRASCS_OpenPort               (STR_FIRST + 657)
#define idsRASCS_PortOpened             (STR_FIRST + 658)
#define idsRASCS_ConnectDevice          (STR_FIRST + 659)
#define idsRASCS_DeviceConnected        (STR_FIRST + 660)
#define idsRASCS_AuthNotify             (STR_FIRST + 661)
#define idsRASCS_AuthRetry              (STR_FIRST + 662)
#define idsRASCS_AuthCallback           (STR_FIRST + 663)
#define idsRASCS_AuthChangePassword     (STR_FIRST + 664)
#define idsRASCS_AuthProject            (STR_FIRST + 665)
#define idsRASCS_AuthLinkSpeed          (STR_FIRST + 666)
#define idsRASCS_AuthAck                (STR_FIRST + 667)
#define idsRASCS_Authenticated          (STR_FIRST + 669)
#define idsRASCS_PrepareForCallback     (STR_FIRST + 670)
#define idsRASCS_WaitForModemReset      (STR_FIRST + 671)
#define idsRASCS_WaitForCallback        (STR_FIRST + 672)
#define idsRASCS_Projected              (STR_FIRST + 673)
#define idsRASCS_Connected              (STR_FIRST + 674)
#define idsRASCS_Disconnected           (STR_FIRST + 675)
#define idshrSetDialParamsFailed        (STR_FIRST + 676)
#define idsRASCS_AllDevicesConnected    (STR_FIRST + 678)
#define idsDefault                      (STR_FIRST + 681)
#define idsFailACacheCompact            (STR_FIRST + 682)
#define idsFailACacheCompactReason      (STR_FIRST + 683)
#define idsConfirmDelMsgsStore          (STR_FIRST + 684)
#define idsConfirmDelMsgsAll            (STR_FIRST + 685)

// For the HTML Welcome message
#define idsWelcomeMessageSubj           (STR_FIRST + 686)
#define idsSpoolerDisconnect            (STR_FIRST + 696)
#define idsHTMLErrArticleNotCached      (STR_FIRST + 699)

#define idsStopTT                       (STR_FIRST + 701)

#define idsSecurityWarning              (STR_FIRST + 702)
#define idsProgDLPostTo                 (STR_FIRST + 707)
#define idsMigMsgsODSError              (STR_FIRST + 708)
#define idsMigMsgsODSNoDiskSpace        (STR_FIRST + 709)
#define idsHelpMSWebFirst               (STR_FIRST + 710)
#define idsHelpMSWebFree                (STR_FIRST + 711)
#define idsHelpMSWebProductNews         (STR_FIRST + 712)
#define idsHelpMSWebFaq                 (STR_FIRST + 713)
#define idsHelpMSWebSupport             (STR_FIRST + 714)
#define idsHelpMSWebFeedback            (STR_FIRST + 715)
#define idsHelpMSWebBest                (STR_FIRST + 716)
#define idsHelpMSWebSearch              (STR_FIRST + 717)
#define idsHelpMSWebHome                (STR_FIRST + 718)
#define idsHelpMSWebOutlook             (STR_FIRST + 719)
#define idsHelpMSWebIE                  (STR_FIRST + 720)
#define idsHelpMSWebCert                (STR_FIRST + 721)
#define idsHelpMSWebCertSubName         (STR_FIRST + 722)
#define idsHelpMSWebHotmail             (STR_FIRST + 723)
#define idsHelpMSWebLast                (STR_FIRST + 730)

#define idsCombineAndDecodeTT           (STR_FIRST + 732)
#define idsPostAndDownloadTT            (STR_FIRST + 733)
#define idsGetNextTT                    (STR_FIRST + 734)
#define idsUnscrambleTT                 (STR_FIRST + 735)
#define idsErrCantCombineNotConnected   (STR_FIRST + 737)
#define idsErrHTMLInNewsIsBad           (STR_FIRST + 740)
#define idsRasPromptDisconnect          (STR_FIRST + 741)
#define idsProgReceivedLines            (STR_FIRST + 743)
#define idsErrSendDownloadFail          (STR_FIRST + 745)
#define idsErrSaveDownloadFail          (STR_FIRST + 746)

#define idsOK                           (STR_FIRST + 750)
#define idsYES                          (STR_FIRST + 751)
#define idsNO                           (STR_FIRST + 752)
#define idsCANCEL                       (STR_FIRST + 753)

#define idsHTMLErrNewsDLCancelled       (STR_FIRST + 781)
#define idsNewMailNotify                (STR_FIRST + 794)
#define idsXMsgsYUnreadZonServ          (STR_FIRST + 795)
#define idsGetHeaderFmt                 (STR_FIRST + 796)
#define idsHTMLDiskOutOfSpace           (STR_FIRST + 799)   // Bug# 50704 (v-snatar)

#define idsToWell                       (STR_FIRST + 822)
#define idsFromWell                     (STR_FIRST + 823)
#define idsFolder                       (STR_FIRST + 829)
#define idsIn                           (STR_FIRST + 838)
#define idsKB                           (STR_FIRST + 844)
#define idsRulePickFrom                 (STR_FIRST + 852)
#define idsRulePickTo                   (STR_FIRST + 853)
#define idsRulePickForwardTo            (STR_FIRST + 854)
#define idsRulePickCC                   (STR_FIRST + 855)
#define idsNameCol                      (STR_FIRST + 861)
#define idsUnread                       (STR_FIRST + 862)
#define idsNew                          (STR_FIRST + 863)
#define idsLastUpdated                  (STR_FIRST + 864)
#define idsWastedSpace                  (STR_FIRST + 865)
#define idsTotal                        (STR_FIRST + 866)
#define idsErrDDFileNotFound            (STR_FIRST + 867)
#define idsGroupPropStatusDef           (STR_FIRST + 871)
#define idsFolderPropStatusDef          (STR_FIRST + 872)

#define idsFolderPropStatus             (STR_FIRST + 874)
#define idsTipOfTheDay                  (STR_FIRST + 875)
#define idsNextTip                      (STR_FIRST + 876)
#define idsRulePickToOrCC               (STR_FIRST + 877)
#define idsEmptyControl                 (STR_FIRST + 878)
#define idsEmptyApproved                (STR_FIRST + 879)

#define idshrCantOpenOutbox             (STR_FIRST + 908)
#define idsInetMailConnectingHost       (STR_FIRST + 923)
#define idsInetMailRecvStatus           (STR_FIRST + 932)
#define idsDetail_Account               (STR_FIRST + 941)
#define idsDetail_Server                (STR_FIRST + 942)
#define idsDetail_UserName              (STR_FIRST + 943)
#define idsDetail_Protocol              (STR_FIRST + 944)
#define idsDetail_Port                  (STR_FIRST + 945)
#define idsDetail_Secure                (STR_FIRST + 946)
#define idsDetail_ErrorNumber           (STR_FIRST + 947)
#define idsDetail_HRESULT               (STR_FIRST + 948)
#define idsDetails_Config               (STR_FIRST + 949)

#define idshrLockUidCacheFailed         (STR_FIRST + 986)
#define idshrCantLeaveOnServer          (STR_FIRST + 988)
#define idsAccount                      (STR_FIRST + 997)
#define idsSendMsgUsing                 (STR_FIRST + 999)
#define idsSendMsgAccelTip              (STR_FIRST + 1000)
#define idsDefaultAccount               (STR_FIRST + 1001)
#define idsConnection                   (STR_FIRST + 1002)
#define idsConnectionLAN                (STR_FIRST + 1003)
#define idsConnectionManual             (STR_FIRST + 1004)
#define idsSendMsgOneAccount            (STR_FIRST + 1008)
#define idsErrNoSendAccounts            (STR_FIRST + 1009)
#define idsWarnDeleteAccount            (STR_FIRST + 1014)
#define idsPollAllAccounts              (STR_FIRST + 1015)
#define idsRuleNtfySndFilter            (STR_FIRST + 1016)
#define idsSecurityField                (STR_FIRST + 1017)
#define idsStitchingMessages            (STR_FIRST + 1018)
#define idsRuleReplyWithFilter          (STR_FIRST + 1019)
#define idsCopy                         (STR_FIRST + 1020)
#define idsCopyCaption                  (STR_FIRST + 1021)
#define idsMove                         (STR_FIRST + 1022)
#define idsMoveCaption                  (STR_FIRST + 1023)
#define idsErrFolderMove                (STR_FIRST + 1026)
#define idsErrCantMoveIntoSubfolder     (STR_FIRST + 1027)
#define idsErrURLExec                   (STR_FIRST + 1028)
#define idsErrNoteDeferedInit           (STR_FIRST + 1029)
#define idsErrCannotMoveSpecial         (STR_FIRST + 1030)
#define idsErrLoadingHtmlEdit           (STR_FIRST + 1031)
#define idsErrLoadingWAB                (STR_FIRST + 1032)
#define idsErrWAB                       (STR_FIRST + 1033)
#define idsErrRTLDirFailed              (STR_FIRST + 1034)

// Languages for purposes of spelling
#define idsDefaultLang                  (STR_FIRST + 1058)

#define idsWarnDeleteManyFolders        (STR_FIRST + 1070)
#define idsDownloadingImapFldrs         (STR_FIRST + 1072)
#define idsColLines                     (STR_FIRST + 1073)
#define idsNewFolder                    (STR_FIRST + 1074)
#define idsImapLogon                    (STR_FIRST + 1076)
#define idsFontSize0                    (STR_FIRST + 1079)
#define idsFontSize1                    (STR_FIRST + 1080)
#define idsFontSize2                    (STR_FIRST + 1081)
#define idsFontSize3                    (STR_FIRST + 1082)
#define idsFontSize4                    (STR_FIRST + 1083)
#define idsFontSize5                    (STR_FIRST + 1084)
#define idsFontSize6                    (STR_FIRST + 1085)
#define idsErrSicilyFailedToLoad        (STR_FIRST + 1089)
#define idsErrSicilyLogonFailed         (STR_FIRST + 1090)
#define idsOui                          (STR_FIRST + 1101)
#define idsNon                          (STR_FIRST + 1102)
#define idsBit                          (STR_FIRST + 1103)
#define idsMaybe                        (STR_FIRST + 1104)
#define idsLogCheckingNewMessages       (STR_FIRST + 1125)
#define idsErrNotSaveUntilDownloadDone  (STR_FIRST + 1126)
#define idsLogErrorSwitchGroup          (STR_FIRST + 1127)
#define idsSendBeforeFullyDisplayed     (STR_FIRST + 1128)
#define idsLogStartDownloadAll          (STR_FIRST + 1132)
#define idsIMAPFolderListFailed         (STR_FIRST + 1150)
#define idsIMAPCreateFailed             (STR_FIRST + 1151)
#define idsIMAPCreateListFailed         (STR_FIRST + 1152)
#define idsIMAPCreateSubscribeFailed    (STR_FIRST + 1153)

#define idsIMAPSendNextOpErrText        (STR_FIRST + 1158)
#define idsIMAPServerAlertTitle         (STR_FIRST + 1165)
#define idsIMAPServerAlertIntro         (STR_FIRST + 1166)
#define idsIMAPServerParseErrTitle      (STR_FIRST + 1167)
#define idsIMAPServerParseErrIntro      (STR_FIRST + 1168)

#define idsIMAPMsgDeleteSyncErrText     (STR_FIRST + 1180)
#define idsIMAPSelectFailureTextFmt     (STR_FIRST + 1182)
#define idsIMAPNewMsgDLErrText          (STR_FIRST + 1184)
#define idsIMAPOldMsgUpdateFailure      (STR_FIRST + 1185)
#define idsErrNewsgroupBlocked          (STR_FIRST + 1188)
#define idsErrNewsgroupNoPosting        (STR_FIRST + 1189)

#define idsIMAPNoHierarchyLosePrefix    (STR_FIRST + 1193)
#define idsIMAPPrefixCreateFailedFmt    (STR_FIRST + 1194)

#define idsAll                          (STR_FIRST + 1198)
#define idsErrCmdFailed                 (STR_FIRST + 1200)

#define idsIMAPDeleteFldrFailed         (STR_FIRST + 1203)
#define idsIMAPDeleteFldrUnsubFailed    (STR_FIRST + 1204)
#define idsIMAPAppendFailed             (STR_FIRST + 1209)
#define idsBccWell                      (STR_FIRST + 1218)
#define idsErrNewsCantOpen              (STR_FIRST + 1219)
#define idsErrNewsExpired               (STR_FIRST + 1220)
#define idsIMAPCopyMsgsFailed           (STR_FIRST + 1224)
#define idsAthenaTitle                  (STR_FIRST + 1236)
#define idsIMAPDnldProgressFmt          (STR_FIRST + 1239)
#define idsIMAPDnldDlgDLFailed          (STR_FIRST + 1240)
#define idsIMAPBodyFetchFailed          (STR_FIRST + 1245)
#define idsSecurityLineDigSign          (STR_FIRST + 1249)
#define idsSecurityLineSignGood         (STR_FIRST + 1250)
#define idsSecurityLineSignBad          (STR_FIRST + 1251)
#define idsSecurityLineSignUnsure       (STR_FIRST + 1252)
#define idsSecurityLineBreakStr         (STR_FIRST + 1253)
#define idsSecurityLineEncryption       (STR_FIRST + 1254)
#define idsSecurityLineEncGood          (STR_FIRST + 1255)
#define idsSecurityLineEncBad           (STR_FIRST + 1256)
#define idsErrViewLanguage              (STR_FIRST + 1258)
#define idsErrSecurityNoSigningCert     (STR_FIRST + 1265)
#define idsIMAPRenameFailed             (STR_FIRST + 1269)
#define idsIMAPRenameFCUpdateFailure    (STR_FIRST + 1270)
#define idsIMAPRenameSubscribeFailed    (STR_FIRST + 1272)
#define idsIMAPRenameUnsubscribeFailed  (STR_FIRST + 1273)
#define idsIMAPAtomicRenameFailed       (STR_FIRST + 1275)
#define idsEmptyStr                     (STR_FIRST + 1277)
#define idsIMAPUIDValidityError         (STR_FIRST + 1279)
#define idsSecurityLineSignPreProblem   (STR_FIRST + 1281)
#define idsSecurityLineEncExpired       (STR_FIRST + 1282)
#define idsSecurityLineSignDistrusted   (STR_FIRST + 1283)
#define idsSecurityLineSignExpired      (STR_FIRST + 1284)
#define idsSecurityLineListStr          (STR_FIRST + 1285)
#define idsErrSecurityAccessDenied      (STR_FIRST + 1286)
#define idsSecurityLineSignMismatch     (STR_FIRST + 1287)
#define idsEncodingMore                 (STR_FIRST + 1288)

#define idsNYIGeneral                   (STR_FIRST + 1289)
#define idsNYITitle                     (STR_FIRST + 1290)
#define idsSecurityLineSignOthers       (STR_FIRST + 1291)

#define idsViewLangMimeDBBad            (STR_FIRST + 1301)
// standard warning -- reorder and die vvv
#define idsSecurityCertMissing          (STR_FIRST + 1305)
#define idsSecurityCertExpired          (STR_FIRST + 1306)
#define idsSecurityCertChainTooLong     (STR_FIRST + 1307)
#define idsSecurityCertNoIssuer         (STR_FIRST + 1308)
#define idsSecurityCertRevoked          (STR_FIRST + 1309)
#define idsSecurityCertNotTrusted       (STR_FIRST + 1310)
#define idsSecurityCertInvalid          (STR_FIRST + 1311)
#define idsSecurityCertError            (STR_FIRST + 1312)
#define idsSecurityCertNoPrint          (STR_FIRST + 1313)
#define idsSecurityCertUnknown          (STR_FIRST + 1314)
// standard warning -- reorder and die ^^^
#define idsErrFailedNavigate            (STR_FIRST + 1330)
#define idsAthenaStoreDir               (STR_FIRST + 1331)
#define idsDisconnecting                (STR_FIRST + 1333)
#define idsWrnSecurityNoCertForEnc      (STR_FIRST + 1334)
#define idsErrSecurityNoPrivateKey      (STR_FIRST + 1335)
#define idsErrSecurityNoChosenCert      (STR_FIRST + 1336)
#define idsErrSecurityNoCertForDecrypt  (STR_FIRST + 1338)
#define idsViewLanguageGeneralHelp      (STR_FIRST + 1344)
#define idsErrDuplicateAccount          (STR_FIRST + 1345)
#define idsErrRenameAccountFailed       (STR_FIRST + 1346)
#define idsSecurityLineSignUntrusted    (STR_FIRST + 1350)
#define idsNNTPErrUnknownResponse       (STR_FIRST + 1354)
#define idsNNTPErrNewgroupsFailed       (STR_FIRST + 1355)
#define idsNNTPErrListFailed            (STR_FIRST + 1356)
#define idsNNTPErrListGroupFailed       (STR_FIRST + 1357)
#define idsNNTPErrGroupFailed           (STR_FIRST + 1358)
#define idsNNTPErrGroupNotFound         (STR_FIRST + 1359)
#define idsNNTPErrArticleFailed         (STR_FIRST + 1360)
#define idsNNTPErrHeadFailed            (STR_FIRST + 1361)
#define idsNNTPErrBodyFailed            (STR_FIRST + 1362)
#define idsNNTPErrPostFailed            (STR_FIRST + 1363)
#define idsNNTPErrNextFailed            (STR_FIRST + 1364)
#define idsNNTPErrDateFailed            (STR_FIRST + 1365)
#define idsNNTPErrHeadersFailed         (STR_FIRST + 1366)
#define idsNNTPErrXhdrFailed            (STR_FIRST + 1367)
#define idsDetail_ServerResponse        (STR_FIRST + 1368)
#define idsFavoritesFromOutlook         (STR_FIRST + 1369)
#define idsErrFavorites                 (STR_FIRST + 1370)
#define idsErrSendWebPageUrl            (STR_FIRST + 1371)
#define idsWrnSecurityTrustAddressSigner (STR_FIRST + 1372)
#define idsWrnSecurityTrustAddressSender (STR_FIRST + 1373)
#define idsTasks                        (STR_FIRST + 1374)
#define idsErrors                       (STR_FIRST + 1375)
#define idsStatusCol                    (STR_FIRST + 1377)
#define idsErrCantFindHost              (STR_FIRST + 1378)
#define idsFmtTagGeneralHelp            (STR_FIRST + 1379)
#define idsHtmlNoFrames                 (STR_FIRST + 1380)
#define idsErrPostWithoutNewsgroup      (STR_FIRST + 1381)
#define idsNewsTaskPost                 (STR_FIRST + 1382)
#define idsStateExecuting               (STR_FIRST + 1384)
#define idsStateCompleted               (STR_FIRST + 1385)
#define idsStateFailed                  (STR_FIRST + 1386)
#define idsErrNewMsgsFailed             (STR_FIRST + 1387)
#define idsCheckNewMsgsServer           (STR_FIRST + 1389)
#define idsChooseName                   (STR_FIRST + 1390)
#define idsRecUnknown                   (STR_FIRST + 1391)
#define idsRasErrorGeneralWithName      (STR_FIRST + 1392)
#define idsErrFindWAB                   (STR_FIRST + 1393)
#define idsErrAttachVCard               (STR_FIRST + 1394)
#define idsNewsTaskPostError            (STR_FIRST + 1396)
#define idsDLHeaders                    (STR_FIRST + 1398)
#define idsDLHeadersAndMarked           (STR_FIRST + 1399)
#define idsDLNewMsgs                    (STR_FIRST + 1400)
#define idsDLNewMsgsAndMarked           (STR_FIRST + 1401)
#define idsDLAllMsgs                    (STR_FIRST + 1402)
#define idsDLMarkedMsgs                 (STR_FIRST + 1403)
#define idsSpoolerIdleErrors            (STR_FIRST + 1404)
#define idsSpoolerIdle                  (STR_FIRST + 1405)
#define idsStateWarnings                (STR_FIRST + 1406)
#define idsNewsTaskArticleError         (STR_FIRST + 1407)
#define idsForwardMessage               (STR_FIRST + 1408)
#define idsColPriority                  (STR_FIRST + 1409)
#define idsColAttach                    (STR_FIRST + 1410)
#define idsServerErrorNumber                        (STR_FIRST + 1411)
#define idsSocketErrorNumber                        (STR_FIRST + 1412)
#define IDS_IXP_E_TIMEOUT                           (STR_FIRST + 1414)
#define IDS_IXP_E_USER_CANCEL                       (STR_FIRST + 1415)
#define IDS_IXP_E_INVALID_ACCOUNT                   (STR_FIRST + 1416)
#define IDS_IXP_E_SOCKET_CONNECT_ERROR              (STR_FIRST + 1418)
#define IDS_IXP_E_SOCKET_INIT_ERROR                 (STR_FIRST + 1419)
#define IDS_IXP_E_SOCKET_WRITE_ERROR                (STR_FIRST + 1420)
#define IDS_IXP_E_SOCKET_READ_ERROR                 (STR_FIRST + 1421)
#define IDS_IXP_E_CONNECTION_DROPPED                (STR_FIRST + 1422)
#define IDS_IXP_E_WINSOCK_FAILED_WSASTARTUP         (STR_FIRST + 1423)
#define IDS_IXP_E_LOAD_SICILY_FAILED                (STR_FIRST + 1424)
#define IDS_IXP_E_INVALID_CERT_CN                   (STR_FIRST + 1425)
#define IDS_IXP_E_INVALID_CERT_DATE                 (STR_FIRST + 1426)
#define IDS_IXP_E_CONN                              (STR_FIRST + 1427)
#define IDS_IXP_E_CANT_FIND_HOST                    (STR_FIRST + 1428)
#define IDS_IXP_E_SICILY_LOGON_FAILED               (STR_FIRST + 1429)
#define IDS_IXP_E_FAILED_TO_CONNECT                 (STR_FIRST + 1430)
#define IDS_IXP_E_SMTP_RESPONSE_ERROR               (STR_FIRST + 1431)
#define IDS_IXP_E_SMTP_UNKNOWN_RESPONSE_CODE        (STR_FIRST + 1432)
#define IDS_E_OUTOFMEMORY                           (STR_FIRST + 1433)
#define IDS_IXP_E_UNKNOWN                           (STR_FIRST + 1434)
#define IDS_IXP_E_SMTP_REJECTED_SENDER              (STR_FIRST + 1435)
#define IDS_SP_E_SENDINGSPLITGROUP                  (STR_FIRST + 1436)
#define IDS_SP_E_SMTP_CANTOPENMESSAGE               (STR_FIRST + 1437)
#define IDS_IXP_E_SMTP_NO_RECIPIENTS                (STR_FIRST + 1439)
#define IDS_IXP_E_SMTP_NO_SENDER                    (STR_FIRST + 1440)
#define IDS_IXP_E_SMTP_REJECTED_RECIPIENTS          (STR_FIRST + 1441)
#define IDS_SPS_SMTPEVENT                           (STR_FIRST + 1442)
#define IDS_SPS_POP3EVENT                           (STR_FIRST + 1443)
#define IDS_SPS_SMTPPROGRESS                        (STR_FIRST + 1444)
#define IDS_SPS_SMTPPROGRESS_SPLIT                  (STR_FIRST + 1445)
#define IDS_SPS_SMTPPROGGEN                         (STR_FIRST + 1446)
#define IDS_SPS_POP3CHECKING                        (STR_FIRST + 1447)
#define IDS_SPS_POP3STAT                            (STR_FIRST + 1448)
#define IDS_SPS_POP3DELE                            (STR_FIRST + 1449)
#define IDS_SPS_POP3UIDL_TOP                        (STR_FIRST + 1450)
#define IDS_SPS_POP3UIDL_UIDL                       (STR_FIRST + 1451)
#define IDS_SPS_PREDOWNRULES                        (STR_FIRST + 1452)
#define IDS_IXP_E_POP3_RESPONSE_ERROR               (STR_FIRST + 1453)
#define IDS_IXP_E_POP3_INVALID_USER_NAME            (STR_FIRST + 1454)
#define IDS_IXP_E_POP3_INVALID_PASSWORD             (STR_FIRST + 1455)
#define idsNNTPErrPasswordFailed                    (STR_FIRST + 1456)
#define idsStateCanceled                            (STR_FIRST + 1457)
#define idsSBCheckingNews                           (STR_FIRST + 1458)
#define idsSBSendingNews                            (STR_FIRST + 1459)
#define idsSBReceivingNews                          (STR_FIRST + 1460)
#define IDS_SPS_MOVEPROGRESS                        (STR_FIRST + 1461)
#define IDS_SPS_MOVEEVENT                           (STR_FIRST + 1462)
// standard warning -- reorder and die vvv
//NOTE: some of the Ok ids are referenced by offset only
#define OFFSET_SMIMEOK                  20
#define idsWrnSecurityMsgTamper         (STR_FIRST + 1465)
#define idsOkSecurityMsgTamper          (idsWrnSecurityMsgTamper + OFFSET_SMIMEOK)
#define idsUnkSecurityMsgTamper         (STR_FIRST + 1466)
#define idsWrnSecurityTrustNotTrusted   (STR_FIRST + 1467)
#define idsOkSecurityTrustNotTrusted    (idsWrnSecurityTrustNotTrusted + OFFSET_SMIMEOK)
#define idsUnkSecurityTrust             (STR_FIRST + 1468)
#define idsWrnSecurityTrustAddress      (STR_FIRST + 1470)
#define idsOkSecurityTrustAddress       (idsWrnSecurityTrustAddress + OFFSET_SMIMEOK)
#define idsWrnSecurityCertRevoked       (STR_FIRST + 1471)
#define idsOkSecurityCertRevoked        (idsWrnSecurityCertRevoked + OFFSET_SMIMEOK)
#define idsWrnSecurityOtherValidity     (STR_FIRST + 1472)
#define idsOkSecurityOtherValidity      (idsWrnSecurityOtherValidity + OFFSET_SMIMEOK)
#define idsWrnSecurityTrustExpired      (STR_FIRST + 1480)
#define idsOkSecurityTrustExpired       (idsWrnSecurityTrustExpired + OFFSET_SMIMEOK)
#define idsSecCerificateErr             (STR_FIRST + 1486)
#define idsNoCerificateErr              (STR_FIRST + 1488)
#define idsSaveSecMsgToDraft            (STR_FIRST + 1489)
// standard warning -- reorder and die ^^^
#define idsConnNoDial                   (STR_FIRST + 1506)
#define idsSaveSecMsgToFolder           (STR_FIRST + 1508)

#define idsStationery                   (STR_FIRST + 1509)
#define idsCaptionMail                  (STR_FIRST + 1510)
#define idsCaptionNews                  (STR_FIRST + 1511)
#define idsImageFileFilter              (STR_FIRST + 1512)
#define idsErrNewStationery             (STR_FIRST + 1514)
#define idsHtmlFileFilter               (STR_FIRST + 1515)
#define idsErrVCardProperties           (STR_FIRST + 1516)
#define idsRSListGeneralHelp            (STR_FIRST + 1517)
#define idsTTVCardStamp                 (STR_FIRST + 1518)
//added for BUG 2103
#define idsErrStationeryNotFound        (STR_FIRST + 1521)
#define idsDialAlways                   (STR_FIRST + 1522)
#define idsDialIfNotOffline             (STR_FIRST + 1523)
#define idsDoNotDial                    (STR_FIRST + 1524)
#define idsSmallIcons                   (STR_FIRST + 1525)
#define idsLargeIcons                   (STR_FIRST + 1526)
#define idsShowTextLabels               (STR_FIRST + 1527)
#define idsPartialTextLabels            (STR_FIRST + 1528)
#define idsNoTextLabels                 (STR_FIRST + 1529)

#define idsSendRecvOneAccount           (STR_FIRST + 1600)
#define idsSendRecvUsing                (STR_FIRST + 1601)
#define idsFPStatInbox                  (STR_FIRST + 1602)
#define idsComposeFontFace              (STR_FIRST + 1608)
#define IDS_SP_E_RETRFAILED             (STR_FIRST + 1609)
#define IDS_SPS_POP3TOTAL               (STR_FIRST + 1610)
#define IDS_SPS_POP3NEW                 (STR_FIRST + 1611)
#define IDS_IXP_E_SMTP_553_MAILBOX_NAME_SYNTAX (STR_FIRST + 1612)
#define IDS_SPS_SMTPUSEDEFAULT          (STR_FIRST + 1613)
#define idsNNTPErrServerTimeout         (STR_FIRST + 1614)
#define idsPictureTitle                 (STR_FIRST + 1615)
#define idsErrNoSubscribedGroups        (STR_FIRST + 1616)
#define idsWarnErrorUnsentMail          (STR_FIRST + 1617)
#define idsClose                        (STR_FIRST + 1618)
#define idsSelectFolder                 (STR_FIRST + 1619)
#define idsErrNoSubscribedFolders       (STR_FIRST + 1621)
#define idsReplyForwardLoop             (STR_FIRST + 1623)
#define idsNotDefNewsClient             (STR_FIRST + 1624)
#define idsFontSample                   (STR_FIRST + 1625)
#define idsSelectStationery             (STR_FIRST + 1626)
#define idsShopMoreStationery           (STR_FIRST + 1627)
#define idsFontFolderSmall              (STR_FIRST + 1629)
#define idsFontViewTextSmall            (STR_FIRST + 1631)

#define idsIMAPSubscribeFailedFmt       (STR_FIRST + 1635)
#define idsIMAPUnsubscribeFailedFmt     (STR_FIRST + 1636)

#define idsIMAPSubscrAddErrorFmt        (STR_FIRST + 1646)

#define idsModerated                    (STR_FIRST + 1651)
#define idsBlocked                      (STR_FIRST + 1652)
#define idsWindowLayout                 (STR_FIRST + 1654)
#define IDS_IXP_E_SMTP_552_STORAGE_OVERFLOW (STR_FIRST + 1655)
#define idsSigningCertProperties        (STR_FIRST + 1656)
#define idsRas_Dialing_Param            (STR_FIRST + 1657)
#define idsFormatK                      (STR_FIRST + 1658)
#define idsGoToFolderTitle              (STR_FIRST + 1660)
#define idsGoToFolderText               (STR_FIRST + 1661)
#define idsMicrosoft                    (STR_FIRST + 1662)
#define idsSendLaterUsing               (STR_FIRST + 1664)
#define idsSendLaterOneAccount          (STR_FIRST + 1665)
#define idsNotApplicable                (STR_FIRST + 1668)
#define idsIMAPPollUnreadFailuresFmt    (STR_FIRST + 1670)
#define idsIMAPPollUnreadIMAP4Fmt       (STR_FIRST + 1671)
#define idsNoAccountsFound              (STR_FIRST + 1673)
#define idsErrSecurityCertDisappeared   (STR_FIRST + 1674)
#define idsErrSecuritySendExpiredSign   (STR_FIRST + 1675)
#define idsErrSecuritySendTrust         (STR_FIRST + 1676)
#define idsErrSecuritySendExpiredEnc    (STR_FIRST + 1677)
#define idsNoNewsAccountsFound          (STR_FIRST + 1679)
#define idsErrSecurityExtFailure        (STR_FIRST + 1680)
#define idsWrnSecurityRevFail           (STR_FIRST + 1681)
#define idsWrnSecurityNoCDP             (STR_FIRST + 1682)
#define idsErrSecurityCertRevoked       (STR_FIRST + 1683)
#define idsErrSecuritySendExpSignEnc    (STR_FIRST + 1684)
#define idsErrSecurityCertRevokedEnc    (STR_FIRST + 1685)
#define idsErrSecuritySendTrustEnc      (STR_FIRST + 1686)
#define idsErrSecurityExtFailureEnc     (STR_FIRST + 1687)
#define idsErrEncCertCommon             (STR_FIRST + 1688)
#define idsErrSignCertText20            (STR_FIRST + 1689)
#define idsErrSignCertText21            (STR_FIRST + 1690)
#define idsErrSignCertText22            (STR_FIRST + 1691)

// Strings used in Simple MAPI - vsnatar
#define idsAttachedFiles                (STR_FIRST + 1700)

#define idsIMAPFolderReadOnly           (STR_FIRST + 1702)


#define idsErrBadMHTMLLinks             (STR_FIRST + 1718)
#define idsAbortDownload                (STR_FIRST + 1719)
#define idsErrWorkingOffline            (STR_FIRST + 1720)

#define idsNewAthenaUser                (STR_FIRST + 1727)
#define idsSearching                    (STR_FIRST + 1731)
//#define idsWarnSMapi                  (STR_FIRST + 1733)
#define idsWelcomeFromDisplay           (STR_FIRST + 1734)
#define idsWelcomeFromEmail             (STR_FIRST + 1735)
#define idsOutlookNews                  (STR_FIRST + 1736)
#define idsNotDefOutNewsClient          (STR_FIRST + 1739)
#define idsAlwaysCheckOutNews           (STR_FIRST + 1740)
#define idsApplyStationeryGeneralHelp   (STR_FIRST + 1741)
#define IDS_ERROR_PREFIX1               (STR_FIRST + 1750)
#define IDS_ERROR_CREATE_INSTMUTEX      (STR_FIRST + 1751)
#define IDS_ERROR_MIMEOLE_ALLOCATOR     (STR_FIRST + 1752)
#define IDS_ERROR_FIRST_TIME_ICW        (STR_FIRST + 1753)
#define IDS_ERROR_INITSTORE_DIRECTORY   (STR_FIRST + 1754)
#define IDS_ERROR_REG_WNDCLASS          (STR_FIRST + 1757)
#define IDS_ERROR_CREATEWINDOW          (STR_FIRST + 1758)
#define IDS_ERROR_INIT_GOPTIONS         (STR_FIRST + 1759)
#define IDS_ERROR_INITSTORE             (STR_FIRST + 1761)
#define IDS_ERROR_CREATE_ACCTMAN        (STR_FIRST + 1763)
#define IDS_ERROR_ALLOC_ACCTADVISE      (STR_FIRST + 1766)
#define IDS_ERROR_INIT_ACCTADVISE       (STR_FIRST + 1767)
#define IDS_ERROR_INIT_ACCTMAN          (STR_FIRST + 1768)
#define IDS_ERROR_ADVISE_ACCTMAN        (STR_FIRST + 1769)
#define IDS_ERROR_ALLOC_CONMAN          (STR_FIRST + 1770)
#define IDS_ERROR_INIT_CONMAN           (STR_FIRST + 1771)
#define IDS_ERROR_CREATE_SPOOLER        (STR_FIRST + 1772)
#define IDS_ERROR_CREATE_FONTCACHE      (STR_FIRST + 1773)
#define IDS_ERROR_REASON1               (STR_FIRST + 1774)
#define IDS_ERROR_REASON2               (STR_FIRST + 1775)
#define IDS_ERROR_START_HELP            (STR_FIRST + 1776)
#define IDS_ERROR_UNKNOWN               (STR_FIRST + 1777)
#define IDS_ERROR_FILE_NOEXIST          (STR_FIRST + 1778)

#define idsConfirmChangeStoreLocation   (STR_FIRST + 1782)
//#define idsCantMoveStoreToSubfolder     (STR_FIRST + 1783)
#define idsMoveStoreProgress            (STR_FIRST + 1784)
#define IDS_ERROR_BADVER_DLL            (STR_FIRST + 1785)
#define idsResNameEmailAddress          (STR_FIRST + 1786)
#define idsResNamePerInfo               (STR_FIRST + 1787)
#define idsResNameAddress               (STR_FIRST + 1788)
#define idsResNameBusInfo               (STR_FIRST + 1789)
#define idsResNameTitle                 (STR_FIRST + 1790)
#define idsResNameDept                  (STR_FIRST + 1791)
#define idsResNameOff                   (STR_FIRST + 1792)
#define idsResNameComp                  (STR_FIRST + 1793)
#define idsResNameNotes                 (STR_FIRST + 1794)
#define idsResNamePhone                 (STR_FIRST + 1795)
#define idsResNameFax                   (STR_FIRST + 1796)
#define idsResNameCellular              (STR_FIRST + 1797)
#define idsResNameWeb                   (STR_FIRST + 1798)
#define idsResNamePager                 (STR_FIRST + 1799)
#define idsSpoolerUserCancel            (STR_FIRST + 1803)
#define idsEmptyView                    (STR_FIRST + 1807)
#define IDS_ERROR_MISSING_DLL           (STR_FIRST + 1812)
#define idsDefaultSignature             (STR_FIRST + 1813)
#define idsSigNameFmt                   (STR_FIRST + 1814)
#define IDS_SP_E_CANT_MOVETO_SENTITEMS  (STR_FIRST + 1815)
#define idsType                         (STR_FIRST + 1816)
#define idsMail                         (STR_FIRST + 1817)
#define idsNews                         (STR_FIRST + 1818)
#define idsErrSelectOneColumn           (STR_FIRST + 1825)
#define idsWorkOffline                  (STR_FIRST + 1826)
#define idsColumnDlgTitle               (STR_FIRST + 1844)
#define idsMailSig                      (STR_FIRST + 1845)
#define idsNewsSig                      (STR_FIRST + 1846)
#define idsStationeryOpen               (STR_FIRST + 1852)
#define idsStationeryExistWarning       (STR_FIRST + 1853)
#define idsStationeryEmptyWarning       (STR_FIRST + 1854)
#define idsStationerySample             (STR_FIRST + 1855)
#define idsBackgroundEmptyWarning       (STR_FIRST + 1856)
#define idsFilterMailIni                (STR_FIRST + 1857)
#define idsErrorMailIni                 (STR_FIRST + 1858)
#define idsCriteriaNewsgroup            (STR_FIRST + 1859)
#define idsCriteriaFromNot              (STR_FIRST + 1860)
#define idsCriteriaToNot                (STR_FIRST + 1861)
#define idsCriteriaCCNot                (STR_FIRST + 1862)
#define idsCriteriaBodyNot              (STR_FIRST + 1863)
#define idsCriteriaSubjectNot           (STR_FIRST + 1865)
#define idsCriteriaSubject              (STR_FIRST + 1866)
#define idsCriteriaBody                 (STR_FIRST + 1867)
#define idsCriteriaTo                   (STR_FIRST + 1868)
#define idsCriteriaFrom                 (STR_FIRST + 1869)
#define idsCriteriaPriority             (STR_FIRST + 1870)
#define idsCriteriaAttachment           (STR_FIRST + 1871)
#define idsCriteriaSize                 (STR_FIRST + 1872)
#define idsCriteriaDate                 (STR_FIRST + 1873)
#define idsCriteriaHeader               (STR_FIRST + 1874)
#define idsCriteriaJunk                 (STR_FIRST + 1875)
#define idsCriteriaAccount              (STR_FIRST + 1876)
#define idsCriteriaAll                  (STR_FIRST + 1877)
#define idsCriteriaAnd                  (STR_FIRST + 1878)
#define idsActionsDelete                (STR_FIRST + 1880)
#define idsActionsCopy                  (STR_FIRST + 1881)
#define idsActionsFwd                   (STR_FIRST + 1882)
#define idsActionsReply                 (STR_FIRST + 1883)
#define idsActionsMove                  (STR_FIRST + 1884)
#define idsActionsDelServer             (STR_FIRST + 1885)
#define idsActionsDontDownload          (STR_FIRST + 1886)
#define idsActionsNotifySound           (STR_FIRST + 1887)
#define idsActionsHighlight             (STR_FIRST + 1888)
#define idsActionsFlag                  (STR_FIRST + 1889)
#define idsActionsStop                  (STR_FIRST + 1890)
#define idsActionsNotifyMsg             (STR_FIRST + 1891)
#define idsErrorCreateRulesMan          (STR_FIRST + 1892)
#define idsErrorInitRulesMan            (STR_FIRST + 1893)
#define idsCriteriaCCAddr               (STR_FIRST + 1894)
#define idsCriteriaCC                   (STR_FIRST + 1895)
#define idsRuleHeader                   (STR_FIRST + 1896)
#define idsEmailParseSep                (STR_FIRST + 1906)
#define idsEmailSep                     (STR_FIRST + 1907)
#define idsShow                         (STR_FIRST + 1910)
#define idsColDownload                  (STR_FIRST + 1911)
#define idsNewsgroup                    (STR_FIRST + 1912)
#define idsTabVisible                   (STR_FIRST + 1913)
#define idsOEBandTitle                  (STR_FIRST + 1920)
#define idsMNBandTitle                  (STR_FIRST + 1921)
#define idsABBandTitle                  (STR_FIRST + 1923)

// BL control strings
#define idsBADelBLEntry                 (STR_FIRST + 1924)
#define idsBADelBLABEntry               (STR_FIRST + 1925)
#define idsBADelABEntry                 (STR_FIRST + 1926)
#define idsBADelMultiple                (STR_FIRST + 1927)
#define idsBAErrExtChars                (STR_FIRST + 1928)
// #define idsBAErrNotHotmail              (STR_FIRST + 1929) // Not used anymore
#define idsWABExtTitle                  (STR_FIRST + 1930)
#define idsBAErrJITFail                 (STR_FIRST + 1931)

#define idsEmptySubscriptionList        (STR_FIRST + 1932)
#define idsAllMessages                  (STR_FIRST + 1933)
#define idsNewMessages                  (STR_FIRST + 1934)
#define idsNewHeaders                   (STR_FIRST + 1935)
#define idsRulesErrorNoName             (STR_FIRST + 1938)
// #define idsBAHotMailName                (STR_FIRST + 1939) // Not used anymore
#define idsBADefault                    (STR_FIRST + 1940)
#define idsRuleDefaultName              (STR_FIRST + 1941)
#define idsFlag                         (STR_FIRST + 1942)
#define idsRulesErrorNoCriteria         (STR_FIRST + 1943)
#define idsCongratStr                   (STR_FIRST + 1945)
#define idsEnvSend                      (STR_FIRST + 1946)
#define idsEnvBcc                       (STR_FIRST + 1948)
#define idsErrEnvHostCoCreate           (STR_FIRST + 1949)
#define idsErrEnvHostCreateNote         (STR_FIRST + 1950)
#define idsCreateEnvHostPoupMenu        (STR_FIRST + 1951)
#define idsHTMLEmptyPreviewSel          (STR_FIRST + 1953)
#define idsSigFileNoExistError          (STR_FIRST + 1954)
#define idsRulesWarnDelete              (STR_FIRST + 1955)
#define idsRulesCopyName                (STR_FIRST + 1956)
#define idsErrOneOrMoreEmptyDistLists   (STR_FIRST + 1957)
#define idsSenderCertAdded              (STR_FIRST + 1958)
#define idsRulesErrorNoActions          (STR_FIRST + 1959)
#define idsPreviewPane                  (STR_FIRST + 1961)
#define idsRulesErrorFix                (STR_FIRST + 1962)
#define idsRulesErrorHeader             (STR_FIRST + 1963)
#define idsRulesErrorEnable             (STR_FIRST + 1964)
#define idsSubscribe                    (STR_FIRST + 1965)
#define idsCriteriaToOrCCNot            (STR_FIRST + 1966)
#define idsCriteriaToOrCC               (STR_FIRST + 1967)
#define idsRulesWarnEmptyEmail          (STR_FIRST + 1968)
#define idsActionsRead                  (STR_FIRST + 1969)
#define idsSelectMyCertTitle            (STR_FIRST + 1970)
#define idsBitStrength                  (STR_FIRST + 1971)
#define idsWrnLowSecurity               (STR_FIRST + 1972)
#define idsNewsMessage                  (STR_FIRST + 1973)
#define idsMailMessage                  (STR_FIRST + 1974)
#define idsSecurityLineSignRevoked      (STR_FIRST + 1975)
#define idsRevokationOffline            (STR_FIRST + 1976)
#define idsRevokationFail               (STR_FIRST + 1977)
#define idsRevokationTurnedOff          (STR_FIRST + 1978)
#define idsServiceName                  (STR_FIRST + 1979)

// Multi user strings
#define idsErrHtmlBodyFailedToLoad      (STR_FIRST + 1990)
#define idsErrLoadProtocolBad           (STR_FIRST + 1991)
#define idsCantLoadMsident              (STR_FIRST + 1992)
#define idsLogoffFormat                 (STR_FIRST + 1993)
#define idsSwitchUser                   (STR_FIRST + 1994)
#define idsMaintainConnection           (STR_FIRST + 1995)
#define idsSaveEncrypted                (STR_FIRST + 1996)

#define idsSelectClient                 (STR_FIRST + 1997)
#define idsMigrate                      (STR_FIRST + 1998)
#define idsLocation                     (STR_FIRST + 1999)
#define idsSelectFoldersHdr             (STR_FIRST + 2000)
#define idsAddressComplete              (STR_FIRST + 2001)
#define idsCongratulations              (STR_FIRST + 2002)
#define IDS_ERROR_OPEN_STORE            (STR_FIRST + 2003)
#define idsPersonalFolders              (STR_FIRST + 2004)
#define idsBADispStatus                 (STR_FIRST + 2006)
#define idsBAEmail                      (STR_FIRST + 2007)
#define idsBAIMsg                       (STR_FIRST + 2008)
#define idsBAOnline                     (STR_FIRST + 2009)
#define idsBAInvisible                  (STR_FIRST + 2010)
#define idsBABusy                       (STR_FIRST + 2011)
#define idsBABack                       (STR_FIRST + 2012)
#define idsBAAway                       (STR_FIRST + 2013)
#define idsBAOnPhone                    (STR_FIRST + 2014)
#define idsBALunch                      (STR_FIRST + 2015)
#define idsBAOffline                    (STR_FIRST + 2016)
#define idsBAIdle                       (STR_FIRST + 2017)
#define idsApplyingRules                (STR_FIRST + 2018)
#define idsRuleAddrCaption              (STR_FIRST + 2019)
#define idsRuleAddrWell                 (STR_FIRST + 2020)
#define idsRulesFilter                  (STR_FIRST + 2021)
#define idsDefRulesExt                  (STR_FIRST + 2022)
#define idsRulesDefFile                 (STR_FIRST + 2023)
#define idsSenderDesc                   (STR_FIRST + 2024)
#define idsSenderBlank                  (STR_FIRST + 2025)
#define idsSenderAdded                  (STR_FIRST + 2026)
#define idsJITErrDenied                 (STR_FIRST + 2030)
#define idsSYNCMGRErr                   (STR_FIRST + 2031)
#define idsErrSetMessageStreamFailed    (STR_FIRST + 2032)
#define idsErrDeleteCachedFolderFail    (STR_FIRST + 2033)
#define idsCopyingMessages              (STR_FIRST + 2035)
#define idsMovingMessages               (STR_FIRST + 2036)
#define idsSendingToOutbox              (STR_FIRST + 2037)
#define idsSavingToFolder               (STR_FIRST + 2038)
#define idsWorkingOffline               (STR_FIRST + 2039)
#define idsMarkingMessages              (STR_FIRST + 2041)
#define idsMovingFolder                 (STR_FIRST + 2042)
#define idsDeletingFolder               (STR_FIRST + 2043)
#define idsDeletingMessages             (STR_FIRST + 2044)
#define idsErrTooManySplitMsgs          (STR_FIRST + 2045)
#define idsRenamingFolder               (STR_FIRST + 2046)
#define idsGetNewHeaders                (STR_FIRST + 2047)
#define idsDownloadFoldersTitle         (STR_FIRST + 2050)
#define idsDownloadFoldersText          (STR_FIRST + 2051)
#define idsErrCreateFinder              (STR_FIRST + 2052)
#define idsDateSize                     (STR_FIRST + 2053)
#define idsAdvanced                     (STR_FIRST + 2054)
#define idsErrCannotSaveInSourceEdit    (STR_FIRST + 2055)

#define idsRulesMail                    (STR_FIRST + 2056)
#define idsRulesNews                    (STR_FIRST + 2057)
#define idsRulesJunk                    (STR_FIRST + 2058)
#define idsRulesSenders                 (STR_FIRST + 2059)
#define idsRuleTitleNews                (STR_FIRST + 2060)
#define idsRuleSenderErrorNone          (STR_FIRST + 2061)
#define idsRuleSenderWarnDelete         (STR_FIRST + 2062)
#define idsRuleAdded                    (STR_FIRST + 2063)
#define idsCreateRuleError              (STR_FIRST + 2064)
#define idsSenderError                  (STR_FIRST + 2065)
#define idsSettingMessageFlags          (STR_FIRST + 2067)
#define idsNewShortcutTitle             (STR_FIRST + 2069)
#define idsNewShortcutCaption           (STR_FIRST + 2070)
#define idsFailedToConnectSecurely      (STR_FIRST + 2071)
#define idsColDownloadMsg               (STR_FIRST + 2072)
#define idsIMAPUnsubRemoveErrorFmt      (STR_FIRST + 2073)
#define idsEmptyNewsAcct                (STR_FIRST + 2074)
#define idsCurrentlyDefMail             (STR_FIRST + 2075)
#define idsCurrentlyDefNews             (STR_FIRST + 2076)
#define idsNotDefMail                   (STR_FIRST + 2077)
#define idsNotDefNews                   (STR_FIRST + 2078)
//#define idsBeta2BuildStr                (STR_FIRST + 2079)
#define idsShowFolderCmd                (STR_FIRST + 2080)
#define idsHideFolderCmd                (STR_FIRST + 2081)
#define idsSubscribeFolderCmd           (STR_FIRST + 2082)
#define idsUnsubscribeFolderCmd         (STR_FIRST + 2083)
#define idsEmptyMailAcct                (STR_FIRST + 2084)
#define idsFmtDownloadingMessage        (STR_FIRST + 2085)
#define idsAccountLabelFmt              (STR_FIRST + 2086)
#define idsFolderLabelFmt               (STR_FIRST + 2087)
#define idsCreateSpecialFailed          (STR_FIRST + 2088)
#define idsViewEncryptID                (STR_FIRST + 2089)

#define idsStatusFlagged                (STR_FIRST + 2090)
#define idsStatusLowPri                 (STR_FIRST + 2091)
#define idsStatusHighPri                (STR_FIRST + 2092)

#define idsActionsDownload              (STR_FIRST + 2095)
#define idsSelectNewsgroup              (STR_FIRST + 2096)
#define idsSelectNewsgroupCaption       (STR_FIRST + 2097)
#define idsBlockSender                  (STR_FIRST + 2098)
#define idsJunkMail                     (STR_FIRST + 2099)

#define IDS_TIPS_GENERAL_FIRST          (STR_FIRST + 2100)
#define IDS_TIPS_GENERAL_0              (STR_FIRST + 2100)
#define IDS_TIPS_GENERAL_1              (STR_FIRST + 2101)
#define IDS_TIPS_GENERAL_2              (STR_FIRST + 2102)
#define IDS_TIPS_GENERAL_3              (STR_FIRST + 2103)
#define IDS_TIPS_GENERAL_4              (STR_FIRST + 2104)
#define IDS_TIPS_GENERAL_5              (STR_FIRST + 2105)
#define IDS_TIPS_GENERAL_6              (STR_FIRST + 2106)
#define IDS_TIPS_GENERAL_7              (STR_FIRST + 2107)
#define IDS_TIPS_GENERAL_8              (STR_FIRST + 2108)
#define IDS_TIPS_GENERAL_9              (STR_FIRST + 2109)
#define IDS_TIPS_GENERAL_10             (STR_FIRST + 2110)
#define IDS_TIPS_GENERAL_11             (STR_FIRST + 2111)
#define IDS_TIPS_GENERAL_12             (STR_FIRST + 2112)
#define IDS_TIPS_GENERAL_13             (STR_FIRST + 2113)
#define IDS_TIPS_GENERAL_14             (STR_FIRST + 2114)
#define IDS_TIPS_GENERAL_15             (STR_FIRST + 2115)
#define IDS_TIPS_GENERAL_16             (STR_FIRST + 2116)
#define IDS_TIPS_GENERAL_17             (STR_FIRST + 2117)
#define IDS_TIPS_GENERAL_18             (STR_FIRST + 2118)
#define IDS_TIPS_GENERAL_19             (STR_FIRST + 2119)
#define IDS_TIPS_GENERAL_20             (STR_FIRST + 2120)
#define IDS_TIPS_GENERAL_21             (STR_FIRST + 2121)
#define IDS_TIPS_GENERAL_22             (STR_FIRST + 2122)
#define IDS_TIPS_GENERAL_23             (STR_FIRST + 2123)
#define IDS_TIPS_GENERAL_24             (STR_FIRST + 2124)
#define IDS_TIPS_GENERAL_25             (STR_FIRST + 2125)
#define IDS_TIPS_GENERAL_26             (STR_FIRST + 2126)
#define IDS_TIPS_GENERAL_27             (STR_FIRST + 2127)
#define IDS_TIPS_GENERAL_28             (STR_FIRST + 2128)
#define IDS_TIPS_GENERAL_29             (STR_FIRST + 2129)
#define IDS_TIPS_GENERAL_30             (STR_FIRST + 2130)
#define IDS_TIPS_GENERAL_31             (STR_FIRST + 2131)
#define IDS_TIPS_GENERAL_32             (STR_FIRST + 2132)
#define IDS_TIPS_GENERAL_33             (STR_FIRST + 2133)
#define IDS_TIPS_GENERAL_34             (STR_FIRST + 2134)
#define IDS_TIPS_GENERAL_35             (STR_FIRST + 2135)
#define IDS_TIPS_GENERAL_36             (STR_FIRST + 2136)
#define IDS_TIPS_GENERAL_37             (STR_FIRST + 2137)
#define IDS_TIPS_GENERAL_38             (STR_FIRST + 2138)
#define IDS_TIPS_GENERAL_39             (STR_FIRST + 2139)
#define IDS_TIPS_GENERAL_40             (STR_FIRST + 2140)
#define IDS_TIPS_GENERAL_41             (STR_FIRST + 2141)
#define IDS_TIPS_GENERAL_LAST           (STR_FIRST + 2141)

#define IDS_TIPS_NEWS_FIRST             (STR_FIRST + 2200)
#define IDS_TIPS_NEWS_0                 (STR_FIRST + 2200)
#define IDS_TIPS_NEWS_1                 (STR_FIRST + 2201)
#define IDS_TIPS_NEWS_2                 (STR_FIRST + 2202)
#define IDS_TIPS_NEWS_3                 (STR_FIRST + 2203)
#define IDS_TIPS_NEWS_4                 (STR_FIRST + 2204)
#define IDS_TIPS_NEWS_5                 (STR_FIRST + 2205)
#define IDS_TIPS_NEWS_6                 (STR_FIRST + 2206)
#define IDS_TIPS_NEWS_7                 (STR_FIRST + 2207)
#define IDS_TIPS_NEWS_8                 (STR_FIRST + 2208)
#define IDS_TIPS_NEWS_9                 (STR_FIRST + 2209)
#define IDS_TIPS_NEWS_10                (STR_FIRST + 2210)
#define IDS_TIPS_NEWS_11                (STR_FIRST + 2211)
#define IDS_TIPS_NEWS_12                (STR_FIRST + 2212)
#define IDS_TIPS_NEWS_13                (STR_FIRST + 2213)
#define IDS_TIPS_NEWS_14                (STR_FIRST + 2214)
#define IDS_TIPS_NEWS_15                (STR_FIRST + 2215)
#define IDS_TIPS_NEWS_LAST              (STR_FIRST + 2215)

#define IDS_TIPS_IMAP_FIRST             (STR_FIRST + 2250)
#define IDS_TIPS_IMAP_0                 (STR_FIRST + 2250)
#define IDS_TIPS_IMAP_1                 (STR_FIRST + 2251)
#define IDS_TIPS_IMAP_2                 (STR_FIRST + 2252)
#define IDS_TIPS_IMAP_3                 (STR_FIRST + 2253)
#define IDS_TIPS_IMAP_4                 (STR_FIRST + 2254)
#define IDS_TIPS_IMAP_5                 (STR_FIRST + 2255)
#define IDS_TIPS_IMAP_6                 (STR_FIRST + 2256)
#define IDS_TIPS_IMAP_7                 (STR_FIRST + 2257)
#define IDS_TIPS_IMAP_8                 (STR_FIRST + 2258)
#define IDS_TIPS_IMAP_LAST              (STR_FIRST + 2258)

#define idsSynchronizeNowBtn            (STR_FIRST + 2280)
#define idsIMAPFoldersBtn               (STR_FIRST + 2281)
#define idsSettingsBtn                  (STR_FIRST + 2282)
#define idsNewsgroupsBtn                (STR_FIRST + 2283)
#define idsSetSyncSettings              (STR_FIRST + 2284)  
#define idsSetNewsSyncSettings          (STR_FIRST + 2285)
#define idsSyncManager                  (STR_FIRST + 2286)
#define idsColThreadState               (STR_FIRST + 2287)
#define idsErrOpenUrlFmt                (STR_FIRST + 2288)
#define idsWantToSubscribe              (STR_FIRST + 2289)
#define idsPurgingMessages              (STR_FIRST + 2290)
#define idsRulesToolbarTitle            (STR_FIRST + 2291)
#define idsCreateFilter                 (STR_FIRST + 2292)
#define idsCriteriaSender               (STR_FIRST + 2293)
#define idsActionsShow                  (STR_FIRST + 2294)
#define idsViewDefaultName              (STR_FIRST + 2295)
#define idsFontSampleFmt                (STR_FIRST + 2296)
#define idsImport                       (STR_FIRST + 2297)
#define idsPerformExport                (STR_FIRST + 2298)
#define idsExport                       (STR_FIRST + 2299)
#define idsExportTitle                  (STR_FIRST + 2300)
#define idsImportTitle                  (STR_FIRST + 2301)
#define idsImportingFolderFmt           (STR_FIRST + 2302)
#define idsExportingFolderFmt           (STR_FIRST + 2303)
#define idsImportingMessageFmt          (STR_FIRST + 2304)
#define idsExportError                  (STR_FIRST + 2305)
#define idsMAPIStoreOpenError           (STR_FIRST + 2306)
#define idsMAPIInitError                (STR_FIRST + 2307)
#define idsAddressUnknownFmt            (STR_FIRST + 2308)
#define idsFolderOpenFail               (STR_FIRST + 2309)
#define idsFolderReadFail               (STR_FIRST + 2310)
#define idsFolderImportErrorFmt         (STR_FIRST + 2314)
#define idsOut                          (STR_FIRST + 2315)
#define idsTrash                        (STR_FIRST + 2316)
#define idsEudora                       (STR_FIRST + 2317)
#define idsNetscape                     (STR_FIRST + 2318)
#define idsImportABTitle                (STR_FIRST + 2319)
#define idsImportAB                     (STR_FIRST + 2320)
#define idsImportingABFmt               (STR_FIRST + 2321)
#define idsBrowseFolderText             (STR_FIRST + 2322)
#define idsLocationUnknown              (STR_FIRST + 2323)
#define idsLocationInvalid              (STR_FIRST + 2324)
#define idsCancelWizard                 (STR_FIRST + 2325)
#define idsABImportError                (STR_FIRST + 2327)
#define idsExchange                     (STR_FIRST + 2328)
#define idsCommunicator                 (STR_FIRST + 2329)
#define idsMapiInitError                (STR_FIRST + 2330)
#define idsNoMapiProfiles               (STR_FIRST + 2331)
#define idsMapiImportFailed             (STR_FIRST + 2332)
#define idsSelectFolders                (STR_FIRST + 2333)
#define idsPop3UidlFile                 (STR_FIRST + 2334)
#define idsOfflineFile                  (STR_FIRST + 2335)
#define idsFoldersFile                  (STR_FIRST + 2336)
#define idsMessagesFile                 (STR_FIRST + 2337)
#define idsSavingFmt                    (STR_FIRST + 2338)
#define idsErrEmptyRecipientAddress     (STR_FIRST + 2339)
#define idsRuleMailDefaultName          (STR_FIRST + 2340)
#define idsRuleNewsDefaultName          (STR_FIRST + 2341)
#define idsCriteriaRead                 (STR_FIRST + 2342)
#define idsCriteriaReplies              (STR_FIRST + 2343)
#define idsCriteriaDownloaded           (STR_FIRST + 2344)
#define idsCriteriaDeleted              (STR_FIRST + 2345)
#define idsCriteriaThreadState          (STR_FIRST + 2346)
#define idsSampleMailRule               (STR_FIRST + 2347)
#define idsSampleNewsRule               (STR_FIRST + 2348)
#define idsViewAllMessages              (STR_FIRST + 2349)
#define idsViewNoDeleted                (STR_FIRST + 2350)
#define idsViewUnread                   (STR_FIRST + 2351)
#define idsViewDownloaded               (STR_FIRST + 2352)
#define idsViewReplies                  (STR_FIRST + 2353)
#define idsViewNoIgnored                (STR_FIRST + 2354)
#define idsActionsHide                  (STR_FIRST + 2355)
#define idsCriteriaNotRead              (STR_FIRST + 2356)
#define idsCriteriaNotDownloaded        (STR_FIRST + 2357)
#define idsCriteriaNotDeleted           (STR_FIRST + 2358)
#define idsYouMadeChanges               (STR_FIRST + 2359)
#define idsRefreshFolderListPrompt      (STR_FIRST + 2360)
#define idsRulesErrBadFileFormat        (STR_FIRST + 2361)
#define idsDSDeleteCollapsedThread      (STR_FIRST + 2362)
#define idsXMsgsYUnreadFind             (STR_FIRST + 2363)
#define idsMonitoring                   (STR_FIRST + 2364)
#define idsSyncManagerNews              (STR_FIRST + 2365)
#define idsOfflineTransactionsFailed    (STR_FIRST + 2370)
#define idsMovedToOfflineErrors         (STR_FIRST + 2371)
#define idsStatNameHeader               (STR_FIRST + 2372)
#define idsStatBackHeader               (STR_FIRST + 2373)
#define idsStatFontHeader               (STR_FIRST + 2374)
#define idsStatMarginHeader             (STR_FIRST + 2375)
#define idsStatFinalHeader              (STR_FIRST + 2376)
#define idsStatBackMsg                  (STR_FIRST + 2377)
#define idsStatMarginMsg                (STR_FIRST + 2378)
#define idsStatFontMsg                  (STR_FIRST + 2379)
#define idsStatNameMsg                  (STR_FIRST + 2380)
#define idsStatCompleteMsg              (STR_FIRST + 2381)
#define idsStatWizVertPos               (STR_FIRST + 2382)
#define idsStatWizHorzPos               (STR_FIRST + 2383)
#define idsStatWizTile                  (STR_FIRST + 2384)
#define idsErrStatEditNoSelection       (STR_FIRST + 2385)
#define idsGetUnreadCountFailureFmt     (STR_FIRST + 2386)
#define idsIMAPFoldersTT                (STR_FIRST + 2387)
#define idsSecurityTT                   (STR_FIRST + 2388)
#define idsErrOfflineFldrCreate         (STR_FIRST + 2389)
#define idsErrOfflineFldrRename         (STR_FIRST + 2390)
#define idsErrOfflineFldrDelete         (STR_FIRST + 2391)
#define idsErrOfflineFldrMove           (STR_FIRST + 2392)
#define idsUndeleteTT                   (STR_FIRST + 2393)
#define idsAddressesBtn                 (STR_FIRST + 2394)
#define idsCancelBtn                    (STR_FIRST + 2395)
#define idsDecodeBtn                    (STR_FIRST + 2396)
#define idsGetHeadersBtn                (STR_FIRST + 2397)
#define idsInboxBtn                     (STR_FIRST + 2398)
#define idsOutboxBtn                    (STR_FIRST + 2399)
#define idsSentItemsBtn                 (STR_FIRST + 2400)
#define idsMarkAllBtn                   (STR_FIRST + 2401)
#define idsMarkOfflineBtn               (STR_FIRST + 2402)
#define idsMarkThreadBtn                (STR_FIRST + 2403)
#define idsNextUnreadBtn                (STR_FIRST + 2404)
#define idsNextThreadBtn                (STR_FIRST + 2405)
#define idsNextFolderBtn                (STR_FIRST + 2406)
#define idsPurgeBtn                     (STR_FIRST + 2407)
#define idsReplyBtn                     (STR_FIRST + 2408)
#define idsReplyAllBtn                  (STR_FIRST + 2409)
#define idsReplyGroupBtn                (STR_FIRST + 2410)
#define idsSendReceiveBtn               (STR_FIRST + 2411)
#define idsSyncNowBtn                   (STR_FIRST + 2412)
#define idsMarkReadBtn                  (STR_FIRST + 2413)
#define idsAttachBtn                    (STR_FIRST + 2414)
#define idsRecipBtn                     (STR_FIRST + 2415)
#define idsOfflineBtn                   (STR_FIRST + 2416)
#define idsOnlineBtn                    (STR_FIRST + 2417)
#define idsUpdatingFolderList           (STR_FIRST + 2418)
#define idsEncryptBtn                   (STR_FIRST + 2419)
#define idsDigSignBtn                   (STR_FIRST + 2420)
#define idsCheckBtn                     (STR_FIRST + 2421)
#define idsPriorityBtn                  (STR_FIRST + 2422)
#define idsSortingFolder                (STR_FIRST + 2423)

#define idsSecureEncrypt                (STR_FIRST + 2424)
#define idsNormalPri                    (STR_FIRST + 2425)
#define idsSecureNone                   (STR_FIRST + 2426)
#define idsCriteriaLines                (STR_FIRST + 2427)
#define idsLines                        (STR_FIRST + 2428)
#define idsCriteriaAge                  (STR_FIRST + 2429)
#define idsDays                         (STR_FIRST + 2430)
#define idsHighPri                      (STR_FIRST + 2431)
#define idsLowPri                       (STR_FIRST + 2432)
#define idsCriteriaSecure               (STR_FIRST + 2433)
#define idsSecureSigned                 (STR_FIRST + 2434)
#define idsThreadWatch                  (STR_FIRST + 2435)
#define idsThreadIgnore                 (STR_FIRST + 2436)
#define idsThreadNone                   (STR_FIRST + 2437)
#define idsNewsServer                   (STR_FIRST + 2438)
#define idsActionsAnd                   (STR_FIRST + 2439)
#define idsCriteriaOr                   (STR_FIRST + 2440)
#define idsCriteriaAndOr                (STR_FIRST + 2441)
#define idsMessageFileName              (STR_FIRST + 2442)
#define idsEnvSendCopy                  (STR_FIRST + 2443)
#define idsStatusWatched                (STR_FIRST + 2444)
#define idsStatusIgnored                (STR_FIRST + 2445)
#define idsStatusFormat1                (STR_FIRST + 2446)
#define idsStatusFormat2                (STR_FIRST + 2447)
#define idsStatusFormat3                (STR_FIRST + 2448)
#define idsChangeNewsServer             (STR_FIRST + 2449)
#define idsForceSaveToLocalDrafts       (STR_FIRST + 2450)
#define idsHTMLErrArticleExpired        (STR_FIRST + 2451)
#define idsCriteriaFlagged              (STR_FIRST + 2452)
#define idsCriteriaNotFlagged           (STR_FIRST + 2453)
#define idsLocalFoldersMinor            (STR_FIRST + 2454)
#define idsNoteCantSwitchIdentity       (STR_FIRST + 2455)
#define idsFindNextFinished             (STR_FIRST + 2456)
#define idsFindNextFinishedFailed       (STR_FIRST + 2457)
#define idsPushPinInfo                  (STR_FIRST + 2458)
#define idsNewMailBtn                   (STR_FIRST + 2459)
#define idsNewNewsBtn                   (STR_FIRST + 2460)
#define idsRulesErrorNoText             (STR_FIRST + 2461)
#define idsRulesErrorNoAddr             (STR_FIRST + 2462)
#define idsCantCopyNotDownloaded        (STR_FIRST + 2463)
#define idsCantMoveNotDownloaded        (STR_FIRST + 2464)
#define idsErrAddToWabSender            (STR_FIRST + 2465)
#define idsUseIntlToolbarDefaults       (STR_FIRST + 2466)
#define idsOE5IMAPSpecialFldrs          (STR_FIRST + 2467)
#define idsWrongSecHeader               (STR_FIRST + 2468)
#define idsYouMadeChangesOneOrMore      (STR_FIRST + 2469)
#define idsWorkOfflineHangup            (STR_FIRST + 2470)
#define idsWorkingOnline                (STR_FIRST + 2471)
#define idsViewFiltered                 (STR_FIRST + 2472)
#define idsViewsErrorNoName             (STR_FIRST + 2473)
#define idsViewsErrorNoCriteria         (STR_FIRST + 2474)
#define idsViewsErrorNoActions          (STR_FIRST + 2475)
#define idsColumnHiddenWarning          (STR_FIRST + 2476)
#define idsMsgrEmptyList                (STR_FIRST + 2477)
#define idsMigIncomplete                (STR_FIRST + 2478)
#define idsUndeletingMessages           (STR_FIRST + 2479)
#define idsVerifyingFile                (STR_FIRST + 2480)
#define idsRepairingFile                (STR_FIRST + 2481)
#define idsCheckWatchedMessgesServer    (STR_FIRST + 2482)
#define idsCheckingWatchedProgress      (STR_FIRST + 2483)
#define idsErrFailedWatchInit           (STR_FIRST + 2484)
#define idsCheckingWatchedFolderProg    (STR_FIRST + 2485)
#define idsActionsJunkMail              (STR_FIRST + 2486)
#define idsOutlookNewsReader            (STR_FIRST + 2487)
#define idsErrNoMailInstalled           (STR_FIRST + 2488)
#define idsReplyTextPrefix              (STR_FIRST + 2489)
#define idsReplyTextAppend              (STR_FIRST + 2490)
#define idsNoTextInNewsPost             (STR_FIRST + 2491)
#define idsExceptionBlank               (STR_FIRST + 2492)
#define idsRuleExcptWarnDelete          (STR_FIRST + 2493)
#define idsActionsWatch                 (STR_FIRST + 2494)
#define idsSRAccountMenuHelp            (STR_FIRST + 2495)
#define idsInsertSigGeneralHelp         (STR_FIRST + 2496)
#define idsApplyFormatGeneralHelp       (STR_FIRST + 2497)
//#define idsAddUserFail                  (STR_FIRST + 2498)
#define idsCriteriaFromEdit             (STR_FIRST + 2499)
#define idsCriteriaToEdit               (STR_FIRST + 2500)
#define idsCriteriaCCEdit               (STR_FIRST + 2501)
#define idsCriteriaToOrCCEdit           (STR_FIRST + 2502)
#define idsCriteriaSubjectEdit          (STR_FIRST + 2503)
#define idsCriteriaBodyEdit             (STR_FIRST + 2504)
#define idsCriteriaMultOr               (STR_FIRST + 2505)
#define idsCriteriaMultAnd              (STR_FIRST + 2506)
#define idsCriteriaFromNotEdit          (STR_FIRST + 2507)
#define idsCriteriaToNotEdit            (STR_FIRST + 2508)
#define idsCriteriaCCNotEdit            (STR_FIRST + 2509)
#define idsCriteriaToOrCCNotEdit        (STR_FIRST + 2510)
#define idsCriteriaSubjectNotEdit       (STR_FIRST + 2511)
#define idsCriteriaBodyNotEdit          (STR_FIRST + 2512)
#define idsCriteriaMultFirst            (STR_FIRST + 2513)
#define idsCriteriaMultFirstNot         (STR_FIRST + 2514)
#define idsShowMessages                 (STR_FIRST + 2515)
#define idsHideMessages                 (STR_FIRST + 2516)
#define idsShowHideMessages             (STR_FIRST + 2517)
#define idsCriteriaEditFirst            (STR_FIRST + 2518)
#define idsCriteriaEditOr               (STR_FIRST + 2519)
#define idsCriteriaEditAnd              (STR_FIRST + 2520)
#define idsVerifyCancel                 (STR_FIRST + 2521)
#define idsIMAPHC_NoSlash               (STR_FIRST + 2522)
#define idsIMAPHC_NoBackSlash           (STR_FIRST + 2523)
#define idsIMAPHC_NoDot                 (STR_FIRST + 2524)
#define idsIMAPHC_NoHC                  (STR_FIRST + 2525)
#define idsApplyRuleTitle               (STR_FIRST + 2526)
#define idsNewMailRuleTitle             (STR_FIRST + 2527)
#define idsEditMailRuleTitle            (STR_FIRST + 2528)
#define idsNewNewsRuleTitle             (STR_FIRST + 2529)
#define idsEditNewsRuleTitle            (STR_FIRST + 2530)
#define idsNewViewTitle                 (STR_FIRST + 2531)
#define idsEditViewTitle                (STR_FIRST + 2532)
#define IDS_NO_DESCRIPTIONS_DOWNLOADED  (STR_FIRST + 2533)
#define idsApplyRulesNoNewsFolders      (STR_FIRST + 2534)
#define idsApplyRulesFinished           (STR_FIRST + 2535)
#define idsErrorApplyRulesMail          (STR_FIRST + 2536)
#define idsErrorApplyRulesNews          (STR_FIRST + 2537)
#define idsStatusUnsafeAttach           (STR_FIRST + 2538)

#define IDS_IXP_E_HTTP_USE_PROXY        (STR_FIRST + 2575)
#define IDS_IXP_E_HTTP_BAD_REQUEST      (STR_FIRST + 2576)
#define IDS_IXP_E_HTTP_UNAUTHORIZED     (STR_FIRST + 2577)
#define IDS_IXP_E_HTTP_FORBIDDEN        (STR_FIRST + 2578)
#define IDS_IXP_E_HTTP_NOT_FOUND        (STR_FIRST + 2579)
#define IDS_IXP_E_HTTP_METHOD_NOT_ALLOW (STR_FIRST + 2580)
#define IDS_IXP_E_HTTP_NOT_ACCEPTABLE   (STR_FIRST + 2581)
#define IDS_IXP_E_HTTP_PROXY_AUTH_REQ   (STR_FIRST + 2582)
#define IDS_IXP_E_HTTP_REQUEST_TIMEOUT  (STR_FIRST + 2583)
#define IDS_IXP_E_HTTP_CONFLICT         (STR_FIRST + 2584)
#define IDS_IXP_E_HTTP_GONE             (STR_FIRST + 2585)
#define IDS_IXP_E_HTTP_LENGTH_REQUIRED  (STR_FIRST + 2586)
#define IDS_IXP_E_HTTP_PRECOND_FAILED   (STR_FIRST + 2587)
#define IDS_IXP_E_HTTP_INTERNAL_ERROR   (STR_FIRST + 2588)
#define IDS_IXP_E_HTTP_NOT_IMPLEMENTED  (STR_FIRST + 2589)
#define IDS_IXP_E_HTTP_BAD_GATEWAY      (STR_FIRST + 2590)
#define IDS_IXP_E_HTTP_SERVICE_UNAVAIL  (STR_FIRST + 2591)
#define IDS_IXP_E_HTTP_GATEWAY_TIMEOUT  (STR_FIRST + 2592)
#define IDS_IXP_E_HTTP_VERS_NOT_SUP     (STR_FIRST + 2593)
#define idsTBCustomize                  (STR_FIRST + 2594)
#define idsNotConnectedTo               (STR_FIRST + 2595)
#define idsRulesApplyMail               (STR_FIRST + 2596)
#define idsRulesApplyNews               (STR_FIRST + 2597)
#define idsEmptyJunkMail                (STR_FIRST + 2598)
#define idsEmptyFilteredView            (STR_FIRST + 2599)
#define idsAddException                 (STR_FIRST + 2600)
#define idsEditException                (STR_FIRST + 2601)
#define idsAddBlockSender               (STR_FIRST + 2602)
#define idsEditBlockSender              (STR_FIRST + 2603)
#define idsRulesNoIMAP                  (STR_FIRST + 2604)
#define idsJunkMailNoIMAP               (STR_FIRST + 2605)
#define idsBlockSenderNoIMAP            (STR_FIRST + 2606)
#define idsRulesOffHeader               (STR_FIRST + 2607)
#define idsRulesErrorFwdHeader          (STR_FIRST + 2608)
#define idsRulesApplyHeader             (STR_FIRST + 2609)
#define idsRulesDescriptionEmpty        (STR_FIRST + 2610)
#define idsViewDescriptionEmpty         (STR_FIRST + 2611)
#define idsDisplayImapSubDlgOffline     (STR_FIRST + 2612)
#define idsDisplayNewsSubDlgOffline     (STR_FIRST + 2613)
#define idsDBAccessDenied               (STR_FIRST + 2614)
#define idsUnreadCountPollErrorFmt      (STR_FIRST + 2615)
#define idsHeaderDownloadFailureFmt     (STR_FIRST + 2616)
#define idsMessageSyncFailureFmt        (STR_FIRST + 2617)
#define idsShowDeleted                  (STR_FIRST + 2618)
#define idsSendReceive                  (STR_FIRST + 2619)
#define idsNewsFilterDefaultName        (STR_FIRST + 2620)
#define idsMoveStoreFoundODS            (STR_FIRST + 2621)
#define idsStoreMoveRegWriteFail        (STR_FIRST + 2622)
#define idsIMAPNoTranslatableInferiors  (STR_FIRST + 2623)
#define idsMSOutlookNewsReader          (STR_FIRST + 2624)
#define idsMoveDownloadFail             (STR_FIRST + 2625)
#define idsCopyDownloadFail             (STR_FIRST + 2626)
#define idsCustomizeViewTitle           (STR_FIRST + 2627)
#define idsViewMenuHelpControl          (STR_FIRST + 2628)
#define idsNoMoreUnreadMessages         (STR_FIRST + 2629)
#define idsNoMoreUnreadFolders          (STR_FIRST + 2630)
#define idsErrorAttachingMsgsToNote     (STR_FIRST + 2631)
#define idsSenderAddedPrompt            (STR_FIRST + 2632)
#define idsSendersAddedPrompt           (STR_FIRST + 2633)
#define idsOEPreviewPane                (STR_FIRST + 2634)
#define idsOutlookBar                   (STR_FIRST + 2635)
#define idsFolderBar                    (STR_FIRST + 2636)
#define idsSendersApplyProgress         (STR_FIRST + 2637)
#define idsSendersApplySuccess          (STR_FIRST + 2638)
#define idsSendersApplyFail             (STR_FIRST + 2639)
#define idsRulesApplyFail               (STR_FIRST + 2640)
#define idsSenderDupWarn                (STR_FIRST + 2641)
#define idsSyncFolder                   (STR_FIRST + 2642)
#define idsHttpServiceDoesntWork        (STR_FIRST + 2643)
#define idsHttpNoDeleteSupport          (STR_FIRST + 2644)
#define idsHttpNoSpaceOnServer          (STR_FIRST + 2645)
#define idsHttpNoSendMsgUrl             (STR_FIRST + 2646)
#define idsCantModifyMsnFolder          (STR_FIRST + 2647)
#define idsNothingToSync                (STR_FIRST + 2648)
#define idsSMTPSTARTTLSRequired         (STR_FIRST + 2649)
#define IDS_TIPS_MMS_FIRST              (STR_FIRST + 2650)
#define IDS_TIPS_MMS_0                  (STR_FIRST + 2650)
#define IDS_TIPS_MMS_1                  (STR_FIRST + 2651)
#define IDS_TIPS_MMS_2                  (STR_FIRST + 2652)
#define IDS_TIPS_MMS_3                  (STR_FIRST + 2653)
#define IDS_TIPS_MMS_4                  (STR_FIRST + 2654)
#define IDS_TIPS_MMS_5                  (STR_FIRST + 2655)
#define IDS_TIPS_MMS_6                  (STR_FIRST + 2656)
#define IDS_TIPS_MMS_7                  (STR_FIRST + 2657)
#define IDS_TIPS_MMS_8                  (STR_FIRST + 2658)
#define IDS_TIPS_MMS_LAST               (STR_FIRST + 2658)
#define idsSyncFolderTitle              (STR_FIRST + 2659)

#define IDS_TIPS_HM_FIRST               (STR_FIRST + 2660)
#define IDS_TIPS_HM_0                   (STR_FIRST + 2660)
#define IDS_TIPS_HM_1                   (STR_FIRST + 2661)
#define IDS_TIPS_HM_2                   (STR_FIRST + 2662)
#define IDS_TIPS_HM_3                   (STR_FIRST + 2663)
#define IDS_TIPS_HM_4                   (STR_FIRST + 2664)
#define IDS_TIPS_HM_5                   (STR_FIRST + 2665)
#define IDS_TIPS_HM_6                   (STR_FIRST + 2666)
#define IDS_TIPS_HM_7                   (STR_FIRST + 2667)
#define IDS_TIPS_HM_8                   (STR_FIRST + 2668)
#define IDS_TIPS_HM_9                   (STR_FIRST + 2669)
#define IDS_TIPS_HM_10                  (STR_FIRST + 2670)
#define IDS_TIPS_HM_LAST                (STR_FIRST + 2670)
#define idsSMTPNoSTARTTLSSupport        (STR_FIRST + 2671)
#define idsSMTPSTARTTLSFailed           (STR_FIRST + 2672)
#define idsHttpPollFailed               (STR_FIRST + 2673)
#define idsHttpBatchCopyErrors          (STR_FIRST + 2674)
#define idsHttpBatchCopyNoStorage       (STR_FIRST + 2675)

#define idsFmtSetupAccount              (STR_FIRST + 2684)
#define idsPromptCloseWiz               (STR_FIRST + 2685)
#define idsSimpleMAPI                   (STR_FIRST + 2686)
#define idsMAPISTUBMissingExport        (STR_FIRST + 2687)
#define idsMAPISTUBNoLoad               (STR_FIRST + 2688)
#define idsMAPISTUBFailed               (STR_FIRST + 2689)
#define idsMAPISTUBNeedsReboot          (STR_FIRST + 2690)
#define idsEditPeopleErrorNoName        (STR_FIRST + 2691)
#define idsSendWithoutAttach            (STR_FIRST + 2692)
#define idsReadReceipt                  (STR_FIRST + 2693)
#define idsDeleteReceipt                (STR_FIRST + 2694)
#define idsPromptReturnReceipts         (STR_FIRST + 2695)
#define idsReadableTextFirst            (STR_FIRST + 2696)
#define idsReadableTextSecond           (STR_FIRST + 2697)
#define idsWarnUnsentMailOffline        (STR_FIRST + 2698)
#define idsHideFolders                  (STR_FIRST + 2699)
#define idsUniTextFileFilter            (STR_FIRST + 2700)
#define idsReceiptsError                (STR_FIRST + 2701)
#define idsReceiptAt                    (STR_FIRST + 2702)
#define idsErrMoveMsgs                  (STR_FIRST + 2703)
#define idsErrCopyMsgs                  (STR_FIRST + 2704)
#define idsSignCertNotIncl              (STR_FIRST + 2705)
#define idsMsgWasNotEncrypted           (STR_FIRST + 2706)
#define idsEncrCertNotFoundOnPC         (STR_FIRST + 2707)
#define idsEncrCertNotIncluded          (STR_FIRST + 2708)
#define idsNoteLangTitle9x              (STR_FIRST + 2709)
#define idsProperyAccessDenied          (STR_FIRST + 2710)
#define idsErrAccessDenied              (STR_FIRST + 2711)
#define idsSentField                    (STR_FIRST + 2712)
#define idsReceiptField                 (STR_FIRST + 2713)
#define idsSecureReceiptText            (STR_FIRST + 2714)
#define idsSecurityInitError            (STR_FIRST + 2715)
#define idsSecReceiptCantDecode         (STR_FIRST + 2716)
#define idsCantFindSentItemFolder       (STR_FIRST + 2717)
#define idsCantFindOrgMsg               (STR_FIRST + 2718)
#define idsNoMatchRecBody               (STR_FIRST + 2719)
#define idsHashMisMatch                 (STR_FIRST + 2720)
#define idsRecHasProblems               (STR_FIRST + 2721)
#define idsCannotSendSecReceipt         (STR_FIRST + 2722)
#define idsFinalSelfReceipt             (STR_FIRST + 2723)
#define idsSelectEncrCertTitle          (STR_FIRST + 2724)
#define idsOESignature                  (STR_FIRST + 2725)
#define idsSendLabelErr                 (STR_FIRST + 2726)
#define idsSendRecRequestErr            (STR_FIRST + 2727)
#define idsSecPolicyNotFound            (STR_FIRST + 2728)
#define idsSecPolicyErr                 (STR_FIRST + 2729)
#define idsSecPolicyBadCert             (STR_FIRST + 2730)
#define idsSecPolicyForceEncr           (STR_FIRST + 2731)
#define idsWrnSecEncryption             (STR_FIRST + 2732)
#define idsHttpNoMoveCopy               (STR_FIRST + 2733)
#define idsReadme                       (STR_FIRST + 2734)
//
// end string Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Bitmap Resource IDs
//
#define idbGlobe                        1
#define idb16x16                        2
#define idb16x16st                      4
#define idbSplashHiRes                  5
#define idbSplashLoRes                  6
#define idbSplash256                    7
#define idbBtns                        12
#define idbFolders                     16
#define idbSecurity                    19
#define idbFoldersLarge                20
#define idbHeaderStatus                21
#define IDB_STATWIZ_WATERMARK          22
#define IDB_STATWIZ_HEADER             23

// Don't change the order of these - SteveSer
#define idbBrowser                     27
#define idbBrowserHot                  28
// Don't change the order of these - SteveSer

#define idbBrand38                     31
#define idbBrand26                     32
#define idbBrand22                     33
#define idbHiBrand38                   34
#define idbHiBrand22                   35
#define idbSpooler                     36
#define idbHiBrand26                   37

// Don't change the order of these - SteveSer
#define idb256Browser                  38
#define idb256BrowserHot               39
#define idbSmBrowser                   40
#define idbSmBrowserHot                41

// Don't change the order of these - SteveSer

// Don't change the order of these vvv (t-erikne)
#define idbPaneBar32                   42
#define idbPaneBar32Hot                43
// Don't change the order of these ^^^ (t-erikne)

#define idbAddrBookHot                 47

// BL control
#define idbStatus                      53
#define idbClosePin                    54
#define idbOptions                     62

//Rules Toolbar bitmap
#define idbSmRulesTB                   idbSmBrowser      
#define idbSmRulesTBHot                idbSmBrowserHot   
#define idbLoRulesTB                   idbBrowser   
#define idbLoRulesTBHot                idbBrowserHot
#define idbHiRulesTB                   idb256Browser    
#define idbHiRulesTBHot                idb256BrowserHot
#define idbRules                       63 

#define idbOELogo                      64
#define idbWindowsLogo                 65

// Non-Whistler bitmaps
#define idbNWSmBrowser                 66
#define idbNWSmBrowserHot              67
#define idbNWBrowser                   68
#define idbNWBrowserHot                69
#define idbNW256Browser                70 
#define idbNW256BrowserHot             71


// Whistler 32bit color bitmaps
#define idb32SmBrowser                 72
#define idb32SmBrowserHot              73
#define idb32256Browser                74
#define idb32256BrowserHot             75

#define idbNWSmRulesTB                 idbNWSmBrowser      
#define idbNWSmRulesTBHot              idbNWSmBrowserHot   
#define idbNWLoRulesTB                 idbNWBrowser   
#define idbNWLoRulesTBHot              idbNWBrowserHot
#define idbNWHiRulesTB                 idbNW256Browser    
#define idbNWHiRulesTBHot              idbNW256BrowserHot

#define idb32SmRulesTB                 idb32SmBrowser      
#define idb32SmRulesTBHot              idb32SmBrowserHot   
#define idb32LoRulesTB                 idbBrowser   
#define idb32LoRulesTBHot              idbBrowserHot
#define idb32HiRulesTB                 idb32256Browser    
#define idb32HiRulesTBHot              idb32256BrowserHot

//
// END Bitmap Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Icon Resource IDs
//
#define idiMail                         2
#define idiMailNews                     idiMail
#define idiNews                         3
#define idiPasswordKeys                 6
#define idiNewsServer                   7
#define idiNewsGroup                    8
#define idiMessageAtt                  12
#define idiMsgPropSent                 14
#define idiMsgPropUnSent               15
#define idiError                       16
#define idiArtPropPost                 19
#define idiArtPropUnpost               20
#define idiPhone                       21
#define idiNewMailNotify               23
#define idiFolder                      25
#define idiNewsFolder                  27
#define idiSecReceipt                  28
#define idiReceipt                     29
#define idiDLMail                      41
#define idiDLNews                      42
#define idiWindowLayout                46
#define idiToolbarLayout               47
#define idiPrePaneLayout               48
#define idiUser                        50
#define idiPasswordKeys2               51
#define idiLogin                       52
#define idiMessenger                   53
#define idiFind                        54

#define idiSmallMsgPropSent            56
#define idiSmallMsgPropUnSent          57 
#define idiSmallArtPropPost            58
#define idiSmallArtPropUnpost          59
#define idiSecReceiptIcon              60

//
// END Icon Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Animation Resource IDs
//
#define idanInbox                     1
#define idanOutbox                    2
#define idanDecode                    6
#define idanCompact                   7
#define idanDownloadNews              8
#define idanCopyMsgs                  9

//
// END Animation Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Dialog Resource IDs (DIALOG resource ids, not control ids!)
//
#define iddVersion                      1
#define iddDontShow                     2
#define iddCopyMoveMessages             3
#define iddAdvSecurity                  4
#define iddAthenaDefault                6
#define iddStoreLocation                7
#define iddAdvSig                       8
#define iddSubscribe                   12
#define IDD_PLAYBACK                   13
#define iddSubscribeImap               14
#define iddUpdateNewsgroup             15
#define iddPassword                    16

#define iddInsertFile                  21

#define iddRasLogon                    27
#define iddWebPage                     28
#define iddBkImage                     29

#define iddPickGroup                   40
#define iddDownloadGroups              41
#define iddNewFolder                   45
#define iddRasCloseConn                46
#define iddOpt_Security                47
#define iddOpt_Spelling                48
#define iddOpt_DialUp                  49
#define iddOpt_Read                    50
#define iddOpt_General                 51
#define iddOpt_Send                    52
#define iddOpt_Advanced                53
#define iddOpt_Signature               54
#define iddOpt_Compose                 55

#define iddMsgProp_General             58
#define iddMsgProp_Details             60
#define iddRasProgress                 62
#define iddDetailedError               63

#define iddOrderMessages               69
#define iddCriteriaAge                 70
#define iddActionsShow                 71
#define iddCriteriaSecure              72
#define iddCriteriaPriority            73
#define iddCriteriaThreadState         74
#define iddCriteriaRead                75
#define iddActionWatch                 76
#define iddExceptionsList              77
#define iddEditException               78
#define iddPlainRecipWarning           79
#define iddCriteriaDownloaded          80
#define iddCriteriaFlag                81
#define iddCriteriaPeople              82
#define iddCriteriaWords               83
#define iddCriteriaPeopleOptions       84
#define iddCriteriaWordsOptions        85
#define iddCacheMan                    86
#define iddProgress                    87
#define IDD_FIND                       88
#define iddHotMailWizard               89
#define iddApplyView                   90

#define iddCombineAndDecode            92

#define iddMsgProp_Security_Msg        95
#define iddMsgProp_Sec_ViewCert        96

#define iddSecCerificateErr            98

#define iddHTMLSettings               105
#define iddPlainSettings              106
#define iddFolderProp_General         115
#define iddGroupProp_General          116

#define iddSendIntlSetting            120
#define iddNewsProp_Cache             121
#define iddInetMailError              126
#define iddCreateFolder               133
#define iddSelectFolder               134
#define iddTransportErrorDlg          138
#define iddSpoolerDlg                 140
#define iddFrameWarning               141
#define iddGroupProp_Update           143
#define iddRasStartup                 144
#define iddIntlSetting                146
#define iddCharsetConflict            147
#define iddTimeout                    149
#define iddSelectStationery           150
#define iddFolderProp_Update          151
#define iddViewLayout                 152

#define iddWarnSecuritySigningCert    154
#define iddErrSecurityNoSigningCert   155
#define iddViewsManager               157
#define iddEditView                   159
#define iddColumns                    160
#define iddRulesManager               161
#define iddEditRule                   162
#define iddCriteriaAcct               165
#define iddActionColor                166
#define iddCriteriaLogic              167
#define iddCriteriaSize               169
#define iddActionFwd                  170

#define iddStatName                   171
#define iddStatBackground             172
#define iddStatFont                   173
#define iddStatMargin                 174
#define iddMoreStationery             175
#define iddStatFinal                  176
#define iddStatStart                  177
#define iddSelectLabel                178  
#define iddStatWelcome                179
#define iddCriteriaLines              180

// BL Dialogs
#define iddSignOn                     181
#define iddWabExt                     182
#ifdef SMIME_V3
#define iddSecReceipt                 183
#define iddSecResponse                184
#endif // SMIME_V3

#define iddSyncSettings               200
#define iddRulesMail                  201
#define iddRulesJunk                  203
#define iddRulesSenders               204
#define iddEditSender                 205
#define iddRuleApplyTo                206
#define iddOfferOffline               210
#define iddToolbarTextIcons           211
#define iddMapiSend                   212

// import/export dlgs
#define iddExport                     220
#define iddImpProgress                221
#define iddMigrate                    222
#define iddMigrateMode                223
#define iddMigrateIncomplete          224
#define iddSelectClient               225
#define iddLocation                   226
#define iddSelectFolders              227
#define iddAddressComplete            228
#define iddSelectCommUser             229
#define iddSelectAth16User            230
#define iddProvideMailPath            231
#define iddCongratulations            232
#define iddOpt_Receipts               233

//
// END Dialog Resource IDs (DIALOG resource ids, not control ids!)
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Dialog Control IDs (control ids, not DIALOG resource ids!)
//
// These only need to be unique within a single dialog.
//

// universal dialog stuff
#define IDC_STATIC                      -1
#define idcStatic1                      3500
#define idcStatic2                      3501
#define idcStatic3                      3502
#define idcStatic4                      3503
#define idcStatic5                      3504
#define idchkDontShowMeAgain            3505
#define idcStatic6                      3506
#define idcStatic7                      3507
#define idcStatic8                      3508
#define idcStatic9                      3509
#define idcStatic10                     3510
#define idcStatic11                     3511

// charset conflict dialog
#define idcSendAsUnicode                100

// version dialog
#define IDC_OE_LOGO                     101
#define IDC_VERSION_STAMP               102
#define IDC_MICROSOFT_COPYRIGHT         103
#define IDC_HALLMARK_COPYRIGHT          104
#define IDC_HALLMARK_COPYRIGHT_2        105
#define IDC_COMPONENT_LIST              106
#define IDC_WINDOWS_LOGO                107

// WebPage dialog
#define idTxtWebPage                    1000

// header and note controls
#define NOTE_FIRST                      1000
#define idREBody                        (NOTE_FIRST + 0)
#define idADTo                          (NOTE_FIRST + 1)
#define idADNewsgroups                  (NOTE_FIRST + 2)
#define idADCc                          (NOTE_FIRST + 3)
#define idTXTSubject                    (NOTE_FIRST + 4)
#define idADFrom                        (NOTE_FIRST + 5)
#define idbtnTo                         (NOTE_FIRST + 7)
#define idbtnCc                         (NOTE_FIRST + 8)
#define idAttach                        (NOTE_FIRST + 12)
#define idcNoteHdr                      (NOTE_FIRST + 15)
#define idTXTDate                       (NOTE_FIRST + 16)
#define idTXTFollowupTo                 (NOTE_FIRST + 18)
#define idADReplyTo                     (NOTE_FIRST + 19)
#define idTXTOrg                        (NOTE_FIRST + 20)
#define idTXTDistribution               (NOTE_FIRST + 21)
#define idTXTKeywords                   (NOTE_FIRST + 22)
#define idADApproved                    (NOTE_FIRST + 23)
#define idbtnFollowup                   (NOTE_FIRST + 24)
#define idbtnReplyTo                    (NOTE_FIRST + 25)
#define idADBCc                         (NOTE_FIRST + 26)
#define idbtnBCc                        (NOTE_FIRST + 27)
#define idSecurity                      (NOTE_FIRST + 28)
#define idStatusbar                     (NOTE_FIRST + 29)
#define idTxtBkImage                    (NOTE_FIRST + 30)
#define idTxtControl                    (NOTE_FIRST + 31)
#define idBrowsePicture                 (NOTE_FIRST + 33)
#define idVCardStamp                    (NOTE_FIRST + 34)
#define idFromCombo                     (NOTE_FIRST + 37)

// Tools.Spelling dialog
#define PSB_Spell_Ignore            101
#define PSB_Spell_IgnoreAll         102
#define PSB_Spell_Change            103
#define PSB_Spell_ChangeAll         104
#define PSB_Spell_Add               105
#define PSB_Spell_Suggest           106
#define PSB_Spell_UndoLast          107
#define EDT_Spell_WrongWord         108
#define TXT_Spell_Error             109
#define PSB_Spell_Options           110
#define TXT_Spell_Suggest           111
#define LBX_Spell_Suggest           112
#define EDT_Spell_ChangeTo          113
#define TXT_Spell_ChangeTo          114

#define CHK_AlwaysSuggest           202
#define CHK_CheckSpellingOnSend     203
#define CHK_IgnoreUppercase         204
#define CHK_IgnoreNumbers           205
#define CHK_IgnoreDBCS              206
#define CHK_IgnoreOriginalMessage   207
#define CHK_IgnoreURL               208
#define CHK_CheckSpellingOnType     209

#define idcSpellLanguages           215
#define idcViewDictionary           216

#define GRP_SpellIgnore             512

#define idtxtFolderName             101

#define IDC_CAPTION                 1049
#define IDC_TREEVIEW                1050
#define IDC_NEWFOLDER_BTN           1051

// This ID is to be used in richedit templates.
#define idredtTemplate              500

// Certificate error dlg
#define idcCertList                 1234
#define idGetDigitalIDs             1235
#define idcErrStat                  1236

// Intl Send dialog
#define idcLangCombo                    1001
#define idcLangCheck                    1002
#define idcServerEdit                   1003
#define idcSavePwCheck                  1004

// MsgrAb WabExt dialog
#define IDC_MSGR_ID_EDIT                1005
#define IDC_MSGR_ADD                    1006
#define IDC_USER_NAME                   1007
#define IDC_SEND_INSTANT_MESSAGE        1008
#define IDC_MSGR_BUTTON_SETDEFAULT      1010

// Certificate warning dialog
#define IDC_DONTSIGN                    1020

// Select security label dialog
#define IDC_POLICY_COMBO                1025
#define IDC_CLASSIF_COMB                1026
#define IDC_PRIVACY_EDIT                1027
#define IDC_CONFIGURE                   1028

#define IDC_ENCRECEIPT                  1029

#define IDC_FOLDER_STATIC               2000

//
// END Dialog Control IDs (control ids, not DIALOG resource ids!)
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Menu Resource IDs (MENU resources, not commands!)
//

//
// END Menu Resource IDs (MENU resources, not commands!)
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Cursor Resource IDs
//

#define idcurBrHand                     4

//
// END Cursor Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN RCDATA Resource IDs
//

//
// END RCDATA Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Accelerator Resource IDs
//

//
// END Accelerator Resource IDs
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN window ids.
//

#define idwAttachWell   1000

// END window ids
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN indices into the toolbar button bitmap
//

enum {
    itbNewMsg = 0,      //1
    itbPrint,           //2
    itbCut,             //3
    itbCopy,            //4
    itbPaste,           //5
    itbUndo,            //6
    itbDelete,          //7
    itbFind,            //8
    itbGotoInbox,       //9
    itbDeliverNowUsingAll,  //10
    itbReply,               //11
    itbReplyAll,            //12
    itbForward,             //13
    itbSend,                //14
    itbSaveAs,              //14
    itbPickRecipients,      //15
    itbCheckNames,          //16
    itbAttach,              //17
    itbNext,                //18
    itbPrevious,            //19
    itbNextUnreadArticle,   //20
    itbNextUnreadThread,    //21
    itbNextUnreadSubscr,    //22
    itbMarkAsRead,          //23
    itbConnect,             //24
    itbNewPost,             //25
    itbMarkDownload,        //26
    itbReplyByPost,         //27
    itbDisconnect,          //28
    itbMarkTopicRead,       //29
    itbMarkAllRead,         //30
    itbMarkTopicDownload,   //31
    //itbNextTopic,           //32
    itbInsertSig,           //33
    itbPostNow,             //34
    itbViewContacts,        //35
    itbEncrypted,           //36
    itbSigned,              //37
    itbSetPriority,         //38
    itbEnvOpt,              //39
    itbEnvBcc,              //40
    itbSpelling,            //41
    ctbBtns                 //
    };


// FormatBar stuff
enum
    {
    itbFormattingTag,
    itbFormattingBold,
    itbFormattingItalic,
    itbFormattingUnderline,
    itbFormattingColor,
    itbFormattingNumbers,
    itbFormattingBullets,
    itbFormattingDecreaseIndent,
    itbFormattingIncreaseIndent,
    itbFormattingLeft,
    itbFormattingCenter,
    itbFormattingRight,
    itbFormattingInsertHLine,
    itbFormattingInsertLink,
    itbFormattingInsertImage,
    ctbFormatting
    };

// Folder bitmap stuff
// Do NOT move the first two entries beyond 14.
enum
    {
    iNullBitmap = 0,
    iSortAsc,
    iSortDesc,
    iUnchecked,
    iChecked,
    iHeaderChecked,
    iFolderClosed,
    iInbox,
    iOutbox,
    iSendMail,
    iWastebasket,
    iFolderDraft,
    iFolderError,
    iFolderJunk,
    iFolderMsnPromo,
    iNewsGroup,
    iNewsServer,
    iUnsubGroup,
    iUnsubServer,
    iMailServer,
    iLocalFolders,
    iMailNews,
    iNewsGroupSync,
    iNewsRoot,
    iFolderDownload,
    iInboxDownload,
    iOutboxDownload,
    iSentDownload,
    iDeletedDownload,
    iDraftDownload,
    iErrorDownload,
    iJunkDownload,
    iMsnDownload,
    iMsnServer,
    cFolderIcon
    };

enum {
    iCBEncryption,
    iCBSigning,
    iCBBadEnc,
    iCBBadSign,
    iCBPaperclip,
    iCBVCard,
    };

// Folder State bitmap stuff
enum
    {
    iDownloadHeaders = 0,
    iDownloadNew,
    iDownloadAll,
    iStateMax
    };

enum
    {
    iColorMenu = 0,
    iColorCombo,
    iColorMax
    };

// Coolbar bitmaps
enum
{
    TBIMAGE_ADDRESS_BOOK,
    TBIMAGE_CANCEL_MESSAGE,
    TBIMAGE_COMBINE_AND_DECODE,
    TBIMAGE_CONTACTS_LIST,
    TBIMAGE_COPY_TO_FOLDER,
    TBIMAGE_DELETE,
    TBIMAGE_LANGUAGE,
    TBIMAGE_FIND,
    TBIMAGE_FOLDER_LIST,
    TBIMAGE_FORWARD,
    TBIMAGE_GET_HEADERS,
    TBIMAGE_GO_INBOX,
    TBIMAGE_GO_OUTBOX,
    TBIMAGE_GO_SENT_ITEMS,
    TBIMAGE_HELP,
    TBIMAGE_IMAP_FOLDERS,
    TBIMAGE_MARK_ALL_READ,
    TBIMAGE_MARK_DOWNLOAD,
    TBIMAGE_MARK_READ,
    TBIMAGE_MARK_THREAD_READ,
    TBIMAGE_MARK_UNREAD,
    TBIMAGE_MOVE_TO_FOLDER,
    TBIMAGE_NEW_MESSAGE,
    TBIMAGE_NEW_POST,
    TBIMAGE_NEWSGROUPS,
    TBIMAGE_NEXT_UNREAD_MESSAGE,
    TBIMAGE_NEXT_UNREAD_FOLDER,
    TBIMAGE_NEXT_UNREAD_THREAD,
    TBIMAGE_PREVIEW_PANE,
    TBIMAGE_PRINT,
    TBIMAGE_PURGE_DELETED,
    TBIMAGE_REFRESH,
    TBIMAGE_REPLY,
    TBIMAGE_REPLY_ALL,
    TBIMAGE_REPLY_GROUP,
    TBIMAGE_SAVE_AS,
    TBIMAGE_SEND_RECEIVE,
    TBIMAGE_STOP,
    TBIMAGE_SYNCHRONIZE,
    TBIMAGE_UNDELETE,
    TBIMAGE_UNSCRAMBLE,
    TBIMAGE_WORK_OFFLINE,
    TBIMAGE_WORK_ONLINE,    
    TBIMAGE_CUT,
    TBIMAGE_COPY,
    TBIMAGE_PASTE,
    TBIMAGE_UNDO,
    TBIMAGE_SEND_MAIL,
    TBIMAGE_CHECK_NAMES,
    TBIMAGE_INSERT_ATTACHMENT,
    TBIMAGE_NEXT,
    TBIMAGE_PREVIOUS,
    TBIMAGE_REPLY_GROUP_AUTHOR,
    TBIMAGE_INSERT_SIG,
    TBIMAGE_SEND_NEWS,
    TBIMAGE_SECURITY_POPUP,
    TBIMAGE_SET_PRIORITY,
    TBIMAGE_ENVELOPE_OPTIONS,
    TBIMAGE_ENVELOPE_BCC,
    TBIMAGE_SPELLING,
    TBIMAGE_SIGNED,
    TBIMAGE_MAX
};

//
// END indices into the toolbar button bitmap
//
/////////////////////////////////////////////////////////////////////////////


#endif //__RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\athena.cpp ===
//
//  athena.cpp
//
//  Really global stuff
//

#include "pch.hxx"
#include <mimeole.h>
#include <BadStrFunctions.h>

OESTDAPI_(BOOL) FMissingCert(const CERTSTATE cs)
{
    return (cs == CERTIFICATE_NOT_PRESENT || cs == CERTIFICATE_NOPRINT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\bstr.h ===
/*
 * BSTR utilities
 * 
 */

#ifndef _BSTR_H
#define _BSTR_H

OESTDAPI_(HRESULT) HrIStreamToBSTR(UINT cp, LPSTREAM pstm, BSTR *pbstr);
OESTDAPI_(HRESULT) HrLPSZToBSTR(LPCSTR lpsz, BSTR *pbstr);
OESTDAPI_(HRESULT) HrLPSZCPToBSTR(UINT cp, LPCSTR lpsz, BSTR *pbstr);
OESTDAPI_(HRESULT) HrIStreamWToBSTR(LPSTREAM pstmW, BSTR *pbstr);
OESTDAPI_(HRESULT) HrBSTRToLPSZ(UINT cp, BSTR bstr, LPSTR *ppszOut);



#endif //_BSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\timeout.h ===
#define IDC_TIMEOUT 1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoeres\uidlerr.h ===
#define idbDownload                     1000
#define idcDontAskAgain                 1001
#define idsMessage                      1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\bstr.cpp ===
#include <pch.hxx>
#include "mimeole.h" //for CP_UNICODE
#include "mlang.h"
#include "demand.h"
#include <BadStrFunctions.h>

HRESULT HrLPSZCPToBSTR(UINT cp, LPCSTR lpsz, BSTR *pbstr)
{
    HRESULT                  hr = NOERROR;
    BSTR                     bstr=0;
    UINT                     cchSrc = 0;
    UINT                     cchDest = 0;
    IMultiLanguage          *pMLang = NULL;
    IMLangConvertCharset    *pMLangConv = NULL;

    if (!cp)
        cp = GetACP();

    if ((cp == CP_UTF8) && (lpsz[0] == 0xEF) && (lpsz[1] == 0xBB) && (lpsz[2] == 0xBF))
        lpsz += 3;        // Skip BOM
    
    IF_FAILEXIT(hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage, (void**)&pMLang));
    IF_FAILEXIT(hr = pMLang->CreateConvertCharset(cp, CP_UNICODE, NULL, &pMLangConv));    

    // get byte count
    cchDest = cchSrc = lstrlen(lpsz) + 1;

    // allocate a wide-string with enough character to hold string - use character count
    IF_NULLEXIT(bstr=SysAllocStringLen(NULL, cchSrc));

    hr = pMLangConv->DoConversionToUnicode((CHAR*)lpsz, &cchSrc, (WCHAR*)bstr, &cchDest);

    *pbstr = bstr;
    bstr=0;             // freed by caller

exit:
    if(bstr)
        SysFreeString(bstr);
    ReleaseObj(pMLangConv);
    ReleaseObj(pMLang);   
    return hr;
}

HRESULT HrLPSZToBSTR(LPCSTR lpsz, BSTR *pbstr)
{
    // GetACP so that it works on non-US platform
    return HrLPSZCPToBSTR(GetACP(), lpsz, pbstr);
}

HRESULT HrIStreamToBSTR(UINT cp, LPSTREAM pstm, BSTR *pbstr)
{
    HRESULT     hr;
    ULONG       cb;
    LPSTR       lpsz=0;
    BOOL        fLittleEndian = FALSE;

    if (CP_UNICODE == cp || (S_OK == HrIsStreamUnicode(pstm, &fLittleEndian)))
        return(HrIStreamWToBSTR(pstm, pbstr));

    hr=HrGetStreamSize(pstm, &cb);
    if (FAILED(hr))
        goto error;
    if (cb==0)
    {
        hr = E_FAIL;
        goto error;
    }
    
    HrRewindStream(pstm);      

    if (!MemAlloc((LPVOID *)&lpsz, cb+1))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }    
    
    hr = pstm->Read(lpsz, cb, &cb);
    if (FAILED(hr))
        goto error;

    lpsz[cb]=0;    

    hr = HrLPSZCPToBSTR(cp,lpsz, pbstr);
    if (FAILED(hr))
        goto error;

error:
    MemFree(lpsz);   
    return hr;
}



HRESULT HrIStreamWToBSTR(LPSTREAM pstm, BSTR *pbstr)
{
    ULONG       cb,
                cbTest,
                cch;
    BSTR        bstr;
    HRESULT     hr = E_FAIL;

    if (pstm == NULL || pbstr == NULL)
        return E_INVALIDARG;

    *pbstr = 0;
    
    if (SUCCEEDED(HrGetStreamSize(pstm, &cb)) && cb)
        {
        cch = cb / sizeof(WCHAR);

        HrRewindStream(pstm);

        bstr=SysAllocStringLen(NULL, cch);
        if(bstr)
            {
            // Raid 60259 - OE: Cannot successfully insert text file in Unicode (UCS-2)
            hr = pstm->Read(bstr, sizeof(WCHAR), &cbTest);
            if (SUCCEEDED(hr) && (sizeof(WCHAR) == cbTest) && (bstr[0] != 0xfeff))
                HrRewindStream(pstm);

            hr = pstm->Read(bstr, cb, &cb);
            if (SUCCEEDED(hr))
                {
                Assert (cb/sizeof(WCHAR) <= cch);
                bstr[cb/sizeof(WCHAR)]=0;
                *pbstr = bstr;
                }
            }
        }
    return hr;
}


HRESULT HrBSTRToLPSZ(UINT cp, BSTR bstr, LPSTR *ppszOut)
{
    Assert (bstr && ppszOut);

    *ppszOut = PszToANSI(cp, bstr);
    return *ppszOut ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\clogfile.h ===
//--------------------------------------------------------------------------
// LogFile.h
// Copyright (C) Microsoft Corporation, 1997 - Rocket Database
//--------------------------------------------------------------------------
#ifndef __CLOGFILE_H
#define __CLOGFILE_H

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
#define MAX_LOGFILE_PREFIX  10

//--------------------------------------------------------------------------
// Write Log Type
//--------------------------------------------------------------------------
typedef enum {
    LOGFILE_RX = 0,
    LOGFILE_TX,
    LOGFILE_DB,
    LOGFILE_MAX
} LOGFILETYPE;

#define DONT_TRUNCATE 0xFFFFFFFF

//--------------------------------------------------------------------------
// ILogFile
//--------------------------------------------------------------------------
interface ILogFile : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Open(HINSTANCE hInst, LPCSTR szLogFile, LPCSTR szPrefix, DWORD cbTruncate, DWORD dwShareMode) = 0;
    virtual HRESULT STDMETHODCALLTYPE TraceLog(SHOWTRACEMASK dwMask, TRACEMACROTYPE tracetype, ULONG ulLine, HRESULT hrResult, LPCSTR pszMessage) = 0;
    virtual HRESULT STDMETHODCALLTYPE WriteLog(LOGFILETYPE lft, LPCSTR pszData) = 0;
    virtual HRESULT STDMETHODCALLTYPE DebugLog(LPCSTR pszData) = 0;
    virtual HRESULT STDMETHODCALLTYPE DebugLogs(LPCSTR pszFormat, const char *s) = 0;
    virtual HRESULT STDMETHODCALLTYPE DebugLogd(const char *fmt, int d) = 0;
};

//--------------------------------------------------------------------------
// DllExported CLogFile Class
//--------------------------------------------------------------------------
class CLogFile : public ILogFile
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CLogFile(void);
    ~CLogFile(void);

    //----------------------------------------------------------------------
    // IUnknown
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    //----------------------------------------------------------------------
    // CLogFile Methods
    //----------------------------------------------------------------------
    STDMETHODIMP Open(HINSTANCE hInst, LPCSTR szLogFile, LPCSTR szPrefix, DWORD cbTruncate, DWORD dwShareMode);
    STDMETHODIMP TraceLog(SHOWTRACEMASK dwMask, TRACEMACROTYPE tracetype, ULONG ulLine, HRESULT hrResult, LPCSTR pszMessage);
    STDMETHODIMP WriteLog(LOGFILETYPE lft, LPCSTR pszData);
    STDMETHODIMP DebugLog(LPCSTR pszData);   // data to be logged
    STDMETHODIMP DebugLogs(LPCSTR pszFormat, const char *s);
    STDMETHODIMP DebugLogd(const char *fmt, int d);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;                             // Reference Counting
    HANDLE              m_hFile;                            // Handle to the logfile
    CHAR                m_szPrefix[MAX_LOGFILE_PREFIX];     // Logfile prefix
    HANDLE              m_hMutex;                           // So log files can be shared across procs
    CRITICAL_SECTION    m_cs;                               // Thread Safety
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
OESTDAPI_(HRESULT) CreateLogFile(HINSTANCE hInst, LPCSTR pszLogFile, LPCSTR pszPrefix, 
                                 DWORD cbTruncate, ILogFile **ppLogFile, DWORD dwShareMode);

#endif // __CLOGFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\clogfile.cpp ===
//--------------------------------------------------------------------------
// LogFile.cpp
// Copyright (C) Microsoft Corporation, 1997 - Rocket Database
//--------------------------------------------------------------------------
#include "pch.hxx"
#include <stdio.h>
#include <time.h>
#include <winver.h>
#include "clogfile.h"
#include <shlwapi.h>
#include <demand.h>
#include <BadStrFunctions.h>

//--------------------------------------------------------------------------
// LogFileTypes - RX = Receive, TX = Transmit, DB = Debug
//--------------------------------------------------------------------------
static LPSTR s_rgszPrefix[LOGFILE_MAX] = {
    "rx",
    "tx",
    "db"
};

//--------------------------------------------------------------------------
// These are strings that we shouldn't log in plaintext
//--------------------------------------------------------------------------
static LPSTR s_rgszPassPrefix[] = {
    "AUTHINFO PASS ",
    "PASS ",
    NULL
};

//--------------------------------------------------------------------------
// CreateSystemHandleName
//--------------------------------------------------------------------------
HRESULT CreateSystemHandleName(LPCSTR pszBase, LPCSTR pszSpecific, 
    LPSTR *ppszName)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       cchName;

    // Trace
    TraceCall("CreateSystemHandleName");

    // Invalid Args
    Assert(pszBase && pszSpecific && ppszName);

    // Init
    *ppszName = NULL;

    // Compute Length
    cchName = lstrlen(pszBase) + lstrlen(pszSpecific) + 15;

    // Allocate
    IF_NULLEXIT(*ppszName = PszAllocA(cchName));

    // Format the name
    wnsprintf(*ppszName, cchName, "%s%s", pszBase, pszSpecific);

    // Remove backslashes from this string
    ReplaceChars(*ppszName, '\\', '_');

    // Lower Case
    CharLower(*ppszName);

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CreateLogFile
//--------------------------------------------------------------------------
OESTDAPI_(HRESULT) CreateLogFile(HINSTANCE hInst, LPCSTR pszLogFile, 
    LPCSTR pszPrefix, DWORD cbTruncate, ILogFile **ppLogFile,
    DWORD dwShareMode)
{
    // Locals
    HRESULT     hr=S_OK;
    CLogFile   *pNew=NULL;

    // Trace
    TraceCall("CreateLogFile");

    // Invalid Args
    Assert(ppLogFile && pszLogFile);

    // Initialize
    *ppLogFile = NULL;

    // Create me
    pNew = new CLogFile;
    if (NULL == pNew)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // Open It
    IF_FAILEXIT(hr = pNew->Open(hInst, pszLogFile, pszPrefix, cbTruncate, dwShareMode));

    // Open It
    *ppLogFile = (ILogFile *)pNew;

    // Don't release it
    pNew = NULL;

exit:
    // Cleanup
    SafeRelease(pNew);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CLogFile::CLogFile
//--------------------------------------------------------------------------
CLogFile::CLogFile(void)
{
    TraceCall("CLogFile::CLogFile");
    m_cRef = 1;
    m_hMutex = NULL;
    m_hFile = INVALID_HANDLE_VALUE;
    InitializeCriticalSection(&m_cs);
}

//--------------------------------------------------------------------------
// CLogFile::~CLogFile
//--------------------------------------------------------------------------
CLogFile::~CLogFile(void)
{
    TraceCall("CLogFile::~CLogFile");
    if (m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle_F16(m_hFile);
    SafeCloseHandle(m_hMutex);
    DeleteCriticalSection(&m_cs);
}

//--------------------------------------------------------------------------
// CLogFile::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CLogFile::AddRef(void)
{
    TraceCall("CLogFile::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// CLogFile::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CLogFile::Release(void)
{
    TraceCall("CLogFile::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// CLogFile::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CLogFile::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CLogFile::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CLogFile::Open
//--------------------------------------------------------------------------
STDMETHODIMP CLogFile::Open(HINSTANCE hInst, LPCSTR pszFile, LPCSTR pszPrefix,
                            DWORD cbTruncate, DWORD dwShareMode)
{   
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szVersion[MAX_PATH];
    CHAR            szPath[MAX_PATH];
    LPSTR           pszInfo=NULL;
    DWORD           dwVerHnd;
    DWORD           dwVerInfoSize;
    DWORD           cbFile;
    CHAR            szGet[MAX_PATH];
    UINT            uLen;
    LPWORD          pdwTrans;
    LPSTR           pszT;
    SYSTEMTIME      st;
    LPSTR           pszVersion;
    CHAR            szPathMinusExt[MAX_PATH + 2];
    CHAR            szExt[4];
    DWORD           dwBytesWritten;
    LPSTR           pszMutex=NULL;
    BOOL            fReleaseMutex=FALSE;
    int             iCurrentLogNum; // For unique logfile generation

    // Tracing
    TraceCall("CLogFile::Open");

    // Save the Prefix
    StrCpyN(m_szPrefix, pszPrefix ? pszPrefix : "", ARRAYSIZE(m_szPrefix));

    // Create a Mutex Name
    IF_FAILEXIT(hr = CreateSystemHandleName(pszFile, "logfile", &pszMutex));

    // Create the Mutex
    m_hMutex = CreateMutex(NULL, FALSE, pszMutex);
    if (m_hMutex == NULL)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // If we have a mutex
    if (WAIT_OBJECT_0 != WaitForSingleObject(m_hMutex, INFINITE))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Release the Mutex
    fReleaseMutex = TRUE;

    // Split the logfile into path+filename and extension
    iCurrentLogNum = 0;
    StrCpyN(szPathMinusExt, pszFile, ARRAYSIZE(szPathMinusExt));
    pszT = PathFindExtension(szPathMinusExt);
    if (pszT && '.' == *pszT)
    {
        StrCpyN(szExt, pszT + 1, ARRAYSIZE(szExt));
        *pszT = '\0'; // Remove extension from path and filename
    }
    else
    {
        // Use default extension of "log"
        StrCpyN(szExt, "log", ARRAYSIZE(szExt));
    }

    // Generate first logfile name
    wnsprintf(szPath, ARRAYSIZE(szPath), "%s.%s", szPathMinusExt, szExt);

    // Open|Create the log file
    do
    {
        m_hFile = CreateFile(szPath, GENERIC_WRITE, dwShareMode, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == m_hFile)
        {
            DWORD dwLastErr;

            dwLastErr = GetLastError();
            // If file is already in use, then try to create a separate logfile. Otherwise bail.
            if (ERROR_SHARING_VIOLATION == dwLastErr)
            {
                // Generate next unique file name
                iCurrentLogNum += 1;
                wnsprintf(szPath, ARRAYSIZE(szPath), "%s (%d).%s", szPathMinusExt, iCurrentLogNum, szExt);
            }
            else
            {
                hr = TraceResultSz(E_FAIL, _MSG("Can't open logfile %s, GetLastError() = %d", szPath, dwLastErr));
                goto exit;
            }
        }
    } while (INVALID_HANDLE_VALUE == m_hFile);

    // Get the File Size
    cbFile = GetFileSize(m_hFile, NULL);

    // Get the size of the file    
    if (0xFFFFFFFF != cbFile) 
    {
        // Truncate It
        if (cbFile >= cbTruncate)
        {
            // Set the file pointer to the end of the file
            if (0xFFFFFFFF == SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN))
            {
                Assert(FALSE);
                hr = TraceResult(E_FAIL);
                goto exit;
            }

            // Set the End of file
            if (0 == SetEndOfFile(m_hFile))
            {
                Assert(FALSE);
                hr = TraceResult(E_FAIL);
                goto exit;
            }

            // File is zero-length
            cbFile = 0;
        }

        // Set the file pointer to the end of the file
        if (0xFFFFFFFF == SetFilePointer(m_hFile, 0, NULL, FILE_END))
        {
            Assert(FALSE);
            hr = TraceResultSz(E_FAIL, _MSG("Can't seek to the end of the logfile %s, GetLastError() = %d", szPath, GetLastError()));
            goto exit;
        }
    }

    // Get Module FileName
	GetModuleFileName(hInst, szPath, sizeof(szPath));

    // Initialize szVersion
    szVersion[0] = '\0';

	// Get version information from athena
	dwVerInfoSize = GetFileVersionInfoSize(szPath, &dwVerHnd);
    if (dwVerInfoSize)
    {
        // Allocate
        IF_NULLEXIT(pszInfo = (LPSTR)g_pMalloc->Alloc(dwVerInfoSize));

        // Get version info
	    if (GetFileVersionInfo(szPath, dwVerHnd, dwVerInfoSize, pszInfo))
        {
            // VerQueryValue
            if (VerQueryValue(pszInfo, "\\VarFileInfo\\Translation", (LPVOID *)&pdwTrans, &uLen) && uLen >= (2 * sizeof(WORD)))
            {
                // set up buffer for calls to VerQueryValue()
                wnsprintf(szGet, ARRAYSIZE(szGet), "\\StringFileInfo\\%04X%04X\\", pdwTrans[0], pdwTrans[1]);

                // What is this doing
                DWORD cchLen = lstrlen(szGet);
                pszT = szGet + cchLen;

                // Setup file description
                StrCatBuff(szGet, "FileDescription", ARRAYSIZE(szGet));

                // Get the file description
                if (VerQueryValue(pszInfo, szGet, (LPVOID *)&pszVersion, &uLen) && uLen)
                {                                    
                    StrCpyN(szVersion, pszVersion, ARRAYSIZE(szVersion));
                    StrCatBuff(szVersion, " ", ARRAYSIZE(szVersion));
                }

                // Setup Version String
                StrCpyN(pszT, "FileVersion", ARRAYSIZE(szGet) - cchLen);

                // Get the file version
                if (VerQueryValue(pszInfo, szGet, (LPVOID *)&pszVersion, &uLen) && uLen)
                    StrCatBuff(szVersion, pszVersion, ARRAYSIZE(szVersion));
            }
        }
    }

    // Write the Date
    GetLocalTime(&st);
    wnsprintf(szPath, ARRAYSIZE(szPath), "\r\n%s\r\n%s Log started at %.2d/%.2d/%.4d %.2d:%.2d:%.2d\r\n", szVersion, pszPrefix, st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);

    // add a new line
    WriteFile(m_hFile, szPath, lstrlen(szPath), &dwBytesWritten, NULL);

exit:
    // Failure
    AssertSz(SUCCEEDED(hr), "Log file could not be opened.");

    // Cleanup
    if (fReleaseMutex)
        ReleaseMutex(m_hMutex);
    SafeMemFree(pszInfo);
    SafeMemFree(pszMutex);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// WriteLogMsg
//--------------------------------------------------------------------------
STDMETHODIMP WriteLogMsg(CLogFile *pLogFile, LOGFILETYPE lft, LPTSTR pszFormat, ...)
{
    static TCHAR szBuffer[2048];
    va_list arglist;

    va_start(arglist, pszFormat);
    wvnsprintf(szBuffer, ARRAYSIZE(szBuffer), pszFormat, arglist);
    va_end(arglist);

    return pLogFile->WriteLog(lft, szBuffer);
}

//--------------------------------------------------------------------------
// CLogFile::TraceLog
//--------------------------------------------------------------------------
STDMETHODIMP CLogFile::TraceLog(SHOWTRACEMASK dwMask, TRACEMACROTYPE tracetype, ULONG ulLine, HRESULT hrResult, LPCSTR pszMessage)
{
    // Write the message
    if (TRACE_INFO == tracetype && pszMessage)
    {
        if (ISFLAGSET(dwMask, SHOW_TRACE_INFO))
            WriteLogMsg(this, LOGFILE_DB, "0x%08X: L(%d), Info: %s", GetCurrentThreadId(), ulLine, pszMessage);
    }
    else if (TRACE_RESULT == tracetype && pszMessage)
        WriteLogMsg(this, LOGFILE_DB, "0x%08X: L(%d), Result: HRESULT(0x%08X) - GetLastError() = %d - %s", GetCurrentThreadId(), ulLine, hrResult, GetLastError(), pszMessage);
    else if (TRACE_RESULT == tracetype && NULL == pszMessage)
        WriteLogMsg(this, LOGFILE_DB, "0x%08X: L(%d), Result: HRESULT(0x%08X) - GetLastError() = %d", GetCurrentThreadId(), ulLine, hrResult, GetLastError());
    else
        Assert(FALSE);

    // Done
    return hrResult;
}

//--------------------------------------------------------------------------
// CLogFile::WriteLog
//--------------------------------------------------------------------------
STDMETHODIMP CLogFile::WriteLog(LOGFILETYPE lft, LPCSTR pszData)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       bWrite;
    DWORD       cBytesWritten;
    SYSTEMTIME  st;
    CHAR        szLogPrefx[30];
    INT         cb;
    LPSTR       *ppszPrefix;
    LPSTR       pszFree=NULL;
    BOOL        fReleaseMutex=FALSE;

    // Trace
    TraceCall("CLogFile::WriteLog");

    // File is not open
    if (m_hFile == INVALID_HANDLE_VALUE)
        return TraceResult(E_UNEXPECTED);

    // Invalid Args
    Assert(pszData && lft < LOGFILE_MAX);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Initialized
    Assert(m_hMutex);

    // If we have a mutex
    if (WAIT_OBJECT_0 != WaitForSingleObject(m_hMutex, INFINITE))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Release the Mutex
    fReleaseMutex = TRUE;

    // Get the time
    GetLocalTime(&st);
    
    // Write the log prefix and time stamp
    wnsprintf(szLogPrefx, ARRAYSIZE(szLogPrefx), "%s: %.2d:%.2d:%.2d [%s] ", m_szPrefix, st.wHour, st.wMinute, st.wSecond, s_rgszPrefix[lft]);

    // Set the file pointer to the end of the file (otherwise multiple writers overwrite each other)
    if (0xFFFFFFFF == SetFilePointer(m_hFile, 0, NULL, FILE_END))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Write the time and prefix
    if (0 == WriteFile(m_hFile, szLogPrefx, lstrlen(szLogPrefx), &cBytesWritten, NULL))
    {
        hr = TraceResultSz(E_FAIL, _MSG("Can't write to logfile. GetLastError() = %d", GetLastError()));
        goto exit;
    }

    // Loop through prefixes
    for (ppszPrefix = s_rgszPassPrefix; *ppszPrefix; ppszPrefix++)
    {
        // Does the data start with one of these prefixes
        if (0 == StrCmpNI(pszData, *ppszPrefix, lstrlen(*ppszPrefix)))
        {
            // Dup the buffer that was passed in
            IF_NULLEXIT(pszFree = PszDupA(pszData));

            // Reset pszData
            pszData = pszFree;

            // Fixup the buffer
            for (LPSTR pszTmp = (LPSTR)pszData + lstrlen(*ppszPrefix); *pszTmp && *pszTmp != '\r'; pszTmp++)
                *pszTmp = '*';

            // Done
            break;
        }
    }

    // Get the length of pszData
    cb = lstrlen(pszData);

    // write the log data
    if (0 == WriteFile(m_hFile, pszData, cb, &cBytesWritten, NULL))
    {
        hr = TraceResultSz(E_FAIL, _MSG("Can't write to logfile. GetLastError() = %d", GetLastError()));
        goto exit;
    }

    // Add a CRLF if not there already
    if (cb < 2 || pszData[cb-1] != '\n' || pszData[cb-2] != '\r')
        WriteFile(m_hFile, "\r\n", 2, &cBytesWritten, NULL);

exit:
    // Cleanup
    if (fReleaseMutex)
        ReleaseMutex(m_hMutex);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeMemFree(pszFree);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// CLogFile::DebugLog
//--------------------------------------------------------------------------
STDMETHODIMP CLogFile::DebugLog(LPCSTR pszData)
{
    return WriteLog(LOGFILE_DB, pszData);
}

//--------------------------------------------------------------------------
// CLogFile::DebugLogs
//--------------------------------------------------------------------------
STDMETHODIMP CLogFile::DebugLogs(LPCSTR pszFormat, LPCSTR pszString)
{
    // Locals
    CHAR szBuffer[1024];

    // Build the String
    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), pszFormat, pszString);

    // Call Debug Log
    return DebugLog(szBuffer);
}

//--------------------------------------------------------------------------
// CLogFile::DebugLogd
//--------------------------------------------------------------------------
STDMETHODIMP CLogFile::DebugLogd(LPCSTR pszFormat, INT d)
{
    // Locals
    CHAR szBuffer[1024];

    // Build the String
    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), pszFormat, d);

    // Call Debug Log
    return DebugLog(szBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\capiutil.cpp ===
/*
**  c a p i u t i l . c p p
**
**  Purpose:
**      A few helper functions for the crypt32 utilities
**
**  History
**      5/22/97: (t-erikne) Created.
**
**    Copyright (C) Microsoft Corp. 1997.
*/

/////////////////////////////////////////////////////////////////////////////
//
// Depends on
//

#include "pch.hxx"
#include "demand.h"
#include <BadStrFunctions.h>

/////////////////  CAPI Enhancement code

LPVOID WINAPI CryptAllocFunc(size_t cbSize)
{
    LPVOID      pv;
    if (!MemAlloc(&pv, cbSize)) {
        return NULL;
    }
    return pv;
}

VOID WINAPI CryptFreeFunc(LPVOID pv)
{
    MemFree(pv);
}

CRYPT_ENCODE_PARA       CryptEncodeAlloc = {
    sizeof(CRYPT_ENCODE_PARA), (PFN_CRYPT_ALLOC) CryptAllocFunc, CryptFreeFunc
};

CRYPT_DECODE_PARA       CryptDecodeAlloc = {
    sizeof(CRYPT_DECODE_PARA), (PFN_CRYPT_ALLOC) CryptAllocFunc, CryptFreeFunc
};


/*  HrGetLastError
**
**  Purpose:
**      Convert a GetLastError value to an HRESULT
**      A failure HRESULT must have the high bit set.
**
**  Takes:
**      none
**
**  Returns:
**      HRESULT
*/
HRESULT HrGetLastError(void)
{
    DWORD error;
    HRESULT hr;

    error = GetLastError();

    if (error && ! (error & 0x80000000)) {
        hr = error | 0x80070000;    // system error
    } else {
        hr = (HRESULT)error;
    }

    return(hr);
}


/*  PVGetCertificateParam:
**
**  Purpose:
**      Combine the "how big? okay, here." double question to get a parameter
**      from a certificate.  Give it a thing to get and it will alloc the mem.
**  Takes:
**      IN pCert            - CAPI certificate to query
**      IN dwParam          - parameter to find, ex: CERT_SHA1_HASH_PROP_ID
**      OUT OPTIONAL cbOut  - (def value of NULL) size of the returned PVOID
**  Returns:
**      data that was obtained, NULL if failed
*/
OESTDAPI_(LPVOID) PVGetCertificateParam(
    PCCERT_CONTEXT  pCert,
    DWORD           dwParam,
    DWORD          *cbOut)
{
    HRESULT     hr;
    LPVOID      pv;

    hr = HrGetCertificateParam(pCert, dwParam, &pv, cbOut);
    if (FAILED(hr)) {
        return NULL;
    }
    return pv;
}

OESTDAPI_(HRESULT) HrGetCertificateParam(
    PCCERT_CONTEXT  pCert,
    DWORD           dwParam,
    LPVOID *        ppv,
    DWORD          *cbOut)
{
    DWORD               cbData;
    BOOL                f;
    HRESULT             hr = S_OK;
    void *              pvData = NULL;

    if (!pCert)
        {
        hr = E_INVALIDARG;
        goto ErrorReturn;
        }

    cbData = 0;
    f = CertGetCertificateContextProperty(pCert, dwParam, NULL, &cbData);
    if (!f || !cbData) {
        hr = HrGetLastError();
        goto ErrorReturn;
    }

    if (!MemAlloc(&pvData, cbData)) {
        hr = E_OUTOFMEMORY;
        goto ErrorReturn;
    }


    if (!CertGetCertificateContextProperty(pCert, dwParam, pvData, &cbData)) {
        hr = HrGetLastError();
        goto ErrorReturn;
    }

    *ppv = pvData;

exit:
    if (cbOut)
        *cbOut = cbData;
    return hr;;

ErrorReturn:
    if (pvData)
        {
        MemFree(pvData);
        pvData = NULL;
        }
    cbData = 0;
    goto exit;
}


/*  HrDecodeObject:
**
**  Purpose:
**      Combine the "how big? okay, here." double question to decode an
**      object.  Give it a thing to get and it will alloc the mem.  Return
**      HRESULT to caller.  Allow specification of decode flags.
**  Takes:
**      IN pbEncoded        - encoded data
**      IN cbEncoded        - size of data in pbData
**      IN item             - X509_* ... the thing to get
**      IN dwFlags          - CRYPT_DECODE_NOCOPY_FLAG
**      OUT OPTIONAL cbOut  - (def value of NULL) size of the return
**      OUT ppvOut           - allocated buffer with return data
**  Notes:
**      pbEncoded can't be freed until return is freed if
**      CRYPT_DECODE_NOCOPY_FLAG is specified.
**  Returns:
**      HRESULT
*/

OESTDAPI_(HRESULT) HrDecodeObject(
    const BYTE   *pbEncoded,
    DWORD   cbEncoded,
    LPCSTR  item,
    DWORD   dwFlags,
    DWORD  *pcbOut,
    LPVOID *ppvOut)
{
    DWORD cbData;
    HRESULT hr = S_OK;

    if (!(pbEncoded && cbEncoded && ppvOut))
        {
        hr = E_INVALIDARG;
        goto ErrorReturn;
        }


    if (!CryptDecodeObjectEx(X509_ASN_ENCODING, item, pbEncoded, cbEncoded,
                             dwFlags | CRYPT_DECODE_ALLOC_FLAG,
                             &CryptDecodeAlloc, ppvOut, &cbData)) {
        hr = HrGetLastError();
    }
    else {
        if (pcbOut != NULL) {
            *pcbOut = cbData;
        }
    }

ErrorReturn:
    return hr;
}


/*  PVDecodeObject:
**
**  Purpose:
**      Combine the "how big? okay, here." double question to decode an
**      object.  Give it a thing to get and it will alloc the mem.
**  Takes:
**      IN pbEncoded        - encoded data
**      IN cbEncoded        - size of data in pbData
**      IN item             - X509_* ... the thing to get
**      OUT OPTIONAL cbOut  - (def value of NULL) size of the return
**  Notes:
**      pbEncoded can't be freed until return is freed.
**  Returns:
**      data that was obtained, NULL if failed
*/
OESTDAPI_(LPVOID) PVDecodeObject(
    const BYTE   *pbEncoded,
    DWORD   cbEncoded,
    LPCSTR  item,
    DWORD  *pcbOut)
{
    void *pvData = NULL;
    HRESULT hr;

    if (hr = HrDecodeObject(pbEncoded, cbEncoded, item, CRYPT_DECODE_NOCOPY_FLAG, pcbOut, &pvData)) {
        SetLastError(hr);
    }

    return pvData;
}


/*  SzGetAltNameEmail:
**
**  Input:
**      pCert -> certificate context
**      lpszOID -> OID or predefined id of alt name to look in.  ie, OID_SUBJECT_ALT_NAME or
**        X509_ALTERNATE_NAME.
**
**  Returns:
**      Buffer containing email name or NULL if not found.
**      Caller must MemFree the buffer.
*/
OESTDAPI_(LPSTR) SzGetAltNameEmail(
  const PCCERT_CONTEXT pCert,
  LPSTR lpszOID) {
    PCERT_INFO pCertInfo = pCert->pCertInfo;
    PCERT_ALT_NAME_ENTRY pAltNameEntry;
    PCERT_ALT_NAME_INFO pAltNameInfo;
    ULONG i, j, cbData;
    LPSTR szRet = NULL;


    if (lpszOID == (LPCSTR)X509_ALTERNATE_NAME) {
        lpszOID = szOID_SUBJECT_ALT_NAME;
    }

    for (i = 0; i < pCertInfo->cExtension; i++) {
        if (! lstrcmp(pCertInfo->rgExtension[i].pszObjId, lpszOID)) {
            // Found the OID.  Look for the email tag

            if (pAltNameInfo = (PCERT_ALT_NAME_INFO)PVDecodeObject(
              pCertInfo->rgExtension[i].Value.pbData,
              pCertInfo->rgExtension[i].Value.cbData,
              lpszOID,
              NULL)) {

                // Cycle through the alt name entries
                for (j = 0; j < pAltNameInfo->cAltEntry; j++) {
                    if (pAltNameEntry = &pAltNameInfo->rgAltEntry[j]) {
                        if (pAltNameEntry->dwAltNameChoice == CERT_ALT_NAME_RFC822_NAME) {
                            // This is it, copy it out to a new allocation

                            if (pAltNameEntry->pwszRfc822Name)
                                {
                                cbData = WideCharToMultiByte(
                                  CP_ACP,
                                  0,
                                  (LPWSTR)pAltNameEntry->pwszRfc822Name,
                                  -1,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL);


                                if (MemAlloc((LPVOID*)&szRet, cbData)) {
                                    WideCharToMultiByte(
                                      CP_ACP,
                                      0,
                                      (LPWSTR)pAltNameEntry->pwszRfc822Name,
                                      -1,
                                      szRet,
                                      cbData,
                                      NULL,
                                      NULL);
                                    return(szRet);
                                }
                            }
                        }
                    }
                }

                MemFree(pAltNameInfo);
            }
        }
    }
    return(NULL);
}


/*  SzConvertRDNString
**
**  Purpose:
**      Figure out what kind of string data is in the RDN, allocate
**      a buffer and convert the string data to DBCS/ANSI.
**
**  Takes:
**      IN pRdnAttr - Certificate RDN atteribute
**  Returns:
**      A MemAlloc'd buffer containing the string.
**
**  BUGBUG: Should make mailnews use this function rather than
**      rolling it's own.
*/
LPTSTR SzConvertRDNString(PCERT_RDN_ATTR pRdnAttr) {
    LPTSTR szRet = NULL;
    ULONG cbData = 0;

    // We only handle certain types
    //N look to see if we should have a stack var for the ->
    if ((CERT_RDN_NUMERIC_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_PRINTABLE_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_IA5_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_VISIBLE_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_ISO646_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_UNIVERSAL_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_TELETEX_STRING != pRdnAttr->dwValueType) &&
      (CERT_RDN_UNICODE_STRING != pRdnAttr->dwValueType)) {
        Assert((CERT_RDN_NUMERIC_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_PRINTABLE_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_IA5_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_VISIBLE_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_ISO646_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_UNIVERSAL_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_TELETEX_STRING == pRdnAttr->dwValueType) ||
        (CERT_RDN_UNICODE_STRING == pRdnAttr->dwValueType));
        return(NULL);
    }

    // Find out how much space to allocate.

    switch (pRdnAttr->dwValueType) {
        case CERT_RDN_UNICODE_STRING:
            cbData = WideCharToMultiByte(
              CP_ACP,
              0,
              (LPWSTR)pRdnAttr->Value.pbData,
              -1,
              NULL,
              0,
              NULL,
              NULL);
            break;

        case CERT_RDN_UNIVERSAL_STRING:
        case CERT_RDN_TELETEX_STRING:
            cbData = CertRDNValueToStr(pRdnAttr->dwValueType,
              (PCERT_RDN_VALUE_BLOB)&(pRdnAttr->Value),
              NULL,
              0);
            break;

        default:
            cbData = pRdnAttr->Value.cbData + 1;
        break;
    }

    if (! MemAlloc((LPVOID*)&szRet, cbData)) {
        Assert(szRet);
        return(NULL);
    }

    // Copy the string
    switch (pRdnAttr->dwValueType) {
        case CERT_RDN_UNICODE_STRING:
            if (FALSE == WideCharToMultiByte(
              CP_ACP,
              0,
              (LPWSTR)pRdnAttr->Value.pbData,
              -1,
              szRet,
              cbData,
              NULL,
              NULL)) {
                LocalFree(szRet);
                return(NULL);
            }
            break;

        case CERT_RDN_UNIVERSAL_STRING:
        case CERT_RDN_TELETEX_STRING:
            CertRDNValueToStr(pRdnAttr->dwValueType,
              (PCERT_RDN_VALUE_BLOB)&(pRdnAttr->Value),
              szRet,
              cbData);
            break;

        default:
            StrCpyN(szRet, (LPCSTR)pRdnAttr->Value.pbData, cbData);
            if (cbData)
            {
                szRet[cbData - 1] = '\0';
            }
            break;
    }
    return(szRet);
}


/*  SzGetCertificateEmailAddress:
**
**  Returns:
**      NULL if there is no email address
*/
OESTDAPI_(LPSTR) SzGetCertificateEmailAddress(
    const PCCERT_CONTEXT    pCert)
{
    PCERT_NAME_INFO pNameInfo;
    PCERT_ALT_NAME_INFO pAltNameInfo = NULL;
    PCERT_RDN_ATTR  pRDNAttr;
    LPSTR           szRet = NULL;

    Assert(pCert && pCert->pCertInfo);

    if (pCert && pCert->pCertInfo)
        {
        pNameInfo = (PCERT_NAME_INFO)PVDecodeObject(pCert->pCertInfo->Subject.pbData,
            pCert->pCertInfo->Subject.cbData, X509_NAME, 0);
        if (pNameInfo)
            {
            pRDNAttr = CertFindRDNAttr(szOID_RSA_emailAddr, pNameInfo);
            if (pRDNAttr)
                {
                Assert(0 == lstrcmp(szOID_RSA_emailAddr, pRDNAttr->pszObjId));
                szRet = SzConvertRDNString(pRDNAttr);
                }
            MemFree(pNameInfo);
            }

        if (! szRet)
            {
            if (! (szRet = SzGetAltNameEmail(pCert, szOID_SUBJECT_ALT_NAME)))
                {
                szRet = SzGetAltNameEmail(pCert, szOID_SUBJECT_ALT_NAME2);
                }
            }
        }

    return(szRet);
}


/*  PVGetMsgParam:
**
**  Purpose:
**      Combine the "how big? okay, here." double question to grab
**      stuff from a message.
**      Give it a thing to get and it will alloc the mem.
**  Takes:
**      IN hCryptMsg        - message to query
**      IN dwParam          - CMSG_*
**      IN dwIndex          - depends on CMSG
**      OUT OPTIONAL pcbOut - (def value of NULL) size of the return
**  Returns:
**      data that was obtained, NULL if failed
*/

OESTDAPI_(LPVOID) PVGetMsgParam(
    HCRYPTMSG hCryptMsg,
    DWORD dwParam,
    DWORD dwIndex,
    DWORD *pcbData)
{
    HRESULT     hr;
    LPVOID      pv;

    hr = HrGetMsgParam(hCryptMsg, dwParam, dwIndex, &pv, pcbData);
    if (FAILED(hr)) {
        SetLastError(hr);
        pv = NULL;
    }
    return pv;
}

OESTDAPI_(HRESULT) HrGetMsgParam(
    HCRYPTMSG hCryptMsg,
    DWORD dwParam,
    DWORD dwIndex,
    LPVOID * ppv,
    DWORD *pcbData)
{
    DWORD       cbData;
    BOOL        f;
    HRESULT     hr = 0;
    void *      pvData = NULL;

    if (!(hCryptMsg))
        {
        hr = E_INVALIDARG;
        goto ErrorReturn;
        }

    cbData = 0;
    f = CryptMsgGetParam(hCryptMsg, dwParam, dwIndex, NULL, &cbData);

    if (!f || !cbData) {
        hr = HrGetLastError();
        goto ErrorReturn;
    }

    if (!MemAlloc(&pvData, cbData)) {
        hr = E_OUTOFMEMORY;
        goto ErrorReturn;
    }

    if (!CryptMsgGetParam(hCryptMsg, dwParam, dwIndex, pvData, &cbData)) {
        hr = HrGetLastError();
        goto ErrorReturn;
    }

    *ppv = pvData;
    
exit:
    if (pcbData)
        *pcbData = cbData;
    return hr;

ErrorReturn:
    if (pvData)
        {
        MemFree(pvData);
        pvData = NULL;
        }
    cbData = 0;
    goto exit;
}

//
//  This function gets the usage bits of a certificate
//  only the first 32 bits are retrieve, this is enough in most cases
//

HRESULT HrGetCertKeyUsage(PCCERT_CONTEXT pccert, DWORD * pdwUsage)
{
    HRESULT                     hr = S_OK;
    PCRYPT_BIT_BLOB             pbits = NULL;
    PCERT_EXTENSION             pext;
    DWORD                       cbStruct;

    Assert(pccert != NULL && pdwUsage != NULL);
    *pdwUsage = 0;

    pext = CertFindExtension(szOID_KEY_USAGE,
                    pccert->pCertInfo->cExtension,
                    pccert->pCertInfo->rgExtension);
    if(pext == NULL) {
        //
        //  We do not have the intended key usage specified in the cert, we assume it
        //  is OK for all purpose initially.
        //
        *pdwUsage = 0xff;
        goto ExitHere;
    }
    if (CryptDecodeObjectEx(X509_ASN_ENCODING, X509_KEY_USAGE,
                            pext->Value.pbData, pext->Value.cbData,
                            CRYPT_DECODE_ALLOC_FLAG, &CryptDecodeAlloc,
                            (void **)&pbits, &cbStruct))
    {
        Assert(pbits->cbData >= 1);
        *pdwUsage = *pbits->pbData;
    }
    else
        hr = HrGetLastError();

ExitHere:
    if (pbits) {
        CryptFreeFunc(pbits);
    }
    return hr;
}


//  HrVerifyCertEnhKeyUsage
//
//  This function verifies that the given certificate is valid for the
//  E-MAIL purpose.
//

HRESULT HrVerifyCertEnhKeyUsage(PCCERT_CONTEXT pccert, LPCSTR szOID)
{
    DWORD               cb;
    HRESULT             hr;
    HRESULT             hrRet = S_FALSE;
    DWORD               i;
    PCERT_EXTENSION     pextEnhKeyUsage;
    PCERT_ENHKEY_USAGE  pusage = NULL;
    
    // Check for the enhanced key usage extension
    //
    //  Must have a correct enhanced key usage to be viable.
    //
    //  Crack the usage on the cert

    BOOL f = CertGetEnhancedKeyUsage(pccert, 0, NULL, &cb);
    if (!f || (cb == 0)) 
    {
        hrRet = S_OK;
        goto Exit;
    }

    if (!MemAlloc((LPVOID *) &pusage, cb))
    {
        hrRet = HrGetLastError();
        goto Exit;
    }

    if (!CertGetEnhancedKeyUsage(pccert, 0, pusage, &cb)) 
    {
        // Bail and prevent the user from using this cert if we have
        //  any problems

        hrRet = HrGetLastError();
        goto Exit;
    }

    // Make sure that this certificate is valid for E-Mail purposes

    for (i = 0; i < pusage->cUsageIdentifier; i++)
        if (0 == strcmp(pusage->rgpszUsageIdentifier[i], szOID))
            hrRet = S_OK;

    
Exit:
    SafeMemFree(pusage);
    return hrRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\debug.c ===
// --------------------------------------------------------------------------------
// Debug.c
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include <stdarg.h>
#include <shlwapi.h>

ASSERTDATA

#ifdef DEBUG
#ifndef WIN16
#include <mimeole.h>
#else //WIN16 - Followings are from MIMEOLE.H
#define E_PENDING          _HRESULT_TYPEDEF_(0x8000000AL)
#define FACILITY_INTERNET  12
#define MIME_E_NOT_FOUND   MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, 0xCE05)
#endif //WIN16

// --------------------------------------------------------------------------------
// DebugStrf
// --------------------------------------------------------------------------------
__cdecl DebugStrf(LPTSTR lpszFormat, ...)
{
    static TCHAR szDebugBuff[500];
    va_list arglist;

    va_start(arglist, lpszFormat);
    wvnsprintf(szDebugBuff, ARRAYSIZE(szDebugBuff), lpszFormat, arglist);
    va_end(arglist);

    OutputDebugString(szDebugBuff);
}

// --------------------------------------------------------------------------------
// HrTrace
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrTrace(HRESULT hr, LPSTR lpszFile, INT nLine)
{
    if (FAILED(hr) && MIME_E_NOT_FOUND != hr && E_PENDING != hr && E_NOINTERFACE != hr)
        DebugTrace ("%s(%d) - HRESULT - %0X\n", lpszFile, nLine, hr);
    return hr;
}

// --------------------------------------------------------------------------------
// AssertSzFn
// --------------------------------------------------------------------------------
OESTDAPI_(void) AssertSzFn(LPSTR szMsg, LPSTR szFile, int nLine)
{
    static const char rgch1[]     = "File %s, line %d:";
    static const char rgch2[]     = "Unknown file:";
    static const char szAssert[]  = "Assert Failure";

    char    rgch[512];
    char   *lpsz;
    int     ret, cch;

    if (szFile)
        wnsprintf(rgch, ARRAYSIZE(rgch), rgch1, szFile, nLine);
    else
        StrCpyN(rgch, rgch2, ARRAYSIZE(rgch));

    StrCatBuff(rgch, "\n\n", ARRAYSIZE(rgch));
    StrCatBuff(rgch, szMsg, ARRAYSIZE(rgch));

    ret = MessageBox(GetActiveWindow(), rgch, szAssert, MB_ABORTRETRYIGNORE|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND);

    if (ret != IDIGNORE)
        DebugBreak();

    /* Force a hard exit w/ a GP-fault so that Dr. Watson generates a nice stack trace log. */
    if (ret == IDABORT)
        *(LPBYTE)0 = 1; // write to address 0 causes GP-fault
}

// --------------------------------------------------------------------------------
// NFAssertSzFn
// --------------------------------------------------------------------------------
OESTDAPI_(void) NFAssertSzFn(LPSTR szMsg, LPSTR szFile, int nLine)
{
    char rgch[512];
#ifdef MAC
    static const char rgch1[] = "Non-fatal assert:\n\tFile %s, line %u:\n\t%s\n";
#else   // !MAC
    static const char rgch1[] = "Non-fatal assert:\r\n\tFile %s, line %u:\r\n\t%s\r\n";
#endif  // MAC
    wnsprintf(rgch, ARRAYSIZE(rgch), rgch1, szFile, nLine, szMsg ? szMsg : "");
    OutputDebugString(rgch);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\datetime.cpp ===
/*
 *  datetime.c
 *  
 *  Purpose:
 *      mostly stolen from NT winfile
 *
 *      Call GetInternational(), on startup and WM_WININICHANGE
 *  
 *  Owners:
 *      brettm
 */

#include "pch.hxx"
#include <time.h>
#include "dt.h"
#include <BadStrFunctions.h>

ASSERTDATA

CCH CchFmtTime ( PDTR pdtr, LPSTR szBuf, CCH cchBuf, TMTYP tmtyp );
CCH CchFmtDate ( PDTR pdtr, LPSTR szBuf, CCH cchBuf, DTTYP dttyp, LPSTR szDatePicture );
CCH CchFmtDateTime ( PDTR pdtr, LPSTR szDateTime, CCH cch, DTTYP dttyp, TMTYP tmtyp, BOOL fForceWestern);
void GetCurDateTime(PDTR pdtr);
BOOL GetDowDateFormat(char *sz, int cch);

//WIDE VERSIONS
CCH CchFmtTimeW (PDTR pdtr, LPWSTR wszBuf, CCH cchBuf, TMTYP tmtyp, 
                 PFGETTIMEFORMATW pfGetTimeFormatW);

CCH CchFmtDateW (PDTR pdtr, LPWSTR wszBuf, CCH cchBuf, DTTYP dttyp, LPWSTR wszDatePicture,
                 PFGETDATEFORMATW pfGetDateFormatW);

CCH CchFmtDateTimeW (PDTR pdtr, LPWSTR wszDateTime, CCH cch, DTTYP dttyp, TMTYP tmtyp, 
                     BOOL fForceWestern, PFGETDATEFORMATW pfGetDateFormatW, 
                     PFGETTIMEFORMATW pfGetTimeFormatW);

BOOL GetDowDateFormatW(WCHAR *wsz, int cch, PFGETLOCALEINFOW pfGetLocaleInfoW);



#define LCID_WESTERN   MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)


/*
 *	CchFileTimeToDateTimeSz
 *	
 *	Purpose:
 *		Takes the time passed in as a FILETIME stick it into a ized string using
 *		the short date format.
 *		For WIN32, the *pft is converted to the  time before made
 *		into a string
 *	
 *	Parameters:
 *		pft			Points to FILETIME structure
 *		szStr		String where to put the ized version of the date
 *		fNoSeconds	Don't display seconds
 *	
 *	Returns:
 *		The length of the date string
 */
OESTDAPI_(INT) CchFileTimeToDateTimeSz(FILETIME * pft, CHAR * szDateTime, int cch, DWORD dwFlags)
{
    int         iret;
    FILETIME	ft;
    DTTYP       dttyp;
    TMTYP       tmtyp;
    DTR         dtr;
    SYSTEMTIME  st;
    char        szFmt[CCHMAX_DOWDATEFMT];
    
    // Put the file time in our time zone.
    if (!(dwFlags & DTM_NOTIMEZONEOFFSET))
        FileTimeToLocalFileTime(pft, &ft);
    else
        ft = *pft;
    
    FileTimeToSystemTime(&ft, &st);
    
    if (dwFlags & DTM_DOWSHORTDATE)
    {
        Assert((dwFlags & DTM_DOWSHORTDATE) == DTM_DOWSHORTDATE);
        
        //Use LOCALE_USE_CP_ACP to make sure that CP_ACP is used
        if (GetDowDateFormat(szFmt, sizeof(szFmt)))
            iret = GetDateFormat(LOCALE_USER_DEFAULT, LOCALE_USE_CP_ACP, &st, szFmt, szDateTime, cch);
        else
            iret = 0;
        return(iret);
    }
    
    dtr.yr = st.wYear;
    dtr.mon = st.wMonth;
    dtr.day = st.wDay;
    dtr.hr = st.wHour;
    dtr.mn = st.wMinute;
    dtr.sec = st.wSecond;
    
    dttyp = ((dwFlags & DTM_LONGDATE) ? dttypLong : dttypShort);
    tmtyp = ((dwFlags & DTM_NOSECONDS) ? ftmtypAccuHM : ftmtypAccuHMS);
    
    if (dwFlags & DTM_NODATE)
    {
        iret = CchFmtTime(&dtr, szDateTime, cch, tmtyp);
    }
    else if (dwFlags & DTM_NOTIME)
    {
        iret = CchFmtDate(&dtr, szDateTime, cch, dttyp, NULL);
    }
    else
    {
        //For the formatted date, DTM_FORCEWESTERN flag returns English date and time. 
        //Without DTM_FORCEWESTERN the formatted time may not be representable in ASCII.

        iret = CchFmtDateTime(&dtr, szDateTime, cch, dttyp, tmtyp, dwFlags & DTM_FORCEWESTERN);
    }
    
    return(iret);
}

CCH CchFmtTime ( PDTR pdtr, LPSTR szBuf, CCH cchBuf, TMTYP tmtyp )
{
    DWORD       flags;
    int         cch;
    SYSTEMTIME  st;
    
    if ( cchBuf == 0 )
    {
        AssertSz ( fFalse, "0-length buffer passed to CchFmtTime" );
        return 0;
    }
    
    Assert(szBuf);
    
    if (pdtr == NULL)
    {
        GetLocalTime(&st);
    }
    else
    {
        //	Bullet raid #3143
        //	Validate data.  Set to minimums if invalid.
        Assert(pdtr->hr >= 0 && pdtr->hr < 24);
        Assert(pdtr->mn >= 0 && pdtr->mn < 60);
        Assert(pdtr->sec >= 0 && pdtr->sec < 60);
        
        // GetTimeFormat doesn't like invalid values
        ZeroMemory(&st, sizeof(SYSTEMTIME));
        st.wMonth = 1;
        st.wDay = 1;
        
        st.wHour = pdtr->hr;
        st.wMinute = pdtr->mn;
        st.wSecond = pdtr->sec;
    }
    
    Assert((tmtyp & ftmtypHours24) == 0);
    
    if ( tmtyp & ftmtypAccuHMS )
        flags = 0;
    else if ( tmtyp & ftmtypAccuH )
        flags = TIME_NOMINUTESORSECONDS;
    else
        flags = TIME_NOSECONDS;	// default value

    //Use LOCALE_USE_CP_ACP to make sure that CP_ACP is used
    flags |= LOCALE_USE_CP_ACP;

    cch = GetTimeFormat(LOCALE_USER_DEFAULT, flags, &st, NULL, szBuf, cchBuf);
    
    return((cch == 0) ? 0 : (cch - 1));
}


/*
 -	CchFmtDate
 -
 *	Purpose:
 *		formats the date passed in the DTR into the LPSTR passed
 *		according to the formatting "instructions" passed in DTTYP
 *		and  szDatePicture. If values are not explicitly passed,
 *		values are read in from WIN.INI
 *
 *	Arguments:
 *		pdtr:	pointer to DTR where time is passed - if NULL,
 *				current date is used.
 *		szBuf:	buffer where formatted info is to be passed
 *		cchBuf:	size of buffer
 *		dttyp:	type of date format
 *		szDatePicture: picture of the date - if NULL, values are
 *				read in from WIN.INI
 *
 *    Note: see reply from win-bug at end of function describing
 *			separator strings in date pictures
 *
 *	Returns:
 *		count of chars inserted in szBuf
 * 
 *	Side effects:
 *
 *
 *	Errors:
 *		returns count of 0 in case of error
 *
 */
CCH CchFmtDate ( PDTR pdtr, LPSTR szBuf, CCH cchBuf, DTTYP dttyp, LPSTR szDatePicture )
{
    SYSTEMTIME st={0};
    int cch;
    DTR dtr;
    DWORD flags;
    
    Assert(szBuf);
    if (!cchBuf)
    {
        AssertSz ( fFalse, "0-length buffer passed to CchFmtDate" );
        return 0;
    }
    
    if (!pdtr)
    {
        pdtr = &dtr;
        GetCurDateTime ( pdtr );
    }
    else
    {
        //	Bullet raid #3143
        //	Validate data.  Set to minimums if invalid.
        if (pdtr->yr < nMinDtrYear ||  pdtr->yr >= nMacDtrYear)
            pdtr->yr = nMinDtrYear;
        if (pdtr->mon <=  0  ||  pdtr->mon > 12)
            pdtr->mon = 1;
        if (pdtr->day <= 0  ||  pdtr->day > 31)
            pdtr->day = 1;
        if (pdtr->dow < 0  ||  pdtr->dow >= 7)
            pdtr->dow = 0;
    }
    
    Assert ( pdtr );
    Assert ( pdtr->yr  >= nMinDtrYear &&  pdtr->yr < nMacDtrYear );
    Assert ( pdtr->mon >  0  &&  pdtr->mon <= 12 );
    Assert ( pdtr->day >  0  &&  pdtr->day <= 31 );
    Assert((dttyp == dttypShort) || (dttyp == dttypLong));
    
    // TODO: handle dttypSplSDayShort properly...
    
    flags = 0;
    if (dttyp == dttypLong)
        flags = flags | DATE_LONGDATE;
    
    st.wYear = pdtr->yr;
    st.wMonth = pdtr->mon;
    st.wDay = pdtr->day;
    st.wDayOfWeek = 0;

    //Use LOCALE_USE_CP_ACP to make sure that CP_ACP is used
    flags |= LOCALE_USE_CP_ACP;

    cch = GetDateFormat(LOCALE_USER_DEFAULT, flags, &st, NULL, szBuf, cchBuf);
    
    return((cch == 0) ? 0 : (cch - 1));
}

CCH CchFmtDateTime ( PDTR pdtr, LPSTR szDateTime, CCH cch, DTTYP dttyp, TMTYP tmtyp, BOOL fForceWestern)
{
    int         cchT;
    LPSTR          szTime;
    DWORD       flags;
    SYSTEMTIME  st={0};
    int         icch = cch;
    
    st.wYear = pdtr->yr;
    st.wMonth = pdtr->mon;
    st.wDay = pdtr->day;
    st.wHour = pdtr->hr;
    st.wMinute = pdtr->mn;
    st.wSecond = pdtr->sec;
    
    Assert (LCID_WESTERN == 0x409);
    Assert((dttyp == dttypShort) || (dttyp == dttypLong));
    if (dttyp == dttypLong)
        flags = DATE_LONGDATE;
    else
        flags = DATE_SHORTDATE;

    //Use LOCALE_USE_CP_ACP to make sure that CP_ACP is used
    flags |= LOCALE_USE_CP_ACP;

    *szDateTime = 0;
    cchT = GetDateFormat(fForceWestern? LCID_WESTERN:LOCALE_USER_DEFAULT, flags, &st, NULL, szDateTime, cch);
    if (cchT == 0)
        return(0);

    //Don't do the rest of the stuff if we don't have atleast two chars. because we need to add space between date and time.
    //After that theres no point in calling GetTimeFormatW if there isn't atleast one char left.
    if (cchT <= (icch - 2))
    {    
        flags = 0;
        if (tmtyp & ftmtypHours24)
            flags |= TIME_FORCE24HOURFORMAT;
        if (tmtyp & ftmtypAccuH)
            flags |= TIME_NOMINUTESORSECONDS;
        else if (!(tmtyp & ftmtypAccuHMS))
            flags |= TIME_NOSECONDS;
    
        // Tack on a space and then the time.
        // GetDateFormat returns count of chars INCLUDING the NULL terminator, hence the - 1
        szTime = szDateTime + (cchT - 1);
        *szTime++ = ' ';
        *szTime = 0;

        //Use LOCALE_USE_CP_ACP to make sure that CP_ACP is used
        flags|= LOCALE_USE_CP_ACP;

        cchT = GetTimeFormat(fForceWestern? LCID_WESTERN:LOCALE_USER_DEFAULT, flags, &st, NULL, szTime, (cch - cchT));
    }
    else
        cchT = 0;

    return(cchT == 0 ? 0 : lstrlen(szDateTime));
}

/*
 -	GetCurDateTime
 -
 *	Purpose:
 *		Gets the current system date/time from the OS, and stores it
 *		as an expanded date/time in *pdtr.
 *
 *	Parameters:
 *		pdtr	Pointer to the DTR used to store the date/time.
 *
 *	Returns:
 *		void
 *
 */
void GetCurDateTime(PDTR pdtr)
{
	SYSTEMTIME	SystemTime;

	GetLocalTime(&SystemTime);

	pdtr->hr= SystemTime.wHour;
	pdtr->mn= SystemTime.wMinute;
	pdtr->sec= SystemTime.wSecond;

	pdtr->day = SystemTime.wDay;
	pdtr->mon = SystemTime.wMonth;
	pdtr->yr  = SystemTime.wYear;
	pdtr->dow = SystemTime.wDayOfWeek;
}

BOOL GetDowDateFormat(char *sz, int cch)
{
    char szDow[] = "ddd ";
    
    Assert(cch > sizeof(szDow));
    StrCpyN(sz, szDow, cch);

    //Use LOCALE_USE_CP_ACP to make sure that CP_ACP is used
    return(0 != GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE | LOCALE_USE_CP_ACP,
        &sz[4], cch - 4));
}

//
//  CompareSystime
//
//  returns  0 if *pst1 == *pst2 (ignores milliseconds)
//  returns <0 if *pst1 <  *pst2
//  return  >0 if *pst1 >  *pst2
//
int CompareSystime(SYSTEMTIME *pst1, SYSTEMTIME *pst2)
{
    int iRet;

    if ((iRet = pst1->wYear - pst2->wYear) == 0)
    {
        if ((iRet = pst1->wMonth - pst2->wMonth) == 0)
        {
            if ((iRet = pst1->wDay - pst2->wDay) == 0)
            {
                if ((iRet = pst1->wHour - pst2->wHour) == 0)
                {
                    if ((iRet = pst1->wMinute - pst2->wMinute) == 0)
                        iRet = pst1->wSecond - pst2->wSecond;
                }
            }
        }
    }
    return(iRet);
}

OESTDAPI_(INT) CchFileTimeToDateTimeW(FILETIME * pft, WCHAR * wszDateTime, 
                                      int        cch, DWORD      dwFlags, 
                                      PFGETDATEFORMATW pfGetDateFormatW, 
                                      PFGETTIMEFORMATW pfGetTimeFormatW,
                                      PFGETLOCALEINFOW pfGetLocaleInfoW)
{
    int         iret;
    FILETIME	ft;
    DTTYP       dttyp;
    TMTYP       tmtyp;
    DTR         dtr;
    SYSTEMTIME  st;
    WCHAR       wszFmt[CCHMAX_DOWDATEFMT];
    
    // Put the file time in our time zone.
    if (!(dwFlags & DTM_NOTIMEZONEOFFSET))
        FileTimeToLocalFileTime(pft, &ft);
    else
        ft = *pft;
    
    FileTimeToSystemTime(&ft, &st);
    
    if (dwFlags & DTM_DOWSHORTDATE)
    {
        Assert((dwFlags & DTM_DOWSHORTDATE) == DTM_DOWSHORTDATE);
        
        if (GetDowDateFormatW(wszFmt, ARRAYSIZE(wszFmt), pfGetLocaleInfoW))
            iret = pfGetDateFormatW(LOCALE_USER_DEFAULT, 0, &st, wszFmt, wszDateTime, cch);
        else
            iret = 0;
        return(iret);
    }
    
    dtr.yr = st.wYear;
    dtr.mon = st.wMonth;
    dtr.day = st.wDay;
    dtr.hr = st.wHour;
    dtr.mn = st.wMinute;
    dtr.sec = st.wSecond;
    dtr.dow = st.wDayOfWeek;
    
    dttyp = ((dwFlags & DTM_LONGDATE) ? dttypLong : dttypShort);
    tmtyp = ((dwFlags & DTM_NOSECONDS) ? ftmtypAccuHM : ftmtypAccuHMS);
    
    if (dwFlags & DTM_NODATE)
    {
        iret = CchFmtTimeW(&dtr, wszDateTime, cch, tmtyp, pfGetTimeFormatW);
    }
    else if (dwFlags & DTM_NOTIME)
    {
        iret = CchFmtDateW(&dtr, wszDateTime, cch, dttyp, NULL, pfGetDateFormatW);
    }
    else
    {        
        //For the formatted date, DTM_FORCEWESTERN flag returns English date and time. 
        //Without DTM_FORCEWESTERN the formatted time may not be representable in ASCII.

        iret = CchFmtDateTimeW(&dtr, wszDateTime, cch, dttyp, tmtyp, 
                                dwFlags & DTM_FORCEWESTERN, pfGetDateFormatW, 
                                pfGetTimeFormatW);
    }
    
    return(iret);
}

CCH CchFmtTimeW( PDTR pdtr, LPWSTR wszBuf, CCH cchBuf, TMTYP tmtyp, 
                 PFGETTIMEFORMATW pfGetTimeFormatW)
{
    DWORD       flags;
    int         cch;
    SYSTEMTIME  st;
    
    if ( cchBuf == 0 )
    {
        AssertSz ( fFalse, "0-length buffer passed to CchFmtTime" );
        return 0;
    }
    
    Assert(wszBuf);
    
    if (pdtr == NULL)
    {
        GetLocalTime(&st);
    }
    else
    {
        //	Bullet raid #3143
        //	Validate data.  Set to minimums if invalid.
        Assert(pdtr->hr >= 0 && pdtr->hr < 24);
        Assert(pdtr->mn >= 0 && pdtr->mn < 60);
        Assert(pdtr->sec >= 0 && pdtr->sec < 60);
        
        // GetTimeFormat doesn't like invalid values
        ZeroMemory(&st, sizeof(SYSTEMTIME));
        st.wMonth = 1;
        st.wDay = 1;
        
        st.wHour = pdtr->hr;
        st.wMinute = pdtr->mn;
        st.wSecond = pdtr->sec;
    }
    
    Assert((tmtyp & ftmtypHours24) == 0);
    
    if ( tmtyp & ftmtypAccuHMS )
        flags = 0;
    else if ( tmtyp & ftmtypAccuH )
        flags = TIME_NOMINUTESORSECONDS;
    else
        flags = TIME_NOSECONDS;	// default value
    
    cch = pfGetTimeFormatW(LOCALE_USER_DEFAULT, flags, &st, NULL, wszBuf, cchBuf);
    
    return((cch == 0) ? 0 : (cch - 1));
}

CCH CchFmtDateW( PDTR pdtr, LPWSTR wszBuf, CCH cchBuf, DTTYP dttyp, LPWSTR wszDatePicture,
                 PFGETDATEFORMATW pfGetDateFormatW)
{
    SYSTEMTIME st={0};
    int cch;
    DTR dtr;
    DWORD flags;
    
    Assert(wszBuf);
    if (!cchBuf)
    {
        AssertSz ( fFalse, "0-length buffer passed to CchFmtDate" );
        return 0;
    }
    
    if (!pdtr)
    {
        pdtr = &dtr;
        GetCurDateTime ( pdtr );
    }
    else
    {
        //	Bullet raid #3143
        //	Validate data.  Set to minimums if invalid.
        if (pdtr->yr < nMinDtrYear ||  pdtr->yr >= nMacDtrYear)
            pdtr->yr = nMinDtrYear;
        if (pdtr->mon <=  0  ||  pdtr->mon > 12)
            pdtr->mon = 1;
        if (pdtr->day <= 0  ||  pdtr->day > 31)
            pdtr->day = 1;
        if (pdtr->dow < 0  ||  pdtr->dow >= 7)
            pdtr->dow = 0;
    }
    
    Assert ( pdtr );
    Assert ( pdtr->yr  >= nMinDtrYear &&  pdtr->yr < nMacDtrYear );
    Assert ( pdtr->mon >  0  &&  pdtr->mon <= 12 );
    Assert ( pdtr->day >  0  &&  pdtr->day <= 31 );
    Assert((dttyp == dttypShort) || (dttyp == dttypLong));
    
    // TODO: handle dttypSplSDayShort properly...
    
    flags = 0;
    if (dttyp == dttypLong)
        flags = flags | DATE_LONGDATE;
    
    st.wYear = pdtr->yr;
    st.wMonth = pdtr->mon;
    st.wDay = pdtr->day;
    st.wDayOfWeek = 0;
    cch = pfGetDateFormatW(LOCALE_USER_DEFAULT, flags, &st, NULL, wszBuf, cchBuf);
    
    return((cch == 0) ? 0 : (cch - 1));
}

CCH CchFmtDateTimeW( PDTR pdtr, LPWSTR wszDateTime, CCH cch, DTTYP dttyp, TMTYP tmtyp, 
                     BOOL fForceWestern, PFGETDATEFORMATW pfGetDateFormatW, 
                     PFGETTIMEFORMATW pfGetTimeFormatW)
{
    int         cchT;
    LPWSTR      wszTime;
    DWORD       flags;
    SYSTEMTIME  st={0};
    int         icch = cch;
    
    st.wYear = pdtr->yr;
    st.wMonth = pdtr->mon;
    st.wDay = pdtr->day;
    st.wHour = pdtr->hr;
    st.wMinute = pdtr->mn;
    st.wSecond = pdtr->sec;
    
    Assert (LCID_WESTERN == 0x409);
    Assert((dttyp == dttypShort) || (dttyp == dttypLong));
    if (dttyp == dttypLong)
        flags = DATE_LONGDATE;
    else
        flags = DATE_SHORTDATE;
    
    *wszDateTime = 0;
    cchT = pfGetDateFormatW(fForceWestern? LCID_WESTERN:LOCALE_USER_DEFAULT, flags, &st, NULL, wszDateTime, cch);
    if (cchT == 0)
        return(0);

    //Don't do the rest of the stuff if we don't have atleast two chars. because we need to add space between date and time.
    //After that theres no point in calling GetTimeFormatW if there isn't atleast one char left.
    if (cchT <= (icch - 2))
    {    
        flags = 0;
        if (tmtyp & ftmtypHours24)
            flags |= TIME_FORCE24HOURFORMAT;
        if (tmtyp & ftmtypAccuH)
            flags |= TIME_NOMINUTESORSECONDS;
        else if (!(tmtyp & ftmtypAccuHMS))
            flags |= TIME_NOSECONDS;

        // Tack on a space and then the time.
        // GetDateFormat returns count of chars INCLUDING the NULL terminator, hence the - 1
        wszTime = wszDateTime + (lstrlenW(wszDateTime));
        *wszTime++ = L' ';
        *wszTime = 0;
        cchT = pfGetTimeFormatW(fForceWestern? LCID_WESTERN:LOCALE_USER_DEFAULT, flags, &st, NULL, wszTime, (cch - cchT));
    }
    else
        cchT = 0;

    return(cchT == 0 ? 0 : lstrlenW(wszDateTime));
}

BOOL GetDowDateFormatW(WCHAR *wsz, int cch, PFGETLOCALEINFOW pfGetLocaleInfoW)
{
    WCHAR wszDow[] = L"ddd ";
    
    Assert(cch > sizeof(wszDow));
    StrCpyNW(wsz, wszDow, cch);
    return(0 != (pfGetLocaleInfoW)(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE,
        &wsz[4], cch - 4));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\dataobj.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     dataobj.h
//
//  PURPOSE:    Defines a simple IDataObject that can be used for basic drag
//              and drop scenarios.
//

#ifndef __DATAOBJ__H
#define __DATAOBJ__H

// Class CDataObject
// -----------------
// 
// Overview
//     This data object provides a simple IDataObject implementation that
//     can be used for basic drag and drop.  When the caller allocates one
//     of these objects, they are responsible for calling HrInitData() to 
//     tell the object what data it provides and in which formats.  Once 
//     this is provided, the object can be passed to ::DoDragDrop() or put 
//     on the clipboard.  
//
// Notes
//     This object assumes that _ALL_ of the data it provides is given to 
//     it in a memory pointer.  The object can however convert that memory
//     pointer to either an HGLOBAL or IStream if the caller requests.
//
//

typedef HRESULT (CALLBACK *PFNFREEDATAOBJ)(PDATAOBJINFO pDataObjInfo, DWORD celt);

class CDataObject : public IDataObject
{
public:
    // Constructors and Destructor
    CDataObject();
    ~CDataObject();

    // IUnknown Interface members
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDataObject Interface members
    STDMETHODIMP GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    STDMETHODIMP GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut);
    STDMETHODIMP SetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium,   
                         BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC** ppEnum);
    STDMETHODIMP DAdvise(LPFORMATETC pFE, DWORD advf, 
                         IAdviseSink* ppAdviseSink, LPDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA** ppEnumAdvise);

    // Utility Routines
    HRESULT Init(PDATAOBJINFO pDataObjInfo, DWORD celt, PFNFREEDATAOBJ pfnFree);

private:
    ULONG           m_cRef;     // Object reference count
    PDATAOBJINFO    m_pInfo;    // Information we provide
    PFNFREEDATAOBJ  m_pfnFree;  // free funciton for the data object
    DWORD           m_celtInfo; // Number of elements in m_pInfo
};

OESTDAPI_(HRESULT) CreateDataObject(PDATAOBJINFO pDataObjInfo, DWORD celt, PFNFREEDATAOBJ pfnFree, IDataObject **ppDataObj);

#endif  //__DATAOBJ__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\defguid.cpp ===
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
#include "pch.hxx"
#include <initguid.h>
#define INITGUID
#include "mimeole.h"
#include "hotwiz.h"
#include <BadStrFunctions.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\dt.h ===
#ifndef _INC_DATETIME_H
#define _INC_DATETIME_H

#define nMinDtrYear		1900
#define nMacDtrYear		(2999 + 1)

typedef unsigned int CCH;

#define CCHMAX_DOWDATEFMT   84

typedef struct _dtr
{
	short	yr;
	short	mon;
	short	day;
	short	hr;
	short	mn;
	short	sec;
	short	dow;		/* day of week: 0=Sun, 1=Mon, etc. */
} DTR;
typedef DTR *	PDTR;

typedef		WORD	DTTYP;
#define 	dttypNull			((DTTYP)0)
#define 	dttypShort			((DTTYP)0)
#define 	dttypLong			((DTTYP)1)

typedef		WORD	TMTYP;
#define 	tmtypNull				((TMTYP)0)
#define 	ftmtypHours12			((TMTYP)0x0001)
#define 	ftmtypHours24			((TMTYP)0x0002)
#define 	ftmtypHoursDef			((TMTYP)0x0000)
#define 	ftmtypSzTrailYes		((TMTYP)0x0004)
#define 	ftmtypSzTrailNo			((TMTYP)0x0008)
#define 	ftmtypSzTrailDef		((TMTYP)0x0000)
#define 	ftmtypLead0sNo			((TMTYP)0x0010)
#define 	ftmtypLead0sYes			((TMTYP)0x0020)
#define 	ftmtypLead0sDef			((TMTYP)0x0000)
#define 	ftmtypAccuHM			((TMTYP)0x0000)
#define 	ftmtypAccuHMS			((TMTYP)0x0040)
#define 	ftmtypAccuH				((TMTYP)0x0080)

typedef struct
{
	WORD	yr;
	BYTE	mon;
	BYTE	day;
} YMD;

typedef struct
{
	WORD	hr;
	BYTE	min;
	BYTE	sec;
} TIME;

#define		IszOfDay(day)		(day)
#define		IszOfSDay(day)		(day+7)
#define		IszOfMonth(mon)	    (mon+13)
#define		IszOfSMonth(mon)	(mon+25)

int  CompareSystime(SYSTEMTIME *pst1, SYSTEMTIME *pst2);

#endif //_INC_DATETIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\dllmain.h ===
// --------------------------------------------------------------------------------
// Dllmain.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __DLLMAIN_H
#define __DLLMAIN_H

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern HINSTANCE                g_hInst;
extern LPMALLOC                 g_pMalloc;
extern DWORD                    g_dwTlsMsgBuffIndex;
extern CRITICAL_SECTION         g_csTempFileList;
extern LPTEMPFILEINFO           g_pTempFileHead;
extern OSVERSIONINFO            g_rOSVersionInfo;

#endif // __DLLMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\dataobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     dataobj.cpp
//
//  PURPOSE:    Implements a generic IDataObject that can be used for simple
//              drag and drop scenarios.
//
//  HISTORY:
//

#include "pch.hxx"
#include "dllmain.h"
#include "msoert.h"
#include <BadStrFunctions.h>


CDataObject::CDataObject ()
{
    m_cRef = 1;
    m_pInfo = 0;
    m_celtInfo = 0;
    m_pfnFree = 0;
}

CDataObject::~CDataObject ()
{
    if (m_pfnFree)
        m_pfnFree(m_pInfo, m_celtInfo);
}


//
//  FUNCTION:   Init
//
//  PURPOSE:    Allows the caller to provide the object with data and formats.
//
//  PARAMETERS:
//      [in] pDataObjInfo - An array of DATAOBJINFO structs which contain the
//                          data and formats that the data object will provide.
//      [in] celt         - The number of elements in pDataObjInfo.
//      [in] pfnFree      - callback to free allocated data
//
//  RETURNS:
//      S_OK         - The object is initialized OK.
//      E_INVALIDARG - Either pDataObjInfo is NULL or celt is zero.
//
//  COMMENTS:
//      Note, after the caller gives the object pDataObjInfo, this object owns
//      that data and will be responsible for freeing it.
//
HRESULT CDataObject::Init(PDATAOBJINFO pDataObjInfo, DWORD celt, PFNFREEDATAOBJ pfnFree)
{
    if (!pDataObjInfo || celt == 0)
        return (E_INVALIDARG);
    
    // Hold on to the data
    m_pInfo = pDataObjInfo;
    m_celtInfo = celt;    
    m_pfnFree = pfnFree;
    return (S_OK);
}


STDMETHODIMP CDataObject::QueryInterface (REFIID riid, LPVOID* ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPVOID)(IUnknown*) this;
    }
    else if (IsEqualIID(riid, IID_IDataObject))
    {
        *ppv = (LPVOID)(IDataObject*) this;
    }

    if (NULL == *ppv)
        return (E_NOINTERFACE);

    ((LPUNKNOWN) *ppv)->AddRef();
    return (S_OK);
}

STDMETHODIMP_(ULONG) CDataObject::AddRef (void)
{
    return (++m_cRef);
}

STDMETHODIMP_(ULONG) CDataObject::Release (void)
{
    ULONG cRef = --m_cRef;

    if (0 == m_cRef)
        delete this;

    return (cRef);
}


STDMETHODIMP CDataObject::GetData (LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    HRESULT hr = E_INVALIDARG;

    Assert(pStgMedium && pFE);
    if (pStgMedium && pFE)
    {
        HGLOBAL hGlobal = NULL;
        LPVOID  pv = NULL;

        hr = DV_E_FORMATETC;

        ZeroMemory(pStgMedium, sizeof(STGMEDIUM));
    
        // Loop through the pInfo array to see if any of the elements has the
        // same clipboard format as pFE
        for (DWORD i = 0; i < m_celtInfo; i++)
        {
            if (pFE->cfFormat == m_pInfo[i].fe.cfFormat)
            {
                // Make a copy of the data for this pInfo
                hGlobal = GlobalAlloc(GMEM_SHARE | GHND, m_pInfo[i].cbData);
                if (!hGlobal)
                    return (E_OUTOFMEMORY);
                
                pv = GlobalLock(hGlobal);
                if (!pv)
                {
                    hr = E_POINTER;
                    break;
                }
                else
                {
                    CopyMemory(pv, m_pInfo[i].pData, m_pInfo[i].cbData);
                    GlobalUnlock(hGlobal);            
            
                    // Fill in the pStgMedium struct
                    if (pFE->tymed & TYMED_HGLOBAL)
                    {
                        pStgMedium->hGlobal = hGlobal;
                        pStgMedium->tymed = TYMED_HGLOBAL;
                        return (S_OK);
                    }
                    else if (pFE->tymed & TYMED_ISTREAM)
                    {
                        // If the user wants a stream, convert our HGLOBAL to a stream
                        if (SUCCEEDED(CreateStreamOnHGlobal(hGlobal, TRUE, &pStgMedium->pstm)))
                        {
                            pStgMedium->tymed = TYMED_ISTREAM;
                            return (S_OK);
                        }
                        else
                        { 
                            return (STG_E_MEDIUMFULL);
                        }
                    }
                    else
                    {
                        GlobalFree(hGlobal);
                        return (DV_E_TYMED);
                    }
                }
            }
        }
    }
        
    return hr;
}

STDMETHODIMP CDataObject::GetDataHere (LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC pFE)
{
    BOOL fReturn = FALSE;

    // Check the aspects we support.  Implementations of this object will only
    // support DVASPECT_CONTENT.
    if (pFE && !(DVASPECT_CONTENT & pFE->dwAspect))
        return (DV_E_DVASPECT);

    if (pFE)
    {
        // Now check for an appropriate TYMED.
        fReturn = (pFE->tymed & TYMED_HGLOBAL) || (pFE->tymed & TYMED_ISTREAM);
    }

    return (fReturn ? S_OK : DV_E_TYMED);
}

STDMETHODIMP CDataObject::GetCanonicalFormatEtc(LPFORMATETC pFEIn,
                                                LPFORMATETC pFEOut)
{
    if (NULL == pFEOut)
        return (E_INVALIDARG);

    pFEOut->ptd = NULL;
    return (DATA_S_SAMEFORMATETC);
}

STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC** ppEnum)
{
    if (DATADIR_GET == dwDirection)
    {
        if (SUCCEEDED(CreateEnumFormatEtc(this, m_celtInfo, m_pInfo, NULL, ppEnum)))
            return (S_OK);
        else
            return (E_FAIL);
    }
    else
    {
        *ppEnum = NULL;
        return (E_NOTIMPL);
    }
}

STDMETHODIMP CDataObject::SetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium, BOOL fRelease)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDataObject::DAdvise(LPFORMATETC pFE, DWORD advf, IAdviseSink* ppAdviseSink, LPDWORD pdwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDataObject::DUnadvise(DWORD dwConnection)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDataObject::EnumDAdvise(IEnumSTATDATA** ppEnumAdvise)
{
    return E_NOTIMPL;
}


OESTDAPI_(HRESULT) CreateDataObject(PDATAOBJINFO pDataObjInfo, DWORD celt, PFNFREEDATAOBJ pfnFree, IDataObject **ppDataObj)
{
    CDataObject *pDataObj;
    HRESULT     hr;

    pDataObj = new CDataObject();
    if (!pDataObj)
        return E_OUTOFMEMORY;

    hr = pDataObj->Init(pDataObjInfo, celt, pfnFree);
    if (FAILED(hr))
        goto error;

    hr = pDataObj->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObj);

error:
    pDataObj->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\dllmain.cpp ===
// --------------------------------------------------------------------------------
// Dllmain.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include <shfusion.h>
#ifndef MAC
#define DEFINE_STRCONST
#include "dllmain.h"
#include "demand.h"
#include "strconst.h"
#include "oertpriv.h"
#include <BadStrFunctions.h>

// --------------------------------------------------------------------------------
// Globals - Object count and lock count
// --------------------------------------------------------------------------------
HINSTANCE               g_hInst=NULL;
IMalloc                *g_pMalloc=NULL;
CRITICAL_SECTION        g_csTempFileList={0};
LPTEMPFILEINFO          g_pTempFileHead=NULL;
DWORD                   g_dwTlsMsgBuffIndex=0xffffffff;
OSVERSIONINFO           g_rOSVersionInfo ={0};

// --------------------------------------------------------------------------------
// Debug Globals
// --------------------------------------------------------------------------------
#ifdef DEBUG
DWORD dwDOUTLevel=0;
DWORD dwDOUTLMod=0;
DWORD dwDOUTLModLevel=0;
#endif

#ifndef WIN16

// --------------------------------------------------------------------------------
// GetDllMajorVersion
// --------------------------------------------------------------------------------
OEDLLVERSION WINAPI GetDllMajorVersion(void)
{
    return OEDLL_VERSION_CURRENT;
}

// --------------------------------------------------------------------------------
// Dll Entry Point
// --------------------------------------------------------------------------------
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Handle Attach - detach reason
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        SHFusionInitialize(NULL);
        // Save the Instance Handle
	    g_hInst = hInst;

        // Create the task allocator
        CoGetMalloc(1, &g_pMalloc);

        // Critical Section for the tempfile list
        InitializeCriticalSection(&g_csTempFileList);

        // Initialize Demand Loaded libs
        InitDemandLoadedLibs();

        // Allocate a TLS index
        g_dwTlsMsgBuffIndex = TlsAlloc();
        Assert(g_dwTlsMsgBuffIndex != 0xffffffff);

        // Allocate a buffer and store it into the tls index
        ThreadAllocateTlsMsgBuffer();

        g_rOSVersionInfo.dwOSVersionInfoSize = sizeof(g_rOSVersionInfo);

        GetVersionEx(&g_rOSVersionInfo);

        // Initialize Debug Stuff
#ifdef DEBUG
        dwDOUTLevel=GetPrivateProfileInt("Debug", "ICLevel", 0, "athena.ini");
        dwDOUTLMod=GetPrivateProfileInt("Debug", "Mod", 0, "athena.ini");
        dwDOUTLModLevel=GetPrivateProfileInt("Debug", "ModLevel", 0, "athena.ini");
#endif
    }

    // Thread Attach
    else if (DLL_THREAD_ATTACH == dwReason)
    {
        // Allocate a buffer and store it into the tls index
        ThreadAllocateTlsMsgBuffer();
    }

    // Thread Dettach
    else if (DLL_THREAD_DETACH == dwReason)
    {
        // Allocate a buffer and store it into the tls index
        ThreadFreeTlsMsgBuffer();
    }

    // Process Detach
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        // Allocate a buffer and store it into the tls index
        ThreadFreeTlsMsgBuffer();

        // Free the tls index
        TlsFree(g_dwTlsMsgBuffIndex);
        g_dwTlsMsgBuffIndex = 0xffffffff;

        // Cleanup Global Temp Files
        CleanupGlobalTempFiles();

        // Kill the temp file list critical Section
        DeleteCriticalSection(&g_csTempFileList);

        // Free demand loaded libs
        FreeDemandLoadedLibs();

        // Release task allocator
        SafeRelease(g_pMalloc);
        SHFusionUninitialize();
    }

    // Done
    return TRUE;
}

#else //WIN16

BOOL FAR PASCAL  LibMain( HINSTANCE hDll, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine )
{
    g_hInst = hDll;
    OleInitialize( NULL );
    CoGetMalloc( 1, &g_pMalloc );
    InitDemandLoadedLibs();
#ifdef DEBUG
    dwDOUTLevel=GetPrivateProfileInt("Debug", "ICLevel", 0, "athena.ini");
    dwDOUTLMod=GetPrivateProfileInt("Debug", "Mod", 0, "athena.ini");
    dwDOUTLModLevel=GetPrivateProfileInt("Debug", "ModLevel", 0, "athena.ini");
#endif
    return( TRUE );
}

int CALLBACK  WEP( int nExitType )
{
    BOOL  fDSExist = FALSE;

    // Following ASM code is to check if DS has been loaded properly
    // This is because WEP can be called even before DS is initialized in
    // some low memory situation.
    _asm {
        push bx
        push cx
        mov  cx, ds
        lar  bx, cx
        jnz  wrong
        test bx, 8000h
        jz   wrong
        mov  fDSExist, ax
wrong:  pop  cx
        pop  bx
    }

    if ( fDSExist )
    {
        SafeRelease( g_pMalloc );
    }
    return( TRUE );
}

#endif //WIN16

#endif  // !MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\enumfmt.h ===
// --------------------------------------------------------------------------
// Enumfmt.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------
#ifndef __ENUMFMT_H
#define __ENUMFMT_H

// Class CEnumFormatEtc
// --------------------
// 
// Overview
//     This object provides a enumerator for FORMATETC structures.  The 
//     IDataObject uses this when callers invoke IDataObject::EnumFormatEtc.
//     
//     The data object creates one of this objects and provides an array
//     of FORMATETC structures in the constructor.  The interface is then
//     passed to the invoker of IDataObject::EnumFormatEtc().
//
class CEnumFormatEtc : public IEnumFORMATETC
    {
public: 
    CEnumFormatEtc(LPUNKNOWN, PDATAOBJINFO, ULONG);
    CEnumFormatEtc(LPUNKNOWN, ULONG, LPFORMATETC);
    ~CEnumFormatEtc(void);

    // IUnknown members that delegate to m_pUnkOuter
    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumFORMATETC members
    STDMETHODIMP Next(ULONG, LPFORMATETC, ULONG FAR *);
    STDMETHODIMP Skip(ULONG);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumFORMATETC FAR * FAR *);

private: 
    ULONG       m_cRef;                 // Object reference count
    LPUNKNOWN   m_pUnkRef;              // IUnknown for ref counting
    ULONG       m_iCur;                 // Current element
    ULONG       m_cfe;                  // Number of FORMATETC's in us
    LPFORMATETC m_prgfe;                // Source of FORMATETC's
};

#endif // __ENUMFMT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\hfilestm.h ===
// =================================================================================
// HFILE Stream Definition
// =================================================================================
#ifndef __HFILESTM_H
#define __HFILESTM_H

// =================================================================================
// CHFileStm
// =================================================================================
class CHFileStm : public IStream
{
private:
    ULONG                   m_cRef;
    HANDLE                  m_hFile;
    DWORD                   m_dwDesiredAccess;

public:
    CHFileStm (HANDLE hFile, DWORD dwDesiredAccess);
    ~CHFileStm ();
    HRESULT HrVerifyState (DWORD dwAccess);
    STDMETHODIMP_(ULONG) AddRef (VOID);
    STDMETHODIMP_(ULONG) Release (VOID);
    STDMETHODIMP QueryInterface (REFIID, LPVOID*);
    STDMETHODIMP Read (LPVOID, ULONG, ULONG*);
    STDMETHODIMP Write (const void *, ULONG, ULONG*);
    STDMETHODIMP Seek (LARGE_INTEGER, DWORD, ULARGE_INTEGER*);
    STDMETHODIMP SetSize (ULARGE_INTEGER);
    STDMETHODIMP CopyTo (LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER*, ULARGE_INTEGER*);
    STDMETHODIMP Commit (DWORD);
    STDMETHODIMP Revert ();
    STDMETHODIMP LockRegion (ULARGE_INTEGER, ULARGE_INTEGER,DWORD);
    STDMETHODIMP UnlockRegion (ULARGE_INTEGER, ULARGE_INTEGER, DWORD);
    STDMETHODIMP Stat (STATSTG*, DWORD);
    STDMETHODIMP Clone (LPSTREAM*);
};

typedef CHFileStm *LPHFILESTM;

#endif __HFILESTM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\enumfmt.cpp ===
// --------------------------------------------------------------------------
// Enumfmt.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------
#include "pch.hxx"
#include "enumfmt.h"
#include <BadStrFunctions.h>

//////////////////////////////////////////////////////////////////////////////
//
// CEnumFormatEtc Implementation
//
//////////////////////////////////////////////////////////////////////////////
//
//  COMMENTS:
//      This class was designed and implemented by Kraig Brockschmidt in
//      is book "Inside OLE2".  See Chapter 6 "Uniform Data Transfer Using
//      Data Objects" for more information.
//

// =================================================================================
// CreateStreamOnHFile
// =================================================================================
OESTDAPI_(HRESULT) CreateEnumFormatEtc(LPUNKNOWN pUnkRef, ULONG celt, PDATAOBJINFO rgInfo, LPFORMATETC rgfe,
                             IEnumFORMATETC **  lppstmHFile)
{
    CEnumFormatEtc *    pEnumFmt = NULL;
    HRESULT             hr = S_OK;

    // Check the incoming params
    if ((0 == pUnkRef) || (0 == lppstmHFile) || (0 == celt) || ((0 != rgInfo) && (0 != rgfe)))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *lppstmHFile = NULL;

    // Create the rules manager object
    if (NULL != rgInfo)
    {
        pEnumFmt = new CEnumFormatEtc(pUnkRef, rgInfo, celt);
    }
    else
    {
        pEnumFmt = new CEnumFormatEtc(pUnkRef, celt, rgfe);
    }
    
    if (NULL == pEnumFmt)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the rules manager interface
    hr = pEnumFmt->QueryInterface(IID_IEnumFORMATETC, (void **) lppstmHFile);
    if (FAILED(hr))
    {
        goto exit;
    }

    pEnumFmt = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pEnumFmt)
    {
        delete pEnumFmt;
    }
    
    return hr;
}

CEnumFormatEtc::CEnumFormatEtc(LPUNKNOWN pUnkRef, PDATAOBJINFO rgInfo, ULONG celt)
    {
    UINT i;

    m_cRef = 0;
    m_pUnkRef = pUnkRef;

    m_iCur = 0;
    m_cfe = celt;
    m_prgfe = new FORMATETC[(UINT) celt];

    if (NULL != m_prgfe)
        {
        for (i = 0; i < celt; i++)
            m_prgfe[i] = rgInfo[i].fe;
        }
    }

CEnumFormatEtc::CEnumFormatEtc(LPUNKNOWN pUnkRef, ULONG cFE, LPFORMATETC rgfe)
    {
    UINT i;

    m_cRef = 0;
    m_pUnkRef = pUnkRef;

    m_iCur = 0;
    m_cfe = cFE;
    m_prgfe = new FORMATETC[(UINT) cFE];

    if (NULL != m_prgfe)
        {
        for (i = 0; i < cFE; i++)
            m_prgfe[i] = rgfe[i];
        }
    }

CEnumFormatEtc::~CEnumFormatEtc(void)
    {
    if (NULL != m_prgfe)
        delete [] m_prgfe;

    return;
    }


STDMETHODIMP CEnumFormatEtc::QueryInterface(REFIID riid, LPVOID* ppv)
    {
    *ppv = NULL;

    //
    // Enumerators are separate objects, not the data object, so we
    // only need to support our IUnknown and IEnumFORMATETC intefaces
    // here with no concern for aggregation.
    //

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumFORMATETC))
        *ppv = (LPVOID) this;

    if (NULL != *ppv)
        {
        ((LPUNKNOWN) *ppv)->AddRef();
        return (NOERROR);
        }

    return (ResultFromScode(E_NOINTERFACE));
    }


STDMETHODIMP_(ULONG) CEnumFormatEtc::AddRef(void)
    {
    ++m_cRef;
    m_pUnkRef->AddRef();
    return (m_cRef);
    }

STDMETHODIMP_(ULONG) CEnumFormatEtc::Release(void)
    {
    ULONG cRefT;

    cRefT = --m_cRef;

    m_pUnkRef->Release();

    if (0 == m_cRef)
        delete this;

    return (cRefT);
    }


STDMETHODIMP CEnumFormatEtc::Next(ULONG cFE, LPFORMATETC pFE, ULONG* pulFE)
    {
    ULONG cReturn = 0L;

    if (NULL == m_prgfe)
        return (ResultFromScode(S_FALSE));

    if (NULL != pulFE)
        *pulFE = 0L;

    if (NULL == pFE || m_iCur >= m_cfe)
        return ResultFromScode(S_FALSE);

    while (m_iCur < m_cfe && cFE > 0)
        {
        *pFE++ = m_prgfe[m_iCur++];
        cReturn++;
        cFE--;
        }

    if (NULL != pulFE)
        *pulFE = cReturn;

    return (NOERROR);
    }


STDMETHODIMP CEnumFormatEtc::Skip(ULONG cSkip)
    {
    if (((m_iCur + cSkip) >= m_cfe) || NULL == m_prgfe)
        return (ResultFromScode(S_FALSE));

    m_iCur += cSkip;
    return (NOERROR);
    }


STDMETHODIMP CEnumFormatEtc::Reset(void)
    {
    m_iCur = 0;
    return (NOERROR);
    }


STDMETHODIMP CEnumFormatEtc::Clone(LPENUMFORMATETC* ppEnum)
    {
    CEnumFormatEtc* pNew;

    *ppEnum = NULL;

    // Create the clone.
    pNew = new CEnumFormatEtc(m_pUnkRef, m_cfe, m_prgfe);
    if (NULL == pNew)
        return (ResultFromScode(E_OUTOFMEMORY));

    pNew->AddRef();
    pNew->m_iCur = m_iCur;

    *ppEnum = pNew;
    return (NOERROR);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\list.cpp ===
//============================================================================
//
//    File implements generic linked list class
//
//============================================================================

#include "pch.hxx"
#include "list.h"
#include <BadStrFunctions.h>


CItem::CItem(LPVOID lpObj, LPItem FAR * lppHeadItem, LPCSTR lpName)
{
    this->lpObj = lpObj;
    this->lpName = lpName;
    this->iRefCnt = 1;

    lppListHead = lppHeadItem;

    lpPrevItem = NULL;
    lpNextItem = *lppHeadItem;  // NULL at the beginning.

    if ( *lppHeadItem )
        (*lppHeadItem)->lpPrevItem = this;

    *lppHeadItem = this;
}


CItem::~CItem()
{
    if ( lpPrevItem )
        lpPrevItem->lpNextItem = lpNextItem;
    else
        *lppListHead = lpNextItem;

    if ( lpNextItem )
        lpNextItem->lpPrevItem = lpPrevItem;

    if ( lpName )
        free ( (LPVOID)lpName );
}


CList::~CList()
{
    LPItem lpItem;

    while ( lpListHead )
        {
        lpItem = lpListHead;
        delete lpItem;  // item @ list head modifies lpListHead
        }
}


LPItem CList::FindItem(LPVOID lpObj)
{
    LPItem lpItem = lpListHead;

    while ( lpItem )
        {
        if (lpItem->lpObj == lpObj)
            return lpItem;

        lpItem = lpItem->lpNextItem;
        }

    return NULL;
}


LPVOID CList::FindItemHandleWithName(LPCSTR lpName, LPVOID lpMem)
{
    LPItem lpItem = lpListHead;

    while( lpItem )
        {
        if( lpName )
            {
            if( !strcmpi( lpName, lpItem->lpName ) )
                {
                lpItem->iRefCnt++;
                return lpItem->lpObj;
                }
            }
        else
            {
            if (lpItem->lpObj == lpMem)
                {
                lpItem->iRefCnt--;

                if( lpItem->iRefCnt == 0 )
                    return lpItem->lpObj;
                else
                    return NULL;
                }
            }

        lpItem = lpItem->lpNextItem;
        }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\htmlcset.cpp ===
// --------------------------------------------------------------------------------
// htmlcset.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include <docobj.h>
#include "mshtmdid.h"
#include "mshtmcid.h"
#include "mshtml.h"
#include <BadStrFunctions.h>

// --------------------------------------------------------------------------------
// HTMLCSETTHREAD
// --------------------------------------------------------------------------------
typedef struct tagHTMLCSETTHREAD {
    HRESULT             hrResult;
    IStream            *pStmHtml;
    LPSTR               pszCharset;
} HTMLCSETTHREAD, *LPHTMLCSETTHREAD;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
class CSimpleSite : public IOleClientSite, public IDispatch, public IOleCommandTarget
{
public:
    // ----------------------------------------------------------------------------
    // Constructor
    // ----------------------------------------------------------------------------
    CSimpleSite(IHTMLDocument2 *pDocument)
    {
        TraceCall("CSimpleSite::CSimpleSite");
        Assert(pDocument);
        m_cRef = 1;
        m_pDocument = pDocument;
        m_pszCharset = NULL;
    }

    // ----------------------------------------------------------------------------
    // Deconstructor
    // ----------------------------------------------------------------------------
    ~CSimpleSite(void) 
    {
        TraceCall("CSimpleSite::~CSimpleSite");
        SafeMemFree(m_pszCharset);
    }

    // ----------------------------------------------------------------------------
    // IUnknown
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IOleClientSite methods.
    // ----------------------------------------------------------------------------
    STDMETHODIMP SaveObject(void) { return E_NOTIMPL; }
    STDMETHODIMP GetMoniker(DWORD, DWORD, LPMONIKER *) { return E_NOTIMPL; }
    STDMETHODIMP GetContainer(LPOLECONTAINER *) { return E_NOTIMPL; }
    STDMETHODIMP ShowObject(void) { return E_NOTIMPL; }
    STDMETHODIMP OnShowWindow(BOOL) { return E_NOTIMPL; }
    STDMETHODIMP RequestNewObjectLayout(void) { return E_NOTIMPL; }

    // ----------------------------------------------------------------------------
    // IDispatch
    // ----------------------------------------------------------------------------
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) { return E_NOTIMPL; }
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid) { return E_NOTIMPL; }
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // ----------------------------------------------------------------------------
    // IOleCommandTarget
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText) { return E_NOTIMPL; }
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

private:
    // ----------------------------------------------------------------------------
    // Privates
    // ----------------------------------------------------------------------------
    LONG                m_cRef;
    IHTMLDocument2     *m_pDocument;

public:
    // ----------------------------------------------------------------------------
    // Publics
    // ----------------------------------------------------------------------------
    LPSTR               m_pszCharset;
};

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
DWORD GetHtmlCharsetThreadEntry(LPDWORD pdwParam);

// --------------------------------------------------------------------------------
// GetHtmlCharset
// --------------------------------------------------------------------------------
HRESULT GetHtmlCharset(IStream *pStmHtml, LPSTR *ppszCharset)
{
    // Locals
    HRESULT             hr=S_OK;
    HTHREAD             hThread=NULL;
    DWORD               dwThreadId;
    HTMLCSETTHREAD      Thread;

    // Trace
    TraceCall("GetHtmlCharset");

    // Invalid Arg
    if (NULL == pStmHtml || NULL == ppszCharset)
        return TraceResult(E_INVALIDARG);

    // Init
    *ppszCharset = NULL;

    // Initialize the Structure
    ZeroMemory(&Thread, sizeof(HTMLCSETTHREAD));

    // Initialize
    Thread.hrResult = S_OK;
    Thread.pStmHtml = pStmHtml;

    // Rewind it
    IF_FAILEXIT(hr = HrRewindStream(pStmHtml));

    // Create the inetmail thread
    hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)GetHtmlCharsetThreadEntry, &Thread, 0, &dwThreadId);
    if (NULL == hThread)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // Wait for SpoolEngineThreadEntry to signal the event
    WaitForSingleObject(hThread, INFINITE);

    // Failure
    if (FAILED(Thread.hrResult))
    {
        hr = TraceResult(Thread.hrResult);
        goto exit;
    }

    // Null pszCharset ?
    if (NULL == Thread.pszCharset)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // Return the object
    *ppszCharset = Thread.pszCharset;

exit:
    // Cleanup
    if (hThread)
        CloseHandle(hThread);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// GetHtmlCharsetThreadEntry
// --------------------------------------------------------------------------------
DWORD GetHtmlCharsetThreadEntry(LPDWORD pdwParam)
{
    // Locals
    HRESULT              hr=S_OK;
    MSG                  msg;
    CSimpleSite         *pSite=NULL;
    IHTMLDocument2      *pDocument=NULL;
    IOleObject          *pOleObject=NULL;
    IOleCommandTarget   *pTarget=NULL;
    IPersistStreamInit  *pPersist=NULL;
    LPHTMLCSETTHREAD     pThread=(LPHTMLCSETTHREAD)pdwParam;

    // Trace
    TraceCall("GetHtmlCharsetThreadEntry");

    // Initialize COM
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        pThread->hrResult = hr;
        return(0);
    }

    // Create me a trident
    IF_FAILEXIT(hr = CoCreateInstance(CLSID_HTMLDocument, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER, IID_IHTMLDocument2, (LPVOID *)&pDocument));

    // Create Site
    IF_NULLEXIT(pSite = new CSimpleSite(pDocument));

    // Get Command Target
    IF_FAILEXIT(hr = pDocument->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pTarget));

    // Get the OLE object interface from trident
    IF_FAILEXIT(hr = pTarget->QueryInterface(IID_IOleObject, (LPVOID *)&pOleObject));

    // Set the client site
    IF_FAILEXIT(hr = pOleObject->SetClientSite((IOleClientSite *)pSite));

    // Get IPersistStreamInit
    IF_FAILEXIT(hr = pTarget->QueryInterface(IID_IPersistStreamInit, (LPVOID *)&pPersist));

    // Load
    IF_FAILEXIT(hr = pPersist->Load(pThread->pStmHtml));

    // Pump Messages
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Kill the Site
    pOleObject->SetClientSite(NULL);

    // Get Charset
    pThread->pszCharset = pSite->m_pszCharset;

    // Don't Free It
    pSite->m_pszCharset = NULL;

exit:
    // Cleanup
    SafeRelease(pSite);
    SafeRelease(pOleObject);
    SafeRelease(pPersist);
    SafeRelease(pTarget);
    SafeRelease(pDocument);

    // Return hr
    pThread->hrResult = hr;

    // Uninit ole
    CoUninitialize();

    // Done
    return(1);
}

// --------------------------------------------------------------------------------
// CSimpleSite::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSimpleSite::AddRef(void)
{
    return ::InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CSimpleSite::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSimpleSite::Release(void)
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

// --------------------------------------------------------------------------------
// CSimpleSite::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CSimpleSite::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CSimpleSite::QueryInterface");

    // Invalid Arg
    Assert(ppv);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)(IOleClientSite *)this;
    else if (IID_IOleClientSite == riid)
        *ppv = (IOleClientSite *)this;
    else if (IID_IDispatch == riid)
        *ppv = (IDispatch *)this;
    else if (IID_IOleCommandTarget == riid)
        *ppv = (IOleCommandTarget *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CSimpleSite::Invoke
// --------------------------------------------------------------------------------
STDMETHODIMP CSimpleSite::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, 
    WORD wFlags, DISPPARAMS FAR* pDispParams, VARIANT *pVarResult, 
    EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    // Trace
    TraceCall("CSimpleSite::Invoke");

    // Only support one dispid
    if (dispIdMember != DISPID_AMBIENT_DLCONTROL)
        return(E_NOTIMPL);

    // Invalid arg
    if (NULL == pVarResult)
        return(E_INVALIDARG);
    
    // Set the return value
    pVarResult->vt = VT_I4;
    pVarResult->lVal = DLCTL_NO_SCRIPTS | DLCTL_NO_JAVA | DLCTL_NO_RUNACTIVEXCTLS | DLCTL_NO_DLACTIVEXCTLS | DLCTL_NO_FRAMEDOWNLOAD | DLCTL_FORCEOFFLINE;

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// CSimpleSite::Exec
// --------------------------------------------------------------------------------
STDMETHODIMP CSimpleSite::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, 
    DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    // Trace
    TraceCall("CSimpleSite::Exec");

    // Done Parsing ?
    if (IDM_PARSECOMPLETE == nCmdID)
    {
        // Locals
        BSTR bstrCharset=NULL;

        // Valid
        Assert(m_pDocument);

        // Get Charset
        if (SUCCEEDED(m_pDocument->get_charset(&bstrCharset)) && bstrCharset)
        {
            // Validate
            Assert(NULL == m_pszCharset);

            // Convert to ansi
            m_pszCharset = PszToANSI(CP_ACP, bstrCharset);

            // Free the bstr
            SysFreeString(bstrCharset);
        }

        // Done
        PostThreadMessage(GetCurrentThreadId(), WM_QUIT, 0, 0);
    }

    // Done
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\hfilestm.cpp ===
// =================================================================================
// HFILE Stream Implementation
// =================================================================================
#include "pch.hxx"
#include "hfilestm.h"
#include "unicnvrt.h"
#include "Error.h"
#include <BadStrFunctions.h>

extern HRESULT HrGetLastError(void);

// =================================================================================
// CreateStreamOnHFile
// =================================================================================
OESTDAPI_(HRESULT) CreateStreamOnHFile (LPTSTR                  lpszFile, 
                                        DWORD                   dwDesiredAccess,
                                        DWORD                   dwShareMode,
                                        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
                                        DWORD                   dwCreationDistribution,
                                        DWORD                   dwFlagsAndAttributes,
                                        HANDLE                  hTemplateFile,
                                        LPSTREAM               *lppstmHFile)
{
    HRESULT hr;
    LPWSTR pwszFile = PszToUnicode(CP_ACP, lpszFile);

    if (!pwszFile && lpszFile)
        return E_OUTOFMEMORY;

    hr = CreateStreamOnHFileW(pwszFile, dwDesiredAccess, dwShareMode,
                              lpSecurityAttributes, dwCreationDistribution,
                              dwFlagsAndAttributes, hTemplateFile, lppstmHFile);

    MemFree(pwszFile);
    return hr;
}

OESTDAPI_(HRESULT) CreateStreamOnHFileW(LPWSTR                  lpwszFile, 
                                        DWORD                   dwDesiredAccess,
                                        DWORD                   dwShareMode,
                                        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
                                        DWORD                   dwCreationDistribution,
                                        DWORD                   dwFlagsAndAttributes,
                                        HANDLE                  hTemplateFile,
                                        LPSTREAM               *lppstmHFile)
{
    // Locals
    HRESULT     hr = S_OK;
    LPHFILESTM  lpstmHFile = NULL;
    DWORD       nBufferLength;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    WCHAR       wszFile[MAX_PATH], 
                wszTempDir[MAX_PATH];

    // Check Params
    Assert (lppstmHFile);
    Assert (dwDesiredAccess & GENERIC_READ || dwDesiredAccess & GENERIC_WRITE);

    // Temp File ?
    if (lpwszFile == NULL)
    {
        // Get Temp Dir
        nBufferLength = AthGetTempPathW(ARRAYSIZE(wszTempDir), wszTempDir);

        if (nBufferLength == 0 || nBufferLength > ARRAYSIZE(wszTempDir))
        {
            hr = E_FAIL;
            goto exit;
        }

        // Get Temp File Name
        UINT uFile = AthGetTempFileNameW(wszTempDir, L"tmp", 0, wszFile);
        if (uFile == 0)
        {
            hr = E_FAIL;
            goto exit;
        }

        // Reset file name
        lpwszFile = wszFile;

        // Delete When Done
        dwFlagsAndAttributes |= FILE_FLAG_DELETE_ON_CLOSE;

        // Always create a new temp file
        dwCreationDistribution = OPEN_EXISTING;
    }

    // Open the file
    hFile = AthCreateFileW(lpwszFile, dwDesiredAccess, dwShareMode, 
                            lpSecurityAttributes, dwCreationDistribution, 
                            dwFlagsAndAttributes, hTemplateFile);

    // Error
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = hrCreateFile;
        return hr;
    }

    // Create Object
    lpstmHFile = new CHFileStm (hFile, dwDesiredAccess);
    if (lpstmHFile == NULL)
    {
        hr = hrMemory;
        goto exit;
    }

exit:
    // Cleanup
    if (FAILED (hr))
    {
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle_F16 (hFile);
        SafeRelease (lpstmHFile);
    }

    // Set return
    *lppstmHFile = (LPSTREAM)lpstmHFile;

    // Done
    return hr;
}

// =================================================================================
// CHFileStm::Constructor
// =================================================================================
CHFileStm::CHFileStm (HANDLE hFile, DWORD dwDesiredAccess)
{
    m_cRef = 1;
    m_hFile = hFile;
    m_dwDesiredAccess = dwDesiredAccess;
}

// =================================================================================
// CHFileStm::Deconstructor
// =================================================================================
CHFileStm::~CHFileStm ()
{
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle_F16 (m_hFile);
    }
}

// =================================================================================
// CHFileStm::AddRef
// =================================================================================
ULONG CHFileStm::AddRef ()
{
    ++m_cRef;
    return m_cRef;
}

// =================================================================================
// CHFileStm::Release
// =================================================================================
ULONG CHFileStm::Release ()
{
    ULONG ulCount = --m_cRef;
    if (!ulCount)
        delete this;
    return ulCount;
}

// =================================================================================
// CHFileStm::QueryInterface
// =================================================================================
STDMETHODIMP CHFileStm::QueryInterface (REFIID iid, LPVOID* ppvObj)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, IID_IStream))
    {
        *ppvObj = this;
        AddRef();
        return(S_OK);
    }

    return E_NOINTERFACE;
}

// =================================================================================
// CHFileStm::Read
// =================================================================================
STDMETHODIMP CHFileStm::Read (LPVOID lpv, ULONG cb, ULONG *pcbRead)
{
    // Locals
    HRESULT             hr = S_OK;
    BOOL                fReturn;
    DWORD               dwRead;

    // Check Params
    Assert (lpv);
    Assert (m_hFile != INVALID_HANDLE_VALUE);

    // Read some bytes from m_hFile
    fReturn = ReadFile (m_hFile, lpv, cb, &dwRead, NULL);
    if (!fReturn)
    {
        hr = HrGetLastError();
        AssertSz (FALSE, "CHFileStm::Read Failed, you might want to take a look at this.");        hr = E_FAIL;
        goto exit;
    }

    // Write byte
    if (pcbRead)
        *pcbRead = dwRead;

exit:
    // Done
    return hr;
}

// =================================================================================
// CHFileStm::Write
// =================================================================================
STDMETHODIMP CHFileStm::Write (const void *lpv, ULONG cb, ULONG *pcbWritten)
{
    // Locals
    HRESULT             hr = S_OK;
    BOOL                fReturn;
    DWORD               dwWritten;

    // Check Params
    Assert (lpv);
    Assert (m_hFile != INVALID_HANDLE_VALUE);

    // Read some bytes from m_hFile
    fReturn = WriteFile (m_hFile, lpv, cb, &dwWritten, NULL);
    if (!fReturn)
    {
        AssertSz (FALSE, "CHFileStm::Write Failed, you might want to take a look at this.");
        hr = STG_E_MEDIUMFULL;  //Bug #50704 (v-snatar) // changed from E_FAILE to propagate the error so that
                                // OnPreviewUpdate( ) properly displays "Out Of Space" error message
        goto exit;
    }

    // Write byte
    if (pcbWritten)
        *pcbWritten = dwWritten;

exit:
    // Done
    return hr;
}

// =================================================================================
// CHFileStm::Seek
// =================================================================================
STDMETHODIMP CHFileStm::Seek (LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    // Locals
    HRESULT             hr = S_OK;
    DWORD               dwReturn;
    LONG                LowPart;        // Cast to signed, could be negative

    Assert (m_hFile != INVALID_HANDLE_VALUE);

    // Cast lowpart
    LowPart = (LONG)dlibMove.LowPart;
    IF_WIN32( Assert (dlibMove.HighPart == 0); )

    // Seek the file pointer
    switch (dwOrigin)
    {
   	case STREAM_SEEK_SET:
        dwReturn = SetFilePointer (m_hFile, LowPart, NULL, FILE_BEGIN);
        break;

    case STREAM_SEEK_CUR:
        dwReturn = SetFilePointer (m_hFile, LowPart, NULL, FILE_CURRENT);
        break;

    case STREAM_SEEK_END:
        dwReturn = SetFilePointer (m_hFile, LowPart, NULL, FILE_END);
        break;

    default:
        dwReturn = 0xFFFFFFFF;
    }

    // Failure ?
    if (dwReturn == 0xFFFFFFFF)
    {
        AssertSz (FALSE, "CHFileStm::Seek Failed, you might want to take a look at this.");
        hr = E_FAIL;
        goto exit;
    }

    // Return Position
    if (plibNewPosition)
    {
        plibNewPosition->QuadPart = dwReturn;
    }

exit:
    // Done
    return hr;
}

// =================================================================================
// CHFileStm::Commit
// =================================================================================
STDMETHODIMP CHFileStm::Commit (DWORD grfCommitFlags)
{
    // Locals
    HRESULT             hr = S_OK;

    Assert (m_hFile != INVALID_HANDLE_VALUE);

    // Flush the buffers
    if (FlushFileBuffers (m_hFile) == FALSE)
    {
        AssertSz (FALSE, "FlushFileBuffers failed");
        hr = E_FAIL;
        goto exit;
    }

exit:
    // Done
    return hr;
}

// =================================================================================
// CHFileStm::SetSize
// =================================================================================
STDMETHODIMP CHFileStm::SetSize (ULARGE_INTEGER uli)
{
    // Seek to dwSize
    if (SetFilePointer (m_hFile, uli.LowPart, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        AssertSz (FALSE, "SetFilePointer failed");
        return E_FAIL;
    }

    // SetEndOfFile
    if (SetEndOfFile (m_hFile) == FALSE)
    {
        AssertSz (FALSE, "SetEndOfFile failed");
        return E_FAIL;
    }

    // Done
    return S_OK;
}

// =================================================================================
// CHFileStm::CopyTo
// =================================================================================
STDMETHODIMP CHFileStm::CopyTo (LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER*, ULARGE_INTEGER*)
{
    return E_NOTIMPL;
}

// =================================================================================
// CHFileStm::Revert
// =================================================================================
STDMETHODIMP CHFileStm::Revert ()
{
    return E_NOTIMPL;
}

// =================================================================================
// CHFileStm::LockRegion
// =================================================================================
STDMETHODIMP CHFileStm::LockRegion (ULARGE_INTEGER, ULARGE_INTEGER,DWORD)
{
    return E_NOTIMPL;
}

// =================================================================================
// CHFileStm::UnlockRegion
// =================================================================================
STDMETHODIMP CHFileStm::UnlockRegion (ULARGE_INTEGER, ULARGE_INTEGER, DWORD)
{
    return E_NOTIMPL;
}

// =================================================================================
// CHFileStm::Stat
// =================================================================================
STDMETHODIMP CHFileStm::Stat (STATSTG*, DWORD)
{
    return E_NOTIMPL;
}

// =================================================================================
// CHFileStm::Clone
// =================================================================================
STDMETHODIMP CHFileStm::Clone (LPSTREAM*)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\listintr.h ===
#ifndef __LISTINTR_H
#define __LISTINTR_H

typedef enum tagLISTDIRECTION {
    LD_FORWARD = 0,
    LD_REVERSE = 1,
    LD_LASTDIRECTION = 2
} LISTDIRECTION;


typedef void (*IVPL_COMPAREFUNCTYPE)(void *ptrA, void *ptrB, bool *pfALessThanB, DWORD_PTR dwCookie);
typedef void (*IVPL_FREEITEMFUNCTYPE)(void *ptr);

typedef void (*IUL_COMPAREFUNCTYPE)(IUnknown *pIUnkA, IUnknown *pIUnkB, bool *pfALessThanB, DWORD_PTR dwCookie);

interface IVoidPtrList;
interface IUnknownList;

HRESULT IVoidPtrList_CreateInstance(IVoidPtrList** ppList);
HRESULT IUnknownList_CreateInstance(IUnknownList** ppList);


interface IVoidPtrList : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Init(
        IVPL_COMPAREFUNCTYPE pCompareFunc,
        DWORD_PTR dwCookie,
        IVPL_FREEITEMFUNCTYPE pFreeItemFunc,
        DWORD dwInitSize) PURE;

    virtual HRESULT STDMETHODCALLTYPE GetCount(DWORD *pdwCount) PURE;

    virtual HRESULT STDMETHODCALLTYPE ClearList(void) PURE;

    virtual HRESULT STDMETHODCALLTYPE AddItem(LPVOID ptr, DWORD *pdwHandle) PURE;

    virtual HRESULT STDMETHODCALLTYPE RemoveItem(DWORD dwHandle) PURE;

    virtual HRESULT STDMETHODCALLTYPE GetNext(
		LISTDIRECTION bDirection,
        LPVOID *pptr, 
        DWORD *pdwHandle) PURE; 

    virtual HRESULT STDMETHODCALLTYPE SkipNext(LISTDIRECTION bDirection, DWORD *pdwHandle) PURE; 

    virtual HRESULT STDMETHODCALLTYPE Resort(void) PURE;
};


interface IUnknownList : public IUnknown
{
public:
    // IUnknownList members
    virtual HRESULT STDMETHODCALLTYPE Init(IUL_COMPAREFUNCTYPE pCompareFunc, DWORD_PTR dwCookie, DWORD dwInitSize) PURE;

    virtual HRESULT STDMETHODCALLTYPE GetCount(DWORD *pdwCount) PURE;

    virtual HRESULT STDMETHODCALLTYPE ClearList(void) PURE;

    virtual HRESULT STDMETHODCALLTYPE AddItem(IUnknown *pIUnk, DWORD *pdwHandle) PURE;

    virtual HRESULT STDMETHODCALLTYPE RemoveItem(DWORD dwHandle) PURE;

    virtual HRESULT STDMETHODCALLTYPE GetNext(LISTDIRECTION bDirection, IUnknown **ppIUnk, DWORD *pdwHandle) PURE; 

    virtual HRESULT STDMETHODCALLTYPE SkipNext(LISTDIRECTION bDirection, DWORD *pdwHandle) PURE;

    virtual HRESULT STDMETHODCALLTYPE Resort(void) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\memcache.cpp ===
// --------------------------------------------------------------------------------
// MemCache.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "memcache.h"
#include <BadStrFunctions.h>

// --------------------------------------------------------------------------------
// CELLSIZE
// --------------------------------------------------------------------------------
#define CELLSIZE(_ulIndex)      ((DWORD)(_ulIndex + m_cbMin))

// --------------------------------------------------------------------------------
// CELLINDEX
// --------------------------------------------------------------------------------
#define CELLINDEX(_cb)          ((ULONG)(_cb - m_cbMin))

// --------------------------------------------------------------------------------
// ISVALIDITEM
// --------------------------------------------------------------------------------
#define ISVALIDITEM(_pv, _iCell) \
    (FALSE == IsBadReadPtr(_pv, CELLSIZE(_iCell)) &&  \
     FALSE == IsBadWritePtr(_pv, CELLSIZE(_iCell)) && \
     m_pMalloc->GetSize(_pv) >= CELLSIZE(_iCell))

// --------------------------------------------------------------------------------
// CMemoryCache::CMemoryCache
// --------------------------------------------------------------------------------
CMemoryCache::CMemoryCache(IMalloc *pMalloc, ULONG cbMin /* =0 */, ULONG cbCacheMax /* =131072 */)
    : m_pMalloc(pMalloc), m_cbMin(cbMin + sizeof(MEMCACHEITEM)), m_cbCacheMax(cbCacheMax)
{
    m_cRef = 1;
    m_cbCacheCur = 0;
    ZeroMemory(m_rgCell, sizeof(m_rgCell));
#ifdef DEBUG
    ZeroMemory(&m_rMetric, sizeof(MEMCACHEMETRIC));
#endif
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMemoryCache::CMemoryCache
// --------------------------------------------------------------------------------
CMemoryCache::~CMemoryCache(void)
{
#ifdef DEBUG
    DebugTrace("InetComm - CMemoryCache: cAlloc = %d\n", m_rMetric.cAlloc);
    DebugTrace("InetComm - CMemoryCache: cAllocCache = %d\n", m_rMetric.cAllocCache);
    DebugTrace("InetComm - CMemoryCache: cbAlloc = %d bytes\n", m_rMetric.cbAlloc);
    DebugTrace("InetComm - CMemoryCache: cFree = %d\n", m_rMetric.cFree);
    DebugTrace("InetComm - CMemoryCache: cbFree = %d bytes\n", m_rMetric.cbFree);
    DebugTrace("InetComm - CMemoryCache: cbCacheMax = %d bytes\n", m_rMetric.cbCacheMax);
    DebugTrace("InetComm - CMemoryCache: cFreeFull = %d\n", m_rMetric.cFreeFull);
    DebugTrace("InetComm - CMemoryCache: cLookAhead = %d\n", m_rMetric.cLookAhead);
    DebugTrace("InetComm - CMemoryCache: Average Look Aheads = %d\n", (m_rMetric.cLookAhead / m_rMetric.cAlloc));
    DebugTrace("InetComm - CMemoryCache: cMostFree = %d\n", m_rMetric.cMostFree);
    DebugTrace("InetComm - CMemoryCache: cbMostFree = %d bytes\n", m_rMetric.cbMostFree);
    DebugTrace("InetComm - CMemoryCache: cMostAlloc = %d\n", m_rMetric.cMostAlloc);
    DebugTrace("InetComm - CMemoryCache: cbMostAlloc = %d bytes\n", m_rMetric.cbMostAlloc);
#endif
    HeapMinimize();
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMemoryCache::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMemoryCache::AddRef(void)
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CMemoryCache::CMemoryCache
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMemoryCache::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CMemoryCache::Alloc
// --------------------------------------------------------------------------------
STDMETHODIMP_(LPVOID) CMemoryCache::Alloc(DWORD cbAlloc)
{
    // Locals
    ULONG           iCell;
    ULONG           iCellMax;
    LPVOID          pvAlloc;

    // No Work
    if (0 == cbAlloc)
        return NULL;

    // Count Number of allocations
    INCMETRIC(cAlloc, 1);
    INCMETRIC(cbAlloc, cbAlloc);

    // Get Index
    iCell = CELLINDEX(cbAlloc);

    // Out of range
    if (iCell >= CACHECELLS)
    {
        // Normal Alloc
        return m_pMalloc->Alloc(cbAlloc);
    }

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Compute iMax
    iCellMax = min(iCell + 10, CACHECELLS);

    // Try to allocate within 0 - 10 bytes of iCell
    while(iCell < iCellMax)
    {
        // Set pvAlloc
        pvAlloc = m_rgCell[iCell].pvItemHead;

        // Done
        if (pvAlloc)
            break;

        // Next
        iCell++;

        // Metric
        INCMETRIC(cLookAhead, 1);
    }

    // Is there memory here
    if (NULL == pvAlloc)
    {
        // Thread Safety
        LeaveCriticalSection(&m_cs);

        // Normal Alloc
        return m_pMalloc->Alloc(cbAlloc);
    }

    // Count Number of allocations
    INCMETRIC(cAllocCache, 1);
    INCMETRIC(cbAllocCache, CELLSIZE(iCell));

    // Adjust the Chain
    m_rgCell[iCell].pvItemHead = ((LPMEMCACHEITEM)pvAlloc)->pvItemNext;

    // Reduce the Size
    m_cbCacheCur -= CELLSIZE(iCell);

#ifdef DEBUG
    memset(pvAlloc, 0xFF, cbAlloc);
    m_rgCell[iCell].cAlloc++;
    if (m_rgCell[iCell].cAlloc > m_rMetric.cMostAlloc)
    {
        m_rMetric.cMostAlloc = m_rgCell[iCell].cAlloc;
        m_rMetric.cbMostAlloc = CELLSIZE(iCell);
    }
#endif

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return pvAlloc;
}

// --------------------------------------------------------------------------------
// CMemoryCache::Realloc
// --------------------------------------------------------------------------------
STDMETHODIMP_(LPVOID) CMemoryCache::Realloc(LPVOID pv, DWORD cbAlloc)
{
    // Locals
    ULONG       cbCurrent;
    LPVOID      pvAlloc;

    // Free
    if (0 == cbAlloc)
    {
        // Free pv
        Free(pv);

        // Done
        return NULL;
    }

    // No pv
    if (NULL == pv)
    {
        // Just Alloc
        return Alloc(cbAlloc);
    }

    // If we have Get Size of pv
    cbCurrent = m_pMalloc->GetSize(pv);

    // Allocate
    pvAlloc = Alloc(cbAlloc);

    // Failure
    if (NULL == pvAlloc)
        return NULL;

    // Copy
    CopyMemory(pvAlloc, pv, min(cbCurrent, cbAlloc));

    // Done
    return pvAlloc;
}

// --------------------------------------------------------------------------------
// CMemoryCache::Free
// --------------------------------------------------------------------------------
STDMETHODIMP_(VOID) CMemoryCache::Free(LPVOID pvFree)
{
    // Locals
    ULONG           iCell;
    ULONG           cbFree;
    MEMCACHEITEM    rItem;

    // No Work
    if (NULL == pvFree)
        return;

    // Get the size
    cbFree = m_pMalloc->GetSize(pvFree);

    // Metrics
    INCMETRIC(cFree, 1);
    INCMETRIC(cbFree, cbFree);

    // Lets put it into the cell
    iCell = CELLINDEX(cbFree);

    // Verify the buffer
    Assert(ISVALIDITEM(pvFree, iCell));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Size of buffer is out of range or the cache has reached its max
    if (cbFree < m_cbMin || cbFree - m_cbMin > CACHECELLS || m_cbCacheCur + cbFree > m_cbCacheMax)
    {
        // Stats
        INCMETRIC(cFreeFull, 1);

        // Thread Safety
        LeaveCriticalSection(&m_cs);

        // Free It
        m_pMalloc->Free(pvFree);

        // Done
        return;
    }

    // Set Next
    rItem.pvItemNext = m_rgCell[iCell].pvItemHead;

#ifdef DEBUG
    memset(pvFree, 0xDD, cbFree);
#endif

    // Write this into the buffer
    CopyMemory(pvFree, &rItem, sizeof(MEMCACHEITEM));

    // Reset pvItemHead
    m_rgCell[iCell].pvItemHead = pvFree;

    // Increment m_cbCacheCur
    m_cbCacheCur += cbFree;

#ifdef DEBUG
    if (m_cbCacheCur > m_rMetric.cbCacheMax)
        m_rMetric.cbCacheMax = m_cbCacheCur;
    m_rgCell[iCell].cFree++;
    if (m_rgCell[iCell].cFree > m_rMetric.cMostFree)
    {
        m_rMetric.cMostFree = m_rgCell[iCell].cFree;
        m_rMetric.cbMostFree = CELLSIZE(iCell);
    }
#endif

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMemoryCache::HeapMinimize
// --------------------------------------------------------------------------------
STDMETHODIMP_(VOID) CMemoryCache::HeapMinimize(void)
{
    // Locals
    LPVOID          pvCurr;
    LPVOID          pvNext;
    ULONG           i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Walk throught the cells
    for (i=0; i<ARRAYSIZE(m_rgCell); i++)
    {
        // Set Current
        pvCurr = m_rgCell[i].pvItemHead;

        // Call the Chain of Buffers
        while(pvCurr)
        {
            // Valid Buffer
            Assert(ISVALIDITEM(pvCurr, i));

            // Get Next
            pvNext = ((LPMEMCACHEITEM)pvCurr)->pvItemNext;

            // Free this buffer
            m_pMalloc->Free(pvCurr);

            // Goto Next
            pvCurr = pvNext;
        }

        // Clear the cell
        m_rgCell[i].pvItemHead = NULL;
    }

    // Minimize internal cache
    m_pMalloc->HeapMinimize();

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\mshtutil.h ===
/*
 *    m s h t u t i l . c p p
 *    
 *    Purpose:
 *        MSHTML utilities
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _MSHTUTIL_H
#define _MSHTUTIL_H

enum
{
    TM_TAGMENU  = 0
};

interface IHTMLDocument2;
interface IHTMLBodyElement;
interface IHTMLElement;
interface IHTMLStyleSheet;

OESTDAPI_(HRESULT) HrCreateTridentMenu(IUnknown *pUnkTrident, ULONG uMenu, ULONG idmFirst, ULONG cMaxItems, HMENU *phMenu);
OESTDAPI_(HRESULT) HrCheckTridentMenu(IUnknown *pUnkTrident, ULONG uMenu, ULONG idmFirst, ULONG idmLast, HMENU hMenu);
OESTDAPI_(HRESULT) HrGetElementImpl(IHTMLDocument2 *pDoc, LPCTSTR pszName, IHTMLElement **ppElem);
OESTDAPI_(HRESULT) HrSetDirtyFlagImpl(LPUNKNOWN pUnkTrident, BOOL fDirty);
OESTDAPI_(HRESULT) HrGetBodyElement(IHTMLDocument2 *pDoc, IHTMLBodyElement **ppBody);
OESTDAPI_(HRESULT) HrGetStyleSheet(IHTMLDocument2 *pDoc, IHTMLStyleSheet **ppStyle);


#endif //_MSHTUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\mshtutil.cpp ===
/*
 *    m s h t u t i l . c p p
 *    
 *    Purpose:
 *        MSHTML utilities
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include <imm.h>
#include "dllmain.h"
#include "urlmon.h"
#include "wininet.h"
#include "mshtml.h"
#include "mshtmcid.h"
#include "mshtmhst.h"
#include "demand.h"
#include <shlwapi.h>
#include <BadStrFunctions.h>

ASSERTDATA

/*
 *  t y p e d e f s
 */

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s
 */

/*
 *  g l o b a l s 
 */


/*
 *  p r o t o t y p e s
 */

HRESULT HrCheckTridentMenu(IUnknown *pUnkTrident, ULONG uMenu, ULONG idmFirst, ULONG idmLast, HMENU hMenu)
{
    HRESULT     hr = S_OK;

    if (pUnkTrident == NULL)
        return E_INVALIDARG;

    switch (uMenu)
    {
        case TM_TAGMENU:
        {
            IOleCommandTarget  *pCmdTarget = NULL;
            VARIANTARG          va;
            // uncheck stuff incase of failure
            CheckMenuRadioItem(hMenu, idmFirst, idmLast, 0, MF_BYCOMMAND|MF_UNCHECKED);

            hr = pUnkTrident->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget);
            if (FAILED(hr))
                break;
            
            va.vt = VT_BSTR;
            va.bstrVal = NULL;

            if(SUCCEEDED(pCmdTarget->Exec(&CMDSETID_Forms3, IDM_BLOCKFMT, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &va)))
            {
                TCHAR szBufMenu[MAX_PATH];
                TCHAR szBufTag[MAX_PATH];
                ULONG cmenus = (ULONG)GetMenuItemCount(hMenu);

                *szBufTag = 0;
                *szBufMenu = 0;

                if (va.vt == VT_BSTR && va.bstrVal)
                    {
                    WideCharToMultiByte(CP_ACP, 0, (WCHAR*)va.bstrVal, -1, szBufTag, MAX_PATH, NULL, NULL);
                    szBufTag[MAX_PATH - 1] = 0;
                    SysFreeString(va.bstrVal);
                    }

                // find the right one in the tag menu to put a radio button.
                for(ULONG i = idmFirst; i < cmenus+idmFirst; i++)
                    {
                    GetMenuString(hMenu, i, szBufMenu, MAX_PATH, MF_BYCOMMAND);
                    if(0 == StrCmpI(szBufMenu, szBufTag))
                        {
                        CheckMenuRadioItem(hMenu, idmFirst, idmLast, i, MF_BYCOMMAND);
                        break;
                        }
                    }
            }
            pCmdTarget->Release();
            break;
        }
        default:
            hr = E_FAIL;
    }

    return hr;

}

HRESULT HrCreateTridentMenu(IUnknown *pUnkTrident, ULONG uMenu, ULONG idmFirst, ULONG cMaxItems, HMENU *phMenu)
{
    HRESULT             hr = NOERROR;
    VARIANTARG          va;
    LONG                lLBound, 
                        lUBound, 
                        lIndex;
    BSTR                bstr;
    TCHAR               szBuf[CCHMAX_STRINGRES];
    SAFEARRAY           *psa;
    ULONG               idmTag=idmFirst;
    HMENU               hmenu;
    IOleCommandTarget   *pCmdTarget;

    if (phMenu == NULL || pUnkTrident == NULL)
        return E_INVALIDARG;

    hmenu = CreatePopupMenu();
    if (hmenu == NULL)
        return E_OUTOFMEMORY;

    switch (uMenu)
        {
        case TM_TAGMENU:
            hr = pUnkTrident->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget);
            if (SUCCEEDED(hr))
                {
                va.vt = VT_ARRAY;
                va.parray = NULL;

                hr = pCmdTarget->Exec(&CMDSETID_Forms3, IDM_GETBLOCKFMTS, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &va);
                if (SUCCEEDED(hr))
                    {
                    psa = V_ARRAY(&va);

                    SafeArrayGetLBound(psa, 1, &lLBound);
                    SafeArrayGetUBound(psa, 1, &lUBound);
            
                    for (lIndex=lLBound; lIndex<=lUBound; lIndex++)
                        {
                        if (idmTag == idmFirst + cMaxItems) // don't append to many
                            break;

                        if (SafeArrayGetElement(psa, &lIndex, &bstr)==S_OK)
                            {
                            if(WideCharToMultiByte(CP_ACP, 0, bstr, -1, szBuf, CCHMAX_STRINGRES, NULL, NULL))
                                AppendMenu(hmenu, MF_STRING | MF_BYCOMMAND, idmTag++, (LPCTSTR)szBuf);
                            szBuf[CCHMAX_STRINGRES - 1] = 0;
                            SysFreeString(bstr);
                            }
                        }
                    SafeArrayDestroy(psa);
                    }
                pCmdTarget->Release();
                }
            break;

        default:
            hr = E_FAIL;
        }
    
    if (hr==S_OK)
        *phMenu = hmenu;

    return hr;
}



HRESULT HrGetElementImpl(IHTMLDocument2 *pDoc, LPCTSTR pszName, IHTMLElement **ppElem)
{
    HRESULT                 hr = E_FAIL;
    IHTMLElementCollection *pCollect = NULL;
    IDispatch              *pDisp = NULL;
    VARIANTARG              va1, va2;

    if (pDoc)
        {
        pDoc->get_all(&pCollect);
        if (pCollect)
            {
            if (SUCCEEDED(HrLPSZToBSTR(pszName, &va1.bstrVal)))
                {
                va1.vt = VT_BSTR;
                va2.vt = VT_EMPTY;
                pCollect->item(va1, va2, &pDisp);
                if (pDisp)
                    {
                    hr = pDisp->QueryInterface(IID_IHTMLElement, (LPVOID*)ppElem);
                    pDisp->Release();
                    }
                SysFreeString(va1.bstrVal);
                }
            pCollect->Release();
            }
        }
    return hr;

}

HRESULT HrGetBodyElement(IHTMLDocument2 *pDoc, IHTMLBodyElement **ppBody)
{
    HRESULT         hr=E_FAIL;
    IHTMLElement    *pElem=0;

    if (ppBody == NULL)
        return E_INVALIDARG;

    *ppBody = 0;
    if (pDoc)
        {
        pDoc->get_body(&pElem);
        if (pElem)
            {
            hr = pElem->QueryInterface(IID_IHTMLBodyElement, (LPVOID *)ppBody);
            pElem->Release();
            }
        }
    return hr;
}


HRESULT HrSetDirtyFlagImpl(LPUNKNOWN pUnkTrident, BOOL fDirty)
{
    VARIANTARG          va;
    IOleCommandTarget   *pCmdTarget;

    if (!pUnkTrident)
        return E_INVALIDARG;

    if (pUnkTrident->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&pCmdTarget)==S_OK)
        {
        va.vt = VT_BOOL;
        va.boolVal = fDirty?VARIANT_TRUE:VARIANT_FALSE;
        pCmdTarget->Exec(&CMDSETID_Forms3, IDM_SETDIRTY, MSOCMDEXECOPT_DONTPROMPTUSER, &va, NULL);
        pCmdTarget->Release();
        }
    return S_OK;
}



HRESULT HrGetStyleSheet(IHTMLDocument2 *pDoc, IHTMLStyleSheet **ppStyle)
{
    IHTMLStyleSheetsCollection  *pStyleSheets;
    IHTMLStyleSheet             *pStyle;
    VARIANTARG                  va1, va2;
    HRESULT                     hr=E_FAIL;

    if (pDoc == NULL || ppStyle == NULL)
        return E_INVALIDARG;

    *ppStyle=NULL;

    if (pDoc->get_styleSheets(&pStyleSheets)==S_OK)
        {
        va1.vt = VT_I4;
        va1.lVal = (LONG)0;
        va2.vt = VT_EMPTY;
        pStyleSheets->item(&va1, &va2);
        if (va2.vt == VT_DISPATCH && va2.pdispVal)
            hr = va2.pdispVal->QueryInterface(IID_IHTMLStyleSheet, (LPVOID *)ppStyle);

        pStyleSheets->Release();
        }

    // not found, let's create a new one
    if (*ppStyle==NULL)
        hr = pDoc->createStyleSheet(NULL, -1, ppStyle);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\memcache.h ===
// --------------------------------------------------------------------------------
// MemCache.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __MEMCACHE_H
#define __MEMCACHE_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CMemoryCache;
typedef CMemoryCache *LPMEMORYCACHE;

// --------------------------------------------------------------------------------
// CACHECELLS
// --------------------------------------------------------------------------------
#define CACHECELLS 20480

// --------------------------------------------------------------------------------
// MEMCACHECELL
// --------------------------------------------------------------------------------
typedef struct tagMEMCACHECELL {
#ifdef DEBUG
    ULONG               cFree;
    ULONG               cAlloc;
#endif
    LPVOID              pvItemHead;        // Pointer to first block    
} MEMCACHECELL, *LPMEMCACHECELL;

// --------------------------------------------------------------------------------
// Memory Cache Debug Metrics
// --------------------------------------------------------------------------------
#ifdef DEBUG
typedef struct tagMEMCACHEMETRIC {
    ULONG               cAlloc;   
    ULONG               cAllocCache;
    ULONG               cbAlloc;  
    ULONG               cbAllocCache;
    ULONG               cFree;
    ULONG               cbFree;   
    ULONG               cbCacheMax;
    ULONG               cFreeFull;
    ULONG               cLookAhead;
    ULONG               cMostAlloc;
    ULONG               cMostFree;
    ULONG               cbMostAlloc;
    ULONG               cbMostFree;
} MEMCACHEMETRIC, *LPMEMCACHEMETRIC;

#define INCMETRIC(_member, _amount)       (m_rMetric.##_member += _amount)
#else // DEBUG
#define INCMETRIC(_member, _amount)       1 ? (void)0 : (void)
#endif // DEBUG

// --------------------------------------------------------------------------------
// MEMCACHEITEM
// --------------------------------------------------------------------------------
typedef struct tagMEMCACHEITEM {
    LPVOID              pvItemNext;        // Pointer to next block of same size
} MEMCACHEITEM, *LPMEMCACHEITEM;

// --------------------------------------------------------------------------------
// CMemoryCache
// --------------------------------------------------------------------------------
class CMemoryCache : public IMalloc
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMemoryCache(IMalloc *pMalloc, ULONG cbMin=0, ULONG cbCacheMax=131072);
    ~CMemoryCache(void);

    // ----------------------------------------------------------------------------
    // IUnknown Members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv) { return TrapError(E_NOTIMPL); }
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // CMemoryCache Members
    // ----------------------------------------------------------------------------
    STDMETHODIMP_(LPVOID) Alloc(ULONG cb);
    STDMETHODIMP_(LPVOID) Realloc(LPVOID pv, ULONG cb);
    STDMETHODIMP_(VOID) Free(LPVOID pv);
    STDMETHODIMP_(VOID) HeapMinimize(void);
    STDMETHODIMP_(INT) DidAlloc(LPVOID pv) { return(m_pMalloc->DidAlloc(pv)); }
    STDMETHODIMP_(ULONG) GetSize(LPVOID pv) { return(m_pMalloc->GetSize(pv)); }

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    ULONG               m_cRef;                 // Reference Count
    ULONG               m_cbMin;                // Smallest size buffer to cache
    ULONG               m_cbCacheMax;           // Maximum size of the cache
    ULONG               m_cbCacheCur;           // Current Size of the cache
    IMalloc            *m_pMalloc;              // Memory Allocator
    MEMCACHECELL        m_rgCell[CACHECELLS];   // Array of pointers to cell chains
    CRITICAL_SECTION    m_cs;                   // Critical Section
#ifdef DEBUG
    MEMCACHEMETRIC      m_rMetric;              // Debug Stats on Cache Usage
#endif
};

#endif // __MEMCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\msoedbg.cpp ===
// --------------------------------------------------------------------------------
// Msoedbg.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include <BadStrFunctions.h>

// --------------------------------------------------------------------------------
// Debug Only Code
// --------------------------------------------------------------------------------
#ifdef DEBUG

#include <shlwapi.h>
#include "dllmain.h"

// --------------------------------------------------------------------------------
// REGISTRYNAMES
// --------------------------------------------------------------------------------
typedef struct tagREGISTRYNAMES {
    LPCSTR              pszEnableTracing;
    LPCSTR              pszTraceLogType;
    LPCSTR              pszLogfilePath;
    LPCSTR              pszResetLogfile;
    LPCSTR              pszLogTraceCall;
    LPCSTR              pszLogTraceInfo;
    LPCSTR              pszLogWatchFilePath;
    LPCSTR              pszLaunchLogWatcher;
    LPCSTR              pszDisplaySourceFilePaths;
    LPCSTR              pszTraceCallIndent;
} REGISTRYNAMES, *LPREGISTRYNAMES;

// --------------------------------------------------------------------------------
// RegKeyNames
// --------------------------------------------------------------------------------
static REGISTRYNAMES g_rRegKeyNames = { 
    "EnableTracing",
    "TraceLogType",
    "LogfilePath",
    "LogfileResetType",
    "LogTraceCall",
    "LogTraceInfo",
    "LogWatchFilePath",
    "LaunchLogWatcher",
    "DisplaySourceFilePaths",
    "TraceCallIndent"
};

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
void ReadTraceComponentInfo(
        IN          HKEY                    hRegKey, 
        IN          LPREGISTRYNAMES         pNames, 
        OUT         LPTRACECOMPONENTINFO    pInfo);

void ReadTraceItemTable(
        IN          HKEY                    hKeyRoot,
        IN          LPCSTR                  pszSubKey,
        OUT         LPTRACEITEMTABLE        pTable);

// --------------------------------------------------------------------------------
// Global Configuration
// --------------------------------------------------------------------------------
static CRITICAL_SECTION         g_csTracing={0};
static LPTRACECOMPONENTINFO     g_pHeadComponent=NULL;

// --------------------------------------------------------------------------------
// InitializeTracingSystem
// --------------------------------------------------------------------------------
void InitializeTracingSystem(void)
{
    g_dwTlsTraceThread = TlsAlloc();
    Assert(g_dwTlsTraceThread != 0xffffffff);
    InitializeCriticalSection(&g_csTracing);
}

// --------------------------------------------------------------------------------
// FreeTraceItemTable
// --------------------------------------------------------------------------------
void FreeTraceItemTable(LPTRACEITEMTABLE pTable)
{
    for (ULONG i=0; i<pTable->cItems; i++)
        SafeMemFree(pTable->prgItem[i].pszName);
    SafeMemFree(pTable->prgItem);
}

// --------------------------------------------------------------------------------
// FreeTraceComponentInfo
// --------------------------------------------------------------------------------
void FreeTraceComponentInfo(LPTRACECOMPONENTINFO pInfo)
{
    SafeRelease(pInfo->pStmFile);
    SafeMemFree(pInfo->pszComponent);
    FreeTraceItemTable(&pInfo->rFunctions);
    FreeTraceItemTable(&pInfo->rClasses);
    FreeTraceItemTable(&pInfo->rThreads);
    FreeTraceItemTable(&pInfo->rFiles);
    FreeTraceItemTable(&pInfo->rTagged);
}

// --------------------------------------------------------------------------------
// FreeTraceThreadInfo
// --------------------------------------------------------------------------------
void FreeTraceThreadInfo(LPTRACETHREADINFO pThread)
{
    //Assert(pThread->cStackDepth == 0);
    SafeMemFree(pThread->pszName);
}

// --------------------------------------------------------------------------------
// UninitializeTracingSystem
// --------------------------------------------------------------------------------
void UninitializeTracingSystem(void)
{
    // Locals
    LPTRACECOMPONENTINFO pCurrComponent=g_pHeadComponent;
    LPTRACECOMPONENTINFO pNextComponent;

    // Loop
    while(pCurrComponent)
    {
        // Save Next
        pNextComponent = pCurrComponent->pNext;

        // Free the Current
        FreeTraceComponentInfo(pCurrComponent);
        g_pMalloc->Free(pCurrComponent);

        // Goto Next
        pCurrComponent = pNextComponent;
    }

    // Reset Headers
    g_pHeadComponent = NULL;

    // Free Critical Section
    DeleteCriticalSection(&g_csTracing);

    // Free thread tls index
    TlsFree(g_dwTlsTraceThread);
    g_dwTlsTraceThread = 0xffffffff;
}

// --------------------------------------------------------------------------------
// CoStartTracingComponent
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) CoStartTracingComponent(
        IN          HKEY                    hKeyRoot, 
        IN          LPCSTR                  pszRegRoot,
        OUT         LPDWORD                 pdwTraceId)
{
    // Locals
    HRESULT                 hr=S_OK;
    HKEY                    hRoot=NULL;
    DWORD                   dw;
    LPTRACECOMPONENTINFO    pComponent=NULL;
    ULONG                   i;
    LONG                    j;

    // Invalid Arg
    if (NULL == hKeyRoot || NULL == pszRegRoot || NULL == pdwTraceId)
        return TrapError(E_INVALIDARG);

    // Initialize
    *pdwTraceId = 0;

    // Thread Safe
    EnterCriticalSection(&g_csTracing);

    // Open pszRegRoot
    if (RegOpenKeyEx(hKeyRoot, pszRegRoot, 0, KEY_ALL_ACCESS, &hRoot) != ERROR_SUCCESS)
    {
        // Lets create the subkey
        if (RegCreateKeyEx(hKeyRoot, pszRegRoot, 0, NULL, NULL, KEY_ALL_ACCESS, NULL, &hRoot, &dw) != ERROR_SUCCESS)
        {
            Assert(FALSE);
            hRoot = NULL;
            goto exit;
        }
    }

    // Allocate a new LPTRACECOMPONENTINFO
    CHECKALLOC(pComponent = (LPTRACECOMPONENTINFO)g_pMalloc->Alloc(sizeof(TRACECOMPONENTINFO)));

    // Loads Configuration...
    ReadTraceComponentInfo(hRoot, &g_rRegKeyNames, pComponent);

    // Read trace item tables
    ReadTraceItemTable(hRoot, "Functions", &pComponent->rFunctions);
    ReadTraceItemTable(hRoot, "Classes", &pComponent->rClasses);
    ReadTraceItemTable(hRoot, "Threads", &pComponent->rThreads);
    ReadTraceItemTable(hRoot, "Files", &pComponent->rFiles);
    ReadTraceItemTable(hRoot, "Tagged", &pComponent->rTagged);

    // Fixup Class Names to have a :: on the end
    for (i=0; i<pComponent->rClasses.cItems; i++)
    {
        // I'm guaranteed to have extra room, loot at ReadTraceItemTable
        StrCatBuff(pComponent->rClasses.prgItem[i].pszName, "::", pComponent->rClasses.prgItem[i].cchName);
    }

    // Parse off the component name
    for (j=lstrlen(pszRegRoot); j>=0; j--)
    {
        // Software\\Microsoft\\Outlook Express\\Debug\\MSIMNUI
        if ('\\' == pszRegRoot[j])
        {
            // Dup the string
            CHECKALLOC(pComponent->pszComponent = PszDupA(pszRegRoot + j + 1));

            // Done
            break;
        }
    }

    // Did we find a component name
    Assert(pComponent->pszComponent);
    if (NULL == pComponent->pszComponent)
    {
        // Unknown Module
        CHECKALLOC(pComponent->pszComponent = PszDupA("ModUnknown"));
    }

    // Link pComponent into linked list
    pComponent->pNext = g_pHeadComponent;
    if (g_pHeadComponent)
        g_pHeadComponent->pPrev = pComponent;
    g_pHeadComponent = pComponent;

    // Set Return Value
    *pdwTraceId = (DWORD)pComponent;
    pComponent = NULL;

exit:
    // Thread Safe
    LeaveCriticalSection(&g_csTracing);
        
    // Cleanup
    if (hRoot)
        RegCloseKey(hRoot);
    if (pComponent)
    {
        FreeTraceComponentInfo(pComponent);
        g_pMalloc->Free(pComponent);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CoStopTracingComponent
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) CoStopTracingComponent(
        IN          DWORD                   dwTraceId /* g_dbg_dwTraceId */)
{
    // Locals
    LPTRACECOMPONENTINFO pInfo;

    // Invalid Arg
    if (0 == dwTraceId)
        return E_INVALIDARG;

    // Thread Safe
    EnterCriticalSection(&g_csTracing);

    // Cast
    pInfo = (LPTRACECOMPONENTINFO)dwTraceId;

    // Find pInfo in the linked list
    if (pInfo->pNext)
        pInfo->pNext->pPrev = pInfo->pPrev;
    if (pInfo->pPrev)
        pInfo->pPrev->pNext = pInfo->pNext;

    // Was this the head item ?
    if (pInfo == g_pHeadComponent)
        g_pHeadComponent = pInfo->pNext;

    // Free pInfo
    FreeTraceComponentInfo(pInfo);
    g_pMalloc->Free(pInfo);

    // Thread Safe
    LeaveCriticalSection(&g_csTracing);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// ThreadAllocateTlsTraceInfo
// --------------------------------------------------------------------------------
void ThreadAllocateTlsTraceInfo(void)
{
    // Do we have a tls index
    if (0xffffffff != g_dwTlsTraceThread)
    {
        // Allocate thread info
        LPTRACETHREADINFO pThread = (LPTRACETHREADINFO)g_pMalloc->Alloc(sizeof(TRACETHREADINFO));

        // Zero It out
        if (pThread)
        {
            // Zero It
            ZeroMemory(pThread, sizeof(TRACETHREADINFO));

            // Get the thread id
            pThread->dwThreadId = GetCurrentThreadId();
        }

        // Store It
        TlsSetValue(g_dwTlsTraceThread, pThread);
    }
}

// --------------------------------------------------------------------------------
// ThreadFreeTlsTraceInfo
// --------------------------------------------------------------------------------
void ThreadFreeTlsTraceInfo(void)
{
    // Do we have a tls index
    if (0xffffffff != g_dwTlsTraceThread)
    {
        // Allocate thread info
        LPTRACETHREADINFO pThread = (LPTRACETHREADINFO)TlsGetValue(g_dwTlsTraceThread);

        // Free It
        if (pThread)
        {
            SafeMemFree(pThread->pszName);
            MemFree(pThread);
        }

        // Store It
        TlsSetValue(g_dwTlsTraceThread, NULL);
    }
}

// --------------------------------------------------------------------------------
// CoTraceSetCurrentThreadName
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) CoTraceSetCurrentThreadName(
        IN          LPCSTR                  pszThreadName)
{
    // Invalid Arg
    Assert(pszThreadName);

    // Do we have a tls index
    if (0xffffffff != g_dwTlsTraceThread)
    {
        // Allocate thread info
        LPTRACETHREADINFO pThread = (LPTRACETHREADINFO)TlsGetValue(g_dwTlsTraceThread);

        // If there is a thread
        if (pThread)
        {
            // If the name has not yet been set...
            SafeMemFree(pThread->pszName);

            // Duplicate It
            pThread->pszName = PszDupA(pszThreadName);
            Assert(pThread->pszName);
        }
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// PGetCurrentTraceThread
// --------------------------------------------------------------------------------
LPTRACETHREADINFO PGetCurrentTraceThread(void)
{
    // Locals
    LPTRACETHREADINFO pThread=NULL;

    // Do we have a tls index
    if (0xffffffff != g_dwTlsTraceThread)
    {
        // Allocate thread info
        pThread = (LPTRACETHREADINFO)TlsGetValue(g_dwTlsTraceThread);
    }

    // Done
    return pThread;
}

// --------------------------------------------------------------------------------
// ReadTraceComponentInfo
// --------------------------------------------------------------------------------
void ReadTraceComponentInfo(
        IN          HKEY                    hRegKey, 
        IN          LPREGISTRYNAMES         pNames, 
        OUT         LPTRACECOMPONENTINFO    pInfo)
{
    // Locals
    ULONG           cb;

    // Invalid ARg
    Assert(hRegKey && pNames && pInfo);

    // ZeroInit
    ZeroMemory(pInfo, sizeof(TRACECOMPONENTINFO));

    // Read pInfo->fEnableTracing
    cb = sizeof(pInfo->tracetype);
    if (RegQueryValueEx(hRegKey, pNames->pszEnableTracing, 0, NULL, (LPBYTE)&pInfo->tracetype, &cb) != ERROR_SUCCESS)
    {
        // Set the Default Value
        pInfo->tracetype = TRACE_NONE;
        SideAssert(RegSetValueEx(hRegKey, pNames->pszEnableTracing, 0, REG_DWORD, (LPBYTE)&pInfo->tracetype, sizeof(DWORD)) == ERROR_SUCCESS);
    }

    // Read pInfo->logtype
    cb = sizeof(DWORD);
    if (RegQueryValueEx(hRegKey, pNames->pszTraceLogType, 0, NULL, (LPBYTE)&pInfo->logtype, &cb) != ERROR_SUCCESS)
    {
        // Set the Default Value
        pInfo->logtype = LOGTYPE_OUTPUT;
        SideAssert(RegSetValueEx(hRegKey, pNames->pszTraceLogType, 0, REG_DWORD, (LPBYTE)&pInfo->logtype, sizeof(DWORD)) == ERROR_SUCCESS);
    }

    // Read pInfo->szLogfilePath
    cb = sizeof(pInfo->szLogfilePath);
    if (RegQueryValueEx(hRegKey, pNames->pszLogfilePath, 0, NULL, (LPBYTE)&pInfo->szLogfilePath, &cb) != ERROR_SUCCESS)
    {
        // Set the Default Value
        SideAssert(RegSetValueEx(hRegKey, pNames->pszLogfilePath, 0, REG_SZ, (LPBYTE)"", 1) == ERROR_SUCCESS);

        // Adjust the logtype
        if (pInfo->logtype >= LOGTYPE_FILE)
            pInfo->logtype = LOGTYPE_OUTPUT;
    }

    // Read pInfo->fResetLogfile
    cb = sizeof(DWORD);
    if (RegQueryValueEx(hRegKey, pNames->pszResetLogfile, 0, NULL, (LPBYTE)&pInfo->fResetLogfile, &cb) != ERROR_SUCCESS)
    {
        // Set the Default Value
        pInfo->fResetLogfile = TRUE;
        SideAssert(RegSetValueEx(hRegKey, pNames->pszResetLogfile, 0, REG_DWORD, (LPBYTE)&pInfo->fResetLogfile, sizeof(DWORD)) == ERROR_SUCCESS);
    }

    // Read pInfo->fTraceCallIndent
    cb = sizeof(DWORD);
    if (RegQueryValueEx(hRegKey, pNames->pszTraceCallIndent, 0, NULL, (LPBYTE)&pInfo->fTraceCallIndent, &cb) != ERROR_SUCCESS)
    {
        // Set the Default Value
        pInfo->fTraceCallIndent = TRUE;
        SideAssert(RegSetValueEx(hRegKey, pNames->pszTraceCallIndent, 0, REG_DWORD, (LPBYTE)&pInfo->fTraceCallIndent, sizeof(DWORD)) == ERROR_SUCCESS);
    }

    // Read pInfo->fTraceCalls
    cb = sizeof(DWORD);
    if (RegQueryValueEx(hRegKey, pNames->pszLogTraceCall, 0, NULL, (LPBYTE)&pInfo->fTraceCalls, &cb) != ERROR_SUCCESS)
    {
        // Set the Default Value
        pInfo->fTraceCalls = FALSE;
        SideAssert(RegSetValueEx(hRegKey, pNames->pszLogTraceCall, 0, REG_DWORD, (LPBYTE)&pInfo->fTraceCalls, sizeof(DWORD)) == ERROR_SUCCESS);
    }

    // Read pInfo->fTraceInfo
    cb = sizeof(DWORD);
    if (RegQueryValueEx(hRegKey, pNames->pszLogTraceInfo, 0, NULL, (LPBYTE)&pInfo->fTraceInfo, &cb) != ERROR_SUCCESS)
    {
        // Set the Default Value
        pInfo->fTraceInfo = FALSE;
        SideAssert(RegSetValueEx(hRegKey, pNames->pszLogTraceInfo, 0, REG_DWORD, (LPBYTE)&pInfo->fTraceInfo, sizeof(DWORD)) == ERROR_SUCCESS);
    }

    // Read pInfo->fLaunchLogWatcher
    cb = sizeof(DWORD);
    if (RegQueryValueEx(hRegKey, pNames->pszLaunchLogWatcher, 0, NULL, (LPBYTE)&pInfo->fLaunchLogWatcher, &cb) != ERROR_SUCCESS)
    {
        // Set the Default Value
        pInfo->fLaunchLogWatcher = FALSE;
        SideAssert(RegSetValueEx(hRegKey, pNames->pszLaunchLogWatcher, 0, REG_DWORD, (LPBYTE)&pInfo->fLaunchLogWatcher, sizeof(DWORD)) == ERROR_SUCCESS);
    }

    // Read pInfo->szLogWatchFilePath
    cb = sizeof(pInfo->szLogWatchFilePath);
    if (RegQueryValueEx(hRegKey, pNames->pszLogWatchFilePath, 0, NULL, (LPBYTE)&pInfo->szLogWatchFilePath, &cb) != ERROR_SUCCESS)
    {
        // Set the Default Value
        SideAssert(RegSetValueEx(hRegKey, pNames->pszLogWatchFilePath, 0, REG_SZ, (LPBYTE)"", 1) == ERROR_SUCCESS);

        // Reset
        pInfo->fLaunchLogWatcher = FALSE;
    }

    // Read pInfo->fDisplaySourceFilePaths
    cb = sizeof(DWORD);
    if (RegQueryValueEx(hRegKey, pNames->pszDisplaySourceFilePaths, 0, NULL, (LPBYTE)&pInfo->fDisplaySourceFilePaths, &cb) != ERROR_SUCCESS)
    {
        // Set the Default Value
        pInfo->fDisplaySourceFilePaths = FALSE;
        SideAssert(RegSetValueEx(hRegKey, pNames->pszDisplaySourceFilePaths, 0, REG_DWORD, (LPBYTE)&pInfo->fDisplaySourceFilePaths, sizeof(DWORD)) == ERROR_SUCCESS);
    }

    // Open the file...
    if (LOGTYPE_BOTH == pInfo->logtype || LOGTYPE_FILE == pInfo->logtype)
    {
        // Open the logfile
        if (FAILED(OpenFileStreamShare(pInfo->szLogfilePath, pInfo->fResetLogfile ? CREATE_ALWAYS : OPEN_ALWAYS, 
                                       GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, &pInfo->pStmFile)))
        {
            // Switch Logtype
            Assert(FALSE);
            pInfo->logtype = LOGTYPE_OUTPUT;
        }

        // Launch LogWatcher ?
        if (pInfo->pStmFile && pInfo->fLaunchLogWatcher)
        {
            // Locals
            STARTUPINFO         rStart;
            PROCESS_INFORMATION rProcess;
            LPSTR               pszCmdLine;

            // Init process info
            ZeroMemory(&rProcess, sizeof(PROCESS_INFORMATION));

            // Init Startup info
            ZeroMemory(&rStart, sizeof(STARTUPINFO));
            rStart.cb = sizeof(STARTUPINFO);
            rStart.wShowWindow = SW_NORMAL;

            // Create the command line
            DWORD cchSize = (lstrlen(pInfo->szLogWatchFilePath) + lstrlen(pInfo->szLogfilePath) + 2);
            pszCmdLine = (LPSTR)g_pMalloc->Alloc(cchSize);
            Assert(pszCmdLine);
            wnsprintf(pszCmdLine, cchSize, "%s %s", pInfo->szLogWatchFilePath, pInfo->szLogfilePath);

            // Create the process...
            CreateProcess(pInfo->szLogWatchFilePath, pszCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &rStart, &rProcess);

            // Cleanup
            g_pMalloc->Free(pszCmdLine);
        }
    }
}

// --------------------------------------------------------------------------------
// ReadTraceItemTable
// --------------------------------------------------------------------------------
void ReadTraceItemTable(
        IN          HKEY                    hKeyRoot,
        IN          LPCSTR                  pszSubKey,
        OUT         LPTRACEITEMTABLE        pTable)
{
    // Locals
    HKEY        hSubKey=NULL;
    ULONG       cbMax;
    ULONG       i;
    ULONG       cb;
    LONG        lResult;

    // Invalid Arg
    Assert(hKeyRoot && pszSubKey && pTable);

    // Init
    ZeroMemory(pTable, sizeof(TRACEITEMTABLE));

    // Open pszRegRoot
    if (RegOpenKeyEx(hKeyRoot, pszSubKey, 0, KEY_ALL_ACCESS, &hSubKey) != ERROR_SUCCESS)
    {
        // Lets create the subkey
        if (RegCreateKeyEx(hKeyRoot, pszSubKey, 0, NULL, NULL, KEY_ALL_ACCESS, NULL, &hSubKey, &cbMax) != ERROR_SUCCESS)
        {
            Assert(FALSE);
            return;
        }
    }

    // Count SubItems
    if (RegQueryInfoKey(hSubKey, NULL, NULL, NULL, &pTable->cItems, &cbMax, NULL, NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
    {
        pTable->cItems = 0;
        goto exit;
    }

    // No Items
    if (0 == pTable->cItems)
        goto exit;

    // Check
    AssertSz(cbMax < MAX_PATH, "Name is longer than MAX_PATH.");

    // Allocate an Array
    pTable->prgItem = (LPTRACEITEMINFO)g_pMalloc->Alloc(pTable->cItems * sizeof(TRACEITEMINFO));

    // Init
    ZeroMemory(pTable->prgItem, pTable->cItems * sizeof(TRACEITEMINFO));

    // Loop through the subkeys
    for (i=0; i<pTable->cItems; i++)
    {
        // Allocate
        pTable->prgItem[i].pszName = (LPSTR)g_pMalloc->Alloc(cbMax + 10);
        Assert(pTable->prgItem[i].pszName);

        // Set max size
        lResult = RegEnumKeyEx(hSubKey, i, pTable->prgItem[i].pszName, &cb, NULL, NULL, NULL, NULL);

        // Done or failure
        if (lResult == ERROR_NO_MORE_ITEMS)
            break;
        else if (lResult != ERROR_SUCCESS)
        {
            Assert(FALSE);
            continue;
        }

        // Save Length of Name
        pTable->prgItem[i].cchName = lstrlen(pTable->prgItem[i].pszName);
    }

exit:
    // Cleanup
    if (hSubKey)
        RegCloseKey(hSubKey);
}

// --------------------------------------------------------------------------------
// CDebugTrace::CDebugTrace
// --------------------------------------------------------------------------------
CDebugTrace::CDebugTrace(DWORD dwTraceId, LPCSTR pszFilePath, ULONG ulLine, LPCSTR pszFunction, LPCSTR pszTag, LPCSTR pszMessage)
{
    // Get Component Information
    m_pComponent = (LPTRACECOMPONENTINFO)dwTraceId;

    // Invalid Arg
    Assert(pszFilePath && pszFunction);

    // Save Function and File Name
    m_pszFunction = pszFunction;
    m_pszFilePath = pszFilePath;
    m_pszFileName = NULL;
    m_ulCallLine = ulLine;
    m_pThreadDefault = NULL;
    m_dwTickEnter = GetTickCount();

    // Get thread information
    m_pThread = PGetCurrentTraceThread();
    if (NULL == m_pThread)
    {
        // Allocate a default thread info object
        m_pThreadDefault = (LPTRACETHREADINFO)g_pMalloc->Alloc(sizeof(TRACETHREADINFO));

        // Zero init
        ZeroMemory(m_pThreadDefault, sizeof(TRACETHREADINFO));

        // Set thread id, name and stack depth
        m_pThreadDefault->dwThreadId = GetCurrentThreadId();
        m_pThreadDefault->pszName = "_Unknown_";
        m_pThreadDefault->cStackDepth = 0;

        // Save a current thread information
        m_pThread = m_pThreadDefault;
    }

    // Save Stack Depth
    m_cStackDepth = m_pThread->cStackDepth;

    // Are we tracing
    m_fTracing = _FIsTraceEnabled(pszTag);

    // Should we log this ?
    if (m_fTracing && m_pComponent && m_pComponent->fTraceCalls)
    {
        // Output some information
        if (pszMessage)
            _OutputDebugText(NULL, ulLine, "ENTER: %s - %s\r\n", m_pszFunction, pszMessage);
        else
            _OutputDebugText(NULL, ulLine, "ENTER: %s\r\n", m_pszFunction);
    }

    // Increment Stack Depth
    m_pThread->cStackDepth++;
}

// --------------------------------------------------------------------------------
// CDebugTrace::~CDebugTrace
// --------------------------------------------------------------------------------
CDebugTrace::~CDebugTrace(void)
{
    // Invalid Arg
    Assert(m_pThread);

    // Decrement Stack Depth
    m_pThread->cStackDepth--;

    // Did we trace the call
    if (m_fTracing && m_pComponent && m_pComponent->fTraceCalls)
    {
        // Output some information
        _OutputDebugText(NULL, m_ulCallLine, "LEAVE: %s (Inc.Time: %d ms)\r\n", m_pszFunction, ((GetTickCount() - m_dwTickEnter)));
    }

    // Cleanup
    SafeMemFree(m_pThreadDefault);
}

// --------------------------------------------------------------------------------
// CDebugTrace::_FIsTraceEnabled
// --------------------------------------------------------------------------------
BOOL CDebugTrace::_FIsTraceEnabled(LPCSTR pszTag)
{
    // No Component
    if (NULL == m_pComponent)
        return FALSE;

    // No tracing enabled
    if (TRACE_NONE == m_pComponent->tracetype)
        return FALSE;

    // Trace Everything
    if (TRACE_EVERYTHING == m_pComponent->tracetype)
        return TRUE;

    // Is current inforamtion registered
    return _FIsRegistered(pszTag);
}

// --------------------------------------------------------------------------------
// CDebugTrace::_FIsRegistered
// --------------------------------------------------------------------------------
BOOL CDebugTrace::_FIsRegistered(LPCSTR pszTag)
{
    // Locals
    ULONG i;

    // No Component
    if (NULL == m_pComponent)
        return FALSE;

    // Search Registered Classes
    for (i=0; i<m_pComponent->rClasses.cItems; i++)
    {
        // Better have a name
        Assert(m_pComponent->rClasses.prgItem[i].pszName);

        // Compare CClass:: to m_pszFunction
        if (StrCmpN(m_pszFunction, m_pComponent->rClasses.prgItem[i].pszName, m_pComponent->rClasses.prgItem[i].cchName) == 0)
            return TRUE;
    }

    // Search Registered Functions
    for (i=0; i<m_pComponent->rFunctions.cItems; i++)
    {
        // Better have a name
        Assert(m_pComponent->rFunctions.prgItem[i].pszName);

        // Compare CClass:: to m_pszFunction
        if (lstrcmp(m_pszFunction, m_pComponent->rFunctions.prgItem[i].pszName) == 0)
            return TRUE;
    }

    // Get a filename
    if (NULL == m_pszFileName)
        m_pszFileName = PathFindFileName(m_pszFilePath);

    // Search Registered Files
    for (i=0; i<m_pComponent->rFiles.cItems; i++)
    {
        // Better have a name
        Assert(m_pComponent->rFiles.prgItem[i].pszName);

        // Compare CClass:: to m_pszFunction
        if (lstrcmp(m_pszFileName, m_pComponent->rFiles.prgItem[i].pszName) == 0)
            return TRUE;
    }

    // Does this thread have a name
    if (m_pThread->pszName)
    {
        // Search Registered Threads
        for (i=0; i<m_pComponent->rThreads.cItems; i++)
        {
            // Better have a name
            Assert(m_pComponent->rThreads.prgItem[i].pszName);

            // Compare CClass:: to m_pszFunction
            if (lstrcmp(m_pThread->pszName, m_pComponent->rThreads.prgItem[i].pszName) == 0)
                return TRUE;
        }
    }

    // Search Tagged Items
    if (pszTag)
    {
        for (i=0; i<m_pComponent->rTagged.cItems; i++)
        {
            // Better have a name
            Assert(m_pComponent->rTagged.prgItem[i].pszName);

            // Compare CClass:: to m_pszFunction
            if (lstrcmp(pszTag, m_pComponent->rTagged.prgItem[i].pszName) == 0)
                return TRUE;
        }
    }

    // Don't log it
    return FALSE;
}

// --------------------------------------------------------------------------------
// CDebugTrace::_OutputDebugText
// --------------------------------------------------------------------------------
void CDebugTrace::_OutputDebugText(CLogFile *pLog, ULONG ulLine, LPSTR pszFormat, ...)
{
    // Locals
    va_list         arglist;
    ULONG           cchOutput;
    LPCSTR          pszFile;
    CHAR            szIndent[512];

    // Should we output anything
    if (NULL == m_pComponent || (m_pComponent->logtype == LOGTYPE_NONE && NULL == pLog))
        return;

    // Format the string
    va_start(arglist, pszFormat);
    wvnsprintf(m_pThread->szBuffer, ARRAYSIZE(m_pThread->szBuffer), pszFormat, arglist);
    va_end(arglist);

    // Write Header
    if (m_pComponent->fDisplaySourceFilePaths)
        pszFile = m_pszFilePath;
    else
    {
        // Get a filename
        if (NULL == m_pszFileName)
        {
            // Parse out the filename
            m_pszFileName = PathFindFileName(m_pszFilePath);
            if (NULL == m_pszFileName)
                m_pszFileName = m_pszFilePath;
        }

        // Use just a filename
        pszFile = m_pszFileName;
    }

    // Setup Indent
    if (m_pComponent->fTraceCalls && m_pComponent->fTraceCallIndent)
    {
        // Assert that we have enough room
        Assert(m_cStackDepth * 4 <= sizeof(szIndent));

        // Setup the indent
        FillMemory(szIndent, m_cStackDepth * 4, ' ');

        // Insert a null
        szIndent[m_cStackDepth * 4] = '\0';
    }
    else
        *szIndent = '\0';

    // Build the string
    cchOutput = wnsprintf(m_pThread->szOutput, ARRAYSIZE(m_pThread->szOutput), "0x%08X: %s: %s(%05d) %s%s", m_pThread->dwThreadId, m_pComponent->pszComponent, pszFile, ulLine, szIndent, m_pThread->szBuffer);
    Assert(cchOutput < sizeof(m_pThread->szOutput));

    // Output to vc window
    if (LOGTYPE_OUTPUT == m_pComponent->logtype || LOGTYPE_BOTH == m_pComponent->logtype)
        OutputDebugString(m_pThread->szOutput);

    // Output to file
    if (LOGTYPE_FILE == m_pComponent->logtype || LOGTYPE_BOTH == m_pComponent->logtype)
        m_pComponent->pStmFile->Write(m_pThread->szOutput, cchOutput, NULL);

    // LogFile
    if (pLog)
        pLog->DebugLog(m_pThread->szOutput);
}

// --------------------------------------------------------------------------------
// CDebugTrace::TraceInfo
// --------------------------------------------------------------------------------
void CDebugTrace::TraceInfoImpl(ULONG ulLine, LPCSTR pszMessage, CLogFile *pLog)
{
    // Should we log this ?
    if (m_fTracing && m_pComponent && m_pComponent->fTraceInfo)
    {
        // Output some information
        if (pszMessage)
            _OutputDebugText(pLog, ulLine, "INFO: %s - %s\r\n", m_pszFunction, pszMessage);
        else
            _OutputDebugText(pLog, ulLine, "INFO: %s\r\n", m_pszFunction);
    }
}

// ----------------------------------------------------------------------------
// CDebugTrace::TraceResult
// ----------------------------------------------------------------------------
HRESULT CDebugTrace::TraceResultImpl(ULONG ulLine, HRESULT hrResult, LPCSTR pszMessage, CLogFile *pLog)
{
    // Output some information
    if (pszMessage)
        _OutputDebugText(pLog, ulLine, "RESULT: %s - HRESULT(0x%08X) - GetLastError() = %d - %s\r\n", m_pszFunction, hrResult, GetLastError(), pszMessage);
    else
        _OutputDebugText(pLog, ulLine, "RESULT: %s - HRESULT(0x%08X) - GetLastError() = %d\r\n", m_pszFunction, hrResult, GetLastError());

    // Done
    return hrResult;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\oertpriv.h ===
// --------------------------------------------------------------------------------
// Oertpriv.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __OERTPRIV_H
#define __OERTPRIV_H

// --------------------------------------------------------------------------------
// Stream Utilitys
// --------------------------------------------------------------------------------
HRESULT HrCopyStream2(LPSTREAM lpstmIn, LPSTREAM lpstmOut1, LPSTREAM lpstmOut2, ULONG *pcb);
HRESULT HrCopyStreamToFile(LPSTREAM lpstm, HANDLE hFile, ULONG *pcb);
BOOL    CreateHGlobalFromStream(LPSTREAM pstm, HGLOBAL *phg);
BOOL    FDoesStreamContain8bit(LPSTREAM lpstm);

// --------------------------------------------------------------------------------
// FILESTREAMINFO
// --------------------------------------------------------------------------------
typedef struct tagFILESTREAMINFO {
    WCHAR           szFilePath[MAX_PATH];
    DWORD           dwDesiredAccess;
    DWORD           dwShareMode;
    SECURITY_ATTRIBUTES rSecurityAttributes;
    DWORD           dwCreationDistribution;
    DWORD           dwFlagsAndAttributes;
    HANDLE          hTemplateFile;
} FILESTREAMINFO, *LPFILESTREAMINFO;

// --------------------------------------------------------------------------------
// CFileStream
// --------------------------------------------------------------------------------
class CFileStream : public IStream
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CFileStream(void);
    ~CFileStream(void);

    // ----------------------------------------------------------------------------
    // IUnknown Members
    // ----------------------------------------------------------------------------
    STDMETHODIMP_(ULONG) AddRef(VOID);
    STDMETHODIMP_(ULONG) Release(VOID);
    STDMETHODIMP QueryInterface(REFIID, LPVOID*);

    // ----------------------------------------------------------------------------
    // IStream Members
    // ----------------------------------------------------------------------------
    STDMETHODIMP Read(void HUGEP_16 *, ULONG, ULONG*);
    STDMETHODIMP Write(const void HUGEP_16 *, ULONG, ULONG*);
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER*);
    STDMETHODIMP SetSize(ULARGE_INTEGER);
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER*, ULARGE_INTEGER*);
    STDMETHODIMP Commit(DWORD);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER,DWORD);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD);
    STDMETHODIMP Stat(STATSTG*, DWORD);
    STDMETHODIMP Clone(LPSTREAM*);

    // ----------------------------------------------------------------------------
    // CFileStream Members
    // ----------------------------------------------------------------------------
    HRESULT Open(LPFILESTREAMINFO pFileStreamInfo);
    void Close(void);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    ULONG                  m_cRef;
    HANDLE                 m_hFile;
    FILESTREAMINFO         m_rInfo;
};

// --------------------------------------------------------------------------------
// String Utilitys
// --------------------------------------------------------------------------------
VOID    StripUndesirables(LPTSTR psz);
LPSTR   PszDupLenA(LPCSTR pcszSource, ULONG nLen);
BOOL    FValidFileChar(CHAR c);
LPWSTR  PszFromANSIStreamW(UINT cp, LPSTREAM pstm);
TCHAR   ToUpper(TCHAR c);
int     IsXDigit(LPSTR psz);
int     IsUpper(LPSTR psz);
int     IsAlpha(LPSTR psz);
int     IsPunct(LPSTR psz);
LPSTR   strsave(char *);
void    strappend(char **, char *);
BOOL    FIsValidRegKeyNameA(LPSTR pwszKey);
BOOL    FIsValidRegKeyNameW(LPWSTR pwszKey);
void    ThreadAllocateTlsMsgBuffer(void);
void    ThreadFreeTlsMsgBuffer(void);

#ifdef UNICODE
#define FIsValidRegKeyName FIsValidRegKeyNameW
#else
#define FIsValidRegKeyName FIsValidRegKeyNameA
#endif

#endif // __OERTPRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\oenotify.h ===
//+-------------------------------------------------------------------------
// Notify.h
//--------------------------------------------------------------------------
#ifndef __OENOTIFY_H
#define __OENOTIFY_H

#include <notify.h>

//+-------------------------------------------------------------------------
// CNotify
//--------------------------------------------------------------------------
class CNotify : public INotify
{
public:
    //+---------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CNotify(void);
    ~CNotify(void);

    //+---------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //+---------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    STDMETHODIMP Initialize(LPCSTR pszName);
    STDMETHODIMP Register(HWND hwndNotify, HWND hwndThunk, BOOL fExternal);
    STDMETHODIMP Unregister(HWND hwndNotify);
    STDMETHODIMP Lock(HWND hwnd);
    STDMETHODIMP Unlock(void);
    STDMETHODIMP NotificationNeeded(void);
    STDMETHODIMP DoNotification(UINT uWndMsg, WPARAM wParam, LPARAM lParam, DWORD dwFlags);

private:
    //+---------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;         // Reference Count
    HANDLE              m_hMutex;       // Handle to the memory mapped file mutex
    HANDLE              m_hFileMap;     // Handle to the memory mapped file
    LPNOTIFYWINDOWTABLE m_pTable;       // Pointer into memory mapped file view
    BOOL                m_fLocked;      // This object is currently in m_hMutex
    HWND                m_hwndLock;     // hwnd that called ::Lock
};

#endif // __NOTIFY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\oenotify.cpp ===
#include "pch.hxx"
#include <notify.h>
#include "oenotify.h"
#include <BadStrFunctions.h>

//+-------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT WriteStructInfo(LPSTREAM pStream, LPCSTRUCTINFO pStruct);
HRESULT ReadBuildStructInfoParam(LPSTREAM pStream, LPSTRUCTINFO pStruct);

#ifdef DEBUG
BOOL ByteCompare(LPBYTE pb1, LPBYTE pb2, ULONG cb);
void DebugValidateStructInfo(LPCSTRUCTINFO pStruct);
#endif

static const char c_szMutex[] = "mutex";
static const char c_szMappedFile[] = "mappedfile";

OESTDAPI_(HRESULT) CreateNotify(INotify **ppNotify)
    {
    CNotify *pNotify;

    Assert(ppNotify != NULL);

    pNotify = new CNotify;

    *ppNotify = (INotify *)pNotify;

    return(pNotify == NULL ? E_OUTOFMEMORY : S_OK);
    }

//+-------------------------------------------------------------------------
// CNotify::CNotify
//--------------------------------------------------------------------------
CNotify::CNotify(void)
{
    TraceCall("CNotify::CNotify");
    m_cRef = 1;
    m_hMutex = NULL;
    m_hFileMap = NULL;
    m_pTable = NULL;
    m_fLocked = FALSE;
    m_hwndLock = NULL;
}

//+-------------------------------------------------------------------------
// CNotify::~CNotify
//--------------------------------------------------------------------------
CNotify::~CNotify(void)
{
    TraceCall("CNotify::~CNotify");
    Assert(!m_fLocked);
    if (m_pTable)
        UnmapViewOfFile(m_pTable);
    SafeCloseHandle(m_hFileMap);
    SafeCloseHandle(m_hMutex);
}

//+-------------------------------------------------------------------------
// CNotify::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CNotify::AddRef(void)
{
    TraceCall("CNotify::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//+-------------------------------------------------------------------------
// CNotify::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CNotify::Release(void)
{
    TraceCall("CNotify::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//+-------------------------------------------------------------------------
// CNotify::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CNotify::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("CNotify::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return hr;
}

//+-------------------------------------------------------------------------
// CNotify::Initialize
//-------------------------------------------------------------------------- 
HRESULT CNotify::Initialize(LPCSTR pszName)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszObject=NULL;
    LPSTR       pszT;
    DWORD       dwReturn;
    BOOL        fReleaseMutex=FALSE;

    // Stack
    TraceCall("CNotify::Initialize");

    // Invalid Arg
    Assert(pszName);

    // Already Initialized...
    Assert(NULL == m_hMutex && NULL == m_hFileMap && NULL == m_pTable);

    // Allocate pszObject
    DWORD cchSize = (lstrlen(pszName) + lstrlen(c_szMutex) + 1);
    IF_NULLEXIT(pszObject = PszAllocA(sizeof(pszObject[0]) * cchSize));

    // Make pszObject
    wnsprintf(pszObject, cchSize, "%s%s", pszName, c_szMutex);

    // Create the mutex
    ReplaceChars(pszObject, '\\', '_');
    IF_NULLEXIT(m_hMutex = CreateMutex(NULL, FALSE, pszObject));

    // Lets grab the mutex so we can party with the memory-mapped file
    dwReturn = WaitForSingleObject(m_hMutex, MSEC_WAIT_NOTIFY);
    if (WAIT_OBJECT_0 != dwReturn)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Release mutex on exit
    fReleaseMutex = TRUE;

    // Free pszObject
    g_pMalloc->Free(pszObject);

    // Allocate pszObject
    cchSize = (lstrlen(pszName) + lstrlen(c_szMappedFile) + 1);
    IF_NULLEXIT(pszObject = PszAllocA(sizeof(pszObject[0]) * cchSize));

    // Make pszObject
    wnsprintf(pszObject, cchSize, "%s%s", pszName, c_szMappedFile);

    // Create the memory mapped file using the system swapfile
    ReplaceChars(pszObject, '\\', '_');
    IF_NULLEXIT(m_hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(NOTIFYWINDOWTABLE), pszObject));

    // Map a view of the memory mapped file
    IF_NULLEXIT(m_pTable = (LPNOTIFYWINDOWTABLE)MapViewOfFile(m_hFileMap, FILE_MAP_WRITE, 0, 0, sizeof(NOTIFYWINDOWTABLE)));

exit:
    // Release ?
    if (fReleaseMutex)
        ReleaseMutex(m_hMutex);

    // Cleanup
    SafeMemFree(pszObject);

    // Done
    return hr;
}

//+-------------------------------------------------------------------------
// CNotify::Lock
//-------------------------------------------------------------------------- 
HRESULT CNotify::Lock(HWND hwnd)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwReturn;

    // Stack
    TraceCall("CNotify::Lock");

    // We should not be locked right now
    Assert(FALSE == m_fLocked && NULL != m_hMutex);

    // Grap the Mutex
    dwReturn = WaitForSingleObject(m_hMutex, MSEC_WAIT_NOTIFY);
    if (WAIT_OBJECT_0 != dwReturn)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Save the window and set new state
    m_hwndLock = hwnd;
    m_fLocked = TRUE;

exit:
    // Done
    return hr;
}

//+-------------------------------------------------------------------------
// CNotify::Unlock
//-------------------------------------------------------------------------- 
HRESULT CNotify::Unlock(void)
{
    // Stack
    TraceCall("CNotify::Unlock");

    // We should be locked
    Assert(m_fLocked);

    // Release the mutex
    ReleaseMutex(m_hMutex);

    // Reset state
    m_hwndLock = NULL;
    m_fLocked = FALSE;

    // Done
    return S_OK;
}

//+-------------------------------------------------------------------------
// CNotify::NotificationNeeded - Must have called ::Lock(hwndLock)
//-------------------------------------------------------------------------- 
HRESULT CNotify::NotificationNeeded(void)
{
    // Locals
    HRESULT     hr=S_FALSE;

    // Stack
    TraceCall("CNotify::NotificationNeeded");

    // We should be locked
    Assert(m_fLocked);

    // If there are no windows...
    if (0 == m_pTable->cWindows)
        goto exit;

    // If there is only one registered window and its m_hwndLock...
    if (1 == m_pTable->cWindows && m_pTable->rgWindow[0].hwndNotify && m_hwndLock == m_pTable->rgWindow[0].hwndNotify)
        goto exit;

    // Otherwise, we need to do a notification
    hr = S_OK;

exit:
    // Done
    return hr;
}

//+-------------------------------------------------------------------------
// CNotify::Register
//-------------------------------------------------------------------------- 
HRESULT CNotify::Register(HWND hwndNotify, HWND hwndThunk, BOOL fExternal)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwReturn;
    ULONG           i;
    LPNOTIFYWINDOW  pEntry=NULL;
    LPNOTIFYWINDOW  pRow;
    BOOL            fReleaseMutex=FALSE;

    // Stack
    TraceCall("CNotify::Register");

    // Invalid Arg
    Assert(hwndThunk && IsWindow(hwndThunk) && hwndNotify && IsWindow(hwndNotify));
// FIX by having hwndNotify created on an HTML that won't be destroyed when one of the windows goes away.

    // Validate the state
    Assert(m_pTable && m_hMutex && m_hFileMap && FALSE == m_fLocked);

    // Grap the mutex
    dwReturn = WaitForSingleObject(m_hMutex, MSEC_WAIT_NOTIFY);
    if (WAIT_OBJECT_0 != dwReturn)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Release the mutex
    fReleaseMutex = TRUE;

    // Lets try to use an empty entry in the table first
    for (i=0; i<m_pTable->cWindows; i++)
    {
        // Readability
        pRow = &m_pTable->rgWindow[i];

        // Is this not empty ?
        if (NULL == pRow->hwndThunk || NULL == pRow->hwndNotify || !IsWindow(pRow->hwndThunk) || !IsWindow(pRow->hwndNotify))
        {
            pEntry = pRow;
            break;
        }
    }
    
    // If we didn't find an entry yet, lets add into the end
    if (NULL == pEntry)
    {
        // If we still have room
        if (m_pTable->cWindows >= CMAX_HWND_NOTIFY)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Append
        pEntry = &m_pTable->rgWindow[m_pTable->cWindows];
        m_pTable->cWindows++;
    }

    // Set pEntry
    Assert(pEntry);
    pEntry->hwndThunk = hwndThunk;
    pEntry->hwndNotify = hwndNotify;
    pEntry->fExternal = fExternal;

exit:
    // Release Mutex ?
    if (fReleaseMutex)
        ReleaseMutex(m_hMutex);

    // Done
    return hr;
}

//+-------------------------------------------------------------------------
// CNotify::Unregister
//-------------------------------------------------------------------------- 
HRESULT CNotify::Unregister(HWND hwndNotify)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwReturn;
    ULONG           i;
    LPNOTIFYWINDOW  pEntry=NULL;
    LPNOTIFYWINDOW  pRow;
    BOOL            fReleaseMutex=FALSE;

    // Stack
    TraceCall("CNotify::Unregister");

    // Invalid Arg
    Assert(hwndNotify && IsWindow(hwndNotify));

    // Validate the state
    Assert(m_pTable && m_hMutex && m_hFileMap && FALSE == m_fLocked);

    // Grap the mutex
    dwReturn = WaitForSingleObject(m_hMutex, MSEC_WAIT_NOTIFY);
    if (WAIT_OBJECT_0 != dwReturn)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Release the mutex
    fReleaseMutex = TRUE;

    // Lets try to use an empty entry in the table first
    for (i=0; i<m_pTable->cWindows; i++)
    {
        // Readability
        pRow = &m_pTable->rgWindow[i];

        // Is this the row
        // HWNDs are unique so only need to check notify window for match
        if (hwndNotify == pRow->hwndNotify)
        {
            pRow->hwndThunk = NULL;
            pRow->hwndNotify = NULL;
            break;
        }
    }
    
exit:
    // Release Mutex ?
    if (fReleaseMutex)
        ReleaseMutex(m_hMutex);

    // Done
    return hr;
}

//+-------------------------------------------------------------------------
// CNotify::DoNotification
//-------------------------------------------------------------------------- 
HRESULT CNotify::DoNotification(UINT uWndMsg, WPARAM wParam, LPARAM lParam, DWORD dwFlags)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               dwThisProcess;
    DWORD               dwNotifyProcess;
    DWORD               dwResult;
    LPNOTIFYWINDOW      pRow;
    ULONG               i;
    DWORD_PTR           dw;
    NOTIFYDATA          rNotify;

    // Stack
    TraceCall("CNotify::DoNotify");

    // State
    Assert(m_fLocked);

    // Get this process Id
    dwThisProcess = GetCurrentProcessId();

    // Lets try to use an empty entry in the table first
    for (i=0; i<m_pTable->cWindows; i++)
    {
        // Readability
        pRow = &m_pTable->rgWindow[i];

        // If the notify window is valid
        if (NULL == pRow->hwndNotify || !IsWindow(pRow->hwndNotify))
            continue;

        // Skip the window that locked this notify
        if (m_hwndLock == pRow->hwndNotify)
            continue;

        // Get the process in which the destination window resides
        GetWindowThreadProcessId(pRow->hwndNotify, &dwNotifyProcess);

        // Initialize Notify Info
        ZeroMemory(&rNotify, sizeof(NOTIFYDATA));

        // Set notification window
        rNotify.hwndNotify = pRow->hwndNotify;

        // Allow for callback to remap wParam and lParam
        if (ISFLAGSET(dwFlags, SNF_CALLBACK))
        {
            // Call callback function
            IF_FAILEXIT(hr = ((PFNNOTIFYCALLBACK)wParam)(lParam, &rNotify, (BOOL)(dwThisProcess != dwNotifyProcess), pRow->fExternal));
        }

        // Otherwise, setup rNotifyInfo myself
        else
        {
            // Setup NOtification
            rNotify.msg = uWndMsg;
            rNotify.wParam = wParam;
            rNotify.lParam = lParam;
        }

        // Set the current Flags
        rNotify.dwFlags |= dwFlags;

        // No Cross-Process
        if (dwThisProcess != dwNotifyProcess && !ISFLAGSET(rNotify.dwFlags, SNF_CROSSPROCESS))
            continue;

        // If the notify window is out of process
        if (dwThisProcess != dwNotifyProcess && ISFLAGSET(rNotify.dwFlags, SNF_HASTHUNKINFO))
        {
            // Thunk the notification to another process
            Assert(rNotify.rCopyData.lpData);
            SendMessageTimeout(pRow->hwndThunk, WM_COPYDATA, (WPARAM)NULL, (LPARAM)&rNotify.rCopyData, SMTO_ABORTIFHUNG, 1500, &dw);

            // Un-register
            if (dw == SNR_UNREGISTER)
            {
                pRow->hwndNotify = NULL;
                pRow->hwndThunk = NULL;
            }

            // Cleanup
            SafeMemFree(rNotify.rCopyData.lpData);
        }

        // Otherwise, its within this process...
        else if (ISFLAGSET(dwFlags, SNF_SENDMSG))
        {
            // Do in-process send message
            if (SendMessage(pRow->hwndNotify, rNotify.msg, rNotify.wParam, rNotify.lParam) == SNR_UNREGISTER)
            {
                pRow->hwndNotify = NULL;
                pRow->hwndThunk = NULL;
            }
        }

        // Otherwise, just do a PostMessage
        else
            PostMessage(pRow->hwndNotify, rNotify.msg, rNotify.wParam, rNotify.lParam);
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------
// HWND pRow->hwndNotify
// ------------------------------------------------------------
// UINT uWndMsg
// ------------------------------------------------------------
// DWORD dwFlags (SNF_xxx)
// ------------------------------------------------------------
// DWORD pParam1->dwFlags
// ------------------------------------------------------------
// DWORD pParam1->cbStruct
// ------------------------------------------------------------
// DWORD pParam1->cMembers
// ------------------------------------------------------------
// Param1 Members (DWORD dwFlags, DWORD cbData, BYTE prgData)
// ------------------------------------------------------------
// DWORD pParam2->dwFlags
// ------------------------------------------------------------
// DWORD pParam2->cbStruct
// ------------------------------------------------------------
// DWORD pParam2->cMembers
// ------------------------------------------------------------
// Param2 Members (DWORD cbType, DWORD cbData, BYTE prgData)
// ------------------------------------------------------------



//+-------------------------------------------------------------------------
// BuildNotificationPackage
//-------------------------------------------------------------------------- 
OESTDAPI_(HRESULT) BuildNotificationPackage(LPNOTIFYDATA pNotify, PCOPYDATASTRUCT pCopyData)
{
    // Locals
    HRESULT         hr=S_OK;
    CByteStream     cStream;

    // Trace
    TraceCall("BuildNotificationPackage");

    // Args
    Assert(pNotify && IsWindow(pNotify->hwndNotify) && pCopyData);

    // Zero the copy data struct
    ZeroMemory(pCopyData, sizeof(COPYDATASTRUCT));

    // Set dwData
    pCopyData->dwData = MSOEAPI_ACDM_NOTIFY;

    // Write hwndNotify
    IF_FAILEXIT(hr = cStream.Write(&pNotify->hwndNotify, sizeof(pNotify->hwndNotify), NULL));

    // Write uWndMsg
    IF_FAILEXIT(hr = cStream.Write(&pNotify->msg, sizeof(pNotify->msg), NULL));

    // Write dwFlags
    IF_FAILEXIT(hr = cStream.Write(&pNotify->dwFlags, sizeof(pNotify->dwFlags), NULL));

    // Write pParam1
    if (ISFLAGSET(pNotify->dwFlags, SNF_VALIDPARAM1))
    {
        IF_FAILEXIT(hr = WriteStructInfo(&cStream, &pNotify->rParam1));
    }

    // Write pParam2
    if (ISFLAGSET(pNotify->dwFlags, SNF_VALIDPARAM2))
    {
        IF_FAILEXIT(hr = WriteStructInfo(&cStream, &pNotify->rParam2));
    }

    // Take the bytes out of the byte stream
    cStream.AcquireBytes(&pCopyData->cbData, (LPBYTE *)&pCopyData->lpData, ACQ_DISPLACE);

exit:
    // Done
    return hr;
}

//+-------------------------------------------------------------------------
// CrackNotificationPackage
//-------------------------------------------------------------------------- 
OESTDAPI_(HRESULT) CrackNotificationPackage(PCOPYDATASTRUCT pCopyData, LPNOTIFYDATA pNotify)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwParam;
    DWORD           cb;
    LPBYTE          pb;
    CByteStream     cStream((LPBYTE)pCopyData->lpData, pCopyData->cbData);

    // Trace
    TraceCall("CrackNotificationPackage");

    // Args
    Assert(pCopyData && pNotify);
    Assert(pCopyData->dwData == MSOEAPI_ACDM_NOTIFY);

    // Init
    ZeroMemory(pNotify, sizeof(NOTIFYDATA));

    // Read hwndNotify
    IF_FAILEXIT(hr = cStream.Read(&pNotify->hwndNotify, sizeof(pNotify->hwndNotify), NULL));

    // Read uWndMsg
    IF_FAILEXIT(hr = cStream.Read(&pNotify->msg, sizeof(pNotify->msg), NULL));

    // Read dwFlags
    IF_FAILEXIT(hr = cStream.Read(&pNotify->dwFlags, sizeof(pNotify->dwFlags), NULL));

    // Read pwParam
    if (ISFLAGSET(pNotify->dwFlags, SNF_VALIDPARAM1))
    {
        // Read It
        IF_FAILEXIT(hr = ReadBuildStructInfoParam(&cStream, &pNotify->rParam1));

        // Set wParam
        pNotify->wParam = (WPARAM)pNotify->rParam1.pbStruct;
    }

    // Read pParam2
    if (ISFLAGSET(pNotify->dwFlags, SNF_VALIDPARAM2))
    {
        // Read It
        IF_FAILEXIT(hr = ReadBuildStructInfoParam(&cStream, &pNotify->rParam2));

        // Set lParam
        pNotify->lParam = (WPARAM)pNotify->rParam2.pbStruct;
    }

exit:
    // pull the bytes back out of cStream so it doesn't try to free it
    cStream.AcquireBytes(&cb, &pb, ACQ_DISPLACE);

    // Done
    return hr;
}

//+-------------------------------------------------------------------------
// WriteStructInfo
//-------------------------------------------------------------------------- 
HRESULT WriteStructInfo(LPSTREAM pStream, LPCSTRUCTINFO pStruct)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMEMBERINFO    pMember;
    ULONG           i;

    // Trace
    TraceCall("WriteStructInfo");

    // Args
    Assert(pStream && pStruct && pStruct->pbStruct);

    // Make sure the structinfo is good
#ifdef DEBUG
    DebugValidateStructInfo(pStruct);
#endif

    // Write dwFlags
    IF_FAILEXIT(hr = pStream->Write(&pStruct->dwFlags, sizeof(pStruct->dwFlags), NULL));

    // Write cbStruct
    IF_FAILEXIT(hr = pStream->Write(&pStruct->cbStruct, sizeof(pStruct->cbStruct), NULL));

    // Write cMembers
    IF_FAILEXIT(hr = pStream->Write(&pStruct->cMembers, sizeof(pStruct->cMembers), NULL));

    // Validate cMembers
    Assert(pStruct->cMembers <= CMAX_STRUCT_MEMBERS);

    // If there are no members
    if (0 == pStruct->cMembers)
    {
        // Better have this flag set
        Assert(ISFLAGSET(pStruct->dwFlags, STRUCTINFO_VALUEONLY));

        // If pointer
        if (ISFLAGSET(pStruct->dwFlags, STRUCTINFO_POINTER))
        {
           IF_FAILEXIT(hr = pStream->Write(pStruct->pbStruct, pStruct->cbStruct, NULL));
        }

        // pStruct->pbStruct contains DWORD sized value
        else
        {
            // Size should be equal to sizeof pbStruct
            Assert(pStruct->cbStruct == sizeof(pStruct->pbStruct));

            // Write It
            IF_FAILEXIT(hr = pStream->Write(&pStruct->pbStruct, sizeof(pStruct->pbStruct), NULL));
        }

        // Done
        goto exit;
    }

    // WriteStructInfoMembers
    for (i=0; i<pStruct->cMembers; i++)
    {
        // Readability
        pMember = (LPMEMBERINFO)&pStruct->rgMember[i];

        // Write pMember->dwFlags
        IF_FAILEXIT(hr = pStream->Write(&pMember->dwFlags, sizeof(pMember->dwFlags), NULL));

        // Validate
        Assert(!ISFLAGSET(pMember->dwFlags, MEMBERINFO_POINTER) ? pMember->cbData <= pMember->cbSize : sizeof(LPBYTE) == pMember->cbSize);

        // Write pMember->cbSize
        IF_FAILEXIT(hr = pStream->Write(&pMember->cbSize, sizeof(pMember->cbSize), NULL));

        // Write pMember->cbData
        IF_FAILEXIT(hr = pStream->Write(&pMember->cbData, sizeof(pMember->cbData), NULL));

        // Write pMember->pbData
        if (pMember->cbData)
        {
            IF_FAILEXIT(hr = pStream->Write(pMember->pbData, pMember->cbData, NULL));
        }
    }

exit:
    // Done
    return hr;
}

//+-------------------------------------------------------------------------
// ReadBuildStructInfoParam
//-------------------------------------------------------------------------- 
HRESULT ReadBuildStructInfoParam(LPSTREAM pStream, LPSTRUCTINFO pStruct)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwOffset=0;
    LPMEMBERINFO    pMember;
    ULONG           i;

    // Trace
    TraceCall("ReadBuildStructInfoParam");

    // Args
    Assert(pStream && pStruct);

    // Init
    ZeroMemory(pStruct, sizeof(STRUCTINFO));

    // Read dwFlags
    IF_FAILEXIT(hr = pStream->Read(&pStruct->dwFlags, sizeof(pStruct->dwFlags), NULL));

    // Read cbStruct
    IF_FAILEXIT(hr = pStream->Read(&pStruct->cbStruct, sizeof(pStruct->cbStruct), NULL));

    // Read cMembers
    IF_FAILEXIT(hr = pStream->Read(&pStruct->cMembers, sizeof(pStruct->cMembers), NULL));

    // If there are no members
    if (0 == pStruct->cMembers)
    {
        // Better have this flag set
        Assert(ISFLAGSET(pStruct->dwFlags, STRUCTINFO_VALUEONLY));

        // If pointer
        if (ISFLAGSET(pStruct->dwFlags, STRUCTINFO_POINTER))
        {
            // Allocate pbStruct
            IF_NULLEXIT(pStruct->pbStruct = (LPBYTE)g_pMalloc->Alloc(pStruct->cbStruct));

            // Read It
            IF_FAILEXIT(hr = pStream->Read(pStruct->pbStruct, pStruct->cbStruct, NULL));
        }

        // pStruct->pbStruct contains DWORD sized value
        else
        {
            // Size should be less than or equal to pbStruct
            Assert(pStruct->cbStruct == sizeof(pStruct->pbStruct));

            // Read the Data
            IF_FAILEXIT(hr = pStream->Read(&pStruct->pbStruct, sizeof(pStruct->pbStruct), NULL));
        }

        // Done
        goto exit;
    }

    // Allocate pbStruct
    IF_NULLEXIT(pStruct->pbStruct = (LPBYTE)g_pMalloc->Alloc(pStruct->cbStruct));

    // Validate cMembers
    Assert(pStruct->cMembers <= CMAX_STRUCT_MEMBERS);

    // ReadStructInfoMembers
    for (i=0; i<pStruct->cMembers; i++)
    {
        // Readability
        pMember = &pStruct->rgMember[i];

        // Write pMember->dwFlags
        IF_FAILEXIT(hr = pStream->Read(&pMember->dwFlags, sizeof(pMember->dwFlags), NULL));

        // Write pMember->cbSize
        IF_FAILEXIT(hr = pStream->Read(&pMember->cbSize, sizeof(pMember->cbSize), NULL));

        // Write pMember->cbData
        IF_FAILEXIT(hr = pStream->Read(&pMember->cbData, sizeof(pMember->cbData), NULL));

        // Validate
        Assert(!ISFLAGSET(pMember->dwFlags, MEMBERINFO_POINTER) ? pMember->cbData <= pMember->cbSize : sizeof(LPBYTE) == pMember->cbSize);

        // Write pMember->pbData
        if (pMember->cbData)
        {
            // Allocate
            IF_NULLEXIT(pMember->pbData = (LPBYTE)g_pMalloc->Alloc(max(pMember->cbSize, pMember->cbData)));

            // Read It
            IF_FAILEXIT(hr = pStream->Read(pMember->pbData, pMember->cbData, NULL));
        }
    }

    // Build pbStruct
    for (i=0; i<pStruct->cMembers; i++)
    {
        // Readability
        pMember = &pStruct->rgMember[i];

        // If not a pointer...
        if (ISFLAGSET(pMember->dwFlags, MEMBERINFO_POINTER))
        {
            // Validate
            Assert(pMember->cbSize == sizeof(LPBYTE));

            // Copy the pointer
            CopyMemory((LPBYTE)(pStruct->pbStruct + dwOffset), &pMember->pbData, sizeof(LPBYTE));
        }

        // Otherwise, its just a value
        else
        {
            // Copy the pointer
            CopyMemory((LPBYTE)(pStruct->pbStruct + dwOffset), pMember->pbData, pMember->cbData);
        }

        // Increment dwOffset
        dwOffset += pMember->cbSize;
    }

    // Validate the structure
#ifdef DEBUG
    DebugValidateStructInfo(pStruct);
#endif

    // Free things that were not referenced by pointer
    for (i=0; i<pStruct->cMembers; i++)
    {
        // Readability
        pMember = &pStruct->rgMember[i];

        // If not a pointer...
        if (!ISFLAGSET(pMember->dwFlags, MEMBERINFO_POINTER))
        {
            // This was copied into pbStruct
            SafeMemFree(pMember->pbData);
        }
    }

exit:
    // Done
    return hr;
}

#ifdef DEBUG
BOOL ByteCompare(LPBYTE pb1, LPBYTE pb2, ULONG cb)
{
    for (ULONG i=0; i<cb; i++)
    {
        if (pb1[i] != pb2[i])
        {
            Assert(FALSE);
            return FALSE;
        }
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
// DebugValidateStructInfo
//-------------------------------------------------------------------------- 
void DebugValidateStructInfo(LPCSTRUCTINFO pStruct)
{
    // Locals
    LPMEMBERINFO    pMember;
    LPBYTE          pb;
    DWORD           dwOffset=0;
    ULONG           i;

    // WriteStructInfoMembers
    for (i=0; i<pStruct->cMembers; i++)
    {
        // Readability
        pMember = (LPMEMBERINFO)&pStruct->rgMember[i];

        // If not a pointer...
        if (ISFLAGSET(pMember->dwFlags, MEMBERINFO_POINTER))
        {
            // If null pointer
            if (ISFLAGSET(pMember->dwFlags, MEMBERINFO_POINTER_NULL))
            {
                Assert(pMember->cbData == 0 && pMember->pbData == NULL);
                CopyMemory(&pb, (LPBYTE)(pStruct->pbStruct + dwOffset), sizeof(LPBYTE));
                Assert(pb == NULL);
            }

            // Otherwise
            else
            {
                // Copy the pointer
                CopyMemory(&pb, (LPBYTE)(pStruct->pbStruct + dwOffset), sizeof(LPBYTE));

                // Compare the memory
                ByteCompare(pb, pMember->pbData, pMember->cbData);
            }
        }

        // Otherwise, its a pointer
        else
        {
            // Compare
            ByteCompare((LPBYTE)(pStruct->pbStruct + dwOffset), pMember->pbData, pMember->cbData);
        }

        // Increment offset
        dwOffset += pMember->cbSize;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\rasutil.cpp ===
// --------------------------------------------------------------------------------
// Rasutil.cpp
// --------------------------------------------------------------------------------
#include "pch.hxx"
#ifndef MAC
#include <windowsx.h>
#include <imnxport.h>
#include <rasdlg.h>
#include "demand.h"
#include <BadStrFunctions.h>

typedef BOOL (*PFRED)(LPTSTR, LPTSTR, LPRASENTRYDLG);

// --------------------------------------------------------------------------------
// HrFillRasCombo
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrFillRasCombo(HWND hwndComboBox, BOOL fUpdateOnly, DWORD *pdwRASResult)
{
    // Locals
    HRESULT         hr=S_OK;
    LPRASENTRYNAME  pEntry=NULL;
    DWORD           dwSize,
                    cEntries,
                    i,
                    dwError;
    INT             iSel;

    // Update Only
    if (!fUpdateOnly)
        SendMessage(hwndComboBox, CB_RESETCONTENT,0,0);
    
    // Allocate RASENTRYNAME
    dwSize = sizeof(RASENTRYNAME);
    CHECKHR(hr = HrAlloc((LPVOID*)&pEntry, dwSize));
    
    // Ver stamp the entry
    pEntry->dwSize = sizeof(RASENTRYNAME);
    cEntries = 0;
    dwError = RasEnumEntries(NULL, NULL, pEntry, &dwSize, &cEntries);
    if (dwError == ERROR_BUFFER_TOO_SMALL)
    {
        SafeMemFree(pEntry);
        CHECKHR(hr = HrAlloc((LPVOID *)&pEntry, dwSize));
        pEntry->dwSize = sizeof(RASENTRYNAME);
        cEntries = 0;
        dwError = RasEnumEntries(NULL, NULL, pEntry, &dwSize, &cEntries);        
    }

    // Error ?
    if (dwError)
    {
        if (pdwRASResult)
            *pdwRASResult = dwError;
        hr = TrapError(IXP_E_RAS_ERROR);
        goto exit;
    }

    // Loop through the entries
    for (i=0; i<cEntries; i++)
    {
        // Not Updating...
        if (!fUpdateOnly)
            SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)(pEntry[i].szEntryName));

        // Updating Combo
        else
        {
            if (ComboBox_FindStringExact(hwndComboBox, 0, pEntry[i].szEntryName) < 0)
            {
                iSel = ComboBox_AddString(hwndComboBox, pEntry[i].szEntryName);
                Assert(iSel >= 0);
                ComboBox_SetCurSel(hwndComboBox, iSel);
            }
        }
    }

exit:    
    // Cleanup
    SafeMemFree(pEntry);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// EditPhonebookEntry
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrEditPhonebookEntry(HWND hwnd, LPTSTR pszEntryName, DWORD *pdwRASResult)
{
    // Locals
    DWORD dwError = NO_ERROR;

    if (S_OK == IsPlatformWinNT())
    {
        HMODULE hRasDlg = NULL;

        hRasDlg = LoadLibrary("rasdlg.dll");
        if (hRasDlg)
        {
            PFRED pfred = NULL;

            pfred = (PFRED)GetProcAddress(hRasDlg, TEXT("RasEntryDlgA"));
            if (pfred)
            {
                RASENTRYDLG info;

                ZeroMemory(&info, sizeof(RASENTRYDLG));
                info.dwSize = sizeof(RASENTRYDLG);
                info.hwndOwner = hwnd;

                // Edit phone book entry
                pfred(NULL, pszEntryName, &info);

                dwError = info.dwError;
            }
            else
            {
                dwError = GetLastError();
            }
            FreeLibrary(hRasDlg);
        }
        else
        {
            dwError = GetLastError();
        }
    }
    else
    {
        // Edit phone book entry
        dwError = RasEditPhonebookEntry(hwnd, NULL, pszEntryName);
    }

    if (dwError)
    {
        if (pdwRASResult)
            *pdwRASResult = dwError;
        return TrapError(IXP_E_RAS_ERROR);
    }
    else
    {
        // Done
        return S_OK;
    }
}

// --------------------------------------------------------------------------------
// HrCreatePhonebookEntry
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrCreatePhonebookEntry(HWND hwnd, DWORD *pdwRASResult)
{
    // Locals
    DWORD dwError = NO_ERROR;

    if (S_OK == IsPlatformWinNT())
    {
        HMODULE hRasDlg = NULL;

        hRasDlg = LoadLibrary("rasdlg.dll");
        if (hRasDlg)
        {
            PFRED pfred = NULL;

            pfred = (PFRED)GetProcAddress(hRasDlg, TEXT("RasEntryDlgA"));
            if (pfred)
            {
                RASENTRYDLG info;

                ZeroMemory(&info, sizeof(RASENTRYDLG));
                info.dwSize = sizeof(RASENTRYDLG);
                info.hwndOwner = hwnd;
                info.dwFlags = RASEDFLAG_NewEntry;

                // Create Phonebook entry
                pfred(NULL, NULL, &info);

                dwError = info.dwError;
            }
            else
            {
                dwError = GetLastError();
            }
            FreeLibrary(hRasDlg);
        }
        else
        {
            dwError = GetLastError();
        }
    }
    else
    {
        // Create Phonebook entry
        dwError = RasCreatePhonebookEntry(hwnd, NULL);
    }

    if (dwError)
    {
        if (pdwRASResult)
            *pdwRASResult = dwError;
        return TrapError(IXP_E_RAS_ERROR);
    }
    else
    {
        // Done
        return S_OK;
    }
}
#endif  // !MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\oertutil.cpp ===
// --------------------------------------------------------------------------------
// OERTUTIL.CPP
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"

#undef BADSTRFUNCTIONS_H
#undef lstrcpyA
#undef lstrcpy
#define lstrcpy lstrcpyA
#include <BadStrFunctions.h>

#include "strconst.h"
#include <shlwapi.h>
#include <shlwapip.h>
#include <richedit.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <mshtmhst.h>
#include "demand.h"
#include "hotwiz.h"
#include "unicnvrt.h"
#include "comctrlp.h"

int BrowseCallbackProcA(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData);
int BrowseCallbackProcW(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData);

typedef struct tagBROWSEFOLDERINFOA
{
    LPCSTR psz;
    BOOL fFileSysOnly;
} BROWSEFOLDERINFOA;

typedef struct tagBROWSEFOLDERINFOW
{
    LPCWSTR pwsz;
    BOOL fFileSysOnly;
} BROWSEFOLDERINFOW;

//// YST FIX
// This function returns unique and  unpredictable path for temporary files.
// It fixes some security problem when hacker can run ActiveSetup in known directory, when user open attachment.
// For fix this we try to save temporery attachment file in unknown directory: in URL Cache dir.
// This function returns only directory name and user must create and remove file by self.
// it has also theoretical possibility to loose data at time 

DWORD AthGetTempUniquePathW( DWORD   nBufferLength,  // size, in characters, of the buffer
                       LPWSTR  pwszBuffer )      // pointer to buffer for temp. path
{
    DWORD  nRequired = 0;
    CHAR   szBuffer[MAX_PATH + 20];
    LPWSTR  pwszBufferToFree = NULL;
    CHAR       pszFilePath[MAX_PATH + 1];
    CHAR        szFileName[MAX_PATH];
    LPSTR       pszFile = NULL;
    LPSTR       pszExt = NULL;


    Assert(pwszBuffer);

    //1. Create unique temp file name
    // Get Temp Dir
    if(0 == GetTempPathA(ARRAYSIZE(szBuffer), szBuffer))
        goto err;
    
    if (0 == GetTempFileName(szBuffer, "wbk", 0, (LPSTR) pszFilePath))
    {
err:
            nRequired = 0;
            *pwszBuffer = 0;
            return(nRequired);
    }
    // Find the filename
    pszFile = PathFindFileName(pszFilePath);

    // Get the Extension
    pszExt = PathFindExtension(pszFilePath);
   
    // Copy fileName
    if (pszExt && pszFile && pszExt >= pszFile)
        StrCpyN(szFileName, pszFile, (DWORD) (min((pszExt - pszFile) + 1, ARRAYSIZE(szFileName))));
    else
        StrCpyN(szFileName, pszFile, ARRAYSIZE(szFileName));


    // 2. Create bigus URL
    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), "http://%s.bogus", szFileName);
    szBuffer[ARRAYSIZE(szBuffer) - 1] = 0;

    // 3. Create bogus URL cache entry
    szFileName[0] = 0;
    if (!CreateUrlCacheEntry(szBuffer, 0, NULL, szFileName, 0))
        goto err;
    
    // DeleteUrlCacheEntry(szFileName);

    // Find path for cache
    pszFile = PathFindFileName(szFileName);
    if(pszFile)
        *pszFile = '\0';

    pwszBufferToFree = PszToUnicode(CP_ACP, szFileName);
    if (pwszBufferToFree)
    {
        nRequired = lstrlenW(pwszBufferToFree);

        if ( nRequired < nBufferLength) 
            CopyMemory(pwszBuffer, pwszBufferToFree, (nRequired+1)*sizeof(WCHAR) );
        else
        {
            nRequired = 0;
            *pwszBuffer = 0;
        }
    }
    else
        *pwszBuffer = 0;

    // Cleanup
    MemFree(pwszBufferToFree);
    DeleteFile(pszFilePath); // GetTempFileName creates file and we need to remove it
    return nRequired;
}


/// END YST FIX

// --------------------------------------------------------------------------------
// GenerateUniqueFileName
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) GenerateUniqueFileName(LPCSTR pszDirectory, LPCSTR pszFileName, LPCSTR pszExtension, 
    LPSTR pszFilePath, ULONG cchMaxPath)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cchDirectory;
    ULONG       cchFileName;
    ULONG       cchExtension;
    CHAR        szUnique[10];
    ULONG       cchUnique;
    ULONG       cbEstimate;
    HANDLE      hTemp=INVALID_HANDLE_VALUE;
    DWORD       cUnique=0;
    DWORD       dwLastError;
    LPCSTR      pszSlash;

    // Invalid Arg
    Assert(pszDirectory && pszFileName && pszExtension && pszFilePath);

    // Compute lengths
    *szUnique = '\0';
    cchDirectory = lstrlen(pszDirectory);
    cchFileName = lstrlen(pszFileName);
    cchExtension = lstrlen(pszExtension);

    // Set pszSplashes
    if ('\\' == *CharPrev(pszDirectory, pszDirectory + cchDirectory))
        pszSlash = "";
    else
        pszSlash = "\\";

    // Try to create the file
    while(1)
    {
        // Compute length of unique post fix
        cchUnique = lstrlen(szUnique);

        // Do I have room + 1 (
        cbEstimate = cchDirectory + cchFileName + cchExtension + cchUnique;

        // Too Big
        if (cbEstimate + 1 > cchMaxPath)
        {
LengFail:
            Assert(FALSE);
            hr = TrapError(E_FAIL);
            goto exit;
        }

        while(cbEstimate > (MAX_PATH - 4))
        {
            if((cchUnique + cchDirectory) >= (MAX_PATH - 7))
                goto LengFail;
            else if(cchFileName > 2)
            {
                pszFileName = CharNext(pszFileName);
                cchFileName = lstrlen(pszFileName);
            }
            else if(cchExtension > 2)
            {
                pszExtension = CharNext(pszExtension);
                cchExtension = lstrlen(pszExtension);
            }
            else
                goto LengFail;

            cbEstimate = cchDirectory + cchFileName + cchExtension + cchUnique;
        }
        // Build the file path
        if (0 == cchUnique)
            wnsprintf(pszFilePath, cchMaxPath, "%s%s%s%s", pszDirectory, pszSlash, pszFileName, pszExtension);
        else
            wnsprintf(pszFilePath, cchMaxPath, "%s%s%s (%s)%s", pszDirectory, pszSlash, pszFileName, szUnique, pszExtension);

        // Open the File
        hTemp = CreateFile(pszFilePath, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL , NULL);
        if (INVALID_HANDLE_VALUE != hTemp)
        {
            // confirm that what we had is a file
            CloseHandle(hTemp);
            hTemp = INVALID_HANDLE_VALUE;
            if (DeleteFile(pszFilePath))
            {
                hTemp = CreateFile(pszFilePath, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL , NULL);
                break;
            }
        }

        // Get the last error
        dwLastError = GetLastError();

        // If it didn't fail because ERROR_ALREADY_EXISTS, then fail
        if (ERROR_ALREADY_EXISTS != dwLastError && ERROR_FILE_EXISTS != dwLastError)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Increment cUnique
        cUnique++;

        // Format szUnique
        wnsprintf(szUnique, ARRAYSIZE(szUnique), "%d", cUnique);
    }

exit:
    // Cleanup
    if (INVALID_HANDLE_VALUE != hTemp)
        CloseHandle(hTemp);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CreateTempFile
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) CreateTempFile(LPCSTR pszSuggest, LPCSTR pszExtension, LPSTR *ppszFilePath, HANDLE *phFile)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szTempDir[MAX_PATH];
    WCHAR       wszTempDir[MAX_PATH];
    CHAR        szFileName[MAX_PATH];
    LPSTR       pszFilePath=NULL;
    LPSTR       pszFile;
    LPSTR       pszExt;
    ULONG       cbAlloc;

    // Invalid Arg
    Assert(ppszFilePath && phFile);

    // Init
    *phFile = INVALID_HANDLE_VALUE;

    // Create a temp file stream in URL cache
    if(AthGetTempUniquePathW(ARRAYSIZE(wszTempDir), wszTempDir))
    {
        LPSTR pszAnsiStr = PszToANSI(CP_ACP, wszTempDir);
        if (!pszAnsiStr)
            goto exit;
        StrCpyN(szTempDir, pszAnsiStr, ARRAYSIZE(szTempDir));
        MemFree(pszAnsiStr);
    }
    // If cannot find URL cache try TEMP dir
    else 
    {
        DWORD nBufferLength = GetTempPath(ARRAYSIZE(szTempDir), szTempDir);
    
        if (nBufferLength == 0 || nBufferLength > ARRAYSIZE(szTempDir))
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
    }

    // Compute Max Size of pszFilePath
    cbAlloc = MAX_PATH + lstrlen(szTempDir);
    if (pszSuggest)
        cbAlloc += lstrlen(pszSuggest);
    if (pszExtension)
        cbAlloc += lstrlen(pszExtension);

    // Allocate m_pszNeedFile
    CHECKALLOC(pszFilePath = PszAllocA(cbAlloc + 1));

    // Create a unique file path with suggested pszFileName and pszExtension
    if (NULL != pszSuggest)
    {
        // Find the filename
        pszFile = PathFindFileName(pszSuggest);

        // Get the Extension
        pszExt = PathFindExtension(pszSuggest);

        // If no pszExtension, use extension from pszSuggest
        if (NULL == pszExtension)
            pszExtension = pszExt ? pszExt : (LPSTR)c_szDotDat;

        // Copy fileName
        if (pszExt && pszFile && pszExt >= pszFile)
            StrCpyN(szFileName, pszFile, (DWORD) (min((pszExt - pszFile) - 1, ARRAYSIZE(szFileName))));
        else
            StrCpyN(szFileName, pszSuggest, ARRAYSIZE(szFileName));

        // Fixup szTempDir
        if (szTempDir[lstrlen(szTempDir) - 1] != '\\')
            StrCatBuff(szTempDir, "\\", ARRAYSIZE(szTempDir));

        // GenerateUniqueFileName
        hr = GenerateUniqueFileName(szTempDir, szFileName, pszExtension, pszFilePath, cbAlloc);
    }

    // If no filename and no extension or suggested name failed, just use the windows function
    if ((NULL == pszSuggest) || FAILED(hr))
    {
        hr = S_OK;

        // Get Temp File Name
        if (0 == GetTempFileName(szTempDir, "wbk", 0, pszFilePath))
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
    }

    // Open the File
    *phFile = CreateFile(pszFilePath, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL , NULL);
    if (INVALID_HANDLE_VALUE == *phFile)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // SetReturn
    *ppszFilePath = pszFilePath;
    pszFilePath = NULL;

exit:
    // Cleanup
    SafeMemFree(pszFilePath);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// WriteStreamToFileHandle
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) WriteStreamToFileHandle(IStream *pStream, HANDLE hFile, ULONG *pcbTotal)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbRead;
    ULONG       cbTotal=0;
    BYTE        rgbBuffer[2048];
    ULONG       cbWrote;

    // Invalid Arg
    if(!pStream || !hFile || (hFile == INVALID_HANDLE_VALUE))
    {
        Assert(FALSE);
        return(E_INVALIDARG);
    }

    // Dump pStream to hFile
    while(1)
    {
        // Read a blob
        CHECKHR(hr = pStream->Read(rgbBuffer, sizeof(rgbBuffer), &cbRead));

        // Done
        if (0 == cbRead)
            break;

        // Write to the file
        if (0 == WriteFile(hFile, rgbBuffer, cbRead, &cbWrote, NULL))
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Count Bytes
        cbTotal += cbWrote;
    }

    // Return Total
    if (pcbTotal)
        *pcbTotal = cbTotal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DeleteTempFile
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) DeleteTempFile(LPTEMPFILEINFO pTempFile)
{
    // Locals
    BOOL  fDeleted;
    DWORD dwAttributes;

    // If NULL, assume the file has been deleted
    if (NULL == pTempFile->pszFilePath)
        return S_OK;

    // Have we launched a process on this temp file which is still running?
    if (pTempFile->hProcess && WAIT_OBJECT_0 != WaitForSingleObject(pTempFile->hProcess, 0))
        return S_FALSE; // This file is probably still in use: won't delete

    // First check if this is a file or a directory, then terminate it
    dwAttributes = GetFileAttributes(pTempFile->pszFilePath);
    if (0xFFFFFFFF != dwAttributes && (FILE_ATTRIBUTE_DIRECTORY & dwAttributes))
        fDeleted = RemoveDirectory(pTempFile->pszFilePath);
    else
        fDeleted = DeleteFile(pTempFile->pszFilePath);

    // Done
    return fDeleted ? S_OK : S_FALSE;
}

// --------------------------------------------------------------------------------
// AppendTempFileList
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) AppendTempFileList(LPTEMPFILEINFO *ppHead, LPSTR pszFilePath, HANDLE hProcess)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTEMPFILEINFO  pTempFile, pInsertionPt;

    // Allocate pTempFile
    CHECKALLOC(pTempFile = (LPTEMPFILEINFO)g_pMalloc->Alloc(sizeof(TEMPFILEINFO)));

    // Fill in the fields
    ZeroMemory(pTempFile, sizeof(TEMPFILEINFO));
    pTempFile->pszFilePath = pszFilePath;
    pTempFile->hProcess = hProcess;
    pTempFile->pNext = NULL;

    // Insert new record at the end of the linked list
    pInsertionPt = *ppHead;
    if (NULL == pInsertionPt)
        // Insert record into empty linked list
        (*ppHead) = pTempFile;
    else
    {
        // Insert record at end of linked list
        while (NULL != pInsertionPt->pNext)
            pInsertionPt = pInsertionPt->pNext;

        pInsertionPt->pNext = pTempFile;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// DeleteTempFileOnShutdown
// --------------------------------------------------------------------------------
OESTDAPI_(VOID) DeleteTempFileOnShutdown(LPTEMPFILEINFO pTempFile)
{
    LPTEMPFILEINFO pInsertionPt;

    Assert(NULL != pTempFile && NULL == pTempFile->pNext);

    // Enter global Critical Section
    EnterCriticalSection(&g_csTempFileList);

    // Insert new record at the end of the global linked list
    pTempFile->pNext = NULL;
    pInsertionPt = g_pTempFileHead;
    if (NULL == pInsertionPt)
        // Insert record into empty linked list
        g_pTempFileHead = pTempFile;
    else
    {
        // Insert record at end of linked list
        while (NULL != pInsertionPt->pNext)
            pInsertionPt = pInsertionPt->pNext;

        pInsertionPt->pNext = pTempFile;
    }
    
    // Leave global Critical Section
    LeaveCriticalSection(&g_csTempFileList);
}

// --------------------------------------------------------------------------------
// DeleteTempFileOnShutdownEx
// --------------------------------------------------------------------------------
OESTDAPI_(VOID) DeleteTempFileOnShutdownEx(LPSTR pszFilePath, HANDLE hProcess)
{
    // Enter global Critical Section
    EnterCriticalSection(&g_csTempFileList);

    // Append to globa list
    AppendTempFileList(&g_pTempFileHead, pszFilePath, hProcess);
    
    // Enter global Critical Section
    LeaveCriticalSection(&g_csTempFileList);
}

// --------------------------------------------------------------------------------
// CleanupGlobalTempFiles
// --------------------------------------------------------------------------------
OESTDAPI_(VOID) CleanupGlobalTempFiles(void)
{
    // Locals
    LPTEMPFILEINFO pCurrent;
    LPTEMPFILEINFO pNext;

    // Enter global Critical Section
    EnterCriticalSection(&g_csTempFileList);

    // Init
    pCurrent = g_pTempFileHead;

    // Do the loop
    while(pCurrent)
    {
        // Save Next
        pNext = pCurrent->pNext;

        // Delete the temp file
        DeleteTempFile(pCurrent);

        // Free file name
        SafeMemFree(pCurrent->pszFilePath);

        // Free pCurrent
        g_pMalloc->Free(pCurrent);

        // Goto Next
        pCurrent = pNext;
    }

    // Null the head
    g_pTempFileHead = NULL;

    // Leave global Critical Section
    LeaveCriticalSection(&g_csTempFileList);
}

// QFE 2522
#define EXT_SIZE        4 
#define TMP_SIZE        10

// =====================================================================================
// FBuildTempPath
// =====================================================================================
BOOL FBuildTempPath(LPTSTR lpszOrigFile, LPTSTR lpszPath, ULONG cbMaxPath, BOOL fLink)
{
    LPWSTR lpszOrigFileW = PszToUnicode(CP_ACP, lpszOrigFile);
    LPWSTR lpszPathW = NULL;
    BOOL result = FALSE;

    if (!lpszOrigFileW)
        return result;

    MemAlloc((LPVOID *) &lpszPathW, sizeof(WCHAR) * cbMaxPath);
    if (lpszPathW)
    {        
        result = FBuildTempPathW(lpszOrigFileW, lpszPathW, cbMaxPath, fLink);
        if (result)
            WideCharToMultiByte(CP_ACP, 0, lpszPathW, -1, lpszPath, cbMaxPath, NULL, NULL);
    }

    MemFree(lpszOrigFileW);
    MemFree(lpszPathW);
    return result;
}


BOOL FBuildTempPathW(LPWSTR lpszOrigFile, LPWSTR lpszPath, ULONG cchMaxPath, BOOL fLink)
{
    // Locals
    INT             i;
    WCHAR          *pszName, 
                   *pszExt,
                   *pszOrigFileTemp = NULL,
                    szName[MAX_PATH],
                    szTempDir[MAX_PATH];

    // Check Params
    AssertSz(lpszOrigFile && lpszPath, "Null Parameter");

    // Get Temp Path
    if(!AthGetTempUniquePathW(ARRAYSIZE(szTempDir), szTempDir))
        szTempDir[0] = L'\0';

    int nTmp = lstrlenW(szTempDir);
    if(nTmp >= (((int) cchMaxPath) - TMP_SIZE - EXT_SIZE - 1))
    {
        StrCpyNW(szTempDir, L"\\", ARRAYSIZE(szTempDir));
        nTmp = lstrlenW(szTempDir);
    }

    DWORD cchSize = (lstrlenW(lpszOrigFile) + 1);
    if (!MemAlloc((LPVOID *) &pszOrigFileTemp, sizeof(WCHAR) * cchSize) ||
        (lpszOrigFile == NULL))
        return(FALSE);

    StrCpyNW(pszOrigFileTemp, lpszOrigFile, cchSize);

    // Get the file name and extension
    pszName = PathFindFileNameW(pszOrigFileTemp);
    Assert(!FIsEmptyW(pszName));

    pszExt = PathFindExtensionW(pszOrigFileTemp);

    if(nTmp + lstrlenW(pszName) + lstrlenW(pszExt)> (((int) cchMaxPath) - TMP_SIZE)) // QFE  2522
    {
        if(nTmp + lstrlenW(pszExt) > (((int) cchMaxPath) - TMP_SIZE))
            pszExt[0] = L'\0';

        // Truncate anything that won't fit in the buffer passed in
        if(lstrlenW(pszName) >= ((int) cchMaxPath) - (nTmp + lstrlenW(pszExt) + TMP_SIZE + 1))
            *(pszName + ((int) cchMaxPath) - (nTmp + lstrlenW(pszExt) + TMP_SIZE + 1)) = '\0';
    }

    if (*pszExt != 0)
    {
        Assert(*pszExt == L'.');
        *pszExt = 0;
        StrCpyNW(szName, pszName, ARRAYSIZE(szName));
        *pszExt = L'.';
    }
    else
    {
        StrCpyNW(szName, pszName, ARRAYSIZE(szName));
    }

    if (fLink)
        pszExt = (LPWSTR)c_szLnkExt;

    // Make first attemp file name
    Assert (szTempDir[lstrlenW(szTempDir)-1] == L'\\');
    Assert(cchMaxPath >= (ULONG)(lstrlenW(szTempDir) + lstrlenW(szName) + lstrlenW(pszExt) + TMP_SIZE));

    StrCpyNW(lpszPath, szTempDir, cchMaxPath);
    StrCatBuffW(lpszPath, szName, cchMaxPath);
    StrCatBuffW(lpszPath, pszExt, cchMaxPath);

    // If it doesn't exist, were done
    if (PathFileExistsW(lpszPath) == FALSE)
    {
        MemFree(pszOrigFileTemp);
        return(TRUE);
    }

    // Loop to find a temp name that doesn't exist
    for (i=1; i<100 ;i++)
    {
        // Build new path
        wnsprintfW(lpszPath, cchMaxPath, L"%s%s (%d)%s", szTempDir, szName, i, pszExt);

        // If it doesn't exist, were done
        if (PathFileExistsW(lpszPath) == FALSE)
        {
            MemFree(pszOrigFileTemp);
            return(TRUE);
        }
    }

    // Done
    MemFree(pszOrigFileTemp);
    return(FALSE);
}


void FreeTempFileList(LPTEMPFILEINFO pTempFileHead)
{
    // Locals
    LPTEMPFILEINFO pCurrent;
    LPTEMPFILEINFO pNext;

    // Init
    pCurrent = pTempFileHead;

    // Do the loop
    while(pCurrent)
    {
        // Save Next
        pNext = pCurrent->pNext;

        // If not deleted, append to global file list
        if (S_FALSE == DeleteTempFile(pCurrent))
        {
            // MSOERT maintains a list of global temp files to be killed on shutdown
            DeleteTempFileOnShutdown(pCurrent);
        }

        // Otherwise, delete this node
        else
        {
            // Free file name
            SafeMemFree(pCurrent->pszFilePath);

            // Free pCurrent
            g_pMalloc->Free(pCurrent);
        }

        // Goto Next
        pCurrent = pNext;
    }
}


DWORD CALLBACK EditStreamInCallback(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR *pcb)
{
    AssertSz(dwCookie, "Houston, we have a problem...");
    ((LPSTREAM)dwCookie)->Read(pbBuff, cb, (ULONG *)pcb);
#ifdef DEBUG
    // validate for the richedit bug...
    // if we put a \r in the richedit as the last char without a \n
    // ie not a \r\n pair, it bithces and faults...
        if(*pcb && *pcb<cb)
            AssertSz(pbBuff[(*pcb)-1]!='\r', "is this the richedit bug??");
#endif
    return NOERROR;
}

DWORD CALLBACK EditStreamOutCallback(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR *pcb)
{
    return ((LPSTREAM)dwCookie)->Write(pbBuff, cb, (ULONG *)pcb);
}


HRESULT RicheditStreamIn(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags)
{
    EDITSTREAM  es;

    if(!pstm)
        return E_INVALIDARG;

    if(!IsWindow(hwndRE))
        return E_INVALIDARG;

    HrRewindStream(pstm);

    es.dwCookie = (DWORD_PTR)pstm;
    es.pfnCallback=(EDITSTREAMCALLBACK)EditStreamInCallback;
    SendMessage(hwndRE, EM_STREAMIN, uSelFlags, (LPARAM)&es);
    return NOERROR;
}

HRESULT RicheditStreamOut(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags)
{
    EDITSTREAM  es;

    if(!pstm)
        return E_INVALIDARG;

    if(!IsWindow(hwndRE))
        return E_INVALIDARG;

    es.dwCookie = (DWORD_PTR)pstm;
    es.pfnCallback=(EDITSTREAMCALLBACK)EditStreamOutCallback;
    SendMessage(hwndRE, EM_STREAMOUT, uSelFlags, (LPARAM)&es);
    return NOERROR;
}


HRESULT ShellUtil_GetSpecialFolderPath(DWORD dwSpecialFolder, LPSTR rgchPath)
{
    LPITEMIDLIST    pidl = NULL;
    HRESULT         hr = E_FAIL;

    if (SHGetSpecialFolderLocation(NULL, dwSpecialFolder, &pidl)==S_OK)
    {
        if (SHGetPathFromIDList(pidl, rgchPath))
            hr = S_OK;
        
        SHFree(pidl);
    }
    return hr;
}

/*
 *  CenterDialog
 *
 *  Purpose:
 *      This function centers a dialog with respect to its parent
 *      dialog.
 *
 *  Parameters:
 *      hwndDlg     hwnd of the dialog to center
 */
VOID CenterDialog(HWND hwndDlg)
{
    HWND    hwndOwner;
    RECT    rc;
    RECT    rcDlg;
    RECT    rcOwner;
    RECT    rcWork;
    INT     x;
    INT     y;
    INT     nAdjust;

    // Get the working area rectangle
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0);

    // Get the owner window and dialog box rectangles.
    //  The window rect of the destop window is in trouble on multimonitored
    //  macs. GetWindow only gets the main screen.
    if (hwndOwner = GetParent(hwndDlg))
        GetWindowRect(hwndOwner, &rcOwner);
    else
        rcOwner = rcWork;

    GetWindowRect(hwndDlg, &rcDlg);
    rc = rcOwner;

    // Offset the owner and dialog box rectangles so that
    // right and bottom values represent the width and
    // height, and then offset the owner again to discard
    // space taken up by the dialog box.
    OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);
    OffsetRect(&rc, -rc.left, -rc.top);
    OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);

    // The new position is the sum of half the remaining
    // space and the owner's original position.
    // But not less than Zero - jefbai

    x= rcOwner.left + (rc.right / 2);
    y= rcOwner.top + (rc.bottom / 2);

    // Make sure the dialog doesn't go off the right edge of the screen
    nAdjust = rcWork.right - (x + rcDlg.right);
    if (nAdjust < 0)
        x += nAdjust;

    //$ Raid 5128: Make sure the left edge is visible
    if (x < rcWork.left)
        x = rcWork.left;

    // Make sure the dialog doesn't go off the bottom edge of the screen
    nAdjust = rcWork.bottom - (y + rcDlg.bottom);
    if (nAdjust < 0)
        y += nAdjust;

    //$ Raid 5128: Make sure the top edge is visible
    if (y < rcWork.top)
        y = rcWork.top;
    SetWindowPos(hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}


void SetIntlFont(HWND hwnd)
{
    HFONT hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    if (hfont == NULL)
        hfont = (HFONT)GetStockObject(SYSTEM_FONT);
    if (hfont != NULL)
        SendMessage(hwnd, WM_SETFONT, (WPARAM)hfont, MAKELPARAM(TRUE, 0));
}



// See whether entire string will fit in *prc; if not, compute number of chars
// that will fit, including ellipses.  Returns length of string in *pcchDraw.
//
BOOL NeedsEllipses(HDC hdc, LPCTSTR pszText, RECT FAR* prc, int FAR* pcchDraw, int cxEllipses)
{
    int cchText;
    int cxRect;
    int ichMin, ichMax, ichMid;
    SIZE siz;
#if !defined(UNICODE)  // && defined(DBCS)
    LPCTSTR lpsz;
#endif

    cxRect = prc->right - prc->left;

    cchText = lstrlen(pszText);

    if (cchText == 0)
    {
        *pcchDraw = cchText;
        return FALSE;
    }

    GetTextExtentPoint32(hdc, pszText, cchText, &siz);

    if (siz.cx <= cxRect)
    {
        *pcchDraw = cchText;
        return FALSE;
    }

    cxRect -= cxEllipses;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxRect > 0)
    {
        // Binary search to find character that will fit
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
        {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            GetTextExtentPoint32(hdc, &pszText[ichMin], ichMid - ichMin, &siz);

            if (siz.cx < cxRect)
            {
                ichMin = ichMid;
                cxRect -= siz.cx;
            }
            else if (siz.cx > cxRect)
            {
                ichMax = ichMid - 1;
            }
            else
            {
                // Exact match up up to ichMid: just exit.
                //
                ichMax = ichMid;
                break;
            }
        }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
    }

#if !defined(UNICODE) // && defined(DBCS)
    // b#8934
    lpsz = &pszText[ichMax];
    while ( lpsz-- > pszText )
    {
        if (!IsDBCSLeadByte(*lpsz))
            break;
    }
    ichMax += ( (&pszText[ichMax] - lpsz) & 1 ) ? 0: 1;
#endif

    *pcchDraw = ichMax;
    return TRUE;
}




#define CCHELLIPSES 3
#define CCHLABELMAX MAX_PATH


void IDrawText(HDC hdc, LPCTSTR pszText, RECT FAR* prc, BOOL fEllipses, int cyChar)
{
    int         cchText,
                cxEllipses;
    RECT        rc;
    TCHAR       ach[CCHLABELMAX + CCHELLIPSES];
    SIZE        sze;

    // REVIEW: Performance idea:
    // We could cache the currently selected text color
    // so we don't have to set and restore it each time
    // when the color is the same.
    //
    if (!pszText)
        return;

    if (IsRectEmpty(prc))
        return;


    rc = *prc;

    if(fEllipses)
    {
        GetTextExtentPoint32(hdc, g_szEllipsis, lstrlen(g_szEllipsis), &sze);
        cxEllipses=sze.cx;
    }

    if ((fEllipses) &&
            NeedsEllipses(hdc, pszText, &rc, &cchText, cxEllipses))
    {
        // In some cases cchText was comming back bigger than
        // ARRYASIZE(ach), so we need to make sure we don't overflow the buffer

        // if cchText is too big for the buffer, truncate it down to size
        if (cchText >= ARRAYSIZE(ach) - CCHELLIPSES)
            cchText = ARRAYSIZE(ach) - CCHELLIPSES - 1;

        memcpy(ach, pszText, cchText * sizeof(TCHAR));
        StrCpyN(ach + cchText, g_szEllipsis, (ARRAYSIZE(ach) - cchText));

        pszText = ach;
        cchText += CCHELLIPSES;
    }
    else
    {
        cchText = lstrlen(pszText);
    }

    // Center vertically in case the bitmap (to the left) is larger than
    // the height of one line
    if (cyChar)
        rc.top += (rc.bottom - rc.top - cyChar) / 2;
    ExtTextOut(hdc, rc.left, rc.top, 0, prc, pszText, cchText, NULL);
}


BOOL FIsHTMLFile(LPSTR pszFile)
{
    int cch;

    if(pszFile==NULL)
        return FALSE;

    cch = lstrlen(pszFile);

    if ((cch > 4 && lstrcmpi(&pszFile[cch-4], ".htm")==0) ||
        (cch > 5 && lstrcmpi(&pszFile[cch-5], ".html")==0))
        return TRUE;

    return FALSE;
}

BOOL FIsHTMLFileW(LPWSTR pwszFile)
{
    int cch;

    if(pwszFile==NULL)
        return FALSE;

    cch = lstrlenW(pwszFile);

    if ((cch > 4 && StrCmpIW(&pwszFile[cch-4], L".htm")==0) ||
        (cch > 5 && StrCmpIW(&pwszFile[cch-5], L".html")==0))
        return TRUE;

    return FALSE;
}

BOOL GetExePath(LPCTSTR szExe, TCHAR *szPath, DWORD cch, BOOL fDirOnly)
{
    BOOL fRet;
    HKEY hkey;
    DWORD dwType, cb;
    TCHAR sz[MAX_PATH], szT[MAX_PATH];

    Assert(szExe != NULL);
    Assert(szPath != NULL);

    fRet = FALSE;

    wnsprintf(sz, ARRAYSIZE(sz), c_szPathFileFmt, c_szAppPaths, szExe);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(szT);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, fDirOnly ? c_szRegPath : NULL, 0, &dwType, (LPBYTE)szT, &cb) && cb)
        {
            if (dwType == REG_EXPAND_SZ)
            {
                cb = ExpandEnvironmentStrings(szT, szPath, cch);
                if (cb != 0 && cb <= cch)
                    fRet = TRUE;
            }
            else
            {
                Assert(dwType == REG_SZ);
                StrCpyN(szPath, szT, cch);
                fRet = TRUE;
            }
        }

        RegCloseKey(hkey);
    }

    return(fRet);
}


int MessageBoxInstW(HINSTANCE hInst, HWND hwndOwner, LPWSTR pwszTitle, LPWSTR pwsz1, LPWSTR pwsz2, UINT fuStyle, 
                                PFLOADSTRINGW pfLoadStringW, PFMESSAGEBOXW pfMessageBoxW)
{
    WCHAR wszTitle[CCHMAX_STRINGRES];
    WCHAR wszText[2 * CCHMAX_STRINGRES + 2];
    int cch;

    Assert(pwsz1);
    Assert(pwszTitle != NULL);

    if (!(fuStyle & MB_ICONEXCLAMATION) && 
        !(fuStyle & MB_ICONWARNING) &&
        !(fuStyle & MB_ICONINFORMATION) &&
        !(fuStyle & MB_ICONASTERISK) &&
        //!(fuStyle & MB_ICONQUESTION) &&  // BUG: 18105
        !(fuStyle & MB_ICONSTOP) &&
        !(fuStyle & MB_ICONERROR) &&
        !(fuStyle & MB_ICONHAND))
    {
        if (fuStyle & MB_OK)
            fuStyle |= MB_ICONINFORMATION;
        else if (fuStyle & MB_YESNO || fuStyle & MB_YESNOCANCEL || fuStyle & MB_OKCANCEL)
            fuStyle |= MB_ICONEXCLAMATION; // BUG 18105 MB_ICONQUESTION;
        else if (fuStyle & MB_RETRYCANCEL || fuStyle & MB_ABORTRETRYIGNORE)
            fuStyle |= MB_ICONWARNING;
        else
            fuStyle |= MB_ICONWARNING;
    }

    if (IS_INTRESOURCE(pwszTitle))
    {
        // its a string resource id
        cch = pfLoadStringW(hInst, PtrToUlong(pwszTitle), wszTitle, ARRAYSIZE(wszTitle));
        if (cch == 0)
            return(0);

        pwszTitle = wszTitle;
    }

    if (!(IS_INTRESOURCE(pwsz1)))
    {
        // its a pointer to a string
        Assert(lstrlenW(pwsz1) < CCHMAX_STRINGRES);
        if (NULL == StrCpyNW(wszText, pwsz1, ARRAYSIZE(wszText)))
            return(0);

        cch = lstrlenW(wszText);
    }
    else
    {
        // its a string resource id
        cch = pfLoadStringW(hInst, PtrToUlong(pwsz1), wszText, ARRAYSIZE(wszText)-2);
        if (cch == 0)
            return(0);
    }

    if (pwsz2)
    {
        // there's another string that we need to append to the
        // first string...
        wszText[cch++] = L'\n';
        wszText[cch++] = L'\n';

        if (!(IS_INTRESOURCE(pwsz2)))
        {
            // its a pointer to a string
            Assert(lstrlenW(pwsz2) < CCHMAX_STRINGRES);
            if (NULL == StrCpyNW(&wszText[cch], pwsz2, (ARRAYSIZE(wszText) - cch)))
                return(0);
        }
        else
        {
            int cchTemp = ARRAYSIZE(wszText) - cch;
            Assert(cchTemp > 0);
            if (0 == pfLoadStringW(hInst, PtrToUlong(pwsz2), &wszText[cch], cchTemp))
                return(0);
        }
    }

    return(pfMessageBoxW(hwndOwner, wszText, pwszTitle, MB_SETFOREGROUND | fuStyle));
}

int MessageBoxInst(HINSTANCE hInst, HWND hwndOwner, LPTSTR pszTitle, LPTSTR psz1, LPTSTR psz2, UINT fuStyle)
{
    TCHAR szTitle[CCHMAX_STRINGRES];
    TCHAR szText[2 * CCHMAX_STRINGRES + 2];
    int cch;

    Assert(psz1);
    Assert(pszTitle != NULL);

    if (!(fuStyle & MB_ICONEXCLAMATION) && 
        !(fuStyle & MB_ICONWARNING) &&
        !(fuStyle & MB_ICONINFORMATION) &&
        !(fuStyle & MB_ICONASTERISK) &&
        //!(fuStyle & MB_ICONQUESTION) &&  // BUG: 18105
        !(fuStyle & MB_ICONSTOP) &&
        !(fuStyle & MB_ICONERROR) &&
        !(fuStyle & MB_ICONHAND))
    {
        if (fuStyle & MB_OK)
            fuStyle |= MB_ICONINFORMATION;
        else if (fuStyle & MB_YESNO || fuStyle & MB_YESNOCANCEL || fuStyle & MB_OKCANCEL)
            fuStyle |= MB_ICONEXCLAMATION; // BUG 18105 MB_ICONQUESTION;
        else if (fuStyle & MB_RETRYCANCEL || fuStyle & MB_ABORTRETRYIGNORE)
            fuStyle |= MB_ICONWARNING;
        else
            fuStyle |= MB_ICONWARNING;
    }

    if (IS_INTRESOURCE(pszTitle))
    {
        // its a string resource id
        cch = LoadString(hInst, PtrToUlong(pszTitle), szTitle, ARRAYSIZE(szTitle));
        if (cch == 0)
            return(0);

        pszTitle = szTitle;
    }

    if (!(IS_INTRESOURCE(psz1)))
    {
        // its a pointer to a string
        // Assert(lstrlen(psz1) < CCHMAX_STRINGRES);
        // if (NULL == StrCpyN(szText, psz1, ARRAYSIZE(szText)))
        //     return(0);

        if (NULL == StrCpyN(szText, psz1, ARRAYSIZE(szText) - 1))
            return(0);

        szText[ARRAYSIZE(szText) - 1] = '\0';
        cch = lstrlen(szText);
    }
    else
    {
        // its a string resource id
        cch = LoadString(hInst, PtrToUlong(psz1), szText, ARRAYSIZE(szText)-1);
        if (cch == 0)
            return(0);
    }

    // check that we have enough room for the '\n's and at least one byte of data
    if (psz2 && (cch < (ARRAYSIZE(szText) - 4)))
    {
        // there's another string that we need to append to the
        // first string...
        szText[cch++] = '\n';
        szText[cch++] = '\n';

        if (!(IS_INTRESOURCE(psz2)))
        {
            // its a pointer to a string
            // Assert(lstrlen(psz2) < CCHMAX_STRINGRES);

            if (NULL == StrCpyN(&szText[cch], psz2, (ARRAYSIZE(szText)-1)-cch))
                return(0);
        }
        else
        {
            int cchTemp = ARRAYSIZE(szText) - cch;
            Assert(cchTemp > 0);
            if (0 == LoadString(hInst, PtrToUlong(psz2), &szText[cch], cchTemp))
                return(0);
        }
    }

    return(MessageBox(hwndOwner, szText, pszTitle, MB_SETFOREGROUND | fuStyle));
}

BOOL BrowseForFolder(HINSTANCE hInst, HWND hwnd, TCHAR *pszDir, int cch, int idsText, BOOL fFileSysOnly)
{
    LPITEMIDLIST        plist;
    BROWSEINFO          bi;
    BROWSEFOLDERINFOA   bfi;
    BOOL                fRet = FALSE;
    CHAR               *psz = NULL, 
                        szTemp[MAX_PATH];
    CHAR                szRes[256];

    Assert(pszDir != NULL);
    Assert(cch >= MAX_PATH);

    LoadString(hInst, idsText, szRes, ARRAYSIZE(szRes));

    bfi.psz = pszDir;
    bfi.fFileSysOnly = fFileSysOnly;

    bi.hwndOwner = hwnd;
    bi.pidlRoot = NULL;
    bi.pszDisplayName = szTemp;
    bi.lpszTitle = szRes;
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_STATUSTEXT;
    bi.lpfn = BrowseCallbackProcA;
    bi.lParam = (LPARAM)&bfi;
    plist = SHBrowseForFolder(&bi);

    if (plist != NULL)
    {
        fRet = SHGetPathFromIDList(plist, pszDir);
        SHFree(plist);
    }

    return(fRet);
}

BOOL SHGetPathFromIDListAthW(LPCITEMIDLIST pidl, LPWSTR pwszPath)
{
    CHAR pszPath[MAX_PATH];
    BOOL fSucceeded = FALSE;

    fSucceeded = SHGetPathFromIDListW(pidl, pwszPath);

    if (!fSucceeded)
    {
        fSucceeded = SHGetPathFromIDListA(pidl, pszPath);
        if (fSucceeded)
            fSucceeded = (0 != MultiByteToWideChar(CP_ACP, 0, pszPath, -1, pwszPath, MAX_PATH));
    }

    return fSucceeded;
}

LPITEMIDLIST SHBrowseForFolderAthW(LPBROWSEINFOW pbiW)
{
    LPITEMIDLIST    pidl = NULL;
    LPSTR           pszTitle = NULL;
    CHAR            szDisplay[MAX_PATH];
    BROWSEINFOA     biA;

    Assert(pbiW);

    if((IsPlatformWinNT() == S_OK) && g_rOSVersionInfo.dwMajorVersion >= 5)
        pidl = SHBrowseForFolderW(pbiW);  // this is only for NT5
    else
    {
        pszTitle = PszToANSI(CP_ACP, pbiW->lpszTitle);
        if (!pszTitle)
            goto exit;

        biA = *((BROWSEINFOA*)pbiW);
        biA.lpszTitle = pszTitle;
        biA.pszDisplayName = szDisplay;

        pidl = SHBrowseForFolderA(&biA);
        if (pidl)
        {
            if (0 == MultiByteToWideChar(CP_ACP, 0, biA.pszDisplayName, -1, pbiW->pszDisplayName, MAX_PATH))
            {
                SHFree(pidl);
                pidl = NULL;
            }
        }
    }

exit:
    MemFree(pszTitle);
    return pidl;
}


BOOL BrowseForFolderW(HINSTANCE hInst, HWND hwnd, WCHAR *pwszDir, int cch, int idsText, BOOL fFileSysOnly)
{
    LPITEMIDLIST        plist;
    BROWSEINFOW         bi;
    BROWSEFOLDERINFOW   bfi;
    BOOL                fRet = FALSE;
    WCHAR              *pwsz = NULL, 
                        wszTemp[MAX_PATH];
    CHAR                szRes[256];

    Assert(pwszDir != NULL);
    Assert(cch >= MAX_PATH);

    // Don't have access to all wrappers in msoert so
    // must do conversion ourselves for LoadStringW
    LoadString(hInst, idsText, szRes, ARRAYSIZE(szRes));
    pwsz = PszToUnicode(CP_ACP, szRes);
    if (!pwsz)
        goto exit;

    bfi.pwsz = pwszDir;
    bfi.fFileSysOnly = fFileSysOnly;

    bi.hwndOwner = hwnd;
    bi.pidlRoot = NULL;
    bi.pszDisplayName = wszTemp;
    bi.lpszTitle = pwsz;
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_STATUSTEXT;
    bi.lpfn = BrowseCallbackProcW;
    bi.lParam = (LPARAM)&bfi;
    plist = SHBrowseForFolderAthW(&bi);

    if (plist != NULL)
    {
        fRet = SHGetPathFromIDListAthW(plist, pwszDir);
        SHFree(plist);
    }

exit:
    MemFree(pwsz);
    return(fRet);
}

int BrowseCallbackProcW(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
{
    BOOL fRet;
    UINT type;
    WCHAR wsz[MAX_PATH];
    BROWSEFOLDERINFOW *pbfi;

    switch (msg)
    {
        case BFFM_INITIALIZED:
            pbfi = (BROWSEFOLDERINFOW *)lpData;
            Assert(pbfi != NULL);
            SendMessage(hwnd, BFFM_SETSELECTIONW, TRUE, (LPARAM)pbfi->pwsz);
            break;

        case BFFM_SELCHANGED:
            pbfi = (BROWSEFOLDERINFOW *)lpData;
            Assert(pbfi != NULL);
            fRet = SHGetPathFromIDListAthW((LPITEMIDLIST)lParam, wsz);
            if (fRet)
            {
                if (L':' == wsz[1] && L'\\' == wsz[2])
                {
                    wsz[3] = 0;
                    if (S_OK == IsPlatformWinNT())
                        type = GetDriveTypeW(wsz);
                    else
                    {
                        // Since we can't fail in this function, we need to do some kind
                        // of conversion that doesn't require memory allocations, etc.
                        // Since drives always must be ansi, can do the conversion in this
                        // really ugly way.
                        CHAR   szDir[] = "a:\\";
                        AssertSz(0 == ((LPSTR)wsz)[1], "The char is not a unicode ANSI char");
                        *szDir = *((LPSTR)wsz);
                        type = GetDriveType(szDir);
                    }
                    if (pbfi->fFileSysOnly)
                        fRet = (type == DRIVE_FIXED);
                    else
                        fRet = (type == DRIVE_FIXED || type == DRIVE_REMOVABLE || type == DRIVE_REMOTE);
                }
                else
                {
                    fRet = !pbfi->fFileSysOnly;
                }
            }

            SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)fRet);
            break;
    }

    return(0);
}

int BrowseCallbackProcA(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
{
    BOOL fRet;
    UINT type;
    CHAR sz[MAX_PATH];
    BROWSEFOLDERINFOA *pbfi;

    switch (msg)
    {
        case BFFM_INITIALIZED:
            pbfi = (BROWSEFOLDERINFOA *)lpData;
            Assert(pbfi != NULL);
            SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)pbfi->psz);
            break;

        case BFFM_SELCHANGED:
            pbfi = (BROWSEFOLDERINFOA *)lpData;
            Assert(pbfi != NULL);
            fRet = SHGetPathFromIDList((LPITEMIDLIST)lParam, sz);
            if (fRet)
            {
                // Only reason to do this check is to see if we have
                // some funky chars in the filename. This will protect us
                // from selecting files with non-ANSI chars in them.
                if (PathFileExists(sz))
                {
                    if (':' == sz[1] && '\\' == sz[2])
                    {
                        sz[3] = 0;
                        type = GetDriveType(sz);

                        if (pbfi->fFileSysOnly)
                            fRet = (type == DRIVE_FIXED);
                        else
                            fRet = (type == DRIVE_FIXED || type == DRIVE_REMOVABLE || type == DRIVE_REMOTE);
                    }
                    else
                    {
                        fRet = !pbfi->fFileSysOnly;
                    }
                }
                else
                    fRet = FALSE;
            }

            SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)fRet);
            break;
    }

    return(0);
}

HRESULT IsPlatformWinNT(void)
{
    return (g_rOSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) ? S_OK : S_FALSE;
}

void UpdateRebarBandColors(HWND hwndRebar)
{
    REBARBANDINFO   rbbi;
    UINT            i;
    UINT            cBands;
    
    // First find the band with the toolbar
    cBands = (UINT) SendMessage(hwndRebar, RB_GETBANDCOUNT, 0, 0);
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_ID;
    
    for (i = 0; i < cBands; i++)
    {
        SendMessage(hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);

        ZeroMemory(&rbbi, sizeof(rbbi));
        rbbi.cbSize  = sizeof(REBARBANDINFO);
        rbbi.fMask   = RBBIM_COLORS;
        rbbi.clrFore = GetSysColor(COLOR_BTNTEXT);
        rbbi.clrBack = GetSysColor(COLOR_BTNFACE);
    
        SendMessage(hwndRebar, RB_SETBANDINFO, i, (LPARAM) (LPREBARBANDINFO) &rbbi);
    }
}




#define RGB_BUTTONTEXT      (RGB(000,000,000))  // black
#define RGB_BUTTONSHADOW    (RGB(128,128,128))  // dark grey
#define RGB_BUTTONFACE      (RGB(192,192,192))  // bright grey
#define RGB_BUTTONHILIGHT   (RGB(255,255,255))  // white
#define RGB_TRANSPARENT     (RGB(255,000,255))  // pink

inline BOOL fIsNT5()        { return((g_rOSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_rOSVersionInfo.dwMajorVersion >= 5)); }
inline BOOL fIsWhistler()   { return((fIsNT5() && g_rOSVersionInfo.dwMinorVersion >=1) || 
            ((g_rOSVersionInfo.dwMajorVersion > 5) &&  (g_rOSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT))); }


/*
 * This function loads an OE toolbar bitmap and maps 3D colors to the
 * appropriate current scheme. We also map black and white so that we look
 * good on high-contrast displays
 */

HIMAGELIST LoadMappedToolbarBitmap(HINSTANCE hInst, int idBitmap, int cx)
{
    static const COLORMAP SysColorMap[] = {
        {RGB_BUTTONTEXT,    COLOR_BTNTEXT},     // black
        {RGB_BUTTONSHADOW,  COLOR_BTNSHADOW},   // dark grey
        {RGB_BUTTONFACE,    COLOR_BTNFACE},     // bright grey
        {RGB_BUTTONHILIGHT, COLOR_BTNHIGHLIGHT},// white
    };

    #define NUM_DEFAULT_MAPS (sizeof(SysColorMap)/sizeof(COLORMAP))
    COLORMAP DefaultColorMap[NUM_DEFAULT_MAPS];
        
    HIMAGELIST  himl;
    HBITMAP     hBmp;
    BITMAP      bm;
    int         cy=0;

    /* Get system colors for the default color map */
    for (int i=0; i < NUM_DEFAULT_MAPS; i++)
    {
        DefaultColorMap[i].from = SysColorMap[i].from;
        DefaultColorMap[i].to = GetSysColor((int)SysColorMap[i].to);
    }

    if(!fIsWhistler())
        hBmp = CreateMappedBitmap(hInst, idBitmap, 0, (COLORMAP *)&DefaultColorMap, NUM_DEFAULT_MAPS);
    else
        hBmp = CreateMappedBitmap(hInst, idBitmap, CMB_DIBSECTION, (COLORMAP *)&DefaultColorMap, NUM_DEFAULT_MAPS);
    if (!hBmp)
        return NULL;

    if (GetObject(hBmp, sizeof(BITMAP), &bm))
        cy = bm.bmHeight;

    if(!fIsWhistler())
        himl = ImageList_Create(cx, cy, ILC_COLORDDB|ILC_MASK, 4, 4);
    else
        himl = ImageList_Create(cx, cy, ILC_COLOR32|ILC_MASK, 4, 4);
    if (!himl)
    {
        DeleteObject(hBmp);
        return NULL;
    }

//    if(!fIsWhistler())
    {
        ImageList_AddMasked(himl, hBmp, RGB_TRANSPARENT);
        ImageList_SetBkColor(himl, CLR_NONE);
    }
    DeleteObject(hBmp);
    return himl;
}



HRESULT DoHotMailWizard(HWND hwndOwner, LPSTR pszUrl, LPSTR pszFriendly, RECT *prc, IUnknown *pUnkHost)
{
    IHotWizard     *pWiz=NULL;
    HRESULT         hr = S_OK;
    LPWSTR          pwszUrl = NULL,
                    pwszCaption = NULL;
    IHotWizardHost *pHost = NULL;

    if (pUnkHost)
        IF_FAILEXIT(hr = pUnkHost->QueryInterface(IID_IHotWizardHost, (LPVOID *)&pHost));
    
    // create and show the wizard
    IF_FAILEXIT(hr = CoCreateInstance(CLSID_OEHotMailWizard, NULL, CLSCTX_INPROC_SERVER, IID_IHotWizard, (LPVOID*)&pWiz));

    IF_NULLEXIT(pwszUrl = PszToUnicode(CP_ACP, pszUrl));

    IF_NULLEXIT(pwszCaption = PszToUnicode(CP_ACP, pszFriendly));

    IF_FAILEXIT(hr = pWiz->Show(hwndOwner, pwszUrl, pwszCaption, pHost, prc));

exit:
    MemFree(pwszUrl);
    MemFree(pwszCaption);
    ReleaseObj(pWiz);
    ReleaseObj(pHost);
    return hr;
}

BOOL fGetBrowserUrlEncoding(LPDWORD  pdwFlags)
{
    DWORD       dwUrlEncodingDisableUTF8; 
    DWORD       dwSize = sizeof(dwUrlEncodingDisableUTF8); 
    BOOL        fDefault = FALSE;
    DWORD       dwFlags = *pdwFlags;
    BOOL        fret = TRUE;

    if (ERROR_SUCCESS == SHRegGetUSValue(c_szInternetSettingsPath, c_szUrlEncoding, 
                                         NULL, (LPBYTE) &dwUrlEncodingDisableUTF8, &dwSize, 
                                         FALSE, (LPVOID) &fDefault, sizeof(fDefault)))
    {
        if (!dwUrlEncodingDisableUTF8)
            dwFlags |= DOCHOSTUIFLAG_URL_ENCODING_ENABLE_UTF8; 
        else 
            dwFlags |= DOCHOSTUIFLAG_URL_ENCODING_DISABLE_UTF8; 

        *pdwFlags = dwFlags;
    }
    else fret = FALSE;

    return fret;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\stmutil.cpp ===
// --------------------------------------------------------------------------------
// Stmutil.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "oertpriv.h"
#include "shlwapi.h"
#include "unicnvrt.h"
#include <BadStrFunctions.h>

#pragma warning (disable: 4127) // conditional expression is constant

// Stream Block Copy Size
#define STMTRNSIZE      4096

// --------------------------------------------------------------------------------
// Disk full simulation on CFileStream
// --------------------------------------------------------------------------------
#ifdef DEBUG
    static BOOL g_fSimulateFullDisk = 0;
#endif

// --------------------------------------------------------------------------------
// HrIsStreamUnicode
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrIsStreamUnicode(LPSTREAM pStream, BOOL *pfLittleEndian)
{
    // Locals
    HRESULT     hr=S_OK;
    BYTE        rgb[2];
    DWORD       cbRead;
    DWORD       cbPosition;

    // Invalid Args
    if (NULL == pStream || NULL == pfLittleEndian)
        return(TraceResult(E_INVALIDARG));

    // Trace
    TraceCall("HrIsStreamUnicode");

    // Get the current position
    IF_FAILEXIT(hr = HrGetStreamPos(pStream, &cbPosition));

    // Read Two Bytes
    IF_FAILEXIT(hr = pStream->Read(rgb, 2, &cbRead));

    // Reposition the Stream
    HrStreamSeekSet(pStream, cbPosition);

    // Didn't Read Enough ?
    if (2 != cbRead)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Little Endian
    if (0xFF == rgb[0] && 0xFE == rgb[1])
    {
        *pfLittleEndian = TRUE;
        hr = S_OK;
        goto exit;
    }

    // Big Endian
    if (0xFE == rgb[0] && 0xFF == rgb[1])
    {
        *pfLittleEndian = FALSE;
        hr = S_OK;
        goto exit;
    }

    // Not Unicode
    hr = S_FALSE;

exit:
    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// HrCopyLockBytesToStream
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrCopyLockBytesToStream(ILockBytes *pLockBytes, IStream *pStream, ULONG *pcbCopied)
{
    // Locals
    HRESULT         hr=S_OK;
    ULARGE_INTEGER  uliCopy;
    ULONG           cbRead;
    BYTE            rgbBuffer[STMTRNSIZE];

    // Invalid Artg
    Assert(pLockBytes && pStream);

    // Set offset
    uliCopy.QuadPart = 0;

    // Copy m_pLockBytes to pstmTemp
    while(1)
    {
        // Read
        CHECKHR(hr = pLockBytes->ReadAt(uliCopy, rgbBuffer, sizeof(rgbBuffer), &cbRead));

        // Done
        if (0 == cbRead)
            break;

        // Write to stream
        CHECKHR(hr = pStream->Write(rgbBuffer, cbRead, NULL));

        // Increment offset
        uliCopy.QuadPart += cbRead;
    }

    // Return Amount Copied
    if (pcbCopied)
        *pcbCopied = (ULONG)uliCopy.QuadPart;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// FDoesStreamContains8bit
// --------------------------------------------------------------------------------
BOOL FDoesStreamContain8bit (LPSTREAM lpstm)
{
    // Locals
    BOOL            fResult=FALSE;
    BYTE            buf[4096];
    ULONG           cbRead,
                    i;

    // Loop through the stream
    while(1)
    {
        // Read cbCopy bytes from in
        if (FAILED(lpstm->Read (buf, sizeof(buf), &cbRead)) || cbRead == 0)
            break;

        // Scan for 8bit
        for (i=0; i<cbRead; i++)
        {
            if (IS_EXTENDED(buf[i]))
            {
                fResult = TRUE;
                break;
            }
        }
    }

    // Done
    return fResult;
}

// --------------------------------------------------------------------------------
// HrCopyStreamCB - A generic implementation of IStream::CopyTo
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrCopyStreamCB(
        LPSTREAM        lpstmIn,
        LPSTREAM        lpstmOut,
        ULARGE_INTEGER  uliCopy, 
        ULARGE_INTEGER *puliRead,
        ULARGE_INTEGER *puliWritten)
{
    // Locals
    HRESULT     hr = S_OK;
    BYTE        buf[4096];
    ULONG       cbRead,
                cbWritten,
                cbRemaining = uliCopy.LowPart,
                cbGet;

    // Init out params
    if (puliRead)
        ULISet32(*puliRead, 0);
    if (puliWritten)
        ULISet32(*puliWritten, 0);

    if ((NULL == lpstmIn) || (NULL == lpstmOut) || 
        ((0 != uliCopy.HighPart) && ((DWORD)-1 != uliCopy.HighPart || (DWORD)-1 != uliCopy.LowPart)))
        return TrapError(E_INVALIDARG);

    while (cbRemaining)
    {
        cbGet = min(sizeof(buf), cbRemaining);

        CHECKHR (hr = lpstmIn->Read (buf, cbGet, &cbRead));

        if (0 == cbRead)
            break;

        CHECKHR (hr = lpstmOut->Write (buf, cbRead, &cbWritten));

        // Verify
        Assert (cbWritten == cbRead);

        if (puliRead)
            puliRead->LowPart += cbRead;
        if (puliWritten)
            puliWritten->LowPart += cbWritten;

        // Compute number of bytes left to copy
        cbRemaining -= cbRead;
    }

exit:    
    return hr;
}

// --------------------------------------------------------------------------------
// HrCopyStreamCBEndOnCRLF - Copy cb bytes from lpstmIn to lpstmOut, and last CRLF
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrCopyStreamCBEndOnCRLF(LPSTREAM lpstmIn, LPSTREAM  lpstmOut, ULONG cb, ULONG *pcbActual)
{
    // Locals
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead = 0, cbWritten = 0, cbTotal = 0, cbRemaining = 0, cbCopy;

    do
    {
        // Compute number of bytes left to copy
        cbRemaining = cb - cbTotal;
        if (cbRemaining >= sizeof (buf))
            cbCopy = sizeof (buf);
        else
            cbCopy = cbRemaining;

        // Done
        if (cbCopy == 0)
            break;

        // Read cbCopy bytes from in
        CHECKHR (hr = lpstmIn->Read (buf, cbCopy, &cbRead));

        if (cbRead == 0)
            break;

        // Write cbCopy bytes to out
        CHECKHR (hr = lpstmOut->Write (buf, cbRead, NULL));

        // Verify
        cbTotal += cbRead;

    } while (cbRead == cbCopy);

    // If last character was not a '\n', append until we append a '\n'
    // Yes, please do not tell me that this is horable because I know that copying one
    // character at a time from a stream is not good and I should be deported right
    // along with brettm, but, this loop should never iterate more than the max line
    // length of the body of a message, so there. (sbailey)
    if (cbRead && buf[cbRead] != '\n')
    {
        do
        {
            // Read cbCopy bytes from in
            CHECKHR (hr = lpstmIn->Read (buf, 1, &cbRead));

            // Nothing left
            if (cbRead == 0)
                break;

            // Write cbCopy bytes to out
            CHECKHR (hr = lpstmOut->Write (buf, 1, NULL));

            // Inc Total
            cbTotal++;

        } while (buf[0] != '\n');
    }

exit:    
    if (pcbActual)
        *pcbActual = cbTotal;
    return hr;
}

// --------------------------------------------------------------------------------
// HrCopyStream2 - copies lpstmIn to two out streams - caller must do the commit
// --------------------------------------------------------------------------------
HRESULT HrCopyStream2(LPSTREAM lpstmIn, LPSTREAM  lpstmOut1, LPSTREAM lpstmOut2, ULONG *pcb)
{
    // Locals
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead = 0, cbWritten = 0, cbTotal = 0;

    do
    {
        CHECKHR (hr = lpstmIn->Read (buf, sizeof (buf), &cbRead));
        if (cbRead == 0) break;
        CHECKHR (hr = lpstmOut1->Write (buf, cbRead, &cbWritten));
        Assert (cbWritten == cbRead);
        CHECKHR (hr = lpstmOut2->Write (buf, cbRead, &cbWritten));
        Assert (cbWritten == cbRead);
        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));

exit:    
    if (pcb)
        *pcb = cbTotal;
    return hr;
}

// --------------------------------------------------------------------------------
// HrCopyStreamToFile
// --------------------------------------------------------------------------------
HRESULT HrCopyStreamToFile (LPSTREAM lpstm, HANDLE hFile, ULONG *pcb)
{
    // Locals
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead = 0, cbWritten = 0, cbTotal = 0;
    BOOL           bResult;

    do
    {
        // Read a block
        CHECKHR (hr = lpstm->Read (buf, sizeof (buf), &cbRead));
        if (cbRead == 0) break;

        // Write the block to the file
        bResult = WriteFile (hFile, buf, cbRead, &cbWritten, NULL);
        if (bResult == FALSE || cbWritten != cbRead)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Keep Track of Total bytes written
        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));

exit:    
    // Set Total
    if (pcb)
        *pcb = cbTotal;

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrStreamToByte
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrStreamToByte(LPSTREAM lpstm, LPBYTE *lppb, ULONG *pcb)
{
    // Locals
    HRESULT         hr = S_OK;
    ULONG           cbRead, cbSize;

    // Check Params
    AssertSz (lpstm && lppb, "Null Parameter");

    CHECKHR(hr = HrGetStreamSize(lpstm, &cbSize));
    CHECKHR(hr = HrRewindStream(lpstm));

    // Allocate Memory
    CHECKHR(hr = HrAlloc((LPVOID *)lppb, cbSize + 10));

    // Read Everything to lppsz
    CHECKHR(hr = lpstm->Read(*lppb, cbSize, &cbRead));
    if (cbRead != cbSize)
    {
        hr = TrapError(S_FALSE);
        goto exit;
    }

    // Outbound size
    if (pcb)
        *pcb = cbSize;
    
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrCopyStream
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, OPTIONAL ULONG *pcb)
{
    // Locals
    HRESULT        hr = S_OK;
    BYTE           buf[STMTRNSIZE];
    ULONG          cbRead=0,
                   cbTotal=0;

    do
    {
        CHECKHR(hr = pstmIn->Read(buf, sizeof(buf), &cbRead));
        if (cbRead == 0) break;
        CHECKHR(hr = pstmOut->Write(buf, cbRead, NULL));
        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));

exit:    
    if (pcb)
        *pcb = cbTotal;
    return hr;
}

// --------------------------------------------------------------------------------
// HrCopyStreamToByte
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrCopyStreamToByte(LPSTREAM lpstmIn, LPBYTE pbDest, ULONG *pcb)
{
    // Locals
    HRESULT        hr=S_OK;
    BYTE           buf[STMTRNSIZE];
    ULONG          cbRead=0, 
                   cbTotal=0;

    do
    {
        // Read a buffer from stream
        CHECKHR(hr = lpstmIn->Read (buf, sizeof (buf), &cbRead));

        // Nothing Read...
        if (cbRead == 0) 
            break;

        // Copy that
        CopyMemory(pbDest + cbTotal, buf, cbRead);

        // Increment total
        cbTotal += cbRead;

    } while (cbRead == sizeof(buf));

exit:    
    // Set total
    if (pcb)
        *pcb = cbTotal;
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrByteToStream
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb)
{
    // Locals
    HRESULT hr=S_OK;

    // Check Params
    AssertSz(lppstm && lpb, "Null Parameter");

    // Create H Global Stream
    CHECKHR(hr = CreateStreamOnHGlobal (NULL, TRUE, lppstm));

    // Write String
    CHECKHR(hr = (*lppstm)->Write (lpb, cb, NULL));

    // Rewind the steam
    CHECKHR(hr = HrRewindStream(*lppstm));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrRewindStream
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrRewindStream(LPSTREAM pstm)
{
    // Locals
    HRESULT        hr=S_OK;
    LARGE_INTEGER  liOrigin = {0,0};

    // Check Params
    Assert(pstm);

    // Seek to 0
    CHECKHR(hr = pstm->Seek(liOrigin, STREAM_SEEK_SET, NULL));

exit:    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrGetStreamPos
// --------------------------------------------------------------------------------
HRESULT HrGetStreamPos(LPSTREAM pstm, ULONG *piPos)
{
    // Locals
    HRESULT        hr=S_OK;
    ULARGE_INTEGER uliPos   = {0,0};
    LARGE_INTEGER  liOrigin = {0,0};

    // check Params
    Assert(piPos && pstm);

    // Seek
    CHECKHR(hr = pstm->Seek(liOrigin, STREAM_SEEK_CUR, &uliPos));

    // Set position
    *piPos = uliPos.LowPart;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrGetStreamSize
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrGetStreamSize(LPSTREAM pstm, ULONG *pcb)
{
    // Locals
    HRESULT hr=S_OK;
    ULARGE_INTEGER uliPos = {0,0};
    LARGE_INTEGER liOrigin = {0,0};

    // check params
    Assert(pcb && pstm);

    // Seek
    CHECKHR(hr = pstm->Seek(liOrigin, STREAM_SEEK_END, &uliPos));

    // set size
    *pcb = uliPos.LowPart;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrSafeGetStreamSize
// --------------------------------------------------------------------------------
HRESULT HrSafeGetStreamSize(LPSTREAM pstm, ULONG *pcb)
{
    // Locals
    HRESULT        hr=S_OK;
    ULONG          iPos;
    ULARGE_INTEGER uliPos = {0,0};
    LARGE_INTEGER  liOrigin = {0,0};

    // check params
    Assert(pcb && pstm);

    // Get the stream position
    CHECKHR(hr = HrGetStreamPos(pstm, &iPos));

    // Seek
    CHECKHR(hr = pstm->Seek(liOrigin, STREAM_SEEK_END, &uliPos));

    // set size
    *pcb = uliPos.LowPart;

    // Seek back to original position
    CHECKHR(hr = HrStreamSeekSet(pstm, iPos));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrStreamSeekSet
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrStreamSeekSet(LPSTREAM pstm, ULONG iPos)
{
    // Locals
    HRESULT       hr=S_OK;
    LARGE_INTEGER liOrigin;

    // Check Params
    Assert(pstm);

    // Set Origin Correctly
    liOrigin.QuadPart = iPos;

    // Seek
    CHECKHR(hr = pstm->Seek(liOrigin, STREAM_SEEK_SET, NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrStreamSeekEnd
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrStreamSeekEnd(LPSTREAM pstm)
{
    // Locals
    HRESULT       hr=S_OK;
    LARGE_INTEGER liOrigin = {0,0};

    // Check Params
    Assert(pstm);

    // Seek
    CHECKHR(hr = pstm->Seek(liOrigin, STREAM_SEEK_END, NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrStreamSeekBegin
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrStreamSeekBegin(LPSTREAM pstm)
{
    // Locals
    HRESULT       hr=S_OK;
    LARGE_INTEGER liOrigin = {0,0};

    // Check Params
    Assert(pstm);

    // Seek
    CHECKHR(hr = pstm->Seek(liOrigin, STREAM_SEEK_SET, NULL));

exit:
    // Done
    return hr;

}

// --------------------------------------------------------------------------------
// HrStreamSeekCur
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrStreamSeekCur(LPSTREAM pstm, LONG iPos)
{
    // Locals
    HRESULT       hr=S_OK;
    LARGE_INTEGER liOrigin;

    // Check Params
    Assert(pstm);

    // Setup Origin
    liOrigin.QuadPart = iPos;

    // Seek
    CHECKHR(hr = pstm->Seek(liOrigin, STREAM_SEEK_CUR, NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CreateFileStream
// --------------------------------------------------------------------------------
HRESULT CreateFileStream(
        LPWSTR                  pszFile, 
        DWORD                   dwDesiredAccess,
        DWORD                   dwShareMode,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
        DWORD                   dwCreationDistribution,
        DWORD                   dwFlagsAndAttributes,
        HANDLE                  hTemplateFile,
        LPSTREAM               *ppstmFile)
{
    // Locals
    HRESULT             hr=S_OK;
    FILESTREAMINFO      rInfo;
    CFileStream        *pstmFile=NULL;
    WCHAR               szTempDir[MAX_PATH];

    // check params
    if (NULL == ppstmFile)
        return TrapError(E_INVALIDARG);

    // Check Params
    Assert(dwDesiredAccess & GENERIC_READ || dwDesiredAccess & GENERIC_WRITE);

    // Setup File Stream Info struct
    ZeroMemory(&rInfo, sizeof(rInfo));
    rInfo.dwDesiredAccess = dwDesiredAccess;
    rInfo.dwShareMode = dwShareMode;
    if (lpSecurityAttributes)
        CopyMemory(&rInfo.rSecurityAttributes, lpSecurityAttributes, sizeof(SECURITY_ATTRIBUTES));
    rInfo.dwCreationDistribution = dwCreationDistribution;
    rInfo.dwFlagsAndAttributes = dwFlagsAndAttributes;
    rInfo.hTemplateFile = hTemplateFile;

    // Create Object
    pstmFile = new CFileStream();
    if (NULL == pstmFile)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Temp File ?
    if (NULL == pszFile)
    {
        // Get Temp Dir
        DWORD nBufferLength = AthGetTempPathW(ARRAYSIZE(szTempDir), szTempDir);

        if (nBufferLength == 0 || nBufferLength > ARRAYSIZE(szTempDir))
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Get Temp File Name
        UINT uFile = AthGetTempFileNameW(szTempDir, L"tmp", 0, rInfo.szFilePath);
        if (uFile == 0)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
#ifdef DEBUG
        else if (g_fSimulateFullDisk)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
#endif

        // Delete When Done
        rInfo.dwFlagsAndAttributes |= FILE_FLAG_DELETE_ON_CLOSE;

        // Always create a new temp file
        rInfo.dwCreationDistribution = OPEN_EXISTING;
    }
    else
    {
        // Copy filename
        StrCpyNW(rInfo.szFilePath, pszFile, ARRAYSIZE(rInfo.szFilePath));
    }

    // Open it
    CHECKHR(hr = pstmFile->Open(&rInfo));


    // Success
    *ppstmFile = pstmFile;
    pstmFile = NULL;

exit:
    // Cleanup
    SafeRelease(pstmFile);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CreateTempFileStream
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) CreateTempFileStream(LPSTREAM *ppstmFile)
{
    return CreateFileStream(NULL, 
                            GENERIC_READ | GENERIC_WRITE, 
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, 
                            OPEN_ALWAYS, 
                            FILE_ATTRIBUTE_NORMAL, 
                            NULL, 
                            ppstmFile);
}

// --------------------------------------------------------------------------------
// OpenFileStream
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) OpenFileStream(LPSTR pszFile, DWORD dwCreationDistribution, 
    DWORD dwAccess, LPSTREAM *ppstmFile)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pszFileW=NULL;

    // Trace
    TraceCall("OpenFileStream");

    // Convert
    IF_NULLEXIT(pszFileW = PszToUnicode(CP_ACP, pszFile));

    // Call unicode version
    IF_FAILEXIT(hr = OpenFileStreamW(pszFileW, dwCreationDistribution, dwAccess, ppstmFile));

exit:
    // Cleanup
    SafeMemFree(pszFileW);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// OpenFileStreamW
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) OpenFileStreamW(LPWSTR pszFile, DWORD dwCreationDistribution, 
    DWORD dwAccess, LPSTREAM *ppstmFile)
{
    Assert(pszFile);
    return CreateFileStream(pszFile, 
                            dwAccess,
                            FILE_SHARE_READ | FILE_SHARE_WRITE, 
                            NULL, 
                            dwCreationDistribution,  
                            FILE_ATTRIBUTE_NORMAL, 
                            NULL, 
                            ppstmFile);
}

// --------------------------------------------------------------------------------
// OpenFileStreamWithFlags
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) OpenFileStreamWithFlags(LPSTR pszFile, DWORD dwCreationDistribution, 
    DWORD dwAccess, DWORD dwFlagsAndAttributes, LPSTREAM *ppstmFile)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pszFileW=NULL;

    // Trace
    TraceCall("OpenFileStreamWithFlags");

    // Convert to unicode
    IF_NULLEXIT(pszFileW = PszToUnicode(CP_ACP, pszFile));

    // Call unicode version
    IF_FAILEXIT(hr = OpenFileStreamWithFlagsW(pszFileW, dwCreationDistribution, dwAccess, dwFlagsAndAttributes, ppstmFile));

exit:
    // Cleanup
    SafeMemFree(pszFileW);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// OpenFileStreamWithFlagsW
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) OpenFileStreamWithFlagsW(LPWSTR pszFile, DWORD dwCreationDistribution, 
    DWORD dwAccess, DWORD dwFlagsAndAttributes, LPSTREAM *ppstmFile)
{
    Assert(pszFile);
    return CreateFileStream(pszFile, 
                            dwAccess,
                            FILE_SHARE_READ | FILE_SHARE_WRITE, 
                            NULL, 
                            dwCreationDistribution,  
                            dwFlagsAndAttributes, 
                            NULL, 
                            ppstmFile);
}

// --------------------------------------------------------------------------------
// WriteStreamToFile
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) WriteStreamToFile(LPSTREAM pstm, LPSTR lpszFile, DWORD dwCreationDistribution, DWORD dwAccess)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pszFileW=NULL;

    // Trace
    TraceCall("WriteStreamToFile");

    // Convert to unicode
    IF_NULLEXIT(pszFileW = PszToUnicode(CP_ACP, lpszFile));

    // Call Unicode Version
    IF_FAILEXIT(hr = WriteStreamToFileW(pstm, pszFileW, dwCreationDistribution, dwAccess));

exit:
    // Cleanup
    SafeMemFree(pszFileW);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// WriteStreamToFileW
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) WriteStreamToFileW(LPSTREAM pstm, LPWSTR lpszFile, DWORD dwCreationDistribution, DWORD dwAccess)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTREAM    pstmFile=NULL;

    // Open the stream
    IF_FAILEXIT(hr = OpenFileStreamW(lpszFile, dwCreationDistribution, dwAccess, &pstmFile));

    // Rewind
    IF_FAILEXIT(hr = HrRewindStream(pstm));

    // Copy
    IF_FAILEXIT(hr = HrCopyStream (pstm, pstmFile, NULL));

    // Rewind
    IF_FAILEXIT(hr = HrRewindStream(pstm));

exit:
    // Cleanup
    SafeRelease(pstmFile);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// OpenFileStreamShare
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) OpenFileStreamShare(LPSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, 
    DWORD dwShare, LPSTREAM *ppstmFile)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pszFileW=NULL;

    // Trace
    TraceCall("OpenFileStreamShare");

    // Convert to unicode
    IF_NULLEXIT(pszFileW = PszToUnicode(CP_ACP, pszFile));

    // Call unicode versoin
    IF_FAILEXIT(hr = OpenFileStreamShareW(pszFileW, dwCreationDistribution, dwAccess, dwShare, ppstmFile));

exit:
    // Cleanup
    SafeMemFree(pszFileW);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// OpenFileStreamShareW
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT) OpenFileStreamShareW(LPWSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, 
    DWORD dwShare, LPSTREAM *ppstmFile)
{
    Assert(pszFile);
    return CreateFileStream(pszFile, 
                            dwAccess,
                            dwShare,
                            NULL, 
                            dwCreationDistribution,  
                            FILE_ATTRIBUTE_NORMAL, 
                            NULL, 
                            ppstmFile);
}

// --------------------------------------------------------------------------------
// CFileStream::Constructor
// --------------------------------------------------------------------------------
CFileStream::CFileStream(void)
{
    m_cRef = 1;
    m_hFile = INVALID_HANDLE_VALUE;
    ZeroMemory(&m_rInfo, sizeof(FILESTREAMINFO));
}

// --------------------------------------------------------------------------------
// CFileStream::Deconstructor
// --------------------------------------------------------------------------------
CFileStream::~CFileStream(void)
{
    Close();
}

// --------------------------------------------------------------------------------
// CFileStream::AddRef
// --------------------------------------------------------------------------------
ULONG CFileStream::AddRef ()
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CFileStream::Release
// --------------------------------------------------------------------------------
ULONG CFileStream::Release ()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CFileStream::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CFileStream::QueryInterface (REFIID iid, LPVOID* ppvObj)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, IID_IStream))
    {
        *ppvObj = this;
        AddRef();
        return(S_OK);
    }
    return E_NOINTERFACE;
}

// --------------------------------------------------------------------------------
// CFileStream::Open
// --------------------------------------------------------------------------------
HRESULT CFileStream::Open(LPFILESTREAMINFO pFileStreamInfo)
{
    // Better not be open
    Assert(m_hFile == INVALID_HANDLE_VALUE);

    // Copy File Info
    CopyMemory(&m_rInfo, pFileStreamInfo, sizeof(FILESTREAMINFO));

    // Open the file
    m_hFile = AthCreateFileW(m_rInfo.szFilePath, m_rInfo.dwDesiredAccess, m_rInfo.dwShareMode, 
                        NULL, m_rInfo.dwCreationDistribution, 
                       m_rInfo.dwFlagsAndAttributes, m_rInfo.hTemplateFile);

    // Error
    if (INVALID_HANDLE_VALUE == m_hFile)
        return TrapError(E_FAIL);
#ifdef DEBUG
    else if (g_fSimulateFullDisk)
        return TrapError(E_FAIL);
#endif

    // Success
    return S_OK;
}

// --------------------------------------------------------------------------------
// CFileStream::Close
// --------------------------------------------------------------------------------
void CFileStream::Close(void)
{
    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        CloseHandle_F16(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }
}

// --------------------------------------------------------------------------------
// CFileStream::Read
// --------------------------------------------------------------------------------
STDMETHODIMP CFileStream::Read (void HUGEP_16 *lpv, ULONG cb, ULONG *pcbRead)
{
    // Locals
    HRESULT             hr = S_OK;
    BOOL                fReturn;
    DWORD               dwRead;

    // Check Params
    Assert(lpv && m_hFile != INVALID_HANDLE_VALUE);

    // Read some bytes from m_hFile
    fReturn = ReadFile (m_hFile, lpv, cb, &dwRead, NULL);
    if (!fReturn)
    {
        AssertSz(FALSE, "CFileStream::Read Failed");
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Write byte
    if (pcbRead)
        *pcbRead = dwRead;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CFileStream::Write
// --------------------------------------------------------------------------------
STDMETHODIMP CFileStream::Write(const void HUGEP_16 *lpv, ULONG cb, ULONG *pcbWritten)
{
    // Locals
    HRESULT             hr = S_OK;
    BOOL                fReturn;
    DWORD               dwWritten;

    // Check Params
    Assert(lpv);
    Assert(m_hFile != INVALID_HANDLE_VALUE);

    // Read some bytes from m_hFile
    fReturn = WriteFile(m_hFile, lpv, cb, &dwWritten, NULL);
    if (!fReturn)
    {
        AssertSz (FALSE, "CFileStream::Write Failed");
        hr = TrapError(E_FAIL);
        goto exit;
    }
#ifdef DEBUG
    else if (g_fSimulateFullDisk)
    {
        AssertSz (FALSE, "CFileStream::Write Failed");
        hr = TrapError(E_FAIL);
        goto exit;
    }
#endif

    // Write byte
    if (pcbWritten)
        *pcbWritten = dwWritten;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CFileStream::Seek
// --------------------------------------------------------------------------------
STDMETHODIMP CFileStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    // Locals
    HRESULT             hr = S_OK;
    DWORD               dwReturn;
    LONG                lMove;        // Cast to signed, could be negative

    Assert (m_hFile != INVALID_HANDLE_VALUE);

    // Cast lowpart
    lMove = (LONG)dlibMove.QuadPart;

    // Seek the file pointer
    switch (dwOrigin)
    {
   	case STREAM_SEEK_SET:
        dwReturn = SetFilePointer (m_hFile, lMove, NULL, FILE_BEGIN);
        break;

    case STREAM_SEEK_CUR:
        dwReturn = SetFilePointer (m_hFile, lMove, NULL, FILE_CURRENT);
        break;

    case STREAM_SEEK_END:
        dwReturn = SetFilePointer (m_hFile, lMove, NULL, FILE_END);
        break;
    default:
        dwReturn = 0xFFFFFFFF;
    }

    // Failure ?
    if (dwReturn == 0xFFFFFFFF)
    {
        AssertSz(FALSE, "CFileStream::Seek Failed");
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Return Position
    if (plibNewPosition)
        plibNewPosition->QuadPart = dwReturn;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CFileStream::Commit
// --------------------------------------------------------------------------------
STDMETHODIMP CFileStream::Commit(DWORD)
{
    // Locals
    HRESULT             hr = S_OK;

    Assert(m_hFile != INVALID_HANDLE_VALUE);

    // Flush the buffers
    if (FlushFileBuffers (m_hFile) == FALSE)
    {
        AssertSz(FALSE, "FlushFileBuffers failed");
        hr = TrapError(E_FAIL);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CFileStream::SetSize
// --------------------------------------------------------------------------------
STDMETHODIMP CFileStream::SetSize (ULARGE_INTEGER uli)
{
    DWORD   dwOrig;

    // remember the current file position
    dwOrig = SetFilePointer (m_hFile, 0, NULL, FILE_CURRENT);
    if (dwOrig == 0xFFFFFFFF)
    {
        AssertSz(FALSE, "Get current position failed");
        return TrapError(E_FAIL);
    }
        
            
    // Seek to dwSize
    if (SetFilePointer (m_hFile, uli.LowPart, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        AssertSz(FALSE, "SetFilePointer failed");
        return TrapError(STG_E_MEDIUMFULL);
    }

    // SetEndOfFile
    if (SetEndOfFile (m_hFile) == FALSE)
    {
        AssertSz(FALSE, "SetEndOfFile failed");
        return TrapError(STG_E_MEDIUMFULL);
    }

    // if the original position we less than the new size, return the file
    // pointer to the original position
    if (dwOrig < uli.LowPart)
    {
        if (SetFilePointer (m_hFile, dwOrig, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        {
            AssertSz(FALSE, "SetFilePointer failed");
            return TrapError(STG_E_MEDIUMFULL);
        }
    }        
    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CFileStream::CopyTo
// This needs to be written better, but for now it's no worse that what a
// client would do
// --------------------------------------------------------------------------------
STDMETHODIMP CFileStream::CopyTo (LPSTREAM pstmDst,
                                  ULARGE_INTEGER uli,
                                  ULARGE_INTEGER* puliRead,
                                  ULARGE_INTEGER* puliWritten)
{
    ULONG   cbBuf;
    ULONG   cbCopy;
    VOID *  pvBuf       = 0;
    BYTE    rgBuf[STMTRNSIZE];
    ULONG   cbRemain;
    ULONG   cbReadTot   = 0;
    ULONG   cbWriteTot  = 0;
    HRESULT hr          = 0;
    

    if (uli.HighPart)
        cbRemain = 0xFFFFFFFF;
    else
        cbRemain = uli.LowPart;
    
    // Attempt to allocate a buffer

    cbBuf = (UINT)cbRemain;

    if (cbBuf > STMTRNSIZE)
        cbBuf = STMTRNSIZE;

    // Copy the data one buffer at a time

    while (cbRemain > 0)
    {
        // Compute maximum bytes to copy this time

        cbCopy = cbRemain;
        if (cbCopy > cbBuf)
            cbCopy = cbBuf;

        // Read into the buffer
        hr = Read (rgBuf, cbCopy,  &cbCopy);
        if (FAILED(hr))
            goto err;

        if (cbCopy == 0)
            break;

        cbReadTot   += cbCopy;
        cbRemain    -= cbCopy;

        // Write buffer into the destination stream

        {
            ULONG cbWrite = cbCopy;

            while (cbWrite)
            {
                hr = pstmDst->Write(rgBuf, cbWrite, &cbCopy);
                if (FAILED(hr))
                    goto err;

                cbWriteTot += cbCopy;
                cbWrite    -= cbCopy;

                if (cbCopy == 0)
                    break;
            }
        }
    }
    
err:    
    if (puliRead)
    {
        puliRead->HighPart = 0;
        puliRead->LowPart  = cbReadTot;
    }

    if (puliWritten)
    {
        puliWritten->HighPart   = 0;
        puliWritten->LowPart    = cbWriteTot;
    }
    
    return (hr);
}

// --------------------------------------------------------------------------------
// CFileStream::Revert
// --------------------------------------------------------------------------------
STDMETHODIMP CFileStream::Revert ()
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CFileStream::LockRegion
// --------------------------------------------------------------------------------
STDMETHODIMP CFileStream::LockRegion (ULARGE_INTEGER, ULARGE_INTEGER,DWORD)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CFileStream::UnlockRegion
// --------------------------------------------------------------------------------
STDMETHODIMP CFileStream::UnlockRegion (ULARGE_INTEGER, ULARGE_INTEGER, DWORD)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CFileStream::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CFileStream::Stat (STATSTG*, DWORD)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CFileStream::Clone
// --------------------------------------------------------------------------------
STDMETHODIMP CFileStream::Clone (LPSTREAM*)
{
    return E_NOTIMPL;
}

DWORD RemoveCRLF(LPSTR pszT, DWORD cbT, BOOL * pfBadDBCS)
{
    DWORD i = 0;
    
    *pfBadDBCS = FALSE;
    
    while (i < cbT)
    {
        if (IsDBCSLeadByte(pszT[i]))
        {
            if ((i + 1) >= cbT)
            {
                cbT--;
                *pfBadDBCS = TRUE;
                break;
            }

            i += 2;
        }
        else if ('\n' == pszT[i] || '\r' == pszT[i])
        {
            MoveMemory(pszT + i, pszT + (i + 1), cbT - i);
            cbT--;
        }
        else
        {
            i++;
        }
    }

    return cbT;
}

#define CB_STREAMMATCH  0x00000FFF
// --------------------------------------------------------------------------------
// StreamSubStringMatch
// --------------------------------------------------------------------------------
OESTDAPI_(BOOL) StreamSubStringMatch(LPSTREAM pstm, CHAR * pszSearch)
{
    BOOL            fRet = FALSE;
    ULONG           cbSave = 0;
    LONG            cbSize = 0;
    CHAR            rgchBuff[CB_STREAMMATCH + 1];
    LPSTR           pszRead = NULL;
    ULONG           cbRead = 0;
    ULONG           cbIn = 0;
    BOOL            fBadDBCS = FALSE;
    CHAR            chSave = 0;

    // Check incoming params
    if ((NULL == pstm) || (NULL == pszSearch))
    {
        goto exit;
    }

    // We want to save off the entire string and
    // a possible ending lead byte...
    cbSave = lstrlen(pszSearch);
    
    // Get the stream size
    if (FAILED(HrGetStreamSize(pstm, (ULONG *) &cbSize)))
    {
        goto exit;
    }

    // Reset the stream to the beginning
    if (FAILED(HrRewindStream(pstm)))
    {
        goto exit;
    }

    // Set up the defaults
    pszRead = rgchBuff;
    cbRead = CB_STREAMMATCH;
    
    // Search for string through the entire stream
    while ((cbSize > 0) && (S_OK == pstm->Read(pszRead, cbRead, &cbIn)))
    {
        // We're done if we read nothing...
        if (0 == cbIn)
        {
            goto exit;
        }
        
        // Note that we've read the bytes
        cbSize -= cbIn;
        
        // Raid 2741: FIND: OE: FE: Find Text/Message to be able to find wrapped DBCS words in plain text message body
        cbIn = RemoveCRLF(rgchBuff, (DWORD) (cbIn + pszRead - rgchBuff), &fBadDBCS);

        // Do we need to save the char
        if (FALSE != fBadDBCS)
        {
            chSave = rgchBuff[cbIn];
        }

        // Terminate the buffer
        rgchBuff[cbIn] = '\0';
        
        // Search for string
        if (NULL != StrStrIA(rgchBuff, pszSearch))
        {
            fRet = TRUE;
            break;
        }
        
        // Are we done with the stream
        if (0 >= cbSize)
        {
            break;
        }

        // Do we need to restore the char
        if (FALSE != fBadDBCS)
        {
            rgchBuff[cbIn] = chSave;
            cbIn++;
        }

        // Save part of the buffer
        
        // How much space do we have in the buffer
        cbRead = CB_STREAMMATCH - cbSave;
        
        // Save the characters
        MoveMemory(rgchBuff, rgchBuff + cbIn - cbSave, cbSave);

        // Figure out the new start of the buffer
        pszRead = rgchBuff + cbSave;
    }

exit:
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\protstor.cpp ===
/*
**  p r o t s t o r . c p p
**   
**  Purpose:
**      Functions to provide blob-level access to the pstore
**
**  Note:
**      LocalAlloc/Free are used for memory allocation
**
**  History
**      2/12/97: (t-erikne) created
**   
**    Copyright (C) Microsoft Corp. 1997.
*/

///////////////////////////////////////////////////////////////////////////
// 
// Depends on
//

#include "pch.hxx"
#include <pstore.h>
#include "wstrings.h"
#include <error.h>
#ifdef MAC
#include <mapinls.h>
#endif  // !MAC
#include <BadStrFunctions.h>

///////////////////////////////////////////////////////////////////////////
// 
// Static Things
//

static void     _PST_GenerateTagName(LPWSTR pwsz, DWORD cch, DWORD offset);

#ifdef DEBUG

#define test3sub_string L"Test 3 SUBType"
// {220D5CC2-853A-11d0-84BC-00C04FD43F8F}
static GUID test3sub = 
{ 0x220d5cc2, 0x853a, 0x11d0, { 0x84, 0xbc, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f } };

// {4E741310-850D-11d0-84BB-00C04FD43F8F}
static GUID NOT_EXIST = 
{ 0x4e741310, 0x850d, 0x11d0, { 0x84, 0xbb, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f } };

// {FFAC62F0-8533-11d0-84BC-00C04FD43F8F}
#define NoRuleSubType_string L"Foobar bang with no rules"
static GUID NoRuleSubType = 
{ 0xffac62f0, 0x8533, 0x11d0, { 0x84, 0xbc, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f } };

#endif

///////////////////////////////////////////////////////////////////////////
// 
// Functions
//

OESTDAPI_(HRESULT) PSTSetNewData(
        IN IPStore *const      pISecProv,
        IN const GUID *const   guidType,
        IN const GUID *const   guidSubt,
        IN LPCWSTR             wszAccountName,
        IN const BLOB *const   pclear,
        OUT BLOB *const        phandle)
{
    HRESULT             hr = S_OK;
    const int           cchLookup = 80;
    WCHAR               wszLookup[cchLookup];
    PST_PROMPTINFO      PromptInfo = { sizeof(PST_PROMPTINFO), 0, NULL, L""};
    DWORD               count = 0;
    BYTE                *pb = NULL;

    if (!(pISecProv &&
        guidType && guidSubt &&
        wszAccountName &&
        pclear && pclear->pBlobData && pclear->cbSize))
        return E_INVALIDARG;

    if (phandle)
        phandle->pBlobData = NULL;

    StrCpyNW(wszLookup, wszAccountName, cchLookup);

    do
        {
        // if they didn't give us an out param for the lookup, then it is
        // dumb to make one.  Just try the AccountName
        if (phandle)
            _PST_GenerateTagName(wszLookup, cchLookup, count++);

        hr = pISecProv->WriteItem(
            PST_KEY_CURRENT_USER,
            guidType,
            guidSubt,
            wszLookup,
            pclear->cbSize,
            pclear->pBlobData,
            &PromptInfo,
            PST_CF_NONE,
            PST_NO_OVERWRITE);

        if (!phandle)
            {
            // if we didn't get an out param, we are done regardless
            break;
            }
        }
    while (PST_E_ITEM_EXISTS == hr);

    if (SUCCEEDED(hr))
        {
        // we created it

        if (phandle)
            {
            phandle->cbSize = (lstrlenW(wszLookup) + 1) * sizeof(WCHAR);

            //NOTE: LocalAlloc is our memory allocator
            phandle->pBlobData = (BYTE *)LocalAlloc(LMEM_ZEROINIT, phandle->cbSize);
            if (!phandle->pBlobData)
                {
                hr = E_OUTOFMEMORY;
                goto exit;
                }
            StrCpyNW((LPWSTR)phandle->pBlobData, wszLookup, (phandle->cbSize / sizeof(wszLookup[0])));
            }
        }

exit:
    return hr;
}

OESTDAPI_(HRESULT) PSTGetData(
        IN IPStore *const      pISecProv,
        IN const GUID *const   guidType,
        IN const GUID *const   guidSubt,
        IN LPCWSTR             wszLookupName,
        OUT BLOB *const        pclear)
{
    HRESULT             hr;
    PST_PROMPTINFO      PromptInfo = { sizeof(PST_PROMPTINFO), 0, NULL, L""};

    pclear->pBlobData = NULL;
    pclear->cbSize = 0;

    if (!(pISecProv && wszLookupName && pclear))
        return E_INVALIDARG;
    
    if (SUCCEEDED(hr = pISecProv->OpenItem(
        PST_KEY_CURRENT_USER,
        guidType,
        guidSubt,
        wszLookupName,
        PST_READ,
        &PromptInfo,
        0)))
        {
        hr = pISecProv->ReadItem(
            PST_KEY_CURRENT_USER,
            guidType,
            guidSubt,
            wszLookupName,
            &pclear->cbSize,
            &pclear->pBlobData,  // ppbData
            &PromptInfo,        // pPromptInfo
            0);                 // dwFlags

        // don't care if this fails
        pISecProv->CloseItem(
            PST_KEY_CURRENT_USER,
            guidType,
            guidSubt,
            wszLookupName,
            0);
        }

    if (FAILED(TrapError(hr)))
        hr = hrPasswordNotFound;
    return hr;
}

OESTDAPI_(LPWSTR) WszGenerateNameFromBlob(IN BLOB blob)
{
    LPWSTR      szW = NULL;
    TCHAR       szT[100];
    DWORD       *pdw;
    TCHAR       *pt;
    int         i, max;
    DWORD       cch;

    if (blob.cbSize > ARRAYSIZE(szT) ||
        blob.cbSize % sizeof(DWORD))
        return NULL;

    cch = (blob.cbSize*2)+1;
    szW = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, cch*sizeof(WCHAR));
    if (!szW)
        return NULL;

    pt = szT;
    szT[0] = '\000';
    pdw = (DWORD *)blob.pBlobData;

    max = blob.cbSize / sizeof(DWORD);
    for (i = 0; i < max; i++, pdw++)
    {
        DWORD cchLeft = (ARRAYSIZE(szT) - (DWORD)(pt - szT) - 1);             // Good old typing will convert the pointer math to # of chars instead of # of bytes.
        if (cchLeft)
        {
            pt += wnsprintf(pt, cchLeft, "%X", *pdw);
        }
    }
    *pt = '\000';

    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szT, cch, szW, cch);
    szW[cch-1] = 0;

    return szW;
}

OESTDAPI_(void) PSTFreeHandle(LPBYTE pb)
{
    if (pb)
        LocalFree((HLOCAL)pb);
}

OESTDAPI_(HRESULT) PSTCreateTypeSubType_NoUI(
        IN IPStore *const     pISecProv,
        IN const GUID *const  guidType,
        IN LPCWSTR            szType,
        IN const GUID *const  guidSubt,
        IN LPCWSTR            szSubt)
{
#ifdef ENABLE_RULES
    PST_ACCESSRULESET   RuleSet;
    PST_ACCESSRULE      rgRules[2];
#endif
    PST_TYPEINFO        Info;
    HRESULT             hr;

    if (!pISecProv)
        return E_INVALIDARG;

    Info.cbSize = sizeof(PST_TYPEINFO);

    // if type is not available the create it
    Info.szDisplayName = (LPWSTR)szType;
    if (S_OK != (hr = pISecProv->CreateType(PST_KEY_CURRENT_USER,
                                            guidType,
                                            &Info,
                                            0)))
    {
        if (PST_E_TYPE_EXISTS != hr)
            goto exit;
    }

    // make rules for read, write access
#ifdef ATH_RELEASE_BUILD
#error Need to enable access rules for protected store passwords? (t-erikne)
#endif

#ifdef ENABLE_RULES
    // Do Rule Stuff

    RuleSet.cbSize = sizeof(PST_ACCESSRULESET);
    RuleSet.cRules = 2;
    RuleSet.rgRules = rgRules;

    //PST_BINARYCHECKDATA bindata;
    PST_ACCESSCLAUSE    rgClauses[1];
    //N need to or on on the authenticode stuff
    // derive the calling exe (me) and only allow access to me
    rgClauses[0].ClaTYPE_GUID = PST_CURRENT_EXE;
    rgClauses[0].cbClauseData = 0;
    rgClauses[0].pbClauseData = NULL;
    rgRules[0].AccessModeFlags = PST_READ;        // READ:    just exe
    rgRules[0].cClauses = 1;
    rgRules[0].rgClauses = rgClauses;
    rgRules[1].AccessModeFlags = PST_WRITE;       // WRITE:   just exe
    rgRules[1].cClauses = 1;
    rgRules[1].rgClauses = rgClauses;
#endif

    // create the server password subtype
    Info.szDisplayName = (LPWSTR)szSubt;
    if (S_OK != 
        (hr = pISecProv->CreateSubtype(
                                        PST_KEY_CURRENT_USER,
                                        guidType,
                                        guidSubt,
                                        &Info,
#ifdef ENABLE_RULES
                                        &Rules,
#else
                                        NULL,
#endif
                                        0)))
    {
        if (PST_E_TYPE_EXISTS != hr)
            goto exit;
    }

    hr = S_OK;  // cool if we made it here
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////
// 
// Static utility functions
//

void _PST_GenerateTagName(LPWSTR pwsz, DWORD cch, DWORD offset)
{
    SYSTEMTIME  stNow;
    FILETIME    ftNow;
    const int   cchArrLen = 32;
    WCHAR       wszTime[cchArrLen];
    TCHAR       szT[cchArrLen];
    UINT        ich=0;
    UINT        cchLen=lstrlenW(pwsz);

    GetLocalTime(&stNow);
    ZeroMemory(&ftNow, sizeof(ftNow));
    SystemTimeToFileTime(&stNow, &ftNow);

    // Raid 48394 - 2 backslashes in account friendly name causes the account to not be fully created
    while (ich < cchLen)
    {
        if (L'\\' == pwsz[ich])
        {
            MoveMemory((LPBYTE)pwsz + (sizeof(WCHAR) * ich), (LPBYTE)pwsz + ((ich + 1) * sizeof(WCHAR)), (cchLen - ich) * sizeof(WCHAR));
            cchLen--;
        }
        else
            ich++;
    }

    wnsprintf(szT, ARRAYSIZE(szT), TEXT("%08.8lX"), ftNow.dwLowDateTime+offset);
    if (MultiByteToWideChar(CP_ACP, 0, szT, -1, wszTime, cchArrLen))
    {
        const int cchTime = lstrlenW(wszTime);
        if (long(cch) > lstrlenW(pwsz)+cchTime)
            StrCatBuffW(pwsz, wszTime, cch);
        else
            StrCpyNW(&pwsz[cch-cchTime-1], wszTime, (cchTime + 1));
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\unicnvrt.h ===
#ifndef __UNICNVRT__
#define __UNICNVRT__

#include "wtypes.h"

extern BOOL g_bRunningOnNT; //set in dllmain.cpp

UINT AthGetTempFileNameW(
        LPCWSTR lpPathName,
        LPCWSTR lpPrefixString,
        UINT    uUnique,
        LPWSTR  lpTempFileName);

DWORD AthGetTempPathW(
        DWORD nBufferLength, 
        LPWSTR lpBuffer);

HANDLE AthCreateFileW(
        LPCWSTR                 lpFileName,
        DWORD                   dwDesiredAccess,
        DWORD                   dwShareMode,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
        DWORD                   dwCreationDisposition,
        DWORD                   dwFlagsAndAttributes,
        HANDLE                  hTemplateFile);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\strutil.cpp ===
// --------------------------------------------------------------------------
// Strutil.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------
#include "pch.hxx"
#include <iert.h>
#include "dllmain.h"
#include "oertpriv.h"
#include <wininet.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <qstrcmpi.h>
#include <shlwapi.h>
#include "unicnvrt.h"
#include <BadStrFunctions.h>

// conversion from 'int' to 'unsigned short', possible loss of data
#pragma warning (disable:4244) 

// --------------------------------------------------------------------------
// g_szMonths
// --------------------------------------------------------------------------
static const LPSTR g_szMonths[] = { 
    "Jan", "Feb", "Mar", 
    "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", 
    "Oct", "Nov", "Dec"
};

// --------------------------------------------------------------------------
// g_szDays
// --------------------------------------------------------------------------
static const LPSTR g_szDays[] = { 
    "Sun", 
    "Mon", 
    "Tue", 
    "Wed", 
    "Thu", 
    "Fri", 
    "Sat"
};

// --------------------------------------------------------------------------
// g_rgZones
// --------------------------------------------------------------------------
static const INETTIMEZONE g_rgZones[] = { 
    { "UT",  0,  0 }, 
    { "GMT", 0,  0 },
    { "EST", 5,  0 }, 
    { "EDT", 4,  0 },
    { "CST", 6,  0 }, 
    { "CDT", 5,  0 },
    { "MST", 7,  0 }, 
    { "MDT", 6,  0 },
    { "PST", 8,  0 }, 
    { "PDT", 7,  0 },
    { "KST", -9, 0 },
    { "JST", -9, 0 },
    {  NULL, 0,  0 } 
};

// --------------------------------------------------------------------------------
// How big is the thread local storage string buffer
// -------------------------------------------------------------------------------
#define CBMAX_THREAD_TLS_BUFFER 512

// --------------------------------------------------------------------------------
// ThreadAllocateTlsMsgBuffer
// -------------------------------------------------------------------------------
void ThreadAllocateTlsMsgBuffer(void)
{
    if (g_dwTlsMsgBuffIndex != 0xffffffff)
        TlsSetValue(g_dwTlsMsgBuffIndex, NULL);
}

// --------------------------------------------------------------------------------
// ThreadFreeTlsMsgBuffer
// -------------------------------------------------------------------------------
void ThreadFreeTlsMsgBuffer(void)
{
    if (g_dwTlsMsgBuffIndex != 0xffffffff)
    {
        LPSTR psz = (LPSTR)TlsGetValue(g_dwTlsMsgBuffIndex);
        SafeMemFree(psz);
        SideAssert(0 != TlsSetValue(g_dwTlsMsgBuffIndex, NULL));
    }
}

// --------------------------------------------------------------------------------
// PszGetTlsBuffer
// -------------------------------------------------------------------------------
LPSTR PszGetTlsBuffer(void)
{
    // Get the buffer
    LPSTR pszBuffer = (LPSTR)TlsGetValue(g_dwTlsMsgBuffIndex);

    // If buffer has not been allocated
    if (NULL == pszBuffer)
    {
        // Allocate it
        pszBuffer = (LPSTR)g_pMalloc->Alloc(CBMAX_THREAD_TLS_BUFFER);

        // Store it
        Assert(pszBuffer);
        SideAssert(0 != TlsSetValue(g_dwTlsMsgBuffIndex, pszBuffer));
    }

    // Done
    return pszBuffer;
}

// --------------------------------------------------------------------------------
// _MSG - Used to build a string from variable length args, thread-safe
// -------------------------------------------------------------------------------
OESTDAPI_(LPCSTR) _MSG(LPSTR pszFormat, ...) 
{
    // Locals
    va_list     arglist;
    LPSTR       pszBuffer=NULL;

    // I use tls to hold the buffer
    if (g_dwTlsMsgBuffIndex != 0xffffffff)
    {
        // Setup the arglist
        va_start(arglist, pszFormat);

        // Get the Buffer
        pszBuffer = PszGetTlsBuffer();

        // If we have a buffer
        if (pszBuffer)
        {
            // Format the data
            wvnsprintf(pszBuffer, (CBMAX_THREAD_TLS_BUFFER - sizeof(pszBuffer[0])), pszFormat, arglist);
        }

        // End the arglist
        va_end(arglist);
    }

    return ((LPCSTR)pszBuffer);
}

// --------------------------------------------------------------------------
// StrChrExA
// --------------------------------------------------------------------------
OESTDAPI_(LPCSTR) StrChrExA(UINT codepage, LPCSTR pszString, CHAR ch)
{
    // Locals
    LPSTR pszT=(LPSTR)pszString;

    // Loop for ch in pszString
    while(*pszT)
    {
        // Lead Byte
        if (IsDBCSLeadByteEx(codepage, *pszT))
            pszT++;
        else if (*pszT == ch)
            return pszT;
        pszT++;
    }

    // Not Found
    return NULL;
}

// --------------------------------------------------------------------------
// PszDayFromIndex
// --------------------------------------------------------------------------
OESTDAPI_(LPCSTR) PszDayFromIndex(ULONG ulIndex)
{
    // Invalid Arg
    Assert(ulIndex <= 6);

    // Adjust ulIndex
    ulIndex = (ulIndex > 6) ? 0 : ulIndex;

    // Return
    return g_szDays[ulIndex];
}

// --------------------------------------------------------------------------
// PszMonthFromIndex (ulIndex is one-based)
// --------------------------------------------------------------------------
OESTDAPI_(LPCSTR) PszMonthFromIndex(ULONG ulIndex)
{
    // Invalid Arg
    Assert(ulIndex >= 1 && ulIndex <= 12);

    // Adjust ulIndex
    ulIndex = (ulIndex < 1 || ulIndex > 12) ? 0 : ulIndex - 1;

    // Return
    return g_szMonths[ulIndex];
}

// --------------------------------------------------------------------------
// HrFindInetTimeZone
// --------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrFindInetTimeZone(LPCSTR pszTimeZone, LPINETTIMEZONE pTimeZone)
{
    // Invalid Arg
    Assert(pszTimeZone && pTimeZone);

    // Loop timezone table
    for (ULONG iZoneCode=0; g_rgZones[iZoneCode].lpszZoneCode!=NULL; iZoneCode++)
    {
        // Is this the code...
        if (lstrcmpi(pszTimeZone, g_rgZones[iZoneCode].lpszZoneCode) == 0)
        {
            CopyMemory(pTimeZone, &g_rgZones[iZoneCode], sizeof(INETTIMEZONE));
            return S_OK;
        }
    }

    // Not Found
    return E_FAIL;
}

// --------------------------------------------------------------------------
// HrIndexOfMonth
// --------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrIndexOfMonth(LPCSTR pszMonth, ULONG *pulIndex)
{
    // Invalid Arg
    Assert(pszMonth && pulIndex);

    // Loop the Months
    for (ULONG iMonth=0; iMonth < ARRAYSIZE(g_szMonths); iMonth++)
    {
        // Is this the month
        if (OEMstrcmpi(pszMonth, g_szMonths[iMonth]) == 0)
        {
            // Set It
            *pulIndex = (iMonth + 1);

            // Validate
            AssertSz(*pulIndex >= 1 && *pulIndex <= 12, "HrIndexOfMonth - Bad Month");

            // Done
            return S_OK;
        }
    }

    *pulIndex = 0;

    // Not Found
    return E_FAIL;
}

// --------------------------------------------------------------------------
// HrIndexOfWeek
// --------------------------------------------------------------------------
OESTDAPI_(HRESULT) HrIndexOfWeek(LPCSTR pszDay, ULONG *pulIndex)
{
    // Invalid Arg
    Assert(pszDay && pulIndex);

    // Loop the Days
    for (ULONG iDayOfWeek=0; iDayOfWeek < ARRAYSIZE(g_szDays); iDayOfWeek++)
    {
        // Is this the day
        if (OEMstrcmpi(pszDay, g_szDays[iDayOfWeek]) == 0)
        {
            // Set Day Of Week
            *pulIndex = iDayOfWeek;

            // Validate
            AssertSz(((int) *pulIndex) >= 0 && ((int) *pulIndex) <= 6, "HrIndexOfDay - Bad day of week");

            // Done
            return S_OK;
        }
    }

    *pulIndex = 0;

    // Failure
    return E_FAIL;
}

// --------------------------------------------------------------------------
// PszEscapeMenuStringA
//
// Escapes & characters with another & so that they show up correctly when shown
// in a menu. 
// --------------------------------------------------------------------------------
OESTDAPI_(LPSTR) PszEscapeMenuStringA(LPCSTR pszSource, LPSTR pszQuoted, int cchMax)
{
    LPSTR pszT=pszQuoted;
    int cch = 1;    // 1 is intentional

    Assert(pszSource);
    Assert(pszQuoted);

    while((cch < cchMax) && (*pszSource))
    {
        if (IsDBCSLeadByte(*pszSource))
            {
            cch++;
            // Is there only space for lead byte?
            if (cch == cchMax)
                // Yes, don't write it
                break;
            else
                *pszT++ = *pszSource++;
            }
        else if ('&' == *pszSource)
            {
            cch++;
            if (cch == cchMax)
                break;
            else
                *pszT++ = '&';
            }

        // Only way this could fail is if there was a DBCSLeadByte with no trail byte
        Assert(*pszSource);

        *pszT++ = *pszSource++;
        cch++;
    }
    *pszT = 0;

    return pszQuoted;
}

// --------------------------------------------------------------------------------
// PszSkipWhiteA
// --------------------------------------------------------------------------
OESTDAPI_(LPSTR) PszSkipWhiteA(LPSTR psz)
{
    while(*psz && (*psz == ' ' || *psz == '\t'))
        psz++;
    return psz;
}

OESTDAPI_(LPWSTR) PszSkipWhiteW(LPWSTR psz)
{
    while(*psz && (*psz == L' ' || *psz == L'\t'))
        psz++;
    return psz;
}

// --------------------------------------------------------------------------
// PszScanToWhiteA
// --------------------------------------------------------------------------
OESTDAPI_(LPSTR) PszScanToWhiteA(LPSTR psz)
{
    while(*psz && ' ' != *psz && '\t' != *psz)
        psz++;
    return psz;
}

// --------------------------------------------------------------------------
// PszScanToCharA
// --------------------------------------------------------------------------
OESTDAPI_(LPSTR) PszScanToCharA(LPSTR psz, CHAR ch)
{
    while(*psz && ch != *psz)
        psz++;
    return psz;
}

// --------------------------------------------------------------------------
// PszDupLenA
// duplicates a string with upto cchMax characters in (and a null term)
// --------------------------------------------------------------------------
OESTDAPI_(LPSTR) PszDupLenA(LPCSTR pcszSource, int cchMax)
{
    // Locals
    LPSTR   pszDup=NULL;

    // No Source
    if (pcszSource == NULL || cchMax == 0)
        goto exit;

    // the amount to copy if the min of the max and the
    // source
    cchMax = min(lstrlen(pcszSource), cchMax);

    // Allocate the String
    pszDup = PszAllocA(cchMax+1);  // +1 for null term
    if (!pszDup)
        goto exit;

    // Copy the data, leave room for the null-term
    CopyMemory(pszDup, pcszSource, cchMax);

    // null terminate
    pszDup[cchMax] = 0;

exit:
    // Done
    return pszDup;
}

// --------------------------------------------------------------------------
// PszFromANSIStreamA - pstm is assumed to be an ANSI stream
// --------------------------------------------------------------------------
OESTDAPI_(LPSTR) PszFromANSIStreamA(LPSTREAM pstm)
{
    // Locals
    HRESULT         hr;
    LPSTR           psz=NULL;
    ULONG           cb;

    // Get stream size
    hr = HrGetStreamSize(pstm, &cb);
    if (FAILED(hr))
    {
        Assert(FALSE);
        return NULL;
    }

    // Rewind the stream
    HrRewindStream(pstm);

    // Allocate a buffer
    if ((psz = PszAllocA(cb + 1)) != NULL)
    {
        // Read a buffer from stream
        hr = pstm->Read(psz, cb, NULL);
        if (FAILED(hr))
        {
            Assert(FALSE);
            MemFree(psz);
            return NULL;
        }

        // Null Terminate
        *(psz + cb) = '\0';
    }

    // Done
    return psz;
}

// --------------------------------------------------------------------------
// PszFromANSIStreamW  - pstm is assumed to be an ANSI stream
// --------------------------------------------------------------------------
LPWSTR PszFromANSIStreamW(UINT cp, LPSTREAM pstm)
{
    // Get ANSI string
    LPSTR psz = PszFromANSIStreamA(pstm);
    if (NULL == psz)
        return NULL;

    // Convert to unicode
    LPWSTR pwsz = PszToUnicode(cp, psz);
    
    // Done
    return pwsz;
}

// --------------------------------------------------------------------------
// ConvertFromHex - Converts a hexdigit into a numerica value
// --------------------------------------------------------------------------
OESTDAPI_(CHAR) ChConvertFromHex (CHAR ch)
{
    if (ch >= '0' && ch <= '9')
        return CHAR((ch - '0'));

    else if (ch >= 'A'&& ch <= 'F')
        return CHAR(((ch - 'A') + 10));

    else if (ch >= 'a' && ch <= 'f')
        return CHAR(((ch - 'a') + 10));

    else
        return ((CHAR)(BYTE)255);
}

// --------------------------------------------------------------------------
// FIsValidRegKeyNameA
// --------------------------------------------------------------------------
BOOL FIsValidRegKeyNameA(LPSTR pszKey)
{
    // Locals
    LPSTR psz=pszKey;

    // If Empty...
    if (FIsEmptyA(pszKey))
        return FALSE;

    // Check for backslashes
    while(*psz)
    {
        if (*psz == '\\')
            return FALSE;
        psz = CharNextA(psz);
    }

    // Its ok
    return TRUE;
}

// --------------------------------------------------------------------------
// FIsValidRegKeyNameW
// --------------------------------------------------------------------------
BOOL FIsValidRegKeyNameW(LPWSTR pwszKey)
{
    // Locals
    LPWSTR pwsz=pwszKey;

    // If Empty...
    if (FIsEmptyW(pwszKey))
        return FALSE;

    // Check for backslashes
    while(*pwsz)
    {
        if (*pwsz == L'\\')
            return FALSE;
        pwsz = CharNextW(pwsz);
    }

    // Its ok
    return TRUE;
}

// --------------------------------------------------------------------------
// FIsSpaceA
// --------------------------------------------------------------------------
OESTDAPI_(BOOL) FIsSpaceA(LPSTR psz)
{
    WORD wType = 0;

    if (IsDBCSLeadByte(*psz))
        SideAssert(GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
    else
        SideAssert(GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
    return (wType & C1_SPACE);
}

// --------------------------------------------------------------------------
// FIsSpaceW
// --------------------------------------------------------------------------
OESTDAPI_(BOOL) FIsSpaceW(LPWSTR pwsz)
{
    BOOL result = FALSE;

    if (S_OK == IsPlatformWinNT())
    {
        WORD wType = 0;
        SideAssert(GetStringTypeExW(LOCALE_USER_DEFAULT, CT_CTYPE1, pwsz, 1, &wType));
        result = (wType & C1_SPACE);
    }
    else
    {
        LPSTR psz = PszToANSI(CP_ACP, pwsz);
        if (psz)
            result = FIsSpaceA(psz);
        MemFree(psz);
    }

    return result;
}

// --------------------------------------------------------------------------
// FIsEmptyA
// --------------------------------------------------------------------------
OESTDAPI_(BOOL) FIsEmptyA(LPCSTR pcszString)
{
    // Locals
    LPSTR psz;

    // Bad Pointer
    if (!pcszString)
        return TRUE;

	// Check for All spaces
    psz = (LPSTR)pcszString;
    while (*psz)
    {
        if (FIsSpaceA(psz) == FALSE)
            return FALSE;
        psz++;
    }

	// Done
	return TRUE;
}

// --------------------------------------------------------------------------
// FIsEmptyW
// --------------------------------------------------------------------------
OESTDAPI_(BOOL) FIsEmptyW(LPCWSTR pcwszString)
{
    // Locals
    LPWSTR pwsz;

    // Bad Pointer
    if (!pcwszString)
        return TRUE;

	// Check for All spaces
    pwsz = (LPWSTR)pcwszString;
    while (*pwsz)
    {
        if (FIsSpaceW(pwsz) == FALSE)
            return FALSE;
        pwsz++;
    }

	// Done
	return TRUE;
}

// --------------------------------------------------------------------------
// PszAllocA
// --------------------------------------------------------------------------
OESTDAPI_(LPSTR) PszAllocA(INT nLen)
{
    // Locals
    LPSTR  psz=NULL;

    // Empty ?
    if (nLen == 0)
        goto exit;

    // Allocate
    if (FAILED(HrAlloc((LPVOID *)&psz, (nLen + 1) * sizeof (CHAR))))
        goto exit;
    
exit:
    // Done
    return psz;
}

// --------------------------------------------------------------------------
// PszAllocW
// --------------------------------------------------------------------------
OESTDAPI_(LPWSTR) PszAllocW(INT nLen)
{
    // Locals
    LPWSTR  pwsz=NULL;

    // Empty ?
    if (nLen == 0)
        goto exit;

    // Allocate
    if (FAILED(HrAlloc((LPVOID *)&pwsz, (nLen + 1) * sizeof (WCHAR))))
        goto exit;
    
exit:
    // Done
    return pwsz;
}

// --------------------------------------------------------------------------
// PszToUnicode
// --------------------------------------------------------------------------
OESTDAPI_(LPWSTR) PszToUnicode(UINT cp, LPCSTR pcszSource)
{
    // Locals
    INT         cchNarrow,
                cchWide;
    LPWSTR      pwszDup=NULL;

    // No Source
    if (pcszSource == NULL)
        goto exit;

    // Length
    cchNarrow = lstrlenA(pcszSource) + 1;

    // Determine how much space is needed for translated widechar
    cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, NULL, 0);

    // Error
    if (cchWide == 0)
        goto exit;

    // Alloc temp buffer
    pwszDup = PszAllocW(cchWide + 1);
    if (!pwszDup)
        goto exit;

    // Do the actual translation
	cchWide = MultiByteToWideChar(cp, MB_PRECOMPOSED, pcszSource, cchNarrow, pwszDup, cchWide+1);

    // Error
    if (cchWide == 0)
    {
        SafeMemFree(pwszDup);
        goto exit;
    }

exit:
    // Done
    return pwszDup;
}

// --------------------------------------------------------------------------
// PszToANSI
// --------------------------------------------------------------------------
OESTDAPI_(LPSTR) PszToANSI(UINT cp, LPCWSTR pcwszSource)
{
    // Locals
    INT         cchNarrow,
                cchWide;
    LPSTR       pszDup=NULL;

    // No Source
    if (pcwszSource == NULL)
        goto exit;

    // Length
    cchWide = lstrlenW(pcwszSource)+1;

    // Determine how much space is needed for translated widechar
    cchNarrow = WideCharToMultiByte(cp, 0, pcwszSource, cchWide, NULL, 0, NULL, NULL);

    // Error
    if (cchNarrow == 0)
        goto exit;

    // Alloc temp buffer
    pszDup = PszAllocA(cchNarrow + 1);
    if (!pszDup)
        goto exit;

    // Do the actual translation
	cchNarrow = WideCharToMultiByte(cp, 0, pcwszSource, cchWide, pszDup, cchNarrow+1, NULL, NULL);

    // Error
    if (cchNarrow == 0)
    {
        SafeMemFree(pszDup);
        goto exit;
    }

exit:
    // Done
    return pszDup;
}

// --------------------------------------------------------------------------
// PszDupA
// --------------------------------------------------------------------------
OESTDAPI_(LPSTR) PszDupA(LPCSTR pcszSource)
{
    // Locals
    INT     nLen;
    LPSTR   pszDup=NULL;

    // No Source
    if (pcszSource == NULL)
        goto exit;

    // Get String Length
    nLen = lstrlenA(pcszSource) + 1;

    // Allocate the String
    pszDup = PszAllocA(nLen);
    if (!pszDup)
        goto exit;

    // Copy the data
    CopyMemory(pszDup, pcszSource, nLen);

exit:
    // Done
    return pszDup;
}

// --------------------------------------------------------------------------
// PszDupW
// --------------------------------------------------------------------------
OESTDAPI_(LPWSTR) PszDupW(LPCWSTR pcwszSource)
{
    // Locals
    INT     nLen;
    LPWSTR  pwszDup=NULL;

    // No Source
    if (pcwszSource == NULL)
        goto exit;

    // Get String Length
    nLen = lstrlenW(pcwszSource) + 1;

    // Allocate the String
    pwszDup = PszAllocW(nLen);
    if (!pwszDup)
        goto exit;

    // Copy the data
    CopyMemory(pwszDup, pcwszSource, nLen * sizeof(WCHAR));

exit:
    // Done
    return pwszDup;
}

// --------------------------------------------------------------------------
// StripCRLF
// --------------------------------------------------------------------------
OESTDAPI_(void) StripCRLF(LPSTR lpsz, ULONG *pcb)
{
    // Null ?
    AssertSz (lpsz && pcb, "NULL Parameter");

    // If length is zero, then return
    if (!lpsz || !pcb || (*pcb == 0))
    {
        Assert(0);
        return;
    }

    // Check last three characters of the string, last char might or might not be a null-term
    LONG iLast = (*pcb) - 2;
    if (iLast < 0)
        iLast = 0;
    for (LONG i=(*pcb); i>=iLast; i--)
    {
        // Is end character a '\n'
        if (lpsz[i] == chLF)
        {
            lpsz[i] = '\0';
            (*pcb)--;
        }

        // Is end character a '\r'
        if (lpsz[i] == chCR)
        {
            lpsz[i] = '\0';
            (*pcb)--;
        }
    }
        
    return;
}

// --------------------------------------------------------------------------
// ToUpper
// --------------------------------------------------------------------------
TCHAR ToUpper(TCHAR c)
{
    return (TCHAR)LOWORD(CharUpper(MAKEINTRESOURCE(c)));
}

// --------------------------------------------------------------------------
// IsPrint
// --------------------------------------------------------------------------
OESTDAPI_(int) IsPrint(LPSTR psz)
{
    WORD wType;
    if (IsDBCSLeadByte(*psz))
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
    else
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
    return !(wType & C1_CNTRL);
}

// --------------------------------------------------------------------------
// IsDigit
// --------------------------------------------------------------------------
OESTDAPI_(int) IsDigit(LPSTR psz)
{
    WORD wType;
    if (IsDBCSLeadByte(*psz))
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
    else
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
    return (wType & C1_DIGIT);
}

// --------------------------------------------------------------------------
// IsXDigit
// --------------------------------------------------------------------------
int IsXDigit(LPSTR psz)
{
    WORD wType;
    if (IsDBCSLeadByte(*psz))
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
    else
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
    return (wType & C1_XDIGIT);
}

// --------------------------------------------------------------------------
// IsUpper
// --------------------------------------------------------------------------
OESTDAPI_(INT) IsUpper(LPSTR psz)
{
    WORD wType;
    if (IsDBCSLeadByte(*psz))
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
    else
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
    return (wType & C1_UPPER);
}

// --------------------------------------------------------------------------
// IsAlpha
// --------------------------------------------------------------------------
int IsAlpha(LPSTR psz)
{
    WORD wType;
    if (IsDBCSLeadByte(*psz))
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
    else
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
    return (wType & C1_ALPHA);
}

// --------------------------------------------------------------------------
// IsPunct
// --------------------------------------------------------------------------
int IsPunct(LPSTR psz)
{
    WORD wType;
    if (IsDBCSLeadByte(*psz))
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 2, &wType));
    else
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, psz, 1, &wType));
    return (wType & C1_PUNCT);
}

// --------------------------------------------------------------------------
// strsave
// --------------------------------------------------------------------------
char *strsave(char *s)
{
    char *p;

    if (!s)
        return NULL;

    DWORD cchSize = (lstrlen(s)+1);
    if (MemAlloc((LPVOID*)&p, cchSize * sizeof(p[0])))
    {
        StrCpyN(p, s, cchSize);
    }

    return p;
}

// --------------------------------------------------------------------------
// strtrim
// --------------------------------------------------------------------------
OESTDAPI_(LPSTR) strtrim(char *s)
{
    char *p;

    for (p = s; *p; p++)
        ;
    for (--p ; (p>=s) && StrChr(" \t\r\n",*p); --p) 
        *p = '\0';
    while (*s && StrChr(" \t\r\n",*s))
        ++s;
    return s;
}

OESTDAPI_(LPWSTR) strtrimW(WCHAR *s)
{
    WCHAR *p;

    for (p = s; *p; p++)
        ;
    for (--p ; (p>=s) && StrChrW(L" \t\r\n",*p); --p) 
        *p = '\0';
    while (*s && StrChrW(L" \t\r\n",*s))
        ++s;
    return s;
}

// --------------------------------------------------------------------------
// strappend
// --------------------------------------------------------------------------
void strappend(char **pp, char *s)
{
    char *p;
  
    Assert(pp);
  
    if (!s)
        return;
  
    if (!*pp) 
        {
        DWORD cchSize = (lstrlen(s)+1);
        if (!MemAlloc((LPVOID*)&p, cchSize * sizeof(p[0])))
            return;
        StrCpyNA(p, s, cchSize);
        } 
    else 
        {
        DWORD cchSize = (lstrlen(s) + lstrlen(*pp) + 2);
        if (!MemAlloc((LPVOID*)&p, cchSize * sizeof(p[0])))
            return;
        StrCpyNA(p, *pp, cchSize);
        StrCatBuffA(p, "\r", cchSize);
        StrCatBuffA(p, s, cchSize);
        MemFree(*pp);
        }
    
    *pp = p;
}

OESTDAPI_(ULONG) UlStripWhitespace(LPTSTR lpsz, BOOL fLeading, BOOL fTrailing, ULONG *pcb)
{
    // Locals
    ULONG           cb;
    LPTSTR          psz;
        
    Assert(lpsz != NULL);
    Assert(fLeading || fTrailing);

    // Did the user pass in the length
    if (pcb)
        cb = *pcb;
    else
        cb = lstrlen (lpsz);

    if (cb == 0)
        return cb;

    if (fLeading)
    {
        psz = lpsz;
        
        while (FIsSpace(psz))
        {
            psz++;
            cb--;
        }
        
        if (psz != lpsz)
            // get the NULL at the end too
            MoveMemory(lpsz, psz, (cb + 1) * sizeof(TCHAR));
    }
    
    if (fTrailing)
    {
        psz = lpsz + cb;
        
        while (cb > 0)
        {
            if (!FIsSpace(psz-1))
                break;
            psz--;
            cb--;
        }    
        
        // NULL Term
        *psz = '\0';
    }
    
    // Set String Size
    if (pcb)
        *pcb = cb;
    
    // Done
    return cb;
}

OESTDAPI_(ULONG) UlStripWhitespaceW(LPWSTR lpwsz, BOOL fLeading, BOOL fTrailing, ULONG *pcb)
{
    // Locals
    ULONG           cb;
    LPWSTR          pwsz;
    
    Assert(lpwsz != NULL);
    Assert(fLeading || fTrailing);
    
    // Did the user pass in the length
    if (pcb)
        cb = *pcb;
    else
        cb = lstrlenW(lpwsz)* sizeof(WCHAR) ; // multiply by sizeof(WCHAR) to get correct byte size.
    
    if (cb == 0)
        return cb;
    
    if (fLeading)
    {
        pwsz = lpwsz;
        
        while (FIsSpaceW(pwsz))
        {
            pwsz++;
            cb -= sizeof(*pwsz);
        }
        
        if (pwsz != lpwsz)
            // get the NULL at the end too
            MoveMemory(lpwsz, pwsz, cb + sizeof(WCHAR));
    }
    
    if (fTrailing)
    {
        pwsz = lpwsz + cb / sizeof(WCHAR); // Divided by size of WCHAR to get right pointer 
        
        while (cb > 0)
        {
            if (!FIsSpaceW(pwsz - 1))
                break;
            pwsz--;
            cb -= sizeof(*pwsz);
        }    
        
        // NULL Term
        *pwsz = L'\0';
    }
    
    // Set String Size
    if (pcb)
        *pcb = cb;
    
    // Done
    return cb;
}

// =============================================================================================
// Converts first two characters of lpcsz to a WORD
// =============================================================================================
SHORT ASCII_NFromSz (LPCSTR lpcsz)
{
    char acWordStr[3];
    Assert (lpcsz);
    CopyMemory (acWordStr, lpcsz, 2 * sizeof (char));
    acWordStr[2] = '\0';
    return ((SHORT) (StrToInt (acWordStr)));
}



// =================================================================================
// Adjust the time at lpSysTime by adding the given lHoursToAdd &
// lMinutesToAdd. Returns the adjusted time at lpFileTime.
// =================================================================================
HRESULT HrAdjustTime (LPSYSTEMTIME lpSysTime, LONG lHoursToAdd, LONG lMinutesToAdd, LPFILETIME lpFileTime)
{
    // Locals
    HRESULT         hr = S_OK;
    BOOL            bResult = FALSE;
    LONG            lUnitsToAdd = 0;
    LARGE_INTEGER   liTime;
	LONGLONG        liHoursToAdd = 1i64, liMinutesToAdd = 1i64;

    // Check Params
    AssertSz (lpSysTime && lpFileTime, "Null Parameter");

    // Convert sys time to file time
    if (!SystemTimeToFileTime (lpSysTime, lpFileTime))
    {
        hr = TRAPHR (E_FAIL);
        DebugTrace( "SystemTimeToFileTime() failed, dwError=%d.\n", GetLastError());
        goto Exit;
    }

    // Init
    liTime.LowPart  = lpFileTime->dwLowDateTime;
    liTime.HighPart = lpFileTime->dwHighDateTime;

    // Adjust the hour
    if (lHoursToAdd != 0)
    {
        lUnitsToAdd = lHoursToAdd * 3600;
        liHoursToAdd *= lUnitsToAdd;
        liHoursToAdd *= 10000000i64;
        liTime.QuadPart += liHoursToAdd;
    }

    // Adjust the minutes
    if (lMinutesToAdd != 0)
    {
        lUnitsToAdd = lMinutesToAdd * 60;
        liMinutesToAdd *= lUnitsToAdd;
        liMinutesToAdd *= 10000000i64;
        liTime.QuadPart += liMinutesToAdd;
    }

    // Assign the result to FILETIME
    lpFileTime->dwLowDateTime  = liTime.LowPart;
    lpFileTime->dwHighDateTime = liTime.HighPart;

Exit:
    return hr;
}

// =================================================================================
// Addjust the time at lpSysTime according to the given Zone info,
// Returns the adjusted time at lpFileTime.
// =================================================================================
BOOL ProcessZoneInfo (LPSTR lpszZoneInfo, INT *lpcHoursToAdd, INT *lpcMinutesToAdd)
{
    // Locals
    ULONG           cbZoneInfo;
    BOOL            bResult;

    // Init
    *lpcHoursToAdd = 0;
    *lpcMinutesToAdd = 0;
    cbZoneInfo = lstrlen (lpszZoneInfo);
    bResult = TRUE;

    // +hhmm or -hhmm
    if ((*lpszZoneInfo == '-' || *lpszZoneInfo == '+') && cbZoneInfo <= 5)
    {
        // Take off 
        cbZoneInfo-=1;

        // determine the hour/minute offset
        if (cbZoneInfo == 4)
        {
            *lpcMinutesToAdd = (INT)StrToInt (lpszZoneInfo+3);
            *(lpszZoneInfo+3) = 0x00;
            *lpcHoursToAdd = (INT)StrToInt(lpszZoneInfo+1);
        }

        // 3
        else if (cbZoneInfo == 3)
        {
            *lpcMinutesToAdd = (INT)StrToInt (lpszZoneInfo+2);
            *(lpszZoneInfo+2) = 0x00;
            *lpcHoursToAdd = (INT)StrToInt (lpszZoneInfo+1);
        }

        // 2
        else if (cbZoneInfo == 2 || cbZoneInfo == 1)
        {
            *lpcMinutesToAdd = 0;
            *lpcHoursToAdd = (INT)StrToInt(lpszZoneInfo+1);
        }
        
        if (*lpszZoneInfo == '+')
        {
            *lpcHoursToAdd = -*lpcHoursToAdd;
            *lpcMinutesToAdd = -*lpcMinutesToAdd;
        }
    }

    //  Xenix conversion:  TZ = current time zone or other unknown tz types.
    else if (lstrcmpi (lpszZoneInfo, "TZ") == 0 || 
             lstrcmpi (lpszZoneInfo, "LOCAL") == 0 ||
             lstrcmpi (lpszZoneInfo, "UNDEFINED") == 0)
    {
        TIME_ZONE_INFORMATION tzi ;
        DWORD dwRet = GetTimeZoneInformation (&tzi);
        if (dwRet != 0xFFFFFFFF)
        {
            LONG cMinuteBias = tzi.Bias;

            if (dwRet == TIME_ZONE_ID_STANDARD)
                cMinuteBias += tzi.StandardBias ;

            else if (dwRet == TIME_ZONE_ID_DAYLIGHT)
                cMinuteBias += tzi.DaylightBias ;

            *lpcHoursToAdd = cMinuteBias / 60 ;
            *lpcMinutesToAdd = cMinuteBias % 60 ;
        }
        else
        {
            AssertSz (FALSE, "Why would this happen");
            bResult = FALSE;
        }
    }

    // Loop through known time zone standards
    else
    {
        for (INT i=0; g_rgZones[i].lpszZoneCode!=NULL; i++)
        {
            if (lstrcmpi (lpszZoneInfo, g_rgZones[i].lpszZoneCode) == 0)
            {
                *lpcHoursToAdd = g_rgZones[i].cHourOffset;
                *lpcMinutesToAdd = g_rgZones[i].cMinuteOffset;
                break;
            }
        }

        if (g_rgZones[i].lpszZoneCode == NULL)
        {
            DebugTrace( "Unrecognized zone info: [%s]\n", lpszZoneInfo );
            bResult = FALSE;
        }
    }

    return bResult;
}


#define IS_DIGITA(ch)    (ch >= '0' && ch <= '9')
#define IS_DIGITW(ch)    (ch >= L'0' && ch <= L'9')

// ---------------------------------------------------------------------------------------
// StrToUintA
// ---------------------------------------------------------------------------------------
OESTDAPI_(UINT) StrToUintA(LPCSTR lpSrc)
{
    UINT n = 0;

    Assert(*lpSrc != '-');

    while (IS_DIGITA(*lpSrc))
        {
        n *= 10;
        n += *lpSrc - '0';
        lpSrc++;
        }
    return n;
}

// ---------------------------------------------------------------------------------------
// StrToUintW
// ---------------------------------------------------------------------------------------
OESTDAPI_(UINT) StrToUintW(LPCWSTR lpSrc)
{
    UINT n = 0;

    Assert(*lpSrc != '-');

    while (IS_DIGITW(*lpSrc))
        {
        n *= 10;
        n += *lpSrc - L'0';
        lpSrc++;
        }
    return n;
}

// ---------------------------------------------------------------------------------------
// FIsValidFileNameCharW
// ---------------------------------------------------------------------------------------
OESTDAPI_(BOOL) FIsValidFileNameCharW(WCHAR wch)
{
    // Locals
    LPWSTR pwsz;
    static const WCHAR s_pwszBad[] = L"<>:\"/\\|?*";

    pwsz = (LPWSTR)s_pwszBad;
    while(*pwsz)
    {
        if (wch == *pwsz)
            return FALSE;
        pwsz++;
    }

    // Shouldn't allow any control chars
    if ((wch >= 0x0000) && (wch < 0x0020))
        return FALSE;

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------
// FIsValidFileNameCharA
// --------------------------------------------------------------------------
OESTDAPI_(BOOL) FIsValidFileNameCharA(UINT codepage, CHAR ch)
{
    // Locals
    LPSTR psz;
    static const CHAR s_szBad[] = "<>:\"/\\|?*";

    psz = (LPSTR)s_szBad;
    while(*psz)
    {
        if (IsDBCSLeadByteEx(codepage, *psz))
            psz++;
        else if (ch == *psz)
            return FALSE;
        psz++;
    }

    // Shouldn't allow any control chars
    if ((ch >= 0x00) && (ch < 0x20))
        return FALSE;

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------
// CleanupFileNameInPlaceA
// --------------------------------------------------------------------------
OESTDAPI_(ULONG) EXPORT_16 CleanupFileNameInPlaceA(UINT codepage, LPSTR psz)
{
    UINT    ich=0;
    UINT    cch=lstrlen(psz);

    // Fixup codepage?
    if (1200 == codepage)
        codepage = CP_ACP;

    // Loop and remove invalid chars
	while (ich < cch)
	{
        // If lead byte, skip it, its leagal
        if (IsDBCSLeadByteEx(codepage, psz[ich]))
            ich+=2;

        // Illeagl file name character ?
        else if (!FIsValidFileNameCharA(codepage, psz[ich]))
        {
			MoveMemory (psz + ich, psz + (ich + 1), cch - ich);
			cch--;
        }
        else
            ich++;
    }

    // Return the Length
    return cch;
}

// --------------------------------------------------------------------------
// CleanupFileNameInPlaceW
// --------------------------------------------------------------------------
OESTDAPI_(ULONG) EXPORT_16 CleanupFileNameInPlaceW(LPWSTR pwsz)
{
    // Locals
    ULONG ich=0;
    ULONG cch=lstrlenW(pwsz);

    // Loop and remove invalids
	while (ich < cch)
	{
        // Illeagl file name character ?
        if (!FIsValidFileNameCharW(pwsz[ich]))
            pwsz[ich]=L'_';
        
        ich++;
    }

    // Return the length
    return cch;
}

// =============================================================================================
// ReplaceChars
// =============================================================================================
OESTDAPI_(INT) EXPORT_16 ReplaceChars(LPCSTR pszString, CHAR chFind, CHAR chReplace)
{
    // Locals
    LPSTR pszT=(LPSTR)pszString;
    DWORD nCount=0;

    // Loop for ch in pszString
    while(*pszT)
    {
        // Lead Byte
        if (IsDBCSLeadByte(*pszT))
            pszT++;
        else if (*pszT == chFind)
        {
            *pszT = chReplace;
            nCount++;
        }
        pszT++;
    }

    // Not Found
    return nCount;
}

OESTDAPI_(INT) EXPORT_16 ReplaceCharsW(LPCWSTR pszString, WCHAR chFind, WCHAR chReplace)
{
    // Locals
    LPWSTR pszT = (LPWSTR)pszString;
    DWORD nCount=0;

    // Loop for ch in pszString
    while(*pszT)
    {
        if (*pszT == chFind)
        {
            *pszT = chReplace;
            nCount++;
        }
        pszT++;
    }

    // Not Found
    return nCount;
}

OESTDAPI_(BOOL) IsValidFileIfFileUrl(LPSTR pszUrl)
{
    TCHAR   rgch[MAX_PATH];
    ULONG   cch=ARRAYSIZE(rgch);

    // pathCreate from url execpts a cannonicalised url with file:// infront
    if (UrlCanonicalizeA(pszUrl, rgch, &cch, 0)==S_OK)
        {
        cch = ARRAYSIZE(rgch);
        if (PathCreateFromUrlA(rgch, rgch, &cch, 0)==S_OK &&  
            !PathFileExistsA(rgch))
            return FALSE;
        }

    return TRUE;

}

OESTDAPI_(BOOL) IsValidFileIfFileUrlW(LPWSTR pwszUrl)
{
    WCHAR   wsz[MAX_PATH];
    ULONG   cch=ARRAYSIZE(wsz);

    // pathCreate from url execpts a cannonicalised url with file:// infront
    if (UrlCanonicalizeW(pwszUrl, wsz, &cch, 0)==S_OK)
        {
        cch = ARRAYSIZE(wsz);
        if (PathCreateFromUrlW(wsz, wsz, &cch, 0)==S_OK &&  
            !PathFileExistsW(wsz))
            return FALSE;
        }

    return TRUE;

}

/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/
char * __cdecl StrTokEx (char ** ppszIn, const char * pcszCtrlIn)
{
    unsigned char *psz;
    const unsigned char *pszCtrl = (const unsigned char *)pcszCtrlIn;
    unsigned char map[32] = {0};
    
    LPSTR pszToken;
    
    if(*ppszIn == NULL)
        return NULL;
    
    /* Set bits in delimiter table */
    do
    {
        map[*pszCtrl >> 3] |= (1 << (*pszCtrl & 7));
    } 
    while (*pszCtrl++);
    
    /* Initialize str. */
    psz = (unsigned char*)*ppszIn;
    
    /* Find beginning of token (skip over leading delimiters). Note that
    * there is no token if this loop sets str to point to the terminal
    * null (*str == '\0') */
    while ((map[*psz >> 3] & (1 << (*psz & 7))) && *psz)
        psz++;
    
    pszToken = (LPSTR)psz;
    
    /* Find the end of the token. If it is not the end of the string,
    * put a null there. */
    for (; *psz ; psz++)
    {
        if (map[*psz >> 3] & (1 << (*psz & 7))) 
        {
            *psz++ = '\0';
            break;
        }
    }
    
    /* string now points to beginning of next token */
    *ppszIn = (LPSTR)psz;
    
    /* Determine if a token has been found. */
    if (pszToken == (LPSTR)psz)
        return NULL;
    else
        return pszToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\unicnvrt.cpp ===
#include "pch.hxx"
#include <BadStrFunctions.h>

UINT AthGetTempFileNameW( LPCWSTR pwszPathName,       // pointer to directory name for temporary file
                          LPCWSTR pwszPrefixString,   // pointer to filename prefix
                          UINT    uUnique,          // number used to create temporary filename
                          LPWSTR  wszTempFileName)   // pointer to buffer that receives the new filename                                                           
{
    UINT        uRetValue = 0;
    LPSTR       pszPathName = NULL,
                pszPrefixString = NULL;
    CHAR        szTempFileName[MAX_PATH];
    LPWSTR      pwszTempFileName = NULL;

    Assert(pwszPathName && pwszPrefixString && wszTempFileName);

    if (S_OK == IsPlatformWinNT())
        return GetTempFileNameW(pwszPathName, pwszPrefixString, uUnique, wszTempFileName);

    pszPathName = PszToANSI(CP_ACP, pwszPathName);
    if (!pszPathName)
        goto exit;
    pszPrefixString = PszToANSI(CP_ACP, pwszPrefixString);
    if (!pszPrefixString)
        goto exit;

    uRetValue = GetTempFileNameA(pszPathName, pszPrefixString, uUnique, szTempFileName);

    if ( uRetValue != 0 ) 
    {
        pwszTempFileName = PszToUnicode(CP_ACP, szTempFileName);
        if (!pwszTempFileName)
        {
            uRetValue = 0;
            goto exit;
        }
        CopyMemory(wszTempFileName, pwszTempFileName, (lstrlenW(pwszTempFileName)+1)*sizeof(WCHAR));
    }

exit:
    MemFree(pwszTempFileName);
    MemFree(pszPathName);
    MemFree(pszPrefixString);
    
    return uRetValue;

}

DWORD AthGetTempPathW( DWORD   nBufferLength,  // size, in characters, of the buffer
                       LPWSTR  pwszBuffer )      // pointer to buffer for temp. path
{

    DWORD  nRequired = 0;
    CHAR   szBuffer[MAX_PATH];
    LPWSTR pwszBufferToFree = NULL;

    Assert(pwszBuffer);

    if (S_OK == IsPlatformWinNT())
        return GetTempPathW(nBufferLength, pwszBuffer);

    nRequired = GetTempPathA(MAX_PATH, szBuffer);

    if (nRequired == 0 || nRequired > MAX_PATH)
    {
        *pwszBuffer = 0;
    }
    else
    {
        pwszBufferToFree = PszToUnicode(CP_ACP, szBuffer);
        if (pwszBufferToFree)
        {
            nRequired = lstrlenW(pwszBufferToFree);

            if ( nRequired < nBufferLength) 
                CopyMemory(pwszBuffer, pwszBufferToFree, (nRequired+1)*sizeof(WCHAR) );
            else
            {
                nRequired = 0;
                *pwszBuffer = 0;
            }
        }
        else
            *pwszBuffer = 0;

        MemFree(pwszBufferToFree);
    }

    return nRequired;
}

HANDLE AthCreateFileW(LPCWSTR lpFileName,             // pointer to name of the file
                       DWORD   dwDesiredAccess,        // access (read-write) mode
                       DWORD   dwShareMode,            // share mode
                       LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                       // pointer to security attributes
                       DWORD   dwCreationDisposition,  // how to create
                       DWORD   dwFlagsAndAttributes,   // file attributes
                       HANDLE  hTemplateFile )        // handle to file with attributes to copy
                               
{

    LPSTR lpFileA = NULL;
    HANDLE hFile = NULL;

    if (S_OK == IsPlatformWinNT())
        return CreateFileW( lpFileName, 
                            dwDesiredAccess, 
                            dwShareMode, 
                            lpSecurityAttributes, 
                            dwCreationDisposition, 
                            dwFlagsAndAttributes, 
                            hTemplateFile);

    lpFileA = PszToANSI(CP_ACP, lpFileName);
    if (lpFileA)
        hFile = CreateFileA(lpFileA, 
                            dwDesiredAccess, 
                            dwShareMode, 
                            lpSecurityAttributes, 
                            dwCreationDisposition, 
                            dwFlagsAndAttributes, 
                            hTemplateFile);

    MemFree(lpFileA);

    return (hFile);
}

LONG_PTR SetWindowLongPtrAthW(HWND hWnd, int  nIndex, LONG_PTR dwNewLong)
{
    if (S_OK == IsPlatformWinNT())
        return SetWindowLongPtrW(hWnd, nIndex, dwNewLong);

    return SetWindowLongPtrA(hWnd, nIndex, dwNewLong);
}

/**********************************************************************************\
* bobn 6/23/99
*
* The following code was ported from ShlWapi.  There were problems with
* our implementation on Win95 and it seemed prudent to have a solution
* without a bunch of special cases.
*
*
\**********************************************************************************/

#define DBCS_CHARSIZE   (2)

int Ath_MBToWCS(LPSTR pszIn, int cchIn, LPWSTR *ppwszOut)
{
    int cch = 0;
    int cbAlloc;

    if ((0 != cchIn) && (NULL != ppwszOut))
    {
        cchIn++;
        cbAlloc = cchIn * sizeof(WCHAR);

        *ppwszOut = (LPWSTR)LocalAlloc(LMEM_FIXED, cbAlloc);

        if (NULL != *ppwszOut)
        {
            cch = MultiByteToWideChar(CP_ACP, 0, pszIn, cchIn, *ppwszOut, cchIn);

            if (!cch)
            {
                LocalFree(*ppwszOut);
                *ppwszOut = NULL;
            }
            else
            {
                cch--;  //  Just return the number of characters
            }
        }
    }

    return cch;
}

int Ath_WCSToMB(LPCWSTR pwszIn, int cchIn, LPSTR *ppszOut)
{
    int cch = 0;
    int cbAlloc;

    if ((0 != cchIn) && (NULL != ppszOut))
    {
        cchIn++;
        cbAlloc = cchIn * DBCS_CHARSIZE;

        *ppszOut = (LPSTR)LocalAlloc(LMEM_FIXED, cbAlloc);

        if (NULL != *ppszOut)
        {
            cch = WideCharToMultiByte(CP_ACP, 0, pwszIn, cchIn, 
                                      *ppszOut, cbAlloc, NULL, NULL);

            if (!cch)
            {
                LocalFree(*ppszOut);
                *ppszOut = NULL;
            }
            else
            {
                cch--;  //  Just return the number of characters
            }
        }
    }

    return cch;
}

/****************************** Module Header ******************************\
* Module Name: wsprintf.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*  sprintf.c
*
*  Implements Windows friendly versions of sprintf and vsprintf
*
*  History:
*   2-15-89  craigc     Initial
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

/* Max number of characters. Doesn't include termination character */
#define out(c) if (cchLimit) {*lpOut++=(c); cchLimit--;} else goto errorout

/***************************************************************************\
* AthSP_GetFmtValueW
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
*  07-27-92  GregoryW   Created Unicode version (copied from AthSP_GetFmtValue)
\***************************************************************************/

LPCWSTR AthSP_GetFmtValueW(
    LPCWSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= L'0' && *lpch <= L'9') {
        ii *= 10;
        ii += (int)(*lpch - L'0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* AthSP_PutNumberW
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

int AthSP_PutNumberW(
    LPWSTR lpstr,
    DWORD n,
    int   limit,
    DWORD radix,
    int   uppercase,
    int   *pcch)
{
    DWORD mod;
    *pcch = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (limit) {
        do  {
            mod =  n % radix;
            n /= radix;

            mod += '0';
            if (mod > '9')
            mod += uppercase;
            *lpstr++ = (WCHAR)mod;
            (*pcch)++;
        } while((*pcch < limit) && n);
    }

    return (n == 0) && (*pcch > 0);
}

/***************************************************************************\
* AthSP_ReverseW
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

void AthSP_ReverseW(
    LPWSTR lpFirst,
    LPWSTR lpLast)
{
    WCHAR ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}


/***************************************************************************\
* wvsprintfW (API)
*
* wsprintfW() calls this function.
*
* History:
*    11-Feb-1992 GregoryW copied xwvsprintf
*         Temporary hack until we have C runtime support
* 1-22-97 tnoonan       Converted to wvnsprintfW
\***************************************************************************/

OESTDAPI_(int) AthwvnsprintfW(
    LPWSTR lpOut,
    int cchLimitIn,
    LPCWSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem = FALSE;
    WCHAR prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = --cchLimitIn, cch, cchAvailable;
    LPWSTR lpT, lpTWC;
    LPSTR psz;
    va_list varglist = arglist;
    union {
        long l;
        unsigned long ul;
        CHAR sz[2];
        WCHAR wsz[2];
    } val;

    if (cchLimit < 0)
        return 0;

    while (*lpFmt != 0) {
        if (*lpFmt == L'%') {

            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == L'-')
                    left++;
                else if (*lpFmt == L'#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == L'0') {
                fillch = L'0';
                lpFmt++;
            } else
                fillch = L' ';

            /*
             * read the width specification
             */
            lpFmt = AthSP_GetFmtValueW(lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == L'.') {
                lpFmt = AthSP_GetFmtValueW(++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if ((*lpFmt == L'w') || (*lpFmt == L't')) {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == L'l') {
                size = 1;
                lpFmt++;
            } else {
                size = 0;
                if (*lpFmt == L'h') {
                    lpFmt++;
                    hprefix = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case L'i':
            case L'd':
                size=1;
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case L'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = L' ';

                /*
                 * if size == 1, "%lu" was specified (good);
                 * if size == 2, "%wu" was specified (bad)
                 */
                if (size) {
                    val.l = va_arg(varglist, LONG);
                } else if (sign) {
                    val.l = va_arg(varglist, SHORT);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 * AthSP_PutNumberW returns FALSE if it runs out of space
                 */
                if (!AthSP_PutNumberW(lpOut, val.l, cchLimit, radix, upper, &cch))
                {
                    break;
                }

                //  Now we have the number backwards, calculate how much
                //  more buffer space we'll need for this number to
                //  format correctly.
                cchAvailable = cchLimit - cch;

                width -= cch;
                prec -= cch;
                if (prec > 0)
                {
                    width -= prec;
                    cchAvailable -= prec;
                }

                if (width > 0)
                {
                    cchAvailable -= width - (sign ? 1 : 0);
                }

                if (sign)
                {
                    cchAvailable--;
                }

                if (cchAvailable < 0)
                {
                    break;
                }

                //  We have enough space to format the buffer as requested
                //  without overflowing.

                lpOut += cch;
                cchLimit -= cch;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out(L'0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != L'0') {
                        if (sign) {
                            sign = 0;
                            out(L'-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out(L'0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out(L'-');

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    AthSP_ReverseW(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out(L'-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * reverse the string in place
                     */
                    AthSP_ReverseW(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case L'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case L'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = L'X';
                    else
                        prefix = L'x';
                goto donumeric;

            case L'c':
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'C' ***/

            case L'C':
                /*
                 * if size == 0, "%C" or "%hc" was specified (CHAR);
                 * if size == 1, "%c" or "%lc" was specified (WCHAR);
                 * if size == 2, "%wc" or "%tc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0;
                    lpT = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    psz = (LPSTR)(val.sz);
                    goto putstring;
                }

            case L's':
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 'S' ***/

            case L'S':
                /*
                 * if size == 0, "%S" or "%hs" was specified (LPSTR)
                 * if size == 1, "%s" or "%ls" was specified (LPWSTR);
                 * if size == 2, "%ws" or "%ts" was specified (LPWSTR)
                 */
                if (size) {
                    lpT = va_arg(varglist, LPWSTR);
                    cch = lstrlenW(lpT);
                } else {
                    psz = va_arg(varglist, LPSTR);
                    cch = lstrlen((LPCSTR)psz);
putstring:
                    cch = Ath_MBToWCS(psz, cch, &lpTWC);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTWC;
                }
putwstring:
                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     LocalFree(lpTWC);
                     fAllocateMem = FALSE;
                }

                break;

            default:
normalch:
                out((WCHAR)*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    if (fAllocateMem)
    {
        LocalFree(lpTWC);
    }

    return cchLimitIn - cchLimit;
}

OESTDAPI_(int) AthwsprintfW( LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, ... )
{
    va_list arglist;
    int ret;

    Assert(lpOut);
    Assert(lpFmt);

    lpOut[0] = 0;
    va_start(arglist, lpFmt);
    
    ret = AthwvnsprintfW(lpOut, cchLimitIn, lpFmt, arglist);
    va_end(arglist);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\strconst.h ===
// --------------------------------------------------------------------------
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------
#ifndef _STRCONST_H
#define _STRCONST_H

// --------------------------------------------------------------------------
// String Const Def Macros
// --------------------------------------------------------------------------
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C extern
#endif

#ifdef DEFINE_STRCONST
#define STRCONSTA(x,y)    EXTERN_C const char x[] = y
#define STRCONSTW(x,y)    EXTERN_C const WCHAR x[] = L##y
#else
#define STRCONSTA(x,y)    EXTERN_C const char x[]
#define STRCONSTW(x,y)    EXTERN_C const WCHAR x[]
#endif

// --------------------------------------------------------------------------
// Const Strings
// --------------------------------------------------------------------------
STRCONSTA(c_szEmpty,                    "");
STRCONSTA(c_szDotDat,                   ".dat");
STRCONSTA(c_szAppPaths,                 "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths");
STRCONSTA(c_szRegPath,                  "Path");
STRCONSTA(c_szPathFileFmt,              "%s\\%s");
STRCONSTA(g_szEllipsis,                 "...");
STRCONSTW(c_szLnkExt,                   ".lnk");
STRCONSTA(c_szInternetSettingsPath,     "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings");
STRCONSTA(c_szUrlEncoding,              "UrlEncoding");


#endif // _STRCONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\voidlist.cpp ===
#include "pch.hxx"
#include "voidlist.h"
#include "msoedbg.h"
#include <winbase.h>

struct CNode
{
    CNode *m_pNodes[LD_LASTDIRECTION];
    void  *m_pValue;
	DWORD  m_dwHandle;

    CNode() : m_pValue(NULL) 
        {
        m_pNodes[LD_FORWARD] = NULL; 
        m_pNodes[LD_REVERSE] = NULL;
        }

    CNode* GetNext() {return m_pNodes[LD_FORWARD];}
    CNode* GetPrev() {return m_pNodes[LD_REVERSE];}

    void SetNext(CNode *pNode) {m_pNodes[LD_FORWARD] = pNode;}
    void SetPrev(CNode *pNode) {m_pNodes[LD_REVERSE] = pNode;}
};

// *************************************************
CVoidPtrList::CVoidPtrList() : m_cRefCount(1), m_cCount(0), m_dwCookie(0), 
                m_pCompareFunc(NULL), m_pFreeItemFunc(NULL), m_fInited(false)
{
    SetHead(NULL);
    SetTail(NULL);
    InitializeCriticalSection(&m_rCritSect);
}

// *************************************************
CVoidPtrList::~CVoidPtrList()
{
    ClearList();
    DeleteCriticalSection(&m_rCritSect);
}

// ******************************************************
ULONG CVoidPtrList::AddRef(void) 
{
    return InterlockedIncrement(&m_cRefCount);
}

// ******************************************************
ULONG CVoidPtrList::Release(void) 
{
    LONG cRef = InterlockedDecrement(&m_cRefCount);
    if (0 == cRef) 
        delete this; 

    return S_OK;
}

// *************************************************
HRESULT CVoidPtrList::Init(IVPL_COMPAREFUNCTYPE pCompareFunc, DWORD_PTR dwCookie, 
                           IVPL_FREEITEMFUNCTYPE pFreeItemFunc, DWORD dwInitSize)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_rCritSect);
    
    if (!m_fInited)
        {
        m_dwCookie = dwCookie;
        m_pCompareFunc = pCompareFunc;
        m_pFreeItemFunc = pFreeItemFunc;
        //~~~ Need to do something with dwInitSize.
        }
    else
        hr = E_FAIL;

    LeaveCriticalSection(&m_rCritSect);

    return hr;
}

// *************************************************
HRESULT CVoidPtrList::ClearList(void)
{
    EnterCriticalSection(&m_rCritSect);

    CNode   *pCurr = GetHead(),
            *pNext;
    SetHead(NULL);
    SetTail(NULL);

    m_cCount = 0;
    if (m_pFreeItemFunc)
        while (pCurr)
            {
            pNext = pCurr->GetNext();
            m_pFreeItemFunc(pCurr->m_pValue);
            delete pCurr;
            pCurr = pNext;
            }
    else
        while (pCurr)
            {
            pNext = pCurr->GetNext();
            delete pCurr;
            pCurr = pNext;
            }

    LeaveCriticalSection(&m_rCritSect);
    return S_OK;
}

// *************************************************
HRESULT CVoidPtrList::AddItem(LPVOID ptr, DWORD *pdwHandle)
{
    HRESULT hr = S_OK;
    Assert(ptr);

    EnterCriticalSection(&m_rCritSect);

    CNode *pNewNode = new CNode;
    if (pNewNode)
        {
        pNewNode->m_pValue = ptr;
        pNewNode->m_dwHandle = GetNewHandle();
        if (m_pCompareFunc)
            SortedAddItem(pNewNode);
        else
            NonSortedAddItem(pNewNode);
        }
    else
        hr = E_OUTOFMEMORY;

    LeaveCriticalSection(&m_rCritSect);

    if (pNewNode)
        *pdwHandle = pNewNode->m_dwHandle;
    return hr;
}

// *************************************************
void CVoidPtrList::SortedAddItem(CNode *pNode)
{
    if (0 == m_cCount++)
        {
        SetHead(pNode);
        SetTail(pNode);
        }
    else
        {
        CNode *compAgainstNode = GetHead();
        void *pValue = pNode->m_pValue;
        while (compAgainstNode)
            {
            bool ALessThanB;
            m_pCompareFunc(pValue, compAgainstNode->m_pValue, &ALessThanB, m_dwCookie);
            if (ALessThanB)
                break;
            else
                compAgainstNode = compAgainstNode->GetNext();
            }

        // Insert at Tail
        if (!compAgainstNode)
            {
            GetTail()->SetNext(pNode);
            pNode->SetPrev(GetTail());
            SetTail(pNode);
            }
        // Insert at Head
        else if (!compAgainstNode->GetPrev())
            {
            GetHead()->SetPrev(pNode);
            pNode->SetNext(GetHead());
            SetHead(pNode);
            }
        // Insert in middle
        else
            {
            CNode *prev = compAgainstNode->GetPrev();
            pNode->SetNext(compAgainstNode);
            pNode->SetPrev(prev);
            prev->SetNext(pNode);
            compAgainstNode->SetPrev(pNode);
            }
        }
}

// *************************************************
void CVoidPtrList::NonSortedAddItem(CNode *pNode)
{
    if (0 == m_cCount)
        {
        SetHead(pNode);
        SetTail(pNode);
        }
    else
        {
        GetHead()->SetPrev(pNode);
        pNode->SetNext(GetHead());
        SetHead(pNode);
        }
    m_cCount++;
}

// *************************************************
HRESULT CVoidPtrList::RemoveItem(DWORD dwHandle)
{
    CNode *pCurr = FindItem(dwHandle);

    if (pCurr)
        {
        EnterCriticalSection(&m_rCritSect);

        CNode *pNext = pCurr->GetNext();
        CNode *pPrev = pCurr->GetPrev();

        if (pNext)
            pNext->SetPrev(pPrev);
        else
            SetTail(pPrev);

        if (pPrev)
            pPrev->SetNext(pNext);
        else
            SetHead(pNext);

        if (m_pFreeItemFunc)
            m_pFreeItemFunc(pCurr->m_pValue);
        delete pCurr;
        m_cCount--;

        LeaveCriticalSection(&m_rCritSect);
        }
    return S_OK;
}

// *************************************************
HRESULT CVoidPtrList::GetNext(LISTDIRECTION bDirection, LPVOID *pptr, DWORD *pdwHandle) 
{
    CNode *pCurr = FindItem(*pdwHandle);
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_rCritSect);
    if (pCurr)
        pCurr = pCurr->m_pNodes[bDirection];
    else
        pCurr = m_pEnds[bDirection];
    
    if (pCurr)
    {
        *pptr = pCurr->m_pValue;
        *pdwHandle = pCurr->m_dwHandle;
    }
    else
        {
        *pptr = NULL;
        hr = E_FAIL;
        }

    LeaveCriticalSection(&m_rCritSect);
    return hr;
}

// *************************************************
HRESULT CVoidPtrList::SkipNext(LISTDIRECTION bDirection, DWORD *pdwHandle) 
{
    CNode *pCurr = FindItem(*pdwHandle);

    EnterCriticalSection(&m_rCritSect);

    if (pCurr)
        pCurr = pCurr->m_pNodes[bDirection];
    else
        pCurr = m_pEnds[bDirection];

    if (pCurr)
        *pdwHandle = pCurr->m_dwHandle;

    LeaveCriticalSection(&m_rCritSect);

    if (pCurr)
        return S_OK;

    return E_FAIL;
}

// *************************************************
HRESULT CVoidPtrList::Resort(void)
{
    EnterCriticalSection(&m_rCritSect);

    if (m_pCompareFunc && (m_cCount > 1))
        {
        CNode *pHead = GetHead();
        m_cCount = 0;
        SetHead(NULL);
        SetTail(NULL);
        while (pHead)
            {
            CNode *pNext = pHead->GetNext();
            pHead->SetPrev(NULL);
            pHead->SetNext(NULL);
            SortedAddItem(pHead);
            pHead = pNext;
            }
        }

    LeaveCriticalSection(&m_rCritSect);
    return S_OK;
}

// *************************************************
CNode* CVoidPtrList::FindItem(DWORD dwHandle)
{
    CNode *pHead = GetHead();

    for (pHead = GetHead(); NULL != pHead; pHead = pHead->GetNext())
    {
        if (dwHandle == pHead->m_dwHandle)
            break;
    }

    return pHead;
}

// *************************************************
DWORD CVoidPtrList::GetNewHandle()
{
    CNode *pHead = GetHead();
    DWORD dwHandle = 0;

    for (dwHandle = HANDLE_START; HANDLE_END > dwHandle; dwHandle++)
    {
        for (pHead = GetHead(); NULL != pHead; pHead = pHead->GetNext())
        {
            if (dwHandle == pHead->m_dwHandle)
                break;
        }

        if (NULL == pHead)
            break;
    }

    return dwHandle;
}

// =================================================
// Static functions
// =================================================
HRESULT CVoidPtrList::CreateInstance(CVoidPtrList** ppList)
{
    HRESULT hr = S_OK;

    // Create me
    CVoidPtrList *pNew = new CVoidPtrList;
    if (NULL == pNew)
        hr = E_OUTOFMEMORY;

    *ppList = pNew;

    // Done
    return hr;
}

HRESULT IVoidPtrList_CreateInstance(IVoidPtrList** ppList)
{
    CVoidPtrList* pList;
    HRESULT hr = CVoidPtrList::CreateInstance(&pList);
    if (SUCCEEDED(hr))
        *ppList = static_cast<IVoidPtrList*>(pList);
    else
        *ppList = NULL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\unknlist.h ===
#ifndef __UNKNLIST_H
#define __UNKNLIST_H

#include "listintr.h"

class CUnknownList : public IUnknownList
{
private:
    IVoidPtrList    *m_pList;
    DWORD           m_cRefCount;

    static void FreeUnknown(void *ptr) {(reinterpret_cast<IUnknown*>(ptr))->Release();}
    
public:
    CUnknownList() : m_pList(NULL), m_cRefCount(1) {}
    ~CUnknownList();

    // IUnknown members
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return E_NOTIMPL;}
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    
    // IUnknownList members
    virtual HRESULT STDMETHODCALLTYPE Init(IUL_COMPAREFUNCTYPE pCompareFunc, DWORD_PTR dwCookie, DWORD dwInitSize) {
        return m_pList->Init(
                reinterpret_cast<IVPL_COMPAREFUNCTYPE>(pCompareFunc), 
                dwCookie, 
                CUnknownList::FreeUnknown, 
                dwInitSize);}

    virtual HRESULT STDMETHODCALLTYPE GetCount(DWORD *pdwCount) {
        return m_pList->GetCount(pdwCount);}

    virtual HRESULT STDMETHODCALLTYPE ClearList(void) {
        return m_pList->ClearList();}

    virtual HRESULT STDMETHODCALLTYPE AddItem(IUnknown *pIUnk, DWORD *pdwHandle);

    virtual HRESULT STDMETHODCALLTYPE RemoveItem(DWORD dwHandle) {
        return m_pList->RemoveItem(dwHandle);}

    virtual HRESULT STDMETHODCALLTYPE GetNext(LISTDIRECTION bDirection, IUnknown **ppIUnk, DWORD *pdwHandle); 

    virtual HRESULT STDMETHODCALLTYPE SkipNext(LISTDIRECTION bDirection, DWORD *pdwHandle) {
        return m_pList->SkipNext(bDirection, pdwHandle);}

    virtual HRESULT STDMETHODCALLTYPE Resort(void) {
        return m_pList->Resort();}

    static HRESULT CreateInstance(CUnknownList** ppList);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\unknlist.cpp ===
#include "pch.hxx"
#include "unknlist.h"
#include <BadStrFunctions.h>


// ******************************************************
CUnknownList::~CUnknownList()
{
    if (m_pList)
        m_pList->Release();
}

// ******************************************************
ULONG CUnknownList::AddRef(void) 
{
    m_cRefCount++; 
    return S_OK;
}

// ******************************************************
ULONG CUnknownList::Release(void) 
{
    m_cRefCount--; 
    if (0 == m_cRefCount) 
        delete this; 
    return S_OK;
}

// ******************************************************
HRESULT CUnknownList::AddItem(IUnknown *pIUnk, DWORD *pdwHandle)
{
    HRESULT hr = m_pList->AddItem(LPVOID(pIUnk), pdwHandle);
    if (SUCCEEDED(hr))
        pIUnk->AddRef();
    return hr;
}

// ******************************************************
HRESULT CUnknownList::GetNext(LISTDIRECTION bDirection, IUnknown **ppIUnk, DWORD *pdwHandle)
{
    HRESULT hr = m_pList->GetNext(bDirection, reinterpret_cast<void**>(ppIUnk), pdwHandle);
    if (SUCCEEDED(hr))
        (*ppIUnk)->AddRef();
    return hr;
}

// ======================================================
// Static functions
// ======================================================
HRESULT CUnknownList::CreateInstance(CUnknownList** ppList)
{
    HRESULT hr = S_OK;

    // Create me
    CUnknownList *pNew = new CUnknownList;
    if (NULL == pNew)
        hr = E_OUTOFMEMORY;

    hr = IVoidPtrList_CreateInstance(&(pNew->m_pList));
    if (NULL == pNew->m_pList)
        {
        delete pNew;
        pNew = NULL;
        }

    *ppList = pNew;

    // Done
    return hr;
}

HRESULT IUnknownList_CreateInstance(IUnknownList** ppList)
{
    CUnknownList* pList;
    HRESULT hr = CUnknownList::CreateInstance(&pList);
    if (SUCCEEDED(hr))
        *ppList = static_cast<IUnknownList*>(pList);
    else
        *ppList = NULL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\voidlist.h ===
#ifndef __VOIDLIST_H
#define __VOIDLIST_H

#include "listintr.h"

struct CNode;

class CVoidPtrList : public IVoidPtrList
{
private:
    enum
    {
        HANDLE_START    = 0x00000001,
        HANDLE_END      = 0xffffffff
    };
    
    CNode                  *m_pEnds[2];  // Head and tail
    DWORD                   m_cCount;
    DWORD_PTR               m_dwCookie;
    LONG                    m_cRefCount;
    IVPL_COMPAREFUNCTYPE    m_pCompareFunc;
    IVPL_FREEITEMFUNCTYPE   m_pFreeItemFunc;
    CRITICAL_SECTION        m_rCritSect;
    bool                    m_fInited;
    
    void SortedAddItem(CNode *pNode);
    void NonSortedAddItem(CNode *pNode);

    CNode* GetHead() {return m_pEnds[LD_FORWARD];}
    CNode* GetTail() {return m_pEnds[LD_REVERSE];}
    void SetHead(CNode* pNode) {m_pEnds[LD_FORWARD] = pNode;}
    void SetTail(CNode* pNode) {m_pEnds[LD_REVERSE] = pNode;}
    CNode* FindItem(DWORD dwHandle);
    DWORD GetNewHandle();

public:
    CVoidPtrList();
    ~CVoidPtrList();

    // IUnknown members
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return E_NOTIMPL;}
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    
    
    // IVoidPtrList members
    virtual HRESULT STDMETHODCALLTYPE Init(
        IVPL_COMPAREFUNCTYPE pCompareFunc,
        DWORD_PTR dwCookie,
        IVPL_FREEITEMFUNCTYPE pFreeItemFunc,
        DWORD dwInitSize);

    virtual HRESULT STDMETHODCALLTYPE GetCount(DWORD *pdwCount) {
        *pdwCount = m_cCount; return S_OK;}

    virtual HRESULT STDMETHODCALLTYPE ClearList(void);

    virtual HRESULT STDMETHODCALLTYPE AddItem(LPVOID ptr, DWORD *pdwHandle);

    virtual HRESULT STDMETHODCALLTYPE RemoveItem(DWORD dwHandle);

    virtual HRESULT STDMETHODCALLTYPE GetNext(
        LISTDIRECTION bDirection,
        LPVOID *pptr, 
        DWORD *pdwHandle); 

    virtual HRESULT STDMETHODCALLTYPE SkipNext(LISTDIRECTION bDirection, DWORD *pdwHandle); 

    virtual HRESULT STDMETHODCALLTYPE Resort(void);

    static HRESULT CreateInstance(CVoidPtrList** ppList);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\wstrings.h ===
#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\wstrings.c ===
//============================================================================
//
// DBCS and UNICODE aware string routines
//
//
//============================================================================
#include "pch.hxx"  // not really a pch in this case, just a header
#include "wstrings.h"

#pragma warning (disable: 4706) // assignment within conditional expression

OESTDAPI_(BOOL) UnlocStrEqNW(LPCWSTR pwsz1, LPCWSTR pwsz2, DWORD cch)
{
    if (!pwsz1 || !pwsz2)
        {
        if (!pwsz1 && !pwsz2)
            return TRUE;
        return FALSE;
        }

    while (cch && *pwsz1 && *pwsz2 && (*pwsz1 == *pwsz2))
        {
        pwsz1++;
        pwsz2++;
        cch--;
        }
    return !cch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\w16stub.cpp ===
//============================================================================
//
// Stub or little implementation for Win32 specific APIs
//
//============================================================================

#include "pch.hxx"
#include <direct.h>
#include <shlwapi.h>
#include <shellapi.h>
#include "list.h"

#define EACCES      13

extern "C"
{

/*****************************************************************************\
*                                                                             *
*  From winbase.h (INC32)
*                                                                             *
\*****************************************************************************/

BOOL
WINAPI __export
SetFileAttributesA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
    )
{
   return( FALSE );
}

BOOL
WINAPI __export
SetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    )
{
   return( FALSE );
}

/* HeapAlloc and HeapFree uses Global memory
 */

CList * g_HeapList = NULL;

LPVOID
WINAPI __export
OE16HeapAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    DWORD dwBytes
    )
{
    Assert ( dwBytes < 0x10000 );   // Can't handle more than 64KB
    return malloc( dwBytes );
}

LPVOID
WINAPI __export
HeapReAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem,
    DWORD dwBytes
    )
{
   return( NULL );
}

BOOL
WINAPI __export
OE16HeapFree(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    )
{
    free (lpMem );
    return TRUE;
}

DWORD
WINAPI __export
HeapSize(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    )
{
    return 0;
}

DWORD
WINAPI __export
GetShortPathNameA(
    LPCSTR lpszLongPath,
    LPSTR  lpszShortPath,
    DWORD    cchBuffer

    )
{
   return( 0L );
}

VOID
WINAPI __export
SetLastError(
    DWORD dwErrCode
    )
{
}
#ifdef RUN16_WIN16X
LONG
WINAPI
CompareFileTime(
    CONST FILETIME *lpFileTime1,
    CONST FILETIME *lpFileTime2
    )
{
   return( 0 );
}
#endif
/***** It is in Win16x.h as dummy inline
VOID
WINAPI
Sleep(
    DWORD dwMilliseconds
    )
{
   sleep( (unsigned)((dwMilliseconds+999)/1000) );
   Yield();
}
********/

BOOL
WINAPI __export
CreateProcessA(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
   return( FALSE );
}

UINT
WINAPI __export
GetDriveTypeA(
    LPCSTR lpRootPathName
    )
{
   return( 0 );      // DRIVE_UNKNOWN
}

DWORD
WINAPI __export
GetEnvironmentVariableA(
    LPCSTR lpName,
    LPSTR lpBuffer,
    DWORD nSize
    )
{
   return( 0 );
}

BOOL
WINAPI __export
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    if ( !mkdir( lpPathName ) )
        if ( errno != EACCES )
            return FALSE;

    return TRUE;
}

BOOL
WINAPI __export
GetUserNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    )
{
   return( FALSE );
}

BOOL
WINAPI __export
GetComputerNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    )
{
   return( FALSE );
}



/*****************************************************************************\
*                                                                             *
*  OE16 File mapping object related function
*                                                                             *
\*****************************************************************************/
CList * g_FileMappingList = NULL;

LPVOID
WINAPI __export
OE16CreateFileMapping(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    )
{
    LPVOID lpMem;
    LPCSTR lpNameLocal;
    if ( !g_FileMappingList )
        g_FileMappingList = new CList;

    if ( !g_FileMappingList )
        return (LPVOID)NULL;

    lpMem = g_FileMappingList->FindItemHandleWithName ( lpName, NULL );
    if ( lpMem  == NULL )
        {
        lpMem = malloc( dwMaximumSizeLow );
        if ( lpMem != NULL )
            {
            ZeroMemory ( lpMem, dwMaximumSizeLow );
            lpNameLocal = strdup( lpName );
            if( lpNameLocal )
                g_FileMappingList->AddItemWithName( (LPVOID)lpMem, lpNameLocal );
            else
                {
                free( lpMem );
                lpMem = NULL;
                }
            }
        }

    return lpMem;
}


LPVOID
WINAPI __export
OE16MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap
    )
{
   // We are using fixed memory.
   return (LPVOID)hFileMappingObject;
}

BOOL
WINAPI __export
OE16UnmapViewOfFile(
    LPCVOID lpBaseAddress
    )
{
    return TRUE;
}


BOOL
WINAPI __export
OE16CloseFileMapping(
    LPVOID lpObject
    )
{
    LPVOID lpMem;
    if( !g_FileMappingList )
        return FALSE;

    lpMem = g_FileMappingList->FindItemHandleWithName( NULL, lpObject );

    // if lpMem is not NULL, it means usagecnt == 0. Let's delete the item.
    if( lpMem != NULL )
        {
        // Delete the item.
        g_FileMappingList->DelItem ( (LPVOID)lpMem );

        free ( lpMem );

        if( g_FileMappingList->IsEmpty() )
            {
            delete g_FileMappingList;
            g_FileMappingList = NULL;
            }
        }

    return TRUE;
}


///// Got to remove those below related to file mapping object
HANDLE
WINAPI
CreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    )
{
   return( NULL );
}

LPVOID
WINAPI
MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap
    )
{
   return( NULL );
}

BOOL
WINAPI
UnmapViewOfFile(
    LPCVOID lpBaseAddress
    )
{
   return( FALSE );
}

BOOL
WINAPI __export
OE16ReleaseMutex(
    HANDLE hMutex
    )
{
   return( TRUE );
}

BOOL
WINAPI __export
GetDiskFreeSpaceA(
    LPCSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )
{
   return( FALSE );
}

DWORD
WINAPI __export
GetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    )
{
   return( 0 );
}

BOOL
WINAPI __export
IsTextUnicode(
    CONST LPVOID lpBuffer,
    int cb,
    LPINT lpi
    )
{
   return( FALSE );
}


LPVOID
WINAPI __export
VirtualAlloc(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    )
{
    lpAddress = (LPVOID) malloc(dwSize);
    return lpAddress;
}

BOOL
WINAPI __export
VirtualFree(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD dwFreeType
    )
{
    free(lpAddress);
    return TRUE;
}

VOID
WINAPI __export
GetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    )
{
    lpSystemInfo->dwPageSize = 4096;
}

VOID
WINAPI __export
GetSystemTimeAsFileTime(
    LPFILETIME lpSystemTimeAsFileTime
    )
{
}

DWORD
WINAPI __export
ExpandEnvironmentStrings(
    LPCSTR lpSrc,
    LPSTR lpDst,
    DWORD nSize
    )
{
    return ((DWORD) 0);
}


/*****************************************************************************\
*                                                                             *
*  From shlobj.h(INC32)
*                                                                             *
\*****************************************************************************/

BOOL WINAPI __export SHGetPathFromIDListA( LPCITEMIDLIST pidl, LPSTR pszPath )
{
   return( FALSE );
}

LPITEMIDLIST WINAPI __export SHBrowseForFolderA(LPBROWSEINFOA lpbi)
{
   return( NULL );
}

HRESULT WINAPI __export
SHGetSpecialFolderLocation( HWND hwndOwner, int nFolder, LPITEMIDLIST* ppidl )
{
   return( E_NOTIMPL );
}


/*****************************************************************************\
*                                                                             *
*  From shlobjp.h(private\windows\inc)
*                                                                             *
\*****************************************************************************/

void   WINAPI __export SHFree(LPVOID pv)
{
}


/*****************************************************************************\
*                                                                             *
*  From wingdi.h(INC32)
*                                                                             *
\*****************************************************************************/

BOOL WINAPI __export TranslateCharsetInfo( DWORD FAR *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
{
   return( FALSE );
}


/*****************************************************************************\
*                                                                             *
*  From winuser.h - It should be in the (win16x.h)INC16
*                                                                             *
\*****************************************************************************/

BOOL
WINAPI __export
EnumThreadWindows(
    DWORD dwThreadId,
    WNDENUMPROC lpfn,
    LPARAM lParam)
{
   return( FALSE );
}

int
WINAPI __export
DrawTextEx(
    HDC hdc,
    LPCSTR lpsz,
    int cb,
    LPRECT lprc,
    UINT fuFormat,
    LPVOID lpDTP )
{
   Assert( ( fuFormat & ( DT_EDITCONTROL | DT_PATH_ELLIPSIS | DT_END_ELLIPSIS |
                          DT_MODIFYSTRING | DT_RTLREADING | DT_WORD_ELLIPSIS ) ) == 0 );
   Assert( lpDTP == NULL );
   return( DrawText( hdc, lpsz, cb, lprc, fuFormat ) );
}


//
// 6/18/97 - Implemented sizing ability only
//
BOOL
WINAPI __export
DrawIconEx(
    HDC hdc,
    int xLeft,
    int yTop,
    HICON hIcon,
    int cxWidth,
    int cyHeight,
    UINT istepIfAniCur,
    HBRUSH hbrFlickerFreeDraw,
    UINT diFlags )
{
   int  cx = GetSystemMetrics( SM_CXICON );
   int  cy = GetSystemMetrics( SM_CYICON );

   if ( cxWidth == 0 )
      cxWidth = cx;
   if ( cyHeight == 0 )
      cyHeight = cy;

   HBITMAP  hbmIcon   = CreateCompatibleBitmap( hdc, cx, cy );
   HDC  hdcIcon = CreateCompatibleDC( hdc );
   HBITMAP  hbmIconOld  = (HBITMAP)SelectObject( hdcIcon, hbmIcon );

   if ( diFlags & DI_MASK )
   {
      COLORREF  rgbTxt, rgbBk;
      HBITMAP  hbmMask;
      HBITMAP  hbmMaskOld;
      HDC  hdcMask = CreateCompatibleDC( hdc );

      hbmMask = CreateCompatibleBitmap( hdcMask, cx, cy );
      hbmMaskOld = (HBITMAP)SelectObject( hdcMask, hbmMask );
      PatBlt( hdcMask, 0, 0, cx, cy, BLACKNESS );
      DrawIcon( hdcMask, 0, 0, hIcon );
      PatBlt( hdcIcon, 0, 0, cx, cy, WHITENESS );
      DrawIcon( hdcIcon, 0, 0, hIcon );
      BitBlt( hdcMask, 0, 0, cx, cy, hdcIcon, 0, 0, SRCINVERT );

      rgbTxt = SetTextColor( hdc, RGB( 0, 0, 0 ) );
      rgbBk  = SetBkColor( hdc, RGB( 255, 255, 255 ) );
      StretchBlt( hdc, xLeft, yTop, cxWidth, cyHeight, hdcMask, 0, 0, cx, cy,
                     ( diFlags & DI_IMAGE ) ? SRCAND : SRCCOPY );
      SetTextColor( hdc, rgbTxt );
      SetBkColor( hdc, rgbBk );

      DeleteObject( SelectObject( hdcMask, hbmMaskOld ) );
      DeleteDC( hdcMask );
   }

   if ( diFlags & DI_IMAGE )
   {
      PatBlt( hdcIcon, 0, 0, cx, cy, BLACKNESS );
      DrawIcon( hdcIcon, 0, 0, hIcon );
      StretchBlt( hdc, xLeft, yTop, cxWidth, cyHeight, hdcIcon, 0, 0, cx, cy,
                     ( diFlags & DI_MASK ) ? SRCINVERT : SRCCOPY );
   }

   //
   // Clean Up
   //
   DeleteObject( SelectObject( hdcIcon, hbmIconOld ) );
   DeleteDC( hdcIcon );

   return( TRUE );
}

HANDLE
WINAPI __export
LoadImageA(
    HINSTANCE hInst,
    LPCSTR lpszName,
    UINT uType,
    int cxDesired,
    int cyDesired,
    UINT fuLoad)
{
   return LoadBitmap(hInst, lpszName);
}

BOOL
WINAPI __export
PostThreadMessageA(
    DWORD idThread,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam)
{
   return( FALSE );
}

#if 0
HICON
WINAPI
CopyIcon(
    HICON hIcon)
{
   return( NULL );
}
#endif

BOOL
WINAPI __export
TrackPopupMenuEx(
    HMENU hMenu,
    UINT fuFlags,
    int x,
    int y,
    HWND hwnd,
    LPTPMPARAMS lptpm)
{
    Assert( ( fuFlags & TPM_RETURNCMD ) == 0 );    // Not supported in Win16
    Assert( lptpm == NULL );                       // Different meaning in Win16
    return( TrackPopupMenu( hMenu, fuFlags, x, y, 0, hwnd, NULL ) );
}


/*****************************************************************************\
*                                                                             *
*  From winnls.h(INC32) - It should be in the (win16x.h)INC16
*                                                                             *
\*****************************************************************************/

BOOL
WINAPI __export
IsValidCodePage(
    UINT  CodePage)
{
   return( TRUE );
}

#if 0
int
WINAPI
GetTimeFormatA(
    LCID     Locale,
    DWORD    dwFlags,
    CONST SYSTEMTIME *lpTime,
    LPCSTR lpFormat,
    LPSTR  lpTimeStr,
    int      cchTime)
{
   return( 0 );
}

int
WINAPI
GetDateFormatA(
    LCID     Locale,
    DWORD    dwFlags,
    CONST SYSTEMTIME *lpDate,
    LPCSTR lpFormat,
    LPSTR  lpDateStr,
    int      cchDate)
{
   return( 0 );
}
#endif

BOOL
WINAPI __export
GetCPInfo(
    UINT      CodePage,
    LPCPINFO  lpCPInfo)
{
   return( FALSE );
}

BOOL
WINAPI __export
IsDBCSLeadByteEx(
    UINT  CodePage,
    BYTE  TestChar)
{
   return( FALSE );
}




/*****************************************************************************\
*                                                                             *
*  From wincrypt.h(INC32)
*                                                                             *
\*****************************************************************************/

// ADVAPI32 and CRYPT32 APIs.
BOOL
WINAPI __export
CryptAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags)
{
   return( FALSE );
}

BOOL
WINAPI __export
CryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags)
{
   return( FALSE );
}

BOOL
WINAPI __export
CryptGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags)
{
   return( FALSE );
}

BOOL
WINAPI __export
CryptSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags)
{
   return( FALSE );
}

BOOL
WINAPI __export
CryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey)
{
   return( FALSE );
}

BOOL
WINAPI __export
CryptDestroyKey(
    HCRYPTKEY hKey)
{
   return( FALSE );
}

DWORD
WINAPI __export
CertNameToStrA(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType,
    OUT OPTIONAL LPSTR psz,
    IN DWORD csz
    )
{
   return( FALSE );
}

PCCERT_CONTEXT
WINAPI __export
CertFindCertificateInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CONTEXT pPrevCertContext
    )
{
   return( NULL );
}

LONG
WINAPI __export
CertVerifyTimeValidity(
    IN LPFILETIME pTimeToVerify,
    IN PCERT_INFO pCertInfo
    )
{
   return( 0 );
}

BOOL
WINAPI __export
CryptDecodeObject(
    IN DWORD        dwCertEncodingType,
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    IN DWORD        dwFlags,
    OUT void        *pvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    )
{
   return( FALSE );
}

BOOL
WINAPI __export
CertGetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )

{
   return( FALSE );
}

BOOL
WINAPI __export
CryptEncodeObject(
    IN DWORD        dwCertEncodingType,
    IN LPCSTR       lpszStructType,
    IN const void   *pvStructInfo,
    OUT BYTE        *pbEncoded,
    IN OUT DWORD    *pcbEncoded
    )
{
   return( FALSE );
}

BOOL
WINAPI __export
CertCloseStore(
    IN HCERTSTORE hCertStore,
    DWORD dwFlags
    )
{
   return( FALSE );
}

BOOL
WINAPI __export
CertFreeCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    )
{
   return( FALSE );
}

PCCERT_CONTEXT
WINAPI __export
CertDuplicateCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    )
{
   return( NULL );
}

HCERTSTORE
WINAPI __export
CertDuplicateStore(
    IN HCERTSTORE hCertStore
    )
{
   return( NULL );
}

HCERTSTORE
WINAPI __export
CertOpenStore(
    IN LPCSTR lpszStoreProvider,
    IN DWORD dwEncodingType,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwFlags,
    IN const void *pvPara
    )
{
   return( NULL );
}

BOOL
WINAPI __export
CryptMsgClose(
    IN HCRYPTMSG hCryptMsg
    )
{
   return( FALSE );
}

BOOL
WINAPI __export
CryptMsgUpdate(
    IN HCRYPTMSG hCryptMsg,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    )
{
   return( FALSE );
}

BOOL
WINAPI __export
CryptMsgGetParam(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
   return( FALSE );
}

HCRYPTMSG
WINAPI __export
CryptMsgOpenToEncode(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    )
{
   return( NULL );
}

HCRYPTMSG
WINAPI __export
CryptMsgOpenToDecode(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN OPTIONAL PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    )
{
   return( NULL );
}

PCCERT_CONTEXT
WINAPI __export
CertGetSubjectCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId           // Only the Issuer and SerialNumber
                                    // fields are used
    )
{
   return( NULL );
}

BOOL
WINAPI __export
CryptMsgControl(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    )
{
   return( FALSE );
}

BOOL
WINAPI __export
CertCompareCertificate(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId1,
    IN PCERT_INFO pCertId2
    )
{
   return( FALSE );
}




#if 0
/*****************************************************************************\
*                                                                             *
*  From winreg.h(INC32)
*                                                                             *
\*****************************************************************************/

LONG
APIENTRY
RegEnumValueA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
   return( 0xFFFFFFFFL );
}
#endif


/*****************************************************************************\
*                                                                             *
*  From shellapi.h(INC32)
*                                                                             *
\*****************************************************************************/

DWORD WINAPI __export
SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA FAR *psfi, UINT cbFileInfo, UINT uFlags)
{
   Assert( ( uFlags & SHGFI_PIDL ) == 0 );
   if ( uFlags & SHGFI_ICON )
      psfi->hIcon = NULL;
//      psfi->hIcon = CopyIcon( (HINSTANCE)GetCurrentTask(), LoadIcon( NULL, IDI_APPLICATION ) );
   if ( uFlags & SHGFI_DISPLAYNAME )
      StrCpyN( psfi->szDisplayName, pszPath, ARRAYSIZE(psfi->szDisplayName) );
   if ( uFlags & SHGFI_TYPENAME )
      StrCpyN( psfi->szTypeName, "Type Name", ARRAYSIZE(psfi->szTypeName) );
   return( 0 );
}

BOOL WINAPI __export Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATAA lpData)
{
   return( FALSE );
}

BOOL WINAPI __export Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData)
{
   return( FALSE );
}

BOOL WINAPI __export ShellExecuteExA(LPSHELLEXECUTEINFOA lpExecInfo)
{
   return( FALSE );
}

BOOL WINAPI __export ShellExecuteExW(LPSHELLEXECUTEINFOW lpExecInfo)
{
   return( FALSE );
}

HICON WINAPI __export
ExtractAssociatedIcon( HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon )
{
   return( NULL );
}


#if 0
/*****************************************************************************\
*                                                                             *
*  From INETCOMM
*                                                                             *
\*****************************************************************************/

IMNACCTAPI HRESULT HrCreateAccountManager(IImnAccountManager **ppAccountManager)
{
   return( E_NOTIMPL );
}
#endif


/*****************************************************************************\
*                                                                             *
*  From WIN16X(INC16) - missing APIs
*                                                                             *
\*****************************************************************************/

BOOL
WINAPI __export
GetVersionEx(
    LPOSVERSIONINFOA lpVersionInformation
    )
{
   return( FALSE );
}

BOOL WINAPI __export GetStringTypeEx(
    LCID Locale,
    DWORD dwInfoType,
    LPCTSTR lpSrcStr,
    int cchSrc,
    LPWORD lpCharType
    )
{
   *lpCharType = 0;

   if(dwInfoType == CT_CTYPE1)
   {
       // Simple bug fix for IsDigit.
       if(lpSrcStr[0] >= '0' && lpSrcStr[0] <= '9')
           *lpCharType |= C1_DIGIT;
   }

   return( TRUE );
}

HPALETTE WINAPI __export CreateHalftonePalette(HDC hDC)
{
   return( NULL );
}

BOOL WINAPI __export StretchBlt32(HDC, int, int, int, int, HDC, int, int, int, int, DWORD)
{
   return( FALSE );
}

STDAPI __export
LoadTypeLib(const OLECHAR FAR* szFile, ITypeLib FAR* FAR* pptlib)
{
   return( E_NOTIMPL );
}

STDAPI __export
RegisterTypeLib(
    ITypeLib FAR* ptlib,
    OLECHAR FAR* szFullPath,
    OLECHAR FAR* szHelpDir)
{
   return( E_NOTIMPL );
}


HWND WINAPI __export
HtmlHelpA( HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD dwData )
{
   return( NULL );
}


} // extern "C"


#if 0
/*****************************************************************************\
*                                                                             *
*  From NEWS
*                                                                             *
\*****************************************************************************/

//
// NOTE: This function must be CPP
//
void Output(HWND hwnd, int id, LPSTR sz)
{
}

/*****************************************************************************\
*                                                                             *
*  From PSTOREC
*                                                                             *
\*****************************************************************************/
BOOL __stdcall GetPStoreProvider( 
    IPStoreProvider __RPC_FAR *__RPC_FAR *ppProvider,
    PPST_PROVIDERINFO pProviderInfo,
    DWORD dwReserved)
{
   return( FALSE );
}

BOOL __stdcall EnumPStoreProviders( 
    DWORD dwFlags,
    IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum)
{
   return( FALSE );
}
#endif


/*****************************************************************************\
*                                                                             *
*  From Shlwapi.h(INC16) - SHLWAPI APIs
*                                                                             *
\*****************************************************************************/

STDAPI_(LPSTR) __export
PathFindExtensionA(LPCSTR pszPath)
{
   return( NULL );
}

STDAPI_(LPSTR) __export
PathFindFileNameA(LPCSTR pszPath)
{
   return( NULL );
}

STDAPI_(LPSTR) __export
StrStrA(LPCSTR lpFirst, LPCSTR lpSrch)
{
   return( NULL );
}


STDAPI_(LPSTR) __export
StrFormatByteSizeA(DWORD dw, LPSTR szBuf, UINT uiBufSize)
{
   return( NULL );
}

/*****************************************************************************\
*                                                                             *
*  From Shlwapip.h(INC16) - SHLWAPI APIs
*                                                                             *
\*****************************************************************************/

STDAPI_(HRESULT) __export
UrlUnescapeA(
    LPSTR pszUrl,
    LPSTR pszUnescaped,
    LPDWORD pcchUnescaped,
    DWORD dwFlags)
{
   return( NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oeguids\oeguids.cpp ===
//--------------------------------------------------------------------------
// Oeguids.cpp
//--------------------------------------------------------------------------
#define _WIN32_OE 0x0501
#define DEFINE_STRCONST
#define DEFINE_STRING_CONSTANTS
#define DEFINE_DIRECTDB
#define USES_IID_IWABExtInit
#define USES_IID_IDistList
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIAdviseSink

#include <windows.h>
#include <ole2.h>
#include <initguid.h>
#undef INITGUID
#include "strconst.h"
#include "htmlstr.h"
#include "ourguid.h"
#include "mimeole.h"
#include "mimeolep.h"
#include "mimeedit.h"
#include <msoeapi.h>
#include <wabguid.h>
#ifndef WIN16
#include <msluguid.h>
#else
#include <richedit.h>
#include <richole.h>
#endif // !WIN16
#include <ibodyopt.h>
#include "cmdtargt.h"
#include <msoeopt.h>
#include <msoert.h>
#include <oestore.h>
#include <newimp.h>
#include <envguid.h>
#include <msoeobj.h>
#include <syncop.h>
#include <msoejunk.h>
#include <msident.h>
#include <hotwiz.h>

// $REVIEW: Slimey sleazy #define. Remove when Athena uses imnacct.h instead of imnact.h
#define __imnacct_h__ // Exclude imnacct.h, because it conflicts with imnact.h
#include "imnxport.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\msoert\_regutil.cpp ===
#include <pch.hxx>
#ifndef MAC
#include <BadStrFunctions.h>
#pragma warning (disable: 4127) // conditional expression is constant

#define MAXKEYNAME          256
#define MAXVALUENAME_LENGTH MAXKEYNAME
#define MAXDATA_LENGTH      16L*1024L

/*******************************************************************************
*
*  CopyRegistry
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hSourceKey,
*     hDestinationKey,
*
*******************************************************************************/

// static because CopyRegistry recurses - don't use too much stack
static CHAR g_KeyNameBuffer[MAXKEYNAME];
static CHAR g_ValueNameBuffer[MAXVALUENAME_LENGTH];
static BYTE g_ValueDataBuffer[MAXDATA_LENGTH];

OESTDAPI_(VOID) CopyRegistry(HKEY hSourceKey, HKEY hDestinationKey)
{
    DWORD EnumIndex;
    DWORD cbValueName;
    DWORD cbValueData;
    DWORD Type;
    HKEY hSourceSubKey;
    HKEY hDestinationSubKey;

    //
    //  Copy all of the value names and their data.
    //

    EnumIndex = 0;

    while (TRUE) {

        cbValueName = sizeof(g_ValueNameBuffer);
        cbValueData = MAXDATA_LENGTH;

        if (RegEnumValue(hSourceKey, EnumIndex++, g_ValueNameBuffer,
            &cbValueName, NULL, &Type, g_ValueDataBuffer, &cbValueData) !=
            ERROR_SUCCESS)
            break;

        RegSetValueEx(hDestinationKey, g_ValueNameBuffer, 0, Type,
            g_ValueDataBuffer, cbValueData);

    }

    //
    //  Copy all of the subkeys and recurse into them.
    //

    EnumIndex = 0;

    while (TRUE) {

        if (RegEnumKey(hSourceKey, EnumIndex++, g_KeyNameBuffer, MAXKEYNAME) !=
            ERROR_SUCCESS)
            break;

        if (RegOpenKey(hSourceKey, g_KeyNameBuffer, &hSourceSubKey) ==
            ERROR_SUCCESS) {

            if (RegCreateKey(hDestinationKey, g_KeyNameBuffer,
                &hDestinationSubKey) == ERROR_SUCCESS) {

                CopyRegistry(hSourceSubKey, hDestinationSubKey);

                RegCloseKey(hDestinationSubKey);

            }

            RegCloseKey(hSourceSubKey);

        }

    }
}
#endif  // !MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\junkeng.h ===
/*

  SVMHANDLER.H
  (c) copyright 1998 Microsoft Corp

  Contains the class encapsulating the Support Vector Machine used to do on the fly spam detection

  Robert Rounthwaite (RobertRo@microsoft.com)

*/

#if _MSC_VER > 1000
#pragma once
#endif

#include <msoejunk.h>

#ifdef DEBUG
interface ILogFile;
#endif  // DEBUG

enum boolop
{
    boolopOr = 0,
    boolopAnd
};

enum FeatureLocation
{
    locNil = 0,
    locBody = 1,
    locSubj = 2,
    locFrom = 3,
    locTo = 4,
    locSpecial = 5
};

const DOUBLE THRESH_DEFAULT = 0.90;
const DOUBLE THRESH_MOST    = 0.99;
const DOUBLE THRESH_LEAST   = 0.80;

typedef struct tagFEATURECOMP
{
    FeatureLocation loc;
    union
    {
        LPSTR   pszFeature;
        ULONG   ulRuleNum; // used with locSpecial
    };
    
    // map feature to location in dst file/location in SVM output
    // more than one feature component may map to the same location, combined with the op
    ULONG   ulFeature;
    
    boolop  bop; // first feature in group is alway bopOr
    BOOL    fPresent;
    DWORD   dwFlags;
    USHORT  cchFeature;
    
} FEATURECOMP, * PFEATURECOMP;

static const int CPBLIST_MAX    = 256;

typedef struct tagBODYLIST
{
    USHORT      usItem;
    USHORT      iNext;
} BODYLIST, * PBODYLIST;

class CJunkFilter : public IOEJunkFilter
{
    private:
        enum
        {
            STATE_UNINIT        = 0x00000000,
            STATE_INITIALIZED   = 0x00000001
        };

    private:
        LONG                m_cRef;
        CRITICAL_SECTION    m_cs;
        DWORD               m_dwState;
        
        // Properties of the user
        LPSTR               m_pszFirstName;
        ULONG               m_cchFirstName;
        LPSTR               m_pszLastName;
        ULONG               m_cchLastName;
        LPSTR               m_pszCompanyName;
        ULONG               m_cchCompanyName;
#ifdef DEBUG
        BOOL                m_fJunkMailLogInit;
        ILogFile *          m_pILogFile;
#endif  // DEBUG

    public:
        // Constructor/destructor
        CJunkFilter();
        ~CJunkFilter();
        
        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObject);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IOEJunkFilter
        STDMETHODIMP SetIdentity(LPCSTR pszFirstName, LPCSTR pszLastName, LPCSTR pszCompanyName);
        STDMETHODIMP LoadDataFile(LPCSTR pszFilePath);
        
        STDMETHODIMP SetSpamThresh(ULONG ulThresh);
        STDMETHODIMP GetSpamThresh(ULONG * pulThresh);
        STDMETHODIMP GetDefaultSpamThresh(DOUBLE * pdblThresh);
        
        STDMETHODIMP CalcJunkProb(DWORD dwFlags, IMimePropertySet * pIMPropSet, IMimeMessage * pIMMsg, double * pdblProb);
        
    // returns default value for SpamCutoff. read from SVM output file.
    // should call FSetSVMDataLocation before calling this function
    DOUBLE DblGetDefaultSpamCutoff(VOID){Assert(NULL != m_pszLOCPath); return m_dblDefaultThresh;}

    // Calculates the probability that the current message (defined by the properties of the message) is spam.
    // !Note! that the IN string params may be modified by the function.
    // Returns the probability (0 to 1) that the message is spam in pdblSpamProb
    // the boolean return is determined by comparing to the spam cutoff
    // if the value of a boolean param is unknown use false, use 0 for unknown time.
    BOOL FCalculateSpamProb(LPSTR pszFrom, LPSTR pszTo, LPSTR pszSubject, IStream * pIStmBody,
                            BOOL fDirectMessage, BOOL fHasAttach, FILETIME * pftMessageSent,
                            DOUBLE * pdblSpamProb, BOOL * pfIsSpam);

    // Reads the default spam cutoff without parsing entire file
    // Use GetDefaultSpamCutoff if using FSetSVMDataLocation;
    static HRESULT HrReadDefaultSpamCutoff(LPSTR pszFullPath, DOUBLE * pdblDefCutoff);

private: // members
    WORD                m_rgiBodyList[CPBLIST_MAX];
    BODYLIST *          m_pblistBodyList;
    USHORT              m_cblistBodyList;
    
    FEATURECOMP *       m_rgfeaturecomps;

    // weights from SVM output
    DOUBLE *    m_rgdblSVMWeights;
    
    // Other SVM file variables
    DOUBLE      m_dblCC;
    DOUBLE      m_dblDD;
    DOUBLE      m_dblThresh;
    DOUBLE      m_dblDefaultThresh;
    DOUBLE      m_dblMostThresh;
    DOUBLE      m_dblLeastThresh;

    // Counts
    ULONG       m_cFeatures;
    ULONG       m_cFeatureComps;

    // is Feature present? -1 indicates not yet set, 0 indicates not present, 1 indicates present
    ULONG *     m_rgulFeatureStatus;

    // Set via FSetSVMDataLocation() and SetSpamCutoff()
    LPSTR   m_pszLOCPath;
    DOUBLE  m_dblSpamCutoff;

    // Properties of the message
    LPSTR       m_pszFrom; 
    LPSTR       m_pszTo; 
    LPSTR       m_pszSubject; 
    IStream *   m_pIStmBody;
    ULONG       m_cbBody;
    BOOL        m_fDirectMessage;
    FILETIME    m_ftMessageSent;
    BOOL        m_fHasAttach;

    // Cached special rule results used during spam calculations
    BOOL        m_fRule14;
    BOOL        m_fRule17;

private: // methods
    HRESULT _HrReadSVMOutput(LPCSTR lpszFileName);
    void _EvaluateFeatureComponents(VOID);
    VOID _ProcessFeatureComponentPresence(VOID);
    DOUBLE _DblDoSVMCalc(VOID);
    BOOL _FInvokeSpecialRule(UINT iRuleNum);
    VOID _HandleCaseSensitiveSpecialRules(VOID);
    VOID _EvaluateBodyFeatures(VOID);
    HRESULT _HrBuildBodyList(USHORT cBodyItems);
#ifdef DEBUG
    HRESULT _HrCreateLogFile(VOID);
    VOID _PrintFeatureToLog(ULONG ulIndex);
    VOID _PrintSpecialFeatureToLog(UINT iRuleNum);
#endif  // DEBUG
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\junkeng.cpp ===
/*

  SVMHANDLER.CPP
  (c) copyright 1998 Microsoft Corp

  Contains the class encapsulating the Support Vector Machine used to do on the fly spam detection

  Robert Rounthwaite (RobertRo@microsoft.com)

*/

#include <pch.hxx>
#include "junkeng.h"
#include "junkutil.h"
#include "parsestm.h"
#include <iert.h>
#include <math.h>
#include <limits.h>

class CBodyBuff
{
    private:
        enum
        {
            CB_BODYBUFF_MAX = 4096
        };

        enum
        {
            BBF_CLEAR           = 0x00000000,
            BBF_SET             = 0x00000001,
            BBF_ALPHA           = 0x00000002,
            BBF_NUM             = 0x00000004,
            BBF_SPACE           = 0x00000008,
            BBF_MASK            = 0x0000000F
        };

    private:
        IStream *   m_pIStream;
        ULONG       m_cbStream;
        ULONG       m_ibStream;
        BYTE        m_rgbBuff[CB_BODYBUFF_MAX];
        ULONG       m_cbBuffTotal;
        BYTE *      m_pbBuffCurr;
        DWORD       m_dwFlagsCurr;
        BYTE *      m_pbBuffGood;
        BYTE *      m_pbBuffPrev;
        DWORD       m_dwFlagsPrev;

    public:
        CBodyBuff() : m_pIStream(NULL), m_cbStream(0), m_ibStream(0),
                        m_cbBuffTotal(0), m_pbBuffCurr(m_rgbBuff), m_dwFlagsCurr(BBF_CLEAR),
                        m_pbBuffGood(m_rgbBuff), m_pbBuffPrev(NULL), m_dwFlagsPrev(BBF_CLEAR) {}
        ~CBodyBuff() {SafeRelease(m_pIStream);}

        HRESULT HrInit(DWORD dwFlags, IStream * pIStream);
        HRESULT HrGetCurrChar(CHAR * pchNext);
        BOOL FDoMatch(FEATURECOMP * pfcomp);

        HRESULT HrMoveNext(VOID)
        {
            m_pbBuffPrev = m_pbBuffCurr;
            m_dwFlagsPrev = m_dwFlagsCurr;
            
            m_pbBuffCurr = (BYTE *) CharNext((LPSTR) m_pbBuffCurr);
            m_dwFlagsCurr = BBF_CLEAR;
            
            return S_OK;
        }

    private:
        HRESULT _HrFillBuffer(VOID);
};

static const LPSTR szCountFeatureComp       = "FeatureComponentCount = ";
static const LPSTR szDefaultThresh          = "dThresh =  ";
static const LPSTR szMostThresh             = "mThresh =  ";
static const LPSTR szLeastThresh            = "lThresh =  ";
static const LPSTR szThresh                 = "Threshold =  ";
static const LPSTR szNumberofDim            = "NumDim = ";

#ifdef DEBUG
static const LPSTR STR_REG_PATH_FLAT        = "Software\\Microsoft\\Outlook Express";
static const LPSTR szJunkMailPrefix         = "JUNKMAIL";
static const LPSTR szJunkMailLog            = "JUNKMAIL.LOG";

static const LPSTR LOG_TAGLINE              = "Calculating Junk Mail for message: %s";
static const LPSTR LOG_FIRSTNAME            = "User's First Name: %s";
static const LPSTR LOG_LASTNAME             = "User's Last Name: %s";
static const LPSTR LOG_COMPANYNAME          = "User's Company Name: %s";
static const LPSTR LOG_BODY                 = "Body contains: %s";
static const LPSTR LOG_SUBJECT              = "Subject contains: %s";
static const LPSTR LOG_TO                   = "To line contains: %s";
static const LPSTR LOG_FROM                 = "From line contains: %s";
static const LPSTR LOG_FINAL                = "Junk Mail percentage: %0.1d.%0.6d\r\n";
#endif  // DEBUG

BOOL FReadDouble(LPSTR pszLine, LPSTR pszToken, DOUBLE * pdblVal);
#ifdef DEBUG
VOID PrintToLogFile(ILogFile * pILogFile, LPSTR pszTmpl, LPSTR pszArg);
#endif  // DEBUG

HRESULT CBodyBuff::HrInit(DWORD dwFlags, IStream * pIStream)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if (NULL == pIStream)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Set the stream
    m_pIStream = pIStream;
    m_pIStream->AddRef();

    // Get the stream size
    hr = HrGetStreamSize(m_pIStream, &m_cbStream);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Reset the stream to the beginning
    hr = HrRewindStream(m_pIStream);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Start from the beginning
    m_ibStream = 0;
    
exit:
    return hr;
}

HRESULT CBodyBuff::HrGetCurrChar(CHAR * pchNext)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    Assert(NULL != pchNext);

    // Do we need to get any more characters?
    if (m_pbBuffCurr >= m_pbBuffGood)
    {
        // If we couldn't get any more characters
        if (S_OK != _HrFillBuffer())
        {
            hr = E_FAIL;
            goto exit;
        }
    }
    
    // Get the current char
    *pchNext = *m_pbBuffCurr;

    hr = S_OK;
    
exit:
    return hr;
}

BOOL CBodyBuff::FDoMatch(FEATURECOMP * pfcomp)
{
    BOOL        fRet = FALSE;
    BYTE *      pbSearch = NULL;
    ULONG       cchSearch = 0;
    LPSTR       pszMatch = NULL;
    DWORD       dwFlags = 0;

    // Check incoming params
    Assert(NULL != pfcomp);
    Assert(NULL != pfcomp->pszFeature);
    Assert(0 != pfcomp->cchFeature);

    // Set up some locals
    cchSearch = pfcomp->cchFeature;

    // Do we need more characters for the match?
    
    // Include the character after the string, just in case
    // we have a match and need to check the character after
    // the string for a word break
    if ((cchSearch + 1) > (ULONG) (m_pbBuffGood - m_pbBuffCurr))
    {
        // Get more characters

        // If this fails, we still might be good, since
        // we might just have enough characters to do the
        // full match at the end of the stream.
        (VOID) _HrFillBuffer();   
        
        // Could we get enough?
        if (cchSearch > (ULONG) (m_pbBuffGood - m_pbBuffCurr))
        {
            // No Match
            fRet = FALSE;
            goto exit;
        }
    }
    
    // Do match
    pbSearch = m_pbBuffCurr;
    pszMatch = pfcomp->pszFeature;
    while (0 != cchSearch--)
    {
        if (*(pszMatch++) != *(pbSearch++))
        {
            // No Match
            fRet = FALSE;
            goto exit;
        }
    }
                    
    // Validate the match

    // Do we need to figure out if it starts with a word break?
    if (0 != (pfcomp->dwFlags & CT_START_SET))
    {
        dwFlags = pfcomp->dwFlags;
    }
    else
    {
        Assert(CT_END_SET != (dwFlags & CT_END_SET));
        dwFlags = m_dwFlagsCurr;
    }
    
    Assert(CT_START_SET == BBF_SET);
    Assert(CT_START_ALPHA == BBF_ALPHA);
    fRet = FMatchToken((NULL == m_pbBuffPrev),
                        ((m_ibStream >= m_cbStream) && ((m_pbBuffCurr + pfcomp->cchFeature) >= m_pbBuffGood)),
                        (LPCSTR) m_pbBuffPrev, &m_dwFlagsPrev, pfcomp->pszFeature,
                        pfcomp->cchFeature, &dwFlags, (LPCSTR) (m_pbBuffCurr + pfcomp->cchFeature));

    // Save the changed flags
    pfcomp->dwFlags = dwFlags;

    // Cache the current character's state
    m_dwFlagsCurr = (dwFlags & BBF_MASK);
    
exit:
    return fRet;
}

HRESULT CBodyBuff::_HrFillBuffer(VOID)
{
    HRESULT     hr = S_OK;
    LONG        cbExtra = 0;
    ULONG       cbRead = 0;
    ULONG       cbToRead = 0;

    // If there isn't any more of the stream to grab
    if (m_ibStream >= m_cbStream)
    {
        hr = S_FALSE;
        goto exit;
    }
    
    // If this is the first time through, save nothing
    if (NULL == m_pbBuffPrev)
    {
        cbExtra = 0;
    }
    else
    {
        // How much space should I save?
        cbExtra = (ULONG) (m_cbBuffTotal - (m_pbBuffPrev - m_rgbBuff));
        Assert(cbExtra > 0);
        
        // Save the unused data
        MoveMemory(m_rgbBuff, m_pbBuffPrev, (int)min(cbExtra, sizeof(m_rgbBuff)));
        
        // Reset the current pointer
        m_pbBuffCurr = m_rgbBuff + (m_pbBuffCurr - m_pbBuffPrev);

        // Reset the previous pointer
        m_pbBuffPrev = m_rgbBuff;    
    }

    // Read in more data
    cbToRead = (int)min(CB_BODYBUFF_MAX - cbExtra - 1, (LONG) (m_cbStream - m_ibStream));
    hr = m_pIStream->Read(m_rgbBuff + cbExtra, cbToRead, &cbRead);
    if ((FAILED(hr)) || (0 == cbRead))
    {
        // End of stream
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    // Track the number of bytes read
    m_ibStream += cbRead;
    
    // Set the total buffer size
    m_cbBuffTotal = cbExtra + cbRead;

    // Terminate the buffer, just in case
    m_rgbBuff[m_cbBuffTotal] = '\0';
    
    // Uppercase the buffer
    m_pbBuffGood = m_rgbBuff + CharUpperBuff((CHAR *) m_rgbBuff, m_cbBuffTotal);
        
exit:
    return hr;
}

HRESULT CJunkFilter::_HrBuildBodyList(USHORT cBodyItems)
{
    HRESULT             hr = S_OK;
    USHORT              usIndex = 0;
    FEATURECOMP *       pfcomp = NULL;
    USHORT              iBodyList = 0;

    // Check incoming params
    if (0 == cBodyItems)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    Assert(USHRT_MAX > cBodyItems);
    
    // Make sure the old items are freed
    SafeMemFree(m_pblistBodyList);        
    m_cblistBodyList = 0;

    // Initialize the list
    ZeroMemory(m_rgiBodyList, sizeof(m_rgiBodyList));

    // Allocate space to hold all of the items
    hr = HrAlloc((VOID **) &m_pblistBodyList, sizeof(*m_pblistBodyList) * (cBodyItems + 1));
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the body list
    ZeroMemory(m_pblistBodyList, sizeof(*m_pblistBodyList) * (cBodyItems + 1));
    
    // For each feature
    for (usIndex = 0, iBodyList = 1, pfcomp = m_rgfeaturecomps; usIndex < m_cFeatureComps; usIndex++, pfcomp++)
    {
        // If it's a body feature
        if (locBody == pfcomp->loc)
        {
            // Initialize it
            m_pblistBodyList[iBodyList].usItem = usIndex;
            
            // Add it to the list
            m_pblistBodyList[iBodyList].iNext = m_rgiBodyList[(UCHAR) (pfcomp->pszFeature[0])];
            m_rgiBodyList[(UCHAR) (pfcomp->pszFeature[0])] = iBodyList;

            // Move to the next body item
            iBodyList++;
        }
    }

    // Save the number of items
    m_cblistBodyList = cBodyItems + 1;
    
    // Set the return value
    hr = S_OK;
    
exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// _FReadSVMOutput
//
// Read the SVM output from a file (".LKO file")
/////////////////////////////////////////////////////////////////////////////
HRESULT CJunkFilter::_HrReadSVMOutput(LPCSTR pszFileName)
{
    HRESULT         hr = S_OK;
    CParseStream    parsestm;
    ULONG           ulIndex = 0;
    LPSTR           pszBuff = NULL;
    ULONG           cchBuff = 0;
    LPSTR           pszDummy = NULL;
    LPSTR           pszDefThresh = NULL;
    ULONG           cFeatureComponents = 0;
    LPSTR           pszFeature = NULL;
    ULONG           ulFeatureComp = 0;
    USHORT          cBodyItems = 0;
    FEATURECOMP *   pfeaturecomp = NULL;

    if ((NULL == pszFileName) || ('\0' == *pszFileName))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Get the parse stream
    hr = parsestm.HrSetFile(0, pszFileName);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // skip first two lines
    for (ulIndex = 0; ulIndex < 3; ulIndex++)
    {
        SafeMemFree(pszBuff);
        hr = parsestm.HrGetLine(0, &pszBuff, &cchBuff);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // parse 3rd line: only care about CC and DD
    if (FALSE == FReadDouble(pszBuff, "cc =  ", &m_dblCC))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    if (FALSE == FReadDouble(pszBuff, "dd =  ", &m_dblDD))
    {
        hr = E_FAIL;
        goto exit;
    }
    
    SafeMemFree(pszBuff);
    hr = parsestm.HrGetLine(0, &pszBuff, &cchBuff);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    if (FALSE == FReadDouble(pszBuff, szDefaultThresh, &m_dblDefaultThresh))
    {
        m_dblDefaultThresh = THRESH_DEFAULT;
    }

    if (0 == m_dblSpamCutoff)
    {
        m_dblSpamCutoff = m_dblDefaultThresh;
    }
    
    if (FALSE == FReadDouble(pszBuff, szThresh, &m_dblThresh))
    {
        hr = E_FAIL;
        goto exit;
    }
        
    SafeMemFree(pszBuff);
    hr = parsestm.HrGetLine(0, &pszBuff, &cchBuff);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    if (FALSE == FReadDouble(pszBuff, szMostThresh, &m_dblMostThresh))
    {
        m_dblMostThresh = THRESH_MOST;
    }

    if (FALSE == FReadDouble(pszBuff, szLeastThresh, &m_dblLeastThresh))
    {
        m_dblLeastThresh = THRESH_LEAST;
    }

    SafeMemFree(pszBuff);
    hr = parsestm.HrGetLine(0, &pszBuff, &cchBuff);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    m_cFeatures = StrToInt(pszBuff + lstrlen(szNumberofDim));
    if (0 == m_cFeatures)
    {
        hr = E_FAIL;
        goto exit;
    }

    // We only support up to USHRT_MAX features
    if (m_cFeatures >= USHRT_MAX)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    SafeMemFree(pszBuff);
    hr = parsestm.HrGetLine(0, &pszBuff, &cchBuff);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    pszDummy = StrStr(pszBuff, szCountFeatureComp);
    if (NULL != pszDummy)
    {
        pszDummy += lstrlen(szCountFeatureComp);
        cFeatureComponents = StrToInt(pszDummy);
    }

    if (cFeatureComponents < m_cFeatures)
    {
        cFeatureComponents = m_cFeatures * 2;
    }
    
    while (0 != lstrcmp(pszBuff, "Weights"))
    {
        SafeMemFree(pszBuff);
        hr = parsestm.HrGetLine(0, &pszBuff, &cchBuff);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    SafeMemFree(m_rgdblSVMWeights);
    hr = HrAlloc((void **) &m_rgdblSVMWeights, sizeof(*m_rgdblSVMWeights) * m_cFeatures);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    SafeMemFree(m_rgulFeatureStatus);
    hr = HrAlloc((void **) &m_rgulFeatureStatus, sizeof(*m_rgulFeatureStatus) * m_cFeatures);
    if (FAILED(hr))
    {
        goto exit;
    }
    FillMemory(m_rgulFeatureStatus, sizeof(*m_rgulFeatureStatus) * m_cFeatures, -1);
    
    SafeMemFree(m_rgfeaturecomps);
    hr = HrAlloc((void **) &m_rgfeaturecomps, sizeof(*m_rgfeaturecomps) * cFeatureComponents);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Initialize the features
    ZeroMemory(m_rgfeaturecomps, sizeof(*m_rgfeaturecomps) * cFeatureComponents);
    
    for (ulIndex = 0; ulIndex < m_cFeatures; ulIndex++)
    {
        UINT    uiLoc;
        USHORT  cbStr;
        boolop  bop;
        BOOL    fContinue;
        BOOL    fNegative;
        
        SafeMemFree(pszBuff);
        hr = parsestm.HrGetLine(0, &pszBuff, &cchBuff);
        if (FAILED(hr))
        {
            goto exit;
        }
        
        // read the SVM weight
        pszDummy = pszBuff;
        fNegative = ('-' == *pszDummy);
        pszDummy++;
        
        m_rgdblSVMWeights[ulIndex] = StrToDbl(pszDummy, &pszDummy);

        if (FALSE != fNegative)
        {
            m_rgdblSVMWeights[ulIndex] *= -1;
        }
        
        pszDummy++; // skip the separator
        bop = boolopOr;
        fContinue = false;
        do
        {
            pfeaturecomp = &m_rgfeaturecomps[ulFeatureComp++];
            
            // Skip over white space
            UlStripWhitespace(pszDummy, TRUE, FALSE, NULL);
            
            // Location (or "special")
            uiLoc = StrToInt(pszDummy);
            pszDummy = StrStr(pszDummy, ":"); // skip the separator
            pszDummy++;

            pfeaturecomp->loc = (FeatureLocation)uiLoc;
            pfeaturecomp->ulFeature = ulIndex;
            pfeaturecomp->bop = bop;

            if (locBody == pfeaturecomp->loc)
            {
                cBodyItems++;
            }
            
            if (uiLoc == 5)
            {
                UINT uiRuleNumber = StrToInt(pszDummy);
                pszDummy += StrSpn(pszDummy, "0123456789");

                pfeaturecomp->ulRuleNum = uiRuleNumber;
            }
            else
			{
                cbStr  = (USHORT) StrToInt(pszDummy);
                pszDummy = StrStr(pszDummy, ":");
                pszDummy++;

                // We only support strings up to USHRT_MAX
                if (cbStr >= USHRT_MAX)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
                
                hr = HrAlloc((void **) &pszFeature, sizeof(*pszFeature) * (cbStr + 1));
                if (FAILED(hr))
                {
                    goto exit;
                }
                
                StrCpyN(pszFeature, pszDummy, cbStr + 1);
                pszDummy += cbStr;
                if ('\0' != *pszDummy)
                {
                    pszDummy++; // skip the separator
                }
                
                pszFeature[cbStr] = '\0';
                Assert(cbStr == strlen(pszFeature));

                // Save off the string
                pfeaturecomp->pszFeature = pszFeature;
                pszFeature = NULL;
                pfeaturecomp->cchFeature = cbStr;
            }
            
            UlStripWhitespace(pszDummy, TRUE, FALSE, NULL);
            
            switch(*pszDummy)
            {
              case '|':  
                bop = boolopOr;
                fContinue = TRUE;
                break;
                
              case '&':  
                bop = boolopAnd;
                fContinue = TRUE;
                break;
                
              default: 
                fContinue = FALSE;
                break;
            }
            
            pszDummy++;
        }
        while (fContinue);
    }
    
    m_cFeatureComps = ulFeatureComp;

    // Build up body items...
    hr = _HrBuildBodyList(cBodyItems);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = S_OK;
    
exit:
    SafeMemFree(pszFeature);
    SafeMemFree(pszBuff);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// _FInvokeSpecialRule
//
// Invokes the special rule that is this FEATURECOMP. 
// Returns the state of the feature.
/////////////////////////////////////////////////////////////////////////////
BOOL CJunkFilter::_FInvokeSpecialRule(UINT iRuleNum)
{
    BOOL        fRet = FALSE;
    SYSTEMTIME  stSent;
    CHAR        rgchYear[6];
    ULONG       cbSize = 0;
    DWORD       dwDummy = 0;
    
    switch (iRuleNum)
    {
        case 1:
            fRet = FStreamStringSearch(m_pIStmBody, &dwDummy, m_pszFirstName, m_cchFirstName, 0);
            break;
            
        case 2: 
            fRet = FStreamStringSearch(m_pIStmBody, &dwDummy, m_pszLastName, m_cchLastName, 0);
            break;
            
        case 3:
            fRet = FStreamStringSearch(m_pIStmBody, &dwDummy, m_pszCompanyName, m_cchCompanyName, 0);
            break;
            
        case 4: 
            // year message received
            if (FALSE == FTimeEmpty(&m_ftMessageSent))
            {
                // Convert to system time so we can get the year
                SideAssert(FALSE != FileTimeToSystemTime(&m_ftMessageSent, &stSent));

                
                wnsprintf(rgchYear, ARRAYSIZE(rgchYear), "%d", stSent.wYear);
                dwDummy = CT_START_SET | CT_START_NUM | CT_END_SET | CT_END_NUM;
                fRet = FStreamStringSearch(m_pIStmBody, &dwDummy, rgchYear, lstrlen(rgchYear), SSF_CASESENSITIVE);
            }
            break;
            
        case 5:
            // message received in the wee hours (>= 7pm or <6am
            if (FALSE == FTimeEmpty(&m_ftMessageSent))
            {
                // Convert to system time so we can get the year
                SideAssert(FALSE != FileTimeToSystemTime(&m_ftMessageSent, &stSent));
                
                fRet = (stSent.wHour >= (7 + 12)) || (stSent.wHour < 6);
            }
            break;
            
        case 6:
            // message received on weekend
            if (FALSE == FTimeEmpty(&m_ftMessageSent))
            {
                // Convert to system time so we can get the year
                SideAssert(FALSE != FileTimeToSystemTime(&m_ftMessageSent, &stSent));
                
                fRet = ((0 == stSent.wDayOfWeek) || (6 == stSent.wDayOfWeek));
            }
            break;
            
        case 14:
            fRet = m_fRule14; // set in _HandleCaseSensitiveSpecialRules()
            break;
            
        case 15:
            fRet = FSpecialFeatureNonAlphaStm(m_pIStmBody);
            break;
            
        case 16:
            fRet = m_fDirectMessage;
            break;
            
        case 17:
            fRet = m_fRule17; // set in _HandleCaseSensitiveSpecialRules()
            break;
            
        case 18:
            fRet = FSpecialFeatureNonAlpha(m_pszSubject);
            break;
            
        case 19:
            fRet = ((NULL == m_pszTo) || ('\0' == *m_pszTo));
            break;
            
        case 20:
            fRet = m_fHasAttach;
            break;

        case 40:
            fRet = (m_cbBody >= 125);
            break;
            
        case 41:
            fRet = (m_cbBody >= 250);
            break;
            
        case 42:
            fRet = (m_cbBody >= 500);
            break;
            
        case 43:
            fRet = (m_cbBody >= 1000);
            break;
            
        case 44:
            fRet = (m_cbBody >= 2000);
            break;
            
        case 45:
            fRet = (m_cbBody >= 4000);
            break;
            
        case 46:
            fRet = (m_cbBody >= 8000);
            break;
            
        case 47:
            fRet = (m_cbBody >= 16000);
            break;
            
        default:
            AssertSz(FALSE, "unsupported special feature");
            break;
    }
    
    return fRet;
}


/////////////////////////////////////////////////////////////////////////////
// _HandleCaseSensitiveSpecialRules
//
// Called from _EvaluateFeatureComponents().
// Some special rules are case sensitive, so if they're present, we'll 
// evaluate them before we make the texts uppercase and cache the result
// for when they are actually used.
/////////////////////////////////////////////////////////////////////////////
VOID CJunkFilter::_HandleCaseSensitiveSpecialRules()
{
    ULONG   ulIndex = 0;
    
    for (ulIndex = 0; ulIndex < m_cFeatureComps; ulIndex++)
    {
        if (m_rgfeaturecomps[ulIndex].loc == locSpecial)
        {
            switch (m_rgfeaturecomps[ulIndex].ulRuleNum)
            {
              case 14:
                m_fRule14 = FSpecialFeatureUpperCaseWordsStm(m_pIStmBody);
                break;
                
              case 17:
                m_fRule17 = FSpecialFeatureUpperCaseWords(m_pszSubject);
                break;
                
              default: 
                break;
            }
        }
    }
    
    return;
}

VOID CJunkFilter::_EvaluateBodyFeatures(VOID)
{
    CBodyBuff           buffBody;
    CHAR                chMatch = '\0';
    ULONG               ulIndex = 0;
    FEATURECOMP *       pfcomp = NULL;
    USHORT              iBodyList = 0;
    
    // Check to see if we have work to do
    if (NULL == m_pIStmBody)
    {
        goto exit;
    }

    // Set the stream into the buffer
    if (FAILED(buffBody.HrInit(0, m_pIStmBody)))
    {
        goto exit;
    }

    // Initialize all the body features to no found
    for (iBodyList = 1; iBodyList < m_cblistBodyList; iBodyList++)
    {
        // Set it to not found
        m_rgfeaturecomps[m_pblistBodyList[iBodyList].usItem].fPresent = FALSE;
    }
    
    // While we have more bytes to read
    for (; S_OK == buffBody.HrGetCurrChar(&chMatch); buffBody.HrMoveNext())
    {
        // Search for a match through the feature list
        for (iBodyList = m_rgiBodyList[(UCHAR) chMatch]; 0 != iBodyList; iBodyList = m_pblistBodyList[iBodyList].iNext)
        {
            pfcomp = &(m_rgfeaturecomps[m_pblistBodyList[iBodyList].usItem]);
            
            // If we have a body item and it hasn't been found yet
            if (FALSE == pfcomp->fPresent)
            {
                // Could this item be a possible match???
                Assert(NULL != pfcomp->pszFeature);
                
                // Try to do the comparison
                pfcomp->fPresent = buffBody.FDoMatch(pfcomp);
            }
        }
    }

exit:
    return;
}

/////////////////////////////////////////////////////////////////////////////
// _EvaluateFeatureComponents
//
// Evaluates all of the feature components. Sets fPresent in each component
// to true if the feature is present, false otherwise
/////////////////////////////////////////////////////////////////////////////
VOID CJunkFilter::_EvaluateFeatureComponents(VOID)
{
    ULONG           ulIndex = 0;
    FEATURECOMP *   pfcomp = NULL;
    
    _HandleCaseSensitiveSpecialRules();

    if (NULL != m_pszFrom)
    {
        CharUpperBuff(m_pszFrom, lstrlen(m_pszFrom));
    }
    if (NULL != m_pszTo)
    {
        CharUpperBuff(m_pszTo, lstrlen(m_pszTo));
    }
    if (NULL != m_pszSubject)
    {
        CharUpperBuff(m_pszSubject, lstrlen(m_pszSubject));
    }

    for (ulIndex = 0; ulIndex < m_cFeatureComps; ulIndex++)
    {
        pfcomp = &m_rgfeaturecomps[ulIndex];
        
        switch(pfcomp->loc)
        {
          case locNil:
            Assert(locNil != pfcomp->loc);
            pfcomp->fPresent = FALSE;
            break;

          case locSubj:
            pfcomp->fPresent = FWordPresent(m_pszSubject, &(pfcomp->dwFlags), pfcomp->pszFeature, pfcomp->cchFeature, NULL);
            break;
            
          case locFrom:
            pfcomp->fPresent = FWordPresent(m_pszFrom, &(pfcomp->dwFlags), pfcomp->pszFeature, pfcomp->cchFeature, NULL);
            break;
            
          case locTo:
            pfcomp->fPresent = FWordPresent(m_pszTo, &(pfcomp->dwFlags), pfcomp->pszFeature, pfcomp->cchFeature, NULL);
            break;
            
          case locSpecial:
            pfcomp->fPresent = _FInvokeSpecialRule(pfcomp->ulRuleNum);
            break;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// ProcessFeatureComponentPresence
//
// Processes the presence (or absence) of the individual feature components,
// setting the feature status of each feature (which may me made up of
// multiple feature components).
/////////////////////////////////////////////////////////////////////////////
VOID CJunkFilter::_ProcessFeatureComponentPresence(VOID)
{
    ULONG               ulIndex = 0;
    FEATURECOMP *       pfcomp = NULL;
    ULONG               ulFeature = 0;
    
    for (ulIndex = 0; ulIndex < m_cFeatureComps; ulIndex++)
    {
        pfcomp = &m_rgfeaturecomps[ulIndex];
        ulFeature = pfcomp->ulFeature;
        
        if (-1 == m_rgulFeatureStatus[ulFeature]) // first feature of this feature
        {
            if (FALSE != pfcomp->fPresent)
            {
                m_rgulFeatureStatus[ulFeature] = 1;
            }
            else
            {
                m_rgulFeatureStatus[ulFeature] = 0;
            }
        }
        else
        {
            switch (pfcomp->bop)
            {
              case boolopOr:
                if (pfcomp->fPresent)
                {
                    m_rgulFeatureStatus[ulFeature] = 1;
                }
                break;
                
              case boolopAnd:
                if (!pfcomp->fPresent)
                {
                    m_rgulFeatureStatus[ulFeature] = 0;
                }
                break;
                
              default:
                Assert(FALSE);
                break;
            }

        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// _DblDoSVMCalc
//
// Does the actual support vector machine calculation.
// Returns the probability that the message is spam
/////////////////////////////////////////////////////////////////////////////
DOUBLE CJunkFilter::_DblDoSVMCalc(VOID)
{
    DOUBLE  dblAccum;
    DOUBLE  dblResult;
    ULONG   ulIndex = 0;

    dblAccum = 0.0;
    
    for (ulIndex = 0; ulIndex < m_cFeatures; ulIndex++)
    {
        if (m_rgulFeatureStatus[ulIndex] == 1)
        {
            dblAccum += m_rgdblSVMWeights[ulIndex];
#ifdef DEBUG    
            if (NULL != m_pILogFile)
            {
                _PrintFeatureToLog(ulIndex);
            }
#endif  // DEBUG
        }
        else if (m_rgulFeatureStatus[ulIndex] != 0)
        {
            AssertSz(FALSE, "What happened here!");
        }
    }
    
    // Apply threshold;
    dblAccum -= m_dblThresh;

    // Apply sigmoid
    dblResult = (1 / (1 + exp((m_dblCC * dblAccum) + m_dblDD)));

    return dblResult;
}

/////////////////////////////////////////////////////////////////////////////
// BCalculateSpamProb
//
// Calculates the probability that the current message is spam.
// Returns the probability (0 to 1) that the message is spam in prSpamProb
// the boolean return is determined by comparing to the spam cutoff
/////////////////////////////////////////////////////////////////////////////
BOOL CJunkFilter::FCalculateSpamProb(LPSTR pszFrom, LPSTR pszTo, LPSTR pszSubject, IStream * pIStmBody,
                            BOOL fDirectMessage, BOOL fHasAttach, FILETIME * pftMessageSent,
                            DOUBLE * pdblSpamProb, BOOL * pfIsSpam)
{
#ifdef DEBUG
    CHAR    rgchBuff[1024];
    DWORD   dwVal = 0;
#endif  // DEBUG
    
    m_pszFrom = pszFrom;
    m_pszTo = pszTo;        
    m_pszSubject = pszSubject;   
    m_pIStmBody = pIStmBody;      
    m_fDirectMessage = fDirectMessage;
    m_fHasAttach = fHasAttach;
    m_ftMessageSent = *pftMessageSent;

    // Set the size of the body
    if ((NULL == m_pIStmBody) || (FAILED(HrGetStreamSize(m_pIStmBody, &m_cbBody))))
    {
        m_cbBody = 0;
    }

#ifdef DEBUG
    // Get the logfile if we need it
    if (NULL == m_pILogFile)
    {
        _HrCreateLogFile();
    }

    if (NULL != m_pILogFile)
    {
        PrintToLogFile(m_pILogFile, LOG_TAGLINE, pszSubject);

        PrintToLogFile(m_pILogFile, LOG_FIRSTNAME, m_pszFirstName);
        
        PrintToLogFile(m_pILogFile, LOG_LASTNAME, m_pszLastName);
        
        PrintToLogFile(m_pILogFile, LOG_COMPANYNAME, m_pszCompanyName);
    }
#endif  // DEBUG
    
    _EvaluateBodyFeatures();
    _EvaluateFeatureComponents();
    _ProcessFeatureComponentPresence();

    *pdblSpamProb = _DblDoSVMCalc();
    
#ifdef DEBUG
    if (NULL != m_pILogFile)
    {
        dwVal = ( DWORD ) ((*pdblSpamProb * 1000000) + 0.5);
        
        wnsprintf(rgchBuff, ARRAYSIZE(rgchBuff), LOG_FINAL, dwVal / 1000000, dwVal % 1000000);
        
        m_pILogFile->WriteLog(LOGFILE_DB, rgchBuff);
        m_pILogFile->WriteLog(LOGFILE_DB, "");
    }
#endif  // DEBUG
    
    *pfIsSpam = (*pdblSpamProb > m_dblSpamCutoff);

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// BReadDefaultSpamCutoff
//
// Reads the default spam cutoff without parsing entire file
// Use GetDefaultSpamCutoff if using HrSetSVMDataLocation;
// static member function
/////////////////////////////////////////////////////////////////////////////
HRESULT CJunkFilter::HrReadDefaultSpamCutoff(LPSTR pszFullPath, DOUBLE * pdblDefCutoff)
{
    HRESULT         hr = S_OK;
    CParseStream    parsestm;
    LPSTR           pszBuff = NULL;
    ULONG           cchBuff = 0;
    LPSTR           pszDefThresh = NULL;
    ULONG           ulIndex = 0;
    LPSTR           pszDummy = NULL;
    
    if ((NULL == pszFullPath) || ('\0' == *pszFullPath) || (NULL == pdblDefCutoff))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Get the parse stream
    hr = parsestm.HrSetFile(0, pszFullPath);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // skip first three lines
    for (ulIndex = 0; ulIndex < 4; ulIndex++)
    {
        SafeMemFree(pszBuff);
        hr = parsestm.HrGetLine(0, &pszBuff, &cchBuff);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // Find the default threshold
    pszDefThresh = StrStr(pszBuff, ::szDefaultThresh);
    if (NULL == pszDefThresh)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Grab the value
    pszDefThresh += lstrlen(::szDefaultThresh);
    *pdblDefCutoff = StrToDbl(pszDefThresh, &pszDummy);

    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszBuff);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Constructor/destructor
//
/////////////////////////////////////////////////////////////////////////////
CJunkFilter::CJunkFilter() : m_cRef(0), m_pszFirstName(NULL), m_cchFirstName(0), m_pszLastName(NULL),
                m_cchLastName(0), m_pszCompanyName(NULL), m_cchCompanyName(0), m_pblistBodyList(NULL),
                m_cblistBodyList(0), m_rgfeaturecomps(NULL), m_rgdblSVMWeights(NULL), m_dblCC(0), m_dblDD(0),
                m_dblThresh(-1), m_dblDefaultThresh(-1), m_dblMostThresh(0), m_dblLeastThresh(0), m_cFeatures(0),
                m_cFeatureComps(0), m_rgulFeatureStatus(0),
                m_pszLOCPath(NULL), m_dblSpamCutoff(0), m_pszFrom(NULL), m_pszTo(NULL), m_pszSubject(NULL),
                m_pIStmBody(NULL), m_cbBody(0), m_fDirectMessage(FALSE), m_fHasAttach(FALSE),
                m_fRule14(FALSE), m_fRule17(FALSE)
{
    ZeroMemory(m_rgiBodyList, sizeof(m_rgiBodyList));
    
    ZeroMemory(&m_ftMessageSent, sizeof(m_ftMessageSent));
    InitializeCriticalSection(&m_cs);
#ifdef DEBUG
    m_fJunkMailLogInit = FALSE;
    m_pILogFile = NULL;
#endif  // DEBUG
}

CJunkFilter::~CJunkFilter()
{
    ULONG       ulIndex = 0;
    
    SafeMemFree(m_pszFirstName);
    SafeMemFree(m_pszLastName);
    SafeMemFree(m_pszCompanyName);
#ifdef DEBUG
    SafeRelease(m_pILogFile);
#endif  // DEBUG

    for (ulIndex = 0; ulIndex < m_cFeatureComps; ulIndex++)
    {
        if ((locNil != m_rgfeaturecomps[ulIndex].loc) && (locSpecial != m_rgfeaturecomps[ulIndex].loc))
        {
            SafeMemFree(m_rgfeaturecomps[ulIndex].pszFeature);
        }
    }

    SafeMemFree(m_pblistBodyList);
    m_cblistBodyList = 0;
    ZeroMemory(m_rgiBodyList, sizeof(m_rgiBodyList));
    
    SafeMemFree(m_rgdblSVMWeights);
    SafeMemFree(m_rgulFeatureStatus);
    SafeMemFree(m_rgfeaturecomps);
    
    DeleteCriticalSection(&m_cs);
}

STDMETHODIMP_(ULONG) CJunkFilter::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CJunkFilter::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP CJunkFilter::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOEJunkFilter))
    {
        *ppvObject = static_cast<IOEJunkFilter *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CJunkFilter::SetIdentity(LPCSTR pszFirstName, LPCSTR pszLastName, LPCSTR pszCompanyName)
{
    HRESULT     hr = S_OK;

    //Set the new first name
    SafeMemFree(m_pszFirstName);
    m_cchFirstName = 0;
    if (NULL != pszFirstName)
    {
        m_pszFirstName = PszDupA(pszFirstName);
        if (NULL == m_pszFirstName)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        m_cchFirstName = CharUpperBuff(m_pszFirstName, lstrlen(m_pszFirstName));
    }
    
    // Set the new last name
    SafeMemFree(m_pszLastName);
    m_cchLastName = 0;
    if (NULL != pszLastName)
    {
        m_pszLastName = PszDupA(pszLastName);
        if (NULL == m_pszLastName)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        m_cchLastName = CharUpperBuff(m_pszLastName, lstrlen(m_pszLastName));
    }
    
    // Set the new company name
    SafeMemFree(m_pszCompanyName);
    m_cchCompanyName = 0;
    if (NULL != pszCompanyName)
    {
        m_pszCompanyName = PszDupA(pszCompanyName);
        if (NULL == m_pszCompanyName)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        m_cchCompanyName = CharUpperBuff(m_pszCompanyName, lstrlen(m_pszCompanyName));
    }

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CJunkFilter::LoadDataFile(LPCSTR pszFilePath)
{
    HRESULT     hr = S_OK;

    if ((NULL == pszFilePath) || ('\0' == *pszFilePath))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    hr = _HrReadSVMOutput(pszFilePath);
    if (FAILED(hr))
    {
        AssertSz(FALSE, "Unable to successfully read filter params");
        goto exit;
    }
        
    // Set the proper return value
    hr = S_OK;
    
exit:    
    return hr;
}

STDMETHODIMP CJunkFilter::SetSpamThresh(ULONG ulThresh)
{
    HRESULT hr = S_OK;

    switch (ulThresh)
    {
        case STF_USE_MOST:
            m_dblSpamCutoff = m_dblMostThresh;
            break;
            
        case STF_USE_MORE:
            m_dblSpamCutoff = m_dblDefaultThresh + ((m_dblMostThresh - m_dblDefaultThresh) / 2);
            break;
            
        case STF_USE_DEFAULT:
            m_dblSpamCutoff = m_dblDefaultThresh;
            break;
                
        case STF_USE_LESS:
            m_dblSpamCutoff = m_dblDefaultThresh - ((m_dblDefaultThresh - m_dblLeastThresh) / 2);
            break;
            
        case STF_USE_LEAST:
            m_dblSpamCutoff = m_dblLeastThresh;
            break;
            
        default:
            hr = E_INVALIDARG;
            goto exit;
    }
    
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CJunkFilter::GetSpamThresh(ULONG * pulThresh)
{
    HRESULT hr = S_OK;
    ULONG   ulThresh = 0;

    // Check the incoming params
    if (NULL == pulThresh)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    if (m_dblDefaultThresh == m_dblSpamCutoff)
    {
        ulThresh = STF_USE_DEFAULT;
    }
    else if (m_dblMostThresh == m_dblSpamCutoff)
    {
        ulThresh = STF_USE_MOST;
    }
    else if (m_dblLeastThresh == m_dblSpamCutoff)
    {
        ulThresh = STF_USE_LEAST;
    }
    else if (m_dblSpamCutoff > m_dblDefaultThresh)
    {
        ulThresh = STF_USE_MORE;
    }
    else
    {
        ulThresh = STF_USE_LESS;
    }
        
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CJunkFilter::GetDefaultSpamThresh(DOUBLE * pdblThresh)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == pdblThresh)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *pdblThresh = m_dblDefaultThresh * 100.0;
        
    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CJunkFilter::CalcJunkProb(DWORD dwFlags, IMimePropertySet * pIMPropSet, IMimeMessage * pIMMsg, double * pdblProb)
{
    HRESULT             hr = S_OK;
    BOOL                fSpam = FALSE;
    PROPVARIANT         propvar = {0};
    DWORD               dwFlagsMsg = 0;
    FILETIME            ftMsgSent = {0};
    LPSTR               pszFrom = NULL;
    LPSTR               pszTo = NULL;
    LPSTR               pszSubject = NULL;
    IStream *           pIStmBody = NULL;
    IStream *           pIStmHtml = NULL;
    BOOL                fSentToMe = FALSE;
    BOOL                fHasAttachments = FALSE;

    if ((NULL == pIMPropSet) || (NULL == pIMMsg))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Get Message Flags
    if (SUCCEEDED(pIMMsg->GetFlags(&dwFlagsMsg)))
    {
        fHasAttachments = (0 != (dwFlagsMsg & IMF_ATTACHMENTS));
    }

    // Was the message sent to me
    fSentToMe = (0 != (dwFlags & CJPF_SENT_TO_ME));
    
    // Get the from field
    propvar.vt = VT_LPSTR;
    hr = pIMPropSet->GetProp(PIDTOSTR(PID_HDR_FROM), NOFLAGS, &propvar);
    if (SUCCEEDED(hr))
    {
        pszFrom = propvar.pszVal;
    }
    
    // Get the To field
    propvar.vt = VT_LPSTR;
    hr = pIMPropSet->GetProp(PIDTOSTR(PID_HDR_TO), NOFLAGS, &propvar);
    if (SUCCEEDED(hr))
    {
        pszTo = propvar.pszVal;
    }
    
    // Try to Get the Plain Text Stream
    if (FAILED(pIMMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &pIStmBody, NULL)))
    {
        // Try to get the text version from the HTML stream
        if ((FAILED(pIMMsg->GetTextBody(TXT_HTML, IET_DECODED, &pIStmHtml, NULL))) ||
                (FAILED(HrConvertHTMLToPlainText(pIStmHtml, &pIStmBody))))
        {
            pIStmBody = NULL;
        }
    }

    // Get the Subject field
    propvar.vt = VT_LPSTR;
    hr = pIMPropSet->GetProp(PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &propvar);
    if (SUCCEEDED(hr))
    {
        pszSubject = propvar.pszVal;
    }
    
    // Is this a direct message

    // When was the message sent?
    propvar.vt = VT_FILETIME;
    hr = pIMPropSet->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &propvar);
    if (SUCCEEDED(hr))
    {
        ftMsgSent = propvar.filetime;
    }
    
    FillMemory(m_rgulFeatureStatus, sizeof(*m_rgulFeatureStatus) * m_cFeatures, -1);
    
    if (FALSE == FCalculateSpamProb(pszFrom, pszTo, pszSubject, pIStmBody,
                            fSentToMe, fHasAttachments, &ftMsgSent,
                            pdblProb, &fSpam))
    {
        hr = E_FAIL;
        goto exit;
    }

    hr = (FALSE != fSpam) ? S_OK : S_FALSE;
    
exit:
    SafeRelease(pIStmHtml);
    SafeRelease(pIStmBody);
    SafeMemFree(pszSubject);
    SafeMemFree(pszTo);
    SafeMemFree(pszFrom);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrCreateJunkFilter
//
//  This creates a junk filter.
//
//  ppIRule - pointer to return the junk filter
//
//  Returns:    S_OK, on success
//              E_OUTOFMEMORY, if can't create the Junk Filter object
//
///////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI HrCreateJunkFilter(DWORD dwFlags, IOEJunkFilter ** ppIJunkFilter)
{
    CJunkFilter *   pJunk = NULL;
    HRESULT         hr = S_OK;

    // Check the incoming params
    if (NULL == ppIJunkFilter)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing params
    *ppIJunkFilter = NULL;

    // Create the rules manager object
    pJunk = new CJunkFilter;
    if (NULL == pJunk)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the rules manager interface
    hr = pJunk->QueryInterface(IID_IOEJunkFilter, (void **) ppIJunkFilter);
    if (FAILED(hr))
    {
        goto exit;
    }

    pJunk = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    if (NULL != pJunk)
    {
        delete pJunk;
    }
    
    return hr;
}

BOOL FReadDouble(LPSTR pszLine, LPSTR pszToken, DOUBLE * pdblVal)
{
    BOOL    fRet = FALSE;
    LPSTR   pszVal = NULL;
    BOOL    fNegative = FALSE;
    
    // Search for token
    pszVal = StrStr(pszLine, pszToken);

    // If token isn't found then bail
    if (NULL == pszVal)
    {
        fRet = FALSE;
        goto exit;
    }

    // Skip over the token
    pszVal += lstrlen(pszToken);
    
    // Check to see if the value is negative
    if ('-' == *pszVal)
    {
        fNegative = TRUE;
        pszVal++;
    }

    // Read in value
    *pdblVal = StrToDbl(pszVal, &pszVal);

    // Negate the value if neccessary
    if (FALSE != fNegative)
    {
        *pdblVal *= -1;
    }

    fRet = TRUE;
    
exit:
    return fRet;
}

#ifdef DEBUG
static const LPSTR LOG_SPECIAL_BODY_FIRSTNAME       = "Special: Body contains the First Name";
static const LPSTR LOG_SPECIAL_BODY_LASTNAME        = "Special: Body contains the Last Name";
static const LPSTR LOG_SPECIAL_BODY_COMPANYNAME     = "Special: Body contains the Company Name";
static const LPSTR LOG_SPECIAL_BODY_YEARRECVD       = "Special: Body contains the year message received";
static const LPSTR LOG_SPECIAL_SENTTIME_WEEHRS      = "Special: Sent time was between 7PM and 6AM";
static const LPSTR LOG_SPECIAL_SENTTIME_WKEND       = "Special: Sent time was on the weekend (Sat or Sun)";
static const LPSTR LOG_SPECIAL_BODY_25PCTUPCWDS     = "Special: Body contains 25% uppercase words out of the first 50 words";
static const LPSTR LOG_SPECIAL_BODY_8PCTNONALPHA    = "Special: Body contains 8% non-alpha characters out of the first 200 characters";
static const LPSTR LOG_SPECIAL_SENT_DIRECT          = "Special: Sent directly to user";
static const LPSTR LOG_SPECIAL_SUBJECT_25PCTUPCWDS  = "Special: Subject contains 25% uppercase words out of the first 50 words";
static const LPSTR LOG_SPECIAL_SUBJECT_8PCTNONALPHA = "Special: Subject contains 8% non-alpha characters out of the first 200 characters";
static const LPSTR LOG_SPECIAL_TO_EMPTY             = "Special: To line is empty";
static const LPSTR LOG_SPECIAL_HASATTACH            = "Special: Message has an attachment";
static const LPSTR LOG_SPECIAL_BODY_GT125B          = "Special: Body is greater than 125 Bytes";
static const LPSTR LOG_SPECIAL_BODY_GT250B          = "Special: Body is greater than 250 Bytes";
static const LPSTR LOG_SPECIAL_BODY_GT500B          = "Special: Body is greater than 500 Bytes";
static const LPSTR LOG_SPECIAL_BODY_GT1000B         = "Special: Body is greater than 1000 Bytes";
static const LPSTR LOG_SPECIAL_BODY_GT2000B         = "Special: Body is greater than 2000 Bytes";
static const LPSTR LOG_SPECIAL_BODY_GT4000B         = "Special: Body is greater than 4000 Bytes";
static const LPSTR LOG_SPECIAL_BODY_GT8000B         = "Special: Body is greater than 8000 Bytes";
static const LPSTR LOG_SPECIAL_BODY_GT16000B        = "Special: Body is greater than 16000 Bytes";

VOID CJunkFilter::_PrintSpecialFeatureToLog(UINT iRuleNum)
{
    Assert(NULL != m_pILogFile);
    
    switch (iRuleNum)
    {
        case 1:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_FIRSTNAME);
            break;
            
        case 2: 
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_LASTNAME);
            break;
            
        case 3:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_COMPANYNAME);
            break;
            
        case 4: 
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_YEARRECVD);
            break;
            
        case 5:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_SENTTIME_WEEHRS);
            break;
            
        case 6:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_SENTTIME_WKEND);
            break;
            
        case 14:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_25PCTUPCWDS);
            break;
            
        case 15:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_8PCTNONALPHA);
            break;
            
        case 16:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_SENT_DIRECT);
            break;
            
        case 17:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_SUBJECT_25PCTUPCWDS);
            break;
            
        case 18:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_SUBJECT_8PCTNONALPHA);
            break;
            
        case 19:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_TO_EMPTY);
            break;
            
        case 20:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_HASATTACH);
            break;

        case 40:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_GT125B);
            break;
            
        case 41:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_GT250B);
            break;
            
        case 42:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_GT500B);
            break;
            
        case 43:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_GT1000B);
            break;
            
        case 44:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_GT2000B);
            break;
            
        case 45:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_GT4000B);
            break;
            
        case 46:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_GT8000B);
            break;
            
        case 47:
            m_pILogFile->WriteLog(LOGFILE_DB, LOG_SPECIAL_BODY_GT16000B);
            break;
            
        default:
            AssertSz(FALSE, "unsupported special feature");
            break;
    }

    return;
}

VOID CJunkFilter::_PrintFeatureToLog(ULONG ulIndex)
{
    LPSTR   pszBuff = NULL;
    LPSTR   pszTag = NULL;

    // Figure out which tag line to use
    switch (m_rgfeaturecomps[ulIndex].loc)
    {
        case locNil:
            goto exit;
            break;
            
        case locBody:
            pszTag = LOG_BODY;
            break;
            
        case locSubj:
            pszTag = LOG_SUBJECT;
            break;
            
        case locFrom:
            pszTag = LOG_FROM;
            break;
            
        case locTo:
            pszTag = LOG_TO;
            break;

        case locSpecial:
            _PrintSpecialFeatureToLog(m_rgfeaturecomps[ulIndex].ulRuleNum);
            goto exit;
            break;
    }

    // Write out the feature to the log
    PrintToLogFile(m_pILogFile, pszTag, m_rgfeaturecomps[ulIndex].pszFeature);
    
exit:
    SafeMemFree(pszBuff);
    return;
}

HRESULT CJunkFilter::_HrCreateLogFile(VOID)
{
    HRESULT     hr = S_OK;
    LPSTR       pszLogFile = NULL;
    ULONG       cbData = 0;
    ILogFile *  pILogFile = NULL;
    DWORD       dwData = 0;

    if (FALSE != m_fJunkMailLogInit)
    {
        hr = S_FALSE;
        goto exit;
    }

    m_fJunkMailLogInit = TRUE;
    
    // Get the size of the path to Outlook Express
    cbData = sizeof(dwData);
    if ((ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_FLAT, "JunkMailLog", NULL, (BYTE *) &dwData, &cbData)) ||
            (0 == dwData))
    {
        hr = S_FALSE;
        goto exit;
    }

    // Get the size of the path to Outlook Express
    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_FLAT, "InstallRoot", NULL, NULL, &cbData))
    {
        hr = E_FAIL;
        goto exit;
    }

    // How much room do we need to build up the path
    cbData += lstrlen(szJunkMailLog) + 2;

    // Allocate space to hold the path
    hr = HrAlloc((VOID **) &pszLogFile, cbData);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the path to Outlook Express
    ULONG cbBuffer = cbData;
    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, STR_REG_PATH_FLAT, "InstallRoot", NULL, (BYTE *) pszLogFile, &cbBuffer))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Build up the path to the Junk DLL
    if ('\\' != pszLogFile[lstrlen(pszLogFile)])
    {
        StrCatBuff(pszLogFile, "\\", cbData);
    }
    StrCatBuff(pszLogFile, szJunkMailLog, cbData);
    
    hr = CreateLogFile(g_hInst, pszLogFile, szJunkMailPrefix, DONT_TRUNCATE, &pILogFile, FILE_SHARE_READ | FILE_SHARE_WRITE);
    if (FAILED(hr))
    {
        goto exit;
    }

    SafeRelease(m_pILogFile);
    m_pILogFile = pILogFile;
    
    hr = S_OK;
    
exit:
    SafeMemFree(pszLogFile);
    return hr;
}

VOID PrintToLogFile(ILogFile * pILogFile, LPSTR pszTmpl, LPSTR pszArg)
{
    LPSTR   pszBuff = NULL;
    ULONG   cchBuff = 0;
    
    Assert(NULL != pILogFile);
    Assert(NULL != pszTmpl);

    if (NULL =