oneWiz_FwdZoneNamePropertyPage::IDD;
		else
			nextPage = (LRESULT)CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
	}
	else
	{
		nextPage = (LRESULT)CDNSZoneWiz_MastersPropertyPage::IDD;
	}
	return nextPage;
}


BOOL CDNSZoneWiz_StoragePropertyPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

  SendDlgItemMessage(IDC_EDIT_NEW_FILE, EM_SETLIMITTEXT, (WPARAM)_MAX_FNAME, 0);
  SendDlgItemMessage(IDC_EDIT_IMPORT_FILE, EM_SETLIMITTEXT, (WPARAM)_MAX_FNAME, 0);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDNSZoneWiz_StoragePropertyPage::OnKillActive() 
{
	// TODO
	return CPropertyPage::OnKillActive();
}

void CDNSZoneWiz_StoragePropertyPage::SetUIState()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	ASSERT(pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS);

	CButton* pNewFileButton = (CButton*)GetDlgItem(IDC_RADIO_CREATE_NEW_FILE);
	CButton* pImportFileButton = (CButton*)GetDlgItem(IDC_RADIO_IMPORT_FILE);

	CEdit* pNewFileEdit = (CEdit*)GetDlgItem(IDC_EDIT_NEW_FILE);
	CEdit* pImportFileEdit = (CEdit*)GetDlgItem(IDC_EDIT_IMPORT_FILE);

	pNewFileEdit->SetWindowText(_T(""));
	pImportFileEdit->SetWindowText(_T(""));

	if (pHolder->m_pZoneInfo->m_bPrimary)
	{
		// all options are avalable, need to 
		pNewFileButton->EnableWindow(TRUE);
		pNewFileButton->SetCheck(pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::newFile);
		pNewFileEdit->EnableWindow(pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::newFile);

		pImportFileButton->EnableWindow(TRUE);
		pImportFileButton->SetCheck(pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::importFile);
		pImportFileEdit->EnableWindow(pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::importFile);

		if (pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::newFile)
		{
			m_nCurrRadio = IDC_RADIO_CREATE_NEW_FILE;
			pNewFileEdit->SetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
		}
		else if (pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::importFile)
		{
			m_nCurrRadio = IDC_RADIO_IMPORT_FILE;
			pImportFileEdit->SetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
		}
	}
	else
	{
		// only new file available
		pNewFileButton->EnableWindow(TRUE);
		pNewFileButton->SetCheck(TRUE);
		pNewFileEdit->SetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
		pNewFileEdit->EnableWindow(TRUE);

		pImportFileButton->EnableWindow(FALSE);
		pImportFileButton->SetCheck(FALSE);
		pImportFileEdit->EnableWindow(FALSE);

		m_nCurrRadio = IDC_RADIO_CREATE_NEW_FILE;
	}
}


BOOL CDNSZoneWiz_StoragePropertyPage::ValidateEditBoxString(UINT nID)
{
	CEdit* pEdit = (CEdit*)GetDlgItem(nID);
	ASSERT(pEdit != NULL);
	CString sz;
	pEdit->GetWindowText(sz);
	sz.TrimLeft();
	sz.TrimRight();
	return !sz.IsEmpty();
}


void CDNSZoneWiz_StoragePropertyPage::OnChangeNewFileZoneName()
{
	GetHolder()->SetWizardButtonsMiddle(ValidateEditBoxString(IDC_EDIT_NEW_FILE));	
}

void CDNSZoneWiz_StoragePropertyPage::OnChangeImportFileZoneName()
{
	GetHolder()->SetWizardButtonsMiddle(ValidateEditBoxString(IDC_EDIT_IMPORT_FILE));	
}


void CDNSZoneWiz_StoragePropertyPage::SyncRadioButtons(UINT nID)
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	ASSERT(pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS);
	
	CButton* pNewFileButton = (CButton*)GetDlgItem(IDC_RADIO_CREATE_NEW_FILE);
	CButton* pImportFileButton = (CButton*)GetDlgItem(IDC_RADIO_IMPORT_FILE);
	
	CEdit* pNewFileEdit = (CEdit*)GetDlgItem(IDC_EDIT_NEW_FILE);
	CEdit* pImportFileEdit = (CEdit*)GetDlgItem(IDC_EDIT_IMPORT_FILE);

	if (m_nCurrRadio == IDC_RADIO_CREATE_NEW_FILE)
	{
		pNewFileEdit->GetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
	}
	else if(m_nCurrRadio == IDC_RADIO_IMPORT_FILE)
	{	
		pImportFileEdit->GetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
	}

	switch (nID)
	{
	case IDC_RADIO_CREATE_NEW_FILE:
		{
			pImportFileEdit->SetWindowText(_T(""));
			pNewFileEdit->SetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);

			pNewFileEdit->EnableWindow(TRUE);
			pImportFileEdit->EnableWindow(FALSE);

			pImportFileButton->SetCheck(FALSE);
		}
		break;
	case IDC_RADIO_IMPORT_FILE:
		{
			pNewFileEdit->SetWindowText(_T(""));
			pImportFileEdit->SetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);

			pNewFileEdit->EnableWindow(FALSE);
			pImportFileEdit->EnableWindow(TRUE);

			pNewFileButton->SetCheck(FALSE);
		}
		break;
	}
	m_nCurrRadio = nID;
}


void CDNSZoneWiz_StoragePropertyPage::OnChangeRadioCreateNewFile()
{
	SyncRadioButtons(IDC_RADIO_CREATE_NEW_FILE);	
}

void CDNSZoneWiz_StoragePropertyPage::OnChangeRadioImportFile()
{
	SyncRadioButtons(IDC_RADIO_IMPORT_FILE);
}

void CDNSZoneWiz_StoragePropertyPage::GetUIState()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	ASSERT(pHolder->m_pZoneInfo->m_storageType != CDNSCreateZoneInfo::useADS);

	CButton* pNewFileButton = (CButton*)GetDlgItem(IDC_RADIO_CREATE_NEW_FILE);
	CButton* pImportFileButton = (CButton*)GetDlgItem(IDC_RADIO_IMPORT_FILE);

	CEdit* pNewFileEdit = (CEdit*)GetDlgItem(IDC_EDIT_NEW_FILE);
	CEdit* pImportFileEdit = (CEdit*)GetDlgItem(IDC_EDIT_IMPORT_FILE);

	if (pHolder->m_pZoneInfo->m_bPrimary)
	{
		// find the radio selection
		if (pNewFileButton->GetCheck())
		{
			pHolder->m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::newFile;
			pNewFileEdit->GetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
		}
		else if (pImportFileButton->GetCheck())
		{
			pHolder->m_pZoneInfo->m_storageType = CDNSCreateZoneInfo::importFile;
			pImportFileEdit->GetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
		}
	}
	else
	{
		pNewFileEdit->GetWindowText(pHolder->m_pZoneInfo->m_szZoneStorage);
	}

}

#ifdef USE_NDNC
//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ADReplicationPropertyPage


CDNSZoneWiz_ADReplicationPropertyPage::CDNSZoneWiz_ADReplicationPropertyPage() 
				: CPropertyPageBase(CDNSZoneWiz_ADReplicationPropertyPage::IDD)
{
	InitWiz97(FALSE,IDS_ZWIZ_ADREPLICATION_TITLE,IDS_ZWIZ_ADREPLICATION_SUBTITLE);
}

BEGIN_MESSAGE_MAP(CDNSZoneWiz_ADReplicationPropertyPage, CPropertyPageBase)
  ON_BN_CLICKED(IDC_FOREST_RADIO, OnRadioChange)
  ON_BN_CLICKED(IDC_DOMAIN_RADIO, OnRadioChange)
  ON_BN_CLICKED(IDC_DOMAIN_DC_RADIO, OnRadioChange)
  ON_BN_CLICKED(IDC_CUSTOM_RADIO, OnRadioChange)
  ON_CBN_EDITCHANGE(IDC_CUSTOM_COMBO, OnRadioChange)
  ON_CBN_SELCHANGE(IDC_CUSTOM_COMBO, OnCustomComboSelChange)
END_MESSAGE_MAP()

BOOL CDNSZoneWiz_ADReplicationPropertyPage::OnSetActive() 
{
	GetHolder()->SetWizardButtonsMiddle(TRUE);
	SetUIState();
	return CPropertyPageBase::OnSetActive();
}

LRESULT CDNSZoneWiz_ADReplicationPropertyPage::OnWizardNext()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	GetUIState();

	if (pHolder->m_bKnowZoneLookupType && !pHolder->m_bKnowZoneLookupTypeEx)
	{
		if (pHolder->m_pZoneInfo->m_bForward)
			return CDNSZoneWiz_FwdZoneNamePropertyPage::IDD;
		else
			return CDNSZoneWiz_RevZoneNamePropertyPage::IDD;
	}
  return CDNSZoneWiz_ZoneLookupPropertyPage::IDD;
}


LRESULT CDNSZoneWiz_ADReplicationPropertyPage::OnWizardBack() 
{
	GetUIState();
  return CDNSZoneWiz_ZoneTypePropertyPage::IDD;
}


BOOL CDNSZoneWiz_ADReplicationPropertyPage::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	USES_CONVERSION;

  CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
  CDNSServerNode* pServerNode = pHolder->GetServerNode();

  //
  // Get the forest and domain names and format them into the UI
  //

  PCWSTR pszDomainName = UTF8_TO_W(pServerNode->GetDomainName());
  PCWSTR pszForestName = UTF8_TO_W(pServerNode->GetForestName());

  ASSERT(pszDomainName);
  ASSERT(pszForestName);

  CString szWin2KReplText;
  szWin2KReplText.Format(IDS_ZWIZ_AD_REPL_FORMAT, pszDomainName);
  SetDlgItemText(IDC_DOMAIN_DC_RADIO, szWin2KReplText);

  CString szDNSDomainText;
  szDNSDomainText.Format(IDS_ZWIZ_AD_DOMAIN_FORMAT, pszDomainName);
  SetDlgItemText(IDC_DOMAIN_RADIO, szDNSDomainText);

  CString szDNSForestText;
  szDNSForestText.Format(IDS_ZWIZ_AD_FOREST_FORMAT, pszForestName);
  SetDlgItemText(IDC_FOREST_RADIO, szDNSForestText);

  //
  // Enumerate the NDNCs available for storage
  //
  PDNS_RPC_DP_LIST pDirectoryPartitions = NULL;
  DWORD dwErr = ::DnssrvEnumDirectoryPartitions(pServerNode->GetRPCName(),
                                                DNS_DP_ENLISTED,
                                                &pDirectoryPartitions);

  //
  // Don't show an error if we are not able to get the available directory partitions
  // We can still continue on and the user can type in the directory partition they need
  //
  if (dwErr == 0 && pDirectoryPartitions)
  {
    for (DWORD dwIdx = 0; dwIdx < pDirectoryPartitions->dwDpCount; dwIdx++)
    {
      PDNS_RPC_DP_INFO pDirectoryPartition = 0;
      dwErr = ::DnssrvDirectoryPartitionInfo(pServerNode->GetRPCName(),
                                             pDirectoryPartitions->DpArray[dwIdx]->pszDpFqdn,
                                             &pDirectoryPartition);
      if (dwErr == 0 && pDirectoryPartition)
      {
        //
        // Only add the partition if it is not one of the autocreated ones
        // and the DNS server is enlisted in the partition
        //
        if (!(pDirectoryPartition->dwFlags & DNS_DP_AUTOCREATED) &&
            (pDirectoryPartition->dwFlags & DNS_DP_ENLISTED))
        {
          SendDlgItemMessage(IDC_CUSTOM_COMBO, 
                             CB_ADDSTRING, 
                             0, 
                             (LPARAM)UTF8_TO_W(pDirectoryPartition->pszDpFqdn));
        }
        ::DnssrvFreeDirectoryPartitionInfo(pDirectoryPartition);
      }
    }
    ::DnssrvFreeDirectoryPartitionList(pDirectoryPartitions);
  }
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDNSZoneWiz_ADReplicationPropertyPage::OnKillActive() 
{
	// TODO
	return CPropertyPage::OnKillActive();
}

void CDNSZoneWiz_ADReplicationPropertyPage::SetUIState()
{
  SyncRadioButtons();
}

void CDNSZoneWiz_ADReplicationPropertyPage::OnRadioChange()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  if (SendDlgItemMessage(IDC_FOREST_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = forest;
  }
  else if (SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = domain;
  }
  else if (SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = w2k;
  }
  else if (SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = custom;
  }
  else
  {
    // at least one radio button must be selected
    ASSERT(FALSE);
  }
  SyncRadioButtons();
}

void CDNSZoneWiz_ADReplicationPropertyPage::SyncRadioButtons()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  switch (pHolder->m_pZoneInfo->m_replType)
  {
  case forest:
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);

    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(FALSE);
    GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(FALSE);
    break;

  case domain:
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);

    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(FALSE);
    GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(FALSE);
    break;

  case w2k:
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);

    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(FALSE);
    GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(FALSE);
    break;

  case custom:
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
 
    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(TRUE);
    GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(TRUE);
   break;

  default:
    SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
    SendDlgItemMessage(IDC_FOREST_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);
    SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_SETCHECK, (WPARAM)BST_UNCHECKED, 0);

    GetDlgItem(IDC_CUSTOM_COMBO)->EnableWindow(FALSE);
    GetDlgItem(IDC_CUSTOM_STATIC)->EnableWindow(FALSE);
    break;
  }
   
  if (BST_CHECKED == SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_GETCHECK, 0, 0))
  {
    CString szTemp;
    GetDlgItemText(IDC_CUSTOM_COMBO, szTemp);
    pHolder->SetWizardButtonsMiddle(!szTemp.IsEmpty());
  }
  else
  {
    pHolder->SetWizardButtonsMiddle(TRUE);
  }
}

void CDNSZoneWiz_ADReplicationPropertyPage::OnCustomComboSelChange()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  LRESULT iSel = SendDlgItemMessage(IDC_CUSTOM_COMBO, CB_GETCURSEL, 0, 0);
  if (CB_ERR != iSel)
  {
    CString szTemp;
    CComboBox* pComboBox = reinterpret_cast<CComboBox*>(GetDlgItem(IDC_CUSTOM_COMBO));
    ASSERT(pComboBox);

    pComboBox->GetLBText(static_cast<int>(iSel), szTemp);
    pHolder->SetWizardButtonsMiddle(!szTemp.IsEmpty());
  }
  else
  {
    pHolder->SetWizardButtonsMiddle(FALSE);
  }
}

void CDNSZoneWiz_ADReplicationPropertyPage::GetUIState()
{
  CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

  if (SendDlgItemMessage(IDC_FOREST_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = forest;
  }
  else if (SendDlgItemMessage(IDC_DOMAIN_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = domain;
  }
  else if (SendDlgItemMessage(IDC_DOMAIN_DC_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = w2k;
  }
  else if (SendDlgItemMessage(IDC_CUSTOM_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
  {
    pHolder->m_pZoneInfo->m_replType = custom;
  }
  else
  {
    // at least one radio button must be checked
    ASSERT(FALSE);
  }
  SyncRadioButtons();

  CComboBox* pCustomCombo = reinterpret_cast<CComboBox*>(GetDlgItem(IDC_CUSTOM_COMBO));
  ASSERT(pCustomCombo);

  int iSel = pCustomCombo->GetCurSel();
  if (iSel != CB_ERR)
  {
    pCustomCombo->GetLBText(iSel, pHolder->m_pZoneInfo->m_szCustomReplName);
  }
  else
  {
    pCustomCombo->GetWindowText(pHolder->m_pZoneInfo->m_szCustomReplName);
  }
}
#endif // USE_NDNC

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_FinishPropertyPage

CDNSZoneWiz_FinishPropertyPage::CDNSZoneWiz_FinishPropertyPage() 
				: CPropertyPageBase(CDNSZoneWiz_FinishPropertyPage::IDD),
				m_typeText(N_ZONEWIZ_TYPES)
{
	InitWiz97(TRUE,0,0);
}


BOOL CDNSZoneWiz_FinishPropertyPage::OnInitDialog()
{
  CPropertyPageBase::OnInitDialog();

  SetBigBoldFont(m_hWnd, IDC_STATIC_COMPLETE);

	VERIFY(m_typeText.Init(this,IDC_TYPE_STATIC));
	VERIFY(m_lookupText.Init(this,IDC_LOOKUP_STATIC));
	return TRUE;
}

LRESULT CDNSZoneWiz_FinishPropertyPage::OnWizardBack()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	if (pHolder->m_pZoneInfo->m_bPrimary)
	{
		return (LRESULT)CDNSZoneWiz_DynamicPropertyPage::IDD;
	}

  // This was an else but the sundown build did not like having a control path not return a value
	return (LRESULT)CDNSZoneWiz_MastersPropertyPage::IDD; // secondary
}

BOOL CDNSZoneWiz_FinishPropertyPage::OnWizardFinish()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();
	return pHolder->CreateZone();
}

BOOL CDNSZoneWiz_FinishPropertyPage::OnSetActive() 
{
	GetHolder()->SetWizardButtonsLast(TRUE);

	DisplaySummaryInfo();
	
	return CPropertyPageBase::OnSetActive();
}

void CDNSZoneWiz_FinishPropertyPage::DisplaySummaryInfo()
{
	CDNSZoneWizardHolder* pHolder = (CDNSZoneWizardHolder*)GetHolder();

	GetDlgItem(IDC_NAME_STATIC)->SetWindowText(pHolder->m_pZoneInfo->m_szZoneName);
	BOOL bUseADS = pHolder->m_pZoneInfo->m_storageType == CDNSCreateZoneInfo::useADS;
	
	int nType;
	if (pHolder->m_pZoneInfo->m_bPrimary)
  {
		nType = bUseADS ? N_ZONEWIZ_TYPES_DS_PRIMARY : N_ZONEWIZ_TYPES_PRIMARY;
  }
	else
  {
		if (pHolder->m_pZoneInfo->m_bIsStub)
    {
      nType = N_ZONEWIZ_TYPES_STUB;
    }
    else
    {
      nType = N_ZONEWIZ_TYPES_SECONDARY;
    }
  }
	m_typeText.SetStateX(nType);
	
	m_lookupText.SetToggleState(pHolder->m_pZoneInfo->m_bForward);
	
	GetDlgItem(IDC_STORAGE_TYPE_STATIC)->ShowWindow(!bUseADS);

	CStatic* pStorageNameStatic = (CStatic*)GetDlgItem(IDC_STORAGE_NAME_STATIC);
	pStorageNameStatic->ShowWindow(!bUseADS);
	LPCTSTR lpszText = bUseADS ? NULL : (LPCTSTR)(pHolder->m_pZoneInfo->m_szZoneStorage);
	pStorageNameStatic->SetWindowText(lpszText);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dnsmgr\zonewiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       zonewiz.h
//
//--------------------------------------------------------------------------



#ifndef _ZONEWIZ_H
#define _ZONEWIZ_H

#include "ipeditor.h"

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CDNSServerNode;
class CDNSZoneNode;

class CDNSZoneWiz_StartPropertyPage;
class CDNSZoneWiz_SelectServerPropertyPage;
class CDNSZoneWiz_ZoneTypePropertyPage;
class CDNSZoneWiz_ZoneLookupPropertyPage;
class CDNSZoneWiz_ZoneNamePropertyPageBase;
class CDNSZoneWiz_FwdZoneNamePropertyPage;
class CDNSZoneWiz_DynamicPropertyPage;
class CDNSZoneWiz_RevZoneNamePropertyPage;
class CDNSZoneWiz_MastersPropertyPage;
class CDNSZoneWiz_StoragePropertyPage;
#ifdef USE_NDNC
class CDNSZoneWiz_ADReplicationPropertyPage;
#endif // USE_NDNC
class CDNSZoneWiz_FinishPropertyPage;


///////////////////////////////////////////////////////////////////////////////
// CDNSCreateZoneInfo
// information gathered by the Zone Wizard

class CDNSCreateZoneInfo
{
public:
	CDNSCreateZoneInfo();
	~CDNSCreateZoneInfo();

	void ResetIpArr();
	void SetIpArr(PIP_ADDRESS ipMastersArray, DWORD nMastersCount);
	const CDNSCreateZoneInfo& operator=(const CDNSCreateZoneInfo& info);

	typedef enum { newFile = 0 , importFile, useADS} storageType;

	BOOL m_bPrimary;
	BOOL m_bForward;
  BOOL m_bIsStub;
	CString m_szZoneName;
	CString m_szZoneStorage;
	storageType m_storageType;
#ifdef USE_NDNC
  ReplicationType m_replType;
  CString m_szCustomReplName;
#endif // USE_NDNC

	PIP_ADDRESS m_ipMastersArray;
	DWORD m_nMastersCount;
  BOOL  m_bLocalListOfMasters;
  UINT m_nDynamicUpdate;

	// UI session specific info (not used for actual creation)
	BOOL m_bWasForward;
};


///////////////////////////////////////////////////////////////////////////////
// CDNSZoneWizardHolder
// page holder to contain DNS zone wizard property pages

class CDNSZoneWizardHolder : public CPropertyPageHolderBase
{
public:
	CDNSZoneWizardHolder(CComponentDataObject* pComponentData);

	// simple cast helpers
	CDNSServerNode* GetServerNode() { return (CDNSServerNode*)GetContainerNode();}
	void SetServerNode(CDNSServerNode* pServerNode) { SetContainerNode((CDNSServerNode*) pServerNode);}

	void SetZoneNode(CDNSZoneNode* pZoneNode) { SetTreeNode((CTreeNode*)pZoneNode); }
	CDNSZoneNode* GetZoneNode() { return (CDNSZoneNode*)GetTreeNode();}

	void Initialize(CDNSServerNode* pServerNode, // might be null,
									  BOOL bServerPage  = FALSE, BOOL bFinishPage = TRUE);

	void PreSetZoneLookupType(BOOL bForward);
  void PreSetZoneLookupTypeEx(BOOL bForward, UINT nZoneType, BOOL bADIntegrated);
	void SetContextPages(UINT nNextToPage, UINT nBackToPage);
	UINT GetFirstEntryPointPageID();
	UINT GetLastEntryPointPageID();

	CDNSCreateZoneInfo* GetZoneInfoPtr() { return m_pZoneInfo;}
	void SetZoneInfoPtr(CDNSCreateZoneInfo* pZoneInfo)
	{
		m_pZoneInfo = (pZoneInfo != NULL) ? pZoneInfo : NULL;
	}

	static DNS_STATUS CDNSZoneWizardHolder::CreateZoneHelper(CDNSServerNode* pServerNode, 
													CDNSCreateZoneInfo* pZoneInfo, 
													CComponentDataObject* pComponentData);

private:
	// data for zone creation
	CDNSCreateZoneInfo m_zoneInfo;
	CDNSCreateZoneInfo* m_pZoneInfo;

	BOOL CreateZone();

	// cached pointers to property pages
	CDNSZoneWiz_StartPropertyPage*				  m_pStartPage;
	CDNSZoneWiz_SelectServerPropertyPage*		m_pTargetServerPage;
	CDNSZoneWiz_ZoneTypePropertyPage*			  m_pReplicationTypePage;
	CDNSZoneWiz_ZoneLookupPropertyPage*			m_pZoneLookupPage;
	CDNSZoneWiz_FwdZoneNamePropertyPage*		m_pFwdZoneNamePage;
  CDNSZoneWiz_DynamicPropertyPage*        m_pDynamicPage;
	CDNSZoneWiz_RevZoneNamePropertyPage*		m_pRevZoneNamePage;
	CDNSZoneWiz_MastersPropertyPage*			  m_pMastersPage;
	CDNSZoneWiz_StoragePropertyPage*			  m_pStoragePage;	
#ifdef USE_NDNC
  CDNSZoneWiz_ADReplicationPropertyPage*  m_pADReplPage;
#endif // USE_NDNC
	CDNSZoneWiz_FinishPropertyPage*				  m_pFinishPage;

	BOOL m_bKnowZoneLookupType;			// already know Fwd/Rev type
  BOOL m_bKnowZoneLookupTypeEx;   // already know Fwd/Rev, AD-integrated, and zone type
	BOOL m_bServerPage;
	BOOL m_bFinishPage;
	UINT m_nNextToPage;
	UINT m_nBackToPage;

	// helper functions


	// to access data in the holder
	friend class CDNSZoneWiz_StartPropertyPage;
	friend class CDNSZoneWiz_SelectServerPropertyPage;
	friend class CDNSZoneWiz_ZoneTypePropertyPage;
	friend class CDNSZoneWiz_ZoneLookupPropertyPage;
	friend class CDNSZoneWiz_ZoneNamePropertyPageBase;
	friend class CDNSZoneWiz_FwdZoneNamePropertyPage;
  friend class CDNSZoneWiz_DynamicPropertyPage;
	friend class CDNSZoneWiz_RevZoneNamePropertyPage;
	friend class CDNSZoneWiz_MastersPropertyPage;
	friend class CDNSZoneWiz_StoragePropertyPage;
#ifdef USE_NDNC
  friend class CDNSZoneWiz_ADReplicationPropertyPage;
#endif USE_NDNC
	friend class CDNSZoneWiz_FinishPropertyPage;

};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_StartPropertyPage

class CDNSZoneWiz_StartPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_StartPropertyPage();

// Overrides
public:
	virtual BOOL OnSetActive();

protected:
	virtual BOOL OnInitDialog();

public:
// Dialog Data
	enum { IDD = IDD_ZWIZ_START };

};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_SelectServerPropertyPage

class CDNSZoneWiz_SelectServerPropertyPage : public CPropertyPageBase
{

// Construction
public:
	CDNSZoneWiz_SelectServerPropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_SELECT_SERVER };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnKillActive();
protected:

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();

	afx_msg void OnListboxSelChange(); // message handler

	DECLARE_MESSAGE_MAP()
private:
	CListBox* GetServerListBox()
	{ return (CListBox*)GetDlgItem(IDC_SERVERS_LIST);}
};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ZoneTypePropertyPage

class CDNSZoneWiz_ZoneTypePropertyPage : public CPropertyPageBase
{

// Construction
public:
	CDNSZoneWiz_ZoneTypePropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_ZONE_TYPE };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnKillActive();
protected:

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
  afx_msg void OnRadioChange();

	DECLARE_MESSAGE_MAP()

private:
	void SetUIState();
	void GetUIState();
};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ZoneLookupPropertyPage

class CDNSZoneWiz_ZoneLookupPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_ZoneLookupPropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_ZONE_LOOKUP };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditZoneName();

private:
};


//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ZoneNamePropertyPageBase

class CDNSZoneWiz_ZoneNamePropertyPageBase : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_ZoneNamePropertyPageBase(UINT nIDD);

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
protected:

// Implementation
protected:
	// Generated message map functions
	afx_msg void OnBrowse();
	afx_msg void OnChangeEditZoneName();

	DECLARE_MESSAGE_MAP()
protected:
	CButton* GetBrowseButton() { return (CButton*)GetDlgItem(IDC_BROWSE_BUTTON);}
	CEdit* GetZoneNameEdit() { return (CEdit*)GetDlgItem(IDC_EDIT_ZONE_NAME);}
	void SetUIState();
	void GetUIState();
};


//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_FwdZoneNamePropertyPage

class CDNSZoneWiz_FwdZoneNamePropertyPage : 
			public CDNSZoneWiz_ZoneNamePropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_FwdZoneNamePropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_FWD_ZONE_NAME };
};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_RevZoneNamePropertyPage

class CDNSZoneWiz_RevZoneNamePropertyPage : 
		public CDNSZoneWiz_ZoneNamePropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_RevZoneNamePropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_REV_ZONE_NAME };

// Overrides
public:
	virtual BOOL OnSetActive();

protected:

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeSubnetIPv4Ctrl();
//	afx_msg void OnChangeMaskIPv4Ctrl();
	afx_msg void OnChangeUseIPRadio();
	afx_msg	void OnChangeUseEditRadio();
  afx_msg void OnHelpButton();

	DECLARE_MESSAGE_MAP()
private:

	BOOL m_bUseIP;	// flags to tell wich entry method we use

	CButton* GetUseIPRadio() { return (CButton*)GetDlgItem(IDC_USE_IP_RADIO);}
	CButton* GetUseEditRadio() { return (CButton*)GetDlgItem(IDC_USE_EDIT_RADIO);}
	CDNSIPv4Control* GetSubnetIPv4Ctrl() 
			{ return (CDNSIPv4Control*)GetDlgItem(IDC_SUBNET_IPEDIT);}
/*	CDNSIPv4Control* GetMaskIPv4Ctrl() 
			{ return (CDNSIPv4Control*)GetDlgItem(IDC_MASK_IPEDIT);}
*/
	void SyncRadioButtons(BOOL bPrevUseIP);
	void ResetIPEditAndNameValue();
	BOOL BuildZoneName(DWORD* dwSubnetArr /*, DWORD* dwMaskArr*/);
};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_MastersPropertyPage

class CZoneWiz_MastersIPEditor : public CIPEditor
{
public:
	virtual void OnChangeData();
};

class CDNSZoneWiz_MastersPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_MastersPropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_MASTERS };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();

protected:

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowse();

	DECLARE_MESSAGE_MAP()
private:
	CZoneWiz_MastersIPEditor m_editor;

	void SetValidIPArray(BOOL b);

	BOOL m_bValidIPArray;

	void SetUIState();
	void GetUIState();

	friend class CZoneWiz_MastersIPEditor;
};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_DynamicPropertyPage

class CDNSZoneWiz_DynamicPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_DynamicPropertyPage();
	~CDNSZoneWiz_DynamicPropertyPage()
	{
	}

// Dialog Data
	enum { IDD = IDD_ZWIZ_DYNAMIC_UPDATE };

  // Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();

	DECLARE_MESSAGE_MAP()

private:	
  void SetUIState();
	void GetUIState();
};

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_StoragePropertyPage

class CDNSZoneWiz_StoragePropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_StoragePropertyPage();
	~CDNSZoneWiz_StoragePropertyPage()
	{
	}

// Dialog Data
	enum { IDD = IDD_ZWIZ_STORAGE };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnKillActive();

protected:

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewFileZoneName();
	afx_msg void OnChangeImportFileZoneName();
	afx_msg void OnChangeRadioCreateNewFile();
	afx_msg void OnChangeRadioImportFile();

	DECLARE_MESSAGE_MAP()
private:
	UINT m_nCurrRadio;
	BOOL ValidateEditBoxString(UINT nID);
	void SyncRadioButtons(UINT nID);
	void SetUIState();
	void GetUIState();

};

#ifdef USE_NDNC
//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_ADReplicationPropertyPage

class CDNSZoneWiz_ADReplicationPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_ADReplicationPropertyPage();
	~CDNSZoneWiz_ADReplicationPropertyPage()
	{
	}

// Dialog Data
	enum { IDD = IDD_ZWIZ_AD_REPLICATION };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnKillActive();

protected:

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();

  afx_msg void OnRadioChange();
  afx_msg void OnCustomComboSelChange();

	DECLARE_MESSAGE_MAP()
private:
  void SyncRadioButtons();
	void SetUIState();
	void GetUIState();
};
#endif // USE_NDNC

//////////////////////////////////////////////////////////////////////////
// CDNSZoneWiz_FinishPropertyPage

class CDNSZoneWiz_FinishPropertyPage : public CPropertyPageBase
{
// Construction
public:
	CDNSZoneWiz_FinishPropertyPage();

// Dialog Data
	enum { IDD = IDD_ZWIZ_FINISH };

// Overrides
public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnWizardFinish();

protected:
	virtual BOOL OnInitDialog();

private:
	CDNSManageControlTextHelper		m_typeText;	
	CDNSToggleTextControlHelper		m_lookupText;

	void DisplaySummaryInfo();
};

#endif // _ZONEWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_DSA_TRACE)
  #if defined(TRACE)
    #undef TRACE
    void  DSATrace(LPCWSTR, ...);
    #define TRACE DSATrace
  #endif // defined(TRACE)
#endif // defined(_USE_DSA_TRACE)


#if defined(_USE_DSA_ASSERT)
#undef ASSERT
#undef VERIFY
#undef THIS_FILE
#define THIS_FILE          __FILE__
BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine);
#define ASSERT(f) \
	do \
	{ \
	if (!(f) && DSAAssertFailedLine(THIS_FILE, __LINE__)) \
		::DebugBreak(); \
	} while (0) \

#define VERIFY(f)          ASSERT(f)

#endif // _USE_DSA_ASSERT

#if defined (_USE_DSA_TIMER)

void DSATimer(LPCWSTR, ...);
#define TIMER DSATimer

#else

#define TIMER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\dataobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dataobj.h
//
//--------------------------------------------------------------------------


#ifndef _DATAOBJ_H
#define _DATAOBJ_H


class CDataObject : public IDataObject, public CComObjectRoot
{
public:
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

// Construction/Destruction
    CDataObject() : m_lNotifyHandle(0), m_hwndParentSheet(NULL)
	{
		m_pComponentData = NULL;
	};

    ~CDataObject()
	{
		if (m_pComponentData != NULL)
		{
			m_pComponentData->Release();
			m_pComponentData = NULL;
		}
	};

	void SetIComponentData(CComponentDataImpl* pData)
	{
		ASSERT(pData);
		ASSERT(m_pComponentData == NULL);
		LPUNKNOWN pUnk = pData->GetUnknown();
		HRESULT hr;

		hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));

		ASSERT(hr == S_OK);
	}

public:
	// Clipboard formats that are required by the console
    static CLIPFORMAT    m_cfNodeType;
    static CLIPFORMAT    m_cfNodeTypeString;
    static CLIPFORMAT    m_cfDisplayName;
    static CLIPFORMAT    m_cfCoClass;
	// internal clipboard format
    static CLIPFORMAT    m_cfInternal;

    // Property Page Clipboard formats
    static CLIPFORMAT m_cfDsObjectNames;
    static CLIPFORMAT m_cfDsDisplayOptions;
    static CLIPFORMAT m_cfGetIPropSheetCfg;


// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease);

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type)
    { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

    void SetCookie(MMC_COOKIE cookie) { m_internal.m_cookie = cookie; }
    void SetString(LPCTSTR lpString) { m_internal.m_string = lpString; }
    void SetClass(LPCTSTR lpString) { m_internal.m_class = lpString; }

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);

    INTERNAL m_internal;

	LPCOMPONENTDATA     m_pComponentData;   // pointer to the IComponetData object

    LONG_PTR m_lNotifyHandle;
    HWND     m_hwndParentSheet;
};


#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\cdomain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cdomain.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
//#include "afxdlgs.h"
#include <lm.h>
#include "activeds.h"
#include <dnsapi.h>  // for DnsFlushResolverCache()

#include "domobj.h"
#include "Cdomain.h"
#include "DataObj.h"
#include "notify.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DOMADMIN_LINKED_HELP_FILE L"ADconcepts.chm"
#define DOMADMIN_SNAPIN_HELP_FILE L"domadmin.chm"

int _MessageBox(HWND hWnd,          // handle to owner window
                LPCTSTR lpText,     // pointer to text in message box
                UINT uType);        // style of message box

/////////////////////////////////////////////////////////////////////////////
// macros

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

/////////////////////////////////////////////////////////////////////////////
// constants


// {19B9A3F8-F975-11d1-97AD-00A0C9A06D2D}
static const GUID CLSID_DomainSnapinAbout =
{ 0x19b9a3f8, 0xf975, 0x11d1, { 0x97, 0xad, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };


const CLSID CLSID_DomainAdmin = { /* ebc53a38-a23f-11d0-b09b-00c04fd8dca6 */
    0xebc53a38,
    0xa23f,
    0x11d0,
    {0xb0, 0x9b, 0x00, 0xc0, 0x4f, 0xd8, 0xdc, 0xa6}
  };

const GUID cDefaultNodeType = { /* 4c06495e-a241-11d0-b09b-00c04fd8dca6 */
    0x4c06495e,
    0xa241,
    0x11d0,
    {0xb0, 0x9b, 0x00, 0xc0, 0x4f, 0xd8, 0xdc, 0xa6}
  };

const wchar_t* cszDefaultNodeType = _T("4c06495e-a241-11d0-b09b-00c04fd8dca6");


// Internal private format
const wchar_t* CCF_DS_DOMAIN_TREE_SNAPIN_INTERNAL = L"DS_DOMAIN_TREE_SNAPIN_INTERNAL";





/////////////////////////////////////////////////////////////////////////////
// global functions

//forward decl
void PrintColumn(
                 PADS_SEARCH_COLUMN pColumn,
                 LPWSTR pszColumnName
                 );

BOOL IsMMCMultiSelectDataObject(IDataObject* pDataObject)
{
    if (pDataObject == NULL)
        return FALSE;

    static UINT s_cf = 0;
    if (s_cf == 0)
    {
        USES_CONVERSION;
        s_cf = RegisterClipboardFormat(W2T(CCF_MMC_MULTISELECT_DATAOBJECT));
    }

    FORMATETC fmt = {(CLIPFORMAT)s_cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    return (pDataObject->QueryGetData(&fmt) == S_OK);
}


#define NEXT_HELP_TABLE_ENTRY(p) ((p)+2)
#define TABLE_ENTRY_CTRL_ID(p) (*p)
#define TABLE_ENTRY_HELP_ID(p) (*(p+1))
#define IS_LAST_TABLE_ENTRY(p) (TABLE_ENTRY_CTRL_ID(p) == 0)


BOOL FindDialogContextTopic(/*IN*/ DWORD* pTable, 
                            /*IN*/ HELPINFO* pHelpInfo,
                            /*OUT*/ ULONG* pnContextTopic)
{
	ASSERT(pHelpInfo != NULL);
  *pnContextTopic = 0;

	// look inside the table
	while (!IS_LAST_TABLE_ENTRY(pTable))
	{
		if (TABLE_ENTRY_CTRL_ID(pTable) == (DWORD)pHelpInfo->iCtrlId) 
    {
			*pnContextTopic = TABLE_ENTRY_HELP_ID(pTable);
      return TRUE;
    }
		pTable = NEXT_HELP_TABLE_ENTRY(pTable); 
	}
	return FALSE;
}


void DialogContextHelp(DWORD* pTable, HELPINFO* pHelpInfo)
{
	ULONG nContextTopic;
  if (FindDialogContextTopic(pTable, pHelpInfo, &nContextTopic))
  {
	  CString szHelpFilePath;
	  LPTSTR lpszBuffer = szHelpFilePath.GetBuffer(2*MAX_PATH);
	  UINT nLen = ::GetSystemWindowsDirectory(lpszBuffer, 2*MAX_PATH);
	  if (nLen == 0)
		  return;
	  wcscpy(&lpszBuffer[nLen], L"\\HELP\\DOMADMIN.HLP");
	  szHelpFilePath.ReleaseBuffer();
	  ::WinHelp((HWND) pHelpInfo->hItemHandle, 
            szHelpFilePath, HELP_CONTEXTPOPUP, nContextTopic);
  }	 
}


LPCWSTR GetServerNameFromCommandLine()
{
  const WCHAR szOverrideSrvCommandLine[] = L"/Server=";	// Not subject to localization
  const int cchOverrideSrvCommandLine = (sizeof(szOverrideSrvCommandLine)/sizeof(WCHAR)) - 1; 
    
  static CString g_strOverrideServerName;

  // retrieve the command line arguments
  LPCWSTR* lpServiceArgVectors;		// Array of pointers to string
  int cArgs = 0;						// Count of arguments

  lpServiceArgVectors = (LPCWSTR *)CommandLineToArgvW(GetCommandLineW(), OUT &cArgs);
  if (lpServiceArgVectors == NULL)
  {
    return NULL;
  }

  CString str;
  for (int i = 1; i < cArgs; i++)
  {
    ASSERT(lpServiceArgVectors[i] != NULL);
    str = lpServiceArgVectors[i];	// Copy the string
    TRACE (_T("command line arg: %s\n"), lpServiceArgVectors[i]);
    str = str.Left(cchOverrideSrvCommandLine);
    if (str.CompareNoCase(szOverrideSrvCommandLine) == 0) 
    {
      g_strOverrideServerName = lpServiceArgVectors[i] + cchOverrideSrvCommandLine;
      break;
    } 

  } // for
  LocalFree(lpServiceArgVectors);
  
  TRACE(L"GetServerNameFromCommandLine() returning <%s>\n", (LPCWSTR)g_strOverrideServerName);
  return g_strOverrideServerName.IsEmpty() ? NULL : (LPCWSTR)g_strOverrideServerName;
}



/////////////////////////////////////////////////////////////////////////////
// CInternalFormatCracker

BOOL CInternalFormatCracker::Extract(LPDATAOBJECT lpDataObject)
{
	if (m_pInternalFormat != NULL)
	{
		FREE_INTERNAL(m_pInternalFormat);
	    m_pInternalFormat = NULL;
	}
	if (lpDataObject == NULL)
		return FALSE;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)CDataObject::m_cfInternal, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream
    stgmedium.hGlobal = ::GlobalAlloc(GMEM_SHARE, sizeof(INTERNAL));

    // Attempt to get data from the object
    do
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
            break;

        m_pInternalFormat = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);
        if (m_pInternalFormat == NULL)
            return FALSE;

    } while (FALSE);

    return TRUE;
}

BOOL CInternalFormatCracker::GetContext(LPDATAOBJECT pDataObject, // input
								CFolderObject** ppFolderObject, // output
								DATA_OBJECT_TYPES* pType		// output
								)
{
	*ppFolderObject = NULL;
	*pType = CCT_UNINITIALIZED;

	BOOL bRet = FALSE;
	if (!Extract(pDataObject))
		return bRet;
	
	// have to figure out which kind of cookie we have
	if ( (GetInternal()->m_type == CCT_RESULT) || (GetInternal()->m_type == CCT_SCOPE) )
	{
    if (GetInternal()->m_cookie == 0)
    {
      // this is the root
      *ppFolderObject = m_pCD->GetRootFolder();
      bRet = TRUE;
    }
    else
    {
      // regular cookie (scope or result pane)
		  *ppFolderObject = reinterpret_cast<CFolderObject*>(GetInternal()->m_cookie);
      _ASSERTE(*ppFolderObject != NULL);
		  *pType = GetInternal()->m_type;
		  bRet = TRUE;
    }
	}
	else if (GetInternal()->m_type == CCT_UNINITIALIZED)
	{
		// no data in the object, just ignore
		if(GetInternal()->m_cookie == -1)
    {
		  bRet = TRUE;
    }
    else
    {
      // secondary page cookie
      *ppFolderObject = reinterpret_cast<CFolderObject*>(GetInternal()->m_cookie);
      bRet = TRUE;
    }
	}
	else //CCT_SNAPIN_MANAGER
	{
		ASSERT(GetInternal()->m_type == CCT_SNAPIN_MANAGER);
		bRet = TRUE;
		*pType = GetInternal()->m_type;
	}
	return bRet;
}


///////////////////////////////////////////////////////////////////////////////
////////////////////////// CComponentDataImpl (i.e. scope pane side) //////////
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);

CComponentDataImpl::CComponentDataImpl() : m_rootFolder(this)
{
  DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);

  m_bInitSuccess = FALSE;

	m_hDomainIcon = NULL;
  m_pConsoleNameSpace = NULL;
  m_pConsole = NULL;

  /* HACK WARNING: this is a gross hack to get around a blunder
     in dsuiext.dll. in order to see get DS extension information,
     we MUST have USERDNSDOMAIN set in the environment
     */
  {
    WCHAR * pszUDD = NULL;

    pszUDD = _wgetenv (L"USERDNSDOMAIN");
    if (pszUDD == NULL) {
      _wputenv (L"USERDNSDOMAIN=not-present");
    }
  }

}

HRESULT CComponentDataImpl::FinalConstruct()
{
	// create and initialize hidden window
  m_pHiddenWnd = new CHiddenWnd(this);

  ASSERT(m_pHiddenWnd);
  if (!m_pHiddenWnd->Create())
  {
    TRACE(_T("Failed to create hidden window\n"));
    ASSERT(FALSE);
  }
  return S_OK;
}

CComponentDataImpl::~CComponentDataImpl()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    ASSERT(m_pConsoleNameSpace == NULL);
}

void CComponentDataImpl::FinalRelease()
{
   _DeleteHiddenWnd();
}

STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
    ASSERT(pUnknown != NULL);
    HRESULT hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
    ASSERT(m_pConsoleNameSpace == NULL);
    pUnknown->QueryInterface(IID_IConsoleNameSpace,
                    reinterpret_cast<void**>(&m_pConsoleNameSpace));

    // add the images for the scope tree
    CBitmap bmp16x16;
    LPIMAGELIST lpScopeImage;

    hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);
    if (FAILED(hr))
    {
      return hr;
    }

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    ASSERT(hr == S_OK);
    if (FAILED(hr))
    {
      return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_DOMAIN_SMALL);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                       0, RGB(128, 0, 0));

    lpScopeImage->Release();

    // bind to the path info
    hr = GetBasePathsInfo()->InitFromName(GetServerNameFromCommandLine());
    m_bInitSuccess = SUCCEEDED(hr);
    
    if (FAILED(hr))
    {
      HWND hWndParent;
      GetMainWindow(&hWndParent);
			ReportError(hWndParent, IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
      // TODO: error handling, change icon
    }

    return S_OK;
}

HWND CComponentDataImpl::GetHiddenWindow() 
{ 
  ASSERT(m_pHiddenWnd != NULL);
  ASSERT(::IsWindow(m_pHiddenWnd->m_hWnd)); 
  return m_pHiddenWnd->m_hWnd;
}

void CComponentDataImpl::_DeleteHiddenWnd()
{
  if (m_pHiddenWnd == NULL)
    return;
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (m_pHiddenWnd->m_hWnd != NULL)
	{
		VERIFY(m_pHiddenWnd->DestroyWindow()); 
	}
  delete m_pHiddenWnd;
  m_pHiddenWnd = NULL;
}

STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CComponentImpl>* pObject;
    HRESULT hr = CComObject<CComponentImpl>::CreateInstance(&pObject);

    if (FAILED(hr))
    {
        ASSERT(FALSE && "CComObject<CComponentImpl>::CreateInstance(&pObject) failed");
        return hr;
    }

    ASSERT(pObject != NULL);

    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_pConsoleNameSpace != NULL);
    HRESULT hr = S_OK;

    // Since it's my folder it has an internal format.
    // Design Note: for extension.  I can use the fact, that the data object doesn't have
    // my internal format and I should look at the node type and see how to extend it.
    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnPropertyChange(param);
    }
    else
    {
		if (lpDataObject == NULL)
			return S_OK;

        CFolderObject* pFolderObject = NULL;
        DATA_OBJECT_TYPES type;
        CInternalFormatCracker dobjCracker(this);
        if (!dobjCracker.GetContext(lpDataObject, &pFolderObject, &type))
        {
            // Extensions not supported.
            ASSERT(FALSE);
            return S_OK;
        }

        switch(event)
        {
        case MMCN_EXPAND:
            hr = OnExpand(pFolderObject, arg, param);
            break;
		case MMCN_REFRESH:
			OnRefreshVerbHandler(pFolderObject, NULL);
			break;
        default:
            break;
        }

    }

    return hr;
}

STDMETHODIMP CComponentDataImpl::Destroy()
{

    SAFE_RELEASE(m_pConsoleNameSpace);
    SAFE_RELEASE(m_pConsole);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
	if (ppDataObject == NULL)
		return E_INVALIDARG;

	// create data object
    CComObject<CDataObject>* pObject;
    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);
	// set pointer to IComponentData
	pObject->SetIComponentData(this);

    if (cookie != NULL)
	{
		// object is not the root
		CDomainObject * pDomain = (CDomainObject *)cookie;
		pObject->SetClass( pDomain->GetClass());
    }

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData


HRESULT CComponentDataImpl::OnExpand(CFolderObject* pFolderObject, LPARAM arg, LPARAM param)
{
  if (arg == TRUE)
    {
      // Did Initialize get called?
      ASSERT(m_pConsoleNameSpace != NULL);
      EnumerateScopePane(pFolderObject,
                         param);
    }

  return S_OK;
}


HRESULT CComponentDataImpl::OnPropertyChange(LPARAM param)
{
    return S_OK;
}




void CComponentDataImpl::EnumerateScopePane(CFolderObject* pFolderObject, HSCOPEITEM pParent)
{
	ASSERT(m_pConsoleNameSpace != NULL); // make sure we QI'ed for the interface

	HRESULT hr = S_OK;
	
  HWND hWndParent;
  GetMainWindow(&hWndParent);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CWaitCursor cWait;

	CRootFolderObject* pRootFolder = GetRootFolder();
	if (pFolderObject == pRootFolder) // asked to enumerate the root
	{
		pRootFolder->SetScopeID(pParent);
		if (m_bInitSuccess && (!pRootFolder->HasData()))
		{
      hr = GetDsDisplaySpecOptionsCFHolder()->Init(GetBasePathsInfo());
      ASSERT(SUCCEEDED(hr));
      hr = pRootFolder->Bind();
      if (FAILED(hr))
      {
				ReportError(hWndParent, IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
      // TODO: error handling, change icon
        return;
      }

			hr = pRootFolder->GetData();
			if (FAILED(hr))
      {
				ReportError(hWndParent, IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
        return;
      }
		}
		pRootFolder->EnumerateRootFolder(this);
	}
	else // asked to enumerate a subfolder of the root
	{
		if (pRootFolder->HasData())
		{
			pRootFolder->EnumerateFolder(pFolderObject, pParent, this);
		}
	}
}

STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    ASSERT(pScopeDataItem != NULL);
    if (pScopeDataItem == NULL)
        return E_POINTER;

    CDomainObject* pDomain = reinterpret_cast<CDomainObject*>(pScopeDataItem->lParam);

    ASSERT(pScopeDataItem->mask & SDI_STR);
    pScopeDataItem->displayname = (LPWSTR)pDomain->GetDisplayString(0);

    ASSERT(pScopeDataItem->displayname != NULL);

    return S_OK;
}


class CCompareDomainObjectByDN
{
public:
  CCompareDomainObjectByDN(LPCWSTR lpszDN) { m_lpszDN = lpszDN;}
  bool operator()(CDomainObject* p)
  {
    return (_wcsicmp(m_lpszDN, p->GetNCName()) == 0);
  }
private:
  LPCWSTR m_lpszDN;
};



STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
  if (lpDataObjectA == NULL || lpDataObjectB == NULL)
      return E_POINTER;

	CFolderObject *pFolderObjectA, *pFolderObjectB;
	DATA_OBJECT_TYPES typeA, typeB;
	CInternalFormatCracker dobjCrackerA(this), dobjCrackerB(this);
	if ( (!dobjCrackerA.GetContext(lpDataObjectA, &pFolderObjectA, &typeA)) ||
       (!dobjCrackerB.GetContext(lpDataObjectB, &pFolderObjectB, &typeB)) )
		return E_INVALIDARG; // something went wrong


  // must have valid cookies
  if ( (pFolderObjectA == NULL) || (pFolderObjectB == NULL) )
  {
    return S_FALSE;
  }
    
  if (pFolderObjectA == pFolderObjectB)
  {
    // same pointer, they are the same (either both from real nodes
    // or both from secondary pages)
    return S_OK;
  }

  // the two cookies are different, but one of them might be from a secondary property page
  // and another from a real node
  CDomainObject* pA = dynamic_cast<CDomainObject*>(pFolderObjectA);
  CDomainObject* pB = dynamic_cast<CDomainObject*>(pFolderObjectB);

  if ((pA == NULL) || (pB == NULL))
  {
    return S_FALSE;
  }

  BOOL bSecondaryA = m_secondaryPagesManager.IsCookiePresent(pA);
  BOOL bSecondaryB = m_secondaryPagesManager.IsCookiePresent(pB);

  BOOL bTheSame = FALSE;
  if (bSecondaryA && !bSecondaryB)
  {
    bTheSame = m_secondaryPagesManager.FindCookie(CCompareDomainObjectByDN(pB->GetNCName())) != NULL;
  }
  else if (!bSecondaryA && bSecondaryB)
  {
    bTheSame = m_secondaryPagesManager.FindCookie(CCompareDomainObjectByDN(pA->GetNCName())) != NULL;
  }

  return bTheSame ? S_OK : S_FALSE;
}

HRESULT CComponentDataImpl::AddFolder(CFolderObject* pFolderObject,
									  HSCOPEITEM pParentScopeItem,
									  BOOL bHasChildren)
{
  TRACE(L"CComponentDataImpl::AddFolder(%s)\n", pFolderObject->GetDisplayString(0));

  SCOPEDATAITEM scopeItem;
  memset(&scopeItem, 0, sizeof(SCOPEDATAITEM));

	// set parent scope item
	scopeItem.mask |= SDI_PARENT;
	scopeItem.relativeID = pParentScopeItem;

	// Add node name, we implement callback
	scopeItem.mask |= SDI_STR;
	scopeItem.displayname = MMC_CALLBACK;

	// Add the lParam
	scopeItem.mask |= SDI_PARAM;
	scopeItem.lParam = reinterpret_cast<LPARAM>(pFolderObject);
	
	// Add close image
	scopeItem.mask |= SDI_IMAGE;
	scopeItem.nImage = pFolderObject->GetImageIndex();

	// Add open image
	scopeItem.mask |= SDI_OPENIMAGE;
	scopeItem.nOpenImage = pFolderObject->GetImageIndex();

	// Add button to node if the folder has children
	if (bHasChildren == TRUE)
	{
		scopeItem.mask |= SDI_CHILDREN;
		scopeItem.cChildren = 1;
	}

	pFolderObject->SetScopeID(0);
	HRESULT	hr = m_pConsoleNameSpace->InsertItem(&scopeItem);
	if (SUCCEEDED(hr))
		pFolderObject->SetScopeID(scopeItem.ID);

	return hr;
}

HRESULT CComponentDataImpl::AddDomainIcon()
{
	if (m_hDomainIcon != NULL)
		return S_OK;

  m_hDomainIcon = GetBasePathsInfo()->GetIcon(L"domainDNS",
                                  DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON,
                                  0, 0);
	if (m_hDomainIcon == NULL)
		return S_OK;

	LPIMAGELIST lpScopeImage;
    HRESULT hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
		return hr;
    // Set the images
    hr = lpScopeImage->ImageListSetIcon((LONG_PTR*)m_hDomainIcon,DOMAIN_IMAGE_IDX);
	lpScopeImage->Release();
	return hr;
}

HRESULT CComponentDataImpl::AddDomainIconToResultPane(LPIMAGELIST lpImageList)
{
	if (m_hDomainIcon == NULL)
		return S_OK;
	return lpImageList->ImageListSetIcon((LONG_PTR*)m_hDomainIcon,DOMAIN_IMAGE_IDX);
}


int CComponentDataImpl::GetDomainImageIndex()
{
	return (m_hDomainIcon != NULL) ? DOMAIN_IMAGE_IDX : DOMAIN_IMAGE_DEFAULT_IDX;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation
//+----------------------------------------------------------------------------
//
//  Function:   AddPageProc
//
//  Synopsis:   The IShellPropSheetExt->AddPages callback.
//
//-----------------------------------------------------------------------------
BOOL CALLBACK
AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall)
{
    TRACE(_T("xx.%03x> AddPageProc()\n"), GetCurrentThreadId());

    HRESULT hr;

    hr = ((LPPROPERTYSHEETCALLBACK)pCall)->AddPage(hPage);

    return hr == S_OK;
}
STDMETHODIMP CComponentDataImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    TRACE(_T("xx.%03x> CComponentDataImpl::CreatePropertyPages()\n"),
          GetCurrentThreadId());

    // Validate Inputs
    if (lpProvider == NULL)
    {
        return E_INVALIDARG;
    }

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    CWaitCursor wait;

    CFolderObject* pFolderObject = NULL;
    DATA_OBJECT_TYPES type;
    CInternalFormatCracker dobjCracker(this);
    if ( (!dobjCracker.GetContext(lpIDataObject, &pFolderObject, &type)) ||
            (pFolderObject == NULL))
    return E_NOTIMPL; // unknown format

    // special case the root
    if (pFolderObject == GetRootFolder())
    {
      return GetRootFolder()->OnAddPages(lpProvider, handle);
    }

    // See if a sheet is already up for this object.
    //
    if (IsSheetAlreadyUp(lpIDataObject))
    {
        return S_OK;
    }

    if (pFolderObject->GetParentFolder() == GetRootFolder())
    {
       TRACE(L"\t!!!!! This is the root domain\n");
    }

   // See if a PDC is available.
   //
   CDomainObject * pDomainObject = (CDomainObject *)pFolderObject;

   PCWSTR wzDomain = pDomainObject->GetDomainName();

   // If the domain name is null, then launching a secondary page. The domain
   // object properties have already been set in _OnSheetCreate.
   //
   if (wzDomain && *wzDomain)
   {
      TRACE(L"Calling DsGetDcName on %s\n", wzDomain);
      CString strCachedPDC;
      PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;

      // Get the cached PDC name for display later if the PDC can't be contacted.
      //
      DWORD dwRet = DsGetDcNameW(NULL, wzDomain, NULL, NULL, DS_PDC_REQUIRED, &pDCInfo);

      int nID = IDS_NO_PDC_MSG;

      if (ERROR_SUCCESS == dwRet)
      {
         strCachedPDC = pDCInfo->DomainControllerName + 2;
         NetApiBufferFree(pDCInfo);
      }

      // Now do a NetLogon cache update (with the force flag) to see if the PDC
      // is actually available.
      //
      dwRet = DsGetDcNameW(NULL, wzDomain, NULL, NULL, 
                           DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY, &pDCInfo);

      if (ERROR_SUCCESS == dwRet)
      {
         CString strPDC;

         strPDC = pDCInfo->DomainControllerName + 2; // skip the UNC backslashes.

         NetApiBufferFree(pDCInfo);

         TRACE(L"PDC: %s\n", (PCWSTR)strPDC);

         if (strPDC.IsEmpty())
         {
            return E_OUTOFMEMORY;
         }

         pDomainObject->SetPDC(strPDC);

         pDomainObject->SetPdcAvailable(true);
      }
      else
      {
         pDomainObject->SetPdcAvailable(false);

         CString strMsg;

         if (strCachedPDC.IsEmpty())
         {
            strMsg.LoadString(IDS_UNKNOWN_PDC_MSG);
         }
         else
         {
            strMsg.Format(IDS_NO_PDC_MSG, strCachedPDC);
         }
         HWND hWndParent;
         GetMainWindow(&hWndParent);
         _MessageBox(hWndParent, strMsg, MB_OK | MB_ICONEXCLAMATION);
      }
   }

    //
    // Pass the Notify Handle to the data object.
    //
    PROPSHEETCFG SheetCfg = {handle};
    FORMATETC fe = {CDataObject::m_cfGetIPropSheetCfg, NULL, DVASPECT_CONTENT,
                    -1, TYMED_HGLOBAL};
    STGMEDIUM sm = {TYMED_HGLOBAL, NULL, NULL};
    sm.hGlobal = (HGLOBAL)&SheetCfg;

    lpIDataObject->SetData(&fe, &sm, FALSE);

    //
    // Initialize and create the pages.
    //
    // Bind to the property sheet COM object at startup and hold its pointer
    // until shutdown so that its cache can live as long as us.
    //
    CComPtr<IShellExtInit> spShlInit;
    hr = CoCreateInstance(CLSID_DsPropertyPages, NULL, CLSCTX_INPROC_SERVER,
                          IID_IShellExtInit, (void **)&spShlInit);
    if (FAILED(hr))
    {
        TRACE(TEXT("CoCreateInstance on CLSID_DsPropertyPages failed, hr: 0x%x\n "), hr);
        return hr;
    }

    hr = spShlInit->Initialize(NULL, lpIDataObject, 0);

    if (FAILED(hr))
    {
        TRACE(TEXT("spShlInit->Initialize failed, hr: 0x%x\n"), hr);
        return hr;
    }

    CComPtr<IShellPropSheetExt> spSPSE;

    hr = spShlInit->QueryInterface(IID_IShellPropSheetExt, (void **)&spSPSE);

    if (FAILED(hr))
    {
        TRACE(TEXT("spShlInit->QI for IID_IShellPropSheetExt failed, hr: 0x%x\n"), hr);
        return hr;
    }

    hr = spSPSE->AddPages(AddPageProc, (LONG_PTR)lpProvider);

    if (FAILED(hr))
    {
        TRACE(TEXT("pSPSE->AddPages failed, hr: 0x%x\n"), hr);
        return hr;
    }

    _SheetLockCookie(pFolderObject);

    return hr;
}


// Sheet locking and unlocking add by JEFFJON 1/26/99
//
void CComponentDataImpl::_OnSheetClose(CFolderObject* pCookie)
{
  ASSERT(pCookie != NULL);
  _SheetUnlockCookie(pCookie);

  CDomainObject* pDomObj = dynamic_cast<CDomainObject*>(pCookie);
  if (pDomObj != NULL)
    m_secondaryPagesManager.OnSheetClose(pDomObj);
}


void CComponentDataImpl::_OnSheetCreate(PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo,
                                        PWSTR pwzDC)
{
  ASSERT(pDsaSecondaryPageInfo != NULL);

  // get the info from the packed structure
  HWND hwndParent = pDsaSecondaryPageInfo->hwndParentSheet;

  LPCWSTR lpszTitle = (LPCWSTR)((BYTE*)pDsaSecondaryPageInfo + pDsaSecondaryPageInfo->offsetTitle);
  DSOBJECTNAMES* pDsObjectNames = &(pDsaSecondaryPageInfo->dsObjectNames);

  ASSERT(pDsObjectNames->cItems == 1);
  DSOBJECT* pDsObject = &(pDsObjectNames->aObjects[0]);

  LPCWSTR lpszName = (LPCWSTR)((BYTE*)pDsObject + pDsObject->offsetName);
  LPCWSTR lpszClass = (LPCWSTR)((BYTE*)pDsObject + pDsObject->offsetClass);
    
  // with the given info, create a cookie and set it
  CDomainObject* pNewCookie = new CDomainObject(); 
  pNewCookie->InitializeForSecondaryPage(lpszName, lpszClass, GetDomainImageIndex());

   // The parent sheet will be in read-only mode if a PDC is not available.
   pNewCookie->SetPdcAvailable(!(pDsObject->dwFlags & DSOBJECT_READONLYPAGES));

   if (pwzDC && !IsBadReadPtr(pwzDC, sizeof(PWSTR)))
   {
      pNewCookie->SetPDC(pwzDC);
   }

    // with the cookie, can call into ourselves to get a data object
  CComPtr<IDataObject> spDataObject;
  MMC_COOKIE cookie = reinterpret_cast<MMC_COOKIE>(pNewCookie);
  HRESULT hr = QueryDataObject(cookie, CCT_UNINITIALIZED, &spDataObject);

  if (FAILED(hr) || (spDataObject == NULL) || IsSheetAlreadyUp(spDataObject))
  {
    // we failed to create a data object (rare)
    // or the sheet is already up
    delete pNewCookie;
    return;
  }

  //
  // Pass the parent sheet handle to the data object.
  //
  PROPSHEETCFG SheetCfg = {0};
  SheetCfg.hwndParentSheet = hwndParent;
  FORMATETC fe = {CDataObject::m_cfGetIPropSheetCfg, NULL, DVASPECT_CONTENT,
                  -1, TYMED_HGLOBAL};
  STGMEDIUM sm = {TYMED_HGLOBAL, NULL, NULL};
  sm.hGlobal = (HGLOBAL)&SheetCfg;

  hr = spDataObject->SetData(&fe, &sm, FALSE);

  ASSERT(SUCCEEDED(hr));

  // with the data object, call into MMC to get the sheet 
  hr = m_secondaryPagesManager.CreateSheet(GetHiddenWindow(), 
                                      m_pConsole, 
                                      GetUnknown(),
                                      pNewCookie,
                                      spDataObject,
                                      lpszTitle);

  // if failed, the cookie can be discarded, 
  // if succeeded, the cookie has been inserted into
  // the secondary pages manager cookie list
  if (FAILED(hr))
  {
    delete pNewCookie;
  }

}





void  CComponentDataImpl::_SheetLockCookie(CFolderObject* pCookie)
{
  pCookie->IncrementSheetLockCount();
  m_sheetCookieTable.Add(pCookie);
}

void  CComponentDataImpl::_SheetUnlockCookie(CFolderObject* pCookie)
{
  pCookie->DecrementSheetLockCount();
  m_sheetCookieTable.Remove(pCookie);
}

STDMETHODIMP CComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
	CFolderObject* pFolderObject;
	DATA_OBJECT_TYPES type;
	CInternalFormatCracker dobjCracker(this);
	if (!dobjCracker.GetContext(lpDataObject, &pFolderObject, &type))
  {
    // not internal format, not ours
		return S_FALSE;
  }

  // this is the MMC snzpin wizard, we do not have one
  if (type == CCT_SNAPIN_MANAGER)
  {
    return S_FALSE;
  }

  // if NULL no pages
  if (pFolderObject == NULL)
  {
    return S_FALSE;
  }

  // secondary pages data objects have to be checked first,
  // because they look like the root (no parents, but they
  // have CCT_UNINITIALIZED 
  if ( (pFolderObject->GetParentFolder() == NULL) || (type == CCT_UNINITIALIZED) )
  {
    return S_OK;
  }

  // check if this is the root
  if (GetRootFolder() == pFolderObject)
  {
    // this is the root
    ASSERT(type == CCT_SCOPE);
    return S_OK;
  }

  // default case, have DSPROP property pages
  return S_OK;
}

BOOL CComponentDataImpl::IsScopePaneNode(LPDATAOBJECT lpDataObject)
{
	CFolderObject* pFolderObject;
	DATA_OBJECT_TYPES type;
	CInternalFormatCracker dobjCracker(this);
	if (!dobjCracker.GetContext(lpDataObject, &pFolderObject, &type))
		return FALSE;
  return (dobjCracker.GetInternal()->m_type == CCT_SCOPE);
}

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT pDataObject,
                                              LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              long *pInsertionAllowed)
{
  HRESULT hr = S_OK;

	CFolderObject* pFolderObject;
	DATA_OBJECT_TYPES type;
	CInternalFormatCracker dobjCracker(this);
	if (!dobjCracker.GetContext(pDataObject, &pFolderObject, &type))
        return E_FAIL;

    return pFolderObject->OnAddMenuItems(pContextMenuCallback, pInsertionAllowed);
}


STDMETHODIMP CComponentDataImpl::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
  // Note - snap-ins need to look at the data object and determine
  // in what context the command is being called.

	CFolderObject* pFolderObject;
	DATA_OBJECT_TYPES type;
	CInternalFormatCracker dobjCracker(this);
	if (!dobjCracker.GetContext(pDataObject, &pFolderObject, &type))
        return E_FAIL;

    return pFolderObject->OnCommand(this, nCommandID);
}

/////////////////////////////////////////////////////////////////////////////
// CComponentDataImpl::ISnapinHelp2 members

STDMETHODIMP CComponentDataImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
  {
    return E_INVALIDARG;
  }

  CString szHelpFilePath;
  LPTSTR lpszBuffer = szHelpFilePath.GetBuffer(2*MAX_PATH);
  UINT nLen = ::GetSystemWindowsDirectory(lpszBuffer, 2*MAX_PATH);
  if (nLen == 0)
  {
    return E_FAIL;
  }
  szHelpFilePath.ReleaseBuffer();
  szHelpFilePath += L"\\help\\";
  szHelpFilePath += DOMADMIN_SNAPIN_HELP_FILE;

  UINT nBytes = (szHelpFilePath.GetLength()+1) * sizeof(WCHAR);
  *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);

  if (NULL == *lpCompiledHelpFile)
  {
    return E_OUTOFMEMORY;
  }

  memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);

  return S_OK;
}

STDMETHODIMP CComponentDataImpl::GetLinkedTopics(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
  {
    return E_INVALIDARG;
  }

  CString szHelpFilePath;
  LPTSTR lpszBuffer = szHelpFilePath.GetBuffer(2*MAX_PATH);
  UINT nLen = ::GetSystemWindowsDirectory(lpszBuffer, 2*MAX_PATH);
  if (nLen == 0)
  {
    return E_FAIL;
  }
  szHelpFilePath.ReleaseBuffer();
  szHelpFilePath += L"\\help\\";
  szHelpFilePath += DOMADMIN_LINKED_HELP_FILE;

  UINT nBytes = (szHelpFilePath.GetLength()+1) * sizeof(WCHAR);
  *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);

  if (NULL == *lpCompiledHelpFile)
  {
    return E_OUTOFMEMORY;
  }

  memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);

  return S_OK;
}
/////////////////////////////////////////////////////////////////////

void CComponentDataImpl::HandleStandardVerbsHelper(CComponentImpl* pComponentImpl,
									LPCONSOLEVERB pConsoleVerb,
									BOOL bScope, BOOL bSelect,
									CFolderObject* pFolderObject,
                                    DATA_OBJECT_TYPES type)
{
    // You should crack the data object and enable/disable/hide standard
    // commands appropriately.  The standard commands are reset everytime you get
    // called. So you must reset them back.

	ASSERT(pConsoleVerb != NULL);
	ASSERT(pComponentImpl != NULL);
	ASSERT(pFolderObject != NULL);

	// reset the selection
	pComponentImpl->SetSelection(NULL, CCT_UNINITIALIZED);


	if (bSelect)
	{
    // special case the root
    BOOL bIsRoot = (pFolderObject == GetRootFolder());

		// setting the selection, if any
		pComponentImpl->SetSelection(pFolderObject, type);

		// the default just disables all the non implemented verbs
		pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
		pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, FALSE);

		pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
		pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, FALSE);

		pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
		pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);

		pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, TRUE);
		pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, FALSE);

		// handling of standard verbs

		// MMC_VERB_DELETE (always disabled)
		pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, FALSE);
		pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);

		// MMC_VERB_REFRESH (enabled only for root)
    if (bIsRoot)
    {
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
		  pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
    }
    else
    {
		  pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);
		  pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
    }

		// MMC_VERB_PROPERTIES
    // passing NULL pFolderObject means multiple selection
    BOOL bHasProperties = (pFolderObject != NULL);
		BOOL bHideProperties = !bHasProperties;
		pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, bHasProperties);
		pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, bHideProperties);
		
		// SET DEFAULT VERB
		// assume only folders: only one default verb (i.e. will not have MMC_VERB_PROPERTIES)
		pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

	}
}

void CComponentDataImpl::OnRefreshVerbHandler(CFolderObject* pFolderObject, 
                                              CComponentImpl* pComponentImpl,
                                              BOOL bBindAgain)
{
  TRACE(L"CComponentDataImpl::OnRefreshVerbHandler(...,..., %d)\n", bBindAgain);
	if (pFolderObject->_WarningOnSheetsUp(this))
		return;

  // make sure the DNS cache is flushed, in case a somain was added.
  VERIFY(::DnsFlushResolverCache());

  // NOTICE: only the root folder allows refresh
  ASSERT(pFolderObject == GetRootFolder());

	// remove all the children of the root from the UI
  m_pConsoleNameSpace->DeleteItem(m_rootFolder.GetScopeID(), /*fDeleteThis*/ FALSE);

  HRESULT hr = S_OK;
  if (bBindAgain)
  {
    // the server name has changed
    hr = m_rootFolder.Bind();
    TRACE(L"m_rootFolder.Bind() returned hr = 0x%x\n", hr);
  }
  
  if (SUCCEEDED(hr))
  {
	  // refresh the data from the server
	  hr = m_rootFolder.GetData();
    TRACE(L"m_rootFolder.GetData() returned hr = 0x%x\n", hr);
  }

	if (FAILED(hr))
	{
    HWND hWndParent;
    GetMainWindow(&hWndParent);
		ReportError(hWndParent, IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
	}

  if (FAILED(hr))
    return;

	// re-enumerate
	m_rootFolder.EnumerateRootFolder(this);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////// CComponentImpl (i.e. result pane side) //////////////////
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CComponentImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    return S_FALSE;
}


// This compare is used to sort the item's in the listview
//
// Parameters:
//
// lUserParam - user param passed in when IResultData::Sort() was called
// cookieA - first item to compare
// cookieB - second item to compare
// pnResult [in, out]- contains the col on entry,
//          -1, 0, 1 based on comparison for return value.
//
// Note: Assume sort is ascending when comparing.

STDMETHODIMP CComponentImpl::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
    if (pnResult == NULL)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // check col range
    int nCol = *pnResult;
    ASSERT(nCol >=0 && nCol< 3);

    *pnResult = 0;

    LPCTSTR szStringA;
    LPCTSTR szStringB;

    CDomainObject* pDataA = reinterpret_cast<CDomainObject*>(cookieA);
    CDomainObject* pDataB = reinterpret_cast<CDomainObject*>(cookieB);


    ASSERT(pDataA != NULL && pDataB != NULL);

    // Currently DomAdmin has just two columns, Name and Type. The value of
    // the type column is always "DomainDNS", so there is nothing to compare
    // for that column and the default *pnResult, set to zero above, is
    // returned.

    if (nCol == 0)
    {
        szStringA = pDataA->GetDomainName();
        szStringB = pDataB->GetDomainName();

        ASSERT(szStringA != NULL);
        ASSERT(szStringB != NULL);

        *pnResult = _tcscmp(szStringA, szStringB);
    }

    return S_OK;
}


void CComponentImpl::HandleStandardVerbs(BOOL bScope, BOOL bSelect,
                                         CFolderObject* pFolderObject, DATA_OBJECT_TYPES type)
{
    // delegate it to the IComponentData helper function
    ASSERT(m_pCD != NULL);
	m_pCD->HandleStandardVerbsHelper(
		this, m_pConsoleVerb, bScope, bSelect, pFolderObject, type);
}

void CComponentImpl::Refresh(CFolderObject* pFolderObject)
{
	ASSERT(m_pComponentData != NULL);
	// delegate it to the IComponentData helper function
	((CComponentDataImpl*)m_pComponentData)->OnRefreshVerbHandler(pFolderObject, this);
}



//                   utility routines
////////////////////////////////////////////////////////////////////
//
// Print the data depending on its type.
//

#ifdef DBG
void
PrintColumn(
    PADS_SEARCH_COLUMN pColumn,
    LPWSTR pszColumnName
    )
{

    ULONG i, j, k;

    if (!pColumn) {
        return;
    }

    TRACE(_T(
        "%s = "),
        pszColumnName
        );

    for (k=0; k < pColumn->dwNumValues; k++) {
        if (k > 0)
            TRACE(_T("#  "));

        switch(pColumn->dwADsType) {
        case ADSTYPE_DN_STRING         :
            TRACE(_T(
                "%s  "),
                (LPWSTR) pColumn->pADsValues[k].DNString
                );
            break;
        case ADSTYPE_CASE_EXACT_STRING :
            TRACE(_T(
                "%s  "),
                (LPWSTR) pColumn->pADsValues[k].CaseExactString
                );
            break;
        case ADSTYPE_CASE_IGNORE_STRING:
            TRACE(_T(
                "%s  "),
                (LPWSTR) pColumn->pADsValues[k].CaseIgnoreString
                );
            break;
        case ADSTYPE_PRINTABLE_STRING  :
            TRACE(_T(
                "%s  "),
                (LPWSTR) pColumn->pADsValues[k].PrintableString
                );
            break;
        case ADSTYPE_NUMERIC_STRING    :
            TRACE(_T(
                "%s  "),
                (LPWSTR) pColumn->pADsValues[k].NumericString
                );
            break;

        case ADSTYPE_BOOLEAN           :
            TRACE(_T(
                "%s  "),
                (DWORD) pColumn->pADsValues[k].Boolean ?
                L"TRUE" : L"FALSE"
                );
            break;

        case ADSTYPE_INTEGER           :
            TRACE(_T(
                "%d  "),
                (DWORD) pColumn->pADsValues[k].Integer
                );
            break;

        case ADSTYPE_OCTET_STRING      :
            for (j=0; j<pColumn->pADsValues[k].OctetString.dwLength; j++) {
                TRACE(_T(
                    "%02x"),
                    ((BYTE *)pColumn->pADsValues[k].OctetString.lpValue)[j]
                    );
            }
            break;

        case ADSTYPE_LARGE_INTEGER     :
            TRACE(_T(
                "%e = "),
                (double) pColumn->pADsValues[k].Integer
                );
            break;

        case ADSTYPE_UTC_TIME          :
            TRACE(_T(
                "(date value) "
                ));
            break;
        case ADSTYPE_PROV_SPECIFIC     :
            TRACE(_T(
                "(provider specific value) "
                ));
            break;

        }
    }

    TRACE(_T("\n"));
}

#endif

/////////////////////////////////////////////////////////////////////////////
// Return TRUE if we are enumerating our main folder

BOOL CComponentImpl::IsEnumerating(LPDATAOBJECT lpDataObject)
{
    BOOL bResult = FALSE;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)CDataObject::m_cfNodeType, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(GUID));

    // Attempt to get data from the object
    do
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
            break;

        GUID* nodeType = reinterpret_cast<GUID*>(stgmedium.hGlobal);

        if (nodeType == NULL)
            break;

        // Is this my main node (static folder node type)
        if (*nodeType == cDefaultNodeType)
            bResult = TRUE;

    } while (FALSE);


    // Free resources
    if (stgmedium.hGlobal != NULL)
        GlobalFree(stgmedium.hGlobal);

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// CComponentImpl's IComponent implementation

STDMETHODIMP CComponentImpl::GetResultViewType(MMC_COOKIE cookie,  LPOLESTR* ppViewType,
                                        long *pViewOptions)
{
  // Use default view
  *pViewOptions = 0;
  return S_FALSE;
}

STDMETHODIMP CComponentImpl::Initialize(LPCONSOLE lpConsole)
{
    ASSERT(lpConsole != NULL);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    // Load resource strings
    LoadResources();

    // QI for a IHeaderCtrl
    HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);
    ASSERT(hr == S_OK);

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    ASSERT(hr == S_OK);

    //InitializeHeaders(NULL);
    //InitializeBitmaps(NULL);
    return S_OK;
}

STDMETHODIMP CComponentImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (event == MMCN_PROPERTY_CHANGE)
    {
        hr = OnPropertyChange(lpDataObject);
    }
    else if (event == MMCN_VIEW_CHANGE)
    {
        hr = OnUpdateView(lpDataObject);
    }
    else if (event == MMCN_CONTEXTHELP)
    {
        CComPtr<IDisplayHelp> spHelp;
        hr = m_pConsole->QueryInterface(IID_IDisplayHelp, (void **)&spHelp);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            TRACE(L"Setting the help topic to adconcepts.chm::/domadmin_top.htm\n");
            spHelp->ShowTopic(L"adconcepts.chm::/domadmin_top.htm");
        }
    }
    else
    {
        if (lpDataObject == NULL)
            return S_OK;

        CFolderObject* pFolderObject = NULL;
        DATA_OBJECT_TYPES type;
        CInternalFormatCracker dobjCracker(m_pCD);
        if (!dobjCracker.GetContext(lpDataObject, &pFolderObject, &type))
        {
            // Extensions not supported.
            ASSERT(FALSE);
            return S_OK;
        }
        ASSERT(pFolderObject != NULL);

        switch(event)
        {
        case MMCN_SHOW:
            hr = OnShow(pFolderObject, arg, param);
            break;

        case MMCN_ADD_IMAGES:
            hr = OnAddImages(pFolderObject, arg, param);
            break;

        case MMCN_SELECT:
            if (IsMMCMultiSelectDataObject(lpDataObject) == TRUE)
                pFolderObject = NULL;
            HandleStandardVerbs( (BOOL) LOWORD(arg)/*bScope*/,
                                 (BOOL) HIWORD(arg)/*bSelect*/, pFolderObject, type);
            break;

        case MMCN_REFRESH:
            Refresh(pFolderObject);
            break;

        default:
            break;
        } // switch
    } // else

    if (m_pResult)
    {
      // should put something here, someday?
      ;
    }

    return hr;
}

STDMETHODIMP CComponentImpl::Destroy(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pImageResult);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        SAFE_RELEASE(m_pComponentData); // QI'ed in IComponentDataImpl::CreateComponent

        SAFE_RELEASE(m_pConsoleVerb);
    }

    return S_OK;
}

STDMETHODIMP CComponentImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    // Delegate it to the IComponentData
    ASSERT(m_pComponentData != NULL);
    return m_pComponentData->QueryDataObject(cookie, type, ppDataObject);
}

/////////////////////////////////////////////////////////////////////////////
// CComponentImpl's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentImpl);

CComponentImpl::CComponentImpl()
{
  DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentImpl);
  Construct();
}

CComponentImpl::~CComponentImpl()
{
#if DBG==1
    ASSERT(dbg_cRef == 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentImpl);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);
    Construct();
}

void CComponentImpl::Construct()
{
#if DBG==1
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pImageResult = NULL;
    m_pComponentData = NULL;
    m_pCD = NULL;
    m_pConsoleVerb = NULL;

	m_selectedType = CCT_UNINITIALIZED;
	m_pSelectedFolderObject = NULL;

}

void CComponentImpl::LoadResources()
{
    // Load strings from resources
    m_column1.LoadString(IDS_NAME);
    m_column2.LoadString(IDS_TYPE);
}

HRESULT CComponentImpl::InitializeHeaders(CFolderObject* pFolderObject)
{
    HRESULT hr = S_OK;
    ASSERT(m_pHeader);

	// NOTICE: we ignore the cookie, keep always the same columns
    m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, 200);     // Name
    m_pHeader->InsertColumn(1, m_column2, LVCFMT_LEFT, 80);     // Type

    return hr;
}

HRESULT CComponentImpl::InitializeBitmaps(CFolderObject* pFolderObject)
{
    ASSERT(m_pImageResult != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBitmap bmp16x16;
    CBitmap bmp32x32;

    // Load the bitmaps from the dll
    VERIFY(bmp16x16.LoadBitmap(IDB_DOMAIN_SMALL));
    VERIFY(bmp32x32.LoadBitmap(IDB_DOMAIN_LARGE));

    // Set the images
    HRESULT hr = m_pImageResult->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                       0, RGB(128, 0, 0));
	if (FAILED(hr))
		return hr;
	return ((CComponentDataImpl*)m_pComponentData)->AddDomainIconToResultPane(m_pImageResult);
}


STDMETHODIMP CComponentImpl::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
  ASSERT(pResult != NULL);

  CDomainObject* pDomain = reinterpret_cast<CDomainObject*>(pResult->lParam);
  if ( (pDomain != NULL) && (pResult->mask & RDI_STR) )
	{
		pResult->str = (LPWSTR)pDomain->GetDisplayString(pResult->nCol);
    TRACE(L"pResult->str = %s\n", pResult->str);
	}
	if ((pResult->mask & RDI_IMAGE) && (pResult->nCol == 0))
	{
		pResult->nImage = pDomain->GetImageIndex();
	}

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation


STDMETHODIMP CComponentImpl::AddMenuItems(LPDATAOBJECT pDataObject,
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                   long * pInsertionAllowed)
{
    return dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
            AddMenuItems(pDataObject, pContextMenuCallback, pInsertionAllowed);
}

STDMETHODIMP CComponentImpl::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    return dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
            Command(nCommandID, pDataObject);
}


HRESULT CComponentImpl::OnShow(CFolderObject* pFolderObject, LPARAM arg, LPARAM param)
{
    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
         // Show the headers for this nodetype
        InitializeHeaders(pFolderObject);
        Enumerate(pFolderObject, param);
    }
    return S_OK;
}

HRESULT CComponentImpl::OnAddImages(CFolderObject* pFolderObject, LPARAM arg, LPARAM param)
{
	return InitializeBitmaps(pFolderObject);
}


HRESULT CComponentImpl::OnPropertyChange(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

HRESULT CComponentImpl::OnUpdateView(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

void CComponentImpl::Enumerate(CFolderObject* pFolderObject, HSCOPEITEM pParent)
{
}



//////////////////////////////////////////////////////////////////////////
// CDomainSnapinAbout

CDomainSnapinAbout::CDomainSnapinAbout()
{
  m_uIdStrProvider = IDS_COMPANY;
  m_uIdStrVersion = IDS_SNAPIN_VERSION;
  m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
  m_uIdIconImage = IDI_DOMAIN;
  m_uIdBitmapSmallImage = IDB_DOMAIN_SMALL;
  m_uIdBitmapSmallImageOpen = IDB_DOMAIN_SMALL;
  m_uIdBitmapLargeImage = IDB_DOMAIN_LARGE;
  m_crImageMask = RGB(255,0,255);
}

////////////////////////////////////////////////////////////////////
// CHiddenWnd

const UINT CHiddenWnd::s_SheetCloseNotificationMessage =    WM_DSA_SHEET_CLOSE_NOTIFY;
const UINT CHiddenWnd::s_SheetCreateNotificationMessage =   WM_DSA_SHEET_CREATE_NOTIFY;

BOOL CHiddenWnd::Create()
{
  RECT rcPos;
  ZeroMemory(&rcPos, sizeof(RECT));
  HWND hWnd = CWindowImpl<CHiddenWnd>::Create( NULL, //HWND hWndParent, 
                      rcPos, //RECT& rcPos, 
                      NULL,  //LPCTSTR szWindowName = NULL, 
                      WS_POPUP,   //DWORD dwStyle = WS_CHILD | WS_VISIBLE, 
                      0x0,   //DWORD dwExStyle = 0, 
                      0      //UINT nID = 0 
                      );
  return hWnd != NULL;
}


LRESULT CHiddenWnd::OnSheetCloseNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  ASSERT(m_pCD != NULL);
  CFolderObject* pCookie = reinterpret_cast<CFolderObject*>(wParam);
  m_pCD->_OnSheetClose(pCookie);
  return 1;
}

LRESULT CHiddenWnd::OnSheetCreateNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
  ASSERT(m_pCD != NULL);
  PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo = reinterpret_cast<PDSA_SEC_PAGE_INFO>(wParam);
  ASSERT(pDsaSecondaryPageInfo != NULL);
  PWSTR pwzDC = (PWSTR)lParam;

  m_pCD->_OnSheetCreate(pDsaSecondaryPageInfo, pwzDC);

  ::LocalFree(pDsaSecondaryPageInfo);

   if (pwzDC && !IsBadReadPtr(pwzDC, sizeof(PWSTR)))
   {
      ::LocalFree(pwzDC);
   }

  return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\dataobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dataobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "domobj.h" 
#include "cdomain.h"
#include "dataobj.h"

#include <dsgetdc.h>
#include <lm.h>

extern "C" 
{
#include <lmapibuf.h>
}


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity

///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

// Clipboard formats that are required by the console
CLIPFORMAT CDataObject::m_cfNodeType       = (CLIPFORMAT)RegisterClipboardFormat(CCF_NODETYPE);
CLIPFORMAT CDataObject::m_cfNodeTypeString = (CLIPFORMAT)RegisterClipboardFormat(CCF_SZNODETYPE);  
CLIPFORMAT CDataObject::m_cfDisplayName    = (CLIPFORMAT)(CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME); 
CLIPFORMAT CDataObject::m_cfCoClass        = (CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_CLASSID);

// internal clipboard format
CLIPFORMAT CDataObject::m_cfInternal       = (CLIPFORMAT)RegisterClipboardFormat(CCF_DS_DOMAIN_TREE_SNAPIN_INTERNAL); 

// Property Page Clipboard formats
CLIPFORMAT CDataObject::m_cfDsObjectNames = 
                                (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
CLIPFORMAT CDataObject::m_cfDsDisplayOptions =
                        (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_DISPLAY_SPEC_OPTIONS);
CLIPFORMAT CDataObject::m_cfGetIPropSheetCfg =
                        (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_PROPSHEETCONFIG);

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations


STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString) 
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }

	return hr;
}

STDMETHODIMP CDataObject::GetData(LPFORMATETC pFormatEtc, LPSTGMEDIUM pMedium)
{
  if (IsBadWritePtr(pMedium, sizeof(STGMEDIUM)))
  {
    return E_INVALIDARG;
  }
  if (!(pFormatEtc->tymed & TYMED_HGLOBAL))
  {
    return DV_E_TYMED;
  }

  CComponentDataImpl* pCD = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
  if (pCD == NULL)
  {
    return E_FAIL;
  }

  if (pFormatEtc->cfFormat == m_cfDsObjectNames)
  {
    // Return the object name and class.
    CDomainObject* pDomainObject = reinterpret_cast<CDomainObject*>(m_internal.m_cookie);
    if (pDomainObject == NULL)
    {
      return E_INVALIDARG;
    }

    LPCWSTR lpszNamingContext = pDomainObject->GetNCName();
    LPCWSTR lpszClass = pDomainObject->GetClass();

    // build an LDAP path out of the DN
    CString strPath;
    if (pDomainObject->PdcAvailable())
    {
       strPath = L"LDAP://";
       strPath += pDomainObject->GetPDC();
       strPath += L"/";
       strPath += lpszNamingContext;
       TRACE(L"DomAdmin::CDataObject::GetData domain path: %s\n", (PCWSTR)strPath);
    }
    else
    {
      pCD->GetBasePathsInfo()->ComposeADsIPath(strPath, lpszNamingContext);
    }

    int cbPath  = sizeof(TCHAR) * (_tcslen(strPath) + 1);
    int cbClass = sizeof(TCHAR) * (_tcslen(lpszClass) + 1);
    int cbStruct = sizeof(DSOBJECTNAMES);

    LPDSOBJECTNAMES pDSObj;

    pDSObj = (LPDSOBJECTNAMES)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                          cbStruct + cbPath + cbClass);

    if (pDSObj == NULL)
    {
      return STG_E_MEDIUMFULL;
    }

    pDSObj->clsidNamespace = CLSID_DomainAdmin;
    pDSObj->cItems = 1;
    pDSObj->aObjects[0].dwFlags = pDomainObject->PdcAvailable() ? 0 : DSOBJECT_READONLYPAGES;
    pDSObj->aObjects[0].dwProviderFlags = 0;
    pDSObj->aObjects[0].offsetName = cbStruct;
    pDSObj->aObjects[0].offsetClass = cbStruct + cbPath;

    _tcscpy((LPTSTR)((BYTE *)pDSObj + cbStruct), strPath);
    _tcscpy((LPTSTR)((BYTE *)pDSObj + cbStruct + cbPath), lpszClass);

    pMedium->hGlobal = (HGLOBAL)pDSObj;
  }
  else if (pFormatEtc->cfFormat == m_cfDsDisplayOptions)
  {
    // Get the DSDISPLAYSPECOPTIONS structure.
    // Use the value cached in the component data.
    CComponentDataImpl* pCD = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    if (pCD != NULL)
    {
      PDSDISPLAYSPECOPTIONS pDsDisplaySpecOptions = 
          pCD->GetDsDisplaySpecOptionsCFHolder()->Get();
      pMedium->hGlobal = (HGLOBAL)pDsDisplaySpecOptions;
      if (pDsDisplaySpecOptions == NULL)
        return E_OUTOFMEMORY;
    }
    else
    {
      return E_FAIL;
    }
  }
  else if (pFormatEtc->cfFormat == m_cfGetIPropSheetCfg)
  {
	  // Added by JEFFJON 1/26/99
		PPROPSHEETCFG pSheetCfg;

		pSheetCfg = (PPROPSHEETCFG)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
															sizeof(PROPSHEETCFG));
		if (pSheetCfg == NULL)
		  {
			 return STG_E_MEDIUMFULL;
		  }

		pSheetCfg->lNotifyHandle = m_lNotifyHandle;
		pSheetCfg->hwndParentSheet = m_hwndParentSheet;
		pSheetCfg->hwndHidden = pCD->GetHiddenWindow();

		CFolderObject* pFolderObject = reinterpret_cast<CFolderObject*>(m_internal.m_cookie);
		pSheetCfg->wParamSheetClose = reinterpret_cast<WPARAM>(pFolderObject);

		pMedium->hGlobal = (HGLOBAL)pSheetCfg;
	}

  else
  {
      return DV_E_FORMATETC;
  }

  pMedium->tymed = TYMED_HGLOBAL;
  pMedium->pUnkForRelease = NULL;

  return S_OK;
}
    
STDMETHODIMP
CDataObject::SetData(FORMATETC * pFormatEtc, STGMEDIUM * pMedium,
                       BOOL fRelease)
{
    if (pFormatEtc->cfFormat == m_cfGetIPropSheetCfg)
    {
        if (!(pFormatEtc->tymed & TYMED_HGLOBAL))
        {
            return DV_E_TYMED;
        }

        PPROPSHEETCFG pSheetCfg = (PPROPSHEETCFG)pMedium->hGlobal;

        // don't overwrite existing data.

        if (0 == m_lNotifyHandle)
        {
          m_lNotifyHandle = pSheetCfg->lNotifyHandle;
        }

        if (NULL == m_hwndParentSheet)
        {
          m_hwndParentSheet = pSheetCfg->hwndParentSheet;
        }

        if (fRelease)
        {
            GlobalFree(pMedium->hGlobal);
        }
        return S_OK;
    }
    else
    {
        return DV_E_FORMATETC;
    }
}


STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
		    hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE', 
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    return Create(reinterpret_cast<const void*>(&cDefaultNodeType), sizeof(GUID), lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    return Create(cszDefaultNodeType, ((wcslen(cszDefaultNodeType)+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name from resource
    // Note - if this is not provided, the console will used the snap-in name

    CString szDispName;
    szDispName.LoadString(IDS_NODENAME);

    return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{

    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::CreateCoClassID
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
  CLSID CoClassID;
  CoClassID = CLSID_DomainAdmin;
  return Create(&CoClassID, sizeof(CLSID), lpMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\cdomain.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cdomain.h
//
//--------------------------------------------------------------------------


#ifndef _CDOMAIN_H
#define _CDOMAIN_H

#include "resource.h"       // main symbols

extern const CLSID CLSID_DomainSnapinAbout;

extern const CLSID CLSID_DomainAdmin;    // In-Proc server GUID
extern const GUID cDefaultNodeType;        // Main NodeType GUID on numeric format
extern const wchar_t*  cszDefaultNodeType; // Main NodeType GUID on string format

extern const wchar_t* CCF_DS_DOMAIN_TREE_SNAPIN_INTERNAL;

/////////////////////////////////////////////////////////////////////////////
// macros

#define FREE_INTERNAL(pInternal) \
    ASSERT(pInternal != NULL); \
    do { if (pInternal != NULL) \
        GlobalFree(pInternal); } \
    while(0);

/////////////////////////////////////////////////////////////////////////////
// forward declarations
class CDomainObject;
class CComponentImpl;
class CComponentDataImpl;
class CHiddenWnd;
class CDataObject;

/////////////////////////////////////////////////////////////////////////////
// constants

// Note - This is the offset in my image list that represents the folder
const DOMAIN_IMAGE_DEFAULT_IDX = 0;
const DOMAIN_IMAGE_IDX = 1;

/////////////////////////////////////////////////////////////////////////////
// global functions

void DialogContextHelp(DWORD* pTable, HELPINFO* pHelpInfo);


/////////////////////////////////////////////////////////////////////////////
// CInternalFormatCracker

class CInternalFormatCracker
{
public:
	CInternalFormatCracker(CComponentDataImpl* pCD)
	{
        m_pCD = pCD;
		m_pInternalFormat = NULL;
	}
	~CInternalFormatCracker()
	{
		if (m_pInternalFormat != NULL)
			FREE_INTERNAL(m_pInternalFormat);
	}

	BOOL Extract(LPDATAOBJECT lpDataObject);
	BOOL GetContext(LPDATAOBJECT pDataObject, // input
					CFolderObject** ppFolderObject, // output
					DATA_OBJECT_TYPES* pType		// output
					);
	INTERNAL* GetInternal()
	{
		return m_pInternalFormat;
	}

private:
	INTERNAL* m_pInternalFormat;
    CComponentDataImpl*		m_pCD;
};



/////////////////////////////////////////////////////////////////////////////
// CComponentDataImpl (i.e. scope pane side)

class CRootFolderObject; // fwd decl

class CComponentDataImpl:
    public IComponentData,
    public IExtendPropertySheet,
    public IExtendContextMenu,
    public ISnapinHelp2,
    public CComObjectRoot,
    public CComCoClass<CComponentDataImpl, &CLSID_DomainAdmin>
{

	friend class CComponentImpl;

BEGIN_COM_MAP(CComponentDataImpl)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
  COM_INTERFACE_ENTRY(ISnapinHelp2)
END_COM_MAP()

  DECLARE_REGISTRY_CLSID()

  friend class CComponentImpl;
	friend class CDataObject;

	CComponentDataImpl();
	HRESULT FinalConstruct();
	~CComponentDataImpl();
	void FinalRelease();	

public:
	// IComponentData interface members
	STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	STDMETHOD(Destroy)();
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
	STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
	STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

	// IExtendPropertySheet interface
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider,
								 LONG_PTR handle,
								 LPDATAOBJECT lpIDataObject);
	STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

	// IExtendContextMenu
public:
	STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
						  LPCONTEXTMENUCALLBACK pCallbackUnknown,
						  long *pInsertionAllowed);
	STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

  // ISnapinHelp2 interface members
  STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
  STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFile);

	// Notify handler declarations
private:
	HRESULT OnExpand(CFolderObject* pFolderObject, LPARAM arg, LPARAM param);
	HRESULT OnPropertyChange(LPARAM param);

#if DBG==1
public:
	ULONG InternalAddRef()
	{
	  return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
	  return CComObjectRoot::InternalRelease();
	}
#endif // DBG==1

public:
  MyBasePathsInfo* GetBasePathsInfo() { return &m_basePathsInfo;}
	CRootFolderObject*		GetRootFolder() { return &m_rootFolder;}
  CDsDisplaySpecOptionsCFHolder* GetDsDisplaySpecOptionsCFHolder()
          { return &m_DsDisplaySpecOptionsCFHolder;}

	HRESULT AddFolder(CFolderObject* pFolderObject,
									  HSCOPEITEM pParentScopeItem,
									  BOOL bHasChildren);
	HRESULT AddDomainIcon();
	HRESULT AddDomainIconToResultPane(LPIMAGELIST lpImageList);
	int GetDomainImageIndex();

  HRESULT GetMainWindow(HWND* phWnd) { return m_pConsole->GetMainWindow(phWnd);}

	// Scope item creation helpers
private:
	void EnumerateScopePane(CFolderObject* pFolderObject, HSCOPEITEM pParent);
	BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);

private:
	LPCONSOLENAMESPACE      m_pConsoleNameSpace;
	LPCONSOLE               m_pConsole;

	void HandleStandardVerbsHelper(CComponentImpl* pComponentImpl,
									LPCONSOLEVERB pConsoleVerb,
									BOOL bScope, BOOL bSelect,
									CFolderObject* pFolderObject,
                                    DATA_OBJECT_TYPES type);
	void OnRefreshVerbHandler(CFolderObject* pFolderObject, 
                            CComponentImpl* pComponentImpl,
                            BOOL bBindAgain=FALSE);


	void _OnSheetClose(CFolderObject* pCookie);
  void _OnSheetCreate(PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo, PWSTR pwzDC);

  // sheet API's
  void _SheetLockCookie(CFolderObject* pCookie);
  void _SheetUnlockCookie(CFolderObject* pCookie);

public:
  HWND GetHiddenWindow();

  CCookieSheetTable* GetCookieSheet() { return &m_sheetCookieTable; }
  void SetInit() { m_bInitSuccess = TRUE; }

protected:
  void _DeleteHiddenWnd();
  CHiddenWnd*      m_pHiddenWnd;

private:

  friend class CHiddenWnd;      // to access thread notification handlers

private:
	CRootFolderObject		m_rootFolder;		// root folder
  MyBasePathsInfo    m_basePathsInfo; // container of base path info
  CDsDisplaySpecOptionsCFHolder m_DsDisplaySpecOptionsCFHolder;  // cached clipbard format.

	HICON				m_hDomainIcon;
  BOOL        m_bInitSuccess;

  friend class CRootFolderObject;
 	CCookieSheetTable m_sheetCookieTable; // table of cookies having a sheet up
  CSecondaryPagesManager<CDomainObject> m_secondaryPagesManager;
};



/////////////////////////////////////////////////////////////////////////////
// CComponentImpl (i.e. result pane side)

class CComponentImpl :
    public IComponent,
    public IExtendContextMenu,
    public IResultDataCompare,
    public CComObjectRoot
{
public:
    CComponentImpl();
    ~CComponentImpl();

BEGIN_COM_MAP(CComponentImpl)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()

    friend class CDataObject;

// IComponent interface members
public:
	STDMETHOD(Initialize)(LPCONSOLE lpConsole);
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	STDMETHOD(Destroy)(MMC_COOKIE cookie);
	STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType,
							   long *pViewOptions);
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
						LPDATAOBJECT* ppDataObject);

	STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
	STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
	STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// Helpers for CComponentImpl
public:
    void SetIComponentData(CComponentDataImpl* pData);
	void SetSelection(CFolderObject* pSelectedFolderObject, DATA_OBJECT_TYPES selectedType)
	{
		m_pSelectedFolderObject = pSelectedFolderObject;
		m_selectedType = selectedType;
	}

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnShow(CFolderObject* pFolderObject, LPARAM arg, LPARAM param);
	HRESULT OnAddImages(CFolderObject* pFolderObject, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPDATAOBJECT lpDataObject);
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject);

// IExtendContextMenu
public:
	STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
							LPCONTEXTMENUCALLBACK pCallbackUnknown,
							long *pInsertionAllowed);
	STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// Helper functions
protected:
    BOOL IsEnumerating(LPDATAOBJECT lpDataObject);
    void Construct();
    void LoadResources();
    HRESULT InitializeHeaders(CFolderObject* pFolderObject);

    void Enumerate(CFolderObject* pFolderObject, HSCOPEITEM pParent);
	void Refresh(CFolderObject* pFolderObject);

// Result pane helpers
    HRESULT InitializeBitmaps(CFolderObject* pFolderObject);

// UI Helpers
    void HandleStandardVerbs(BOOL bScope, BOOL bSelect,
                            CFolderObject* pFolderObject, DATA_OBJECT_TYPES type);

// Interface pointers
protected:
    LPCONSOLE           m_pConsole;   // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;  // Result pane's header control interface
    LPCOMPONENTDATA     m_pComponentData;
    CComponentDataImpl* m_pCD;
    LPRESULTDATA        m_pResult;      // My interface pointer to the result pane
    LPIMAGELIST         m_pImageResult; // My interface pointer to the result pane image list
    LPCONSOLEVERB       m_pConsoleVerb; // pointer the console verb

// Header titles for each nodetype(s)
protected:
    CString m_column1;      // Name
    CString m_column2;      // Type

// state variables for this window
	CFolderObject*		m_pSelectedFolderObject;	// item selection (MMC_SELECT)
	DATA_OBJECT_TYPES	m_selectedType;				// matching m_pSelectedNode
};

inline void CComponentImpl::SetIComponentData(CComponentDataImpl* pData)
{
    ASSERT(pData);
    ASSERT(m_pCD == NULL);
    ASSERT(m_pComponentData == NULL);
    m_pCD = pData;
    LPUNKNOWN pUnk = pData->GetUnknown();
    HRESULT hr;

    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));

    ASSERT(hr == S_OK);
}


//////////////////////////////////////////////////////////////////////////
// CDomainSnapinAbout

class CDomainSnapinAbout :
	public CSnapinAbout,
	public CComCoClass<CDomainSnapinAbout, &CLSID_DomainSnapinAbout>

{
public:
  DECLARE_REGISTRY_CLSID()
    CDomainSnapinAbout();
};

////////////////////////////////////////////////////////////////////
// CHiddenWnd

class CHiddenWnd : public CWindowImpl<CHiddenWnd>
{
public:
  DECLARE_WND_CLASS(L"DSAHiddenWindow")

  static const UINT s_SheetCloseNotificationMessage;
  static const UINT s_SheetCreateNotificationMessage;

  CHiddenWnd(CComponentDataImpl* pCD)
  {
    ASSERT(pCD != NULL);
    m_pCD = pCD;
  }

	BOOL Create(); 	
	
  // message handlers
  LRESULT OnSheetCloseNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnSheetCreateNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);


  BEGIN_MSG_MAP(CHiddenWnd)
    MESSAGE_HANDLER( CHiddenWnd::s_SheetCloseNotificationMessage, OnSheetCloseNotification )
    MESSAGE_HANDLER( CHiddenWnd::s_SheetCreateNotificationMessage, OnSheetCreateNotification )
  END_MSG_MAP()

private:
  CComponentDataImpl* m_pCD;
};


#endif // _CDOMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\dbg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dbg.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_DSA_TRACE) || defined(_USE_DSA_ASSERT) || defined(_USE_DSA_TIMER)

UINT GetInfoFromIniFile(LPCWSTR lpszSection, LPCWSTR lpszKey, INT nDefault = 0)
{
  static LPCWSTR lpszFile = L"\\system32\\domadmin.ini";

  WCHAR szFilePath[2*MAX_PATH];
	UINT nLen = ::GetSystemWindowsDirectory(szFilePath, 2*MAX_PATH);
	if (nLen == 0)
		return nDefault;

  wcscat(szFilePath, lpszFile);
  return ::GetPrivateProfileInt(lpszSection, lpszKey, nDefault, szFilePath);
}
#endif


#if defined(_USE_DSA_TRACE)

#ifdef DEBUG_DSA
DWORD g_dwTrace = 0x1;
#else
DWORD g_dwTrace = ::GetInfoFromIniFile(L"Debug", L"Trace");
#endif

void DSATrace(LPCTSTR lpszFormat, ...)
{
  if (g_dwTrace == 0)
    return;

	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512];

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), lpszFormat, args);

	// was there an error? was the expanded string too long?
	ASSERT(nBuf >= 0);
  ::OutputDebugString(szBuffer);

	va_end(args);
}

#endif // defined(_USE_DSA_TRACE)

#if defined(_USE_DSA_ASSERT)

DWORD g_dwAssert = ::GetInfoFromIniFile(L"Debug", L"Assert");

BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine)
{
  if (g_dwAssert == 0)
    return FALSE;

  WCHAR szMessage[_MAX_PATH*2];

	// assume the debugger or auxiliary port
	wsprintf(szMessage, _T("Assertion Failed: File %hs, Line %d\n"),
		lpszFileName, nLine);
	OutputDebugString(szMessage);

	// display the assert
	int nCode = ::MessageBox(NULL, szMessage, _T("Assertion Failed!"),
		MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

  OutputDebugString(L"after message box\n");
	if (nCode == IDIGNORE)
  {
		return FALSE;   // ignore
  }

	if (nCode == IDRETRY)
  {
		return TRUE;    // will cause DebugBreak
  }

	abort();     // should not return 
	return TRUE;

}
#endif // _USE_DSA_ASSERT

#if defined(_USE_DSA_TIMER)

#ifdef TIMER_DSA
DWORD g_dwTimer = 0x1;
#else
DWORD g_dwTimer = ::GetInfoFromIniFile(L"Debug", L"Timer");
#endif

DWORD StartTicks = ::GetTickCount();
DWORD LastTicks = 0;

void DSATimer(LPCTSTR lpszFormat, ...)
{
  if (g_dwTimer == 0)
    return;

	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512], szBuffer2[512];

        DWORD CurrentTicks = GetTickCount() - StartTicks;
        DWORD Interval = CurrentTicks - LastTicks;
        LastTicks = CurrentTicks;

        nBuf = swprintf(szBuffer2,
                           L"%d, (%d): %ws", CurrentTicks,
							Interval, lpszFormat);
	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), 
                           szBuffer2, 
                           args);

	// was there an error? was the expanded string too long?
	ASSERT(nBuf >= 0);
  ::OutputDebugString(szBuffer);

	va_end(args);
}
#endif // _USE_DSA_TIMER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\domain.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       domain.h
//
//--------------------------------------------------------------------------


#ifndef _DOMAIN_H
#define _DOMAIN_H

///////////////////////////////////////////////////////////////////////
// CDsUiWizDLL

class CDsUiWizDLL
{
public:
	CDsUiWizDLL();
	~CDsUiWizDLL();
	
	BOOL Load();

	HRESULT TrustWizard(HWND hWndParent = NULL, LPCWSTR lpsz = NULL);

private:
	HMODULE m_hLibrary;
	FARPROC m_pfFunction;

};

#endif // _DOMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\domobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domobj.h
//
//--------------------------------------------------------------------------



#ifndef _DOMOBJ_H
#define _DOMOBJ_H

///////////////////////////////////////////////////////////////////////
// global helper functions

void ReportError(HWND hWnd, UINT nMsgID, HRESULT hr);

///////////////////////////////////////////////////////////////////////
// Forward declarations

class CComponentDataImpl;
class CFolderObject;
class CCookieSheetTable;
class CDomainObject;

///////////////////////////////////////////////////////////////////////
// CDomainTreeBrowser

class CDomainTreeBrowser
{
public:
  CDomainTreeBrowser()
  {
    m_pDomains = NULL;
  }
  ~CDomainTreeBrowser()
  {
    _Reset();
  }

  BOOL HasData() { return m_pDomains != NULL; }
  HRESULT Bind(MyBasePathsInfo* pInfo);
	HRESULT GetData();

  PDOMAIN_TREE	GetDomainTree()
  {
    ASSERT(m_pDomains != NULL);
    return m_pDomains;
  }


private:
	CComPtr<IDsBrowseDomainTree>	m_spIDsBrowseDomainTree; // interface pointer for browsing
  CComPtr<IDirectorySearch>   m_spIDirectorySearch; //

	PDOMAIN_TREE			m_pDomains;			// pointer to the domain info to from backend


  void _Reset()
  {
    _FreeDomains();
    m_spIDsBrowseDomainTree = NULL;
    m_spIDirectorySearch = NULL;
  }
  void _FreeDomains()
  {
    if (m_pDomains == NULL)
      return;
    if (m_spIDsBrowseDomainTree != NULL)
      m_spIDsBrowseDomainTree->FreeDomains(&m_pDomains);
    else
      ::LocalFree(m_pDomains);
    m_pDomains = NULL;
  }

};


////////////////////////////////////////////////////////////////////
// CCookieTableBase

class CCookieTableBase
{
public:
  CCookieTableBase();
  ~CCookieTableBase();

  void Add(CFolderObject* pCookie);
  BOOL Remove(CFolderObject* pCookie);
  BOOL IsPresent(CFolderObject* pCookie);
  void Reset();
  UINT GetCount();

protected:
  UINT m_nEntries;
  CFolderObject** m_pCookieArr;
};

////////////////////////////////////////////////////////////////////
// CCookieSheetTable

class CCookieSheetTable : public CCookieTableBase
{
public:
  void BringToForeground(CFolderObject* pCookie, CComponentDataImpl* pCD);
};




///////////////////////////////////////////////////////////////////////
// CFolderObject

typedef CList<CFolderObject*, CFolderObject*> CFolderObjectList;

class CFolderObject
{
public:
	CFolderObject()
	{
		m_nImage = 0;
		m_ID = 0;
		m_pParentFolder = NULL;
		m_nSheetLockCount = 0;
	}
	virtual ~CFolderObject();

	void SetScopeID(HSCOPEITEM ID) { m_ID = ID; }
	HSCOPEITEM GetScopeID() { return m_ID; }
	void SetImageIndex(int nImage) { m_nImage = nImage;}
	int GetImageIndex() { return m_nImage;}
	virtual LPCTSTR GetDisplayString(int nIndex) { return L"";}
  virtual HRESULT OnCommand(CComponentDataImpl* pCD, long nCommandID) { return S_OK;}
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              long *pInsertionAllowed) { return S_OK;}
	BOOL AddChild(CFolderObject* pChildFolderObject);
	void RemoveAllChildren();

	void SetParentFolder(CFolderObject* pParentFolder) { m_pParentFolder = pParentFolder; }
	CFolderObject* GetParentFolder() { return m_pParentFolder; }

	void IncrementSheetLockCount();
	void DecrementSheetLockCount();
	BOOL IsSheetLocked() { return (m_nSheetLockCount > 0); }

	BOOL _WarningOnSheetsUp(CComponentDataImpl* pCD);

private:
	HSCOPEITEM m_ID;				// scope item ID for this folder
	int m_nImage;					// index if the image for folder
	CFolderObjectList m_childList;  // list of children

	CFolderObject* m_pParentFolder;
	
	LONG m_nSheetLockCount; // keeps track if a node has been locked by a property sheet  

};


///////////////////////////////////////////////////////////////////////
// CRootFolderObject

class CRootFolderObject : public CFolderObject
{
public:
	CRootFolderObject(CComponentDataImpl* pCD);
	virtual ~CRootFolderObject()  { }

	BOOL HasData() { return m_domainTreeBrowser.HasData(); }
  HRESULT Bind();
  HRESULT GetData();

	HRESULT EnumerateRootFolder(CComponentDataImpl* pComponentData);
	HRESULT EnumerateFolder(CFolderObject* pFolderObject,
							HSCOPEITEM pParent,
							CComponentDataImpl* pComponentData);
  virtual HRESULT OnCommand(CComponentDataImpl* pCD, long nCommandID);
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                            long *pInsertionAllowed);

  HRESULT OnAddPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle);

  CDomainObject* GetEnterpriseRootNode(void) {return m_pEnterpriseRoot;};

private:
  //void OnDomainTrustWizard();
  void OnRetarget();
  void OnEditFSMO();

	CComponentDataImpl*		m_pCD;					// back pointer to snapin
  CDomainTreeBrowser  m_domainTreeBrowser;
  CDomainObject*  m_pEnterpriseRoot;
};



///////////////////////////////////////////////////////////////////////
// CDomainObject

class CDomainObject : public CFolderObject
{
  friend class CRootFolderObject;

public:
  CDomainObject() : m_pDomainDescription(NULL), _fPdcAvailable(false)
  {
    TRACE(L"CDomainObject CTOR (0x%08x)\n", this);
    m_bSecondary = FALSE;
  };

  virtual ~CDomainObject();
  virtual LPCTSTR GetDisplayString(int nIndex);
  virtual HRESULT OnCommand(CComponentDataImpl* pCD, long nCommandID);
  virtual HRESULT OnAddMenuItems(LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                 long *pInsertionAllowed);

  // Interface
public:

  // string access functions
  LPCWSTR GetDomainName() { return GetDescriptionPtr()->pszName; };
  LPCWSTR GetNCName() { return GetDescriptionPtr()->pszNCName; };
  LPCWSTR GetClass () { return GetDescriptionPtr()->pszObjectClass; };

  DOMAIN_DESC* GetDescriptionPtr()
        { ASSERT(m_pDomainDescription != NULL); return m_pDomainDescription; };

  void InitializeForSecondaryPage(LPCWSTR pszNCName,
                                  LPCWSTR pszObjectClass,
                                  int nImage);

  void   SetPDC(PCWSTR pwzPDC) {_strPDC = pwzPDC;};
  PCWSTR GetPDC(void) {return _strPDC;};
  void   SetPdcAvailable(bool fAvail);
  bool   PdcAvailable(void) {return _fPdcAvailable;};

  // Implementation
private:
  void Initialize(DOMAIN_DESC* pDomainDescription,
                  int nImage,
                  BOOL bHasChildren = FALSE);

  void OnManage(CComponentDataImpl* pCD);
  void OnDomainTrustWizard(CComponentDataImpl* pCD);

  // Attributes
private:

  DOMAIN_DESC * m_pDomainDescription; // pointer to the data in the blob
  BOOL m_bSecondary;  // from a secondary page
  CString _strPDC;
  bool    _fPdcAvailable;
};


#endif // _DOMOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\helparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       helparr.h
//
//--------------------------------------------------------------------------

#define	IDH_ADD_BTN	20001077
#define	IDH_CHANGE_FSMO_TREE	20001052
#define	IDH_DELETE_BTN	20001078
#define	IDH_EDIT	20001075
#define	IDH_EDIT_CURRENT_DC_TREE	20001025
#define	IDH_EDIT_CURRENT_DC_TREE2	20001050
#define	IDH_EDIT_CURRENT_FSMO_DC_TREE	20001051
#define	IDH_EDIT_DC_TREE	20001028
#define	IDH_LIST	20001076
#define	IDH_RADIO_ANY_TREE	20001026
#define	IDH_RADIO_SPECIFY_TREE	20001027


const DWORD g_aHelpIDs_IDD_UPN_SUFFIX[]=
{
	IDC_DELETE_BTN,IDH_DELETE_BTN,
	IDC_ADD_BTN,IDH_ADD_BTN,
	IDC_LIST,IDH_LIST,
	IDC_EDIT,IDH_EDIT,
	0,0
};


/*
REVIEW_MARCOC: obsolete, need to remove from the HELP ID's

const DWORD g_aHelpIDs_TREE_IDD_CHANGE_DC[]=
{
	IDC_EDIT_DC,IDH_EDIT_DC_TREE,
	IDC_RADIO_SPECIFY,IDH_RADIO_SPECIFY_TREE,
	IDC_RADIO_ANY,IDH_RADIO_ANY_TREE,
	IDC_EDIT_CURRENT_DC,IDH_EDIT_CURRENT_DC_TREE,
	0, 0
};
*/

const DWORD g_aHelpIDs_TREE_IDD_EDIT_FSMO[]=
{
	IDC_CHANGE_FSMO,IDH_CHANGE_FSMO_TREE,
	IDC_EDIT_CURRENT_FSMO_DC,IDH_EDIT_CURRENT_FSMO_DC_TREE,
	IDC_EDIT_CURRENT_DC,IDH_EDIT_CURRENT_DC_TREE2,	
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\domobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domobj.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
#include "domobj.h"
#include "domobjui.h"
#include "cdomain.h"
#include "domain.h"
#include "proppage.h"
#include "notify.h"





#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


///////////////////////////////////////////////////////////////////////
// global helper functions




int _MessageBox(HWND hWnd,          // handle to owner window
                LPCTSTR lpText,     // pointer to text in message box
                UINT uType)         // style of message box
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CString szCaption;
  szCaption.LoadString(AFX_IDS_APP_TITLE);
  return ::MessageBox(hWnd, lpText, szCaption, uType);
}
 






void ReportError(HWND hWnd, UINT nMsgID, HRESULT hr)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  LPTSTR ptzSysMsg = NULL;
  int cch = 0;
  int retval = MB_OK;

  // load message for this HRESULT
  cch = cchLoadHrMsg( hr, &ptzSysMsg, TRUE );
  
  CString szError;
  if (cch == 0)
  {
    // could not get a message string, format the raw hr value
    CString s;
    s.LoadString(IDS_FAILURE_UNK);
    szError.Format((LPCWSTR)s, hr);
  }
  else
  {
    szError = ptzSysMsg;
  }

  // format message string with
  CString szFmt;
  szFmt.LoadString(nMsgID);
  CString szMsg;
  szMsg.Format((LPCWSTR)szFmt, (LPCWSTR)szError);
  _MessageBox(hWnd, szMsg, MB_OK|MB_ICONERROR);

  // cleanup
  if (NULL != ptzSysMsg)
      LocalFree(ptzSysMsg);
}



///////////////////////////////////////////////////////////////////////

//CDsUiWizDLL g_dsUiWizDLL;

enum
{
    // Identifiers for each of the commands to be inserted into the context menu.
    IDM_MANAGE,
    IDM_TRUST_WIZ,
    IDM_RETARGET,
    IDM_EDIT_FSMO,
    IDM_DOMAIN_VERSION,
    IDM_FOREST_VERSION
};


HRESULT _AddMenuItemHelper(IContextMenuCallback* pIContextMenuCallback,
                     UINT nResourceID, // contains text and status text seperated by '\n'
                     long lCommandID,
                     long lInsertionPointID,
                     long fFlags = 0,
                     long fSpecialFlags = 0)
{
    ASSERT( pIContextMenuCallback != NULL );

    // load the resource
    CString strText;
    strText.LoadString(nResourceID);
    ASSERT( !strText.IsEmpty() );

    // split the resource into the menu text and status text
    CString strStatusText;
    int iSeparator = strText.Find(_T('\n'));
    if (0 > iSeparator)
    {
        ASSERT( FALSE );
        strStatusText = strText;
    }
    else
    {
        strStatusText = strText.Right( strText.GetLength()-(iSeparator+1) );
        strText = strText.Left( iSeparator );
    }

    // add the menu item
    USES_CONVERSION;
    CONTEXTMENUITEM contextmenuitem;
    ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
    contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strText));
    contextmenuitem.strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strStatusText));
    contextmenuitem.lCommandID = lCommandID;
    contextmenuitem.lInsertionPointID = lInsertionPointID;
    contextmenuitem.fFlags = fFlags;
    contextmenuitem.fSpecialFlags = fSpecialFlags;
    HRESULT hr = pIContextMenuCallback->AddItem( &contextmenuitem );
    ASSERT(hr == S_OK);
  
  return hr;
}


///////////////////////////////////////////////////////////////////////
// CDomainTreeBrowser

HRESULT CDomainTreeBrowser::Bind(MyBasePathsInfo* pInfo)
{
  TRACE(L"CDomainTreeBrowser::Bind()\n");

  ASSERT(pInfo != NULL);

  _Reset();
  HRESULT hr = S_OK;

  // create a browse object
  hr = ::CoCreateInstance(CLSID_DsDomainTreeBrowser,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDsBrowseDomainTree,
            (LPVOID*)&m_spIDsBrowseDomainTree);
  if (FAILED(hr))
  {
    TRACE(L"CoCreateInstance(CLSID_DsDomainTreeBrowser, ...) failed with hr = 0x%x\n");
     goto error;
  }

  // set the target computer
  hr = m_spIDsBrowseDomainTree->SetComputer(pInfo->GetServerName(), NULL, NULL);
  TRACE(L"m_spIDsBrowseDomainTree->SetComputer(%s, NULL, NULL) returned hr = 0x%x\n", 
                    pInfo->GetServerName(), hr);

  if (FAILED(hr))
     goto error;

  ASSERT(SUCCEEDED(hr));
  return hr; // all was fine

error:
  // things went wrong, clear all
  _Reset();
  return hr;
}


HRESULT CDomainTreeBrowser::GetData()
{
  ASSERT(m_spIDsBrowseDomainTree != NULL);

   HRESULT hr = S_OK;

   PDOMAIN_TREE pNewDomains = NULL;
   m_spIDsBrowseDomainTree->FlushCachedDomains();
   DWORD dwFlags = DBDTF_RETURNFQDN;
   hr = m_spIDsBrowseDomainTree->GetDomains(&pNewDomains, dwFlags);
   TRACE(L"m_spIDsBrowseDomainTree->GetDomains(...) returned hr = 0x%x\n", hr);

   if (SUCCEEDED(hr) && (pNewDomains != NULL))
   {
      _FreeDomains();
      m_pDomains = pNewDomains;
   }
   return hr;
}


///////////////////////////////////////////////////////////////////////
// CFolderObject

CFolderObject::~CFolderObject()
{
   RemoveAllChildren();
}


BOOL CFolderObject::AddChild(CFolderObject* pChildFolderObject)
{
   return (m_childList.AddTail(pChildFolderObject) != NULL);
}

void CFolderObject::RemoveAllChildren()
{
   while (!m_childList.IsEmpty())
      delete m_childList.RemoveHead();
}

void CFolderObject::IncrementSheetLockCount() 
{
   ++m_nSheetLockCount;
   if (m_pParentFolder != NULL)
      m_pParentFolder->IncrementSheetLockCount();
}

void CFolderObject::DecrementSheetLockCount() 
{
  ASSERT(m_nSheetLockCount > 0);
   --m_nSheetLockCount; 
   if (m_pParentFolder != NULL) 
      m_pParentFolder->DecrementSheetLockCount();
}

BOOL CFolderObject::_WarningOnSheetsUp(CComponentDataImpl* pCD)
{
   if (!IsSheetLocked()) 
      return FALSE; // no warning, all is cool

   // warning to user that oeration cannot be performed
   AfxMessageBox(IDS_SHEETS_UP_DELETE, MB_OK);
      ASSERT(FALSE);

   // need to bring sheets on the foreground
   pCD->GetCookieSheet()->BringToForeground(this, pCD);

   return TRUE;
}



///////////////////////////////////////////////////////////////////////
// CRootFolderObject

CRootFolderObject::CRootFolderObject(CComponentDataImpl* pCD) :
   m_pEnterpriseRoot(NULL)
{
	m_pCD = pCD;
}


HRESULT CRootFolderObject::Bind() 
{ 
  return m_domainTreeBrowser.Bind(m_pCD->GetBasePathsInfo()); 
}



HRESULT CRootFolderObject::GetData()
{
   HRESULT hr = m_domainTreeBrowser.GetData();
   if (FAILED(hr))
      return hr;

   // firs time, try to load the domain icon
   VERIFY(SUCCEEDED(m_pCD->AddDomainIcon()));

   RemoveAllChildren(); // clear the UI structures
   return hr;
}


HRESULT CRootFolderObject::EnumerateRootFolder(CComponentDataImpl* pComponentData)
{
   TRACE(L"CRootFolderObject::EnumerateRootFolder()\n");
   if (!m_domainTreeBrowser.HasData())
   {
      TRACE(L"m_domainTreeBrowser.HasData() == FALSE \n");
      return S_OK;
   }

   HRESULT hr = S_OK;
   MyBasePathsInfo * pBPI;

   //
   // Get the enterprise root domain DN from the RootDSE.
   //
   pBPI = pComponentData->GetBasePathsInfo();
   if (!pBPI)
   {
      ASSERT(FALSE);
      return E_FAIL;
   }

   PCWSTR pwzRoot = pBPI->GetRootDomainNamingContext();

   TRACE(L"Root path: %ws\n", pwzRoot);
   PDOMAIN_DESC pRootDomain = NULL;

   //
   // Insert the root nodes. First insert the enterprise root.
   //
   for (pRootDomain = m_domainTreeBrowser.GetDomainTree()->aDomains; pRootDomain; 
        pRootDomain = pRootDomain->pdNextSibling)
   {
      if (_wcsicmp(pwzRoot, pRootDomain->pszNCName) == 0)
      {
         TRACE(L"Enterprise root found!\n");
         CDomainObject* pDomain = new CDomainObject;
         if (!pDomain)
         {
            ASSERT(FALSE);
            return E_OUTOFMEMORY;
         }
         pDomain->Initialize(pRootDomain, m_pCD->GetDomainImageIndex());
         AddChild(pDomain);
         pDomain->SetParentFolder(this);

         hr = pComponentData->AddFolder(pDomain, GetScopeID(), TRUE); // has children
         if (FAILED(hr))
         {
            return hr;
         }
         //
         // Create a non-refcounted reference to the enterprise root domain node.
         // Do NOT call delete on the m_pEnterpriseRoot pointer!
         //
         m_pEnterpriseRoot = pDomain;

         break;
      }
   }

   //
   // Now insert the rest of the root nodes.
   //
   for (pRootDomain = m_domainTreeBrowser.GetDomainTree()->aDomains; pRootDomain; 
        pRootDomain = pRootDomain->pdNextSibling)
   {
      if (_wcsicmp(pwzRoot, pRootDomain->pszNCName) == 0)
      {
         // Root already inserted.
         continue;
      }
      CDomainObject* pDomain = new CDomainObject;
      if (!pDomain)
      {
         ASSERT(FALSE);
         return E_OUTOFMEMORY;
      }
      pDomain->Initialize(pRootDomain, m_pCD->GetDomainImageIndex());
      AddChild(pDomain);
      pDomain->SetParentFolder(this);

      hr = pComponentData->AddFolder(pDomain, GetScopeID(), TRUE); // has children
      if (FAILED(hr))
      {
         break;
      }
   }

   return hr;
}

HRESULT
CRootFolderObject::EnumerateFolder(CFolderObject* pFolderObject, 
                                   HSCOPEITEM pParent,
                                   CComponentDataImpl* pComponentData)
{
	HRESULT hr = E_FAIL;
	if (!m_domainTreeBrowser.HasData())
		return hr;
				
	ASSERT(pFolderObject != NULL);
	ASSERT(pFolderObject->GetScopeID() == pParent);

	CDomainObject* pDomainObject = dynamic_cast<CDomainObject*>(pFolderObject);
	if (pDomainObject == NULL)
		return hr;

	DOMAIN_DESC* pDomainDesc = pDomainObject->GetDescriptionPtr();

	if (pDomainDesc == NULL)
		return hr;

	if (pDomainDesc->pdChildList == NULL)
		return S_OK;

	for (DOMAIN_DESC* pChild = pDomainDesc->pdChildList; pChild; 
						pChild = pChild->pdNextSibling)
	{
		CDomainObject* pDomain = new CDomainObject;
		pDomain->Initialize(pChild,
					   m_pCD->GetDomainImageIndex());
		hr = pComponentData->AddFolder(pDomain, pDomainObject->GetScopeID(), 
								TRUE); // has children
		pFolderObject->AddChild(pDomain);
		pDomain->SetParentFolder(pFolderObject);

		if (FAILED(hr))
		  break;
	} // for
	return hr;
}


HRESULT CRootFolderObject::OnAddMenuItems(LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              long *pInsertionAllowed)
{
  HRESULT hr = S_OK;
  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
  {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
/*
    if (g_dsUiWizDLL.Load())
    {
        return _AddMenuItemHelper(pContextMenuCallback, IDS_COMMAND_TRUST_WIZ, IDM_TRUST_WIZ, CCM_INSERTIONPOINTID_PRIMARY_TOP);
    }
*/
    _AddMenuItemHelper(pContextMenuCallback, IDS_COMMAND_RETARGET, IDM_RETARGET, CCM_INSERTIONPOINTID_PRIMARY_TOP);
    _AddMenuItemHelper(pContextMenuCallback, IDS_COMMAND_EDIT_FSMO, IDM_EDIT_FSMO, CCM_INSERTIONPOINTID_PRIMARY_TOP);
    _AddMenuItemHelper(pContextMenuCallback, IDS_COMMAND_FOREST_VER, IDM_FOREST_VERSION, CCM_INSERTIONPOINTID_PRIMARY_TOP);
  }
  return hr;
}



HRESULT CRootFolderObject::OnCommand(CComponentDataImpl* pCD, long nCommandID)
{
    HRESULT hr = S_OK;
    CString strConfig, strPartitions, strSchema;

    switch (nCommandID)
    {
    //case IDM_TRUST_WIZ:
    //    OnDomainTrustWizard();
    //    break;
    case IDM_RETARGET:
        OnRetarget();
        break;
    case IDM_EDIT_FSMO:
        OnEditFSMO();
        break;
    case IDM_FOREST_VERSION:
        MyBasePathsInfo * pBPI;
        pBPI = pCD->GetBasePathsInfo();
        if (!pBPI)
        {
           ASSERT(FALSE);
           return E_FAIL;
        }
        pBPI->GetConfigPath(strConfig);
        pBPI->GetPartitionsPath(strPartitions);
        pBPI->GetSchemaPath(strSchema);
        HWND hWndParent;
        pCD->GetMainWindow(&hWndParent);
        CDomainObject* pRoot;
        pRoot = GetEnterpriseRootNode();
        if (!pRoot)
        {
           ASSERT(FALSE);
           return E_FAIL;
        }
        DSPROP_ForestVersionDlg(strConfig, strPartitions, strSchema,
                                pRoot->GetDomainName(), hWndParent);
        break;
    default:
      ASSERT(FALSE); // Unknown command!
      hr = E_FAIL;
    }
    return hr;  
}


//void CRootFolderObject::OnDomainTrustWizard()
//{
    //g_dsUiWizDLL.TrustWizard();
//}


void CRootFolderObject::OnRetarget()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (_WarningOnSheetsUp(m_pCD))
		return;

  HWND hWndParent;
  m_pCD->GetMainWindow(&hWndParent);

  CComPtr<IDsAdminChooseDC> spIDsAdminChooseDC;

  CComBSTR bstrSelectedDC;

  HRESULT hr = ::CoCreateInstance(CLSID_DsAdminChooseDCObj,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IDsAdminChooseDC,
                        (void **) &spIDsAdminChooseDC);
  if (FAILED(hr))
  {
    ::ReportError(hWndParent, IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
    return;
  }

  // invoke the dialog
  hr = spIDsAdminChooseDC->InvokeDialog(hWndParent,
                                        m_pCD->GetBasePathsInfo()->GetDomainName(),
                                        m_pCD->GetBasePathsInfo()->GetServerName(),
                                        0x0,
                                        &bstrSelectedDC);
  
  if (SUCCEEDED(hr) && (hr != S_FALSE))
  {
    
    TRACE(L"CChangeDCDialog returned IDOK, with dlg.GetNewDCName() = %s\n", bstrSelectedDC);

    // attempt to bind
    MyBasePathsInfo tempBasePathsInfo;

    {
      CWaitCursor wait;
      hr = tempBasePathsInfo.InitFromName(bstrSelectedDC);
    }
    TRACE(L"tempBasePathsInfo.GetServerName() == %s\n", tempBasePathsInfo.GetServerName());
    if (FAILED(hr))
    {
      TRACE(L"tempBasePathsInfo.InitFromName(bstrSelectedDC) failed with hr = 0x%x\n", hr);
			ReportError(hWndParent, IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
      // TODO: error handling, change icon
    }
    else
    {
      m_pCD->GetBasePathsInfo()->InitFromInfo(&tempBasePathsInfo);
      m_pCD->SetInit();
      TRACE(L"m_pCD->GetBasePathsInfo()->GetServerName() == %s\n", m_pCD->GetBasePathsInfo()->GetServerName());
      hr = m_pCD->GetDsDisplaySpecOptionsCFHolder()->Init(m_pCD->GetBasePathsInfo());
      ASSERT(SUCCEEDED(hr));

      {
        CWaitCursor wait;
        m_pCD->OnRefreshVerbHandler(this, NULL, TRUE /*bBindAgain */);
      }

    } // if
  } // if

}



void CRootFolderObject::OnEditFSMO()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  HWND hWndParent;
  m_pCD->GetMainWindow(&hWndParent);

  CComPtr<IDisplayHelp> spIDisplayHelp;
  HRESULT hr = m_pCD->m_pConsole->QueryInterface (IID_IDisplayHelp, 
                            (void **)&spIDisplayHelp);
  ASSERT(spIDisplayHelp != NULL);

  CEditFsmoDialog dlg(m_pCD->GetBasePathsInfo(), hWndParent, spIDisplayHelp);
  dlg.DoModal();
}



HRESULT CRootFolderObject::OnAddPages(LPPROPERTYSHEETCALLBACK lpProvider, 
    LONG_PTR handle) 
{ 
  CUpnSuffixPropertyPage* pPage = new CUpnSuffixPropertyPage();
  HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(&pPage->m_psp);
  return lpProvider->AddPage(hPage);
}


///////////////////////////////////////////////////////////////////////
// CDomainObject


CDomainObject::~CDomainObject()
{
  if (m_bSecondary)
  {
    ASSERT(m_pDomainDescription != NULL);
    ::free(m_pDomainDescription);
  }
}


LPCTSTR CDomainObject::GetDisplayString(int nCol)
{
	switch (nCol)
	{
	case 0:
		return GetDomainName();
	case 1:
		return GetClass();
	default:
		ASSERT(FALSE);
	} // switch
	return _T("");
}



void CDomainObject::Initialize(DOMAIN_DESC* pDomainDescription,
                           int nImage,
                           BOOL bHasChildren)
{
	SetImageIndex(nImage);

  // save pointer to domain description in DOMAIN_TREE
  m_pDomainDescription = pDomainDescription;
}


void CDomainObject::InitializeForSecondaryPage(LPCWSTR pszNCName,
                                  LPCWSTR pszObjectClass,
                                  int nImage)
{
  ASSERT(pszNCName != NULL);
  ASSERT(pszObjectClass != NULL);

  SetImageIndex(nImage);

  // standalone node, need to build a dummy DOMAIN_DESC
  m_bSecondary = TRUE;

  // allocate and zero memory
  int nNCNameLen = lstrlen(pszNCName)+1;
  int nObjectClassLen = lstrlen(pszObjectClass)+1;

  int nByteLen = sizeof(DOMAIN_DESC) + sizeof(WCHAR)*(nNCNameLen + nObjectClassLen);

  m_pDomainDescription = (DOMAIN_DESC*)::malloc(nByteLen);
  ASSERT(m_pDomainDescription);
  if (!m_pDomainDescription)
  {
    return;
  }
  ::ZeroMemory(m_pDomainDescription, nByteLen);

  // copy the strings
  m_pDomainDescription->pszNCName = (WCHAR*) (((BYTE*)m_pDomainDescription) + sizeof(DOMAIN_DESC));
  wcscpy(m_pDomainDescription->pszNCName, pszNCName); 

  m_pDomainDescription->pszObjectClass = (WCHAR*) (((BYTE*)m_pDomainDescription->pszNCName) + sizeof(WCHAR)*nNCNameLen);
  wcscpy(m_pDomainDescription->pszObjectClass, pszObjectClass); 
}




HRESULT CDomainObject::OnAddMenuItems(LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                              long *pInsertionAllowed)
{
  HRESULT hr = S_OK;
  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
  {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    hr = _AddMenuItemHelper(pContextMenuCallback, IDS_COMMAND_MANAGE, IDM_MANAGE, CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if (FAILED(hr))
        return hr;
    hr = _AddMenuItemHelper(pContextMenuCallback, IDS_COMMAND_DOMAIN_VER, IDM_DOMAIN_VERSION, CCM_INSERTIONPOINTID_PRIMARY_TOP);
    if (FAILED(hr))
        return hr;
  }
  return hr;
}



HRESULT CDomainObject::OnCommand(CComponentDataImpl* pCD, long nCommandID)
{
    HRESULT hr = S_OK;
    CString strPath;

    switch (nCommandID)
    {
    case IDM_MANAGE:
        OnManage(pCD);
        break;
    //case IDM_TRUST_WIZ:
    //    OnDomainTrustWizard(pCD);
    //    break;
    case IDM_DOMAIN_VERSION:
        HWND hWndParent;
        MyBasePathsInfo * pBPI;
        pBPI = pCD->GetBasePathsInfo();
        if (!pBPI)
        {
           ASSERT(FALSE);
           return E_FAIL;
        }
        pCD->GetMainWindow(&hWndParent);
        // build an LDAP path out of the DN
        if (PdcAvailable())
        {
            strPath = L"LDAP://";
            strPath += GetPDC();
            strPath += L"/";
            strPath += GetNCName();
        }
        else
        {
            pBPI->ComposeADsIPath(strPath, GetNCName());
        }
        DSPROP_DomainVersionDlg(strPath, GetDomainName(), hWndParent);
        break;
    default:
      ASSERT(FALSE); // Unknown command!
      hr = E_FAIL;
    }
    return hr;  
}

void CDomainObject::OnManage(CComponentDataImpl* pCD)
{
  static LPCWSTR lpszSearchArr[] =
  {
    L"%userprofile%\\Application Data\\Microsoft\\AdminTools\\dsa.msc",
    L"%systemroot%\\system32\\dsa.msc",
    NULL
  };

  WCHAR szParamString[MAX_PATH];
  WCHAR szFileName[MAX_PATH];

  wcscpy (szParamString, L" /Domain=");
  wcscat (szParamString, (LPWSTR)(GetDomainName()));

  SHELLEXECUTEINFO seiManage = {0};
	seiManage.fMask = SEE_MASK_DOENVSUBST | SEE_MASK_FLAG_NO_UI;
  seiManage.cbSize = sizeof (SHELLEXECUTEINFO);
  seiManage.lpParameters = (LPCWSTR)&szParamString;
  seiManage.nShow = SW_SHOW;

  BOOL bExecuted = FALSE;
  DWORD dwErr = 0;
  for (int k=0; lpszSearchArr[k] != NULL; k++)
  {
    CWaitCursor cWait;

    seiManage.lpFile = (LPCWSTR)lpszSearchArr[k];
    if (!ShellExecuteEx(&seiManage))
    {
      dwErr = ::GetLastError();
    }
    else
    {
      bExecuted = TRUE;
      break;
    }
  }
  if (!bExecuted)
  {
    HWND hWndParent;
    pCD->GetMainWindow(&hWndParent);
    ReportError(hWndParent, IDS_ERROR_MANAGE, HRESULT_FROM_WIN32(dwErr));
  }
}

//void CDomainObject::OnDomainTrustWizard(CComponentDataImpl* pCD)
//{
    //g_dsUiWizDLL.TrustWizard();
//}

void CDomainObject::SetPdcAvailable(bool fAvail)
{
   _fPdcAvailable = fAvail;
}

////////////////////////////////////////////////////////////////////
// CCookieTableBase

#define NUMBER_OF_COOKIE_TABLE_ENTRIES 4 // default count, expandable at run time

CCookieTableBase::CCookieTableBase() :
    m_pCookieArr(NULL)
{
  m_nEntries = NUMBER_OF_COOKIE_TABLE_ENTRIES;
  m_pCookieArr =(CFolderObject**)malloc(m_nEntries*sizeof(CFolderObject*));

  ASSERT(m_pCookieArr);

  if (m_pCookieArr)
  {
    ZeroMemory(m_pCookieArr, m_nEntries*sizeof(CFolderObject*));
  }
}

CCookieTableBase::~CCookieTableBase()
{
  if (m_pCookieArr)
  {
    free(m_pCookieArr);
  }
}

void CCookieTableBase::Add(CFolderObject* pCookie)
{
  ASSERT(!IsPresent(pCookie)); 
  if (!m_pCookieArr)
  {
    return;
  }
  UINT nFreeSlot = m_nEntries;
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] == NULL)
    {
      m_pCookieArr[k] = pCookie;
      return;
    }
  }
  // no space left, need to allocate
  int nAlloc = m_nEntries*2;
  m_pCookieArr = (CFolderObject**)realloc(m_pCookieArr, sizeof(CFolderObject*)*nAlloc);
  ASSERT(m_pCookieArr);
  if (m_pCookieArr)
  {
    ::ZeroMemory(&m_pCookieArr[m_nEntries], sizeof(CFolderObject*)*m_nEntries);
    m_pCookieArr[m_nEntries] = pCookie;
    m_nEntries = nAlloc;
  }
}

BOOL CCookieTableBase::Remove(CFolderObject* pCookie)
{
  if (!m_pCookieArr)
  {
    return FALSE;
  }
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] == pCookie)
    {
      m_pCookieArr[k] = NULL;
      return TRUE; // found
    }
  }
  return FALSE; // not found
}


BOOL CCookieTableBase::IsPresent(CFolderObject* pCookie)
{
  if (!m_pCookieArr)
  {
    return FALSE;
  }
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] == pCookie)
      return TRUE;
  }
  return FALSE;
}

void CCookieTableBase::Reset()
{
  if (!m_pCookieArr)
  {
    return;
  }
  for (UINT k=0; k<m_nEntries; k++)
  {
    m_pCookieArr[k] = NULL;
  }
 
}

UINT CCookieTableBase::GetCount()
{
  if (!m_pCookieArr)
  {
    return 0;
  }
  UINT nCount = 0;
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] != NULL)
      nCount++;
  }
  return nCount;
}



////////////////////////////////////////////////////////////////////
// CDSCookieSheetTable

void CCookieSheetTable::BringToForeground(CFolderObject* pCookie, CComponentDataImpl* pCD)
{
  ASSERT(pCD != NULL);
  ASSERT(pCookie != NULL);
  if (!m_pCookieArr)
  {
    return;
  }
  // look for the cookie itself and for all the cookies that have the 
  // given cookie as parent or ancestor
  BOOL bActivate = TRUE;
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] != NULL)
    {
      CFolderObject* pAncestorCookie = m_pCookieArr[k];
      while (pAncestorCookie != NULL)
      {
        if (pAncestorCookie == pCookie)
        {
          CString szADSIPath;
		    LPCWSTR lpszNamingContext = ((CDomainObject *)m_pCookieArr[k])->GetNCName();
		    pCD->GetBasePathsInfo()->ComposeADsIPath(szADSIPath, lpszNamingContext);

          // the first one will be also activated
          VERIFY(BringSheetToForeground((LPWSTR)(LPCWSTR)szADSIPath, bActivate));
          if (bActivate)
            bActivate = !bActivate;
        }
        pAncestorCookie = pAncestorCookie->GetParentFolder();
      }	// while
    } // if
  } // for

}


///////////////////////////////////////////////////////////////////////
// CDsUiWizDLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\domain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domain.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"

#include <atlimpl.cpp> // include only once ont in PCH

// this redefines the DEFINE_GUID() macro to do allocation.
#include "initguid.h"
#include <dsclient.h>
#include <dsadminp.h>

#include "resource.h"
#include "domain.h"

#include "domobj.h" 
#include "cdomain.h"



HRESULT WINAPI CDomainAdminModule::UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister)
{
	static const WCHAR szIPS32[] = _T("InprocServer32");
	static const WCHAR szCLSID[] = _T("CLSID");

	HRESULT hRes = S_OK;

	LPOLESTR lpOleStrCLSIDValue;
	::StringFromCLSID(clsid, &lpOleStrCLSIDValue);

	CRegKey key;
	if (bRegister)
	{
		LONG lRes = key.Open(HKEY_CLASSES_ROOT, szCLSID);
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpOleStrCLSIDValue);
			if (lRes == ERROR_SUCCESS)
			{
				WCHAR szModule[_MAX_PATH];
				::GetModuleFileName(m_hInst, szModule, _MAX_PATH);
				key.SetKeyValue(szIPS32, szModule);
			}
		}
		if (lRes != ERROR_SUCCESS)
			hRes = HRESULT_FROM_WIN32(lRes);
	}
	else
	{
		key.Attach(HKEY_CLASSES_ROOT);
		if (key.Open(key, szCLSID) == ERROR_SUCCESS)
			key.RecurseDeleteKey(lpOleStrCLSIDValue);
	}
	::CoTaskMemFree(lpOleStrCLSIDValue);
	return hRes;
}





CDomainAdminModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_DomainAdmin, CComponentDataImpl)
  OBJECT_ENTRY(CLSID_DomainSnapinAbout, CDomainSnapinAbout)
END_OBJECT_MAP()


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
  static char THIS_FILE[] = __FILE__;
#endif

class CDomainApp : public CWinApp
{
public:
  virtual BOOL InitInstance();
  virtual int ExitInstance();
};

CDomainApp theApp;

BOOL CDomainApp::InitInstance()
{
  _Module.Init(ObjectMap, m_hInstance);
  return CWinApp::InitInstance();
}

int CDomainApp::ExitInstance()
{
  _Module.Term();

  DEBUG_VERIFY_INSTANCE_COUNT(CComponentImpl);
  DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataImpl);

  return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
  return _Module.GetClassObject(rclsid, riid, ppv);
}

LPCTSTR g_cszBasePath	= _T("Software\\Microsoft\\MMC\\SnapIns");
LPCTSTR g_cszNameString	= _T("NameString");
LPCTSTR g_cszNameStringIndirect = _T("NameStringIndirect");
LPCTSTR g_cszProvider	= _T("Provider");
LPCTSTR g_cszVersion	= _T("Version");
LPCTSTR g_cszAbout		= _T("About");
LPCTSTR g_cszStandAlone	= _T("StandAlone");
LPCTSTR g_cszNodeTypes	= _T("NodeTypes");

LPCTSTR GUIDToCString(REFGUID guid, CString & str)
{
  USES_CONVERSION;
	
  OLECHAR lpszGUID[128];
  int nChars = ::StringFromGUID2(guid, lpszGUID, 128);
  LPTSTR lpString = OLE2T(lpszGUID);

  LPTSTR lpGUID = str.GetBuffer(nChars);
  if (lpGUID)
    {
      CopyMemory(lpGUID, lpString, nChars*sizeof(TCHAR));
      str.ReleaseBuffer();
    }

  return str;
}

HRESULT RegisterSnapin()
{
  HRESULT hr = S_OK;
  CString strKey;
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  try
    {
      CString str;
      
      CRegKey rkBase;
      rkBase.Open(HKEY_LOCAL_MACHINE, g_cszBasePath);

      // Create snapin GUID key and set properties
      CRegKey rkCLSID;
      rkCLSID.Create(rkBase, GUIDToCString(CLSID_DomainAdmin, str));
      str.LoadString(IDS_DESCRIPTION);
      //        str = _T("MSFT Domain Tree Manager");
      rkCLSID.SetValue(str, g_cszNameString);

      {
        WCHAR szModule[_MAX_PATH];
        ::GetModuleFileName(AfxGetInstanceHandle(), szModule, _MAX_PATH);
        str.Format(_T("@%s,-%d"), szModule, IDS_DESCRIPTION);
        rkCLSID.SetValue(str, g_cszNameStringIndirect);
      }

      str.LoadString(IDS_COMPANY);
      rkCLSID.SetValue(str, g_cszProvider);
      str.LoadString(IDS_SNAPIN_VERSION);
      rkCLSID.SetValue((LPCWSTR)str, g_cszVersion);

      rkCLSID.SetValue(GUIDToCString(CLSID_DomainSnapinAbout, str), g_cszAbout);
        
      // Create "StandAlone" key
      CRegKey rkStandAlone;
      rkStandAlone.Create(rkCLSID, g_cszStandAlone);
                
      // Create "NodeTypes" key
      CRegKey rkNodeTypes;
      rkNodeTypes.Create(rkCLSID,  g_cszNodeTypes);

      // NodeTypes guids
      CRegKey rkN1;
      rkN1.Create(rkNodeTypes, GUIDToCString(cDefaultNodeType, str));
    }
  catch(CMemoryException * e)
    {
      e->Delete();
      hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
  catch(COleException * e)
    {
      e->Delete();
      hr = SELFREG_E_CLASS;
    }
	
  return hr;
}

HRESULT UnregisterSnapin()
{
  HRESULT hr = S_OK;
	
  try
    {
      CRegKey rkBase;
      rkBase.Open(HKEY_LOCAL_MACHINE, g_cszBasePath);

      CString str;
      rkBase.RecurseDeleteKey(GUIDToCString(CLSID_DomainAdmin, str));
    }
  catch(CException * e)
    {
      DWORD err = ::GetLastError();
      hr = HRESULT_FROM_WIN32(err);
      e->Delete();
    }

  return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	HRESULT hRes = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
	if (FAILED(hRes))
		return SELFREG_E_CLASS;

	return RegisterSnapin();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return UnregisterSnapin();
}


///////////////////////////////////////////////////////////////////////
// CDsUiWizDLL

CDsUiWizDLL::CDsUiWizDLL()
{
	m_hLibrary = NULL;
	m_pfFunction = NULL;
}


CDsUiWizDLL::~CDsUiWizDLL()
{
	if (m_hLibrary != NULL)
	{
		::FreeLibrary(m_hLibrary);
		m_hLibrary = NULL;
	}
}

BOOL CDsUiWizDLL::Load()
{
	if (m_hLibrary != NULL)
        return TRUE; // already loaded
	m_hLibrary = ::LoadLibrary(_T("dsuiwiz.dll"));
	if (NULL == m_hLibrary)
	{
		// The library is not present
		return FALSE;
	}
	m_pfFunction = ::GetProcAddress(m_hLibrary, "TrustWizard" );
	if ( NULL == m_pfFunction )
	{
		// The library is present but does not have the entry point
		::FreeLibrary( m_hLibrary );
		m_hLibrary = NULL;
		return FALSE;
	}
	ASSERT(m_hLibrary != NULL);
	ASSERT(m_pfFunction != NULL);
	return TRUE;
}


typedef HRESULT (*TRUST_WIZARD_PROC) (HWND, LPCWSTR);

HRESULT CDsUiWizDLL::TrustWizard(HWND hWndParent, LPCWSTR lpsz)
{
	ASSERT(m_hLibrary != NULL);
	ASSERT(m_pfFunction != NULL);
	return ((TRUST_WIZARD_PROC)m_pfFunction) (hWndParent, lpsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\domobjui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domobjui.h
//
//--------------------------------------------------------------------------

#ifndef _DOMOBJUI_H
#define _DOMOBJUI_H


///////////////////////////////////////////////////////////////////////
// fwd declarations
class CDSBasePathsInfo;


///////////////////////////////////////////////////////////////////////
// CEditFsmoDialog

class CEditFsmoDialog : public CDialog
{
public:
  CEditFsmoDialog(MyBasePathsInfo* pInfo, HWND hWndParent, IDisplayHelp* pIDisplayHelp);
  
private:

	virtual BOOL OnInitDialog();

  afx_msg void OnChange();
  afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);

  void _SetFsmoServerStatus(BOOL bOnLine);

  MyBasePathsInfo* m_pInfo;        // info about the current focus
  CComPtr<IDisplayHelp> m_spIDisplayHelp;
  CString m_szFsmoOwnerServerName; 
  CToggleTextControlHelper m_fsmoServerState;

  DECLARE_MESSAGE_MAP()
};


#endif // _DOMOBJUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\domobjui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domobjui.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "domobj.h"
#include "cdomain.h"
#include "domain.h"
#include "cdomain.h"

#include "domobjui.h"

#include "helparr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////
// CMoreInfoMessageBox

class CMoreInfoMessageBox : public CDialog
{
public:
  CMoreInfoMessageBox(HWND hWndParent, IDisplayHelp* pIDisplayHelp) 
    : CDialog(IDD_MSGBOX_OK_MOREINFO, CWnd::FromHandle(hWndParent)),
    m_spIDisplayHelp(pIDisplayHelp)
  {
  }

  void SetURL(LPCWSTR lpszURL) { m_szURL = lpszURL;}
  void SetMessage(LPCWSTR lpsz)
  {
    m_szMessage = lpsz;
  }

	// message handlers and MFC overrides
	virtual BOOL OnInitDialog()
  {
    SetDlgItemText(IDC_STATIC_MESSAGE, m_szMessage);
    return TRUE;
  }

	afx_msg void OnMoreInfo()
  {
    TRACE(L"ShowTopic(%s)\n", (LPCWSTR)m_szURL);
    m_spIDisplayHelp->ShowTopic((LPWSTR)(LPCWSTR)m_szURL);
  }

  DECLARE_MESSAGE_MAP()
private:
  CComPtr<IDisplayHelp> m_spIDisplayHelp;
  CString m_szMessage;
  CString m_szURL;
};

BEGIN_MESSAGE_MAP(CMoreInfoMessageBox, CDialog)
	ON_BN_CLICKED(ID_BUTTON_MORE_INFO, OnMoreInfo)
END_MESSAGE_MAP()



///////////////////////////////////////////////////////////////////////
// CEditFsmoDialog


BEGIN_MESSAGE_MAP(CEditFsmoDialog, CDialog)
	ON_BN_CLICKED(IDC_CHANGE_FSMO, OnChange)
  ON_WM_HELPINFO()
END_MESSAGE_MAP()

CEditFsmoDialog::CEditFsmoDialog(MyBasePathsInfo* pInfo, HWND hWndParent, IDisplayHelp* pIDisplayHelp) :
  CDialog(IDD_EDIT_FSMO, CWnd::FromHandle(hWndParent)) 
{
  m_pInfo = pInfo;
  m_spIDisplayHelp = pIDisplayHelp;
}


BOOL CEditFsmoDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();

  // init the status (online/offline) control)
  m_fsmoServerState.Init(::GetDlgItem(m_hWnd, IDC_STATIC_FSMO_STATUS));

  SetDlgItemText(IDC_EDIT_CURRENT_DC, m_pInfo->GetServerName());

  HRESULT hr;
  MyBasePathsInfo fsmoOwnerInfo;
  {
    CWaitCursor wait;

    PWSTR pszFsmoOwner = 0;
    hr = FindFsmoOwner(m_pInfo, DOMAIN_NAMING_FSMO, &fsmoOwnerInfo, &pszFsmoOwner);


    if (pszFsmoOwner)
    {
      m_szFsmoOwnerServerName = pszFsmoOwner;
      delete[] pszFsmoOwner;
      pszFsmoOwner = 0;
    }
  }

  BOOL bOnLine = SUCCEEDED(hr);
  _SetFsmoServerStatus(bOnLine);

  if (bOnLine)
  {
    // set the focus on change button
    GetDlgItem(IDC_CHANGE_FSMO)->SetFocus();
  }
  else
  {
    // set the focus on close button
    GetDlgItem(IDCANCEL)->SetFocus();
  }

  return FALSE; // we set the focus
}

void CEditFsmoDialog::OnChange()
{
  // verify we have different servers
  if (m_szFsmoOwnerServerName.CompareNoCase(m_pInfo->GetServerName()) == 0)
  {
    AfxMessageBox(IDS_WARNING_CHANGE_FOCUS, MB_OK);
    return;
  }

  // make sure the user wants to do it
  if (AfxMessageBox(IDS_CHANGE_FSMO_CONFIRMATION, MB_OKCANCEL) != IDOK)
    return;

  HRESULT hr = S_OK;
  // try a graceful transfer
  {
    CWaitCursor wait;
    hr = GracefulFsmoOwnerTransfer(m_pInfo, DOMAIN_NAMING_FSMO);
  }
  if (FAILED(hr))
  {
    CString szFmt, szMsg;
    PWSTR pszError = 0;
    StringErrorFromHr(hr, &pszError);

    szFmt.LoadString(IDS_ERROR_CHANGE_FSMO_OWNER);
    szMsg.Format(szFmt, pszError);

    CMoreInfoMessageBox dlg(m_hWnd, m_spIDisplayHelp);
    dlg.SetMessage(szMsg);
    dlg.SetURL(L"ADconcepts.chm::/FSMO_DOMAIN_NAMING_ForcefulSeizure.htm");
    dlg.DoModal();
  }
  else
  {
    m_szFsmoOwnerServerName = m_pInfo->GetServerName();
    _SetFsmoServerStatus(TRUE);
    AfxMessageBox(IDS_CHANGE_FSMO_SUCCESS, MB_OK);
  }
}

void CEditFsmoDialog::_SetFsmoServerStatus(BOOL bOnLine)
{
  // set the FSMO owner server name
  if (m_szFsmoOwnerServerName.IsEmpty())
  {
    CString szError;
    szError.LoadString(IDS_FSMO_SERVER_ERROR);
    SetDlgItemText(IDC_EDIT_CURRENT_FSMO_DC, szError);
  }
  else
  {
    SetDlgItemText(IDC_EDIT_CURRENT_FSMO_DC, m_szFsmoOwnerServerName);
  }

  // set the status of the FSMO owner server
  m_fsmoServerState.SetToggleState(bOnLine);

  // enable disable the change button
  GetDlgItem(IDC_CHANGE_FSMO)->EnableWindow(bOnLine);
}


BOOL CEditFsmoDialog::OnHelpInfo(HELPINFO* pHelpInfo) 
{
  DialogContextHelp((DWORD*)&g_aHelpIDs_TREE_IDD_EDIT_FSMO, pHelpInfo);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\mybasepathsinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      MyBasePathsInfo.h
//
//  Contents:  Thin wrapper around dsadminlib CDSBasePathsInfo class
//             to deal with memory management of strings
//
//  History:   04/02/2001 jeffjon    Created
//
//--------------------------------------------------------------------------

class MyBasePathsInfo : public CDSBasePathsInfo
{
public:
  // Functions from the base class that are wrapped to take references to 
  // CStrings

  void ComposeADsIPath(CString& szPath, IN LPCWSTR lpszNamingContext);

  void GetSchemaPath(CString& s);
  void GetConfigPath(CString& s);
  void GetDefaultRootPath(CString& s);
  void GetRootDSEPath(CString& s);
  void GetAbstractSchemaPath(CString& s);
  void GetPartitionsPath(CString& s);
  void GetSchemaObjectPath(IN LPCWSTR lpszObjClass, CString& s);
  void GetInfrastructureObjectPath(CString& s);
};

HRESULT GetADSIServerName(CString& szServer, IN IUnknown* pUnk);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\mybasepathsinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      MyBasePathsInfo.h
//
//  Contents:  Thin wrapper around dsadminlib CDSBasePathsInfo class
//             to deal with memory management of strings
//
//  History:   04/02/2001 jeffjon    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"


void MyBasePathsInfo::ComposeADsIPath(CString& szPath, IN LPCWSTR lpszNamingContext)
{
  int result = 0;
  szPath.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::ComposeADsIPath(&pszPath, lpszNamingContext);
  
  if (pszPath && result)
  {
     szPath = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetSchemaPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetSchemaPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetConfigPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetConfigPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetDefaultRootPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetDefaultRootPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetRootDSEPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetRootDSEPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetAbstractSchemaPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetAbstractSchemaPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetPartitionsPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetPartitionsPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetSchemaObjectPath(IN LPCWSTR lpszObjClass, CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetSchemaObjectPath(lpszObjClass, &pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetInfrastructureObjectPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetInfrastructureObjectPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

HRESULT GetADSIServerName(CString& szServer, IN IUnknown* pUnk)
{
  PWSTR pszServer = 0;
  HRESULT hr = GetADSIServerName(&pszServer, pUnk);
  if (SUCCEEDED(hr) && pszServer)
  {
    szServer = pszServer;

    delete[] pszServer;
    pszServer = 0;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\proppage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       proppage.h
//
//--------------------------------------------------------------------------


#ifndef _PROPPAGE_H
#define _PROPPAGE_H

#include "afxdlgs.h"


#define MAX_UPN_SUFFIX_LEN 256


////////////////////////////////////////////////////////////////////////////////
// CUpnSuffixPropertyPage


class CUpnSuffixListBox : public CListBox
{
public:
  int AddItem(LPCTSTR lpszText)
    { return AddString(lpszText);}
  void GetItem(int iItem, CString& szText)
    { GetText(iItem, szText);}
  
  BOOL DeleteItem(int iItem)
    { return DeleteString(iItem) != LB_ERR;}

  int GetSelection() 
    { return GetCurSel();}
  BOOL SetSelection(int nSel)
    { return SetCurSel(nSel) != LB_ERR; }

  void UpdateHorizontalExtent()
  {
	  int nHorzExtent = 0;
	  CClientDC dc(this);
	  int nItems = GetCount();
	  for	(int i=0; i < nItems; i++)
	  {
		  TEXTMETRIC tm;
		  VERIFY(dc.GetTextMetrics(&tm));
		  CString szBuffer;
		  GetText(i, szBuffer);
		  CSize ext = dc.GetTextExtent(szBuffer,szBuffer.GetLength());
		  nHorzExtent = max(ext.cx ,nHorzExtent); 
	  }
	  SetHorizontalExtent(nHorzExtent);
  }

};


class CUpnSuffixPropertyPage : public CPropertyPage
{
public:
  CUpnSuffixPropertyPage();
  virtual ~CUpnSuffixPropertyPage();

  virtual BOOL OnInitDialog();
  virtual BOOL OnApply();

private:
  afx_msg void OnAddButton();
  afx_msg void OnDeleteButton();
  afx_msg void OnEditChange();
  afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);

private:
  void _SetDirty(BOOL bDirty)
  { 
	  SetModified(bDirty); 
	  m_bDirty = bDirty;
  }	
  BOOL _IsDirty() { return m_bDirty;}

  HRESULT _GetPartitionsContainer();
  void _Read();
  HRESULT _Write();

  BOOL m_bDirty;
  IDirectoryObject* m_pIADsPartitionsCont;
  CUpnSuffixListBox m_listBox;
  CString m_szEditText;

  UINT m_nPreviousDefaultButtonID;

  // hook up the callback for C++ object destruction
  LPFNPSPCALLBACK m_pfnOldPropCallback;
  static UINT CALLBACK PropSheetPageProc(
    HWND hwnd,	
    UINT uMsg,	
    LPPROPSHEETPAGE ppsp);	

  DECLARE_MESSAGE_MAP()
};

#endif // _PROPPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\proppage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       proppage.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"
#include "proppage.h"
#include "domobj.h"
#include "cdomain.h"

#include "helparr.h"

////////////////////////////////////////////////////////////////////////////////
// CUpnSuffixPropertyPage


// hook the property sheet callback to allow
// C++ object destruction

// static callback override function
UINT CALLBACK CUpnSuffixPropertyPage::PropSheetPageProc(
    HWND hwnd,	
    UINT uMsg,	
    LPPROPSHEETPAGE ppsp)
{
  CUpnSuffixPropertyPage* pPage = (CUpnSuffixPropertyPage*)(ppsp->lParam);
  ASSERT(pPage != NULL);

  UINT nResult = (*(pPage->m_pfnOldPropCallback))(hwnd, uMsg, ppsp);
  if (uMsg == PSPCB_RELEASE)
  {
    delete pPage;
  }
  return nResult;
}


BEGIN_MESSAGE_MAP(CUpnSuffixPropertyPage, CPropertyPage)
	ON_BN_CLICKED(IDC_ADD_BTN, OnAddButton)
  ON_BN_CLICKED(IDC_DELETE_BTN, OnDeleteButton)
  ON_EN_CHANGE(IDC_EDIT, OnEditChange)
  ON_WM_HELPINFO()
END_MESSAGE_MAP()


CUpnSuffixPropertyPage::CUpnSuffixPropertyPage() : 
    CPropertyPage(IDD_UPN_SUFFIX),
    m_nPreviousDefaultButtonID(0)
{
  m_pfnOldPropCallback = m_psp.pfnCallback;
  m_psp.pfnCallback = PropSheetPageProc;
  m_bDirty = FALSE;
  m_pIADsPartitionsCont = NULL;
}

CUpnSuffixPropertyPage::~CUpnSuffixPropertyPage()
{
  if (m_pIADsPartitionsCont != NULL)
  {
    m_pIADsPartitionsCont->Release();
    m_pIADsPartitionsCont = NULL;
  }
}

BOOL CUpnSuffixPropertyPage::OnInitDialog()
{
  CPropertyPage::OnInitDialog();

  VERIFY(m_listBox.SubclassDlgItem(IDC_LIST, this));
  ((CEdit*)GetDlgItem(IDC_EDIT))->SetLimitText(MAX_UPN_SUFFIX_LEN);

  HRESULT hr = _GetPartitionsContainer();
  if (SUCCEEDED(hr))
  {
    _Read();
    GetDlgItem(IDC_ADD_BTN)->EnableWindow(FALSE);
  }
  else
  {
    // failed to contact DC, disable the whole UI
    GetDlgItem(IDC_ADD_BTN)->EnableWindow(FALSE);
    GetDlgItem(IDC_DELETE_BTN)->EnableWindow(FALSE);
    GetDlgItem(IDC_LIST)->EnableWindow(FALSE);
    GetDlgItem(IDC_EDIT)->EnableWindow(FALSE);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ReportError(::GetParent(m_hWnd), IDS_CANT_GET_PARTITIONS_INFORMATION, hr);
  }
  
  LRESULT lDefID = ::SendMessage(GetParent()->GetSafeHwnd(), DM_GETDEFID, 0, 0);
  if (lDefID != 0)
  {
    m_nPreviousDefaultButtonID = LOWORD(lDefID);
  }

  _SetDirty(FALSE);
  return TRUE;
}

BOOL CUpnSuffixPropertyPage::OnApply()
{
  if (!_IsDirty())
    return TRUE;

  HRESULT hr = _Write();
  if (SUCCEEDED(hr))
  {
    _SetDirty(FALSE);
    return TRUE;
  }
  ReportError(::GetParent(m_hWnd),IDS_ERROR_WRITE_UPN_SUFFIXES, hr);
  return FALSE;
}


void CUpnSuffixPropertyPage::OnEditChange()
{
  GetDlgItemText(IDC_EDIT, m_szEditText);
  m_szEditText.TrimRight();
  m_szEditText.TrimLeft();
  
  BOOL bEnable = !m_szEditText.IsEmpty();
  CWnd* pWndFocus = CWnd::GetFocus();
  CWnd* pAddBtnWnd = GetDlgItem(IDC_ADD_BTN);

  if (!bEnable && (pAddBtnWnd == pWndFocus) )
  {
    GetDlgItem(IDC_EDIT)->SetFocus();
  }

  GetDlgItem(IDC_ADD_BTN)->EnableWindow(bEnable);
  if (bEnable)
  {
    //
    // Set the add button as the default button
    //
    ::SendMessage(GetParent()->GetSafeHwnd(), DM_SETDEFID, (WPARAM)IDC_ADD_BTN, 0);

    //
    // Force the Add button to redraw itself
    //
    ::SendDlgItemMessage(GetSafeHwnd(),
                         IDC_ADD_BTN,
                         BM_SETSTYLE,
                         BS_DEFPUSHBUTTON,
                         MAKELPARAM(TRUE, 0));
                       
    //
    // Force the previous default button to redraw itself
    //
    ::SendDlgItemMessage(GetParent()->GetSafeHwnd(),
                         m_nPreviousDefaultButtonID,
                         BM_SETSTYLE,
                         BS_PUSHBUTTON,
                         MAKELPARAM(TRUE, 0));
    
  }
  else
  {
    //
    // Set the previous button as the default button
    //
    ::SendMessage(GetParent()->GetSafeHwnd(), DM_SETDEFID, (WPARAM)m_nPreviousDefaultButtonID, 0);

    //
    // Force the previous default button to redraw itself
    //
    ::SendDlgItemMessage(GetParent()->GetSafeHwnd(),
                         m_nPreviousDefaultButtonID,
                         BM_SETSTYLE,
                         BS_DEFPUSHBUTTON,
                         MAKELPARAM(TRUE, 0));

    //
    // Force the Add button to redraw itself
    //
    ::SendDlgItemMessage(GetParent()->GetSafeHwnd(),
                         IDC_ADD_BTN,
                         BM_SETSTYLE,
                         BS_PUSHBUTTON,
                         MAKELPARAM(TRUE, 0));
                      
  }
}

void CUpnSuffixPropertyPage::OnAddButton()
{
  // cannot add duplicated items
  int nCount = m_listBox.GetCount();
  CString szItem;
  for (int i=0; i<nCount; i++)
  {
    m_listBox.GetItem(i, szItem);
    if (_wcsicmp((LPCWSTR)szItem, (LPCWSTR)m_szEditText) == 0)
    {
      AFX_MANAGE_STATE(AfxGetStaticModuleState());
      AfxMessageBox(IDS_ERROR_ADD_UPN_NO_DUPLICATE, MB_OK|MB_ICONINFORMATION);
      return;
    }
  }

  m_listBox.AddItem(m_szEditText);
  m_listBox.UpdateHorizontalExtent();
  SetDlgItemText(IDC_EDIT, NULL);

  if (1 == m_listBox.GetCount())
  {
    // we did not have any item in the list
    // need to set the selection on the first one
    VERIFY(m_listBox.SetSelection(0));
    // need to enable buttons
    GetDlgItem(IDC_DELETE_BTN)->EnableWindow(TRUE);
  }
  _SetDirty(TRUE);
}

void CUpnSuffixPropertyPage::OnDeleteButton()
{
  int nCount = m_listBox.GetCount();
  int nSel = m_listBox.GetSelection();
  ASSERT(nCount > 0);
  ASSERT((nSel >= 0) && (nSel < nCount));

  // ask the user for confirmation
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  if (IDNO == AfxMessageBox(IDS_WARNING_DELETE_UPN_SUFFIX, MB_YESNO|MB_ICONQUESTION))
    return;

  // save the value and put it back in the edit control
  CString szText;
  m_listBox.GetItem(nSel, szText);
  GetDlgItem(IDC_EDIT)->SetWindowText(szText);

  // delete the item in the list
  VERIFY(m_listBox.DeleteItem(nSel));
  m_listBox.UpdateHorizontalExtent();

  // handle UI changes
  if (nCount == 1)
  {
    // removed the last one, lost the selection
    CWnd* pWndFocus = CWnd::GetFocus();
    CWnd* pDelBtnWnd = GetDlgItem(IDC_DELETE_BTN);

    if (pDelBtnWnd == pWndFocus)
    {
      GetDlgItem(IDC_EDIT)->SetFocus();
    }
    GetDlgItem(IDC_DELETE_BTN)->EnableWindow(FALSE);
  }
  else 
  {
    // need to select again: is it the last one or not
    int nNewSel = (nSel == nCount-1) ? nSel-1 : nSel;
    VERIFY(m_listBox.SetSelection(nNewSel));
    ASSERT(m_listBox.GetSelection() == nNewSel);
  }
  
  _SetDirty(TRUE);
}

BOOL CUpnSuffixPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
  DialogContextHelp((DWORD*)&g_aHelpIDs_IDD_UPN_SUFFIX, pHelpInfo);
	return TRUE;
}

//////////////////////////////////////////////////////////
// CUpnSuffixPropertyPage internal implementation methods 


LPWSTR g_lpszRootDSE = L"LDAP://RootDSE";
LPWSTR g_lpszConfigurationNamingContext = L"configurationNamingContext";
LPWSTR g_lpszPartitionsFormat = L"LDAP://CN=Partitions,%s";
LPWSTR g_lpszPartitionsFormatWithServer = L"LDAP://%s/CN=Partitions,%s";
LPWSTR g_lpszUpnSuffixes = L"uPNSuffixes";

HRESULT CUpnSuffixPropertyPage::_GetPartitionsContainer()
{
  if (m_pIADsPartitionsCont != NULL)
  {
    m_pIADsPartitionsCont->Release();
    m_pIADsPartitionsCont = NULL;
  }

  // get the root of the enterprise
  IADs* pADs;
  HRESULT hr = ::ADsGetObject(g_lpszRootDSE,
                      IID_IADs, (void **)&pADs);
  if (!(SUCCEEDED(hr))) 
  {
    return hr;
  }

  //
  // Get the server name so we can bind with ADS_SERVER_BIND
  //
  CString szServerName;
  hr = GetADSIServerName(szServerName, pADs);
  if (FAILED(hr))
  {
    szServerName.Empty();
  }
  
  // get the configuration naming context container
  VARIANT configVar;
  ::VariantInit(&configVar);
  hr = pADs->Get(g_lpszConfigurationNamingContext,
                   &configVar);

  if (SUCCEEDED(hr))
  {
    // get the partitions container
    DWORD dwFlags = ADS_SECURE_AUTHENTICATION;
    CString szPartitionsPath;
    if (szServerName.IsEmpty())
    {
      szPartitionsPath.Format(g_lpszPartitionsFormat, configVar.bstrVal);
    }
    else
    {
      szPartitionsPath.Format(g_lpszPartitionsFormatWithServer, szServerName, configVar.bstrVal);
      dwFlags |= ADS_SERVER_BIND;
    }
    IADsContainer* pIADsContainer;
    hr = ::ADsOpenObject((LPWSTR)(LPCWSTR)szPartitionsPath,
                         NULL, // username
                         NULL, // password
                         dwFlags,
                         IID_IDirectoryObject, 
                         (void **)&m_pIADsPartitionsCont);
    if (hr == E_INVALIDARG &&
        (dwFlags & ADS_SERVER_BIND))
    {
      //
      // Trying again without the ADS_SERVER_BIND flag
      //
      dwFlags &= ~ADS_SERVER_BIND;
      hr = ::ADsOpenObject((LPWSTR)(LPCWSTR)szPartitionsPath,
                           NULL, // username
                           NULL, // password
                           dwFlags,
                           IID_IDirectoryObject, 
                           (void **)&m_pIADsPartitionsCont);
    }
  }
  ::VariantClear(&configVar);
  pADs->Release();
  return hr;
}


void CUpnSuffixPropertyPage::_Read()
{
  ASSERT(m_pIADsPartitionsCont != NULL);

  PADS_ATTR_INFO pAttrs = NULL;
  LPWSTR lpszArr[1];
  DWORD cAttrs;

  BOOL bHaveItems = FALSE;

  HRESULT hr = m_pIADsPartitionsCont->GetObjectAttributes(
                &g_lpszUpnSuffixes, 1, &pAttrs, &cAttrs);

  if (SUCCEEDED(hr) && (pAttrs != NULL) && (cAttrs == 1) )
  {
    ASSERT(pAttrs->dwADsType == ADSTYPE_CASE_IGNORE_STRING);
    ASSERT(cAttrs == 1);
    for (DWORD i=0; i<pAttrs->dwNumValues; i++)
    {
      m_listBox.AddItem(pAttrs->pADsValues[i].CaseIgnoreString);
      //TRACE(_T("i=%d, %s\n"), i, pAttrs->pADsValues[i].CaseIgnoreString);
    }
    bHaveItems = pAttrs->dwNumValues > 0;
  }

  if (bHaveItems)
  {
    m_listBox.UpdateHorizontalExtent();
    VERIFY(m_listBox.SetSelection(0));
  }
  GetDlgItem(IDC_DELETE_BTN)->EnableWindow(bHaveItems);

  if (pAttrs != NULL)
  {
    ::FreeADsMem(pAttrs);
  }

}


HRESULT CUpnSuffixPropertyPage::_Write()
{
  ASSERT(m_pIADsPartitionsCont != NULL);
  DWORD cModified;
  CString* pStringArr = NULL;
  ADSVALUE* pValues = NULL;

  // set the update struct
  ADS_ATTR_INFO info;
  info.pszAttrName = g_lpszUpnSuffixes;
  info.dwADsType = ADSTYPE_CASE_IGNORE_STRING;
  info.dwControlCode = ADS_ATTR_CLEAR;
  info.pADsValues = NULL;
  info.dwNumValues = 0;

  int nCount = m_listBox.GetCount();

  if (nCount > 0)
  {
    info.dwControlCode = ADS_ATTR_UPDATE;
    info.dwNumValues = (DWORD)nCount;
    
    pStringArr = new CString[nCount];
    ADSVALUE* pValues = new ADSVALUE[nCount];
    info.pADsValues = pValues;

    for (int i=0; i<nCount; i++)
    {
      m_listBox.GetItem(i,pStringArr[i]);
      pValues[i].dwType = ADSTYPE_CASE_IGNORE_STRING;
      pValues[i].CaseIgnoreString = (LPWSTR)(LPCWSTR)pStringArr[i];
    }
    
  }

  HRESULT hr = m_pIADsPartitionsCont->SetObjectAttributes(
                &info, 1, &cModified);

  if (pStringArr != NULL)
    delete[] pStringArr;

  if (pValues != NULL)
    delete[] pValues;
  
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by domain.rc
//
#define IDS_NAME                        2
#define ID_BUTTON_MORE_INFO             3
#define IDS_TYPE                        4
#define IDS_NODENAME                    5
#define IDS_CANT_GET_PARTITIONS_INFORMATION 6
#define IDS_FAILURE_UNK                 7
#define IDS_DESCRIPTION                 8
#define IDS_COMPANY                     9
#define IDS_SNAPIN_VERSION              10
#define IDS_SNAPINABOUT_DESCRIPTION     11
#define IDS_FSMO_SERVER_ERROR           14
#define IDS_SHEETS_UP_DELETE            40
#define IDS_COMMAND_MANAGE              100
#define IDS_COMMAND_RETARGET            102
#define IDS_COMMAND_EDIT_FSMO           103
#define IDS_COMMAND_DOMAIN_VER          104
#define IDS_COMMAND_FOREST_VER          105
#define IDC_ADD_BTN                     149
#define IDS_WARNING_DELETE_UPN_SUFFIX   200
#define IDS_ERROR_WRITE_UPN_SUFFIXES    201
#define IDC_LIST                        202
#define IDS_ERROR_ADD_UPN_NO_DUPLICATE  202
#define IDC_EDIT_CURRENT_DC             203
#define IDS_ERROR_CHANGE_FSMO_OWNER     203
#define IDS_ERROR_MANAGE                204
#define IDS_WARNING_CHANGE_FOCUS        205
#define IDS_CHANGE_FSMO_CONFIRMATION    206
#define IDC_EDIT_CURRENT_FSMO_DC        207
#define IDS_CHANGE_FSMO_CONFIRMATION_FORCED 207
#define IDC_CHANGE_FSMO                 208
#define IDS_CHANGE_FSMO_SUCCESS         208
#define IDC_STATIC_FSMO_STATUS          210
#define IDB_DOMAIN_SMALL                212
#define IDB_DOMAIN_LARGE                213
#define IDD_UPN_SUFFIX                  214
#define IDI_DOMAIN                      215
#define IDD_EDIT_FSMO                   217
#define IDC_STATIC_MESSAGE              258
#define IDC_EDIT                        361
#define IDD_MSGBOX_OK_MOREINFO          426
#define IDC_DELETE_BTN                  1045
#define IDS_NO_PDC_MSG                  57345
#define IDS_UNKNOWN_PDC_MSG             57346

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        219
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         211
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------



#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\stdabout.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdabout.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"

HRESULT
HrLoadOleString(
   UINT uStringId,                  // IN: String Id to load from the resource
   OUT LPOLESTR * ppaszOleString)   // OUT: Pointer to pointer to allocated OLE string
{
   if (ppaszOleString == NULL)
   {
      TRACE0("HrLoadOleString() - ppaszOleString is NULL.\n");
      return E_POINTER;
   }
   CString strT;		// Temporary string
   AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Needed for LoadString()
   VERIFY( strT.LoadString(uStringId) );
   *ppaszOleString = reinterpret_cast<LPOLESTR>
      (CoTaskMemAlloc((strT.GetLength() + 1)* sizeof(wchar_t)));
   if (*ppaszOleString == NULL)
      return E_OUTOFMEMORY;
   USES_CONVERSION;
   wcscpy(OUT *ppaszOleString, T2OLE((LPTSTR)(LPCTSTR)strT));
   return S_OK;
} // HrLoadOleString()

CSnapinAbout::CSnapinAbout()
{
}

CSnapinAbout::~CSnapinAbout()
{
   if ( m_hSmallImage )
      ::DeleteObject (m_hSmallImage);

   if ( m_hSmallImageOpen )
      ::DeleteObject (m_hSmallImageOpen);

   if ( m_hLargeImage )
      ::DeleteObject (m_hLargeImage);
}

STDMETHODIMP CSnapinAbout::GetSnapinDescription(OUT LPOLESTR __RPC_FAR *lpDescription)
{
   return HrLoadOleString(m_uIdStrDestription, OUT lpDescription);
}

STDMETHODIMP CSnapinAbout::GetProvider(OUT LPOLESTR __RPC_FAR *lpName)
{
   return HrLoadOleString(m_uIdStrProvider, OUT lpName);
}

STDMETHODIMP CSnapinAbout::GetSnapinVersion(OUT LPOLESTR __RPC_FAR *lpVersion)
{
   return HrLoadOleString(m_uIdStrVersion, OUT lpVersion);
}

STDMETHODIMP CSnapinAbout::GetSnapinImage(OUT HICON __RPC_FAR *hAppIcon)
{
   if (hAppIcon == NULL)
      return E_POINTER;
   AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
   *hAppIcon = ::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_uIdIconImage));
   if (*hAppIcon == NULL)
   {
      ASSERT(FALSE && "Unable to load icon");
      return E_FAIL;
   }
   return S_OK;
}

STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask)
{
   ASSERT(hSmallImage != NULL);
   ASSERT(hSmallImageOpen != NULL);
   ASSERT(hLargeImage != NULL);
   ASSERT(crMask != NULL);
   AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
   HINSTANCE hInstance = AfxGetInstanceHandle();

   if ( !m_hSmallImage )
      m_hSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImage));
   if ( !m_hSmallImageOpen )
      m_hSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImageOpen));
   if ( !m_hLargeImage )
      m_hLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapLargeImage));

   *hSmallImage = m_hSmallImage;
   *hSmallImageOpen = m_hSmallImageOpen;
   *hLargeImage = m_hLargeImage;
   
   *crMask = m_crImageMask;
   #ifdef _DEBUG
   if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
   {
      TRACE0("WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
      return E_FAIL;
   }
   #endif
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\stdabout.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdabout.h
//
//--------------------------------------------------------------------------

#ifndef __STDABOUT_H_INCLUDED__
#define __STDABOUT_H_INCLUDED__


class CSnapinAbout :
   public ISnapinAbout,
   public CComObjectRoot
{
BEGIN_COM_MAP(CSnapinAbout)
   COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()
public:
   CSnapinAbout();
   virtual ~CSnapinAbout ();

// ISnapinAbout
   STDMETHOD(GetSnapinDescription)(OUT LPOLESTR __RPC_FAR *lpDescription);
   STDMETHOD(GetProvider)(OUT LPOLESTR __RPC_FAR *lpName);
   STDMETHOD(GetSnapinVersion)(OUT LPOLESTR __RPC_FAR *lpVersion);
   STDMETHOD(GetSnapinImage)(OUT HICON __RPC_FAR *hAppIcon);
   STDMETHOD(GetStaticFolderImage)(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask);
protected:
   // The following data members MUST be initialized by the constructor
   // of the derived class.
   UINT m_uIdStrDestription;		// Resource Id of the description
   UINT m_uIdStrProvider;		// Resource Id of the provider (ie, Microsoft Corporation)
   UINT m_uIdStrVersion;			// Resource Id of the version of the snapin
   UINT m_uIdIconImage;			// Resource Id for the icon/image of the snapin
   UINT m_uIdBitmapSmallImage;
   UINT m_uIdBitmapSmallImageOpen;
   UINT m_uIdBitmapLargeImage;
   COLORREF m_crImageMask;
   HBITMAP m_hSmallImage;          // cached bitmap for GetStaticFolderImage
   HBITMAP m_hSmallImageOpen;      // cached bitmap for GetStaticFolderImage
   HBITMAP m_hLargeImage;          // cached bitmap for GetStaticFolderImage
}; // CSnapinAbout()

#endif // ~__STDABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\domain\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------




#include <afxwin.h>
#include <afxdisp.h>


///////////////////////////////////////////
// ASSERT's and TRACE's without debug CRT's
#if defined (DBG)
  #if !defined (_DEBUG)
    #define _USE_DSA_TRACE
    #define _USE_DSA_ASSERT
    #define _USE_DSA_TIMER
  #endif
#endif

#include "dbg.h"
///////////////////////////////////////////



#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module


class CDomainAdminModule : public CComModule
{
public:
	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);
};

#define DECLARE_REGISTRY_CLSID() \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
{ \
		return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister); \
}

extern CDomainAdminModule _Module;

#include <atlcom.h>
#include <atlwin.h>
#include <mmc.h>
#include <afxcmn.h>
#include <afxtempl.h>
#include <dsgetdc.h>
#include <shlobj.h> // needed for dsclient.h
#include <dsclient.h>
#include <dsclintp.h>

#include <dspropp.h>
#include "propcfg.h"

#include <dscmn.h>
#include <dsadminp.h> // DS Admin utilities

const long UNINITIALIZED = -1;


/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL)
    {
        pObj->Release();
        pObj = NULL;
    }
    else
    {
        TRACE(_T("Release called on NULL interface ptr\n"));
    }
}

struct INTERNAL
{
    INTERNAL() { m_type = CCT_UNINITIALIZED; m_cookie = -1;};
    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;     // What context is the data object.
    MMC_COOKIE          m_cookie;   // What object the cookie represents
    CString             m_string;
    CString             m_class;

    INTERNAL & operator=(const INTERNAL& rhs)
    {
        if (&rhs == this)
            return *this;

        m_type = rhs.m_type;
        m_cookie = rhs.m_cookie;
        m_string = rhs.m_string;

        return *this;
    }

    BOOL operator==(const INTERNAL& rhs)
    {
        return rhs.m_string == m_string;
    }
};


// Debug instance counter
#ifdef _DEBUG

inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)
#endif

/////////////////////////////////////////////////////////////////////

#include "stdabout.h"
#include "MyBasePathsInfo.h"
#include <secondaryProppages.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\cert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       cert.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	Cert.cpp
//
//	This file is the implementation of the CCertificate object.
//
//	GLOSSARY
//	- BLOB		Binary Large Object
//	- DER		Distinguished Encoding Rules
//	- RDN		Relative Distinguished Names
//
//	HISTORY
//	19-Jun-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "common.h"
#include "cert.h"


/////////////////////////////////////////////////////////////////////
CCertificate::CCertificate()
	{
	m_paCertContext = NULL;
	m_blobCertData.pbData = NULL;
	}

CCertificate::~CCertificate()
	{
	// Free the certificate
	::CertFreeCertificateContext(m_paCertContext);
	delete m_blobCertData.pbData;
	}


void DisplaySystemError (HWND hParent, DWORD dwErr)
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	LPVOID	lpMsgBuf;
		
	FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,    
			NULL,
			dwErr,
			MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			 (LPTSTR) &lpMsgBuf,    0,    NULL);
		
	// Display the string.
	CString	caption;
	VERIFY (caption.LoadString (IDS_ADD_CERTIFICATE_MAPPING));
	::MessageBox (hParent, (LPWSTR) lpMsgBuf, (LPCTSTR) caption, MB_OK | MB_ICONINFORMATION);
	// Free the buffer.
	LocalFree (lpMsgBuf);
}

// This code copied from CertMgr project - LOCATE.C  
BOOL CCertificate::FLoadCertificate (LPCTSTR szFile)
{
	ASSERT (szFile);
	if ( !szFile )
		return FALSE;

	BOOL			bReturn = FALSE;
    PVOID			FileNameVoidP = (PVOID) szFile;
    PCCERT_CONTEXT  pCertContext = NULL;
    DWORD			dwEncodingType = 0;
    DWORD			dwContentType = 0;
    DWORD			dwFormatType = 0;

	// NB.  It's possible to read in a serialized store at this point, too.
	// We've have to add the UI to display the certs in the file so the
	// user could pick one.  Use CryptUIDlgSelectCertificate ().
    bReturn = ::CryptQueryObject (
			CERT_QUERY_OBJECT_FILE,
			FileNameVoidP,
			CERT_QUERY_CONTENT_FLAG_ALL, //CERT_QUERY_CONTENT_CERT | CERT_QUERY_CONTENT_SERIALIZED_CERT,
			CERT_QUERY_FORMAT_FLAG_ALL,
			0,
			&dwEncodingType,
			&dwContentType,
			&dwFormatType,
			NULL,
			NULL,
			(const void **)&pCertContext);

	ASSERT (bReturn);
    if ( bReturn ) 
	{
        //
        // Success. See what we get back.
        //

		if ( (dwContentType != CERT_QUERY_CONTENT_CERT) || !pCertContext ) 
		{
            //
            // Not a valid cert file.
            //
            if  ( pCertContext )
                ::CertFreeCertificateContext (pCertContext);

            CString text;
			CString	caption;

            VERIFY (text.LoadString (IDS_CERTFILEFORMATERR));
			VERIFY (caption.LoadString (IDS_ADD_CERTIFICATE_MAPPING));
            MessageBox (NULL, text, caption, MB_OK | MB_ICONINFORMATION);
            bReturn = FALSE;
        }
		else
		{
			// Cert context is valid - let's save it to the global handle
			m_paCertContext = pCertContext;
		}
	}
	else
	{
		DWORD	dwErr = GetLastError ();

		DisplaySystemError (NULL, dwErr);
	}

	return bReturn;
}


/////////////////////////////////////////////////////////////////////
//	This routine is a wrapper to API ::CertNameToStr() automatically
//	calculating the length of the output string and returning the data
//	into the CString object.
void CCertificate::CertNameToCString(
	IN DWORD dwCertEncodingType,
	IN CERT_NAME_BLOB * pName,
	OUT CString * pstrData)
	{
	ASSERT(pstrData != NULL);
	// Calculate how many characters are needed
	int cch = ::CertNameToStr(
        IN dwCertEncodingType,
		IN pName,
		IN c_dwCertNameStrType,
		NULL, 0);
	TCHAR * pchT = pstrData->GetBuffer(cch);
	ASSERT(pchT != NULL);
	ASSERT(lstrlen(pchT) == 0);
	(void)::CertNameToStr(
		IN dwCertEncodingType,
		IN pName,
		IN c_dwCertNameStrType,
		OUT pchT, IN cch);
	pstrData->ReleaseBuffer();
	} // CCertificate::CertNameToCString()


/////////////////////////////////////////////////////////////////////
void CCertificate::GetIssuer(OUT CString * pstrName)
	{
	ASSERT(pstrName != NULL);
	ASSERT(m_paCertContext != NULL);
	ASSERT(m_paCertContext->pCertInfo != NULL);

	CERT_INFO * pCertInfo = m_paCertContext->pCertInfo;

	BOOL fSelfIssued = CertCompareCertificateName(
			m_paCertContext->dwCertEncodingType,
			&pCertInfo->Subject,
			&pCertInfo->Issuer);
	if (fSelfIssued)
		{
		// Self issued certificate
		GetSubject(OUT pstrName);
		return;
		}
	// Get the issuer
	CertNameToCString(
		IN m_paCertContext->dwCertEncodingType,
		IN &pCertInfo->Issuer,
		OUT pstrName);
	} // CCertificate::GetIssuer()


/////////////////////////////////////////////////////////////////////
void CCertificate::GetSubject(OUT CString * pstrName)
	{
	ASSERT(pstrName != NULL);
	ASSERT(m_paCertContext != NULL);
	ASSERT(m_paCertContext->pCertInfo != NULL);

	CertNameToCString(
		IN m_paCertContext->dwCertEncodingType,
		IN &m_paCertContext->pCertInfo->Subject,
		OUT pstrName);
	} // CCertificate::GetSubject()


/////////////////////////////////////////////////////////////////////
void CCertificate::GetAltSubject(OUT CString * pstrName)
	{
	ASSERT(pstrName != NULL);
	ASSERT(m_paCertContext != NULL);
	ASSERT(m_paCertContext->pCertInfo != NULL);

	pstrName->Empty();
	CERT_INFO * pCertInfo = m_paCertContext->pCertInfo;
	CERT_EXTENSION * pCertExtension;

	// Search for the AltSubject in the extensions
	pCertExtension = ::CertFindExtension(
		IN szOID_SUBJECT_ALT_NAME, // Same as X509_ALTERNATE_NAME
		IN pCertInfo->cExtension,
		IN pCertInfo->rgExtension);
	if (pCertExtension == NULL)
		return;		// No AltSubject

	DWORD dwErr = ERROR_SUCCESS;
	BOOL fSuccess;
	DWORD cbData = 0;
	// Find out how many bytes are needed for AltSubject
	fSuccess = ::CryptDecodeObject(
		m_paCertContext->dwCertEncodingType,
		X509_ALTERNATE_NAME,
		IN pCertExtension->Value.pbData,
		IN pCertExtension->Value.cbData,
		0,	// dwFlags
		NULL,
		INOUT &cbData);
	if (!fSuccess)
		{
		dwErr = ::GetLastError();
		TRACE1("CryptDecodeObject() returned error %u", dwErr);
		return;
		}
	ASSERT(cbData > 0);
	BYTE * pbDataT = new BYTE[cbData];

	// Decode the AltSubject name
	fSuccess = ::CryptDecodeObject(
		m_paCertContext->dwCertEncodingType,
		X509_ALTERNATE_NAME,
		IN pCertExtension->Value.pbData,
		IN pCertExtension->Value.cbData,
		0,	// dwFlags
		OUT pbDataT,
		INOUT &cbData);
	if (!fSuccess)
		{
		dwErr = ::GetLastError();
		TRACE1("CryptDecodeObject() returned error %u", dwErr);
		}
	else
		{
		CERT_ALT_NAME_INFO * pCertAltNameInfo = (CERT_ALT_NAME_INFO *)pbDataT;
		CERT_ALT_NAME_ENTRY * pEntry = pCertAltNameInfo->rgAltEntry;
		ASSERT(pEntry != NULL);
		for (UINT i = 0; i < pCertAltNameInfo->cAltEntry; i++, pEntry++)
			{
			if (pEntry->dwAltNameChoice == CERT_ALT_NAME_DNS_NAME)
				{
				*pstrName = pEntry->pwszDNSName;
				break;
				}

			} // for
		} // if...else
	delete pbDataT;
	} // CCertificate::GetAltSubject()

/////////////////////////////////////////////////////////////////////
void CCertificate::GetSimString(OUT CString * pstrData)
	{
	ASSERT(pstrData != NULL);

	CString strIssuer;
	CString strSubject;
	CString strAltSubject;
	GetIssuer(OUT &strIssuer);
	GetSubject(OUT &strSubject);
	GetAltSubject(OUT &strAltSubject);

	LPTSTR * pargzpszIssuer = ParseSimString(strIssuer);
	LPTSTR * pargzpszSubject = ParseSimString(strSubject);
	LPTSTR * pargzpszAltSubject = ParseSimString(strAltSubject);

	// Make a "X509" string
	UnsplitX509String(OUT pstrData, pargzpszIssuer, pargzpszSubject, pargzpszAltSubject);
	
	delete pargzpszIssuer;
	delete pargzpszSubject;
	delete pargzpszAltSubject;
	} // CCertificate::GetSimString()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\cert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       cert.h
//
//--------------------------------------------------------------------------

//	Cert.h

#ifndef __CERT_H_INCLUDED__
#define __CERT_H_INCLUDED__

#include "util.h"	// structure TBLOB

class CCertificate
{
protected:
	PCCERT_CONTEXT m_paCertContext;		// Pointer to allocated certificate
	TBLOB m_blobCertData;				// Raw data read from the file

	// Default flag for CertNameToStr()
	enum { c_dwCertNameStrType = CERT_X500_NAME_STR };

public:
	CCertificate();
	~CCertificate();

	BOOL FLoadCertificate(LPCTSTR szFile);
	
	void CertNameToCString(
		IN DWORD dwCertEncodingType,
		IN CERT_NAME_BLOB * pName,
		OUT CString * pstrData);

	void GetIssuer(OUT CString * pstrName);
	void GetSubject(OUT CString * pstrName);
	void GetAltSubject(OUT CString * pstrName);
	void GetSimString(OUT CString * pstrData);

}; // CCertificate

// Those strings are not subject to localization
const TCHAR szX509[]			= _T("X509:");
const TCHAR szKerberos[]		= _T("Kerberos:");

#define cchX509					(ARRAYLEN(szX509) - 1)
#define cchKerberos				(ARRAYLEN(szKerberos) - 1)

// Strings with angle brackets
const TCHAR szSimIssuer[]		= _T("<I>");
const TCHAR szSimSubject[]		= _T("<S>");
const TCHAR szSimAltSubject[]	= _T("<AS>");

#endif // ~__CERT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\contextmenu.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ContextMenu.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "dsutil.h"

#include "ContextMenu.h"
#include "dsfilter.h"
#include "resource.h"
#include "query.h"


/////////////////////////////////////////////////////////////////////
// Language independent IDs for known context menu items
// WARNING : these should NEVER be changed 
//           the whole point of having these is so that other
//           developers can rely on them being the same no matter
//           what language or version they use.  The context menus
//           can change but their IDs should not
//
//
#define CMID_GEN_TASK_SELECT_FOREST     L"_DSADMIN_SELECT_FOREST"
#define CMID_GEN_TASK_SELECT_DOMAIN     L"_DSADMIN_SELECT_DOMAIN"
#define CMID_GEN_TASK_SELECT_DC         L"_DSADMIN_SELECT_DC"
#define CMID_GEN_TASK_EDIT_FSMO         L"_DSADMIN_EDIT_FSMO"
#define CMID_GEN_TASK_RAISE_VERSION     L"_DSADMIN_GEN_RAISE_VERSION"
#define CMID_VIEW_SERVICES_NODE         L"_DSADMIN_VIEW_SERVICES"
#define CMID_VIEW_COMPUTER_HACK         L"_DSADMIN_VIEW_COMPUTERS_AS_CONTAINERS"
#define CMID_VIEW_ADVANCED              L"_DSADMIN_VIEW_ADVANCED"
#define CMID_IMPORT_QUERY               L"_DSADMIN_IMPORT_QUERY"
#define CMID_NEW_QUERY_FOLDER           L"_DSADMIN_NEW_QUERY"
#define CMID_NEW_FAVORITES_FOLDER       L"_DSADMIN_NEW_FAVORITES"
#define CMID_EDIT_QUERY                 L"_DSADMIN_EDIT_QUERY"
#define CMID_EXPORT_QUERY               L"_DSADMIN_EXPORT_QUERY"
#define CMID_VIEW_FILTER_OPTIONS        L"_DSADMIN_VIEW_FILTER"
#define CMID_DS_OBJECT_FIND             L"_DSADMIN_FIND"
#define CMID_GEN_TASK_RUN_KCC           L"_DSADMIN_RUN_KCC"
#define CMID_GEN_TASK_MOVE              L"_DSADMIN_MOVE"


void CContextMenuVerbs::LoadStandardVerbs(IConsoleVerb* pConsoleVerb, 
                                          BOOL bScope, 
                                          BOOL bSelect, 
                                          CUINode* pUINode,
                                          LPDATAOBJECT pDataObject) 
{
  if (!bSelect || pUINode == NULL)
  {
    return;
  }

  if (pConsoleVerb)
  {

    if (bScope)
    {
      //
      // Item is in scope pane. Therefore it is a container.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }
    else
    {
      //
      // Item is in result pane. Make properties the default verb.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    }

    CInternalFormatCracker ifc;
    if (pDataObject != NULL)
    {
      if (FAILED(ifc.Extract(pDataObject)))
      {
        return;
      }
    }

    //
    // Verbs supported by all items, except root
    //
    if (pDataObject != NULL && ifc.GetCookieCount() > 1) 
    {
      //
      // multiple selection
      //
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);

      //
      // Can delete
      //
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

      //
      // Properties
      //
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

      //
      // Can cut
      //
      // NOTICE: we use the same logic as the delete verb: we
      // always allow cut, even though the single items in the
      // multiple selection might have Cut turned off.
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, TRUE);

      //
      // Can copy
      //
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, FALSE);


    }
    else  // single selection
    {
      BOOL bEnable = FALSE;
      BOOL bHide = TRUE;

      //
      // Properties
      //
      bEnable = pUINode->ArePropertiesAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, bEnable);

      //
      // Rename
      //
      bEnable = pUINode->IsRenameAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, bEnable);

      //
      // Delete
      //
      bEnable = pUINode->IsDeleteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, bEnable);

      //
      // Refresh
      //
      bEnable = pUINode->IsRefreshAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, bEnable);

      //
      // Cut
      //

      bEnable = pUINode->IsCutAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, bEnable);
      
      //
      // Copy
      //
      bEnable = pUINode->IsCopyAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, bEnable);
      
      //
      // Paste
      //
      bEnable = pUINode->IsPasteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, bEnable);

      //
      // Print
      //
      bEnable = pUINode->IsPrintAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, bEnable);
    }
  }
}

HRESULT CContextMenuVerbs::DSLoadAndAddMenuItem(IContextMenuCallback2* pIContextMenuCallback,
                                                  UINT nResourceID, // contains text and status text seperated by '\n'
                                                  long lCommandID,
                                                  long lInsertionPointID,
                                                  long fFlags,
                                                  PCWSTR pszLanguageIndependentID,
                                                  long fSpecialFlags)
{
  ASSERT( pIContextMenuCallback != NULL );

  // load the resource
  CString strText;
  strText.LoadString( nResourceID );
  ASSERT( !strText.IsEmpty() );

  // split the resource into the menu text and status text
  CString strStatusText;
  int iSeparator = strText.Find(_T('\n'));
  if (0 > iSeparator)
  {
    ASSERT( FALSE );
    strStatusText = strText;
  }
  else
  {
    strStatusText = strText.Right( strText.GetLength()-(iSeparator+1) );
    strText = strText.Left( iSeparator );
  }

  // add the menu item
  USES_CONVERSION;
  CONTEXTMENUITEM2 contextmenuitem;
  ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
  contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strText));
  contextmenuitem.strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strStatusText));
  contextmenuitem.lCommandID = lCommandID;
  contextmenuitem.lInsertionPointID = lInsertionPointID;
  contextmenuitem.fFlags = fFlags;
  contextmenuitem.fSpecialFlags = ((fFlags & MF_POPUP) ? CCM_SPECIAL_SUBMENU : 0L) | fSpecialFlags;
  contextmenuitem.strLanguageIndependentName = const_cast<PWSTR>(pszLanguageIndependentID);
  HRESULT hr = pIContextMenuCallback->AddItem( &contextmenuitem );
  ASSERT(hr == S_OK);
  
  return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSnapinRootMenuVerbs
//

HRESULT CSnapinRootMenuVerbs::LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                                          CUINode*) 
{
  TRACE(_T("CSnapinRootMenuVerbs::LoadTopMenu()\n"));
  HRESULT hr = S_OK;
  UINT nMenuItem = 0;
  PCWSTR pszLIID = NULL;

  if (m_pComponentData->QuerySnapinType() == SNAPINTYPE_SITE)
  {
    nMenuItem = IDM_GEN_TASK_SELECT_FOREST;
    pszLIID = CMID_GEN_TASK_SELECT_FOREST;
  }
  else
  {
    nMenuItem = IDM_GEN_TASK_SELECT_DOMAIN;
    pszLIID = CMID_GEN_TASK_SELECT_DOMAIN;
  }

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             nMenuItem,
                             nMenuItem,
                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                             0,
                             pszLIID);
  ASSERT(SUCCEEDED(hr));

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_GEN_TASK_SELECT_DC,
                             IDM_GEN_TASK_SELECT_DC,
                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                             0,
                             pszLIID);
  ASSERT(SUCCEEDED(hr));

  if (m_pComponentData->QuerySnapinType() != SNAPINTYPE_SITE &&
      m_pComponentData->GetBasePathsInfo()->IsInitialized())
  {
    //
    // Load Operations Masters... menu
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_EDIT_FSMO,
                               IDM_GEN_TASK_EDIT_FSMO,
                               CCM_INSERTIONPOINTID_PRIMARY_TOP,
                               0,
                               CMID_GEN_TASK_EDIT_FSMO);
    ASSERT(SUCCEEDED(hr));

    //
    // Load Raise Domain Version... menu item.
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_RAISE_VERSION,
                               IDM_GEN_TASK_RAISE_VERSION,
                               CCM_INSERTIONPOINTID_PRIMARY_TOP,
                               0,
                               CMID_GEN_TASK_RAISE_VERSION);
    ASSERT(SUCCEEDED(hr));
  }

  return hr;
}

HRESULT CSnapinRootMenuVerbs::LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback,
                                           CUINode*) 
{
  TRACE(_T("CSnapinRootMenuVerbs::LoadTaskMenu()\n"));
  HRESULT hr = S_OK;
  UINT nMenuItem = 0;
  PWSTR pszLIID = NULL;

  if (m_pComponentData->QuerySnapinType() == SNAPINTYPE_SITE)
  {
    nMenuItem = IDM_GEN_TASK_SELECT_FOREST;
    pszLIID = CMID_GEN_TASK_SELECT_FOREST;
  }
  else
  {
    nMenuItem = IDM_GEN_TASK_SELECT_DOMAIN;
    pszLIID = CMID_GEN_TASK_SELECT_DOMAIN;
  }

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             nMenuItem,
                             nMenuItem,
                             CCM_INSERTIONPOINTID_PRIMARY_TASK,
                             0,
                             pszLIID);
  ASSERT(SUCCEEDED(hr));

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_GEN_TASK_SELECT_DC,
                             IDM_GEN_TASK_SELECT_DC,
                             CCM_INSERTIONPOINTID_PRIMARY_TASK,
                             0,
                             pszLIID);
  ASSERT(SUCCEEDED(hr));

  if (m_pComponentData->QuerySnapinType() != SNAPINTYPE_SITE &&
      m_pComponentData->GetBasePathsInfo()->IsInitialized())
  {
    //
    // Load Operations Masters... menu
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_EDIT_FSMO,
                               IDM_GEN_TASK_EDIT_FSMO,
                               CCM_INSERTIONPOINTID_PRIMARY_TASK,
                               0,
                               CMID_GEN_TASK_EDIT_FSMO);
    ASSERT(SUCCEEDED(hr));

    //
    // Load Raise Domain Version... menu item.
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_RAISE_VERSION,
                               IDM_GEN_TASK_RAISE_VERSION,
                               CCM_INSERTIONPOINTID_PRIMARY_TASK,
                               0,
                               CMID_GEN_TASK_RAISE_VERSION);
    ASSERT(SUCCEEDED(hr));
  }

  return hr;
}

HRESULT CSnapinRootMenuVerbs::LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, 
                                           CUINode*) 
{
  HRESULT hr = S_OK;

  if (m_pComponentData->QuerySnapinType() == SNAPINTYPE_SITE)
  {
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_VIEW_SERVICES_NODE,
                               IDM_VIEW_SERVICES_NODE,
                               CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                               m_pComponentData->ViewServicesNode()? MF_CHECKED : 0,
                               CMID_VIEW_SERVICES_NODE);
    ASSERT(SUCCEEDED(hr));
  }
  else
  {
    //
    // AD U&G
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                           IDM_VIEW_COMPUTER_HACK,
                           IDM_VIEW_COMPUTER_HACK,
                           CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                           m_pComponentData->ExpandComputers()? MF_CHECKED : 0,
                           CMID_VIEW_COMPUTER_HACK);
    ASSERT(SUCCEEDED(hr));

    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_VIEW_ADVANCED,
                               IDM_VIEW_ADVANCED,
                               CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                               m_pComponentData->GetQueryFilter()->IsAdvancedView()? MF_CHECKED : 0,
                               CMID_VIEW_ADVANCED);
    ASSERT(SUCCEEDED(hr));
  }

  return hr;
} 

/////////////////////////////////////////////////////////////////////////////
// CFavoritesFolderMenuVerbs
//

void CFavoritesFolderMenuVerbs::LoadStandardVerbs(IConsoleVerb* pConsoleVerb, 
                                                  BOOL bScope, 
                                                  BOOL bSelect, 
                                                  CUINode* pUINode,
                                                  LPDATAOBJECT pDataObject) 
{
  if (!bSelect || pUINode == NULL)
  {
    return;
  }

  if (pConsoleVerb)
  {

    if (bScope)
    {
      //
      // Item is in scope pane. Therefore it is a container.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }
    else
    {
      //
      // Item is in result pane. Make properties the default verb.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    }

    CInternalFormatCracker ifc;
    if (pDataObject != NULL)
    {
      if (FAILED(ifc.Extract(pDataObject)))
      {
        return;
      }
    }

    //
    // Verbs supported by all items, except root
    //
    if (pDataObject != NULL && ifc.GetCookieCount() > 1) 
    {
      //
      // multiple selection
      //
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);

      //
      // Can delete
      //
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

      //
      // Properties
      //
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);

      //
      // Can cut
      //
      // NOTICE: we use the same logic as the delete verb: we
      // always allow cut, even though the single items in the
      // multiple selection might have Cut turned off.
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, TRUE);

      //
      // Can copy
      //
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, TRUE);


    }
    else  // single selection
    {
      BOOL bEnable = FALSE;
      BOOL bHide = TRUE;

      //
      // Properties
      //
      bEnable = pUINode->ArePropertiesAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, bEnable);

      //
      // Rename
      //
      bEnable = pUINode->IsRenameAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, bEnable);

      //
      // Delete
      //
      bEnable = pUINode->IsDeleteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, bEnable);

      //
      // Refresh
      //
      bEnable = pUINode->IsRefreshAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, bEnable);
      
      //
      // Paste
      //
      bEnable = pUINode->IsPasteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, bEnable);

      //
      // Cut
      //
      bEnable = pUINode->IsCutAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, bEnable);
      
      //
      // Copy
      //
      bEnable = pUINode->IsCopyAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, bEnable);

      //
      // Print
      //
      bEnable = pUINode->IsPrintAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, bEnable);
    }
  }
}


HRESULT CFavoritesFolderMenuVerbs::LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                                               CUINode*) 
{
  HRESULT hr = S_OK;
  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_IMPORT_QUERY,
                             IDM_IMPORT_QUERY,
                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                             0,
                             CMID_IMPORT_QUERY);
  ASSERT(SUCCEEDED(hr));
  return hr;
}

HRESULT CFavoritesFolderMenuVerbs::LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback,
                                                CUINode*) 
{
  HRESULT hr = S_OK;

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_IMPORT_QUERY,
                             IDM_IMPORT_QUERY,
                             CCM_INSERTIONPOINTID_PRIMARY_TASK,
                             0,
                             CMID_IMPORT_QUERY);
  ASSERT(SUCCEEDED(hr));
  return hr;
}

HRESULT CFavoritesFolderMenuVerbs::LoadNewMenu(IContextMenuCallback2* pContextMenuCallback,
                                               IShellExtInit*,
                                               LPDATAOBJECT,
                                               CUINode*,
                                               long*) 
{
  HRESULT hr = S_OK;

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_NEW_QUERY_FOLDER,
                             IDM_NEW_QUERY_FOLDER,
                             CCM_INSERTIONPOINTID_PRIMARY_NEW,
                             0,
                             CMID_NEW_QUERY_FOLDER);

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_NEW_FAVORITES_FOLDER,
                             IDM_NEW_FAVORITES_FOLDER,
                             CCM_INSERTIONPOINTID_PRIMARY_NEW,
                             0,
                             CMID_NEW_FAVORITES_FOLDER);
  return hr;
}

HRESULT CFavoritesFolderMenuVerbs::LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, 
                                           CUINode*) 
{
  HRESULT hr = S_OK;

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_VIEW_ADVANCED,
                             IDM_VIEW_ADVANCED,
                             CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                             m_pComponentData->GetQueryFilter()->IsAdvancedView()? MF_CHECKED : 0,
                             CMID_VIEW_ADVANCED);
  ASSERT(SUCCEEDED(hr));

  return hr;
} 



/////////////////////////////////////////////////////////////////////////////
// CSavedQueryMenuVerbs
//

void CSavedQueryMenuVerbs::LoadStandardVerbs(IConsoleVerb* pConsoleVerb, 
                                             BOOL bScope, 
                                             BOOL bSelect, 
                                             CUINode* pUINode,
                                             LPDATAOBJECT pDataObject) 
{
  if (!bSelect || pUINode == NULL)
  {
    return;
  }

  if (pConsoleVerb)
  {

    if (bScope)
    {
      //
      // Item is in scope pane. Therefore it is a container.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }
    else
    {
      //
      // Item is in result pane. Make properties the default verb.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    }

    CInternalFormatCracker ifc;
    if (pDataObject != NULL)
    {
      if (FAILED(ifc.Extract(pDataObject)))
      {
        return;
      }
    }

    //
    // Verbs supported by all items, except root
    //
    if (pDataObject != NULL && ifc.GetCookieCount() > 1) 
    {
      //
      // multiple selection
      //
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);

      //
      // Can delete
      //
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

      //
      // Properties
      //
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);

      //
      // Can cut
      //
      // NOTICE: we use the same logic as the delete verb: we
      // always allow cut, even though the single items in the
      // multiple selection might have Cut turned off.
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, TRUE);

      //
      // Can copy
      //
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, TRUE);


    }
    else  // single selection
    {
      BOOL bEnable = FALSE;
      BOOL bHide = TRUE;

      //
      // Properties
      //
      bEnable = pUINode->ArePropertiesAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, bEnable);

      //
      // Rename
      //
      bEnable = pUINode->IsRenameAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, bEnable);

      //
      // Delete
      //
      bEnable = pUINode->IsDeleteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, bEnable);

      //
      // Refresh
      //
      bEnable = pUINode->IsRefreshAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, bEnable);

      //
      // Cut
      //

      bEnable = pUINode->IsCutAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, bEnable);
      
      //
      // Copy
      //
      bEnable = pUINode->IsCopyAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, bEnable);
      
      //
      // Paste
      //
      bEnable = pUINode->IsPasteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, bEnable);

      //
      // Cut
      //
      bEnable = pUINode->IsCutAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, bEnable);
      
      //
      // Print
      //
      bEnable = pUINode->IsPrintAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, bEnable);
    }
  }
}

HRESULT CSavedQueryMenuVerbs::LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                                          CUINode*) 
{
  HRESULT hr = S_OK;

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_EDIT_QUERY,
                             IDM_EDIT_QUERY,
                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                             0,
                             CMID_EDIT_QUERY);
  ASSERT(SUCCEEDED(hr));

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_EXPORT_QUERY,
                             IDM_EXPORT_QUERY,
                             CCM_INSERTIONPOINTID_PRIMARY_TOP,
                             0,
                             CMID_EXPORT_QUERY);
  ASSERT(SUCCEEDED(hr));
  return hr;
}

HRESULT CSavedQueryMenuVerbs::LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback,
                                           CUINode*) 
{
  HRESULT hr = S_OK;

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_EDIT_QUERY,
                             IDM_EDIT_QUERY,
                             CCM_INSERTIONPOINTID_PRIMARY_TASK,
                             0,
                             CMID_EDIT_QUERY);
  ASSERT(SUCCEEDED(hr));

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_EXPORT_QUERY,
                             IDM_EXPORT_QUERY,
                             CCM_INSERTIONPOINTID_PRIMARY_TASK,
                             0,
                             CMID_EXPORT_QUERY);
  ASSERT(SUCCEEDED(hr));
  return hr;
}

HRESULT CSavedQueryMenuVerbs::LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, 
                                           CUINode*) 
{
  HRESULT hr = S_OK;

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_VIEW_ADVANCED,
                             IDM_VIEW_ADVANCED,
                             CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                             m_pComponentData->GetQueryFilter()->IsAdvancedView()? MF_CHECKED : 0,
                             CMID_VIEW_ADVANCED);
  ASSERT(SUCCEEDED(hr));

  return hr;
} 

/////////////////////////////////////////////////////////////////////////////
// CDSContextMenuVerbs
//

HRESULT CDSContextMenuVerbs::LoadNewMenu(IContextMenuCallback2* pContextMenuCallback,
                                         IShellExtInit* pShlInit,
                                         LPDATAOBJECT pDataObject,
                                         CUINode* pUINode,
                                         long *pInsertionAllowed) 
{
  HRESULT hr = S_OK;
  UINT cChildCount = 0;
  UINT index;

  if (pUINode == NULL) 
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  CDSCookie* pCookie = NULL;
  ASSERT(IS_CLASS(*pUINode, CDSUINode));
  pCookie = GetDSCookieFromUINode(pUINode);
  ASSERT(pCookie != NULL);

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  TRACE(_T("CDSComponentData::_LoadNewMenu (on %s)\n"), pCookie->GetName());
  CWaitCursor cwait;

  WCHAR ** ppChildren;
  ppChildren = pCookie->GetChildList();
  if (ppChildren == NULL) 
  {
    m_pComponentData->FillInChildList (pCookie);
    ppChildren = pCookie->GetChildList();
  }
  

  ///////////////////////////////////////////////////////////
  // get common menu items from DS and merge.
  //
  HMENU hDSMenu = CreatePopupMenu();
  if (hDSMenu == NULL)
  {
    TRACE(_T("Failed to CreatePopupMenu() in CDSContextMenuVerbs::LoadNewMenu()"));
    ASSERT(FALSE);
    return GetLastError();
  }

  BOOL fRet = TRUE;
  hr = pShlInit->Initialize(NULL, pDataObject, 0);
  if (FAILED(hr)) 
  {
    TRACE(TEXT("pShlInit->Initialize failed, hr: 0x%x\n"), hr);
  } 
  else 
  {
    IContextMenu * pICM= NULL;
    hr = pShlInit->QueryInterface(IID_IContextMenu, (void **)&pICM);
    
    if (FAILED(hr)) 
    {
      TRACE(TEXT("pShlInit->QI for IID_IContextMenu failed, hr: 0x%x\n"), hr);
    } 
    else 
    {
      //
      // NOTE: QueryContextMenu returns with the HRESULT with the severity set as normal
      //       for success and failure but the facility is zero and the code is the 
      //       count of the menu items added
      //
      hr = pICM->QueryContextMenu (hDSMenu, 0, MENU_MERGE_BASE, MENU_MERGE_LIMIT, NULL);
      if ((SUCCEEDED(hr)) && (HRESULT_CODE(hr) > 0)) 
      {
        UINT cItems = GetMenuItemCount (hDSMenu);
        MENUITEMINFO miiItem;
        miiItem.cbSize = sizeof(MENUITEMINFO);
        WCHAR szBuffer[MAX_PATH];

        for (index = 0; index < cItems; index++) 
        {
          miiItem.fMask = MIIM_TYPE | MIIM_DATA | MIIM_ID | MIIM_SUBMENU | MIIM_STATE;
          WCHAR * pszString = new WCHAR[MAX_PATH];
          miiItem.dwTypeData = pszString;
          miiItem.cch = MAX_PATH;
          fRet = GetMenuItemInfo (hDSMenu, index, TRUE, &miiItem);
          if (fRet) 
          {
            //
            // got item back, add it to MMC context menu
            //
            CONTEXTMENUITEM2 ctiItem;
            ::ZeroMemory( &ctiItem, sizeof(CONTEXTMENUITEM2) );

            hr = pICM->GetCommandString (miiItem.wID - MENU_MERGE_BASE, 
                                         GCS_HELPTEXT,
                                         NULL, 
                                         (char *)szBuffer, 
                                         sizeof(szBuffer));

            ctiItem.strName = miiItem.dwTypeData;
            ctiItem.strStatusBarText = szBuffer;
            ctiItem.lCommandID = miiItem.wID;
            if (miiItem.fState == MFS_GRAYED) 
            {
              ctiItem.fFlags = MF_GRAYED;
            } 
            else 
            {
              ctiItem.fFlags = 0;
            }
            ctiItem.fSpecialFlags = 0;
            
            //
            // Now try to get a language independent identifier
            //
            WCHAR szLanguageIndependentID[MAX_PATH];
            ::ZeroMemory( szLanguageIndependentID, sizeof(WCHAR) * MAX_PATH);
            hr = pICM->GetCommandString(miiItem.wID - MENU_MERGE_BASE,
                                        GCS_VERBW,
                                        NULL,
                                        (char*)szLanguageIndependentID,
                                        sizeof(szLanguageIndependentID));
            if (SUCCEEDED(hr) && 
                szLanguageIndependentID && 
                szLanguageIndependentID[0] != 0)
            {
              ctiItem.strLanguageIndependentName = szLanguageIndependentID;

              //
              // Add the menu item to the Top of the MMC menu
              //
              if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
              {
                ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                hr = pContextMenuCallback->AddItem( &ctiItem );
                ASSERT(SUCCEEDED(hr));
              }

              if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
              {
                ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
                hr = pContextMenuCallback->AddItem(&ctiItem );
                ASSERT(SUCCEEDED(hr));
              }
            }
            else
            {
              CComPtr<IContextMenuCallback> spOldCallback;
              hr = pContextMenuCallback->QueryInterface(IID_IContextMenuCallback, (void**)&spOldCallback);
              if (SUCCEEDED(hr))
              {
                if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
                {
                  ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
                  hr = spOldCallback->AddItem((CONTEXTMENUITEM*)&ctiItem);
                  ASSERT(SUCCEEDED(hr));
                }

                if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
                {
                  ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                  hr = spOldCallback->AddItem((CONTEXTMENUITEM*)&ctiItem);
                  ASSERT(SUCCEEDED(hr));
                }
              }
            }
          }
          delete pszString;
        }
      }
    }
    if (pICM) 
    {
      pICM->Release();
    }
  }
  DestroyMenu(hDSMenu);

  ///////////////////////////////////////////////////////////
  // Insert the New menu items

  cChildCount = pCookie->GetChildCount();
  if (cChildCount != 0) 
  {
    for (index = 0; index < cChildCount; index++) 
    {
      CString strItem, strStatus;
      strItem = ppChildren[index];
      strStatus.LoadString(IDS_CREATEOBJ);
      
      UINT fFlags = 0;
      CONTEXTMENUITEM2 contextmenuitem;
      WCHAR wszFriendlyName[120];

      //
      // get localized name for class
      //
      hr = m_pComponentData->GetBasePathsInfo()->GetFriendlyClassName(ppChildren[index],
                                                                      wszFriendlyName, 
                                                                      sizeof(wszFriendlyName)/sizeof(WCHAR));
      if (SUCCEEDED(hr)) 
      {
        strItem = (CString)wszFriendlyName;
      } 
      else 
      {
        strItem = ppChildren[index];
      }
      
      ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
      contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strItem));
      contextmenuitem.strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strStatus));
      contextmenuitem.lCommandID = IDM_NEW_OBJECT_BASE + index;
      contextmenuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
      contextmenuitem.fFlags = fFlags;
      contextmenuitem.fSpecialFlags = ((fFlags & MF_POPUP) ? CCM_SPECIAL_SUBMENU : 0L);
      contextmenuitem.strLanguageIndependentName = ppChildren[index];
      
      if (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW)
      {
        hr = pContextMenuCallback->AddItem( &contextmenuitem );
        ASSERT(SUCCEEDED(hr));
      }

      if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
      {
        int nID = InsertAtTopContextMenu(pCookie->GetClass(), ppChildren[index]);
        if (0 != nID)
        {
          CString cstrNewObject;
          cstrNewObject.LoadString(nID);
          contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)cstrNewObject));
          contextmenuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
          hr = pContextMenuCallback->AddItem( &contextmenuitem );
          ASSERT(SUCCEEDED(hr));
        }
      }
    }
  }
  
  return hr;
}

int CDSContextMenuVerbs::InsertAtTopContextMenu(LPCWSTR pwszParentClass, LPCWSTR pwszChildClass)
{
  int nID = 0;

  if (!wcscmp(pwszParentClass, L"subnetContainer"))
  {

    if (!wcscmp(pwszChildClass, L"subnet"))
    {
      nID = IDS_NEW_SUBNET;
    }

  } 
  else if (!wcscmp(pwszParentClass, L"nTDSDSA")) 
  {

    if (!wcscmp(pwszChildClass, L"nTDSConnection"))
    {
      nID = IDS_NEW_NTDSCONNECTION;
    }
  } 
  else if (!wcscmp(pwszParentClass, L"interSiteTransport"))
  {

    if (!wcscmp(pwszChildClass, L"siteLink"))
    {
      nID = IDS_NEW_SITELINK;
    }
    else if (!wcscmp(pwszChildClass, L"siteLinkBridge"))
    {
      nID = IDS_NEW_SITELINKBRIDGE;
    }
  } 
  else if (!wcscmp(pwszParentClass, L"sitesContainer"))
  {
    if (!wcscmp(pwszChildClass, L"site"))
    {
      nID = IDS_NEW_SITE;
    }
  }

  return nID;
}

HRESULT CDSContextMenuVerbs::LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, 
                                          CUINode*) 
{
  HRESULT hr = S_OK;

  if ( m_pComponentData->IsPrimarySnapin())
  {
    //
    // Insert these if running as a primary snapin and not an extension
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_VIEW_FILTER_OPTIONS,
                               IDM_VIEW_FILTER_OPTIONS,
                               CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                               0,
                               CMID_VIEW_FILTER_OPTIONS);
  }

  return hr;
}

HRESULT CDSContextMenuVerbs::LoadMenuExtensions(IContextMenuCallback2* piCMenuCallback,
                                                IShellExtInit* pShlInit,
                                                LPDATAOBJECT pDataObject,
                                                CUINode*) 
{
  UINT index = 0;
  HRESULT hr = S_OK;
  
  ///////////////////////////////////////////////////////////
  // get common menu items from DS and merge.
  HMENU hDSMenu = CreatePopupMenu();
  if (hDSMenu == NULL)
  {
    TRACE(_T("Failed to CreatePopupMenu() in CDSContextMenuVerbs::LoadMenuExtensions()"));
    ASSERT(FALSE);
    return GetLastError();
  }

  BOOL fRet = TRUE;
  CInternalFormatCracker ObjCracker;
  LPDATAOBJECT pDO = NULL;

  pDO = ObjCracker.ExtractMultiSelect (pDataObject);
  if (pDO == NULL) 
  {
    pDO = pDataObject;
  }

  hr = pShlInit->Initialize(NULL, pDO, 0);
  if (FAILED(hr)) 
  {
    TRACE(TEXT("pShlInit->Initialize failed, hr: 0x%x\n"), hr);
  } 
  else 
  {
    IContextMenu * pICM= NULL;
    hr = pShlInit->QueryInterface(IID_IContextMenu, (void **)&pICM);
    
    if (FAILED(hr)) 
    {
      TRACE(TEXT("pShlInit->QI for IID_IContextMenu failed, hr: 0x%x\n"), hr);
    } 
    else 
    {
      //
      // NOTE: QueryContextMenu returns with the HRESULT with the severity set as normal
      //       for success and failure but the facility is zero and the code is the 
      //       count of the menu items added
      //
      hr = pICM->QueryContextMenu (hDSMenu, 0, MENU_MERGE_BASE, MENU_MERGE_LIMIT, NULL);
      if ((SUCCEEDED(hr)) && (HRESULT_CODE(hr) > 0)) 
      {
        UINT cItems = GetMenuItemCount (hDSMenu);
        MENUITEMINFO miiItem;
        miiItem.cbSize = sizeof(MENUITEMINFO);
        WCHAR szBuffer[MAX_PATH];

        for (index = 0; index < cItems; index++) 
        {
          miiItem.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
          WCHAR * pszString = new WCHAR[MAX_PATH];
          miiItem.dwTypeData = pszString;
          miiItem.cch = MAX_PATH;
          fRet = GetMenuItemInfo (hDSMenu, index, TRUE, &miiItem);
          if (fRet) 
          {
            // got item back, add it to MMC context menu
            CONTEXTMENUITEM2 ctiItem;
            ::ZeroMemory( &ctiItem, sizeof(CONTEXTMENUITEM2) );

            hr = pICM->GetCommandString (miiItem.wID - MENU_MERGE_BASE, 
                                         GCS_HELPTEXT,
                                         NULL, 
                                         (char *)szBuffer, 
                                         sizeof(szBuffer));

            ctiItem.strName = miiItem.dwTypeData;
            ctiItem.strStatusBarText = szBuffer;
            ctiItem.lCommandID = miiItem.wID;
            ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
            if (miiItem.fState == MF_GRAYED) 
            {
              ctiItem.fFlags = MF_GRAYED;
            } 
            else 
            {
              ctiItem.fFlags = 0;
            }
            ctiItem.fSpecialFlags = 0;
            
            //
            // Now try to retrieve the language independent ID
            //
            WCHAR szLanguageIndependentID[MAX_PATH];
            ::ZeroMemory( szLanguageIndependentID, sizeof(WCHAR) * MAX_PATH);
            hr = pICM->GetCommandString(miiItem.wID - MENU_MERGE_BASE,
                                        GCS_VERBW,
                                        NULL,
                                        (char*)szLanguageIndependentID,
                                        sizeof(szLanguageIndependentID));
            if (SUCCEEDED(hr) && 
                szLanguageIndependentID &&
                szLanguageIndependentID[0] != 0)
            {
              ctiItem.strLanguageIndependentName = szLanguageIndependentID;

              hr = piCMenuCallback->AddItem( &ctiItem );
              ASSERT(SUCCEEDED(hr));
              ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
              hr = piCMenuCallback->AddItem( &ctiItem );
            }
            else
            {
              CComPtr<IContextMenuCallback> spOldCallback;
              hr = piCMenuCallback->QueryInterface(IID_IContextMenuCallback, (void**)&spOldCallback);
              if (SUCCEEDED(hr))
              {
                hr = spOldCallback->AddItem( (CONTEXTMENUITEM*)&ctiItem );
                ASSERT(SUCCEEDED(hr));
                ctiItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
                hr = spOldCallback->AddItem( (CONTEXTMENUITEM*)&ctiItem );
              }
              ASSERT(SUCCEEDED(hr));
            }
          }
          delete pszString;
        }
      }
    }
    if (pICM) 
    {
      pICM->Release();
    }
  }
  DestroyMenu(hDSMenu);

  ///////////////////////////////////////////////////////////

  return hr;
  
}


///////////////////////////////////////////////////////////////////
// CDSAdminContextMenuVerbs
//

void CDSAdminContextMenuVerbs::LoadStandardVerbs(IConsoleVerb* pConsoleVerb, 
                                                 BOOL bScope, 
                                                 BOOL bSelect, 
                                                 CUINode* pUINode,
                                                 LPDATAOBJECT pDataObject) 
{
  CContextMenuVerbs::LoadStandardVerbs(pConsoleVerb, bScope, bSelect, pUINode, pDataObject);

}

HRESULT CDSAdminContextMenuVerbs::LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                                              CUINode* pUINode) 
{
  HRESULT hr = S_OK;

  hr = LoadTopTaskHelper(pContextMenuCallback, pUINode, CCM_INSERTIONPOINTID_PRIMARY_TOP);
  return hr;
}

HRESULT CDSAdminContextMenuVerbs::LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback,
                                               CUINode* pUINode)
{
  HRESULT hr = S_OK;

  hr = LoadTopTaskHelper(pContextMenuCallback, pUINode, CCM_INSERTIONPOINTID_PRIMARY_TASK);
  return hr;
}

HRESULT CDSAdminContextMenuVerbs::LoadTopTaskHelper(IContextMenuCallback2* pContextMenuCallback, 
                                                    CUINode* pUINode,
                                                    int insertionPoint)
{
  TRACE(_T("CDSAdminContextMenuVerbs::LoadTopTaskHelper()\n"));
  HRESULT hr = S_OK;
  ASSERT(IS_CLASS(*pUINode, CDSUINode));

  if (pUINode->IsContainer())
  {
    //
    // Load Find menu
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_DS_OBJECT_FIND,
                               IDM_DS_OBJECT_FIND,
                               insertionPoint,
                               0,
                               CMID_DS_OBJECT_FIND);
    ASSERT(SUCCEEDED(hr));
  }


  CDSCookie* pCookie = NULL;
  pCookie = GetDSCookieFromUINode(pUINode);
  if (pCookie == NULL)
  {
    ASSERT(FALSE);
    return E_FAIL;
  }

  CString szClass;
  szClass = pCookie->GetClass();

  if (szClass == L"domainDNS")
  {
    //
    // Load Connect to Domain... menu
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_SELECT_DOMAIN,
                               IDM_GEN_TASK_SELECT_DOMAIN,
                               insertionPoint,
                               0,
                               CMID_GEN_TASK_SELECT_DOMAIN);
    ASSERT( SUCCEEDED(hr) );

    //
    // Load Connect to Domain Controller... menu
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_SELECT_DC,
                               IDM_GEN_TASK_SELECT_DC,
                               insertionPoint,
                               0,
                               CMID_GEN_TASK_SELECT_DC);
    ASSERT( SUCCEEDED(hr) );

    //
    // Load Raise Domain Version... menu item.
    //
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_RAISE_VERSION,
                               IDM_GEN_TASK_RAISE_VERSION,
                               insertionPoint,
                               0,
                               CMID_GEN_TASK_RAISE_VERSION);
    ASSERT(SUCCEEDED(hr));

    if (m_pComponentData->GetBasePathsInfo()->IsInitialized())
    {
       //
       // Load Operations Masters... menu
       //
       hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                                  IDM_GEN_TASK_EDIT_FSMO,
                                  IDM_GEN_TASK_EDIT_FSMO,
                                  insertionPoint,
                                  0,
                                  CMID_GEN_TASK_EDIT_FSMO);
       ASSERT(SUCCEEDED(hr));
    }
  }
  return hr;
}

HRESULT CDSAdminContextMenuVerbs::LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, 
                                               CUINode* pUINode) 
{
  HRESULT hr = S_OK;
  
  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_VIEW_COMPUTER_HACK,
                             IDM_VIEW_COMPUTER_HACK,
                             CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                             m_pComponentData->ExpandComputers()? MF_CHECKED : 0,
                             CMID_VIEW_COMPUTER_HACK);
  ASSERT(SUCCEEDED(hr));

  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_VIEW_ADVANCED,
                             IDM_VIEW_ADVANCED,
                             CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                             m_pComponentData->GetQueryFilter()->IsAdvancedView()? MF_CHECKED : 0,
                             CMID_VIEW_ADVANCED);
  ASSERT(SUCCEEDED(hr));

  hr = CDSContextMenuVerbs::LoadViewMenu(pContextMenuCallback, pUINode);
  ASSERT(SUCCEEDED(hr));

  return hr;
}

///////////////////////////////////////////////////////////////////
// CSARContextMenuVerbs
//

void CSARContextMenuVerbs::LoadStandardVerbs(IConsoleVerb* pConsoleVerb, 
                                             BOOL bScope, 
                                             BOOL bSelect, 
                                             CUINode* pUINode,
                                             LPDATAOBJECT pDataObject) 
{
  ASSERT(IS_CLASS(*pUINode, CDSUINode));
  CDSCookie* pCookie = NULL;
  pCookie = GetDSCookieFromUINode(pUINode);

  CString szClass;
  szClass = pCookie->GetClass();

  if (!bSelect || pUINode == NULL)
  {
    return;
  }

  if (pConsoleVerb)
  {

    if (bScope)
    {
      //
      // Item is in scope pane. Therefore it is a container.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }
    else
    {
      //
      // Item is in result pane. Make properties the default verb.
      //
      pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    }

    CInternalFormatCracker ifc;
    if (pDataObject != NULL)
    {
      if (FAILED(ifc.Extract(pDataObject)))
      {
        return;
      }
    }

    //
    // Verbs supported by all items, except root
    //
    if (pDataObject != NULL && ifc.GetCookieCount() > 1) 
    {
      //
      // multiple selection
      //
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);

      //
      // Can delete
      //
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE);

      //
      // Properties
      //
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

      //
      // Can cut
      //
      // NOTICE: we are only allowing servers to be moved and since
      // servers are the only things in a serversContainer we enable
      // cut on multiselect only if the parent is a serversContainer
      //
      if (szClass.CompareNoCase(L"serversContainer"))
      {
        pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, FALSE);
        pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, TRUE);
      }
      else
      {
        pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, TRUE);
        pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, FALSE);
      }

      //
      // Can copy
      //
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, FALSE);


    }
    else  // single selection
    {
      BOOL bEnable = FALSE;
      BOOL bHide = TRUE;

      //
      // Properties
      //
      bEnable = pUINode->ArePropertiesAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, bEnable);

      //
      // Rename
      //
      bEnable = pUINode->IsRenameAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, bEnable);

      //
      // Delete
      //
      bEnable = pUINode->IsDeleteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, bEnable);

      //
      // Refresh
      //
      bEnable = pUINode->IsRefreshAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, bEnable);

      //
      // Cut
      //

      bEnable = pUINode->IsCutAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, bEnable);
      
      //
      // Copy
      //
      bEnable = pUINode->IsCopyAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, bEnable);
      
      //
      // Paste
      //
      bEnable = pUINode->IsPasteAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, bEnable);

      //
      // Print
      //
      bEnable = pUINode->IsPrintAllowed(m_pComponentData, &bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, bHide);
      pConsoleVerb->SetVerbState(MMC_VERB_PRINT, ENABLED, bEnable);
    }
  }

}

HRESULT CSARContextMenuVerbs::LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                                          CUINode* pUINode) 
{
  HRESULT hr = S_OK;

  hr = CDSContextMenuVerbs::LoadTopMenu(pContextMenuCallback, pUINode);
  ASSERT(SUCCEEDED(hr));

  hr = LoadTopTaskHelper(pContextMenuCallback, pUINode, CCM_INSERTIONPOINTID_PRIMARY_TOP);
  return hr;
}

HRESULT CSARContextMenuVerbs::LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback, 
                                           CUINode* pUINode) 
{
  HRESULT hr = S_OK;

  hr = CDSContextMenuVerbs::LoadTaskMenu(pContextMenuCallback, pUINode);
  ASSERT(SUCCEEDED(hr));

  hr = LoadTopTaskHelper(pContextMenuCallback, pUINode, CCM_INSERTIONPOINTID_PRIMARY_TASK);
  ASSERT(SUCCEEDED(hr));

  ASSERT(IS_CLASS(*pUINode, CDSUINode));
  CDSCookie* pCookie = NULL;
  pCookie = GetDSCookieFromUINode(pUINode);

  CString szClass;
  szClass = pCookie->GetClass();

  if (szClass == L"nTDSDSA")
  {
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_RUN_KCC,
                               IDM_GEN_TASK_RUN_KCC,
                               CCM_INSERTIONPOINTID_PRIMARY_TASK,
                               0,
                               CMID_GEN_TASK_RUN_KCC);
    ASSERT(SUCCEEDED(hr));
  }
  
  return hr;
}

HRESULT CSARContextMenuVerbs::LoadTopTaskHelper(IContextMenuCallback2* pContextMenuCallback, 
                                                CUINode* pUINode,
                                                int insertionPoint)
{
  HRESULT hr = S_OK;

  CDSCookie* pCookie = NULL;
  ASSERT(IS_CLASS(*pUINode, CDSUINode));
  pCookie = GetDSCookieFromUINode(pUINode);
  if (pCookie == NULL)
  {
    ASSERT(FALSE);
    return E_FAIL;
  }

  CString szClass;
  szClass = pCookie->GetClass();

  if ((szClass == L"domainOrganizationalUnit") ||
      (szClass == L"domainLocality"))
  {
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_SELECT_FOREST,
                               IDM_GEN_TASK_SELECT_FOREST,
                               insertionPoint,
                               0,
                               CMID_GEN_TASK_SELECT_FOREST);
    ASSERT(SUCCEEDED(hr));

    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_SELECT_DC,
                               IDM_GEN_TASK_SELECT_DC,
                               insertionPoint,
                               0,
                               CMID_GEN_TASK_SELECT_DC);
    ASSERT( SUCCEEDED(hr) );
  }

  int iSystemFlags = pCookie->GetSystemFlags();
  if ( iSystemFlags & (FLAG_CONFIG_ALLOW_MOVE | FLAG_CONFIG_ALLOW_LIMITED_MOVE) ) 
  {
    hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                               IDM_GEN_TASK_MOVE,
                               IDM_GEN_TASK_MOVE,
                               insertionPoint,
                               0,
                               CMID_GEN_TASK_MOVE);
    ASSERT( SUCCEEDED(hr) );
  }

  return hr;
}

HRESULT CSARContextMenuVerbs::LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, 
                                           CUINode* pUINode) 
{
  HRESULT hr = S_OK;

  hr = CDSContextMenuVerbs::LoadViewMenu(pContextMenuCallback, pUINode);
  ASSERT(SUCCEEDED(hr));

  /* View->Services Node should only be on the root
  hr = DSLoadAndAddMenuItem( pContextMenuCallback,
                             IDM_VIEW_SERVICES_NODE,
                             IDM_VIEW_SERVICES_NODE,
                             CCM_INSERTIONPOINTID_PRIMARY_VIEW,
                             m_pComponentData->ViewServicesNode()? MF_CHECKED : 0,
                             CMID_VIEW_SERVICES_NODE);
  ASSERT(SUCCEEDED(hr));
*/
  return hr;
} 

HRESULT CSARContextMenuVerbs::LoadMainMenu(IContextMenuCallback2* piCMenuCallback,
                                          LPDATAOBJECT,
                                          CUINode* pUINode) 
{
  HRESULT hr = S_OK;

  ASSERT(IS_CLASS(*pUINode, CDSUINode));
  CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);
  ASSERT(pCookie != NULL);

  int iSystemFlags = pCookie->GetSystemFlags();

  if ( iSystemFlags & (FLAG_CONFIG_ALLOW_MOVE | FLAG_CONFIG_ALLOW_LIMITED_MOVE) ) 
  {
    hr = DSLoadAndAddMenuItem( piCMenuCallback,
                               IDM_GEN_TASK_MOVE,
                               IDM_GEN_TASK_MOVE,
                               CCM_INSERTIONPOINTID_PRIMARY_TOP,
                               0,
                               CMID_GEN_TASK_MOVE);
  }
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\contextmenu.h ===
//+----------------------------------------------------------------------------
//
//  DS Administration MMC snapin.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       ContextMenu.h
//
//  Contents:   ContextMenu object functions
//
//  Classes:    CContextMenuVerbs
//              CDSContextMenuVerbs
//              CDSAdminContextMenuVerbs
//              CSARContextMenuVerbs
//
//  History:    28-Oct-99 JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef __CONTEXTMENU_H_
#define __CONTEXTMENU_H_

#include "dssnap.h"

///////////////////////////////////////////////////////////////////////////
// CContextMenuVerbs
//

class CContextMenuVerbs
{
public:
  CContextMenuVerbs(CDSComponentData* pComponentData) : m_pComponentData(pComponentData)
  {}
  virtual ~CContextMenuVerbs() {}

  virtual HRESULT LoadNewMenu(IContextMenuCallback2*,
                              IShellExtInit*,
                              LPDATAOBJECT,
                              CUINode*,
                              long*) { return S_OK; }
  virtual HRESULT LoadTopMenu(IContextMenuCallback2*, 
                              CUINode*) { return S_OK; }
  virtual HRESULT LoadMainMenu(IContextMenuCallback2*,
                               LPDATAOBJECT,
                               CUINode*) { return S_OK; }
  virtual HRESULT LoadViewMenu(IContextMenuCallback2*,
                               CUINode*) { return S_OK; }
  virtual HRESULT LoadTaskMenu(IContextMenuCallback2*,
                               CUINode*) { return S_OK; }
  virtual void LoadStandardVerbs(IConsoleVerb* pConsoleVerb,
                                 BOOL bScope, 
                                 BOOL bSelect, 
                                 CUINode* pUINode,
                                 LPDATAOBJECT pDataObject);
  virtual HRESULT LoadMenuExtensions(IContextMenuCallback2*,
                                     IShellExtInit*,
                                     LPDATAOBJECT,
                                     CUINode*) { return S_OK; }

protected:
  HRESULT DSLoadAndAddMenuItem(IContextMenuCallback2* pIContextMenuCallback2,
                               UINT nResourceID, // contains text and status text seperated by '\n'
                               long lCommandID,
                               long lInsertionPointID,
                               long fFlags,
                               PCWSTR pszLanguageIndependentID,
                               long fSpecialFlags = 0);

  CDSComponentData* m_pComponentData;
};

///////////////////////////////////////////////////////////////////////////
// CSnapinRootMenuVerbs
//

class CSnapinRootMenuVerbs : public CContextMenuVerbs
{
public:
  CSnapinRootMenuVerbs(CDSComponentData* pComponentData) : CContextMenuVerbs(pComponentData)
  {}

  virtual ~CSnapinRootMenuVerbs() {}

  virtual HRESULT LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                              CUINode* pUINode);
  virtual HRESULT LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback,
                               CUINode* pUINode);
  virtual HRESULT LoadViewMenu(IContextMenuCallback2* piCMenuCallback,
                               CUINode* pUINode);
};

///////////////////////////////////////////////////////////////////////////
// CFavoritesFolderMenuVerbs
//

class CFavoritesFolderMenuVerbs : public CContextMenuVerbs
{
public:
  CFavoritesFolderMenuVerbs(CDSComponentData* pComponentData) : CContextMenuVerbs(pComponentData)
  {}

  virtual ~CFavoritesFolderMenuVerbs() {}

  virtual HRESULT LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                              CUINode* pUINode);
  virtual HRESULT LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback,
                               CUINode* pUINode);
  virtual HRESULT LoadNewMenu(IContextMenuCallback2* pContextMenuCallback,
                              IShellExtInit* pShlInit,
                              LPDATAOBJECT pDataObject,
                              CUINode* pUINode,
                              long *pInsertionAllowed);
  virtual void LoadStandardVerbs(IConsoleVerb* pConsoleVerb,
                                 BOOL bScope, 
                                 BOOL bSelect, 
                                 CUINode* pUINode,
                                 LPDATAOBJECT pDataObject);
  virtual HRESULT LoadViewMenu(IContextMenuCallback2* piCMenuCallback,
                               CUINode* pUINode);
};

///////////////////////////////////////////////////////////////////////////
// CSavedQueryMenuVerbs
//

class CSavedQueryMenuVerbs : public CContextMenuVerbs
{
public:
  CSavedQueryMenuVerbs(CDSComponentData* pComponentData) : CContextMenuVerbs(pComponentData)
  {}

  virtual ~CSavedQueryMenuVerbs() {}

  virtual HRESULT LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                              CUINode* pUINode);
  virtual HRESULT LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback,
                               CUINode* pUINode);
  virtual void LoadStandardVerbs(IConsoleVerb* pConsoleVerb,
                                 BOOL bScope, 
                                 BOOL bSelect, 
                                 CUINode* pUINode,
                                 LPDATAOBJECT pDataObject);
  virtual HRESULT LoadViewMenu(IContextMenuCallback2* piCMenuCallback,
                               CUINode* pUINode);
};

///////////////////////////////////////////////////////////////////////////
// CDSContextMenuVerbs
//
// This class is used to handle common behavior for DS objects
//

class CDSContextMenuVerbs : public CContextMenuVerbs
{
public:
  CDSContextMenuVerbs(CDSComponentData* pComponentData) : CContextMenuVerbs(pComponentData)
  {}
  virtual ~CDSContextMenuVerbs() {}

  virtual HRESULT LoadNewMenu(IContextMenuCallback2* pContextMenuCallback,
                              IShellExtInit* pShlInit,
                              LPDATAOBJECT pDataObject,
                              CUINode* pUINode,
                              long *pInsertionAllowed);
  virtual HRESULT LoadViewMenu(IContextMenuCallback2* pContextMenuCallback,
                               CUINode* pUINode);
  virtual HRESULT LoadMenuExtensions(IContextMenuCallback2* pContextMenuCallback,
                                     IShellExtInit* pShlInit,
                                     LPDATAOBJECT pDataObject,
                                     CUINode* pUINode);

protected:

  int InsertAtTopContextMenu(LPCWSTR pwszParentClass, LPCWSTR pwszChildClass);

};

///////////////////////////////////////////////////////////////////////////
// CDSAdminContextMenuVerbs
//
// This class is used to handle specific behavior for DSAdmin
//

class CDSAdminContextMenuVerbs : public CDSContextMenuVerbs
{
public:
  CDSAdminContextMenuVerbs(CDSComponentData* pComponentData) : CDSContextMenuVerbs(pComponentData)
  {}
  virtual ~CDSAdminContextMenuVerbs() {}

  virtual HRESULT LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, 
                              CUINode* pUINode);
  virtual HRESULT LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback, 
                               CUINode* pUINode);
  virtual HRESULT LoadViewMenu(IContextMenuCallback2* piCMenuCallback,
                               CUINode* pUINode);
  virtual void LoadStandardVerbs(IConsoleVerb* pConsoleVerb,
                                 BOOL bScope, 
                                 BOOL bSelect,
                                 CUINode* pUINode,
                                 LPDATAOBJECT pDataObject);
//  virtual HRESULT LoadNewMenu() {}
//  virtual HRESULT LoadMainMenu();
//  virtual HRESULT LoadMenuExtensions() {}

protected:
  HRESULT LoadTopTaskHelper(IContextMenuCallback2* pContextMenuCallback, 
                            CUINode* pUINode,
                            int insertionPoint);
};

///////////////////////////////////////////////////////////////////////////
// CSARContextMenuVerbs
//
// This class is used to handle specific behavior for Sites and Repl
//

class CSARContextMenuVerbs : public CDSContextMenuVerbs
{
public:
  CSARContextMenuVerbs(CDSComponentData* pComponentData) : CDSContextMenuVerbs(pComponentData)
  {}
  virtual ~CSARContextMenuVerbs() {}

  virtual HRESULT LoadTopMenu(IContextMenuCallback2* pContextMenuCallback, CUINode* pUINode);
  virtual HRESULT LoadTaskMenu(IContextMenuCallback2* pContextMenuCallback, CUINode* pUINode);
  virtual HRESULT LoadViewMenu(IContextMenuCallback2* pContextMenuCallback, CUINode* pUINode);
  virtual HRESULT LoadMainMenu(IContextMenuCallback2* pContextMenuCallback,
                               LPDATAOBJECT pDataObject,
                               CUINode* pUINode);
  virtual void LoadStandardVerbs(IConsoleVerb* pConsoleVerb,
                                 BOOL bScope, 
                                 BOOL bSelect, 
                                 CUINode* pUINode,
                                 LPDATAOBJECT pDataObject);
//  virtual HRESULT LoadNewMenu() {}
//  virtual HRESULT LoadMainMenu();
//  virtual HRESULT LoadStandardVerbs() {}
//  virtual HRESULT LoadMenuExtensions() {}
  

protected:
  HRESULT LoadTopTaskHelper(IContextMenuCallback2* pContextMenuCallback, 
                            CUINode* pUINode,
                            int insertionPoint);
};

#endif // __CONTEXTMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\common.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       common.h
//
//--------------------------------------------------------------------------

//	Common.h
//
//	Include files that are used frequently into the project.
//

#ifndef _COMMON_H_INCLUDED
#define _COMMON_H_INCLUDED


#ifdef _DEBUG
	#define DEBUG
#endif

// Generic Includes
#include "DbgUtil.h"
#include "uiutil.h"

// Private Includes
#include "resource.h"
#include "SimRc.h"
#include "SimUtil.h"
#include "SimData.h"
#include "SimProp.h"
#include "SimProp1.h"
#include "SimProp2.h"
#include "SimProp3.h"
#include "SimCert.h"

#endif // ~_COMMON_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dbgutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       dbgutil.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	DbgUtil.h
//
//	Handy debugging macros.
//	
//	HISTORY
//	19-Jun-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#ifndef APIERR
	typedef DWORD APIERR;		// Error code typically returned by ::GetLastError()
#endif

/////////////////////////////////////////////////////////////////////
//
// Dummy macros
//
#define INOUT		// Parameter is both input and output
#define IGNORED		// Output parameter is ignored

/////////////////////////////////////////////////////////////////////
//
// Handy macros
//

#ifdef DEBUG
	#define DebugCode(x)	x
	#define GarbageInit(pv, cb)	memset(pv, 'a', cb)
#else
	#define DebugCode(x)
	#define GarbageInit(pv, cb)
#endif


/////////////////////////////////////////////////////////////////////
#define Assert(x)		ASSERT(x)

/////////////////////////////////////////////////////////////////////
// Report is an unsual situation.  This is somewhat similar
// to an assert but does not always represent a code bug.
// eg: Unable to load an icon.
//
#define Report(x)		ASSERT(x)		// Currently defined as an assert because I don't have time to rewrite another macro


/////////////////////////////////////////////////////////////////////
//	Macro Endorse()
//
//	This macro is mostly used when validating parameters.
//	Some parameters are allowed to be NULL because they are optional
//	or simply because the interface uses the NULL case as a valid
//	input parameter.  In this case the Endorse() macro is used to
//	acknowledge the validity of such a parameter.
//
//	REMARKS
//	This macro is the opposite of Assert().
//
//	EXAMPLE
//	Endorse(p == NULL);	// Code acknowledge p == NULL to not be (or not cause) an error
//
#define Endorse(x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dbg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dbg.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_DSA_TRACE) || defined(_USE_DSA_ASSERT) || defined(_USE_DSA_TIMER)

UINT GetInfoFromIniFile(LPCWSTR lpszSection, LPCWSTR lpszKey, INT nDefault = 0)
{
  static LPCWSTR lpszFile = L"\\system32\\dsadmin.ini";

  WCHAR szFilePath[2*MAX_PATH];
	UINT nLen = ::GetSystemWindowsDirectory(szFilePath, 2*MAX_PATH);
	if (nLen == 0)
		return nDefault;

  wcscat(szFilePath, lpszFile);
  return ::GetPrivateProfileInt(lpszSection, lpszKey, nDefault, szFilePath);
}
#endif


#if defined(_USE_DSA_TRACE)

#ifdef DEBUG_DSA
DWORD g_dwTrace = 0x1;
#else
DWORD g_dwTrace = ::GetInfoFromIniFile(L"Debug", L"Trace");
#endif

void __cdecl DSATrace(LPCTSTR lpszFormat, ...)
{
  if (g_dwTrace == 0)
    return;

	va_list args;
	va_start(args, lpszFormat);

	int nBuf;

  //
  // Might need to deal with some long path names when the OU structure gets really deep.
  // bug #30432
  //
	WCHAR szBuffer[2048];

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), lpszFormat, args);

	// was there an error? was the expanded string too long?
	ASSERT(nBuf >= 0);
  ::OutputDebugString(szBuffer);

	va_end(args);
}

#endif // defined(_USE_DSA_TRACE)

#if defined(_USE_DSA_ASSERT)

DWORD g_dwAssert = ::GetInfoFromIniFile(L"Debug", L"Assert");

BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine)
{
  if (g_dwAssert == 0)
    return FALSE;

  WCHAR szMessage[_MAX_PATH*2];

	// assume the debugger or auxiliary port
	wsprintf(szMessage, _T("Assertion Failed: File %hs, Line %d\n"),
		lpszFileName, nLine);
	OutputDebugString(szMessage);

	// display the assert
	int nCode = ::MessageBox(NULL, szMessage, _T("Assertion Failed!"),
		MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

  OutputDebugString(L"after message box\n");
	if (nCode == IDIGNORE)
  {
		return FALSE;   // ignore
  }

	if (nCode == IDRETRY)
  {
		return TRUE;    // will cause DebugBreak
  }

	abort();     // should not return 
	return TRUE;

}
#endif // _USE_DSA_ASSERT

#if defined(_USE_DSA_TIMER)

#ifdef TIMER_DSA
DWORD g_dwTimer = 0x1;
#else
DWORD g_dwTimer = ::GetInfoFromIniFile(L"Debug", L"Timer");
#endif

DWORD StartTicks = ::GetTickCount();
DWORD LastTicks = 0;

void __cdecl DSATimer(LPCTSTR lpszFormat, ...)
{
  if (g_dwTimer == 0)
    return;

	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512], szBuffer2[512];

        DWORD CurrentTicks = GetTickCount() - StartTicks;
        DWORD Interval = CurrentTicks - LastTicks;
        LastTicks = CurrentTicks;

        nBuf = swprintf(szBuffer2,
                           L"%d, (%d): %ws", CurrentTicks,
							Interval, lpszFormat);
	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), 
                           szBuffer2, 
                           args);

	// was there an error? was the expanded string too long?
	ASSERT(nBuf >= 0);
  ::OutputDebugString(szBuffer);

	va_end(args);
}
#endif // _USE_DSA_TIMER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\copyobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       copyobj.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	copyobj.h

#ifndef __COPYOBJ_H_INCLUDED__
#define __COPYOBJ_H_INCLUDED__

/////////////////////////////////////////////////////////////////////
// CCopyableAttributesHolder

class CCopyableAttributesHolder
{
public:
  CCopyableAttributesHolder()
  {
  }
  ~CCopyableAttributesHolder()
  {
  }
  HRESULT LoadFromSchema(MyBasePathsInfo* pBasePathsInfo);

  BOOL CanCopy(LPCWSTR lpszAttributeName);
private:
  
  BOOL _FindInNotCopyableHardwiredList(LPCWSTR lpszAttributeName);

  CStringList m_attributeNameList;
};



/////////////////////////////////////////////////////////////////////
// CCopyObjectHandlerBase

class CCopyObjectHandlerBase
{
public:
  CCopyObjectHandlerBase()
  {
  }
  virtual ~CCopyObjectHandlerBase()
  {
  }

  IADs* GetCopyFrom() 
  {
    ASSERT(m_spIADsCopyFrom != NULL);
    return m_spIADsCopyFrom;
  }

  virtual HRESULT Init(MyBasePathsInfo*, IADs* pIADsCopyFrom)
  {
    m_spIADsCopyFrom = pIADsCopyFrom;
    return S_OK;
  }

  virtual HRESULT CopyAtCreation(IADs*)
  {
    return S_OK;
  }
  virtual HRESULT Copy(IADs*, BOOL, HWND, LPCWSTR)
  {
    return S_OK;
  }

protected:

  CComPtr<IADs> m_spIADsCopyFrom;						

};



/////////////////////////////////////////////////////////////////////
// CGroupMembershipEntry

class CGroupMembershipEntry
{
public:
  enum actionType { none, add, remove};

  CGroupMembershipEntry(DWORD dwObjectRID, LPCWSTR lpszDistinguishedName)
  {
    m_dwObjectRID = dwObjectRID;
    m_szDistinguishedName = lpszDistinguishedName;
    m_action = none;
    m_hr = S_OK;
  }
  ~CGroupMembershipEntry()
  {
  }

  LPCWSTR GetDN() { return m_szDistinguishedName; }
  DWORD GetRID() { return m_dwObjectRID; }
  BOOL IsPrimaryGroup() { return m_dwObjectRID != 0x0; }

  actionType GetActionType() { return m_action; }
  void MarkAdd() { m_action = add; }
  void MarkRemove() { m_action = remove; }

#ifdef DBG
  LPCWSTR GetActionString()
  {
    if (m_action == none)
      return L"none";
    else if (m_action == add)
      return L"add";
    return L"remove";
  }

#endif // DBG

public:
  HRESULT m_hr;

private:
  CString m_szDistinguishedName;  // DN of the group
  DWORD m_dwObjectRID;            // RID (valid only if it is the primary group)
  actionType m_action;
};


/////////////////////////////////////////////////////////////////////
// CGroupMembershipEntryList

class CGroupMembershipEntryList : 
      public CList<CGroupMembershipEntry*, CGroupMembershipEntry*>
{
public:
  ~CGroupMembershipEntryList()
  {
    _RemoveAll();
  }
  CGroupMembershipEntry* FindByDN(LPCWSTR lpszDN)
  {
    for (POSITION pos = GetHeadPosition(); pos != NULL; )
    {
      CGroupMembershipEntry* pEntry = GetNext(pos);
      if (wcscmp(lpszDN, pEntry->GetDN()) == 0)
      {
        return pEntry;
      }
    }
    return NULL;
  }
  void Merge(CGroupMembershipEntryList* pList)
  {
    while(!pList->IsEmpty())
      AddTail(pList->RemoveHead());
  }

#ifdef DBG
  void Trace(LPCWSTR lpszTitle)
  {
    TRACE(L"\n%s\n\n", lpszTitle);
    for (POSITION pos = GetHeadPosition(); pos != NULL; )
    {
      CGroupMembershipEntry* pEntry = GetNext(pos);
      TRACE(L"action = %s RID %d, DN = <%s> \n", pEntry->GetActionString(), pEntry->GetRID(), pEntry->GetDN());
    }
    TRACE(L"\n");
  }
#endif // DBG

private:
  void _RemoveAll()
  {
    while(!IsEmpty())
      delete RemoveHead();
  }
};



/////////////////////////////////////////////////////////////////////
// CSid

class CSid
{
public:
  CSid()
  {
    m_pSID = NULL;
  }
  ~CSid()
  {
    if (m_pSID != NULL)
      free(m_pSID);
  }
  HRESULT Init(IADs* pIADs);

  BOOL Init(size_t nByteLen, PSID  pSID)
  {
    if ((nByteLen == 0) || (pSID == NULL))
      return FALSE;

    m_pSID = malloc(nByteLen);
    if (m_pSID == NULL)
      return FALSE;

    memcpy(m_pSID, pSID, nByteLen);
    return TRUE;
  }

  PSID GetSid() { return m_pSID;}
private:
  PSID  m_pSID;
};


/////////////////////////////////////////////////////////////////////
// CGroupMembershipHolder

class CGroupMembershipHolder
{
public:
  CGroupMembershipHolder()
  {
    m_bPrimaryGroupFound = FALSE;
  }
  ~CGroupMembershipHolder()
  {
  }

  HRESULT Read(IADs* pIADs);
  HRESULT CopyFrom(CGroupMembershipHolder* pSource);
  HRESULT Write();

  void ProcessFailures(HRESULT& hr, CString& szFailureString, BOOL* pPrimaryGroupFound);

private:



  HRESULT _ReadPrimaryGroupInfo();
  HRESULT _ReadNonPrimaryGroupInfo();
  
  
  CComPtr<IADs> m_spIADs;       // object ADSI pointer
  CSid  m_objectSid;            // object SID
  CString m_szDomainLDAPPath;   // LDAP path of the domain the object is in

  CGroupMembershipEntryList m_entryList;
  BOOL  m_bPrimaryGroupFound;
};


/////////////////////////////////////////////////////////////////////
// CCopyUserHandler

class CCopyUserHandler : public CCopyObjectHandlerBase
{
public:
  CCopyUserHandler()
  {
    m_bPasswordCannotChange = FALSE;
    m_bPasswordMustChange = FALSE;

    m_hrFailure = S_OK;
    m_bPrimaryGroupFound = FALSE;

    m_bNeedToCreateHomeDir = FALSE;
  }

  virtual HRESULT Init(MyBasePathsInfo* pBasePathsInfo, IADs* pIADsCopyFrom);
  
  virtual HRESULT CopyAtCreation(IADs* pIADsCopyTo)
  {
    return _CopyAttributes(pIADsCopyTo);
  }

  virtual HRESULT Copy(IADs* pIADsCopyTo, BOOL bPostCommit, 
                        HWND hWnd, LPCWSTR lpszObjectName);

  BOOL PasswordCannotChange()
  {
    return m_bPasswordCannotChange;
  }

  BOOL PasswordMustChange()
  {
    return m_bPasswordMustChange;
  }

  void _ShowGroupMembershipWarnings(HWND hWnd, LPCWSTR lpszObjectName);

private:
  HRESULT _ReadPasswordCannotChange();
  HRESULT _ReadPasswordMustChange();

  HRESULT _CopyAttributes(IADs* pIADsCopyTo);
  HRESULT _CopyGroupMembership(IADs* pIADsCopyTo);

  HRESULT _UpdatePaths(IADs* pIADsCopyTo);
  HRESULT _CreateHomeDirectory(IADs* pIADsCopyTo, LPCWSTR lpszObjectName, HWND hWnd);

  CCopyableAttributesHolder m_copyableAttributesHolder;
  CGroupMembershipHolder m_sourceMembershipHolder;

  BOOL m_bPasswordCannotChange;
  BOOL m_bPasswordMustChange;


  HRESULT m_hrFailure;
  CString m_szFailureString;
  BOOL    m_bPrimaryGroupFound;

  BOOL m_bNeedToCreateHomeDir;
};


#endif // __COPYOBJ_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dataobj.cpp ===
//+----------------------------------------------------------------------------
//
//  DS Administration MMC snapin.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DataObj.cpp
//
//  Contents:   Data Object implementation.
//
//  Classes:    CDSDataObject
//
//  History:    02-Oct-96 WayneSc    Created
//              06-Feb-97 EricB - added Property Page Data support
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"

#include "DSdirect.h"
#include "DataObj.h"
#include "dssnap.h"

#include <lm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//+----------------------------------------------------------------------------
// MMC's clipboard formats:
//-----------------------------------------------------------------------------
// Snap-in NodeType in both GUID format and string format
CLIPFORMAT CDSDataObject::m_cfNodeType =
                                (CLIPFORMAT)RegisterClipboardFormat(CCF_NODETYPE);
CLIPFORMAT CDSDataObject::m_cfNodeTypeString = 
                                (CLIPFORMAT)RegisterClipboardFormat(CCF_SZNODETYPE);
CLIPFORMAT CDSDataObject::m_cfDisplayName =
                                (CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME);
CLIPFORMAT CDSDataObject::m_cfCoClass =
                                (CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
CLIPFORMAT CDSDataObject::m_cfpMultiSelDataObj =
                                (CLIPFORMAT)RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
CLIPFORMAT CDSDataObject::m_cfMultiObjTypes =
                                (CLIPFORMAT)RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
CLIPFORMAT CDSDataObject::m_cfMultiSelDataObjs =
                                (CLIPFORMAT)RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);
CLIPFORMAT CDSDataObject::m_cfPreload =
                        (CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);

//+----------------------------------------------------------------------------
// Our clipboard formats:
//-----------------------------------------------------------------------------

CLIPFORMAT CDSDataObject::m_cfInternal = 
                                (CLIPFORMAT)RegisterClipboardFormat(SNAPIN_INTERNAL);
CLIPFORMAT CDSDataObject::m_cfDsObjectNames = 
                                (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
CLIPFORMAT CDSDataObject::m_cfDsDisplaySpecOptions =
                                (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_DISPLAY_SPEC_OPTIONS);
CLIPFORMAT CDSDataObject::m_cfDsSchemaPath =
                                (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_SCHEMA_PATH);
CLIPFORMAT CDSDataObject::m_cfPropSheetCfg =
                        (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_PROPSHEETCONFIG);
CLIPFORMAT CDSDataObject::m_cfParentHwnd =
                        (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_PARENTHWND);

CLIPFORMAT CDSDataObject::m_cfComponentData = 
                        (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_COMPDATA);

CLIPFORMAT CDSDataObject::m_cfColumnID =
                        (CLIPFORMAT)RegisterClipboardFormat(CCF_COLUMN_SET_ID);

CLIPFORMAT CDSDataObject::m_cfMultiSelectProppage =
                        (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_MULTISELECTPROPPAGE);

//+----------------------------------------------------------------------------
// CDSDataObject implementation
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::IDataObject::GetData
//
//  Synopsis:   Returns data, in this case the Prop Page format data.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDSDataObject::GetData(FORMATETC * pFormatEtc, STGMEDIUM * pMedium)
{
  //TRACE(_T("xx.%03x> CDSDataObject(0x%x)::GetData\n"),
  //      GetCurrentThreadId(), this);
  HRESULT hr = S_OK;
  if (IsBadWritePtr(pMedium, sizeof(STGMEDIUM)))
  {
    return E_INVALIDARG;
  }
  if (!(pFormatEtc->tymed & TYMED_HGLOBAL))
  {
    return DV_E_TYMED;
  }

  if (pFormatEtc->cfFormat == m_cfDsObjectNames)
  {
    // make a deep copy of the cached data
    pMedium->hGlobal = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                        m_nDSObjCachedBytes);
    if (pMedium->hGlobal == NULL)
    {
      return E_OUTOFMEMORY;
    }
    memcpy(pMedium->hGlobal, m_pDSObjCached, m_nDSObjCachedBytes);
  } 
  else if (pFormatEtc->cfFormat == m_cfDsDisplaySpecOptions)
  {
    //
    // Get the DSDISPLAYSPECOPTIONS structure.
    // Use the value cached in the component data.
    //
    if (m_pDsComponentData != NULL)
    {
      PDSDISPLAYSPECOPTIONS pDsDisplaySpecOptions = m_pDsComponentData->GetDsDisplaySpecOptions();
      pMedium->hGlobal = (HGLOBAL)pDsDisplaySpecOptions;
      if (pDsDisplaySpecOptions == NULL)
        return E_OUTOFMEMORY;
    }
    else
    {
      return E_FAIL;
    }
  }
  else if (pFormatEtc->cfFormat == m_cfDsSchemaPath)
  {
    ASSERT(m_pDsComponentData);
    LPCWSTR lpszSchemaNamingCtx = m_pDsComponentData->GetBasePathsInfo()->GetSchemaNamingContext();
    size_t nSchemaNamingCtxLen = wcslen(lpszSchemaNamingCtx);
    if (nSchemaNamingCtxLen == 0)
    {
      return E_FAIL;
    }
    PWSTR pwzSchemaPath = (PWSTR)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                             (nSchemaNamingCtxLen +1) * sizeof(WCHAR));
    if (pwzSchemaPath == NULL)
    {
      return STG_E_MEDIUMFULL;
    }

    wcscpy(pwzSchemaPath, lpszSchemaNamingCtx);

    pMedium->hGlobal = pwzSchemaPath;
  }
  else if (pFormatEtc->cfFormat == m_cfPropSheetCfg)
  {
    // Return the property sheet notification handle.
    //
    PPROPSHEETCFG pSheetCfg;

    pSheetCfg = (PPROPSHEETCFG)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                           sizeof(PROPSHEETCFG));
    if (pSheetCfg == NULL)
    {
      return STG_E_MEDIUMFULL;
    }

    pSheetCfg->lNotifyHandle = m_lNotifyHandle;
    pSheetCfg->hwndParentSheet = m_hwndParentSheet;
    pSheetCfg->hwndHidden = m_pDsComponentData->GetHiddenWindow();
    pSheetCfg->wParamSheetClose = reinterpret_cast<WPARAM>(m_internal.m_cookie);

    pMedium->hGlobal = (HGLOBAL)pSheetCfg;
  }
  else if (pFormatEtc->cfFormat == m_cfParentHwnd)
  {
    // return the HWND of the MMC frame window
    HWND* pHWndMain = (HWND*)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                         sizeof(HWND));
    m_pDsComponentData->m_pFrame->GetMainWindow(pHWndMain);
    pMedium->hGlobal = (HGLOBAL)pHWndMain;
  }
  else if (pFormatEtc->cfFormat == m_cfComponentData)
  {
    // return the m_pDsComponentData the data object is bound to
    CDSComponentData** ppCD = (CDSComponentData**)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                           sizeof(CDSComponentData*));
    if (ppCD != NULL)
    {
      *ppCD = m_pDsComponentData;
      pMedium->hGlobal = (HGLOBAL)ppCD;
    }
    else
    {
      return STG_E_MEDIUMFULL;
    }
  }
  else if (pFormatEtc->cfFormat == m_cfMultiSelectProppage)
  {
    if (m_szUniqueID == _T(""))
    {
      return E_FAIL;
    }

    UINT nLength = m_szUniqueID.GetLength();
    PWSTR pszGuidString = (PWSTR)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                             (nLength +1) * sizeof(WCHAR));
    if (pszGuidString == NULL)
    {
      return STG_E_MEDIUMFULL;
    }

    wcscpy(pszGuidString, m_szUniqueID);

    pMedium->hGlobal = pszGuidString;
  }
  else if (pFormatEtc->cfFormat == m_cfMultiObjTypes)
  {
    hr = CreateMultiSelectObject(pMedium);
  } 
  else if (pFormatEtc->cfFormat == m_cfInternal)
  {
    hr = CreateInternal(pMedium);
  } 
  else if (pFormatEtc->cfFormat == m_cfColumnID)
  {
    hr = CreateColumnID(pMedium); 
  }
  else
  {
    return DV_E_FORMATETC;
  }

  pMedium->tymed = TYMED_HGLOBAL;
  pMedium->pUnkForRelease = NULL;

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::IDataObject::GetDataHere
//
//  Synopsis:   Returns data in callers storage medium
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDSDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString) 
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfPreload)
    {
        // MMC notify the snapin before loading with the MMCN_PRELOAD notify message

        BOOL bPreload = TRUE;
        hr = Create(&bPreload, sizeof(BOOL), lpMedium);
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::IDataObject::SetData
//
//  Synopsis:   Allows the caller to set data object values.
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDSDataObject::SetData(FORMATETC * pFormatEtc, STGMEDIUM * pMedium,
                                    BOOL fRelease)
{
  HRESULT hr = S_OK;

  if (pFormatEtc->cfFormat == m_cfPropSheetCfg)
  {
    if (!(pFormatEtc->tymed & TYMED_HGLOBAL))
    {
      return DV_E_TYMED;
    }

    PPROPSHEETCFG pSheetCfg = (PPROPSHEETCFG)pMedium->hGlobal;

    if ( NULL != pSheetCfg->lNotifyHandle)
    {
      m_lNotifyHandle = pSheetCfg->lNotifyHandle;
    }

    if (NULL != pSheetCfg->hwndParentSheet)
    {
      m_hwndParentSheet = pSheetCfg->hwndParentSheet;
    }

    if (fRelease)
    {
      GlobalFree(pMedium->hGlobal);
    }
    return S_OK;
  }
  else if (pFormatEtc->cfFormat == m_cfMultiSelectProppage)
  {
    if (!(pFormatEtc->tymed & TYMED_HGLOBAL))
    {
      return DV_E_TYMED;
    }

    PWSTR pszGuidString = (PWSTR)pMedium->hGlobal;
    if (pszGuidString == NULL)
    {
      ASSERT(FALSE);
      return E_FAIL;
    }

    m_szUniqueID = pszGuidString;
  }
  else
  {
    return DV_E_FORMATETC;
  }
  return hr;
}


//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::IDataObject::EnumFormatEtc
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDSDataObject::EnumFormatEtc(DWORD, LPENUMFORMATETC*)
{
	return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::Create
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CDSDataObject::Create(const void * pBuffer, int len, LPSTGMEDIUM pMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || pMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (pMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(pMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
		    hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE', 
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::CreateNodeTypeData
//
//  Synopsis:   Create the node type object in GUID format
//
//-----------------------------------------------------------------------------
HRESULT
CDSDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    TRACE(_T("xx.%03x> GetDataHere on Node Type\n"), GetCurrentThreadId());
    GUID* pGuid = m_internal.m_cookie->GetGUID();
    return Create(pGuid, sizeof(GUID), lpMedium);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::CreateNodeTypeStringData
//
//  Synopsis:   Create the node type object in GUID string format
//
//-----------------------------------------------------------------------------
HRESULT
CDSDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    TRACE(_T("xx.%03x> GetDataHere on Node Type String\n"), GetCurrentThreadId());
    GUID* pGuid = m_internal.m_cookie->GetGUID();
    CString strGUID;
    WCHAR * szGUID;
    StringFromCLSID(*pGuid, &szGUID);
    strGUID = szGUID;
    return Create (strGUID, strGUID.GetLength()+ sizeof(wchar_t),
                   lpMedium);

}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::CreateDisplayName
//
//  Synopsis:   This is the display named used in the scope pane and snap-in
//              manager.
//
//-----------------------------------------------------------------------------
HRESULT
CDSDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    TRACE(_T("xx.%03x> GetDataHere on Display Name\n"), GetCurrentThreadId());

    // Load the name from resource
    // Note - if this is not provided, the console will used the snap-in name

    CString szDispName;
    szDispName.LoadString( ResourceIDForSnapinType[ m_internal.m_snapintype ]);

    return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(wchar_t)), lpMedium);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::CreateMultiSelectObject
//
//  Synopsis:   this is to create the list of types selected
//
//-----------------------------------------------------------------------------

HRESULT
CDSDataObject::CreateMultiSelectObject(LPSTGMEDIUM lpMedium)
{
  TRACE(_T("xx.%03x> GetDataHere on MultiSelectObject\n"), GetCurrentThreadId());
    
  CUINode** cookieArray = NULL;
  cookieArray = (CUINode**) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                          m_internal.m_cookie_count*sizeof(CUINode*));
  if (!cookieArray) {
    return E_OUTOFMEMORY;
  }
  for (UINT k=0; k<m_internal.m_cookie_count; k++)
  {
    if (k==0)
      cookieArray[k] = m_internal.m_cookie;
    else
      cookieArray[k] = m_internal.m_p_cookies[k-1];
  }
  BOOL* bDuplicateArr = NULL;
  bDuplicateArr = (BOOL*)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                     m_internal.m_cookie_count*sizeof(BOOL));
  if (!bDuplicateArr) {
    if (cookieArray)
      GlobalFree (cookieArray);
    return E_OUTOFMEMORY;
  }
  //ZeroMemory(bDuplicateArr, m_internal.m_cookie_count*sizeof(BOOL));

  UINT cCount = 0;
  for (UINT index=0; index<m_internal.m_cookie_count; index++)
  {
    for (UINT j=0; j<index;j++)
    {
      GUID Guid1 = *(cookieArray[index]->GetGUID());
      GUID Guid2 = *(cookieArray[j]->GetGUID());
      if (IsEqualGUID (Guid1, Guid2)) 
      {
        bDuplicateArr[index] = TRUE;
        break; //repeated GUID
      }
    }
    if (!bDuplicateArr[index])
      cCount++;
  }      

   
  UINT size = sizeof(SMMCObjectTypes) + (cCount - 1) * 
    sizeof(GUID);
  void * pTmp = ::GlobalAlloc(GPTR, size);
  if (!pTmp) {
    if (cookieArray) {
      GlobalFree (cookieArray);
    }
    if (bDuplicateArr) {
      GlobalFree (bDuplicateArr);
    }
    return E_OUTOFMEMORY;
  }
    
  SMMCObjectTypes* pdata = reinterpret_cast<SMMCObjectTypes*>(pTmp);
  pdata->count = cCount;
  UINT i = 0;
  for (index=0; index<m_internal.m_cookie_count; index++)
  {
    if (!bDuplicateArr[index])
    pdata->guid[i++] = *(cookieArray[index]->GetGUID());
  }
  ASSERT(i == cCount);
  lpMedium->hGlobal = pTmp;

  GlobalFree (cookieArray);
  GlobalFree (bDuplicateArr);

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::CreateInternal
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CDSDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{
  HRESULT hr = S_OK;
  INTERNAL * pInt = NULL;
  void * pBuf = NULL;

  UINT size = sizeof(INTERNAL);
  size += sizeof(CUINode *) * (m_internal.m_cookie_count - 1);
  pBuf = GlobalAlloc (GPTR, size);
  pInt = (INTERNAL *) pBuf;
  lpMedium->hGlobal = pBuf;
  
  if (pInt != NULL &&
      m_internal.m_cookie_count > 1) 
  {
    // copy the data
    pInt->m_type = m_internal.m_type;
    pInt->m_cookie = m_internal.m_cookie;
    pInt->m_snapintype = m_internal.m_snapintype;
    pInt->m_cookie_count = m_internal.m_cookie_count;
    
    pInt->m_p_cookies = (CUINode **) ((BYTE *)pInt + sizeof(INTERNAL));
    memcpy (pInt->m_p_cookies, m_internal.m_p_cookies,
            sizeof(CUINode *) * (m_internal.m_cookie_count - 1));
    hr = Create(pBuf, size, lpMedium);
  }
  else 
  {
    hr = Create(&m_internal, sizeof(INTERNAL), lpMedium);
  }
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::CreateCoClassID
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CDSDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
  TRACE(_T("xx.%03x> GetDataHere on CoClass\n"), GetCurrentThreadId());
  CLSID CoClassID;
  
  switch (m_internal.m_snapintype) {
  case SNAPINTYPE_DS:
    CoClassID = CLSID_DSSnapin;
    break;
  case SNAPINTYPE_SITE:
    CoClassID = CLSID_SiteSnapin;
    break;
  default:
    memset (&CoClassID,0,sizeof(CLSID));
  }
  return Create(&CoClassID, sizeof(CLSID), lpMedium);
}


//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::CreateColumnID
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT 
CDSDataObject::CreateColumnID(LPSTGMEDIUM lpMedium)
{
  // build the column id
  CDSColumnSet* pColumnSet = (m_internal.m_cookie)->GetColumnSet(m_pDsComponentData);

  if (pColumnSet == NULL)
	  return DV_E_TYMED;

  LPCWSTR lpszID = pColumnSet->GetColumnID();
  size_t iLen = wcslen(lpszID);

  // allocate enough memory for the struct and the string for the column id
  SColumnSetID* pColumnID = (SColumnSetID*)malloc(sizeof(SColumnSetID) + (iLen * sizeof(WCHAR)));
  if (pColumnID != NULL)
  {
    memset(pColumnID, 0, sizeof(SColumnSetID) + (iLen * sizeof(WCHAR)));
    pColumnID->cBytes = static_cast<ULONG>(iLen * sizeof(WCHAR));
    memcpy(pColumnID->id, lpszID, (iLen * sizeof(WCHAR)));

    // copy the column id to global memory
    size_t cb = sizeof(SColumnSetID) + (iLen * sizeof(WCHAR));

    lpMedium->tymed = TYMED_HGLOBAL;
    lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, cb);

    if (lpMedium->hGlobal == NULL)
      return STG_E_MEDIUMFULL;

    BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
    memcpy(pb, pColumnID, cb);

    ::GlobalUnlock(lpMedium->hGlobal);

    free(pColumnID);
  }
	return S_OK;
}


HRESULT CDSDataObject::CreateDsObjectNamesCached()
{
  if (m_pDSObjCached != NULL)
  {
    ::free(m_pDSObjCached);
    m_pDSObjCached = NULL;
    m_nDSObjCachedBytes = 0;
  }


  // figure out how much storage we need
  DWORD cbStorage = 0;
  INT cbStruct = sizeof(DSOBJECTNAMES) + 
    ((m_internal.m_cookie_count - 1) * sizeof(DSOBJECT));
  CString strPath;
  CString strClass;
  CUINode* pNode;
  CDSCookie * pCookie;

  //
  // this loop is to calc how much storage we need.
  //
  for (UINT index = 0; index < m_internal.m_cookie_count; index++)
  {
    if (index == 0) 
    {
      pNode = m_internal.m_cookie;
    } 
    else 
    {
      pNode = m_internal.m_p_cookies[index - 1];
    }

    pCookie = NULL;
    if (IS_CLASS(*pNode, CDSUINode))
    {
      pCookie = GetDSCookieFromUINode(pNode);
    }

    //
    // All the nodes must be of type CDSUINode or else we fail
    //
    if (pCookie == NULL)
    {
      return E_FAIL;
    }

    m_pDsComponentData->GetBasePathsInfo()->ComposeADsIPath(strPath, pCookie->GetPath());
    strClass = pCookie->GetClass();
    if (_wcsicmp(strClass, L"Unknown") == 0)
    {
      strClass = L"";
    }
    cbStorage += (strPath.GetLength() + 1 + strClass.GetLength() + 1) * sizeof(TCHAR);
  }

  //
  // Allocate the needed storage
  //
  m_pDSObjCached = (LPDSOBJECTNAMES)malloc(cbStruct + cbStorage);
  
  if (m_pDSObjCached == NULL)
  {
    return STG_E_MEDIUMFULL;
  }
  m_nDSObjCachedBytes = cbStruct + cbStorage;

  switch (m_internal.m_snapintype)
  {
    case SNAPINTYPE_DS:
      m_pDSObjCached->clsidNamespace = CLSID_DSSnapin;
      break;
    case SNAPINTYPE_SITE:
      m_pDSObjCached->clsidNamespace = CLSID_SiteSnapin;
      break;
    default:
      memset (&m_pDSObjCached->clsidNamespace, 0, sizeof(CLSID));
  }

  m_pDSObjCached->cItems = m_internal.m_cookie_count;
  DWORD NextOffset = cbStruct;
  for (index = 0; index < m_internal.m_cookie_count; index++)
  {
    if (index == 0) 
    {
      pNode = m_internal.m_cookie;
    } 
    else 
    {
      pNode = m_internal.m_p_cookies[index - 1];
    }

    pCookie = NULL;
    if (IS_CLASS(*pNode, CDSUINode))
    {
      pCookie = GetDSCookieFromUINode(pNode);
    }

    //
    // All nodes must be of type CDSUINode or else we fail
    //
    if (pCookie == NULL)
    {
      return E_FAIL;
    }

    //
    // Set the data from the node and node data
    //
    m_pDSObjCached->aObjects[index].dwFlags = pNode->IsContainer() ? DSOBJECT_ISCONTAINER : 0;
    m_pDSObjCached->aObjects[index].dwProviderFlags = (m_pDsComponentData->IsAdvancedView()) ?
      DSPROVIDER_ADVANCED : 0;
    m_pDsComponentData->GetBasePathsInfo()->ComposeADsIPath(strPath, pCookie->GetPath());
    strClass = pCookie->GetClass();
    if (_wcsicmp(strClass, L"Unknown") == 0)
    {
      strClass = L"";
    }

    m_pDSObjCached->aObjects[index].offsetName = NextOffset;
    m_pDSObjCached->aObjects[index].offsetClass = NextOffset + 
      (strPath.GetLength() + 1) * sizeof(TCHAR);

    _tcscpy((LPTSTR)((BYTE *)m_pDSObjCached + NextOffset), strPath);
    NextOffset += (strPath.GetLength() + 1) * sizeof(TCHAR);

    _tcscpy((LPTSTR)((BYTE *)m_pDSObjCached + NextOffset), strClass);
    NextOffset += (strClass.GetLength() + 1) * sizeof(TCHAR);
  }
  return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Method:     CDSDataObject::AddCookie
//
//  Synopsis:   adds a cookie to the data object. if this is
//              the first cookie it goes in m_cookie, else it
//              goes into the cookie list m_p_cookies.
//
//-----------------------------------------------------------------------------
void 
CDSDataObject::AddCookie(CUINode* pUINode)
{
  const UINT MEM_CHUNK_SIZE = 10;
  void * pTMP = NULL;
  if (m_internal.m_cookie) {  // already have a cookie
    if ((m_internal.m_cookie_count - 1) % MEM_CHUNK_SIZE == 0) {
      if (m_internal.m_p_cookies) {
        pTMP = realloc (m_internal.m_p_cookies,
                        (m_internal.m_cookie_count - 1 +
                         MEM_CHUNK_SIZE) * sizeof (CUINode *));
      } else {
        pTMP = malloc (MEM_CHUNK_SIZE * sizeof (CUINode *));
      }
      if (pTMP == NULL) {
        TRACE(_T("CDataObject::AddCookie - malloc/realloc failed.."));
        ASSERT (pTMP != NULL);
      }
      m_internal.m_p_cookies = (CUINode **)pTMP;
    }
    (*(m_internal.m_p_cookies + m_internal.m_cookie_count - 1)) = pUINode;
    m_internal.m_cookie_count++;
  } else {
    m_internal.m_cookie = pUINode;
    m_internal.m_cookie_count = 1;
  }
  CreateDsObjectNamesCached();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\copyobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       copyobj.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	copyobj.cpp
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

#include "util.h"
#include "dsutil.h"

#include "newobj.h"
#include "copyobj.h"
#include "dscmn.h"    // CrackName()
#include "querysup.h"


// attributes for "intelligent" copy user
static const PWSTR g_szProfilePath  = L"profilePath";
static const PWSTR g_szHomeDir      = L"homeDirectory";


/////////////////////////////////////////////////////////////////////
// global functions





//+----------------------------------------------------------------------------
//
//  Function:   _GetDomainScope
//
//  Synopsis:   Returns the full LDAP DN of the domain of the given object.
//
//-----------------------------------------------------------------------------

HRESULT _GetDomainScope(IADs* pIADs, CString& szDomainLDAPPath)
{
  // get the DN of the current object
  // get the SID of the object
  CComVariant varObjectDistinguishedName;
  HRESULT hr = pIADs->Get(L"distinguishedName", &varObjectDistinguishedName);
  if (FAILED(hr))
  {
    TRACE(L"pIADs->Get(distinguishedName,...) failed with hr = 0x%x\n", hr);
    return hr;
  }

  TRACE(L"Retrieved distinguishedName = <%s>\n", varObjectDistinguishedName.bstrVal);

  // obtain the FQDN of the domain the object is in
  LPWSTR pwzDomainDN = NULL;
  hr = CrackName(varObjectDistinguishedName.bstrVal, &pwzDomainDN, GET_FQDN_DOMAIN_NAME);
  if (FAILED(hr))
  {
    TRACE(L"CrackName(%s) failed with hr = 0x%x\n", varObjectDistinguishedName.bstrVal, hr);
    return hr;
  }

  TRACE(L"CrackName(%s) returned <%s>\n", varObjectDistinguishedName.bstrVal, pwzDomainDN);
  
  // retrieve the server name the object is bound to
  CString szServer;
  hr = GetADSIServerName(OUT szServer, IN pIADs);
  if (FAILED(hr))
  {
    TRACE(L"GetADSIServerName() failed with hr = 0x%x\n", hr);
    return hr;
  }

  TRACE(L"GetADSIServerName() returned <%s>\n", (LPCWSTR)szServer);

  // build the full LDAP path of the domain
  CPathCracker pathCracker;
  hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
  hr = pathCracker.Set((LPWSTR)((LPCWSTR)szServer), ADS_SETTYPE_SERVER);
  hr = pathCracker.Set(pwzDomainDN, ADS_SETTYPE_DN);
  LocalFreeStringW(&pwzDomainDN);
  CComBSTR bstrDomainPath;
  hr = pathCracker.Retrieve(ADS_FORMAT_X500, &bstrDomainPath);
  if (FAILED(hr))
  {
    TRACE(L"PathCracker() failed to build LDAP path. hr = 0x%x\n", hr);
    return hr;
  }

  szDomainLDAPPath = bstrDomainPath;

  TRACE(L"Object's domain is: <%s>\n", (LPCWSTR)szDomainLDAPPath);

  return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Method:     _ConvertRIDtoName
//
//  Synopsis:   Convert the RID to the object DN.
//
//-----------------------------------------------------------------------------
HRESULT _ConvertRIDtoName(IN LPCWSTR lpszDomainLDAPPath,
                          IN PSID pObjSID, 
                          IN DWORD priGroupRID, 
                          OUT CString& szGroupPath)
{
  PWSTR g_wzADsPath = L"ADsPath";

  if ((pObjSID == NULL) || (priGroupRID == 0))
  {
    return E_INVALIDARG;
  }

  HRESULT hr = S_OK;
  UCHAR * psaCount, i;
  PSID pSID = NULL;
  PSID_IDENTIFIER_AUTHORITY psia;
  DWORD rgRid[8];

  psaCount = GetSidSubAuthorityCount(pObjSID);

  if (psaCount == NULL)
  {
    hr = HRESULT_FROM_WIN32(GetLastError());
    TRACE(L"GetSidSubAuthorityCount() failed, hr = 0x%x\n", hr);
    return hr;
  }

  ASSERT(*psaCount <= 8);
  if (*psaCount > 8)
  {
      return E_FAIL;
  }

  for (i = 0; i < (*psaCount - 1); i++)
  {
    PDWORD pRid = GetSidSubAuthority(pObjSID, (DWORD)i);
    if (pRid == NULL)
    {
      hr = HRESULT_FROM_WIN32(GetLastError());
      TRACE(L"GetSidSubAuthority() failed, hr = 0x%x\n", hr);
      return hr;
    }
    rgRid[i] = *pRid;
  }

  rgRid[*psaCount - 1] = priGroupRID;

  for (i = *psaCount; i < 8; i++)
  {
      rgRid[i] = 0;
  }

  psia = GetSidIdentifierAuthority(pObjSID);

  if (psia == NULL)
  {
    hr = HRESULT_FROM_WIN32(GetLastError());
    TRACE(L"GetSidIdentifierAuthority() failed, hr = 0x%x\n", hr);
    return hr;
  }

  if (!AllocateAndInitializeSid(psia, *psaCount, rgRid[0], rgRid[1],
                                rgRid[2], rgRid[3], rgRid[4],
                                rgRid[5], rgRid[6], rgRid[7], &pSID))
  {
    hr = HRESULT_FROM_WIN32(GetLastError());
    TRACE(L"AllocateAndInitializeSid() failed, hr = 0x%x\n", hr);
    return hr;
  }

  PWSTR rgpwzAttrNames[] = {g_wzADsPath};
  const WCHAR wzSearchFormat[] = L"(&(objectCategory=group)(objectSid=%s))";
  PWSTR pwzSID;
  CString strSearchFilter;

  hr = ADsEncodeBinaryData((PBYTE)pSID, GetLengthSid(pSID), &pwzSID);
  if (FAILED(hr))
  {
    TRACE(L"ADsEncodeBinaryData() failed, hr = 0x%x\n", hr);
    return hr;
  }

  strSearchFilter.Format(wzSearchFormat, pwzSID);
  FreeADsMem(pwzSID);


  CDSSearch Search;
  hr = Search.Init(lpszDomainLDAPPath);
  if (FAILED(hr))
  {
    TRACE(L"Search.Init(%s) failed, hr = 0x%x\n", lpszDomainLDAPPath, hr);
    return hr;
  }

  Search.SetFilterString(const_cast<LPWSTR>((LPCTSTR)strSearchFilter));

  Search.SetAttributeList(rgpwzAttrNames, 1);
  Search.SetSearchScope(ADS_SCOPE_SUBTREE);

  hr = Search.DoQuery();
  if (FAILED(hr))
  {
    TRACE(L"Search.DoQuery() failed, hr = 0x%x\n", hr);
    return hr;
  }

  hr = Search.GetNextRow();

  if (hr == S_ADS_NOMORE_ROWS)
  {
    hr = S_OK;
    szGroupPath = L"";
    TRACE(L"Search. returned S_ADS_NOMORE_ROWS, we failed to find the primary group object, hr = 0x%x\n", hr);
    return hr;
  }

  if (FAILED(hr))
  {
    TRACE(L"Search.GetNextRow() failed, hr = 0x%x\n", hr);
    return hr;
  }


  ADS_SEARCH_COLUMN Column;
  hr = Search.GetColumn(g_wzADsPath, &Column);
  if (FAILED(hr))
  {
    TRACE(L"Search.GetColumn(%s) failed, hr = 0x%x\n", g_wzADsPath, hr);
    return hr;
  }

  szGroupPath = Column.pADsValues->CaseIgnoreString;
  Search.FreeColumn(&Column);

  return hr;
}



/////////////////////////////////////////////////////////////////////
// CCopyableAttributesHolder


HRESULT CCopyableAttributesHolder::LoadFromSchema(MyBasePathsInfo* pBasePathsInfo)
{
  TRACE(L"CCopyableAttributesHolder::LoadFromSchema()\n");

	// build the LDAP path for the schema class
  LPCWSTR lpszPhysicalSchemaNamingContext = pBasePathsInfo->GetSchemaNamingContext();

  CString szPhysicalSchemaPath;
  pBasePathsInfo->ComposeADsIPath(szPhysicalSchemaPath,lpszPhysicalSchemaNamingContext);

  CDSSearch search;
  HRESULT hr = search.Init(szPhysicalSchemaPath);
  if (FAILED(hr))
  {
    TRACE(L"search.Init(%s) failed with hr = 0x%x\n", (LPCWSTR)szPhysicalSchemaPath, hr);
    return hr;
  }

  // the query string filters out the attribute classes that have the
  // "searchFlags" attribute with the 5th bit set (16 == 2^4)
  static LPCWSTR lpszFilterFormat = 
    L"(&(objectCategory=CN=Attribute-Schema,%s)(searchFlags:1.2.840.113556.1.4.803:=16))";

  int nFmtLen = lstrlen(lpszFilterFormat);
  int nSchemaContextLen = lstrlen(lpszPhysicalSchemaNamingContext);

  WCHAR* pszFilter = new WCHAR[nFmtLen+nSchemaContextLen+1];
  if (!pszFilter)
  {
    TRACE(L"Could not allocate enough space for filter string\n");
    return E_OUTOFMEMORY;
  }
  wsprintf(pszFilter, lpszFilterFormat, lpszPhysicalSchemaNamingContext);

  static const int cAttrs = 1;
  static LPCWSTR pszAttribsArr[cAttrs] = 
  {
    L"lDAPDisplayName", // e.g. "accountExpires"
  }; 

  search.SetFilterString(pszFilter);
  search.SetSearchScope(ADS_SCOPE_ONELEVEL);
  search.SetAttributeList((LPWSTR*)pszAttribsArr, cAttrs);

  hr = search.DoQuery();
  if (FAILED(hr))
  {
    TRACE(L"search.DoQuery() failed with hr = 0x%x\n", hr);
    return hr;
  }

  TRACE(L"\n*** Query Results BEGIN ***\n\n");

  ADS_SEARCH_COLUMN Column;
  hr = search.GetNextRow();
  while (hr != S_ADS_NOMORE_ROWS)
  {
    if (FAILED(hr))
    {
      continue;
    }

    HRESULT hr0 = search.GetColumn((LPWSTR)pszAttribsArr[0], &Column);
    if (FAILED(hr0))
    {
      continue;
    }

    LPCWSTR lpszAttr = Column.pADsValues->CaseIgnoreString;
    TRACE(L"Attribute = %s", lpszAttr);

    // screen against attributes we want to skip anyway
    if (!_FindInNotCopyableHardwiredList(lpszAttr))
    {
      TRACE(L" can be copied");
      m_attributeNameList.AddTail(lpszAttr);
    }
    TRACE(L"\n");

    search.FreeColumn(&Column);

    hr = search.GetNextRow(); 
  } // while

  TRACE(L"\n*** Query Results END ***\n\n");

  if (pszFilter)
  {
    delete[] pszFilter;
    pszFilter = 0;
  }

  return hr;
}

BOOL CCopyableAttributesHolder::CanCopy(LPCWSTR lpszAttributeName)
{
  for (POSITION pos = m_attributeNameList.GetHeadPosition(); pos != NULL; )
  {
    CString& strRef = m_attributeNameList.GetNext(pos);
    if (_wcsicmp(lpszAttributeName, strRef) == 0)
      return TRUE;
  }
  return FALSE;
}


// function to screen out attributes that will not
// be copied (or not copied in bulk) no matter what the 
// schema setting are

BOOL CCopyableAttributesHolder::_FindInNotCopyableHardwiredList(LPCWSTR lpszAttributeName)
{
  static LPCWSTR _lpszNoCopyArr[] =
  {
    // we skip the toxic waste dump, no matter what
    L"userParameters",

    // userAccountControl handled separately after commit
    L"userAccountControl",

    // group membership (to be handled after commit)
    L"primaryGroupID",
    L"memberOf",

    NULL // end of table marker
  };


  for (int k = 0; _lpszNoCopyArr[k] != NULL; k++)
  {
    if (_wcsicmp(lpszAttributeName, _lpszNoCopyArr[k]) == 0)
      return TRUE;
  }
  return FALSE;
}






/////////////////////////////////////////////////////////////////////
// CCopyObjectHandlerBase


/////////////////////////////////////////////////////////////////////
// CSid

HRESULT CSid::Init(IADs* pIADs)
{
  static LPWSTR g_wzObjectSID = L"objectSID";
  CComPtr<IDirectoryObject> spDirObj;

  HRESULT hr = pIADs->QueryInterface(IID_IDirectoryObject, (void**)&spDirObj);
  if (FAILED(hr))
  {
    return hr;
  }

  PWSTR rgpwzAttrNames[] = {g_wzObjectSID};
  DWORD cAttrs = 1;
  Smart_PADS_ATTR_INFO spAttrs;

  hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, cAttrs, &spAttrs, &cAttrs);
  if (FAILED(hr))
  {
    return hr;
  }
  if (_wcsicmp(spAttrs[0].pszAttrName, g_wzObjectSID) != 0)
  {
    return E_FAIL;
  }

  if (!Init(spAttrs[0].pADsValues->OctetString.dwLength,
            spAttrs[0].pADsValues->OctetString.lpValue))
  {
    return E_OUTOFMEMORY;
  }
  return S_OK;

}

/////////////////////////////////////////////////////////////////////
// CGroupMembershipHolder

HRESULT CGroupMembershipHolder::Read(IADs* pIADs)
{
  if (pIADs == NULL)
    return E_INVALIDARG;

  // hang on to the ADSI pointer
  m_spIADs = pIADs;

  // get the SID of the object
  HRESULT hr = m_objectSid.Init(m_spIADs);
  if (FAILED(hr))
  {
    TRACE(L"Failed to retrieve object SID, hr = 0x%x\n", hr);
    return hr;
  }

  // get the info about the domain we are in
  hr = _GetDomainScope(m_spIADs, m_szDomainLDAPPath);
  if (FAILED(hr))
  {
    TRACE(L"_GetDomainScope() failed, hr = 0x%x\n", hr);
    return hr;
  }

  hr = _ReadPrimaryGroupInfo();
  if (FAILED(hr))
  {
    TRACE(L"_ReadPrimaryGroupInfo() failed, hr = 0x%x\n", hr);
    return hr;
  }

  hr = _ReadNonPrimaryGroupInfo();
  if (FAILED(hr))
  {
    TRACE(L"_ReadNonPrimaryGroupInfo() failed, hr = 0x%x\n", hr);
    return hr;
  }

#ifdef DBG
  m_entryList.Trace(L"Group Membership List:");
#endif // DBG

  return hr;
}


HRESULT CGroupMembershipHolder::CopyFrom(CGroupMembershipHolder* pSource)
{
  // Add all the elements that are in the source 
  // but not yet in the destination
  CGroupMembershipEntryList* pSourceList = &(pSource->m_entryList);

  //
  // Copy the state of the primary group
  //
  m_bPrimaryGroupFound = pSource->m_bPrimaryGroupFound;

  CGroupMembershipEntryList additionsEntryList;


  for (POSITION pos = pSourceList->GetHeadPosition(); pos != NULL; )
  {
    CGroupMembershipEntry* pCurrSourceEntry = pSourceList->GetNext(pos);

    // look if the the source item is already in the current list
    CGroupMembershipEntry* pEntry = m_entryList.FindByDN(pCurrSourceEntry->GetDN());

    if (pEntry == NULL)
    {
      if (_wcsicmp(pCurrSourceEntry->GetDN(), L"") != 0)
      {
        // not found in the entry list, need to add
        pEntry = new CGroupMembershipEntry(pCurrSourceEntry->GetRID(), pCurrSourceEntry->GetDN());
        pEntry->MarkAdd();
        additionsEntryList.AddTail(pEntry);

        TRACE(L"add: RID %d, DN = <%s>\n", pEntry->GetRID(), pEntry->GetDN());
      }
    }
  } // for


  // find all the elements that are in the destination
  // but not in the source (slated for deletion)
  for (pos = m_entryList.GetHeadPosition(); pos != NULL; )
  {
    CGroupMembershipEntry* pCurrDestEntry = m_entryList.GetNext(pos);

    // look if the the source item is in the source list

    CGroupMembershipEntry* pEntry = pSourceList->FindByDN(pCurrDestEntry->GetDN());

    if (pEntry == NULL)
    {
      // not found in the entry list, need to mark for deletion
      pCurrDestEntry->MarkRemove();
      TRACE(L"remove: RID %d, DN = <%s>\n", pCurrDestEntry->GetRID(), pCurrDestEntry->GetDN());
    }
  } // for

  // catenate the list of additions to the entry list
  m_entryList.Merge(&additionsEntryList);

  return S_OK;
}



HRESULT _EditGroupMembership(LPCWSTR lpszServer, LPCWSTR lpszUserPath, LPCWSTR lpszGroupDN, BOOL bAdd)
{
  // build the full LDAP path of the domain
  CPathCracker pathCracker;
  HRESULT hr = pathCracker.Set((LPWSTR)lpszServer, ADS_SETTYPE_SERVER);
  hr = pathCracker.Set((LPWSTR)lpszGroupDN, ADS_SETTYPE_DN);
  
  CComBSTR bstrGroupPath;
  hr = pathCracker.Retrieve(ADS_FORMAT_X500, &bstrGroupPath);
  if (FAILED(hr))
  {
    TRACE(L"PathCracker() failed to build LDAP path. hr = 0x%x\n", hr);
    return hr;
  }

  CComPtr<IADs> spIADs;
  hr = DSAdminOpenObject(bstrGroupPath,
                         IID_IADs, 
                         (void **)&spIADs,
                         TRUE /*bServer*/);
  if (FAILED(hr))
  {
    TRACE(L"DSAdminOpenObject(%s) on group failed, hr = 0x%x\n", bstrGroupPath, hr);
    return hr;
  }
  hr = spIADs->GetInfo();
  CComPtr<IADsGroup> spIADsGroup;
  hr = spIADs->QueryInterface(IID_IADsGroup, (void**)&spIADsGroup);

  if (bAdd)
  {
    hr = spIADsGroup->Add((LPWSTR)lpszUserPath);
    if (FAILED(hr))
    {
      TRACE(L"spIADsGroup->Add(%s) on group failed, hr = 0x%x\n", lpszUserPath, hr);
      return hr;
    }
  }
  else
  {
    hr = spIADsGroup->Remove((LPWSTR)lpszUserPath);
    if (FAILED(hr))
    {
      TRACE(L"spIADsGroup->Remove(%s) on group failed, hr = 0x%x\n", lpszUserPath, hr);
      return hr;
    }
  }
  
  hr = spIADsGroup->SetInfo();
  if (FAILED(hr))
  {
    TRACE(L"spIADsGroup->SetInfo() on group failed, hr = 0x%x\n", hr);
    return hr;
  }

  return hr;
}



HRESULT CGroupMembershipHolder::Write()
{
  TRACE(L"CGroupMembershipHolder::Write()\n");

#ifdef DBG
  m_entryList.Trace(L"Group Membership List:");
#endif // DBG

  // get the path of the user object
  CComBSTR bstrObjPath;
  HRESULT hr = m_spIADs->get_ADsPath(&bstrObjPath);
  if (FAILED(hr))
  {
    TRACE(L"m_spIADs->get_ADsPath() failed with hr = 0x%x\n", hr);
    return hr;
  }

  TRACE(L"bstrPath = %s\n", (LPCWSTR)bstrObjPath);

  // retrieve the server name the object is bound to
  CString szServer;
  hr = GetADSIServerName(OUT szServer, IN m_spIADs);
  if (FAILED(hr))
  {
    TRACE(L"GetADSIServerName() failed with hr = 0x%x\n", hr);
    return hr;
  }

  // first do all the additions
  // also remember if we added a primary group
  CGroupMembershipEntry* pNewPrimaryGroupEntry = NULL;

  TRACE(L"\nfirst do all the additions\n\n");

  for (POSITION pos = m_entryList.GetHeadPosition(); pos != NULL; )
  {
    CGroupMembershipEntry* pCurrEntry = m_entryList.GetNext(pos);

    if (pCurrEntry->GetActionType() == CGroupMembershipEntry::add)
    {
      TRACE(L"add: RID %d, DN = <%s>\n", pCurrEntry->GetRID(), pCurrEntry->GetDN());

      pCurrEntry->m_hr = _EditGroupMembership(szServer, bstrObjPath, pCurrEntry->GetDN(), TRUE /*bAdd*/);
      if (SUCCEEDED(pCurrEntry->m_hr) && (pCurrEntry->IsPrimaryGroup()))
      {
        ASSERT(pNewPrimaryGroupEntry == NULL);
        pNewPrimaryGroupEntry = pCurrEntry;
      }
    }
  } // for

  if (m_bPrimaryGroupFound)
  {
    // second, do the primary group change
    TRACE(L"\ndo the primary group change\n\n");
    if (pNewPrimaryGroupEntry != NULL)
    {
      TRACE(L"new primary: RID %d, DN = <%s>\n", 
        pNewPrimaryGroupEntry->GetRID(), pNewPrimaryGroupEntry->GetDN());

      CComVariant varPrimaryGroupID;
      varPrimaryGroupID.vt = VT_I4;
      varPrimaryGroupID.lVal = pNewPrimaryGroupEntry->GetRID();

      hr = m_spIADs->Put(L"primaryGroupID", varPrimaryGroupID); 
      if (FAILED(hr))
      {
        TRACE(L"m_spIADs->Put(primaryGroupID) failed with hr = 0x%x\n", hr);
        return hr;
      }
  
      hr = m_spIADs->SetInfo();
      if (FAILED(hr))
      {
        TRACE(L"m_spIADs->SetInfo() failed with hr = 0x%x\n", hr);
        return hr;
      }
    }
  }

  // finally do the deletes
  TRACE(L"\ndo the deletes\n\n");
  for (pos = m_entryList.GetHeadPosition(); pos != NULL; )
  {
    CGroupMembershipEntry* pCurrEntry = m_entryList.GetNext(pos);

    if (pCurrEntry->GetActionType() == CGroupMembershipEntry::remove)
    {
      TRACE(L"remove: RID %d, DN = <%s>\n", pCurrEntry->GetRID(), pCurrEntry->GetDN());

      pCurrEntry->m_hr = _EditGroupMembership(szServer, bstrObjPath, pCurrEntry->GetDN(), FALSE /*bAdd*/);
    }
  } // for

  return S_OK;
}


void CGroupMembershipHolder::ProcessFailures(HRESULT& hr, CString& szFailureString, BOOL* pPrimaryGroupFound)
{
  // reset variables
  hr = S_OK;
  szFailureString.Empty();

  BOOL bFirstOne = TRUE;
  BOOL bGotAccessDenied = FALSE;

  *pPrimaryGroupFound = m_bPrimaryGroupFound;

  // compose the best error code. If one code is access denied,
  // return it. If none is access denied, use the first error code

  for (POSITION pos = m_entryList.GetHeadPosition(); pos != NULL; )
  {
    CGroupMembershipEntry* pCurrEntry = m_entryList.GetNext(pos);
    if (FAILED(pCurrEntry->m_hr))
    {
      if (pCurrEntry->m_hr == E_ACCESSDENIED)
      {
        bGotAccessDenied = TRUE;
      }
      if (bFirstOne)
      {
        bFirstOne = FALSE;
        hr = pCurrEntry->m_hr;
      }
      else
      {
        szFailureString += L"\n";
      }

      LPWSTR pszCanonical = NULL;
      HRESULT hrCanonical = 
          CrackName((LPWSTR)pCurrEntry->GetDN(), &pszCanonical, GET_OBJ_CAN_NAME, NULL);
      if ((S_OK == hrCanonical) && (pszCanonical != NULL))
      {
        szFailureString += pszCanonical;
        LocalFreeStringW(&pszCanonical);
      }
      else
      {
        szFailureString += pCurrEntry->GetDN();
      }
    }
  } // for

  if (bGotAccessDenied)
  {
    // override any error we have
    hr = E_ACCESSDENIED;
  }
}


HRESULT CGroupMembershipHolder::_ReadPrimaryGroupInfo()
{
  // from the object SID and the primary group RID, get the full
  // primary group info

  // read the RID for the primary group
  CComVariant varPrimaryGroupID;
  HRESULT hr = m_spIADs->Get(L"primaryGroupID", &varPrimaryGroupID);
  if (FAILED(hr))
  {
    TRACE(L"m_spIADs->Get(primaryGroupID, ...) failed, hr = 0x%x\n", hr);
    return hr;
  }
  ASSERT(varPrimaryGroupID.vt == VT_I4);
  TRACE(L"primaryGroupID = %d\n", varPrimaryGroupID.lVal);

  // now need to map it into actual group information

 
  CString szGroupPath;
  PSID pObjSID = m_objectSid.GetSid();
  DWORD priGroupRID = varPrimaryGroupID.lVal;
  hr = _ConvertRIDtoName(IN m_szDomainLDAPPath,
                         IN pObjSID,
                         IN priGroupRID, 
                         OUT szGroupPath);
  if (FAILED(hr))
  {
    TRACE(L"_ConvertRIDtoName() failed, hr = 0x%x\n", hr);
    return hr;
  }

  CComBSTR bstrGroupDN;
  if (szGroupPath != L"")
  {
    m_bPrimaryGroupFound = TRUE;

    // from the LDAP path, retrieve the DN
    CPathCracker pathCracker;
    hr = pathCracker.Set((LPWSTR)(LPCWSTR)szGroupPath, ADS_SETTYPE_FULL);
    hr = pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bstrGroupDN);
    if (FAILED(hr))
    {
      TRACE(L"PathCracker() failed to build primary group DN path. hr = 0x%x\n", hr);
      return hr;
    }
  }
  else
  {
    bstrGroupDN = szGroupPath;
  }

  // create a new entry
  CGroupMembershipEntry* pEntry = new CGroupMembershipEntry(priGroupRID, bstrGroupDN);
  m_entryList.AddTail(pEntry);
  TRACE(L"CGroupMembershipEntry(%d,%s) added to list\n", priGroupRID, bstrGroupDN);

  return hr;
}




HRESULT CGroupMembershipHolder::_ReadNonPrimaryGroupInfo()
{
  // copy group membership
  CComVariant varMemberOf;
  HRESULT hr = m_spIADs->Get(L"memberOf", &varMemberOf);
  if (hr == E_ADS_PROPERTY_NOT_FOUND)
  {
    TRACE(L"_ReadNonPrimaryGroupInfo(): memberOf not set\n");
    return S_OK;
  }

  if (FAILED(hr))
  {
    return hr;
  }

  CStringList groupList;
  hr = HrVariantToStringList(IN varMemberOf, groupList);
  if (FAILED(hr))
  {
    TRACE(L"HrVariantToStringList() failed with hr = 0x%x\n", hr);
    return hr;
  }


  CComBSTR bstrPath;
  hr = m_spIADs->get_ADsPath(&bstrPath);
  if (FAILED(hr))
  {
    TRACE(L"m_spIADs->get_ADsPath() failed with hr = 0x%x\n", hr);
    return hr;
  }

  TRACE(L"bstrPath = %s\n", (LPCWSTR)bstrPath);

  for (POSITION pos = groupList.GetHeadPosition(); pos != NULL; )
  {
    CString szGroupDN = groupList.GetNext(pos);
    TRACE(_T("szGroupDN: %s\n"), (LPCWSTR)szGroupDN);
    CGroupMembershipEntry* pEntry = new CGroupMembershipEntry(0x0, szGroupDN);
    m_entryList.AddTail(pEntry);
  } 

  return hr;    
}




/////////////////////////////////////////////////////////////////////
// CCopyUserHandler


HRESULT CCopyUserHandler::Init(MyBasePathsInfo* pBasePathsInfo, IADs* pIADsCopyFrom)
{
  HRESULT hr = CCopyObjectHandlerBase::Init(pBasePathsInfo, pIADsCopyFrom);
  if (FAILED(hr))
  {
    return hr;
  }

  // read list of copyable attributes form the schema
  hr = m_copyableAttributesHolder.LoadFromSchema(pBasePathsInfo);
  if (FAILED(hr))
  {
    return hr;
  }

  // read group membership information
  hr = m_sourceMembershipHolder.Read(m_spIADsCopyFrom);
  if (FAILED(hr))
  {
    return hr;
  }

  hr = _ReadPasswordCannotChange();
  if (FAILED(hr))
  {
    return hr;
  }

  hr = _ReadPasswordMustChange();

  return hr;
}
 


HRESULT CCopyUserHandler::Copy(IADs* pIADsCopyTo, BOOL bPostCommit, 
                        HWND hWnd, LPCWSTR lpszObjectName)
{
  HRESULT hr = S_OK;
  if (bPostCommit)
  {
    hr = _CopyGroupMembership(pIADsCopyTo);
    if (SUCCEEDED(hr))
    {
      // might have failed to add to some group(s)
      _ShowGroupMembershipWarnings(hWnd, lpszObjectName);
    }
    if (FAILED(hr))
    {
      // something went really wrong, need to bail out
      return hr;
    }

    if (m_bNeedToCreateHomeDir)
    {
      // it might fail under unforeseen circumstances
      hr = _CreateHomeDirectory(pIADsCopyTo, lpszObjectName, hWnd);
    }
  }
  else
  {
    hr = _UpdatePaths(pIADsCopyTo);
  }
  return hr;
}



HRESULT CCopyUserHandler::_ReadPasswordCannotChange()
{
  CChangePasswordPrivilegeAction ChangePasswordPrivilegeAction;

  HRESULT hr = ChangePasswordPrivilegeAction.Load(GetCopyFrom());
  if (FAILED(hr))
  {
    TRACE(L"ChangePasswordPrivilegeAction.Load() failed with hr = 0x%x\n", hr);
    return hr;
  }

  hr = ChangePasswordPrivilegeAction.Read(&m_bPasswordCannotChange);
  if (FAILED(hr))
  {
    TRACE(L"ChangePasswordPrivilegeAction.Read() failed with hr = 0x%x\n", hr);
    return hr;
  }
  return S_OK;
}


HRESULT CCopyUserHandler::_ReadPasswordMustChange()
{
  CComPtr<IDirectoryObject> spDirObj;
  HRESULT hr = GetCopyFrom()->QueryInterface(IID_IDirectoryObject, (void**)&spDirObj);
  if (FAILED(hr))
  {
    return hr;
  }

  PWSTR rgpwzAttrNames[] = {L"pwdLastSet"};
  DWORD cAttrs = 1;
  Smart_PADS_ATTR_INFO spAttrs;

  hr = spDirObj->GetObjectAttributes(rgpwzAttrNames, cAttrs, &spAttrs, &cAttrs);
  if (FAILED(hr))
  {
    return hr;
  }

  if ( (_wcsicmp(spAttrs[0].pszAttrName, L"pwdLastSet") != 0) ||
       (spAttrs[0].dwADsType != ADSTYPE_LARGE_INTEGER) )
  {
    return E_FAIL;
  }

  m_bPasswordMustChange = (spAttrs[0].pADsValues->LargeInteger.QuadPart == 0);
  
  return S_OK;
}

HRESULT CCopyUserHandler::_CopyAttributes(IADs* pIADsCopyTo)
{
  ASSERT(pIADsCopyTo != NULL);
  ASSERT(m_spIADsCopyFrom != NULL);

  HRESULT hr = S_OK;

  CComPtr<IADsPropertyList> spIADsPropertyList;
  
  // get a property list interface from the object we want to copy from
  hr = m_spIADsCopyFrom->QueryInterface(IID_IADsPropertyList, (void**)&spIADsPropertyList);
  if (FAILED(hr))
  {
    return hr;
  }

  // ignore the return value and try to continue even if it didn't reset
  hr = spIADsPropertyList->Reset();

  // loop thru the list of set attributes
  CComVariant varProperty;
  do 
  {
    hr = spIADsPropertyList->Next(&varProperty);
    if (SUCCEEDED(hr))
    {
      ASSERT(varProperty.vt == VT_DISPATCH);
      if (varProperty.pdispVal != NULL)
      {
        CComPtr<IADsPropertyEntry> spIADsPropertyEntry;
        hr = (varProperty.pdispVal)->QueryInterface(IID_IADsPropertyEntry, (void**)&spIADsPropertyEntry);
        if (SUCCEEDED(hr))
        {
          CComBSTR bstrName;
          hr = spIADsPropertyEntry->get_Name(&bstrName);
          if (SUCCEEDED(hr))
          {
            TRACE(L" Property Name = <%s>", bstrName);
            if (m_copyableAttributesHolder.CanCopy(bstrName))
            {
              TRACE(L"  Can copy: ");
              CComVariant varData;
              hr = m_spIADsCopyFrom->Get(bstrName, &varData);
              if (SUCCEEDED(hr))
              {
                HRESULT hr1 = pIADsCopyTo->Put(bstrName, varData);
                if (SUCCEEDED(hr1))
                {
                  TRACE(L"Added");
                }
                else
                {
                  TRACE(L"Failed: 0x%x", hr1);
                }
              }
            }
            TRACE(L"\n");
          }
        }
      }
    }
    varProperty.Clear();
  }
  while (hr == S_OK);

  return S_OK;
}

// Given an IADs* of an object, retrieves a string attrubute
// in a variant
HRESULT _GetStringAttribute(IN IADs* pIADs, IN LPCWSTR lpszAttribute, OUT CComVariant& var)
{
  TRACE(L"_GetStringAttribute(_, %s, _)\n", lpszAttribute);

  HRESULT hr = pIADs->Get((LPWSTR)lpszAttribute, &var);
  if (FAILED(hr))
  {
    TRACE(L"_GetStringAttribute(): pIADs->Get() failed with hr = 0x%x\n", hr);  
    return hr;
  }
  if (var.vt != VT_BSTR)
  {
    TRACE(L"_GetStringAttribute(): failed because var.vt != VT_BSTR\n");
    return E_INVALIDARG;
  }
  return S_OK;
}


BOOL _ChangePathUsingSAMAccountName(IN LPCWSTR lpszSAMAccountNameSource,
                          IN LPCWSTR lpszSAMAccountDestination,
                          INOUT CComVariant& varValPath)
{
  // NOTICE: we do the substitution only if we find
  // something like:
  // \\myhost\myshare\JoeB
  // i.e. the last token in the path is the source SAM account name
  // we change into \\myhost\myshare\FrankM

  TRACE(L"_ChangePathUsingSAMAccountName(%s, %s, _)\n",
     lpszSAMAccountNameSource, lpszSAMAccountDestination);


  ASSERT(lpszSAMAccountNameSource != NULL);
  ASSERT(lpszSAMAccountDestination != NULL);

  // invalid string
  if ( (varValPath.vt != VT_BSTR) || (varValPath.bstrVal == NULL))
  {
    TRACE(L"returning FALSE, varValPath of wrong type or NULL\n");
    return FALSE;
  }

  CString szSourcePath = varValPath.bstrVal;
  TRACE(L"Input value for varValPath.bstrVal = %s\n", varValPath.bstrVal);


  // look for a \ as a separator 
  int iLastSlash = szSourcePath.ReverseFind(L'\\');
  if (iLastSlash == -1)
  {
    //
    // No slashes were found
    //
    TRACE(L"returning FALSE, could not find the \\ at the end of the string\n");
    return FALSE;
  }
  CString szSAMName = szSourcePath.Right(szSourcePath.GetLength() - iLastSlash - 1);
  ASSERT(!szSAMName.IsEmpty());

  // compare what is after the \ with the source SAM account name
  if (szSAMName.CompareNoCase(lpszSAMAccountNameSource) != 0)
  {
    TRACE(L"returning FALSE, lpszLeaf = %s does not match source SAM account name\n", szSAMName);
    return FALSE;
  }

  CString szBasePath = szSourcePath.Left(iLastSlash + 1);
  CString szNewPath = szBasePath + lpszSAMAccountDestination;

  // replace old value in variant
  ::SysFreeString(varValPath.bstrVal);
  varValPath.bstrVal = ::SysAllocString(szNewPath);

  TRACE(L"returning TRUE, new varValPath.bstrVal = %s\n", varValPath.bstrVal);

  return TRUE; // we did a replacement
}


HRESULT _UpdatePathAttribute(IN LPCWSTR lpszAttributeName,
                           IN LPCWSTR lpszSAMAccountNameSource,
                           IN LPCWSTR lpszSAMAccountDestination,
                           IN IADs* pIADsCopySource,
                           IN IADs* pIADsCopyTo,
                           OUT BOOL* pbDirChanged)
{

  TRACE(L"_UpdatePathAttribute(%s, %s, %s, _, _, _)\n",
    lpszAttributeName, lpszSAMAccountNameSource, lpszSAMAccountDestination);

  *pbDirChanged = FALSE;

  // get the value of the source attribute
  CComVariant varVal;
  HRESULT hr = pIADsCopySource->Get((LPWSTR)lpszAttributeName, &varVal);

  // if attribute not set, nothing to do
  if (hr == E_ADS_PROPERTY_NOT_FOUND)
  {
    TRACE(L"attribute not set, just returning\n");
    return E_ADS_PROPERTY_NOT_FOUND;
  }

  // handle other unexpected failures
  if (FAILED(hr))
  {
    TRACE(L"pIADsCopySource->Get(%s,_) failed with hr = 0x%x\n", lpszAttributeName, hr);
    return hr;
  }

  if (varVal.vt == VT_EMPTY)
  {
    TRACE(L"just returning because varVal.vt == VT_EMPTY\n");
    return E_ADS_PROPERTY_NOT_FOUND;
  }
  if (varVal.vt != VT_BSTR)
  {
    TRACE(L"failed because var.vt != VT_BSTR\n");
    return E_INVALIDARG;
  }

  // synthesize the new value of the path, if appropriate
  if (_ChangePathUsingSAMAccountName(lpszSAMAccountNameSource, lpszSAMAccountDestination, varVal))
  {
    // the path got updated, need to update the destination object
    hr = pIADsCopyTo->Put((LPWSTR)lpszAttributeName, varVal);
    TRACE(L"pIADsCopyTo->Put(%s,_) returned hr = 0x%x\n", lpszAttributeName, hr);

    if (SUCCEEDED(hr))
    {
      *pbDirChanged = TRUE;
    }
  }

  TRACE(L"*pbDirChanged = %d\n", *pbDirChanged);

  // we should fail only in really exceptional circumstances
  ASSERT(SUCCEEDED(hr));
  return hr;
}


HRESULT CCopyUserHandler::_UpdatePaths(IADs* pIADsCopyTo)
{
  // NOTICE: we assume that, if the paths are copyable, they have been
  // bulk copied when the temporary object was created.
  // If the paths have to be adjusted, we overwrite the copy.

  TRACE(L"CCopyUserHandler::_UpdatePaths()\n");

  // reset the flag for post commit
  m_bNeedToCreateHomeDir = FALSE;

  BOOL bCopyHomeDir = m_copyableAttributesHolder.CanCopy(g_szHomeDir);
  BOOL bCopyProfilePath = m_copyableAttributesHolder.CanCopy(g_szProfilePath);

  TRACE(L"bCopyHomeDir = %d, bCopyProfilePath = %d\n", bCopyHomeDir, bCopyProfilePath);

  if (!bCopyHomeDir && !bCopyProfilePath)
  {
    TRACE(L"no need to update anything, bail out\n");
    return S_OK;
  }


  // retrieve the SAM account names of source and destination
  // to synthesize the new paths
  IADs* pIADsCopySource = GetCopyFrom();

  CComVariant varSAMNameSource;
  HRESULT hr = _GetStringAttribute(pIADsCopySource, gsz_samAccountName, varSAMNameSource);
  if (FAILED(hr))
  {
    TRACE(L"_GetStringAttribute() failed on source SAM account name\n");
    return hr;
  }

  CComVariant varSAMNameDestination;
  hr = _GetStringAttribute(pIADsCopyTo, gsz_samAccountName, varSAMNameDestination);
  if (FAILED(hr))
  {
    TRACE(L"_GetStringAttribute() failed on destination SAM account name\n");
    return hr;
  }

  if (bCopyHomeDir)
  {
    BOOL bDummy;
    hr = _UpdatePathAttribute(g_szHomeDir, varSAMNameSource.bstrVal, 
                                      varSAMNameDestination.bstrVal,
                                      pIADsCopySource,
                                      pIADsCopyTo,
                                      &bDummy);
    
    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
      // not set, just clear the HRESULT
      hr = S_OK;
    }
    else
    {
      // the home directory was set, verify it is a UNC path
      CComVariant varDestinationHomeDir;
      hr = _GetStringAttribute(pIADsCopyTo, g_szHomeDir, varDestinationHomeDir);
      if (FAILED(hr))
      {
        TRACE(L"_GetStringAttribute() failed on homeDir hr = 0x%x\n", hr);
        return hr;
      }

      m_bNeedToCreateHomeDir = DSPROP_IsValidUNCPath(varDestinationHomeDir.bstrVal);
      TRACE(L"DSPROP_IsValidUNCPath(%s) returned = %d\n", 
                varDestinationHomeDir.bstrVal, m_bNeedToCreateHomeDir);

    }

    if (FAILED(hr))
    {
      TRACE(L"_UpdatePathAttribute() failed on homeDir hr = 0x%x\n", hr);
      return hr;
    }

  }

  if (bCopyProfilePath)
  {
    BOOL bDummy;
    hr = _UpdatePathAttribute(g_szProfilePath, varSAMNameSource.bstrVal, 
                                      varSAMNameDestination.bstrVal,
                                      pIADsCopySource,
                                      pIADsCopyTo,
                                      &bDummy);
    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
      // not set, just clear the HRESULT
      hr = S_OK;
    }

    if (FAILED(hr))
    {
      TRACE(L"_UpdatePathAttribute() failed on profilePath hr = 0x%x\n", hr);
      return hr;
    }

  }

  // failure expected only under exceptional circumstances
  return S_OK;
}

HRESULT CCopyUserHandler::_CreateHomeDirectory(IADs* pIADsCopyTo, 
                                               LPCWSTR lpszObjectName, HWND hWnd)
{
  TRACE(L"CCopyUserHandler::_CreateHomeDirectory()\n");

  ASSERT(m_bNeedToCreateHomeDir);

  // retrieve the home directory attribute
  CComVariant VarHomeDir;
  HRESULT hr = pIADsCopyTo->Get(g_szHomeDir, &VarHomeDir);
  if (FAILED(hr))
  {
    TRACE(L"pIADsCopyTo->Get(%s,_) failed, hr = 0x%x\n", g_szHomeDir, hr);
    return hr;
  }
  if (VarHomeDir.vt != VT_BSTR)
  {
    TRACE(L"failing because varVal.vt != VT_BSTR\n");
    return E_INVALIDARG;
  }

  // retrieve the SID of the newly created object
  CSid destinationObjectSid;
  hr = destinationObjectSid.Init(pIADsCopyTo);
  if (FAILED(hr))
  {
    TRACE(L"destinationObjectSid.Init() failed, , hr = 0x%x\n", hr);

    // unforeseen error
    PVOID apv[1] = {(LPWSTR)(lpszObjectName) };
    ReportErrorEx(hWnd, IDS_CANT_READ_HOME_DIR_SID, hr,
               MB_OK | MB_ICONWARNING, apv, 1);

    // we cannot proceed further, but we return success because 
    // we already displayed the error message and we want to treat the
    // failure as a warning

    return S_OK;
  }

  // make call to helper function to create directory and set ACL's on it
  DWORD dwErr = ::DSPROP_CreateHomeDirectory(destinationObjectSid.GetSid(), VarHomeDir.bstrVal);
  TRACE(L"DSPROP_CreateHomeDirectory(%s, pSid) returned dwErr = 0x%x\n", VarHomeDir.bstrVal, dwErr);

  if (dwErr != 0)
  {
    // treat as a warning, display a message and continue
   
    PVOID apv[1] = {VarHomeDir.bstrVal};

    UINT nMsgID = 0;
    switch (dwErr)
    {
    case ERROR_ALREADY_EXISTS:
      nMsgID = IDS_HOME_DIR_EXISTS;
      break;
    case ERROR_PATH_NOT_FOUND:
      nMsgID = IDS_HOME_DIR_CREATE_FAILED;
      break;
    case ERROR_LOGON_FAILURE:
    case ERROR_NOT_AUTHENTICATED:
    case ERROR_INVALID_PASSWORD:
    case ERROR_PASSWORD_EXPIRED:
    case ERROR_ACCOUNT_DISABLED:
    case ERROR_ACCOUNT_LOCKED_OUT:
      nMsgID = IDS_HOME_DIR_CREATE_NO_ACCESS;
      break;
    default:
      nMsgID = IDS_HOME_DIR_CREATE_FAIL;
    } // switch

    HRESULT hrTemp = HRESULT_FROM_WIN32(dwErr);
    ReportErrorEx(hWnd, nMsgID, hrTemp,
           MB_OK|MB_ICONWARNING , apv, 1);

  }

  return S_OK;
}


HRESULT CCopyUserHandler::_CopyGroupMembership(IADs* pIADsCopyTo)
{
  if (pIADsCopyTo == NULL)
    return E_INVALIDARG;

  HRESULT hr = pIADsCopyTo->GetInfo();
  if (FAILED(hr))
  {
    TRACE(L"pIADsCopyTo->GetInfo() failed with hr = 0x%x\n", hr);
    return hr;
  }


  CGroupMembershipHolder destinationMembership;

  hr = destinationMembership.Read(pIADsCopyTo);
  if (FAILED(hr))
  {
    TRACE(L"destinationMembership.Read(pIADsCopyTo) failed with hr = 0x%x\n", hr);
    return hr;
  }

  hr = destinationMembership.CopyFrom(&m_sourceMembershipHolder);
  if (FAILED(hr))
  {
    TRACE(L"destinationMembership.CopyFrom() failed with hr = 0x%x\n", hr);
    return hr;
  }

  hr = destinationMembership.Write();
  if (FAILED(hr))
  {
    // something unexpected failed and we are going to percolate
    // it to the wizards for a generic warning message
    TRACE(L"destinationMembership.Write() failed with hr = 0x%x\n", hr);
    return hr;
  }

  // there can be failures related to acccess denied on some groups
  // we handle them with a cumulative warning
  destinationMembership.ProcessFailures(m_hrFailure, m_szFailureString, &m_bPrimaryGroupFound);

  return S_OK;
}


void CCopyUserHandler::_ShowGroupMembershipWarnings(HWND hWnd, LPCWSTR lpszObjectName)
{
  if (!m_bPrimaryGroupFound)
  {
    // Some message box
    ReportMessageEx(hWnd, IDS_123_CANT_COPY_PRIMARY_GROUP_NOT_FOUND, 
                    MB_OK | MB_ICONWARNING);
  }

  if (m_szFailureString.IsEmpty())
  {
    // we have nothing
    return;
  }

  // we have an HRESULT we can use
  ASSERT(FAILED(m_hrFailure));

  UINT nMsgID = (m_hrFailure == E_ACCESSDENIED) ? 
                  IDS_123_CANT_COPY_SOME_GROUP_MEMBERSHIP_ACCESS_DENIED :
                  IDS_123_CANT_COPY_SOME_GROUP_MEMBERSHIP;

  PVOID apv[2] = {(LPWSTR)(lpszObjectName), (LPWSTR)(LPCWSTR)m_szFailureString };
  ReportErrorEx(hWnd,nMsgID, m_hrFailure,
               MB_OK | MB_ICONERROR, apv, 2);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dbg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       dbg.h
//
//--------------------------------------------------------------------------



/////////////////////////////////////////////////////////////////////
// debug helpers

#if defined(_USE_DSA_TRACE)
  #if defined(TRACE)
    #undef TRACE
    void  DSATrace(LPCWSTR, ...);
    #define TRACE DSATrace
  #endif // defined(TRACE)
#endif // defined(_USE_DSA_TRACE)


#if defined(_USE_DSA_ASSERT)
#undef ASSERT
#undef VERIFY
#undef THIS_FILE
#define THIS_FILE          __FILE__
BOOL DSAAssertFailedLine(LPCSTR lpszFileName, int nLine);
#define ASSERT(f) \
	do \
	{ \
    BOOL bPrefast = (f && L"a hack so that prefast doesn't bark"); \
  	if (!(bPrefast) && DSAAssertFailedLine(THIS_FILE, __LINE__)) \
	  	::DebugBreak(); \
	} while (0) \

#define VERIFY(f)          ASSERT(f)

#endif // _USE_DSA_ASSERT

#if defined (_USE_DSA_TIMER)

void DSATimer(LPCWSTR, ...);
#define TIMER DSATimer

#else

#define TIMER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dataobj.h ===
//+----------------------------------------------------------------------------
//
//  DS Administration MMC snapin.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       DataObj.h
//
//  Contents:   Data Object Functions
//
//  Classes:    CDSDataObject
//
//  History:    02-Oct-96 WayneSc    Created
//              06-Feb-97 EricB - added Property Page Data support
//
//--------------------------------------------------------------------------

#ifndef __DATAOBJ_H__
#define __DATAOBJ_H__

#define CFSTR_DS_COMPDATA TEXT("DsCompData")

class CDSComponentData;

//+----------------------------------------------------------------------------
//
//  Class: CDSDataObject
//
//-----------------------------------------------------------------------------
class CDSDataObject : public IDataObject, public CComObjectRoot 
{
// ATL Maps
    DECLARE_NOT_AGGREGATABLE(CDSDataObject)
    BEGIN_COM_MAP(CDSDataObject)
        COM_INTERFACE_ENTRY(IDataObject)
    END_COM_MAP()

// Construction/Destruction
  CDSDataObject() : m_lNotifyHandle(0), m_hwndParentSheet(NULL)
  {
    m_pDsComponentData = NULL;
    m_pDSObjCached = NULL;
    m_nDSObjCachedBytes = 0;
    m_szUniqueID = _T("");
  }
  
  ~CDSDataObject() 
  {
    if (m_internal.m_p_cookies != NULL)
    {
      ASSERT(m_internal.m_cookie_count > 1);
      free(m_internal.m_p_cookies);
    }

    if (m_pDSObjCached != NULL)
    {
      ::free(m_pDSObjCached);
    }
  }

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(FORMATETC * pformatetcIn, STGMEDIUM * pmedium);

    STDMETHOD(GetDataHere)(FORMATETC * pFormatEtcIn, STGMEDIUM * pMedium);

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection,
                             IEnumFORMATETC ** ppenumFormatEtc);

    STDMETHOD(SetData)(FORMATETC * pformatetc, STGMEDIUM * pmedium,
                       BOOL fRelease);

// Not Implemented
private:
    STDMETHOD(QueryGetData)(FORMATETC*)                         { return E_NOTIMPL; };
    STDMETHOD(GetCanonicalFormatEtc)(FORMATETC*, FORMATETC*)    { return E_NOTIMPL; };
    STDMETHOD(DAdvise)(FORMATETC*, DWORD, IAdviseSink*, DWORD*) { return E_NOTIMPL; };
    STDMETHOD(DUnadvise)(DWORD)                                 { return E_NOTIMPL; };
    STDMETHOD(EnumDAdvise)(IEnumSTATDATA**)                     { return E_NOTIMPL; };

public:
    // Clipboard formats that are required by the console
    static CLIPFORMAT    m_cfNodeType;
    static CLIPFORMAT    m_cfNodeTypeString;  
    static CLIPFORMAT    m_cfDisplayName;
    static CLIPFORMAT    m_cfCoClass;
    static CLIPFORMAT    m_cfInternal;
    static CLIPFORMAT    m_cfMultiSelDataObjs;
    static CLIPFORMAT    m_cfMultiObjTypes;
    static CLIPFORMAT    m_cfpMultiSelDataObj;
    static CLIPFORMAT    m_cfColumnID;
    static CLIPFORMAT    m_cfPreload;
    
    // Property Page Clipboard formats
    static CLIPFORMAT m_cfDsObjectNames;
    static CLIPFORMAT m_cfDsDisplaySpecOptions;
    static CLIPFORMAT m_cfDsSchemaPath;
    static CLIPFORMAT m_cfPropSheetCfg;
    static CLIPFORMAT m_cfParentHwnd;
    static CLIPFORMAT m_cfMultiSelectProppage;

    // Private format for internal communication
    static CLIPFORMAT m_cfComponentData;

    ULONG InternalAddRef()
    {
      //        ++CSnapin::lDataObjectRefCount;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
      //    --CSnapin::lDataObjectRefCount;
        return CComObjectRoot::InternalRelease();
    }

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type, SnapinType snapintype)
    {
        ASSERT(m_internal.m_type == CCT_UNINITIALIZED);
        m_internal.m_type = type;
        m_internal.m_snapintype = snapintype;
    }

    void SetCookie(CUINode* pUINode) { 
      m_internal.m_cookie = pUINode;
      m_internal.m_cookie_count = 1;
      CreateDsObjectNamesCached();
    }
    void AddCookie(CUINode* pUINode);
    void SetString(LPTSTR lpString) { m_internal.m_string = lpString; }
    void SetComponentData(CDSComponentData * pCompData)
                                    { m_pDsComponentData = pCompData; }

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateMultiSelectObject(LPSTGMEDIUM lpMedium);
    HRESULT CreateColumnID(LPSTGMEDIUM lpMedium);

    HRESULT CreateDsObjectNamesCached();

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
    INTERNAL m_internal;
    CDSComponentData * m_pDsComponentData;
    LONG_PTR m_lNotifyHandle;
    HWND     m_hwndParentSheet;

    LPDSOBJECTNAMES m_pDSObjCached;
    DWORD m_nDSObjCachedBytes;
    CString m_szUniqueID;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dcbufmgr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dcbufmgr.h
//
//--------------------------------------------------------------------------

#ifndef __DCBUFMGR_H__
#define __DCBUFMGR_H__

#include "afxmt.h"    // CCriticalSection
#include "ntdsapi.h" //PDS_DOMAIN_CONTROLLER_INFO_1

#define WM_USER_GETDC_THREAD_DONE      WM_USER + 200

enum BUFFER_ENTRY_TYPE {
    BUFFER_ENTRY_TYPE_VALID = 0,
    BUFFER_ENTRY_TYPE_ERROR,
    BUFFER_ENTRY_TYPE_INPROGRESS
};

class CDCSITEINFO
{
public:
  CString                       m_csDomainName;
  DWORD                         m_cInfo;
  PDS_DOMAIN_CONTROLLER_INFO_1  m_pDCInfo;
  HRESULT                       m_hr;

  CDCSITEINFO();
  ~CDCSITEINFO();

  inline CString& GetDomainName() { return m_csDomainName; }
  inline DWORD GetNumOfInfo() { return m_cInfo; }
  inline PDS_DOMAIN_CONTROLLER_INFO_1 GetDCInfo() { return m_pDCInfo; }

  void SetEntry(LPCTSTR pszDomainName, DWORD cInfo, PVOID pDCInfo, HRESULT hr);
  enum BUFFER_ENTRY_TYPE GetEntryType();
  void ReSet();
};

class CDCBufferManager
{
private:
  LONG  m_cRef; // instance reference count
  HWND  m_hDlg; // the owner dialog which owns this instance 
  LONG  m_lContinue; // synchronization flag between owner dialog and all the related running threads
  CCriticalSection  m_CriticalSection; // synchronize access to the buffer
  CMapStringToPtr   m_map; // DomainName ==> PDCSITEINFO. The Buffer.

  void FreeBuffer();

  // constructor
  CDCBufferManager(HWND hDlg);
  // destructor
  ~CDCBufferManager();

public:
  static HRESULT CreateInstance(
    IN HWND hDlg, 
    OUT CDCBufferManager **ppDCBufferManager
  );

  LONG AddRef();
  LONG Release();
  void SignalExit();
  BOOL ShouldExit();

  HRESULT LoadInfo(
      IN PCTSTR pszDomainDnsName,
      OUT CDCSITEINFO **ppInfo
  );
  HRESULT AddInfo(
      IN PCTSTR   pszDomainDnsName, 
      IN DWORD    cInfo, 
      IN PVOID    pDCInfo,
      IN HRESULT  hr,
      OUT PVOID*  ppv
  );
  void ThreadReport(
      IN PVOID    ptr,
      IN HRESULT  hr
  );
  HRESULT StartThread(
      IN PCTSTR pszDomainDnsName
  );
};

#endif // __DCBUFMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dscache.cpp ===
// DSCache.cpp : implementation file
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSCache.cpp
//
//  Contents:  TBD
//
//  History:   31-jan-97 jimharr created
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"

#include "util.h"
#include "dsutil.h"

#include "dscache.h"
#include "dscookie.h"
#include "newobj.h"
#include "gencreat.h"
#include "querysup.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////
// helper functions

HRESULT HrVariantToStringList(const VARIANT& refvar, CStringList& refstringlist); // prototype

static CString g_szAllTypesArr[8];

void InitGroupTypeStringTable()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CString szSecTypeArr[2];
  szSecTypeArr[0].LoadString(IDS_GROUP_SECURITY);
  szSecTypeArr[1].LoadString(IDS_GROUP_DISTRIBUTION);

  CString szTypeArr[4];
  szTypeArr[0].LoadString(IDS_GROUP_GLOBAL);
  szTypeArr[1].LoadString(IDS_GROUP_DOMAIN_LOCAL);
  szTypeArr[2].LoadString(IDS_GROUP_UNIVERSAL);
  szTypeArr[3].LoadString(IDS_GROUP_BUILTIN_LOCAL);

  for (int iSec=0; iSec<2; iSec++)
  {
    for (int iType=0; iType<4; iType++)
    {
      int k = (iSec*4)+iType;
      g_szAllTypesArr[k] = szSecTypeArr[iSec];
      g_szAllTypesArr[k] += szTypeArr[iType];
    }
  }
}


LPCWSTR GetGroupTypeStringHelper(INT GroupType)
{
  // need to map the type into the array index

  // first part (2 types)
  int iSec = (GroupType & GROUP_TYPE_SECURITY_ENABLED) ? 0 : 1;

  //
  // second part (4 types)
  //
  // NOTE : can't use the following switch here because there may be some
  //        extra bits used in the group type. See bug #90507.
  //  switch (GroupType & ~GROUP_TYPE_SECURITY_ENABLED)
  //
  int iType = -1;
  if (GroupType & GROUP_TYPE_ACCOUNT_GROUP)
  {
    iType = 0;
  }
  else if (GroupType & GROUP_TYPE_RESOURCE_GROUP)
  {
    iType = 1;
  }
  else if (GroupType & GROUP_TYPE_UNIVERSAL_GROUP)
  {
    iType = 2;
  }
  else if (GroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP ||
           GroupType & GROUP_TYPE_RESOURCE_GROUP)
  {
    iType = 3;
  }
  else
  {
    ASSERT(FALSE); // this should never happen, invalid bit pattern
    return NULL;
  }

  int k = (iSec*4)+iType;
  ASSERT((k>=0) && (k<8));
  ASSERT(!g_szAllTypesArr[k].IsEmpty());
  return g_szAllTypesArr[k];
}








//////////////////////////////////////////////////////////////////////////
// CDSClassCacheItemBase

CDSClassCacheItemBase::~CDSClassCacheItemBase()
{
  if (m_pMandPropsList != NULL)
  {
    delete m_pMandPropsList;
  }

  if (m_pAdminContextMenu != NULL)
  {
    delete[] m_pAdminContextMenu;
  }
  if (m_pAdminPropertyPages != NULL)
  {
    delete[] m_pAdminPropertyPages ;
  }
  if (m_pAdminMultiSelectPropertyPages != NULL)
  {
    delete[] m_pAdminMultiSelectPropertyPages;
  }

}


HRESULT CDSClassCacheItemBase::CreateItem(LPCWSTR lpszClass, 
                            IADs* pDSObject, 
                            CDSComponentData* pCD,
                            CDSClassCacheItemBase** ppItem)
{
  ASSERT(ppItem != NULL);

  // determine which type of object we have
  if (wcscmp(lpszClass, L"user") == 0
#ifdef INETORGPERSON
      || _wcsicmp(lpszClass, L"inetOrgPerson") == 0
#endif
     )
  {
    *ppItem = new CDSClassCacheItemUser;
  }
  else if(wcscmp(lpszClass,L"group") == 0)
  {
    *ppItem = new CDSClassCacheItemGroup;
  }
  else
  {
    *ppItem = new CDSClassCacheItemGeneric;
  }

  if (*ppItem == NULL)
    return E_OUTOFMEMORY;

  HRESULT hr = (*ppItem)->Init(lpszClass, pDSObject, pCD);
  if (FAILED(hr))
  {
    delete *ppItem;
    *ppItem = NULL;
  }
  return hr;
}

HRESULT CDSClassCacheItemBase::Init(LPCWSTR lpszClass, IADs* pDSObject, CDSComponentData *pCD)
{
  HRESULT hr = S_OK;

  // init to default values
  m_bIsContainer = FALSE;
  m_GUID = GUID_NULL;
  m_szClass = lpszClass;
  m_szFriendlyClassName = lpszClass;
  m_szNamingAttribute = L"cn";

  ASSERT(!m_szClass.IsEmpty());

 
  // get schema path to bind to class object in the schema
  CComBSTR bstrSchema;
  if (pDSObject != NULL) 
  {
    // we have an ADSI pointer to use
    hr = pDSObject->get_Schema(&bstrSchema);
  } 
  else 
  {
    // no object yet (create new case)
    CString strSchema;
    pCD->GetBasePathsInfo()->GetAbstractSchemaPath(strSchema);
    strSchema += L"/";
    strSchema += lpszClass;
    bstrSchema = (LPCWSTR)strSchema;
  }
  
  // bind to the schema object
  CComPtr<IADsClass> spDsClass;
  hr = DSAdminOpenObject(bstrSchema,
                         IID_IADsClass, 
                         (LPVOID *)&spDsClass,
                         TRUE /*bServer*/);

  if (SUCCEEDED(hr)) 
  {
    // got class info from the schema
    // se the container flag
    if ((!wcscmp(lpszClass, L"computer")) || 
        (!wcscmp(lpszClass, L"user")) || 
#ifdef INETORGPERSON
        (!wcscmp(lpszClass, L"inetOrgPerson")) ||
#endif
        (!wcscmp(lpszClass,L"group"))) 
    {
      // special classes we know about
      m_bIsContainer = pCD->ExpandComputers();
    } 
    else 
    {
      // generic class, ask the schema
      VARIANT_BOOL bIsContainer;
      hr = spDsClass->get_Container(&bIsContainer);
      if (SUCCEEDED(hr)) 
      {
        if (bIsContainer)
        {
          m_bIsContainer = TRUE;
        }
      }
    }

    // get the class GUID
    CComVariant Var;
    hr = spDsClass->Get(L"schemaIDGUID", &Var);
    if (SUCCEEDED(hr)) 
    {
      GUID* pgtemp;
      pgtemp = (GUID*) (Var.parray->pvData);
      m_GUID = *pgtemp;
    } 

    // get the friendly class name
    WCHAR wszBuf[120];
    hr = pCD->GetBasePathsInfo()->GetFriendlyClassName(lpszClass, wszBuf, 120);
    if (SUCCEEDED(hr))
    {
      m_szFriendlyClassName = wszBuf;
    }

    // get the naming attribute
    Var.Clear();
    hr = spDsClass->get_NamingProperties(&Var);
    // fill out m_szNamingAttribute here.
    if (SUCCEEDED(hr)) 
    {
      m_szNamingAttribute = Var.bstrVal;
    } 
  } 
  else 
  {
    // we failed getting class info from the schema
    if (wcscmp(L"Unknown", lpszClass) == 0)
    {
      m_szFriendlyClassName.LoadString(IDS_DISPLAYTEXT_NONE);
    }
  }

  // locate the column set for this class
  m_pColumnSet = pCD->FindColumnSet(lpszClass);
  ASSERT(m_pColumnSet != NULL);

  // set the icon index(es)
  SetIconData(pCD);

  return S_OK;
}


CMandatoryADsAttributeList*
CDSClassCacheItemBase::GetMandatoryAttributeList(CDSComponentData* pCD)
{
  // got it already cached ?
  if (m_pMandPropsList != NULL) {
    return m_pMandPropsList;
  }

  // need to build the list  
  HRESULT hr = S_OK;
  CComBSTR bstrSchema;
  IADsClass * pDsClass = NULL;
  CMandatoryADsAttribute* pNamingAttribute = NULL;
  POSITION pos = NULL;

  CComVariant MandatoryList;
  CStringList Strings;
  CString csProp;

  LPTSTR pszSyntax;
  const LPTSTR pszNameSyntax = L"2.5.5.12";
  CDSSearch SchemaSrch(pCD->m_pClassCache, pCD);
  CString strPhysSchema;
  const int cCols = 2;
  LPTSTR pszAttributes[cCols] = {L"ADsPath",
                                 L"attributeSyntax" };
  ADS_SEARCH_COLUMN ColumnData;

  m_pMandPropsList = new CMandatoryADsAttributeList;

  // get the class object from the schema

  CString strSchema;
  pCD->GetBasePathsInfo()->GetAbstractSchemaPath(strSchema);
  strSchema += L"/";
  strSchema += GetClassName();
  bstrSchema = (LPCWSTR)strSchema;

  hr = DSAdminOpenObject(bstrSchema,
                         IID_IADsClass, 
                         (LPVOID *)&pDsClass,
                         TRUE /*bServer*/);
  if (FAILED(hr))
    goto CleanUp;

  pCD->GetBasePathsInfo()->GetSchemaPath(strPhysSchema);

  SchemaSrch.Init (strPhysSchema);
  SchemaSrch.SetSearchScope(ADS_SCOPE_ONELEVEL);
  hr = pDsClass->get_MandatoryProperties (&MandatoryList);
  if (FAILED(hr))
    goto CleanUp;

  hr = HrVariantToStringList (IN MandatoryList, OUT Strings);
  if (FAILED(hr))
    goto CleanUp;


  pos = Strings.GetHeadPosition();
  TRACE(_T("class: %s\n"), GetClassName());
  while (pos != NULL) {
    csProp = Strings.GetNext(INOUT pos);
    // skip WHAT????
    if (!wcscmp(csProp, gsz_objectClass) ||
        !wcscmp(csProp, gsz_nTSecurityDescriptor) ||
        !wcscmp(csProp, gsz_instanceType) ||
        !wcscmp(csProp, gsz_objectCategory) ||
        !wcscmp(csProp, gsz_objectSid)) {
      continue;
    }
    TRACE(_T("\tmandatory prop: %s.\n"), csProp);
    CString csFilter = CString(L"(&(objectClass=attributeSchema)(lDAPDisplayName=") +
      csProp + CString(L"))");
    SchemaSrch.SetFilterString((LPTSTR)(LPCTSTR)csFilter);
    SchemaSrch.SetAttributeList (pszAttributes, cCols);
    hr = SchemaSrch.DoQuery ();
    if (SUCCEEDED(hr)) {
      hr = SchemaSrch.GetNextRow();
      if (SUCCEEDED(hr)) {
        hr = SchemaSrch.GetColumn(pszAttributes[cCols - 1],
                                  &ColumnData);
        TRACE(_T("\t\tattributeSyntax: %s\n"), 
              ColumnData.pADsValues->CaseIgnoreString);
        pszSyntax = ColumnData.pADsValues->CaseIgnoreString;
        CMandatoryADsAttribute* pAttr = new CMandatoryADsAttribute((LPCTSTR)csProp,
                                                    NULL,
                                                    pszSyntax);
        if (wcscmp(csProp, GetNamingAttribute()) == 0)
          pNamingAttribute = pAttr;
        else
          m_pMandPropsList->AddTail(pAttr);
      } // if
        SchemaSrch.m_pObj->FreeColumn (&ColumnData);
    } // if
  } // while

  // make sure naming attribute is present
  if (pNamingAttribute == NULL)
  {
    pNamingAttribute = new CMandatoryADsAttribute(GetNamingAttribute(),
                                                          NULL,
                                                          pszNameSyntax);
  }
  // make sure the naming attribute is the first in the list
  m_pMandPropsList->AddHead(pNamingAttribute);


CleanUp:

  if (pDsClass) {
    pDsClass->Release();
  }
  return m_pMandPropsList;
}

CDSColumnSet* 
CDSClassCacheItemBase::GetColumnSet()
{
  return m_pColumnSet;
}

//
// Display Specifier cached accessors
//
GUID* CDSClassCacheItemBase::GetAdminPropertyPages(UINT* pnCount) 
{ 
  *pnCount = m_nAdminPPCount;
  return m_pAdminPropertyPages; 
}

void CDSClassCacheItemBase::SetAdminPropertyPages(UINT nCount, GUID* pGuids) 
{
  m_nAdminPPCount = nCount;
  if (m_pAdminPropertyPages != NULL)
  {
    delete[] m_pAdminPropertyPages;
  }
  m_pAdminPropertyPages = pGuids;
}

GUID* CDSClassCacheItemBase::GetAdminContextMenu(UINT* pnCount)
{
  *pnCount = m_nAdminCMCount;
  return m_pAdminContextMenu;
}

void CDSClassCacheItemBase::SetAdminContextMenu(UINT nCount, GUID* pGuids)
{
  m_nAdminCMCount = nCount;
  if (m_pAdminContextMenu != NULL)
  {
    delete[] m_pAdminContextMenu;
  }
  m_pAdminContextMenu = pGuids;
}

GUID* CDSClassCacheItemBase::GetAdminMultiSelectPropertyPages(UINT* pnCount)
{
  *pnCount = m_nAdminMSPPCount;
  return m_pAdminMultiSelectPropertyPages;
}

void CDSClassCacheItemBase::SetAdminMultiSelectPropertyPages(UINT nCount, GUID* pGuids)
{
  m_nAdminMSPPCount = nCount;
  if (m_pAdminMultiSelectPropertyPages != NULL)
  {
    delete[] m_pAdminMultiSelectPropertyPages;
  }
  m_pAdminMultiSelectPropertyPages = pGuids;
}


//////////////////////////////////////////////////////////////////////////
// CDSClassIconIndexes

void CDSClassIconIndexes::SetIconData(LPCWSTR lpszClass, BOOL bContainer, CDSComponentData *pCD, int)
{
  DWORD dwBaseFlags = DSGIF_GETDEFAULTICON;
  if (bContainer)
    dwBaseFlags |= DSGIF_DEFAULTISCONTAINER;

  int iIconIndex;
  // get the generic icon
  HRESULT hr = pCD->AddClassIcon(lpszClass, DSGIF_ISNORMAL | dwBaseFlags, &iIconIndex);
  m_iIconIndex = SUCCEEDED(hr) ? iIconIndex : -1;
  m_iIconIndexOpen = m_iIconIndexDisabled = m_iIconIndex;

  // get the open icon
  hr = pCD->AddClassIcon(lpszClass, DSGIF_ISOPEN | dwBaseFlags, &iIconIndex);
  if (SUCCEEDED(hr))
  {
    m_iIconIndexOpen = iIconIndex;
  }
  // get the disabled icon
  hr = pCD->AddClassIcon(lpszClass, DSGIF_ISDISABLED | dwBaseFlags, &iIconIndex);
  if (SUCCEEDED(hr))
  {
    m_iIconIndexDisabled = iIconIndex;
  }
  TRACE(_T("Added icon for class: %s\n"), lpszClass);
  TRACE(_T("Index:    %d\n"), m_iIconIndex);
  TRACE(_T("Open:     %d\n"), m_iIconIndexOpen);
  TRACE(_T("Disabled: %d\n"), m_iIconIndexDisabled);
}


//////////////////////////////////////////////////////////////////////////
// CDSClassCacheItemGeneric


inline int CDSClassCacheItemGeneric::GetIconIndex(CDSCookie* pCookie, BOOL bOpen)
{
  return m_iconIndexesStandard.GetIconIndex(pCookie->IsDisabled(), bOpen);
}

inline void CDSClassCacheItemGeneric::SetIconData(CDSComponentData *pCD)
{
  m_iconIndexesStandard.SetIconData(GetClassName(), IsContainer(), pCD,0);
}


//////////////////////////////////////////////////////////////////////////
// CDSClassCacheItemGroup

inline int CDSClassCacheItemGroup::GetIconIndex(CDSCookie* pCookie, BOOL bOpen)
{
  CDSClassIconIndexes* pIndexes = &m_iconIndexesStandard;
  CDSCookieInfoBase* pExtraInfo = pCookie->GetExtraInfo();
  if ( (pExtraInfo != NULL) && (pExtraInfo->GetClass() == CDSCookieInfoBase::group) )
  {
    if (((((CDSCookieInfoGroup*)pExtraInfo)->m_GroupType) & GROUP_TYPE_SECURITY_ENABLED) != 0)
      pIndexes = & m_iconIndexesAlternate;
  }
  return pIndexes->GetIconIndex(pCookie->IsDisabled(), bOpen);
}
  
inline void CDSClassCacheItemGroup::SetIconData(CDSComponentData *pCD)
{
  LPCWSTR lpszClass = GetClassName();
  m_iconIndexesStandard.SetIconData(lpszClass, IsContainer(), pCD,0);
  m_iconIndexesAlternate.SetIconData(lpszClass, IsContainer(), pCD,1);
/*
  // test just to get load some icons with a fake class and a fake "groupAlt-Display" object
  m_iconIndexesAlternate.SetIconData(L"groupAlt", m_bIsContainer, pCD, 1);
*/
}


//////////////////////////////////////////////////////////////////////////
// CDSCache


BOOL CDSCache::ToggleExpandSpecialClasses(BOOL bContainer)
{
  _Lock();
  BOOL bFound = FALSE;
  CDSClassCacheItemBase* pItem;

  if (Lookup(L"computer", pItem))
  {
    pItem->SetContainerFlag(bContainer);
    bFound = TRUE;
  }

  if (Lookup(L"user", pItem))
  {
    pItem->SetContainerFlag(bContainer);
    bFound = TRUE;
  }
#ifdef INETORGPERSON
  if (Lookup(L"inetOrgPerson", pItem))
  {
    pItem->SetContainerFlag(bContainer);
    bFound = TRUE;
  }
#endif

  if (Lookup(L"group", pItem))
  {
    pItem->SetContainerFlag(bContainer);
    bFound = TRUE;
  }

  _Unlock();

  return bFound;
}

CDSColumnSet* CDSCache::FindColumnSet(LPCWSTR lpszColumnID)
{ 
  _Lock();
  CDSColumnSet* pColumnSet = NULL;
  if (_wcsicmp(DEFAULT_COLUMN_SET, lpszColumnID) == 0)
  {
    //
    // return the default column set
    //
    pColumnSet = dynamic_cast<CDSColumnSet*>(m_ColumnList.GetDefaultColumnSet());
  }
  else
  {
    pColumnSet = dynamic_cast<CDSColumnSet*>(m_ColumnList.FindColumnSet(lpszColumnID));
  }
  _Unlock();
  return  pColumnSet;
}



CDSClassCacheItemBase* CDSCache::FindClassCacheItem(CDSComponentData* pCD,
                                                    LPCWSTR lpszObjectClass,
                                                    LPCWSTR lpszObjectLdapPath
                                                    )
{
  _Lock();
  CDSClassCacheItemBase* pDsCacheItem = NULL;
  BOOL bFound = m_Map.Lookup(lpszObjectClass, pDsCacheItem);
  if (!bFound)
  {
    // Item not found in cache, create, insert in the cache and return it
    TRACE(_T("did not find class <%s> for this item in the Cache.\n"), (LPCWSTR)lpszObjectClass);

    // Check to see if the object is a container
    CComPtr<IADs> spADsObject = NULL;

    if (lpszObjectLdapPath != NULL)
    {
      DSAdminOpenObject(lpszObjectLdapPath,
                        IID_IADs,
                        (LPVOID*)&spADsObject,
                        TRUE /*bServer*/);

      // NOTICE: we might fail to bind here if we do not have read rights
      // this will give a NULL spADsObject, that will work just fine on the CreateItem() call below
    }

    // create object
    HRESULT hrCreate = CDSClassCacheItemBase::CreateItem(lpszObjectClass, spADsObject, pCD, &pDsCacheItem);
    ASSERT(pDsCacheItem != NULL);
    ASSERT(SUCCEEDED(hrCreate));

    // set in the cache
    m_Map.SetAt(lpszObjectClass, pDsCacheItem);
  }
  _Unlock();
  return pDsCacheItem;
}

#define DS_CACHE_STREAM_VERSION ((DWORD)0x0)

HRESULT CDSCache::Save(IStream* pStm)
{
  // save cache version number 
  HRESULT hr = SaveDWordHelper(pStm, DS_CACHE_STREAM_VERSION);
  if (FAILED(hr))
    return hr;

  // save column list
  return m_ColumnList.Save(pStm);
}

HRESULT CDSCache::Load(IStream* pStm)
{
  // load cache version number 
  DWORD dwVersion;
  HRESULT hr = LoadDWordHelper(pStm, &dwVersion);
  if ( FAILED(hr) ||(dwVersion != DS_CACHE_STREAM_VERSION) )
    return E_FAIL;


  // load column list
  return m_ColumnList.Load(pStm);
}


HRESULT CDSCache::TabCollect_AddMultiSelectPropertyPages(LPPROPERTYSHEETCALLBACK pCall,
                                                         LONG_PTR,
                                                         LPDATAOBJECT pDataObject, 
                                                         MyBasePathsInfo* pBasePathsInfo)
{
  HRESULT hr = S_OK;
  CString szClassName;
  CString szDisplayProperty = L"AdminMultiSelectPropertyPages";

  GUID* pGuids = NULL;
  UINT nCount = 0;
  if (IsHomogenousDSSelection(pDataObject, szClassName))
  {
    //
    // Get the guid for the multiselect proppages of the homogenous class selection
    //

    //
    // Check the cache first
    //
    BOOL bFoundGuids = FALSE;
    CDSClassCacheItemBase* pItem = NULL;
    BOOL bFoundItem = Lookup(szClassName, pItem);
    if (bFoundItem)
    {
      if (pItem == NULL)
      {
        ASSERT(FALSE);
        bFoundItem = FALSE;
      }
      else
      {
        //
        // Retrieve guids from cache
        //
        pGuids = pItem->GetAdminMultiSelectPropertyPages(&nCount);
        if (nCount > 0 && pGuids != NULL)
        {
          bFoundGuids = TRUE;
        }
      }
    }

    if (!bFoundGuids)
    {
      //
      // Class cache item did not contain GUID
      //
      hr = TabCollect_GetDisplayGUIDs(szClassName, 
                                      szDisplayProperty, 
                                      pBasePathsInfo, 
                                      &nCount, 
                                      &pGuids);
      if (FAILED(hr))
      {
        //
        // Try the default-Display object then
        //
        hr = TabCollect_GetDisplayGUIDs(L"default",
                                        szDisplayProperty,
                                        pBasePathsInfo,
                                        &nCount,
                                        &pGuids);
        if (FAILED(hr))
        {
          return hr;
        }
      }

      if (bFoundItem)
      {
        //
        // Cache the new guids
        //
        pItem->SetAdminMultiSelectPropertyPages(nCount, pGuids);
      }
    }
  }
  else
  {
    //
    // Get the default multi-select proppages
    //
    hr = TabCollect_GetDisplayGUIDs(L"default", szDisplayProperty, pBasePathsInfo, &nCount, &pGuids);

    //
    // Right now there is no default item in the cache so we have to get it each time from
    // the DS
    //
  }

  if (SUCCEEDED(hr))
  {
    if (nCount > 0 && pGuids != NULL)
    {
      //
      // Create all the pages, initialize, and then add them
      //
      for (UINT nIndex = 0; nIndex < nCount; nIndex++)
      {
        //
        // Create
        //
        CComPtr<IShellExtInit> spShellInit;
        hr = ::CoCreateInstance((pGuids[nIndex]), 
                                NULL, 
                                CLSCTX_INPROC_SERVER, 
                                IID_IShellExtInit,
                                (PVOID*)&spShellInit);
        if (FAILED(hr))
        {
          continue;
        }

        //
        // Initialize
        //
        hr = spShellInit->Initialize(NULL, pDataObject, 0);
        if (FAILED(hr))
        {
          continue;
        }

        //
        // Add
        //
        CComPtr<IShellPropSheetExt> spPropSheetExt;
        hr = spShellInit->QueryInterface(IID_IShellPropSheetExt, (PVOID*)&spPropSheetExt);
        if (FAILED(hr))
        {
          continue;
        }

        hr = spPropSheetExt->AddPages(AddPageProc, (LPARAM)pCall);
        if (FAILED(hr))
        {
          TRACE(TEXT("spPropSheetExt->AddPages failed, hr: 0x%x\n"), hr);
          continue;
        }
      }
    }
  }

  return hr;
}

void CDSCache::_CollectDisplaySettings(MyBasePathsInfo* pBasePathsInfo)
{
  static LPCWSTR lpszSettingsObjectClass = L"dsUISettings";
  static LPCWSTR lpszSettingsObject = L"cn=DS-UI-Default-Settings";
  static LPCWSTR lpszSecurityGroupProperty = L"msDS-Security-Group-Extra-Classes";
  static LPCWSTR lpszNonSecurityGroupProperty = L"msDS-Non-Security-Group-Extra-Classes";
  static LPCWSTR lpszFilterContainers = L"ms-DS-Filter-Containers";

  if (pBasePathsInfo == NULL)
  {
    return;
  }

  //
  // get the display specifiers locale container (e.g. 409)
  //
  CComPtr<IADsContainer> spLocaleContainer;
  HRESULT hr = pBasePathsInfo->GetDisplaySpecifier(NULL, IID_IADsContainer, (void**)&spLocaleContainer);
  if (FAILED(hr))
  {
    return;
  }

  //
  // bind to the settings object
  //
  CComPtr<IDispatch> spIDispatchObject;
  hr = spLocaleContainer->GetObject((LPWSTR)lpszSettingsObjectClass, 
                                    (LPWSTR)lpszSettingsObject, 
                                    &spIDispatchObject);
  if (FAILED(hr))
  {
    return;
  }

  CComPtr<IADs> spSettingsObject;
  hr = spIDispatchObject->QueryInterface(IID_IADs, (void**)&spSettingsObject);
  if (FAILED(hr))
  {
    return;
  }

  //
  // get the security group extra classes as a CStringList
  //
  CComVariant var;
  hr = spSettingsObject->Get((LPWSTR)lpszSecurityGroupProperty, &var);
  if (SUCCEEDED(hr))
  {
    hr = HrVariantToStringList(var, m_szSecurityGroupExtraClasses);
  }

  //
  // get the non-security group extra classes as a CStringList
  //
  var.Clear();
  hr = spSettingsObject->Get((LPWSTR)lpszNonSecurityGroupProperty, &var);
  if (SUCCEEDED(hr))
  {
    hr = HrVariantToStringList(var, m_szNonSecurityGroupExtraClasses);
  }

  //
  // get the additional filter containers as a CStringList
  //
  var.Clear();
  hr = spSettingsObject->Get((LPWSTR)lpszFilterContainers, &var);
  if (SUCCEEDED(hr))
  {
    CStringList szContainers;
    hr = HrVariantToStringList(var, szContainers);
    if (SUCCEEDED(hr))
    {
      //
      // Allocate the filter struct element
      //
      m_pfilterelementDsAdminDrillDown = new FilterElementStruct;
      if (m_pfilterelementDsAdminDrillDown != NULL)
      {
        //
        // Allocate the tokens
        //
        m_pfilterelementDsAdminDrillDown->ppTokens = new FilterTokenStruct*[szContainers.GetCount()];
        if (m_pfilterelementDsAdminDrillDown->ppTokens != NULL)
        {
          //
          // Allocate and fill in each token
          //
          int idx = 0;
          POSITION pos = szContainers.GetHeadPosition();
          while (pos != NULL)
          {
            CString szContainerCategory = szContainers.GetNext(pos);
            ASSERT(!szContainerCategory.IsEmpty());

            m_pfilterelementDsAdminDrillDown->ppTokens[idx] = new FilterTokenStruct;
            if (m_pfilterelementDsAdminDrillDown->ppTokens[idx] != NULL)
            {
              m_pfilterelementDsAdminDrillDown->ppTokens[idx]->nType = TOKEN_TYPE_CATEGORY;
              m_pfilterelementDsAdminDrillDown->ppTokens[idx]->lpszString = new WCHAR[szContainerCategory.GetLength() + 1];
              if (m_pfilterelementDsAdminDrillDown->ppTokens[idx]->lpszString != NULL)
              {
                wcscpy(m_pfilterelementDsAdminDrillDown->ppTokens[idx]->lpszString, (LPCWSTR)szContainerCategory);
                idx++;
              }
            }
          }
          //
          // Count only the ones that were added successfully
          //
          m_pfilterelementDsAdminDrillDown->cNumTokens = idx;

          //
          // But they all should have been added successfully so assert that
          //
          ASSERT(idx == szContainers.GetCount());
        }
        else
        {
          //
          // failed to allocate space for the tokens,
          // delete all the other allocated and set the
          // global to NULL
          //
          delete m_pfilterelementDsAdminDrillDown;
          m_pfilterelementDsAdminDrillDown = NULL;
        }
      }
    }
  }

  m_bDisplaySettingsCollected = TRUE;
}

BOOL CDSCache::CanAddToGroup(MyBasePathsInfo* pBasePathsInfo, PCWSTR pszClass, BOOL bSecurity)
{
  _Lock();

  if (!m_bDisplaySettingsCollected)
  {
    _CollectDisplaySettings(pBasePathsInfo);
  }

  BOOL bResult = FALSE;
  if (bSecurity)
  {
    POSITION pos = m_szSecurityGroupExtraClasses.GetHeadPosition();
    while (pos != NULL)
    {
      CString szClass = m_szSecurityGroupExtraClasses.GetNext(pos);
      ASSERT(!szClass.IsEmpty());

      if (_wcsicmp(szClass, pszClass) == 0)
      {
        bResult = TRUE;
        break;
      }
    }
  }
  else
  {
    POSITION pos = m_szNonSecurityGroupExtraClasses.GetHeadPosition();
    while (pos != NULL)
    {
      CString szClass = m_szNonSecurityGroupExtraClasses.GetNext(pos);
      ASSERT(!szClass.IsEmpty());

      if (_wcsicmp(szClass, pszClass) == 0)
      {
        bResult = TRUE;
        break;
      }
    }
  }
  _Unlock();
  return bResult;
}

FilterElementStruct* CDSCache::GetFilterElementStruct(CDSComponentData* pDSComponentData)
{
  _Lock();

  if (!m_bDisplaySettingsCollected)
  {
    _CollectDisplaySettings(pDSComponentData->GetBasePathsInfo());
  }

  _Unlock();
  return (SNAPINTYPE_SITE == pDSComponentData->QuerySnapinType()) ?
                &g_filterelementSiteReplDrillDown : m_pfilterelementDsAdminDrillDown;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dcbufmgr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       dcbufmgr.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "dscmn.h"  // Smart_DsHandle
#include "dcbufmgr.h"
#include "process.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DSGETDCINFO_LEVEL_1     1

unsigned __stdcall GetDCThreadFunc( void* lParam );

//+---------------------------------------------------------------------------
//
//  Function:   CDCBufferManager::CDCBufferManager
//
//  Synopsis:   constructor
//
//----------------------------------------------------------------------------
CDCBufferManager::CDCBufferManager(HWND hDlg) : 
  m_cRef(0), m_hDlg(hDlg)
{
  TRACE(_T("CDCBufferManager::CDCBufferManager, this=%x\n"), this);

  m_lContinue = 1;        
}

//+---------------------------------------------------------------------------
//
//  Function:   CDCBufferManager::~CDCBufferManager
//
//  Synopsis:   destructor
//
//----------------------------------------------------------------------------
CDCBufferManager::~CDCBufferManager()
{
  TRACE(_T("CDCBufferManager::~CDCBufferManager, this=%x\n"), this);

  ASSERT(0 >= m_cRef);
  FreeBuffer();
}

//+---------------------------------------------------------------------------
//
//  Function:   CDCBufferManager::CreateInstance
//
//  Synopsis:   Create an instance of CDCBufferManager.
//
//----------------------------------------------------------------------------
HRESULT
CDCBufferManager::CreateInstance(
    IN HWND               hDlg, 
    OUT CDCBufferManager **ppDCBufferManager
)
{
  TRACE(_T("CDCBufferManager::CreateInstance, hDlg=%x\n"), hDlg);

  ASSERT(ppDCBufferManager);

  *ppDCBufferManager = new CDCBufferManager(hDlg);
  if ( !(*ppDCBufferManager) )
    return E_OUTOFMEMORY;

  (*ppDCBufferManager)->AddRef();

  return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDCBufferManager::AddRef
//
//  Synopsis:   Increment reference count of this instance
//
//----------------------------------------------------------------------------
LONG
CDCBufferManager::AddRef()
{
  TRACE(_T("CDCBufferManager::AddRef, this=%x, preValue=%d\n"), this, m_cRef);

  return InterlockedIncrement(&m_cRef);
}

//+---------------------------------------------------------------------------
//
//  Function:   CDCBufferManager::Release
//
//  Synopsis:   Decrement reference count of this instance.
//              When the reference count reaches 0, delete this instance.
//
//----------------------------------------------------------------------------
LONG
CDCBufferManager::Release()
{
  TRACE(_T("CDCBufferManager::Release, this=%x, preValue=%d\n"), this, m_cRef);

  if (InterlockedDecrement(&m_cRef) <= 0)
  {
    delete this;
    return 0;
  }

  return m_cRef;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDCBufferManager::SignalExit
//
//  Synopsis:   Called by the owner dialog to signal the related threads to exit.
//
//----------------------------------------------------------------------------
void
CDCBufferManager::SignalExit()
{ 
  TRACE(_T("CDCBufferManager::SignalExit\n"));

  InterlockedExchange(&m_lContinue, FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   CDCBufferManager::ShouldExit
//
//  Synopsis:   Threads are calling this function periodically to see
//              if the owner dialog signals them to exit.
//
//----------------------------------------------------------------------------
BOOL
CDCBufferManager::ShouldExit()
{
  TRACE(_T("CDCBufferManager::ShouldExit %d\n"), !m_lContinue);

  return (!m_lContinue);
}

//+---------------------------------------------------------------------------
//
//  Function:   CDCBufferManager::LoadInfo
//
//  Synopsis:   The Owner dialog call it to get a pointer to the info of the specified domain.
//      The buffer consists of entries. 
//      Each entry is in the form of (LPTSTR szDomainName, CDCSITEINFO* pEntry).
//
//      LoadInfo() will first look up in the buffer.
//      If a valid entry is found, pass back pEntry to caller.
//      If an error entry is found, reset it (clear the error) and retry.
//      If an inprogress entry is found, do nothing. The caller will handle a THREAD_DONE later.
//      If no entry in the buffer, create a new entry, kick off a thread.
//
//      When the owner dialog get THREAD_DONE message, the related entry
//      in the buffer should either be a valid entry or an error entry.
//
//----------------------------------------------------------------------------
HRESULT
CDCBufferManager::LoadInfo(
    IN PCTSTR       pszDomainDnsName,
    OUT CDCSITEINFO **ppInfo
)
{
  ASSERT(pszDomainDnsName);
  ASSERT(*pszDomainDnsName);
  ASSERT(ppInfo);
  ASSERT(*ppInfo == NULL);  // prevent memory leak

  TRACE(_T("CDCBufferManager::LoadInfo for %s\n"), pszDomainDnsName);

  BOOL          bStartNewThread = FALSE;
  HRESULT       hr = S_OK;
  PVOID         ptr = NULL;
  CDCSITEINFO*  pEntry = NULL;

  m_CriticalSection.Lock();     // Lock buffer

  if (m_map.Lookup(pszDomainDnsName, ptr))
  {
    //
    // Found an entry in the buffer.
    //
    if (ptr)
    {
      pEntry = (CDCSITEINFO*)ptr;
      switch (pEntry->GetEntryType())
      {
      case BUFFER_ENTRY_TYPE_VALID:
        // return the valid entry pointer
        *ppInfo = pEntry;
        break;
      case BUFFER_ENTRY_TYPE_ERROR:
        // kick off a thread to retry
        pEntry->ReSet();
        bStartNewThread = TRUE;
        break;
      case BUFFER_ENTRY_TYPE_INPROGRESS:
        // do nothing
        break;
      }
    }

  } else
  {
    //
    // not found in the buffer, need to start a new thread
    //
    bStartNewThread = TRUE;
    pEntry = new CDCSITEINFO();
    if (pEntry)
      m_map.SetAt(pszDomainDnsName, pEntry);
    else
      hr = E_OUTOFMEMORY;
  }

  if (SUCCEEDED(hr) && bStartNewThread)
  {
    hr = StartThread(pszDomainDnsName);
    if (FAILED(hr))
    {
      delete pEntry;
      m_map.RemoveKey(pszDomainDnsName);
    }
  }

  m_CriticalSection.Unlock();   // Unlock buffer

  return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDCBufferManager::AddInfo
//
//  Synopsis:   Called by the thread function to add one result to the buffer.
//              It will pass back the pointer to the entry in the 5th parameters.
//
//----------------------------------------------------------------------------
HRESULT
CDCBufferManager::AddInfo(
    IN PCTSTR   pszDomainDnsName, 
    IN DWORD    cInfo, 
    IN PVOID    pDCInfo,
    IN HRESULT  hr,
    OUT PVOID*  ppv
)
{
  ASSERT(pszDomainDnsName);
  ASSERT(*pszDomainDnsName);
  ASSERT(ppv);
  ASSERT(*ppv == NULL); // prevent memory leak

  TRACE(_T("CDCBufferManager::AddInfo for %s, cInfo=%d, hr=%x\n"), 
    pszDomainDnsName, cInfo, hr);

  PVOID   p = NULL;

  m_CriticalSection.Lock();     // Lock buffer

  //
  // the entry must have been existed with a non-NULL pointer
  //
  m_map.Lookup(pszDomainDnsName, p);
  ASSERT(p);

  ((CDCSITEINFO*)p)->SetEntry(pszDomainDnsName, cInfo, pDCInfo, hr);

  m_CriticalSection.Unlock();   // Unlock buffer

  *ppv = p;

  return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CDCBufferManager::FreeBuffer
//
//  Synopsis:   Clear m_map. 
//              This member holds all the results returned by various threads 
//              since the initialization of the owner dialog. Each one is 
//              in the form of (DomainName ==> CDCSITEINFO*)
//
//----------------------------------------------------------------------------
void
CDCBufferManager::FreeBuffer()
{
  CString csDomainDnsName;
  PVOID   ptr = NULL;

  m_CriticalSection.Lock();     // Lock buffer

  for (POSITION pos = m_map.GetStartPosition(); pos; )
  {
    m_map.GetNextAssoc(pos, csDomainDnsName, ptr);
    
    if (ptr)
      delete ((CDCSITEINFO*)ptr);
  }

  m_map.RemoveAll();

  m_CriticalSection.Unlock();   // Unlock buffer
}

//+---------------------------------------------------------------------------
//
//  Function:   CDCBufferManager::ThreadReport
//
//  Synopsis:   Report THREAD_DONE to the owner dialog. 
//
//----------------------------------------------------------------------------
void
CDCBufferManager::ThreadReport(
    IN PVOID    ptr,
    IN HRESULT  hr
)
{
  ASSERT(ptr);

  TRACE(_T("CDCBufferManager::ThreadReport ptr=%x, hr=%x\n"), ptr, hr);

  PostMessage(m_hDlg, WM_USER_GETDC_THREAD_DONE,
    reinterpret_cast<WPARAM>(ptr), hr);
}

/////////////////////////////////////////////////////////
// 
// thread info structure
typedef struct _GetDCThreadInfo
{
  PTSTR                  pszDomainDnsName;
  CDCBufferManager      *pDCBufferManager;
} GETDCTHREADINFO;

//+---------------------------------------------------------------------------
//
//  Function:   CDCBufferManager::StartThread
//
//  Synopsis:   Start a thread. 
//
//     Pass the following info to the thread function:
//
//     pszDomainDnsName: 
//          domain we need to get a list of DCs for.
//     pDCBufferManager:
//          the CDCBufferManager instance for the ThreadFunc to 
//          add result to the buffer
//
//----------------------------------------------------------------------------
HRESULT
CDCBufferManager::StartThread(
    IN PCTSTR pszDomainDnsName
) 
{
  ASSERT(pszDomainDnsName);
  ASSERT(*pszDomainDnsName);

  TRACE(_T("CDCBufferManager::StartThread for %s\n"), pszDomainDnsName);

  GETDCTHREADINFO *pThreadInfo = new GETDCTHREADINFO;
  if (!pThreadInfo)
    return E_OUTOFMEMORY;

  pThreadInfo->pszDomainDnsName = _tcsdup(pszDomainDnsName);
  if ( !(pThreadInfo->pszDomainDnsName) )
  {
    delete pThreadInfo;
    return E_OUTOFMEMORY;
  }

  pThreadInfo->pDCBufferManager = this;

  AddRef();

  unsigned threadID;
  HANDLE pThread = (HANDLE)_beginthreadex( 
                      NULL,               //void *security, 
                      0,                  //unsigned stack_size, 
                      &GetDCThreadFunc,   //unsigned ( __stdcall *start_address )( void * ), 
                      (void *)pThreadInfo, //void *arglist, 
                      0,                  //unsigned initflag, 
                      &threadID           //unsigned *thrdaddr
                      );


  if (!pThread)
  {
    free(pThreadInfo->pszDomainDnsName);
    delete pThreadInfo;

    Release();

    return E_FAIL;
  }

  return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDCThreadFunc
//
//  Synopsis:   The GetDC Thread Function. 
//              This function invokes DsGetDomainControllerInfo() to get a list
//              of DCs in the specified domain, and add them to the buffer of 
//              CDCBufferManager instance.
//              This function regularly checks to see if the owner dialog signals
//              it to exit, if not, it will finish its normal operation and
//              post a THREAD_DONE message to the owner dialog.
//
//----------------------------------------------------------------------------
unsigned __stdcall GetDCThreadFunc( void* lParam )
{
  GETDCTHREADINFO *pThreadInfo = reinterpret_cast<GETDCTHREADINFO *>(lParam);
  ASSERT(pThreadInfo);
  ASSERT(pThreadInfo->pszDomainDnsName);
  ASSERT(*(pThreadInfo->pszDomainDnsName));
  ASSERT(pThreadInfo->pDCBufferManager);

  TRACE(_T("GetDCThreadFunc pszDomainDnsName=%s, pDCBufferManager=%x\n"),
    pThreadInfo->pszDomainDnsName, pThreadInfo->pDCBufferManager);

  //
  // retrieve information passed into this function
  //
  CString             csDomain = pThreadInfo->pszDomainDnsName;
  CDCBufferManager    *pDCBufferManager = pThreadInfo->pDCBufferManager;
  free(pThreadInfo->pszDomainDnsName);
  delete pThreadInfo;

  PVOID                         pEntry = NULL;
  DWORD                         cInfo = 0;
  PDS_DOMAIN_CONTROLLER_INFO_1  pInfo = NULL;
  DWORD                         dwErr = 0;
  HRESULT                       hr = S_OK;
  Smart_DsHandle                shDs;  // smart pointer, will Unbind automatically

  if (pDCBufferManager->ShouldExit())
    goto Thread_Exit;

  dwErr = DsBind(NULL, const_cast<LPTSTR>(static_cast<LPCTSTR>(csDomain)), &shDs);
  
  if (pDCBufferManager->ShouldExit())
    goto Thread_Exit;

  if (ERROR_SUCCESS != dwErr) {
    // DsBind() failed. 
    // Add an error entry in the buffer.
    hr = HRESULT_FROM_WIN32(dwErr);
    pDCBufferManager->AddInfo(csDomain, 0, NULL, hr, &pEntry);
    goto Thread_Exit;
  }

  dwErr = DsGetDomainControllerInfo(
              shDs,                                               // HANDLE   hDs
              const_cast<LPTSTR>(static_cast<LPCTSTR>(csDomain)), // LPTSTR   DomainName
              DSGETDCINFO_LEVEL_1,                                // DWORD    InfoLevel
              &cInfo,                                             // DWORD    *pcOut
              reinterpret_cast<VOID **>(&pInfo)                   // VOID     **ppInfo
              );
  
  if (pDCBufferManager->ShouldExit())
  {
    if ((ERROR_SUCCESS == dwErr) && pInfo)
      DsFreeDomainControllerInfo(DSGETDCINFO_LEVEL_1, cInfo, pInfo);
    goto Thread_Exit;
  }
  
  if (ERROR_SUCCESS != dwErr) {
    // DsGetDomainControllerInfo() failed. 
    // Add an error entry in the buffer
    hr = HRESULT_FROM_WIN32(dwErr);
    pDCBufferManager->AddInfo(csDomain, 0, NULL, hr, &pEntry);
    goto Thread_Exit;
  }

  //
  // Add result to the buffer in CDCBufferManager
  //
  hr = pDCBufferManager->AddInfo(csDomain, cInfo, pInfo, S_OK, &pEntry);

  if (FAILED(hr))
    DsFreeDomainControllerInfo(DSGETDCINFO_LEVEL_1, cInfo, pInfo);

Thread_Exit:

  if (FALSE == pDCBufferManager->ShouldExit())
  {
    //
    // report THREAD_DONE with the pointer to the entry
    //
    if (pEntry)
      pDCBufferManager->ThreadReport(pEntry, hr);
  }

  //
  // Decrement the reference count on the CDCBufferManager instance
  //
  pDCBufferManager->Release();

  return 0;
}

///////////////////////////////////////////////
// class CDCSITEINFO

CDCSITEINFO::CDCSITEINFO()
{
  m_csDomainName.Empty();
  m_cInfo = 0;
  m_pDCInfo = NULL;
  m_hr = S_OK;
}

CDCSITEINFO::~CDCSITEINFO()
{
  if (m_pDCInfo)
    DsFreeDomainControllerInfo(DSGETDCINFO_LEVEL_1, m_cInfo, m_pDCInfo);
}

void
CDCSITEINFO::SetEntry(LPCTSTR pszDomainName, DWORD cInfo, PVOID pDCInfo, HRESULT hr)
{
  m_csDomainName = pszDomainName;
  m_cInfo = cInfo;
  m_pDCInfo = (PDS_DOMAIN_CONTROLLER_INFO_1)pDCInfo;
  m_hr = hr;
}

enum BUFFER_ENTRY_TYPE
CDCSITEINFO::GetEntryType()
{
  if (FAILED(m_hr))
    return BUFFER_ENTRY_TYPE_ERROR;
  if (m_cInfo == 0 || m_pDCInfo == NULL)
    return BUFFER_ENTRY_TYPE_INPROGRESS;
  return BUFFER_ENTRY_TYPE_VALID;
}

void
CDCSITEINFO::ReSet()
{
  ASSERT(GetEntryType() == BUFFER_ENTRY_TYPE_ERROR);
  m_hr = S_OK;
  ASSERT(GetEntryType() == BUFFER_ENTRY_TYPE_INPROGRESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dlgcreat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dlgcreat.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	dlgcreat.h
//
//	Class definition for dialogs that create new ADs objects.
//
//	HISTORY
//	24-Aug-97	Dan Morin	Creation.
//
/////////////////////////////////////////////////////////////////////

#ifndef _DLGCREAT_H
#define _DLGCREAT_H


#include <objsel.h> // object picker
#include "util.h"
#include "uiutil.h"

// FORWARD DECLARATIONS
class CNewADsObjectCreateInfo;	// Defined in newobj.h

class CWizExtensionSite;
class CWizExtensionSiteManager;

class CCreateNewObjectWizardBase;


class CCreateNewObjectPageBase;
class CCreateNewObjectDataPage;
class CCreateNewObjectFinishPage; 



///////////////////////////////////////////////////////////////////////////
// CHPropSheetPageArr

class CHPropSheetPageArr
{
public:
  CHPropSheetPageArr();
  ~CHPropSheetPageArr()
  {
    free(m_pArr);
  }
  void AddHPage(HPROPSHEETPAGE hPage);
  HPROPSHEETPAGE* GetArr(){ return m_pArr;}
  ULONG GetCount() {return m_nCount;}
private:
  HPROPSHEETPAGE* m_pArr;
  ULONG m_nSize;
  ULONG m_nCount;
};



///////////////////////////////////////////////////////////////////////////
// CDsAdminNewObjSiteImpl

class CDsAdminNewObjSiteImpl : public IDsAdminNewObj, 
                               public IDsAdminNewObjPrimarySite, 
                               public CComObjectRoot
{
  DECLARE_NOT_AGGREGATABLE(CDsAdminNewObjSiteImpl)
  
BEGIN_COM_MAP(CDsAdminNewObjSiteImpl)
  COM_INTERFACE_ENTRY(IDsAdminNewObj)
  COM_INTERFACE_ENTRY(IDsAdminNewObjPrimarySite)
END_COM_MAP()

public:
  CDsAdminNewObjSiteImpl() 
  {
    m_pSite = NULL;
  }
  ~CDsAdminNewObjSiteImpl() {}

  // IDsAdminNewObj methods
  STDMETHOD(SetButtons)(THIS_ /*IN*/ ULONG nCurrIndex, /*IN*/ BOOL bValid); 
  STDMETHOD(GetPageCounts)(THIS_ /*OUT*/ LONG* pnTotal,
                               /*OUT*/ LONG* pnStartIndex); 

  // IDsAdminNewObjPrimarySite methods
  STDMETHOD(CreateNew)(THIS_ /*IN*/ LPCWSTR pszName);
  STDMETHOD(Commit)(THIS_ );

// Implementation
public:
  void Init(CWizExtensionSite* pSite)
  { 
    m_pSite = pSite;
  }

private:

  BOOL _IsPrimarySite();
  CWizExtensionSite* m_pSite; // back pointer

};



///////////////////////////////////////////////////////////////////////////
// CWizExtensionSite

class CWizExtensionSite
{
public:

  CWizExtensionSite(CWizExtensionSiteManager* pSiteManager)
  {
    ASSERT(pSiteManager != NULL);
    m_pSiteManager = pSiteManager;
    m_pSiteImplComObject = NULL;
  }
  ~CWizExtensionSite()
  {
    // if created during InitializeExtension(), it has
    // a ref count of 1, so need to release once to 
    // destroy
    if (m_pSiteImplComObject != NULL)
    {
      m_pSiteImplComObject->Release();
    }
  }

  HRESULT InitializeExtension(GUID* pGuid);
  BOOL GetSummaryInfo(CString& s);

  IDsAdminNewObjExt* GetNewObjExt() 
  { 
    ASSERT(m_spIDsAdminNewObjExt != NULL);
    return m_spIDsAdminNewObjExt;
  }

  CWizExtensionSiteManager* GetSiteManager() { return m_pSiteManager;}
  CHPropSheetPageArr* GetHPageArr() { return &m_pageArray;}

private:
  static BOOL CALLBACK FAR _OnAddPage(HPROPSHEETPAGE hsheetpage, LPARAM lParam);

  CWizExtensionSiteManager* m_pSiteManager; // back pointer

  CComPtr<IDsAdminNewObjExt> m_spIDsAdminNewObjExt; // extension interface pointer
  CHPropSheetPageArr m_pageArray;    // array of property page handles

  CComObject<CDsAdminNewObjSiteImpl>* m_pSiteImplComObject; // fully formed COM object
};


///////////////////////////////////////////////////////////////////////////
// CWizExtensionSiteManager

class  CWizExtensionSiteList : public CList<CWizExtensionSite*, CWizExtensionSite*>
{
public:
  ~CWizExtensionSiteList()
  {
    while (!IsEmpty())
      delete RemoveTail();
  }
};



class CWizExtensionSiteManager
{
public:
  CWizExtensionSiteManager(CCreateNewObjectWizardBase* pWiz)
  {
    ASSERT(pWiz != NULL);
    m_pWiz = pWiz;
    m_pPrimaryExtensionSite = NULL;
  }

  ~CWizExtensionSiteManager()
  {
    if (m_pPrimaryExtensionSite != NULL)
      delete m_pPrimaryExtensionSite;
  }

  CCreateNewObjectWizardBase* GetWiz() { return m_pWiz;}
  CWizExtensionSite* GetPrimaryExtensionSite() { return m_pPrimaryExtensionSite;}
  CWizExtensionSiteList* GetExtensionSiteList() { return &m_extensionSiteList;}

  HRESULT CreatePrimaryExtension(GUID* pGuid, 
                                  IADsContainer* pADsContainerObj,
                                  LPCWSTR lpszClassName);

  HRESULT CreateExtensions(GUID* aCreateWizExtGUIDArr, ULONG nCount,
                           IADsContainer* pADsContainerObj,
                           LPCWSTR lpszClassName);

  UINT GetTotalHPageCount();

  void SetObject(IADs* pADsObj);
  HRESULT WriteExtensionData(HWND hWnd, ULONG uContext);
  HRESULT NotifyExtensionsOnError(HWND hWnd, HRESULT hr, ULONG uContext);
  void GetExtensionsSummaryInfo(CString& s);

private:
  CCreateNewObjectWizardBase* m_pWiz; // back pointer to wizard

  CWizExtensionSite* m_pPrimaryExtensionSite;
  CWizExtensionSiteList m_extensionSiteList;
};


/////////////////////////////////////////////////////////////////////
// CCreateNewObjectWizardBase

typedef CArray<CCreateNewObjectPageBase*, CCreateNewObjectPageBase*> CWizPagePtrArr;

class CCreateNewObjectWizardBase
{
public:
  CCreateNewObjectWizardBase(CNewADsObjectCreateInfo* m_pNewADsObjectCreateInfo);
  virtual ~CCreateNewObjectWizardBase();

  HRESULT InitPrimaryExtension();
  HRESULT DoModal();

  BOOL OnFinish();

  HWND GetWnd();
	void SetWizardButtonsFirst(BOOL bValid) 
	{ 
		SetWizardButtons(bValid ? PSWIZB_NEXT : 0);
	}
	void SetWizardButtonsMiddle(BOOL bValid) 
	{ 
		SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_NEXT) : PSWIZB_BACK);
	}
	void SetWizardButtonsLast(BOOL bValid) 
	{ 
		SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_FINISH) : (PSWIZB_BACK|PSWIZB_DISABLEDFINISH));
	}
  void EnableOKButton(BOOL bValid)
  {
    SetWizardButtons(bValid ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH);
  }
  void SetWizardOKCancel()
  {
    PropSheet_SetFinishText(GetWnd(), (LPCWSTR)m_szOKButtonCaption);
  }

  CNewADsObjectCreateInfo* GetInfo() 
  {
    ASSERT(m_pNewADsObjectCreateInfo != NULL);
    return m_pNewADsObjectCreateInfo;
  }

  void SetWizardButtons(CCreateNewObjectPageBase* pPage, BOOL bValid);
  HRESULT SetWizardButtons(CWizExtensionSite* pSite, ULONG nCurrIndex, BOOL bValid);

  void SetObjectForExtensions(CCreateNewObjectPageBase* pPage);
  LPCWSTR GetCaption() { return m_szCaption;}
  HICON GetClassIcon();
  void GetSummaryInfo(CString& s);

  HRESULT CreateNewFromPrimaryExtension(LPCWSTR pszName);
  void GetPageCounts(CWizExtensionSite* pSite, 
                      /*OUT*/ LONG* pnTotal, /*OUT*/ LONG* pnStartIndex);
  BOOL HasFinishPage() { return m_pFinishPage != NULL; }

protected:
  void AddPage(CCreateNewObjectPageBase* pPage);

  void SetWizardButtons(DWORD dwFlags)
  {
    ::PropSheet_SetWizButtons(GetWnd(), dwFlags);
  }

  virtual void GetSummaryInfoHeader(CString& s);
  virtual void OnFinishSetInfoFailed(HRESULT hr);

private:
  
  void LoadCaptions();

  HRESULT WriteData(ULONG uContext);
  HRESULT RecreateObject();

  CNewADsObjectCreateInfo * m_pNewADsObjectCreateInfo;
  
  CCreateNewObjectFinishPage* m_pFinishPage;

private:

  CWizExtensionSiteManager m_siteManager;

  CString m_szCaption;
  CString m_szOKButtonCaption;

  HICON m_hClassIcon;
  PROPSHEETHEADER m_psh;
  HWND m_hWnd;  // cached HWND
  CWizPagePtrArr m_pages;  // pages we own
  HRESULT m_hrReturnValue;

  static int CALLBACK PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam);

};



/////////////////////////////////////////////////////////////////////
// CIconCtrl


class CIconCtrl : public CStatic
{
public:
  CIconCtrl() { m_hIcon;}
  ~CIconCtrl() { DestroyIcon(m_hIcon); }
  void SetIcon(HICON hIcon)
  {
    ASSERT(hIcon != NULL);
    m_hIcon = hIcon;
  }
protected:
  HICON m_hIcon;
  afx_msg void OnPaint();
  DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////
// CCreateNewObjectPageBase

class CCreateNewObjectPageBase : public CPropertyPageEx_Mine
{
public:
  	CCreateNewObjectPageBase(UINT nIDTemplate);

// Implementation
protected:
  virtual BOOL OnInitDialog();
  virtual BOOL OnSetActive();

  virtual void GetSummaryInfo(CString&) { };
protected:
  CCreateNewObjectWizardBase* GetWiz() { ASSERT(m_pWiz != NULL); return m_pWiz;}

private:
  CIconCtrl m_iconCtrl; // to display class icon
  CCreateNewObjectWizardBase* m_pWiz;  // back pointer to wizard object

  friend class CCreateNewObjectWizardBase; // sets the m_pWiz member
  DECLARE_MESSAGE_MAP()
protected:
  afx_msg LONG OnFormatCaption(WPARAM wParam, LPARAM lParam);

};


/////////////////////////////////////////////////////////////////////
// CCreateNewObjectDataPage

class CCreateNewObjectDataPage : public CCreateNewObjectPageBase
{
public:
  CCreateNewObjectDataPage(UINT nIDTemplate);

// Implementation
protected:
  virtual BOOL OnSetActive();
  virtual BOOL OnKillActive();
  virtual LRESULT OnWizardNext();
  virtual LRESULT OnWizardBack();
  virtual BOOL OnWizardFinish();

  // interface to exchange data: need to override
  // SetData(): called to write data from the UI to the temp. object
  // return successful HRESULT to allow a kill focus/page dismissal
  virtual HRESULT SetData(BOOL bSilent = FALSE) = 0;
  // GetData(): called to load data from temporary object to UI
  // return TRUE if want the Next/OK button to be enabled
  // when called with a non NULL IADs
  virtual BOOL GetData(IADs* pIADsCopyFrom) = 0;

  // function called after the finish page has done the commit,
  // need to implement if the page needs to do something after SetInfo()
  // has been called
public:
  virtual HRESULT OnPostCommit(BOOL = FALSE) { return S_OK;}
  virtual HRESULT OnPreCommit(BOOL bSilent = FALSE) { return SetData(bSilent);}

private:
  BOOL m_bFirstTimeGetDataCalled;
};

/////////////////////////////////////////////////////////////////////
// CCreateNewObjectFinishPage

class CCreateNewObjectFinishPage : public CCreateNewObjectPageBase
{
public:
  enum { IDD = IDD_CREATE_NEW_FINISH };

  CCreateNewObjectFinishPage();

// Implementation
protected:
  virtual BOOL OnSetActive();
  virtual BOOL OnKillActive();
  virtual BOOL OnWizardFinish();

  afx_msg void OnSetFocusEdit();

  DECLARE_MESSAGE_MAP()
private:
  void WriteSummary(LPCWSTR lpszSummaryText);
  BOOL m_bNeedSetFocus;
};


///////////////////////////////////////////////////////////////////
// CCreateNewNamedObjectPage

class CCreateNewNamedObjectPage : public CCreateNewObjectDataPage
{
protected:

  CCreateNewNamedObjectPage(UINT nIDTemplate) 
        : CCreateNewObjectDataPage(nIDTemplate) {}

protected:
  // interface to exchange data
  virtual HRESULT SetData(BOOL bSilent = FALSE);
  virtual BOOL GetData(IADs* pIADsCopyFrom);

protected:
  virtual BOOL OnInitDialog();
  afx_msg void OnNameChange();

  virtual BOOL ValidateName(LPCTSTR pcszName);
  
  CString m_strName;		// Name of object  
  DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW CN WIZARD
//	Create a new object where the only mandatory attribute is "cn"
class CCreateNewObjectCnPage : public CCreateNewNamedObjectPage
{
protected:
  enum { IDD = IDD_CREATE_NEW_OBJECT_CN }; 
public:
  CCreateNewObjectCnPage() : CCreateNewNamedObjectPage(IDD) {}
}; 

class CCreateNewObjectCnWizard : public CCreateNewObjectWizardBase
{
public:
  CCreateNewObjectCnWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo)
    : CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
  {
    AddPage(&m_page1);
  }
private:
  CCreateNewObjectCnPage m_page1;
};


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW VOLUME WIZARD
//
//	Create a new volume object (friendly name: shared folder)
//
//

class CCreateNewVolumePage : public CCreateNewObjectDataPage
{
public:
  enum { IDD = IDD_CREATE_NEW_VOLUME }; 
  CCreateNewVolumePage();

protected:
  // interface to exchange data
  virtual HRESULT SetData(BOOL bSilent = FALSE);
  virtual BOOL GetData(IADs* pIADsCopyFrom);

protected:
  virtual BOOL OnInitDialog();
  afx_msg void OnNameChange();
  afx_msg void OnPathChange();

  void _UpdateUI();
  CString m_strName;		// Name of object
  CString m_strUncPath;	// UNC path of the object
  DECLARE_MESSAGE_MAP()
}; 

class CCreateNewVolumeWizard : public CCreateNewObjectWizardBase
{
public:
  CCreateNewVolumeWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo);

private:
  CCreateNewVolumePage m_page1;
};

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW COMPUTER WIZARD




class CCreateNewComputerPage : public CCreateNewObjectDataPage
{
public:
  enum { IDD = IDD_CREATE_NEW_COMPUTER };
  CCreateNewComputerPage();

  BOOL OnError(HRESULT hr);

protected:
  // interface to exchange data
  virtual BOOL OnInitDialog();
  virtual HRESULT SetData(BOOL bSilent = FALSE);
  virtual BOOL GetData(IADs* pIADsCopyFrom);

  virtual HRESULT OnPostCommit(BOOL bSilent = FALSE);
  virtual void GetSummaryInfo(CString& s);

protected:
  afx_msg void OnNameChange();
  afx_msg void OnSamNameChange();
  afx_msg void OnChangePrincipalButton();

  DECLARE_MESSAGE_MAP()

private:
  CString m_strName;		// DNS Name of computer
  CString m_strSamName;		// Downlevel Name of computer

  // security
  void UpdateSecurityPrincipalUI(PDS_SELECTION pDsSelection);
  HRESULT BuildNewAccessList(PACL* ppDacl);

  HRESULT SetSecurity();

  CSidHolder m_securityPrincipalSidHolder;

  HRESULT _LookupSamAccountNameFromSid(PSID pSid, CString& szSamAccountName);

  HRESULT _ValidateName();
  HRESULT _ValidateSamName();

}; 

class CCreateNewComputerWizard : public CCreateNewObjectWizardBase
{
public:
  CCreateNewComputerWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo);

protected:
  virtual void OnFinishSetInfoFailed(HRESULT hr);

private:
  CCreateNewComputerPage m_page1;
};

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW OU WIZARD

class CCreateNewOUPage : public CCreateNewObjectDataPage
{
public:
  enum { IDD = IDD_CREATE_NEW_OBJECT_CN }; 
  CCreateNewOUPage();

protected:
  // interface to exchange data
  virtual HRESULT SetData(BOOL bSilent = FALSE);
  virtual BOOL GetData(IADs* pIADsCopyFrom);

protected:
  virtual BOOL OnInitDialog();
  afx_msg void OnNameChange();
  virtual BOOL OnWizardFinish();
  virtual BOOL OnSetActive();

  CString m_strOUName;		// Name of OU
  DECLARE_MESSAGE_MAP()
};

class CCreateNewOUWizard : public CCreateNewObjectWizardBase
{
public:
  CCreateNewOUWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo);

private:
  CCreateNewOUPage m_page1;
};

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW GROUP WIZARD

class CCreateNewGroupPage : public CCreateNewObjectDataPage
{
public:
  enum { IDD = IDD_CREATE_NEW_GROUP }; 
  CCreateNewGroupPage();

protected:
  // interface to exchange data
  virtual HRESULT SetData(BOOL bSilent = FALSE);
  virtual BOOL GetData(IADs* pIADsCopyFrom);

protected:
  virtual BOOL OnInitDialog();
  afx_msg void OnNameChange();
  afx_msg void OnSamNameChange();
  afx_msg void OnSecurityOrTypeChange();

  CString m_strGroupName;		// Name of Group
  CString m_strSamName;                 // downlevel name of group
  BOOL m_fMixed;
  UINT m_SAMLength;

private:
  BOOL _InitUI();

  DECLARE_MESSAGE_MAP()
};

class CCreateNewGroupWizard : public CCreateNewObjectWizardBase
{
public:
  CCreateNewGroupWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo);

private:
  CCreateNewGroupPage m_page1;
};

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW CONTACT WIZARD

class CCreateNewContactPage : public CCreateNewObjectDataPage
{
public:
  enum { IDD = IDD_CREATE_NEW_CONTACT }; 
  CCreateNewContactPage();

protected:
  // interface to exchange data
  virtual HRESULT SetData(BOOL bSilent = FALSE);
  virtual BOOL GetData(IADs* pIADsCopyFrom);

protected:
  virtual BOOL OnInitDialog();
  afx_msg void OnNameChange();
  afx_msg void OnFullNameChange();
  afx_msg void OnDispNameChange();

  CString m_strFirstName;		// First Name of user
  CString m_strInitials;		// Initials of user
  CString m_strLastName;		// Last Name of user
  CString m_strFullName;		// Full Name of user (and obj CN)
  CString m_strDispName;		// Display Name of user (and obj CN)

  CUserNameFormatter m_nameFormatter; // name ordering for given name and surname

  DECLARE_MESSAGE_MAP()
};

class CCreateNewContactWizard : public CCreateNewObjectWizardBase
{
public:
  CCreateNewContactWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo);

private:
  CCreateNewContactPage m_page1;
};

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW USER WIZARD

class CCreateNewUserPage1 : public CCreateNewObjectDataPage
{
public:
  enum { IDD = IDD_CREATE_NEW_USER1 }; 
  CCreateNewUserPage1();

  LPCWSTR GetFullName() { return m_strFullName;}; 
  BOOL OnError( HRESULT hr );

protected:
  virtual BOOL OnInitDialog();
  virtual void GetSummaryInfo(CString& s);

  // interface to exchange data
  virtual HRESULT SetData(BOOL bSilent = FALSE);
  virtual BOOL GetData(IADs* pIADsCopyFrom);

protected:
  afx_msg void OnNameChange();
  afx_msg void OnLoginNameChange();
  afx_msg void OnSAMNameChange();
  afx_msg void OnFullNameChange();

  CString m_strFirstName;		// First Name of user
  CString m_strInitials;		// Initials of user
  CString m_strLastName;		// Last Name of user
  CString m_strFullName;		// Full Name of user (and obj CN)
  CString m_strLoginName;		// Login name of user
  CString m_strSAMName;		        // NT4 Login name of user

  CString m_LocalDomain;                // Current Domain

  CUserNameFormatter m_nameFormatter; // name ordering for given name and surname

private:
  BOOL _InitUI();

  BOOL m_bForcingNameChange;
  DECLARE_MESSAGE_MAP()
};

class CCreateNewUserPage2 : public CCreateNewObjectDataPage
{
public:
  enum { IDD = IDD_CREATE_NEW_USER2 }; 
  CCreateNewUserPage2();

  void SetPage1(CCreateNewUserPage1* p)
  {
    ASSERT(p != NULL);
    m_pPage1 = p;
  }

protected:
  virtual void GetSummaryInfo(CString& s);

  virtual BOOL OnInitDialog();

  // interface to exchange data
  virtual HRESULT SetData(BOOL bSilent = FALSE);
  virtual BOOL GetData(IADs* pIADsCopyFrom);

  virtual HRESULT OnPostCommit(BOOL bSilent = FALSE);

protected:
  afx_msg void OnNameChange();
  afx_msg void OnLoginNameChange();
  afx_msg void OnPasswordPropsClick();

  DECLARE_MESSAGE_MAP()

private:
  CCreateNewUserPage1* m_pPage1;
  void _GetCheckBoxSummaryInfo(UINT nCtrlID, UINT nStringID, CString& s);
};

class CCreateNewUserWizard : public CCreateNewObjectWizardBase
{
public:
  CCreateNewUserWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo);

protected:
  virtual void GetSummaryInfoHeader(CString& s);
  virtual void OnFinishSetInfoFailed(HRESULT hr);

private:
  CCreateNewUserPage1 m_page1;
  CCreateNewUserPage2 m_page2;
};


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW PRINT QUEUE WIZARD
//
//	Create a new PrintQueue object. the only mandatory props
//	are "cn" and "uNCName".
//
class CCreateNewPrintQPage : public CCreateNewObjectDataPage
{
public:
  enum { IDD = IDD_CREATE_NEW_PRINTQ }; 
  CCreateNewPrintQPage();

protected:
  // interface to exchange data
  virtual HRESULT SetData(BOOL bSilent = FALSE);
  virtual BOOL GetData(IADs* pIADsCopyFrom);

protected:
  afx_msg void OnPathChange();

  CString m_strUncPath;	        // UNC path of the object
  CString m_strContainer;       // UNC path of the object
  LPWSTR m_pwszNewObj;          // Path to created object

  void _UpdateUI();

  DECLARE_MESSAGE_MAP()
}; 

class CCreateNewPrintQWizard : public CCreateNewObjectWizardBase
{
public:
  CCreateNewPrintQWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo);

private:
  CCreateNewPrintQPage m_page1;
};

#ifdef FRS_CREATE
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW FRS SUBSCRIBER WIZARD

class CCreateNewFrsSubscriberPage : public CCreateNewNamedObjectPage
{
public:
  enum { IDD = IDD_CREATE_NEW_FRS_SUBSCRIBER }; 
  CCreateNewFrsSubscriberPage() : CCreateNewNamedObjectPage(IDD) {}

protected:
  // interface to exchange data
  virtual HRESULT SetData(BOOL bSilent = FALSE);

protected:
  CString m_strRootPath;		// FRS root path
  CString m_strStagingPath;		// FRS staging path

private:
  BOOL ReadAbsolutePath( int ctrlID, OUT CString& strrefValue );
}; 

class CCreateNewFrsSubscriberWizard : public CCreateNewObjectWizardBase
{
public:
  CCreateNewFrsSubscriberWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo)
    : CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
  {
    AddPage(&m_page1);
  }
private:
  CCreateNewFrsSubscriberPage m_page1;
};
#endif // FRS_CREATE

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW SITE WIZARD AND NEW SUBNET WIZARD (NEWSITE.CPP)

class CreateAndChoosePage : public CCreateNewNamedObjectPage
{
   public:

   CreateAndChoosePage(UINT nIDTemplate);

   protected:

   // CWnd overrides

   afx_msg
   void
   OnDestroy();

   // CDialog overrides

   virtual
   BOOL
   OnInitDialog() = 0;

   // CPropertyPage overrides

   BOOL
   OnSetActive();

   private:

   typedef CCreateNewObjectDataPage Base;

   virtual void
   initListContents(LPCWSTR containerPath) = 0;

   protected:

   HWND        listview;
   HIMAGELIST  listview_imagelist;

   DECLARE_MESSAGE_MAP();
}; 


class CreateNewSitePage : public CreateAndChoosePage
{
   public:

   CreateNewSitePage();

   protected:

   // CDialog overrides

   virtual
   BOOL
   OnInitDialog();

   // CCreateNewObjectDataPage overrides

   virtual
   HRESULT
   SetData(BOOL bSilent = FALSE);

   // JonN 5/11/01 251560 Disable OK until site link chosen
   DECLARE_MESSAGE_MAP()
   afx_msg void OnChange();
   afx_msg void OnSelChange( NMHDR*, LRESULT* );

   virtual BOOL ValidateName(LPCTSTR pcszName);

   virtual
   HRESULT
   OnPostCommit(BOOL bSilent = FALSE);

   virtual void
   initListContents(LPCWSTR containerPath);

   private:

   HRESULT
   tweakSiteLink(LPCTSTR siteDN);
}; 



class CreateNewSiteWizard : public CCreateNewObjectWizardBase
{
   public:

   CreateNewSiteWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo);

   private:

   CreateNewSitePage page;
};


class CreateNewSubnetPage : public CreateAndChoosePage
{
   public:

   CreateNewSubnetPage();

   protected:

   // CDialog overrides

   virtual
   BOOL
   OnInitDialog();

   // CCreateNewObjectDataPage overrides

   virtual
   HRESULT
   SetData(BOOL bSilent = FALSE);

   virtual void
   initListContents(LPCWSTR containerPath);

   private:

   HRESULT
   tweakSiteLink(LPCTSTR siteDN);

protected:
   afx_msg void OnSubnetMaskChange();

   DECLARE_MESSAGE_MAP();
}; 



class CreateNewSubnetWizard : public CCreateNewObjectWizardBase
{
   public:

   CreateNewSubnetWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo);

   private:

   CreateNewSubnetPage page;
};



///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// Shared between NEW SITE LINK WIZARD and NEW SITE LINK BRIDGE WIZARD 

class DSPROP_BSTR_BLOCK;
class CCreatePageWithDuellingListboxes : public CCreateNewObjectDataPage
{
public:
  CCreatePageWithDuellingListboxes(
      UINT nIDTemplate,
      LPCWSTR lpcwszAttrName,
      const DSPROP_BSTR_BLOCK& bstrblock );

protected:
  // interface to exchange data
  virtual HRESULT SetData(BOOL bSilent = FALSE);
  virtual BOOL GetData(IADs* pIADsCopyFrom);
  virtual BOOL OnSetActive();
  void SetWizardButtons();

protected:
  afx_msg void OnNameChange();
  afx_msg void OnDuellingButtonAdd();
  afx_msg void OnDuellingButtonRemove();
  afx_msg void OnDuellingListboxSelchange();
  afx_msg void OnDestroy();

  CString m_strName;
  HWND m_hwndInListbox;
  HWND m_hwndOutListbox;
  CString m_strAttrName;
  const DSPROP_BSTR_BLOCK& m_bstrblock;

  DECLARE_MESSAGE_MAP()
}; 


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW SITE LINK WIZARD

class CCreateNewSiteLinkPage : public CCreatePageWithDuellingListboxes
{
public:
  enum { IDD = IDD_CREATE_NEW_SITE_LINK }; 
  CCreateNewSiteLinkPage( const DSPROP_BSTR_BLOCK& bstrblock );

protected:
  // interface to exchange data
  virtual BOOL OnSetActive();
  virtual HRESULT SetData(BOOL bSilent = FALSE);
};


class CCreateNewSiteLinkWizard : public CCreateNewObjectWizardBase
{
public:
  CCreateNewSiteLinkWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo,
                           const DSPROP_BSTR_BLOCK& bstrblock );

private:
  CCreateNewSiteLinkPage m_page1;
};


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW SITE LINK BRIDGE WIZARD

class CCreateNewSiteLinkBridgePage : public CCreatePageWithDuellingListboxes
{
public:
  enum { IDD = IDD_CREATE_NEW_SITE_LINK_BRIDGE }; 
  CCreateNewSiteLinkBridgePage( const DSPROP_BSTR_BLOCK& bstrblock );

protected:
  // interface to exchange data
  virtual HRESULT SetData(BOOL bSilent = FALSE);
};

class CCreateNewSiteLinkBridgeWizard : public CCreateNewObjectWizardBase
{
public:
  CCreateNewSiteLinkBridgeWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo,
                                 const DSPROP_BSTR_BLOCK& bstrblockSiteLinks );

private:
  CCreateNewSiteLinkBridgePage m_page1;
};

#endif // _DLGCREAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dscache.h ===
/////////////////////////////////////////////////////////////////////////////
// CDSCookie
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSCache.h
//
//  Contents:  DS Cache functions
//
//  History:   31-Jan-97 Jimharr    Created
//
//--------------------------------------------------------------------------


#ifndef __DSCACHE_H__
#define __DSCACHE_H__

#include "dscolumn.h"
#include "dsfilter.h"  // FilterElementStruct

//////////////////////////////////////////////////////////////////////////
// helper functions

void InitGroupTypeStringTable();
LPCWSTR GetGroupTypeStringHelper(INT GroupType);


//////////////////////////////////////////////////////////////////////////
// fwd decl
class CDSComponentData;
class CMandatoryADsAttribute;
class CMandatoryADsAttributeList;

//////////////////////////////////////////////////////////////////////////
// CDSClassCacheItemBase

class CDSClassCacheItemBase
{
public:
  static HRESULT CreateItem(IN LPCWSTR lpszClass, 
                            IN IADs* pDSObject, 
                            IN CDSComponentData *pCD,
                            OUT CDSClassCacheItemBase** ppItem);
public:
  CDSClassCacheItemBase()
  {
    m_GUID = GUID_NULL;
    m_bIsContainer = FALSE;
    m_pMandPropsList = NULL;
    m_pColumnSet = NULL;

    m_pAdminPropertyPages            = NULL;
    m_nAdminPPCount                  = 0;
    m_pAdminContextMenu              = NULL;
    m_nAdminCMCount                  = 0;
    m_pAdminMultiSelectPropertyPages = NULL;
    m_nAdminMSPPCount                = 0;
  }
  virtual ~CDSClassCacheItemBase();

public:
  // accessor functions
  LPCWSTR GetClassName() 
  { 
    ASSERT(!m_szClass.IsEmpty());
    return m_szClass;
  }
  LPCWSTR GetFriendlyClassName() 
  { 
    ASSERT(!m_szFriendlyClassName.IsEmpty());
    return m_szFriendlyClassName; 
  }

  LPCWSTR GetNamingAttribute() 
  { 
    ASSERT(!m_szNamingAttribute.IsEmpty());
    return m_szNamingAttribute;
  }

  CDSColumnSet* GetColumnSet();

  GUID* GetGUID() { return &m_GUID; }
  BOOL IsContainer() { return m_bIsContainer; }
  BOOL SetContainerFlag(BOOL fIsContainer) { m_bIsContainer = fIsContainer; return m_bIsContainer; }

  CMandatoryADsAttributeList* GetMandatoryAttributeList(CDSComponentData* pCD);

  virtual int GetIconIndex(CDSCookie* pCookie, BOOL bOpen) = 0;

  //
  // Display Specifier cached accessors
  //
  virtual GUID* GetAdminPropertyPages(UINT* pnCount);
  virtual void SetAdminPropertyPages(UINT nCount, GUID* pGuids);
  virtual GUID* GetAdminContextMenu(UINT* pnCount);
  virtual void SetAdminContextMenu(UINT nCount, GUID* pGuids);
  virtual GUID* GetAdminMultiSelectPropertyPages(UINT* pnCount);
  virtual void SetAdminMultiSelectPropertyPages(UINT nCount, GUID* pGuids);

protected:  
  virtual HRESULT Init(LPCWSTR lpszClass, IADs* pDSObject, CDSComponentData *pCD);

  virtual void SetIconData(CDSComponentData *pCD) = 0;


private:
  // data members
  CString     m_szClass;
  CString     m_szNamingAttribute;  // class naming atrribute, eg. "cn" or "ou"
  CString     m_szFriendlyClassName;  // the friendly name for this class
  BOOL        m_bIsContainer;
  GUID        m_GUID;

  //
  // Display specifier GUID cache
  //
  GUID*       m_pAdminPropertyPages;
  UINT        m_nAdminPPCount;
  GUID*       m_pAdminContextMenu;
  UINT        m_nAdminCMCount;
  GUID*       m_pAdminMultiSelectPropertyPages;
  UINT        m_nAdminMSPPCount;

  CDSColumnSet* m_pColumnSet;

  CMandatoryADsAttributeList* m_pMandPropsList;
};


//////////////////////////////////////////////////////////////////////////
// CDSClassIconIndexes

class CDSClassIconIndexes
{
public:
  CDSClassIconIndexes()
  {
    m_iIconIndex = m_iIconIndexOpen = m_iIconIndexDisabled = -1;
  }

  int  GetIconIndex(BOOL bDisabled, BOOL bOpen)
  { 
    if (bDisabled)
      return m_iIconIndexDisabled;
    return bOpen ? m_iIconIndexOpen : m_iIconIndex; 
  }

  void SetIconData(LPCWSTR lpszClass, BOOL bContainer, CDSComponentData *pCD, int nIconSet);

private:
  int m_iIconIndex;
  int m_iIconIndexOpen;
  int m_iIconIndexDisabled;
};

//////////////////////////////////////////////////////////////////////////
// CDSClassCacheItemGeneric

class CDSClassCacheItemGeneric : public CDSClassCacheItemBase
{
public:
  virtual int GetIconIndex(CDSCookie* pCookie, BOOL bOpen);
  
protected:  
  virtual void SetIconData(CDSComponentData *pCD);

  CDSClassIconIndexes m_iconIndexesStandard;
};


//////////////////////////////////////////////////////////////////////////
// CDSClassCacheItemUser

class CDSClassCacheItemUser : public CDSClassCacheItemGeneric
{
};

//////////////////////////////////////////////////////////////////////////
// CDSClassCacheItemGroup

class CDSClassCacheItemGroup : public CDSClassCacheItemGeneric
{
public:
  virtual int GetIconIndex(CDSCookie* pCookie, BOOL bOpen);
  
protected:  
  virtual void SetIconData(CDSComponentData *pCD);

private:
  CDSClassIconIndexes m_iconIndexesAlternate;
};




//////////////////////////////////////////////////////////////////////////
// CDSCache

typedef CMap <CString, LPCTSTR, CDSClassCacheItemBase*, CDSClassCacheItemBase*> CDSCacheMap;

class CDSCache
{
public:
  CDSCache() : m_pfilterelementDsAdminDrillDown(NULL), m_bDisplaySettingsCollected(FALSE)
  {
    ExceptionPropagatingInitializeCriticalSection(&m_cs);
  }
  ~CDSCache() 
  { 
    _Lock();
    _Cleanup();
    _CleanupColumns();
    _Unlock();
    ::DeleteCriticalSection(&m_cs);
  }
private:
  CDSCache(const CDSCache&) {}
  CDSCache& operator=(const CDSCache&) {}

public:
  BOOL ToggleExpandSpecialClasses(BOOL bContainer);

  CDSClassCacheItemBase* FindClassCacheItem(CDSComponentData* pCD,
                                            LPCWSTR lpszObjectClass,
                                            LPCWSTR lpszObjectLdapPath);

  BOOL Lookup(LPCTSTR lpsz, CDSClassCacheItemBase*& pItem)
  {
    _Lock();
    BOOL b = m_Map.Lookup(lpsz, pItem);
    _Unlock();
    return b;
  }

  //
  // Column Set List methods
  //
  CDSColumnSet* FindColumnSet(LPCWSTR lpszColumnID);

  void Initialize(SnapinType snapinType, MyBasePathsInfo* pBasePathsInfo, BOOL bFlushColumns) 
  { 
    _Lock();

    _Cleanup();
    if (bFlushColumns)
    {
      _CleanupColumns();
      m_ColumnList.Initialize(snapinType, pBasePathsInfo); 
    }
    _Unlock();
  }

  HRESULT Save(IStream* pStm);
  HRESULT Load(IStream* pStm);

  HRESULT TabCollect_AddMultiSelectPropertyPages(LPPROPERTYSHEETCALLBACK pCall,
                                                 LONG_PTR lNotifyHandle,
                                                 LPDATAOBJECT pDataObject, 
                                                 MyBasePathsInfo* pBasePathsInfo);

  BOOL CanAddToGroup(MyBasePathsInfo* pBasePathsInfo, PCWSTR pszClass, BOOL bSecurity);

  FilterElementStruct* GetFilterElementStruct(CDSComponentData* pDSComponentData);

private:
  void _Cleanup()
  {
    CString Key;
    CDSClassCacheItemBase* pCacheItem = NULL;
    POSITION pos = m_Map.GetStartPosition();
    while (!m_Map.IsEmpty()) 
    {
      m_Map.GetNextAssoc (pos, Key, pCacheItem);
      m_Map.RemoveKey (Key);
      delete pCacheItem;
    }

    m_szSecurityGroupExtraClasses.RemoveAll();
    m_szNonSecurityGroupExtraClasses.RemoveAll();
    m_bDisplaySettingsCollected = FALSE;

    //
    // Cleanup filter containers
    //
    _CleanupFilterContainers();
  }

  void _CleanupFilterContainers()
  {
    if (m_pfilterelementDsAdminDrillDown != NULL)
    {
      if (m_pfilterelementDsAdminDrillDown->ppTokens != NULL)
      {
        for (UINT idx = 0; idx < m_pfilterelementDsAdminDrillDown->cNumTokens; idx++)
        {
          if (m_pfilterelementDsAdminDrillDown->ppTokens[idx] != NULL)
          {
            delete[] m_pfilterelementDsAdminDrillDown->ppTokens[idx]->lpszString;
            m_pfilterelementDsAdminDrillDown->ppTokens[idx]->lpszString = NULL;
          }
        }
        delete[] m_pfilterelementDsAdminDrillDown->ppTokens;
        m_pfilterelementDsAdminDrillDown->ppTokens = NULL;
      }
      delete m_pfilterelementDsAdminDrillDown;
      m_pfilterelementDsAdminDrillDown = NULL;
    }
  }

  void _CleanupColumns()
  {
    m_ColumnList.RemoveAndDeleteAllColumnSets();
  }

  void _CollectDisplaySettings(MyBasePathsInfo* pBasePathsInfo);
  void _Lock() { ::EnterCriticalSection(&m_cs);}
  void _Unlock() { ::LeaveCriticalSection(&m_cs);}

  CRITICAL_SECTION m_cs;
  CDSCacheMap m_Map;
  CColumnSetList m_ColumnList;
  BOOL m_bDisplaySettingsCollected;
  CStringList m_szSecurityGroupExtraClasses;
  CStringList m_szNonSecurityGroupExtraClasses;
  FilterElementStruct* m_pfilterelementDsAdminDrillDown;
};


#endif //__DSCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dlgcreat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dlgcreat.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	dlgcreat.cpp
//
//	Implementation of dialogs that create new ADs objects.
//
//	DIALOGS SUPPORTED
//		CCreateNewObjectCnDlg - Dialog asking for "cn" attribute.
//		CCreateNewVolumeDlg - Create a new volume "shared folder" object
//		CCreateNewComputerDlg - Create a new computer object.
//		CCreateNewSiteLinkDlg - Create a new Site Link.
//		CCreateNewSiteLinkBridgeDlg - Create a new Site Link Bridge.

//
//	DIALOGS NOT YET IMPLEMENTED
//		site (validation only)
//		organizationalUnit
//		localPolicy
//		auditingPolicy
//
//	HISTORY
//	24-Aug-97	Dan Morin	Creation.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "dsutil.h"
#include "uiutil.h"

#include <windowsx.h>
#include <lmaccess.h>
#include <dnsapi.h>             // DnsvalidateDnsName_W
#include "winsprlp.h"           //PublishPrinter

#include "newobj.h"		// CNewADsObjectCreateInfo
#include "dscmn.h"
#include "dlgcreat.h"

extern "C"
{
#include "lmerr.h" // NET_API_STATUS
#include "icanon.h" // I_NetPathType
}


///////////////////////////////////////////////////////////////////////////
// CHPropSheetPageArr
CHPropSheetPageArr::CHPropSheetPageArr()
{
  m_nCount = 0;
  m_nSize = 4;
  ULONG nBytes = sizeof(HPROPSHEETPAGE)*m_nSize;
  m_pArr = (HPROPSHEETPAGE*)malloc(nBytes);
  if (m_pArr != NULL)
  {
    ZeroMemory(m_pArr, nBytes);
  }
}


void CHPropSheetPageArr::AddHPage(HPROPSHEETPAGE hPage)
{
  // see if there is space in the array
  if (m_nCount == m_nSize)
  {
    // grow the array
    int nAlloc = m_nSize*2;
    m_pArr = (HPROPSHEETPAGE*)realloc(m_pArr, sizeof(HPROPSHEETPAGE)*nAlloc);
    if (m_pArr != NULL)
    {
      ::ZeroMemory(&m_pArr[m_nSize], sizeof(HPROPSHEETPAGE)*m_nSize);
      m_nSize = nAlloc;
    }
    else
    {
      m_nSize = 0;
    }
  }
  m_pArr[m_nCount] = hPage;
  m_nCount++;
}

///////////////////////////////////////////////////////////////////////////
// CDsAdminNewObjSiteImpl




BOOL CDsAdminNewObjSiteImpl::_IsPrimarySite()
{
  return (m_pSite->GetSiteManager()->GetPrimaryExtensionSite() == m_pSite);
}


STDMETHODIMP CDsAdminNewObjSiteImpl::SetButtons(ULONG nCurrIndex, BOOL bValid)
{
  CCreateNewObjectWizardBase* pWiz = m_pSite->GetSiteManager()->GetWiz();
  return pWiz->SetWizardButtons(m_pSite, nCurrIndex, bValid);
}


STDMETHODIMP CDsAdminNewObjSiteImpl::GetPageCounts(/*OUT*/ LONG* pnTotal,
                               /*OUT*/ LONG* pnStartIndex)
{
  if ( (pnTotal == NULL) || (pnStartIndex == NULL) )
    return E_INVALIDARG;

  m_pSite->GetSiteManager()->GetWiz()->GetPageCounts(m_pSite, pnTotal,pnStartIndex); 
  return S_OK;
}

STDMETHODIMP CDsAdminNewObjSiteImpl::CreateNew(LPCWSTR pszName)
{
  if (m_pSite->GetSiteManager()->GetPrimaryExtensionSite() != m_pSite)
  {
    // cannot do if not a primary extension
    return E_FAIL;
  }

  CCreateNewObjectWizardBase* pWiz = m_pSite->GetSiteManager()->GetWiz();
  return pWiz->CreateNewFromPrimaryExtension(pszName);
}


STDMETHODIMP CDsAdminNewObjSiteImpl::Commit()
{
  if (m_pSite->GetSiteManager()->GetPrimaryExtensionSite() != m_pSite)
  {
    // cannot do if not a primary extension
    return E_FAIL;
  }

  if (m_pSite->GetHPageArr()->GetCount() > 1)
  {
    // valid only if the primary extension has one page only
    return E_FAIL;
  }

  CCreateNewObjectWizardBase* pWiz = m_pSite->GetSiteManager()->GetWiz();
  if (pWiz->HasFinishPage())
  {
    // if we have the finish page, the finish page must handle it
    return E_FAIL;
  }

  // trigger the finish code
  return (pWiz->OnFinish() ? S_OK : E_FAIL);
}


///////////////////////////////////////////////////////////////////////////
// CWizExtensionSite

// static function
BOOL CALLBACK FAR CWizExtensionSite::_OnAddPage(HPROPSHEETPAGE hsheetpage, LPARAM lParam)
{
  TRACE(L"CWizExtensionSite::_OnAddPage(HPROPSHEETPAGE = 0x%x, lParam = 0x%x)\n",
          hsheetpage, lParam);
  CWizExtensionSite* pThis = (CWizExtensionSite*)lParam;
  pThis->m_pageArray.AddHPage(hsheetpage);
  return TRUE;
}

HRESULT CWizExtensionSite::InitializeExtension(GUID* pGuid)
{
  ASSERT(m_pSiteImplComObject == NULL);
  ASSERT(pGuid != NULL);

  WCHAR szBuf[256];
  StringFromGUID2(*(pGuid), szBuf, 256);

  TRACE(L"CWizExtensionSite::InitializeExtension( Guid = %s,\n", szBuf);

  // create extension COM object
  HRESULT hr = ::CoCreateInstance(*pGuid, NULL, CLSCTX_INPROC_SERVER, 
                        IID_IDsAdminNewObjExt, (void**)(&m_spIDsAdminNewObjExt));
  if (FAILED(hr))
  {
    TRACE(L"CoCreateInstance() failed, hr = 0x%x\n", hr);
    return hr;
  }

  // create a CDsAdminNewObjSiteImpl COM object
  ASSERT(m_pSiteImplComObject == NULL);
  CComObject<CDsAdminNewObjSiteImpl>::CreateInstance(&m_pSiteImplComObject);
  if (m_pSiteImplComObject == NULL) 
  {
    TRACE(L"CComObject<CDsAdminNewObjSiteImpl>::CreateInstance() failed\n");
    return E_OUTOFMEMORY;
  }

  // fully construct the object
  hr = m_pSiteImplComObject->FinalConstruct();
  if (FAILED(hr))
  {
    TRACE(L"CComObject<CDsAdminNewObjSiteImpl>::FinalConstruct failed hr = 0x%x\n", hr);

    // ref counting not yet into play, just use operator delete
    delete m_pSiteImplComObject; 
    m_pSiteImplComObject = NULL;
    return hr;
  }
  
  // object has ref count == 0, need to add ref
  // no smart pointer, ref counting on m_pSiteImplComObject

  IDsAdminNewObj* pDsAdminNewObj = NULL;
  m_pSiteImplComObject->QueryInterface(IID_IDsAdminNewObj, (void**)&pDsAdminNewObj);
  ASSERT(pDsAdminNewObj != NULL);

  // now ref count == 1

  // set back pointer to ourselves
  m_pSiteImplComObject->Init(this);

  // initialize the object
  

  CCreateNewObjectWizardBase* pWiz = GetSiteManager()->GetWiz();
  ASSERT(pWiz != NULL);

  CNewADsObjectCreateInfo* pInfo = pWiz->GetInfo();
  ASSERT(pInfo != NULL);


  // create a temporary struct on the stack
  DSA_NEWOBJ_DISPINFO dispinfo;
  ZeroMemory(&dispinfo, sizeof(DSA_NEWOBJ_DISPINFO));

  dispinfo.dwSize = sizeof(DSA_NEWOBJ_DISPINFO);
  dispinfo.hObjClassIcon = pWiz->GetClassIcon();
  dispinfo.lpszWizTitle = const_cast<LPTSTR>(pWiz->GetCaption());
  dispinfo.lpszContDisplayName = const_cast<LPTSTR>(pWiz->GetInfo()->GetContainerCanonicalName());

  TRACE(_T("dispinfo.dwSize = %d\n"), dispinfo.dwSize);
  TRACE(_T("dispinfo.hObjClassIcon = 0x%x\n"), dispinfo.hObjClassIcon);
  TRACE(_T("dispinfo.lpszWizTitle = <%s>\n"), dispinfo.lpszWizTitle);
  TRACE(_T("dispinfo.lpszContDisplayName = <%s>\n"), dispinfo.lpszContDisplayName);


  TRACE(L"\ncalling m_spIDsAdminWizExt->Initialize()\n");

  hr = m_spIDsAdminNewObjExt->Initialize(
                              pInfo->m_pIADsContainer,                              
                              pInfo->GetCopyFromObject(),
                              pInfo->m_pszObjectClass,
                              pDsAdminNewObj,
                              &dispinfo
                              );
  if (FAILED(hr))
  {
    TRACE(L"m_spIDsAdminNewObjExt->Initialize() failed hr = 0x%x\n", hr);
    return hr;
  }

  // collect property pages
  return m_spIDsAdminNewObjExt->AddPages(_OnAddPage, (LPARAM)this);
}

BOOL CWizExtensionSite::GetSummaryInfo(CString& s)
{
  CComBSTR bstr;
  HRESULT hr = GetNewObjExt()->GetSummaryInfo(&bstr);
  if (SUCCEEDED(hr) && bstr != NULL)
  {
    s += bstr;
    s += L"\n";
    return TRUE;
  }
  return FALSE;
}

///////////////////////////////////////////////////////////////////////////
// CWizExtensionSiteManager

HRESULT CWizExtensionSiteManager::CreatePrimaryExtension(GUID* pGuid, 
                                IADsContainer*,
                                LPCWSTR)
{
  ASSERT(m_pPrimaryExtensionSite == NULL);
  m_pPrimaryExtensionSite = new CWizExtensionSite(this);
  if (m_pPrimaryExtensionSite == NULL)
    return E_OUTOFMEMORY;

  // initialize COM object
  HRESULT hr = m_pPrimaryExtensionSite->InitializeExtension(pGuid);

  if (FAILED(hr))
  {
    delete m_pPrimaryExtensionSite;
    m_pPrimaryExtensionSite = NULL;
    return hr;
  }
  
  // make sure it provided at least a page
  if (m_pPrimaryExtensionSite->GetHPageArr()->GetCount() == 0)
  {
    hr = E_INVALIDARG;
    delete m_pPrimaryExtensionSite;
    m_pPrimaryExtensionSite = NULL;
  }
  return hr;
}



HRESULT CWizExtensionSiteManager::CreateExtensions(GUID* aCreateWizExtGUIDArr, ULONG nCount,
                                                    IADsContainer*,
                                                    LPCWSTR lpszClassName)
{
  HRESULT hr;
  TRACE(L"CWizExtensionSiteManager::CreateExtensions(_, nCount = %d, _ , lpszClassName = %s\n",
            nCount,lpszClassName);

  for (ULONG i=0; i<nCount; i++)
  {
    CWizExtensionSite* pSite = new CWizExtensionSite(this);
    if (pSite == NULL)
    {
      hr = E_OUTOFMEMORY;
      break;
    }
    hr = pSite->InitializeExtension(&(aCreateWizExtGUIDArr[i]));
    if (FAILED(hr))
    {
      TRACE(L"pSite->InitializeExtension() failed hr = 0x%x", hr);
      delete pSite;
    }
    else
    {
      m_extensionSiteList.AddTail(pSite);
    }
  }
  TRACE(L"m_extensionSiteList.GetCount() returned %d\n", m_extensionSiteList.GetCount());
  return S_OK;
}

UINT CWizExtensionSiteManager::GetTotalHPageCount()
{
  UINT nCount = 0;
  for (POSITION pos = m_extensionSiteList.GetHeadPosition(); pos != NULL; )
  {
    CWizExtensionSite* pSite = m_extensionSiteList.GetNext(pos);
    nCount += pSite->GetHPageArr()->GetCount();
  } // for
  return nCount;
}

void CWizExtensionSiteManager::SetObject(IADs* pADsObj)
{
  CWizExtensionSite* pPrimarySite = GetPrimaryExtensionSite();
  if (pPrimarySite != NULL)
  {
    pPrimarySite->GetNewObjExt()->SetObject(pADsObj);
  }

  for (POSITION pos = m_extensionSiteList.GetHeadPosition(); pos != NULL; )
  {
    CWizExtensionSite* pSite = m_extensionSiteList.GetNext(pos);
    HRESULT hr = pSite->GetNewObjExt()->SetObject(pADsObj);
    ASSERT(SUCCEEDED(hr));
  }
}

HRESULT CWizExtensionSiteManager::WriteExtensionData(HWND hWnd, ULONG uContext)
{
  for (POSITION pos = m_extensionSiteList.GetHeadPosition(); pos != NULL; )
  {
    CWizExtensionSite* pSite = m_extensionSiteList.GetNext(pos);
    HRESULT hr = pSite->GetNewObjExt()->WriteData(hWnd, uContext);
    if (FAILED(hr))
        return hr;
  } // for
  return S_OK;
}

HRESULT CWizExtensionSiteManager::NotifyExtensionsOnError(HWND hWnd, HRESULT hr, ULONG uContext)
{
  for (POSITION pos = m_extensionSiteList.GetHeadPosition(); pos != NULL; )
  {
    CWizExtensionSite* pSite = m_extensionSiteList.GetNext(pos);
    pSite->GetNewObjExt()->OnError(hWnd, hr, uContext);
  } // for
  return S_OK;
}


void CWizExtensionSiteManager::GetExtensionsSummaryInfo(CString& s)
{
  // just go through regular extensions
  for (POSITION pos = m_extensionSiteList.GetHeadPosition(); pos != NULL; )
  {
    CWizExtensionSite* pSite = m_extensionSiteList.GetNext(pos);
    pSite->GetSummaryInfo(s);
  } // for
}

/////////////////////////////////////////////////////////////////////
// CCreateNewObjectWizardBase

HWND g_hWndHack = NULL;

int CALLBACK CCreateNewObjectWizardBase::PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM)
{
  if (uMsg == PSCB_INITIALIZED)
  {
    ASSERT(::IsWindow(hwndDlg));
    g_hWndHack = hwndDlg;
    DWORD dwStyle = GetWindowLong (hwndDlg, GWL_EXSTYLE);
    dwStyle &= ~WS_EX_CONTEXTHELP;
    SetWindowLong (hwndDlg, GWL_EXSTYLE, dwStyle);
  }
  return 0;
}



CCreateNewObjectWizardBase::CCreateNewObjectWizardBase(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo)
                  : m_siteManager(this)
{
  memset(&m_psh, 0x0, sizeof(PROPSHEETHEADER));
  m_psh.dwSize              = sizeof( m_psh );
  m_psh.dwFlags             = PSH_WIZARD | PSH_PROPTITLE | PSH_USECALLBACK;
  m_psh.hInstance           = _Module.GetModuleInstance();
  m_psh.pszCaption          = NULL; // will set later on per page

  ASSERT(pNewADsObjectCreateInfo != NULL);
  m_pNewADsObjectCreateInfo = pNewADsObjectCreateInfo;

  m_psh.hwndParent = m_pNewADsObjectCreateInfo->GetParentHwnd();
  m_psh.pfnCallback = PropSheetProc;

  m_hWnd = NULL;
  m_pFinishPage = NULL;
  m_hrReturnValue = S_FALSE; // default is cancel

  m_hClassIcon = NULL;
}

CCreateNewObjectWizardBase::~CCreateNewObjectWizardBase()
{
  if (m_pFinishPage != NULL)
    delete m_pFinishPage;

  if (m_hClassIcon)
  {
     DestroyIcon(m_hClassIcon);
  }
}


HRESULT CCreateNewObjectWizardBase::DoModal()
{
  TRACE(L"CCreateNewObjectWizardBase::DoModal()\n");
  ASSERT(m_pNewADsObjectCreateInfo != NULL);
  
  // load the sheet caption
  LoadCaptions();

  CWizExtensionSite* pPrimarySite = m_siteManager.GetPrimaryExtensionSite();

  // load the extensions, if any
  HRESULT hr = m_siteManager.CreateExtensions(
                    m_pNewADsObjectCreateInfo->GetCreateInfo()->aWizardExtensions,
                    m_pNewADsObjectCreateInfo->GetCreateInfo()->cWizardExtensions,
                    m_pNewADsObjectCreateInfo->m_pIADsContainer,
                    m_pNewADsObjectCreateInfo->m_pszObjectClass);
  if (FAILED(hr))
    return (hr);


  // get the # of primary property pages (excluding the Finish Page)
  UINT nBasePagesCount = 0;
  if (pPrimarySite != NULL)
  {
    nBasePagesCount += pPrimarySite->GetHPageArr()->GetCount();
  }
  else
  {
    nBasePagesCount += (UINT)m_pages.GetSize();
  }

  ASSERT(nBasePagesCount > 0);

  // get the handle count for the extensions (total for extension property pages)
  UINT nExtensionHPagesCount = m_siteManager.GetTotalHPageCount();

  // if we have more than one page, add the finish page
  UINT nTotalPageCount = nBasePagesCount + nExtensionHPagesCount;

  if ( (nBasePagesCount + nExtensionHPagesCount) > 1)
  {
    m_pFinishPage = new CCreateNewObjectFinishPage;
    AddPage(m_pFinishPage);
    nTotalPageCount++;
  }
  
  // need to allocate a contiguous chunk of memory to pack
  // all the property sheet handles
  m_psh.nPages = nTotalPageCount;
  m_psh.phpage = new HPROPSHEETPAGE[nTotalPageCount];
  if (m_psh.phpage)
  {
    UINT nOffset = 0; // offset where to write to

    // add the primary pages first
    if (pPrimarySite != NULL)
    {
      ASSERT(nBasePagesCount > 0);
      memcpy(&(m_psh.phpage[nOffset]), pPrimarySite->GetHPageArr()->GetArr(), 
                      sizeof(HPROPSHEETPAGE)*nBasePagesCount);
      nOffset += nBasePagesCount;
    }
    else
    {
      for (UINT i = 0; i < nBasePagesCount; i++)
      {
        CCreateNewObjectPageBase* pPage = m_pages[i];
        m_psh.phpage[nOffset] = ::CreatePropertySheetPage(&(pPage->m_psp));
        nOffset++;
      } // for
    }

    // add the extension pages
    CWizExtensionSiteList* pSiteList = m_siteManager.GetExtensionSiteList();
    for (POSITION pos = pSiteList->GetHeadPosition(); pos != NULL; )
    {
      CWizExtensionSite* pSite = pSiteList->GetNext(pos);
      UINT nCurrCount = pSite->GetHPageArr()->GetCount();
      if (nCurrCount > 0)
      {
        memcpy(&(m_psh.phpage[nOffset]), pSite->GetHPageArr()->GetArr(), 
                        sizeof(HPROPSHEETPAGE)*nCurrCount);
        nOffset += nCurrCount;
      } // if
    } // for

    // add the finish page last, if any
    if (m_pFinishPage != NULL)
    {
      ASSERT( nOffset == (nTotalPageCount-1) );
      m_psh.phpage[nOffset] = ::CreatePropertySheetPage(&(m_pFinishPage->m_psp));
    }

    // finally, invoke the modal sheet
    TRACE(L"::PropertySheet(&m_psh) called with m_psh.nPages = %d\n", m_psh.nPages);

    ::PropertySheet(&m_psh);

    delete[] m_psh.phpage;
    m_psh.phpage = 0;
  }
  return m_hrReturnValue; 
}

void CCreateNewObjectWizardBase::GetPageCounts(CWizExtensionSite* pSite,
                                               /*OUT*/ LONG* pnTotal,
                                                /*OUT*/ LONG* pnStartIndex)
{
  CWizExtensionSite* pPrimarySite = m_siteManager.GetPrimaryExtensionSite();

  *pnTotal = 0;
  // get the # of primary property pages (excluding the Finish Page)
  UINT nBasePagesCount = 0;
  if (pPrimarySite != NULL)
  {
    nBasePagesCount += pPrimarySite->GetHPageArr()->GetCount();
  }
  else
  {
    nBasePagesCount += (UINT)(m_pages.GetSize()-1); // -1 because we exclude finish page
  }

  *pnTotal = nBasePagesCount + m_siteManager.GetTotalHPageCount();

  if (m_pFinishPage != NULL)
  {
    (*pnTotal)++;
  }

  if (pPrimarySite == pSite)
  {
    *pnStartIndex = 0;
  }
  else
  {
    // which site is it?
    *pnStartIndex = nBasePagesCount;
    CWizExtensionSiteList* pSiteList = m_siteManager.GetExtensionSiteList();
    for (POSITION pos = pSiteList->GetHeadPosition(); pos != NULL; )
    {
      CWizExtensionSite* pCurrSite = pSiteList->GetNext(pos);
      if (pCurrSite == pSite)
        break; // got it, we are done
      
      // keep adding the previous counts
      UINT nCurrCount = pCurrSite->GetHPageArr()->GetCount();
      (*pnStartIndex) += nCurrCount;
    } // for
  } // else

}

HWND CCreateNewObjectWizardBase::GetWnd()
{
  if (m_hWnd == NULL)
  {
    for (int i = 0; i < m_pages.GetSize(); i++)
	  {
      CCreateNewObjectPageBase* pPage = m_pages[i];
      if (pPage->m_hWnd != NULL)
      {
        m_hWnd = ::GetParent(pPage->m_hWnd);
        break;
      }
    } // for
  } // if

  if (m_hWnd == NULL)
  {
    m_hWnd = g_hWndHack;
    g_hWndHack = NULL;
  }

  ASSERT(m_hWnd != NULL);
  ASSERT(::IsWindow(m_hWnd));
  return m_hWnd;
}

void CCreateNewObjectWizardBase::AddPage(CCreateNewObjectPageBase* pPage)
{
  m_pages.Add(pPage);
  pPage->m_pWiz = this;
}


HRESULT CCreateNewObjectWizardBase::CreateNewFromPrimaryExtension(LPCWSTR pszName)
{
  // NOTICE: we call with bAllowCopy = FALSE because
  // primary extensions will have to handle the copy semantics 
  // by themselves

  // NOTICE: we pass bSilentError = TRUE because
  // primary extensions will have to handle the message for
  // creation failure

  HRESULT hr = GetInfo()->HrCreateNew(pszName, TRUE /* bSilentError */, FALSE /* bAllowCopy */);

  GetInfo()->PGetIADsPtr();
  m_siteManager.SetObject(GetInfo()->PGetIADsPtr());
  return hr;
}


void CCreateNewObjectWizardBase::SetWizardButtons(
    CCreateNewObjectPageBase* pPage, BOOL bValid)
{
  ASSERT(pPage != NULL);
  if (m_pFinishPage != NULL)
  {
    ASSERT(m_pages.GetSize() >= 1); // at least finish page
    if (pPage == (CCreateNewObjectPageBase*)m_pFinishPage)
    {
      SetWizardButtonsLast(bValid);
    }
    else
    {
      if (m_pages[0] == pPage)
        SetWizardButtonsFirst(bValid);
      else
        SetWizardButtonsMiddle(bValid);
    }
  }
  else
  {
    // single page wizard
    ASSERT(m_pages.GetSize() == 1);
    SetWizardOKCancel();
    EnableOKButton(bValid);
  }
}


HRESULT CCreateNewObjectWizardBase::SetWizardButtons(CWizExtensionSite* pSite, 
                                                     ULONG nCurrIndex, BOOL bValid)
{
  UINT nSitePagesCount = pSite->GetHPageArr()->GetCount();
  if (nSitePagesCount == 0)
  {
    // cannot call from UI less extension
    return E_INVALIDARG;
  }
  if (nCurrIndex >= nSitePagesCount)
  {
    // out of range
    return E_INVALIDARG;
  }

  // get the handle count for the secondary extensions (total for extension property pages)
  UINT nExtensionHPagesCount = m_siteManager.GetTotalHPageCount();

  if (m_siteManager.GetPrimaryExtensionSite() == pSite)
  {
    // called from the primary extension
    if ((nSitePagesCount == 1) && (nExtensionHPagesCount == 0))
    {
      // single page, so we have the OK/Cancel buttons
      SetWizardOKCancel();
      EnableOKButton(bValid);
    }
    else
    {
      // multiple pages
      if (nCurrIndex == 0)
        SetWizardButtonsFirst(bValid);
      else
        SetWizardButtonsMiddle(bValid);
    }
  }
  else
  {
    // called from a secondary extension, we must have the finish page and
    // some primary extension or primary page(s), so we are always in the middle
    ASSERT(m_pFinishPage != NULL);
    SetWizardButtonsMiddle(bValid);
  }
  return S_OK;
}



void CCreateNewObjectWizardBase::SetObjectForExtensions(CCreateNewObjectPageBase* pPage)
{
  ASSERT(pPage != NULL);
  ASSERT(pPage != m_pFinishPage);
  UINT nPages = (UINT)m_pages.GetSize();

  if (m_pFinishPage != NULL)
  {
    ASSERT(nPages > 1); // at least 1 page + finish
    if (pPage == m_pages[nPages-2])
    {
      // this is the last primary page
      // give the ADSI object pointer to all the extensions
      m_siteManager.SetObject(m_pNewADsObjectCreateInfo->PGetIADsPtr());
    }
  }
  else
  {
    // this is the case of a single primary page, but at least one
    // UI-less extension (i.e. no finish page)
    ASSERT(nPages == 1); // just this page, no finish page
    if (pPage == m_pages[0])
    {
      // this is the only primary page
      // give the ADSI object pointer to all the extensions
      m_siteManager.SetObject(m_pNewADsObjectCreateInfo->PGetIADsPtr());
    }
  } // if
}

HRESULT CCreateNewObjectWizardBase::WriteData(ULONG uContext)
{
  HRESULT hr = S_OK;
  CWizExtensionSite* pPrimarySite = m_siteManager.GetPrimaryExtensionSite();
  if (uContext == DSA_NEWOBJ_CTX_POSTCOMMIT)
  {
    // call the post commit on all the data primary pages
    if (pPrimarySite != NULL)
    {
      hr = pPrimarySite->GetNewObjExt()->WriteData(GetWnd(), uContext);
      if (FAILED(hr))
        hr = pPrimarySite->GetNewObjExt()->OnError(GetWnd(), hr, uContext);
    }
    else
    {
      for (int i = 0; i < m_pages.GetSize(); i++)
	    {
        CCreateNewObjectPageBase* pPage = m_pages[i];
        if (pPage != m_pFinishPage)
        {
          CCreateNewObjectDataPage* pDataPage = dynamic_cast<CCreateNewObjectDataPage*>(pPage);
          ASSERT(pDataPage != NULL);
          hr = pDataPage->OnPostCommit();
          if (FAILED(hr))
          {
            m_siteManager.NotifyExtensionsOnError(GetWnd(), hr, uContext);
            break;
          }
        }
      } // for
    } // if
  } // if

  if (uContext == DSA_NEWOBJ_CTX_PRECOMMIT)
  {
    // call the pre commit on all the data primary pages
    // (As per Exchange request)
    if (pPrimarySite != NULL)
    {
      hr = pPrimarySite->GetNewObjExt()->WriteData(GetWnd(), uContext);
      if (FAILED(hr))
        hr = pPrimarySite->GetNewObjExt()->OnError(GetWnd(), hr, uContext);
    }
  }

  if (SUCCEEDED(hr))
  {
    // call the extensions to write data
    hr = m_siteManager.WriteExtensionData(GetWnd(), uContext);
    if (FAILED(hr))
    {
      if (pPrimarySite != NULL)
      {
        pPrimarySite->GetNewObjExt()->OnError(GetWnd(),hr, uContext);
      }
      m_siteManager.NotifyExtensionsOnError(GetWnd(), hr, uContext);
    }
  }
  return hr;
}


void CCreateNewObjectWizardBase::GetSummaryInfoHeader(CString& s)
{
  // by default, add just the name of object
  CString szFmt; 
  szFmt.LoadString(IDS_s_CREATE_NEW_SUMMARY_NAME);
  CString szBuffer;
  szBuffer.Format((LPCWSTR)szFmt, GetInfo()->GetName());
  s += szBuffer;
}


void CCreateNewObjectWizardBase::GetSummaryInfo(CString& s)
{
  // if we have a primary site, tell it to do it all
  CWizExtensionSite* pPrimarySite = m_siteManager.GetPrimaryExtensionSite();
  if (pPrimarySite != NULL)
  {
    // the primary extension has a chance to override
    // the default behavior
    if (!pPrimarySite->GetSummaryInfo(s))
    {
      // failed, we put up the default header
      GetSummaryInfoHeader(s);
    }
  }
  else
  {
    GetSummaryInfoHeader(s);

    // go first through our pages
	  for (int i = 0; i < m_pages.GetSize(); i++)
	  {
      CCreateNewObjectPageBase* pPage = m_pages[i];
      if (pPage != m_pFinishPage)
      {
        CString szTemp;
        pPage->GetSummaryInfo(szTemp);
        if (!szTemp.IsEmpty())
        {
          s += L"\n";
          s += szTemp;
        }
      }
    } // for

    s += L"\n";

  } // if

  // go through the extension pages
  m_siteManager.GetExtensionsSummaryInfo(s);
}

HRESULT CCreateNewObjectWizardBase::RecreateObject()
{
  CWizExtensionSite* pPrimarySite = m_siteManager.GetPrimaryExtensionSite();

  // remove object from backend
  HRESULT hr = m_pNewADsObjectCreateInfo->HrDeleteFromBackend();
  if (FAILED(hr))
  {
    ASSERT(m_pNewADsObjectCreateInfo->PGetIADsPtr() != NULL);
    // could not delete from backend (possibly for lack of delete right)

    HRESULT hrDeleteFail = E_FAIL;
    if (pPrimarySite != NULL)
    {
      hrDeleteFail = pPrimarySite->GetNewObjExt()->OnError(GetWnd(), hr, DSA_NEWOBJ_CTX_CLEANUP);
    }

    if (FAILED(hrDeleteFail))
    {
      // put out a warning
      ReportErrorEx(m_hWnd,IDS_CANT_DELETE_BAD_NEW_OBJECT,S_OK,
                       MB_OK, NULL, 0);
    }
    return hr; 
  }

  // tell all the extensions to release the temporary object
  ASSERT(m_pNewADsObjectCreateInfo->PGetIADsPtr() == NULL);
  m_siteManager.SetObject(NULL);

  if (pPrimarySite != NULL)
  {
    hr = pPrimarySite->GetNewObjExt()->WriteData(GetWnd(), DSA_NEWOBJ_CTX_CLEANUP);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
      return hr;
  }
  else
  {
    // collect data from the primary pages
	  // the first of them will do a create new
    for (int i = 0; i < m_pages.GetSize(); i++)
	  {
      CCreateNewObjectPageBase* pPage = m_pages[i];
      if (pPage != m_pFinishPage)
      {
        hr = ((CCreateNewObjectDataPage*)pPage)->OnPreCommit(TRUE);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr))
          return hr; // some of the primary pages failed
      }
    } // for
  }
  
  // tell the extensions about the new object
  ASSERT(m_pNewADsObjectCreateInfo->PGetIADsPtr() != NULL);
  m_siteManager.SetObject(m_pNewADsObjectCreateInfo->PGetIADsPtr());

  // collect data from extensions
  hr = WriteData(DSA_NEWOBJ_CTX_CLEANUP);
  return hr;
}

BOOL CCreateNewObjectWizardBase::OnFinish() 
{
  CWaitCursor wait;

  BOOL bRetVal = TRUE; // default is dismiss

  // before doing the commit give the extensions a chance to 
  // write their data
  BOOL bPostCommit = FALSE;
  HRESULT hr = WriteData(DSA_NEWOBJ_CTX_PRECOMMIT);
  if (FAILED(hr))
    return FALSE; // do not dismiss

  // do the commit to the backend
  hr = m_pNewADsObjectCreateInfo->HrSetInfo(TRUE /*fSilentError*/);
  if (FAILED(hr))
  {
    // if present, the primary extension will have to handle the failure
    // by displaying an error message
    HRESULT hrSetInfoFail = E_FAIL;
    CWizExtensionSite* pPrimarySite = m_siteManager.GetPrimaryExtensionSite();
    if (pPrimarySite != NULL)
    {
      hrSetInfoFail = pPrimarySite->GetNewObjExt()->OnError(GetWnd(), hr, DSA_NEWOBJ_CTX_COMMIT);
    }

    if (FAILED(hrSetInfoFail))
    {
      // either no primary extension or not handled by it,
      // use the internal handler
      OnFinishSetInfoFailed(hr);      
    }
    return FALSE; // do not dismiss
  }


  // start the post commit phase
  bPostCommit = TRUE;
  m_pNewADsObjectCreateInfo->SetPostCommit(bPostCommit);
  hr = m_pNewADsObjectCreateInfo->HrAddDefaultAttributes();
  if (FAILED(hr))
    return FALSE; // do not dismiss

  BOOL bNeedDeleteFromBackend = FALSE;

  if (SUCCEEDED(hr))
  {
    // the commit went well, need to tell the primary pages and
    // the extensions to write
    hr = WriteData(DSA_NEWOBJ_CTX_POSTCOMMIT);
    if (FAILED(hr))
    {
      bNeedDeleteFromBackend = TRUE;
    }
  }
  m_pNewADsObjectCreateInfo->SetPostCommit(/*bPostCommit*/FALSE); // restore

  // failed the post commit, try to remove from
  // the backend and recreate a valid temporary object
  if (bNeedDeleteFromBackend)
  {
    ASSERT(bRetVal); // the wizard would be hosed
    hr = RecreateObject();
    if (FAILED(hr))
    {
      // we are really up creek
      bRetVal = TRUE; //bail out, the m_hrReturnValue will be set below
      hr = S_FALSE; // avoid error message in the snapin
    }
    else
    {
      // we deleted the committed object, we can keep the wizard up 
      return FALSE;
    }
  }

  if (bRetVal)
  {
    // we are actually dismissing the wizard,
    // set the hr value that will be returned by the modal wizard call itself
    m_hrReturnValue = hr;
  }
  return bRetVal;
}


void CCreateNewObjectWizardBase::OnFinishSetInfoFailed(HRESULT hr)
{
  PVOID apv[1] = {(LPWSTR)m_pNewADsObjectCreateInfo->GetName()};
  ReportErrorEx(GetWnd(),IDS_12_GENERIC_CREATION_FAILURE,hr,
                 MB_OK | MB_ICONERROR, apv, 1);
}

void CCreateNewObjectWizardBase::LoadCaptions()
{
  
  // compute the caption only the first time
  if (m_szCaption.IsEmpty())
  {
    LPCTSTR pszObjectClass = GetInfo()->m_pszObjectClass;
    ASSERT(pszObjectClass != NULL);
    ASSERT(lstrlen(pszObjectClass) > 0);
    WCHAR szFriendlyName[256];
    GetInfo()->GetBasePathsInfo()->GetFriendlyClassName(pszObjectClass, szFriendlyName, 256);
    
    UINT nCaptionRes = (GetInfo()->GetCopyFromObject() == NULL) ? 
                  IDS_s_CREATE_NEW : IDS_s_COPY;

    m_szCaption.Format(nCaptionRes, szFriendlyName);
    ASSERT(!m_szCaption.IsEmpty());
  }  
  if (m_szOKButtonCaption.IsEmpty())
  {
    m_szOKButtonCaption.LoadString(IDS_WIZARD_OK);
  }
}

HICON CCreateNewObjectWizardBase::GetClassIcon()
{
  if (m_hClassIcon == NULL)
  {
    DWORD dwFlags = DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON;
    if (GetInfo()->IsContainer())
      dwFlags |= DSGIF_DEFAULTISCONTAINER;
    m_hClassIcon = GetInfo()->GetBasePathsInfo()->GetIcon(GetInfo()->m_pszObjectClass, 
                              dwFlags, 32,32);
  }
  return m_hClassIcon;
}

HRESULT CCreateNewObjectWizardBase::InitPrimaryExtension()
{
  ASSERT(m_pNewADsObjectCreateInfo != NULL);

  HRESULT hr = m_siteManager.CreatePrimaryExtension(
                              &(m_pNewADsObjectCreateInfo->GetCreateInfo()->clsidWizardPrimaryPage),
                              m_pNewADsObjectCreateInfo->m_pIADsContainer,
                              m_pNewADsObjectCreateInfo->m_pszObjectClass);
  return hr;
}


/////////////////////////////////////////////////////////////////////
// CIconCtrl

BEGIN_MESSAGE_MAP(CIconCtrl, CStatic)
  ON_WM_PAINT()
END_MESSAGE_MAP()

void CIconCtrl::OnPaint()
{
  PAINTSTRUCT ps;
  CDC* pDC = BeginPaint(&ps);
  if (m_hIcon != NULL)
    pDC->DrawIcon(0, 0, m_hIcon); 
  EndPaint(&ps);
}


/////////////////////////////////////////////////////////////////////
// CCreateNewObjectPageBase

#define WM_FORMAT_CAPTION (WM_USER+1)

BEGIN_MESSAGE_MAP(CCreateNewObjectPageBase, CPropertyPageEx_Mine)
  ON_MESSAGE(WM_FORMAT_CAPTION, OnFormatCaption )
END_MESSAGE_MAP()

CCreateNewObjectPageBase::CCreateNewObjectPageBase(UINT nIDTemplate)
      : CPropertyPageEx_Mine(nIDTemplate)
{
  m_pWiz = NULL;          
}          

BOOL CCreateNewObjectPageBase::OnInitDialog()
{
  CPropertyPageEx_Mine::OnInitDialog();

  // set the name of the container
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();
  SetDlgItemText(IDC_EDIT_CONTAINER,
                  pNewADsObjectCreateInfo->GetContainerCanonicalName());

  // set the class icon
  VERIFY(m_iconCtrl.SubclassDlgItem(IDC_STATIC_ICON, this));
  m_iconCtrl.SetIcon(GetWiz()->GetClassIcon()); 

  return TRUE;
}

BOOL CCreateNewObjectPageBase::OnSetActive()
{
  BOOL bRet = CPropertyPageEx_Mine::OnSetActive();
  PostMessage(WM_FORMAT_CAPTION);
  return bRet;
}


LONG CCreateNewObjectPageBase::OnFormatCaption(WPARAM, LPARAM)
{
  // set the title of the Wizard window
  HWND hWndSheet = ::GetParent(m_hWnd);
  ASSERT(::IsWindow(hWndSheet));
  ::SetWindowText(hWndSheet, (LPCWSTR)GetWiz()->GetCaption());
  return 0;
}


/////////////////////////////////////////////////////////////////////
// CCreateNewObjectDataPage


CCreateNewObjectDataPage::CCreateNewObjectDataPage(UINT nIDTemplate)
: CCreateNewObjectPageBase(nIDTemplate)
{
  m_bFirstTimeGetDataCalled = TRUE;
}

BOOL CCreateNewObjectDataPage::OnSetActive()
{
  BOOL bValid = FALSE;
  if (m_bFirstTimeGetDataCalled)
  {
    // first time we call, pass the IADs* pIADsCopyFrom pointer we copy from
    IADs* pIADsCopyFrom = GetWiz()->GetInfo()->GetCopyFromObject();
    bValid = GetData(pIADsCopyFrom);
    m_bFirstTimeGetDataCalled = FALSE;
  }
  else
  {
    bValid = GetData(NULL);
  }

  GetWiz()->SetWizardButtons(this, bValid);
  return CCreateNewObjectPageBase::OnSetActive();
}

LRESULT CCreateNewObjectDataPage::OnWizardNext()
{
  CWaitCursor wait;
  // move to next page only if SetData() succeeded
  if (SUCCEEDED(SetData()))
  {
    // if this is the last primary page, notify the extensions
    GetWiz()->SetObjectForExtensions(this);
    return 0; // move to the next page
  }
  return -1; // do not advance
}

LRESULT CCreateNewObjectDataPage::OnWizardBack()
{
  // move to prev page only if SetData() succeeded
  return SUCCEEDED(SetData()) ? 0 : -1;
}

BOOL CCreateNewObjectDataPage::OnKillActive()
{
  // we do not know what page it will jump to, so we
  // set it to the most sensible choice for an extension
  GetWiz()->SetWizardButtonsMiddle(TRUE);
  return CCreateNewObjectPageBase::OnKillActive();
}

BOOL CCreateNewObjectDataPage::OnWizardFinish()
{
  // this method is called only if this page is the 
  // last one  (that is this is the only primary native page
  // and there are no pages from secondary extensions)
  if (FAILED(SetData()))
    return FALSE;

  // notify the extensions of a new IADs* pointer
  GetWiz()->SetObjectForExtensions(this);

  return GetWiz()->OnFinish();
}


/////////////////////////////////////////////////////////////////////
// CCreateNewObjectFinishPage

BEGIN_MESSAGE_MAP(CCreateNewObjectFinishPage, CCreateNewObjectPageBase)
  ON_EN_SETFOCUS(IDC_EDIT_SUMMARY, OnSetFocusEdit)
END_MESSAGE_MAP()


CCreateNewObjectFinishPage::CCreateNewObjectFinishPage()
: CCreateNewObjectPageBase(CCreateNewObjectFinishPage::IDD)
{
  m_bNeedSetFocus = FALSE;
}

BOOL CCreateNewObjectFinishPage::OnSetActive()
{
  // need to collect all info from pages
  // and put it in the summary info edit box
  CString szBuf;
  GetWiz()->GetSummaryInfo(szBuf);
  WriteSummary(szBuf);
  m_bNeedSetFocus = TRUE;

  GetWiz()->SetWizardButtons(this, TRUE);
  return CCreateNewObjectPageBase::OnSetActive();
}

BOOL CCreateNewObjectFinishPage::OnKillActive()
{
  GetWiz()->SetWizardButtonsMiddle(TRUE);
  return CCreateNewObjectPageBase::OnKillActive();
}

BOOL CCreateNewObjectFinishPage::OnWizardFinish()
{
  return GetWiz()->OnFinish();
}


void CCreateNewObjectFinishPage::OnSetFocusEdit()
{
  CEdit* pEdit = (CEdit*)GetDlgItem(IDC_EDIT_SUMMARY);
	pEdit->SetSel(-1,0, TRUE);
   if (m_bNeedSetFocus)
  {
    m_bNeedSetFocus = FALSE;
    TRACE(_T("Resetting Focus\n"));

    HWND hwndSheet = ::GetParent(m_hWnd);
    ASSERT(::IsWindow(hwndSheet));
    HWND hWndFinishCtrl =::GetDlgItem(hwndSheet, 0x3025);
    ASSERT(::IsWindow(hWndFinishCtrl));
    ::SetFocus(hWndFinishCtrl);
  }
}

void CCreateNewObjectFinishPage::WriteSummary(LPCWSTR lpszSummaryText)
{
  // allocate temporary buffer
  size_t nLen = wcslen(lpszSummaryText) + 1;
  WCHAR* pBuf = new WCHAR[nLen*2];
  if (!pBuf)
  {
    return;
  }

  // change '\n' into '\r\n' sequence
  LPCTSTR pSrc = lpszSummaryText;
  TCHAR* pDest = pBuf;
  while (*pSrc != NULL)
  {
    if ( ( pSrc != lpszSummaryText) && 
          (*(pSrc-1) != TEXT('\r')) && (*pSrc == TEXT('\n')) )
    {
      *(pDest++) = '\r';
    }
    *(pDest++) = *(pSrc++);
  }
  *pDest = NULL; // NULL terminate the destination buffer

  CEdit* pEdit = (CEdit*)GetDlgItem(IDC_EDIT_SUMMARY);
  pEdit->SetWindowText(pBuf);
  delete[] pBuf;
  pBuf = 0;
}

///////////////////////////////////////////////////////////////////
// CCreateNewNamedObjectPage

BEGIN_MESSAGE_MAP(CCreateNewNamedObjectPage, CCreateNewObjectDataPage)
  ON_EN_CHANGE(IDC_EDIT_OBJECT_NAME, OnNameChange)
END_MESSAGE_MAP()

BOOL CCreateNewNamedObjectPage::ValidateName(LPCTSTR)
{
	return TRUE;
}

BOOL CCreateNewNamedObjectPage::OnInitDialog() 
{
  CCreateNewObjectDataPage::OnInitDialog();

  SetDlgItemText(IDC_EDIT_OBJECT_NAME, GetWiz()->GetInfo()->m_strDefaultObjectName);
  return TRUE;
}

BOOL CCreateNewNamedObjectPage::GetData(IADs*)
{
  return !m_strName.IsEmpty();
}

void CCreateNewNamedObjectPage::OnNameChange()
{
  GetDlgItemText(IDC_EDIT_OBJECT_NAME, OUT m_strName);
  m_strName.TrimLeft();
  m_strName.TrimRight();
  // Enable the OK button only if the name is not empty
  GetWiz()->SetWizardButtons(this, !m_strName.IsEmpty());
}

HRESULT CCreateNewNamedObjectPage::SetData(BOOL)
{
  if ( !ValidateName( m_strName ) )
	return E_INVALIDARG;
  // Store the object name in the temporary storage
  HRESULT hr = GetWiz()->GetInfo()->HrCreateNew(m_strName);
  return hr;
}

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW CN UNC WIZARD

BEGIN_MESSAGE_MAP(CCreateNewVolumePage, CCreateNewObjectDataPage)
  ON_EN_CHANGE(IDC_EDIT_OBJECT_NAME, OnNameChange)
  ON_EN_CHANGE(IDC_EDIT_UNC_PATH, OnPathChange)
END_MESSAGE_MAP()

CCreateNewVolumePage::CCreateNewVolumePage()
: CCreateNewObjectDataPage(CCreateNewVolumePage::IDD)
{
}

BOOL CCreateNewVolumePage::OnInitDialog() 
{
  CCreateNewObjectDataPage::OnInitDialog();
  SetDlgItemText(IDC_EDIT_OBJECT_NAME, GetWiz()->GetInfo()->m_strDefaultObjectName);
  Edit_LimitText(GetDlgItem(IDC_EDIT_OBJECT_NAME)->m_hWnd, 64);
  Edit_LimitText (GetDlgItem(IDC_EDIT_UNC_PATH)->m_hWnd, MAX_PATH - 1);
  return TRUE;
}

void CCreateNewVolumePage::OnNameChange()
{
  GetDlgItemText(IDC_EDIT_OBJECT_NAME, OUT m_strName);
  m_strName.TrimLeft();
  m_strName.TrimRight();
  _UpdateUI();
}

void CCreateNewVolumePage::OnPathChange()
{
  GetDlgItemText(IDC_EDIT_UNC_PATH, OUT m_strUncPath);
  m_strUncPath.TrimLeft();
  m_strUncPath.TrimRight();
  _UpdateUI();
}

void CCreateNewVolumePage::_UpdateUI()
{
  //
  // Enable the OK button only if both name and path are not empty and it is a valid 
  // UNC path
  //
  BOOL bIsValidShare = FALSE;
  DWORD dwPathType = 0;
  if (!I_NetPathType(NULL, (PWSTR)(PCWSTR)m_strUncPath, &dwPathType, 0) && dwPathType == ITYPE_UNC)
  {
    bIsValidShare = TRUE;
  }

  GetWiz()->SetWizardButtons(this, !m_strName.IsEmpty() && bIsValidShare);
}

BOOL CCreateNewVolumePage::GetData(IADs*)
{
  return !m_strName.IsEmpty() && !m_strUncPath.IsEmpty();
}

HRESULT CCreateNewVolumePage::SetData(BOOL)
{
  // Store the object name in the temporary storage
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();
  HRESULT hr = pNewADsObjectCreateInfo->HrCreateNew(m_strName);
  if (FAILED(hr))
  {
    return hr;
  }
  
  hr = pNewADsObjectCreateInfo->HrAddVariantBstr(const_cast<PWSTR>(gsz_uNCName), m_strUncPath);
  ASSERT(SUCCEEDED(hr));
  return hr;
}

CCreateNewVolumeWizard:: CCreateNewVolumeWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo) : 
    CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
{
  AddPage(&m_page1);
}

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW PRINT QUEUE WIZARD

BEGIN_MESSAGE_MAP(CCreateNewPrintQPage, CCreateNewObjectDataPage)
  ON_EN_CHANGE(IDC_EDIT_UNC_PATH, OnPathChange)
END_MESSAGE_MAP()


CCreateNewPrintQPage::CCreateNewPrintQPage() 
: CCreateNewObjectDataPage(CCreateNewPrintQPage::IDD)
{
}

BOOL CCreateNewPrintQPage::GetData(IADs*) 
{
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();

  CComPtr<IADs> spObj;
  HRESULT hr = pNewADsObjectCreateInfo->m_pIADsContainer->QueryInterface(
                  IID_IADs, (void **)&spObj);
  if (SUCCEEDED(hr)) 
  {
    CComBSTR bsPath;
    spObj->get_ADsPath (&bsPath);
    m_strContainer = bsPath;
  }
  return FALSE;
}

void CCreateNewPrintQPage::OnPathChange()
{
  GetDlgItemText(IDC_EDIT_UNC_PATH, OUT m_strUncPath);
  m_strUncPath.TrimLeft();
  m_strUncPath.TrimRight();
  _UpdateUI();
}

void CCreateNewPrintQPage::_UpdateUI()
{
  // Enable the OK button only if both name and path are not empty
  GetWiz()->SetWizardButtons(this, !m_strUncPath.IsEmpty());
}

HRESULT CCreateNewPrintQPage::SetData(BOOL bSilent)
{
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();

  CWaitCursor CWait;

  HINSTANCE hWinspool = NULL;
  BOOL (*pfnPublishPrinter)(HWND, PCWSTR, PCWSTR, PCWSTR, PWSTR *, DWORD);
  hWinspool = LoadLibrary(L"Winspool.drv");
  if (!hWinspool) 
  {
    INT Result2 = GetLastError();
    if (!bSilent)
    {
      PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strUncPath};
      ReportErrorEx (::GetParent(m_hWnd),IDS_12_FAILED_TO_CREATE_PRINTER,HRESULT_FROM_WIN32(Result2),
                     MB_OK | MB_ICONERROR, apv, 1);
    }
    return HRESULT_FROM_WIN32(Result2);
  }
  pfnPublishPrinter =   (BOOL (*)(HWND, PCWSTR, PCWSTR, PCWSTR, PWSTR *, DWORD)) 
                                GetProcAddress(hWinspool, (LPCSTR) 217);
  if (!pfnPublishPrinter) 
  {
    INT Result2 = GetLastError();
    if (!bSilent)
    {
      PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strUncPath};
      ReportErrorEx (::GetParent(m_hWnd),IDS_12_FAILED_TO_CREATE_PRINTER,HRESULT_FROM_WIN32(Result2),
                     MB_OK | MB_ICONERROR, apv, 1);
    }
    FreeLibrary(hWinspool);
    return HRESULT_FROM_WIN32(Result2);
  }


  BOOL Result = pfnPublishPrinter ( m_hWnd,
                                   (LPCWSTR)m_strUncPath,
                                   (LPCWSTR)m_strContainer,
                                   (LPCWSTR)NULL,
                                   &m_pwszNewObj,
                                   PUBLISHPRINTER_QUERY);

  FreeLibrary(hWinspool);


  if (!Result) 
  {
    INT Result2 = GetLastError();
    if (Result2 == ERROR_INVALID_LEVEL)
    {
      if (!bSilent)
      {
        ReportErrorEx (::GetParent(m_hWnd),IDS_CANT_CREATE_NT5_PRINTERS,S_OK,
                       MB_OK, NULL, 0);
      }
    } 
    else 
    {
      if (!bSilent)
      {
        PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strUncPath};
        ReportErrorEx (::GetParent(m_hWnd),IDS_12_FAILED_TO_CREATE_PRINTER,HRESULT_FROM_WIN32(Result2),
                       MB_OK | MB_ICONERROR, apv, 1);
      }
    }
    return HRESULT_FROM_WIN32(Result2);
  } 
  else 
  {
    IADs* pIADs = NULL;
    HRESULT hr = DSAdminOpenObject(m_pwszNewObj,
                                   IID_IADs, 
                                   (void **)&pIADs,
                                   TRUE /*bServer*/);
  
    GlobalFree(m_pwszNewObj);
    m_pwszNewObj = NULL;

    if (SUCCEEDED(hr)) 
    {
      pNewADsObjectCreateInfo->SetIADsPtr(pIADs);
      pIADs->Release(); // addref'd by the above Set()
    } 
    else 
    {
      if (!bSilent)
      {
        PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strUncPath};
        ReportErrorEx (m_hWnd,IDS_12_FAILED_TO_ACCESS_PRINTER,hr,
                       MB_OK | MB_ICONERROR, apv, 1);  
      }
      return hr;
    }

  }
  return S_OK;
}

CCreateNewPrintQWizard:: CCreateNewPrintQWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo) : 
    CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
{
  AddPage(&m_page1);
}

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW COMPUTER WIZARD

BEGIN_MESSAGE_MAP(CCreateNewComputerPage, CCreateNewObjectDataPage)
  ON_EN_CHANGE(IDC_EDIT_DNS_NAME, OnNameChange)
  ON_EN_CHANGE(IDC_EDIT_SAM_NAME, OnSamNameChange)
  ON_BN_CLICKED(IDC_CHANGE_PRINCIPAL_BUTTON, OnChangePrincipalButton)
END_MESSAGE_MAP()

CCreateNewComputerPage::CCreateNewComputerPage()
: CCreateNewObjectDataPage(CCreateNewComputerPage::IDD)
{
}

BOOL CCreateNewComputerPage::OnInitDialog() 
{
  Edit_LimitText (GetDlgItem(IDC_EDIT_DNS_NAME)->m_hWnd, 63);
  Edit_LimitText (GetDlgItem(IDC_EDIT_SAM_NAME)->m_hWnd, 15);

  CCreateNewObjectDataPage::OnInitDialog();

  CString szDefault;
  szDefault.LoadString(IDS_NEW_COMPUTER_PRINCIPAL_DEFAULT);
  SetDlgItemText(IDC_PRINCIPAL_EDIT, szDefault);

  return TRUE;
}

BOOL CCreateNewComputerPage::GetData(IADs*) 
{
  return !m_strName.IsEmpty(); //we need a computer name
}





inline LPWSTR WINAPI MyA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp)
{
	ATLASSERT(lpa != NULL);
	ATLASSERT(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
	return lpw;
}


#define A2W_OEM(lpa) (\
	((_lpaMine = lpa) == NULL) ? NULL : (\
		_convert = (lstrlenA(_lpaMine)+1),\
		MyA2WHelper((LPWSTR) alloca(_convert*2), _lpaMine, _convert, CP_OEMCP)))


void _UnicodeToOemConvert(IN PCWSTR pszUnicode, OUT CString& szOemUnicode)
{
  USES_CONVERSION;

  // add this for the macro to work
  PCSTR _lpaMine = NULL;

  // convert to CHAR OEM
  int nLen = lstrlen(pszUnicode);
  PSTR pszOemAnsi = new CHAR[3*(nLen+1)]; // more, to be sure...
  if (pszOemAnsi)
  {
    CharToOem(pszUnicode, pszOemAnsi);

    // convert it back to WCHAR on OEM CP
    szOemUnicode = A2W_OEM(pszOemAnsi);
    delete[] pszOemAnsi;
    pszOemAnsi = 0;
  }
}

void CCreateNewComputerPage::OnNameChange()
{
  GetDlgItemText(IDC_EDIT_DNS_NAME, OUT m_strName);
  m_strName.TrimLeft();
  m_strName.TrimRight();
  
  // generate a SAM account name from the name
  CONST DWORD computerNameLen = 32;
  DWORD Len = computerNameLen;
  WCHAR szDownLevel[computerNameLen];

  if (m_strName.IsEmpty())
  {
    Len = 0;
  }
  else
  {
    // generate the SAM account name from CN

    // run through the OEM conversion, just to
    // behave the same way as typing in the OEM
    // edit box
    CString szOemUnicode;
    _UnicodeToOemConvert(m_strName, szOemUnicode);
    //TRACE(L"szOemUnicode = %s\n", (LPCWSTR)szOemUnicode);
  
    // run through the DNS validation
    if (!DnsHostnameToComputerName((LPWSTR)(LPCWSTR)szOemUnicode, szDownLevel, &Len))
    {
      Len = 0;
    }
  }

  if (Len > 0)
  {
    m_strSamName = szDownLevel;
  }
  else
  {
    m_strSamName.Empty();
  }

  SetDlgItemText(IDC_EDIT_SAM_NAME, m_strSamName);

  GetWiz()->SetWizardButtons(this, 
            !m_strName.IsEmpty() && !m_strSamName.IsEmpty());
}

void CCreateNewComputerPage::OnSamNameChange()
{
  GetDlgItemText(IDC_EDIT_SAM_NAME, OUT m_strSamName);

  GetWiz()->SetWizardButtons(this, 
            !m_strName.IsEmpty() && !m_strSamName.IsEmpty());
}


HRESULT CCreateNewComputerPage::_ValidateSamName()
{
  ASSERT(!m_strSamName.IsEmpty());

  // prep name for error if needed
  PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strSamName};
  
  CONST DWORD computerNameLen = 32;
  DWORD Len = computerNameLen;
  WCHAR szDownLevel[computerNameLen];
  UINT status = 0;
  UINT answer = IDNO;

  NET_API_STATUS netstatus = I_NetNameValidate( 0,
                                             (LPWSTR)(LPCWSTR)m_strSamName,
                                             NAMETYPE_COMPUTER,
                                             0);
  if (netstatus != NERR_Success) {
    ReportErrorEx(m_hWnd,IDS_12_INVALID_SAM_COMPUTER_NAME,HRESULT_FROM_WIN32(netstatus),
                   MB_OK | MB_ICONERROR, apv, 1);
    return HRESULT_FROM_WIN32(netstatus);
  }    

  status = DnsValidateDnsName_W((LPWSTR)(LPCWSTR)m_strSamName);
  if (status == DNS_ERROR_NON_RFC_NAME) {
    answer = ReportErrorEx(m_hWnd,IDS_12_NON_RFC_SAM_COMPUTER_NAME,HRESULT_FROM_WIN32(status),
                           MB_YESNO | MB_ICONWARNING, apv, 1);
    if (answer == IDNO) {
      return HRESULT_FROM_WIN32(status);
    }
  } else {
    if (status != ERROR_SUCCESS) {
      ReportErrorEx(m_hWnd,IDS_12_INVALID_SAM_COMPUTER_NAME,HRESULT_FROM_WIN32(status),
                    MB_OK | MB_ICONERROR, apv, 1);
      return HRESULT_FROM_WIN32(status);
    }
  }

  if (m_strSamName.Find(L".") >= 0) {
    ReportErrorEx(m_hWnd,IDS_12_SAM_COMPUTER_NAME_DOTTED,S_OK/*ignored*/,
                   MB_OK | MB_ICONERROR, apv, 1);
    return HRESULT_FROM_WIN32(DNS_STATUS_DOTTED_NAME);
  }


  // further validate the SAM account name, to make sure it did not get changed
  
  BOOL bValidSamName = 
        DnsHostnameToComputerName((LPWSTR)(LPCWSTR)m_strSamName, szDownLevel, &Len);

  TRACE(L"DnsHostnameToComputerName(%s) returned szDownLevel = %s and bValidSamName = 0x%x\n", 
                        (LPCWSTR)m_strSamName, szDownLevel, bValidSamName);


  if (!bValidSamName || (_wcsicmp(m_strSamName, szDownLevel) != 0))
  {
    ReportErrorEx(m_hWnd,IDS_12_SAM_COMPUTER_NAME_NOT_VALIDATED, S_OK/*ignored*/,
                   MB_OK | MB_ICONERROR, apv, 1);

    return E_FAIL;
  }


  return S_OK;
}


HRESULT CCreateNewComputerPage::_ValidateName()
{
  // prep name for error if needed
  PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strName};
  
  UINT status = 0;
  UINT answer = IDNO;

  NET_API_STATUS netstatus = I_NetNameValidate( 0,
                                             (LPWSTR)(LPCWSTR)m_strName,
                                             NAMETYPE_COMPUTER,
                                             0);
  if (netstatus != NERR_Success) {
    ReportErrorEx(m_hWnd,IDS_12_INVALID_COMPUTER_NAME,HRESULT_FROM_WIN32(netstatus),
                   MB_OK | MB_ICONERROR, apv, 1);
    return HRESULT_FROM_WIN32(netstatus);
  }    

  status = DnsValidateDnsName_W((LPWSTR)(LPCWSTR)m_strName);
  if (status == DNS_ERROR_NON_RFC_NAME) {
    answer = ReportErrorEx(m_hWnd,IDS_12_NON_RFC_COMPUTER_NAME,HRESULT_FROM_WIN32(status),
                           MB_YESNO | MB_ICONWARNING, apv, 1);
    if (answer == IDNO) {
      return HRESULT_FROM_WIN32(status);
    }
  } else {
    if (status != ERROR_SUCCESS) {
      ReportErrorEx(m_hWnd,IDS_12_INVALID_COMPUTER_NAME,HRESULT_FROM_WIN32(status),
                    MB_OK | MB_ICONERROR, apv, 1);
      return HRESULT_FROM_WIN32(status);
    }
  }

  if (m_strName.Find(L".") >= 0) {
    ReportErrorEx(m_hWnd,IDS_12_COMPUTER_NAME_DOTTED,S_OK/*ignored*/,
                   MB_OK | MB_ICONERROR, apv, 1);
    return HRESULT_FROM_WIN32(DNS_STATUS_DOTTED_NAME);
  }
  return S_OK;
}

HRESULT CCreateNewComputerPage::SetData(BOOL)
{
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();

  // name validation
  HRESULT hr = _ValidateName();
  if (FAILED(hr))
  {
    TRACE(L"_ValidateName() failed\n");
    return hr;
  }

  hr = _ValidateSamName();
  if (FAILED(hr))
  {
    TRACE(L"_ValidateSamName() failed\n");
    return hr;
  }

  // do object creation
  hr = pNewADsObjectCreateInfo->HrCreateNew(m_strName);
  if (FAILED(hr))
  {
    return hr;
  }

  // create the ADSI attribute by adding $ at the end
  CString szTemp = m_strSamName + L"$";
  hr = pNewADsObjectCreateInfo->HrAddVariantBstr(const_cast<PWSTR>(gsz_samAccountName), szTemp);

  // set the account type and the desired flags
  LONG lFlags = UF_WORKSTATION_TRUST_ACCOUNT | UF_ACCOUNTDISABLE | UF_PASSWD_NOTREQD;
  hr = pNewADsObjectCreateInfo->HrAddVariantLong(const_cast<PWSTR>(gsz_userAccountControl), lFlags);

  ASSERT(SUCCEEDED(hr));

  return hr;
}

HRESULT CCreateNewComputerPage::OnPostCommit(BOOL bSilent)
{
  HRESULT hr;
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();
  IADs * pIADs = NULL;
  IADsUser * pIADsUser = NULL;
  BOOL bSetPasswordOK = FALSE;
  BOOL bSetSecurityOK = FALSE;

  //prepare for error message, if needed
  PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strName};
  
  // The object was created successfully, so try to update some other attributes

  // try to set the password
  pIADs = pNewADsObjectCreateInfo->PGetIADsPtr();
  ASSERT(pIADs != NULL);
  hr = pIADs->QueryInterface(IID_IADsUser, OUT (void **)&pIADsUser);
  if (FAILED(hr) && !bSilent)
  {
    ASSERT(FALSE); // should never get here in normal operations
    ReportErrorEx(::GetParent(m_hWnd),IDS_ERR_FATAL,hr,
               MB_OK | MB_ICONERROR, NULL, 0);
  }
  else
  {
    ASSERT(pIADsUser != NULL);
    
    if (IsDlgButtonChecked(IDC_NT4_CHECK))
    {
      // NT 4 password, "$<computername>"
      CString szPassword;
      szPassword = m_strSamName;
      szPassword = szPassword.Left(14);
      INT loc = szPassword.Find(L"$");
      if (loc > 0) {
        szPassword = szPassword.Left(loc);
      }
      szPassword.MakeLower();
      CWaitCursor cwait;

      TRACE(L"Setting NT 4 style password\n");
      hr = pIADsUser->SetPassword(const_cast<LPTSTR>((LPCTSTR)szPassword));
    }
    else
    {
      // W2K password, randomly generated. The generated password
      // is not necessarily readable
      CWaitCursor cwait;
      HCRYPTPROV hCryptProv = NULL;
      if (::CryptAcquireContext(&hCryptProv, NULL, NULL, 
                                      PROV_RSA_FULL, 
                                      CRYPT_SILENT|CRYPT_VERIFYCONTEXT))
      {
        int nChars = 14; // password length
        WCHAR* pszPassword = new WCHAR[nChars+1]; // allow one more for NULL
        if (!pszPassword)
        {
          return E_OUTOFMEMORY;
        }

        if (::CryptGenRandom(hCryptProv, (nChars*sizeof(WCHAR)), (BYTE*)pszPassword))
        {
          // there is a VERY REMOTE possibility of a 16 bit
          // pattern of all zeroes that looks like a WCHAR NULL
          // so we check this and we substitute an arbitrary value
          for (int k=0; k<nChars; k++)
          {
            if (pszPassword[k] == NULL)
              pszPassword[k] = 0x1; // arbitrary
          }
          // put a NULL at the end
          pszPassword[nChars] = NULL;
          ASSERT(lstrlen(pszPassword) == nChars);

          TRACE(L"Setting W2K random password\n");
          hr = pIADsUser->SetPassword(pszPassword);
        }
        else
        {
          // CryptGenRandom() failed 
          hr = HRESULT_FROM_WIN32(::GetLastError());
        }
        ::CryptReleaseContext(hCryptProv, 0x0);
        delete[] pszPassword;
        pszPassword = 0;
      }
      else
      {
        // CryptAcquireContext() failed 
        hr = HRESULT_FROM_WIN32(::GetLastError());
      }
    } // QI

    if (SUCCEEDED(hr))
    {
      bSetPasswordOK = TRUE;
    }
    else
    {
      if (!bSilent)
      {
        ReportErrorEx (::GetParent(m_hWnd),IDS_12_CANT_SET_COMP_PWD,hr,
                       MB_OK | MB_ICONWARNING, apv, 1);
      }
    }
    pIADsUser->Release();
  }
  
  // try to write ACL
  hr = S_OK;
  if (m_securityPrincipalSidHolder.Get() == NULL)
  {
    // no need to set the ACL, we are fine
    bSetSecurityOK = TRUE;
  }
  else
  {
    CWaitCursor cwait;
    hr = SetSecurity();
  }
  if (SUCCEEDED(hr))
  {
    bSetSecurityOK = TRUE;
  }
  else
  {
    TRACE1("INFO: Unable to set security for computer %s.\n", (LPCTSTR)m_strName);
    if (!bSilent)
    {
      ReportErrorEx (::GetParent(m_hWnd),IDS_12_UNABLE_TO_WRITE_COMP_ACL,hr,
                     MB_OK | MB_ICONWARNING, apv, 1);
    }
  }

  hr = S_OK;
  if (bSetPasswordOK && bSetSecurityOK)
  {
    // success on the first steps, finally can enable the account
    CComVariant varAccount;
    hr = pNewADsObjectCreateInfo->HrGetAttributeVariant(const_cast<PWSTR>(gsz_userAccountControl), OUT &varAccount);
    if (SUCCEEDED(hr))
    {
      // got user account control, can change flag
      ASSERT(varAccount.vt == VT_I4);
      varAccount.lVal &= ~UF_ACCOUNTDISABLE;
  
      hr = pNewADsObjectCreateInfo->HrAddVariantLong(const_cast<PWSTR>(gsz_userAccountControl), varAccount.lVal);
      
      if (SUCCEEDED(hr))
      {
        // Try to persist the changes
        CWaitCursor cwait;
        hr = pNewADsObjectCreateInfo->HrSetInfo(TRUE /* fSilentError */);
      }
    }
    // handle errors, if any
    if (FAILED(hr)) 
    {
      TRACE1("INFO: Unable to commit account control for computer %s.\n", (LPCTSTR)m_strName);
      if (!bSilent)
      {
        ReportErrorEx (::GetParent(m_hWnd),IDS_12_UNABLE_TO_WRITE_ACCT_CTRL,hr,
                       MB_OK | MB_ICONWARNING, apv, 1);
      }
      hr = S_OK; // treat as a warning, the account is left disabled
    }
  }
  return hr;
} 

#define FILTER_ONE (UGOP_USERS | \
                    UGOP_ACCOUNT_GROUPS_SE | \
                    UGOP_RESOURCE_GROUPS_SE | \
                    UGOP_UNIVERSAL_GROUPS_SE | \
                    UGOP_BUILTIN_GROUPS | \
                    UGOP_WELL_KNOWN_PRINCIPALS_USERS \
                    )


#define FILTER_TWO (UGOP_USERS | \
                    UGOP_ACCOUNT_GROUPS_SE | \
                    UGOP_UNIVERSAL_GROUPS_SE | \
                    UGOP_WELL_KNOWN_PRINCIPALS_USERS | \
                    UGOP_USERS | \
                    UGOP_GLOBAL_GROUPS | \
                    UGOP_ALL_NT4_WELLKNOWN_SIDS \
                    )



void CCreateNewComputerPage::GetSummaryInfo(CString& s)
{
  if (IsDlgButtonChecked(IDC_NT4_CHECK))
  {
    CString sz;
    sz.LoadString(IDS_COMPUTER_CREATE_DLG_NT4_ACCOUNT);
    s += sz;
    s += L"\n";
  }
}



HRESULT CCreateNewComputerPage::_LookupSamAccountNameFromSid(PSID pSid, 
                                                             CString& szSamAccountName)
{
  HRESULT hr = S_OK;
  // need to use the SID and lookup the SAM account name
  WCHAR szName[MAX_PATH], szDomain[MAX_PATH];
  DWORD cchName = MAX_PATH-1, cchDomain = MAX_PATH-1;
  SID_NAME_USE sne;

  LPCWSTR lpszServerName = GetWiz()->GetInfo()->GetBasePathsInfo()->GetServerName();
  if (!LookupAccountSid(lpszServerName, pSid, szName, &cchName, szDomain, &cchDomain, &sne))
  {
    DWORD dwErr = GetLastError();
    TRACE(_T("LookupAccountSid failed with error %d\n"), dwErr);
    return HRESULT_FROM_WIN32(dwErr);
  }

  szSamAccountName = szDomain;
  szSamAccountName += L"\\";
  szSamAccountName += szName;
  return hr;
}





DSOP_SCOPE_INIT_INFO g_aComputerPrincipalDSOPScopes[] =
{
#if 0
    {
        cbSize,
        flType,
        flScope,
        {
            { flBothModes, flMixedModeOnly, flNativeModeOnly },
            flDownlevel,
        },
        pwzDcName,
        pwzADsPath,
        hr // OUT
    },
#endif

    // The Global Catalog
    {
        sizeof(DSOP_SCOPE_INIT_INFO),
        DSOP_SCOPE_TYPE_GLOBAL_CATALOG,
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS | DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS,
        {
            { DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS | 
              DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_SE | 
              DSOP_FILTER_WELL_KNOWN_PRINCIPALS, 0, 0 },
            0,
        },
        NULL,
        NULL,
        S_OK
    },

    // The domain to which the target computer is joined.
    {
        sizeof(DSOP_SCOPE_INIT_INFO),
        DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,
        DSOP_SCOPE_FLAG_STARTING_SCOPE |
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS | DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS,
        {
          // joined domain is always NT5 for DS ACLs Editor
          { 0, 
          //mixed: users, well known SIDs, local groups, builtin groups, global groups, computers
          DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS  | 
          DSOP_FILTER_WELL_KNOWN_PRINCIPALS | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE | 
          DSOP_FILTER_BUILTIN_GROUPS | DSOP_FILTER_GLOBAL_GROUPS_SE, 

          //native users, well known SIDs, local groups, builtin groups, global groups, universal groups, computers
          DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS  | DSOP_FILTER_WELL_KNOWN_PRINCIPALS | 
          DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE | DSOP_FILTER_BUILTIN_GROUPS |
          DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_UNIVERSAL_GROUPS_SE
          },
        0, // zero for downlevel joined domain, should be DS-aware
        },
        NULL,
        NULL,
        S_OK
    },

    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    {
        sizeof(DSOP_SCOPE_INIT_INFO),
        DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS | DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS,
        {
            { DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS | 
              DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_SE, 0, 0},
            0,
        },
        NULL,
        NULL,
        S_OK
    },

    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    {
        sizeof(DSOP_SCOPE_INIT_INFO),
        DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,
        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS | DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS,
        {
            { DSOP_FILTER_INCLUDE_ADVANCED_VIEW | DSOP_FILTER_USERS | 
              DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_SE, 0, 0},
            DSOP_DOWNLEVEL_FILTER_USERS | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS,
        },
        NULL,
        NULL,
        S_OK
    },
};





void CCreateNewComputerPage::OnChangePrincipalButton()
{
  static UINT cfDsObjectPicker = 0;
  if (cfDsObjectPicker == 0)
    cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);


  // create object picker COM object
  CComPtr<IDsObjectPicker> spDsObjectPicker;
  HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker, (void**)&spDsObjectPicker);
  if (FAILED(hr))
    return;

  // set init info
  DSOP_INIT_INFO InitInfo;
  ZeroMemory(&InitInfo, sizeof(InitInfo));

  InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
  InitInfo.pwzTargetComputer = GetWiz()->GetInfo()->GetBasePathsInfo()->GetServerName();
  InitInfo.cDsScopeInfos = sizeof(g_aComputerPrincipalDSOPScopes)/sizeof(DSOP_SCOPE_INIT_INFO);
  InitInfo.aDsScopeInfos = g_aComputerPrincipalDSOPScopes;
  InitInfo.flOptions = 0;
  InitInfo.cAttributesToFetch = 1;
  LPCWSTR lpszObjectSID = L"objectSid";
  InitInfo.apwzAttributeNames = const_cast<LPCTSTR *>(&lpszObjectSID);

  //
  // Loop through the scopes assigning the DC name
  //
  for (UINT idx = 0; idx < InitInfo.cDsScopeInfos; idx++)
  {
    InitInfo.aDsScopeInfos[idx].pwzDcName = GetWiz()->GetInfo()->GetBasePathsInfo()->GetServerName();
  }

  //
  // initialize object picker
  //
  hr = spDsObjectPicker->Initialize(&InitInfo);
  if (FAILED(hr))
    return;

  // invoke the dialog
  CComPtr<IDataObject> spdoSelections;

  hr = spDsObjectPicker->InvokeDialog(m_hWnd, &spdoSelections);
  if (hr == S_FALSE || !spdoSelections)
  {
    return;
  }

  // retrieve data from data object
  FORMATETC fmte = {(CLIPFORMAT)cfDsObjectPicker, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};
  PDS_SELECTION_LIST pDsSelList = NULL;

  hr = spdoSelections->GetData(&fmte, &medium);
  if (FAILED(hr))
    return;

  pDsSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);
  CComBSTR bsDN;

  if (pDsSelList != NULL)
  {
    ASSERT(pDsSelList->cItems == 1); // single selection


    TRACE(_T("pwzName = %s\n"), pDsSelList->aDsSelection[0].pwzName);
    TRACE(_T("pwzADsPath = %s\n"), pDsSelList->aDsSelection[0].pwzADsPath);
    TRACE(_T("pwzClass = %s\n"), pDsSelList->aDsSelection[0].pwzClass);
    TRACE(_T("pwzUPN = %s\n"), pDsSelList->aDsSelection[0].pwzUPN);

    // get the SID
    ASSERT(pDsSelList->aDsSelection[0].pvarFetchedAttributes != NULL);
    if (pDsSelList->aDsSelection[0].pvarFetchedAttributes[0].vt != VT_EMPTY)
    {
      ASSERT(pDsSelList->aDsSelection[0].pvarFetchedAttributes[0].vt == (VT_ARRAY | VT_UI1));
      PSID pSid = pDsSelList->aDsSelection[0].pvarFetchedAttributes[0].parray->pvData;
      ASSERT(IsValidSid(pSid));

      // deep copy SID
      if (!m_securityPrincipalSidHolder.Copy(pSid))
      {
        ASSERT(FALSE); // should never get here in normal operations
        ReportErrorEx(::GetParent(m_hWnd),IDS_ERR_FATAL,hr,
                 MB_OK | MB_ICONERROR, NULL, 0);
    	  goto Exit;
      }
    }


    UpdateSecurityPrincipalUI(&(pDsSelList->aDsSelection[0]));
  }
  else
  {
    PVOID apv[1] = {(LPWSTR)(pDsSelList->aDsSelection[0].pwzName)};
    ReportErrorEx(::GetParent(m_hWnd),IDS_12_CANT_GET_SAM_ACCNT_NAME,hr,
                   MB_OK | MB_ICONERROR, apv, 1);
    goto Exit;
  }

Exit:
  GlobalUnlock(medium.hGlobal);
  ReleaseStgMedium(&medium);

}



void CCreateNewComputerPage::UpdateSecurityPrincipalUI(PDS_SELECTION pDsSelection)
{
  TRACE(L"CCreateNewComputerPage::UpdateSecurityPrincipalUI()\n");

  HRESULT hr = S_OK;

  CString szText;

  LPWSTR pwzADsPath = pDsSelection->pwzADsPath;
  TRACE(L"pDsSelection->pwzADsPath = %s\n", pDsSelection->pwzADsPath);

  // get the X500 name (remove the provider ("LDAP://") in front of the name
  if ((pwzADsPath != NULL) && (pwzADsPath[0] != NULL)) 
  {
    CComBSTR bstrProvider;

    // need a fresh instance because we can set it to WINNT provider
    // and pretty much trash it (oh boy!!!)
    CPathCracker pathCracker;
    hr = pathCracker.Set(pwzADsPath, ADS_SETTYPE_FULL);
    if (FAILED(hr))
    {
      goto End;
    }
    hr = pathCracker.Retrieve(ADS_FORMAT_PROVIDER, &bstrProvider);
    TRACE(L"bstrProvider = %s\n", bstrProvider);
    if (FAILED(hr))
    {
      goto End;
    }

    if (_wcsicmp(bstrProvider, L"LDAP") == 0)
    {
      // it is an LDAP path, get the DN out of it
      // get the DN
      CComBSTR bstrDN;
      hr = pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
      if (FAILED(hr))
      {
        goto End;
      }

      // get the canonical name out of the DN
      LPWSTR pszCanonical = NULL;
      hr = ::CrackName((LPWSTR)bstrDN, &pszCanonical, GET_OBJ_CAN_NAME, NULL);
      if (pszCanonical != NULL)
      {
        szText = pszCanonical;
        ::LocalFreeStringW(&pszCanonical);
      }

    }
    else if (_wcsicmp(bstrProvider, L"WinNT") == 0)
    {
      // we got an NT 4.0 user or group,
      // the mpath is something like: "WinNT://mydomain/JoeB"
      CComBSTR bstrWindows;
      // get "mydomain/JoeB"
      hr = pathCracker.Retrieve(ADS_FORMAT_WINDOWS_DN, &bstrWindows);
      if (FAILED(hr))
      {
        goto End;
      }
      szText = bstrWindows;
      // flip the slash to reverse slash
      int nCh = szText.Find(L'/');
      if (nCh != -1)
      {
        szText.SetAt(nCh, L'\\');
      }
    }
  }

End:

  if (szText.IsEmpty())
  {
    szText = pDsSelection->pwzName;
  }

  SetDlgItemText(IDC_PRINCIPAL_EDIT, szText);
}






DWORD AddEntryInAcl(EXPLICIT_ACCESS* pAccessEntry,
						        PACL* ppDacl)

{
  TRACE(_T("AddEntryInAcl:\n"));

#ifdef DBG

  TRACE(_T("\tpAccessEntry->grfAccessPermissions: 0x%x\n"), pAccessEntry->grfAccessPermissions);
  TRACE(_T("\tpAccessEntry->grfAccessMode: 0x%x\n"), pAccessEntry->grfAccessMode);
  TRACE(_T("\tpAccessEntry->grfInheritance: 0x%x\n"), pAccessEntry->grfInheritance);

  TRACE(L"\n");

  TRUSTEE* pTrustee = &(pAccessEntry->Trustee);
  
  TRACE(L"\tpTrustee: 0x%x\n", pTrustee);
  if (pTrustee != NULL)
  {
    TRACE(L"\tpTrustee->TrusteeForm: 0x%x\n", pTrustee->TrusteeForm);
    TRACE(L"\tpTrustee->TrusteeType: 0x%x\n", pTrustee->TrusteeType);
  }

#endif // DBG


  // add an entry in the DACL
  PACL pOldDacl = *ppDacl;
  *ppDacl = NULL;

  TRACE(L"Calling SetEntriesInAcl()\n");

  DWORD dwErr = ::SetEntriesInAcl(1, pAccessEntry, pOldDacl, ppDacl);

  TRACE(L"SetEntriesInAcl() returned dwErr = 0x%x\n", dwErr);

  if (dwErr == ERROR_SUCCESS)
	{
		LocalFree(pOldDacl);
	}

  return dwErr;
}


HRESULT CCreateNewComputerPage::BuildNewAccessList(PACL* ppDacl)
{
  // SCHEMA.INI [User-Force-Change-Password], rightsGUID=00299570-246d-11d0-a768-00aa006e0529
  static GUID ResetPasswordGUID = 
  { 0x00299570, 0x246d, 0x11d0, { 0xa7, 0x68, 0x00, 0xaa, 0x00, 0x6e, 0x05, 0x29 } }; 

  // rightsGuid of CN=Validated-DNS-Host-Name,CN-Extended-Rights,CN=Configuration
  static GUID ValidatedDNSHostNameGUID =
  { 0x72e39547, 0x7b18, 0x11d1, { 0xad, 0xef, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xcd } };

  // rightsGuid of CN=Validated-SPN,CN-Extended-Rights,CN=Configuration
  static GUID ValidatedSPNGUID =
  { 0xf3a64788, 0x5306, 0x11d1, { 0xa9, 0xc5, 0x00, 0x00, 0xf8, 0x03, 0x67, 0xc1 } };

  // rightsGuid of CN=User-Account-Restrictions,CN-Extended-Rights,CN=Configuration
  static GUID UserAccountRestrictionsGUID =
  { 0x4c164200, 0x20c0, 0x11d0, { 0xa7, 0x68, 0x00, 0xaa, 0x00, 0x6e, 0x05, 0x29 } };

  // create an EXPLICIT_ACCESS struct
  EXPLICIT_ACCESS AccessEntry;
  ZeroMemory(&AccessEntry, sizeof(EXPLICIT_ACCESS));

  // initialize EXPLICIT_ACCESS
  AccessEntry.grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
  AccessEntry.grfAccessMode = GRANT_ACCESS;
  AccessEntry.grfInheritance = NO_INHERITANCE;


  OBJECTS_AND_SID ObjectsAndSid;
  ZeroMemory(&ObjectsAndSid, sizeof(OBJECTS_AND_SID));

  PSID pSid = m_securityPrincipalSidHolder.Get();

  //
  // We don't really care if this succeeds because it is just used in the TRACE
  //
  CString sSamAccountName;
  _LookupSamAccountNameFromSid(pSid, sSamAccountName);
  TRACE(L"Building trustee for <%s>\n", (LPCWSTR)sSamAccountName);


  BuildTrusteeWithObjectsAndSid(&(AccessEntry.Trustee), 
                                &ObjectsAndSid,
                                &ResetPasswordGUID,
                                NULL, // inherit guid
                                pSid
                                );

  // add an entry in the DACL

  DWORD dwErr = ::AddEntryInAcl(&AccessEntry, ppDacl);

  // Add Self Write on Validated-DNS-Host-Name
  if ( ERROR_SUCCESS == dwErr )
  {
    AccessEntry.grfAccessPermissions = ACTRL_DS_SELF;
    BuildTrusteeWithObjectsAndSid(&(AccessEntry.Trustee), 
                                  &ObjectsAndSid,
                                  &ValidatedDNSHostNameGUID,
                                  NULL, // inherit guid
                                  pSid
                                  );

    dwErr = ::AddEntryInAcl(&AccessEntry, ppDacl);
  }

  // Add Self Write on Validated-SPN
  if ( ERROR_SUCCESS == dwErr )
  {
    AccessEntry.grfAccessPermissions = ACTRL_DS_SELF;
    BuildTrusteeWithObjectsAndSid(&(AccessEntry.Trustee), 
                                  &ObjectsAndSid,
                                  &ValidatedSPNGUID,
                                  NULL, // inherit guid
                                  pSid
                                  );

    dwErr = ::AddEntryInAcl(&AccessEntry, ppDacl);
  }

  // Add Write Property on User-Account-Restrictions
  if ( ERROR_SUCCESS == dwErr )
  {
    AccessEntry.grfAccessPermissions = ACTRL_DS_WRITE_PROP;
    BuildTrusteeWithObjectsAndSid(&(AccessEntry.Trustee), 
                                  &ObjectsAndSid,
                                  &UserAccountRestrictionsGUID,
                                  NULL, // inherit guid
                                  pSid
                                  );

    dwErr = ::AddEntryInAcl(&AccessEntry, ppDacl);
  }

  return HRESULT_FROM_WIN32(dwErr);
}



HRESULT CCreateNewComputerPage::SetSecurity()
{
  // get the ADSI object pointer
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();
  IADs* pObj = pNewADsObjectCreateInfo->PGetIADsPtr();

  // get the full LDAP path of the object
  CComBSTR bstrObjectLdapPath;
  HRESULT hr = pObj->get_ADsPath(&bstrObjectLdapPath);
  ASSERT (SUCCEEDED(hr));
  if (FAILED(hr))
  {
    return hr;
  }

  UnescapePath(bstrObjectLdapPath, /*bDN*/ FALSE, bstrObjectLdapPath);

  PACL pAcl = NULL;
  CSimpleSecurityDescriptorHolder SDHolder;

  TRACE(_T("GetNamedSecurityInfo(%s)\n"), bstrObjectLdapPath);

  // read info
  DWORD dwErr = ::GetNamedSecurityInfo(
                        IN  bstrObjectLdapPath,
                        IN  SE_DS_OBJECT_ALL,
                        IN  DACL_SECURITY_INFORMATION,
                        OUT NULL,
                        OUT NULL,
                        OUT &pAcl,
                        OUT NULL,
                        OUT &(SDHolder.m_pSD));

  TRACE(L"GetNamedSecurityInfo() returned dwErr = 0x%x\n", dwErr);

  hr = HRESULT_FROM_WIN32(dwErr);

	if (FAILED(hr))
	{
		TRACE(_T("failed on GetNamedSecurityInfo()\n"));
		return hr;
	}

	// build the new DACL 
	hr = BuildNewAccessList(&pAcl); 

  TRACE(L"SetEntriesInAcl() returned hr = 0x%x\n", hr);

	if (FAILED(hr))
	{
		TRACE(_T("failed on BuildNewAccessList()\n"));
		return hr;
	}

	// commit changes
  dwErr = ::SetNamedSecurityInfo(
                        IN   bstrObjectLdapPath,
                        IN   SE_DS_OBJECT_ALL,
                        IN   DACL_SECURITY_INFORMATION,
                        IN   NULL,
                        IN   NULL,
                        IN   pAcl,
                        IN   NULL);

  TRACE(L"SetNamedSecurityInfo() returned dwErr = 0x%x\n", dwErr);

  hr = HRESULT_FROM_WIN32(dwErr);

  return hr;
}


BOOL CCreateNewComputerPage::OnError(HRESULT hr)
{
  BOOL bRetVal = FALSE;

  if( HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS )
  {

    HRESULT Localhr;
    DWORD LastError; 
    WCHAR Buf1[256], Buf2[256];
    Localhr = ADsGetLastError (&LastError,
                               Buf1, 256, Buf2, 256);
    switch( LastError )
    {
      case ERROR_USER_EXISTS:
      {
        PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strSamName};
        ReportErrorEx (::GetParent(m_hWnd),IDS_ERROR_COMPUTER_EXISTS,hr,
                   MB_OK|MB_ICONWARNING , apv, 1);
        bRetVal = TRUE;
      }
      break;

      case ERROR_DS_OBJ_STRING_NAME_EXISTS:
      {
        PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strName};
        ReportErrorEx (::GetParent(m_hWnd),IDS_ERROR_COMPUTER_DS_OBJ_STRING_NAME_EXISTS,hr,
                   MB_OK|MB_ICONWARNING , apv, 1);
        bRetVal = TRUE;
      }
      break;
    }
  }
  return bRetVal;
}



CCreateNewComputerWizard:: CCreateNewComputerWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo) : 
    CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
{
  AddPage(&m_page1);
}


void CCreateNewComputerWizard::OnFinishSetInfoFailed(HRESULT hr)
{

  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  if ( !( HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS && 
        m_page1.OnError( hr ) ) )
  {
    // everything else is handled by the base class
    CCreateNewObjectWizardBase::OnFinishSetInfoFailed(hr);
  }
}



///////////////////////////////////////////////////////////////
// NEW OU WIZARD

BEGIN_MESSAGE_MAP(CCreateNewOUPage, CCreateNewObjectDataPage)
  ON_EN_CHANGE(IDC_EDIT_OBJECT_NAME, OnNameChange)
END_MESSAGE_MAP()

CCreateNewOUPage::CCreateNewOUPage()
: CCreateNewObjectDataPage(CCreateNewOUPage::IDD)
{
}

BOOL CCreateNewOUPage::OnInitDialog() 
{
  Edit_LimitText (GetDlgItem(IDC_EDIT_OBJECT_NAME)->m_hWnd, 64);
  CCreateNewObjectDataPage::OnInitDialog();
  return TRUE;
}

BOOL CCreateNewOUPage::GetData(IADs*) 
{
  return !m_strOUName.IsEmpty();
}


void CCreateNewOUPage::OnNameChange()
{
  GetDlgItemText(IDC_EDIT_OBJECT_NAME, OUT m_strOUName);
  m_strOUName.TrimLeft();
  m_strOUName.TrimRight();
  GetWiz()->SetWizardButtons(this, !m_strOUName.IsEmpty());
}

HRESULT CCreateNewOUPage::SetData(BOOL)
{
  // Store the object name in the temporary storage
  HRESULT hr = GetWiz()->GetInfo()->HrCreateNew(m_strOUName);
  return hr;
} 

BOOL CCreateNewOUPage::OnSetActive()
{
  BOOL bRet = CCreateNewObjectDataPage::OnSetActive();
  SetDlgItemFocus(IDC_EDIT_OBJECT_NAME);
  SendDlgItemMessage(IDC_EDIT_OBJECT_NAME, EM_SETSEL, 0, -1);

  return bRet;
}

BOOL CCreateNewOUPage::OnWizardFinish()
{
  BOOL bFinish = CCreateNewObjectDataPage::OnWizardFinish();
  if (!bFinish)
  {
    SetDlgItemFocus(IDC_EDIT_OBJECT_NAME);
    SendDlgItemMessage(IDC_EDIT_OBJECT_NAME, EM_SETSEL, 0, -1);
  }
  return bFinish;
}


CCreateNewOUWizard:: CCreateNewOUWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo) : 
    CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
{
  AddPage(&m_page1);
}
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW GROUP WIZARD

BEGIN_MESSAGE_MAP(CCreateNewGroupPage, CCreateNewObjectDataPage)
  ON_EN_CHANGE(IDC_EDIT_OBJECT_NAME, OnNameChange)
  ON_EN_CHANGE(IDC_EDIT_SAM_NAME, OnSamNameChange)
  ON_BN_CLICKED(IDC_RADIO_SEC_GROUP, OnSecurityOrTypeChange)
  ON_BN_CLICKED(IDC_RADIO_DISTRIBUTION_GROUP, OnSecurityOrTypeChange)
  ON_BN_CLICKED(IDC_RADIO_RESOURCE, OnSecurityOrTypeChange)
  ON_BN_CLICKED(IDC_RADIO_ACCOUNT, OnSecurityOrTypeChange)
  ON_BN_CLICKED(IDC_RADIO_UNIVERSAL, OnSecurityOrTypeChange)
END_MESSAGE_MAP()

CCreateNewGroupPage::CCreateNewGroupPage() : 
CCreateNewObjectDataPage(CCreateNewGroupPage::IDD)
{
  m_fMixed = FALSE;
  m_SAMLength = 256; 
}


BOOL CCreateNewGroupPage::OnInitDialog()
{
  CCreateNewObjectDataPage::OnInitDialog();
  VERIFY(_InitUI());
  return TRUE;
}


BOOL CCreateNewGroupPage::_InitUI()
{
  // set limit to edit boxes
  Edit_LimitText(::GetDlgItem(m_hWnd, IDC_EDIT_OBJECT_NAME), 64);
  Edit_LimitText(::GetDlgItem(m_hWnd, IDC_EDIT_SAM_NAME), m_SAMLength);
  
  // determine if we are in mixed mode by
  // retriving the domain we are bound to
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();
  CComPtr<IADs> spContainerObj;
  HRESULT hr = pNewADsObjectCreateInfo->m_pIADsContainer->QueryInterface(
                  IID_IADs, (void **)&spContainerObj);

  if (SUCCEEDED(hr))
  {
    // retrieve the DN of the container
    CComBSTR bstrPath, bstrDN;
    spContainerObj->get_ADsPath(&bstrPath);

    CPathCracker pathCracker;
    pathCracker.Set(bstrPath, ADS_SETTYPE_FULL);
    pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
    pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bstrDN);

    // get the 1779 name of the domain
    LPWSTR pszDomain1779 = NULL;
    hr = CrackName (bstrDN, &pszDomain1779, GET_FQDN_DOMAIN_NAME, NULL);
    if (SUCCEEDED(hr))
    {
      // build LDAP path for domain
      CString strDomObj;
      
      pNewADsObjectCreateInfo->GetBasePathsInfo()->ComposeADsIPath(strDomObj, pszDomain1779);

      LocalFreeStringW(&pszDomain1779);

      // bind to the domain object
      CComPtr<IADs> spDomainObj;
      hr = DSAdminOpenObject(strDomObj,
                             IID_IADs,
                             (void **) &spDomainObj,
                             TRUE /*bServer*/);
      if (SUCCEEDED(hr)) 
      {
        // retrieve the mixed node attribute
        CComVariant Mixed;
        CComBSTR bsMixed(L"nTMixedDomain");
        spDomainObj->Get(bsMixed, &Mixed);
        m_fMixed = (BOOL)Mixed.bVal;
      }
    }
  }

  // initial setup of radiobutton state
  if (m_fMixed) {
    EnableDlgItem (IDC_RADIO_UNIVERSAL, FALSE); // no universal groups allowed
  } 
  // default is global security group 
  ((CButton *)GetDlgItem(IDC_RADIO_ACCOUNT))->SetCheck(1);
  ((CButton *)GetDlgItem(IDC_RADIO_SEC_GROUP))->SetCheck(1);

  return TRUE;
}


HRESULT CCreateNewGroupPage::SetData(BOOL)
{
  HRESULT hr;

  //
  // First check for illegal characters
  //
  int iFind = m_strSamName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS);
  if (iFind != -1 && !m_strSamName.IsEmpty())
  {
    PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strSamName};
    if (IDYES == ReportErrorEx (m_hWnd,IDS_GROUP_SAMNAME_ILLEGAL,S_OK,
                                MB_YESNO | MB_ICONWARNING, apv, 1))
    {
      while (iFind != -1)
      {
        m_strSamName.SetAt(iFind, L'_');
        iFind = m_strSamName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS);
      }
      SetDlgItemText(IDC_EDIT_SAM_NAME, m_strSamName);
    }
    else
    {
      //
      // Set the focus to the edit box and select the text
      //
      GetDlgItem(IDC_EDIT_SAM_NAME)->SetFocus();
      SendDlgItemMessage(IDC_EDIT_SAM_NAME, EM_SETSEL, 0 , -1);
      return E_INVALIDARG;
    }
  }

  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();
  // Store the object name in the temporary storage
  hr = pNewADsObjectCreateInfo->HrCreateNew(m_strGroupName);
  if (FAILED(hr))
  {
    return hr;
  }

  // Create and persist the object
  // Store the object name in the temporary storage
  hr = pNewADsObjectCreateInfo->HrAddVariantBstr(const_cast<PWSTR>(gsz_samAccountName),
                                                 m_strSamName);
  ASSERT(SUCCEEDED(hr));

  CComVariant varGroupType;
  varGroupType.vt = VT_I4;

  BOOL Account = IsDlgButtonChecked (IDC_RADIO_ACCOUNT);
  BOOL Resource = IsDlgButtonChecked (IDC_RADIO_RESOURCE);
  BOOL Security = IsDlgButtonChecked (IDC_RADIO_SEC_GROUP);

  if (Security)
    varGroupType.lVal = GROUP_TYPE_SECURITY_ENABLED;
  else
    varGroupType.lVal = 0;

  if (Resource)
    varGroupType.lVal |= GROUP_TYPE_RESOURCE_GROUP;
  else
    if (Account)
      varGroupType.lVal |= GROUP_TYPE_ACCOUNT_GROUP;
    else
      varGroupType.lVal |= GROUP_TYPE_UNIVERSAL_GROUP;
      

  // Update the GroupType
  hr = pNewADsObjectCreateInfo->HrAddVariantCopyVar(const_cast<PWSTR>(gsz_groupType), varGroupType);
  ASSERT(SUCCEEDED(hr));

  return hr;
}

BOOL CCreateNewGroupPage::GetData(IADs*)
{
  return !m_strGroupName.IsEmpty();
}


void CCreateNewGroupPage::OnNameChange()
{
  GetDlgItemText(IDC_EDIT_OBJECT_NAME, OUT m_strGroupName);
  m_strGroupName.TrimLeft();
  m_strGroupName.TrimRight();
  SetDlgItemText(IDC_EDIT_SAM_NAME, OUT m_strGroupName.Left(m_SAMLength));
  GetWiz()->SetWizardButtons(this,(!m_strGroupName.IsEmpty() &&
                                   !m_strSamName.IsEmpty()));
}

void CCreateNewGroupPage::OnSamNameChange()
{
  GetDlgItemText(IDC_EDIT_SAM_NAME, OUT m_strSamName);
  m_strSamName.TrimLeft();
  m_strSamName.TrimRight();
  GetWiz()->SetWizardButtons(this,(!m_strGroupName.IsEmpty() &&
                                   !m_strSamName.IsEmpty()));
}

void CCreateNewGroupPage::OnSecurityOrTypeChange()
{
  if (!IsDlgButtonChecked (IDC_RADIO_SEC_GROUP)) {
    EnableDlgItem (IDC_RADIO_UNIVERSAL, TRUE);
  } else {
    if (m_fMixed) {
      if (IsDlgButtonChecked (IDC_RADIO_UNIVERSAL)) {
        ((CButton *)GetDlgItem(IDC_RADIO_ACCOUNT))->SetCheck(1);
        ((CButton *)GetDlgItem(IDC_RADIO_UNIVERSAL))->SetCheck(0);
      }
      EnableDlgItem (IDC_RADIO_UNIVERSAL, FALSE);
    }
  }
}

CCreateNewGroupWizard::CCreateNewGroupWizard(
        CNewADsObjectCreateInfo* pNewADsObjectCreateInfo)
: CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
{
  AddPage(&m_page1);
}

///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW CONTACT WIZARD

BEGIN_MESSAGE_MAP(CCreateNewContactPage, CCreateNewObjectDataPage)
  ON_EN_CHANGE(IDC_EDIT_FIRST_NAME, OnNameChange)
  ON_EN_CHANGE(IDC_EDIT_INITIALS, OnNameChange)
  ON_EN_CHANGE(IDC_EDIT_LAST_NAME, OnNameChange)
  ON_EN_CHANGE(IDC_EDIT_FULL_NAME, OnFullNameChange)
  ON_EN_CHANGE(IDC_EDIT_DISP_NAME, OnDispNameChange)
END_MESSAGE_MAP()

CCreateNewContactPage::CCreateNewContactPage() : 
CCreateNewObjectDataPage(CCreateNewContactPage::IDD)
{
}


BOOL CCreateNewContactPage::OnInitDialog()
{
  CCreateNewObjectDataPage::OnInitDialog();

  Edit_LimitText (GetDlgItem(IDC_EDIT_FULL_NAME)->m_hWnd, 64);
  Edit_LimitText (GetDlgItem(IDC_EDIT_LAST_NAME)->m_hWnd, 29);
  Edit_LimitText (GetDlgItem(IDC_EDIT_FIRST_NAME)->m_hWnd, 28);
  Edit_LimitText (GetDlgItem(IDC_EDIT_INITIALS)->m_hWnd, 4);
  Edit_LimitText (GetDlgItem(IDC_EDIT_DISP_NAME)->m_hWnd, 256);

  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();
  m_nameFormatter.Initialize(pNewADsObjectCreateInfo->GetBasePathsInfo(), 
                  pNewADsObjectCreateInfo->m_pszObjectClass);

  return TRUE;
}


HRESULT CCreateNewContactPage::SetData(BOOL)
{
  HRESULT hr;
  // Store the object name in the temporary storage
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();

  // create a new temporary ADs object
  hr = pNewADsObjectCreateInfo->HrCreateNew(m_strFullName);
  if (FAILED(hr)) {
    return hr;
  }
  // set the attributes in the cache
  hr = pNewADsObjectCreateInfo->HrAddVariantBstrIfNotEmpty(L"givenName", m_strFirstName);
  ASSERT(SUCCEEDED(hr));
  hr = pNewADsObjectCreateInfo->HrAddVariantBstrIfNotEmpty(L"initials", m_strInitials);
  ASSERT(SUCCEEDED(hr));
  hr = pNewADsObjectCreateInfo->HrAddVariantBstrIfNotEmpty(L"sn", m_strLastName);
  ASSERT(SUCCEEDED(hr));
  hr = pNewADsObjectCreateInfo->HrAddVariantBstrIfNotEmpty(L"displayName", m_strDispName);
  ASSERT(SUCCEEDED(hr));

  return hr;
}



BOOL CCreateNewContactPage::GetData(IADs*)
{
  return !m_strFullName.IsEmpty();
}


void CCreateNewContactPage::OnNameChange()
{
  GetDlgItemText(IDC_EDIT_FIRST_NAME, OUT m_strFirstName);
  GetDlgItemText(IDC_EDIT_INITIALS, OUT m_strInitials);
  GetDlgItemText(IDC_EDIT_LAST_NAME, OUT m_strLastName);

  m_strFirstName.TrimLeft();
  m_strFirstName.TrimRight();

  m_strInitials.TrimLeft();
  m_strInitials.TrimRight();

  m_strLastName.TrimLeft();
  m_strLastName.TrimRight();

  m_nameFormatter.FormatName(m_strFullName, 
                             m_strFirstName.IsEmpty() ? NULL : (LPCWSTR)m_strFirstName, 
                             m_strInitials.IsEmpty() ? NULL : (LPCWSTR)m_strInitials,
                             m_strLastName.IsEmpty() ? NULL : (LPCWSTR)m_strLastName);
  SetDlgItemText(IDC_EDIT_FULL_NAME, 
                  IN m_strFullName);

  GetWiz()->SetWizardButtons(this, !m_strFullName.IsEmpty());
}

void CCreateNewContactPage::OnFullNameChange()
{
  GetDlgItemText(IDC_EDIT_FULL_NAME, OUT m_strFullName);
  GetWiz()->SetWizardButtons(this, !m_strFullName.IsEmpty());
}

void CCreateNewContactPage::OnDispNameChange()
{
  GetDlgItemText(IDC_EDIT_DISP_NAME, OUT m_strDispName);
  m_strDispName.TrimLeft();
  m_strDispName.TrimRight();
}




CCreateNewContactWizard::CCreateNewContactWizard(
        CNewADsObjectCreateInfo* pNewADsObjectCreateInfo)
: CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
{
  AddPage(&m_page1);
}



#ifdef FRS_CREATE
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW FRS SUBSCRIBER WIZARD

HRESULT CCreateNewFrsSubscriberPage::SetData(BOOL bSilent)
{
  CString strRootPath;
  CString strStagingPath;
  if ( !ReadAbsolutePath( IDC_FRS_ROOT_PATH, strRootPath) ||
       !ReadAbsolutePath( IDC_FRS_STAGING_PATH, strStagingPath ) )
    {
      return E_INVALIDARG;
    }

  HRESULT hr = S_OK;

  // Add more properties, we don't want to create it unless all of these work
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();
  ASSERT( NULL != pNewADsObjectCreateInfo );
  hr = pNewADsObjectCreateInfo->HrAddVariantBstrIfNotEmpty(  gsz_fRSRootPath,
                                                             strRootPath,
                                                             TRUE );
  ASSERT(SUCCEEDED(hr));
  hr = pNewADsObjectCreateInfo->HrAddVariantBstrIfNotEmpty(  gsz_fRSStagingPath,
                                                             strStagingPath,
                                                             TRUE );
  ASSERT(SUCCEEDED(hr));

  // no need to commit here, wait until after extensions have had a shot
  return CCreateNewNamedObjectPage::SetData(bSilent);
}

BOOL CCreateNewFrsSubscriberPage::ReadAbsolutePath( int ctrlID, OUT CString& strrefValue )
{
  // CODEWORK this should also select the text in this field
  GetDlgItemText(ctrlID, OUT strrefValue);
  DWORD PathType = 0;
  if ( NERR_Success != I_NetPathType(
                                     NULL,
                                     const_cast<LPTSTR>((LPCTSTR)strrefValue),
                                     &PathType,
                                     0 ) ||
       ITYPE_PATH_ABSD != PathType )
    {
      PVOID apv[1] = {(LPWSTR)(LPCWSTR)strrefValue};
      ReportErrorEx (::GetParent(m_hWnd),IDS_2_INVALID_ABSOLUTE_PATH,S_OK,
                     MB_OK, apv, 1);

      SetDlgItemFocus(ctrlID);
      return FALSE;
    }
  return TRUE;
} 
#endif // FRS_CREATE


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW SITE LINKWIZARD

BEGIN_MESSAGE_MAP(CCreatePageWithDuellingListboxes, CCreateNewObjectDataPage)
  ON_EN_CHANGE(IDC_NEW_OBJECT_NAME, OnNameChange)
  ON_BN_CLICKED(IDC_DUELLING_RB_ADD, OnDuellingButtonAdd)
  ON_BN_CLICKED(IDC_DUELLING_RB_REMOVE, OnDuellingButtonRemove)
  ON_LBN_SELCHANGE(IDC_DUELLING_LB_OUT, OnDuellingListboxSelchange)
  ON_LBN_SELCHANGE(IDC_DUELLING_LB_IN, OnDuellingListboxSelchange)
  ON_WM_DESTROY()
END_MESSAGE_MAP()

CCreatePageWithDuellingListboxes::CCreatePageWithDuellingListboxes(
    UINT nIDTemplate,
    LPCWSTR lpcwszAttrName,
    const DSPROP_BSTR_BLOCK& bstrblock )
: CCreateNewObjectDataPage(nIDTemplate)
, m_strAttrName( lpcwszAttrName )
, m_bstrblock( bstrblock )
{
}

BOOL CCreatePageWithDuellingListboxes::GetData(IADs*)
{
  return FALSE; // start disabled
}

void CCreatePageWithDuellingListboxes::OnNameChange()
{
  GetDlgItemText(IDC_NEW_OBJECT_NAME, OUT m_strName);
  m_strName.TrimLeft();
  m_strName.TrimRight();
  SetWizardButtons();
}

void CCreatePageWithDuellingListboxes::SetWizardButtons()
{
  BOOL fAllowApply = !(m_strName.IsEmpty());
  GetWiz()->SetWizardButtons(this, fAllowApply);
}

  
HRESULT CCreatePageWithDuellingListboxes::SetData(BOOL)
{
  HRESULT hr = S_OK;
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();
  // Store the object name in the temporary storage
  hr = pNewADsObjectCreateInfo->HrCreateNew(m_strName);
  if (FAILED(hr))
  {
    return hr;
  }

  // build the siteList attribute
  CStringList strlist;
  int cItems = ListBox_GetCount( m_hwndInListbox );
  ASSERT( 0 <= cItems );
  for (int i = cItems-1; i >= 0; i--)
  {
    BSTR bstrDN = (BSTR)ListBox_GetItemData( m_hwndInListbox, i );
    ASSERT( NULL != bstrDN );
    strlist.AddHead( bstrDN );
  }
  ASSERT( strlist.GetCount() > 0 );
  CComVariant svar;
  hr = HrStringListToVariant( OUT svar, IN strlist );
  ASSERT( SUCCEEDED(hr) );

  //
  // set the siteList attribute
  //
  hr = pNewADsObjectCreateInfo->HrAddVariantCopyVar(const_cast<PWSTR>((LPCWSTR)m_strAttrName), svar);
  ASSERT(SUCCEEDED(hr));

  //
  // no need to commit here, wait until after extensions have had a shot
  //
  return hr;
}

//
// The duelling listbox support uses exports from DSPROP.DLL.  Correct
// functioning requires that the control IDs be numbered correctly.
// JonN 8/31/98
//

void CCreatePageWithDuellingListboxes::OnDuellingButtonAdd()
{
    DSPROP_Duelling_ButtonClick(
        m_hWnd,
        IDC_DUELLING_RB_ADD );
    SetWizardButtons();
}

void CCreatePageWithDuellingListboxes::OnDuellingButtonRemove()
{
    DSPROP_Duelling_ButtonClick(
        m_hWnd,
        IDC_DUELLING_RB_REMOVE );
    SetWizardButtons();
}

void CCreatePageWithDuellingListboxes::OnDuellingListboxSelchange()
{
    // don't allow Add/Remove if there are <3 sites
    if (2 < (ListBox_GetCount(m_hwndInListbox)
           + ListBox_GetCount(m_hwndOutListbox)) )
    {
        DSPROP_Duelling_UpdateButtons( m_hWnd, IDC_DUELLING_RB_ADD );
    }
}

void CCreatePageWithDuellingListboxes::OnDestroy()
{
    DSPROP_Duelling_ClearListbox( m_hwndInListbox );
    DSPROP_Duelling_ClearListbox( m_hwndOutListbox );
    CCreateNewObjectDataPage::OnDestroy();
}

BOOL CCreatePageWithDuellingListboxes::OnSetActive()
{
    m_hwndInListbox  = ::GetDlgItem( m_hWnd, IDC_DUELLING_LB_IN  );
    m_hwndOutListbox = ::GetDlgItem( m_hWnd, IDC_DUELLING_LB_OUT );
    ASSERT( NULL != m_hwndInListbox && NULL != m_hwndOutListbox );

    HWND hwndInitial = m_hwndOutListbox;
    if (3 > m_bstrblock.QueryCount())
    {
        // move all sitelinks to "in"
        // Add/Remove will never be enabled
        hwndInitial = m_hwndInListbox;
    }
    HRESULT hr = DSPROP_Duelling_Populate(
        hwndInitial,
        m_bstrblock
        );
    if ( FAILED(hr) )
        return FALSE;
    return CCreateNewObjectDataPage::OnSetActive();
}


CCreateNewSiteLinkPage::CCreateNewSiteLinkPage(
        const DSPROP_BSTR_BLOCK& bstrblock )
: CCreatePageWithDuellingListboxes(
        CCreateNewSiteLinkPage::IDD,
        gsz_siteList,
        bstrblock)
{
}

BOOL CCreateNewSiteLinkPage::OnSetActive()
{
    if (m_bstrblock.QueryCount() < 2)
    {
        // change "must contain two sites" text
        CString sz;
        sz.LoadString(IDS_SITELINK_DLGTEXT_ONE_SITE);
        ::SetDlgItemText( m_hWnd, IDC_STATIC_MESSAGE, sz );
    }

    return CCreatePageWithDuellingListboxes::OnSetActive();
}

HRESULT CCreateNewSiteLinkPage::SetData(BOOL bSilent)
{
    BOOL fAllowApply = TRUE;
    int cIn = ListBox_GetCount(m_hwndInListbox);
    if (1 > cIn)
        fAllowApply = FALSE; // zero sites is a constraint violation
    else if (2 > cIn)
    {
      int cOut = ListBox_GetCount(m_hwndOutListbox);
      if (1 <= cOut) // allow one site if the "out" listbox is empty
        fAllowApply = FALSE;
    }
    if (fAllowApply)
      return CCreatePageWithDuellingListboxes::SetData(bSilent);

    if (!bSilent)
    {
      ReportMessageEx(m_hWnd,
                      IDS_SITELINK_NEEDS_TWO_SITES,
                      MB_OK | MB_ICONSTOP);
    }

    return E_FAIL;
}


CCreateNewSiteLinkWizard::CCreateNewSiteLinkWizard(
        CNewADsObjectCreateInfo* pNewADsObjectCreateInfo,
        const DSPROP_BSTR_BLOCK& bstrblock )
    : CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
    , m_page1( bstrblock )
{
  AddPage(&m_page1);
}


CCreateNewSiteLinkBridgePage::CCreateNewSiteLinkBridgePage(
        const DSPROP_BSTR_BLOCK& bstrblock )
: CCreatePageWithDuellingListboxes(
        CCreateNewSiteLinkBridgePage::IDD,
        gsz_siteLinkList,
        bstrblock)
{
}

HRESULT CCreateNewSiteLinkBridgePage::SetData(BOOL bSilent)
{
    BOOL fAllowApply = TRUE;
    int cIn = ListBox_GetCount(m_hwndInListbox);
    if (2 > cIn)
    {
      fAllowApply = FALSE;
    }
    if (fAllowApply)
      return CCreatePageWithDuellingListboxes::SetData(bSilent);

    if (!bSilent)
    {
      ReportMessageEx(m_hWnd,
                      IDS_SITELINKBRIDGE_NEEDS_TWO_SITELINKS,
                      MB_OK | MB_ICONSTOP);
    }

    return E_FAIL;
}

CCreateNewSiteLinkBridgeWizard:: CCreateNewSiteLinkBridgeWizard(
        CNewADsObjectCreateInfo* pNewADsObjectCreateInfo,
        const DSPROP_BSTR_BLOCK& bstrblockSiteLinks )
    : CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
    , m_page1( bstrblockSiteLinks )
{
  AddPage(&m_page1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dscolumn.cpp ===
// DSColumn.cpp : Implementation of ds column routines and classes

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSColumn.cpp
//
//  Contents:  DS Column routines, classes, and static data
//
//  History:   12-Mar-99 JeffJon    Created
//
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"

#include "util.h"

#include "DSColumn.h"
#include "dscookie.h"
#include "dscmn.h"      // CrackName()
#include "dsutil.h"

BOOL ColumnExtractStringValue(
    OUT CString& strref,
    IN CDSCookie*,
    IN PADS_SEARCH_COLUMN pColumn,
	IN DWORD iValue)
{
  if (pColumn == NULL || pColumn->dwNumValues <= iValue)
  {
    return FALSE;
  }

  switch (pColumn->dwADsType)
	{
	case ADSTYPE_CASE_IGNORE_STRING:
		strref = (LPCWSTR)pColumn->pADsValues[iValue].CaseIgnoreString;
		break;
	case ADSTYPE_DN_STRING:
		strref = (LPCWSTR)pColumn->pADsValues[iValue].DNString;
		break;
	default:
		return FALSE;
	}
    return TRUE;
}

BOOL ColumnExtractString(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN pColumn)
{
    return ColumnExtractStringValue( strref, pCookie, pColumn, 0 );
}

BOOL ColumnExtractElementFromDN(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN pColumn,
    long lElement,
	IN DWORD iValue = 0);

BOOL ColumnExtractElementFromDN(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN pColumn,
    long lElement,
	IN DWORD iValue)
{
    if (pColumn == NULL)
    {
        return FALSE;
    }

    BOOL fRetval = FALSE;
    CString str;
    CComBSTR bstr;
    HRESULT hr = S_OK;
    do { // false loop
        if ( !ColumnExtractStringValue( str, pCookie, pColumn, iValue ) || str.IsEmpty() )
        {
            strref.Empty();
            fRetval = TRUE;
            break;
        }
        CPathCracker pathCracker;
        hr = pathCracker.Set(const_cast<BSTR>((LPCTSTR)str), ADS_SETTYPE_DN);
        if ( FAILED(hr) )
            break;
        // no need to reset this
        hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
        if ( FAILED(hr) )
            break;
        hr = pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF);
        if ( FAILED(hr) )
            break;
        hr = pathCracker.GetElement(lElement, &bstr);
        strref = bstr;
        fRetval = TRUE;
    } while (FALSE); // false loop

    return fRetval;
}

BOOL ColumnExtractLeafFromDN(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN pColumn)
{
  return ColumnExtractElementFromDN( strref, pCookie, pColumn, 0 );
}

BOOL ColumnExtractParentFromDN(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN pColumn)
{
  return ColumnExtractElementFromDN( strref, pCookie, pColumn, 1 );
}

BOOL ColumnExtractGreatGrandparentFromDN(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN pColumn)
{
  return ColumnExtractElementFromDN( strref, pCookie, pColumn, 3 );
}

BOOL ColumnExtractConnectionDisplayName(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN pColumn)
{
  if (pColumn == NULL)
  {
    return FALSE;
  }

    ADS_INTEGER adsint = 0;
    switch (pColumn->dwADsType)
    {
    case ADSTYPE_INTEGER:
      adsint = pColumn->pADsValues->Integer;
      break;
    default:
    // no value, let it stay 0
      break;
    }
    if (NTDSCONN_OPT_IS_GENERATED & adsint) {
      strref.LoadString (IDS_CONNECTION_KCC_GENERATED);
    } else {
      strref = pCookie->GetName();
    }
    return TRUE;
}

BOOL ColumnExtractAttribute(
    OUT CString& strref,
    IN CDSCookie*,
    IN PADS_SEARCH_COLUMN pColumn)
{
  if (pColumn == NULL)
  {
    return FALSE;
  }

  switch (pColumn->dwADsType)
  {
	case ADSTYPE_DN_STRING         :
		strref = pColumn->pADsValues->DNString;
		break;

	case ADSTYPE_CASE_EXACT_STRING :
		strref = pColumn->pADsValues->CaseExactString;
		break;

	case ADSTYPE_CASE_IGNORE_STRING:
		strref = pColumn->pADsValues->CaseIgnoreString;
		break;

	case ADSTYPE_PRINTABLE_STRING  :
		strref = pColumn->pADsValues->PrintableString;
		break;

	case ADSTYPE_NUMERIC_STRING    :
		strref = pColumn->pADsValues->NumericString;
		break;

	case ADSTYPE_OBJECT_CLASS    :
		strref = pColumn->pADsValues->ClassName;
		break;

	case ADSTYPE_BOOLEAN :
		strref = ((DWORD)pColumn->pADsValues->Boolean) ? L"TRUE" : L"FALSE";
		break;

	case ADSTYPE_INTEGER           :
		strref.Format(L"%d", (DWORD) pColumn->pADsValues->Integer);
		break;

	case ADSTYPE_OCTET_STRING      :
		{
			CString sOctet = L"";
	
			BYTE  b;
			for ( DWORD idx=0; idx<pColumn->pADsValues->OctetString.dwLength; idx++) 
			{
				b = ((BYTE *)pColumn->pADsValues->OctetString.lpValue)[idx];
				sOctet.Format(L"0x%02x ", b);
				strref += sOctet;
			}
		}
		break;

	case ADSTYPE_UTC_TIME:
    {
      PTSTR ptszDate = NULL;
      int cchDate = 0;
      SYSTEMTIME st = {0};

      if (!SystemTimeToTzSpecificLocalTime(NULL, &pColumn->pADsValues->UTCTime, &st))
      {
        strref = L"";
        return TRUE;
      }
      cchDate = GetDateFormat(LOCALE_USER_DEFAULT, 0 , 
                              &st, NULL, 
                              ptszDate, 0);
      ptszDate = (PTSTR)malloc(sizeof(TCHAR) * cchDate);
      if (GetDateFormat(LOCALE_USER_DEFAULT, 0, 
                      &st, NULL, 
                      ptszDate, cchDate))
      {
  		  strref = ptszDate;
      }
      else
      {
        strref = L"";
      }
      free(ptszDate);

      PTSTR ptszTime = NULL;

      cchDate = GetTimeFormat(LOCALE_USER_DEFAULT, 0 , 
                              &st, NULL, 
                              ptszTime, 0);
      ptszTime = (PTSTR)malloc(sizeof(TCHAR) * cchDate);
      if (ptszTime != NULL)
      {
        if (GetTimeFormat(LOCALE_USER_DEFAULT, 0, 
                        &st, NULL, 
                        ptszTime, cchDate))
        {
          strref += _T(" ") + CString(ptszTime);
        }
        else
        {
          strref += _T("");
        }
        free(ptszTime);
      }
      else
      {
        strref = _T("");
      }
    }
		break;

	default :
    ASSERT(FALSE);
		break;
  }

  return TRUE;
}


BOOL _ColumnCrackDN(
    OUT CString& strref,
    IN LPCTSTR lpcszDN,
    IN CRACK_NAME_OPR RequestedOpr)
{
    PWSTR pwzName = NULL;
    HRESULT hr = CrackName(const_cast<PTSTR>(lpcszDN),
                           &pwzName,
                           RequestedOpr,
                           NULL);
    if (SUCCEEDED(hr))
    {
        if (GET_OBJ_CAN_NAME_EX == RequestedOpr)
        {
            LPTSTR ptzCanName = wcschr( pwzName, _T('\n') );
            if (NULL != ptzCanName)
                strref = ptzCanName+1;
            else
                strref.Empty();
        }
        else
        {
            strref = pwzName;
        }
        LocalFreeStringW(&pwzName);
    }
    else
    {
        strref.Empty();
    }
    return TRUE;
}

BOOL ColumnExtractNameFromSID(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN)
{
  return _ColumnCrackDN( strref, pCookie->GetPath(), GET_OBJ_CAN_NAME );
}

BOOL ColumnExtractCanonicalNameFromDN(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN pColumn)
{
    if (pColumn == NULL)
    {
        return FALSE;
    }

    CString str;
    if ( !ColumnExtractString( str, pCookie, pColumn ) || str.IsEmpty() )
    {
        strref.Empty();
        return TRUE;
    }

    return _ColumnCrackDN( strref, str, GET_OBJ_CAN_NAME_EX );
}

BOOL ColumnExtractDomainFromDN(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN pColumn)
{
    if (pColumn == NULL)
    {
        return FALSE;
    }

    CString str;
    if ( !ColumnExtractString( str, pCookie, pColumn ) || str.IsEmpty() )
    {
        strref.Empty();
        return TRUE;
    }

    return _ColumnCrackDN( strref, str, GET_DNS_DOMAIN_NAME );
}

int _cdecl _qsort_CompareColumns(const void * elem1, const void * elem2)
{
    PADSVALUE p1 = (PADSVALUE)elem1;
    PADSVALUE p2 = (PADSVALUE)elem2;
    if (!p1 || !p2 || !p1->DNString || !p2->DNString)
        return 0;
    return wcscmp( p1->DNString, p2->DNString );
}

BOOL ColumnExtractLeafList(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN pColumn)
{
    if (pColumn == NULL)
    {
        return FALSE;
    }

    // alphabetical order
    qsort( pColumn->pADsValues,
           pColumn->dwNumValues,
           sizeof(ADSVALUE),
           _qsort_CompareColumns );

    CString strSeparator;
    strSeparator.LoadString(IDS_SEPARATOR);
	for (DWORD iValue = 0; iValue < pColumn->dwNumValues; iValue++)
	{
		CString strTransport;
		if ( !ColumnExtractElementFromDN(
                    strTransport, pCookie, pColumn, 0, iValue) )
			return FALSE;
		if (0 < iValue)
			strref += strSeparator;
		strref += strTransport;
	}

    return TRUE;
}

BOOL _ColumnCrackFRS(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN CRACK_NAME_OPR RequestedOpr)
{
    CDSCookieInfoConnection* pExtraInfo = NULL;
    if (   NULL == pCookie
        || _wcsicmp( pCookie->GetClass(), L"nTDSConnection" )
        || NULL == (pExtraInfo = (CDSCookieInfoConnection*)pCookie->GetExtraInfo())
        || pExtraInfo->GetClass() != CDSCookieInfoBase::connection
        || pExtraInfo->m_strFRSComputerReference.IsEmpty()
       )
    {
        strref.Empty();
        return TRUE;
    }

    return _ColumnCrackDN( strref, pExtraInfo->m_strFRSComputerReference, RequestedOpr );
}

BOOL ColumnExtractFRSComputer(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN)
{
    return _ColumnCrackFRS( strref, pCookie, GET_OBJ_CAN_NAME_EX );
}

BOOL ColumnExtractFRSDomain(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN)
{
    return _ColumnCrackFRS( strref, pCookie, GET_DNS_DOMAIN_NAME );
}

ATTRIBUTE_COLUMN colName = { ATTR_COLTYPE_NAME,
                             IDS_COLUMN_NAME, //column header
                             100,             //col. width
                             NULL,            //ldap attr. name
                             NULL };          //extract fn()

ATTRIBUTE_COLUMN colClass= { ATTR_COLTYPE_CLASS,
                             IDS_COLUMN_TYPE, //column header
                             100,               //col. width
                             NULL,            //ldap attr. name
                             NULL };          //extract fn()

ATTRIBUTE_COLUMN colDesc = { ATTR_COLTYPE_DESC,
                             IDS_COLUMN_DESCRIPTION, //column header
                             150,               //col. width
                             NULL,            //ldap attr. name
                             NULL };          //extract fn()

ATTRIBUTE_COLUMN colSite = { ATTR_COLTYPE_SPECIAL,
                             IDS_COLUMN_SITE, //column header
                             100,             //col. width
                             L"siteObject",   //ldap attr. name
                             ColumnExtractLeafFromDN }; //extract fn()

ATTRIBUTE_COLUMN colLocation = { ATTR_COLTYPE_SPECIAL,
                                 IDS_COLUMN_LOCATION, //column header
                                 150,               //col. width
                                 L"location", //ldap attr. name
                                 NULL }; //extract fn()

ATTRIBUTE_COLUMN colDomain = { ATTR_COLTYPE_SPECIAL,
                               IDS_COLUMN_DOMAIN, //column header
                               150,               //col. width
                               L"serverReference", //ldap attr. name
                               ColumnExtractDomainFromDN }; //extract fn()

ATTRIBUTE_COLUMN colBridgehead = { ATTR_COLTYPE_SPECIAL,
                                   IDS_COLUMN_BRIDGEHEAD, //column header
                                   150,               //col. width
                                   L"bridgeheadTransportList", //ldap attr. name
                                   ColumnExtractLeafList }; //extract fn()

ATTRIBUTE_COLUMN colReplicaComputer = { ATTR_COLTYPE_SPECIAL,
                                        IDS_COLUMN_COMPUTER, //column header
                                        100,               //col. width
                                        L"fRSComputerReference", //ldap attr. name
                                        ColumnExtractCanonicalNameFromDN }; //extract fn()

ATTRIBUTE_COLUMN colReplicaDomain = { ATTR_COLTYPE_SPECIAL,
                                      IDS_COLUMN_DOMAIN, //column header
                                      150,               //col. width
                                      L"fRSComputerReference", //ldap attr. name
                                      ColumnExtractDomainFromDN }; //extract fn()

ATTRIBUTE_COLUMN colFromFRSComputer = { ATTR_COLTYPE_SPECIAL,
                                        IDS_COLUMN_FROM_COMPUTER, //column header
                                        100,             //col. width
                                        L"fromServer",   //ldap attr. name
                                        ColumnExtractFRSComputer }; //extract fn()

ATTRIBUTE_COLUMN colFromFRSDomain = { ATTR_COLTYPE_SPECIAL,
                                      IDS_COLUMN_FROM_DOMAIN, //column header
                                      150,               //col. width
                                      L"fromServer", //ldap attr. name
                                      ColumnExtractFRSDomain }; //extract fn()

ATTRIBUTE_COLUMN colConnectionName={ ATTR_COLTYPE_SPECIAL,
                             IDS_COLUMN_NAME, //column header
                             150,             //col. width
                             L"options",   //ldap attr. name
                             ColumnExtractConnectionDisplayName}; //extract fn()

ATTRIBUTE_COLUMN colFromServer={ ATTR_COLTYPE_SPECIAL,
                             IDS_COLUMN_FROM_SERVER, //column header
                             100,             //col. width
                             L"fromServer",   //ldap attr. name
                             ColumnExtractParentFromDN }; //extract fn()

ATTRIBUTE_COLUMN colFromSite={ ATTR_COLTYPE_SPECIAL,
                             IDS_COLUMN_FROM_SITE, //column header
                             100,             //col. width
                             L"fromServer",   //ldap attr. name
                             ColumnExtractGreatGrandparentFromDN }; //extract fn()

ATTRIBUTE_COLUMN colCost = { ATTR_COLTYPE_SPECIAL,
                                 IDS_COLUMN_COST, //column header
                                 75,               //col. width
                                 L"cost", //ldap attr. name
                                 ColumnExtractAttribute }; //extract fn()

ATTRIBUTE_COLUMN colReplInterval = { ATTR_COLTYPE_SPECIAL,
                                 IDS_COLUMN_REPLINTERVAL, //column header
                                 150,               //col. width
                                 L"replInterval", //ldap attr. name
                                 ColumnExtractAttribute }; //extract fn()

ATTRIBUTE_COLUMN colNameFromSID={ ATTR_COLTYPE_SPECIAL,
                                  IDS_COLUMN_READABLE_NAME,    // column header
                                  100,                // column width
                                  L"container",
                                  ColumnExtractNameFromSID }; // extract fn()

ATTRIBUTE_COLUMN colGenericSpecial={ ATTR_COLTYPE_SPECIAL,
                                     0,                   // resource id 0 means load it from the special column array
                                     50,
                                     NULL,
                                     ColumnExtractAttribute };

ATTRIBUTE_COLUMN colModifiedTime={ ATTR_COLTYPE_MODIFIED_TIME,
                                   0,
                                   50,
                                   NULL,
                                   ColumnExtractAttribute };

SPECIAL_COLUMN g_specialCols[] =
{ 
  { IDS_COLUMN_BUSINESS_PHONE,      L"telephoneNumber",             100 },
  { IDS_COLUMN_CITY,                L"l",                           150 },
  { IDS_COLUMN_COMPANY,             L"company",                     150 },
  { IDS_COLUMN_COUNTRY,             L"c",                           AUTO_WIDTH }, // Default to the width of the header string
  { IDS_COLUMN_DEPARTMENT,          L"department",                  150 },
  { IDS_COLUMN_DISPLAY_NAME,        L"displayName",                 100 },
  { IDS_COLUMN_SAM_ACCOUNT_NAME,    L"sAMAccountName",              120 },
  { IDS_COLUMN_MAIL,                L"mail",                        100 },
  { IDS_COLUMN_ALIAS_NAME,          L"mailNickname",                175 },
  { IDS_COLUMN_HOME_MDB,            L"homeMDB",                     100 },
  { IDS_COLUMN_FIRST_NAME,          L"givenName",                   100 },
  { IDS_COLUMN_IMHOMEURL,           L"msExchIMPhysicalURL",         170 }, 
  { IDS_COLUMN_IMURL,               L"msExchIMMetaPhysicalURL",     140 },
  { IDS_COLUMN_LAST_NAME,           L"sn",                          100 },
  { IDS_COLUMN_MODIFIED,            L"whenChanged",                 130 },
  { IDS_COLUMN_OFFICE,              L"physicalDeliveryOfficeName",  100 },
  { IDS_COLUMN_STATE,               L"st",                          100 },
  { IDS_COLUMN_TARGET_ADDRESS ,     L"targetAddress",               100 },
  { IDS_COLUMN_TITLE,               L"title",                       100 },
  { IDS_COLUMN_UPN,                 L"userPrincipalName",           200 },
  { IDS_COLUMN_TEXTENCODEORADDRESS, L"textEncodedORAddress",        130 },
  { IDS_COLUMN_ZIP_CODE,            L"postalCode",                  100 }
};

PATTRIBUTE_COLUMN colsSubnetContainer[6] = { &colName, &colSite, &colLocation, &colClass, &colDesc, NULL };
PATTRIBUTE_COLUMN colsSitesContainer[5] = { &colName, &colLocation, &colClass, &colDesc, NULL };
PATTRIBUTE_COLUMN colsServersContainer[6] = { &colName, &colDomain, &colBridgehead, &colClass, &colDesc, NULL };
PATTRIBUTE_COLUMN colsNTDSDSA[6] = { &colConnectionName, &colFromServer, &colFromSite, &colClass, &colDesc, NULL };
PATTRIBUTE_COLUMN colsInterSiteTransport[6] = { &colName, &colClass, &colDesc, &colCost, &colReplInterval, NULL };
PATTRIBUTE_COLUMN colsFRSReplicaSet[6] = { &colName, &colReplicaComputer, &colReplicaDomain, &colClass, &colDesc, NULL };
PATTRIBUTE_COLUMN colsFRSMember[6] = { &colConnectionName, &colFromFRSComputer, &colFromFRSDomain, &colClass, &colDesc, NULL };
PATTRIBUTE_COLUMN colsFSP[5] = { &colName, &colClass, &colDesc, &colNameFromSID,  NULL };

PATTRIBUTE_COLUMN colsDefault[4] = { &colName, &colClass, &colDesc, NULL };

// currently, any additional columns must be of string type
COLUMNS_FOR_CLASS g_colarray[] = {
    { _T("subnetContainer"),  _T("subnetContainer"),  5, colsSubnetContainer },
    { _T("sitesContainer"),   _T("sitesContainer"),   4, colsSitesContainer},
    { _T("serversContainer"), _T("serversContainer"), 5, colsServersContainer},
    { _T("nTDSDSA"),          _T("nTDSDSA"),          5, colsNTDSDSA },
    { _T("interSiteTransport"), _T("interSiteTransport"), 5, colsInterSiteTransport},
    { _T("nTFRSReplicaSet"),  _T("nTFRSReplicaSet"),  5, colsFRSReplicaSet },
    { _T("nTFRSMember"),      _T("nTFRSMember"),      5, colsFRSMember },
    { _T("ForeignSecurityPrincipals"), _T("ForeignSecurityPrincipals"), 4, colsFSP },
    { NULL,                  DEFAULT_COLUMN_SET,     3, colsDefault } // empty one at the end; must be here
    };

/*
COLUMNS_FOR_CLASS* GetColumnsForClass( LPCTSTR i_pcszLdapClassName )
{
  if (NULL == i_pcszLdapClassName)
    i_pcszLdapClassName = L"";
  COLUMNS_FOR_CLASS* pColsForClass;
  for (pColsForClass = g_colarray; NULL != pColsForClass->pcszLdapClassName; pColsForClass++) {
    if ( 0 == _wcsicmp(i_pcszLdapClassName, pColsForClass->pcszLdapClassName) ) {
      break;
    }
  }
  ASSERT( NULL != pColsForClass );
  return pColsForClass;
}
*/


////////////////////////////////////////////////////////////////////////////////////
// CDSColumnSet

CDSColumnSet* CDSColumnSet::CreateColumnSet(PCOLUMNS_FOR_CLASS pColsForClass, SnapinType snapinType)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  // Using the class name as both the column id and the class name for the column set
  CDSColumnSet* pNewColumnSet = new CDSColumnSet(pColsForClass->pcszColumnID, pColsForClass->pcszLdapClassName);
  if (!pNewColumnSet)
  {
    TRACE(L"Unable to allocate memory for new column set\n");
    ASSERT(FALSE);
    return 0;
  }

  UINT nUserColCount = 0;
  for (int idx = 0; idx < pColsForClass->nColumns; idx ++)
  {
    CString cstrHeader;
    CDSColumn* pNewColumn;

    if (pColsForClass->apColumns[idx]->resid == 0)
    {
      // Don't add the exchange special columns in DSSite
      if (snapinType == SNAPINTYPE_SITE)
        continue;

      cstrHeader.LoadString(g_specialCols[nUserColCount].resid);
      pNewColumn = new CDSColumn((LPCWSTR)cstrHeader,
                                          LVCFMT_LEFT,
                                          g_specialCols[nUserColCount].iColumnWidth,
                                          idx,
                                          FALSE,
                                          g_specialCols[nUserColCount].ptszAttribute,
                                          pColsForClass->apColumns[idx]->coltype,
                                          pColsForClass->apColumns[idx]->pfnExtract);
      nUserColCount++;
    }
    else
    {
      cstrHeader.LoadString(pColsForClass->apColumns[idx]->resid);
      pNewColumn = new CDSColumn((LPCWSTR)cstrHeader,
                                          LVCFMT_LEFT,
                                          pColsForClass->apColumns[idx]->iColumnWidth,
                                          idx,
                                          TRUE,
                                          pColsForClass->apColumns[idx]->pcszAttribute,
                                          pColsForClass->apColumns[idx]->coltype,
                                          pColsForClass->apColumns[idx]->pfnExtract);
    }
    ASSERT(pNewColumn);
    if (pNewColumn)
    {
      pNewColumnSet->AddColumn(pNewColumn);
    }
  }
  return pNewColumnSet;
}


CDSColumnSet* CDSColumnSet::CreateColumnSetFromString(LPCWSTR lpszClassName, SnapinType snapinType)
{
  COLUMNS_FOR_CLASS* pColsForClass;
  for (pColsForClass = g_colarray; pColsForClass->pcszLdapClassName != NULL; pColsForClass++)
  {
    if (lpszClassName != NULL && pColsForClass->pcszLdapClassName != NULL)
    {
      if (wcscmp(pColsForClass->pcszLdapClassName, lpszClassName) == 0)
      {
        break;
      }
    }
  }
  return CDSColumnSet::CreateColumnSet(pColsForClass, snapinType);
}

CDSColumnSet* CDSColumnSet::CreateDescriptionColumnSet()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  CString szNameHeader;
  VERIFY(szNameHeader.LoadString(IDS_COLUMN_NAME));
  CColumn* pNameColumn = new CColumn(szNameHeader,
                                     LVCFMT_LEFT,
                                     100,
                                     0,
                                     TRUE);
  
  if (pNameColumn == NULL)
  {
    return NULL;
  }

  CString szDescriptionHeader;
  VERIFY(szDescriptionHeader.LoadString(IDS_COLUMN_DESCRIPTION));
  CColumn* pDescColumn = new CColumn(szDescriptionHeader,
                                     LVCFMT_LEFT,
                                     150,
                                     1,
                                     TRUE);
  if (pDescColumn == NULL)
  {
    return NULL;
  }

  CDSColumnSet* pDSColumnSet = new CDSColumnSet(L"***---Description Set---***", NULL);
  if (pDSColumnSet == NULL)
  {
    return NULL;
  }

  pDSColumnSet->AddColumn(pNameColumn);
  pDSColumnSet->AddColumn(pDescColumn);
  return pDSColumnSet;
}

CDSColumnSet* CDSColumnSet::CreateColumnSetFromDisplaySpecifiers(PCWSTR pszClassName, SnapinType snapinType, MyBasePathsInfo* pBasePathsInfo)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = S_OK;
  CDSColumnSet* pNewColumnSet = NULL;
  BOOL bDefaultHardcodedSet = FALSE;

  //
  // Using the class name as both the column id and the class name for the column set
  //
  pNewColumnSet = new CDSColumnSet(pszClassName, pszClassName);
  if (pNewColumnSet != NULL)
  {
    //
    // Start with the hardcoded columns
    //
    COLUMNS_FOR_CLASS* pColsForClass;
    for (pColsForClass = g_colarray; pColsForClass->pcszLdapClassName != NULL; pColsForClass++)
    {
      if (pszClassName != NULL && pColsForClass->pcszLdapClassName != NULL)
      {
        if (wcscmp(pColsForClass->pcszLdapClassName, pszClassName) == 0)
        {
          break;
        }
      }
    }

    if (pColsForClass != NULL)
    {
      if (wcscmp(pColsForClass->pcszColumnID, DEFAULT_COLUMN_SET) == 0)
      {
        bDefaultHardcodedSet = TRUE;
      }

      UINT nUserColCount = 0;
      for (int idx = 0; idx < pColsForClass->nColumns; idx ++)
      {
        CString cstrHeader;
        CDSColumn* pNewColumn;

        if (pColsForClass->apColumns[idx]->resid == 0)
        {
          // Don't add the exchange special columns in DSSite
          if (snapinType == SNAPINTYPE_SITE)
            continue;

          cstrHeader.LoadString(g_specialCols[nUserColCount].resid);
          pNewColumn = new CDSColumn((LPCWSTR)cstrHeader,
                                              LVCFMT_LEFT,
                                              g_specialCols[nUserColCount].iColumnWidth,
                                              idx,
                                              FALSE,
                                              g_specialCols[nUserColCount].ptszAttribute,
                                              pColsForClass->apColumns[idx]->coltype,
                                              pColsForClass->apColumns[idx]->pfnExtract);
          nUserColCount++;
        }
        else
        {
          cstrHeader.LoadString(pColsForClass->apColumns[idx]->resid);
          pNewColumn = new CDSColumn((LPCWSTR)cstrHeader,
                                              LVCFMT_LEFT,
                                              pColsForClass->apColumns[idx]->iColumnWidth,
                                              idx,
                                              TRUE,
                                              pColsForClass->apColumns[idx]->pcszAttribute,
                                              pColsForClass->apColumns[idx]->coltype,
                                              pColsForClass->apColumns[idx]->pfnExtract);
        }
        pNewColumnSet->AddColumn(pNewColumn);
      }
    }

    //
    // Now add the DS extraColumns
    //
    CStringList strListColumns;
    hr = GetDisplaySpecifierProperty(pszClassName, L"extraColumns", pBasePathsInfo, strListColumns);
    if (FAILED(hr))
    {
      hr = GetDisplaySpecifierProperty(pszClassName, L"extraColumns", pBasePathsInfo, strListColumns, true);
    }

    if (SUCCEEDED(hr))
    {
      UINT nColCount = static_cast<UINT>(pNewColumnSet->GetCount());
      POSITION pos = strListColumns.GetHeadPosition();
      while (pos != NULL)
      {
        CDSColumn* pNewColumn = NULL;

        CString szExtraColumn = strListColumns.GetNext(pos);
        if (!szExtraColumn.IsEmpty())
        {
          //
          // Parse the 5-tuple to get the elements to make the column
          //
          CString szAttributeName;
          CString szColHeader;
          BOOL    bVisible = TRUE;
          int     iColumnWidth = 0;
          GUID    guidCallbackInterface;  // unused.  Reserved for future callback interface

          PWSTR pszTemp = new WCHAR[szExtraColumn.GetLength() + 1];
          if (pszTemp != NULL)
          {
            wcscpy(pszTemp, (LPCWSTR)szExtraColumn);

            PWSTR pszVisible = NULL;
            PWSTR pszColumnWidth = NULL;
            PWSTR pszGuidCallback = NULL;

            PWSTR pszNextTuple = pszTemp;


            pszNextTuple = wcstok(pszTemp, L",");
            if (pszNextTuple != NULL)
            {
              szAttributeName = pszNextTuple;
            }

            pszNextTuple = wcstok(NULL, L",");
            if (pszNextTuple != NULL)
            {
              szColHeader = pszNextTuple;
            }

            pszNextTuple = wcstok(NULL, L",");
            if (pszNextTuple != NULL)
            {
              pszVisible = pszNextTuple;
              int i = _wtoi(pszVisible);
              if (i == 0)
              {
                bVisible = FALSE;
              }
              else
              {
                bVisible = TRUE;
              }
            }

            pszNextTuple = wcstok(NULL, L",");
            if (pszNextTuple != NULL)
            {
              pszColumnWidth = pszNextTuple;
              iColumnWidth = _wtoi(pszColumnWidth);
            }

            pszNextTuple = wcstok(NULL, L",");
            if (pszNextTuple != NULL)
            {
              pszGuidCallback = pszNextTuple;
              HRESULT hr2 = ::CLSIDFromString(pszGuidCallback, &guidCallbackInterface);
              if (FAILED(hr2))
              {
                memset(&guidCallbackInterface, 0, sizeof(GUID));
              }
            }

            //
            // Create the column with the retrieved data
            //
            pNewColumn = new CDSColumn((PCWSTR)szColHeader,
                                        LVCFMT_LEFT,
                                        iColumnWidth,
                                        nColCount++,
                                        bVisible,
                                        (PCWSTR)szAttributeName,
                                        ATTR_COLTYPE_SPECIAL,
                                        ColumnExtractAttribute); // this will be changed to the interface when that is implemented
          }

          delete[] pszTemp;
          
        }
        if (pNewColumn != NULL)
        {
          pNewColumnSet->AddColumn(pNewColumn);
        }
      }
    }
  }

  //
  // If we failed to retrieve columns from the display specifier
  // and we hit the default hardcoded set but we were not asking
  // for the default hardcoded set and the snapin isn't the sites snapin
  // Then we delete the column set and we will pickup the actual default
  // column set since we are returning NULL
  //
  if (FAILED(hr) && 
      bDefaultHardcodedSet && 
      _wcsicmp(pszClassName, DEFAULT_COLUMN_SET) != 0 &&
      snapinType != SNAPINTYPE_SITE)
  {
    delete pNewColumnSet;
    pNewColumnSet = NULL;
  }
  return pNewColumnSet;
}

HRESULT CColumnSet::Save(IStream* pStm)
{
  // save the column set ID
  HRESULT hr = SaveStringHelper(GetColumnID(), pStm);
  if (FAILED(hr))
    return hr;
  
  // save the # of visible columns and
  // the indexes of the visible columns
  // NOTICE: we use MMC's MMC_VISIBLE_COLUMNS format to be consitent
  // and to be able to read back easily

  INT nTotalCols = GetNumCols();

  // allocate a bit more than needed (i.e. total # of columns)
  MMC_VISIBLE_COLUMNS* pVisibleColumns = 
    (MMC_VISIBLE_COLUMNS*)new BYTE[sizeof(MMC_VISIBLE_COLUMNS) + (sizeof(INT)*(nTotalCols-1))];

  if (!pVisibleColumns)
  {
    return E_OUTOFMEMORY;
  }
  pVisibleColumns->nVisibleColumns = 0;
  int iIndex = 0;
  for (POSITION pos = GetHeadPosition(); (pos != NULL); )
  {
    CColumn* pCol = GetNext(pos);
    if (pCol->IsVisible())
    {
      pVisibleColumns->rgVisibleCols[pVisibleColumns->nVisibleColumns] = iIndex;
      (pVisibleColumns->nVisibleColumns)++;
    }
    iIndex++;
  }

  // save the right length of the struct
  ULONG nByteCount = sizeof(MMC_VISIBLE_COLUMNS) + (sizeof(INT)*(pVisibleColumns->nVisibleColumns-1));
  ULONG nBytesWritten;
  hr = pStm->Write((void*)pVisibleColumns, nByteCount, &nBytesWritten);
	if (SUCCEEDED(hr))
  {
    if (nBytesWritten < nByteCount)
    {
      hr = STG_E_CANTSAVE;
    }
  }

  delete[] pVisibleColumns;
  pVisibleColumns = 0;
  return hr;
}

HRESULT CColumnSet::Load(IStream* pStm)
{
  // NOTICE: we already loaded the column set ID and
  // got a columns set that matches this

  // read the # of visible columns
	DWORD dwColCount = 0;
  INT nCountMax = GetNumCols();
	HRESULT hr = LoadDWordHelper(pStm, &dwColCount);
	if (FAILED(hr) || ((INT)dwColCount > nCountMax))
		return E_FAIL;

  // allocate some space for the array past the struct
  MMC_VISIBLE_COLUMNS* pVisibleColumns = 
    (MMC_VISIBLE_COLUMNS*)new BYTE[sizeof(MMC_VISIBLE_COLUMNS) + (sizeof(INT)*(dwColCount-1))];
  if (!pVisibleColumns)
  {
    return E_OUTOFMEMORY;
  }
  pVisibleColumns->nVisibleColumns = (INT)dwColCount;

  // load the array of indexes of visible columns
  ULONG nBytesRead;

	ULONG nByteCount = sizeof(DWORD)*dwColCount;
  INT* pArr = pVisibleColumns->rgVisibleCols;
	hr = pStm->Read(pArr, nByteCount, &nBytesRead);
	if (SUCCEEDED(hr))
  {
    if (nBytesRead < nByteCount)
    {
      hr = E_FAIL;
    }
    else
    {
      // update columns
      AddVisibleColumns(pVisibleColumns);
    }
  }
  delete[] pVisibleColumns;
  pVisibleColumns = 0;
  return S_OK;
}




/////////////////////////////////////////////////////////////////////////////////////////
// CColumnSetList

void CColumnSetList::Initialize(SnapinType snapinType, 
                                MyBasePathsInfo* pBasePathsInfo)
{
  m_pBasePathsInfo = pBasePathsInfo;
  m_snapinType = snapinType;
}

//
// Find the column set given a column set ID
//
CColumnSet* CColumnSetList::FindColumnSet(LPCWSTR lpszColumnID)
{
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CColumnSet* pTempSet = GetNext(pos);
		ASSERT(pTempSet != NULL);

		LPCWSTR lpszTempNodeID = pTempSet->GetColumnID();

		if (wcscmp(lpszTempNodeID, lpszColumnID) == 0)
		{
			return pTempSet;
		}
	}
  CColumnSet* pNewColSet = CDSColumnSet::CreateColumnSetFromDisplaySpecifiers(lpszColumnID,
                                                                              m_snapinType,
                                                                              m_pBasePathsInfo);
  if (pNewColSet != NULL)
  {
    AddTail(pNewColSet);
    return pNewColSet;
  }
	return GetDefaultColumnSet();
}

CColumnSet* CColumnSetList::GetDefaultColumnSet()
{
  if (m_pDefaultColumnSet == NULL)
  {
    m_pDefaultColumnSet = CDSColumnSet::CreateColumnSetFromDisplaySpecifiers(DEFAULT_COLUMN_SET,
                                                                             m_snapinType,
                                                                             m_pBasePathsInfo);
  }
  return m_pDefaultColumnSet;
}

HRESULT CColumnSetList::Save(IStream* pStm)
{
  // save # of items in the list
	DWORD dwCount = (DWORD)GetCount(); // list count plus default column set
   if (m_pDefaultColumnSet)
   {
      dwCount++;
   }

	HRESULT hr = SaveDWordHelper(pStm, dwCount);
	if (FAILED(hr))
		return hr;


  // save columnset list
  for (POSITION pos = GetHeadPosition(); pos != NULL; )
	{
		CColumnSet* pTempSet = GetNext(pos);

    if (pTempSet == NULL)
    {
		  ASSERT(pTempSet != NULL);
      continue;
    }

    hr = pTempSet->Save(pStm);
  	if (FAILED(hr))
	  	return hr;
	}

  // save default column set
  if (m_pDefaultColumnSet != NULL)
  {
    hr = m_pDefaultColumnSet->Save(pStm);
  }
	return hr;
}

HRESULT CColumnSetList::Load(IStream* pStm)
{
  // load # of items in the list
  DWORD dwLoadCount;
  HRESULT hr = LoadDWordHelper(pStm, &dwLoadCount);
	if (FAILED(hr))
    return hr;

  // load column list
  CString szColumnID;
  for (DWORD iColSet = 0; iColSet< dwLoadCount; iColSet++)
  {
    // load the string with the name of the column set
    hr = LoadStringHelper(szColumnID, pStm);
    if (FAILED(hr))
      return hr;
    ASSERT(!szColumnID.IsEmpty());
    CColumnSet* pColumnSet = FindColumnSet(szColumnID);
    if (pColumnSet != NULL)
    {
      hr = pColumnSet->Load(pStm);
      if (FAILED(hr))
        return hr;
    }
  }

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsdirect.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSDirect.cpp
//
//  Contents:  ADSI wrapper object implementation
//
//  History:   02-feb-97 jimharr    Created
//             
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"

#include "dsutil.h"

#include "dsdirect.h"

#include "cmnquery.h"
#include "dsquery.h"
#include "dscache.h"
#include "dssnap.h"
#include "dsthread.h"
#include "newobj.h"
#include "querysup.h"

#include <lm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

extern inline
BOOL CleanName (LPWSTR pszObjectName) 
{
  WCHAR * ptr = NULL;
  ptr = wcschr (pszObjectName, L'=') + 1;
  if (ptr) {
    wcscpy (pszObjectName, ptr);
    return TRUE;
  } else
    return FALSE;
}


CDSDirect::CDSDirect()
{
  ASSERT (FALSE);
  m_pCD = NULL;
}

// WARNING: pCD may still be in its constructor and may not be fully constructed yet
CDSDirect::CDSDirect(CDSComponentData * pCD)
{
  m_pCD = pCD;
}


CDSDirect::~CDSDirect()
{
}

HRESULT CDSDirect::DeleteObject(CDSCookie* pCookie,
                         BOOL raiseUI)
{
  
  CComBSTR strParent;
  CComBSTR strThisRDN;
  CComPtr<IADsContainer> spDSContainer;
  CComPtr<IADs> spDSObject;

  // bind to the ADSI object
  CString strPath;
  m_pCD->GetBasePathsInfo()->ComposeADsIPath(strPath, pCookie->GetPath());
  
  HRESULT hr = DSAdminOpenObject(strPath,
                                 IID_IADs,
                                 (void **) &spDSObject,
                                 TRUE /*bServer*/);

  if (FAILED(hr)) 
  {
    goto error;
  }

  // retrieve the parent's path
  hr = spDSObject->get_Parent(&strParent);
  if (FAILED(hr)) 
  {
    goto error;
  }

  // get the RDN of this object
  hr = spDSObject->get_Name (&strThisRDN);
  if (FAILED(hr)) 
  {
    goto error;
  }
  
  // bind to the parent ADSI object
  hr = DSAdminOpenObject(strParent,
                         IID_IADsContainer,
                         (void **) &spDSContainer,
                         TRUE /*bServer*/);
  if (FAILED(hr)) 
  {
    goto error;
  }

  hr = spDSContainer->Delete((LPWSTR)(LPCWSTR)pCookie->GetClass(),
                             (LPWSTR)(LPCWSTR)strThisRDN);

error:
  if ((!SUCCEEDED(hr)) & raiseUI) 
  {
    HWND hwnd;
    m_pCD->m_pFrame->GetMainWindow(&hwnd);
    PVOID apv[1] = {(LPWSTR)pCookie->GetName()};
    ReportErrorEx( m_pCD->m_hwnd, IDS_12_DELETE_FAILED,
                   hr, MB_OK | MB_ICONERROR, apv, 1);
  }

  return hr;
}

HRESULT CDSDirect::GetParentDN(CDSCookie* pCookie, CString& szParentDN)
{
  HRESULT hr = S_OK;
  CString szObjPath;

  CComPtr<IADs> spDSObj;
  m_pCD->GetBasePathsInfo()->ComposeADsIPath(szObjPath, pCookie->GetPath());
  hr = DSAdminOpenObject(szObjPath,
                         IID_IADs,
                         (void **)&spDSObj,
                         TRUE /*bServer*/);
  if (SUCCEEDED(hr)) 
  {
    CComBSTR ParentPath;
    hr = spDSObj->get_Parent(&ParentPath);
    StripADsIPath(ParentPath, szParentDN);
  }
  return hr;
}



///////////////////////////////////////////////////////////////////////////
// CSnapinMoveHandler

class CSnapinMoveHandler : public CMoveHandlerBase
{
public:
    CSnapinMoveHandler(CDSComponentData* pComponentData, HWND hwnd, 
      LPCWSTR lpszBrowseRootPath, CDSCookie* pCookie)
    : CMoveHandlerBase(pComponentData, hwnd, lpszBrowseRootPath)
  {
      m_pCookie = pCookie;
  }

protected:
  virtual UINT GetItemCount() { return (UINT)1;}
  virtual HRESULT BeginTransaction()
  {
    return GetTransaction()->Begin(m_pCookie, 
                                   GetDestPath(), GetDestClass(), IsDestContainer());
  }
  virtual void GetNewPath(UINT, CString& szNewPath)
  {
    GetComponentData()->GetBasePathsInfo()->ComposeADsIPath(szNewPath, m_pCookie->GetPath());
  }
  virtual void GetName(UINT, CString& strref)
  { 
    strref = m_pCookie->GetName();
    return;
  }

  virtual void GetItemPath(UINT, CString& szPath)
  {
    szPath = m_pCookie->GetPath();
  }
  virtual PCWSTR GetItemClass(UINT)
  {
    return m_pCookie->GetClass();
  }
  virtual HRESULT OnItemMoved(UINT, IADs* pIADs)
  {
    CComBSTR bsPath;
    HRESULT hr = pIADs->get_ADsPath(&bsPath);
    if (SUCCEEDED(hr)) 
    {
      CString szPath;
      StripADsIPath(bsPath, szPath);
      m_pCookie->SetPath(szPath);
    }
    return hr;
  }
  virtual void GetClassOfMovedItem(CString& szClass)
  {
    szClass.Empty();
    if (NULL != m_pCookie)
      szClass = m_pCookie->GetClass();
  }

private:
  CDSCookie* m_pCookie;
};

HRESULT
CDSDirect::MoveObject(CDSCookie *pCookie)
{
  HWND hwnd;
  m_pCD->m_pFrame->GetMainWindow(&hwnd);

  HRESULT hr = S_OK;

  CString strPartialRootPath = m_pCD->GetRootPath();
  if (SNAPINTYPE_SITE == m_pCD->QuerySnapinType())
  {
      // This is where we correct the root path
    CPathCracker pathCracker;

    hr = pathCracker.Set(const_cast<BSTR>((LPCTSTR)strPartialRootPath), ADS_SETTYPE_DN);
    ASSERT( SUCCEEDED(hr) );
    long cRootPathElements = 0;
    hr = pathCracker.GetNumElements( &cRootPathElements );
    ASSERT( SUCCEEDED(hr) );
    CComBSTR bstr = pCookie->GetPath();
    hr = pathCracker.Set(bstr, ADS_SETTYPE_DN);
    ASSERT( SUCCEEDED(hr) );
    long cCookiePathElements = 0;
    hr = pathCracker.GetNumElements( &cCookiePathElements );
    ASSERT( SUCCEEDED(hr) );
    //
    // Strip off all but one path element past the base config path
    //
    for (INT i = cCookiePathElements - cRootPathElements; i > 1; i--)
    {
        hr = pathCracker.RemoveLeafElement();
        ASSERT( SUCCEEDED(hr) );
    }
    hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
    ASSERT( SUCCEEDED(hr) );
    hr = pathCracker.Retrieve( ADS_FORMAT_X500_DN, &bstr );
    ASSERT( SUCCEEDED(hr) && bstr != NULL );
    strPartialRootPath = bstr;
    ::SysFreeString( bstr );
  }

  CString strRootPath = m_pCD->GetBasePathsInfo()->GetProviderAndServerName();
  strRootPath += strPartialRootPath;

  CSnapinMoveHandler moveHandler(m_pCD, hwnd, strRootPath, pCookie);

  return moveHandler.Move();
}


HRESULT CDSDirect::RenameObject(CDSCookie* pCookie, LPCWSTR NewName)
{
  HRESULT hr = S_OK;
  IADs * pDSObject = NULL;
  IDispatch * pDispObj = NULL;
  IADsContainer * pContainer = NULL;
  CComBSTR bsParentPath;
  CString szNewAttrName;
  CString szNewNamingContext;
  CString szClass;
  CString szObjectPath, szNewPath;
  CString csNewName;
  CString szPath;
  CDSClassCacheItemBase* pItem = NULL;
  CComBSTR bsEscapedName;

  CPathCracker pathCracker;

  HWND hwnd;
  m_pCD->m_pFrame->GetMainWindow(&hwnd);

  //
  // create a transaction object, the destructor will call End() on it
  //
  CDSNotifyHandlerTransaction transaction(m_pCD);
  transaction.SetEventType(DSA_NOTIFY_REN);

  if (pCookie == NULL)
  {
    return E_INVALIDARG;
  }

  //
  // Retrieve class info from cache
  //
  szClass = pCookie->GetClass();
  BOOL found = m_pCD->m_pClassCache->Lookup ((LPCWSTR)szClass, pItem);
  ASSERT (found == TRUE);
  
  csNewName = NewName;
  csNewName.TrimLeft();
  csNewName.TrimRight();

  //
  // get the new name in the form "cn=foo" or "ou=foo"
  //
  szNewAttrName = pItem->GetNamingAttribute();
  szNewAttrName += L"=";
  szNewAttrName += csNewName;
  TRACE(_T("_RenameObject: Attributed name is %s.\n"), szNewAttrName);

  //
  // bind to object
  //
  m_pCD->GetBasePathsInfo()->ComposeADsIPath(szObjectPath, pCookie->GetPath());
  hr = DSAdminOpenObject(szObjectPath,
                         IID_IADs,
                         (void **)&pDSObject,
                         TRUE /*bServer*/);
  if (!SUCCEEDED(hr)) 
  {
    goto error;
  }

  //
  // get the path of the object container
  //
  hr = pDSObject->get_Parent (&bsParentPath);
  if (!SUCCEEDED(hr)) 
  {
    goto error;
  }

  pDSObject->Release();
  pDSObject = NULL;
  
  //
  // bind to the object container
  //
  hr = DSAdminOpenObject(bsParentPath,
                         IID_IADsContainer,
                         (void **)&pContainer,
                         TRUE /*bServer*/);
  if (!SUCCEEDED(hr)) 
  {
    goto error;
  }

  //
  // build the new LDAP path
  //
  szNewNamingContext = szNewAttrName;
  szNewNamingContext += L",";
  StripADsIPath(bsParentPath, szPath);
  szNewNamingContext += szPath;
  m_pCD->GetBasePathsInfo()->ComposeADsIPath(szNewPath, szNewNamingContext);

  //
  // start the transaction
  //
  // It's ok for containerness to be determined from the cookie since we are concerned 
  // whether the DS object is a container not whether it is a container in the UI
  //
  hr = transaction.Begin(pCookie, szNewPath, szClass, pCookie->IsContainerClass());

  //
  // ask for confirmation
  //
  if (transaction.NeedNotifyCount() > 0)
  {
    CString szMessage, szAssocData;
    szMessage.LoadString(IDS_CONFIRM_RENAME);
    szAssocData.LoadString(IDS_EXTENS_RENAME);
    CConfirmOperationDialog dlg(hwnd, &transaction);
    dlg.SetStrings(szMessage, szAssocData);
    if (IDNO == dlg.DoModal())
    {
      transaction.End();
      hr = S_OK;
      goto error;
    }
  }

  hr = pathCracker.GetEscapedElement(0, //reserved
                                   (BSTR)(LPCWSTR)szNewAttrName,
                                   &bsEscapedName);
  if (FAILED(hr))
  {
    goto error;
  }

  //
  // do the actual rename
  //
  hr = pContainer->MoveHere((LPWSTR)(LPCWSTR)szObjectPath,
                            (LPWSTR)(LPCWSTR)bsEscapedName,
                            &pDispObj);
  if (SUCCEEDED(hr)) 
  {
    transaction.Notify(0); // let extensions know
  }
  else
  {
    TRACE(_T("Object Rename Failed with hr: %lx\n"), hr);
    goto error;
  }

  //
  // rebuild the naming info for the cookie
  //
  hr = pDispObj->QueryInterface (IID_IADs,
                                 (void **)&pDSObject);
  if (SUCCEEDED(hr)) 
  {
    CComBSTR bsPath;
    hr = pDSObject->get_ADsPath(&bsPath);
    if (SUCCEEDED(hr)) 
    {
      StripADsIPath(bsPath, szPath);
      pCookie->SetPath(szPath);

      //
      // remove escaping from name
      //

      hr = pathCracker.Set((LPWSTR)bsPath, ADS_SETTYPE_FULL);
      ASSERT(SUCCEEDED(hr));

      hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
      ASSERT(SUCCEEDED(hr));

      hr = pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);
      ASSERT(SUCCEEDED(hr));
      hr = pathCracker.GetElement( 0, &bsPath );
      ASSERT(SUCCEEDED(hr));

      pCookie->SetName((LPWSTR)bsPath);
    }
  }

error:
  //
  // transaction.End() will be called by the transaction's destructor
  //

  //
  // clear pointers
  //
  if (pDispObj)
  {
    pDispObj->Release();
  }

  if (pDSObject)
  {
    pDSObject->Release();
  }  
  return hr;
}

CDSComponentData* g_pCD = NULL; 

HRESULT
CDSDirect::DSFind(HWND hwnd, LPCWSTR lpszBaseDN)
{
  HRESULT hr;
  DSQUERYINITPARAMS dqip;
  OPENQUERYWINDOW oqw;
  ZeroMemory(&dqip, sizeof(DSQUERYINITPARAMS));
  ZeroMemory(&oqw, sizeof(OPENQUERYWINDOW));

  ICommonQuery * pCommonQuery = NULL;
  IDataObject * pDataObject = NULL;
  
  hr = CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER,
                        IID_ICommonQuery, (PVOID *)&pCommonQuery);
  if (!SUCCEEDED(hr)) {
    ReportErrorEx( (m_pCD) ? m_pCD->m_hwnd : NULL, IDS_1_CANT_CREATE_FIND,
                   hr, MB_OK | MB_ICONERROR, NULL, 0);
    return hr;
  }
  
  CString szPath;
  m_pCD->GetBasePathsInfo()->ComposeADsIPath(szPath, lpszBaseDN);
  LPWSTR pszDefPath = (LPWSTR)(LPCWSTR)szPath;
  dqip.cbStruct = sizeof(dqip);
  dqip.dwFlags = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS | 
    DSQPF_ENABLEADMINFEATURES;
  if (m_pCD->IsAdvancedView()) {
    dqip.dwFlags |= DSQPF_ENABLEADVANCEDFEATURES;
  }
  dqip.pDefaultScope = pszDefPath;

  dqip.pUserName = NULL;
  dqip.pPassword = NULL;
  dqip.pServer = (LPWSTR)(m_pCD->GetBasePathsInfo()->GetServerName());
  dqip.dwFlags |= DSQPF_HASCREDENTIALS;

  oqw.cbStruct = sizeof(oqw);
  oqw.dwFlags = OQWF_SHOWOPTIONAL;
  oqw.clsidHandler = CLSID_DsQuery;
  oqw.pHandlerParameters = &dqip;
  //  oqw.clsidDefaultForm = CLSID_NULL;
  
  g_pCD = m_pCD;
  HWND hwndHidden = m_pCD->GetHiddenWindow();
  SetWindowText(hwndHidden,L"DS Find");

  hr = pCommonQuery->OpenQueryWindow(hwnd, &oqw, &pDataObject);
  
  SetWindowText(hwndHidden, NULL);
  g_pCD = NULL;

  if (FAILED(hr)) {
    ReportErrorEx( m_pCD->m_hwnd, IDS_1_FIND_ERROR,
                   hr, MB_OK | MB_ICONERROR, NULL, 0);
  }
  pCommonQuery->Release();
  if (pDataObject) {
    pDataObject->Release();
  }
  return hr;
}



HRESULT CDSDirect::EnumerateContainer(CDSThreadQueryInfo* pQueryInfo, 
                                       CWorkerThread* pWorkerThread)
{
  ASSERT(!pQueryInfo->m_bTooMuchData);
  ASSERT((pQueryInfo->GetType() == dsFolder) || (pQueryInfo->GetType() == queryFolder));
  
  BEGIN_PROFILING_BLOCK("CDSDirect::EnumerateContainer");

  HRESULT hr = S_OK;
  CString ADsPath;  

  UINT nCurrCount = 0;
  UINT nMaxCount = pQueryInfo->GetMaxItemCount();
  BOOL bOverLimit = FALSE;


  //
  // This wouldn't normally be the way to use the CPathCracker object
  // but for performance reasons we are going to create a single instance
  // for enumerating and pass a reference to the SetCookieFromData so
  // that we don't do a CoCreateInstance for each cookie
  //
  CPathCracker specialPerformancePathCracker;  


  m_pCD->GetBasePathsInfo()->ComposeADsIPath(ADsPath, pQueryInfo->GetPath());

  CDSSearch ContainerSrch(m_pCD->m_pClassCache, m_pCD);

  CDSColumnSet* pColumnSet = NULL;

  CString szPath;
  szPath = pQueryInfo->GetPath();
  CPathCracker pathCracker;
  hr = pathCracker.Set(const_cast<BSTR>((LPCTSTR)szPath), ADS_SETTYPE_DN);
  if (SUCCEEDED(hr))
  {
    CComBSTR bstrLeaf;
    hr = pathCracker.GetElement(0, &bstrLeaf);
    if (SUCCEEDED(hr))
    {
      szPath = bstrLeaf;
    }
  }

  if (szPath.Find(_T("ForeignSecurityPrincipals")) != -1)
  {
    pColumnSet = m_pCD->FindColumnSet(L"ForeignSecurityPrincipals");
  }
  else
  {
    pColumnSet = m_pCD->FindColumnSet(pQueryInfo->GetColumnSetID());
  }
  ASSERT(pColumnSet != NULL);

  hr = ContainerSrch.Init (ADsPath);
  if (!SUCCEEDED(hr))
    goto exiting;

  // CODEWORK this redoes the GetColumnsForClass calculation
  ContainerSrch.SetAttributeListForContainerClass (pColumnSet);
  ContainerSrch.SetFilterString ((LPWSTR)pQueryInfo->GetQueryString());
  
  ContainerSrch.SetSearchScope(pQueryInfo->IsOneLevel() ? ADS_SCOPE_ONELEVEL : ADS_SCOPE_SUBTREE);

  hr = ContainerSrch.DoQuery();
  if (FAILED(hr)) 
    goto exiting;


  hr = ContainerSrch.GetNextRow ();
  while ((hr == S_OK) && !bOverLimit ) {
    CDSCookie* pNewCookie = new CDSCookie();
    HRESULT hr2 = ContainerSrch.SetCookieFromData(pNewCookie,
                                                  specialPerformancePathCracker,
                                                  pColumnSet);
    if (SUCCEEDED(hr2)) {
      CDSUINode* pDSUINode = new CDSUINode(NULL);
      pDSUINode->SetCookie(pNewCookie);

      if (pQueryInfo->GetType() == dsFolder)
      {
        if (pNewCookie->IsContainerClass())
          pDSUINode->MakeContainer();
      }

      pWorkerThread->AddToQueryResult(pDSUINode);
      if (pWorkerThread->MustQuit())
        break;
    } else {
      delete pNewCookie;
    }
    hr = ContainerSrch.GetNextRow();
    if (hr == S_OK) {
      nCurrCount++;
      if (nCurrCount >= nMaxCount)
        bOverLimit = TRUE;
    }

  }
  pQueryInfo->m_bTooMuchData = bOverLimit;

exiting:
  END_PROFILING_BLOCK;
  return hr;
}

HRESULT CDSDirect::EnumerateRootContainer(CDSThreadQueryInfo* pQueryInfo, 
                                           CWorkerThread* pWorkerThread)
{
	ASSERT(pQueryInfo->GetType() == rootFolder);
	HRESULT hr = S_OK;
	m_pCD->Lock();

  //
  // build the nodes below the root
  //

  if (m_pCD->QuerySnapinType() == SNAPINTYPE_SITE)
  {
    hr = CreateRootChild(TEXT("CN=Sites,"), pQueryInfo, pWorkerThread);
    if (!pWorkerThread->MustQuit() && m_pCD->ViewServicesNode())
    {
      hr = CreateRootChild(TEXT("CN=Services,"), pQueryInfo, pWorkerThread);
    }
  }
  else
  {
    hr = CreateRootChild(TEXT(""), pQueryInfo, pWorkerThread);
  }

	if (m_pCD->m_CreateInfo.IsEmpty()) 
	{
		InitCreateInfo();
	}
	m_pCD->Unlock();

	return hr;
}

HRESULT CDSDirect::CreateRootChild(LPCTSTR lpcszPrefix, 
                                    CDSThreadQueryInfo* pQueryInfo, 
                                    CWorkerThread* pWorkerThread)
{
  TRACE(L"CDSDirect::CreateRootChild(%s)\n", lpcszPrefix);

  TRACE(L"pQueryInfo->GetPath() = %s\n", pQueryInfo->GetPath());

  CString BasePath = lpcszPrefix;
  BasePath += pQueryInfo->GetPath();

  CString ADsPath;
  m_pCD->GetBasePathsInfo()->ComposeADsIPath(OUT ADsPath, IN BasePath);

  // create a search object and bind to it
  CDSSearch Search(m_pCD->m_pClassCache, m_pCD);
  HRESULT hr = Search.Init(ADsPath);
  TRACE(L"Search.Init(%s) returned hr = 0x%x\n", (LPCWSTR)ADsPath, hr);
  if (FAILED(hr))
  {
    return hr;
  }

  //
  // set query parameters
  //
  // Search for just this object
  //
  Search.SetSearchScope(ADS_SCOPE_BASE); 

  CUIFolderInfo* pFolderInfo = m_pCD->GetRootNode()->GetFolderInfo();
  if (pFolderInfo == NULL)
  {
    //
    // This shouldn't happen, but just to be on the safe side...
    //
    ASSERT(FALSE); 
    Search.SetAttributeList((LPWSTR *)g_pStandardAttributes, 
                            g_nStdCols);
  }
  else
  {
    CDSColumnSet* pColumnSet = m_pCD->GetRootNode()->GetColumnSet(m_pCD);
    Search.SetAttributeListForContainerClass(pColumnSet);
  }
  Search.SetFilterString (L"(objectClass=*)");
  
  
  // execute the query
  hr = Search.DoQuery();
  TRACE(L"Search.DoQuery() returned hr = 0x%x\n", hr);
  if (FAILED(hr))
  {
    return hr;
  }

  TRACE(L"Search.GetNextRow() returned hr = 0x%x\n", hr);
  hr = Search.GetNextRow();
  if (FAILED(hr))
  {
    return hr;
  }
  
  //
  // we got a query result, create a new cookie object
  // and initialize it from the query result
  //
  CDSCookie* pNewCookie = new CDSCookie;
  Search.SetCookieFromData(pNewCookie,NULL);
  TRACE(L"Got cookie, pNewCookie->GetName() = %s\n", pNewCookie->GetName());

  //
  // special case if it is a domain DNS object,
  // we want fo get the canonical name for display
  //
  if (wcscmp(pNewCookie->GetClass(), L"domainDNS") == 0) 
  {
    ADS_SEARCH_COLUMN Column;
    CString csCanonicalName;
    int slashLocation;
    LPWSTR canonicalNameAttrib = L"canonicalName";
    Search.SetAttributeList (&canonicalNameAttrib, 1);
    
    hr = Search.DoQuery();
    if (FAILED(hr))
    {
      return hr;
    }

    hr = Search.GetNextRow();
    if (FAILED(hr))
    {
      return hr;
    }

    hr = Search.GetColumn(canonicalNameAttrib, &Column);
    if (FAILED(hr))
    {
      return hr;
    }

    ColumnExtractString (csCanonicalName, pNewCookie, &Column);
    slashLocation = csCanonicalName.Find('/');
    if (slashLocation != 0) 
    {
      csCanonicalName = csCanonicalName.Left(slashLocation);
    }
    //
    pNewCookie->SetName(csCanonicalName);
    TRACE(L"canonical name pNewCookie->GetName() = %s\n", pNewCookie->GetName());
    
    //
    // Free column data
    //
    Search.FreeColumn(&Column);
  }

  //
  // Add the new node to the result list
  CDSUINode* pDSUINode = new CDSUINode(NULL);
  pDSUINode->SetCookie(pNewCookie);
  if (pNewCookie->IsContainerClass())
    pDSUINode->MakeContainer();
  pWorkerThread->AddToQueryResult(pDSUINode);

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDSDirect::InitCreateInfo
//
//  Synopsis:   read schema and finds all object names that for whom
//              defaultHidingValue is TRUE;
//
//-----------------------------------------------------------------------------
HRESULT CDSDirect::InitCreateInfo(void)
{
  HRESULT hr = S_OK;
  LPWSTR pAttrs[2] = {L"name",
                      L"lDAPDisplayName"};

  CDSSearch Search (m_pCD->GetClassCache(), m_pCD);
  ADS_SEARCH_COLUMN Column;
  CString csFilter;

  CString szSchemaPath;
  m_pCD->GetBasePathsInfo()->GetSchemaPath(szSchemaPath);
  Search.Init (szSchemaPath);

  csFilter = L"(&(objectCategory=CN=Class-Schema,";
  csFilter += m_pCD->GetBasePathsInfo()->GetSchemaNamingContext();
  csFilter += L")(defaultHidingValue=FALSE))";

  Search.SetFilterString((LPWSTR)(LPCWSTR)csFilter);
  Search.SetAttributeList (pAttrs, 2);
  Search.SetSearchScope(ADS_SCOPE_ONELEVEL);

  hr = Search.DoQuery();
  if (SUCCEEDED(hr)) 
  {
    hr = Search.GetNextRow();
    if(FAILED(hr)) 
    {
      TRACE(_T("Search::GetNextRow failed \n"));
      goto error;
    }

    while (hr == S_OK) 
    {
      hr = Search.GetColumn (pAttrs[1], &Column);
      if (SUCCEEDED(hr)) 
      {
        if (!((!wcscmp(Column.pADsValues->CaseIgnoreString, L"builtinDomain")) ||
              (!wcscmp(Column.pADsValues->CaseIgnoreString, L"localGroup")) ||
              (!wcscmp(Column.pADsValues->CaseIgnoreString, L"domainDNS")) ||
              (!wcscmp(Column.pADsValues->CaseIgnoreString, L"domain")) ||
              (!wcscmp(Column.pADsValues->CaseIgnoreString, L"organization")) ||
              (!wcscmp(Column.pADsValues->CaseIgnoreString, L"locality")))) 
        {
          m_pCD->m_CreateInfo.AddTail (Column.pADsValues->CaseIgnoreString);
          TRACE(_T("added to createinfo: %s\n"),
                Column.pADsValues->CaseIgnoreString); 
        }
        Search.FreeColumn (&Column);
      } 
      else 
      { 
        goto error;
      }
      hr = Search.GetNextRow();
    }
  }


error:
  if (m_pCD->m_CreateInfo.IsEmpty()) 
  {
    ReportErrorEx (m_pCD->m_hwnd,IDS_1_CANT_GET_SCHEMA_CREATE_INFO,hr,
                            MB_OK | MB_ICONERROR, NULL, 0);
  }
  return hr;
}



HRESULT CDSDirect::ReadDSObjectCookie(IN CDSUINode* pContainerDSUINode, // IN: container where to create object
                                      IN LPCWSTR lpszLdapPath, // path of the object
                                      OUT CDSCookie** ppNewCookie)	// newly created cookie
{
  CComPtr<IADs> spADs;
  HRESULT hr = DSAdminOpenObject(lpszLdapPath,
                                 IN IID_IADs,
                                 OUT (LPVOID *) &spADs,
                                 TRUE /*bServer*/);
  if (FAILED(hr))
  {
    return hr;
  }
  return ReadDSObjectCookie(pContainerDSUINode, spADs, ppNewCookie);
}



HRESULT CDSDirect::ReadDSObjectCookie(IN CDSUINode* pContainerDSUINode, // IN: container where to create object
                                      IN IADs* pADs, // pointer to an already bound ADSI object
                                      OUT CDSCookie** ppNewCookie)	// newly created cookie
{
  ASSERT(pContainerDSUINode != NULL);
  ASSERT(pContainerDSUINode->IsContainer());
  ASSERT(pADs != NULL);
  ASSERT(ppNewCookie != NULL);

  // create a new cookie and load data from the DS
  CDSCookie * pDsCookieNew = new CDSCookie();
  CComPtr<IDirectorySearch> spDirSearch;

  CDSColumnSet* pColumnSet = pContainerDSUINode->GetColumnSet(m_pCD);
  ASSERT(pColumnSet != NULL);
  
  HRESULT hr = pADs->QueryInterface (IID_IDirectorySearch, (void **)&spDirSearch);
  ASSERT (hr == S_OK);
  CDSSearch Search(m_pCD->GetClassCache(), m_pCD);
  Search.Init(spDirSearch);
  Search.SetSearchScope(ADS_SCOPE_BASE);

  Search.SetAttributeListForContainerClass(pColumnSet);
  Search.SetFilterString (L"(objectClass=*)");
  Search.DoQuery();
  hr = Search.GetNextRow();

  if (SUCCEEDED(hr) && (hr != S_ADS_NOMORE_ROWS))
  {
    // we got the data, set the cookie
    Search.SetCookieFromData(pDsCookieNew, pColumnSet);
    *ppNewCookie = pDsCookieNew;
    pDsCookieNew = NULL; 
  }      
  
  if (pDsCookieNew != NULL)
  {
    delete pDsCookieNew;
  }
  return hr;
}


/////////////////////////////////////////////////////////////////////
//	CDSDirect::CreateDSObject()
//
//	Create a new ADs object.
//
HRESULT CDSDirect::CreateDSObject(CDSUINode* pContainerDSUINode, // IN: container where to create object
                                  LPCWSTR lpszObjectClass, // IN: class of the object to be created
                                  IN CDSUINode* pCopyFromDSUINode, // IN: (optional) object to be copied
                                  OUT CDSCookie** ppSUINodeNew)	// OUT: OPTIONAL: Pointer to new node
{
  ASSERT(pContainerDSUINode != NULL);
  ASSERT(pContainerDSUINode->IsContainer());
  ASSERT(lpszObjectClass != NULL);
  ASSERT(ppSUINodeNew != NULL);

  CDSCookie* pContainerDsCookie = pContainerDSUINode->GetCookie();
  ASSERT(pContainerDsCookie != NULL);


  CComPtr<IADsContainer> spIADsContainer;
  IADs* pIADs = NULL;
  CDSClassCacheItemBase* pDsCacheItem = NULL;
  HRESULT hr;
  
  // Data structure to hold temporary attribute information to create object
  CNewADsObjectCreateInfo createinfo(m_pCD->GetBasePathsInfo(), lpszObjectClass);

  {
    CWaitCursor wait;
    CString strContainerADsIPath;
    m_pCD->GetBasePathsInfo()->ComposeADsIPath(strContainerADsIPath, pContainerDsCookie->GetPath());
    hr = DSAdminOpenObject(strContainerADsIPath,
                           IN IID_IADsContainer,
                           OUT (LPVOID *) &spIADsContainer,
                           TRUE /*bServer*/);
    if (FAILED(hr))
    {
      PVOID apv[1] = {(LPWSTR)pContainerDsCookie->GetName()};
      ReportErrorEx (m_pCD->m_hwnd,IDS_12_CONTAINER_NOT_FOUND,hr,
                     MB_OK | MB_ICONERROR, apv, 1);
      hr = S_FALSE;	// Avoid display another error message to user
      goto CleanUp;
    }

    // Lookup if the object classname is in the cache
    pDsCacheItem = m_pCD->GetClassCache()->FindClassCacheItem(m_pCD, lpszObjectClass, NULL);
    ASSERT(pDsCacheItem != NULL);
  }

  createinfo.SetContainerInfo(IN spIADsContainer, IN pDsCacheItem, IN m_pCD);

  if (pCopyFromDSUINode != NULL)
  {
    CDSCookie* pCopyFromDsCookie = pCopyFromDSUINode->GetCookie();
    CComPtr<IADs> spIADsCopyFrom;
    CString szPath;
    m_pCD->GetBasePathsInfo()->ComposeADsIPath(szPath, pCopyFromDsCookie->GetPath());

    hr = createinfo.SetCopyInfo(szPath);
    if (FAILED(hr))
    {
      PVOID apv[1] = {(LPWSTR)pCopyFromDsCookie->GetName()};
      ReportErrorEx (m_pCD->m_hwnd,IDS_12_COPY_READ_FAILED,hr,
                     MB_OK | MB_ICONERROR, apv, 1);
      hr = S_FALSE;	// Avoid display another error message to user
      goto CleanUp;

    }
  }

  hr = createinfo.HrLoadCreationInfo();
  if (FAILED(hr))
  {
    goto CleanUp;
  }

  // launch the creation DS object creation wizard
  hr = createinfo.HrDoModal(m_pCD->m_hwnd);


  // now examine the results of the call
  pIADs = createinfo.PGetIADsPtr();
  if (hr != S_OK)
  {
    // Object was not created because user hit "Cancel" or an error occured.
    goto CleanUp;
  }

  if (pIADs == NULL)
  {
    TRACE0("ERROR: Inconsistency between return value from HrDoModal() and IADs pointer.\n");
    ReportErrorEx (m_pCD->m_hwnd,IDS_ERR_FATAL,S_OK,
                   MB_OK | MB_ICONERROR, NULL, 0);
    hr = S_FALSE;	// Avoid display another error message to user
    goto CleanUp;
  }

  

  // successful creation, we need to create a node object for the UI
  if (pContainerDSUINode->GetFolderInfo()->IsExpanded()) 
  {
    ReadDSObjectCookie(pContainerDSUINode, pIADs, ppSUINodeNew);
  } // if expanded
        
CleanUp:
  if (FAILED(hr)) 
  {
    CString Name;
    Name = createinfo.GetName();
    PVOID apv[1] = {(LPWSTR)(LPCWSTR)Name};
    ReportErrorEx (m_pCD->m_hwnd,IDS_12_GENERIC_CREATION_FAILURE,hr,
                   MB_OK | MB_ICONERROR, apv, 1);
  }
  if (pIADs != NULL)
    pIADs->Release();
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsctx.h ===
//
// dsctx.h : Declaration of ds context menu class
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      dsctx.h
//
//  Contents:  context menu extension for DS classes
//
//  History:   08-dec-97 jimharr    Created
//
//--------------------------------------------------------------------------

#ifndef __DSCTX_H_
#define __DSCTX_H_


#include "dssnap.h"



//////////////////////////////////////////////////////////////////////////////////
// CDSContextMenu

class CContextMenuMultipleDeleteHandler;
class CContextMenuSingleDeleteHandler;

class CDSContextMenu:
  IShellExtInit,
  IContextMenu,
  public CComObjectRootEx<CComSingleThreadModel>,
  public CComCoClass<CDSContextMenu, &CLSID_DSContextMenu>
{
  BEGIN_COM_MAP(CDSContextMenu)
    COM_INTERFACE_ENTRY(IShellExtInit)
    COM_INTERFACE_ENTRY(IContextMenu)
  END_COM_MAP()

public:
  DECLARE_REGISTRY_CLSID()

  CDSContextMenu();
  ~CDSContextMenu();


  // IShellExtInit
  STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder, 
                          LPDATAOBJECT pDataObj, 
                          HKEY hKeyID );
  
  // IContextMenu
  STDMETHODIMP QueryContextMenu(HMENU hShellMenu,
                                UINT indexMenu,
                                UINT idCmdFirst, 
                                UINT idCmdLast,
                                UINT uFlags );
  STDMETHODIMP InvokeCommand( LPCMINVOKECOMMANDINFO lpcmi );
  STDMETHODIMP GetCommandString( UINT_PTR idCmd,
                                 UINT uFlags,
                                 UINT FAR* reserved,
                                 LPSTR pszName, 
                                 UINT ccMax );

private:  
  // internal command handlers

  // misc entry points
  void DisableAccount(BOOL bDisable);
  void ModifyPassword();
  void ReplicateNow();
  void AddToGroup();
  void CopyObject();

  // MOVE entry point and helper functions
  void MoveObject();


  // DELETE entry point and helper functions
  void DeleteObject();

  HRESULT _Delete(LPCWSTR lpszPath,
                  LPCWSTR lpszClass,
                        CString * csName);
  HRESULT _DeleteSubtree(LPCWSTR lpszPath,
                              CString * csName);

  // RENAME entry point
  void Rename();

  // internal helper functions
  void _GetExtraInfo(LPDATAOBJECT pDataObj);
  void _ToggleDisabledIcon(UINT index, BOOL bDisable);
  BOOL _WarningOnSheetsUp();
  void _NotifyDsFind(LPCWSTR* lpszNameDelArr, 
                     LPCWSTR* lpszClassDelArr, 
                     DWORD* dwFlagsDelArr, 
                     DWORD* dwProviderFlagsDelArr, 
                     UINT nDeletedCount);

  // member variables

  // data members to store info from data object
  CInternalFormatCracker      m_internalFormat;
  CObjectNamesFormatCracker   m_objectNamesFormat;
  CComPtr<IDataObject> m_spDataObject;

  // context information
  HWND m_hwnd;
  CDSComponentData* m_pCD;  
  GUID m_CallerSnapin;
  
 
  IADsUser * m_pDsObject;
  DWORD m_UserAccountState;
  UINT m_fClasses;    // flag to makr which classes we have in the multiple sel

  BOOL m_Advanced;   // from the provider flags
  
  friend class CContextMenuMultipleDeleteHandler; // _Delete*() functions
  friend class CContextMenuSingleDeleteHandler;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dscolumn.h ===
// DSColumn.h : Declaration of ds column routines and classes
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSColumn.h
//
//  Contents:  Static data and column set routines and classes
//
//  History:   12-mar-99 jeffjon    Created
//
//--------------------------------------------------------------------------

#ifndef _DS_COLUMN_H_
#define _DS_COLUMN_H_

class CDSCookie;

////////////////////////////////////////////////////////////////////////////////
#define DEFAULT_COLUMN_SET    L"default"

typedef enum _ATTRIBUTE_COLUMN_TYPE {
    ATTR_COLTYPE_NAME,
    ATTR_COLTYPE_CLASS,
    ATTR_COLTYPE_DESC,
    ATTR_COLTYPE_SPECIAL,
    ATTR_COLTYPE_MODIFIED_TIME,
} ATTRIBUTE_COLUMN_TYPE;

typedef BOOL (*COLUMN_EXTRACTION_FUNCTION)(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN pColumn);

typedef struct _ATTRIBUTE_COLUMN {
    ATTRIBUTE_COLUMN_TYPE coltype;
    UINT resid;
    int iColumnWidth;
    LPCTSTR pcszAttribute; 
    COLUMN_EXTRACTION_FUNCTION pfnExtract;
} ATTRIBUTE_COLUMN, *PATTRIBUTE_COLUMN;

typedef struct _ColumnsForClass {
    LPCTSTR pcszLdapClassName;
    LPCTSTR pcszColumnID;
    int nColumns;
    PATTRIBUTE_COLUMN* apColumns;
} COLUMNS_FOR_CLASS, *PCOLUMNS_FOR_CLASS;

typedef struct _SpecialColumn {
    UINT resid;
    LPCTSTR ptszAttribute;
    int iColumnWidth;
} SPECIAL_COLUMN, *PSPECIAL_COLUMN;
////////////////////////////////////////////////////////////////////////////////
// CColumn

class CColumn
{
public:
  CColumn(LPCWSTR lpszColumnHeader,
          int nFormat,
          int nWidth,
          int nColumnNum,
          BOOL bDefaultVisible) 
  {
    m_lpszColumnHeader = NULL;
    SetHeader(lpszColumnHeader);
    m_nFormat = nFormat;
    m_nWidth = nWidth;
    m_nColumnNum = nColumnNum;
    m_bDefaultVisible = bDefaultVisible;
    m_bVisible = bDefaultVisible;
  }

  virtual ~CColumn() 
  {
    if (m_lpszColumnHeader != NULL)
      free(m_lpszColumnHeader);
  }

protected:
  CColumn() {}

private:
  //
  // Do nothing copy constructor and operator =
  //
  CColumn(CColumn&) {}
  CColumn& operator=(CColumn&) {}

public:
  LPCWSTR GetHeader() { return (LPCWSTR)m_lpszColumnHeader; }
  void SetHeader(LPCWSTR lpszColumnHeader) 
  { 
    if (m_lpszColumnHeader != NULL)
    {
      free(m_lpszColumnHeader);
    }
    size_t iLen = wcslen(lpszColumnHeader);
    m_lpszColumnHeader = (LPWSTR)malloc(sizeof(WCHAR) * (iLen + 1));
    if (m_lpszColumnHeader != NULL)
    {
      wcscpy(m_lpszColumnHeader, lpszColumnHeader);
    }
  }

  int  GetFormat() { return m_nFormat; }
  void SetFormat(int nFormat) { m_nFormat = nFormat; }
  int  GetWidth() { return m_nWidth; }
  void SetWidth(int nWidth) { m_nWidth = nWidth; }
  int GetColumnNum() { return m_nColumnNum; }
  void SetColumnNum(int nColumnNum) { m_nColumnNum = nColumnNum; }

  void SetVisible(BOOL bVisible) { m_bVisible = bVisible; }
  BOOL IsVisible() { return m_bVisible; }
  void SetDefaultVisibility() { m_bVisible = m_bDefaultVisible; }


protected:
  LPWSTR m_lpszColumnHeader;
  int   m_nFormat;
  int   m_nWidth;
  int   m_nColumnNum;
  BOOL  m_bVisible;
  BOOL  m_bDefaultVisible;
};

////////////////////////////////////////////////////////////////////////////////
// CDSColumn

class CDSColumn : public CColumn
{
public:
  CDSColumn(LPCWSTR lpszColumnHeader,
          int nFormat,
          int nWidth,
          UINT nColumnNum,
          BOOL bDefaultVisible,
          LPCWSTR lpszAttribute,
          ATTRIBUTE_COLUMN_TYPE type, 
          COLUMN_EXTRACTION_FUNCTION pfnExtract)
          : CColumn(lpszColumnHeader, nFormat, nWidth, nColumnNum, bDefaultVisible)
  {
    if (lpszAttribute != NULL)
    {
		  // Make a copy of the attribute
      size_t iLen = wcslen(lpszAttribute);
      m_lpszAttribute = (LPWSTR)malloc(sizeof(WCHAR) * (iLen + 1));
      wcscpy(m_lpszAttribute, lpszAttribute);
    }
    else
    {
      m_lpszAttribute = NULL;
    }

    m_type = type;
    m_pfnExtract = pfnExtract;
  }

  virtual ~CDSColumn()
  {
    if (m_lpszAttribute != NULL)
    {
      free(m_lpszAttribute);
    }
  }

protected:
  CDSColumn() {}

private:
  //
  // Do nothing copy constructor and operator =
  //
  CDSColumn(CDSColumn&) {}
  CDSColumn& operator=(CDSColumn&) {}

public:

  LPCWSTR GetColumnAttribute() { return (LPCWSTR)m_lpszAttribute; }
  ATTRIBUTE_COLUMN_TYPE GetColumnType() { return m_type; }
  COLUMN_EXTRACTION_FUNCTION GetExtractionFunction() { return m_pfnExtract; }

private :
  LPWSTR m_lpszAttribute;
  ATTRIBUTE_COLUMN_TYPE m_type;
  COLUMN_EXTRACTION_FUNCTION m_pfnExtract;
};

////////////////////////////////////////////////////////////////////////////////
// CColumnSet
typedef CList<CColumn*, CColumn*> CColumnList;

class CColumnSet : public CColumnList
{
public :          
	CColumnSet(LPCWSTR lpszColumnID) 
	{
		// Make a copy of the column set ID
    if (lpszColumnID)
    {
      size_t iLen = wcslen(lpszColumnID);
      m_lpszColumnID = (LPWSTR)malloc(sizeof(WCHAR) * (iLen + 1));
      if (m_lpszColumnID != NULL)
      {
        wcscpy(m_lpszColumnID, lpszColumnID);
      }
    }
    else
    {
      ASSERT(FALSE);
    }
  }

	virtual ~CColumnSet() 
	{
    while(!IsEmpty())
    {
      CColumn* pColumn = RemoveTail();
      delete pColumn;
    }

    if (m_lpszColumnID != NULL)
		  free(m_lpszColumnID);
	}

protected:
  CColumnSet() {}

private:
  //
  // Do nothing copy constructor and operator =
  //
  CColumnSet(CColumnSet&) {}
  CColumnSet& operator=(CColumnSet&) {}

public:

  void AddColumn(LPCWSTR lpszHeader, int nFormat, int nWidth, UINT nCol, BOOL bDefaultVisible)
  {
    CColumn* pNewColumn = new CColumn(lpszHeader, nFormat, nWidth, nCol, bDefaultVisible);
    AddTail(pNewColumn);
  }

  void AddColumn(CColumn* pNewColumn) { AddTail(pNewColumn); }

	LPCWSTR GetColumnID() { return (LPCWSTR)m_lpszColumnID; }
  void SetColumnID(LPCWSTR lpszColumnID) 
  {
    if (m_lpszColumnID != NULL)
    {
      free(m_lpszColumnID);
    }

		// Make a copy of the column set ID
    size_t iLen = wcslen(lpszColumnID);
    m_lpszColumnID = (LPWSTR)malloc(sizeof(WCHAR) * (iLen + 1));
    wcscpy(m_lpszColumnID, lpszColumnID);
  }

	int GetNumCols() { return (int)GetCount(); }

  CColumn* GetColumnAt(int idx)
  {
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
    {
      CColumn* pCol = GetNext(pos);
      if (pCol->GetColumnNum() == idx)
        return pCol;
    }
    return NULL;
  }

  void ClearVisibleColumns()
  {
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
    {
      CColumn* pCol = GetNext(pos);
      pCol->SetVisible(FALSE);
    }
  }

  void AddVisibleColumns(MMC_COLUMN_DATA* pColumnData, int nNumCols)
  {
    TRACE(L"CColumnSet::AddVisibleColumns(MMC_COLUMN_DATA*) GetColumnID() = %s\n", GetColumnID());

    if (pColumnData == NULL)
    {
      ASSERT(pColumnData != NULL);
      return;
    }

    for (int idx = 0; idx < nNumCols; idx++)
    {
      TRACE(L"====================\n");
      TRACE(L"pColumnData[%d].nColIndex = %d\n", idx, pColumnData[idx].nColIndex);
      TRACE(L"pColumnData[%d].dwFlags = 0x%x\n", idx, pColumnData[idx].dwFlags);
      
      CColumn* pCol = GetColumnAt(pColumnData[idx].nColIndex);
      ASSERT(pCol != NULL);
      if (pCol == NULL)
      {
        continue;
      }

      LPCWSTR lpszHeader = pCol->GetHeader();
      TRACE(L"Column Header = %s, IsVisible() = %d\n", lpszHeader, pCol->IsVisible());



      if (!(pColumnData[idx].dwFlags & HDI_HIDDEN))
      {
        TRACE(L"pCol->SetVisible(TRUE);\n");
        pCol->SetVisible(TRUE);
      }
    }
  }

  void AddVisibleColumns(MMC_VISIBLE_COLUMNS* pVisibleColumns)
  {
    TRACE(L"CColumnSet::AddVisibleColumns(MMC_VISIBLE_COLUMNS*) GetColumnID() = %s\n", GetColumnID());

    if (pVisibleColumns == NULL)
    {
      ASSERT(pVisibleColumns != NULL);
      return;
    }

    for (int idx = 0; idx < pVisibleColumns->nVisibleColumns; idx++)
    {
      TRACE(L"====================\n");
      TRACE(L"pVisibleColumns->rgVisibleCols[%d] = %d\n", idx, pVisibleColumns->rgVisibleCols[idx]);
      
      if (pVisibleColumns->rgVisibleCols[idx] < GetCount())
      {
        CColumn* pCol = GetColumnAt(pVisibleColumns->rgVisibleCols[idx]);

        ASSERT (pCol != NULL);
        if (pCol == NULL)
        {
          continue;
        }

        LPCWSTR lpszHeader = pCol->GetHeader();
        TRACE(L"Column Header = %s, IsVisible() = %d\n", lpszHeader, pCol->IsVisible());
        pCol->SetVisible(TRUE);
      }
    }
  }

  void SetAllColumnsToDefaultVisibility()
  {
    POSITION pos = GetHeadPosition();
    while (pos != NULL)
    {
      CColumn* pCol = GetNext(pos);
      ASSERT(pCol != NULL);
      pCol->SetDefaultVisibility();
    }
  }


  HRESULT LoadFromColumnData(IColumnData* pColumnData)
  {
    TRACE(L"CColumnSet::LoadFromColumnData(), GetColumnID() = %s\n", GetColumnID());
    LPCWSTR lpszID = GetColumnID();
    size_t iLen = wcslen(lpszID);
  
    // allocate enough memory for the struct and the column ID
    SColumnSetID* pNodeID = (SColumnSetID*)new BYTE[sizeof(SColumnSetID) + (iLen * sizeof(WCHAR))];
    if (!pNodeID)
    {
      return E_OUTOFMEMORY;
    }

    memset(pNodeID, 0, sizeof(SColumnSetID) + (iLen * sizeof(WCHAR)));
    pNodeID->cBytes = static_cast<DWORD>(iLen * sizeof(WCHAR));
    memcpy(pNodeID->id, lpszID, static_cast<UINT>(iLen * sizeof(WCHAR)));

    MMC_COLUMN_SET_DATA* pColumnSetData = NULL;
    HRESULT hr = pColumnData->GetColumnConfigData(pNodeID, &pColumnSetData);
    if (hr == S_OK)
    {
      // the API returns S_OK or S_FALSE, so we check for S_OK
      ASSERT(pColumnSetData != NULL);
      if (pColumnSetData != NULL)
      {
        AddVisibleColumns(pColumnSetData->pColData, pColumnSetData->nNumCols);
        ::CoTaskMemFree(pColumnSetData);
      }
    } // if
    delete[] pNodeID;
    pNodeID = 0;
    return hr;
  }

  HRESULT Save(IStream* pStm);
  HRESULT Load(IStream* pStm);

private :
	LPWSTR m_lpszColumnID;
};

////////////////////////////////////////////////////////////////////////////////
// CDSColumnSet

class CDSColumnSet : public CColumnSet
{
public:
  CDSColumnSet(LPCWSTR lpszColumnID, LPCWSTR lpszClassName) : CColumnSet(lpszColumnID)
  {
		if (lpszClassName != NULL)
    {
      // Make a copy of the column class name
      size_t iLen = wcslen(lpszClassName);
      m_lpszClassName = (LPWSTR)malloc(sizeof(WCHAR) * (iLen + 1));
      wcscpy(m_lpszClassName, lpszClassName);
    }
    else
    {
      m_lpszClassName = NULL;
    }
  }    

  virtual ~CDSColumnSet()
  {
    if (m_lpszClassName != NULL)
      free(m_lpszClassName);
  }

protected:
  CDSColumnSet() {}

private:
  CDSColumnSet(CDSColumnSet&) {}
  CDSColumnSet& operator=(CDSColumnSet&) {}

public:

  LPCWSTR GetClassName() { return (LPCWSTR)m_lpszClassName; }

  static CDSColumnSet* CreateColumnSet(PCOLUMNS_FOR_CLASS pColsForClass, SnapinType snapinType);
  static CDSColumnSet* CreateColumnSetFromString(LPCWSTR lpszClassName, SnapinType snapinType);
  static CDSColumnSet* CreateDescriptionColumnSet();
  static CDSColumnSet* CreateColumnSetFromDisplaySpecifiers(PCWSTR pszClassName, 
                                                            SnapinType snapinType, 
                                                            MyBasePathsInfo* pBasePathsInfo);

private:
  LPWSTR m_lpszClassName;
};



////////////////////////////////////////////////////////////////////////////////
// CColumnSetList

class CColumnSetList : public CList<CColumnSet*, CColumnSet*>
{
public :
  CColumnSetList() : m_pDefaultColumnSet(NULL) {}

private:
  CColumnSetList(CColumnSetList&) {}
  CColumnSetList& operator=(CColumnSetList&) {}

public:

	void Initialize(SnapinType snapinType, MyBasePathsInfo* pBasePathsInfo);

	// Find the column set given a column set ID
	CColumnSet* FindColumnSet(LPCWSTR lpszColumnID);

	void RemoveAndDeleteAllColumnSets()
	{
		while (!IsEmpty())
		{
			CColumnSet* pTempSet = RemoveTail();
			delete pTempSet;
		}
    delete m_pDefaultColumnSet;
    m_pDefaultColumnSet = NULL;
	}

  HRESULT Save(IStream* pStm);
  HRESULT Load(IStream* pStm);

  CColumnSet* GetDefaultColumnSet();

private :
  CColumnSet* m_pDefaultColumnSet;
  SnapinType  m_snapinType;
  MyBasePathsInfo* m_pBasePathsInfo;
};

/////////////////////////////////////////////////////////////////////////////////////


//COLUMNS_FOR_CLASS* GetColumnsForClass( LPCTSTR i_pcszLdapClassName );

BOOL ColumnExtractString(
    OUT CString& strref,
    IN CDSCookie* pCookie,
    IN PADS_SEARCH_COLUMN pColumn);


#endif // _DS_COLUMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dscookie.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSCookie.h
//
//  Contents:  DS Cookie functions
//
//  History:   02-Oct-96 WayneSc    Created
//
//--------------------------------------------------------------------------


#ifndef __DSCOOKIE_H__
#define __DSCOOKIE_H__

#include "dscache.h"
#include "uinode.h"

// Forward prototypes
class CContextMenuVerbs;




/////////////////////////////////////////////////////////////////////////////
// CDSCookieInfoBase : extra inof for special classes we know about

class CDSCookieInfoBase
{
public:
  enum cookieClass { base, group, connection };
  CDSCookieInfoBase()
  {
    m_class = base;
  }
  virtual ~CDSCookieInfoBase()
  {
  }
  cookieClass GetClass() { return m_class;}
  virtual LPCWSTR GetFriendlyClassName() { return L"";}
protected:
  cookieClass m_class;
};

/////////////////////////////////////////////////////////////////////////////
// CDSCookieInfoGroup : extra info for groups

class CDSCookieInfoGroup : public CDSCookieInfoBase
{
public:
  CDSCookieInfoGroup() 
  { 
    m_class = group;
    m_GroupType = 0;
  }

  virtual LPCWSTR GetFriendlyClassName() 
  { 
    return GetGroupTypeStringHelper(m_GroupType);
  }
  INT m_GroupType;
};


/////////////////////////////////////////////////////////////////////////////
// CDSCookieInfoConnection : extra info for nTDSConnection objects

class CDSCookieInfoConnection : public CDSCookieInfoBase
{
public:
  CDSCookieInfoConnection()
  {
    m_class = connection;
    m_nOptions = 0;
    m_fFRSConnection = FALSE;
  }
  CString m_strFRSComputerReference; // not always present
  int m_nOptions;
  BOOL m_fFRSConnection; 
};


/////////////////////////////////////////////////////////////////////////////
// CDSCookie

// CODEWORK these flags come from ntdsa.h

/* Object Class independent bits */
// NOTE: These flags MAY have different behaviour in different NCs.
// For example, the FLAG_CONFIG_foo flags only have meaning inside the
// configuration NC.  the FLAG_DOMAIN_foo flags have meaning only outside the
// configuration NC.  
#define FLAG_DISALLOW_DELETE           0x80000000
#define FLAG_CONFIG_ALLOW_RENAME       0x40000000 
#define FLAG_CONFIG_ALLOW_MOVE         0x20000000 
#define FLAG_CONFIG_ALLOW_LIMITED_MOVE 0x10000000 
#define FLAG_DOMAIN_DISALLOW_RENAME    0x08000000
#define FLAG_DOMAIN_DISALLOW_MOVE      0x04000000

// Bit flags for options attribute on NTDS-Connection objects.
#define NTDSCONN_OPT_IS_GENERATED       ( 1 << 0 )  /* object generated by DS, not admin */

/* Object Class specific bits, by object class */

/* CrossReference objects */
#define FLAG_CR_NTDS_NC       0x00000001 // NC is in NTDS (not VC or foreign)
#define FLAG_CR_NTDS_DOMAIN   0x00000002 // NC is a domain (not non-domain NC)

// end of ntdsa.h

class CDSCookie : public CNodeData
{
public:
    CDSCookie();
    virtual ~CDSCookie();

//operators
public:


  // values retrieved from the cache item (per class values)
  int GetImage(BOOL bOpen); // base and DS
  GUID* GetGUID();  // base and DS

  LPCWSTR GetClass();
  LPCWSTR GetLocalizedClassName();

  // Value management functions
  void SetName(LPCWSTR lpszName) { m_strName = lpszName;}
  LPCWSTR GetName() { return m_strName; }
  
  void SetPath(LPCWSTR lpszPath) { m_strPath = lpszPath;}
  LPCWSTR GetPath(void) { return m_strPath;}
  
  void SetSystemFlags(int iSystemFlags) { m_iSystemFlags=iSystemFlags;}
  int GetSystemFlags(void) { return m_iSystemFlags; }

  void SetDesc(LPCWSTR lpszDesc) { m_strDesc = lpszDesc;}
  LPCWSTR GetDesc() { return m_strDesc; }
  
  void SetCacheItem(CDSClassCacheItemBase* pCacheItem) 
  { 
    ASSERT(pCacheItem != NULL);
    m_pCacheItem = pCacheItem;
  }


  void SetChildList(WCHAR **ppList);
  WCHAR ** GetChildList(void) { return m_ppChildList; }
  
  void SetChildCount(int cChildCount) { m_cChildCount=cChildCount;}
  int GetChildCount(void) { return m_cChildCount; }

  LPCWSTR GetChildListEntry(int iChildIndex) 
  { 
    ASSERT(iChildIndex >= 0 && iChildIndex < GetChildCount());
    return m_ppChildList[iChildIndex];
  }


  BOOL IsDisabled() {	return m_bDisabled; }
  void SetDisabled() { m_bDisabled=TRUE; }
  void ReSetDisabled() { m_bDisabled=FALSE; }

  BOOL IsNonExpiringPwd() { return m_bNonExpiringPassword; }
  void SetNonExpiringPwd() { m_bNonExpiringPassword = TRUE; }
  void ReSetNonExpiringPwd() { m_bNonExpiringPassword = FALSE; }

  BOOL IsContainerClass()
  { 
    if (m_pCacheItem == NULL)
    {
      ASSERT(FALSE); // should never happen
      return TRUE;
    }
    // ask the class cache item about it
    return m_pCacheItem->IsContainer();
  }


  CDSCookieInfoBase* GetExtraInfo() { return m_pExtraInfo;}
  void SetExtraInfo(CDSCookieInfoBase* pExtraInfo)
  {
    ASSERT(pExtraInfo != NULL);
    if (m_pExtraInfo != NULL)
      delete m_pExtraInfo;
    m_pExtraInfo = pExtraInfo;
  }


  
  CStringList& GetParentClassSpecificStrings(void)
  { return m_strlistParentClassSpecificStrings; }

  SYSTEMTIME* GetModifiedTime() { return m_pModifiedTime; }
  void SetModifiedTime(SYSTEMTIME* pModifiedTime)
  {
    if (m_pModifiedTime == NULL)
    {
      m_pModifiedTime = (SYSTEMTIME*)malloc(sizeof(SYSTEMTIME));
    }

    if (m_pModifiedTime != NULL)
    {
      memcpy(m_pModifiedTime, pModifiedTime, sizeof(SYSTEMTIME));
    }
  }

  

//attributes
  
private:
  CString     m_strName;
  CString     m_strPath;
  int         m_iSystemFlags; // systemFlags of the node
  CString     m_strDesc;
  WCHAR     **m_ppChildList; // list of allowable child classes
  int         m_cChildCount; // count of items in above list
  
  BOOL        m_bDisabled;      // only valid if class is sec. princ.
  BOOL        m_bNonExpiringPassword; // only valid if class is sec. princ.

  // We enumerate additional attributes depending on the class of the parent.
  CStringList     m_strlistParentClassSpecificStrings;
  SYSTEMTIME*    m_pModifiedTime;
  

  
  CDSClassCacheItemBase* m_pCacheItem;
  CDSCookieInfoBase* m_pExtraInfo;
};


/////////////////////////////////////////////////////////////////////////////
// CDSUINode : UI node corresponding to a DS object (result of an ADSI query)

class CDSUINode : public CUINode
{
public:
  CDSUINode(CUINode* pParentNode);

  // override of pure virtual functions
  virtual void SetName(LPCWSTR lpszName) { GetCookie()->SetName(lpszName);}
  virtual LPCWSTR GetName() { return GetCookie()->GetName();}

  virtual void SetDesc(LPCWSTR lpszDesc) { GetCookie()->SetDesc(lpszDesc);}
  virtual LPCWSTR GetDesc() { return GetCookie()->GetDesc();}

  int GetImage(BOOL bOpen) { return GetCookie()->GetImage(bOpen);}
  virtual GUID* GetGUID() { return GetCookie()->GetGUID();}

  virtual LPCWSTR GetDisplayString(int nCol, CDSColumnSet* pColumnSet);

  CDSCookie* GetCookie() 
  {
    // assume that the cast succeeds
    CDSCookie* pCookie = dynamic_cast<CDSCookie*>(m_pNodeData);
    ASSERT(pCookie != NULL);
    return pCookie;
  }
  void SetCookie(CDSCookie* pCookie) 
  {
    ASSERT(m_pNodeData == NULL);
    m_pNodeData = pCookie;
  }

// end port

  virtual CDSColumnSet* GetColumnSet(CDSComponentData* pComponentData);

  //
  // These set the state of the standard context menu items
  //
  virtual BOOL IsDeleteAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsRenameAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsRefreshAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL ArePropertiesAllowed(CDSComponentData* pComponentData, BOOL* pbHide);

  virtual BOOL IsCutAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsCopyAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsPasteAllowed(CDSComponentData* pComponentData, BOOL* pbHide);

  virtual CContextMenuVerbs* GetContextMenuVerbsObject(CDSComponentData* pComponentData);

  virtual BOOL HasPropertyPages(LPDATAOBJECT pDataObject);
};

// REVIEW_MARCOC_PORT: this is just to get going, cannot assume this ever
inline CDSCookie* GetDSCookieFromUINode(CUINode* pUINode)
{
  ASSERT(pUINode != NULL);
  CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(pUINode);
  ASSERT(pDSUINode != NULL);
  return pDSUINode->GetCookie();
}




/////////////////////////////////////////////////////////////////////////////
// CDSThreadQueryInfo

typedef enum DSQueryType { unk, rootFolder, dsFolder, queryFolder };

class CDSThreadQueryInfo : public CThreadQueryInfo
{
public:

  CDSThreadQueryInfo()
  {
    m_bOneLevel = TRUE;
    m_QueryType = unk;
  }

  void SetQueryDSQueryParameters(DSQueryType QueryType, 
                                 LPCWSTR lpszPath, 
                                 LPCWSTR lpszClass,
                                 LPCWSTR lpszQueryString, 
                                 UINT nMaxItemCount,
                                 BOOL bOneLevel,
                                 LPCWSTR lpszColumnSetID)
  {
    ASSERT(m_QueryType == unk);
    ASSERT(QueryType != unk);
    m_QueryType = QueryType;
    SetMaxItemCount(nMaxItemCount);
    m_szPath = lpszPath;
    m_szClass = lpszClass;
    m_szQueryString = lpszQueryString;
    m_bOneLevel = bOneLevel;
    m_szColumnSetID = lpszColumnSetID;
  }

  BOOL IsOneLevel() { return m_bOneLevel;}
  DSQueryType GetType() { return m_QueryType;}
  LPCWSTR GetPath() { return m_szPath;}
  LPCWSTR GetClass() { return m_szClass;}
  LPCWSTR GetQueryString() { return m_szQueryString;}
  LPCWSTR GetColumnSetID() { return m_szColumnSetID;}

private:
  BOOL    m_bOneLevel;
  DSQueryType    m_QueryType;
  CString m_szPath;
  CString m_szClass;
  CString m_szQueryString;
  CString m_szColumnSetID;
};

/////////////////////////////////////////////////////////////////////////////
// CThreadQueryResult

class CThreadQueryResult
{
public:
  CThreadQueryResult()
  {
    m_hr = S_OK;
    m_bOwnMemory = TRUE;
  }
  ~CThreadQueryResult()
  {
    if (m_bOwnMemory)
    {
      while (!m_nodeList.IsEmpty())
        delete m_nodeList.RemoveHead();
    }
  }
  CUINodeList m_nodeList;
  HRESULT m_hr;
  BOOL m_bOwnMemory;
};



#endif //__DSCOOKIE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsctx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      dsctx.cpp
//
//  Contents:  object to implement context menu extensions
//
//  History:   08-dec-97 jimharr    Created
//             
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"

#include "util.h"
#include "dsutil.h"

#include "dsctx.h"

#include "dataobj.h"
#include "dscookie.h"
#include "dsdlgs.h"
#include "gsz.h"
#include "querysup.h"
#include "simdata.h"

#include <lm.h>
#include <cmnquery.h> // IPersistQuery
#include <cmnquryp.h> // to get IQueryFrame to notify DS Find
#include <dsquery.h>
#include <dsqueryp.h>
#include <ntlsa.h>    // LsaQueryInformationPolicy

const CLSID CLSID_DSContextMenu = { /* 08eb4fa6-6ffd-11d1-b0e0-00c04fd8dca6 */
    0x08eb4fa6, 0x6ffd, 0x11d1,
    {0xb0, 0xe0, 0x00, 0xc0, 0x4f, 0xd8, 0xdc, 0xa6}
  };

////////////////////////////////////////////////////////////////////
// Language independent context menu IDs
// WARNING : these should NEVER be changed 
//           the whole point of having these is so that other
//           developers can rely on them being the same no matter
//           what language or version they use.  The context menus
//           can change but their IDs should not
//
#define CMID_ENABLE_ACCOUNT         L"_DSADMIN_ENABLE_ACCOUNT"
#define CMID_DISABLE_ACCOUNT        L"_DSADMIN_DISABLE_ACCOUNT"
#define CMID_MAP_CERTIFICATES       L"_DSADMIN_MAP_CERTIFICATES"
#define CMID_CHANGE_PASSWORD        L"_DSADMIN_CHANGE_PASSWORD"
#define CMID_MOVE_OBJECT            L"_DSADMIN_MOVE"
#define CMID_DELETE_OBJECT          L"_DSADMIN_DELETE"
#define CMID_REPLICATE_NOW          L"_DSADMIN_REPLICATE_NOW"
#define CMID_ADD_OBJECTS_TO_GROUP   L"_DSADMIN_ADD_TO_GROUP"
#define CMID_COPY_OBJECT            L"_DSADMIN_COPY"
#define CMID_RENAME_OBJECT          L"_DSADMIN_RENAME"


static CLIPFORMAT g_cfDsObjectNames;
static CLIPFORMAT g_cfDsInternal;
static CLIPFORMAT g_cfCoClass;

static CLIPFORMAT g_cfPropSheetCfg;

static CLIPFORMAT g_cfParentHwnd;
static CLIPFORMAT g_cfComponentData;

///////////////////////////////////////////////////////////////////////////
// CContextMenuSingleDeleteHandler

class CContextMenuSingleDeleteHandler : public CSingleDeleteHandlerBase
{
public:
  CContextMenuSingleDeleteHandler(CDSComponentData* pComponentData, HWND hwnd,
                                  LPCWSTR lpszPath, LPCWSTR lpszClass, 
                                  BOOL bContainer, CDSContextMenu* pCtxMenu)
                              : CSingleDeleteHandlerBase(pComponentData, hwnd)
  {
    m_pCtxMenu = pCtxMenu;
    m_lpszPath = lpszPath;
    m_lpszClass= lpszClass;
    m_bContainer = bContainer;
  }

protected:
  CDSContextMenu* m_pCtxMenu;
  LPCWSTR m_lpszPath;
  LPCWSTR m_lpszClass;
  BOOL m_bContainer;

  virtual HRESULT BeginTransaction()
  {
    return GetTransaction()->Begin(m_lpszPath, m_lpszClass, m_bContainer, NULL, NULL, FALSE);
  }
  virtual HRESULT DeleteObject()
  {
    CString szName;
    return m_pCtxMenu->_Delete(m_lpszPath, m_lpszClass, &szName);
  }
  virtual HRESULT DeleteSubtree()
  {
    CString szName;
    return m_pCtxMenu->_DeleteSubtree(m_lpszPath, &szName);
  }
  virtual void GetItemName(OUT CString& szName)
  {
    //
    // Clear out any existing value
    //
    szName.Empty();

    CPathCracker pathCracker;
    HRESULT hr = pathCracker.Set((BSTR)(LPWSTR)GetItemPath(), ADS_SETTYPE_FULL);
    if (SUCCEEDED(hr))
    {
      hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
      if (SUCCEEDED(hr))
      {
        hr = pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);
        if (SUCCEEDED(hr))
        {
          CComBSTR bstrName;
          hr = pathCracker.Retrieve(ADS_FORMAT_LEAF, &bstrName);
          if (SUCCEEDED(hr))
          {
            szName = bstrName;
          }
        }
      }
    }

    if (szName.IsEmpty())
    {
      szName = GetItemPath();
    }
  }
  virtual LPCWSTR GetItemClass(){ return m_lpszClass; }
  virtual LPCWSTR GetItemPath(){ return m_lpszPath; }

};

///////////////////////////////////////////////////////////////////////////
// CContextMenuMultipleDeleteHandler

class CContextMenuMultipleDeleteHandler : public CMultipleDeleteHandlerBase
{
public:
  CContextMenuMultipleDeleteHandler(CDSComponentData* pComponentData, HWND hwnd,
                                    IDataObject* pDataObject,
                                    CObjectNamesFormatCracker* pObjCracker,
                                    CDSContextMenu* pCtxMenu)
                                    : CMultipleDeleteHandlerBase(pComponentData, hwnd)
  {
    m_pDataObject = pDataObject;
    m_pObjCracker = pObjCracker;
    m_pCtxMenu = pCtxMenu;
    
    ASSERT(m_pObjCracker->GetCount() > 1);
    // allocate an array of BOOL's to keep track of what actually got deleted
    // and initialize ot to zero (FALSE)
    m_pDeletedArr = new BOOL[GetItemCount()];
    ::ZeroMemory(m_pDeletedArr, sizeof(BOOL)*GetItemCount());
  }
  virtual ~CContextMenuMultipleDeleteHandler()
  {
    delete[] m_pDeletedArr;
  }

  BOOL WasItemDeleted(UINT i) 
  {
    ASSERT(i < GetItemCount());
    return m_pDeletedArr[i];
  }

protected:
  virtual UINT GetItemCount() { return m_pObjCracker->GetCount();}
  virtual HRESULT BeginTransaction()
  {
    return GetTransaction()->Begin(m_pDataObject, NULL, NULL, FALSE);
  }
  virtual HRESULT DeleteObject(UINT i)
  {
    bool fAlternateDeleteMethod = false;
    LPCWSTR lpszObjectPath  = m_pObjCracker->GetName(i);
    LPCWSTR lpszObjectClass = m_pObjCracker->GetClass(i);

    HRESULT hr = ObjectDeletionCheck(
          lpszObjectPath,
          NULL,
          lpszObjectClass,
          fAlternateDeleteMethod );
    if (FAILED(hr) || HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr)
      return hr;

    if (!fAlternateDeleteMethod)
    {
      CString szName;
      hr = m_pCtxMenu->_Delete(lpszObjectPath, lpszObjectClass, &szName);
    }
    if (SUCCEEDED(hr) && (hr != S_FALSE))
    {
      m_pDeletedArr[i] = TRUE;
    }
    return hr;
  }
  virtual HRESULT DeleteSubtree(UINT i)
  {
    CString szName;
    HRESULT hr = m_pCtxMenu->_DeleteSubtree(m_pObjCracker->GetName(i), &szName);
    if (SUCCEEDED(hr) && (hr != S_FALSE))
    {
      m_pDeletedArr[i] = TRUE;
    }
    return hr;
  }
  virtual void GetItemName(IN UINT i, OUT CString& szName)
  {
    //
    // Clear out any existing value
    //
    szName.Empty();

    CPathCracker pathCracker;
    HRESULT hr = pathCracker.Set((BSTR)(LPWSTR)m_pObjCracker->GetName(i), ADS_SETTYPE_FULL);
    if (SUCCEEDED(hr))
    {
      hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
      if (SUCCEEDED(hr))
      {
        hr = pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);
        if (SUCCEEDED(hr))
        {
          CComBSTR bstrName;
          hr = pathCracker.Retrieve(ADS_FORMAT_LEAF, &bstrName);
          if (SUCCEEDED(hr))
          {
            szName = bstrName;
          }
        }
      }
    }

    if (szName.IsEmpty())
    {
      szName = m_pObjCracker->GetName(i);
    }
  }

  virtual void GetItemPath(UINT i, CString& szPath)
  {
    szPath = m_pObjCracker->GetName(i);
  }
  virtual PCWSTR GetItemClass(UINT i)
  {
    return m_pObjCracker->GetClass(i);
  }
private:
  IDataObject* m_pDataObject;
  CObjectNamesFormatCracker* m_pObjCracker;
  CDSContextMenu* m_pCtxMenu;
  BOOL* m_pDeletedArr;
};

///////////////////////////////////////////////////////////////////////////
// ContextMenu

class CContextMenuMoveHandler : public CMoveHandlerBase
{
public:
    CContextMenuMoveHandler(CDSComponentData* pComponentData, HWND hwnd, 
                            LPCWSTR lpszBrowseRootPath, 
                            IDataObject* pDataObject,
                            CInternalFormatCracker* pInternalFormatCracker,
                            CObjectNamesFormatCracker* pObjectNamesFormatCracker)
    : CMoveHandlerBase(pComponentData, hwnd, lpszBrowseRootPath)
  {
    m_pDataObject = pDataObject;
    m_pInternalFormatCracker = pInternalFormatCracker;
    m_pObjectNamesFormatCracker = pObjectNamesFormatCracker;
  }

protected:
  virtual UINT GetItemCount() { return m_pObjectNamesFormatCracker->GetCount();}
  virtual HRESULT BeginTransaction()
  {
    return GetTransaction()->Begin(m_pDataObject,
                          GetDestPath(), GetDestClass(), IsDestContainer());
  }
  virtual void GetNewPath(UINT i, CString& szNewPath)
  {
    szNewPath = m_pObjectNamesFormatCracker->GetName(i);
  }
  virtual void GetItemPath(UINT i, CString& szPath)
  {
    szPath = m_pObjectNamesFormatCracker->GetName(i);
  }
  virtual PCWSTR GetItemClass(UINT i)
  {
    return m_pObjectNamesFormatCracker->GetClass(i);
  }
  virtual void GetName(UINT i, CString& strref)
  { 
    HRESULT hr = S_OK;
    if (m_pInternalFormatCracker->HasData())
    {
      CUINode* pUINode = m_pInternalFormatCracker->GetCookie(i);
      CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);
      if (pCookie != NULL)
      {
        strref = pCookie->GetName();
      }
      else
      {
        strref = L"";
      }
      return;
    }
    else 
    {
      // REVIEW_MARCOC_PORT: this might be inefficent, need to make a member variable
      CPathCracker pathCracker;
      hr = pathCracker.Set((LPWSTR)m_pObjectNamesFormatCracker->GetName(i),
                              ADS_SETTYPE_FULL);
      hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);

      CComBSTR DestName;
      hr = pathCracker.GetElement( 0, &DestName );
      strref = DestName;
      return;
    }
  }
  virtual HRESULT OnItemMoved(UINT i, IADs* /*pIADs*/)
  {
    HRESULT hr = S_OK;
    if (m_pInternalFormatCracker != NULL && m_pInternalFormatCracker->HasData())
    {
      CUINode* pUINode = m_pInternalFormatCracker->GetCookie(i);
      pUINode->SetExtOp(OPCODE_MOVE);

      /* REVIEW_JEFFJON : removed due to bug 190532 After changing view from list to detail 
                          and back to list the drag and drop does not work from query window
                          We decided that saved queries will be snapshots of the time
                          they are run and we should not try to keep them updated.

      CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);
      if (pCookie != NULL)
      {
        CUINode* pParentNode = pUINode->GetParent();
        if (pParentNode != NULL && !IS_CLASS(*pParentNode, CDSUINode))
        {
          CComBSTR bsPath;
          hr = pIADs->get_ADsPath(&bsPath);
          if (SUCCEEDED(hr)) 
          {
            CString szPath;
            StripADsIPath(bsPath, szPath);
            pCookie->SetPath(szPath);
          }
        }
      }
      */
    }
    return hr;
  }
  virtual void GetClassOfMovedItem(CString& szClass)
  {
    szClass.Empty();
    if (NULL == m_pObjectNamesFormatCracker)
      return;
    UINT nCount = GetItemCount();
    if (0 == nCount)
      return;
    szClass = m_pObjectNamesFormatCracker->GetClass(0);
    for (UINT i = 1; i < nCount; i++)
    {
      if (0 != szClass.CompareNoCase( m_pObjectNamesFormatCracker->GetClass(i) ))
      {
        szClass.Empty();
        return;
      }
    }
  }

private:
  IDataObject* m_pDataObject;
  CInternalFormatCracker*    m_pInternalFormatCracker;
  CObjectNamesFormatCracker*   m_pObjectNamesFormatCracker;
};


///////////////////////////////////////////////////////////////////////////
// CDSContextMenu

CDSContextMenu::CDSContextMenu()
{
  m_pDsObject = NULL;
  m_fClasses = 0;
  m_hwnd = NULL;
  m_pCD = NULL;
}

CDSContextMenu::~CDSContextMenu()
{
  if (m_pDsObject) {
    m_pDsObject->Release();
  }
}

const UINT Type_User =               0x0001;
const UINT Type_Group =              0x0002;
const UINT Type_Computer =           0x0004;
const UINT Type_NTDSConnection =     0x0008;
const UINT Type_TrueNTDSConnection = 0x0010;
const UINT Type_FRSConnection   =    0x0020;
const UINT Type_Domain =             0x0040;
const UINT Type_Contact =            0x0080;
const UINT Type_OU =                 0x0100;

const UINT Type_Others =             0x8000;


extern CDSComponentData* g_pCD;






////////////////////////////////////////////////////////////
// IShellExtInit methods
STDMETHODIMP
CDSContextMenu::Initialize(LPCITEMIDLIST, 
                           LPDATAOBJECT pDataObj,
                           HKEY)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = 0;
  USES_CONVERSION;

  TRACE(_T("CDsContextMenu::Initialize.\n"));
  TIMER(_T("Entering DSContext Init().\n"));

  if (pDataObj == NULL)
  {
    return E_INVALIDARG; // no point in going on
  }

  // hold on to the data object
  m_spDataObject = pDataObj;

  // get path and class info: this format is always needed
  hr = m_objectNamesFormat.Extract(pDataObj);
  if (FAILED(hr))
    return hr;

  // we need at least one object in the selection
  ASSERT(m_objectNamesFormat.HasData());
  if (m_objectNamesFormat.GetCount() == 0)
  {
    TRACE (_T("DSContextMenu::Init: can't find path\n"));
    return S_OK;
  }

  // get DSADMIN internal format (it can be there or not)
  // if present, we are called from DS Admin
  m_internalFormat.Extract(pDataObj);

  // get extra info
  _GetExtraInfo(pDataObj);

  // check whether an NTDSConnection is actually an FRS connection
  if (m_fClasses & Type_NTDSConnection)
  {
    //
    // check whether this is an NTDS instance or an FRS instance
    // CODEWORK this will not work outside of DSADMIN (e.g. in DSFIND)
    //
    if ( m_internalFormat.HasData()
      && NULL != m_internalFormat.GetCookie(0) 
      && NULL != m_internalFormat.GetCookie(0)->GetParent() )
    {
      CUINode* pUIParentNode = m_internalFormat.GetCookie(0)->GetParent();
      CDSCookie* pParentCookie = GetDSCookieFromUINode(pUIParentNode);

      CString strClass = pParentCookie->GetClass();
      bool fParentIsFrs = false;
      HRESULT hr2 = DSPROP_IsFrsObject(
        const_cast<LPWSTR>((LPCTSTR)strClass), &fParentIsFrs );
      ASSERT( SUCCEEDED(hr2) );
      if ( SUCCEEDED(hr2) )
        m_fClasses |= ( (fParentIsFrs) ? Type_FRSConnection : Type_TrueNTDSConnection );
    }
  }

  TIMER(_T("Exiting DSContext Init().\n"));
  return hr;
}

///////////////////////////////////////////////////////////
// IContextMenu methods
STDMETHODIMP
CDSContextMenu::QueryContextMenu(HMENU hMenu,
                                 UINT indexMenu,
                                 UINT idCmdFirst, 
                                 UINT,
                                 UINT)

{

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = S_OK;
  TCHAR szBuffer[MAX_PATH];
  const INT cItems = 10; //max num of items added
  UINT nLargestCmd = 0;
  CComVariant CurrentState;
  BOOL bEnableMove = TRUE; 
  BOOL bEnableDelete = TRUE;
  BOOL bEnableRename = TRUE;

  TRACE(_T("CDsContextMenu::QueryContextMenu.\n"));
  TIMER(_T("Entering DSContext QCM().\n"));

  if (m_internalFormat.HasData()) 
  {
    int iSystemFlags = 0;
    DWORD i = 0;

    //
    // Loop through all the selected nodes adding the appropriate menu items
    //
    for (i=0; i < m_internalFormat.GetCookieCount(); i++) 
    {
      CUINode* pUINode = m_internalFormat.GetCookie(i);
      iSystemFlags = GetDSCookieFromUINode(pUINode)->GetSystemFlags();

      switch (m_internalFormat.GetSnapinType()) // assume multi-selected items all have the same snapin type
      { 
        case SNAPINTYPE_DS:
        case SNAPINTYPE_DSEX:
          bEnableMove = bEnableMove && 
                        !(iSystemFlags & FLAG_DOMAIN_DISALLOW_MOVE);
          bEnableDelete = bEnableDelete && 
                          !(iSystemFlags & FLAG_DISALLOW_DELETE);
          bEnableRename = bEnableRename &&
                          !(iSystemFlags & FLAG_DOMAIN_DISALLOW_RENAME);
          break;

        case SNAPINTYPE_SITE:
          bEnableMove = bEnableMove && 
                        ( iSystemFlags & (FLAG_CONFIG_ALLOW_MOVE | FLAG_CONFIG_ALLOW_LIMITED_MOVE) );
          bEnableDelete = bEnableDelete && 
                          !(iSystemFlags & FLAG_DISALLOW_DELETE);
          bEnableRename = bEnableRename &&
                          (iSystemFlags & FLAG_CONFIG_ALLOW_RENAME);
          break;

        default:
          break;
      } // switch
    } // end of for loop
  } // if
 
  //
  // add them items to your menu, inserting them at indexMenu + the offset for your
  // item.  idCmdFirst / idCmdList is the range you should use, they should
  // not exceed this range.  On exit return the number of items and IDs you claimed,
  //

  //
  // Add the Move menu item if this is the Sites snapin
  //
  if ((m_CallerSnapin != CLSID_SiteSnapin) &&
      !(m_fClasses & Type_Domain) &&
      bEnableMove &&
      (m_pCD != NULL))
  {
    if ( !LoadString(AfxGetInstanceHandle(), IDS_MOVE_OBJECT,
                     szBuffer, ARRAYLEN(szBuffer)) ) 
    {
      TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
      goto exit_gracefully;
    }
    InsertMenu(hMenu,
               indexMenu, 
               MF_BYPOSITION|MF_STRING,
               idCmdFirst+IDC_MOVE_OBJECT,
               szBuffer);
    nLargestCmd = __max(nLargestCmd, idCmdFirst+IDC_MOVE_OBJECT);
  }

  //
  // If this is a User or Computer object add the Reset Account menu item
  // It is done this way so that if m_fClasses contains more than computer
  // and object types in conjuction with user and/or object types we fail
  // 
  if ( m_fClasses && !(m_fClasses & ~(Type_User | Type_Computer))) 
  {
    if (m_objectNamesFormat.GetCount() == 1) 
    {
      //
      // Load the string for the menu item
      //
      if (m_fClasses == Type_Computer) // Computer
      {
        if ( !LoadString(AfxGetInstanceHandle(), IDS_RESET_ACCOUNT,
                         szBuffer, ARRAYLEN(szBuffer)) ) 
        {
          TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
          goto exit_gracefully;
        }
      } 
      else  // User
      {
        if ( !LoadString(AfxGetInstanceHandle(), IDS_CHANGE_PASSWORD,
                         szBuffer, ARRAYLEN(szBuffer)) ) 
        {
          TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
          goto exit_gracefully;
        }
      }

      //
      // Insert the menu item
      //
      InsertMenu(hMenu,
                 indexMenu, 
                 MF_BYPOSITION|MF_STRING,
                 idCmdFirst+IDC_CHANGE_PASSWORD,
                 szBuffer);
      nLargestCmd = __max(nLargestCmd, idCmdFirst+IDC_CHANGE_PASSWORD);

      //
      // Bind and figure out if the account is disabled
      // then add a menu item to enable or disable the account accordingly
      //
      hr = DSAdminOpenObject(m_objectNamesFormat.GetName(0),
                             IID_IADsUser,
                             (void **)&m_pDsObject,
                             TRUE /*bServer*/);
      if (SUCCEEDED(hr)) 
      {
        hr = m_pDsObject->Get(L"userAccountControl", &CurrentState);
        if (SUCCEEDED(hr)) 
        {
          m_UserAccountState = CurrentState.lVal;
          if (!(m_UserAccountState & UF_SERVER_TRUST_ACCOUNT))
          {
            if ((m_UserAccountState & UF_ACCOUNTDISABLE))
            {
              //
              // Account is disabled...  Load the enable string and insert
              // the menu item
              //
              if ( !LoadString(AfxGetInstanceHandle(), IDS_ENABLE_ACCOUNT,
                               szBuffer, ARRAYLEN(szBuffer)) ) 
              {
                TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
                goto exit_gracefully;
              }
              InsertMenu(hMenu,
                         indexMenu, 
                         MF_BYPOSITION|MF_STRING,
                         idCmdFirst+IDC_ENABLE_ACCOUNT,
                         szBuffer);
              nLargestCmd = __max(nLargestCmd, idCmdFirst+IDC_ENABLE_ACCOUNT);
            } 
            else 
            {
              //
              // Account is enabled...  Load the disable string and insert
              // the menu item.
              //
              if ( !LoadString(AfxGetInstanceHandle(), IDS_DISABLE_ACCOUNT,
                               szBuffer, ARRAYLEN(szBuffer)) ) 
              {
                TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
                goto exit_gracefully;
              }
              InsertMenu(hMenu,
                         indexMenu, 
                         MF_BYPOSITION|MF_STRING,
                         idCmdFirst+IDC_ENABLE_ACCOUNT,
                         szBuffer);
              nLargestCmd = __max(nLargestCmd, idCmdFirst+IDC_ENABLE_ACCOUNT);
            }
          }
        } // if get userAccountControl succeeded
      } // if bind succeeded

      if (m_Advanced) 
      {
        if ( !LoadString(AfxGetInstanceHandle(), IDS_MAP_CERTIFICATES,
                         szBuffer, ARRAYLEN(szBuffer)) ) {
          TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
          goto exit_gracefully;
        }
        InsertMenu(hMenu,
                   indexMenu, 
                   MF_BYPOSITION|MF_STRING,
                   idCmdFirst+IDC_MAP_CERTIFICATES,
                   szBuffer);
        nLargestCmd = __max(nLargestCmd, idCmdFirst+IDC_MAP_CERTIFICATES);
      }
    } 
    else // m_objectNamesFormat.GetCount() != 1
    {
      if (m_fClasses && !(m_fClasses & ~(Type_User | Type_Computer))) 
      {
        //
        // Load the enable account menu item
        //
        if ( !LoadString(AfxGetInstanceHandle(), IDS_ENABLE_ACCOUNT,
                         szBuffer, ARRAYLEN(szBuffer)) ) 
        {
          TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
          goto exit_gracefully;
        }
        InsertMenu(hMenu,
                   indexMenu, 
                   MF_BYPOSITION|MF_STRING,
                   idCmdFirst+IDC_ENABLE_ACCOUNT,
                   szBuffer);
        nLargestCmd = __max(nLargestCmd, idCmdFirst+IDC_ENABLE_ACCOUNT);

        //
        // Load the disable account menu item
        //
        if ( !LoadString(AfxGetInstanceHandle(), IDS_DISABLE_ACCOUNT,
                         szBuffer, ARRAYLEN(szBuffer)) ) 
        {
          TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
          goto exit_gracefully;
        }
        InsertMenu(hMenu,
                   indexMenu, 
                   MF_BYPOSITION|MF_STRING,
                   idCmdFirst+IDC_DISABLE_ACCOUNT,
                   szBuffer);
        nLargestCmd = __max(nLargestCmd, idCmdFirst+IDC_DISABLE_ACCOUNT);

      } // if (m_objectNamesFormat.GetCount() == 1)
    }      
  } // if User or Computer

  //
  // If the node is a user, or contact insert Add objects to group menu item
  // Note: OU removed 08/02/2000 by JeffJon
  //
  if (m_fClasses && !(m_fClasses & ~(Type_User | Type_Contact))) 
  {
    if ( !LoadString(AfxGetInstanceHandle(), IDS_ADD_TO_GROUP,
                     szBuffer, ARRAYLEN(szBuffer)) ) 
    {
      TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
      goto exit_gracefully;
    }
    BOOL bInsertSuccess = InsertMenu(hMenu,
                                     indexMenu, 
                                     MF_BYPOSITION|MF_STRING,
                                     idCmdFirst+IDC_ADD_OBJECTS_TO_GROUP,
                                     szBuffer);
    nLargestCmd = __max(nLargestCmd, idCmdFirst+IDC_ADD_OBJECTS_TO_GROUP);
    if (!bInsertSuccess)
    {
      TRACE(_T("Failed to insert Add to group context menu item. 0x%x\n"), GetLastError());
    }
  }
  
  //
  // If we weren't called from MMC
  //
  if (!m_internalFormat.HasData()) 
  { 
    //
    // Insert the delete menu item if appropriate
    //
    if ( !LoadString(AfxGetInstanceHandle(), IDS_DELETE,
                     szBuffer, ARRAYLEN(szBuffer)) ) 
    {
      TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
      goto exit_gracefully;
    }
    if (bEnableDelete) 
    {
      InsertMenu(hMenu,
                 indexMenu, 
                 MF_BYPOSITION|MF_STRING,
                 idCmdFirst+IDC_DELETE_OBJECT,
                 szBuffer);
      nLargestCmd = __max(nLargestCmd, idCmdFirst+IDC_DELETE_OBJECT);
    }

    //
    // If single selection and node is a computer insert the rename menu item
    // NOTE : the rename handler is heavily dependent on DSAdmin being the caller
    //        hence the check for m_pCD.
    //
    if (m_pCD != NULL &&
        (m_objectNamesFormat.GetCount() == 1) &&
        !(m_fClasses & Type_Computer)) 
    {
      if ( !LoadString(AfxGetInstanceHandle(), IDS_RENAME,
                       szBuffer, ARRAYLEN(szBuffer)) ) 
      {
        TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
        goto exit_gracefully;
      }
      if (bEnableRename) 
      {
        InsertMenu(hMenu,
                   indexMenu, 
                   MF_BYPOSITION|MF_STRING,
                   idCmdFirst+IDC_RENAME_OBJECT,
                   szBuffer);
        nLargestCmd = __max(nLargestCmd, idCmdFirst+IDC_RENAME_OBJECT);
      }
    }
  } // if not called from mmc
  

  //
  // If node type is NTDSConnection insert the replicate now menu item
  //
  if (m_fClasses & Type_TrueNTDSConnection) 
  {
    if ( !LoadString(AfxGetInstanceHandle(), IDS_REPLICATE_NOW,
                     szBuffer, ARRAYLEN(szBuffer)) ) 
    {
      TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
      goto exit_gracefully;
    }
    InsertMenu(hMenu,
               indexMenu, 
               MF_BYPOSITION|MF_STRING,
               idCmdFirst+IDC_REPLICATE_NOW,
               szBuffer);
    nLargestCmd = __max(nLargestCmd, idCmdFirst+IDC_REPLICATE_NOW);
  } // node type NTDSConnection

  //
  // If node type is user and we can copy it the add the copy object menu item
  //
  if ( (m_pCD != NULL) && (m_objectNamesFormat.GetCount() == 1) && (m_fClasses == Type_User) )
  {
    if (S_OK == m_pCD->_CanCopyDSObject(m_spDataObject))
    {
      if ( !LoadString(AfxGetInstanceHandle(), IDS_COPY_OBJECT,
                       szBuffer, ARRAYLEN(szBuffer)) ) 
      {
        TRACE(_T("Failed to load resource for menu item. hr is %lx\n"), hr);
        goto exit_gracefully;
      }
      InsertMenu(hMenu,
           indexMenu, 
           MF_BYPOSITION|MF_STRING,
           idCmdFirst+IDC_COPY_OBJECT,
           szBuffer);
      nLargestCmd = __max(nLargestCmd, idCmdFirst+IDC_COPY_OBJECT);
    } // if
  } // if


  hr = S_OK;
  
exit_gracefully:
  
  if (SUCCEEDED(hr))
    hr = MAKE_HRESULT(SEVERITY_SUCCESS, 0, cItems);
  
  TIMER(_T("Exiting DSContext QCM().\n"));
  return hr;
}

STDMETHODIMP
CDSContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = S_OK;
  TRACE (_T("CDSContextMenu::InvokeCommand\n"));
 
  if (lpcmi->hwnd != m_hwnd)
  {
    m_hwnd = lpcmi->hwnd;
  }
  
  TRACE (_T("\tlpcmi->lpVerb is %d.\n"), lpcmi->lpVerb);
  switch ((INT_PTR)(lpcmi->lpVerb)) {
  case IDC_ENABLE_ACCOUNT:
    if (m_objectNamesFormat.GetCount() == 1) {
      if (m_UserAccountState & UF_ACCOUNTDISABLE) {
        DisableAccount(FALSE);
      } else {
        DisableAccount(TRUE);
      }
    } else {
      DisableAccount(FALSE);
    }
    break;

  case IDC_DISABLE_ACCOUNT:
    DisableAccount(TRUE);
    break;

  case IDC_MAP_CERTIFICATES:
    {
      ASSERT (m_objectNamesFormat.GetCount() == 1);
	    LPWSTR pszCanonical = NULL;
      CString szName = m_objectNamesFormat.GetName(0);
      CString szPath;
      StripADsIPath(szName, szPath, false);  // don't use escaped mode

      // we don't care about the return code here
      CrackName((LPWSTR) (LPCWSTR)szPath, 
                     &pszCanonical, 
                     GET_OBJ_CAN_NAME, 
                     NULL);
      
      CSimData simData;
      if ( simData.FInit(pszCanonical, szName, m_hwnd)) 
          simData.DoModal();
      else
          hr = E_FAIL;

      if ( pszCanonical )
        LocalFreeStringW(&pszCanonical);
		  
      return hr;
    }
    break;
  case IDC_CHANGE_PASSWORD:
    ASSERT (m_objectNamesFormat.GetCount() == 1);
    ModifyPassword();
    break;
  case IDC_MOVE_OBJECT:
    MoveObject();
    break;
  case IDC_DELETE_OBJECT:
    TRACE(_T("called Delete in context menu extension\n"));
    DeleteObject();
    break;
  case IDC_REPLICATE_NOW:
    ReplicateNow();
    break;
  case IDC_ADD_OBJECTS_TO_GROUP:
    AddToGroup();
    break;
  case IDC_COPY_OBJECT:
    CopyObject();
    break;
  case IDC_RENAME_OBJECT:
    Rename();
    break;
  }
  return hr;
}

STDMETHODIMP
CDSContextMenu::GetCommandString(UINT_PTR idCmd,
                                   UINT uFlags,
                                   UINT FAR*, 
                                   LPSTR pszName,
                                   UINT ccMax)

{
  HRESULT hr = S_OK;

  TRACE (_T("CDSContextMenu::GetCommandString\n"));
  TRACE (_T("\tidCmd is %d.\n"), idCmd);
  if (uFlags == GCS_HELPTEXT) 
  {
    CString csHelp;
  
    switch ((idCmd)) 
    {
    case IDC_ENABLE_ACCOUNT:
      csHelp.LoadString (IDS_ENABLE_ACCOUNT_HELPSTRING);
      break;

    case IDC_DISABLE_ACCOUNT:
      csHelp.LoadString (IDS_DISABLE_ACCOUNT_HELPSTRING);
      break;

    case IDC_MAP_CERTIFICATES:
      csHelp.LoadString (IDS_MAP_CERTS_HELPSTRING);
        break;

    case IDC_CHANGE_PASSWORD:
      csHelp.LoadString (IDS_CHANGE_PWD_HELPSTRING);
      break;

    case IDC_MOVE_OBJECT:
      csHelp.LoadString (IDS_MOVE_OBJECT_HELPSTRING);
      break;

    case IDC_DELETE_OBJECT:
      csHelp.LoadString (IDS_DELETE_OBJECT_HELPSTRING);
      break;

    case IDC_REPLICATE_NOW:
      csHelp.LoadString (IDS_REPLICATE_HELPSTRING);
      break;

    case IDC_ADD_OBJECTS_TO_GROUP:
      csHelp.LoadString (IDS_ADD_OBJECTS_HELPSTRING);
      break;
    case IDC_COPY_OBJECT:
      csHelp.LoadString (IDS_COPY_HELPSTRING);
      break;
    case IDC_RENAME_OBJECT:
      csHelp.LoadString (IDS_RENAME_HELPSTRING);
      break;
    }

    ASSERT ((UINT)csHelp.GetLength() < ccMax);
    wcscpy ((LPWSTR)pszName, (LPWSTR)(LPCWSTR)csHelp);
  }
  else if (uFlags == GCS_VERB) 
  {
    //
    // Return the language independent ID of the context menu item
    //
    CString szMenuID;

    switch ((idCmd)) 
    {
    case IDC_ENABLE_ACCOUNT:
      szMenuID = CMID_ENABLE_ACCOUNT;
      break;

    case IDC_DISABLE_ACCOUNT:
      szMenuID = CMID_DISABLE_ACCOUNT;
      break;

    case IDC_MAP_CERTIFICATES:
      szMenuID = CMID_MAP_CERTIFICATES;
      break;

    case IDC_CHANGE_PASSWORD:
      szMenuID = CMID_CHANGE_PASSWORD;
      break;

    case IDC_MOVE_OBJECT:
      szMenuID = CMID_MOVE_OBJECT;
      break;

    case IDC_DELETE_OBJECT:
      szMenuID = CMID_DELETE_OBJECT;
      break;

    case IDC_REPLICATE_NOW:
      szMenuID = CMID_REPLICATE_NOW;
      break;

    case IDC_ADD_OBJECTS_TO_GROUP:
      szMenuID = CMID_ADD_OBJECTS_TO_GROUP;
      break;

    case IDC_COPY_OBJECT:
      szMenuID = CMID_COPY_OBJECT;
      break;

    case IDC_RENAME_OBJECT:
      szMenuID = CMID_RENAME_OBJECT;
      break;
    }

    ASSERT ((UINT)szMenuID.GetLength() < ccMax);
    wcscpy ((LPWSTR)pszName, (LPWSTR)(LPCWSTR)szMenuID);
  }
  else
  {
    TRACE(_T("We are not supporting any other GetCommandString() flags besides GCS_VERB and GCS_HELPTEXT"));
    return E_INVALIDARG;
  }
  return hr;
}

void CDSContextMenu::_ToggleDisabledIcon(UINT index, BOOL bDisable)
{
  if ( (m_pCD != NULL) && m_internalFormat.HasData())
  {
    CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(m_internalFormat.GetCookie(index));
    ASSERT(pDSUINode != NULL);
    if (pDSUINode == NULL)
      return;
    m_pCD->ToggleDisabled(pDSUINode, bDisable);
  }
}



void CDSContextMenu::DisableAccount(BOOL bDisable)
{
  HRESULT hr = S_OK;
  HRESULT hr2 = S_OK;
  CComVariant Disabled;
  DWORD Response = IDYES;

  if (m_objectNamesFormat.GetCount() == 1) { // single selection
    if (m_pDsObject) {
      if (((bDisable) && (!(m_UserAccountState & UF_ACCOUNTDISABLE))) ||
          ((!bDisable) && (m_UserAccountState & UF_ACCOUNTDISABLE))) {
        Disabled.vt = VT_I4;
        Disabled.lVal = m_UserAccountState;
        if (bDisable == TRUE) {
          Disabled.lVal |= UF_ACCOUNTDISABLE;
        } else {
          Disabled.lVal &= ~UF_ACCOUNTDISABLE;
        }
          
        // prep for display by getting obj name
        CPathCracker pathCracker;

        hr2 = pathCracker.Set((LPWSTR)m_objectNamesFormat.GetName(0), ADS_SETTYPE_FULL);
        ASSERT(SUCCEEDED(hr2));
        hr2 = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
        ASSERT(SUCCEEDED(hr2));

        CComBSTR DestName;

        LONG iEMode = 0;
        hr2 = pathCracker.get_EscapedMode(&iEMode);
        ASSERT(SUCCEEDED(hr2));
        hr2 = pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);
        ASSERT(SUCCEEDED(hr2));
        hr2 = pathCracker.GetElement( 0, &DestName );
        ASSERT(SUCCEEDED(hr2));
        hr2 = pathCracker.put_EscapedMode(iEMode);
        ASSERT(SUCCEEDED(hr2));
        PVOID apv[1] = {(LPWSTR)DestName};

        CString strClass = m_objectNamesFormat.GetClass(0);

        if ((strClass == "computer") && (bDisable)) {
          Response = ReportErrorEx (m_hwnd,IDS_12_DISABLE_COMPUTER_P,hr,
                           MB_YESNO | MB_ICONWARNING, apv, 1);
        }
        if (Response == IDYES) {
          hr = m_pDsObject->Put(L"userAccountControl", Disabled);
          hr = m_pDsObject->SetInfo();
          
          if (SUCCEEDED(hr)) {
            _ToggleDisabledIcon(0, bDisable);
            if (bDisable) {
              ReportErrorEx (m_hwnd,IDS_12_USER_DISABLED_SUCCESSFULLY,hr,
                             MB_OK | MB_ICONINFORMATION, apv, 1);
            }
            else {
              ReportErrorEx (m_hwnd,IDS_12_USER_ENABLED_SUCCESSFULLY,hr,
                             MB_OK | MB_ICONINFORMATION, apv, 1);
            }
          } else {
            if (bDisable) {
            ReportErrorEx (m_hwnd,IDS_12_USER_DISABLE_FAILED,hr,
                           MB_OK | MB_ICONERROR, apv, 1);
            } else
              ReportErrorEx (m_hwnd,IDS_12_USER_ENABLE_FAILED,hr,
                             MB_OK | MB_ICONERROR, apv, 1);
          }
        } 
      }
    } else {
      PVOID apv[1] = {(LPWSTR)m_objectNamesFormat.GetName(0)};
      ReportErrorEx (m_hwnd,IDS_12_USER_OBJECT_NOT_ACCESSABLE,hr,
                     MB_OK | MB_ICONERROR, apv, 1);
    }
  } 
  else //multiple selection
  { 
    UINT index;
    IADsUser * pObj = NULL;
    CComVariant CurrentState;
    DWORD UserAccountState;
    BOOL error = FALSE;
    DWORD ResponseToo = IDYES;

    if ((m_fClasses & Type_Computer) && (bDisable)) 
    {
      ResponseToo = ReportMessageEx (m_hwnd, IDS_MULTI_DISABLE_COMPUTER, 
                                  MB_YESNO | MB_ICONWARNING);
    }
    if (ResponseToo == IDYES) 
    {
      for (index = 0; index < m_objectNamesFormat.GetCount(); index++) 
      {
        hr = DSAdminOpenObject(m_objectNamesFormat.GetName(index),
                               IID_IADsUser, 
                               (void **)&pObj,
                               TRUE /*bServer*/);
        if (SUCCEEDED(hr)) 
        {
          hr = pObj->Get(L"userAccountControl", &CurrentState);
          if (SUCCEEDED(hr)) 
          {
            UserAccountState = CurrentState.lVal;
            if (((bDisable) && (!(UserAccountState & UF_ACCOUNTDISABLE))) ||
                ((!bDisable) && (UserAccountState & UF_ACCOUNTDISABLE))) 
            {
              Disabled.vt = VT_I4;
              Disabled.lVal = UserAccountState;
              if (bDisable == TRUE) 
              {
                Disabled.lVal |= UF_ACCOUNTDISABLE;
              } 
              else 
              {
                Disabled.lVal &= ~UF_ACCOUNTDISABLE;
              }
              hr = pObj->Put(L"userAccountControl", Disabled);
              hr = pObj->SetInfo();
              if (FAILED(hr)) 
              {
                error = TRUE;
                break;
              } 
              else 
              {
                _ToggleDisabledIcon(index, bDisable);
              }
            }
          }
          pObj->Release();
        } 
        else 
        {
          // prep for display by getting obj name
          CPathCracker pathCracker;

          hr2 = pathCracker.Set((LPWSTR)m_objectNamesFormat.GetName(index), ADS_SETTYPE_FULL);
          ASSERT(SUCCEEDED(hr2));
          hr2 = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
          ASSERT(SUCCEEDED(hr2));

          CComBSTR ObjName;

          hr2 = pathCracker.GetElement( 0, &ObjName );
          ASSERT(SUCCEEDED(hr2));
          PVOID apv[1] = {(LPWSTR)ObjName};
          ReportErrorEx (m_hwnd,IDS_12_USER_OBJECT_NOT_ACCESSABLE,hr,
                         MB_OK | MB_ICONERROR, apv, 1);
        }
      }
    }
    if (error) 
    {
      if (bDisable)
        ReportErrorEx (m_hwnd,IDS_DISABLES_FAILED,hr,
                       MB_OK | MB_ICONERROR, NULL, 0);
      else
        ReportErrorEx (m_hwnd,IDS_ENABLES_FAILED,hr,
                       MB_OK | MB_ICONERROR, NULL, 0);
    } 
    else 
    {
      if (bDisable) 
      {
        ReportErrorEx (m_hwnd, IDS_DISABLED_SUCCESSFULLY, S_OK,
                       MB_OK | MB_ICONINFORMATION, NULL, 0);
      } 
      else 
      {
        ReportErrorEx (m_hwnd, IDS_ENABLED_SUCCESSFULLY, S_OK,
                       MB_OK | MB_ICONINFORMATION, NULL, 0);
      }
    }
  }
}

void CDSContextMenu::ModifyPassword()
{
  HRESULT hr = S_OK;
  CString NewPwd, CfmPwd;
  CComVariant Var;
  BOOL error;
  LPCWSTR lpszClass, lpszPath;
  CChangePassword ChgDlg;
  CWaitCursor CWait;

  lpszPath = m_objectNamesFormat.GetName(0);
  
  // prep for display by getting obj name
  CPathCracker pathCracker;

  hr = pathCracker.Set((LPWSTR)lpszPath, ADS_SETTYPE_FULL);
  hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
  hr = pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);

  CComBSTR ObjName;
  hr = pathCracker.Retrieve(ADS_FORMAT_LEAF, &ObjName );

  PVOID apv[1] = {(LPWSTR)ObjName};

  if (!m_pDsObject) {
    hr = DSAdminOpenObject(lpszPath,
                           IID_IADsUser,
                           (void **)&m_pDsObject,
                           TRUE /*bServer*/);
    if (FAILED(hr)) {
      ReportErrorEx (m_hwnd,IDS_12_USER_OBJECT_NOT_ACCESSABLE,hr,
                     MB_OK | MB_ICONERROR, apv, 1);
      goto exit_gracefully;
    }
  }

  lpszClass = m_objectNamesFormat.GetClass(0);

  //
  // Get the userAccountControl
  //
  ASSERT(SUCCEEDED(hr));
  hr = m_pDsObject->Get(L"userAccountControl", &Var);

  if (wcscmp(lpszClass, L"computer") == 0) 
  {
    if (FAILED(hr) || ((Var.lVal & UF_SERVER_TRUST_ACCOUNT) != 0)) 
    {
      ReportErrorEx (m_hwnd, IDS_1_CANT_RESET_DOMAIN_CONTROLLER, S_OK,
                     MB_OK | MB_ICONERROR, apv, 1);
    } 
    else 
    {
      DWORD Response = IDYES;
      Response = ReportMessageEx (m_hwnd, IDS_CONFIRM_PASSWORD, 
                                  MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);
      if (Response == IDYES) 
      {
        hr = m_pDsObject->Get(L"sAMAccountName", &Var);
        ASSERT(SUCCEEDED(hr));
        NewPwd = Var.bstrVal;
        NewPwd = NewPwd.Left(14);
        INT loc = NewPwd.Find(L"$");
        if (loc > 0) 
        {
          NewPwd = NewPwd.Left(loc);
        }
        NewPwd.MakeLower();
        if (SUCCEEDED(hr)) 
        {
          hr = m_pDsObject->SetPassword((LPWSTR)(LPCWSTR)NewPwd);
          if (SUCCEEDED(hr)) 
          {
            ReportErrorEx (m_hwnd,IDS_1_RESET_ACCOUNT_SUCCESSFULL,hr,
                           MB_OK | MB_ICONINFORMATION, apv, 1);
          } 
          else 
          {
            ReportErrorEx (m_hwnd,IDS_12_RESET_ACCOUNT_FAILED,hr,
                           MB_OK | MB_ICONERROR, apv, 1);
          }
        }
      }
    }
  } 
  else // Not computer object
  {
    //
    // If password doesn't expire don't allow the checkbox for
    // requiring the user to change the password at next logon
    //
    if (Var.lVal & UF_DONT_EXPIRE_PASSWD)
    {
      ChgDlg.AllowMustChangePasswordCheck(FALSE);
    }

    //
    // NTRAID#Windows Bugs-278296-2001/01/12-jeffjon 
    // Checking "user must change password" on the Reset Pwd dialog 
    // is silently ignored when Write PwdLastSet not granted
    //
    // Disable the checkbox if the admin doesn't have the right
    // to write the pwdLastSet attribute
    //
    BOOL bAllowMustChangePassword = FALSE;
    CComPtr<IDirectoryObject> spDirObject;
    hr = m_pDsObject->QueryInterface(IID_IDirectoryObject, (void**)&spDirObject);
    if (SUCCEEDED(hr))
    {
      PWSTR ppAttrs[] = { (PWSTR)g_pszAllowedAttributesEffective };
      DWORD dwAttrsReturned = 0;
      PADS_ATTR_INFO pAttrInfo = 0;
      hr = spDirObject->GetObjectAttributes(ppAttrs, 1, &pAttrInfo, &dwAttrsReturned);
      if (SUCCEEDED(hr) && dwAttrsReturned == 1 && pAttrInfo)
      {
        if (pAttrInfo->pszAttrName && 
            0 == _wcsicmp(pAttrInfo->pszAttrName, g_pszAllowedAttributesEffective) &&
            pAttrInfo->pADsValues)
        {
          for (DWORD dwIdx = 0; dwIdx < pAttrInfo->dwNumValues; ++dwIdx)
          {
            if (pAttrInfo->pADsValues[dwIdx].CaseIgnoreString &&
                _wcsicmp(pAttrInfo->pADsValues[dwIdx].CaseIgnoreString, g_pszPwdLastSet))
            {
              bAllowMustChangePassword = TRUE;
              break;
            }
          }
        }
      }

      //
      // Disable the checkbox if the user object doesn't have rights
      // to change their password
      //
      if (!CanUserChangePassword(spDirObject))
      {
        bAllowMustChangePassword = FALSE;
      }
    }
    if (!bAllowMustChangePassword)
    {
      ChgDlg.AllowMustChangePasswordCheck(FALSE);
    }


    do 
    {
      error = FALSE;
      if (ChgDlg.DoModal() == IDOK) 
      {
        CWaitCursor CWait2;
        NewPwd = ChgDlg.GetNew();
        CfmPwd = ChgDlg.GetConfirm();
        
        if (NewPwd==CfmPwd) 
        {
          if (SUCCEEDED(hr)) 
          {
            hr = m_pDsObject->SetPassword((LPWSTR)(LPCWSTR)NewPwd);
            
            if (SUCCEEDED(hr))
            {
              hr = ModifyNetWareUserPassword(m_pDsObject, lpszPath, NewPwd);
            }

            if (SUCCEEDED(hr)) 
            {
              BOOL ForceChange = ChgDlg.GetChangePwd();
              if (ForceChange) 
              {
                //Check to see if the user password does not expire
                BOOL bContinueToForceChange = TRUE;
                IADs* pIADs = NULL;
                HRESULT hr3 = m_pDsObject->QueryInterface(IID_IADs, OUT (void **)&pIADs);
                if (SUCCEEDED(hr3)) 
                {
                  ASSERT(pIADs != NULL);
                  CComVariant var;
                  hr3 = pIADs->Get(IN (LPWSTR)gsz_userAccountControl, OUT &var);
                  if (SUCCEEDED(hr3)) 
                  {
                    ASSERT(var.vt == VT_I4);
                    if (var.lVal & UF_DONT_EXPIRE_PASSWD) 
                    {
                      ReportErrorEx (m_hwnd,IDS_12_PASSWORD_DOES_NOT_EXPIRE,hr,
                                     MB_OK | MB_ICONWARNING, apv, 1);
                      bContinueToForceChange = FALSE;
                    }
                    pIADs->Release();
                  }
                }

                // If password can expire then force the change at next logon
                if (bContinueToForceChange) 
                {
                  IDirectoryObject * pIDSObject = NULL;
                  LPWSTR szPwdLastSet = L"pwdLastSet";
                  ADSVALUE ADsValuePwdLastSet = {ADSTYPE_LARGE_INTEGER, NULL};
                  ADS_ATTR_INFO AttrInfoPwdLastSet = {szPwdLastSet, ADS_ATTR_UPDATE,
                                                      ADSTYPE_LARGE_INTEGER,
                                                      &ADsValuePwdLastSet, 1};
                  ADsValuePwdLastSet.LargeInteger.QuadPart = 0;
                  HRESULT hr2 = m_pDsObject->QueryInterface(IID_IDirectoryObject, 
                                                   OUT (void **)&pIDSObject);
                  if (SUCCEEDED(hr2)) 
                  {
                    ASSERT(pIDSObject != NULL);
                    DWORD cAttrModified = 0;
                    hr2 = pIDSObject->SetObjectAttributes(&AttrInfoPwdLastSet,
                                                         1, &cAttrModified);
                    pIDSObject->Release();
                  }
                }
              } 
              ReportErrorEx (m_hwnd,IDS_12_PASSWORD_CHANGE_SUCCESSFUL,hr,
                             MB_OK | MB_ICONINFORMATION, apv, 1);
            } 
            else 
            {
              ReportErrorEx (m_hwnd,IDS_12_PASSWORD_CHANGE_FAILED,hr,
                             MB_OK | MB_ICONERROR, apv, 1);
            }
          }
        } 
        else 
        {
          ReportErrorEx (m_hwnd,IDS_NEW_AND_CONFIRM_NOT_SAME,hr,
                         MB_OK | MB_ICONERROR, NULL, 0);
          ChgDlg.Clear();
          error = TRUE;
        }
      }
    } while (error);
  }
exit_gracefully:
  return;
}

#define BREAK_ON_FAIL if (FAILED(hr)) { break; }
#define BREAK_AND_ASSERT_ON_FAIL if (FAILED(hr)) { ASSERT(FALSE); break; }
#define RETURN_AND_ASSERT_ON_FAIL if (FAILED(hr)) { ASSERT(FALSE); return; }

void CDSContextMenu::MoveObject()
{

  // REVIEW_MARCOC: need to make sure the LDAP path has the SERVER or DOMAIN in it

  // if called in the context of DS Admin, guard against property sheet open on this cookie
  if (_WarningOnSheetsUp())
    return; 

  // get the first path in the data object
  ASSERT(m_objectNamesFormat.HasData());

  // now do crack name to get root path for the browse dialog
  CString szRootPath;

  if (m_pCD != NULL)
  {
    szRootPath = m_pCD->GetBasePathsInfo()->GetProviderAndServerName();
    szRootPath += m_pCD->GetRootPath();
  }
  else
  {

    LPCWSTR lpszObjPath = m_objectNamesFormat.GetName(0);

    // make sure there's no strange escaping in the path
    CComBSTR bstrPath;
    CComBSTR bstrProvider;
    CComBSTR bstrServer;


    CPathCracker pathCracker;

    pathCracker.Set((LPTSTR)lpszObjPath, ADS_SETTYPE_FULL);
    pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
    pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF);
    pathCracker.Retrieve( ADS_FORMAT_X500_DN, &bstrPath);
    pathCracker.Retrieve( ADS_FORMAT_SERVER, &bstrServer);
    pathCracker.Retrieve( ADS_FORMAT_PROVIDER, &bstrProvider);


    LPWSTR pwszDomainPath;
    HRESULT hr = CrackName(const_cast<LPWSTR>((LPCWSTR)bstrPath),
                           &pwszDomainPath,
                           GET_FQDN_DOMAIN_NAME,
                           m_hwnd);

    if ((FAILED(hr)) || (HRESULT_CODE(hr) == DS_NAME_ERROR_NO_MAPPING))
    {
      TRACE(_T("CrackNames failed to get domain for %s.\n"),
            lpszObjPath);
      szRootPath = L"";
    } 
    else 
    {
      CPathCracker pathCrackerOther;
      hr = pathCrackerOther.Set( pwszDomainPath, ADS_SETTYPE_DN );
      RETURN_AND_ASSERT_ON_FAIL;
      hr = pathCrackerOther.Set( bstrProvider, ADS_SETTYPE_PROVIDER );
      RETURN_AND_ASSERT_ON_FAIL;
      hr = pathCrackerOther.Set( bstrServer, ADS_SETTYPE_SERVER );
      RETURN_AND_ASSERT_ON_FAIL;
      CComBSTR sbstrRootPath;
      hr = pathCrackerOther.Retrieve( ADS_FORMAT_X500, &sbstrRootPath );
      RETURN_AND_ASSERT_ON_FAIL;
      szRootPath = sbstrRootPath;
    }
    if (pwszDomainPath != NULL)
      ::LocalFreeStringW(&pwszDomainPath);
  }

  CMultiselectMoveHandler moveHandler(m_pCD, m_hwnd, szRootPath);
  HRESULT hr = moveHandler.Initialize(m_spDataObject, &m_objectNamesFormat, 
                                                      &m_internalFormat);
  ASSERT(SUCCEEDED(hr));
  moveHandler.Move();
}


void CDSContextMenu::DeleteObject()
{
  _ASSERTE(m_objectNamesFormat.HasData());

  // if called in the context of DS Admin, guard against property sheet open on this cookie
  if (_WarningOnSheetsUp())
    return; 

  UINT nObjectCount = m_objectNamesFormat.GetCount();
  if (nObjectCount == 0)
  {
    ASSERT(nObjectCount != 0);
    return;
  }

  UINT nDeletedCount = 0;

  PCWSTR* pszNameDelArr = 0;
  PCWSTR* pszClassDelArr = 0;
  DWORD* dwFlagsDelArr = 0;
  DWORD* dwProviderFlagsDelArr = 0;

  do // false loop
  {
	  pszNameDelArr = new PCWSTR[nObjectCount];
	  pszClassDelArr = new PCWSTR[nObjectCount];
	  dwFlagsDelArr = new DWORD[nObjectCount];
	  dwProviderFlagsDelArr = new DWORD[nObjectCount];

	  if (!pszNameDelArr  ||
	      !pszClassDelArr ||
	      !dwFlagsDelArr  ||
	      !dwProviderFlagsDelArr)
	  {
      break;
	  }

    switch(nObjectCount)
    {
    case 1:
      {
        // single selection delete
        CContextMenuSingleDeleteHandler deleteHandler(m_pCD, m_hwnd, 
                                                  m_objectNamesFormat.GetName(0), 
                                                  m_objectNamesFormat.GetClass(0),
                                                  m_objectNamesFormat.IsContainer(0),
                                                  this);
        HRESULT hr = deleteHandler.Delete();
        if (SUCCEEDED(hr) && (hr != S_FALSE))
        {
          nDeletedCount = 1;
          pszNameDelArr[0] = m_objectNamesFormat.GetName(0);
          pszClassDelArr[0] = m_objectNamesFormat.GetClass(0);
          dwFlagsDelArr[0] = m_objectNamesFormat.GetFlags(0);
          dwProviderFlagsDelArr[0] = m_objectNamesFormat.GetProviderFlags(0);
        }

      }
      break;
    default:
      {
        // multiple selection
        CContextMenuMultipleDeleteHandler deleteHandler(m_pCD, m_hwnd, m_spDataObject,
                                                  &m_objectNamesFormat, this);
        deleteHandler.Delete();
        for (UINT k=0; k< nObjectCount; k++)
        {
          if (deleteHandler.WasItemDeleted(k))
          {
            pszNameDelArr[nDeletedCount] = m_objectNamesFormat.GetName(k);
            pszClassDelArr[nDeletedCount] = m_objectNamesFormat.GetClass(k);
            dwFlagsDelArr[nDeletedCount] = m_objectNamesFormat.GetFlags(k);
            dwProviderFlagsDelArr[nDeletedCount] = m_objectNamesFormat.GetProviderFlags(k);

            nDeletedCount++;
          } // if
        } // for
      }
    }; // switch


    _NotifyDsFind((PCWSTR*)pszNameDelArr, 
                  (PCWSTR*)pszClassDelArr, 
                  dwFlagsDelArr, 
                  dwProviderFlagsDelArr, 
                  nDeletedCount);
  } while (false);

  if (pszNameDelArr)
  {
    delete[] pszNameDelArr;
    pszNameDelArr = 0;
  }

  if (pszClassDelArr)
  {
    delete[] pszClassDelArr;
    pszClassDelArr = 0;
  }

  if (dwFlagsDelArr)
  {
    delete[] dwFlagsDelArr;
    dwFlagsDelArr = 0;
  }

  if (dwProviderFlagsDelArr)
  {
    delete[] dwProviderFlagsDelArr;
    dwProviderFlagsDelArr = 0;
  }
}



void CDSContextMenu::_NotifyDsFind(LPCWSTR* lpszNameDelArr, 
                                   LPCWSTR* lpszClassDelArr, 
                                   DWORD* dwFlagsDelArr, 
                                   DWORD* dwProviderFlagsDelArr, 
                                   UINT nDeletedCount)
{
  if (nDeletedCount == 0)
  {
    // nothing to delete
    return;
  }

  if (m_internalFormat.HasData())
  {
    // called from DS Admin directly, not from DS Find
    return;
  }

  // ask DS Find about the notification interface
  CComPtr<IQueryFrame> spIQueryFrame;
  if ( !::SendMessage(m_hwnd, CQFWM_GETFRAME, 0, (LPARAM)&spIQueryFrame) )
  {
    // interface not found
    return;
  }

  CComPtr<IDsQueryHandler> spDsQueryHandler;
  HRESULT hr = spIQueryFrame->GetHandler(IID_IDsQueryHandler, (void **)&spDsQueryHandler);
  if (FAILED(hr))
  {
    // interface not found
    return;
  }

  // we finally have the interface, build the data structures

  // figure out how much storage we need
  DWORD cbStruct = sizeof(DSOBJECTNAMES) + 
              ((nDeletedCount - 1) * sizeof(DSOBJECT));

  size_t cbStorage = 0;
  for (UINT index = 0; index < nDeletedCount; index++)
  {
    cbStorage += sizeof(WCHAR)*(wcslen(lpszNameDelArr[index])+1);
    cbStorage += sizeof(WCHAR)*(wcslen(lpszClassDelArr[index])+1);
  }

  // allocate memory
  LPDSOBJECTNAMES pDSObj = (LPDSOBJECTNAMES)::malloc(cbStruct + cbStorage);
  if (pDSObj == NULL)
  {
    ASSERT(FALSE);
    return;
  }

  // fill in the structs
  pDSObj->clsidNamespace = m_CallerSnapin;

  pDSObj->cItems = nDeletedCount;
  DWORD NextOffset = cbStruct;
  for (index = 0; index < nDeletedCount; index++)
  {
    pDSObj->aObjects[index].dwFlags = dwFlagsDelArr[index];

    pDSObj->aObjects[index].dwProviderFlags = dwProviderFlagsDelArr[index];

    pDSObj->aObjects[index].offsetName = NextOffset;
    pDSObj->aObjects[index].offsetClass = static_cast<ULONG>(NextOffset + 
      (wcslen(lpszNameDelArr[index])+1) * sizeof(WCHAR));

    _tcscpy((LPTSTR)((BYTE *)pDSObj + NextOffset), lpszNameDelArr[index]);
    NextOffset += static_cast<ULONG>((wcslen(lpszNameDelArr[index]) + 1) * sizeof(WCHAR));

    _tcscpy((LPTSTR)((BYTE *)pDSObj + NextOffset), lpszClassDelArr[index]);
    NextOffset += static_cast<ULONG>((wcslen(lpszClassDelArr[index]) + 1) * sizeof(WCHAR));
  }

  // make the call
  hr = spDsQueryHandler->UpdateView(DSQRVF_ITEMSDELETED, pDSObj);

  ::free(pDSObj);

}

HRESULT
CDSContextMenu::_Delete(LPCWSTR lpszPath, LPCWSTR lpszClass,
                         CString * csName)
{
  CComBSTR strParent;
  CComBSTR strThisRDN;
  IADsContainer * pDSContainer = NULL;
  IADs * pDSObject = NULL;
  HRESULT hr = S_OK;

  hr = DSAdminOpenObject(lpszPath,
                         IID_IADs,
                         (void **) &pDSObject,
                         TRUE /*bServer*/);
  if (!SUCCEEDED(hr)) {
    goto error;
  }

  hr = pDSObject->get_Parent(&strParent);
  if (!SUCCEEDED(hr)) {
    goto error;
  }
  
  hr = pDSObject->get_Name (&strThisRDN);
  if (!SUCCEEDED(hr)) {
    goto error;
  }
  
  pDSObject->Release();
  pDSObject = NULL;

  hr = DSAdminOpenObject(strParent,
                         IID_IADsContainer,
                         (void **) &pDSContainer,
                         TRUE /*bServer*/);
  if (!SUCCEEDED(hr)) {
    goto error;
  }

  hr = pDSContainer->Delete ((LPWSTR)lpszClass,
                             (LPWSTR)(LPCWSTR)strThisRDN);

error:
  if (pDSContainer)
    pDSContainer->Release();
  if (pDSObject)
    pDSObject->Release();
  if (FAILED(hr)) {
    *csName = strThisRDN;
  }
  return hr;
}

HRESULT
CDSContextMenu::_DeleteSubtree(LPCWSTR lpszPath,
                                CString * csName)
{
  HRESULT hr = S_OK;

  IADsDeleteOps * pObj = NULL;
  IADs * pObj2 = NULL;

  hr = DSAdminOpenObject(lpszPath,
                         IID_IADsDeleteOps, 
                         (void **)&pObj,
                         TRUE /*bServer*/);
  if (SUCCEEDED(hr)) {
    TIMER(_T("Call to Deleteobject (to do subtree delete).\n"));
    hr = pObj->DeleteObject(NULL); //flag is reserved by ADSI
    TIMER(_T("Call to Deleteobject completed.\n"));
  }
  if (FAILED(hr)) {
    CComBSTR strName;
    HRESULT hr2 = pObj->QueryInterface (IID_IADs, (void **)&pObj2);
    if (SUCCEEDED(hr2)) {
      hr2 = pObj2->get_Name(&strName);
      if (SUCCEEDED(hr2)) {
        *csName = strName;
      } else {
        csName->LoadString (IDS_UNKNOWN);
      }
    }
  }

  if (pObj2) {
    pObj2->Release();
  }
  if (pObj) {
    pObj->Release();
  }
  return hr;
}

// code from JeffParh
NTSTATUS RetrieveRootDomainName( LPCWSTR lpcwszTargetDC, BSTR* pbstrRootDomainName )
{
  if (NULL == pbstrRootDomainName)
  {
    ASSERT(FALSE);
    return STATUS_INVALID_PARAMETER;
  }
  ASSERT( NULL == *pbstrRootDomainName );

  NTSTATUS ntStatus = STATUS_SUCCESS;
  LSA_HANDLE hPolicy = NULL;
  POLICY_DNS_DOMAIN_INFO* pDnsDomainInfo = NULL;

  do { // false loop

    UNICODE_STRING unistrTargetDC;
    if (NULL != lpcwszTargetDC)
    {
      unistrTargetDC.Length = (USHORT)(::lstrlen(lpcwszTargetDC)*sizeof(WCHAR));
      unistrTargetDC.MaximumLength = unistrTargetDC.Length;
      unistrTargetDC.Buffer = (LPWSTR)lpcwszTargetDC;
    }

    LSA_OBJECT_ATTRIBUTES oa;
    ZeroMemory( &oa, sizeof(oa) );
    ntStatus = LsaOpenPolicy(
                    (NULL != lpcwszTargetDC) ? &unistrTargetDC : NULL,
                    &oa,
                    POLICY_VIEW_LOCAL_INFORMATION,
                    &hPolicy
                    );
    if ( !LSA_SUCCESS( ntStatus ) )
    {
      ASSERT(FALSE);
      break;
    }

    ntStatus = LsaQueryInformationPolicy(
                    hPolicy,
                    PolicyDnsDomainInformation,
                    (PVOID*)&pDnsDomainInfo
                    );
    if ( !LSA_SUCCESS( ntStatus ) )
    {
      ASSERT(FALSE);
      break;
    }

    *pbstrRootDomainName = ::SysAllocStringLen(
        pDnsDomainInfo->DnsForestName.Buffer,
        pDnsDomainInfo->DnsForestName.Length / sizeof(WCHAR) );
    if (NULL == *pbstrRootDomainName)
    {
      ntStatus = STATUS_NO_MEMORY;
      break;
    }

  } while (false); // false loop

  if (NULL != pDnsDomainInfo)
  {
    NTSTATUS ntstatus2 = LsaFreeMemory( pDnsDomainInfo );
    ASSERT( LSA_SUCCESS(ntstatus2) );
  }
  if (NULL != hPolicy)
  {
    NTSTATUS ntstatus2 = LsaClose( hPolicy );
    ASSERT( LSA_SUCCESS(ntstatus2) );
  }

  return ntStatus;
}

void AddMatchingNCs(
  IN OUT CStringList& refstrlist,
  IN const PADS_ATTR_INFO padsattrinfo1,
  IN const PADS_ATTR_INFO padsattrinfo2 )
{
  if ( !padsattrinfo1 || !padsattrinfo2 )
    return;
  for (DWORD iTarget = 0; iTarget < padsattrinfo1[0].dwNumValues; iTarget++)
  {
    LPWSTR lpszTargetNC = padsattrinfo1[0].pADsValues[iTarget].DNString;
    ASSERT( NULL != lpszTargetNC );
    bool fFound = false;
    for (DWORD iSource = 0; iSource < padsattrinfo2[0].dwNumValues; iSource++)
    {
      LPWSTR lpszSourceNC = padsattrinfo2[0].pADsValues[iSource].DNString;
      ASSERT( NULL != lpszSourceNC );
      if ( !lstrcmpiW( lpszTargetNC, lpszSourceNC ) )
      {
        fFound = true;
        break;
      }
    }
    if (fFound)
      refstrlist.AddHead( lpszTargetNC ); // CODEWORK can throw
  }
}


HRESULT PrepareReplicaSyncParameters(
  IN LPCWSTR strNTDSConnection,
  IN BSTR bstrRootDomainName,
  OUT BSTR* pbstrDsBindName,
  OUT UUID* puuidSourceObjectGUID,
  OUT CStringList& refstrlistCommonNCs,
  OUT ULONG* pulDsSyncOptions,
  OUT BSTR* pbstrFromServer
  )
{
  ASSERT(   NULL != strNTDSConnection
         && NULL != bstrRootDomainName
         && NULL != pbstrDsBindName
         && NULL == *pbstrDsBindName
         && NULL != puuidSourceObjectGUID
         && refstrlistCommonNCs.IsEmpty()
         && NULL != pulDsSyncOptions
        );

  HRESULT hr = S_OK;

  do { // false loop

    CComPtr<IADs> spIADs;
    // read attributes of nTDSConnection object
    hr = DSAdminOpenObject(strNTDSConnection,
                           IID_IADs,
                           (void **) &spIADs,
                           TRUE /*bServer*/);
    BREAK_ON_FAIL;
    hr = GetStringAttr( spIADs, L"fromServer", pbstrFromServer);
    BREAK_AND_ASSERT_ON_FAIL; // required attribute
    spIADs.Release(); // method of CComPtr<>, also sets pointer to NULL

    // get the path to the target nTDSDSA object
    CPathCracker pathCracker;

    hr = pathCracker.Set( const_cast<BSTR>(strNTDSConnection), ADS_SETTYPE_FULL );
    BREAK_AND_ASSERT_ON_FAIL;
    hr = pathCracker.RemoveLeafElement();
    BREAK_AND_ASSERT_ON_FAIL;
    CComBSTR sbstrTargetNTDSDSAPath;
    hr = pathCracker.Retrieve( ADS_FORMAT_X500, &sbstrTargetNTDSDSAPath );
    BREAK_AND_ASSERT_ON_FAIL;

    // get the sitename for the target NTDSA object
    hr = pathCracker.SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
    BREAK_AND_ASSERT_ON_FAIL;
    CComBSTR sbstrTargetSite;
    hr = pathCracker.GetElement( 3L, &sbstrTargetSite );
    BREAK_AND_ASSERT_ON_FAIL;
    hr = pathCracker.SetDisplayType( ADS_DISPLAY_FULL );
    BREAK_AND_ASSERT_ON_FAIL;

    // read objectGUID of the target nTDSDSA object
    hr = DSAdminOpenObject(sbstrTargetNTDSDSAPath,
                           IID_IADs,
                           (void **) &spIADs,
                           TRUE /*bServer*/);
    BREAK_ON_FAIL;
    CComBSTR sbstrTargetObjectGUID;
    hr = GetObjectGUID( spIADs, &sbstrTargetObjectGUID );
    // The objectGUID attribute should be set for nTDSDSA objects
    BREAK_AND_ASSERT_ON_FAIL;

    // read hasMasterNCs of the target nTDSDSA object
    Smart_PADS_ATTR_INFO spTargetMasterNCAttrs;
    hr = GetAttr( spIADs, L"hasMasterNCs", &spTargetMasterNCAttrs );
    // The hasMasterNCs attribute should be set for nTDSDSA objects
    BREAK_AND_ASSERT_ON_FAIL;

    // read hasPartialReplicaNCs of the target nTDSDSA object
    Smart_PADS_ATTR_INFO spTargetPartialNCAttrs;
    (void) GetAttr( spIADs, L"hasPartialReplicaNCs", &spTargetPartialNCAttrs );
    // The hasPartialReplicaNCs attribute may or may not be set for nTDSDSA objects
    spIADs.Release(); // method of CComPtr<>, also sets pointer to NULL

    /*
    hr = spIADsPathname->RemoveLeafElement();
    BREAK_AND_ASSERT_ON_FAIL;
    CComBSTR sbstrTargetServerPath;
    hr = spIADsPathname->Retrieve( ADS_FORMAT_X500, &sbstrTargetServerPath );
    BREAK_AND_ASSERT_ON_FAIL;
    hr = DSAdminOpenObject(sbstrTargetServerPath,
                           IID_IADs,
                           (void **) &spIADs,
                           TRUE);
    BREAK_ON_FAIL;
    CComVariant var;
    hr = spIADs->Get(L"dNSHostName", &var);
    BREAK_ON_FAIL; // can be missing for brand-new DCs
    spIADs.Release(); // method of CComPtr<>, also sets pointer to NULL
    ASSERT((var.vt == VT_BSTR) && var.bstrVal && *(var.bstrVal));
    LPWSTR lpszDNSHostName = var.bstrVal;
    */

    // get the path to the source nTDSDSA object
    hr = pathCracker.Set(
        (pbstrFromServer) ? *pbstrFromServer : NULL,
        ADS_SETTYPE_DN );
    BREAK_AND_ASSERT_ON_FAIL;
    CComBSTR sbstrSourceNTDSDSAPath;
    hr = pathCracker.Retrieve( ADS_FORMAT_X500, &sbstrSourceNTDSDSAPath );
    BREAK_AND_ASSERT_ON_FAIL;

    // get the sitename for the source NTDSA object
    hr = pathCracker.SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
    BREAK_AND_ASSERT_ON_FAIL;
    CComBSTR sbstrSourceSite;
    hr = pathCracker.GetElement( 3L, &sbstrSourceSite );
    BREAK_AND_ASSERT_ON_FAIL;
    hr = pathCracker.SetDisplayType( ADS_DISPLAY_FULL );
    BREAK_AND_ASSERT_ON_FAIL;

    // determine whether the two DCs are in the same site
    *pulDsSyncOptions = (lstrcmpi(sbstrSourceSite, sbstrTargetSite))
                            ? DS_REPSYNC_ASYNCHRONOUS_OPERATION
                            : 0;

    // read objectGUID of the source NTDSDSA object
    hr = DSAdminOpenObject(sbstrSourceNTDSDSAPath,
                           IID_IADs,
                           (void **) &spIADs,
                           TRUE /*bServer*/);
    BREAK_ON_FAIL;
    hr = GetObjectGUID( spIADs, puuidSourceObjectGUID );
    // The objectGUID attribute should be set for nTDSDSA objects
    BREAK_AND_ASSERT_ON_FAIL;

    // read hasMasterNCs of the source nTDSDSA object
    Smart_PADS_ATTR_INFO spSourceMasterNCAttrs;
    hr = GetAttr( spIADs, L"hasMasterNCs", &spSourceMasterNCAttrs );
    // The hasMasterNCs attribute should be set for nTDSDSA objects
    BREAK_AND_ASSERT_ON_FAIL;

    // read hasMasterNCs of the source nTDSDSA object
    Smart_PADS_ATTR_INFO spSourcePartialNCAttrs;
    (void) GetAttr( spIADs, L"hasPartialReplicaNCs", &spSourcePartialNCAttrs );
    // The hasPartialReplicaNCs attribute may or may not be set for nTDSDSA objects
    spIADs.Release(); // method of CComPtr<>, also sets pointer to NULL

    // Determine which NCs the two NTDSDSAs have in common
    AddMatchingNCs( refstrlistCommonNCs, spTargetMasterNCAttrs,  spSourceMasterNCAttrs  );
    AddMatchingNCs( refstrlistCommonNCs, spTargetPartialNCAttrs, spSourceMasterNCAttrs  );
    AddMatchingNCs( refstrlistCommonNCs, spTargetPartialNCAttrs, spSourcePartialNCAttrs );

    // Build the name of the inbound domain controller for this connection
    CString csGUID( sbstrTargetObjectGUID );
    ASSERT( L'{' == csGUID[0] && L'}' == csGUID[csGUID.GetLength()-1] );
    CString csDC = csGUID.Mid( 1, csGUID.GetLength()-2 );
    csDC += L"._msdcs.";
    csDC += bstrRootDomainName;
    *pbstrDsBindName = ::SysAllocString( csDC );
    /*
    *pbstrDsBindName = ::SysAllocString( lpszDNSHostName );
    */
    if (NULL == *pbstrDsBindName)
    {
      hr = E_OUTOFMEMORY;
      BREAK_AND_ASSERT_ON_FAIL;
    }

  } while (false); // false loop

  return hr;
}

void CDSContextMenu::AddToGroup()
{
  
  CWaitCursor waitcursor;
  HRESULT hr = S_OK;
  TRACE (_T("CDSContextMenu::AddToGroup\n"));

  hr = AddDataObjListToGroup (&m_objectNamesFormat, m_hwnd, m_pCD);

  return;
}


// This level takes care of displaying the error messages
// CODEWORK should this try to replicate other domains to GCs?
void CDSContextMenu::ReplicateNow()
{
  CWaitCursor waitcursor;

  CComBSTR sbstrRootDomainName;
  LPCWSTR lpcwszTargetDC = NULL;
  if ( NULL != m_pCD && NULL != m_pCD->GetBasePathsInfo() )
    lpcwszTargetDC = m_pCD->GetBasePathsInfo()->GetServerName();
  NTSTATUS ntstatus = RetrieveRootDomainName( lpcwszTargetDC, &sbstrRootDomainName );
  if ( !LSA_SUCCESS(ntstatus) )
  {
	// error in RetrieveRootDomainName against DSADMIN target DC
    PVOID apv[1] = {(LPWSTR)(lpcwszTargetDC) };
    (void) ReportErrorEx(   m_hwnd,
                            IDS_REPLNOW_1_PARAMLOAD_ERROR,
                            ntstatus,               // CODEWORK
                            MB_OK | MB_ICONEXCLAMATION,
                            apv,
                            1,
                            IDS_REPLNOW_TITLE );
    return;
  }

  CComBSTR sbstrFailingConnection;
  CComBSTR sbstrFromServer;
  CComBSTR sbstrFailingNC;
  HRESULT hr = S_OK;
  bool fSyncError = false;
  ULONG ulOptionsUsed = 0;
  // loop through the array of objects
  UINT cCount;
  for (cCount=0; cCount < m_objectNamesFormat.GetCount(); cCount++) {
    if (wcscmp(m_objectNamesFormat.GetClass(cCount), L"nTDSConnection") !=0)
      continue;

    // get the replication parameters for this connection object
    CComBSTR sbstrDsBindName;
    UUID uuidSourceObjectGUID;
    CStringList strlistCommonNCs;
    ULONG ulDsSyncOptions = 0L;
  	sbstrFromServer.Empty();
    sbstrFailingConnection = m_objectNamesFormat.GetName(cCount);
    hr = PrepareReplicaSyncParameters(
      sbstrFailingConnection,
      sbstrRootDomainName,
      &sbstrDsBindName,
      &uuidSourceObjectGUID,
      strlistCommonNCs,
      &ulDsSyncOptions,
      &sbstrFromServer
      );
    BREAK_ON_FAIL;

    // now bind to the target DC
    Smart_DsHandle shDS;
    DWORD dwWinError = DsBind( sbstrDsBindName, // DomainControllerAddress
                               NULL,            // DnsDomainName
                               &shDS );
    if (ERROR_SUCCESS != dwWinError)
    {
      hr = HRESULT_FROM_WIN32(dwWinError);
      ASSERT( FAILED(hr) );
      break;
    }

    // sync all common naming contexts for this connection
    CString strCommonNC;
    POSITION pos = strlistCommonNCs.GetHeadPosition();
    while (NULL != pos)
    {
      strCommonNC = strlistCommonNCs.GetNext( pos ) ;
      ASSERT( 0 != strCommonNC.GetLength() );
      dwWinError = DsReplicaSync( shDS,
                                  const_cast<LPWSTR>((LPCTSTR)strCommonNC),
                                  &uuidSourceObjectGUID,
                                  ulDsSyncOptions );
      if (ERROR_SUCCESS != dwWinError)
      {
        sbstrFailingNC = strCommonNC;
        hr = HRESULT_FROM_WIN32(dwWinError);
        ASSERT( FAILED(hr) );
        break;
      }
    }
    if ( FAILED(hr) )
    {
      fSyncError = true;
      break;
    }
    ulOptionsUsed |= ulDsSyncOptions;

  } // for

  if ( SUCCEEDED(hr) )
  {
    (void) ReportMessageEx( m_hwnd,
                            (ulOptionsUsed & DS_REPSYNC_ASYNCHRONOUS_OPERATION)
                                         ? IDS_REPLNOW_SUCCEEDED_DELAYED
                                         : IDS_REPLNOW_SUCCEEDED_IMMEDIATE,
                            MB_OK | MB_ICONINFORMATION,
                            NULL,
                            0,
                            IDS_REPLNOW_TITLE );
  }
  else
  {
    // JonN 3/30/00
    // 6793: SITEREPL: ReplicateNow should provide more error information

    // retrieve name of target DC
    CComBSTR sbstrToServerRDN;
    CPathCracker pathCracker;
    HRESULT hr2 = pathCracker.Set(sbstrFailingConnection, ADS_SETTYPE_FULL);
    ASSERT( SUCCEEDED(hr2) );
    hr2 = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
    ASSERT( SUCCEEDED(hr2) );
    hr2 = pathCracker.GetElement(2, &sbstrToServerRDN);
    ASSERT( SUCCEEDED(hr2) );

    if (fSyncError)
    {
      // error in DsReplicaSync against connection target DC

      // retrieve name of source DC
      CComBSTR sbstrFromServerRDN;
      hr2 = pathCracker.Set(sbstrFromServer, ADS_SETTYPE_DN);
      ASSERT( SUCCEEDED(hr2) );
      hr2 = pathCracker.GetElement(1, &sbstrFromServerRDN);
      ASSERT( SUCCEEDED(hr2) );

      // retrieve name of naming context
      if (sbstrFailingNC && !wcsncmp(L"CN=",sbstrFailingNC,3))
      {
        hr2 = pathCracker.Set(sbstrFailingNC, ADS_SETTYPE_DN);
        ASSERT( SUCCEEDED(hr2) );
        hr2 = pathCracker.GetElement( 0, &sbstrFailingNC );
        ASSERT( SUCCEEDED(hr2) );
      } else {
        LPWSTR pwzDomainNC = NULL;
        hr2 = CrackName(sbstrFailingNC, &pwzDomainNC, GET_DNS_DOMAIN_NAME, NULL);
        ASSERT( SUCCEEDED(hr2) && NULL != pwzDomainNC );
        sbstrFailingNC = pwzDomainNC;
        LocalFreeStringW(&pwzDomainNC);
      }

      PVOID apv[3] = { sbstrToServerRDN, sbstrFromServerRDN, sbstrFailingNC };
      (void) ReportErrorEx(   m_hwnd,
                              IDS_REPLNOW_3_FORCESYNC_ERROR,
                              hr,
                              MB_OK | MB_ICONEXCLAMATION,
                              apv,
                              3,
                              IDS_REPLNOW_TITLE );
    }
    else
    {
      // error in PrepareReplicaSyncParameters against connection target DC
      PVOID apv[1] = { sbstrToServerRDN };
      (void) ReportErrorEx(   m_hwnd,
                              IDS_REPLNOW_1_PARAMLOAD_ERROR,
                              hr,
                              MB_OK | MB_ICONEXCLAMATION,
                              apv,
                              1,
                              IDS_REPLNOW_TITLE );
    }
  }
}

void CDSContextMenu::CopyObject()
{
  if (m_pCD != NULL) 
  {
    m_pCD->_CopyDSObject(m_spDataObject);
  }
}

void CDSContextMenu::_GetExtraInfo(LPDATAOBJECT pDataObj)
{
  FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

  ASSERT(m_objectNamesFormat.HasData());
  
  //we assume these are all the same
  m_Advanced = (m_objectNamesFormat.GetProviderFlags(0) & DSPROVIDER_ADVANCED) != 0;

  // set classes flag      
  for (UINT index = 0; index < m_objectNamesFormat.GetCount(); index++) 
  {
    if (wcscmp(m_objectNamesFormat.GetClass(index), L"user") == 0
#ifdef INETORGPERSON
        || wcscmp(m_objectNamesFormat.GetClass(index), L"inetOrgPerson") == 0
#endif
        ) 
      m_fClasses |= Type_User;
    else if (wcscmp(m_objectNamesFormat.GetClass(index), L"group") == 0)
      m_fClasses |= Type_Group;
    else if (wcscmp(m_objectNamesFormat.GetClass(index), L"computer") == 0)
      m_fClasses |= Type_Computer;
    else if (wcscmp(m_objectNamesFormat.GetClass(index), L"nTDSConnection") == 0)
      m_fClasses |= Type_NTDSConnection;
    else if (wcscmp(m_objectNamesFormat.GetClass(index), L"domainDNS") == 0)
      m_fClasses |= Type_Domain;
    else if (wcscmp(m_objectNamesFormat.GetClass(index), L"contact") == 0)
      m_fClasses |= Type_Contact;
    else if (wcscmp(m_objectNamesFormat.GetClass(index), L"group") == 0)
      m_fClasses |= Type_Group;
    else if (wcscmp(m_objectNamesFormat.GetClass(index), L"organizationalUnit") == 0)
      m_fClasses |= Type_OU;
    else
      m_fClasses |= Type_Others;
  } // for


  // set classid
  g_cfCoClass = (CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
  fmte.cfFormat = g_cfCoClass;
  STGMEDIUM Stg;
  Stg.tymed = TYMED_HGLOBAL;
  Stg.hGlobal = GlobalAlloc (GPTR, sizeof(CLSID));
  HRESULT hr = pDataObj->GetDataHere(&fmte, &Stg);
  if ( SUCCEEDED(hr) ) 
  {
    memcpy (&m_CallerSnapin,  Stg.hGlobal, sizeof(GUID));
    ::GlobalFree(Stg.hGlobal);
  } 
  else 
  {
    m_CallerSnapin = GUID_NULL;
  }

  // get HWND (MMC mainframe window)
  g_cfParentHwnd = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_PARENTHWND);
  fmte.cfFormat = g_cfParentHwnd;
  Stg.tymed = TYMED_NULL;
  if ( SUCCEEDED(pDataObj->GetData(&fmte, &Stg)) ) 
  {
    memcpy (&m_hwnd,  Stg.hGlobal, sizeof(HWND));
    ::GlobalFree(Stg.hGlobal);
  }
  else 
  {
    // need an HWND anyway
    m_hwnd = ::GetActiveWindow();
  }

  TRACE(L"HWND = 0x%x\n", m_hwnd);
  ASSERT((m_hwnd != NULL) && ::IsWindow(m_hwnd));

  // get component data (if in the context of DS Admin)
  g_cfComponentData = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DS_COMPDATA);
  fmte.cfFormat = g_cfComponentData;
  Stg.tymed = TYMED_NULL;
  if ( SUCCEEDED(pDataObj->GetData(&fmte, &Stg)) ) 
  {
    memcpy (&m_pCD, Stg.hGlobal, sizeof(CDSComponentData*));
    ::GlobalFree(Stg.hGlobal);
  } else 
  {
    m_pCD = NULL;
  }
  
  // get component data (if in the context of DS Find)
  if (m_pCD == NULL)
  {
    m_pCD = g_pCD;
  }
}

BOOL 
CDSContextMenu::_WarningOnSheetsUp()
{
  // if called in the context of DS Admin, guard against property sheet open on this cookie
  if ( (m_pCD != NULL) && m_internalFormat.HasData() ) 
  {
    return m_pCD->_WarningOnSheetsUp(&m_internalFormat);
  }
  return FALSE;
}



void
CDSContextMenu::Rename()
{
  HRESULT hr = S_OK;
  INT_PTR answer = IDOK;
  LPWSTR pszDomain = NULL;
  LPWSTR pwzLocalDomain = NULL;
  IDirectoryObject * pObj = NULL;
  IADs * pObj2 = NULL;
  IADs * pPartitions = NULL;
  CString csLogin;
  CString csTemp;
  CString csSam;
  CWaitCursor cwait;
  BOOL error = FALSE;
  BOOL fAccessDenied = FALSE;
  LPWSTR pszNewName = NULL;
  LPWSTR pszFirstName = NULL;
  LPWSTR pszDispName = NULL;
  LPWSTR pszSurName = NULL;
  LPWSTR pszSAMName = NULL;
  LPWSTR pszUPN = NULL;
  BOOL NoRename = FALSE;

  CComVariant Var;


  // guard against property sheet open on this cookie
  if (_WarningOnSheetsUp())
    return;

  CString strClass = m_objectNamesFormat.GetClass(0);
  if (strClass == L"user"
#ifdef INETORGPERSON
      || strClass == L"inetOrgPerson"
#endif
      ) 
  {
    // rename user
    CRenameUserDlg dlgRename(m_pCD);

    LPWSTR pAttrNames[] = {L"distinguishedName",
                           L"userPrincipalName",
                           L"sAMAccountName",
                           L"givenName",
                           L"displayName",
                           L"sn",
                           L"cn"};
    PADS_ATTR_INFO pAttrs = NULL;
    ULONG cAttrs = 0;

    CString szPath = m_objectNamesFormat.GetName(0);
    hr = DSAdminOpenObject(szPath,
                           IID_IDirectoryObject, 
                           (void **)&pObj,
                           TRUE /*bServer*/);
    if (SUCCEEDED(hr)) {
      hr = pObj->GetObjectAttributes (pAttrNames, 7, &pAttrs, &cAttrs);
      if (SUCCEEDED(hr)) {
        for (UINT i = 0; i < cAttrs; i++) {
          if (_wcsicmp (L"distinguishedName", pAttrs[i].pszAttrName) == 0) {
            hr = CrackName (pAttrs[i].pADsValues->CaseIgnoreString,
                            &pszDomain, GET_NT4_DOMAIN_NAME, NULL);
            if (SUCCEEDED(hr)) {
              dlgRename.m_dldomain = pszDomain;
              dlgRename.m_dldomain += L'\\';
            }
            // get the Domain of this object, need it later.
            CComBSTR bsDN;
            CPathCracker pathCracker;
            pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
            pathCracker.Set((LPTSTR)(LPCTSTR)szPath, ADS_SETTYPE_FULL);
            pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bsDN);
            
            // get the NT 5 (dns) domain name
            TRACE(L"CrackName(%s, &pwzLocalDomain, GET_DNS_DOMAIN_NAME, NULL);\n", bsDN);
            hr = CrackName(bsDN, &pwzLocalDomain, GET_DNS_DOMAIN_NAME, NULL);
            TRACE(L"CrackName returned hr = 0x%x, pwzLocalDomain = <%s>\n", hr, pwzLocalDomain);
          }
          if (_wcsicmp (L"userPrincipalName", pAttrs[i].pszAttrName) == 0) {
            csTemp = pAttrs[i].pADsValues->CaseIgnoreString;
            INT loc = csTemp.Find (L'@');
            if (loc > 0) {
              dlgRename.m_login = csTemp.Left(loc);
              dlgRename.m_domain = csTemp.Right (csTemp.GetLength() - loc);
            } else {
              dlgRename.m_login = csTemp;
              ASSERT (0 && L"can't find @ in upn");
            }
          }

          if (_wcsicmp (L"sAMAccountName", pAttrs[i].pszAttrName) == 0) {
            dlgRename.m_samaccountname = pAttrs[i].pADsValues->CaseIgnoreString;
          }
          if (_wcsicmp (L"givenName", pAttrs[i].pszAttrName) == 0) {
            dlgRename.m_first = pAttrs[i].pADsValues->CaseIgnoreString;
          }
          if (_wcsicmp (L"displayName", pAttrs[i].pszAttrName) == 0) {
            dlgRename.m_displayname = pAttrs[i].pADsValues->CaseIgnoreString;
          }
          if (_wcsicmp (L"sn", pAttrs[i].pszAttrName) == 0) {
            dlgRename.m_last = pAttrs[i].pADsValues->CaseIgnoreString;
          }
          if (_wcsicmp (L"cn", pAttrs[i].pszAttrName) == 0) {
            dlgRename.m_cn = pAttrs[i].pADsValues->CaseIgnoreString;
            dlgRename.m_oldcn = dlgRename.m_cn;
          }
        }
      }
      // get UPN suffixes from this OU, if present
      IADs * pObjADs = NULL;
      IADs * pCont = NULL;
      BSTR bsParentPath;
      CStringList UPNs;
      
      hr = pObj->QueryInterface (IID_IADs, (void **)&pObjADs);
      ASSERT (SUCCEEDED(hr));
      hr = pObjADs->get_Parent(&bsParentPath);
      ASSERT (SUCCEEDED(hr));
      hr = DSAdminOpenObject(bsParentPath,
                             IID_IADs, 
                             (void **)&pCont,
                             TRUE /*bServer*/);
      
      CComVariant sVar;
      hr = pCont->Get ( L"uPNSuffixes", &sVar);
      if (SUCCEEDED(hr)) {
        hr = HrVariantToStringList (IN sVar, UPNs);
        if (SUCCEEDED(hr)) {
          POSITION pos = UPNs.GetHeadPosition();
          CString csSuffix;
          while (pos != NULL) {
            csSuffix = L"@";
            csSuffix += UPNs.GetNext(INOUT pos);
            TRACE(_T("UPN suffix: %s\n"), csSuffix);
            if (wcscmp (csSuffix, dlgRename.m_domain)) {
              dlgRename.m_domains.AddTail (csSuffix);
            }
          }
        }
      } else {// now get the domain options
        IDsBrowseDomainTree* pDsDomains = NULL;
        hr = ::CoCreateInstance(CLSID_DsDomainTreeBrowser,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IDsBrowseDomainTree,
                                (LPVOID*)&pDsDomains);
        ASSERT(SUCCEEDED(hr));
      
        PDOMAIN_TREE pNewDomains = NULL;
        hr = pDsDomains->GetDomains(&pNewDomains, 0);
        if (SUCCEEDED(hr))
          {
            ASSERT(pNewDomains);
            for (UINT index = 0; index < pNewDomains->dwCount; index++) {
              if (pNewDomains->aDomains[index].pszTrustParent == NULL) {
                CString strAtDomain = "@";
                strAtDomain += pNewDomains->aDomains[index].pszName;
                if (wcscmp (strAtDomain, dlgRename.m_domain)) {
                  dlgRename.m_domains.AddTail (strAtDomain);
            
                }
              }
            }
            pDsDomains->FreeDomains(&pNewDomains);
          }

        if (pDsDomains) {
          pDsDomains->Release();
        }

        LocalFreeStringW(&pszDomain);
        // get UPN suffixes
        CString csPartitions;
        CStringList UPNsToo;
        // get config path from main object
        csPartitions = m_pCD->GetBasePathsInfo()->GetProviderAndServerName();
        csPartitions += L"CN=Partitions,";
        csPartitions += m_pCD->GetBasePathsInfo()->GetConfigNamingContext();
        hr = DSAdminOpenObject(csPartitions,
                               IID_IADs, 
                               (void **)&pPartitions,
                               TRUE /*bServer*/);
        if (SUCCEEDED(hr)) {
          CComVariant sVarToo;
          hr = pPartitions->Get ( L"uPNSuffixes", &sVarToo);
          if (SUCCEEDED(hr)) {
            hr = HrVariantToStringList (IN sVarToo, UPNsToo);
            if (SUCCEEDED(hr)) {
              POSITION pos = UPNs.GetHeadPosition();
              CString csSuffix;
              while (pos != NULL) {
                csSuffix = L"@";
                csSuffix += UPNsToo.GetNext(INOUT pos);
                TRACE(_T("UPN suffix: %s\n"), csSuffix);
                if (wcscmp (csSuffix, dlgRename.m_domain)) {
                  dlgRename.m_domains.AddTail (csSuffix);
                }
              }
            }
          }
          pPartitions->Release();
        }
      }
      error = TRUE;
      while ((error) && (!fAccessDenied)){
        answer = dlgRename.DoModal();
        if (answer == IDOK) {
          ADSVALUE avUPN = {ADSTYPE_CASE_IGNORE_STRING, NULL};
          ADS_ATTR_INFO aiUPN = {L"userPrincipalName", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, &avUPN, 1};
          ADSVALUE avSAMName = {ADSTYPE_CASE_IGNORE_STRING, NULL};
          ADS_ATTR_INFO aiSAMName = {L"sAMAccountName", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, &avSAMName, 1};
          ADSVALUE avGiven = {ADSTYPE_CASE_IGNORE_STRING, NULL};
          ADS_ATTR_INFO aiGiven = {L"givenName", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, &avGiven, 1};
          ADSVALUE avSurName = {ADSTYPE_CASE_IGNORE_STRING, NULL};
          ADS_ATTR_INFO aiSurName = {L"sn", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, &avSurName, 1};
           ADSVALUE avDispName = {ADSTYPE_CASE_IGNORE_STRING, NULL};
           ADS_ATTR_INFO aiDispName = {L"displayName", ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, &avDispName, 1};

          ADS_ATTR_INFO rgAttrs[5];
          ULONG cModified = 0;
          cAttrs = 0;

          if (!dlgRename.m_login.IsEmpty() &&
              !dlgRename.m_domain.IsEmpty()) {
            dlgRename.m_login.TrimRight();
            dlgRename.m_login.TrimLeft();
            dlgRename.m_domain.TrimRight();
            dlgRename.m_domain.TrimLeft();
            csTemp = (dlgRename.m_login + dlgRename.m_domain);
            pszUPN = new WCHAR[wcslen(csTemp) + sizeof(WCHAR)];
            wcscpy (pszUPN, csTemp);
            avUPN.CaseIgnoreString = pszUPN;
          } else {
            aiUPN.dwControlCode = ADS_ATTR_CLEAR;
          }
          rgAttrs[cAttrs++] = aiUPN;

          // test UPN for duplication
          
          // test UPN for duplication
          // validate UPN with GC before doing the put.
          BOOL fDomainSearchFailed = FALSE;
          BOOL fGCSearchFailed = FALSE;


          BOOL dup = FALSE;
          CString strFilter;
          LPWSTR pAttributes[1] = {L"cn"};
          IDirectorySearch * pGCObj = NULL;
          CDSSearch DSS (m_pCD->m_pClassCache, m_pCD);
          hr = DSPROP_GetGCSearchOnDomain(pwzLocalDomain,
                                          IID_IDirectorySearch, 
                                          (void **)&pGCObj);

          if (FAILED(hr)) {
            fGCSearchFailed = TRUE;
          } else {
            DSS.Init (pGCObj);
            
            LPWSTR pUserAttributes[1] = {L"cn"};
            strFilter = L"(userPrincipalName=";
            strFilter += pszUPN;
            strFilter += L")";
            DSS.SetAttributeList (pUserAttributes, 1);
            DSS.SetFilterString ((LPWSTR)(LPCWSTR)strFilter);
            DSS.SetSearchScope (ADS_SCOPE_SUBTREE);
            DSS.DoQuery();
            hr = DSS.GetNextRow();
            dup = FALSE;
            while ((hr == S_OK) && (dup == FALSE)) { // this means a row was returned, so we're dup
              ADS_SEARCH_COLUMN Col;
              hr = DSS.GetColumn(pUserAttributes[0], &Col);
              if (_wcsicmp(Col.pADsValues->CaseIgnoreString, dlgRename.m_oldcn)) {
                dup = TRUE;
                ReportErrorEx (m_hwnd, IDS_UPN_DUP, hr,
                               MB_OK, NULL, 0);
              } 
              hr = DSS.GetNextRow();
            }
            if (hr != S_ADS_NOMORE_ROWS) {
              fGCSearchFailed = TRUE;
            }
          }
          HRESULT hr2 = S_OK;
          if (dup)
            continue;
          else {
              CString strInitPath = L"LDAP://";
              strInitPath += pwzLocalDomain;
              TRACE(_T("Initialize Domain search object with: %s...\n"), strInitPath);
              hr2 = DSS.Init (strInitPath);
              if (SUCCEEDED(hr2)) {
                LPWSTR pAttributes2[1] = {L"cn"};
                strFilter = L"(userPrincipalName=";
                strFilter += pszUPN;
                strFilter += L")";
                TRACE(_T("searching current domain for %s...\n"), pszUPN);
                DSS.SetAttributeList (pAttributes2, 1);
                DSS.SetFilterString ((LPWSTR)(LPCWSTR)strFilter);
                DSS.SetSearchScope (ADS_SCOPE_SUBTREE);
                DSS.DoQuery();
                hr2 = DSS.GetNextRow();
                TRACE(_T("done searching current domain for %s...\n"), pszUPN);
              }
              while ((hr2 == S_OK) && (dup == FALSE)) { // this means a row was returned, so we're dup
                ADS_SEARCH_COLUMN Col;
                HRESULT hr3 = DSS.GetColumn(pAttributes[0], &Col);
                ASSERT(hr3 == S_OK);
                if (_wcsicmp(Col.pADsValues->CaseIgnoreString, dlgRename.m_oldcn)) {
                  dup = TRUE;
                  ReportErrorEx (m_hwnd, IDS_UPN_DUP, hr,
                                 MB_OK, NULL, 0);
                } 
                hr2 = DSS.GetNextRow();
              }
              if (hr2 != S_ADS_NOMORE_ROWS) { // oops, had another problem
                fDomainSearchFailed = TRUE;
              }
          }
          if (dup)
            continue;
          else {
            if (fDomainSearchFailed || fGCSearchFailed) {
              HRESULT hrSearch = S_OK;
              if (fDomainSearchFailed) {
                hrSearch = hr2;
              } else {
                hrSearch = hr;
              }
              ReportErrorEx (m_hwnd,IDS_UPN_SEARCH_FAILED2,hrSearch,
                             MB_OK | MB_ICONWARNING, NULL, 0);
            }
          }

          if (pGCObj) {
            pGCObj->Release();
            pGCObj = NULL;
          }

          pszNewName = new WCHAR[wcslen(dlgRename.m_cn) + sizeof(WCHAR)];
          dlgRename.m_cn.TrimRight();
          dlgRename.m_cn.TrimLeft();

          wcscpy (pszNewName, dlgRename.m_cn);

          if (dlgRename.m_cn == dlgRename.m_oldcn)
            NoRename = TRUE;

          if (!dlgRename.m_displayname.IsEmpty()) {
            dlgRename.m_displayname.TrimLeft();
            dlgRename.m_displayname.TrimRight();
            pszDispName = new WCHAR[wcslen(dlgRename.m_displayname) + sizeof(WCHAR)];
            wcscpy (pszDispName, dlgRename.m_displayname);
            avDispName.CaseIgnoreString = pszDispName;
          } else {
            aiDispName.dwControlCode = ADS_ATTR_CLEAR;
          }
          rgAttrs[cAttrs++] = aiDispName;

          if (!dlgRename.m_first.IsEmpty()) {
            dlgRename.m_first.TrimLeft();
            dlgRename.m_first.TrimRight();
            pszFirstName = new WCHAR[wcslen(dlgRename.m_first) + sizeof(WCHAR)];
            wcscpy (pszFirstName, dlgRename.m_first);
            avGiven.CaseIgnoreString = pszFirstName;
          } else {
            aiGiven.dwControlCode = ADS_ATTR_CLEAR;
          }
          rgAttrs[cAttrs++] = aiGiven;

          if (!dlgRename.m_last.IsEmpty()) {
            dlgRename.m_last.TrimLeft();
            dlgRename.m_last.TrimRight();
            pszSurName = new WCHAR[wcslen(dlgRename.m_last) + sizeof(WCHAR)];
            wcscpy (pszSurName, dlgRename.m_last);
            avSurName.CaseIgnoreString = pszSurName;
          } else {
            aiSurName.dwControlCode = ADS_ATTR_CLEAR;
          }
          rgAttrs[cAttrs++] = aiSurName;

          if (!dlgRename.m_samaccountname.IsEmpty()) {
            dlgRename.m_samaccountname.TrimLeft();
            dlgRename.m_samaccountname.TrimRight();
            pszSAMName = new WCHAR[wcslen(dlgRename.m_samaccountname) + sizeof(WCHAR)];
            wcscpy (pszSAMName, dlgRename.m_samaccountname);
            avSAMName.CaseIgnoreString = pszSAMName;
          } else {
            aiSAMName.dwControlCode = ADS_ATTR_CLEAR;
          }
          rgAttrs[cAttrs++] = aiSAMName;
          
          
          hr = pObj->SetObjectAttributes (rgAttrs, cAttrs, &cModified);
          if (FAILED(hr)) {
            if (hr == E_ACCESSDENIED) {
              fAccessDenied = TRUE;
              NoRename = TRUE;
            } else {
              ReportErrorEx (m_hwnd, IDS_NAME_CHANGE_FAILED, hr,
                             MB_OK|MB_ICONERROR, NULL, 0, TRUE);
            }
          } else {
            error = FALSE;
          }
        } else {
          error = FALSE;
        }
      } 
    } else {
      answer = IDCANCEL;
      PVOID apv[1] = {(BSTR)(LPWSTR)(LPCWSTR)m_objectNamesFormat.GetName(0)};
      ReportErrorEx (m_hwnd,IDS_12_USER_OBJECT_NOT_ACCESSABLE,hr,
                     MB_OK | MB_ICONERROR, apv, 1);
    }
  } else if (strClass == L"group") {
    CRenameGroupDlg * pdlgRename = new CRenameGroupDlg;

      CString szPath;
    szPath = m_objectNamesFormat.GetName(0);
    hr = DSAdminOpenObject(szPath,
                           IID_IADs, 
                           (void **)&pObj2,
                           TRUE /*bServer*/);
    if (SUCCEEDED(hr)) {
      hr = pObj2->Get (L"sAMAccountName", &Var);
      ASSERT (SUCCEEDED(hr));
      csSam = Var.bstrVal;
      if (strClass == L"computer") {
        INT loc = csSam.Find(L"$");
        if (loc > 0) {
          csSam = csSam.Left(loc);
        }
      }
      
      hr = pObj2->Get (L"cn", &Var);
      ASSERT (SUCCEEDED(hr));
      pdlgRename->m_cn = Var.bstrVal;
      
      // figure out group type
      if (strClass == L"group") {
        CComVariant varType;
        hr = pObj2->Get(L"groupType", &varType);
        ASSERT(SUCCEEDED(hr));
        INT GroupType = (varType.lVal & ~GROUP_TYPE_SECURITY_ENABLED);
        if (GroupType == GROUP_TYPE_RESOURCE_GROUP) {
          pdlgRename->m_samtextlimit = 64;
        }
      }

      pdlgRename->m_samaccountname = csSam;

      error = TRUE;
      while ((error) && (!fAccessDenied)){
        answer = pdlgRename->DoModal();
        if (answer == IDOK) {
          pdlgRename->m_cn.TrimRight();
          pdlgRename->m_cn.TrimLeft();
          pszNewName = new WCHAR[wcslen(pdlgRename->m_cn) + (1 * sizeof(WCHAR))];
          wcscpy (pszNewName, pdlgRename->m_cn);
          Var.vt = VT_BSTR;
          
          pdlgRename->m_samaccountname.TrimLeft();
          pdlgRename->m_samaccountname.TrimRight();
          csSam = pdlgRename->m_samaccountname;
          if (strClass == L"computer") {
            csSam += L"$";
          }
          Var.bstrVal = SysAllocString(csSam);
          hr = pObj2->Put (L"sAMAccountName", Var);
          ASSERT (SUCCEEDED(hr));
          if (FAILED(hr)) {
            continue;
          }
          
          hr = pObj2->SetInfo();
          if (FAILED(hr)) {
            if (hr == E_ACCESSDENIED) {
              fAccessDenied = TRUE;
              NoRename = TRUE;
            } else {
              ReportErrorEx (m_hwnd, IDS_NAME_CHANGE_FAILED, hr,
                             MB_OK|MB_ICONERROR, NULL, 0, TRUE);
            }
          } else {
            error = FALSE;
          }
        } else {
          error = FALSE;
        }
      }
    } else {
      answer = IDCANCEL;
    }
    if (pdlgRename) {
      delete pdlgRename;
    }
  } else if (strClass == L"contact") {
    // rename contact
    CRenameContactDlg dlgRename;

    CString szPath;
    szPath = m_objectNamesFormat.GetName(0);
    hr = DSAdminOpenObject(szPath,
                           IID_IADs, 
                           (void **)&pObj2,
                           TRUE /*bServer*/);
    if (SUCCEEDED(hr)) {
      hr = pObj2->Get (L"givenName", &Var);
      ASSERT (SUCCEEDED(hr) || (hr == E_ADS_PROPERTY_NOT_FOUND));
      if (SUCCEEDED(hr)) {
        dlgRename.m_first = Var.bstrVal;
      }

      hr = pObj2->Get (L"sn", &Var);
      ASSERT (SUCCEEDED(hr) || (hr == E_ADS_PROPERTY_NOT_FOUND));
      if (SUCCEEDED(hr)) {
        dlgRename.m_last = Var.bstrVal;
      }

      hr = pObj2->Get (L"displayName", &Var);
      ASSERT (SUCCEEDED(hr) || (hr == E_ADS_PROPERTY_NOT_FOUND));
      if (SUCCEEDED(hr)) {
        dlgRename.m_disp = Var.bstrVal;
      }

      hr = pObj2->Get (L"cn", &Var);
      ASSERT (SUCCEEDED(hr) || (hr == E_ADS_PROPERTY_NOT_FOUND));
      if (SUCCEEDED(hr)) {
        dlgRename.m_cn = Var.bstrVal;
      }

      error = TRUE;
      while ((error) && (!fAccessDenied)){
        answer = dlgRename.DoModal();
        if (answer == IDOK) {
          dlgRename.m_cn.TrimRight();
          dlgRename.m_cn.TrimLeft();
          pszNewName = new WCHAR[wcslen(dlgRename.m_cn) + (1 * sizeof(WCHAR))];
          wcscpy (pszNewName, dlgRename.m_cn);
          Var.vt = VT_BSTR;
          
          if (!dlgRename.m_first.IsEmpty()) {
            dlgRename.m_first.TrimLeft();
            dlgRename.m_first.TrimRight();
            Var.bstrVal = SysAllocString (dlgRename.m_first);
            hr = pObj2->Put (L"givenName", Var);
            ASSERT (SUCCEEDED(hr));
          }
          
          if (!dlgRename.m_last.IsEmpty()) {
            dlgRename.m_last.TrimLeft();
            dlgRename.m_last.TrimRight();
            Var.bstrVal = SysAllocString(dlgRename.m_last);
            hr = pObj2->Put (L"sn", Var);
            ASSERT (SUCCEEDED(hr));
          }
          
          if (!dlgRename.m_disp.IsEmpty()) {
            dlgRename.m_disp.TrimLeft();
            dlgRename.m_disp.TrimRight();
            Var.bstrVal = SysAllocString(dlgRename.m_disp);
            hr = pObj2->Put (L"displayName", Var);
            ASSERT (SUCCEEDED(hr));
          }
          
          hr = pObj2->SetInfo();
          if (FAILED(hr)) {
            if (hr == E_ACCESSDENIED) {
              fAccessDenied = TRUE;
              NoRename = TRUE;
            } else {
              ReportErrorEx (m_hwnd, IDS_NAME_CHANGE_FAILED, hr,
                             MB_OK|MB_ICONERROR, NULL, 0, TRUE);
            }
          } else {
            error = FALSE;
          } 
        } else {
          error = FALSE;
        }
      }
    } else {
      answer = IDCANCEL;
    }
  } else {
    // need generic dialog here.
    CRenameGenericDlg dlgRename (CWnd::FromHandle(m_hwnd));

    CString szPath;
    szPath = m_objectNamesFormat.GetName(0);
    hr = DSAdminOpenObject(szPath,
                           IID_IADs, 
                           (void **)&pObj2,
                           TRUE /*bServer*/);
    if (SUCCEEDED(hr)) {
      CDSClassCacheItemBase* pItem = NULL;
      
      pItem = m_pCD->m_pClassCache->FindClassCacheItem(m_pCD, (LPCWSTR)strClass, szPath);
      
      ASSERT (pItem != NULL);
      //get the naming attribute
      CString csNewAttrName;
      csNewAttrName = pItem->GetNamingAttribute();
      
      hr = pObj2->Get (CComBSTR(csNewAttrName), &Var);
      
      ASSERT (SUCCEEDED(hr) || (hr == E_ADS_PROPERTY_NOT_FOUND));
      if (SUCCEEDED(hr)) {
        dlgRename.m_cn = Var.bstrVal;
      }

      error = TRUE;
      while (error) {
        answer = dlgRename.DoModal();
        if (answer == IDOK) {
          dlgRename.m_cn.TrimRight();
          dlgRename.m_cn.TrimLeft();
          pszNewName = new WCHAR[wcslen(dlgRename.m_cn) + (1 * sizeof(WCHAR))];
          wcscpy (pszNewName, dlgRename.m_cn);
          error = FALSE;
        } else {
          error = FALSE;
        }
      }
    }
          
  }    
  if ((answer == IDOK) && (error == FALSE) && (NoRename == FALSE)) {
    CString csObjectPath = m_objectNamesFormat.GetName(0);
    CDSClassCacheItemBase* pItem = NULL;
    pItem = m_pCD->m_pClassCache->FindClassCacheItem(m_pCD, (LPCWSTR)strClass, csObjectPath);
    ASSERT (pItem != NULL);
    
    // get the new name in the form "cn=foo" or "ou=foo"
    CString csNewAttrName;
    csNewAttrName = pItem->GetNamingAttribute();
    csNewAttrName += L"=";
    csNewAttrName += pszNewName;
    TRACE(_T("_RenameObject: Attributed name is %s.\n"), csNewAttrName);
    
    // bind to object
    IADs *pDSObject = NULL;
    hr = DSAdminOpenObject(csObjectPath,
                           IID_IADs,
                           (void **)&pDSObject,
                           TRUE /*bServer*/);
    if (!SUCCEEDED(hr)) {
      goto error;
    }
    BSTR bsParentPath;
    // get the path of the object container
    hr = pDSObject->get_Parent (&bsParentPath);
    if (!SUCCEEDED(hr)) {
      goto error;
    }
    pDSObject->Release();
    pDSObject = NULL;
    
    IADsContainer * pContainer = NULL;
    // bind to the object container
    hr = DSAdminOpenObject(bsParentPath,
                           IID_IADsContainer,
                           (void **)&pContainer,
                           TRUE /*bServer*/);
    if (!SUCCEEDED(hr)) {
      goto error;
    }

    // build the new LDAP path
    CString csNewNamingContext, csNewPath, szPath;
    BSTR bsEscapedName;
    csNewNamingContext = csNewAttrName;
    csNewNamingContext += L",";
    StripADsIPath(bsParentPath, szPath);
    csNewNamingContext += szPath;
    m_pCD->GetBasePathsInfo()->ComposeADsIPath(csNewPath, csNewNamingContext);

    // create a transaction object, the destructor will call End() on it
    CDSNotifyHandlerTransaction transaction(m_pCD);
    transaction.SetEventType(DSA_NOTIFY_REN);

    // start the transaction
    hr = transaction.Begin(m_objectNamesFormat.GetName(0),
                           m_objectNamesFormat.GetClass(0), 
                           m_objectNamesFormat.IsContainer(0),
                           csNewPath, 
                           m_objectNamesFormat.GetClass(0), 
                           m_objectNamesFormat.IsContainer(0));

    // ask for confirmation
    if (transaction.NeedNotifyCount() > 0)
    {
      CString szMessage, szAssocData;
      szMessage.LoadString(IDS_CONFIRM_RENAME);
      szAssocData.LoadString(IDS_EXTENS_RENAME);
      CConfirmOperationDialog dlg(::GetParent(m_hwnd), &transaction);
      dlg.SetStrings(szMessage, szAssocData);
      if (IDNO == dlg.DoModal())
      {
        transaction.End();
        hr = S_OK;
        goto error;
      }
    }

    CPathCracker pathCracker;
    hr = pathCracker.GetEscapedElement(0, //reserved
                                          (BSTR)(LPCWSTR)csNewAttrName,
                                          &bsEscapedName);
    if (FAILED(hr))
      goto error;

    IDispatch * pDispObj = NULL;
    // do the actual rename
    hr = pContainer->MoveHere((LPWSTR)(LPCWSTR)csObjectPath,
                              (LPWSTR)(LPCWSTR)bsEscapedName,
                              &pDispObj);
    
    
    if (SUCCEEDED(hr) && (hr != S_FALSE)) {
      // let extensions know
      transaction.Notify(0); 

      // send notify to diz
    }
    
    if (pDispObj) {
      pDispObj->Release();
    }
  }  
  if (fAccessDenied) {
    PVOID apv[1] = {(LPWSTR)m_objectNamesFormat.GetName(0)};
    ReportErrorEx(::GetParent(m_hwnd),IDS_12_RENAME_NOT_ALLOWED,hr,
                  MB_OK | MB_ICONERROR, apv, 1);
  }

error:  
  // transaction.End() will be called by the transaction's destructor

  if (pwzLocalDomain) {
     LocalFreeStringW(&pwzLocalDomain);
  }
  if (pszNewName) {
    delete pszNewName;
  }
  if (pszFirstName) {
    delete pszFirstName;
  } 
  if (pszDispName) {
    delete pszDispName;
  }
  if (pszSurName) {
    delete pszSurName;
  }
  if (pszSAMName){
    delete pszSAMName;
  }
  if (pszUPN) {
    delete pszUPN;
  }

  if (pObj) {
    pObj->Release();
  }
  if (pObj2) {
    pObj2->Release();
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsdirect.h ===
// DSdirect.h : Declaration of ds routines and clases
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSdirect.h
//
//  Contents:  Encapsulation for ADsi interfaces and methods
//
//  History:   02-feb-97 jimharr    Created
//
//--------------------------------------------------------------------------

#ifndef __DSDIRECT_H_
#define __DSDIRECT_H_


class CDSDirect;
class CDSCookie;
class CDSUINode;
class CDSComponentData;
class CDSThreadQueryInfo;
class CWorkerThread;


class CDSDirect
{
public:
  CDSDirect();
  CDSDirect(CDSComponentData * pCD);
  ~CDSDirect();

  CString m_strDNS;
  CDSComponentData * m_pCD;
  
  HRESULT EnumerateContainer(CDSThreadQueryInfo* pQueryInfo, 
                             CWorkerThread* pWorkerThread);

  HRESULT EnumerateRootContainer(CDSThreadQueryInfo* pQueryInfo, 
                                  CWorkerThread* pWorkerThread);
  HRESULT CreateRootChild(LPCTSTR lpcszPrefix, 
                          CDSThreadQueryInfo* pQueryInfo, 
                          CWorkerThread* pWorkerThread);

  HRESULT DeleteObject(CDSCookie *pCookie, BOOL raiseUI);
  HRESULT MoveObject(CDSCookie *pCookie);
  HRESULT RenameObject(CDSCookie *pCookie, LPCWSTR lpszBaseDN);
  HRESULT DSFind(HWND hwnd, LPCWSTR lpszBaseDN);

  HRESULT GetParentDN(CDSCookie* pCookie, CString& szParentDN);
  HRESULT InitCreateInfo();

  HRESULT ReadDSObjectCookie(IN CDSUINode* pContainerDSUINode, // IN: container where to create object
                             IN LPCWSTR lpszLdapPath, // path of the object
                             OUT CDSCookie** ppNewCookie);	// newly created cookie

  HRESULT ReadDSObjectCookie(IN CDSUINode* pContainerDSUINode, // IN: container where to create object
                                      IN IADs* pADs, // pointer to an already bound ADSI object
                                      OUT CDSCookie** ppNewCookie);	// newly created cookie

  HRESULT CreateDSObject(CDSUINode* pContainerDSUINode, // IN: container where to create object
                         LPCWSTR lpszObjectClass, // IN: class of the object to be created
                         IN CDSUINode* pCopyFromDSUINode, // IN: (optional) object to be copied
                         OUT CDSCookie** ppSUINodeNew);	// OUT: OPTIONAL: Pointer to new node
                
};

//////////////////////////////////////////////////////////////////////////////////
// standard attributes array (for queries)

extern const INT g_nStdCols; // number of items in the standard attributes array
extern const LPWSTR g_pStandardAttributes[]; // array if attrbutes

// indexes in the array
extern const INT g_nADsPath;
extern const INT g_nName;
extern const INT g_nObjectClass;
extern const INT g_nGroupType;
extern const INT g_nDescription;
extern const INT g_nUserAccountControl;
extern const INT g_nSystemFlags;

///////////////////////////////////////////////////////////////////////////////////

#endif __DSDIRECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dscookie.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSCookie.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "dscookie.h"
#include "dssnap.h"
#include "ContextMenu.h"

#include <notify.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CDSCookie

CDSCookie::CDSCookie() 
{
  m_ppChildList = NULL;
  m_bDisabled = FALSE;
  m_bNonExpiringPassword = FALSE;
  m_iSystemFlags = 0;
  m_pCacheItem = NULL;
  m_pExtraInfo = NULL;
  m_pModifiedTime = NULL;
}


CDSCookie::~CDSCookie() 
{
  
  if (m_ppChildList)
    LocalFree (m_ppChildList);
  
  if (m_pExtraInfo != NULL)
  {
    delete m_pExtraInfo;
    m_pExtraInfo = NULL;
  }

  if (m_pModifiedTime != NULL)
    free(m_pModifiedTime);

  //TRACE(_T("CDSCookie::Deleted (%s)\n"), m_strName);
}

CDSColumnSet* CDSUINode::GetColumnSet(CDSComponentData* pComponentData)
{
  CDSColumnSet* pColumnSet = NULL;
  if (IsContainer())
  {
    CDSCookie* pCookie = GetDSCookieFromUINode(this);
    if (pCookie != NULL)
    {
      PCWSTR pszClass = pCookie->GetClass();
      if (pszClass != NULL)
      {
        pColumnSet = GetFolderInfo()->GetColumnSet(pszClass, pComponentData);
      }
    }

    if (pColumnSet == NULL)
    {
      pColumnSet = GetFolderInfo()->GetColumnSet(DEFAULT_COLUMN_SET, pComponentData);
    }
  }
    
  return pColumnSet;
}


int CDSCookie::GetImage(BOOL bOpen) 
{ 
  ASSERT(m_pCacheItem != NULL);
  return m_pCacheItem->GetIconIndex(this, bOpen);
}

GUID* CDSCookie::GetGUID() 
{ 
  if(m_pCacheItem != NULL)
    return m_pCacheItem->GetGUID();
  return (GUID*)&GUID_NULL;
}


LPCWSTR CDSCookie::GetClass()
{ 
  if (m_pCacheItem == NULL)
    return L"";
  return m_pCacheItem->GetClassName();
}

LPCWSTR CDSCookie::GetLocalizedClassName() 
{ 
  // try to see if we have extra info to use
  if (m_pExtraInfo != NULL)
  {
    LPCWSTR lpsz = m_pExtraInfo->GetFriendlyClassName();
    if ((lpsz != NULL) && (lpsz[0] != NULL))
      return lpsz;
  }
  // try the class cache
  if (m_pCacheItem != NULL)
  {
    return m_pCacheItem->GetFriendlyClassName(); 
  }
  return L""; 
}


//+-------------------------------------------------------------------------
// Value Management functions
//+-------------------------------------------------------------------------

void
CDSCookie::SetChildList (WCHAR **ppList)
{ 
  if (m_ppChildList) {
    LocalFree (m_ppChildList);
  }
  m_ppChildList=ppList;
}



/////////////////////////////////////////////////////////////////////////////
// CDSUINode : UI node corresponding to a DS object (result of an ADSI query)
CDSUINode::CDSUINode(CUINode* pParentNode) : CUINode(pParentNode)
{
}

LPCWSTR CDSUINode::GetDisplayString(int nCol, CDSColumnSet* pColumnSet)
{
  // if we are out of range for the column set, just return
  if ( (nCol < 0) || pColumnSet == NULL || (nCol >= pColumnSet->GetNumCols()) )
  {
    return L"";
  }

  // we have a valid range
  LPCWSTR lpszDisplayString = NULL;
  CDSColumn* pCol = (CDSColumn*)pColumnSet->GetColumnAt(nCol);
  ASSERT(pCol != NULL);

  switch ( pCol->GetColumnType())
  {
  case ATTR_COLTYPE_NAME:
    lpszDisplayString = const_cast<LPTSTR>(GetName());
    break;
  case ATTR_COLTYPE_CLASS:
    lpszDisplayString = const_cast<LPTSTR>(GetCookie()->GetLocalizedClassName());
    break;
  case ATTR_COLTYPE_DESC:
    lpszDisplayString = const_cast<LPTSTR>(GetDesc());
    break;
  default:
    ASSERT(FALSE);
    // fall through
  case ATTR_COLTYPE_SPECIAL:
  case ATTR_COLTYPE_MODIFIED_TIME:
    {
      // determine how many SPECIAL columns came before this one
      int nSpecialCol = 0;
      int idx = 0;
      POSITION pos = pColumnSet->GetHeadPosition();
      while (idx < nCol && pos != NULL)
      {
        CDSColumn* pColumn = (CDSColumn*)pColumnSet->GetNext(pos);
        ASSERT(pColumn != NULL);

        if ((pColumn->GetColumnType() == ATTR_COLTYPE_SPECIAL || pColumn->GetColumnType() == ATTR_COLTYPE_MODIFIED_TIME) &&
              pColumn->IsVisible())
        {
          nSpecialCol++;
        }
        idx++;
      }
      CStringList& strlist = GetCookie()->GetParentClassSpecificStrings();
      POSITION pos2 = strlist.FindIndex( nSpecialCol );
      if ( NULL != pos2 )
      {
        CString& strref = strlist.GetAt( pos2 );
        lpszDisplayString = const_cast<LPTSTR>((LPCTSTR)strref);
      }
      else
      {
        lpszDisplayString = L"";
      }
    }
  } // switch

  ASSERT(lpszDisplayString != NULL);
  return lpszDisplayString;
}

BOOL CDSUINode::IsDeleteAllowed(CDSComponentData*, BOOL* pbHide)
{
  int iSystemFlags = 0;
  CDSCookie* pCookie = NULL;

  ASSERT(IS_CLASS(*m_pNodeData, CDSCookie));
  pCookie = dynamic_cast<CDSCookie*>(m_pNodeData);
  
  if (pCookie == NULL)
  {
    ASSERT(FALSE);
    *pbHide = TRUE;
    return FALSE;
  }
  
  if (wcscmp(pCookie->GetClass(), L"domainDNS") == 0)
  {
    *pbHide = TRUE;
    return FALSE;
  }

  *pbHide = FALSE;
  iSystemFlags = pCookie->GetSystemFlags();
  if (iSystemFlags & FLAG_DISALLOW_DELETE) 
  {
    return FALSE;
  }
  return TRUE;
}

BOOL CDSUINode::IsRenameAllowed(CDSComponentData* pComponentData, BOOL* pbHide)
{
  int iSystemFlags = 0;
  CDSCookie* pCookie = NULL;

  ASSERT(IS_CLASS(*m_pNodeData, CDSCookie));
  pCookie = dynamic_cast<CDSCookie*>(m_pNodeData);
  
  if (pCookie == NULL)
  {
    ASSERT(FALSE);
    *pbHide = TRUE;
    return FALSE;
  }
 
  //
  // Disable rename for domainDNS and computer objects
  //
  if (wcscmp(pCookie->GetClass(), L"domainDNS") == 0 ||
      wcscmp(pCookie->GetClass(), L"computer") == 0)
  {
    *pbHide = TRUE;
    return FALSE;
  }

  BOOL bEnable = pComponentData->CanEnableVerb(this);
  SnapinType iSnapinType = pComponentData->QuerySnapinType();

  *pbHide = FALSE;
  iSystemFlags = pCookie->GetSystemFlags();

  switch (iSnapinType) 
  {
    case SNAPINTYPE_DS:
    case SNAPINTYPE_DSEX:
      if (iSystemFlags & FLAG_DOMAIN_DISALLOW_RENAME) 
      {
        return FALSE;
      }
      else
      {
        return bEnable;
      }
    case SNAPINTYPE_SITE:
      if (iSystemFlags & FLAG_CONFIG_ALLOW_RENAME) 
      {
        return bEnable;
      }
      else
      {
        return FALSE;
      }
    default:
      break;
  }
  return TRUE;
}

BOOL CDSUINode::IsRefreshAllowed(CDSComponentData* pComponentData, BOOL* pbHide)
{
  *pbHide = FALSE;
  return pComponentData->CanEnableVerb(this);
}

BOOL CDSUINode::ArePropertiesAllowed(CDSComponentData* pComponentData, BOOL* pbHide)
{
  CDSCookie* pCookie = NULL;

  ASSERT(IS_CLASS(*m_pNodeData, CDSCookie));
  pCookie = dynamic_cast<CDSCookie*>(m_pNodeData);
  
  if (pCookie == NULL)
  {
    ASSERT(FALSE);
    *pbHide = TRUE;
    return FALSE;
  }

  if (wcscmp(pCookie->GetClass(), L"domainDNS") == 0)
  {
    //
    // domain node, just show properties
    //
    *pbHide = FALSE;
    return pComponentData->CanEnableVerb(this);
  }
  *pbHide = FALSE;
  return TRUE;
}


BOOL CDSUINode::IsCutAllowed(CDSComponentData* pComponentData, BOOL* pbHide)
{
  //
  // For Sites and Services we only allow cut on server nodes
  //
  if (pComponentData->QuerySnapinType() == SNAPINTYPE_SITE)
  {
    CDSCookie* pCookie = dynamic_cast<CDSCookie*>(GetNodeData());
    if (pCookie)
    {
      if (_wcsicmp(pCookie->GetClass(), L"server") == 0)
      {
        *pbHide = FALSE;
        return TRUE;
      }
      
      *pbHide = TRUE;
      return FALSE;
    }
  }
  return IsDeleteAllowed(pComponentData, pbHide);
}


BOOL CDSUINode::IsCopyAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = TRUE;
  return FALSE; 
}


BOOL CDSUINode::IsPasteAllowed(CDSComponentData* pComponentData, BOOL* pbHide)
{
  //
  // For Sites and Services we only allow paste on serversContainers
  //
  if (pComponentData->QuerySnapinType() == SNAPINTYPE_SITE)
  {
    CDSCookie* pCookie = dynamic_cast<CDSCookie*>(GetNodeData());
    if (pCookie)
    {
      CString szClass;
      szClass = pCookie->GetClass();
      if (_wcsicmp(pCookie->GetClass(), L"serversContainer") == 0)
      {
        *pbHide = FALSE;
        return TRUE;
      }
      
      *pbHide = TRUE;
      return FALSE;
    }
  }
  *pbHide = FALSE;
  return TRUE;
}


CContextMenuVerbs* CDSUINode::GetContextMenuVerbsObject(CDSComponentData* pComponentData)
{ 
  if (m_pMenuVerbs == NULL)
  {
    if (pComponentData->QuerySnapinType() == SNAPINTYPE_SITE)
    {
      m_pMenuVerbs = new CSARContextMenuVerbs(pComponentData);
    }
    else
    {
      m_pMenuVerbs = new CDSAdminContextMenuVerbs(pComponentData);
    }
  }
  return m_pMenuVerbs;
}

BOOL CDSUINode::HasPropertyPages(LPDATAOBJECT)
{
  BOOL bRet = TRUE;

  if (dynamic_cast<CDSCookie*>(GetNodeData()) == NULL)
  {
    bRet = FALSE;
  }

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsfilter.cpp ===
//+-------------------------------------------------------------------------
//
//  Windows NT Directory Service Administration SnapIn
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      dsfilter.cpp
//
//  Contents:  DS App
//
//  History:   07-Oct-97  MarcoC
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"

#include "util.h"
#include "uiutil.h"

#include "dsfilter.h"

#include "dssnap.h"
#include "helpids.h"

#include "imm.h"  // To disable IME support for numeric edit boxes


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////
// constants and macros


// number of items per folder
#define DS_QUERY_OBJ_COUNT_MAX (999999999) // max value (max # expressed as 999... in DWORD)
#define DS_QUERY_OBJ_COUNT_MIN (1) // min value (min # expressed as 1 in DWORD)
#define DS_QUERY_OBJ_COUNT_DIGITS (9) // limit the edit box to the # of digits
#define DS_QUERY_OBJ_COUNT_DEFAULT 2000   // default value

// filtering options
#define QUERY_FILTER_SHOW_ALL		1
#define QUERY_FILTER_SHOW_BUILTIN	2
#define QUERY_FILTER_SHOW_CUSTOM	3
#define QUERY_FILTER_SHOW_EXTENSION	4


////////////////////////////////////////////////////////////////////////////
// structs and definitions for pre built queries
//


// generic filter tokens


// this gets users, excluding domain, wksta, server trust users
FilterTokenStruct g_usersToken = 
{
  TOKEN_TYPE_SCHEMA_FMT, 
  L"(& (objectCategory=CN=Person,%s)(objectSid=*) (!(samAccountType:1.2.840.113556.1.4.804:=3)) )"
};


// this gets universal, domain local, and domain global groups without regard to them being
// security enabled or not.
FilterTokenStruct g_groupsToken = 
{
  TOKEN_TYPE_SCHEMA_FMT,
  L"(& (objectCategory=CN=Group,%s) (groupType:1.2.840.113556.1.4.804:=14) )"
};

// this gets contacts
FilterTokenStruct g_contactsToken = 
{
  TOKEN_TYPE_SCHEMA_FMT,
  L"(& (objectCategory=CN=Person,%s) (!(objectSid=*)) )"
};


FilterTokenStruct g_ouToken                   = { TOKEN_TYPE_CATEGORY, L"Organizational-Unit"};
FilterTokenStruct g_builtinDomainToken        = { TOKEN_TYPE_CATEGORY, L"Builtin-Domain"};
FilterTokenStruct g_lostAndFoundToken         = { TOKEN_TYPE_CATEGORY, L"Lost-And-Found"};
FilterTokenStruct g_containerToken            = { TOKEN_TYPE_CLASS, L"container"};


FilterTokenStruct g_printQueueToken     = { TOKEN_TYPE_CATEGORY, L"Print-Queue"};
FilterTokenStruct g_volumeToken         = { TOKEN_TYPE_CATEGORY, L"Volume"};
FilterTokenStruct g_computerToken       = { TOKEN_TYPE_CATEGORY, L"Computer"};
FilterTokenStruct g_serAdminPointToken  = { TOKEN_TYPE_CATEGORY, L"Service-Administration-Point"};


FilterTokenStruct g_sitesContainerToken   = { TOKEN_TYPE_CATEGORY, L"Sites-Container"};
FilterTokenStruct g_siteToken             = { TOKEN_TYPE_CATEGORY, L"Site"};

FilterTokenStruct g_nTDSSiteSettingsToken = { TOKEN_TYPE_CATEGORY, L"NTDS-Site-Settings"};
FilterTokenStruct g_serversContainerToken = { TOKEN_TYPE_CATEGORY, L"Servers-Container"};
FilterTokenStruct g_serverToken           = { TOKEN_TYPE_CATEGORY, L"Server"};
FilterTokenStruct g_nTDSDSAToken          = { TOKEN_TYPE_CATEGORY, L"NTDS-DSA"};
FilterTokenStruct g_nTDSConnectionToken   = { TOKEN_TYPE_CATEGORY, L"NTDS-Connection"};
FilterTokenStruct g_subnetContainerToken  = { TOKEN_TYPE_CATEGORY, L"Subnet-Container"};
FilterTokenStruct g_subnetToken           = { TOKEN_TYPE_CATEGORY, L"Subnet"};

FilterTokenStruct g_interSiteTranToken    = { TOKEN_TYPE_CATEGORY, L"Inter-Site-Transport"};
FilterTokenStruct g_interSiteTranContToken= { TOKEN_TYPE_CATEGORY, L"Inter-Site-Transport-Container"};
FilterTokenStruct g_siteLinkToken         = { TOKEN_TYPE_CATEGORY, L"Site-Link"};
FilterTokenStruct g_siteLinkBridgeToken   = { TOKEN_TYPE_CATEGORY, L"Site-Link-Bridge"};

FilterTokenStruct g_nTFRSSettingsToken    = { TOKEN_TYPE_CATEGORY, L"NTFRS-Settings"};
FilterTokenStruct g_nTFRSReplicaSetToken  = { TOKEN_TYPE_CATEGORY, L"NTFRS-Replica-Set"};
FilterTokenStruct g_nTFRSMemberToken      = { TOKEN_TYPE_CATEGORY, L"NTFRS-Member"};


////////////////////////////////////////////////////////////////////////////
// Filter needed to drill down

FilterTokenStruct* g_DsAdminDrillDownTokens[4] = 
{
  &g_ouToken,
  &g_builtinDomainToken,
  &g_lostAndFoundToken,  
  &g_containerToken     
};


//
// Hardcoded filter element struct
// the dynamic one is a member of the CDSCache class
//
FilterElementStruct g_filterelementDsAdminHardcoded =
{
  0,
  4,
  g_DsAdminDrillDownTokens
};

FilterElementStruct g_filterelementSiteReplDrillDown =
{   
  0, // no string ID
  0, // NO items
  NULL
};


////////////////////////////////////////////////////////////////////////////
// data structures for DS Admin filtering

///////////////////////////////////////////////////////////
// users

FilterTokenStruct* g_userTokens[1] = 
{
  &g_usersToken,
};

FilterElementStruct g_filterelementUsers =
{   
  IDS_VIEW_FILTER_USERS,
  1,
  g_userTokens
};

///////////////////////////////////////////////////////////
// groups

FilterTokenStruct* g_groupsTokens[1] = 
{
  &g_groupsToken,
};

FilterElementStruct g_filterelementGroups =
{   
  IDS_VIEW_FILTER_GROUPS,
  1,
  g_groupsTokens
};

///////////////////////////////////////////////////////////
// contacts

FilterTokenStruct* g_contactsTokens[1] = 
{
  &g_contactsToken,
};

FilterElementStruct g_filterelementContacts =
{   
  IDS_VIEW_FILTER_CONTACTS,
  1,
  g_contactsTokens
};

////////////////////////////////////////////////////////////
// printers

FilterTokenStruct* g_printersTokens[1] =
{
  &g_printQueueToken,
};
 
FilterElementStruct g_filterelementPrinters =
{   
  IDS_VIEW_FILTER_PRINTERS,
  1,
  g_printersTokens
}; 

////////////////////////////////////////////////////////////
// volumes

FilterTokenStruct* g_volumesTokens[1] =
{
  &g_volumeToken,
};
 
FilterElementStruct g_filterelementVolumes =
{   
  IDS_VIEW_FILTER_SHARED_FOLDERS,
  1,
  g_volumesTokens
}; 

////////////////////////////////////////////////////////////
// computers

FilterTokenStruct* g_computersTokens[1] =
{
  &g_computerToken
};
 
FilterElementStruct g_filterelementComputers =
{   
  IDS_VIEW_FILTER_COMPUTERS,
  1,
  g_computersTokens
}; 

////////////////////////////////////////////////////////////
// services (admin. points)

FilterTokenStruct* g_servicesTokens[2] =
{
  &g_serAdminPointToken,
  &g_computerToken
};

FilterElementStruct g_filterelementServices =
{   IDS_VIEW_FILTER_SERVICES,
    2,
    g_servicesTokens
}; 

////////////////////////////////////////////////////////////

FilterElementStruct* DsAdminFilterElements[7] =
{
  &g_filterelementUsers,
  &g_filterelementGroups,
  &g_filterelementContacts,
  &g_filterelementComputers,
  &g_filterelementPrinters,
  &g_filterelementVolumes,
  &g_filterelementServices
};

FilterStruct DsAdminFilterStruct = {
    7,
    DsAdminFilterElements
};

////////////////////////////////////////////////////////////////////////////
// data structures for Site and Repl filtering

FilterTokenStruct* g_sitesTokens[9] =
{
  &g_sitesContainerToken,
  &g_siteToken,
  &g_nTDSSiteSettingsToken,
  &g_serversContainerToken,
  &g_serverToken,
  &g_nTDSDSAToken,
  &g_nTDSConnectionToken,
  &g_subnetContainerToken,
  &g_subnetToken
};

FilterElementStruct g_filterelementSites =
{   IDS_VIEW_FILTER_SITES,
    9, // size of g_sitesTokens
    g_sitesTokens
}; 

////////////////////////////////////////////////////////////

FilterTokenStruct* g_interSitesTokens[6] =
{
  &g_interSiteTranContToken,
  &g_interSiteTranToken,
  &g_siteLinkToken,       
  &g_siteLinkBridgeToken,
  &g_subnetContainerToken,
  &g_subnetToken
};

FilterElementStruct g_filterelementInterSite =
{   
  IDS_VIEW_FILTER_INTERSITE,
  6, // size of g_interSitesTokens
  g_interSitesTokens
};


////////////////////////////////////////////////////////////

FilterTokenStruct* g_FRSTokens[4] =
{
  &g_nTFRSSettingsToken,
  &g_nTFRSReplicaSetToken,
  &g_nTFRSMemberToken,    
  &g_nTDSConnectionToken 
};


FilterElementStruct g_filterelementFRS =
{   
  IDS_VIEW_FILTER_FRS,
  4, //size of g_FRSTokens
  g_FRSTokens
};

FilterElementStruct* SiteReplFilterElements[3] =
{
    &g_filterelementSites,
    &g_filterelementInterSite,
    &g_filterelementFRS
};

FilterStruct SiteReplFilterStruct = {
    3,
    SiteReplFilterElements
};

//////////////////////////////////////////////////////////////////////////
// helper functions

void BuildFilterTokenString(CString& sz,
                            FilterTokenStruct* pFilterTokenStruct,
                            LPCWSTR lpszSchemaPath)
{
  switch(pFilterTokenStruct->nType)
  {
  case TOKEN_TYPE_VERBATIM:
    {
      sz += pFilterTokenStruct->lpszString;
    }
    break;
  case TOKEN_TYPE_CLASS:
    {
      sz += L"(ObjectClass=";
      sz += pFilterTokenStruct->lpszString;
      sz += L")";
    }
    break;
  case TOKEN_TYPE_CATEGORY:
    {
      sz += L"(ObjectCategory=CN=";
      sz += pFilterTokenStruct->lpszString;
      sz += L",";
      sz += lpszSchemaPath;
      sz += L")";
    }
    break;
  case TOKEN_TYPE_SCHEMA_FMT:
    {
      int nBufLen = (lstrlen(lpszSchemaPath)+1) + 
                     (lstrlen(pFilterTokenStruct->lpszString)+1);
      WCHAR* pszBuf = new WCHAR[nBufLen];
      if (pszBuf)
      {
        wsprintf(pszBuf, pFilterTokenStruct->lpszString, lpszSchemaPath);
        sz += pszBuf;
        delete[] pszBuf;
        pszBuf = 0;
      }
    }
    break;
  };
}

void BuildFilterElementString(CString& sz,
                              FilterElementStruct* pFilterElementStruct,
                              LPCWSTR lpszSchemaPath)
{
  ASSERT( NULL != pFilterElementStruct );
	for (UINT i=0; i < pFilterElementStruct->cNumTokens; i++)
	{
    BuildFilterTokenString(sz, pFilterElementStruct->ppTokens[i], lpszSchemaPath);
	}
}


inline UINT GetNumElements( const FilterStruct* pfilterstruct )
{
    return pfilterstruct->cNumElements;
}
inline DWORD GetStringId( const FilterStruct* pfilterstruct, UINT iElement )
{
    ASSERT(iElement < GetNumElements(pfilterstruct) );
    return pfilterstruct->ppelements[iElement]->stringid;
}

// miscellanea query tokens
LPCWSTR g_pwszShowAllQuery = L"(objectClass=*)";

LPCWSTR g_pwszShowHiddenQuery = L"(!showInAdvancedViewOnly=TRUE)"; 

LPCWSTR g_pwszShowOUandContainerQuery = 
		L"(objectClass=organizationalUnit)(objectClass=container)";


//////////////////////////////////////////////////////////
// CBuiltInQuerySelection

class CBuiltInQuerySelection
{
public:
  CBuiltInQuerySelection()
  {
    m_bSelArr = NULL;
    m_pfilterstruct = NULL;
  }
  ~CBuiltInQuerySelection()
  {
    if (m_bSelArr != NULL)
      delete[] m_bSelArr;
  }
  BOOL Init(const FilterStruct* pfilterstruct)
  {
    ASSERT(pfilterstruct != NULL);
    m_pfilterstruct = pfilterstruct;
    if (m_pfilterstruct->cNumElements == 0)
      return FALSE;
    if( m_bSelArr )
      delete[] m_bSelArr;
    m_bSelArr = new BOOL[m_pfilterstruct->cNumElements];
    ZeroMemory(m_bSelArr, sizeof(BOOL)*m_pfilterstruct->cNumElements);
    return (m_bSelArr != NULL);
  }

  UINT GetCount() { ASSERT(m_pfilterstruct != NULL); return m_pfilterstruct->cNumElements;}
  void SetSel(UINT i, BOOL b) 
  {
    ASSERT(m_pfilterstruct != NULL);
    ASSERT(i < m_pfilterstruct->cNumElements);
    ASSERT(m_bSelArr != NULL);
    m_bSelArr[i] = b;
  }
  BOOL GetSel(UINT i)
  {
    ASSERT(m_pfilterstruct != NULL);
    ASSERT(i < m_pfilterstruct->cNumElements);
    ASSERT(m_bSelArr != NULL);
    return m_bSelArr[i];
  }

  UINT GetDisplayStringId(UINT i) { return ::GetStringId(m_pfilterstruct,i);}

  HRESULT Load(IStream* pStm)
  {
    ULONG nBytesRead;
	  // read the # of selected built in queries
	  DWORD dwSelCount = 0;
    UINT nSelCountMax = GetCount();
	  HRESULT hr = LoadDWordHelper(pStm, &dwSelCount);
	  if (FAILED(hr) || (dwSelCount > nSelCountMax))
		  return E_FAIL;

	  // read the selection #, if any
    _ResetSel();
	  if (dwSelCount > 0)
	  {
		  ULONG nByteCount = sizeof(DWORD)*dwSelCount;
		  DWORD* pSelArr = new DWORD[dwSelCount];
      if (!pSelArr)
      {
        return E_OUTOFMEMORY;
      }
		  hr = pStm->Read(pSelArr, nByteCount, &nBytesRead);
		  if (SUCCEEDED(hr))
      {
  		  if (nBytesRead < nByteCount)
        {
          hr = E_FAIL;
        }
        else
        {
		      for (UINT k=0; k< (UINT)dwSelCount; k++)
		      {
			      if (pSelArr[k] > nSelCountMax)
            {
              hr = E_FAIL;
              break;
            }
			      SetSel(pSelArr[k], TRUE);
		      }
        }
      }
      delete[] pSelArr;
      pSelArr = 0;
	  }
    return hr;
  }

  HRESULT Save(IStream* pStm)
  {
	  // save the # of selected built in queries
    ULONG nBytesWritten;
	  DWORD dwSelCount = 0;
    UINT nSelectedMax = GetCount();
	  for (UINT k = 0; k < nSelectedMax; k++)
		  if (m_bSelArr[k])
			  dwSelCount++;
	  ASSERT(dwSelCount <= nSelectedMax);
	  HRESULT hr = SaveDWordHelper(pStm, dwSelCount);
	  if (FAILED(hr))
		  return hr;

	  // save the selection #, if any
	  if (dwSelCount > 0)
	  {
		  ULONG nByteCount = sizeof(DWORD)*dwSelCount;
		  DWORD* pSelArr = new DWORD[dwSelCount];
      if (!pSelArr)
      {
        return E_OUTOFMEMORY;
      }

		  ULONG j= 0;
		  for (k=0; k< nSelectedMax; k++)
		  {
			  if (m_bSelArr[k])
			  {
				  ASSERT(j < dwSelCount);
				  pSelArr[j++] = k;
			  }
		  }
		  hr = pStm->Write((void*)pSelArr, nByteCount, &nBytesWritten);
		  if (SUCCEEDED(hr))
      {
  		  if (nBytesWritten < nByteCount)
        {
          hr = STG_E_CANTSAVE;
        }
      }
      delete[] pSelArr;
      pSelArr = 0;
	  }
    return hr;
  }

  BOOL BuildQueryString(CString& sz, LPCWSTR lpszSchemaPath)
  {
    ASSERT( NULL != lpszSchemaPath );
    sz.Empty();
		UINT i;
		UINT nSelCount = 0;
		for (i=0; i< GetCount(); i++)
		{
			if (m_bSelArr[i])
				nSelCount++;
		}
		ASSERT(nSelCount > 0);
		if (nSelCount > 0)
		{
			for (i=0; i < GetCount(); i++)
			{
				if (m_bSelArr[i])
        {
          BuildFilterElementString(sz, 
            m_pfilterstruct->ppelements[i],
            lpszSchemaPath);
        }
			}
		}
    return (nSelCount > 0);
  }

  BOOL IsServicesSelected()
  {
    // only for DS Admin
    if (m_pfilterstruct != &DsAdminFilterStruct)
      return FALSE;
    
    for (UINT k=0; k<GetCount(); k++)
    {
      if (m_pfilterstruct->ppelements[k] == &g_filterelementServices)
        return m_bSelArr[k];
    }
    return FALSE;
  }


private:
  BOOL* m_bSelArr;
  const FilterStruct* m_pfilterstruct;

  void _ResetSel()
  {
    ASSERT(m_bSelArr != NULL);
    ZeroMemory(m_bSelArr, sizeof(BOOL)*GetCount());
  }

};


//////////////////////////////////////////////////////////
// CBuiltInQueryCheckListBox

class CBuiltInQueryCheckListBox : public CCheckListBox
{
public:
	BOOL Initialize(UINT nCtrlID, CBuiltInQuerySelection* pQuerySel, CWnd* pParentWnd);

	void SetArrValue(CBuiltInQuerySelection* pQuerySel);
	void GetArrValue(CBuiltInQuerySelection* pQuerySel);

private:
	const FilterStruct* m_pfilterstruct;
};

BOOL CBuiltInQueryCheckListBox::Initialize(
		UINT nCtrlID, CBuiltInQuerySelection* pQuerySel, CWnd* pParentWnd)
{
	ASSERT( NULL != pQuerySel );
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (!SubclassDlgItem(nCtrlID, pParentWnd))
		return FALSE;
	SetCheckStyle(BS_AUTOCHECKBOX);
	CString szBuf;
  UINT nCount = pQuerySel->GetCount();
	for (UINT i = 0; i < nCount; i++)
	{
		if (!szBuf.LoadString(pQuerySel->GetDisplayStringId(i)) )
			return FALSE;
		AddString( szBuf );
	}

	return TRUE;
}

void CBuiltInQueryCheckListBox::SetArrValue(CBuiltInQuerySelection* pQuerySel)
{
  ASSERT( NULL != pQuerySel );
  UINT nCount = pQuerySel->GetCount();
	for (UINT i=0; i< nCount; i++)
		SetCheck(i, pQuerySel->GetSel(i));
}

void CBuiltInQueryCheckListBox::GetArrValue(CBuiltInQuerySelection* pQuerySel)
{
	ASSERT( NULL != pQuerySel );
  UINT nCount = pQuerySel->GetCount();
	for (UINT i=0; i< nCount; i++)
		pQuerySel->SetSel(i, GetCheck(i) != 0);
}



UINT _StrToUint(LPCWSTR sz)
{
	UINT n = 0;
	while  (*sz != NULL)
	{
		n = n*10 + (WCHAR)(*sz - TEXT('0') ); // assume it is a digit
		sz++;
	}
	return n;
}


/////////////////////////////////////////////////////////////////////
// CDSQueryFilterDialog

class CDSQueryFilterDialog : public CHelpDialog
{
// Construction
public:
	CDSQueryFilterDialog(CDSQueryFilter* pDSQueryFilter);

// Implementation
protected:

  // message handlers and MFC overrides
  virtual BOOL OnInitDialog();
  virtual void OnOK();
  
  afx_msg void OnChangeShowAllRadio();
  afx_msg void OnChangeShowBuiltInRadio();
  afx_msg void OnChangeShowCustomRadio();
  afx_msg void OnChangeQueryCheckList();
  afx_msg void OnListSelChange();
  afx_msg void OnEditCustomQuery();
  afx_msg void OnMaxObjectCountEditChange();
  
  virtual void DoContextHelp(HWND hWndControl);
  
  DECLARE_MESSAGE_MAP()

private:
	// internal state
	CDSQueryFilter* m_pDSQueryFilter;	// back pointer
	CBuiltInQueryCheckListBox	m_builtInQueryCheckList;

	BOOL m_bDirty;
  BOOL m_bOnItemChecked;
	UINT m_nCurrFilterOption;

	// internal helper functions
  CEdit* GetMaxCountEdit() { return (CEdit*)GetDlgItem(IDC_MAX_ITEM_COUNT_EDIT);}
	void LoadUI();
	void SaveUI();
	void SetDirty(BOOL bDirty = TRUE);
	void SyncControls(BOOL bDirty = TRUE);
};


BEGIN_MESSAGE_MAP(CDSQueryFilterDialog, CHelpDialog)
  ON_BN_CLICKED(IDC_SHOW_ALL_RADIO, OnChangeShowAllRadio)
  ON_BN_CLICKED(IDC_SHOW_BUILTIN_RADIO, OnChangeShowBuiltInRadio)
  ON_BN_CLICKED(IDC_SHOW_CUSTOM_RADIO, OnChangeShowCustomRadio)
  ON_CLBN_CHKCHANGE(IDC_BUILTIN_QUERY_CHECK_LIST, OnChangeQueryCheckList)	
  ON_LBN_SELCHANGE(IDC_BUILTIN_QUERY_CHECK_LIST, OnListSelChange)
  ON_BN_CLICKED(IDC_EDIT_CUSTOM_BUTTON, OnEditCustomQuery)
  ON_EN_CHANGE(IDC_MAX_ITEM_COUNT_EDIT, OnMaxObjectCountEditChange)
END_MESSAGE_MAP()

CDSQueryFilterDialog::CDSQueryFilterDialog(CDSQueryFilter* pDSQueryFilter)
	: CHelpDialog(IDD_QUERY_FILTER, NULL)
{
	ASSERT(pDSQueryFilter != NULL);
	m_pDSQueryFilter = pDSQueryFilter;
	m_bDirty = FALSE;
  m_bOnItemChecked = FALSE;
	m_nCurrFilterOption = QUERY_FILTER_SHOW_ALL;
}

BOOL CDSQueryFilterDialog::OnInitDialog()
{
	CHelpDialog::OnInitDialog();

	ASSERT( NULL != m_pDSQueryFilter && NULL != m_pDSQueryFilter->m_pDSComponentData );
	VERIFY(m_builtInQueryCheckList.Initialize(
		IDC_BUILTIN_QUERY_CHECK_LIST,
		m_pDSQueryFilter->m_pBuiltInQuerySel,
		this));

  // set number of digits in the edit control,
  // the number must be less than the # of digits in (DWORD)-1
  GetMaxCountEdit()->LimitText(DS_QUERY_OBJ_COUNT_DIGITS);

    // Disable IME support on the controls
  ImmAssociateContext(GetMaxCountEdit()->GetSafeHwnd(), NULL);

	LoadUI();
	return TRUE;
}


void CDSQueryFilterDialog::OnOK()
{
	ASSERT(m_bDirty); // if not, it should be disabled
	if (!m_bDirty)
		return;
	
	if  (m_nCurrFilterOption == QUERY_FILTER_SHOW_CUSTOM) {
          if ((m_pDSQueryFilter->IsAdvancedQueryDirty() &&
              (!m_pDSQueryFilter->HasValidAdvancedTempQuery())) ||
          
              ((!m_pDSQueryFilter->IsAdvancedQueryDirty() &&
                (!m_pDSQueryFilter->HasValidAdvancedQuery()))))
            {
              // warn the user: no query was specified
              ReportErrorEx (GetSafeHwnd(),IDS_VIEW_FILTER_NO_CUSTOM,S_OK,
                             MB_OK, NULL, 0);
              return;
            }
        }
          
	SaveUI();
	m_pDSQueryFilter->CommitAdvancedFilteringOptionsChanges();
	CHelpDialog::OnOK();
}

void CDSQueryFilterDialog::OnChangeQueryCheckList()
{ 
  m_bOnItemChecked = TRUE;
  SetDirty();
}

void CDSQueryFilterDialog::OnListSelChange()
{ 
  if (!m_bOnItemChecked)
  {
    int iCurSel = m_builtInQueryCheckList.GetCurSel();
    if (iCurSel != LB_ERR)
    {
      m_builtInQueryCheckList.SetCheck(iCurSel, !m_builtInQueryCheckList.GetCheck(iCurSel));
    }
  }
  m_bOnItemChecked = FALSE;
  SetDirty();
}

void CDSQueryFilterDialog::OnChangeShowAllRadio()
{
	m_nCurrFilterOption = QUERY_FILTER_SHOW_ALL;
	SyncControls();
}

void CDSQueryFilterDialog::OnChangeShowBuiltInRadio()
{
	m_nCurrFilterOption = QUERY_FILTER_SHOW_BUILTIN;
	SyncControls();
}

void CDSQueryFilterDialog::OnChangeShowCustomRadio()
{
	m_nCurrFilterOption = QUERY_FILTER_SHOW_CUSTOM;
	SyncControls();
}

void CDSQueryFilterDialog::OnEditCustomQuery()
{
	if (m_pDSQueryFilter->EditAdvancedFilteringOptions(m_hWnd))
  {
		SetDirty();
  }
  else
  {
    SetDirty(FALSE);
  }
}

void CDSQueryFilterDialog::LoadUI()
{
	m_nCurrFilterOption = m_pDSQueryFilter->m_nFilterOption;
	switch (m_nCurrFilterOption)
	{
		case QUERY_FILTER_SHOW_ALL:
			((CButton*)GetDlgItem(IDC_SHOW_ALL_RADIO))->SetCheck(TRUE);
			break;
		case QUERY_FILTER_SHOW_BUILTIN:
			((CButton*)GetDlgItem(IDC_SHOW_BUILTIN_RADIO))->SetCheck(TRUE);
			break;
		case QUERY_FILTER_SHOW_CUSTOM:
			((CButton*)GetDlgItem(IDC_SHOW_CUSTOM_RADIO))->SetCheck(TRUE);
			break;
		default:
			ASSERT(FALSE);
	}

	m_builtInQueryCheckList.SetArrValue(
			m_pDSQueryFilter->m_pBuiltInQuerySel);

  // set the max # of items
  if (m_pDSQueryFilter->m_nMaxItemCount > DS_QUERY_OBJ_COUNT_MAX)
    m_pDSQueryFilter->m_nMaxItemCount = DS_QUERY_OBJ_COUNT_MAX;

  if (m_pDSQueryFilter->m_nMaxItemCount < DS_QUERY_OBJ_COUNT_MIN)
    m_pDSQueryFilter->m_nMaxItemCount = DS_QUERY_OBJ_COUNT_MIN;

  CString s;
  s.Format(_T("%u"), m_pDSQueryFilter->m_nMaxItemCount);
  GetMaxCountEdit()->SetWindowText(s);

	SyncControls(FALSE);
}


void CDSQueryFilterDialog::OnMaxObjectCountEditChange()
{
  // get the max # of items
  CString s;
  GetMaxCountEdit()->GetWindowText(s);
  UINT nMax = _StrToUint(s);
  if (nMax < DS_QUERY_OBJ_COUNT_MIN)
  {
    nMax = DS_QUERY_OBJ_COUNT_MIN;
    s.Format(_T("%u"), nMax);
    GetMaxCountEdit()->SetWindowText(s);
  }
  SetDirty();
}

void CDSQueryFilterDialog::SaveUI()
{
	ASSERT(m_bDirty);
	m_builtInQueryCheckList.GetArrValue(
			m_pDSQueryFilter->m_pBuiltInQuerySel);

	ASSERT(m_nCurrFilterOption != 0);

	if (m_nCurrFilterOption == QUERY_FILTER_SHOW_BUILTIN)
	{
		// if the user selected built in, but no item is checked
		// revert to all
		UINT nSelCount = 0;
    UINT nCount = m_pDSQueryFilter->m_pBuiltInQuerySel->GetCount();
		for (UINT k = 0; k < nCount; k++)
		{
			if (m_pDSQueryFilter->m_pBuiltInQuerySel->GetSel(k))
				nSelCount++;
		}
		if (nSelCount == 0)
			m_nCurrFilterOption = QUERY_FILTER_SHOW_ALL;
	}
	m_pDSQueryFilter->m_nFilterOption = m_nCurrFilterOption;

  // to see services, need to see computers as containers
  // and be in adevanced view
  if ( (m_pDSQueryFilter->m_nFilterOption == QUERY_FILTER_SHOW_BUILTIN) &&
        (m_pDSQueryFilter->m_pBuiltInQuerySel->IsServicesSelected()) )
  {
    m_pDSQueryFilter->m_bExpandComputers = TRUE;
    m_pDSQueryFilter->m_bAdvancedView = TRUE;
  }

  // get the max # of items
  CString s;
  GetMaxCountEdit()->GetWindowText(s);
  m_pDSQueryFilter->m_nMaxItemCount = _StrToUint(s);
  if (m_pDSQueryFilter->m_nMaxItemCount < DS_QUERY_OBJ_COUNT_MIN)
  {
    m_pDSQueryFilter->m_nMaxItemCount = DS_QUERY_OBJ_COUNT_MIN;
    s.Format(_T("%u"), m_pDSQueryFilter->m_nMaxItemCount);
    GetMaxCountEdit()->SetWindowText(s);
  }
}

void CDSQueryFilterDialog::SetDirty(BOOL bDirty)
{
	GetDlgItem(IDOK)->EnableWindow(bDirty);
	m_bDirty = bDirty;
}

void CDSQueryFilterDialog::SyncControls(BOOL bDirty)
{
	GetDlgItem(IDC_BUILTIN_QUERY_CHECK_LIST)->EnableWindow(
		m_nCurrFilterOption == QUERY_FILTER_SHOW_BUILTIN);

	GetDlgItem(IDC_EDIT_CUSTOM_BUTTON)->EnableWindow(
		m_nCurrFilterOption == QUERY_FILTER_SHOW_CUSTOM);

	SetDirty(bDirty);
}

void CDSQueryFilterDialog::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_QUERY_FILTER); 
  }
}

/////////////////////////////////////////////////////////////////////
// 


HRESULT CEntryBase::Load(IStream* pStm, CEntryBase** ppNewEntry)
{
	ASSERT(pStm);
	ULONG nBytesRead;
	HRESULT hr;

	*ppNewEntry = NULL;

	// read type
	BYTE nType = ENTRY_TYPE_BASE;
	hr = pStm->Read((void*)&nType, sizeof(BYTE), &nBytesRead);
	if (FAILED(hr))
		return hr;
	if ((nBytesRead != sizeof(BYTE)) || (nType == ENTRY_TYPE_BASE))
		return E_FAIL;

	// create a new object
	switch (nType)
	{
	case ENTRY_TYPE_INT:
		*ppNewEntry = new CEntryInt;
		break;
	case ENTRY_TYPE_STRING:
		*ppNewEntry = new CEntryString;
		break;
	case ENTRY_TYPE_STRUCT:
		*ppNewEntry = new CEntryStruct;
		break;
	default:
		return E_FAIL; // unknown type
	}
	ASSERT(*ppNewEntry != NULL);
	if (*ppNewEntry == NULL)
		return E_OUTOFMEMORY;

	hr = (*ppNewEntry)->Load(pStm);
	if (FAILED(hr))
	{
		delete (*ppNewEntry);
		*ppNewEntry = NULL;
	}
	return hr;
}



/////////////////////////////////////////////////////////////////////
// CDSAdminPersistQueryFilterImpl

#define SIZEOF	sizeof

#define STRING_SIZE     TEXT("%sSize")
#define STRING_VALUE    TEXT("%sValue")
#define StringByteSize(sz)                          \
        ((lstrlen(sz)+1)*SIZEOF(TCHAR))




/*-----------------------------------------------------------------------------
/ IPersist methods
/----------------------------------------------------------------------------*/

STDMETHODIMP CDSAdminPersistQueryFilterImpl::GetClassID(THIS_ CLSID*)
{
    return E_NOTIMPL;
}


/*-----------------------------------------------------------------------------
/ IPersistQuery methods
/----------------------------------------------------------------------------*/

STDMETHODIMP CDSAdminPersistQueryFilterImpl::WriteString(LPCWSTR pSection, LPCWSTR pKey, LPCWSTR pValue)
{
    if ( !pSection || !pKey || !pValue )
		return E_INVALIDARG;

    TRACE(TEXT("CDSAdminPersistQueryFilterImpl::WriteString(pSection: %s, pKey: %s, pValue: %s)\n"), pSection, pKey, pValue);

	CEntryBase* pEntry;
	HRESULT hr = _GetWriteEntry(pSection, pKey, ENTRY_TYPE_STRING, &pEntry);
	if (FAILED(hr))
		return hr;

	m_bDirty = TRUE;
	return ((CEntryString*)pEntry)->WriteString(pValue);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDSAdminPersistQueryFilterImpl::ReadString(LPCWSTR pSection, LPCWSTR pKey, LPWSTR pBuffer, INT cchBuffer)
{
    if ( !pSection || !pKey || !pBuffer )
		return E_INVALIDARG;

    TRACE(TEXT("CDSAdminPersistQueryFilterImpl::ReadString(pSection: %s, pKey: %s)\n"), pSection, pKey);

	CEntryBase* pEntry;
	HRESULT hr = _GetReadEntry(pSection, pKey, ENTRY_TYPE_STRING, &pEntry);
	if (FAILED(hr))
		return hr;

	return ((CEntryString*)pEntry)->ReadString(pBuffer, cchBuffer);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDSAdminPersistQueryFilterImpl::WriteInt(LPCWSTR pSection, LPCWSTR pKey, INT value)
{
	if ( !pSection || !pKey )
        return E_INVALIDARG;

    TRACE(TEXT("CDSAdminPersistQueryFilterImpl::WriteInt(pSection: %s, pKey: %s, value: %d\n"), pSection, pKey, value);

	CEntryBase* pEntry;
	HRESULT hr = _GetWriteEntry(pSection, pKey, ENTRY_TYPE_INT, &pEntry);
	if (FAILED(hr))
		return hr;

	m_bDirty = TRUE;
	((CEntryInt*)pEntry)->SetInt(value);
	return S_OK;
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDSAdminPersistQueryFilterImpl::ReadInt(LPCWSTR pSection, LPCWSTR pKey, LPINT pValue)
{
    if ( !pSection || !pKey || !pValue )
        return E_INVALIDARG;

    TRACE(TEXT("CDSAdminPersistQueryFilterImpl::ReadInt(pSection: %s, pKey: %s\n"), pSection, pKey);

	CEntryBase* pEntry;
	HRESULT hr = _GetReadEntry(pSection, pKey, ENTRY_TYPE_INT, &pEntry);
	if (FAILED(hr))
		return hr;

	*pValue = ((CEntryInt*)pEntry)->GetInt();
	return S_OK;
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDSAdminPersistQueryFilterImpl::WriteStruct(LPCWSTR pSection, LPCWSTR pKey, 
														 LPVOID pStruct, DWORD cbStruct)
{
    if ( !pSection || !pKey || !pStruct )
        return E_INVALIDARG;

    TRACE(TEXT("CDSAdminPersistQueryFilterImpl::WriteStruct(pSection: %s, pKey: %s cbStruct: %d\n"), pSection, pKey, cbStruct);

	CEntryBase* pEntry;
	HRESULT hr = _GetWriteEntry(pSection, pKey, ENTRY_TYPE_STRUCT, &pEntry);
	if (FAILED(hr))
		return hr;

	m_bDirty = TRUE;
	return ((CEntryStruct*)pEntry)->WriteStruct(pStruct, cbStruct);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDSAdminPersistQueryFilterImpl::ReadStruct(LPCWSTR pSection, LPCWSTR pKey, LPVOID pStruct, DWORD cbStruct)
{
    if ( !pSection || !pKey || !pStruct )
        return E_INVALIDARG;

    TRACE(TEXT("CDSAdminPersistQueryFilterImpl::ReadStruct(pSection: %s, pKey: %s cbStruct: %d\n"), pSection, pKey, cbStruct);

    	CEntryBase* pEntry;
	HRESULT hr = _GetReadEntry(pSection, pKey, ENTRY_TYPE_STRUCT, &pEntry);
	if (FAILED(hr))
		return hr;

	return ((CEntryStruct*)pEntry)->ReadStruct(pStruct, cbStruct);
}

/*---------------------------------------------------------------------------*/

STDMETHODIMP CDSAdminPersistQueryFilterImpl::Clear()
{
	TRACE(TEXT("CDSAdminPersistQueryFilterImpl::Clear()\n"));
	m_bDirty = FALSE;
	_Reset();
	return S_OK;
}

/*---------------------------------------------------------------------------
CDSAdminPersistQueryFilterImpl internal functions
*/

void CDSAdminPersistQueryFilterImpl::_Reset()
{
	TRACE(_T("CDSAdminPersistQueryFilterImpl::_Reset()\n"));
	while (!m_sectionList.IsEmpty())
		delete m_sectionList.RemoveTail();
}

CSection* CDSAdminPersistQueryFilterImpl::_GetSection(LPCTSTR lpszName,BOOL bCreate)
{
	// look in the current list if we have one already
	for( POSITION pos = m_sectionList.GetHeadPosition(); pos != NULL; )
	{
		CSection* pCurrentSection = m_sectionList.GetNext(pos);
		if (lstrcmpi(pCurrentSection->GetName(), lpszName) == 0)
			return pCurrentSection;
	}
	if (!bCreate)
		return NULL;

	// not found, create one and add to the end of the list
	CSection* pNewSection = new CSection(lpszName);
	ASSERT(pNewSection != NULL);
	if (pNewSection != NULL)
		m_sectionList.AddTail(pNewSection);
	return pNewSection;
}


HRESULT CDSAdminPersistQueryFilterImpl::_GetReadEntry(LPCTSTR lpszSectionName, 
													  LPCTSTR lpszEntryName, 
													  BYTE type,
													  CEntryBase** ppEntry)
{
	*ppEntry = NULL;
	CSection* pSectionObj = _GetSection(lpszSectionName, FALSE /*bCreate*/);
	if (pSectionObj == NULL)
		return E_INVALIDARG;

	*ppEntry = pSectionObj->GetEntry(lpszEntryName, type, FALSE /*bCreate*/);
	if ((*ppEntry) == NULL)
		return E_INVALIDARG;
	return S_OK;
}

HRESULT CDSAdminPersistQueryFilterImpl::_GetWriteEntry(LPCTSTR lpszSectionName, 
													  LPCTSTR lpszEntryName, 
													  BYTE type,
													  CEntryBase** ppEntry)
{
	*ppEntry = NULL;
	CSection* pSectionObj = _GetSection(lpszSectionName, TRUE /*bCreate*/);
	if (pSectionObj == NULL)
		return E_OUTOFMEMORY;

	*ppEntry = pSectionObj->GetEntry(lpszEntryName, type, TRUE /*bCreate*/);
	if ((*ppEntry) == NULL)
		return E_OUTOFMEMORY;
	return S_OK;
}


HRESULT CDSAdminPersistQueryFilterImpl::Load(IStream* pStm)
{
	HRESULT hr;
	ULONG nBytesRead;
	
	// number of entries
	DWORD nEntries = 0;
	hr = pStm->Read((void*)&nEntries,sizeof(DWORD), &nBytesRead);
	ASSERT(nBytesRead == sizeof(DWORD));
	if (FAILED(hr) || (nEntries == 0) || (nBytesRead != sizeof(DWORD)))
		return hr;

	// read each entry
	for (DWORD k=0; k< nEntries; k++)
	{
		CSection* pNewSection = new CSection;
		if (pNewSection == NULL)
			return E_OUTOFMEMORY;
		hr = pNewSection->Load(pStm);
		if (FAILED(hr))
		{
			// on failure we cleanup the partial load
			delete pNewSection;
			_Reset();
			return hr;
		}
		m_sectionList.AddTail(pNewSection);
	}
	return hr;
}

HRESULT CDSAdminPersistQueryFilterImpl::Save(IStream* pStm)
{
	HRESULT hr;
	ULONG nBytesWritten;
	DWORD nEntries = (DWORD)m_sectionList.GetCount();

	hr = pStm->Write((void*)&nEntries,sizeof(DWORD), &nBytesWritten);
	ASSERT(nBytesWritten == sizeof(DWORD));
	if (FAILED(hr) || (nEntries == 0))
		return hr;

	// write each entry
	for( POSITION pos = m_sectionList.GetHeadPosition(); pos != NULL; )
	{
		CSection* pCurrentSection = m_sectionList.GetNext(pos);
		hr = pCurrentSection->Save(pStm);
		if (FAILED(hr))
			return hr;
	}
	return hr;
}

HRESULT CDSAdminPersistQueryFilterImpl::Clone(CDSAdminPersistQueryFilterImpl* pCloneCopy)
{
	if (pCloneCopy == NULL)
		return E_INVALIDARG;

	// create a temporary stream
	CComPtr<IStream> spIStream;
	HRESULT hr = ::CreateStreamOnHGlobal(NULL, TRUE, &spIStream);
	if (FAILED(hr))
		return hr;

	// save to it
	hr = Save(spIStream);
	if (FAILED(hr))
		return hr;

	// rewind
	LARGE_INTEGER start;
	start.LowPart = start.HighPart = 0;
	hr = spIStream->Seek(start, STREAM_SEEK_SET, NULL);
	if (FAILED(hr))
		return hr;

	// clear contents of destination
	hr = pCloneCopy->Clear();
	if (FAILED(hr))
		return hr;

	// copy from stream
	return pCloneCopy->Load(spIStream);
}

/////////////////////////////////////////////////////////////////////
// CDSAdvancedQueryFilter

class CDSAdvancedQueryFilter
{
public:
	CDSAdvancedQueryFilter();
	~CDSAdvancedQueryFilter();

	static CLIPFORMAT m_cfDsQueryParams;

	// serialization to/from IStream
	BOOL IsDirty();
	HRESULT Load(IStream* pStm);
	HRESULT Save(IStream* pStm);

	BOOL Edit(HWND hWnd, LPCWSTR lpszServerName);
	void CommitChanges();

	LPCTSTR GetQueryString() { return m_szQueryString;}
	BOOL HasTempQuery()
	{
		return ( (m_pTempPersistQueryImpl != NULL) &&
					!m_pTempPersistQueryImpl->IsEmpty());
	}
	BOOL HasQuery()
	{
		return ( (m_pPersistQueryImpl != NULL) &&
					!m_pPersistQueryImpl->IsEmpty());
	}

private:
	CString m_szQueryString;	// result filter string
	CComObject<CDSAdminPersistQueryFilterImpl>* 
		m_pPersistQueryImpl;	// for DSQuery dialog 

	BOOL m_bDirty;
	// temporary values to be committed when editing
	CString m_szTempQueryString;
	CComObject<CDSAdminPersistQueryFilterImpl>* 
		m_pTempPersistQueryImpl;
};

CDSAdvancedQueryFilter::CDSAdvancedQueryFilter()
{
	m_bDirty = FALSE;
	m_szQueryString = g_pwszShowAllQuery;

	CComObject<CDSAdminPersistQueryFilterImpl>::CreateInstance(
										&m_pPersistQueryImpl);
	ASSERT(m_pPersistQueryImpl != NULL);

	// created with zero refcount,need to AddRef() to one
	m_pPersistQueryImpl->AddRef();

	m_pTempPersistQueryImpl = NULL;
}

CDSAdvancedQueryFilter::~CDSAdvancedQueryFilter()
{
	ASSERT(m_pPersistQueryImpl != NULL);
	// go to refcount of zero, to destroy object
	m_pPersistQueryImpl->Release();

	if (m_pTempPersistQueryImpl != NULL)
		m_pTempPersistQueryImpl->Release();
}

HRESULT CDSAdvancedQueryFilter::Load(IStream* pStm)
{
	// load the query string
	HRESULT hr = LoadStringHelper(m_szQueryString, pStm);
	if (FAILED(hr))
		return hr;
	// load the IPersistQuery state
	hr = m_pPersistQueryImpl->Load(pStm);
	if (FAILED(hr))
		m_szQueryString = g_pwszShowAllQuery;
	return hr;
}

HRESULT CDSAdvancedQueryFilter::Save(IStream* pStm)
{
	// save the query string
	HRESULT hr = SaveStringHelper(m_szQueryString, pStm);
	if (FAILED(hr))
		return hr;
	// save the IPersistQuery state
	return m_pPersistQueryImpl->Save(pStm);
}

CLIPFORMAT CDSAdvancedQueryFilter::m_cfDsQueryParams = 0;

BOOL CDSAdvancedQueryFilter::Edit(HWND hWnd, LPCWSTR lpszServerName)
{
	if (m_cfDsQueryParams == 0)
		m_cfDsQueryParams = (CLIPFORMAT)::RegisterClipboardFormat(CFSTR_DSQUERYPARAMS);

	// create a query object
	HRESULT hr;
	CComPtr<ICommonQuery> spCommonQuery;
    hr = ::CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER,
                          IID_ICommonQuery, (PVOID *)&spCommonQuery);
    if (FAILED(hr))
		return FALSE;
	
	// if first time editing, create a clone of the IPersistQuery data
	if (m_pTempPersistQueryImpl == NULL)
	{
		CComObject<CDSAdminPersistQueryFilterImpl>::CreateInstance(
										&m_pTempPersistQueryImpl);
		ASSERT(m_pTempPersistQueryImpl != NULL);
		// created with zero refcount,need to AddRef() to one
		m_pTempPersistQueryImpl->AddRef();
		if (FAILED(m_pPersistQueryImpl->Clone(m_pTempPersistQueryImpl)))
			return FALSE;
	}

	// setup structs to make the query
  DSQUERYINITPARAMS dqip;
  OPENQUERYWINDOW oqw;
	ZeroMemory(&dqip, sizeof(DSQUERYINITPARAMS));
	ZeroMemory(&oqw, sizeof(OPENQUERYWINDOW));

  dqip.cbStruct = sizeof(dqip);
  dqip.dwFlags = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS |
                 DSQPF_ENABLEADMINFEATURES | DSQPF_HASCREDENTIALS;
  dqip.pDefaultScope = NULL;

  // user, password and server information
  dqip.pUserName = NULL;
  dqip.pPassword = NULL;
  dqip.pServer = const_cast<LPWSTR>(lpszServerName);
  dqip.dwFlags |= DSQPF_HASCREDENTIALS;


  oqw.cbStruct = sizeof(oqw);
  oqw.dwFlags = OQWF_OKCANCEL | OQWF_DEFAULTFORM | OQWF_REMOVEFORMS |
		OQWF_REMOVESCOPES | OQWF_SAVEQUERYONOK | OQWF_HIDEMENUS | OQWF_HIDESEARCHUI;

	if (!m_pTempPersistQueryImpl->IsEmpty())
	  oqw.dwFlags |= OQWF_LOADQUERY;

  oqw.clsidHandler = CLSID_DsQuery;
  oqw.pHandlerParameters = &dqip;
  oqw.clsidDefaultForm = CLSID_DsFindAdvanced;

	// set the IPersistQuery pointer (smart pointer)
	CComPtr<IPersistQuery> spIPersistQuery;
	m_pTempPersistQueryImpl->QueryInterface(IID_IPersistQuery, (void**)&spIPersistQuery);
	// now smart pointer has refcount=1 for it lifetime
	oqw.pPersistQuery = spIPersistQuery;

	// make the call to get the query displayed
	CComPtr<IDataObject> spQueryResultDataObject;
    hr = spCommonQuery->OpenQueryWindow(hWnd, &oqw, &spQueryResultDataObject);

	if (spQueryResultDataObject == NULL)
	{
		if (FAILED(hr))
		{
			// no query available, reset to no data
			m_pTempPersistQueryImpl->Clear();
			m_szTempQueryString = g_pwszShowAllQuery;
			m_bDirty = TRUE;

      //
      // Although it is dirty, we don't want to enable the OK button
      // until there is a valid LDAP query string
      //
			return FALSE;
		}
		// user hit cancel
		return FALSE;
	}

	// retrieve the query string from the data object
	FORMATETC fmte = {m_cfDsQueryParams, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};
	hr = spQueryResultDataObject->GetData(&fmte, &medium);

	if (SUCCEEDED(hr)) // we have data
	{
		// get the query string
		LPDSQUERYPARAMS pDsQueryParams = (LPDSQUERYPARAMS)medium.hGlobal;
		LPWSTR pwszFilter = (LPWSTR)ByteOffset(pDsQueryParams, pDsQueryParams->offsetQuery);
		m_szTempQueryString = pwszFilter;
		::ReleaseStgMedium(&medium);

		// REVIEW_MARCOC: this is a hack waiting for Diz to fix it...
		// the query string should be a well formed expression. Period
		// the query string is in the form (<foo>)(<bar>)...
		// if more of one token, need to wrap as (& (<foo>)(<bar>)...)
		WCHAR* pChar = (WCHAR*)(LPCWSTR)m_szTempQueryString;
		int nLeftPar = 0;
		while (*pChar != NULL)
		{
			if (*pChar == TEXT('('))
			{
				nLeftPar++;
				if (nLeftPar > 1)
					break;
			}
			pChar++;
		}
		if (nLeftPar > 1)
		{
			CString s;
			s.Format(_T("(&%s)"), (LPCTSTR)m_szTempQueryString);
			m_szTempQueryString = s;
		}
		TRACE(_T("m_szTempQueryString = %s\n"), (LPCTSTR)m_szTempQueryString);
		m_bDirty = TRUE;
	}
  else
  {
    m_szTempQueryString = g_pwszShowAllQuery;
    m_bDirty = TRUE;

    //
    // Although it is dirty, we don't want to enable the OK button
    // until there is a valid LDAP query string
    //
    return FALSE;
  }

	return m_bDirty;
}


void CDSAdvancedQueryFilter::CommitChanges()
{
	if (m_bDirty)
	{
		ASSERT(m_pPersistQueryImpl != NULL);
		ASSERT(m_pTempPersistQueryImpl != NULL);

		m_pPersistQueryImpl->Release();
		m_pPersistQueryImpl = m_pTempPersistQueryImpl;
		m_pTempPersistQueryImpl = NULL;

		m_szQueryString = m_szTempQueryString;
		m_bDirty = FALSE;
	}
}

BOOL CDSAdvancedQueryFilter::IsDirty()
{
  return m_bDirty;
}


/////////////////////////////////////////////////////////////////////
// CDSQueryFilter

CDSQueryFilter::CDSQueryFilter()
{
  // basic initialization, need to call Init() after construction
	m_pDSComponentData = NULL;

  m_pBuiltInQuerySel = new CBuiltInQuerySelection;
	m_pAdvancedFilter = new CDSAdvancedQueryFilter;


	// set default options and build query string
  m_bAdvancedView = FALSE;
  m_bExpandComputers = FALSE;
  m_bViewServicesNode = FALSE;

	m_nFilterOption = QUERY_FILTER_SHOW_ALL;
	m_szQueryString = g_pwszShowAllQuery;
  m_nMaxItemCount = DS_QUERY_OBJ_COUNT_DEFAULT;
}

HRESULT CDSQueryFilter::Init(CDSComponentData* pDSComponentData)
{
	ASSERT(pDSComponentData != NULL);
	m_pDSComponentData = pDSComponentData;

/*
  // make sure we have a schema naming context
  LPCWSTR lpszSchemaPath = pDSComponentData->GetBasePathsInfo()->GetSchemaNamingContext();
  if (lpszSchemaPath[0] == NULL)
    return E_FAIL;
*/
  const FilterStruct* pFilterStruct = 
    ((SNAPINTYPE_SITE == m_pDSComponentData->QuerySnapinType()) 
              ? &SiteReplFilterStruct : &DsAdminFilterStruct);
  if (!m_pBuiltInQuerySel->Init(pFilterStruct))
    return E_FAIL;

  //
  // If the snapin is DSSITE then make sure we are in advanced view
  //
  if (SNAPINTYPE_SITE == m_pDSComponentData->QuerySnapinType())
  {
     m_bAdvancedView = TRUE;
  }

  BuildQueryString();
  return S_OK;
}

HRESULT CDSQueryFilter::Bind()
{
  BuildQueryString();

  switch (m_pDSComponentData->QuerySnapinType())
  {
    case SNAPINTYPE_SITE:
      {
        // We are always in "Advanced View" mode for Site And Services Snapin
        if (!IsAdvancedView())
          ToggleAdvancedView();
      }
      break;
    case SNAPINTYPE_DSEX:
      {
        SetExtensionFilterString(g_pwszShowAllQuery);
      }
      break;
  }

  return S_OK;
}




CDSQueryFilter::~CDSQueryFilter()
{
	TRACE(_T("~CDSQueryFilter()\n"));
	delete m_pAdvancedFilter;
  delete m_pBuiltInQuerySel;
}

HRESULT CDSQueryFilter::Load(IStream* pStm)
{
	// serialization not supported for extensions
	if (m_nFilterOption == QUERY_FILTER_SHOW_EXTENSION)
		return E_FAIL;

  ASSERT(pStm);

	HRESULT hr;
	DWORD dwBuf;

  // read advanced view flag
  hr = LoadDWordHelper(pStm, (DWORD*)&m_bAdvancedView);
  if (FAILED(hr))
    return hr;

  //
  // If the snapin is DSSITE then make sure we are in advanced view
  //
  if (SNAPINTYPE_SITE == m_pDSComponentData->QuerySnapinType())
  {
     m_bAdvancedView = TRUE;
  }

  // read m_bExpandComputers
  DWORD dwTemp;
  hr = LoadDWordHelper(pStm, (DWORD*)&dwTemp);
  if (FAILED(hr))
    return hr;
  m_bExpandComputers  = (dwTemp & 0x1) ? TRUE : FALSE;
  m_bViewServicesNode = (dwTemp & 0x2) ? TRUE : FALSE;

	// read the filtering option
	hr = LoadDWordHelper(pStm, &dwBuf);
	if (FAILED(hr))
		return hr;
	if ( (dwBuf != QUERY_FILTER_SHOW_ALL) &&
			(dwBuf != QUERY_FILTER_SHOW_BUILTIN) &&
			(dwBuf != QUERY_FILTER_SHOW_CUSTOM) )
		return E_FAIL;
	m_nFilterOption = dwBuf;

  // read the max # of items per folder
	hr = LoadDWordHelper(pStm, (DWORD*)&m_nMaxItemCount);
	if (FAILED(hr))
		return hr;

  // load the state for the built in queries
  hr = m_pBuiltInQuerySel->Load(pStm);
	if (FAILED(hr))
		return E_FAIL;

	// read data for the advanced filtering options
	hr = m_pAdvancedFilter->Load(pStm);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
	{
		// advanced query options reset to empty
		// just pick the default tryng to recover
		m_nFilterOption = QUERY_FILTER_SHOW_ALL;
		hr = 0;
	}

	if (SUCCEEDED(hr))
		BuildQueryString();
	return hr;
}

HRESULT CDSQueryFilter::Save(IStream* pStm)
{
	// serialization not supported for extensions
	if (m_nFilterOption == QUERY_FILTER_SHOW_EXTENSION)
		return E_FAIL;

	HRESULT hr;

  // save advanced view flag
  hr = SaveDWordHelper(pStm, m_bAdvancedView);
  if (FAILED(hr))
    return hr;

  // save m_bExpandComputers
  DWORD dwTemp = (m_bExpandComputers ? 0x1 : 0) | (m_bViewServicesNode ? 0x2 : 0);
  hr = SaveDWordHelper(pStm, dwTemp);
  if (FAILED(hr))
    return hr;

	// save the filtering option
	hr = SaveDWordHelper(pStm, m_nFilterOption);
	if (FAILED(hr))
		return hr;

  // save the max # of items per folder
	hr = SaveDWordHelper(pStm, m_nMaxItemCount);
	if (FAILED(hr))
		return hr;

  // save the state for the built in queries
  hr = m_pBuiltInQuerySel->Save(pStm);
	if (FAILED(hr))
		return E_FAIL;

	// save data for the advanced filtering options
	return m_pAdvancedFilter->Save(pStm);
}

BOOL CDSQueryFilter::IsFilteringActive()
{
    return (m_nFilterOption != QUERY_FILTER_SHOW_ALL);
}

BOOL CDSQueryFilter::EditFilteringOptions()
{
	ASSERT( NULL != m_pDSComponentData );
	CDSQueryFilterDialog dlg(this);
	if (dlg.DoModal() == IDOK)
	{
		BuildQueryString();
		return TRUE; // dirty
	}
	return FALSE;
}

BOOL CDSQueryFilter::EditAdvancedFilteringOptions(HWND hWnd)
{
  LPCWSTR lpszServerName = m_pDSComponentData->GetBasePathsInfo()->GetServerName();
	return m_pAdvancedFilter->Edit(hWnd, lpszServerName);
}

void CDSQueryFilter::CommitAdvancedFilteringOptionsChanges()
{
	m_pAdvancedFilter->CommitChanges();
	// need to make sure there is an advanced query
	if ( (m_nFilterOption == QUERY_FILTER_SHOW_CUSTOM) &&
		 (!HasValidAdvancedQuery()) )
	{
		// revert to show all if no advanced query specified
		m_nFilterOption = QUERY_FILTER_SHOW_ALL;
	}
}

BOOL CDSQueryFilter::HasValidAdvancedQuery()
{
	return m_pAdvancedFilter->HasQuery();
}

BOOL CDSQueryFilter::HasValidAdvancedTempQuery()
{
	return m_pAdvancedFilter->HasTempQuery();
}

LPCTSTR CDSQueryFilter::GetQueryString()
{
	return m_szQueryString;
}


BOOL CDSQueryFilter::IsAdvancedQueryDirty()
{
	return m_pAdvancedFilter->IsDirty();
}

/*
void _CopyToClipboard(CString& sz)
{
  if (::OpenClipboard(NULL))
  {
    VERIFY(::EmptyClipboard());
    int nLen = sz.GetLength() + 1;
    if (nLen > 0)
    {
      DWORD dwSize = nLen * sizeof(WCHAR);
      HANDLE hMem = GlobalAlloc(GHND, dwSize);
      WCHAR* pBuf = (WCHAR*)GlobalLock(hMem);
      LPCWSTR lpsz = sz;
      memcpy(pBuf, lpsz, dwSize);
      GlobalUnlock(hMem);
      SetClipboardData(CF_UNICODETEXT, hMem);
    }
    VERIFY(::CloseClipboard());
  }
}
*/



void CDSQueryFilter::BuildQueryString()
{
	if (m_nFilterOption == QUERY_FILTER_SHOW_EXTENSION)
		return; // use raw query string 

	switch (m_nFilterOption)
	{
	case QUERY_FILTER_SHOW_ALL:
		m_szQueryString = g_pwszShowAllQuery;
		break;
	case QUERY_FILTER_SHOW_BUILTIN:
		{
      // assume we retrieve a string in the format "(<a>)(<b>)...(<z>)"
      if (!m_pBuiltInQuerySel->BuildQueryString(
                                m_szQueryString,
                                m_pDSComponentData->GetBasePathsInfo()->GetSchemaNamingContext()))
      {
        // should never happen, in this case just revert to show all
        ASSERT(FALSE);
        m_szQueryString = g_pwszShowAllQuery;
      }
		}
		break;
	case QUERY_FILTER_SHOW_CUSTOM:
		{
      // assume we retrieve a string in the format "(<foo>)"
      m_szQueryString = m_pAdvancedFilter->GetQueryString();
		}
		break;
	default:
		ASSERT(FALSE);
	}// switch


  // add token to drill down into containers
  if ( (m_nFilterOption == QUERY_FILTER_SHOW_BUILTIN) ||
       (m_nFilterOption == QUERY_FILTER_SHOW_CUSTOM))
  {
    FilterElementStruct* pFilterElementStructDrillDown = m_pDSComponentData->GetClassCache()->GetFilterElementStruct(m_pDSComponentData);

    if (pFilterElementStructDrillDown == NULL)
    {
      //
      // We failed to retrieve the container class types from the display specifiers
      // so use the hardcoded containers instead
      //
      pFilterElementStructDrillDown = &g_filterelementDsAdminHardcoded;
    }
    
    //
    // assume that the query string is in the form (<foo>)
    // we need to OR it with the drill down tokens, in the form (<bar>), if present
    CString szDrillDownString;
    BuildFilterElementString(szDrillDownString, pFilterElementStructDrillDown,
                               m_pDSComponentData->GetBasePathsInfo()->GetSchemaNamingContext());
    CString szTemp = m_szQueryString;
    m_szQueryString.Format(_T("(|%s%s)"), (LPCWSTR)szDrillDownString, (LPCWSTR)szTemp);
  }

	if (!m_bAdvancedView)
	{
		// need to AND the whole query with g_pwszShowHiddenQuery
		CString szTemp = m_szQueryString;
		m_szQueryString.Format(_T("(&%s%s)"), g_pwszShowHiddenQuery, (LPCTSTR)szTemp);
	}
  //_CopyToClipboard(m_szQueryString);
}

void CDSQueryFilter::SetExtensionFilterString(LPCTSTR lpsz)
{
	m_nFilterOption = QUERY_FILTER_SHOW_EXTENSION;
	m_szQueryString = lpsz;
}

void CDSQueryFilter::ToggleAdvancedView()
{
  m_bAdvancedView = !m_bAdvancedView;
  BuildQueryString();
}

void CDSQueryFilter::ToggleViewServicesNode()
{
  m_bViewServicesNode = !m_bViewServicesNode;
}

void CDSQueryFilter::ToggleExpandComputers()
{
  // if we were in expand computers and services was selected
  // need to revert to show all
  if (m_bExpandComputers && 
      (m_nFilterOption == QUERY_FILTER_SHOW_BUILTIN) && 
      m_pBuiltInQuerySel->IsServicesSelected() )
  {
    m_nFilterOption = QUERY_FILTER_SHOW_ALL;
  }

  // finally toggle the flag
  m_bExpandComputers = !m_bExpandComputers;

  BuildQueryString();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dssite.cpp ===
//+-------------------------------------------------------------------------
//
//  Windows NT Directory Service Administration SnapIn
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      dssite.cpp
//
//  Contents:  DS App
//
//  History:   04-nov-99 JeffJon  Created
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"

#include "dsutil.h"
#include "uiutil.h"

#include "dssnap.h"

#include "dscmn.h"
#include "ntdsapi.h"



#ifdef FIXUPDC
FixupOptionsMsg g_FixupOptionsMsg[NUM_FIXUP_OPTIONS] = {
  {DSROLE_DC_FIXUP_ACCOUNT, IDS_FIXUP_ACCOUNT, FALSE},
  {DSROLE_DC_FIXUP_ACCOUNT_PASSWORD, IDS_FIXUP_ACCOUNT_PASSWORD, TRUE},
  {DSROLE_DC_FIXUP_ACCOUNT_TYPE, IDS_FIXUP_ACCOUNT_TYPE, TRUE},
  {DSROLE_DC_FIXUP_TIME_SERVICE, IDS_FIXUP_TIME_SERVICE, FALSE},
  {DSROLE_DC_FIXUP_DC_SERVICES, IDS_FIXUP_DC_SERVICES, FALSE},
  {DSROLE_DC_FIXUP_FORCE_SYNC, IDS_FIXUP_FORCE_SYNC, TRUE}
};
#endif // FIXUPDC

#ifdef FIXUPDC

// put back in RESOURCE.H if/when this is restored
#define IDD_FIXUP_DC                    239
#define IDC_FIXUP_DC_SERVER             265
#define IDC_FIXUP_DC_CHECK0             266
#define IDC_FIXUP_DC_CHECK1             267
#define IDC_FIXUP_DC_CHECK2             268
#define IDC_FIXUP_DC_CHECK3             269
#define IDC_FIXUP_DC_CHECK4             270
#define IDC_FIXUP_DC_CHECK5             271
#define IDM_GEN_TASK_FIXUP_DC           720
#define IDS_FIXUP_ITSELF                721
#define IDS_FIXUP_REPORT_ERROR          722
#define IDS_FIXUP_REPORT_SUCCESS        723
#define IDS_FIXUP_GEN_ERROR             724
#define IDS_FIXUP_ACCOUNT               725
#define IDS_FIXUP_ACCOUNT_PASSWORD      726
#define IDS_FIXUP_ACCOUNT_TYPE          727
#define IDS_FIXUP_TIME_SERVICE          728
#define IDS_FIXUP_DC_SERVICES           729
#define IDS_FIXUP_FORCE_SYNC            730
#define IDS_FIXUP_DC_SELECTION_WARNING  732

// put back in DSSNAP.RC if/when this is restored
IDD_FIXUP_DC DIALOGEX 0, 0, 211, 163
STYLE DS_MODALFRAME | DS_CONTEXTHELP | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Repair Domain Controller"
FONT 8, "MS Shell Dlg", 0, 0, 0x1
BEGIN
    LTEXT           "Repair:",IDC_STATIC,12,14,33,8
    EDITTEXT        IDC_FIXUP_DC_SERVER,49,14,155,12,ES_AUTOHSCROLL | 
                    ES_READONLY | NOT WS_BORDER
    CONTROL         "Repair Computer &Account",IDC_FIXUP_DC_CHECK0,"Button",
                    BS_AUTOCHECKBOX | WS_TABSTOP,18,35,151,10
    CONTROL         "Repair Computer Account &Password",IDC_FIXUP_DC_CHECK1,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,18,48,151,10
    CONTROL         "Repair Computer Account &Type",IDC_FIXUP_DC_CHECK2,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,18,61,151,10
    CONTROL         "&Synchronize Time Service",IDC_FIXUP_DC_CHECK3,"Button",
                    BS_AUTOCHECKBOX | WS_TABSTOP,18,74,151,10
    CONTROL         "&Reset Active Directory Services",IDC_FIXUP_DC_CHECK4,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,18,87,151,10
    CONTROL         "Synchronize Active &Directory",IDC_FIXUP_DC_CHECK5,
                    "Button",BS_AUTOCHECKBOX | WS_TABSTOP,18,100,151,10
    DEFPUSHBUTTON   "&OK",IDOK,29,143,50,14
    PUSHBUTTON      "&Cancel",IDCANCEL,108,143,50,14
END
    IDM_GEN_TASK_FIXUP_DC   "Repair Domain Controller...\nRepair domain controller."
    IDS_FIXUP_ITSELF        "No other domain controllers in the domain can be contacted. Do you want to repair domain controller %1\nusing its local copy of the directory information?"
    IDS_FIXUP_REPORT_ERROR  "The following operations succeeded:\n%2\nAn error occurred during the following operation:\n%3\nError:%1"
    IDS_FIXUP_REPORT_SUCCESS "The following operations succeeded:\n%1"
    IDS_FIXUP_GEN_ERROR     "The repair of the domain controller was unsuccessful because:\n%1"
    IDS_FIXUP_ACCOUNT       "\n  Repair Computer Account."
    IDS_FIXUP_ACCOUNT_PASSWORD "\n  Repair Computer Account Password."
    IDS_FIXUP_ACCOUNT_TYPE  "\n  Repair Computer Account Type."
    IDS_FIXUP_TIME_SERVICE  "\n  Synchronize Time Service."
    IDS_FIXUP_DC_SERVICES   "\n  Reset Active Directory Services."
    IDS_FIXUP_FORCE_SYNC    "\n  Synchronize Active Directory."
    IDS_FIXUP_DC_SELECTION_WARNING "Make a selection."


HRESULT CDSComponentData::_FixupDC(LPCWSTR pwszPath)
/*++

Routine Description:

    This function calls DsRoleFixDc() API to ssync and fixup 
    local server against other DCs.

Arguments:

    pwszPath: The LDAP Path of the local "server" object. 
    We use this path to get the object, retrieve the server name
    and call the DsRoleFixDc() API. 

Return Value:

    HRESULT

    Report Error to user if any

--*/
{
  HRESULT hr = S_OK;
  CComPtr<IADs> spIADs;

  hr = DSAdminOpenObject(pwszPath, 
                         IID_IADs, 
                         (PVOID *)&spIADs,
                         TRUE /*bServer*/);

  if ( SUCCEEDED(hr) ) {
    //
    // retrieve the local server name
    //
    CComVariant var;
    hr = spIADs->Get(L"dNSHostName", &var);

    if ( SUCCEEDED(hr) )
    {
      ASSERT((var.vt == VT_BSTR) && var.bstrVal && *(var.bstrVal));
      LPWSTR lpszServer = var.bstrVal;

      CFixupDC dlgFixupDC;
      dlgFixupDC.m_strServer = lpszServer;
      if (IDCANCEL == dlgFixupDC.DoModal())
        goto cleanup; // user cancelled the fixup process

      CWaitCursor wait;
      DWORD dwReturn = 0;
      BOOL fLocal = FALSE;
      CString strAccount = _T(""), strPassword = _T("");
      DWORD dwOptions = 0;
      ULONG ulCompletedOps = 0, ulFailedOps = 0;

      for (int i=0; i<NUM_FIXUP_OPTIONS; i++) {
        if (dlgFixupDC.m_bCheck[i])
          dwOptions |= g_FixupOptionsMsg[i].dwOption;
      }

      //
      // call DsRoleFixDc() API to ssync and fixup the local server
      //
      do {
        dwReturn = DsRoleFixDc(
                        lpszServer,
                        (fLocal ? lpszServer : NULL), 
                        (strAccount.IsEmpty() ? NULL : (LPCWSTR)strAccount), 
                        (strAccount.IsEmpty() ? NULL : (LPCWSTR)strPassword),
                        dwOptions,
                        &ulCompletedOps,
                        &ulFailedOps
                        );

        if (ERROR_NO_SUCH_DOMAIN == dwReturn) {
          //
          // lpszServer is the only DC found in the domain,
          // ask if he wants to ssync and fixup the local server against itself
          //
          PVOID apv[1] = {(PVOID)lpszServer}; 
          if (IDNO == ReportMessageEx(m_hwnd, IDS_FIXUP_ITSELF, MB_YESNO | MB_ICONWARNING, apv, 1) )
            goto cleanup; // user cancelled the fixup process

          fLocal = TRUE;

        } else if (ERROR_ACCESS_DENIED == dwReturn) {
          //
          // connection failed
          // prompt for username and password
          //
          CPasswordDlg dlgPassword;
          if (IDCANCEL == dlgPassword.DoModal())
            goto cleanup; // user cancelled the fixup process

          strAccount = dlgPassword.m_strUserName;
          strPassword = dlgPassword.m_strPassword;

        } else {
          // either ERROR_SUCCESS or some other error happened
          break;
        }
      } while (TRUE);

      //
      // report succeeded/failed operations to user
      //
      CString strCompletedOps = _T(""), strFailedOps = _T("");
      CString strMsg;

      for (i=0; i<NUM_FIXUP_OPTIONS; i++) {
        if (ulCompletedOps & g_FixupOptionsMsg[i].dwOption) {
          strMsg.LoadString(g_FixupOptionsMsg[i].nMsgID);
          strCompletedOps += strMsg;
        }
        if (ulFailedOps & g_FixupOptionsMsg[i].dwOption) {
          strMsg.LoadString(g_FixupOptionsMsg[i].nMsgID);
          strFailedOps += strMsg;
        }
      }

      PVOID apv[2];
      apv[0] = (PVOID)(LPCWSTR)strCompletedOps;
      apv[1] = (PVOID)(LPCWSTR)strFailedOps;

      if (dwReturn != ERROR_SUCCESS) {
        ReportErrorEx(m_hwnd, IDS_FIXUP_REPORT_ERROR, dwReturn,
          MB_OK | MB_ICONINFORMATION, apv, 2, 0);
      } else {
        ReportMessageEx(m_hwnd, IDS_FIXUP_REPORT_SUCCESS,
          MB_OK | MB_ICONINFORMATION, apv, 1);
      }
    } // Get()
  } // DSAdminOpenObject()

  if (FAILED(hr))
    ReportErrorEx(m_hwnd, IDS_FIXUP_GEN_ERROR, hr, 
                  MB_OK | MB_ICONINFORMATION, NULL, 0, 0);

cleanup:

  return hr;
}
#endif // FIXUPDC

HRESULT CDSComponentData::_RunKCC(LPCWSTR pwszPath)
/*++

Routine Description:

    This function calls DsReplicaConsistencyCheck()
    to force the KCC to recheck topology immediately.

Arguments:

    pwszPath: The LDAP Path of the local "server" object. 
    We use this path to get the object, retrieve the server name
    and call the DsReplicaConsistencyCheck() API. 

Return Value:

    HRESULT

    Report Error to user if any

--*/
{
  HRESULT hr = S_OK;
  CComPtr<IADs> spIADs;
  BOOL fSyncing = FALSE;

  CWaitCursor cwait;
  CComVariant var;
  LPWSTR lpszRunKCCServer = NULL;

  do { // false loop

    // Bind to "server" object
    hr = DSAdminOpenObject(pwszPath,
                           IID_IADs,
                           (PVOID *)&spIADs,
                           TRUE /*bServer*/);
    if ( FAILED(hr) )
      break;

    // retrieve the local server name
    hr = spIADs->Get(L"dNSHostName", &var);
    if ( FAILED(hr) )
      break;
    if ((var.vt != VT_BSTR) || !(var.bstrVal) || !(*(var.bstrVal)))
    {
      ASSERT(FALSE);
      hr = E_FAIL;
      break;
    }
    lpszRunKCCServer = var.bstrVal;

    // now bind to the target DC
    Smart_DsHandle shDS;
    DWORD dwWinError = DsBind( lpszRunKCCServer, // DomainControllerAddress
                               NULL,             // DnsDomainName
                               &shDS );
    if (ERROR_SUCCESS != dwWinError)
    {
      hr = HRESULT_FROM_WIN32(dwWinError);
      break;
    }

    // Run the KCC synchronously on this DSA
    fSyncing = TRUE;
    dwWinError = DsReplicaConsistencyCheck(
          shDS,
          DS_KCC_TASKID_UPDATE_TOPOLOGY,
          0 ); // synchronous, not DS_KCC_FLAG_ASYNC_OP
    if (ERROR_SUCCESS != dwWinError)
    {
      hr = HRESULT_FROM_WIN32(dwWinError);
      break;
    }

  } while (FALSE); // false loop

  if (FAILED(hr))
  {
    (void) ReportErrorEx(   m_hwnd,
                            (fSyncing) ? IDS_RUN_KCC_1_FORCESYNC_ERROR
                                       : IDS_RUN_KCC_1_PARAMLOAD_ERROR,
                            hr,
                            MB_OK | MB_ICONEXCLAMATION,
                            NULL,
                            0,
                            IDS_RUN_KCC_TITLE );
  } else {
    // JonN 3/30/00
    // 26926: SITEREPL: Add popup after "Check Replication Topology" execution(DSLAB)
    LPCWSTR lpcwszDSADMINServer = NULL;
    if (NULL != GetBasePathsInfo())
    {
      lpcwszDSADMINServer = GetBasePathsInfo()->GetServerName();
      if ( !lpszRunKCCServer || !lpcwszDSADMINServer || !wcscmp( lpszRunKCCServer, lpcwszDSADMINServer ) )
        lpcwszDSADMINServer = NULL;
    }
    PVOID apv[2] = { (PVOID)lpszRunKCCServer, (PVOID)lpcwszDSADMINServer };
    (void) ReportMessageEx( m_hwnd,
                            (NULL == lpcwszDSADMINServer)
                                ? IDS_RUN_KCC_1_SUCCEEDED_LOCAL
                                : IDS_RUN_KCC_2_SUCCEEDED_REMOTE,
                            MB_OK | MB_ICONINFORMATION,
                            apv,
                            2,
                            IDS_RUN_KCC_TITLE );
  }

  return hr;
}

// JonN 7/23/99
// 373806: Site&Svcs:  Renaming an auto-generated connection should make it admin owned
// RETURN TRUE iff rename should proceed, handles own errors
BOOL CDSComponentData::RenameConnectionFixup(CDSCookie* pCookie)
{
  ASSERT( NULL != pCookie );

  CDSCookieInfoConnection* pextrainfo =
    (CDSCookieInfoConnection*)(pCookie->GetExtraInfo());
  if (   (NULL == pextrainfo)
      || (pextrainfo->GetClass() != CDSCookieInfoBase::connection)
      || pextrainfo->m_fFRSConnection
      || !(NTDSCONN_OPT_IS_GENERATED & pextrainfo->m_nOptions)
     )
    return TRUE;

  int nResponse = ReportMessageEx (m_hwnd, IDS_CONNECTION_RENAME_WARNING,
                                   MB_YESNO | MB_ICONWARNING);
  if (IDYES != nResponse)
    return FALSE;

  CString szPath;
  GetBasePathsInfo()->ComposeADsIPath(szPath, pCookie->GetPath());

  CComPtr<IDirectoryObject> spDO;

  HRESULT hr = S_OK;
  do { // false loop
    hr = DSAdminOpenObject(szPath,
                           IID_IDirectoryObject, 
                           (void **)&spDO,
                           TRUE /*bServer*/);
    if ( FAILED(hr) )
      break;

    PWSTR rgpwzAttrNames[] = {L"options"};
    Smart_PADS_ATTR_INFO spAttrs;
    DWORD cAttrs = 1;
    hr = spDO->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);
    if (FAILED(hr))
      break;
    if ( !(NTDSCONN_OPT_IS_GENERATED & spAttrs[0].pADsValues->Integer) )
      break;

    spAttrs[0].pADsValues->Integer &= ~NTDSCONN_OPT_IS_GENERATED;
    spAttrs[0].dwControlCode = ADS_ATTR_UPDATE;

    ULONG cModified = 0;
    hr = spDO->SetObjectAttributes (spAttrs, 1, &cModified);
  } while (false); // false loop

  if (FAILED(hr)) {
    ReportErrorEx (m_hwnd, IDS_CONNECTION_RENAME_ERROR, hr,
                   MB_OK|MB_ICONERROR, NULL, 0, 0, TRUE);
    return FALSE;
  }

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsdlgs.h ===
//+----------------------------------------------------------------------------
//
//  DS Administration MMC snapin.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSDlgs.h
//
//  Contents:  Definition for the DS Dialogs
//
//  History:   03-Oct-96 WayneSc    Created
//
//-----------------------------------------------------------------------------

#ifndef __DSDLGS_H__
#define __DSDLGS_H__

#include "dcbufmgr.h"
#include "uiutil.h"

HRESULT GetDnsNameOfDomainOrForest(
    IN CString&   csName,
    OUT CString&  csDnsName,
    IN BOOL       bIsInputADomainName,
    IN BOOL       bRequireDomain
);




//+----------------------------------------------------------------------------
//
//  Class:      CPropDlg
//
//  Purpose:    Display the properties of a DS object.
//
//-----------------------------------------------------------------------------
class CPropDlg
{
public:
    CPropDlg() {}
    ~CPropDlg() {}

    void SetTitle(CString* pstrTitle) {m_strTitle = *pstrTitle;}
    void SetTitle(LPTSTR szTitle) {m_strTitle = szTitle;}
    CString GetTitle(void) {return m_strTitle;}
    void SetUrl(CString* pstrUrl) {m_strUrl = *pstrUrl;}
    void SetUrl(LPTSTR szUrl) {m_strUrl = szUrl;}
    CString GetUrl(void) {return m_strUrl;}
    void DoModal(void) {CString strMsg = _T("The Url is ");
                        strMsg += m_strUrl;
                        MessageBox(NULL, strMsg, m_strTitle, MB_OK);}

private:
    CString m_strTitle;
    CString m_strUrl;
}; // CPropDlg

/////////////////////////////////////////////////////////////////////////////
class CChangePassword : public CHelpDialog
{
// Construction
public:
  CChangePassword(CWnd* pParent = NULL);   // standard constructor

  CString GetConfirm () { return m_ConfirmPwd;};
  CString GetNew () { return m_NewPwd;};
  BOOL GetChangePwd() { return m_ChangePwd; };
  void Clear();

  void AllowMustChangePasswordCheck(BOOL bAllowCheck) { m_bAllowMustChangePwdCheck = bAllowCheck; }

  // Dialog Data
  //{{AFX_DATA(CChangePassword)
  enum { IDD = IDD_CHANGE_PASSWORD };
  CString  m_ConfirmPwd;
  CString  m_NewPwd;
  BOOL          m_ChangePwd;
  //}}AFX_DATA
  

public:
  virtual BOOL OnInitDialog();
  virtual void DoContextHelp(HWND hWndControl);

  // Overrides
  // ClassWizard generated virtual function overrides
  //{{AFX_VIRTUAL(CChangePassword)
	protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
  
  // Implementation
protected:
  
  // Generated message map functions
  //{{AFX_MSG(CChangePassword)
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()

private:
  BOOL m_bAllowMustChangePwdCheck;
}; // CChangePassword


/////////////////////////////////////////////////////////////////////////////
// CChooseDomainDlg dialog
class CChooseDomainDlg : public CHelpDialog
{
// Construction
public:
  CChooseDomainDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
  //{{AFX_DATA(CChooseDomainDlg)
  enum { IDD = IDD_SELECT_DOMAIN };
  CString  m_csTargetDomain;
  BOOL m_bSaveCurrent;
  //}}AFX_DATA
  BOOL     m_bSiteRepl;

  virtual void DoContextHelp(HWND hWndControl);

// Overrides
  // ClassWizard generated virtual function overrides
  //{{AFX_VIRTUAL(CChooseDomainDlg)
  protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL

// Implementation
protected:

  // Generated message map functions
  //{{AFX_MSG(CChooseDomainDlg)
  afx_msg void OnSelectdomainBrowse();
  virtual void OnOK();
  virtual BOOL OnInitDialog();
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CChooseDCDlg dialog


class CSelectDCEdit : public CEdit
{
public:
  BOOL m_bHandleKillFocus;

  inline CSelectDCEdit() { m_bHandleKillFocus = FALSE; }

  afx_msg void OnKillFocus(CWnd* pNewWnd);

  DECLARE_MESSAGE_MAP()
};

class CChooseDCDlg : public CHelpDialog
{
// Construction
public:
  CChooseDCDlg(CWnd* pParent = NULL);   // standard constructor
  ~CChooseDCDlg();
  // Dialog Data
  //{{AFX_DATA(CChooseDCDlg)
  enum { IDD = IDD_SELECT_DC };
  CListCtrl  m_hDCListView;
  CString  m_csTargetDomainController;
  CString  m_csTargetDomain;
  //}}AFX_DATA

  CSelectDCEdit         m_selectDCEdit;

  BOOL                  m_bSiteRepl;
  CString               m_csPrevDomain;
  CDCBufferManager      *m_pDCBufferManager;
  CString               m_csAnyDC;
  CString               m_csWaiting;
  CString               m_csError;

  virtual void DoContextHelp(HWND hWndControl);

// Overrides
  // ClassWizard generated virtual function overrides
  //{{AFX_VIRTUAL(CChooseDCDlg)
protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL
  
  // Implementation
protected:
  void OnGetDCThreadDone(WPARAM wParam, LPARAM lParam);
  void InsertSpecialMsg(
      IN BOOL bWaiting
  );
  HRESULT InsertDCListView(
      IN CDCSITEINFO *pEntry
  );
  void RefreshDCListViewErrorReport(
      IN PCTSTR pszDomainName, 
      IN HRESULT hr
  );
  void RefreshDCListView();
  void FreeDCItems(CListCtrl& clv);

  // Generated message map functions
  //{{AFX_MSG(CChooseDCDlg)
  virtual BOOL OnInitDialog();
  afx_msg void OnItemchangedSelectdcDCListView(NMHDR* pNMHDR, LRESULT* pResult);
  afx_msg void OnKillfocusSelectdcDomain();
  virtual void OnOK();
  virtual void OnCancel();
  afx_msg void OnSelectdcBrowse();
  afx_msg void OnColumnclickSelectdcDCListView(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
  DECLARE_MESSAGE_MAP()
};



/////////////////////////////////////////////////////////////////////////
// CDsAdminChooseDCObj

class CDsAdminChooseDCObj:
  public IDsAdminChooseDC,
  public CComObjectRoot,
  public CComCoClass<CDsAdminChooseDCObj, &CLSID_DsAdminChooseDCObj>
{
public:
  BEGIN_COM_MAP(CDsAdminChooseDCObj)
    COM_INTERFACE_ENTRY(IDsAdminChooseDC)
  END_COM_MAP()

  DECLARE_REGISTRY_CLSID()
  CDsAdminChooseDCObj()
  {
  }
  ~CDsAdminChooseDCObj()
  {
  }

  // IDsAdminChooseDC
  STDMETHOD(InvokeDialog)(/*IN*/ HWND hwndParent,
                          /*IN*/ LPCWSTR lpszTargetDomain,
                          /*IN*/ LPCWSTR lpszTargetDomainController,
                          /*IN*/ ULONG uFlags,
                          /*OUT*/ BSTR* bstrSelectedDC);
};



/////////////////////////////////////////////////////////////////////////////
// CRenameUser dialog

class CRenameUserDlg : public CHelpDialog
{
// Construction
public:
  CRenameUserDlg(CDSComponentData* pComponentData, CWnd* pParent = NULL);   // standard constructor
  // Dialog Data
  //{{AFX_DATA(CRenameUserDlg)
  enum { IDD = IDD_RENAME_USER };
  CString       m_cn;
  CString       m_displayname;
  CString       m_oldcn;
  CString       m_login;
  CString       m_samaccountname;
  CString       m_domain;
  CString       m_dldomain;
  CStringList   m_domains;
  CString       m_first;
  CString       m_last;
  //}}AFX_DATA


// Overrides
  virtual void DoContextHelp(HWND hWndControl);
  afx_msg void OnObjectNameChange();
  afx_msg void OnNameChange();
  afx_msg void OnUserNameChange();

  // ClassWizard generated virtual function overrides
  //{{AFX_VIRTUAL(CRenameUserDlg)
protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL
  
  // Implementation
protected:
  CUserNameFormatter m_nameFormatter; // name ordering for given name and surname
  
  // Generated message map functions
  //{{AFX_MSG(CRenameUserDlg)
  virtual BOOL OnInitDialog();
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()

private:
  CDSComponentData* m_pComponentData;
};



/////////////////////////////////////////////////////////////////////////////
// CRenameGeneric dialog

class CRenameGenericDlg : public CHelpDialog
{
// Construction
public:
  CRenameGenericDlg(CWnd* pParent = NULL);   // standard constructor
  // Dialog Data
  //{{AFX_DATA(CRenameGenericDlg)
  enum { IDD = IDD_RENAME_GENERIC };
  CString  m_cn;
  //}}AFX_DATA


// Overrides
  virtual void DoContextHelp(HWND hWndControl);

  // ClassWizard generated virtual function overrides
  //{{AFX_VIRTUAL(CRenameGenericDlg)
protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL
  
  // Implementation
protected:
  
  // Generated message map functions
  //{{AFX_MSG(CRenameGenericDlg)
  virtual BOOL OnInitDialog();
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CRenameGroup dialog

class CRenameGroupDlg : public CHelpDialog
{
// Construction
public:
  CRenameGroupDlg(CWnd* pParent = NULL);   // standard constructor
  // Dialog Data
  //{{AFX_DATA(CRenameGroupDlg)
  enum { IDD = IDD_RENAME_GROUP };
  CString       m_samaccountname;
  CString       m_cn;
  UINT          m_samtextlimit;
  //}}AFX_DATA

// Overrides
  virtual void DoContextHelp(HWND hWndControl);

  // ClassWizard generated virtual function overrides
  //{{AFX_VIRTUAL(CRenameGroupDlg)
protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL
  
  // Implementation
protected:
  
  // Generated message map functions
  //{{AFX_MSG(CRenameGroupDlg)
  virtual BOOL OnInitDialog();
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CRenameContact dialog

class CRenameContactDlg : public CHelpDialog
{
// Construction
public:
  CRenameContactDlg(CWnd* pParent = NULL);   // standard constructor
  // Dialog Data
  //{{AFX_DATA(CRenameContactDlg)
  enum { IDD = IDD_RENAME_CONTACT };
  CString  m_cn;
  CString  m_first;
  CString  m_last;
  CString  m_disp;
  //}}AFX_DATA


// Overrides
  virtual void DoContextHelp(HWND hWndControl);

  // ClassWizard generated virtual function overrides
  //{{AFX_VIRTUAL(CRenameContactDlg)
protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL
  
  // Implementation
protected:
  
  // Generated message map functions
  //{{AFX_MSG(CRenameContactDlg)
  virtual BOOL OnInitDialog();
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CSpecialMessageBox dialog

class CSpecialMessageBox : public CDialog
{
// Construction
public:
  CSpecialMessageBox(CWnd* pParent = NULL);   // standard constructor
  // Dialog Data
  //{{AFX_DATA(CSpecialMessageBox)
  enum { IDD = IDD_MULTIPLE_ERROR };
  CString  m_title;
  CString       m_message;
  //}}AFX_DATA


// Overrides
  afx_msg void OnHelpInfo(HELPINFO* lpHelpInfo );

  // ClassWizard generated virtual function overrides
  //{{AFX_VIRTUAL(CSpecialMessageBox)
protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL
  
  // Implementation
protected:
  
  // Generated message map functions
  //{{AFX_MSG(CSpecialMessageBox)
  virtual BOOL OnInitDialog();
  afx_msg void OnYesButton();
  afx_msg void OnNoButton();
  afx_msg void OnYesToAllButton();
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()
};

#ifdef FIXUPDC
/////////////////////////////////////////////////////////////////////////////
// CFixupDC dialog

#define NUM_FIXUP_OPTIONS  6

typedef struct _FixupOptionsMsg {
  DWORD dwOption;
  int nMsgID;
  BOOL bDefaultOn;
} FixupOptionsMsg;

class CFixupDC : public CHelpDialog
{
// Construction
public:
  CFixupDC(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
  //{{AFX_DATA(CFixupDC)
  enum { IDD = IDD_FIXUP_DC };
  CString  m_strServer;
  //}}AFX_DATA

  BOOL  m_bCheck[NUM_FIXUP_OPTIONS];

// Overrides
  virtual void DoContextHelp(HWND hWndControl);

  // ClassWizard generated virtual function overrides
  //{{AFX_VIRTUAL(CFixupDC)
protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL

// Implementation
protected:

  // Generated message map functions
  //{{AFX_MSG(CFixupDC)
  virtual BOOL OnInitDialog();
  virtual void OnOK();
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()
};
#endif // FIXUPDC

/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog

class CPasswordDlg : public CHelpDialog
{
// Construction
public:
  CPasswordDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
  //{{AFX_DATA(CPasswordDlg)
  enum { IDD = IDD_PASSWORD };
  CString  m_strPassword;
  CString  m_strUserName;
  //}}AFX_DATA


// Overrides
  virtual void DoContextHelp(HWND hWndControl);

  // ClassWizard generated virtual function overrides
  //{{AFX_VIRTUAL(CPasswordDlg)
protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL

// Implementation
protected:

  // Generated message map functions
  //{{AFX_MSG(CPasswordDlg)
  virtual void OnOK();
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()
};

#endif //__DSDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsevent.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSObj.h
//
//  Contents:  Main DS Snapin file
//
//  History:   02-Oct-96 WayneSc    Created
//
//--------------------------------------------------------------------------

#ifndef __DSEVENT_H__
#define __DSEVENT_H__

class CDSCookie;
class CDSEvent;
class CInternalFormatCracker;

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))


#define dsNewUser 1100
#define dsNewGroup 1101
#define dsNewOU 1102
#define dsFind 1103
#define dsFilter 1104
#define dsAddMember 1105

/////////////////////////////////////////////////////////////////////////////
// CDSEvent

class CDSEvent : 
  public IComponent,
  public IExtendContextMenu,
  public IExtendControlbar,
  public IExtendPropertySheet,
  public IResultDataCompareEx,
  //public IExtendTaskPad,
  public CComObjectRoot,
  public CComCoClass<CDSEvent,&CLSID_DSSnapin>
{
public:
  CDSEvent();
  ~CDSEvent(); // Operators
public:

  BEGIN_COM_MAP(CDSEvent)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IResultDataCompareEx)
    //COM_INTERFACE_ENTRY(IExtendTaskPad)
  END_COM_MAP()
  //DECLARE_NOT_AGGREGATABLE(CDSEvent) 
  // Remove the comment from the line above if you don't want your object to 
  // support aggregation.  The default is to support it

  // INTERFACES
public:
  // IComponent
  STDMETHOD(Initialize)(IConsole* pFrame);
  STDMETHOD(Notify)(IDataObject * pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
  STDMETHOD(Destroy)(MMC_COOKIE cookie);
  STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
  STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, LPWSTR* ppViewType, long *pViewOptions);
  STDMETHOD(GetDisplayInfo)(LPRESULTDATAITEM pResult);
  STDMETHOD(CompareObjects) (IDataObject * pDataObject, IDataObject * pDataObject2);

  // IExtendContextMenu
  STDMETHOD(AddMenuItems)(IDataObject* piDataObject,
                          IContextMenuCallback* piCallback,
                          long *pInsertionAllowed);
  STDMETHOD(Command)(LONG lCommandID,
                     IDataObject* piDataObject );

  // IExtendControlbar
  STDMETHOD(SetControlbar) (LPCONTROLBAR pControlbar);
  STDMETHOD(ControlbarNotify) (MMC_NOTIFY_TYPE event,
                               LPARAM arg,
                               LPARAM param);
  STDMETHOD(ToolbarCreateObject) (CString csClass,
                                  LPDATAOBJECT lpDataObj);
  STDMETHOD(ToolbarFilter)();
  STDMETHOD (ToolbarFind)(LPDATAOBJECT lpDataObj);
  STDMETHOD (ToolbarAddMember) (LPDATAOBJECT lpDataObj);
  INT IsCreateAllowed(CString csClass,
                      CDSCookie * pContainer);
  STDMETHOD(LoadToolbarStrings) (MMCBUTTON * Buttons);

  // IExtendPropertySheet
  STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall,
                                 LONG_PTR lNotifyHandle, LPDATAOBJECT pDataObject);
  STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

  // IResultDataCompareEx
  STDMETHOD(Compare)(RDCOMPARE* prdc, int* pnResult);

  // Helpers for CDSEvent
  void SetIComponentData(CDSComponentData * pData);


  void SetUpdateAllViewsOrigin(BOOL b) { m_bUpdateAllViewsOrigin = b; }

  HRESULT SelectResultNode(CUINode* pUINode);

protected:
    
  // Initialisation routines for scope and result views
  HRESULT _SetColumns(CUINode* pUINode);
  HRESULT _InitView(CUINode* pUINode);

  // Enum routines for scope and result view
  HRESULT _ShowCookie(CUINode* pUINode, HSCOPEITEM hParent, MMC_NOTIFY_TYPE event);
  HRESULT _EnumerateCookie(CUINode* pUINode, HSCOPEITEM hParent, MMC_NOTIFY_TYPE event);

  // command helpers (called from Command())
  HRESULT _CommandShellExtension(long nCommandID, LPDATAOBJECT pDataObject);


  // other routines
  void    HandleStandardVerbs(BOOL bScope, BOOL bSelect, CUINode* pUINode);
  void    HandleViewChange(LPDATAOBJECT pDataObject,
                           LPARAM arg,
                           LPARAM Action);
  void    _Delete(IDataObject* pDataObject, CInternalFormatCracker* pObjCracker);
  void    _DeleteSingleSel(IDataObject* pDataObject, CUINode *pUINode);
  void    _DeleteMultipleSel(IDataObject* pDataObject, CInternalFormatCracker* pObjCracker);
  void    _DeleteNodeListFromUI(CUINodeList* pNodesDeletedList);

  // handlers for Cut/Copy/Paste operations
  HRESULT _QueryPaste(CUINode* pUINode, IDataObject* pPasteData);
  void    _Paste(CUINode* pUINode, IDataObject* pPasteData, LPDATAOBJECT* ppCutDataObj);
  void    _CutOrMove(IDataObject* pCutOrMoveData);

  void    _PasteDoMove(CDSUINode* pUINode, 
                        CObjectNamesFormatCracker* pObjectNamesFormatPaste, 
                        CInternalFormatCracker* pInternalFC,
                        LPDATAOBJECT* ppCutDataObj);
  void    _PasteAddToGroup(CDSUINode* pUINode, 
                           CObjectNamesFormatCracker* pObjectNamesFormatPaste,
                           LPDATAOBJECT* ppCutDataObj);

  // Utility routines
  HRESULT _AddResultItem(CUINode* pUINode, BOOL bSetSelected = FALSE);
  HRESULT _DisplayCachedNodes(CUINode* pUINode);
  void _UpdateObjectCount(BOOL fZero /* set the count to 0 */);

  
  //Attributes
protected:
  IConsole3*                  m_pFrame;
  IHeaderCtrl*                m_pHeader;
  IResultData2*               m_pResultData;
  IConsoleNameSpace*  	      m_pScopeData;
  IImageList*		              m_pRsltImageList;
  CDSComponentData*           m_pComponentData; // CODEWORK use smartpointer
  HWND                        m_hwnd;           // hwnd of main console window
  IConsoleVerb *              m_pConsoleVerb;
  IToolbar *                  m_pToolbar;
  IControlbar *               m_pControlbar;
  CLIPFORMAT                  m_cfNodeType;
  CLIPFORMAT                  m_cfNodeTypeString;  
  CLIPFORMAT                  m_cfDisplayName;

  CUINode*                    m_pSelectedFolderNode;
  BOOL                        m_UseSelectionParent;

  BOOL                        m_bUpdateAllViewsOrigin;
};
        
inline void CDSEvent::SetIComponentData(CDSComponentData * pData)
{
	if (NULL != m_pComponentData)
		((IComponentData*)m_pComponentData)->Release();

	m_pComponentData = pData;

	if (NULL != m_pComponentData)
		((IComponentData*)m_pComponentData)->AddRef();
}

// String comparison with respect to locale
int LocaleStrCmp(LPCTSTR ptsz1, LPCTSTR ptsz2);

#endif //__DSEVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsfilter.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dsfilter.h
//
//--------------------------------------------------------------------------

#ifndef __DSFILTER_H__
#define __DSFILTER_H__

#include "util.h"

#include <cmnquery.h> // IPersistQuery
#include <dsquery.h>

//////////////////////////////////////////////////////////////////

#define TOKEN_TYPE_VERBATIM     0
#define TOKEN_TYPE_CATEGORY     1
#define TOKEN_TYPE_CLASS        2
#define TOKEN_TYPE_SCHEMA_FMT   3

typedef struct _FilterTokenStruct {
    UINT nType;
    LPWSTR lpszString;
} FilterTokenStruct;

typedef struct _FilterElementStruct {
    DWORD stringid;
    UINT cNumTokens;
    FilterTokenStruct** ppTokens;
} FilterElementStruct;

typedef struct _FilterStruct {
    UINT cNumElements;
    FilterElementStruct** ppelements;
} FilterStruct;


//////////////////////////////////////////////////////////
// constants and macros

extern LPCWSTR g_pwszShowAllQuery;
extern LPCWSTR g_pwszShowHiddenQuery;
extern FilterElementStruct g_filterelementSiteReplDrillDown;
extern FilterElementStruct g_filterelementDsAdminHardcoded;

//////////////////////////////////////////////////////////
// global functions

HRESULT SaveDWordHelper(IStream* pStm, DWORD dw);
HRESULT LoadDWordHelper(IStream* pStm, DWORD* pdw);
void BuildFilterElementString(CString& sz,
                              FilterElementStruct* pFilterElementStruct,
                              LPCWSTR lpszSchemaPath);

//////////////////////////////////////////////////////////
// forward declarations

class CDSComponentData;
class CDSQueryFilterDialog;
class CBuiltInQuerySelection;
class CDSAdvancedQueryFilter;

/////////////////////////////////////////////////////////////////////
// CDSQueryFilter

class CDSQueryFilter
{
public:
	CDSQueryFilter();
	~CDSQueryFilter();

  HRESULT Init(CDSComponentData* pDSComponentData);
  HRESULT Bind();

	// serialization to/from IStream
	HRESULT Load(IStream* pStm);
	HRESULT Save(IStream* pStm);

  BOOL ExpandComputers() { return m_bExpandComputers;}
  BOOL IsAdvancedView() { return m_bAdvancedView;}
  BOOL ViewServicesNode() { return m_bViewServicesNode;}
  UINT GetMaxItemCount() { return m_nMaxItemCount;}
  void ToggleAdvancedView();
  void ToggleExpandComputers();
  void ToggleViewServicesNode();

	LPCTSTR GetQueryString();
  BOOL IsFilteringActive();
	BOOL EditFilteringOptions();
	void BuildQueryString();
	void SetExtensionFilterString(LPCTSTR lpsz);

private:
	CDSComponentData* m_pDSComponentData; // back pointer

  // filtering options not displayed in the dialog, always valid
  BOOL m_bExpandComputers;      // treat computers as containers?
  BOOL m_bAdvancedView;         // advanced view flag
  BOOL m_bViewServicesNode;     // view services node flag

	// query filter state variables
	CString m_szQueryString;	// result filter string

	BOOL	m_bShowHiddenItems;	// always valid
	UINT	m_nFilterOption;	// enum type for filtering type, always valid
  UINT m_nMaxItemCount;  // max # of items per folder query, always valid

  CBuiltInQuerySelection* m_pBuiltInQuerySel; // built in query sel info
	CDSAdvancedQueryFilter*	m_pAdvancedFilter;	// DSQuery dialog wrapper

	friend class CDSQueryFilterDialog;

	BOOL EditAdvancedFilteringOptions(HWND hWnd);
	void CommitAdvancedFilteringOptionsChanges();
	BOOL HasValidAdvancedQuery();
	BOOL HasValidAdvancedTempQuery();
	BOOL IsAdvancedQueryDirty();

};

///////////////////////////////////////////////////////////////////////////////
// CEntryBase
//
#define ENTRY_TYPE_BASE		0
#define ENTRY_TYPE_INT		1
#define ENTRY_TYPE_STRING	2
#define ENTRY_TYPE_STRUCT	3

class CEntryBase
{
public:
	CEntryBase(LPCTSTR lpszName = NULL)
	{ 
		m_type = ENTRY_TYPE_BASE;
		m_szName = lpszName;
	}
	virtual ~CEntryBase() 
	{
	};

	BYTE GetType() { return m_type;}
	LPCTSTR GetName() { return m_szName;}

	static HRESULT Load(IStream* pStm, CEntryBase** ppNewEntry);

	HRESULT virtual Load(IStream* pStm)
	{
		return LoadStringHelper(m_szName, pStm);
	}

	HRESULT virtual Save(IStream* pStm)
	{
	    ASSERT(pStm);
		ULONG nBytesWritten;
		HRESULT hr;

		// save type
		hr = pStm->Write((void*)&m_type, sizeof(BYTE), &nBytesWritten);
		if (FAILED(hr))
			return hr;
		if (nBytesWritten < sizeof(BYTE))
			return STG_E_CANTSAVE;

		// save name
		return SaveStringHelper(m_szName, pStm);
	}

protected:
	CString m_szName;
	BYTE m_type;
};




#define LOAD_BASE(pStm) \
	HRESULT hr = CEntryBase::Load(pStm); \
	if (FAILED(hr)) \
		return hr;

#define SAVE_BASE(pStm) \
	HRESULT hr = CEntryBase::Save(pStm); \
	if (FAILED(hr)) \
		return hr;

class CEntryInt : public CEntryBase
{
public:
	CEntryInt(LPCTSTR lpszName = NULL) : CEntryBase(lpszName) 
	{
		m_type = ENTRY_TYPE_INT;
	}
	virtual ~CEntryInt()
	{
	}
	HRESULT virtual Load(IStream* pStm)
	{
		LOAD_BASE(pStm);
		return LoadDWordHelper(pStm, (DWORD*)&m_nVal);
	}
	HRESULT virtual Save(IStream* pStm)
	{
		SAVE_BASE(pStm);
		return SaveDWordHelper(pStm, m_nVal);
	}

	void SetInt(int n) { m_nVal = n;}
	int GetInt() { return m_nVal;}
private:
	int m_nVal;
};

class CEntryString  : public CEntryBase
{
public:
	CEntryString(LPCTSTR lpszName = NULL) : CEntryBase(lpszName) 
	{ 
		m_type = ENTRY_TYPE_STRING; 
	}
	virtual ~CEntryString()
	{
	}
	HRESULT virtual Load(IStream* pStm)
	{
		LOAD_BASE(pStm);
		return LoadStringHelper(m_szString, pStm);
	}
	HRESULT virtual Save(IStream* pStm)
	{
		SAVE_BASE(pStm);
		return SaveStringHelper(m_szString, pStm);
	}
	HRESULT WriteString(LPCWSTR pValue) 
	{ 
		m_szString = pValue;
		return S_OK;
	}
	HRESULT ReadString(LPWSTR pBuffer, INT cchBuffer)
	{
		LPCWSTR lpsz = m_szString;
		int nLen = m_szString.GetLength()+1; // count NULL;
		if (cchBuffer < nLen)
		{
			// truncation
			memcpy(pBuffer, lpsz, (cchBuffer-1)*sizeof(WCHAR));
			pBuffer[cchBuffer-1] = NULL;
		}
		else
		{
			memcpy(pBuffer, lpsz, nLen*sizeof(WCHAR));
		}
		return S_OK;
	}

private:
	CString m_szString;
};

class CEntryStruct : public CEntryBase
{
public:
	CEntryStruct(LPCTSTR lpszName = NULL) : CEntryBase(lpszName) 
	{ 
		m_type = ENTRY_TYPE_STRUCT; 
		m_dwByteCount = 0;
		m_pBlob = NULL;
	}
	virtual ~CEntryStruct()
	{
		_Reset();
	}
	HRESULT virtual Load(IStream* pStm)
	{
		LOAD_BASE(pStm);
		_Reset();
		ULONG nBytesRead;

		hr = pStm->Read((void*)&m_dwByteCount,sizeof(DWORD), &nBytesRead);
		ASSERT(nBytesRead == sizeof(DWORD));
		if (FAILED(hr) || (nBytesRead != sizeof(DWORD)))
			return hr;
		if (m_dwByteCount == 0)
			return S_OK;

		m_pBlob = malloc(m_dwByteCount);
		if (m_pBlob == NULL)
		{
			m_dwByteCount = 0;
			return E_OUTOFMEMORY;
		}

		hr = pStm->Read(m_pBlob,m_dwByteCount, &nBytesRead);
		ASSERT(nBytesRead == m_dwByteCount);
		if (FAILED(hr) || (nBytesRead != m_dwByteCount))
		{
			free(m_pBlob);
			m_pBlob = NULL;
			m_dwByteCount = 0;
		}
		return hr;
	}
	HRESULT virtual Save(IStream* pStm)
	{
		SAVE_BASE(pStm);
		ULONG nBytesWritten;
		hr = pStm->Write((void*)&m_dwByteCount, sizeof(DWORD),&nBytesWritten);
		ASSERT(nBytesWritten == sizeof(DWORD));
		if (FAILED(hr))
			return hr;

		hr = pStm->Write(m_pBlob, m_dwByteCount, &nBytesWritten);
		ASSERT(nBytesWritten == m_dwByteCount);
		return hr;
	}

	HRESULT WriteStruct(LPVOID pStruct, DWORD cbStruct)
	{
		_Reset();
		if (cbStruct == 0)
			return S_OK;
		m_pBlob = malloc(cbStruct);
		if (m_pBlob == NULL)
			return E_OUTOFMEMORY;
		m_dwByteCount = cbStruct;
		memcpy(m_pBlob, pStruct, cbStruct);
		return S_OK;
	}
	HRESULT ReadStruct(LPVOID pStruct, DWORD cbStruct)
	{
		DWORD cbCopy = m_dwByteCount;
		if (cbStruct < m_dwByteCount)
			cbCopy = cbStruct;
		if (cbCopy == 0)
			return S_OK;
		if (m_pBlob == NULL)
			return E_FAIL;
		memcpy(pStruct, m_pBlob, cbCopy);
		return S_OK;
	}

private:
	DWORD m_dwByteCount;
	void* m_pBlob;

	void _Reset()
	{
		if (m_pBlob != NULL)
		{
			free(m_pBlob);
			m_pBlob = NULL;
		}
		m_dwByteCount = 0;
	}
};

///////////////////////////////////////////////////////////////////////////////
// CSection
//
class CSection
{
public:
	CSection(LPCTSTR lpszName = NULL)
	{
		m_szName = lpszName;
	}
	~CSection()
	{
		while (!m_pEntryList.IsEmpty())
			delete m_pEntryList.RemoveTail();
	}

	LPCTSTR GetName() { return m_szName;}

	HRESULT Load(IStream* pStm)
	{
		// name
		HRESULT hr = LoadStringHelper(m_szName, pStm);
		if (FAILED(hr))
			return hr;
		
		// number of entries
		ULONG nBytesRead;
		DWORD nEntries = 0;

		hr = pStm->Read((void*)&nEntries,sizeof(DWORD), &nBytesRead);
		ASSERT(nBytesRead == sizeof(DWORD));
		if (FAILED(hr) || (nEntries == 0) || (nBytesRead != sizeof(DWORD)))
			return hr;

		// read each entry
		for (DWORD k=0; k< nEntries; k++)
		{
			CEntryBase* pNewEntry;
			hr = CEntryBase::Load(pStm, &pNewEntry);
			if (FAILED(hr))
				return hr;
			ASSERT(pNewEntry != NULL);
			m_pEntryList.AddTail(pNewEntry);
		}
		return hr;
	}

	HRESULT Save(IStream* pStm)
	{
		// name
		HRESULT hr = SaveStringHelper(m_szName, pStm);
		if (FAILED(hr))
			return hr;
		// number of entries
		ULONG nBytesWritten;
		DWORD nEntries = (DWORD)m_pEntryList.GetCount();

		hr = pStm->Write((void*)&nEntries,sizeof(DWORD), &nBytesWritten);
		ASSERT(nBytesWritten == sizeof(DWORD));
		if (FAILED(hr) || (nEntries == 0))
			return hr;

		// write each entry
		for( POSITION pos = m_pEntryList.GetHeadPosition(); pos != NULL; )
		{
			CEntryBase* pCurrentEntry = m_pEntryList.GetNext(pos);
			hr = pCurrentEntry->Save(pStm);
			if (FAILED(hr))
				return hr;
		}
		return hr;
	}

	CEntryBase* GetEntry(LPCTSTR lpszName, BYTE nType, BOOL bCreate)
	{
		// look in the current list if we have one already
		for( POSITION pos = m_pEntryList.GetHeadPosition(); pos != NULL; )
		{
			CEntryBase* pCurrentEntry = m_pEntryList.GetNext(pos);
			if ( (pCurrentEntry->GetType() == nType) && 
					(lstrcmpi(pCurrentEntry->GetName(), lpszName) == 0) )
			{
				return pCurrentEntry;
			}
		}
		if (!bCreate)
			return NULL;

		// not found, create one and add to the end of the list
		CEntryBase* pNewEntry = NULL;
		switch (nType)
		{
		case ENTRY_TYPE_INT:
			pNewEntry = new CEntryInt(lpszName);
			break;
		case ENTRY_TYPE_STRING:
			pNewEntry = new CEntryString(lpszName);
			break;
		case ENTRY_TYPE_STRUCT:
			pNewEntry = new CEntryStruct(lpszName);
			break;
		}
		ASSERT(pNewEntry != NULL);
		if (pNewEntry != NULL)
			m_pEntryList.AddTail(pNewEntry);
		return pNewEntry;
	}
private:
	CString m_szName;
	CList<CEntryBase*,CEntryBase*> m_pEntryList;
};

///////////////////////////////////////////////////////////////////////////////
// CDSAdminPersistQueryFilterImpl
//
class CDSAdminPersistQueryFilterImpl : 
		public IPersistQuery, public CComObjectRoot 
{
// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDSAdminPersistQueryFilterImpl)
BEGIN_COM_MAP(CDSAdminPersistQueryFilterImpl)
	COM_INTERFACE_ENTRY(IPersistQuery)
END_COM_MAP()

// Construction/Destruction
	CDSAdminPersistQueryFilterImpl()
	{
		m_bDirty = FALSE;
	}
	~CDSAdminPersistQueryFilterImpl()
	{
		_Reset();
	}

// IPersistQuery methods
public:
    // IPersist
    STDMETHOD(GetClassID)(CLSID* pClassID);

    // IPersistQuery
    STDMETHOD(WriteString)(LPCWSTR pSection, LPCWSTR pValueName, LPCWSTR pValue);
    STDMETHOD(ReadString)(LPCWSTR pSection, LPCWSTR pValueName, LPTSTR pBuffer, INT cchBuffer);
    STDMETHOD(WriteInt)(LPCWSTR pSection, LPCWSTR pValueName, INT value);
    STDMETHOD(ReadInt)(LPCWSTR pSection, LPCWSTR pValueName, LPINT pValue);
    STDMETHOD(WriteStruct)(LPCWSTR pSection, LPCWSTR pValueName, LPVOID pStruct, DWORD cbStruct);
    STDMETHOD(ReadStruct)(LPCWSTR pSection, LPCWSTR pValueName, LPVOID pStruct, DWORD cbStruct);
	STDMETHOD(Clear)();

public:
	// serialization to/from MMC stream
	HRESULT Load(IStream* pStm);
	HRESULT Save(IStream* pStm);

	// miscellanea
	BOOL IsEmpty()
	{
		return m_sectionList.IsEmpty();
	}

	HRESULT Clone(CDSAdminPersistQueryFilterImpl* pCloneCopy);

private:
	BOOL m_bDirty;
	CList<CSection*, CSection*> m_sectionList;

	void _Reset();
	CSection* _GetSection(LPCTSTR lpszName,BOOL bCreate);
	CEntryBase* _GetEntry(LPCTSTR lpszSectionName, LPCTSTR lpszEntryName, BOOL bCreate);
	HRESULT _GetReadEntry(LPCTSTR lpszSectionName, LPCTSTR lpszEntryName, 
							BYTE type, CEntryBase** ppEntry);
	HRESULT _GetWriteEntry(LPCTSTR lpszSectionName, LPCTSTR lpszEntryName, 
							BYTE type, CEntryBase** ppEntry);

};

#endif // __DSFILTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dssnap.cpp ===
//+-------------------------------------------------------------------------
//
//  Windows NT Directory Service Administration SnapIn
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      dssnap.cpp
//
//  Contents:  DS App
//
//  History:   02-Oct-96 WayneSc    Created
//             06-Mar-97 EricB - added Property Page Extension support
//             24-Jul-97 Dan Morin - Integrated "Generic Create" wizard
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"

#include "util.h"
#include "uiutil.h"
#include "dsutil.h"

#include "dssnap.h"

#include "ContextMenu.h"
#include "DataObj.h"
#include "dsctx.h"
#include "DSdirect.h"
#include "dsdlgs.h"
#include "DSEvent.h" 
#include "dsfilter.h"
#include "dsthread.h"
#include "fsmoui.h"
#include "helpids.h"
#include "newobj.h"		// CNewADsObjectCreateInfo
#include "query.h"
#include "queryui.h"
#include "querysup.h"
#include "rename.h"

#include <notify.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define STRING_LEN (32 * sizeof(OLECHAR))


extern LPWSTR g_lpszLoggedInUser;

#define INITGUID
#include <initguid.h>
#include <dsadminp.h>

const wchar_t* SNAPIN_INTERNAL = L"DS_ADMIN_INTERNAL";

// Define the profiling statics
IMPLEMENT_PROFILING;

//////////////////////////////////////////////////////////////////////////////////
// standard attributes array (for queries)

const INT g_nStdCols = 8; 
const LPWSTR g_pStandardAttributes[g_nStdCols] = {L"ADsPath",
                                                  L"name",
                                                  L"displayName",
                                                  L"objectClass",
                                                  L"groupType",
                                                  L"description",
                                                  L"userAccountControl",
                                                  L"systemFlags"};

extern const INT g_nADsPath = 0;
extern const INT g_nName = 1;
extern const INT g_nDisplayName = 2;
extern const INT g_nObjectClass = 3;
extern const INT g_nGroupType = 4;
extern const INT g_nDescription = 5;
extern const INT g_nUserAccountControl = 6;
extern const INT g_nSystemFlags = 7;


///////////////////////////////////////////////////////////////////////////////////


HRESULT WINAPI CDsAdminModule::UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister)
{
	static const WCHAR szIPS32[] = _T("InprocServer32");
	static const WCHAR szCLSID[] = _T("CLSID");
  static const WCHAR szThreadingModel[] = _T("ThreadingModel");
  static const WCHAR szThreadModelValue[] = _T("Both");

	HRESULT hRes = S_OK;

	LPOLESTR lpOleStrCLSIDValue;
	::StringFromCLSID(clsid, &lpOleStrCLSIDValue);

	CRegKey key;
	if (bRegister)
	{
		LONG lRes = key.Open(HKEY_CLASSES_ROOT, szCLSID);
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpOleStrCLSIDValue);
			if (lRes == ERROR_SUCCESS)
			{
				WCHAR szModule[_MAX_PATH];
				::GetModuleFileName(m_hInst, szModule, _MAX_PATH);
				lRes = key.SetKeyValue(szIPS32, szModule);
        if (lRes == ERROR_SUCCESS)
        {
          lRes = key.Open(key, szIPS32);
          if (lRes == ERROR_SUCCESS)
          {
            key.SetValue(szThreadModelValue, szThreadingModel);
          }
        }
			}
		}
		if (lRes != ERROR_SUCCESS)
			hRes = HRESULT_FROM_WIN32(lRes);
	}
	else
	{
		key.Attach(HKEY_CLASSES_ROOT);
		if (key.Open(key, szCLSID) == ERROR_SUCCESS)
			key.RecurseDeleteKey(lpOleStrCLSIDValue);
	}
	::CoTaskMemFree(lpOleStrCLSIDValue);
	return hRes;
}


CDsAdminModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
  OBJECT_ENTRY(CLSID_DSSnapin, CDSSnapin)
  OBJECT_ENTRY(CLSID_DSSnapinEx, CDSSnapinEx)
  OBJECT_ENTRY(CLSID_SiteSnapin, CSiteSnapin)
  OBJECT_ENTRY(CLSID_DSAboutSnapin, CDSSnapinAbout)
  OBJECT_ENTRY(CLSID_SitesAboutSnapin, CSitesSnapinAbout)
  OBJECT_ENTRY(CLSID_DSContextMenu, CDSContextMenu)
  OBJECT_ENTRY(CLSID_DsAdminCreateObj, CDsAdminCreateObj)
  OBJECT_ENTRY(CLSID_DsAdminChooseDCObj, CDsAdminChooseDCObj)
  OBJECT_ENTRY(CLSID_DSAdminQueryUIForm, CQueryFormBase)
END_OBJECT_MAP()


CCommandLineOptions _commandLineOptions;


class CDSApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CDSApp theApp;

BOOL CDSApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
  InitGroupTypeStringTable();
  _commandLineOptions.Initialize();
	return CWinApp::InitInstance();
}

int CDSApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

#if (FALSE)
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

#endif

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _USE_MFC
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
#else
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
#endif
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}




LPCTSTR g_cszBasePath	= _T("Software\\Microsoft\\MMC\\SnapIns");
LPCTSTR g_cszNameString	= _T("NameString");
LPCTSTR g_cszNameStringIndirect = _T("NameStringIndirect");
LPCTSTR g_cszProvider	= _T("Provider");
LPCTSTR g_cszVersion	= _T("Version");
LPCTSTR g_cszAbout	= _T("About");
LPCTSTR g_cszStandAlone	= _T("StandAlone");
LPCTSTR g_cszExtension	= _T("Extension");
LPCTSTR g_cszNodeTypes	= _T("NodeTypes");

LPCTSTR GUIDToCString(REFGUID guid, CString & str)
{
	USES_CONVERSION;
	
	OLECHAR lpszGUID[128];
	int nChars = ::StringFromGUID2(guid, lpszGUID, 128);
	LPTSTR lpString = OLE2T(lpszGUID);

    LPTSTR lpGUID = str.GetBuffer(nChars);
    if (lpGUID)
    {
        CopyMemory(lpGUID, lpString, nChars*sizeof(TCHAR));
        str.ReleaseBuffer();
    }

    return str;
}


HRESULT _RegisterSnapinHelper(CRegKey& rkBase, REFGUID guid,
                              REFGUID about, UINT nNameStringID, 
                              BOOL bStandalone, CRegKey& rkCLSID)
{
  HRESULT hr = S_OK;
  CString strKey;
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  try
    {
      CString str;
      BOOL result;

      // Create snapin GUID key and set properties
      rkCLSID.Create(rkBase, GUIDToCString(guid, str));

      result = str.LoadString (nNameStringID);
      rkCLSID.SetValue(str, g_cszNameString);

      // JonN 4/26/00 100624: MUI: MMC: Shared Folders snap-in
      //                      stores its display information in the registry
      {
        WCHAR szModule[_MAX_PATH];
        ::GetModuleFileName(AfxGetInstanceHandle(), szModule, _MAX_PATH);
        str.Format( _T("@%s,-%d"), szModule, nNameStringID );
        rkCLSID.SetValue(str, g_cszNameStringIndirect);
      }

      str.LoadString (IDS_SNAPIN_PROVIDER);
      rkCLSID.SetValue(str, g_cszProvider);

      rkCLSID.SetValue(CString(_T("1.0")), g_cszVersion);
      
      // Create "StandAlone" or "Extension" key
      CRegKey rkStandAloneOrExtension;
      rkStandAloneOrExtension.Create(rkCLSID, bStandalone ? g_cszStandAlone : g_cszExtension);

      rkCLSID.SetValue (GUIDToCString(about, str),
                          g_cszAbout);
    }
  catch(CMemoryException * e)
    {
      e->Delete();
      hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
    catch(COleException * e)
    {
        e->Delete();
        hr = SELFREG_E_CLASS;
    }
	
    return hr;
}


void _RegisterNodeTypes(CRegKey& rkCLSID, UINT)
{
	// Create "NodeTypes" key
	CRegKey rkNodeTypes;
	rkNodeTypes.Create(rkCLSID,  g_cszNodeTypes);

	// NodeTypes guids
	CString str;
	str.LoadString (IDS_SNAPIN_PROVIDER);
	CRegKey rkN1;
	rkN1.Create(rkNodeTypes, GUIDToCString(cDefaultNodeType, str));
}

void _RegisterQueryForms()
{
  PWSTR pszDSQueryCLSID = NULL;
  ::StringFromCLSID(CLSID_DsQuery, &pszDSQueryCLSID);
  ASSERT(pszDSQueryCLSID != NULL);

  if (pszDSQueryCLSID != NULL)
  {
    CString szForms = pszDSQueryCLSID;
    ::CoTaskMemFree(pszDSQueryCLSID);

    szForms = L"CLSID\\" + szForms;

    CRegKey rkCLSID_DSQUERY_FORM;
    LONG status = rkCLSID_DSQUERY_FORM.Open(HKEY_CLASSES_ROOT, szForms);
    if (status != ERROR_SUCCESS)
    {
      return;
    }
  
    CRegKey rkDSUIFormKey;
    status = rkDSUIFormKey.Create(rkCLSID_DSQUERY_FORM, L"Forms");
    if (status == ERROR_SUCCESS)
    {
      PWSTR pszDSAFormCLSID = NULL;
      ::StringFromCLSID(CLSID_DSAdminQueryUIForm, &pszDSAFormCLSID);
      ASSERT(pszDSAFormCLSID != NULL);
      if (pszDSAFormCLSID != NULL)
      {

        CRegKey rkDSAdminFormKey;
        status = rkDSAdminFormKey.Create(rkDSUIFormKey, pszDSAFormCLSID);
        if (status == ERROR_SUCCESS)
        {
          rkDSAdminFormKey.SetValue(pszDSAFormCLSID, L"CLSID");
        }
        ::CoTaskMemFree(pszDSAFormCLSID);
      }
    }
  }
}

HRESULT RegisterSnapin()
{
  HRESULT hr = S_OK;
  CString strKey;
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  try
    {
      CString str;
      CRegKey rkBase;
      INT status;
      status = rkBase.Open(HKEY_LOCAL_MACHINE, g_cszBasePath);
      if (status || !rkBase.m_hKey)
        return hr;

      // REGISTER DS ADMIN STANDALONE
      CRegKey rkCLSID_DS;
      hr = _RegisterSnapinHelper(rkBase, CLSID_DSSnapin, CLSID_DSAboutSnapin,
                            IDS_DS_MANAGER, TRUE, rkCLSID_DS);
      if (SUCCEEDED(hr))
      {
        _RegisterNodeTypes(rkCLSID_DS, IDS_DS_MANAGER);
      }

      // REGISTER DS ADMIN EXTENSION
      CRegKey rkCLSID_DS_EX;
      hr = _RegisterSnapinHelper(rkBase, CLSID_DSSnapinEx, GUID_NULL,
                                 IDS_DS_MANAGER_EX, FALSE, rkCLSID_DS_EX);

      if (SUCCEEDED(hr) && rkCLSID_DS_EX.m_hKey != NULL)
      {
        _RegisterNodeTypes(rkCLSID_DS_EX, IDS_DS_MANAGER_EX);
      }
      
      // REGISTER SITE ADMIN STANDALONE
      
      CRegKey rkCLSID_SITE;
      hr = _RegisterSnapinHelper(rkBase, CLSID_SiteSnapin, CLSID_SitesAboutSnapin,
                                 IDS_SITE_MANAGER, TRUE, rkCLSID_SITE);

      if (SUCCEEDED(hr) && rkCLSID_SITE.m_hKey != NULL)
      {
        _RegisterNodeTypes(rkCLSID_SITE, IDS_SITE_MANAGER);
      }

      //
      // Register dsquery forms extension
      //
      _RegisterQueryForms();    
  }
  catch(CMemoryException * e)
    {
      e->Delete();
      hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
    catch(COleException * e)
    {
        e->Delete();
        hr = SELFREG_E_CLASS;
    }
	
    return hr;
}



HRESULT UnregisterSnapin()
{
  HRESULT hr = S_OK;

  try
  {
    CRegKey rkBase;
		rkBase.Open(HKEY_LOCAL_MACHINE, g_cszBasePath);

    if (rkBase.m_hKey != NULL)
    {
      CString str;
	    rkBase.RecurseDeleteKey(GUIDToCString(CLSID_DSSnapin, str));
	    rkBase.RecurseDeleteKey(GUIDToCString(CLSID_DSSnapinEx, str));
	    rkBase.RecurseDeleteKey(GUIDToCString(CLSID_SiteSnapin, str));
    }
  }
  catch(CException * e)
  {
    DWORD err = ::GetLastError();
    hr = HRESULT_FROM_WIN32(err);
    e->Delete();
  }

	return hr;
}






/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	HRESULT hRes = S_OK;
	// registers objects
	hRes = _Module.RegisterServer(FALSE);
  if (FAILED(hRes))
    return hRes;
  hRes = RegisterSnapin();
  return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
    UnregisterSnapin();
	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// CTargetingInfo

const DWORD CTargetingInfo::m_dwSaveDomainFlag = 0x1;

#ifdef _MMC_ISNAPIN_PROPERTY

// properties the snapin supports
LPCWSTR g_szServer = L"Server";
LPCWSTR g_szDomain = L"Domain";
LPCWSTR g_szRDN = L"RDN";


HRESULT CTargetingInfo::InitFromSnapinProperties(long cProps, //property count
                                  MMC_SNAPIN_PROPERTY* pProps) //properties array
{
  TRACE(L"CTargetingInfo::InitFromSnapinProperties()\n");

  // loop through the list of properties and set the variables
  BOOL bDomainSpecified = FALSE;
  for (long k=0; k< cProps; k++)
  {
    if (!bDomainSpecified && (_wcsicmp(pProps[k].pszPropName, g_szServer) == 0))
    {
      m_szStoredTargetName = pProps[k].varValue.bstrVal;
    }
    else if (_wcsicmp(pProps[k].pszPropName, g_szDomain) == 0)
    {
      // domain takes the precedence over server name
      bDomainSpecified = TRUE;
      m_szStoredTargetName = pProps[k].varValue.bstrVal;
    }
    else if (_wcsicmp(pProps[k].pszPropName, g_szRDN) == 0)
    {
      m_szRootRDN = pProps[k].varValue.bstrVal;
    }
  }

  // remove leading and trailing blanks
  m_szStoredTargetName.TrimLeft();
  m_szStoredTargetName.TrimRight();

  return S_OK;
}
#endif // _MMC_ISNAPIN_PROPERTY

void CTargetingInfo::_InitFromCommandLine()
{
  // get the command line switches /Domain or /Server
  LPCWSTR lpszDomainRoot = _commandLineOptions.GetDomainOverride();
  LPCWSTR lpszServerName = _commandLineOptions.GetServerOverride();

  // domain takes the precedence over server name
  m_szStoredTargetName = (lpszDomainRoot != NULL) ? lpszDomainRoot : lpszServerName;

  // remove leading and trailing blanks
  m_szStoredTargetName.TrimLeft();
  m_szStoredTargetName.TrimRight();

  m_szRootRDN = _commandLineOptions.GetRDNOverride();
}

HRESULT CTargetingInfo::Load(IStream* pStm)
{
  DWORD dwFlagsTemp;
  HRESULT hr = LoadDWordHelper(pStm, (DWORD*)&dwFlagsTemp);
	if (FAILED(hr))
		return hr;

  if (dwFlagsTemp == 0)
    return S_OK;

  if (m_szStoredTargetName.IsEmpty())
  {
    // no command line parameters: 
    // read flags and string from stream
    m_dwFlags = dwFlagsTemp;
    hr = LoadStringHelper(m_szStoredTargetName, pStm);
  }
  else
  {
    // have command line parameters: 
    // we do the load to preserve the loading sequence,
    // but we discard the results
    CString szThrowAway;
    hr = LoadStringHelper(szThrowAway, pStm);
  }
  return hr;
}

HRESULT CTargetingInfo::Save(IStream* pStm, LPCWSTR lpszCurrentTargetName)
{
	HRESULT hr = SaveDWordHelper(pStm, m_dwFlags);
	if (FAILED(hr))
		return hr;

  if (m_dwFlags == 0)
    return S_OK;

  CString szTemp = lpszCurrentTargetName;
  return SaveStringHelper(szTemp, pStm);
}


/////////////////////////////////////////////////////////////////////////////
// CIconManager

HRESULT CIconManager::Init(IImageList* pScpImageList, SnapinType snapintype)
{
  if (pScpImageList == NULL)
    return E_INVALIDARG;
  m_pScpImageList = pScpImageList;

  HRESULT hr;
  hr = _LoadIconFromResource(
		(snapintype == SNAPINTYPE_SITE) ? IDI_SITEREPL : IDI_DSADMIN,
		&m_iRootIconIndex);
  ASSERT(SUCCEEDED(hr));
  if (FAILED(hr))
    return hr;

  hr = _LoadIconFromResource(
		(snapintype == SNAPINTYPE_SITE) ? IDI_SITEREPL_ERR : IDI_DSADMIN_ERR,
		&m_iRootIconErrIndex);
  ASSERT(SUCCEEDED(hr));
  if (FAILED(hr))
    return hr;

  hr = _LoadIconFromResource(IDI_ICON_WAIT, &m_iWaitIconIndex);
  ASSERT(SUCCEEDED(hr));
  if (FAILED(hr))
    return hr;

  hr = _LoadIconFromResource(IDI_ICON_WARN, &m_iWarnIconIndex);
  ASSERT(SUCCEEDED(hr));
  if (FAILED(hr))
    return hr;

  hr = _LoadIconFromResource(IDI_FAVORITES, &m_iFavoritesIconIndex);
  ASSERT(SUCCEEDED(hr));
  if (FAILED(hr))
    return hr;

  hr = _LoadIconFromResource(IDI_QUERY, &m_iQueryIconIndex);
  ASSERT(SUCCEEDED(hr));

  hr = _LoadIconFromResource(IDI_QUERY_INVALID, &m_iQueryInvalidIconIndex);
  ASSERT(SUCCEEDED(hr));
  return hr;
}

HRESULT _SetIconHelper(IImageList* pImageList, HICON hiClass16, HICON hiClass32, 
                       int iIndex, BOOL bAdd32 = FALSE)
{
  HRESULT hr  = pImageList->ImageListSetIcon((LONG_PTR *)hiClass16, iIndex);
  if (SUCCEEDED(hr) && (hiClass32 != NULL))
  {
#ifdef ILSI_LARGE_ICON
    if (bAdd32)
    {
      HRESULT hr1  = pImageList->ImageListSetIcon((LONG_PTR *)hiClass32, ILSI_LARGE_ICON(iIndex));
      ASSERT(SUCCEEDED(hr1));
    }
#endif
  }
  return hr;
}

HRESULT CIconManager::FillInIconStrip(IImageList* pImageList)
{
  // cannot do this passing a scope pane image list interface
  ASSERT(m_pScpImageList != pImageList);

  HRESULT hr = S_OK;

  INT iTempIndex = _GetBaseIndex(); 
  for (POSITION pos = m_IconInfoList.GetHeadPosition(); pos != NULL; )
  {
    CIconInfo* pInfo = m_IconInfoList.GetNext(pos);
    hr = _SetIconHelper(pImageList, pInfo->m_hiClass16, pInfo->m_hiClass32, iTempIndex, TRUE);
    if (FAILED(hr))
      break;
    iTempIndex++;
  }
  return hr;
}


HRESULT CIconManager::AddClassIcon(IN LPCWSTR lpszClass, 
                                   IN MyBasePathsInfo* pPathInfo, 
                                   IN DWORD dwFlags,
                                   INOUT int* pnIndex)
{
  HICON hiClass16 = pPathInfo->GetIcon(lpszClass, dwFlags, 16,16);
  HICON hiClass32 = pPathInfo->GetIcon(lpszClass, dwFlags, 32,32);
  return AddIcon(hiClass16, hiClass32, pnIndex);
}



HRESULT CIconManager::AddIcon(IN HICON hiClass16, IN HICON hiClass32, INOUT int* pnIndex)
{
  ASSERT(pnIndex != NULL);
  ASSERT(hiClass16 != NULL);
  ASSERT(m_pScpImageList != NULL);

  *pnIndex = -1;

  int iNextIcon = _GetNextFreeIndex();
  HRESULT hr = _SetIconHelper(m_pScpImageList, hiClass16, hiClass32, iNextIcon);
  if (FAILED(hr))
    return hr;

  CIconInfo* pInfo = new CIconInfo;
  if (pInfo)
  {
    pInfo->m_hiClass16 = hiClass16;
    pInfo->m_hiClass32 = hiClass32;

    m_IconInfoList.AddTail(pInfo);
    *pnIndex = iNextIcon;
  }
  return hr;
}


HRESULT CIconManager::_LoadIconFromResource(IN UINT nIconResID, INOUT int* pnIndex)
{
  ASSERT(pnIndex != NULL);
  ASSERT(m_pScpImageList != NULL);
  HICON hIcon = ::LoadIcon(_Module.GetModuleInstance(), 
                               MAKEINTRESOURCE(nIconResID));
  ASSERT(hIcon != NULL);
  if (hIcon == NULL)
    return E_INVALIDARG;

  return AddIcon(hIcon, NULL, pnIndex);
}



/////////////////////////////////////////////////////////////////////////////
// CInternalFormatCracker


HRESULT CInternalFormatCracker::Extract(LPDATAOBJECT lpDataObject)
{
  _Free();
  if (lpDataObject == NULL)
    return E_INVALIDARG;

  SMMCDataObjects * pDO = NULL;
  
  STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
  FORMATETC formatetc = { CDSDataObject::m_cfInternal, NULL, 
                          DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
  };
  FORMATETC formatetc2 = { CDSDataObject::m_cfMultiSelDataObjs, NULL, 
                           DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
  };

  HRESULT hr = lpDataObject->GetData(&formatetc2, &stgmedium);
  if (FAILED(hr)) {
      
    // Attempt to get data from the object
    do 
      {
        hr = lpDataObject->GetData(&formatetc, &stgmedium);
        if (FAILED(hr))
          break;
          
        m_pInternalFormat = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);
          
        if (m_pInternalFormat == NULL)
        {
          if (SUCCEEDED(hr))
            hr = E_FAIL;
          break;
        }
          
      } while (FALSE); 
      
    return hr;
  } else {
    pDO = reinterpret_cast<SMMCDataObjects*>(stgmedium.hGlobal);
    for (UINT i = 0; i < pDO->count; i++) {
      hr = pDO->lpDataObject[i]->GetData(&formatetc, &stgmedium);
      if (FAILED(hr))
        break;
      
      m_pInternalFormat = reinterpret_cast<INTERNAL*>(stgmedium.hGlobal);
      
      if (m_pInternalFormat != NULL)
        break;
    }
  }
  return hr;
}

LPDATAOBJECT 
CInternalFormatCracker::ExtractMultiSelect(LPDATAOBJECT lpDataObject)
{
  _Free();
  if (lpDataObject == NULL)
    return NULL;

  SMMCDataObjects * pDO = NULL;
  
  STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
  FORMATETC formatetc = { CDSDataObject::m_cfMultiSelDataObjs, NULL, 
                           DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
  };

  if (FAILED(lpDataObject->GetData(&formatetc, &stgmedium))) {
    return NULL;
  } else {
    pDO = reinterpret_cast<SMMCDataObjects*>(stgmedium.hGlobal);
    return pDO->lpDataObject[0]; //assume that ours is the 1st
  }
}


/////////////////////////////////////////////////////////////////////
// CObjectNamesFormatCracker

CLIPFORMAT CObjectNamesFormatCracker::m_cfDsObjectNames = 
                                (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);



HRESULT CObjectNamesFormatCracker::Extract(LPDATAOBJECT lpDataObject)
{
  _Free();
  if (lpDataObject == NULL)
    return E_INVALIDARG;

  STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
  FORMATETC formatetc = { m_cfDsObjectNames, NULL, 
                          DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
  };

  HRESULT hr = lpDataObject->GetData(&formatetc, &stgmedium); 
  if (FAILED(hr)) 
  {
    return hr;
  }

  m_pDsObjectNames = reinterpret_cast<LPDSOBJECTNAMES>(stgmedium.hGlobal);
  if (m_pDsObjectNames == NULL)
  {
    if (SUCCEEDED(hr))
      hr = E_FAIL;
  }

  return hr;
}




/////////////////////////////////////////////////////////////////////
// CDSNotifyHandlerManager


typedef struct
{
  DWORD cNotifyExtensions;            // how many extension CLSIDs?
  CLSID aNotifyExtensions[1];
} DSCLASSNOTIFYINFO, * LPDSCLASSNOTIFYINFO;


HRESULT DsGetClassNotifyInfo(IN MyBasePathsInfo* pBasePathInfo, 
                                        OUT LPDSCLASSNOTIFYINFO* ppInfo)
{
  static LPCWSTR lpszSettingsObjectClass = L"dsUISettings";
  static LPCWSTR lpszSettingsObject = L"cn=DS-UI-Default-Settings";
  static LPCWSTR lpszNotifyProperty = L"dsUIAdminNotification";

  if ( (ppInfo == NULL) || (pBasePathInfo == NULL) )
    return E_INVALIDARG;

  *ppInfo = NULL;

  // get the display specifiers locale container (e.g. 409)
  CComPtr<IADsContainer> spLocaleContainer;
  HRESULT hr = pBasePathInfo->GetDisplaySpecifier(NULL, IID_IADsContainer, (void**)&spLocaleContainer);
  if (FAILED(hr))
    return hr;

  // bind to the settings object
  CComPtr<IDispatch> spIDispatchObject;
  hr = spLocaleContainer->GetObject((LPWSTR)lpszSettingsObjectClass, 
                                    (LPWSTR)lpszSettingsObject, 
                                    &spIDispatchObject);
  if (FAILED(hr))
    return hr;

  CComPtr<IADs> spSettingsObject;
  hr = spIDispatchObject->QueryInterface(IID_IADs, (void**)&spSettingsObject);
  if (FAILED(hr))
    return hr;

  // get multivaled property in string list form
  CComVariant var;
  CStringList stringList;
  hr = spSettingsObject->Get((LPWSTR)lpszNotifyProperty, &var);
  if (FAILED(hr))
    return hr;

  hr = HrVariantToStringList(var, stringList);
  if (FAILED(hr))
    return hr;

  size_t nCount = stringList.GetCount();

  // allocate memory
  DWORD cbCount = sizeof(DSCLASSNOTIFYINFO);
  if (nCount>1)
    cbCount += static_cast<ULONG>((nCount-1)*sizeof(CLSID));

  *ppInfo = (LPDSCLASSNOTIFYINFO)::LocalAlloc(LPTR, cbCount);
  if ((*ppInfo) == NULL)
    return E_OUTOFMEMORY;

  ZeroMemory(*ppInfo, cbCount);

  (*ppInfo)->cNotifyExtensions = 0;
  int* pArr = new int[nCount];
  if (!pArr)
  {
    return E_OUTOFMEMORY;
  }

  CString szEntry, szIndex, szGUID;
  for (POSITION pos = stringList.GetHeadPosition(); pos != NULL; )
  {
    szEntry = stringList.GetNext(pos);
    int nComma = szEntry.Find(L",");
    if (nComma == -1)
      continue;

    szIndex = szEntry.Left(nComma);
    int nIndex = _wtoi((LPCWSTR)szIndex);
    if (nIndex <= 0)
      continue; // allow from 1 up

    // strip leading and traling blanks
    szGUID = szEntry.Mid(nComma+1);
    szGUID.TrimLeft();
    szGUID.TrimRight();

    GUID* pGuid= &((*ppInfo)->aNotifyExtensions[(*ppInfo)->cNotifyExtensions]);
    hr = ::CLSIDFromString((LPWSTR)(LPCWSTR)szGUID, pGuid);
    if (SUCCEEDED(hr))
    {
      pArr[(*ppInfo)->cNotifyExtensions] = nIndex;
      ((*ppInfo)->cNotifyExtensions)++;
    }
  }
  
  if (((*ppInfo)->cNotifyExtensions) > 1)
  {
    // need to sort by index in pArr
    while (TRUE)
    {
      BOOL bSwapped = FALSE;
      for (UINT k=1; k < ((*ppInfo)->cNotifyExtensions); k++)
      {
        if (pArr[k] < pArr[k-1])
        {
          // swap
          int nTemp = pArr[k];
          pArr[k] = pArr[k-1];
          pArr[k-1] = nTemp;
          GUID temp = (*ppInfo)->aNotifyExtensions[k];
          (*ppInfo)->aNotifyExtensions[k] = (*ppInfo)->aNotifyExtensions[k-1];
          (*ppInfo)->aNotifyExtensions[k-1] = temp;
          bSwapped = TRUE;
        }
      }
      if (!bSwapped)
        break;
    }
  }
  delete[] pArr;
  pArr = 0;

  return S_OK;
}



HRESULT CDSNotifyHandlerManager::Init()
{
  _Free(); // prepare for delayed initialization
  return S_OK;
}



HRESULT CDSNotifyHandlerManager::Load(MyBasePathsInfo* pBasePathInfo)
{
  if (m_state != uninitialized)
    return S_OK; // already done, bail out

  // start the initialization process
  ASSERT(m_pInfoArr == NULL);

  m_state = noHandlers;
    
  LPDSCLASSNOTIFYINFO pInfo = NULL;
  HRESULT hr = DsGetClassNotifyInfo(pBasePathInfo, &pInfo);

  if (SUCCEEDED(hr) && (pInfo != NULL) && (pInfo->cNotifyExtensions > 0))
  {
    m_nArrSize = pInfo->cNotifyExtensions;
    m_pInfoArr = new CDSNotifyHandlerInfo[m_nArrSize];
    for (DWORD i=0; i<pInfo->cNotifyExtensions; i++)
    {
      hr = ::CoCreateInstance(pInfo->aNotifyExtensions[i], 
                              NULL, CLSCTX_INPROC_SERVER, 
                              IID_IDsAdminNotifyHandler, 
                              (void**)(&m_pInfoArr[i].m_spIDsAdminNotifyHandler));

      if (SUCCEEDED(hr) && m_pInfoArr[i].m_spIDsAdminNotifyHandler != NULL)
      {

        hr = m_pInfoArr[i].m_spIDsAdminNotifyHandler->Initialize(NULL,
                                                    &(m_pInfoArr[i].m_nRegisteredEvents));
        if (FAILED(hr) || m_pInfoArr[i].m_nRegisteredEvents == 0)
        {
          // release if init failed or not registered for any event
          m_pInfoArr[i].m_spIDsAdminNotifyHandler = NULL;
        } 
        else
        {
          m_state = hasHandlers;
        } //if
      } //if 
    } // for
  } // if

  if (pInfo != NULL)
    ::LocalFree(pInfo);

  return S_OK;
}


void CDSNotifyHandlerManager::Begin(ULONG uEvent, IDataObject* pArg1, IDataObject* pArg2)
{
  ASSERT(m_state == hasHandlers);

  HRESULT hr;
  for (UINT i=0; i<m_nArrSize; i++)
  {
    ASSERT(!m_pInfoArr[i].m_bTransactionPending);
    ASSERT(!m_pInfoArr[i].m_bNeedsNotify);
    ASSERT(m_pInfoArr[i].m_nFlags == 0);
    ASSERT(m_pInfoArr[i].m_szDisplayString.IsEmpty());

    if ( (m_pInfoArr[i].m_spIDsAdminNotifyHandler != NULL) &&
         (m_pInfoArr[i].m_nRegisteredEvents & uEvent) )
    {
      //
      // this call is to set the context information for the event,
      // we ignore the returned result
      //
      CComBSTR bstr;
      hr = m_pInfoArr[i].m_spIDsAdminNotifyHandler->Begin( 
                                                uEvent, pArg1, pArg2,
                                                &(m_pInfoArr[i].m_nFlags), &bstr);
      if (SUCCEEDED(hr) && (bstr != NULL) && (bstr[0] != NULL))
      {
        //
        // extension accepted the notification
        //
        m_pInfoArr[i].m_bNeedsNotify = TRUE;
        m_pInfoArr[i].m_szDisplayString = bstr;
      }

      //
      // mark the extension with a pending transaction
      // on it. we will have to call End()
      //
      m_pInfoArr[i].m_bTransactionPending = TRUE;
    } //if 
  } // for
}

void CDSNotifyHandlerManager::Notify(ULONG nItem, ULONG uEvent)
{
  ASSERT(m_state == hasHandlers);
  HRESULT hr;
  for (UINT i=0; i<m_nArrSize; i++)
  {
    if ( (m_pInfoArr[i].m_spIDsAdminNotifyHandler != NULL) &&
         (m_pInfoArr[i].m_nRegisteredEvents & uEvent) && m_pInfoArr[i].m_bNeedsNotify)
    {
      // should only call if the transaction was started by a Begin() call
      ASSERT(m_pInfoArr[i].m_bTransactionPending);
      hr = m_pInfoArr[i].m_spIDsAdminNotifyHandler->Notify(nItem,
                                    m_pInfoArr[i].m_nFlags);
    } //if 
  } // for
}


void CDSNotifyHandlerManager::End(ULONG uEvent)
{
  ASSERT(m_state == hasHandlers);
  HRESULT hr;
  for (UINT i=0; i<m_nArrSize; i++)
  {
    if ( (m_pInfoArr[i].m_spIDsAdminNotifyHandler != NULL) &&
         (m_pInfoArr[i].m_nRegisteredEvents & uEvent) )
    {
      ASSERT(m_pInfoArr[i].m_bTransactionPending);
      hr = m_pInfoArr[i].m_spIDsAdminNotifyHandler->End();
      // reset the state flags
      m_pInfoArr[i].m_bNeedsNotify = FALSE;
      m_pInfoArr[i].m_bTransactionPending = FALSE;
      m_pInfoArr[i].m_nFlags= 0;
      m_pInfoArr[i].m_szDisplayString.Empty();
    } //if 
    
  } // for
}

UINT CDSNotifyHandlerManager::NeedNotifyCount(ULONG uEvent)
{
  ASSERT(m_state == hasHandlers);
  UINT iCount = 0;
  for (UINT i=0; i<m_nArrSize; i++)
  {
    if ( (m_pInfoArr[i].m_spIDsAdminNotifyHandler != NULL) &&
         (m_pInfoArr[i].m_nRegisteredEvents & uEvent) &&
         m_pInfoArr[i].m_bNeedsNotify)
    {
      ASSERT(m_pInfoArr[i].m_bTransactionPending);
      iCount++;
    } //if 
  } // for
  return iCount;
}


void CDSNotifyHandlerManager::SetCheckListBox(CCheckListBox* pCheckListBox, ULONG uEvent)
{
  ASSERT(m_state == hasHandlers);
  UINT iListBoxIndex = 0;
  for (UINT i=0; i<m_nArrSize; i++)
  {
    if ( (m_pInfoArr[i].m_spIDsAdminNotifyHandler != NULL) &&
         (m_pInfoArr[i].m_nRegisteredEvents & uEvent) &&
         m_pInfoArr[i].m_bNeedsNotify)
    {
      ASSERT(m_pInfoArr[i].m_bTransactionPending);
      pCheckListBox->InsertString(iListBoxIndex, m_pInfoArr[i].m_szDisplayString);
      int nCheck = 0;
      if (m_pInfoArr[i].m_nFlags & DSA_NOTIFY_FLAG_ADDITIONAL_DATA)
        nCheck = 1;
      pCheckListBox->SetCheck(iListBoxIndex, nCheck);
      if (m_pInfoArr[i].m_nFlags & DSA_NOTIFY_FLAG_FORCE_ADDITIONAL_DATA)
        pCheckListBox->Enable(iListBoxIndex, FALSE);
      pCheckListBox->SetItemData(iListBoxIndex, (DWORD_PTR)(&m_pInfoArr[i]));
      iListBoxIndex++;
    } //if 
    
  } // for
}

void CDSNotifyHandlerManager::ReadFromCheckListBox(CCheckListBox* pCheckListBox, ULONG)
{
  ASSERT(m_state == hasHandlers);

  int nCount = pCheckListBox->GetCount();
  ASSERT(nCount != LB_ERR);
  for (int i=0; i< nCount; i++)
  {
    int nCheck = pCheckListBox->GetCheck(i);
    CDSNotifyHandlerInfo* pInfo = (CDSNotifyHandlerInfo*)
              pCheckListBox->GetItemData(i);
    ASSERT(pInfo != NULL);
    if ((pInfo->m_nFlags & DSA_NOTIFY_FLAG_FORCE_ADDITIONAL_DATA) == 0)
    {
      if (nCheck == 0)
        pInfo->m_nFlags &= ~DSA_NOTIFY_FLAG_ADDITIONAL_DATA;
      else
        pInfo->m_nFlags |= DSA_NOTIFY_FLAG_ADDITIONAL_DATA;
    }    
  } // for

}


//////////////////////////////////////////////////////////////////////
// IComponentData implementation

// WARNING this ctor passes an incomplete "this" pointer to other ctors
CDSComponentData::CDSComponentData() :
    m_pShlInit(NULL),
    m_pScope(NULL),
    m_pFrame(NULL)
#ifdef _MMC_ISNAPIN_PROPERTY
    ,
    m_pProperties(NULL)
#endif //_MMC_ISNAPIN_PROPERTY  
{
  ExceptionPropagatingInitializeCriticalSection(&m_cs);

  m_ActiveDS = NULL;

  m_pClassCache = NULL;

  m_pQueryFilter = NULL;

  m_pFavoritesNodesHolder = NULL;

  m_pHiddenWnd = NULL;

  m_pBackgroundThreadInfo = new CBackgroundThreadInfo;

  m_pScpImageList = NULL;
  m_bRunAsPrimarySnapin = TRUE;
  m_bAddRootWhenExtended = FALSE;
  m_bDirty = FALSE;
  m_SerialNumber = 1000; // arbitrary starting point

  m_ColumnWidths[0] = DEFAULT_NAME_COL_WIDTH;
  m_ColumnWidths[1] = DEFAULT_TYPE_COL_WIDTH;
  m_ColumnWidths[2] = DEFAULT_DESC_COL_WIDTH;

  m_InitSuccess = FALSE;
  m_InitAttempted = FALSE;
  m_lpszSnapinHelpFile = NULL;

}

HRESULT CDSComponentData::FinalConstruct()
{
  // This must be delayed until this ctor so that the virtual
  // callouts work propery


  // create and initialize hidden window
  m_pHiddenWnd = new CHiddenWnd(this);
  if (m_pHiddenWnd == NULL)
    return E_OUTOFMEMORY;
  if (!m_pHiddenWnd->Create())
  {
    TRACE(_T("Failed to create hidden window\n"));
    ASSERT(FALSE);
    return E_FAIL;
  }

  // create directory object
  m_ActiveDS = new CDSDirect (this);
  if (m_ActiveDS == NULL)
    return E_OUTOFMEMORY;

  // create class cache
  m_pClassCache = new CDSCache;
  if (m_pClassCache == NULL)
    return E_OUTOFMEMORY;

  m_pClassCache->Initialize(QuerySnapinType(), GetBasePathsInfo(), TRUE);


  // create saved queries holder
  if (QuerySnapinType() == SNAPINTYPE_DS)
  {
    m_pFavoritesNodesHolder = new CFavoritesNodesHolder();
    if (m_pFavoritesNodesHolder == NULL)
      return E_OUTOFMEMORY;

    // REVIEW_MARCOC_PORT this is just to test/demo
//    m_pFavoritesNodesHolder->BuildTestTree(_commandLineOptions.GetSavedQueriesXMLFile(), 
//                                           QuerySnapinType());

    // graft the subtree under the snapin root
    m_RootNode.GetFolderInfo()->AddNode(m_pFavoritesNodesHolder->GetFavoritesRoot());
  }

  // create filter
  m_pQueryFilter = new CDSQueryFilter();
  if (m_pQueryFilter == NULL)
    return E_OUTOFMEMORY;

  /* BUGBUG BUGBUG: this is a gross hack to get around a blunder
     in dsuiext.dll. in order to see get DS extension information,
     we MUST have USERDNSDOMAIN set in the environment
     */
  {
    WCHAR * pszUDD = NULL;
    
    pszUDD = _wgetenv (L"USERDNSDOMAIN");
    if (pszUDD == NULL) {
      _wputenv (L"USERDNSDOMAIN=not-present");
    }
  }

  return S_OK;
}


void CDSComponentData::FinalRelease()
{
  _DeleteHiddenWnd();

  // Dump the profiling data
  DUMP_PROFILING_RESULTS;
}

CDSComponentData::~CDSComponentData()
{
  TRACE(_T("~CDSComponentData entered...\n"));

  ::DeleteCriticalSection(&m_cs);
  ASSERT(m_pScope == NULL);
  
  if (m_pBackgroundThreadInfo != NULL)
  {
    delete m_pBackgroundThreadInfo;
  }

  // clean up the Class Cache
  if (m_pClassCache != NULL)
  {
    delete m_pClassCache;
    m_pClassCache = NULL;
  }

  // cleanup saved queries holder
  if (m_pFavoritesNodesHolder != NULL)
  {
    m_RootNode.GetFolderInfo()->RemoveNode(m_pFavoritesNodesHolder->GetFavoritesRoot());
    delete m_pFavoritesNodesHolder;
    m_pFavoritesNodesHolder = NULL;
  }
  // clean up the ADSI interface
  if (m_ActiveDS != NULL)
  {
    delete m_ActiveDS;
    m_ActiveDS = NULL;
  }

  if (m_pShlInit)
  {
      m_pShlInit->Release();
      m_pShlInit = NULL;
  }
  if (m_pScpImageList) {
    m_pScpImageList->Release();
    m_pScpImageList = NULL;
  }
  if (m_pQueryFilter) {
    delete m_pQueryFilter;
    m_pQueryFilter = NULL;
  }
  if (g_lpszLoggedInUser != NULL) 
  {
    delete[] g_lpszLoggedInUser;
    g_lpszLoggedInUser = NULL;
  }
  TRACE(_T("~CDSComponentData leaving...\n"));

}


HWND CDSComponentData::GetHiddenWindow() 
{ 
  ASSERT(m_pHiddenWnd != NULL);
  ASSERT(::IsWindow(m_pHiddenWnd->m_hWnd)); 
  return m_pHiddenWnd->m_hWnd;
}

void CDSComponentData::_DeleteHiddenWnd()
{
  if (m_pHiddenWnd == NULL)
    return;
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (m_pHiddenWnd->m_hWnd != NULL)
	{
		VERIFY(m_pHiddenWnd->DestroyWindow()); 
	}
  delete m_pHiddenWnd;
  m_pHiddenWnd = NULL;
}

BOOL CDSComponentData::ExpandComputers()
{
  Lock();
  BOOL b = m_pQueryFilter->ExpandComputers();
  Unlock();
  return b;
}

BOOL CDSComponentData::IsAdvancedView()
{
  return m_pQueryFilter->IsAdvancedView();
}

BOOL CDSComponentData::ViewServicesNode()
{
  return m_pQueryFilter->ViewServicesNode();
}



class CLockHandler
{
public:
  CLockHandler(CDSComponentData* pCD)
  {
    m_pCD = pCD;
    m_pCD->Lock();
  }
  ~CLockHandler()
  {
    m_pCD->Unlock();
  }
private:
  CDSComponentData* m_pCD;
};

STDMETHODIMP CDSComponentData::Initialize(LPUNKNOWN pUnknown)
{
  ASSERT(pUnknown != NULL);
  HRESULT hr;

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  // MMC should only call ::Initialize once!
  ASSERT(m_pScope == NULL);
  pUnknown->QueryInterface(IID_IConsoleNameSpace2,
                  reinterpret_cast<void**>(&m_pScope));

  // Get console's pre-registered clipboard formats
  hr = pUnknown->QueryInterface(IID_IConsole3, reinterpret_cast<void**>(&m_pFrame));
  if (FAILED(hr))
  {
    TRACE(TEXT("QueryInterface for IID_IConsole3 failed, hr: 0x%x\n"), hr);
    return hr;
  }

  //
  // Bind to the property sheet COM object at startup and hold its pointer
  // until shutdown so that its cache can live as long as us.
  //
  hr = CoCreateInstance(CLSID_DsPropertyPages, NULL, CLSCTX_INPROC_SERVER,
                        IID_IShellExtInit, (void **)&m_pShlInit);
  if (FAILED(hr))
  {
      TRACE(TEXT("CoCreateInstance on CLSID_DsPropertyPages failed, hr: 0x%x\n"), hr);
      return hr;
  }

  hr = m_pFrame->QueryScopeImageList (&m_pScpImageList);

  if (FAILED(hr))
  {
    TRACE(TEXT("Query for ScopeImageList failed, hr: 0x%x\n"), hr);
    return hr;
  }

  hr = m_iconManager.Init(m_pScpImageList, QuerySnapinType());
  if (FAILED(hr))
  {
    TRACE(TEXT("m_iconManager.Init() failed, hr: 0x%x\n"), hr);
    return hr;
  }

  if (!_StartBackgroundThread())
      return E_FAIL;

  m_pFrame->GetMainWindow(&m_hwnd);


  // NOTICE: we should initialize the filter only if the MyBasePathsInfo
  // initialization call has succeeded (need schema path for filtering).
  // In reality, we need the filter initialized for loading from a stream:
  // with a failure, this initialization is "wrong" because it has 
  // bad naming context info, but we will re initalize when we get good
  // info through retargeting
  hr = m_pQueryFilter->Init(this);
  if (FAILED(hr))
    return hr;

  return S_OK;
}

STDMETHODIMP CDSComponentData::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CDSEvent>* pObject;
    CComObject<CDSEvent>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CDSComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(m_pScope != NULL);
    HRESULT hr = S_FALSE;
    CUINode* pUINode = NULL;

    // Since it's my folder it has an internal format.
    // Design Note: for extension.  I can use the fact, that the data object doesn't have
    // my internal format and I should look at the node type and see how to extend it.

    if (lpDataObject != NULL)
    {
      CInternalFormatCracker dobjCracker;
	    if (FAILED(dobjCracker.Extract(lpDataObject)))
    	{
	    	if ((event == MMCN_EXPAND) && (arg == TRUE) && !m_bRunAsPrimarySnapin)
		    {
			    // this is a namespace extension, need to add
    			// the root of the snapin
	    		hr = _OnNamespaceExtensionExpand(lpDataObject, param);
          if (FAILED(hr))
          {
            hr = S_FALSE;
          }
          return hr;
		    }
    		return S_OK;
	    }

	    // got a valid data object
      pUINode = dobjCracker.GetCookie();
    }    

    if (event == MMCN_PROPERTY_CHANGE)
    {
        TRACE(_T("CDSComponentData::Notify() - property change, pDataObj = 0x%08x, param = 0x%08x, arg = %d.\n"),
              lpDataObject, param, arg);
        if (param != 0)
        {
            hr = _OnPropertyChange((LPDATAOBJECT)param, TRUE);
            if (FAILED(hr))
            {
              hr = S_FALSE;
            }
            return hr;
        }
        return S_FALSE;
    }

    if (pUINode == NULL) 
        return S_FALSE;

    switch (event)
    {
    case MMCN_PRELOAD:
      {
        _OnPreload((HSCOPEITEM)arg);
        hr = S_OK;
      }
      break;
    case MMCN_EXPANDSYNC:
      {
        MMC_EXPANDSYNC_STRUCT* pExpandStruct = 
          reinterpret_cast<MMC_EXPANDSYNC_STRUCT*>(param);
        if (pExpandStruct->bExpanding)
        {
          _OnExpand(pUINode, pExpandStruct->hItem,event);
          pExpandStruct->bHandled = TRUE;
          hr = S_OK;
        }
      }
      break;
    case MMCN_EXPAND:
        if (arg == TRUE) 
        { // Show
          _OnExpand(pUINode,(HSCOPEITEM)param,event);
          hr = S_OK;
        }
        break;

    case MMCN_DELETE:
      {
        CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(pUINode);

        if (pDSUINode == NULL)
        {
          hr = pUINode->Delete(this);
        }
        else
        {
          hr = _DeleteFromBackendAndUI(lpDataObject, pDSUINode);
        }
        if (FAILED(hr))
        {
          hr = S_FALSE;
        }
      }
      break;

    case MMCN_RENAME:
        hr = _Rename (pUINode, (LPWSTR)param);
        if (FAILED(hr))
        {
          hr = S_FALSE;
        }
        break;

    case MMCN_REFRESH:
        hr = Refresh (pUINode);
        if (FAILED(hr))
        {
          hr = S_FALSE;
        }
        break;

    default:
        hr = S_FALSE;
    }
    return hr;
}

STDMETHODIMP CDSComponentData::Destroy()
{
  // sever all ties with cookies having pending requests
  m_queryNodeTable.Reset(); 

  // wait for all the threads to shut down.
  _ShutDownBackgroundThread(); 

   // destroy the hidden window
  _DeleteHiddenWnd();

  if (m_pScope) 
  {
    m_pScope->Release();
    m_pScope = NULL;
  }

  if (m_pFrame) 
  {
    m_pFrame->Release();
    m_pFrame = NULL;
  }

#ifdef _MMC_ISNAPIN_PROPERTY
  if (m_pProperties)
  {
    m_pProperties->Release();
    m_pProperties = NULL;
  }
#endif //_MMC_ISNAPIN_PROPERTY

  return S_OK;
}

STDMETHODIMP CDSComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                               LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    HRESULT hr;
    CUINode* pNode;

    CComObject<CDSDataObject>* pObject;

    CComObject<CDSDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    if (pObject != NULL)
    {
      // Check to see if we have a valid cookie or we should use the snapin
      // cookie
      //
      pNode = reinterpret_cast<CUINode*>(cookie);
      if (pNode == NULL)
      {
        pNode = &m_RootNode;
      }

      // Save cookie and type for delayed rendering
      pObject->SetType(type, QuerySnapinType());
      pObject->SetComponentData(this);
      pObject->SetCookie(pNode);

      hr = pObject->QueryInterface(IID_IDataObject,
                                   reinterpret_cast<void**>(ppDataObject));
      //TRACE(_T("xx.%03x> CDSComponentData::QueryDataObject (CDsDataObject 0x%x)\n"),
      //      GetCurrentThreadId(), *ppDataObject);
    }
    else
    {
      hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CDSComponentData::GetDisplayInfo(LPSCOPEDATAITEM scopeInfo)
{
  CUINode* pNode = reinterpret_cast<CUINode*>(scopeInfo->lParam);
  ASSERT(pNode != NULL);
  ASSERT(pNode->IsContainer());
	
	if (scopeInfo->mask & SDI_STR)
  {
#ifdef DBG
    BOOL bNoName = (pNode->GetParent() == &m_RootNode) && _commandLineOptions.IsNoNameCommandLine();
    scopeInfo->displayname = bNoName ? L"" : const_cast<LPTSTR>(pNode->GetName());
#else
    scopeInfo->displayname = const_cast<LPTSTR>(pNode->GetName());
#endif
  }
	if (scopeInfo->mask & SDI_IMAGE) 
  {
    scopeInfo->nImage = GetImage(pNode, FALSE);
  }
	if (scopeInfo->mask & SDI_OPENIMAGE) 
  {
    scopeInfo->nOpenImage = GetImage(pNode, TRUE);
  }
  return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members


STDMETHODIMP CDSComponentData::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);
	ASSERT(m_bRunAsPrimarySnapin);

    // Copy the CLSID for this snapin
	switch (QuerySnapinType())
	{
	case SNAPINTYPE_DS:
		*pClassID = CLSID_DSSnapin;
		break;
	case SNAPINTYPE_DSEX:
		*pClassID = CLSID_DSSnapinEx;
		break;
	case SNAPINTYPE_SITE:
		*pClassID = CLSID_SiteSnapin;
		break;
	default:
		ASSERT(FALSE);
		return E_FAIL;
	}

    return S_OK;
}

STDMETHODIMP CDSComponentData::IsDirty()
{
  ASSERT(m_bRunAsPrimarySnapin);
  m_pFrame->UpdateAllViews(NULL, NULL, DS_CHECK_COLUMN_WIDTHS);

  return m_bDirty ? S_OK : S_FALSE;
}


// IMPORTANT NOTICE: this value has to be bumped up EVERY time
// a change is made to the stream format
#define DS_STREAM_VERSION ((DWORD)0x08)
#define DS_STREAM_BEFORE_SAVED_QUERIES ((DWORD)0x07)
#define DS_STREAM_W2K_VERSION ((DWORD)0x07)

STDMETHODIMP CDSComponentData::Load(IStream *pStm)
{
  // serialization on extensions not supported
  if (!m_bRunAsPrimarySnapin)
    return E_FAIL;

  ASSERT(pStm);

  // read the version ##
  DWORD dwVersion;
  HRESULT hr = LoadDWordHelper(pStm, &dwVersion);
//  if ( FAILED(hr) ||(dwVersion != DS_STREAM_VERSION) )
  if (FAILED(hr) || dwVersion < DS_STREAM_W2K_VERSION)
    return E_FAIL;
  
  // read targeting info
  hr = m_targetingInfo.Load(pStm);
  if (FAILED(hr))
    return hr;

  //
  // Initialize the root from the target info so that columns
  // can be loaded from the DS
  //
  hr = _InitRootFromCurrentTargetInfo();
  if (FAILED(hr))
    return hr;

  // read filtering options
  hr = m_pQueryFilter->Load(pStm);
  if (FAILED(hr))
    return hr;

  // read the class cache information
  hr = m_pClassCache->Load(pStm);
  if (FAILED(hr))
    return hr;

  if (dwVersion > DS_STREAM_BEFORE_SAVED_QUERIES)
  {
    hr = m_pFavoritesNodesHolder->Load(pStm, this);
    if (FAILED(hr))
    {
      return hr;
    }
  }
  m_bDirty = FALSE; // start clean
  return hr;
}

STDMETHODIMP CDSComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
  // serialization on extensions not supported
  if (!m_bRunAsPrimarySnapin)
    return E_FAIL;

  ASSERT(pStm);

  // write the version ##
  HRESULT hr = SaveDWordHelper(pStm, DS_STREAM_VERSION);
  if (FAILED(hr))
    return hr;


  // save targeting info
  hr = m_targetingInfo.Save(pStm, GetBasePathsInfo()->GetDomainName());
  if (FAILED(hr))
    return hr;


  // save filtering options
  hr = m_pQueryFilter->Save(pStm);
  if (FAILED(hr))
    return hr;

  // save the class cache information
  hr = m_pClassCache->Save(pStm);
  if (FAILED(hr))
    return hr;

  if (QuerySnapinType() == SNAPINTYPE_DS)
  {
    //
    // Save the saved queries folder for dsadmin only
    //
    hr = m_pFavoritesNodesHolder->Save(pStm);
    if (FAILED(hr))
      return hr;
  }

  if (fClearDirty)
    m_bDirty = FALSE;
  return hr;
}

STDMETHODIMP CDSComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
  ASSERT(pcbSize);
  ASSERT(FALSE);

  //
  // Arbitrary values but I don't think we ever get called
  //
  pcbSize->LowPart = 0xffff; 
  pcbSize->HighPart= 0x0;
  return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation


//+----------------------------------------------------------------------------
//
//  Member:     CDSComponentData::IExtendPropertySheet::CreatePropertyPages
//
//  Synopsis:   Called in response to a user click on the Properties context
//              menu item.
//
//-----------------------------------------------------------------------------

STDMETHODIMP
CDSComponentData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK pCall,
                                      LONG_PTR lNotifyHandle,
                                      LPDATAOBJECT pDataObject)
{
  CDSCookie* pCookie = NULL;

  TRACE(_T("xx.%03x> CDSComponentData::CreatePropertyPages()\n"),
        GetCurrentThreadId());

  //
  // Validate Inputs
  //
  if (pCall == NULL)
  {
    return E_INVALIDARG;
  }

  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  HRESULT hr = S_OK;

  CInternalFormatCracker dobjCracker;
  if (FAILED(dobjCracker.Extract(pDataObject)))
  {
    return E_NOTIMPL;
  }

  //
  // Pass the Notify Handle to the data object.
  //
  PROPSHEETCFG SheetCfg = {lNotifyHandle};
  FORMATETC fe = {CDSDataObject::m_cfPropSheetCfg, NULL, DVASPECT_CONTENT,
                  -1, TYMED_HGLOBAL};
  STGMEDIUM sm = {TYMED_HGLOBAL, NULL, NULL};
  sm.hGlobal = (HGLOBAL)&SheetCfg;

  pDataObject->SetData(&fe, &sm, FALSE);

  if (dobjCracker.GetCookieCount() > 1) // multiple selection
  {
    //
    // Pass a unique identifier to the data object
    //
    GUID guid;
    hr = ::CoCreateGuid(&guid);
    if (FAILED(hr))
    {
      ASSERT(FALSE);
      return hr;
    }

    WCHAR pszGuid[40];
    if (!::StringFromGUID2(guid, pszGuid, 40))
    {
      ASSERT(FALSE);
      return E_FAIL;
    }

    FORMATETC multiSelectfe = {CDSDataObject::m_cfMultiSelectProppage, NULL, DVASPECT_CONTENT,
                    -1, TYMED_HGLOBAL};
    STGMEDIUM multiSelectsm = {TYMED_HGLOBAL, NULL, NULL};
    multiSelectsm.hGlobal = (HGLOBAL)pszGuid;

    pDataObject->SetData(&multiSelectfe, &multiSelectsm, FALSE);

    hr = GetClassCache()->TabCollect_AddMultiSelectPropertyPages(pCall, lNotifyHandle, pDataObject, GetBasePathsInfo());
  }
  else  // single selection
  {
    CUINode* pUINode = dobjCracker.GetCookie();
    if (pUINode == NULL)
    {
      return E_NOTIMPL;
    }

    CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(pUINode);
    if (pDSUINode == NULL)
    {
      //
      // Delegate page creation to the node
      //
      return pUINode->CreatePropertyPages(pCall, lNotifyHandle, pDataObject, this);
    }

    pCookie = GetDSCookieFromUINode(pDSUINode);
    ASSERT(pCookie != NULL);

    CString szPath;
    GetBasePathsInfo()->ComposeADsIPath(szPath, pCookie->GetPath());

    FORMATETC mfe = {CDSDataObject::m_cfMultiSelectProppage, NULL, DVASPECT_CONTENT,
                    -1, TYMED_HGLOBAL};
    STGMEDIUM msm = {TYMED_HGLOBAL, NULL, NULL};
    msm.hGlobal = (HGLOBAL)(LPCWSTR)szPath;

    pDataObject->SetData(&mfe, &msm, FALSE);

    //
    // See if a sheet is already up for this object.
    //
    if (IsSheetAlreadyUp(pDataObject))
    {
      return S_OK;
    }

    //
    // Initialize and create the pages. Create an instance of the
    // CDsPropertyPages object for each sheet because each sheet runs on its
    // own thread.
    //
    IShellExtInit * pShlInit;
    hr = CoCreateInstance(CLSID_DsPropertyPages, NULL, CLSCTX_INPROC_SERVER,
                          IID_IShellExtInit, (void **)&pShlInit);
    if (FAILED(hr))
    {
      TRACE(TEXT("CoCreateInstance on CLSID_DsPropertyPages failed, hr: 0x%x\n"), hr);
      return hr;
    }

    //
    // Initialize the sheet with the data object
    //
    hr = pShlInit->Initialize(NULL, pDataObject, 0);
    if (FAILED(hr))
    {
      TRACE(TEXT("pShlInit->Initialize failed, hr: 0x%x\n"), hr);
      pShlInit->Release();
      return hr;
    }

    IShellPropSheetExt * pSPSE;
    hr = pShlInit->QueryInterface(IID_IShellPropSheetExt, (void **)&pSPSE);

    pShlInit->Release();
    if (FAILED(hr))
    {
      TRACE(TEXT("pShlInit->QI for IID_IShellPropSheetExt failed, hr: 0x%x\n"), hr);
      return hr;
    }

    //
    // Add pages to the sheet
    //
    hr = pSPSE->AddPages(AddPageProc, (LPARAM)pCall);
    if (FAILED(hr))
    {
      TRACE(TEXT("pSPSE->AddPages failed, hr: 0x%x\n"), hr);
      pSPSE->Release();
      return hr;
    }

    pSPSE->Release();
  }

  // REVIEW_MARCOC_PORT: need to clean up and leave the locking/unlocking
  // working for non DS property pages
  //_SheetLockCookie(pUINode);
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDSComponentData::IExtendPropertySheet::QueryPagesFor
//
//  Synopsis:   Called before a context menu is posted. If we support a
//              property sheet for this object, then return S_OK.
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDSComponentData::QueryPagesFor(LPDATAOBJECT pDataObject)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  TRACE(TEXT("CDSComponentData::QueryPagesFor().\n"));
    
  BOOL bHasPages = FALSE;

  //
  // Look at the data object and see if it an item in the scope pane.
  //
  CInternalFormatCracker dobjCracker;
  
  HRESULT hr = dobjCracker.Extract(pDataObject);
  if (FAILED(hr) || !dobjCracker.HasData())
  {
    //
    // not internal format, not ours
    //
    return S_FALSE;
  }

  //
  // this is the MMC snapin wizard, we do not have one
  //
  if (dobjCracker.GetType() == CCT_SNAPIN_MANAGER)
  {
    return S_FALSE;
  }

  if (dobjCracker.GetCookieCount() > 1) // multiple selection
  {
    bHasPages = TRUE;
  }
  else  // single selection
  {
    CUINode* pUINode = dobjCracker.GetCookie();
    if (pUINode == NULL)
    {
      return S_FALSE;
    }

    bHasPages = pUINode->HasPropertyPages(pDataObject);
  }
  return (bHasPages) ? S_OK : S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDSComponentData::IComponentData::CompareObjects
//
//  Synopsis:   If the data objects belong to the same DS object, then return
//              S_OK.
//
//-----------------------------------------------------------------------------


class CCompareCookieByDN
{
public:
  CCompareCookieByDN(LPCWSTR lpszDN) { m_lpszDN = lpszDN;}
  bool operator()(CDSUINode* pUINode)
  {
    CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);
    if (pCookie == NULL)
    {
      return FALSE;
    }
    return (_wcsicmp(m_lpszDN, pCookie->GetPath()) == 0);
  }
private:
  LPCWSTR m_lpszDN;
};



STDMETHODIMP CDSComponentData::CompareObjects(LPDATAOBJECT pDataObject1,
                                              LPDATAOBJECT pDataObject2)
{
  TRACE(TEXT("CDSComponentData::CompareObjects().\n"));
  CInternalFormatCracker dobjCracker1;
  CInternalFormatCracker dobjCracker2;
    
  if (FAILED(dobjCracker1.Extract(pDataObject1)) || 
       FAILED(dobjCracker2.Extract(pDataObject2)))
  {
    return S_FALSE; // could not get internal format
  }

  CUINode* pUINode1 = dobjCracker1.GetCookie();
  CUINode* pUINode2 = dobjCracker2.GetCookie();

  //
  // must have valid nodes
  //
  if ( (pUINode1 == NULL) || (pUINode2 == NULL) )
  {
    return S_FALSE;
  }
    
  if (dobjCracker1.GetCookieCount() == 1 &&
      dobjCracker2.GetCookieCount() == 1 &&
      pUINode1 == pUINode2)
  {
    //
    // same pointer, they are the same (either both from real nodes
    // or both from secondary pages)
    //
    return S_OK;
  }


  //
  // if they are not the same, we compare them by DN, because we
  // support only property pages on DS objects
  //
  CObjectNamesFormatCracker objectNamesFormatCracker1;
  CObjectNamesFormatCracker objectNamesFormatCracker2;

  if ( (FAILED(objectNamesFormatCracker1.Extract(pDataObject1))) ||
        (FAILED(objectNamesFormatCracker2.Extract(pDataObject2))) )
  {
    // one or both not a DS object: we assume they are different
    return S_FALSE;
  }

  if ( (objectNamesFormatCracker1.GetCount() != 1) ||
        (objectNamesFormatCracker2.GetCount() != 1) )
  {
    //
    // We are allowing as many multiple selection pages up as the user wants
    //
    return S_FALSE;
  }


  TRACE(L"CDSComponentData::CompareObjects(%s, %s)\n", objectNamesFormatCracker1.GetName(0), 
            objectNamesFormatCracker2.GetName(0));

  return (_wcsicmp(objectNamesFormatCracker1.GetName(0), 
          objectNamesFormatCracker2.GetName(0)) == 0) ? S_OK : S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CDSComponentData::AddMenuItems(LPDATAOBJECT pDataObject,
                                            LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                            long *pInsertionAllowed)
{
  HRESULT hr = S_OK;

  TRACE(_T("CDSComponentData::AddMenuItems()\n"));
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  DATA_OBJECT_TYPES dotType;

  CUINode* pUINode = NULL;
  CUIFolderInfo* pFolderInfo = NULL;
  CInternalFormatCracker dobjCracker;
  
  hr = dobjCracker.Extract(pDataObject);
  if (FAILED(hr))
  {
    ASSERT (FALSE); // Invalid Data Object
    return E_UNEXPECTED;
  }

  dotType = dobjCracker.GetType();
  pUINode = dobjCracker.GetCookie();

  if (pUINode==NULL || dotType==0)
  {
    ASSERT(FALSE); // Invalid args
    return E_UNEXPECTED;

  }

  //
  // Retrieve context menu verb handler form node
  //
  CContextMenuVerbs* pMenuVerbs = pUINode->GetContextMenuVerbsObject(this);
  if (pMenuVerbs == NULL)
  {
    ASSERT(FALSE);
    return E_UNEXPECTED;
  }

  if (pUINode->IsContainer())
  {
    pFolderInfo = pUINode->GetFolderInfo();
    ASSERT(pFolderInfo != NULL);
    
    pFolderInfo->UpdateSerialNumber(this);
  }
    
  //
  // Use the IContextMenuCallback2 interface so that we can use
  // language independent IDs on the menu items.
  //
  CComPtr<IContextMenuCallback2> spMenuCallback2;
  hr = pContextMenuCallback->QueryInterface(IID_IContextMenuCallback2, (PVOID*)&spMenuCallback2);
  if (FAILED(hr))
  {
    ASSERT(FALSE && L"Failed to QI for the IContextMenuCallback2 interface.");
    return E_UNEXPECTED;
  }

  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW)
  {
    //
    // Load New Menu
    //
    hr = pMenuVerbs->LoadNewMenu(spMenuCallback2, 
                                 m_pShlInit, 
                                 pDataObject, 
                                 pUINode, 
                                 pInsertionAllowed);
    ASSERT(SUCCEEDED(hr));
  }

  if ( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP )
  {
    //
    // Load Top Menu
    //
    hr = pMenuVerbs->LoadTopMenu(spMenuCallback2, pUINode);
    ASSERT(SUCCEEDED(hr));
  }

  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
  {
    //
    // Load Task Menu
    //
    hr = pMenuVerbs->LoadTaskMenu(spMenuCallback2, pUINode);
    ASSERT(SUCCEEDED(hr));
  }

  if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
  {
    //
    // Load View Menu
    //
    hr = pMenuVerbs->LoadViewMenu(spMenuCallback2, pUINode);
    ASSERT(SUCCEEDED(hr));
  }

  return hr;
}


STDMETHODIMP CDSComponentData::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  
  if (nCommandID >= IDM_NEW_OBJECT_BASE) 
  {
    // creation of a new DS object
    return _CommandNewDSObject(nCommandID, pDataObject);
  }

  if ((nCommandID >= MENU_MERGE_BASE) && (nCommandID <= MENU_MERGE_LIMIT)) 
  {
    // range of menu ID's coming from shell extensions
    return _CommandShellExtension(nCommandID, pDataObject);
  } 

  HRESULT hr = S_OK;

 
  CInternalFormatCracker dobjCracker;
  hr = dobjCracker.Extract(pDataObject);
  if (FAILED(hr))
  {
    ASSERT (FALSE); // Invalid Data Object
    return hr;
  }

  DATA_OBJECT_TYPES dotType = dobjCracker.GetType();
  CUINode* pUINode = dobjCracker.GetCookie();

  if (pUINode == NULL || dotType == 0)
  {
    ASSERT(FALSE); // Invalid args
    return E_FAIL;
  }

  if (IS_CLASS(*pUINode, CDSUINode))
  {
    CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);

    // menu ID's from standard DSA hard coded values
    switch (nCommandID) 
    {
    case IDM_DS_OBJECT_FIND:
      {
        LPCWSTR lpszPath = NULL;
        if (pCookie == NULL)
        {
          lpszPath = m_RootNode.GetPath();
        }
        else
        {
          lpszPath = pCookie->GetPath();
        }
        m_ActiveDS->DSFind(m_hwnd, lpszPath);
      }
      break;

    case IDM_GEN_TASK_MOVE:
      {
        CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(pUINode);
        ASSERT(pDSUINode != NULL);
        _MoveObject(pDSUINode);
        m_pFrame->UpdateAllViews (NULL, NULL, DS_UPDATE_OBJECT_COUNT);
      }
      break;
    
    case IDM_VIEW_COMPUTER_HACK:
      if (CanRefreshAll()) 
      {
        Lock();
        m_pQueryFilter->ToggleExpandComputers();
        Unlock();
        BOOL fDoRefresh = m_pClassCache->ToggleExpandSpecialClasses(m_pQueryFilter->ExpandComputers());
        m_bDirty = TRUE;

        if (fDoRefresh) 
        {
          RefreshAll();
        }
      }
      break;
    case IDM_GEN_TASK_SELECT_DOMAIN:
    case IDM_GEN_TASK_SELECT_FOREST:
      if (CanRefreshAll()) 
      {
        GetDomain();
      }
      break;
    case IDM_GEN_TASK_SELECT_DC:
      if (CanRefreshAll()) 
      {
        GetDC();
      }
      break;
#ifdef FIXUPDC
    case IDM_GEN_TASK_FIXUP_DC:
#endif // FIXUPDC
    case IDM_GEN_TASK_RUN_KCC:
      {
        ASSERT(pCookie != NULL); 
        //
        // Pass the LDAP path of the parent cookie to _FixupDC or _RunKCC.
        // The current cookie is a nTDSDSA object, 
        // and the parent cookie must be a server object
        //

        CUINode* pParentUINode = pUINode->GetParent();
        ASSERT(pParentUINode != NULL);

        CDSCookie *pParentCookie = GetDSCookieFromUINode(pParentUINode);
        ASSERT(pParentCookie != NULL);
        CString strServerPath = pParentCookie->GetPath();

        CString strPath = GetBasePathsInfo()->GetProviderAndServerName();
        strPath += strServerPath;
#ifdef FIXUPDC
        switch (nCommandID)
        {
        case IDM_GEN_TASK_FIXUP_DC:
          _FixupDC(strPath);
          break;
        case IDM_GEN_TASK_RUN_KCC:
#endif // FIXUPDC
          _RunKCC(strPath);
#ifdef FIXUPDC
          break;
        default:
          ASSERT(FALSE);
          break;
        }
#endif // FIXUPDC
      }
      break;
    case IDM_GEN_TASK_EDIT_FSMO:
      {
        EditFSMO();
      }
      break;

    case IDM_GEN_TASK_RAISE_VERSION:
       RaiseVersion();
       break;

    case IDM_VIEW_ADVANCED:
      {
        if (CanRefreshAll()) 
        {
          ASSERT( SNAPINTYPE_SITE != QuerySnapinType() );
          m_pQueryFilter->ToggleAdvancedView();
          m_bDirty = TRUE;
          RefreshAll();
        }
      }
      break;
    case IDM_VIEW_SERVICES_NODE:
      {
        if (CanRefreshAll()) 
        {
          ASSERT( SNAPINTYPE_SITE == QuerySnapinType() );
          m_pQueryFilter->ToggleViewServicesNode();
          m_bDirty = TRUE;
          if (m_RootNode.GetFolderInfo()->IsExpanded())
          {
            Refresh(&m_RootNode, FALSE /*bFlushCache*/ );
          }
        }
      }
      break;
    case IDM_VIEW_FILTER_OPTIONS:
      {
        if (CanRefreshAll())
        {
          ASSERT(m_bRunAsPrimarySnapin);
          if (m_pQueryFilter->EditFilteringOptions())
          {
            m_bDirty = TRUE;
            RefreshAll();
          }
        }
      }
    break;
    } // switch
  }
  else // Other node types
  {
    pUINode->OnCommand(nCommandID, this);
  }
  return S_OK;
}



HRESULT CDSComponentData::_CommandNewDSObject(long nCommandID, 
                                              LPDATAOBJECT pDataObject)
{
  ASSERT(nCommandID >= IDM_NEW_OBJECT_BASE);
  UINT objIndex = nCommandID - IDM_NEW_OBJECT_BASE;

  if (pDataObject == NULL)
    return E_INVALIDARG;
  
  CInternalFormatCracker internalFormat;
  HRESULT hr = internalFormat.Extract(pDataObject);
  if (FAILED(hr))
  {
    return hr;
  }

  if (!internalFormat.HasData() || (internalFormat.GetCookieCount() != 1))
  {
    return E_INVALIDARG;
  }

  CUINode* pContainerUINode = internalFormat.GetCookie();
  ASSERT(pContainerUINode != NULL);
  
  // can do this for DS objects only
  CDSUINode* pContainerDSUINode = dynamic_cast<CDSUINode*>(pContainerUINode);
  if (pContainerDSUINode == NULL)
  {
    ASSERT(FALSE); // should never happen
    return E_INVALIDARG;
  }

  CDSUINode* pNewDSUINode = NULL;
  // pNewCookie is filled in if it is a leaf, then we call UpdateAllViews
  hr = _CreateDSObject(pContainerDSUINode, pContainerDSUINode->GetCookie()->GetChildListEntry(objIndex), NULL, &pNewDSUINode);

  if (SUCCEEDED(hr) && (hr != S_FALSE) && (pNewDSUINode != NULL)) 
  {
    m_pFrame->UpdateAllViews(pDataObject, (LPARAM)pNewDSUINode, DS_CREATE_OCCURRED);
    m_pFrame->UpdateAllViews(pDataObject, (LPARAM)pContainerDSUINode, DS_UNSELECT_OBJECT);
  }
  m_pFrame->UpdateAllViews (NULL, NULL, DS_UPDATE_OBJECT_COUNT);

  return S_OK;
}


HRESULT CDSComponentData::_CommandShellExtension(long nCommandID, 
                                                 LPDATAOBJECT pDataObject)
{
  CComPtr<IContextMenu> spICM;

  HRESULT hr = m_pShlInit->QueryInterface(IID_IContextMenu, (void **)&spICM);
  if (FAILED(hr))
  {
    ASSERT(FALSE);
    return hr;
  }

  // just call the shell extension
  HWND hwnd;
  CMINVOKECOMMANDINFO cmiCommand;
  hr = m_pFrame->GetMainWindow (&hwnd);
  ASSERT (hr == S_OK);
  cmiCommand.hwnd = hwnd;
  cmiCommand.cbSize = sizeof (CMINVOKECOMMANDINFO);
  cmiCommand.fMask = SEE_MASK_ASYNCOK;
  cmiCommand.lpVerb = MAKEINTRESOURCEA(nCommandID - MENU_MERGE_BASE);
  spICM->InvokeCommand(&cmiCommand);

  // get the internal clibard format to see if it was one of our objects
  // from the DS context emnu extension
  CInternalFormatCracker internalFormat;
  hr = internalFormat.Extract(pDataObject);
  if (FAILED(hr))
  {
    return hr;
  }

  if (!internalFormat.HasData() || (internalFormat.GetCookieCount() != 1))
  {
    return E_INVALIDARG;
  }

  CUINode* pUINode = internalFormat.GetCookie();
  ASSERT(pUINode != NULL);

  if (pUINode->GetExtOp() & OPCODE_MOVE) 
  {
    // REVIEW_MARCOC_PORT: need to generalize this for all folder types
    CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(pUINode);
    ASSERT(pDSUINode != NULL);

    if (pDSUINode != NULL)
    {
      CUINode* pNewParentNode = MoveObjectInUI(pDSUINode);
      if (pNewParentNode && pNewParentNode->GetFolderInfo()->IsExpanded())
      {
         Refresh(pNewParentNode);
      }
    }
  }

  return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDSComponentData::ISnapinHelp2 members

STDMETHODIMP 
CDSComponentData::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
    return E_INVALIDARG;

  if (m_lpszSnapinHelpFile == NULL)
  {
    *lpCompiledHelpFile = NULL;
    return E_NOTIMPL;
  }

	CString szHelpFilePath;
	LPTSTR lpszBuffer = szHelpFilePath.GetBuffer(2*MAX_PATH);
	UINT nLen = ::GetSystemWindowsDirectory(lpszBuffer, 2*MAX_PATH);
	if (nLen == 0)
		return E_FAIL;

  szHelpFilePath.ReleaseBuffer();
  szHelpFilePath += L"\\help\\";
  szHelpFilePath += m_lpszSnapinHelpFile;

  UINT nBytes = (szHelpFilePath.GetLength()+1) * sizeof(WCHAR);
  *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);
  if (*lpCompiledHelpFile != NULL)
  {
    memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);
  }

  return S_OK;
}

STDMETHODIMP
CDSComponentData::GetLinkedTopics(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
    return E_INVALIDARG;

  CString szHelpFilePath;
  LPTSTR lpszBuffer = szHelpFilePath.GetBuffer(2*MAX_PATH);
  UINT nLen = ::GetSystemWindowsDirectory(lpszBuffer, 2*MAX_PATH);
  if (nLen == 0)
    return E_FAIL;

  szHelpFilePath.ReleaseBuffer();
  szHelpFilePath += L"\\help\\";
  szHelpFilePath += DSADMIN_LINKED_HELP_FILE;

  UINT nBytes = (szHelpFilePath.GetLength()+1) * sizeof(WCHAR);
  *lpCompiledHelpFile = (LPOLESTR)::CoTaskMemAlloc(nBytes);
  if (*lpCompiledHelpFile != NULL)
  {
    memcpy(*lpCompiledHelpFile, (LPCWSTR)szHelpFilePath, nBytes);
  }

  return S_OK;
}

#ifdef _MMC_ISNAPIN_PROPERTY
/////////////////////////////////////////////////////////////////////////////
// CDSComponentData::ISnapinProperties members


// struct defining each entry
struct CSnapinPropertyEntry
{
  LPCWSTR lpszName;
  DWORD   dwFlags;
};

// actual table
static const CSnapinPropertyEntry g_snapinPropertyArray[] =
{
  { g_szServer, MMC_PROP_CHANGEAFFECTSUI|MMC_PROP_MODIFIABLE|MMC_PROP_PERSIST},
  { g_szDomain, MMC_PROP_CHANGEAFFECTSUI|MMC_PROP_MODIFIABLE|MMC_PROP_PERSIST},
  { g_szRDN, MMC_PROP_CHANGEAFFECTSUI|MMC_PROP_MODIFIABLE|MMC_PROP_PERSIST},
  { NULL, 0x0} // end of table marker
};



STDMETHODIMP CDSComponentData::Initialize(
    Properties* pProperties)                /* I:my snap-in's properties    */
{
  TRACE(L"CDSComponentData::ISnapinProperties::Initialize()\n");

  if (pProperties == NULL)
  {
    return E_INVALIDARG;
  }

  ASSERT(m_pProperties == NULL); // assume called only once

  // save the interface pointer,
  // it will be released during IComponentData::Destroy()
  m_pProperties = pProperties;
  m_pProperties->AddRef();

  return S_OK;
}


STDMETHODIMP CDSComponentData::QueryPropertyNames(
    ISnapinPropertiesCallback* pCallback)   /* I:interface to add prop names*/
{
  TRACE(L"CDSComponentData::QueryPropertyNames()\n");

  HRESULT hr = S_OK;

  // just loop through the table and add the entries
  for (int k= 0; g_snapinPropertyArray[k].lpszName != NULL; k++)
  {
    hr = pCallback->AddPropertyName(g_snapinPropertyArray[k].lpszName, 
                                    NULL, 
                                    g_snapinPropertyArray[k].dwFlags);
    if (FAILED(hr))
    {
      break;
    }
  }
  return hr;
}

/*+-------------------------------------------------------------------------*
 * CDSComponentData::PropertiesChanged 
 *
 * This method is called when the snap-in's property set has changed.
 * 
 * Returns:
 *      S_OK            change was successful
 *      S_FALSE         change was ignored
 *      E_INVALIDARG    a changed property was invalid (e.g. a malformed
 *                      computer name)
 *      E_FAIL          a changed property was valid, but couldn't be used
 *                      (e.g. a valid name for a computer that couldn't be
 *                      located)
 *--------------------------------------------------------------------------*/

STDMETHODIMP CDSComponentData::PropertiesChanged(
    long                    cChangedProps,      /* I:changed property count */
    MMC_SNAPIN_PROPERTY*    pChangedProps)      /* I:changed properties     */
{
  TRACE(L"CDSComponentData::PropertiesChanged()\n");

  // for the time being we do not allow any property change,
  // we accept only initialization, so make a quick change and bail out
  // if things are not such
  for (long k=0; k< cChangedProps; k++)
  {
    if (pChangedProps[k].eAction != MMC_PROPACT_INITIALIZING)
    {
      return S_FALSE; // change ignored
    }
    if (pChangedProps[k].varValue.vt != VT_BSTR)
    {
      // something is wrong, refuse 
      return E_INVALIDARG;
    }
  }

  // delegate to the targeting info object
  HRESULT hr = m_targetingInfo.InitFromSnapinProperties(cChangedProps, pChangedProps);

  // need to add here the properties for advanced view and alike
  return hr;
}

#endif //_MMC_ISNAPIN_PROPERTY




/////////////////////////////////////////////////////////////////////////////
// internal helpers


HRESULT CDSComponentData::_InitRootFromBasePathsInfo(MyBasePathsInfo* pBasePathsInfo)
{
  // we assume the MyBasePathsInfo we get is valid,
  // we just swap info around and rebuild the related
  // data structures
  GetBasePathsInfo()->InitFromInfo(pBasePathsInfo);
  m_InitSuccess = TRUE;
  TRACE(_T("in _InitRootFromBasePathsInfo, set m_InitSuccess to true\n"));
  return _InitRootFromValidBasePathsInfo();
}


HRESULT CDSComponentData::_InitRootFromCurrentTargetInfo()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CWaitCursor wait;
  
  HRESULT hr = S_OK;

  //
  // This function may be called twice if we are loading from a file,
  // so don't try to initialize a second time
  //
  if (m_InitAttempted)
  {
    return S_OK;
  }

  BOOL bLocalLogin;
  bLocalLogin = IsLocalLogin();

  //if user logged in locally and noting given on 
  //command line
  LPCWSTR lpszServerOrDomain = m_targetingInfo.GetTargetString();
  BOOL bNoTarget = ( (lpszServerOrDomain == NULL) ||
                     (lpszServerOrDomain[0] == NULL) );

  if( bNoTarget && bLocalLogin && (SNAPINTYPE_SITE != QuerySnapinType()))
  {
    TRACE(_T("LoggedIn as Local User and No Command Line arguments\n"));
    CString szMsg;
    szMsg.LoadString(IDS_LOCAL_LOGIN_ERROR);

    CComPtr<IDisplayHelp> spIDisplayHelp;
    hr = m_pFrame->QueryInterface (IID_IDisplayHelp, 
                            (void **)&spIDisplayHelp);

    CMoreInfoMessageBox dlg(m_hwnd, spIDisplayHelp , FALSE);
    dlg.SetMessage(szMsg);
    dlg.SetURL(DSADMIN_MOREINFO_LOCAL_LOGIN_ERROR);
    dlg.DoModal();
    m_InitSuccess = FALSE;
    TRACE(_T("in _InitRootFromCurrentTargetInfo, set m_InitSuccess to false\n"));
  }
  else 
  {

    // initialize base paths
    hr = GetBasePathsInfo()->InitFromName(lpszServerOrDomain);

    //
    // JonN 5/4/00
    // 55400: SITEREPL: Should default to local DC regardless of credentials
    // If the local machine is in the target forest, we target the domain
    // containing the local machine.
    //
    do // false loop
    {
      // We cannot follow this procedudure if we couldn't bind initially
      if (FAILED(hr)) break;

      // Skip this if the user specified a target
      if (!bNoTarget) break;

      // only do this for SITEREPL
      if (SNAPINTYPE_SITE != QuerySnapinType()) break;

      // Check whether the user is logged onto the local domain.
      CString strComputer; // empty string
      CString strLocalDomain;
      HRESULT hr2 = GetDnsNameOfDomainOrForest(
          strComputer, strLocalDomain, FALSE, TRUE );
      if (FAILED(hr2) || strLocalDomain.IsEmpty()) break;
      CString strTargetDomain = GetBasePathsInfo()->GetDomainName();
      if (strTargetDomain.IsEmpty()) break;
      if (!strLocalDomain.CompareNoCase(strTargetDomain)) break;

      // The user is not logged onto the local domain.
      // We need to determine whether the user is logged onto
      // the same forest as the local forest.
      CString strLocalForest;
      hr2 = GetDnsNameOfDomainOrForest(
          strComputer, strLocalForest, FALSE, FALSE );
      if (FAILED(hr2) || strLocalForest.IsEmpty()) break;
      CString strTargetForest;
      strComputer = GetBasePathsInfo()->GetServerName();
      hr2 = GetDnsNameOfDomainOrForest(
          strComputer, strTargetForest, FALSE, FALSE );
      if (FAILED(hr2) || strTargetForest.IsEmpty()) break;
      if (strLocalForest.CompareNoCase(strTargetForest)) break;

      // The user is logged on to a different domain than the local
      // domain, but one in the same forest.  There are probably closer DCs
      // than the one just located, so use them instead.

      // start using hr again here rather than hr2
      TRACE(_T("_InitRootFromCurrentTargetInfo() rebinding\n"));
      hr = GetBasePathsInfo()->InitFromName(strLocalDomain);
      if (FAILED(hr))
      {
        // try to fall back to initial focus
        TRACE(_T("_InitRootFromCurrentTargetInfo() reverting\n"));
        hr = GetBasePathsInfo()->InitFromName(lpszServerOrDomain);
      }

    } while (false); // false loop

    // NOTICE: if we fail, we out out the error message, and
    // we keep a flag to avoid query expansions, but
    // we continue, because we have to keep consistency in all
    // the data structures (class cache, filter, etc.)


    if (FAILED(hr)) 
    {
		  TRACE(_T("_InitRootFromCurrentTargetInfo() failed\n"));
		  ReportErrorEx (m_hwnd, IDS_CANT_GET_ROOTDSE,hr,
                           MB_OK | MB_ICONERROR, NULL, 0);
		  m_InitSuccess = FALSE;
		  TRACE(_T("in _InitRootFromCurrentTargetInfo(), set m_InitSuccess to false\n"));
	  }
    else
    {
      m_InitSuccess = TRUE;
      TRACE(_T("in _InitRootFromCurrentTargetInfo(), set m_InitSuccess to true\n"));
    }
  
  }

  _InitRootFromValidBasePathsInfo();
  m_InitAttempted = TRUE;

  return hr;
}






HRESULT CDSComponentData::_InitRootFromValidBasePathsInfo()
{  
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  HRESULT hr = S_OK;

  // now set the root node strings.  This will be reset below
  // with the DNS name of the domain if everything succeeds

  CString str;
  str.LoadString( ResourceIDForSnapinType[ QuerySnapinType() ] );
  m_RootNode.SetName(str);

  // rebuild the display spec options struct for Data Objects
  hr = BuildDsDisplaySpecOptionsStruct();
  if (FAILED(hr))
    return hr;

  // reset the notification handler
  GetNotifyHandlerManager()->Init();

  // reset the query filter (already initialized in IComponentData::Initialize())
  hr = m_pQueryFilter->Bind();
  if (FAILED(hr))
    return hr;
  
  CString szServerName = GetBasePathsInfo()->GetServerName();
  if (!szServerName.IsEmpty())
  {
    str += L" [";
    str += szServerName;
    str += L"]";
  }

  m_RootNode.SetName(str);
  
  if (QuerySnapinType() == SNAPINTYPE_SITE)
  {
    //fix the default root path
    str = GetBasePathsInfo()->GetConfigNamingContext();
  }
  else
  {
    LPCWSTR lpszRootRDN = m_targetingInfo.GetRootRDN();
    if ( (lpszRootRDN != NULL) && (lpszRootRDN[0] != NULL) )
    {
      // add RDN below default naming context
      // REVIEW_MARCOC_PORT: need to make sure the RDN is valid
      str = m_targetingInfo.GetRootRDN(); 
      str += L",";
      str += GetBasePathsInfo()->GetDefaultRootNamingContext();
    }
    else
    {
      // just use the default naming context
      str = GetBasePathsInfo()->GetDefaultRootNamingContext();
    }
  }

  m_RootNode.SetPath(str);

  // update UI if we already have inserted the root (retargeting case)
  HSCOPEITEM hScopeItemID = m_RootNode.GetFolderInfo()->GetScopeItem();
  if (hScopeItemID != NULL)
  {
    SCOPEDATAITEM Item;
    CString csRoot;

    Item.ID = m_RootNode.GetFolderInfo()->GetScopeItem();
    Item.mask = SDI_STR;
    csRoot = m_RootNode.GetName();
    Item.displayname = (LPWSTR)(LPCWSTR)csRoot;
    m_pScope->SetItem(&Item);

    m_RootNode.SetExtOp(m_InitSuccess ? 0 : OPCODE_ENUM_FAILED);

    ChangeScopeItemIcon(&m_RootNode);
  }

  return hr;
}

void CDSComponentData::GetDomain()
{
  CChooseDomainDlg DomainDlg;

  // load current bind info
  DomainDlg.m_csTargetDomain = GetBasePathsInfo()->GetDomainName();
  DomainDlg.m_bSiteRepl = (SNAPINTYPE_SITE == QuerySnapinType());
  DomainDlg.m_bSaveCurrent = m_targetingInfo.GetSaveCurrent();

  //
  // invoke the dialog
  //
  if (DomainDlg.DoModal() == IDOK)
  {
    CWaitCursor cwait;
    // attempt to bind
    MyBasePathsInfo tempBasePathsInfo;
    HRESULT hr = tempBasePathsInfo.InitFromName(DomainDlg.m_csTargetDomain);
    if (SUCCEEDED(hr))
    {
      hr = _InitRootFromBasePathsInfo(&tempBasePathsInfo);
      if (SUCCEEDED(hr))
      {
        m_targetingInfo.SetSaveCurrent(DomainDlg.m_bSaveCurrent);
        m_bDirty = TRUE;
        ClearClassCacheAndRefreshRoot();
      }
    }

    if (FAILED(hr))
    {
      ReportErrorEx(
        m_hwnd,
        (DomainDlg.m_bSiteRepl ? IDS_RETARGET_FOREST_FAILED : IDS_RETARGET_DOMAIN_FAILED),
        hr, MB_OK | MB_ICONERROR, NULL, 0);
    }
  }
    
  return;
}

void CDSComponentData::GetDC()
{
  CChooseDCDlg DCdlg(CWnd::FromHandle(m_hwnd));

  // load current bind info
  DCdlg.m_bSiteRepl = (SNAPINTYPE_SITE == QuerySnapinType());
  DCdlg.m_csTargetDomain = GetBasePathsInfo()->GetDomainName();
  DCdlg.m_csTargetDomainController = GetBasePathsInfo()->GetServerName();

  //
  // invoke the dialog
  //
  if (DCdlg.DoModal() == IDOK)
  {
    CWaitCursor cwait;
    CString csNewTarget;

    csNewTarget = DCdlg.m_csTargetDomainController;
    if (csNewTarget.IsEmpty())
      csNewTarget = DCdlg.m_csTargetDomain;
    // attempt to bind
    MyBasePathsInfo tempBasePathsInfo;
    HRESULT hr = tempBasePathsInfo.InitFromName(csNewTarget);
    if (SUCCEEDED(hr))
    {
      hr = _InitRootFromBasePathsInfo(&tempBasePathsInfo);
      if (SUCCEEDED(hr))
        ClearClassCacheAndRefreshRoot();
    }

    if (FAILED(hr))
    {
      ReportErrorEx(
        m_hwnd,
        IDS_RETARGET_DC_FAILED,
        hr, MB_OK | MB_ICONERROR, NULL, 0);
    }
  }
    
  return;
}


void CDSComponentData::EditFSMO()
{
  CComPtr<IDisplayHelp> spIDisplayHelp;
  HRESULT hr = m_pFrame->QueryInterface (IID_IDisplayHelp, 
                            (void **)&spIDisplayHelp);
  ASSERT(spIDisplayHelp != NULL);

  if (SUCCEEDED(hr))
  {
    HWND hWnd;
    m_pFrame->GetMainWindow(&hWnd);
    LPCWSTR lpszTODO = L"";
    CFsmoPropertySheet sheet(GetBasePathsInfo(), hWnd, spIDisplayHelp, lpszTODO);
    sheet.DoModal();
  }
}

void CDSComponentData::RaiseVersion(void)
{
   HWND hWnd;
   m_pFrame->GetMainWindow(&hWnd);
   CString strPath;
   GetBasePathsInfo()->GetDefaultRootPath(strPath);
   PCWSTR pwzDnsName = GetBasePathsInfo()->GetDomainName();
   ASSERT(pwzDnsName);
   DSPROP_DomainVersionDlg(strPath, pwzDnsName, hWnd);
}

HRESULT CDSComponentData::_OnPreload(HSCOPEITEM hRoot)
{
  HRESULT hr = S_OK;

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  CString str;
  str.LoadString( ResourceIDForSnapinType[ QuerySnapinType() ] );
  m_RootNode.SetName(str);

  if (GetBasePathsInfo()->IsInitialized())
  {
    CString szServerName = GetBasePathsInfo()->GetServerName();
    if (!szServerName.IsEmpty())
    {
      str += L" [";
      str += szServerName;
      str += L"]";
    }

    m_RootNode.SetName(str);
  }
  SCOPEDATAITEM Item;
  Item.ID = hRoot;
  Item.mask = SDI_STR;
  Item.displayname = (LPWSTR)(LPCWSTR)str;
  hr = m_pScope->SetItem(&Item);
  return hr;
}

HRESULT CDSComponentData::_OnExpand(CUINode* pNode, HSCOPEITEM hParent, MMC_NOTIFY_TYPE event)
{
  HRESULT hr = S_OK;


  if ((pNode == NULL) || (!pNode->IsContainer()) )
  {
    ASSERT(FALSE);  // Invalid Arguments
    return E_INVALIDARG;
  }

  BEGIN_PROFILING_BLOCK("CDSComponentData::_OnExpand");

  CWaitCursor cwait;

  if (pNode->GetFolderInfo()->IsExpanded())
  {
     END_PROFILING_BLOCK;

     //
     // Short circuit the expansion because the node is already expanded
     //
     return S_OK;
  }

  pNode->GetFolderInfo()->SetExpanded();
  if (pNode == &m_RootNode) 
  {
    // initialize the paths and targeting
    _InitRootFromCurrentTargetInfo();

    // add the root cookie to MMC
    pNode->GetFolderInfo()->SetScopeItem(hParent);
    
    SCOPEDATAITEM Item;
    Item.ID = hParent;
    Item.mask = SDI_STR;
    Item.displayname = (LPWSTR)(LPCWSTR)(m_RootNode.GetName());
    m_pScope->SetItem (&Item);

    // also add the root for the saved queries, if present
    if (m_pFavoritesNodesHolder != NULL)
    {
      // add the favorite queries subtree
      _AddScopeItem(m_pFavoritesNodesHolder->GetFavoritesRoot(), 
                    m_RootNode.GetFolderInfo()->GetScopeItem());
    }
  }


  if (IS_CLASS(*pNode, CFavoritesNode))
  {
    // just add the favorites subfolders and query folders
    CUINodeList* pNodeList = pNode->GetFolderInfo()->GetContainerList();
    for (POSITION pos = pNodeList->GetHeadPosition(); pos != NULL; )
    {
      CUINode* pCurrChildNode = pNodeList->GetNext(pos);
      _AddScopeItem(pCurrChildNode, 
                    pNode->GetFolderInfo()->GetScopeItem());
    }

    END_PROFILING_BLOCK;

    // return because we do not need to spawn any background
    // thread query
    return S_OK;
  }

  if (!_PostQueryToBackgroundThread(pNode))
  {
    END_PROFILING_BLOCK;

    // no background thread query generated, we are done
    return S_OK;
  }

  // need to spawn a query request
  pNode->SetExtOp(OPCODE_EXPAND_IN_PROGRESS);
  
  TIMER(_T("posting request to bg threads\n"));

  if (MMCN_EXPANDSYNC == event)
  {
    // if sync expand, have to wait for the query to complete
    MSG tempMSG;
    TRACE(L"MMCN_EXPANDSYNC, before while()\n");
	  while(m_queryNodeTable.IsPresent(pNode))
	  {
		  if (::PeekMessage(&tempMSG,m_pHiddenWnd->m_hWnd,CHiddenWnd::s_ThreadStartNotificationMessage,
										  CHiddenWnd::s_ThreadDoneNotificationMessage,
										  PM_REMOVE))
		  {
			  DispatchMessage(&tempMSG);
		  }
    } // while
    TRACE(L"MMCN_EXPANDSYNC, after while()\n");
  }
  END_PROFILING_BLOCK;
  return hr;
}


HRESULT CDSComponentData::_AddScopeItem(CUINode* pUINode, HSCOPEITEM hParent, BOOL bSetSelected)
{
  if (pUINode==NULL)
  {
    ASSERT(FALSE);  // Invalid Arguments
    return E_INVALIDARG;
  }

  ASSERT(pUINode->IsContainer());
  
  HRESULT hr=S_OK;

  SCOPEDATAITEM  tSDItem;
  ZeroMemory(&tSDItem, sizeof(SCOPEDATAITEM));
  
  tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_STATE | SDI_PARAM |SDI_CHILDREN | SDI_PARENT;
  tSDItem.relativeID = hParent;

  if (IS_CLASS(*pUINode, CSavedQueryNode))
  {
    tSDItem.cChildren = 0;
  }
  else
  {
    tSDItem.cChildren=1;
  }
  tSDItem.nState = 0;
  
    // insert item into tree control
  tSDItem.lParam = reinterpret_cast<LPARAM>(pUINode);
  tSDItem.displayname=(LPWSTR)-1;
  tSDItem.nOpenImage = GetImage(pUINode, TRUE);
  tSDItem.nImage = GetImage(pUINode, FALSE);
  
  hr = m_pScope->InsertItem(&tSDItem);
  if (SUCCEEDED(hr) && tSDItem.ID != NULL)
  {
    pUINode->GetFolderInfo()->SetScopeItem(tSDItem.ID);

    if (bSetSelected)
    {
      m_pFrame->SelectScopeItem(tSDItem.ID);
    }
  }
  return hr;
}

HRESULT CDSComponentData::ChangeScopeItemIcon(CUINode* pUINode)
{
  ASSERT(pUINode->IsContainer());
  SCOPEDATAITEM  tSDItem;
  ZeroMemory(&tSDItem, sizeof(SCOPEDATAITEM));
  tSDItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
  tSDItem.nOpenImage = GetImage(pUINode, TRUE);
  tSDItem.nImage = GetImage(pUINode, FALSE);
  tSDItem.ID = pUINode->GetFolderInfo()->GetScopeItem();
  return m_pScope->SetItem(&tSDItem);
}

HRESULT CDSComponentData::_ChangeResultItemIcon(CUINode* pUINode)
{
  ASSERT(!pUINode->IsContainer());
  return m_pFrame->UpdateAllViews(NULL,(LPARAM)pUINode, DS_UPDATE_OCCURRED);
}

HRESULT CDSComponentData::ToggleDisabled(CDSUINode* pDSUINode, BOOL bDisable)
{
  HRESULT hr = S_OK;

  CDSCookie* pCookie = pDSUINode->GetCookie();
  ASSERT(pCookie != NULL);
  if (pCookie == NULL)
  {
    return E_INVALIDARG;
  }

  if (pCookie->IsDisabled() != bDisable)
  {
    // changed state
    if (bDisable)
      pCookie->SetDisabled();
    else
      pCookie->ReSetDisabled();
    
    // now need to change icon
    if (pDSUINode->IsContainer())
      return ChangeScopeItemIcon(pDSUINode);
    else
      return _ChangeResultItemIcon(pDSUINode);
  }
  return hr;

}


HRESULT CDSComponentData::UpdateItem(CUINode* pNode)
{
  if (pNode->IsContainer())
  {
    //
    // this is a scope pane item
    //
    return _UpdateScopeItem(pNode);
  }
  else
  {
    //
    // this is a result pane item
    // tell the views to update
    //
    return m_pFrame->UpdateAllViews(NULL,(LPARAM)pNode, DS_UPDATE_OCCURRED);
  }
}


HRESULT CDSComponentData::_UpdateScopeItem(CUINode* pNode)
{
  ASSERT(pNode->IsContainer());
  SCOPEDATAITEM  tSDItem;
  ZeroMemory(&tSDItem, sizeof(SCOPEDATAITEM));
  tSDItem.mask = SDI_STR;
  tSDItem.displayname = MMC_CALLBACK;
  tSDItem.ID = pNode->GetFolderInfo()->GetScopeItem();
  return m_pScope->SetItem(&tSDItem);
}


HRESULT CDSComponentData::AddClassIcon(IN LPCWSTR lpszClass, IN DWORD dwFlags, INOUT int* pnIndex)
{
  Lock();
  HRESULT hr = m_iconManager.AddClassIcon(lpszClass, GetBasePathsInfo(), dwFlags, pnIndex);
  Unlock();
  return hr;

}

HRESULT CDSComponentData::FillInIconStrip(IImageList* pImageList)
{
  Lock();
  HRESULT hr = m_iconManager.FillInIconStrip(pImageList);
  Unlock();
  return hr;
}

BOOL
CDSComponentData::IsNotHiddenClass (LPWSTR pwszClass, CDSCookie* pParentCookie)
{
  BOOL bApproved = FALSE;
  if (m_CreateInfo.IsEmpty()) 
  {
    return FALSE;
  }

  POSITION pos;
  pos = m_CreateInfo.GetHeadPosition();
  while (pos) 
  {
    if (!m_CreateInfo.GetNext(pos).CompareNoCase(pwszClass)) 
    {
      bApproved = TRUE;
      goto done;
    } 
    else 
    {
      if (   (!wcscmp (pwszClass, L"sitesContainer"))
          || (!wcscmp (pwszClass, L"site"))
          || (!wcscmp (pwszClass, L"siteLink"))
          || (!wcscmp (pwszClass, L"siteLinkBridge"))
          || (!wcscmp (pwszClass, L"licensingSiteSettings"))
          || (!wcscmp (pwszClass, L"nTDSSiteSettings"))
          || (!wcscmp (pwszClass, L"serversContainer"))
          || (!wcscmp (pwszClass, L"server"))
          || (!wcscmp (pwszClass, L"nTDSDSA"))
          || (!wcscmp (pwszClass, L"subnet"))
#ifdef FRS_CREATE
          || (!wcscmp (pwszClass, L"nTDSConnection"))
          || (!wcscmp (pwszClass, L"nTFRSSettings"))
          || (!wcscmp (pwszClass, L"nTFRSReplicaSet"))
          || (!wcscmp (pwszClass, L"nTFRSMember"))
          || (!wcscmp (pwszClass, L"nTFRSSubscriptions"))
          || (!wcscmp (pwszClass, L"nTFRSSubscriber"))
#endif // FRS_CREATE
         ) 
      {
            bApproved = TRUE;
            goto done;
      }
#ifndef FRS_CREATE
      else if ( !wcscmp(pwszClass, L"nTDSConnection"))
      {
        LPCWSTR pwszParentClass = (pParentCookie) ? pParentCookie->GetClass() : L"";
        if ( NULL != pwszParentClass
          && wcscmp(pwszParentClass, L"nTFRSSettings")
          && wcscmp(pwszParentClass, L"nTFRSReplicaSet")
          && wcscmp(pwszParentClass, L"nTFRSMember")
           )
        {
          bApproved = TRUE;
          goto done;
        }
      }
#endif // !FRS_CREATE
    }
  }

done:
  return bApproved;
}

HRESULT
CDSComponentData::FillInChildList(CDSCookie * pCookie)
{
  HRESULT hr = S_OK;
  
  LPWSTR pszClasses = L"allowedChildClassesEffective";
  LONG uBound, lBound;
  UINT index, index2 = 0;
  UINT cChildCount = 0;
  CString Path;
  WCHAR **ppChildren = NULL;
  VARIANT *pNames = NULL;
  WCHAR *pNextFree;

  CComVariant Var;
  CComVariant VarProp;
  CComVariant varHints;

  CComPtr<IADsPropertyList> spDSObject;
   
  GetBasePathsInfo()->ComposeADsIPath(Path, pCookie->GetPath());
  hr = DSAdminOpenObject(Path,
                         IID_IADsPropertyList,
                         (void **)&spDSObject,
                         TRUE /*bServer*/);
  if (FAILED(hr))
  {
    TRACE(_T("Bind to Container for IPropertyList failed: %lx.\n"), hr);
    goto error;
  }
  else
  { 
    CComPtr<IADs> spDSObject2;
    hr = spDSObject->QueryInterface (IID_IADs, (void **)&spDSObject2);
    if (FAILED(hr)) 
    {
      TRACE(_T("QI to Container for IADs failed: %lx.\n"), hr);
      goto error;
    }
    ADsBuildVarArrayStr (&pszClasses, 1, &varHints);
    spDSObject2->GetInfoEx(varHints, 0);
  }

  hr = spDSObject->GetPropertyItem (pszClasses,
                                   ADSTYPE_CASE_IGNORE_STRING,
                                   &VarProp);
  if (!SUCCEEDED(hr)) 
  {
    TRACE(_T("GetPropertyTtem failed: %lx.\n"), hr);
    goto error;
  }

  if (V_VT(&VarProp) == VT_EMPTY) 
  {
    TRACE(_T("GetPropertyTtem return empty VARIANT: vtype is %lx.\n"), V_VT(&VarProp));
    goto error;
  }
  
  { // scope to allow goto's to compile
    IDispatch * pDisp = NULL;
    pDisp = V_DISPATCH(&VarProp);
    CComPtr<IADsPropertyEntry> spPropEntry;
    hr = pDisp->QueryInterface(IID_IADsPropertyEntry, (void **)&spPropEntry);
    hr = spPropEntry->get_Values(&Var);
  }

  hr = SafeArrayGetUBound (V_ARRAY(&Var), 1, &uBound);
  hr = SafeArrayGetLBound (V_ARRAY(&Var), 1, &lBound);

  hr = SafeArrayAccessData(V_ARRAY(&Var),
                           (void **)&pNames);
  if (FAILED(hr)) 
  {
    TRACE(_T("Accessing safearray data failed: %lx.\n"), hr);
    goto error;
  }
  else
  {
    if (uBound >= 0) 
    {
      cChildCount = (UINT) (uBound - lBound);
      ppChildren = (WCHAR **) LocalAlloc (LPTR,
                                          (cChildCount + 1) * STRING_LEN);
      if (ppChildren != NULL)
      {
        pNextFree = (WCHAR*)(ppChildren + cChildCount + 1);
        index2 = 0;
        for (index = lBound; index <= (UINT)uBound; index++) 
        {
          CComPtr<IADsPropertyValue> spEntry;
          hr = (pNames[index].pdispVal)->QueryInterface (IID_IADsPropertyValue,
                                                         (void **)&spEntry);
          if (SUCCEEDED(hr)) 
          {
            CComBSTR bsObject;
            hr = spEntry->get_CaseIgnoreString (&bsObject);
            TRACE(_T("----->allowed object number %d: %s\n"),
                  index, bsObject);
            if (IsNotHiddenClass(bsObject, pCookie)) 
            {
              TRACE(_T("-----------approved.\n"));
              ppChildren[index2] = pNextFree;
              pNextFree += wcslen(bsObject)+ sizeof (WCHAR);
              wcscpy (ppChildren[index2], bsObject);
              index2 ++;
            } // if
          } // if
        } // for
      } // if
    } // if uBound
#ifdef DBG
    else 
    {
      TRACE(_T("--- no classes returned, no creation allowed here.\n"));
    }
#endif
    VERIFY(SUCCEEDED(SafeArrayUnaccessData(V_ARRAY(&Var))));
  }
  
error:
  
  if (index2 != 0) 
  {
    SortChildList (ppChildren, index2);
    pCookie->SetChildList (ppChildren);
  }
  pCookie->SetChildCount (index2);
  
  return hr;
}

// routine to sort the entries for the "Create New" menu
// simple-minded bubble sort; its a small list

BOOL CDSComponentData::SortChildList (LPWSTR *ppszChildList, UINT cChildCount)
{
  LPWSTR Temp;
  BOOL IsSorted = FALSE;

  while (!IsSorted) 
  {
    IsSorted = TRUE;
    // TRACE(_T("At top of while. ready to go again.\n"));
    for (UINT index = 0; index < cChildCount - 1; index++) 
    {
      if (wcscmp (ppszChildList[index], ppszChildList[index + 1]) > 0) 
      {
        Temp = ppszChildList[index];
        ppszChildList[index] = ppszChildList[index + 1];
        ppszChildList[index + 1] = Temp;
        //TRACE(_T("Swapped %s and %ws. still not done.\n"),
        // ppszChildList[index], ppszChildList[index + 1]);
        IsSorted = FALSE;
      }
    }
  }
  return IsSorted;
}

/////////////////////////////////////////////////////////////////////
//	CDSComponentData::_CreateDSObject()
//
//	Create a new ADs object.
//
HRESULT CDSComponentData::_CreateDSObject(CDSUINode* pContainerDSUINode, // IN: container where to create object
                                         LPCWSTR lpszObjectClass, // IN: class of the object to be created
                                         IN CDSUINode* pCopyFromDSUINode, // IN: (optional) object to be copied
                                         OUT CDSUINode** ppSUINodeNew)	// OUT: OPTIONAL: Pointer to new node
{
  CDSCookie* pNewCookie = NULL;
  HRESULT hr = GetActiveDS()->CreateDSObject(pContainerDSUINode,
                                             lpszObjectClass,
                                             pCopyFromDSUINode,
                                             &pNewCookie);

  if (SUCCEEDED(hr) && (hr != S_FALSE) && (pNewCookie != NULL))
  {
    // make sure we update the icon cache
    m_pFrame->UpdateAllViews(/*unused*/NULL /*pDataObj*/, /*unused*/(LPARAM)0, DS_ICON_STRIP_UPDATE);

    // create a UI node to hold the cookie
    *ppSUINodeNew = new CDSUINode(NULL);
    (*ppSUINodeNew)->SetCookie(pNewCookie);
    if (pNewCookie->IsContainerClass())
    {
      (*ppSUINodeNew)->MakeContainer();
    }

    // Add the new node to the link list
    pContainerDSUINode->GetFolderInfo()->AddNode(*ppSUINodeNew);
    if ((*ppSUINodeNew)->IsContainer())
    {
      //
      // Add the scope item and select it
      //
      _AddScopeItem(*ppSUINodeNew, pContainerDSUINode->GetFolderInfo()->GetScopeItem(), TRUE);
      *ppSUINodeNew = NULL;
    }
  }
  return hr;
} 



//
// return S_OK if can copy, S_FALSE if not, some hr error if failed
//
HRESULT CDSComponentData::_CanCopyDSObject(IDataObject* pCopyFromDsObject)
{
  if (pCopyFromDsObject == NULL)
  {
    return E_INVALIDARG;
  }
  
  CInternalFormatCracker internalFormat;
  HRESULT hr = internalFormat.Extract(pCopyFromDsObject);
  if (FAILED(hr))
  {
    return hr;
  }

  if (!internalFormat.HasData() || (internalFormat.GetCookieCount() != 1))
  {
    return E_INVALIDARG;
  }

  //
  // Get the node data
  //
  CUINode* pUINode = internalFormat.GetCookie();
  CDSCookie* pCopyFromDsCookie = NULL;
  if (IS_CLASS(*pUINode, CDSUINode))
  {
    pCopyFromDsCookie = GetDSCookieFromUINode(pUINode);
  }

  if (pCopyFromDsCookie == NULL)
  {
    return E_INVALIDARG;
  }

  //
  // get the parent node data
  //
  CUINode* pParentUINode = pUINode->GetParent();
  CDSCookie* pContainerDsCookie = NULL;
  if (IS_CLASS(*pParentUINode, CDSUINode))
  {
    pContainerDsCookie = GetDSCookieFromUINode(pParentUINode);
  }

  if (pContainerDsCookie == NULL)
  {
    return E_INVALIDARG;
  }

  //
  // get the class to be created
  //
  LPCWSTR lpszObjectClass = pCopyFromDsCookie->GetClass();

  //
  // try to find the class in the possible child classes of the container
  //
  WCHAR ** ppChildren = pContainerDsCookie->GetChildList();
  if (ppChildren == NULL)
  {
    FillInChildList(pContainerDsCookie);
    ppChildren = pContainerDsCookie->GetChildList();
  }

  //
  // loop trough the class list to find a match
  //
  int cChildCount = pContainerDsCookie->GetChildCount();
  for (int index = 0; index < cChildCount; index++) 
  {
    if (wcscmp(pContainerDsCookie->GetChildListEntry(index), lpszObjectClass) == 0)
    {
      return S_OK; // got one, can create
    }
  }
  return S_FALSE; // not found, cannot create
}



HRESULT CDSComponentData::_CopyDSObject(IDataObject* pCopyFromDsObject) // IN object to be copied
{
  if (pCopyFromDsObject == NULL)
    return E_INVALIDARG;
  
  CInternalFormatCracker internalFormat;
  HRESULT hr = internalFormat.Extract(pCopyFromDsObject);
  if (FAILED(hr))
  {
    return hr;
  }

  if (!internalFormat.HasData() || (internalFormat.GetCookieCount() != 1))
  {
    return E_INVALIDARG;
  }

  CUINode* pCopyFromUINode = internalFormat.GetCookie();
  ASSERT(pCopyFromUINode != NULL);

  // can do this for DS objects only
  CDSUINode* pCopyFromDSUINode = dynamic_cast<CDSUINode*>(pCopyFromUINode);
  if (pCopyFromDSUINode == NULL)
  {
    ASSERT(FALSE); // should never happen
    return E_INVALIDARG;
  }

  // get the parent cookie
  CDSUINode* pContainerDSUINode = dynamic_cast<CDSUINode*>(pCopyFromDSUINode->GetParent());
  if(pContainerDSUINode == NULL)
  {
    ASSERT(FALSE); // should never happen
    return E_INVALIDARG;
  }

  // get the class to be created
  LPCWSTR lpszObjectClass = pCopyFromDSUINode->GetCookie()->GetClass();

  // call the object creation code
  CDSUINode* pNewDSUINode = NULL;
  hr = _CreateDSObject(pContainerDSUINode, lpszObjectClass, pCopyFromDSUINode, &pNewDSUINode);


  // update if result pane item
  // (if it were a scope item, _CreateDSObject() would update it
  if (SUCCEEDED(hr) && (hr != S_FALSE) && (pNewDSUINode != NULL)) 
  {
    m_pFrame->UpdateAllViews(pCopyFromDsObject, (LPARAM)pNewDSUINode, DS_CREATE_OCCURRED_RESULT_PANE);
    m_pFrame->UpdateAllViews(NULL, (LPARAM)pCopyFromDSUINode, DS_UNSELECT_OBJECT);
  }

  return S_OK;
}



HRESULT
CDSComponentData::_DeleteFromBackendAndUI(IDataObject* pDataObject, CDSUINode* pDSUINode)
{
  HRESULT hr = S_OK;
  ASSERT(pDSUINode != NULL);
  ASSERT(pDSUINode->IsContainer());

  // guard against property sheet open on this cookie
  if (_WarningOnSheetsUp(pDSUINode))
    return S_OK; 

  CWaitCursor cwait;
  
  // this call will handle the notifications to extensions
  CDSCookie* pCookie = GetDSCookieFromUINode(pDSUINode);
  hr = _DeleteFromBackEnd(pDataObject, pCookie);

  // if deletion happened, delete the scope item from the UI
  if (SUCCEEDED(hr) && (hr != S_FALSE)) 
  {
    hr = RemoveContainerFromUI(pDSUINode);
    delete pDSUINode;
  } 
  return S_OK;
}

HRESULT CDSComponentData::RemoveContainerFromUI(CUINode* pUINode)
{
  HRESULT hr = S_OK;
  ASSERT(pUINode->IsContainer());

  HSCOPEITEM ItemID, ParentItemID;
  ItemID = pUINode->GetFolderInfo()->GetScopeItem();
  CUINode* pParentNode = NULL;
  hr = m_pScope->GetParentItem(ItemID, &ParentItemID, 
                                (MMC_COOKIE *)&pParentNode);
  m_pScope->DeleteItem(ItemID, TRUE);
  if (SUCCEEDED(hr)) 
  {
    ASSERT(pParentNode->IsContainer());
    // delete memory 
    pParentNode->GetFolderInfo()->RemoveNode(pUINode);
  }
  m_pFrame->UpdateAllViews(NULL, NULL, DS_UPDATE_OBJECT_COUNT);

  //
  // Remove the '+' sign in the UI if this was the last container child in this container
  //
  if (pParentNode != NULL &&
      ParentItemID != 0 &&
      pParentNode->GetFolderInfo()->GetContainerList()->GetCount() == 0)
  {
    SCOPEDATAITEM sdi;
    memset(&sdi, 0, sizeof(SCOPEDATAITEM));

    sdi.ID = ParentItemID;
    sdi.mask |= SDI_CHILDREN;
    sdi.cChildren = 0;

    hr = m_pScope->SetItem(&sdi);
  }

  return hr;
}
///////////////////////////////////////////////////////////////////////////
// CSnapinSingleDeleteHandler

class CSnapinSingleDeleteHandler : public CSingleDeleteHandlerBase
{
public:
  CSnapinSingleDeleteHandler(CDSComponentData* pComponentData, HWND hwnd,
                                  CDSCookie* pCookie)
                              : CSingleDeleteHandlerBase(pComponentData, hwnd)
  {
    m_pCookie = pCookie;
    GetComponentData()->GetBasePathsInfo()->ComposeADsIPath(
        m_strItemPath, m_pCookie->GetPath());
  }

protected:
  CDSCookie* m_pCookie;
  CString m_strItemPath;

  virtual HRESULT BeginTransaction()
  {
    return GetTransaction()->Begin(m_pCookie, NULL, NULL, FALSE);
  }
  virtual HRESULT DeleteObject()
  {
    return GetComponentData()->GetActiveDS()->DeleteObject(m_pCookie ,FALSE);
  }
  virtual HRESULT DeleteSubtree()
  {
    return GetComponentData()->_DeleteSubtreeFromBackEnd(m_pCookie);
  }
  virtual void GetItemName(OUT CString& szName){ szName = m_pCookie->GetName(); }
  virtual LPCWSTR GetItemClass(){ return m_pCookie->GetClass(); }
  virtual LPCWSTR GetItemPath(){ return m_strItemPath; }

};

/*
NOTICE: the function will return S_OK on success, S_FALSE if aborted
        by user, some FAILED(hr) otherwise
*/
HRESULT CDSComponentData::_DeleteFromBackEnd(IDataObject*, CDSCookie* pCookie)
{
  ASSERT(pCookie != NULL);
  CSnapinSingleDeleteHandler deleteHandler(this, m_hwnd, pCookie);
  return deleteHandler.Delete();
}


HRESULT
CDSComponentData::_DeleteSubtreeFromBackEnd(CDSCookie* pCookie)
{

  HRESULT hr = S_OK;
  CComPtr<IADsDeleteOps> spObj;

  CString szPath;
  GetBasePathsInfo()->ComposeADsIPath(szPath, pCookie->GetPath());
  hr = DSAdminOpenObject(szPath,
                         IID_IADsDeleteOps, 
                         (void **)&spObj,
                         TRUE /*bServer*/);
  if (SUCCEEDED(hr)) 
  {
    hr = spObj->DeleteObject(NULL); //flag is reserved by ADSI
  }
  return hr;
}


HRESULT CDSComponentData::_Rename(CUINode* pUINode, LPWSTR NewName)
{
  //
  // Verify parameters
  //
  if (pUINode == NULL || NewName == NULL)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  CWaitCursor cwait;
  HRESULT hr = S_OK;
  CDSCookie* pCookie = NULL;
  CString szPath;

  //
  // guard against property sheet open on this cookie
  //
  if (_WarningOnSheetsUp(pUINode))
  {
    return E_FAIL; 
  }

  if (pUINode->IsSheetLocked()) 
  {
    ReportErrorEx (m_hwnd,IDS_SHEETS_UP_RENAME,hr,
                   MB_OK | MB_ICONINFORMATION, NULL, 0);
    return hr;
  }

  if (IS_CLASS(*pUINode, CDSUINode))
  {
    pCookie = GetDSCookieFromUINode(pUINode);
  
    if (pCookie == NULL)
    {
      return E_FAIL;
    }

    CDSRenameObject* pRenameObject = NULL;
    CString strClass = pCookie->GetClass();
    CString szDN = pCookie->GetPath();
    GetBasePathsInfo()->ComposeADsIPath(szPath, szDN);

    //
    // Rename user object
    //
    if (strClass == L"user"
#ifdef INETORGPERSON
        || strClass == L"inetOrgPerson"
#endif
        ) 
    {
      //
      // Rename user
      //
      pRenameObject = new CDSRenameUser(pUINode, pCookie, NewName, m_hwnd, this);
    } 
    else if (strClass == L"group") 
    {
      //
      // Rename group
      //
      pRenameObject = new CDSRenameGroup(pUINode, pCookie, NewName, m_hwnd, this);
    } 
    else if (strClass == L"contact") 
    {
      // 
      // rename contact
      //
      pRenameObject = new CDSRenameContact(pUINode, pCookie, NewName, m_hwnd, this);
    }
    else if (strClass == L"site") 
    {
      //
      // Rename site
      //
      pRenameObject = new CDSRenameSite(pUINode, pCookie, NewName, m_hwnd, this);
    } 
    else if (strClass == L"subnet") 
    {
      //
      // Rename subnet
      //
      pRenameObject = new CDSRenameSubnet(pUINode, pCookie, NewName, m_hwnd, this);
    } 
    else if (strClass == L"nTDSConnection") 
    {
      //
      // Rename nTDSConnection
      //
      pRenameObject = new CDSRenameNTDSConnection(pUINode, pCookie, NewName, m_hwnd, this);
    } 
    else 
    {
      //
      // Rename other object
      //
      pRenameObject = new CDSRenameObject(pUINode, pCookie, NewName, m_hwnd, this);
    }    

    if (pRenameObject != NULL)
    {
      hr = pRenameObject->DoRename();
    }
    else
    {
      hr = E_FAIL;
    }
  } 
  else // !CDSUINode
  {
    hr = pUINode->Rename(NewName, this);
  }

  if (SUCCEEDED(hr) && !szPath.IsEmpty())
  {
    CStringList pathList;
    pathList.AddTail(szPath);
    InvalidateSavedQueriesContainingObjects(pathList);
  }
  return hr;
}

void CDSComponentData::ClearSubtreeHelperForRename(CUINode* pUINode)
{
  //
  // Verify parameters
  //
  if (pUINode == NULL)
  {
    ASSERT(FALSE);
    return;
  }

  HSCOPEITEM ItemID;
  CUIFolderInfo* pFolderInfo = NULL;

  pFolderInfo = pUINode->GetFolderInfo();

  if (pFolderInfo != NULL)
  {
    //
    // remove the folder subtree in the UI
    //
    ItemID = pFolderInfo->GetScopeItem();
    m_pScope->DeleteItem(ItemID, /* this node*/FALSE);
  
    //
    // clear list of children
    //
    pFolderInfo->DeleteAllLeafNodes();
    pFolderInfo->DeleteAllContainerNodes();
  
    //
    // remove the descendants from the pending query table
    //
    m_queryNodeTable.RemoveDescendants(pUINode);
    pFolderInfo->ReSetExpanded();

    // make sure MMC knows the + sign should show

    SCOPEDATAITEM scopeItem;
    ZeroMemory(&scopeItem, sizeof(SCOPEDATAITEM));

    scopeItem.ID = ItemID;
    scopeItem.mask = SDI_CHILDREN;
    scopeItem.cChildren = 1;

    m_pScope->SetItem(&scopeItem);
  }

}

CUINode* CDSComponentData::MoveObjectInUI(CDSUINode* pDSUINode)
{
  CUINode* pParentUINode = pDSUINode->GetParent();
  HSCOPEITEM ParentItemID = NULL;
  HRESULT hr = S_OK;
  ASSERT(pParentUINode != NULL && pParentUINode->IsContainer());

  //
  // find the new parent node
  //
  CUINode* pNewParentNode = NULL;
  hr = FindParentCookie(pDSUINode->GetCookie()->GetPath(), &pNewParentNode);

  if (pDSUINode->IsContainer())
  {
    HSCOPEITEM ItemID = pDSUINode->GetFolderInfo()->GetScopeItem();

    hr = m_pScope->GetParentItem(ItemID, &ParentItemID, (MMC_COOKIE *)&pParentUINode);
    //
    // remove node from MMC
    //
    m_pScope->DeleteItem(ItemID, TRUE);
    if (SUCCEEDED(hr)) 
    {
      //
      // remove it from the list of children
      //
      pParentUINode->GetFolderInfo()->RemoveNode(pDSUINode);
    }

    if ((hr == S_OK) && pNewParentNode && pNewParentNode->GetFolderInfo()->IsExpanded()) 
    {
      //
      // add to new child list
      //
      pDSUINode->ClearParent();
      if (pNewParentNode != NULL)
      {
        pNewParentNode->GetFolderInfo()->AddNode(pDSUINode);

        //
        // add to MMC scope pane
        //
        _AddScopeItem(pDSUINode, pNewParentNode->GetFolderInfo()->GetScopeItem());
      }
    }
    else 
    {
      // will get it later on when enumerating
      delete pDSUINode;
    }
  }
  else // leaf node
  {
    if ((pNewParentNode) &&
        (pNewParentNode->GetFolderInfo()->IsExpanded())) 
    {
      pDSUINode->ClearParent();
      pNewParentNode->GetFolderInfo()->AddNode(pDSUINode);
    }
    m_pFrame->UpdateAllViews(NULL, (LPARAM)pDSUINode, DS_MOVE_OCCURRED);
  }

  return pNewParentNode;
}


HRESULT CDSComponentData::_MoveObject(CDSUINode* pDSUINode)
{
  // guard against property sheet open on this cookie
  if (_WarningOnSheetsUp(pDSUINode))
    return S_OK; 

  CWaitCursor cwait;

  // call the backend to do the delete
  HRESULT hr = m_ActiveDS->MoveObject(pDSUINode->GetCookie());

  if (SUCCEEDED(hr) && (hr != S_FALSE)) 
  {
    // we actually moved the object, move in the folders and MMC
    CUINode* pNewParentNode = MoveObjectInUI(pDSUINode);
    if (pNewParentNode && pNewParentNode->GetFolderInfo()->IsExpanded())
    {
      Refresh(pNewParentNode);
    }
  }
  return hr;
}

HRESULT CDSComponentData::Refresh(CUINode* pNode, BOOL bFlushCache, BOOL bFlushColumns)
{
  HRESULT hr = S_OK;
  

  TRACE(_T("CDSComponentData::Refresh: cookie is %s\n"),
        pNode->GetName());

  if (m_queryNodeTable.IsLocked(pNode))
  {
    // this might happen if MMC's verb management bent out of shape (BUG?)
    // like in the case of the "*" (num keypad) command (expand the whole tree)
    // just ignore the command
    return S_OK;
  }

  if (_WarningOnSheetsUp(pNode))
    return hr;
  
  if ((pNode == &m_RootNode) && !m_InitSuccess) 
  {
    hr = _InitRootFromCurrentTargetInfo();
    if (FAILED(hr)) 
    {
      m_InitSuccess = FALSE;
      TRACE(_T("in Refresh, set m_InitSuccess to false\n"));
      return hr;
    }
    else 
    {
      m_InitSuccess = TRUE;
      TRACE(_T("in Refresh, set m_InitSuccess to true\n"));
    }
  }


  // remove the folder subtree in the UI
  HSCOPEITEM ItemID = NULL;
  if (pNode->IsContainer())
  {
    ItemID = pNode->GetFolderInfo()->GetScopeItem();
  }
  if (ItemID == NULL) 
  {
    // let's try the parent
    CUINode* pParent = pNode->GetParent();
    ASSERT(pParent != NULL);
    ASSERT(pParent->IsContainer());
    ItemID = pParent->GetFolderInfo()->GetScopeItem();
    if (ItemID == NULL) 
    {
      return S_OK;
    }
    else 
    {
      pNode = pParent;
    }
  }

  m_pScope->DeleteItem(ItemID, /* this node*/FALSE);

  // delete result pane items in the UI
  TIMER(_T("calling update all views..."));
  m_pFrame->UpdateAllViews(NULL, (LPARAM)pNode, DS_REFRESH_REQUESTED);

  // clear list of children
  TIMER(_T("back from UpdateAllViews.\ncleaning up data structs..."));

  if (pNode == &m_RootNode)
  {
    if (m_pFavoritesNodesHolder != NULL)
    {
      // do not remove the favorites, just detach them from tree
      m_RootNode.GetFolderInfo()->RemoveNode(m_pFavoritesNodesHolder->GetFavoritesRoot());
      m_pFavoritesNodesHolder->GetFavoritesRoot()->ClearParent();
      m_pFavoritesNodesHolder->GetFavoritesRoot()->GetFolderInfo()->ReSetExpanded();

      // clean up all the query folders, but otherwise leave the 
      // subtree intact
      m_pFavoritesNodesHolder->GetFavoritesRoot()->RemoveQueryResults();
    }

    // remove the remaining folders
    m_RootNode.GetFolderInfo()->DeleteAllLeafNodes();
    m_RootNode.GetFolderInfo()->DeleteAllContainerNodes();

    if (m_pFavoritesNodesHolder != NULL)
    {
      // re-attach the favorites underneath the root
      m_RootNode.GetFolderInfo()->AddNode(m_pFavoritesNodesHolder->GetFavoritesRoot());

      // add the favorite queries subtree
      _AddScopeItem(m_pFavoritesNodesHolder->GetFavoritesRoot(), 
                    m_RootNode.GetFolderInfo()->GetScopeItem());
    }
  }
  else if (IS_CLASS(*pNode, CFavoritesNode))
  {
    // recurse down to other query folders to do cleanup
    dynamic_cast<CFavoritesNode*>(pNode)->RemoveQueryResults();

    // just add the favorites subfolders and query folders
    CUINodeList* pNodeList = pNode->GetFolderInfo()->GetContainerList();
    for (POSITION pos = pNodeList->GetHeadPosition(); pos != NULL; )
    {
      CUINode* pCurrChildNode = pNodeList->GetNext(pos);
      _AddScopeItem(pCurrChildNode, 
                    pNode->GetFolderInfo()->GetScopeItem());
    }
  }
  else if (IS_CLASS(*pNode, CSavedQueryNode))
  {
    pNode->GetFolderInfo()->DeleteAllLeafNodes();
    pNode->GetFolderInfo()->DeleteAllContainerNodes();
    dynamic_cast<CSavedQueryNode*>(pNode)->SetValid(TRUE);
  }
  else
  {
    ASSERT(IS_CLASS(*pNode, CDSUINode) );

    // standard DS container, just remove all sub objects
    pNode->GetFolderInfo()->DeleteAllLeafNodes();
    pNode->GetFolderInfo()->DeleteAllContainerNodes();
  }

  TIMER(_T("datastructs cleaned up\n"));

  // remove the descendants from the pending query table
  m_queryNodeTable.RemoveDescendants(pNode);

  if ((pNode == &m_RootNode) && bFlushCache)
  {
    TRACE(L"CDSComponentData::Refresh: flushing the cache\n");
    m_pClassCache->Initialize(QuerySnapinType(), GetBasePathsInfo(), bFlushColumns);
  }

  // post a query
  TRACE(L"CDSComponentData::Refresh: posting query\n");
  _PostQueryToBackgroundThread(pNode);
  TRACE(L"CDSComponentData::Refresh: returning\n");

  return hr;
}


#if (FALSE)

HRESULT CDSComponentData::_OnPropertyChange(LPDATAOBJECT pDataObject, BOOL bScope)
{
  if (pDataObject == NULL)
  {
    return E_INVALIDARG;
  }

  CInternalFormatCracker dobjCracker;
  VERIFY(SUCCEEDED(dobjCracker.Extract(pDataObject)));

  CDSCookie* pCookie = NULL;
  CUINode* pUINode = dobjCracker.GetCookie();
  if (pUINode == NULL)
  {
    return E_INVALIDARG;
  }

  //
  // Right now we are not supporting properties on other node types
  //
  if (IS_CLASS(*pUINode, CDSUINode))
  {
    pCookie = GetDSCookieFromUINode(pUINode);
  }

  if (pCookie == NULL)
  {
    // not a DS object
    return S_OK;
  }
  {
    //
    // notify the extension that an object has changed
    //
    CDSNotifyHandlerTransaction transaction(this);
    transaction.SetEventType(DSA_NOTIFY_PROP);
    transaction.Begin(pDataObject, NULL, NULL, FALSE);

    //
    // we do not call Confirm() because this is an asynchrnous call after the fact
    //
    transaction.Notify(0);
    transaction.End();
  }

  //
  // update the data to be displayed
  //

  //
  // update all the possible instances in the query namespace
  //
  if (m_pFavoritesNodesHolder != NULL)
  {
    // find the list of items to update
    CUINodeList queryNamespaceNodeList;
    m_pFavoritesNodesHolder->GetFavoritesRoot()->FindCookiesInQueries(pCookie->GetPath(), &queryNamespaceNodeList);

    // update all of them
    for (POSITION pos = queryNamespaceNodeList.GetHeadPosition(); pos != NULL; )
    {
      CUINode* pCurrUINode = queryNamespaceNodeList.GetNext(pos);
      HRESULT hrCurr = UpdateFromDS(pCurrUINode);
      if (SUCCEEDED(hrCurr))
      {
        UpdateItem(pCurrUINode);
      }
    }
  }

  //
  // figure out if the notification cookie is in the query namespace or
  // in the DS one
  //
  BOOL bNodeFromQueryNamespace = IS_CLASS(*(pUINode->GetParent()), CSavedQueryNode);
  CUINode* pUINodeToUpdate = NULL;
  if (bNodeFromQueryNamespace)
  {
    // find the item 
    FindCookieInSubtree(&m_RootNode, pCookie->GetPath(), QuerySnapinType(), &pUINodeToUpdate);
  }
  else
  {
    pUINodeToUpdate = pUINode;
  }

  if (pUINodeToUpdate != NULL)
  {
    HRESULT hr = UpdateFromDS(pUINodeToUpdate);
    if (SUCCEEDED(hr))
    {
      return UpdateItem(pUINodeToUpdate);
    }
  }

  return S_OK;
}

#endif

HRESULT CDSComponentData::_OnPropertyChange(LPDATAOBJECT pDataObject, BOOL)
{
  if (pDataObject == NULL)
  {
    return E_INVALIDARG;
  }

  CInternalFormatCracker ifc;
  if (FAILED(ifc.Extract(pDataObject)))
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  CUINode* pUINode = ifc.GetCookie();
  if (pUINode != NULL)
  {
    if (!IS_CLASS(*pUINode, CDSUINode))
    {
      UpdateItem(pUINode);
      return S_OK;
    }
  }


  CObjectNamesFormatCracker objectNamesFormatCracker;
  if (FAILED(objectNamesFormatCracker.Extract(pDataObject)))
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  {
    //
    // notify the extension that an object has changed
    //
    CDSNotifyHandlerTransaction transaction(this);
    transaction.SetEventType(DSA_NOTIFY_PROP);
    transaction.Begin(pDataObject, NULL, NULL, FALSE);

    //
    // we do not call Confirm() because this is an asynchrnous call after the fact
    //
    transaction.Notify(0);
    transaction.End();
  }

  for (UINT idx = 0; idx < objectNamesFormatCracker.GetCount(); idx ++)
  {
    //
    // update the data to be displayed, need the DN out of the ADSI path
    //
    CComBSTR bstrDN;
    CPathCracker pathCracker;
    pathCracker.Set((LPWSTR)objectNamesFormatCracker.GetName(idx), ADS_SETTYPE_FULL);
    pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bstrDN);


    //
    // update all the possible instances in the query namespace
    //
    if (m_pFavoritesNodesHolder != NULL)
    {
      // find the list of items to update
      CUINodeList queryNamespaceNodeList;
      m_pFavoritesNodesHolder->GetFavoritesRoot()->FindCookiesInQueries(bstrDN, &queryNamespaceNodeList);

      // update all of them
      for (POSITION pos = queryNamespaceNodeList.GetHeadPosition(); pos != NULL; )
      {
        CUINode* pCurrUINode = queryNamespaceNodeList.GetNext(pos);
        HRESULT hrCurr = UpdateFromDS(pCurrUINode);
        if (SUCCEEDED(hrCurr))
        {
          UpdateItem(pCurrUINode);
        }
      }
    }

    //
    // find node in the DS namespace and update it
    //

    CUINode* pUINodeToUpdate = NULL;
    // find the item 
    FindCookieInSubtree(&m_RootNode, bstrDN, QuerySnapinType(), &pUINodeToUpdate);
    if (pUINodeToUpdate != NULL)
    {
      HRESULT hr = UpdateFromDS(pUINodeToUpdate);
      if (SUCCEEDED(hr))
      {
        UpdateItem(pUINodeToUpdate);
      }
    }
  }
  return S_OK;
}

/* ---------------------------------------------------------

  Helper function to create an LDAP query string to retrieve
  a single element inside a given container.

  Input: the DN of the object to query for.
         e.g.: "cn=foo,ou=bar,dc=mydom,dc=com"
  Output: a query string containing the leaf node properly escaped,
          (as per RFC 2254)
         e.g.: "(cn=foo)"

  NOTES:
  * we do not deal with embedded NULLs (we have regular C/C++ strings)
  * any \ character remaining after the path cracked full unescaping
    has to be escaped along the other special characters by
    using the \HexHex sequences.
------------------------------------------------------------*/

HRESULT _CreateLdapQueryFilterStringFromDN(IN LPCWSTR lpszDN, 
                                           OUT CString& szQueryString)
{
  szQueryString.Empty();
  
  CPathCracker pathCracker;

  // remove any LDAP/ADSI escaping from the DN
  pathCracker.Set((LPWSTR)lpszDN, ADS_SETTYPE_DN);
  pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);

  // retrieve the leaf element
  CString szNewElement;
  CComBSTR bstrLeafElement;
  HRESULT hr = pathCracker.GetElement(0, &bstrLeafElement);
  if (FAILED(hr))
  {
    return hr;
  }

  LPCWSTR lpszTemp = bstrLeafElement;
  TRACE(L"bstrLeafElement = %s\n", lpszTemp);

  // do LDAP escaping (as per RFC 2254)
  szQueryString = L"(";
  for (WCHAR* pChar = bstrLeafElement; (*pChar) != NULL; pChar++)
  {
    switch (*pChar)
    {
    case L'*':
      szQueryString += L"\\2a";
      break;
    case L'(':
      szQueryString += L"\\28";
      break;
    case L')':
      szQueryString += L"\\29";
      break;
    case L'\\':
      szQueryString += L"\\5c";
      break;
    default:
      szQueryString += (*pChar);
    } // switch
  } // for
    
  // finish wrapping with parentheses,
  // to get something like "(cn=foo)"
  szQueryString += L")";

  return S_OK;
}



HRESULT CDSComponentData::UpdateFromDS(CUINode* pUINode)
{
  ASSERT(pUINode != NULL);

  //
  // get the node data
  //
  CDSCookie* pCookie = NULL;
  if (IS_CLASS(*pUINode, CDSUINode))
  {
    pCookie = GetDSCookieFromUINode(pUINode);
  }

  if (pCookie == NULL)
  {
    ASSERT(FALSE); // should never happen
    return E_FAIL;
  }

  //
  // get the container node
  //
  CUINode* pParentUINode = pUINode->GetParent();
  ASSERT(pParentUINode != NULL);

  //
  // get the distinguished name of the parent by using the path in the cookie
  // and removing the leaf element using the path cracker.
  // e.g., given a DN "cn=x,ou=foo,...", the parent DN will be "ou=foo,..."
  //
  CComBSTR bstrParentDN;
  CPathCracker pathCracker;

  HRESULT hr = pathCracker.Set((LPWSTR)pCookie->GetPath(), ADS_SETTYPE_DN);
  ASSERT(SUCCEEDED(hr));
  
  if (pParentUINode != GetRootNode())
  {
    hr = pathCracker.RemoveLeafElement();
    ASSERT(SUCCEEDED(hr));
  }

  hr = pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bstrParentDN);
  ASSERT(SUCCEEDED(hr));

  //
  // get the LDAP path of the parent
  //
  CString szParentLdapPath;
  GetBasePathsInfo()->ComposeADsIPath(szParentLdapPath, bstrParentDN);

  //
  // find a matching column set
  //
  CDSColumnSet* pColumnSet = pParentUINode->GetColumnSet(this);
  if (pColumnSet == NULL)
  {
    return hr;
  }

  //
  // create a search object and init it
  //
  CDSSearch ContainerSrch(m_pClassCache, this);
  
  TRACE(L"ContainerSrch.Init(%s)\n", (LPCWSTR)szParentLdapPath);

  hr = ContainerSrch.Init(szParentLdapPath);
  if (FAILED(hr))
  {
    return hr;
  }

  //
  // create a query string to look for the naming attribute
  // eg, given a DN "cn=x,ou=foo,..." the search string
  // will look like "(cn=x)"
  //
  CString szQueryString;
  hr = _CreateLdapQueryFilterStringFromDN(pCookie->GetPath(), szQueryString);
  if (FAILED(hr)) 
  {
    return hr;
  }

  TRACE(L"szQueryString = %s\n", (LPCWSTR)szQueryString);

  ContainerSrch.SetAttributeListForContainerClass(pColumnSet);
  ContainerSrch.SetFilterString((LPWSTR)(LPCWSTR)szQueryString);

  if (pParentUINode == GetRootNode())
  {
    ContainerSrch.SetSearchScope(ADS_SCOPE_BASE);
  }
  else
  {
    ContainerSrch.SetSearchScope(ADS_SCOPE_ONELEVEL);
  }
  hr = ContainerSrch.DoQuery();
  if (FAILED(hr)) 
  {
    return hr;
  }

  //
  // get the only row
  //
  hr = ContainerSrch.GetNextRow();
  if (hr == S_ADS_NOMORE_ROWS)
  {
    hr = E_INVALIDARG;
  }
  if (FAILED(hr))
  {
    return hr;
  }
  
  //
  // update the cookie itself
  //
  hr = ContainerSrch.SetCookieFromData(pCookie, pColumnSet);

  //
  // special case if it is a domain DNS object,
  // we want fo get the canonical name for display
  //
  if (wcscmp(pCookie->GetClass(), L"domainDNS") == 0) 
  {
    ADS_SEARCH_COLUMN Column;
    CString csCanonicalName;
    int slashLocation;
    LPWSTR canonicalNameAttrib = L"canonicalName";
    ContainerSrch.SetAttributeList (&canonicalNameAttrib, 1);
    
    hr = ContainerSrch.DoQuery();
    if (FAILED(hr))
    {
      return hr;
    }

    hr = ContainerSrch.GetNextRow();
    if (FAILED(hr))
    {
      return hr;
    }

    hr = ContainerSrch.GetColumn(canonicalNameAttrib, &Column);
    if (FAILED(hr))
    {
      return hr;
    }

    ColumnExtractString (csCanonicalName, pCookie, &Column);
    slashLocation = csCanonicalName.Find('/');
    if (slashLocation != 0) 
    {
      csCanonicalName = csCanonicalName.Left(slashLocation);
    }
    pCookie->SetName(csCanonicalName);
    TRACE(L"canonical name pCookie->GetName() = %s\n", pCookie->GetName());
    
    //
    // Free column data
    //
    ContainerSrch.FreeColumn(&Column);
  }

  return hr;
}


BOOL CDSComponentData::CanRefreshAll()
{
  return !_WarningOnSheetsUp(&m_RootNode);
}


void CDSComponentData::RefreshAll()
{
  ASSERT(!m_RootNode.IsSheetLocked());

  // need to refresh the tree (all containers below the root)
  CUINodeList* pContainerNodeList = m_RootNode.GetFolderInfo()->GetContainerList();
  for (POSITION pos = pContainerNodeList->GetHeadPosition(); pos != NULL; )
  {
    CUINode* pNode = pContainerNodeList->GetNext(pos);
    ASSERT(pNode->IsContainer());
	  if (pNode->GetFolderInfo()->IsExpanded())
    {
		  Refresh(pNode);
    }
  }
}

void CDSComponentData::ClearClassCacheAndRefreshRoot()
{
  ASSERT(!m_RootNode.IsSheetLocked());
  if (m_RootNode.GetFolderInfo()->IsExpanded())
  {
	  Refresh(&m_RootNode, TRUE /*bFlushCache*/, FALSE );
  }
}




// REVIEW_MARCOC_PORT: this function is not going to work with
// items that are of different types. Need to generalize as see fit.

BOOL _SearchList(CUINodeList* pContainers,
                               LPCWSTR lpszParentDN,
                               CUINode** ppParentUINode)
{

  for (POSITION pos = pContainers->GetHeadPosition(); pos != NULL; )
  {
    CUINode* pCurrentNode = pContainers->GetNext(pos);
    ASSERT(pCurrentNode->IsContainer());

    if (!IS_CLASS(*pCurrentNode, CDSUINode))
    {
      // not a node with a cookie, just skip
      continue;
    }

    /* is this the right cookie? */
    CDSCookie* pCurrentCookie = GetDSCookieFromUINode(pCurrentNode);
    LPCWSTR lpszCurrentPath = pCurrentCookie->GetPath();
    TRACE (_T("--SearchList: Looking at: %s\n"), lpszCurrentPath);
    if (_wcsicmp(lpszCurrentPath, lpszParentDN) == 0)
    {
      TRACE (_T("--SearchList: Found it!\n"));
      *ppParentUINode = pCurrentNode;
      return TRUE; // got it!!!
    }
    else 
    {
      TRACE (L"--SearchList: not found...\n");
      TRACE (_T("-- going down the tree: %s\n"), lpszCurrentPath);
      CUINodeList* pSubContainers = pCurrentNode->GetFolderInfo()->GetContainerList();
      if (_SearchList(pSubContainers, lpszParentDN, ppParentUINode))
      {
        return TRUE; // got it!!!
      }
    }
  } // for

  return FALSE; // not found
}

/*
  given a cookie, find the cookie corresponding to its
  parent node, if it exists. this is an expensive operation

  this is used for figuring out where to refresh after having
  moved an object. we know the new path to the object, but have
  no idea where or if that parent cookie exists in the tree.

  HUNT IT DOWN!!
  */
HRESULT
CDSComponentData::FindParentCookie(LPCWSTR lpszCookieDN, CUINode** ppParentUINode)
{
  // init outout variable
  *ppParentUINode = NULL;

  // bind to the ADSI aobject
  CString szPath; 
  GetBasePathsInfo()->ComposeADsIPath(szPath, lpszCookieDN);
  CComPtr<IADs> spDSObj;
  HRESULT hr = DSAdminOpenObject(szPath,
                                 IID_IADs,
                                 (void **)&spDSObj,
                                 TRUE /*bServer*/);
  if (FAILED(hr))
  {
    return hr; // could not bind
  }

  // get the LDAP path of the parent
  CComBSTR ParentPath;
  hr = spDSObj->get_Parent(&ParentPath);
  if (FAILED(hr)) 
  {
    return hr;
  }

  CString szParentDN;
  StripADsIPath(ParentPath, szParentDN);
  TRACE(_T("goin on a cookie hunt.. (for %s)\n"), ParentPath);

  // start a search from the root
  CUINodeList* pContainers = m_RootNode.GetFolderInfo()->GetContainerList();
  BOOL bFound = _SearchList(pContainers, 
                        szParentDN, 
                        ppParentUINode);

  return bFound ? S_OK : S_FALSE;
}

//
// This is a recursive search of the currently expanded domain tree starting at 
// the root looking at all CDSUINodes for a matching DN.
//
// NOTE : this may be an extremely expensive operation if a lot
//        of containers have been expanded or they have a lot of
//        children.
//
BOOL CDSComponentData::FindUINodeByDN(CUINode* pContainerNode,
                                      PCWSTR pszDN,
                                      CUINode** ppFoundNode)
{
  if (ppFoundNode == NULL)
  {
    return FALSE;
  }

  *ppFoundNode = NULL;
  if (pContainerNode == NULL || !pContainerNode->IsContainer())
  {
    return FALSE;
  }

  //
  // First look through the leaf nodes
  //
  CUINodeList* pLeafList = pContainerNode->GetFolderInfo()->GetLeafList();
  POSITION leafPos = pLeafList->GetHeadPosition();
  while (leafPos != NULL)
  {
    CUINode* pCurrentLeaf = pLeafList->GetNext(leafPos);
    if (pCurrentLeaf == NULL || !IS_CLASS(*pCurrentLeaf, CDSUINode))
    {
      //
      // We can only search for DNs if the node is a CDSUINode
      //
      continue;
    }

    CDSCookie* pCurrentCookie = GetDSCookieFromUINode(pCurrentLeaf);
    LPCWSTR lpszCurrentPath = pCurrentCookie->GetPath();
    if (_wcsicmp(lpszCurrentPath, pszDN) == 0)
    {
      *ppFoundNode = pCurrentLeaf;
      return TRUE;
    }
  }


  //
  // If not found in the leaf list then do a recursive search on the containers
  //
  CUINodeList* pContainerList = pContainerNode->GetFolderInfo()->GetContainerList();
  POSITION containerPos = pContainerList->GetHeadPosition();
  while (containerPos != NULL)
  {
    CUINode* pCurrentContainer = pContainerList->GetNext(containerPos);
    if (pCurrentContainer == NULL || !IS_CLASS(*pCurrentContainer, CDSUINode))
    {
      //
      // We can only search for DNs if the node is a CDSUINode
      //
      continue;
    }

    CDSCookie* pCurrentCookie = GetDSCookieFromUINode(pCurrentContainer);
    LPCWSTR lpszCurrentPath = pCurrentCookie->GetPath();
    if (_wcsicmp(lpszCurrentPath, pszDN) == 0)
    {
      *ppFoundNode = pCurrentContainer;
      return TRUE;
    }
    else
    {
      //
      // Start the recursion
      //
      if (FindUINodeByDN(pCurrentContainer, pszDN, ppFoundNode))
      {
        return TRUE;
      }
    }
  }
  return FALSE;
}

//
// This looks for nodes in the saved query tree that has the same DN as
// the any of the objects in the list and then invalidates the containing
// saved query node
//
void CDSComponentData::InvalidateSavedQueriesContainingObjects(const CUINodeList& refUINodeList)
{
  if (QuerySnapinType() != SNAPINTYPE_SITE)
  {
    //
    // Make a list of DNs
    //
    CStringList szDNList;

    POSITION pos = refUINodeList.GetHeadPosition();
    while (pos)
    {
      CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(refUINodeList.GetNext(pos));
      if (!pDSUINode)
      {
        //
        // Ignore anything that is not a DS node
        //
        continue;
      }

      CDSCookie* pCookie = GetDSCookieFromUINode(pDSUINode);
      if (!pCookie)
      {
        ASSERT(FALSE);
        continue;
      }

      szDNList.AddTail(pCookie->GetPath());
    }

    if (szDNList.GetCount() > 0)
    {
      //
      // Now search through saved query tree invalidating query nodes
      // that contain items in the list
      //
      GetFavoritesNodeHolder()->InvalidateSavedQueriesContainingObjects(this, szDNList);
    }
  }
}

//
// This looks for nodes in the saved query tree that has the same DN as
// the any of the objects in the list and then invalidates the containing
// saved query node
//
void CDSComponentData::InvalidateSavedQueriesContainingObjects(const CStringList& refPathList)
{
  if (QuerySnapinType() != SNAPINTYPE_SITE)
  {
    CStringList szDNList;
    CPathCracker pathCracker;

    //
    // Convert all the paths to DNs
    //
    POSITION pos = refPathList.GetHeadPosition();
    while (pos)
    {
      CString szPath = refPathList.GetNext(pos);

      HRESULT hr = pathCracker.Set((PWSTR)(PCWSTR)szPath, ADS_SETTYPE_FULL);
      if (SUCCEEDED(hr))
      {
        CComBSTR sbstrDN;
        hr = pathCracker.Retrieve(ADS_FORMAT_X500_DN, &sbstrDN);
        if (SUCCEEDED(hr))
        {
          szDNList.AddTail(sbstrDN);
        }
      }
    }

    if (szDNList.GetCount() > 0)
    {
      //
      // Now search through saved query tree invalidating query nodes
      // that contain items in the list
      //
      GetFavoritesNodeHolder()->InvalidateSavedQueriesContainingObjects(this, szDNList);
    }
  }
}

void CDSComponentData::ReclaimCookies()
{
  AddToLRUList (&m_RootNode);

  CUINode* pUINode = NULL;
  POSITION pos, pos2;
  CUINodeList* pContainers = NULL;

#ifdef DBG
  TRACE (_T("dumping LRU list...\n"));
  pos = m_LRUList.GetHeadPosition();
  while (pos) 
  {
    pUINode = m_LRUList.GetNext(pos);
    CUIFolderInfo* pFolderInfo = pUINode->GetFolderInfo();
    if (pFolderInfo != NULL)
    {
      TRACE (_T("\tcontainer: %s (%d)\n"), pUINode->GetName(),
             pFolderInfo->GetSerialNumber());
    }
  }
#endif

  //
  // Get Root folder info
  //
  CUIFolderInfo* pRootFolderInfo = m_RootNode.GetFolderInfo();
  ASSERT(pRootFolderInfo != NULL);

  TRACE (_T("-->total count is %d: reclaiming cookies from LRU list...\n"),
         pRootFolderInfo->GetObjectCount());

  UINT maxitems = m_pQueryFilter->GetMaxItemCount();
  pos = m_LRUList.GetHeadPosition();
  while (pos) 
  {
    CUIFolderInfo* pUIFolderInfo = NULL;
    pUINode = m_LRUList.GetNext(pos);
    pUIFolderInfo = pUINode->GetFolderInfo();

    if (pUIFolderInfo != NULL)
    {
      TRACE (_T("!!--!!container %s (sn:%d) containing %d objects is being reclaimed\n"),
             pUINode->GetName(),
             pUIFolderInfo->GetSerialNumber(),
             pUIFolderInfo->GetObjectCount());

      //
      // clean all of the leaves out
      //
      pUIFolderInfo->DeleteAllLeafNodes();

      //
      // clean all of the containers here out of the tree view
      //
      pContainers = pUIFolderInfo->GetContainerList();
      if (pContainers) 
      {
        HSCOPEITEM ItemID;
        CUINode* pUIContNode= NULL;
        pos2 = pContainers->GetHeadPosition();
        while (pos2) 
        {
          pUIContNode = pContainers->GetNext(pos2);

          CUIFolderInfo* pFolderInfo = pUIContNode->GetFolderInfo();
          if (pFolderInfo != NULL)
          {
            ItemID = pFolderInfo->GetScopeItem();
            m_pScope->DeleteItem (ItemID, TRUE);
          }
        }
      }
      pUIFolderInfo->DeleteAllContainerNodes();
    
      pUIFolderInfo->ReSetExpanded();
      if (pRootFolderInfo->GetObjectCount() < (maxitems * 5)) 
      {
        break;
      }
    }
  }
  TRACE (_T("--> done reclaiming cookies from LRU list. total count is now %d: ..\n"),
         pRootFolderInfo->GetObjectCount());
  

  //
  // Empty the LRU list
  //
  while (!m_LRUList.IsEmpty()) 
  {
    m_LRUList.RemoveTail();	
  }
}

BOOL CDSComponentData::IsSelectionAnywhere(CUINode* pUINode)
{
  ASSERT(pUINode->IsContainer());

  UINODESELECTION nodeSelection;

  nodeSelection.pUINode = pUINode;
  nodeSelection.IsSelection = FALSE;

  // if any view has this cookie selected, the IsSelection member
  // will be TRUE when we return.
  m_pFrame->UpdateAllViews (NULL,
                            (LPARAM)&nodeSelection,
                            DS_IS_COOKIE_SELECTION);
  return nodeSelection.IsSelection;
}

void CDSComponentData::AddToLRUList (CUINode* pUINode)
{
  HRESULT hr = S_OK;

  CUIFolderInfo* pUIFolderInfo = pUINode->GetFolderInfo();
  if (pUIFolderInfo != NULL)
  {
    CUINodeList* pContainers = pUIFolderInfo->GetContainerList();
    CUINode* pUIContNode = NULL;
    size_t cContainers = pContainers->GetCount();
    BOOL foundSpot = FALSE;
    POSITION pos;

    if (cContainers > 0) 
    {
      pos = pContainers->GetHeadPosition();
      while (pos) 
      {
        pUIContNode = pContainers->GetNext(pos);
        if (pUIContNode != NULL)
        {
          AddToLRUList (pUIContNode);
        }
      }
    }

    //
    // now we've taken care of the children, let's add
    // this one to the list
    //

    //
    // first, let's see if it is expanded
    // this doesn't work currently - asking MMC guys why
    //
    SCOPEDATAITEM ScopeData;
    ZeroMemory (&ScopeData, sizeof(SCOPEDATAITEM));
    ScopeData.ID = pUIFolderInfo->GetScopeItem();
    ScopeData.mask = SDI_STATE | SDI_PARAM;
    hr = m_pScope->GetItem (&ScopeData);

    if (!pUINode->IsSheetLocked()
        && (!IsSelectionAnywhere (pUINode))
        && (pUIFolderInfo->GetSerialNumber() != SERIALNUM_NOT_TOUCHED)
        && (!((ScopeData.nState & TVIS_EXPANDED) == TVIS_EXPANDED))) 
    {
      pos = m_LRUList.GetHeadPosition();
      if (!pos) 
      {
        m_LRUList.AddHead(pUINode);
        TRACE(_T("adding head: %s[%d]\n"), pUINode->GetName(),
              pUIFolderInfo->GetSerialNumber);
      } 
      else 
      {
        CUINode* pLRUNode = NULL;
        CUIFolderInfo* pLRUFolderInfo = NULL;

        while (pos) 
        {
          pLRUNode = m_LRUList.GetAt(pos);
          pLRUFolderInfo = pLRUNode->GetFolderInfo();
          if (pLRUFolderInfo != NULL)
          {
            if (pUIFolderInfo->GetSerialNumber() <
                pLRUFolderInfo->GetSerialNumber()) 
            {
              foundSpot = TRUE;
              break;
            } 
            else
            {
              pLRUNode = m_LRUList.GetNext(pos);
            }
          }
        }

        if (!foundSpot) 
        {
          m_LRUList.AddTail(pUINode);
          TRACE(_T("adding tail: %s [%d]\n"), pUINode->GetName(),
                pUIFolderInfo->GetSerialNumber());
        } 
        else 
        {
          m_LRUList.InsertBefore (pos, pUINode);
          TRACE(_T("inserting: %s [%d]\n"), pUINode->GetName(),
                pUIFolderInfo->GetSerialNumber());
        }
      }
    }
  }
}

HRESULT 
CDSComponentData::_OnNamespaceExtensionExpand(LPDATAOBJECT, HSCOPEITEM hParent)
{
	HRESULT hr = E_FAIL;
	ASSERT(!m_bRunAsPrimarySnapin);
	// namespace extension only for DS snapin
	if (QuerySnapinType() != SNAPINTYPE_DSEX)
		return hr;

	// need to crack the data object to set the context

	// retrieve the query string
	m_pQueryFilter->SetExtensionFilterString(L"(objectClass=*)");

	if (m_bAddRootWhenExtended)
	{
		hr = _AddScopeItem(&m_RootNode, hParent);
	}
	else
	{
		// need to directly expand the root and add children underneath
		hr = _OnExpand(&m_RootNode, hParent, MMCN_EXPAND);
	}
	return hr;
}

//
// Right now this only checks adding group to group and user to group.  Any other object class returns FALSE
//
BOOL CDSComponentData::CanAddCookieToGroup(CDSCookie* pCookie, INT iGroupType, BOOL bMixedMode)
{
  BOOL bCanAdd = FALSE;
  if (pCookie != NULL)
  {
    if (_wcsicmp(pCookie->GetClass(), L"group") == 0)
    {
      CDSCookieInfoGroup* pExtraInfo = dynamic_cast<CDSCookieInfoGroup*>(pCookie->GetExtraInfo());
      if (pExtraInfo != NULL)
      {
        INT iAddGroupType = pExtraInfo->m_GroupType;

        if (bMixedMode)
        {
          //
          // Determine if the group can't be added
          //
          if (iGroupType & GROUP_TYPE_SECURITY_ENABLED)
          {
            if (iGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SE
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SE
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SE
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SE
                  // Member - UG SE
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SE
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SE
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SE
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SE
                  // Member - LG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SE
                  // Member - UG SD
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SE
                  // Member - ? SD
                  //
                  bCanAdd = TRUE;
                }
              }
            }
            else if (iGroupType & GROUP_TYPE_ACCOUNT_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SE
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SE
                  // Member - GG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SE
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SE
                  // Member - UG SE
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - GG SE
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else  // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SE
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SE
                  // Member - GG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SE
                  // Member - LG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SE
                  // Member - UG SD
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - GG SE
                  // Member - ? SD
                  //
                  bCanAdd = FALSE;
                }
              }
            }
            else if (iGroupType & GROUP_TYPE_RESOURCE_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SE
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SE
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SE
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SE
                  // Member - UG SE
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - LG SE
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SE
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SE
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SE
                  // Member - LG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SE
                  // Member - UG SD
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - LG SE
                  // Member - ? SD
                  //
                  bCanAdd = FALSE;
                }
              }
            }
            else if (iGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SE
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SE
                  // Member - GG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SE
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SE
                  // Member - UG SE
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - UG SE
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SE
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SE
                  // Member - GG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SE
                  // Member - LG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SE
                  // Member - UG SD
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - UG SE
                  // Member - ? SD
                  //
                  bCanAdd = FALSE;
                }
              }
            }
            else
            {
              //
              // Mixed Mode
              // Target - ? SE
              // Member - ? ?
              //
              bCanAdd = FALSE;
            }
          }
          else  // Distribution group
          {
            if (iGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SD
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SD
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SD
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SD
                  // Member - UG SE
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SD
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SD
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SD
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SD
                  // Member - LG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SD
                  // Member - UG SD
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - Builtin SD
                  // Member - ? SD
                  //
                  bCanAdd = TRUE;
                }
              }
            }
            else if (iGroupType & GROUP_TYPE_ACCOUNT_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SD
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SD
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SD
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SD
                  // Member - UG SE
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - GG SD
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else  // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SD
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SD
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SD
                  // Member - LG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - GG SD
                  // Member - UG SD
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - GG SD
                  // Member - ? SD
                  //
                  bCanAdd = FALSE;
                }
              }
            }
            else if (iGroupType & GROUP_TYPE_RESOURCE_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SD
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SD
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SD
                  // Member - LG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SD
                  // Member - UG SE
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - LG SD
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SD
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SD
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SD
                  // Member - LG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - LG SD
                  // Member - UG SD
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - LG SD
                  // Member - ? SD
                  //
                  bCanAdd = FALSE;
                }
              }
            }
            else if (iGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SD
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SD
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SD
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SD
                  // Member - UG SE
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - UG SD
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SD
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SD
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SD
                  // Member - LG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Mixed Mode
                  // Target - UG SD
                  // Member - UG SD
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Mixed Mode
                  // Target - UG SD
                  // Member - ? SD
                  //
                  bCanAdd = FALSE;
                }
              }
            }
            else
            {
              //
              // Mixed Mode
              // Target - ? SD
              // Member - ? ?
              //
              bCanAdd = FALSE;
            }
          }
        }
        else // native mode
        {
          //
          // Determine if the group can't be added
          //
          if (iGroupType & GROUP_TYPE_SECURITY_ENABLED)
          {
            if (iGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SE
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SE
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SE
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SE
                  // Member - UG SE
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - Builtin SE
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SE
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SE
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SE
                  // Member - LG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SE
                  // Member - UG SD
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - Builtin SE
                  // Member - ? SD
                  //
                  bCanAdd = TRUE;
                }
              }
            }
            else if (iGroupType & GROUP_TYPE_ACCOUNT_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SE
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SE
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SE
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SE
                  // Member - UG SE
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - GG SE
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else  // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SE
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SE
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SE
                  // Member - LG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SE
                  // Member - UG SD
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - GG SE
                  // Member - ? SD
                  //
                  bCanAdd = FALSE;
                }
              }
            }
            else if (iGroupType & GROUP_TYPE_RESOURCE_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SE
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SE
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SE
                  // Member - LG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SE
                  // Member - UG SE
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - LG SE
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SE
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SE
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SE
                  // Member - LG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SE
                  // Member - UG SD
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - LG SE
                  // Member - ? SD
                  //
                  bCanAdd = FALSE;
                }
              }
            }
            else if (iGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SE
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SE
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SE
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SE
                  // Member - UG SE
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - UG SE
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SE
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SE
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SE
                  // Member - LG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SE
                  // Member - UG SD
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - UG SE
                  // Member - ? SD
                  //
                  bCanAdd = FALSE;
                }
              }
            }
            else
            {
              //
              // Native Mode
              // Target - ? SE
              // Member - ? ?
              //
              bCanAdd = FALSE;
            }
          }
          else  // Distribution group
          {
            if (iGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SD
                  // Member - Buitlin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SD
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SD
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SD
                  // Member - UG SE
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - Builtin SD
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SD
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SD
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SD
                  // Member - LG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - Builtin SD
                  // Member - UG SD
                  // 
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - Builtin SD
                  // Member - ? SD
                  //
                  bCanAdd = TRUE;
                }
              }
            }
            else if (iGroupType & GROUP_TYPE_ACCOUNT_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SD
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SD
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SD
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SD
                  // Member - UG SE
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - GG SD
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else  // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SD
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SD
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SD
                  // Member - LG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - GG SD
                  // Member - UG SD
                  //
                  bCanAdd = FALSE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - GG SD
                  // Member - ? SD
                  //
                  bCanAdd = FALSE;
                }
              }
            }
            else if (iGroupType & GROUP_TYPE_RESOURCE_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SD
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SD
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SD
                  // Member - LG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SD
                  // Member - UG SE
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - LG SD
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SD
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SD
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SD
                  // Member - LG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - LG SD
                  // Member - UG SD
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - LG SD
                  // Member - ? SD
                  //
                  bCanAdd = FALSE;
                }
              }
            }
            else if (iGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
            {
              if (iAddGroupType & GROUP_TYPE_SECURITY_ENABLED)
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SD
                  // Member - Builtin SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SD
                  // Member - GG SE
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SD
                  // Member - LG SE
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SD
                  // Member - UG SE
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - UG SD
                  // Member - ? SE
                  //
                  bCanAdd = FALSE;
                }
              }
              else // group to add is a distribution group
              {
                if (iAddGroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SD
                  // Member - Builtin SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_ACCOUNT_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SD
                  // Member - GG SD
                  //
                  bCanAdd = TRUE;
                }
                else if (iAddGroupType & GROUP_TYPE_RESOURCE_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SD
                  // Member - LG SD
                  //
                  bCanAdd = FALSE;
                }
                else if (iAddGroupType & GROUP_TYPE_UNIVERSAL_GROUP)
                {
                  //
                  // Native Mode
                  // Target - UG SD
                  // Member - UG SD
                  //
                  bCanAdd = TRUE;
                }
                else
                {
                  //
                  // Native Mode
                  // Target - UG SD
                  // Member - ? SD
                  //
                  bCanAdd = FALSE;
                }
              }
            }
            else
            {
              //
              // Native Mode
              // Target - ? SD
              // Member - ? ?
              // 
              bCanAdd = FALSE;
            }
          }
        }
      }
    }
    else if (_wcsicmp(pCookie->GetClass(), L"user") == 0 ||
#ifdef INETORGPERSON
             _wcsicmp(pCookie->GetClass(), L"inetOrgPerson") == 0 ||
#endif
             _wcsicmp(pCookie->GetClass(), L"contact") == 0 ||
             _wcsicmp(pCookie->GetClass(), L"computer") == 0)
    {
      bCanAdd = TRUE;
    }
    else
    {
      BOOL bSecurity = (iGroupType & GROUP_TYPE_SECURITY_ENABLED) ? TRUE : FALSE;
      bCanAdd = m_pClassCache->CanAddToGroup(GetBasePathsInfo(), pCookie->GetClass(), bSecurity);
    }
  }
  else
  {
    bCanAdd = TRUE;
  }
  return bCanAdd;
}

////////////////////////////////////////////////////////////////////
// CDSComponentData thread API's


BOOL CDSComponentData::_StartBackgroundThread()
{
  ASSERT(m_pHiddenWnd != NULL);
  ASSERT(::IsWindow(m_pHiddenWnd->m_hWnd));
  if ((m_pHiddenWnd == NULL) || !::IsWindow(m_pHiddenWnd->m_hWnd) )
    return FALSE;

  CDispatcherThread* pThreadObj = new CDispatcherThread;
  ASSERT(pThreadObj != NULL);
  if (pThreadObj == NULL)
	  return FALSE;

  // start the the thread

  ASSERT(m_pBackgroundThreadInfo->m_nThreadID == 0);
  ASSERT(m_pBackgroundThreadInfo->m_hThreadHandle == NULL);
  ASSERT(m_pBackgroundThreadInfo->m_state == notStarted);

  ASSERT(pThreadObj->m_bAutoDelete);

  if (!pThreadObj->Start(m_pHiddenWnd->m_hWnd, this))
	  return FALSE;

  ASSERT(pThreadObj->m_nThreadID != 0);
  ASSERT(pThreadObj->m_hThread != NULL);
  
  // copy the thread info we need from the thread object
  m_pBackgroundThreadInfo->m_hThreadHandle = pThreadObj->m_hThread;
  m_pBackgroundThreadInfo->m_nThreadID = pThreadObj->m_nThreadID;

  // wait for the thread to start and be ready to receive messages
  _WaitForBackGroundThreadStartAck();

  ASSERT(m_pBackgroundThreadInfo->m_state == running);

  TRACE(L"dispatcher thread (HANDLE = 0x%x) running\n", m_pBackgroundThreadInfo->m_hThreadHandle);

  return TRUE;
}

void CDSComponentData::_WaitForBackGroundThreadStartAck()
{
  ASSERT(m_pHiddenWnd != NULL);
	ASSERT(::IsWindow(m_pHiddenWnd->m_hWnd));
	
	ASSERT(m_pBackgroundThreadInfo->m_state == notStarted);

  MSG tempMSG;
	while(m_pBackgroundThreadInfo->m_state == notStarted)
	{
		if (::PeekMessage(&tempMSG,m_pHiddenWnd->m_hWnd,CHiddenWnd::s_ThreadStartNotificationMessage,
										CHiddenWnd::s_ThreadStartNotificationMessage,
										PM_REMOVE))
		{
			DispatchMessage(&tempMSG);
		}
	}

  ASSERT(m_pBackgroundThreadInfo->m_state == running);
}

void CDSComponentData::_ShutDownBackgroundThread() 
{ 
  TRACE(L"CDSComponentData::_ShutDownBackgroundThread()\n");

  // set thread state to shutdown mode
  // to avoid any spurious processing
  ASSERT(m_pBackgroundThreadInfo->m_nThreadID != 0);
  ASSERT(m_pBackgroundThreadInfo->m_hThreadHandle != NULL);
  ASSERT(m_pBackgroundThreadInfo->m_state == running);

  m_pBackgroundThreadInfo->m_state = shuttingDown;

  // post a message to the dispatcher thread to signal shutdown
  _PostMessageToBackgroundThread(THREAD_SHUTDOWN_MSG, 0,0); 

  // wait for the dispatcher thread to acknowledge 
  // (i.e. all worker threads have shut down)
  
  TRACE(L"Waiting for CHiddenWnd::s_ThreadShutDownNotificationMessage\n");
  MSG tempMSG;
	while(m_pBackgroundThreadInfo->m_state == shuttingDown)
	{
		if (::PeekMessage(&tempMSG,m_pHiddenWnd->m_hWnd,CHiddenWnd::s_ThreadShutDownNotificationMessage,
										CHiddenWnd::s_ThreadShutDownNotificationMessage,
										PM_REMOVE))
		{
			DispatchMessage(&tempMSG);
		}
	}

  ASSERT(m_pBackgroundThreadInfo->m_state == terminated);

  // wait for the dispatcher thread handle to become signalled
  TRACE(L"before WaitForThreadShutdown(0x%x) on dispatcher thread\n", m_pBackgroundThreadInfo->m_hThreadHandle);
  WaitForThreadShutdown(&(m_pBackgroundThreadInfo->m_hThreadHandle), 1);
  TRACE(L"after WaitForThreadShutdown() on dispatcher thread\n");

}


BOOL CDSComponentData::_PostQueryToBackgroundThread(CUINode* pUINode)
{
  CThreadQueryInfo* pQueryInfo = NULL;
  
  if (pUINode == &m_RootNode)
  {
    // enumerating the root of the namespace
    CDSThreadQueryInfo* pDSQueryInfo = new CDSThreadQueryInfo;
    pDSQueryInfo->SetQueryDSQueryParameters(rootFolder,
                                        m_RootNode.GetPath(),
                                        NULL, // class
                                        m_pQueryFilter->GetQueryString(), 
                                        m_pQueryFilter->GetMaxItemCount(),
                                        TRUE, // bOneLevel
                                        m_RootNode.GetColumnSet(this)->GetColumnID());
    pQueryInfo = pDSQueryInfo;
  }
  else if (IS_CLASS(*pUINode, CDSUINode))
  {
    // enumerating regular DS folder
    CDSThreadQueryInfo* pDSQueryInfo = new CDSThreadQueryInfo;
    CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);
    ASSERT(pCookie != NULL);
    pDSQueryInfo->SetQueryDSQueryParameters(dsFolder,
                                        pCookie->GetPath(),
                                        pCookie->GetClass(),
                                        m_pQueryFilter->GetQueryString(), 
                                        m_pQueryFilter->GetMaxItemCount(),
                                        TRUE, // bOneLevel
                                        pUINode->GetColumnSet(this)->GetColumnID());
    pQueryInfo = pDSQueryInfo;

  }
  else if (IS_CLASS(*pUINode, CSavedQueryNode))
  {
    // enumerating a saved query folder
    CDSThreadQueryInfo* pDSQueryInfo = new CDSThreadQueryInfo;
    if (pDSQueryInfo != NULL)
    {
      CSavedQueryNode* pSavedQueryNode = dynamic_cast<CSavedQueryNode*>(pUINode);
      ASSERT(pSavedQueryNode != NULL);
      if (pSavedQueryNode != NULL)
      {
        if (pSavedQueryNode->IsFilterLastLogon())
        {
          if (GetBasePathsInfo()->GetDomainBehaviorVersion() == DS_BEHAVIOR_WIN2000)
          {
            CString szText, szCaption;
            VERIFY(szText.LoadString(IDS_FILTER_LAST_LOGON_VERSION));
            VERIFY(szCaption.LoadString(IDS_DSSNAPINNAME));
            MessageBox(GetHWnd(), szText, szCaption, MB_OK | MB_ICONSTOP);
            return FALSE;
          }
        }
        pDSQueryInfo->SetQueryDSQueryParameters(queryFolder,
                                            pSavedQueryNode->GetRootPath(),
                                            NULL, // class
                                            pSavedQueryNode->GetQueryString(), 
                                            UINT_MAX, // don't limit the number of items the query returns
                                            pSavedQueryNode->IsOneLevel(),
                                            pUINode->GetColumnSet(this)->GetColumnID());
        pQueryInfo = pDSQueryInfo;
      }
      else
      {
        TRACE(_T("Failed to dynamically cast to CSavedQueryNode in CDSComponentData::_PostQueryToBackgroundThread()"));
        ASSERT(FALSE);
      }
    }
    else
    {
      TRACE(_T("Failed to allocate memory for CDSThreadQueryInfo in CDSComponentData::_PostQueryToBackgroundThread()"));
      ASSERT(FALSE);
    }
  }

  if (pQueryInfo == NULL)
  {
    return FALSE;
  }

  TRACE(_T("CDSComponentData::_PostQueryToBackgroundThread: cookie is %s\n"),
      pUINode->GetName());

  ASSERT(pUINode->IsContainer());

  ASSERT(m_pBackgroundThreadInfo->m_nThreadID != 0);
  ASSERT(m_pBackgroundThreadInfo->m_hThreadHandle != NULL);
  ASSERT(m_pBackgroundThreadInfo->m_state == running);

  m_queryNodeTable.Add(pUINode);
  m_pFrame->UpdateAllViews(NULL, (LPARAM)pUINode, DS_VERB_UPDATE);
  VERIFY(SUCCEEDED(ChangeScopeItemIcon(pUINode)));

  TRACE(L"CDSComponentData::_PostQueryToBackgroundThread: posting DISPATCH_THREAD_RUN_MSG\n");
	return _PostMessageToBackgroundThread(DISPATCH_THREAD_RUN_MSG, 
          (WPARAM)pUINode, (LPARAM)pQueryInfo);
}

BOOL CDSComponentData::_PostMessageToBackgroundThread(UINT Msg, WPARAM wParam, LPARAM lParam)
{
  ASSERT(m_pBackgroundThreadInfo->m_nThreadID != 0);
  ASSERT(m_pBackgroundThreadInfo->m_hThreadHandle != NULL);

	return ::PostThreadMessage(m_pBackgroundThreadInfo->m_nThreadID, Msg, wParam, lParam);
}

void CDSComponentData::_OnTooMuchData(CUINode* pUINode)
{
  if (!m_queryNodeTable.IsPresent(pUINode))
    return; // cookie not found, node not there anymore

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  BOOL bHandledWithApproximation = FALSE;
  CDSCookie* pDSCookie = GetDSCookieFromUINode(pUINode);
  if (pDSCookie != NULL)
  {
    CString szPath;
    GetBasePathsInfo()->ComposeADsIPath(szPath, pDSCookie->GetPath()); 

    //
    // Bind to the object and determine approximately how many 
    // objects are in the container
    //
    CComPtr<IDirectoryObject> spDirObject;
    HRESULT hr = DSAdminOpenObject(szPath,
                                   IID_IDirectoryObject,
                                   (PVOID*)&spDirObject,
                                   TRUE /*bServer*/);
    if (SUCCEEDED(hr))
    {
      //
      // Retrieve the approximation through the constructed attribute
      //
      const int iAttrCount = 1;
      PWSTR pszAttribs[] = { L"msDS-Approx-Immed-Subordinates" };
      PADS_ATTR_INFO pAttrInfo = NULL;
      DWORD dwNumRet = 0;

      CComVariant var;
      hr = spDirObject->GetObjectAttributes(pszAttribs,
                                            iAttrCount,
                                            &pAttrInfo,
                                            &dwNumRet);
      if (SUCCEEDED(hr))
      {
        ASSERT(dwNumRet == 1);
        ASSERT(pAttrInfo != NULL && pAttrInfo->pADsValues != NULL);

        if (dwNumRet == 1 &&
            pAttrInfo != NULL &&
            pAttrInfo->pADsValues != NULL)
        {

          UINT nCount = static_cast<UINT>(pAttrInfo->pADsValues->Integer);
          UINT nRetrieved = m_pQueryFilter->GetMaxItemCount();
        
          UINT nApprox = __max(nCount, nRetrieved);
          //
          // Format the message
          //
          CString szMsg;
          szMsg.Format(IDS_MSG_QUERY_TOO_MANY_ITEMS_WITH_APPROX, nRetrieved, nApprox, pUINode->GetName());

          PVOID apv[1] = {(LPWSTR)(LPCWSTR)szMsg};
          ReportErrorEx (m_hwnd,IDS_STRING,S_OK, MB_OK | MB_ICONINFORMATION, apv, 1); 

          //
          // We were able to retrieve the approximation of the contained objects and post an error
          // so we don't have to resort to the old message
          //
          bHandledWithApproximation = TRUE;

          pUINode->GetFolderInfo()->SetTooMuchData(TRUE, nCount);
          m_pFrame->UpdateAllViews (NULL, NULL, DS_UPDATE_OBJECT_COUNT);
        }
        if (pAttrInfo != NULL)
        {
          FreeADsMem(pAttrInfo);
          pAttrInfo = NULL;
        }
      }
    }
  }

  //
  // Resort to using the old message if we are unable to retrieve the approximation
  //
  if (!bHandledWithApproximation)
  {
    CString szFmt;
    szFmt.LoadString(IDS_MSG_QUERY_TOO_MANY_ITEMS);
    CString szMsg;
    szMsg.Format(szFmt, pUINode->GetName()); 
    PVOID apv[1] = {(LPWSTR)(LPCWSTR)szMsg};
    ReportErrorEx (m_hwnd,IDS_STRING,S_OK, MB_OK | MB_ICONINFORMATION, apv, 1); 
  }
}

void CDSComponentData::AddScopeItemToUI(CUINode* pUINode, BOOL bSetSelected)
{
  if (pUINode->IsContainer())
  {
    CUIFolderInfo* pParentInfo = pUINode->GetFolderInfo()->GetParentNode()->GetFolderInfo();
    if (pParentInfo != NULL)
    {
      _AddScopeItem(pUINode, pParentInfo->GetScopeItem(), bSetSelected);
    }
  }
}


void CDSComponentData::AddListOfNodesToUI(CUINode* pUINode, CUINodeList* pNodeList)
{
  CComPtr<IDataObject> spDataObj;
  HRESULT hr = QueryDataObject ((MMC_COOKIE)pUINode, CCT_SCOPE, &spDataObj);
  ASSERT(SUCCEEDED(hr));

  // add the icon just in case
  m_pFrame->UpdateAllViews(spDataObj, /*unused*/(LPARAM)0, DS_ICON_STRIP_UPDATE);

  TIMER(_T("adding containers to scope pane\n"));
  // the cookie is good, add all the cookies
  for (POSITION pos = pNodeList->GetHeadPosition(); pos != NULL; )
  {
    CUINode* pNewUINode = pNodeList->GetNext(pos);
    pUINode->GetFolderInfo()->AddNode(pNewUINode); // add to the linked lists
    if (pNewUINode->IsContainer())
    {
      // add to the scope pane
     _AddScopeItem(pNewUINode, pUINode->GetFolderInfo()->GetScopeItem());
    }
  } // for

  // for the leaf nodes, do a bulk update on the result pane
  TIMER(_T("sending have-data notification to views\n")); 
  m_pFrame->UpdateAllViews(spDataObj, (LPARAM)pNodeList, DS_HAVE_DATA);
}


HRESULT CDSComponentData::ReadUINodeFromLdapPath(IN CDSUINode* pContainerDSUINode,
                                                 IN LPCWSTR lpszLdapPath,
                                                 OUT CDSUINode** ppSUINodeNew)
{
  CDSCookie* pNewCookie = NULL;
  HRESULT hr = GetActiveDS()->ReadDSObjectCookie(pContainerDSUINode,
                                             lpszLdapPath,
                                             &pNewCookie);

  if (SUCCEEDED(hr) && (hr != S_FALSE) && (pNewCookie != NULL))
  {
    // make sure we update the icon cache
    m_pFrame->UpdateAllViews(/*unused*/NULL /*pDataObj*/, /*unused*/(LPARAM)0, DS_ICON_STRIP_UPDATE);

    // create a UI node to hold the cookie
    *ppSUINodeNew = new CDSUINode(NULL);
    (*ppSUINodeNew)->SetCookie(pNewCookie);
    if (pNewCookie->IsContainerClass())
    {
      (*ppSUINodeNew)->MakeContainer();
    }
  }
  return hr;
}


void CDSComponentData::_OnHaveData(CUINode* pUINode, CThreadQueryResult* pResult)
{
  ASSERT(pUINode != NULL);
  ASSERT(pUINode->IsContainer());


  TRACE(_T("CDSComponentData::_OnHaveData()\n"));
  if ( m_queryNodeTable.IsPresent(pUINode) && (pResult != NULL) )
  {
    AddListOfNodesToUI(pUINode, &(pResult->m_nodeList));
    pResult->m_bOwnMemory = FALSE; // relinquish ownership of pointers
  }

  if (m_RootNode.GetFolderInfo()->GetObjectCount() > (m_pQueryFilter->GetMaxItemCount() * 5)) {
    ReclaimCookies();
  }
  if (pResult != NULL)
  {
    delete pResult;
  }
}

void CDSComponentData::_OnDone(CUINode* pUINode, HRESULT hr)
{
  ASSERT(pUINode != NULL);
  ASSERT(pUINode->IsContainer());

  if (!m_queryNodeTable.Remove(pUINode))
    return; // cookie not found, node not there anymore

  // change the icon state
  pUINode->SetExtOp(SUCCEEDED(hr) ? 0 : OPCODE_ENUM_FAILED);
  VERIFY(SUCCEEDED(ChangeScopeItemIcon(pUINode)));

  m_pFrame->UpdateAllViews(NULL, (LPARAM)pUINode, DS_VERB_UPDATE);

  // update serial number
  pUINode->GetFolderInfo()->UpdateSerialNumber(this);

  TIMER(_T("got on-done notification\n"));
  if (SUCCEEDED(hr))
  {
    if (pUINode->GetExtOp() & OPCODE_EXPAND_IN_PROGRESS) {
      m_pFrame->UpdateAllViews(NULL, (LPARAM)pUINode, DS_DELAYED_EXPAND);
    }
  }
  else if (m_InitSuccess)
  {
    if (IS_CLASS(*pUINode, CSavedQueryNode))
    {
      CSavedQueryNode* pQueryNode = dynamic_cast<CSavedQueryNode*>(pUINode);
      if (pQueryNode != NULL)
      {
        if (HRESULT_CODE(hr) == ERROR_DS_FILTER_UNKNOWN)
        {
          //
          // Error message for an invalid query filter
          //
          PVOID apv[2] = {(PVOID)pQueryNode->GetQueryString()}; 
          ReportErrorEx (m_hwnd,IDS_ERRMSG_QUERY_FILTER_NOT_VALID, hr,
                         MB_OK | MB_ICONERROR, apv, 1);
        }
        else if (HRESULT_CODE(hr) == ERROR_DS_NO_SUCH_OBJECT)
        {
          //
          // Error message for an invalid query root
          //
          PVOID apv[2] = {(PVOID)pQueryNode->GetRootPath(),
                          (PVOID)GetBasePathsInfo()->GetServerName()}; 
          ReportErrorEx (m_hwnd,IDS_ERRMSG_QUERY_ROOT_NOT_VALID, hr,
                         MB_OK | MB_ICONERROR, apv, 2);
        }
        else
        {
          //
          // Error message for any other error
          //
          ReportErrorEx (m_hwnd,IDS_ERRMSG_QUERY_FAILED, hr,
                         MB_OK | MB_ICONERROR, NULL, 0);
        }
      }
    }
    else
    {
        PVOID apv[2] = {(PVOID)GetBasePathsInfo()->GetServerName(),
                        (PVOID)pUINode->GetName()}; 
        ReportErrorEx (m_hwnd,IDS_12_CANT_GET_DATA, hr,
                       MB_OK | MB_ICONERROR, apv, 2);
    }
  }

  SortResultPane(pUINode);
}

void CDSComponentData::_OnSheetClose(CUINode* /*pUINode*/)
{
  /*
  ASSERT(pUINode != NULL);

  // REVIEW_MARCOC_PORT: sheet locking is skipped for
  // DS nodes, because we let them float
  CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(pUINode);
  if (pDSUINode != NULL)
  {
    return;
  }

  // not a DS object, need too do the usual thing
  _SheetUnlockCookie(pUINode);
  */
}


HRESULT CreateSecondarySheet(HWND hWndParent, 
                    LPCONSOLE pIConsole, 
                    IUnknown* pUnkComponentData,
                    CDSUINode* pCookie,
                    IDataObject* pDataObject,
                    LPCWSTR lpszTitle)
{
  ASSERT(pIConsole != NULL);
  ASSERT(pDataObject != NULL);
  ASSERT(pUnkComponentData != NULL);

	// get an interface to a sheet provider
	CComPtr<IPropertySheetProvider> spSheetProvider;
	HRESULT hr = pIConsole->QueryInterface(IID_IPropertySheetProvider,(void**)&spSheetProvider);
	ASSERT(SUCCEEDED(hr));
	ASSERT(spSheetProvider != NULL);

	// get an interface to a sheet callback
	CComPtr<IPropertySheetCallback> spSheetCallback;
	hr = pIConsole->QueryInterface(IID_IPropertySheetCallback,(void**)&spSheetCallback);
	ASSERT(SUCCEEDED(hr));
	ASSERT(spSheetCallback != NULL);

	ASSERT(pDataObject != NULL);

	// get a sheet
  MMC_COOKIE cookie = reinterpret_cast<MMC_COOKIE>(pCookie);
	hr = spSheetProvider->CreatePropertySheet(lpszTitle, TRUE, cookie, 
                                            pDataObject, 0x0 /*dwOptions*/);
	ASSERT(SUCCEEDED(hr));

	hr = spSheetProvider->AddPrimaryPages(pUnkComponentData,
											FALSE /*bCreateHandle*/,
											hWndParent,
											FALSE /* bScopePane*/);

  hr = spSheetProvider->AddExtensionPages();

	ASSERT(SUCCEEDED(hr));

	hr = spSheetProvider->Show(reinterpret_cast<LONG_PTR>(hWndParent), 0);
	ASSERT(SUCCEEDED(hr));

	return hr;
}



void CDSComponentData::_OnSheetCreate(PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo)
{
  ASSERT(pDsaSecondaryPageInfo != NULL);

  //
  // get the info from the packed structure
  //
  HWND hwndParent = pDsaSecondaryPageInfo->hwndParentSheet;

  LPCWSTR lpszTitle = (LPCWSTR)((BYTE*)pDsaSecondaryPageInfo + pDsaSecondaryPageInfo->offsetTitle);
  DSOBJECTNAMES* pDsObjectNames = &(pDsaSecondaryPageInfo->dsObjectNames);

  ASSERT(pDsObjectNames->cItems == 1);
  DSOBJECT* pDsObject = &(pDsObjectNames->aObjects[0]);

  LPCWSTR lpszName = (LPCWSTR)((BYTE*)pDsObject + pDsObject->offsetName);
  LPCWSTR lpszClass = (LPCWSTR)((BYTE*)pDsObject + pDsObject->offsetClass);
    
  CDSUINode* pDSUINode = 0;
  CDSCookie* pNewCookie = 0;

  try
  {
    //
    // Create a node and cookie
    //
    pDSUINode = new CDSUINode(NULL);
    if (!pDSUINode)
    {
      return;
    }

    pNewCookie = new CDSCookie(); 
    if (!pNewCookie)
    {
      delete pDSUINode;
      pDSUINode = 0;
      return;
    }
  }
  catch(CMemoryException *)
  {
    if (pDSUINode)
    {
      delete pDSUINode;
      pDSUINode = 0;
    }

    if (pNewCookie)
    {
      delete pNewCookie;
      pNewCookie = 0;
    }
    return;
  }

  //
  // get the DN out of the LDAP path
  //
  CString szLdapPath = lpszName;

  CString szDN;
  StripADsIPath(szLdapPath, szDN);
  pNewCookie->SetPath(szDN);

  CDSClassCacheItemBase* pItem = m_pClassCache->FindClassCacheItem(this, lpszClass, szLdapPath);
  ASSERT(pItem != NULL);
  if (pItem == NULL)
  {
    delete pDSUINode;
    pDSUINode = 0;
    delete pNewCookie;
    pNewCookie = 0;
    return;
  }
   
  pNewCookie->SetCacheItem(pItem);

  //
  // Set the cookie in the node (from now on the node owns the cookie and its memory
  //

  pDSUINode->SetCookie(pNewCookie);
  if (pNewCookie->IsContainerClass())
  {
    pDSUINode->MakeContainer();
  }

  //
  // with the cookie, can call into ourselves to get a data object
  //
  CComPtr<IDataObject> spDataObject;
  MMC_COOKIE cookie = reinterpret_cast<MMC_COOKIE>(pDSUINode);
  HRESULT hr = QueryDataObject(cookie, CCT_UNINITIALIZED, &spDataObject);

  if (FAILED(hr) || (spDataObject == NULL) || IsSheetAlreadyUp(spDataObject))
  {
    //
    // we failed to create a data object (rare)
    // or the sheet is already up
    //
    delete pDSUINode;
    pDSUINode = 0;
    return;
  }

  //
  // Pass the parent sheet handle to the data object.
  //
  PROPSHEETCFG SheetCfg = {0};
  SheetCfg.hwndParentSheet = hwndParent;
  FORMATETC fe = {CDSDataObject::m_cfPropSheetCfg, NULL, DVASPECT_CONTENT,
                  -1, TYMED_HGLOBAL};
  STGMEDIUM sm = {TYMED_HGLOBAL, NULL, NULL};
  sm.hGlobal = (HGLOBAL)&SheetCfg;

  hr = spDataObject->SetData(&fe, &sm, FALSE);

  ASSERT(SUCCEEDED(hr));

  //
  // with the data object, call into MMC to get the sheet 
  //
  hr = CreateSecondarySheet(GetHWnd(), 
                            m_pFrame, 
                            GetUnknown(),
                            pDSUINode,
                            spDataObject,
                            lpszTitle);

  delete pDSUINode;
}

HRESULT CDSComponentData::SelectScopeNode(CUINode* pUINode)
{
  if (!pUINode->IsContainer())
  {
    ASSERT(pUINode->IsContainer());
    return E_INVALIDARG;
  }

  return m_pFrame->SelectScopeItem(pUINode->GetFolderInfo()->GetScopeItem());
}

void CDSComponentData::SortResultPane(CUINode* pUINode)
{
  if(pUINode != NULL)
    m_pFrame->UpdateAllViews(NULL, (LPARAM)pUINode, DS_SORT_RESULT_PANE);
}


HRESULT
CDSComponentData::QueryFromWorkerThread(CThreadQueryInfo* pQueryInfo,
                                             CWorkerThread* pWorkerThread)
{
  HRESULT hr = S_OK;
  if (!m_InitSuccess)
    return E_FAIL;

  //if (IDYES == ::MessageBox (NULL, L"Fail Query ?", L"DS Admin", MB_YESNO))
  //{
  //  return E_FAIL;
  //}

  // function called in the context of a worker thread
  if (IS_CLASS(*pQueryInfo, CDSThreadQueryInfo))
  {
    CDSThreadQueryInfo* pDSQueryInfo = dynamic_cast<CDSThreadQueryInfo*>(pQueryInfo);
    if (pDSQueryInfo != NULL)
    {
      ASSERT(pDSQueryInfo->GetType() != unk);
      if (pDSQueryInfo->GetType() == rootFolder)
      {
        hr = m_ActiveDS->EnumerateRootContainer(pDSQueryInfo, pWorkerThread);
      }
      else if ((pDSQueryInfo->GetType() == dsFolder) || (pDSQueryInfo->GetType() == queryFolder))
      {
        hr = m_ActiveDS->EnumerateContainer(pDSQueryInfo, pWorkerThread);   
      }
    }
    else
    {
      TRACE(_T("Failed to dynamically cast to CDSThreadQueryInfo in CDSComponentData::QueryFromWorkerThread()"));
      ASSERT(FALSE);
      hr = E_OUTOFMEMORY;
    }
  }
  return hr;
}


BOOL CDSComponentData::CanEnableVerb(CUINode* pUINode)
{
  return !m_queryNodeTable.IsLocked(pUINode);
}

int CDSComponentData::GetImage(CUINode* pNode, BOOL bOpen)
{
  ASSERT(pNode != NULL);

  int imageIndex = -1;

  if (m_queryNodeTable.IsPresent(pNode))
  {
    // executing a query, same icon across the board
    imageIndex = m_iconManager.GetWaitIndex();
  }
  else if (pNode->GetExtOp() & OPCODE_ENUM_FAILED) 
  {
    // error condition
    if (pNode == GetRootNode())
      imageIndex = m_iconManager.GetRootErrIndex();
    else
      imageIndex = m_iconManager.GetWarnIndex();
  }
  else
  {
    // normal state icon for the cookie
    if (pNode == GetRootNode())
    {
      // this is the root
      imageIndex = m_iconManager.GetRootIndex();
    }
    else if (IS_CLASS(*pNode, CFavoritesNode))
    {
      imageIndex = m_iconManager.GetFavoritesIndex();
    }
    else if (IS_CLASS(*pNode, CSavedQueryNode))
    {
      CSavedQueryNode* pSavedQueryNode = dynamic_cast<CSavedQueryNode*>(pNode);
      if (pSavedQueryNode->IsValid())
      {
        imageIndex = m_iconManager.GetQueryIndex();
      }
      else
      {
        imageIndex = m_iconManager.GetQueryInvalidIndex();
      }
    }
    else
    {
      imageIndex = pNode->GetImage(bOpen);
    }
  }
  TRACE(_T("CDSComponentData::GetImage() returning: %d\n"), imageIndex);
  return imageIndex;
}

void  CDSComponentData::_SheetLockCookie(CUINode* pNode)
{
  pNode->IncrementSheetLockCount();
  m_sheetNodeTable.Add(pNode);
}

void  CDSComponentData::_SheetUnlockCookie(CUINode* pNode)
{
  pNode->DecrementSheetLockCount();
  m_sheetNodeTable.Remove(pNode);
}

BOOL CDSComponentData::_WarningOnSheetsUp(CUINode* pNode, BOOL bShowMessage, BOOL bActivate)
{
  if (!pNode->IsSheetLocked()) 
    return FALSE; // no warning, all is cool

  if (bShowMessage)
  {
    // warning to user that oeration cannot be performed
    ReportErrorEx (m_hwnd,IDS_SHEETS_UP_DELETE,S_OK,
                   MB_OK | MB_ICONINFORMATION, NULL, 0);
  }

  // need to bring sheets on the foreground and activate it
  m_sheetNodeTable.BringToForeground(pNode, this, bActivate);

  return TRUE;
}

BOOL CDSComponentData::_WarningOnSheetsUp(CInternalFormatCracker* pInternalFormatCracker)
{
  ASSERT(pInternalFormatCracker != NULL);
  if (!pInternalFormatCracker->HasData())
  {
    return FALSE;
  }

  UINT cCookieTotalCount = pInternalFormatCracker->GetCookieCount();

  //
  // protect against operations with sheets up
  //
  BOOL bStop = FALSE;
  BOOL bFirstOne = TRUE;
  for (UINT cCount=0; cCount < cCookieTotalCount; cCount++) 
  {
    CUINode* pUINode = pInternalFormatCracker->GetCookie(cCount);
    if (_WarningOnSheetsUp(pUINode, bFirstOne, bFirstOne)) 
    {
      bStop = TRUE;
      bFirstOne = FALSE;
    }
  } // for

  return bStop;
}


HRESULT CDSComponentData::ColumnsChanged(CDSEvent* pDSEvent, CUINode* pUINode, 
                                         MMC_VISIBLE_COLUMNS* pVisibleColumns, BOOL bRefresh)
{
  ASSERT(pUINode != NULL);
  ASSERT(pUINode->IsContainer());

  if (bRefresh && m_RootNode.IsSheetLocked())
  {
    // warning to user that oeration cannot be performed
    ReportErrorEx (m_hwnd,IDS_SHEETS_UP_COLUMNS_CHANGED,S_OK,
                   MB_OK | MB_ICONINFORMATION, NULL, 0);

    // need to bring sheets on the foreground and activate it
    m_sheetNodeTable.BringToForeground(&m_RootNode, this, TRUE);

    // tell MMC to discard the column changes
    return E_UNEXPECTED;
  }

  CDSColumnSet* pColumnSet = pUINode->GetColumnSet(this);
  pColumnSet->ClearVisibleColumns();

  if (pVisibleColumns != NULL)
  {
    ASSERT(pDSEvent != NULL);
    pDSEvent->SetUpdateAllViewsOrigin(TRUE);
    pColumnSet->AddVisibleColumns(pVisibleColumns);

    // set the dirty flag, need to save to stream to be in sync
    m_bDirty = TRUE;
  }

  m_pFrame->UpdateAllViews(NULL, (LPARAM)pUINode, DS_UPDATE_VISIBLE_COLUMNS);

  if (pDSEvent != NULL)
    pDSEvent->SetUpdateAllViewsOrigin(FALSE);

  if (IS_CLASS(*pUINode, CSavedQueryNode))
  {
    Refresh(pUINode);
  }
  else
  {
    if (bRefresh)
    {
      ASSERT(!m_RootNode.IsSheetLocked()); 
      ::PostMessage(m_pHiddenWnd->m_hWnd, CHiddenWnd::s_RefreshAllNotificationMessage, 0, 0);
    }
  }

  return S_OK;
}

void CDSComponentData::ForceRefreshAll()
{
  m_bDirty = TRUE;
  RefreshAll();
}

HRESULT CDSComponentData::SetRenameMode(CUINode* pUINode)
{
  HRESULT hr = S_OK;

  if (pUINode->IsContainer())
  {
    CUIFolderInfo* pFolderInfo = pUINode->GetFolderInfo();
    hr = m_pFrame->RenameScopeItem(pFolderInfo->GetScopeItem());
  }
  else
  {
    //
    // REVIEW_JEFFJON : Codework to implement for result pane items
    //                  Need to do an UpdateAllViews with new message and handler
    //
  }
  return hr;
}

/////////////////////////////////////////////////////////////////////
// functionality for snapin CoClasses

SnapinType CDSSnapin::QuerySnapinType()   {return SNAPINTYPE_DS;}
SnapinType CDSSnapinEx::QuerySnapinType()   {return SNAPINTYPE_DSEX;}
SnapinType CSiteSnapin::QuerySnapinType() {return SNAPINTYPE_SITE;}

int ResourceIDForSnapinType[SNAPINTYPE_NUMTYPES] =
{
	IDS_DSSNAPINNAME,
	IDS_DS_MANAGER_EX,
	IDS_SITESNAPINNAME
};


/////////////////////////////////////////////////////////////////////
// CDSSnapin (DS standalone)

CDSSnapin::CDSSnapin()
{
	m_lpszSnapinHelpFile = L"dsadmin.chm";
}


/////////////////////////////////////////////////////////////////////
// CDSSnapinEx (DS namespace extension)

CDSSnapinEx::CDSSnapinEx()
{
	m_bRunAsPrimarySnapin = FALSE;
	m_bAddRootWhenExtended = TRUE;
	m_lpszSnapinHelpFile = L"dsadmin.chm";
}


/////////////////////////////////////////////////////////////////////
// CSiteSnapin (Site manager standalone)

CSiteSnapin::CSiteSnapin()
{
	m_lpszSnapinHelpFile = L"dssite.chm";
}


//////////////////////////////////////////////////////////////////////////
// CDSSnapinAbout

CDSSnapinAbout::CDSSnapinAbout()
{
  m_uIdStrProvider = IDS_SNAPIN_PROVIDER;
  m_uIdStrVersion = IDS_SNAPIN_VERSION;
  m_uIdStrDestription = IDS_SNAPINABOUT_DESCRIPTION;
  m_uIdIconImage = IDI_DSADMIN;
  m_uIdBitmapSmallImage = IDB_DSADMIN;
  m_uIdBitmapSmallImageOpen = IDB_DSADMIN;
  m_uIdBitmapLargeImage = IDB_DSADMIN_LG;
  m_crImageMask = RGB(255,0,255);
}

//////////////////////////////////////////////////////////////////////////
// CDSSnapinAbout

CSitesSnapinAbout::CSitesSnapinAbout()
{
  m_uIdStrProvider = IDS_SNAPIN_PROVIDER;
  m_uIdStrVersion = IDS_SNAPIN_VERSION;
  m_uIdStrDestription = IDS_SITES_SNAPINABOUT_DESCRIPTION;
  m_uIdIconImage = IDI_SITEREPL;
  m_uIdBitmapSmallImage = IDB_SITEREPL;
  m_uIdBitmapSmallImageOpen = IDB_SITEREPL;
  m_uIdBitmapLargeImage = IDB_SITEREPL_LG;
  m_crImageMask = RGB(255,0,255);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsevent.cpp ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Administration SnapIn
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSEvent.cpp
//
//  Contents:  Main DS Snapin file
//             This file contains all the interfaces between the snapin and
//             the slate console.  IComponent, IDataObject...etc
//
//  History:   02-Oct-96 WayneSc    Created
//             06-Mar-97 EricB - added Property Page Extension support
//
//-----------------------------------------------------------------------------


#include "stdafx.h"

#include "uiutil.h"
#include "dsutil.h"

#include "dssnap.h"   // Note: this has to be before dsevent.h
#include "DSEvent.h"

#include "ContextMenu.h"
#include "DataObj.h"
#include "dsctx.h"
#include "dsdirect.h"
#include "dsfilter.h"
#include "helpids.h"
#include "query.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// DS Snapin CLSID - {E355E538-1C2E-11d0-8C37-00C04FD8FE93}
const CLSID CLSID_DSSnapin =
 {0xe355e538, 0x1c2e, 0x11d0, {0x8c, 0x37, 0x0, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}};

// DS Snapin Extension CLSID - {006A2A75-547F-11d1-B930-00A0C9A06D2D}
const CLSID CLSID_DSSnapinEx = 
{ 0x6a2a75, 0x547f, 0x11d1, { 0xb9, 0x30, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };

// DS Site CLSID - {d967f824-9968-11d0-b936-00c04fd8d5b0}
const CLSID CLSID_SiteSnapin = { 0xd967f824, 0x9968, 0x11d0, { 0xb9, 0x36, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };

// Default Nodetype GUID - {FC04A81C-1DFA-11D0-8C3b-00C04FD8FE93}
const GUID cDefaultNodeType = 
 {0xFC04A81C, 0x1dfa, 0x11d0, {0x8C, 0x3B, 0x00, 0xC0, 0x4F, 0xD8, 0xFE, 0x93}};

// DS About Snapin CLSID - {c3a904fe-c4f2-11d1-b10b-00104b243180}
const CLSID CLSID_DSAboutSnapin =
 {0xc3a904fe, 0xc4f2, 0x11d1, {0xb1, 0x0b, 0x00, 0x10, 0x4b, 0x24, 0x31, 0x80}};

// DS About Snapin CLSID - {765901ea-c5a1-11d1-b10c-00104b243180}
const CLSID CLSID_SitesAboutSnapin =
 {0x765901ea, 0xc5a1, 0x11d1, {0xb1, 0x0c, 0x00, 0x10, 0x4b, 0x24, 0x31, 0x80}};

// DS Query UI Form extension for saved queries {8C16E7CB-17C2-4729-A669-8474D6712B81}
const CLSID CLSID_DSAdminQueryUIForm = 
{ 0x8c16e7cb, 0x17c2, 0x4729, { 0xa6, 0x69, 0x84, 0x74, 0xd6, 0x71, 0x2b, 0x81 } };

const wchar_t* cszDefaultNodeType = _T("{FC04A81C-1DFA-11d0-8C3B-00C04FD8FE93}");





/////////////////////////////////////////////////////////////////////////////
// CDSEvent

//+-------------------------------------------------------------------------
//
//  Function:   Constructor / Destructor
//
//  Synopsis:
//
//--------------------------------------------------------------------------

CDSEvent::CDSEvent() :
  m_pFrame(NULL),
  m_pHeader(NULL),
  m_pResultData(NULL),
  m_pScopeData(NULL),
  m_pConsoleVerb(NULL),
  m_pRsltImageList(NULL),
  m_pSelectedFolderNode(NULL),
  m_pComponentData( NULL ),
  m_pToolbar(NULL),
  m_pControlbar(NULL),
  m_bUpdateAllViewsOrigin(FALSE)
{
  TRACE(_T("CDSEvent::CDSEvent() - Constructor\n"));
}

CDSEvent::~CDSEvent()
{
  TRACE(_T("CDSEvent::~CDSEvent() - Destructor\n"));

  SetIComponentData( NULL );
}

/////////////////////////////////////////////////////////////////////////////
// IComponent Interfaces

//+-------------------------------------------------------------------------
//
//  Function:   Destroy
//
//  Synopsis:   Used for clean up
//
//--------------------------------------------------------------------------
STDMETHODIMP CDSEvent::Destroy(MMC_COOKIE)
{
  TRACE(_T("CDSEvent::Destroy()\n"));

  if (NULL != m_pHeader)
    m_pFrame->SetHeader(NULL);

  if (NULL != m_pToolbar) 
  {
    m_pToolbar->Release();
  }

  m_pHeader->Release();

  m_pResultData->Release();
  m_pScopeData->Release();
  m_pRsltImageList->Release();
  m_pFrame->Release();
  m_pConsoleVerb->Release();
  return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   Initialize
//
//  Synopsis:   Called everytime the snapin get created.
//
//  Arguments:  IConsole - Pointer to calling object
//
//--------------------------------------------------------------------------

STDMETHODIMP CDSEvent::Initialize(IConsole* pConsole)
{
  TRACE(_T("CDSEvent::Initialize()\n"));
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CWaitCursor wait;

  if (pConsole == NULL)
  {
    // Invalid argument
    return E_POINTER;
  }
	
  // hold on to the frame
  HRESULT hr = pConsole->QueryInterface(IID_IConsole3, (void**)&m_pFrame);
  if (FAILED(hr))
    return hr;
	
  // cache interface pointers we use
  hr = m_pFrame->QueryInterface(IID_IHeaderCtrl, (void**)&m_pHeader);
  if (FAILED(hr))
    return hr;
	
  ASSERT(m_pHeader != NULL);

  hr = m_pFrame->SetHeader(m_pHeader);
  if (FAILED(hr))
    return hr;

  hr = m_pFrame->QueryInterface(IID_IResultData2, (void**)&m_pResultData);
  if (FAILED(hr))
    return hr;
	
  ASSERT(m_pResultData != NULL);

  hr = m_pFrame->QueryInterface(IID_IConsoleNameSpace, (void**)&m_pScopeData);
  if (FAILED(hr))
    return hr;
	
  ASSERT(m_pScopeData != NULL);

  hr = m_pFrame->QueryResultImageList(&m_pRsltImageList);
  if (FAILED(hr))
    return hr;
	
  ASSERT(m_pRsltImageList != NULL);

  hr = m_pFrame->QueryConsoleVerb (&m_pConsoleVerb);
  if (FAILED(hr))
    return hr;

  m_hwnd = m_pComponentData->GetHWnd();

  return S_OK;
}


STDMETHODIMP CDSEvent::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
  TRACE(_T("CDSEvent::GetDataObject()\n"));

  HRESULT hr=S_OK;

  CUINode* pUINode;
  CDSDataObject* const pDataObject = new CComObject<CDSDataObject>;
  ASSERT(pDataObject != 0);

  pDataObject->SetType(type, m_pComponentData->QuerySnapinType());
  pDataObject->SetComponentData(m_pComponentData);

  if (cookie != MMC_MULTI_SELECT_COOKIE)
  {
    pUINode = reinterpret_cast<CUINode*>(cookie);
    pDataObject->SetCookie(pUINode);
  } 
  else 
  {
    TRACE(_T("CDSEvent::GetDataObject() - multi-select.\n"));
    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;
    rdi.nState = LVIS_SELECTED;
    
    do
    {
      rdi.lParam = 0;
      ASSERT(rdi.mask == RDI_STATE);
      ASSERT(rdi.nState == LVIS_SELECTED);
      hr = m_pResultData->GetNextItem(&rdi);
      if (hr != S_OK)
        break;
      
      pUINode = reinterpret_cast<CUINode*>(rdi.lParam);
      pDataObject->AddCookie(pUINode);
    } while (1);
    
  }

  // addref() the new pointer and return it.
  pDataObject->AddRef();
  *ppDataObject = pDataObject;
  TRACE(_T("new data object is at %lx(%lx).\n"),
           pDataObject, *pDataObject);
  return hr;
}



STDMETHODIMP CDSEvent::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
  ASSERT(pResult != NULL);
  HRESULT hr = S_OK;
 
  // get the node we are interested in
  CUINode* pUINode = reinterpret_cast<CUINode*>(pResult->lParam);
  ASSERT( NULL != pUINode );

  if (pResult->mask & RDI_STR)  
  {
    // need string value

    // get the parent to retrieve the column set
    CUINode* pUIParentNode = pUINode->GetParent();
    ASSERT(pUIParentNode != NULL);
    ASSERT(pUIParentNode->IsContainer());

    // retrieve the column set
    CDSColumnSet* pColumnSet = pUIParentNode->GetColumnSet(m_pComponentData);
    ASSERT(pColumnSet != NULL);

    // ask the node to provide the string for the 
    // given column in the column set
    pResult->str = const_cast<LPWSTR>(pUINode->GetDisplayString(pResult->nCol, pColumnSet));
  }

  if (pResult->mask & RDI_IMAGE) 
  {
    // need an icon for result pane
    pResult->nImage = m_pComponentData->GetImage(pUINode, FALSE);
  }

  return hr;
}

/////////////////////////////////////////////////////////////////////////////
//IResultCallback

STDMETHODIMP CDSEvent::GetResultViewType(MMC_COOKIE, LPWSTR* ppViewType, 
                                         long *pViewOptions)
{
  *ppViewType = NULL;
  *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;

  return S_FALSE;
}


//+----------------------------------------------------------------------------
//
//  Member:     CDSEvent::IExtendPropertySheet::CreatePropertyPages
//
//  Synopsis:   Called in response to a user click on the Properties context
//              menu item.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDSEvent::CreatePropertyPages(LPPROPERTYSHEETCALLBACK pCall,
                              LONG_PTR lNotifyHandle,
                              LPDATAOBJECT pDataObject)
{
  IExtendPropertySheet * pEPS = (IExtendPropertySheet *)m_pComponentData;
  return pEPS->CreatePropertyPages(pCall, lNotifyHandle, pDataObject);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDSEvent::IExtendPropertySheet::QueryPagesFor
//
//  Synopsis:   Called before a context menu is posted. If we support a
//              property sheet for this object, then return S_OK.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDSEvent::QueryPagesFor(LPDATAOBJECT pDataObject)
{
  TRACE(TEXT("CDSEvent::QueryPagesFor().\n"));
  return m_pComponentData->QueryPagesFor( pDataObject);
}   

//+---------------------------------------------------------------------------
//
//  Function:   LocaleStrCmp
//
//  Synopsis:   Do a case insensitive string compare that is safe for any
//              locale.
//
//  Arguments:  [ptsz1] - strings to compare
//              [ptsz2]
//
//  Returns:    -1, 0, or 1 just like lstrcmpi
//
//  History:    10-28-96   DavidMun   Created
//
//  Notes:      This is slower than lstrcmpi, but will work when sorting
//              strings even in Japanese.
//
//----------------------------------------------------------------------------

int LocaleStrCmp(LPCTSTR ptsz1, LPCTSTR ptsz2)
{
    int iRet = 0;

    iRet = CompareString(LOCALE_USER_DEFAULT,
                         NORM_IGNORECASE        |
                           NORM_IGNOREKANATYPE  |
                           NORM_IGNOREWIDTH,
                         ptsz1,
                         -1,
                         ptsz2,
                         -1);

    if (iRet)
    {
        iRet -= 2;  // convert to lstrcmpi-style return -1, 0, or 1

        if ( 0 == iRet )
        {
            UNICODE_STRING unistr1;
            unistr1.Length = (USHORT)(::lstrlen(ptsz1)*sizeof(WCHAR));
            unistr1.MaximumLength = unistr1.Length;
            unistr1.Buffer = (LPWSTR)ptsz1;
            UNICODE_STRING unistr2;
            unistr2.Length = (USHORT)(::lstrlen(ptsz2)*sizeof(WCHAR));
            unistr2.MaximumLength = unistr2.Length;
            unistr2.Buffer = (LPWSTR)ptsz2;
            iRet = ::RtlCompareUnicodeString(
                &unistr1,
                &unistr2,
                FALSE );
        }
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        if (dwErr != 0)
        {
          TRACE3 ("CompareString (%s, %s) failed: 0x%x\n", ptsz1, ptsz2, dwErr);
        }
    }
    return iRet;
}
//+----------------------------------------------------------------------------
//
//  Member:     CDSEvent::IResultDataCompareEx::Compare
//
//  Synopsis:   called to do the comparison for sorting in the result
//              pane
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDSEvent::Compare(RDCOMPARE* prdc, int* pnResult)
{
  HRESULT hr = S_OK;
  if (pnResult == NULL)
  {
    ASSERT(FALSE);
    return E_POINTER;
  }

  *pnResult = 0;
  if (prdc == NULL) 
  {
    ASSERT(FALSE);
    return E_POINTER;
  }
 
	CUINode* pUINodeA = reinterpret_cast<CUINode*>(prdc->prdch1->cookie);
	CUINode* pUINodeB = reinterpret_cast<CUINode*>(prdc->prdch2->cookie);
	ASSERT(pUINodeA != NULL);
	ASSERT(pUINodeB != NULL);
	
  if ( (pUINodeA == NULL) || (pUINodeB == NULL) )
  {
    return E_INVALIDARG;
  }

  CString strA, strB;

  CDSColumnSet* pColSetA = pUINodeA->GetParent()->GetColumnSet(m_pComponentData);
  CDSColumnSet* pColSetB = pUINodeB->GetParent()->GetColumnSet(m_pComponentData);

  if ((pColSetA == NULL) || (pColSetB == NULL))
  {
    return E_INVALIDARG;
  }

  CDSColumn* pColA = (CDSColumn*)pColSetA->GetColumnAt(prdc->nColumn);

  if (IS_CLASS(CDSUINode, *pUINodeA) && IS_CLASS(CDSUINode, *pUINodeB))
  {
    //
    // extract cookie info (DS objects)
    //
    CDSCookie* pCookieA = GetDSCookieFromUINode(pUINodeA);
    CDSCookie* pCookieB = GetDSCookieFromUINode(pUINodeB);
    if ( (pCookieB == NULL) || (pCookieA == NULL)) 
    {
      return E_INVALIDARG;
    }

    switch (pColA->GetColumnType()) 
    {
    case ATTR_COLTYPE_NAME:  //name
      strA = pCookieA->GetName();
      strB = pCookieB->GetName();

      *pnResult = LocaleStrCmp(strA, strB);
      break;

    case ATTR_COLTYPE_CLASS:  //class
      strA = pCookieA->GetLocalizedClassName();
      strB = pCookieB->GetLocalizedClassName();

      *pnResult = LocaleStrCmp(strA, strB);
      break;

    case ATTR_COLTYPE_DESC:  //description
      strA = pCookieA->GetDesc();
      strB = pCookieB->GetDesc();

      *pnResult = LocaleStrCmp(strA, strB);
      break;

    case ATTR_COLTYPE_SPECIAL: //special columns
      {
        int nSpecialCol = 0;
        int idx = 0;
        POSITION pos = pColSetA->GetHeadPosition();
        while (idx < prdc->nColumn && pos != NULL) // JonN 4/3/01 313564
        {
          CDSColumn* pColumn = (CDSColumn*)pColSetA->GetNext(pos);
          ASSERT(pColumn != NULL);

          if ((pColumn->GetColumnType() == ATTR_COLTYPE_SPECIAL || pColumn->GetColumnType() == ATTR_COLTYPE_MODIFIED_TIME) && 
                pColumn->IsVisible())
          {
            nSpecialCol++;
          }

          idx++;
        }
        CStringList& strlistA = pCookieA->GetParentClassSpecificStrings();
        POSITION posA = strlistA.FindIndex( nSpecialCol );
        CStringList& strlistB = pCookieB->GetParentClassSpecificStrings();
        POSITION posB = strlistB.FindIndex( nSpecialCol );
        if ( NULL != posA && NULL != posB)
        {
          strA = strlistA.GetAt( posA );
          strB = strlistB.GetAt( posB );
        }
        *pnResult = LocaleStrCmp(strA, strB);
        break;
      }
    case ATTR_COLTYPE_MODIFIED_TIME:
      {
        SYSTEMTIME* pTimeA = pCookieA->GetModifiedTime();
        SYSTEMTIME* pTimeB = pCookieB->GetModifiedTime();
        if (pTimeA == NULL)
        {
          *pnResult = -1;
          break;
        }
        else if (pTimeB == NULL)
        {
          *pnResult = 1;
          break;
        }

        FILETIME fileTimeA, fileTimeB;
 
        if (!SystemTimeToFileTime(pTimeA, &fileTimeA))
          return E_FAIL;

        if (!SystemTimeToFileTime(pTimeB, &fileTimeB))
          return E_FAIL;

        *pnResult = CompareFileTime(&fileTimeA, &fileTimeB);
        break;
      }
    default:
      return E_INVALIDARG;
    }
  }
  else // Not DS objects
  {
    strA = pUINodeA->GetDisplayString(prdc->nColumn, pColSetA);
    strB = pUINodeB->GetDisplayString(prdc->nColumn, pColSetB);
    *pnResult = LocaleStrCmp(strA, strB);
  }

  //  TRACE(_T("Compare: %d\n"), *pnResult);
  return hr;
}   


//+----------------------------------------------------------------------------
//
//  Member:     CDSEvent::IComponent::CompareObjects
//
//  Synopsis:   If the data objects belong to the same DS object, then return
//              S_OK.
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDSEvent::CompareObjects(LPDATAOBJECT pDataObject1, LPDATAOBJECT pDataObject2)
{
  //
  // Delegate to the IComponentData implementation.
  //
  return m_pComponentData->CompareObjects(pDataObject1, pDataObject2);
}


STDMETHODIMP CDSEvent::Notify(IDataObject * pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = S_FALSE;
  CInternalFormatCracker dobjCracker;
  CUINode* pUINode = NULL;

  if (pDataObject != NULL) 
  {
    if (FAILED(dobjCracker.Extract(pDataObject))) 
    {
      if ( (event == MMCN_ADD_IMAGES) && !m_pComponentData->m_bRunAsPrimarySnapin ) 
      {
        m_pComponentData->FillInIconStrip (m_pRsltImageList);
      }
      return S_OK;
    }
    
    pUINode = dobjCracker.GetCookie();
  }

  if (event == MMCN_PROPERTY_CHANGE)
  {
    CWaitCursor cwait;
    TRACE(_T("CDSEvent::Notify() - property change, pDataObj = 0x%08x, param = 0x%08x, arg = %d.\n"),
          pDataObject, param, arg);
    if (param != 0)
    {
      hr = m_pComponentData->_OnPropertyChange((LPDATAOBJECT)param, FALSE);
      if (FAILED(hr))
      {
         hr = S_FALSE;
      }
    }
    return S_OK;
  }

  // some of the MMCN_VIEW_CHANGE, MMCN_CUTORMOVE messages have a NULL data object
  if ((event != MMCN_VIEW_CHANGE) && (event != MMCN_CUTORMOVE) && (pUINode == NULL))
    return S_FALSE;

  switch (event)
    {
    case MMCN_SHOW:
      if (arg == TRUE) 
      { // Show
        CWaitCursor cwait;
        _EnumerateCookie(pUINode,(HSCOPEITEM)param,event);
        hr = S_OK;
      } 
        
      break;

    case MMCN_MINIMIZED:
      hr = S_FALSE;
      break;

    case MMCN_SELECT:
      {
        BOOL bScope = LOWORD(arg);
        BOOL bSelect = HIWORD(arg);

        CContextMenuVerbs* pMenuVerbs = pUINode->GetContextMenuVerbsObject(m_pComponentData);

        if (pMenuVerbs == NULL)
        {
          ASSERT(FALSE);
          return S_FALSE;
        }
        pMenuVerbs->LoadStandardVerbs(m_pConsoleVerb, 
                                           bScope/*bScope*/, 
								                           bSelect/*bSelect*/, 
                                           pUINode,
                                           pDataObject);
        hr = S_OK;
      }
      break;

    case MMCN_DELETE:
      {
        CWaitCursor cwait;
        _Delete(pDataObject, &dobjCracker);
        hr = S_OK;
      }
      break;

    case MMCN_QUERY_PASTE:
      {
        hr = _QueryPaste(pUINode, (IDataObject*)(arg));
	      if (FAILED(hr))
        {
           hr = S_FALSE;
        }
      }
      break;

    case MMCN_PASTE:
      {
        CWaitCursor cwait;
        _Paste(pUINode, (IDataObject*)(arg), (LPDATAOBJECT*)param);
        hr = S_OK;
      }
      break;
    
    case MMCN_CUTORMOVE:
      {
        CWaitCursor cwait;
        ASSERT(pUINode == NULL);
        _CutOrMove((IDataObject*)(arg));
        hr = S_OK;
      }
      break;

    case MMCN_RENAME:
      {
        CWaitCursor cwait;

        hr = m_pComponentData->_Rename (pUINode, 
                                    (LPWSTR) param);
        if (SUCCEEDED(hr)) 
        {
          m_pFrame->UpdateAllViews (pDataObject,
                                    (LPARAM)pUINode,
                                    DS_RENAME_OCCURRED);

          MMC_SORT_SET_DATA* pColumnData = NULL;

          CDSColumnSet* pColumnSet = pUINode->GetParent()->GetColumnSet(m_pComponentData);
          if (pColumnSet == NULL)
            break;

          LPCWSTR lpszID = pColumnSet->GetColumnID();
          size_t iLen = wcslen(lpszID);

          //
          // allocate enough memory for the struct and the guid
          //
          SColumnSetID* pNodeID = (SColumnSetID*)malloc(sizeof(SColumnSetID) + (iLen * sizeof(WCHAR)));
          if (pNodeID != NULL)
          {
            memset(pNodeID, 0, sizeof(SColumnSetID) + (iLen * sizeof(WCHAR)));
            pNodeID->cBytes = static_cast<ULONG>(iLen * sizeof(WCHAR));
            memcpy(pNodeID->id, lpszID, (iLen * sizeof(WCHAR)));

            CComPtr<IColumnData> spColumnData;
            hr = m_pFrame->QueryInterface(IID_IColumnData, (void**)&spColumnData);
            if (spColumnData != NULL)
            {
              hr = spColumnData->GetColumnSortData(pNodeID, &pColumnData);
            }

            if (SUCCEEDED(hr))
            {
              if (pColumnData != NULL)
              {
                if (pColumnData->pSortData[0].nColIndex == 0)
                {
                  m_pFrame->UpdateAllViews(NULL,
                                            (LPARAM)pUINode->GetParent(),
                                            DS_SORT_RESULT_PANE);
                }
                CoTaskMemFree(pColumnData);
              }
            }
            else
            {
              hr = S_FALSE;
            }
            free(pNodeID);
          }
        }
        else
        {
          hr = S_FALSE;
        }
      }
      break;

    case MMCN_VIEW_CHANGE:
      {
        CWaitCursor cwait;
        TRACE (_T("CDSEvent::Notify() - view change message.\n"));
        HandleViewChange (pDataObject, arg, param);
        hr = S_OK;
      }
      break;

    case MMCN_ADD_IMAGES:
      {
        CWaitCursor cwait;
        m_pComponentData->FillInIconStrip (m_pRsltImageList);
        hr = S_OK;
      }
      break;

    case MMCN_REFRESH:
      {
        CWaitCursor cwait;
        m_pComponentData->Refresh(pUINode);
        hr = S_OK;
      }
      break;
    case MMCN_DBLCLICK:
      hr =  S_FALSE;
      break;
    case MMCN_COLUMN_CLICK:
      hr = S_OK;
      break;
    case MMCN_COLUMNS_CHANGED:
      {
        CWaitCursor cwait;
        MMC_VISIBLE_COLUMNS* pVisibleColumns = reinterpret_cast<MMC_VISIBLE_COLUMNS*>(param);
        // Delegate to IComponentData
        hr = m_pComponentData->ColumnsChanged(this, pUINode, pVisibleColumns, TRUE);
        if (FAILED(hr))
        {
          hr = S_FALSE;
        }
      }
      break;
    case MMCN_RESTORE_VIEW :
      {
        CWaitCursor cwait;
        m_pComponentData->ColumnsChanged(this, pUINode, NULL, FALSE);
        *((BOOL*)param) = TRUE;
        hr = S_OK;
      }
      break;
    case MMCN_CONTEXTHELP:
      {
        CWaitCursor cwait;

        IDisplayHelp * phelp = NULL;
        hr = m_pFrame->QueryInterface (IID_IDisplayHelp, 
                                  (void **)&phelp);
        CString strDefTopic;
        if (SUCCEEDED(hr)) 
        {
          if (m_pComponentData->QuerySnapinType() == SNAPINTYPE_SITE) 
          {
            strDefTopic = DSSITES_DEFAULT_TOPIC;
          } 
          else 
          {
            strDefTopic = DSADMIN_DEFAULT_TOPIC;
          }
          phelp->ShowTopic ((LPWSTR)(LPCWSTR)strDefTopic);
          phelp->Release();
        } 
        else 
        {
          ReportErrorEx (m_hwnd, IDS_HELPLESS, hr, NULL, 0);
          hr = S_FALSE;
        }
        if (FAILED(hr))
        {
           hr = S_FALSE;
        }
      }
      break;

    default:
      hr = S_FALSE;
   }

  return hr;

}


/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu

STDMETHODIMP CDSEvent::AddMenuItems(IDataObject*          piDataObject,
                                    IContextMenuCallback* piCallback,
                                    long *pInsertionAllowed)
{
  TRACE(_T("CDSEvent::AddExtensionContextMenuItems()\n"));
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  HRESULT hr;
  CWaitCursor cwait;
  CInternalFormatCracker dobjCracker;

  hr = dobjCracker.Extract(piDataObject);
  if (FAILED(hr))
  {
    return hr;
  }

  DATA_OBJECT_TYPES dotType = dobjCracker.GetType();
  CUINode* pUINode = dobjCracker.GetCookie();

  //
  // Retrieve the verb handler from the node
  // NOTE: multi-selection is handled by cracking the dataobject not by which node
  //       is called to retrieve the CContextMenuVerbs object
  //
  CContextMenuVerbs* pMenuVerbs = pUINode->GetContextMenuVerbsObject(m_pComponentData);
  if (pMenuVerbs == NULL)
  {
    ASSERT(FALSE);
    return E_FAIL;
  }

  CComPtr<IContextMenuCallback2> spContextMenuCallback2;
  hr = piCallback->QueryInterface(IID_IContextMenuCallback2, (PVOID*)&spContextMenuCallback2);
  if (FAILED(hr))
  {
    ASSERT(FALSE && L"Unable to QI for the IContextMenuCallback2 interface.");
    return hr;
  }

  if (dotType == CCT_RESULT) 
  {
    pMenuVerbs->LoadStandardVerbs(m_pConsoleVerb, FALSE/*bScope*/, TRUE /*bSelect*/, pUINode, piDataObject);

    //
    // Create the main menu, if allowed
    //
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) 
    {
      hr = pMenuVerbs->LoadMainMenu(spContextMenuCallback2,piDataObject,pUINode);
      hr = pMenuVerbs->LoadMenuExtensions(spContextMenuCallback2,
                                          m_pComponentData->m_pShlInit,
                                          piDataObject,
                                          pUINode);
    }
    
    if (SUCCEEDED(hr)) 
    {
      // create the task menu
      if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) 
      {
        hr = pMenuVerbs->LoadTaskMenu(spContextMenuCallback2,pUINode);
      }
    }
  } 
  else if (dotType == CCT_SCOPE) 
  {
    
    pMenuVerbs->LoadStandardVerbs(m_pConsoleVerb, TRUE/*bScope*/, TRUE /*bSelect*/, pUINode, piDataObject);
    
    hr = m_pComponentData->AddMenuItems (piDataObject,
                                         piCallback,
                                         pInsertionAllowed);
  } 
  else // CCT_UNINITIALIZED
  { 
    if (dobjCracker.GetCookieCount() > 1) 
    {
      hr = pMenuVerbs->LoadMenuExtensions(spContextMenuCallback2,
                                          m_pComponentData->m_pShlInit,
                                          piDataObject,
                                          pUINode);
    }
  }
  ASSERT( SUCCEEDED(hr) );
  return hr;
}

STDMETHODIMP CDSEvent::Command(long lCommandID, IDataObject * pDataObject)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  TRACE(_T("CDSEvent::Command()\n"));

  CWaitCursor CWait;

  // crack data object

  CInternalFormatCracker dobjCracker;
  HRESULT hr = dobjCracker.Extract(pDataObject);
  if (FAILED(hr)) 
  {
    ASSERT(FALSE); // not our data object
    return hr;
  }

  DATA_OBJECT_TYPES dotType = dobjCracker.GetType();
  if (dotType == CCT_SCOPE) 
  {
    // if called from the tree view context, delegate to ComponentData
    return m_pComponentData->Command(lCommandID, pDataObject);
  }
  
  // context menu shell extensions
  if ((lCommandID >= MENU_MERGE_BASE) && (lCommandID <= MENU_MERGE_LIMIT)) 
  {
    return _CommandShellExtension(lCommandID, pDataObject);
  }

  // standard commands
  CUINode* pUINode = dobjCracker.GetCookie();
  CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);
  
  if ( (pUINode == NULL) ||(pCookie==NULL) )
  {
    ASSERT(FALSE); // Invalid Cookie
    return E_INVALIDARG;
  }
    
  switch (lCommandID) 
  {
  case IDM_GEN_TASK_MOVE:
   {
     CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(pUINode);
     ASSERT(pDSUINode != NULL);

     CDSCookie* pMoveCookie = pDSUINode->GetCookie();

     hr = m_pComponentData->GetActiveDS()->MoveObject(pMoveCookie);
     if (hr == S_OK) 
     {
       CUINode* pNewParentNode = NULL;
       hr = m_pComponentData->FindParentCookie(pMoveCookie->GetPath(), &pNewParentNode);
       if ((hr == S_OK) && (pNewParentNode->GetFolderInfo()->IsExpanded())) 
       {
         pNewParentNode->GetFolderInfo()->AddNode(pUINode);
       }
       m_pFrame->UpdateAllViews(pDataObject, (LPARAM)pUINode, DS_MOVE_OCCURRED);
     }
   }     
   break;

  default:
   ;
  } // switch

  return S_OK;
}


HRESULT CDSEvent::_CommandShellExtension(long nCommandID, LPDATAOBJECT pDataObject)
{
  CWaitCursor wait;

  // initialize shell code with data object
  IShellExtInit* pShlInit = m_pComponentData->m_pShlInit; // local copy, no addref
  HRESULT hr = pShlInit->Initialize(NULL, pDataObject, 0);
  if (FAILED(hr)) 
  {
    TRACE(TEXT("pShlInit->Initialize failed, hr: 0x%x\n"), hr);
    return hr;
  }

  // get the context menu specific interface
  CComPtr<IContextMenu> spICM;
  hr = pShlInit->QueryInterface(IID_IContextMenu, (void **)&spICM);
  if (FAILED(hr)) 
  {
    TRACE(TEXT("pShlInit->QueryInterface(IID_IContextMenu, ...) failed, hr: 0x%x\n"), hr);
    return hr;
  }

  // invoke the shell extension command
  HWND hwnd;
  CMINVOKECOMMANDINFO cmiCommand;
  hr = m_pFrame->GetMainWindow (&hwnd);
  ASSERT (hr == S_OK);
  cmiCommand.hwnd = hwnd;
  cmiCommand.cbSize = sizeof (CMINVOKECOMMANDINFO);
  cmiCommand.fMask = SEE_MASK_ASYNCOK;
  cmiCommand.lpVerb = MAKEINTRESOURCEA(nCommandID - MENU_MERGE_BASE);
  spICM->InvokeCommand (&cmiCommand);


  CInternalFormatCracker dobjCracker;
  hr = dobjCracker.Extract(pDataObject);
  if (FAILED(hr)) 
  {
    ASSERT(FALSE); // not our data object
    return hr;
  }


  // -----------------------------------------------------------------
  // code to update the views if the extension says it moved items
  //
  TRACE(_T("Command: returned from extension commdand\n"));

  CUINodeList nodesMoved;

  HSCOPEITEM ItemID;
  CUINode* pCurrentParentNode = NULL;
  CUINode* pNewParentNode = NULL;

  for (UINT index = 0; index < dobjCracker.GetCookieCount(); index ++) 
  {
    CUINode* pUINode = dobjCracker.GetCookie(index);

    // make sure the node moved is of the right type: for the time
    // being we just deal with DS objects
    if (!IS_CLASS(*pUINode, CDSUINode))
    {
      ASSERT(FALSE); // should not get here
      continue;
    }
    CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);

    if (pUINode->GetExtOp() & OPCODE_MOVE) 
    {
      if (pNewParentNode == NULL) 
      {
        // get the parent from the first node
        // assume that all have the same parent
        m_pComponentData->FindParentCookie(pCookie->GetPath(), &pNewParentNode);
      }

      pCurrentParentNode = pUINode->GetParent();
      if (pCurrentParentNode &&
          IS_CLASS(*pCurrentParentNode, CDSUINode))
      {
         if (pUINode->IsContainer()) 
         {
           ItemID = pUINode->GetFolderInfo()->GetScopeItem();

           // delete the scope item in MMC
           hr = m_pComponentData->m_pScope->DeleteItem(ItemID, TRUE);
           ASSERT(SUCCEEDED(hr));
#ifdef DBG
           if (FAILED(hr)) 
           {
             TRACE(_T("DeleteItem failed on %lx (%s).\n"),
                   ItemID, pUINode->GetName());
           }
           TRACE(_T("Move postprocessing - deleted scope node: %x (%s)\n"),
                 ItemID, pUINode->GetName());
#endif
           if (pCurrentParentNode) 
           {
             pCurrentParentNode->GetFolderInfo()->RemoveNode(pUINode);
           }
        

           if ((pNewParentNode) && pNewParentNode->GetFolderInfo()->IsExpanded()) 
           {
             pUINode->ClearParent();
             pNewParentNode->GetFolderInfo()->AddNode(pUINode);
             hr = m_pComponentData->_AddScopeItem(pUINode, pNewParentNode->GetFolderInfo()->GetScopeItem());
#ifdef DBG
             if (FAILED(hr)) 
             {
               TRACE(_T("AddItem failed on %lx (%s).\n"),
                     ItemID, pUINode->GetName());
             }
             TRACE(_T("Move postprocessing - added scope node: %s\n"),
                   pUINode->GetName());
#endif
           } 
           else 
           {
             // not expanded
             delete pCookie;
             pCookie = NULL;
           }
         } 
         else 
         {
           // not a container
           if ((pNewParentNode) &&
               (pNewParentNode->GetFolderInfo()->IsExpanded())) 
           {
             pUINode->ClearParent();
             pNewParentNode->GetFolderInfo()->AddNode(pUINode);
           }
           nodesMoved.AddTail(pUINode);
         }
      }
      if (pUINode) 
      {
        pUINode->SetExtOp(NULL);
      }
    }
  } // for items in multiple selection


  if (!nodesMoved.IsEmpty()) 
  {
    m_pFrame->UpdateAllViews(NULL, (LPARAM)&nodesMoved, DS_MULTIPLE_MOVE_OCCURRED);
  }
  //------------------------------ends here--------------------------------------
  m_pComponentData->SortResultPane(pNewParentNode);
          
  return S_OK;
}

HRESULT CDSEvent::_InitView(CUINode* pUINode)
{
  CWaitCursor wait;

  HRESULT hr=S_OK;

  //
  // This is more a suggestion than anything so its OK to ignore the return value but
  // we will ASSERT for testing purposes
  //
  hr = m_pResultData->ModifyViewStyle(MMC_ENSUREFOCUSVISIBLE, (MMC_RESULT_VIEW_STYLE)0);
  ASSERT(SUCCEEDED(hr));

  hr=_SetColumns(pUINode);

  m_pSelectedFolderNode = pUINode;

  return hr;
}


HRESULT CDSEvent::_EnumerateCookie(CUINode* pUINode, HSCOPEITEM hParent, MMC_NOTIFY_TYPE event)
{
  TRACE(_T("CDSEvent::_EnumerateCookie()\n"));
  HRESULT hr = S_OK;

  CWaitCursor cwait;

  if ( (pUINode == NULL) || (!pUINode->IsContainer()) )
  {
    ASSERT(FALSE);  // Invalid Arguments
    return E_INVALIDARG;
  }

  if (MMCN_SHOW == event) 
  {
    _InitView(pUINode);

    if (!pUINode->GetFolderInfo()->IsExpanded()) 
    {
      m_pComponentData->_OnExpand(pUINode, hParent, event);
    }

    _DisplayCachedNodes(pUINode);
    pUINode->GetFolderInfo()->UpdateSerialNumber(m_pComponentData);

    if (pUINode->GetFolderInfo()->GetSortOnNextSelect())
    {
      m_pFrame->UpdateAllViews(NULL, (LPARAM)pUINode, DS_SORT_RESULT_PANE);
      pUINode->GetFolderInfo()->SetSortOnNextSelect(FALSE);
    }

  }
  return hr;
}


HRESULT CDSEvent::_DisplayCachedNodes(CUINode* pUINode)
{
  if ( (pUINode == NULL) || (!pUINode->IsContainer()) )
  {
    ASSERT(FALSE);  // Invalid Arguments
    return E_INVALIDARG;
  }

  HRESULT hr = S_OK;

  // Add the leaf nodes
  CUINodeList* pLeafList = pUINode->GetFolderInfo()->GetLeafList();

  for (POSITION pos = pLeafList->GetHeadPosition(); pos != NULL; )
  {
    POSITION prevPos = pos;
    CUINode* pCurrChildUINode = pLeafList->GetNext(pos);
    ASSERT(pCurrChildUINode != NULL);
    if (pCurrChildUINode->GetExtOp() & OPCODE_MOVE)
    {
      pLeafList->RemoveAt(prevPos);
      pCurrChildUINode->SetExtOp(NULL);
      delete pCurrChildUINode;
    }
    else
    {
      hr = _AddResultItem(pCurrChildUINode);
    }
  }

  _UpdateObjectCount(FALSE /* set count to 0?*/);

  return S_OK;
}


HRESULT CDSEvent::_AddResultItem(CUINode* pUINode, BOOL bSetSelect)
{
  if (pUINode == NULL) 
  {
    ASSERT(FALSE);  // Invalid Arguments
    return E_INVALIDARG;
  }


  HRESULT hr = S_OK;

  RESULTDATAITEM rdiListView;
  ZeroMemory(&rdiListView, sizeof(RESULTDATAITEM));

  rdiListView.lParam = reinterpret_cast<LPARAM>(pUINode);
  rdiListView.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
  rdiListView.str = MMC_CALLBACK;
  rdiListView.nImage = MMC_IMAGECALLBACK;

  if (bSetSelect)
  {
    rdiListView.mask |= RDI_STATE;
    rdiListView.nState = LVIS_SELECTED | LVIS_FOCUSED;
  }
  return hr = m_pResultData->InsertItem(&rdiListView);
}

HRESULT CDSEvent::SelectResultNode(CUINode* pUINode)
{
  HRESULTITEM ItemID = 0;
  HRESULT hr = m_pResultData->FindItemByLParam ((LPARAM)pUINode, &ItemID);
  if (SUCCEEDED(hr)) 
  {
    hr = m_pResultData->ModifyItemState(0 /*unused*/,
                                        ItemID,
                                        LVIS_FOCUSED | LVIS_SELECTED,
                                        0 /*no removing*/);
  }
  return hr;
}

void CDSEvent::_DeleteSingleSel(IDataObject* pDataObject, CUINode* pUINode)
{
  ASSERT(!pUINode->IsContainer());
  HRESULT hr = S_OK;

  //
  // Get the parent container for later use
  //
  CUINode* pParentNode = pUINode->GetParent();
  ASSERT(pParentNode != NULL);

  CDSCookie* pCookie = NULL;
  if (IS_CLASS(*pUINode, CDSUINode))
  {
    pCookie = GetDSCookieFromUINode(pUINode);

    if (pCookie == NULL)
    {
      return;
    }

    //
    // delete from the back end 
    // this call will handle the notifification to extensions
    //
    hr = m_pComponentData->_DeleteFromBackEnd(pDataObject, pCookie); 
  }
  else
  {
    hr = pUINode->Delete(m_pComponentData);
  }

  //
  // update the result pane
  //
  if (SUCCEEDED(hr) && (hr != S_FALSE)) 
  {
    m_pFrame->UpdateAllViews(NULL, (LPARAM)pUINode, DS_DELETE_OCCURRED);
  } 

  //
  // Remove the '+' next to the parent in the UI if this is the last container
  // object in this container
  //
  if (pParentNode != NULL &&
      pParentNode->GetFolderInfo()->GetContainerList()->GetCount() == 0)
  {
    SCOPEDATAITEM sdi;
    memset(&sdi, 0, sizeof(SCOPEDATAITEM));

    sdi.ID = pParentNode->GetFolderInfo()->GetScopeItem();
    sdi.mask |= SDI_CHILDREN;
    sdi.cChildren = 0;

    hr = m_pScopeData->SetItem(&sdi);
  }

}






///////////////////////////////////////////////////////////////////////////
// CResultPaneMultipleDeleteHandler

class CResultPaneMultipleDeleteHandler : public CMultipleDeleteHandlerBase
{
public:
  CResultPaneMultipleDeleteHandler(CDSComponentData* pComponentData, HWND hwnd,
                                    IDataObject* pDataObject, 
                                    CInternalFormatCracker* pObjCracker,
                                    CUINodeList* pNodesDeletedList)
                                    : CMultipleDeleteHandlerBase(pComponentData, hwnd)
  {
    m_pDataObject = pDataObject;
    m_pObjCracker = pObjCracker;
    m_pNodesDeletedList = pNodesDeletedList;
  }

protected:
  virtual UINT GetItemCount() { return m_pObjCracker->GetCookieCount();}
  virtual HRESULT BeginTransaction()
  {
    return GetTransaction()->Begin(m_pDataObject, NULL, NULL, FALSE);
  }
  virtual HRESULT DeleteObject(UINT i)
  {
    CUINode* pUINode = m_pObjCracker->GetCookie(i);
    CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);

    if (pCookie != NULL)
    {
      // need to pass full ADSI path to ObjectDeletionCheck
      CString strPath;
      GetComponentData()->GetBasePathsInfo()->ComposeADsIPath(
            strPath, pCookie->GetPath());

      bool fAlternateDeleteMethod = false;
      HRESULT hr = ObjectDeletionCheck(
            strPath,
            pCookie->GetName(),
            pCookie->GetClass(),
            fAlternateDeleteMethod );
      if (  FAILED(hr)
         || HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr
         || fAlternateDeleteMethod )
        return hr;
    }

    return GetComponentData()->GetActiveDS()->DeleteObject(pCookie,
                                                           FALSE); //raise UI for error?
  }
  virtual HRESULT DeleteSubtree(UINT i)
  {
    CUINode* pUINode = m_pObjCracker->GetCookie(i);
    CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);

    return GetComponentData()->_DeleteSubtreeFromBackEnd(pCookie);
  }
  virtual void OnItemDeleted(UINT i)
  {
    CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(m_pObjCracker->GetCookie(i));
    ASSERT(pDSUINode != NULL);

    m_pNodesDeletedList->AddTail(pDSUINode);
  }
  virtual void GetItemName(IN UINT i, OUT CString& szName)
  {
    CUINode* pUINode = m_pObjCracker->GetCookie(i);
    CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);

    if (pCookie != NULL)
    {
      szName = pCookie->GetName();
    }
  }

  virtual void GetItemPath(UINT i, CString& szPath)
  {
    CUINode* pUINode = m_pObjCracker->GetCookie(i);
    CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);

    if (pCookie != NULL)
    {
      GetComponentData()->GetBasePathsInfo()->ComposeADsIPath(szPath, pCookie->GetPath());
    }
  }
  virtual PCWSTR GetItemClass(UINT i)
  {
    CUINode* pUINode = m_pObjCracker->GetCookie(i);
    CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);

    PCWSTR pszClass = NULL;
    if (pCookie != NULL)
    {
      pszClass = pCookie->GetClass();
    }
    return pszClass;
  }
private:
  IDataObject* m_pDataObject;
  CInternalFormatCracker* m_pObjCracker;
  CUINodeList* m_pNodesDeletedList;

};



void CDSEvent::_DeleteNodeListFromUI(CUINodeList* pNodesDeletedList)
{
  // finally, we have to update the UI
  if (pNodesDeletedList->GetCount() == 0)
  {
    return;
  }

  TIMER(_T("updating UI after delete, containers first.\n"));

  //walk this cookie list and take
  //care of the containers (scope pane items)
  for (POSITION pos = pNodesDeletedList->GetHeadPosition(); pos != NULL; )
  {
    POSITION posCurrNode = pos;
    CUINode* pCurrNode = pNodesDeletedList->GetNext(pos);
    ASSERT(pCurrNode != NULL);
    HSCOPEITEM ItemID, ParentItemID;
    if (pCurrNode->IsContainer())
    {
      ItemID = pCurrNode->GetFolderInfo()->GetScopeItem();
      CUINode* pParentNode = NULL;
      HRESULT hr = m_pComponentData->m_pScope->GetParentItem(ItemID,
                                     &ParentItemID, 
                                     (MMC_COOKIE *)&pParentNode);
      m_pComponentData->m_pScope->DeleteItem(ItemID, TRUE);
      if (SUCCEEDED(hr)) 
      {
        pParentNode->GetFolderInfo()->DeleteNode(pCurrNode);
        pNodesDeletedList->RemoveAt(posCurrNode);
      }
    } // container
  } // for

  TIMER(_T("updating UI after delete, now the leaf items.\n"));

  // now update all the views to take care of result pane items
  m_pFrame->UpdateAllViews(NULL, 
                           (LPARAM)pNodesDeletedList,
                           DS_MULTIPLE_DELETE_OCCURRED);
  TIMER(_T("updating UI after delete, done.\n"));

}



void CDSEvent::_DeleteMultipleSel(IDataObject* pDataObject, CInternalFormatCracker* pObjCracker)
{
  // handle the deletion in the back end involving the extensions
  // by calling the delete handler

  //
  // Get the parent container
  //
  CUINode* pContainerNode = NULL;
  CUINode* pUINode = pObjCracker->GetCookie();
  if (pUINode != NULL)
  {
    pContainerNode = pUINode->GetParent();
  }
  else
  {
    ASSERT(FALSE);
  }

  // REVIEW_MARCOC_PORT: for the time being we assume that all the
  // items in the multiple selection are of DS type
  if (!AreAllNodesOfType<CDSUINode>(pObjCracker))
  {
    //
    // Delegate the delete to the container object
    //
    if (pContainerNode != NULL)
    {
      pContainerNode->DeleteMultiselect(m_pComponentData, pObjCracker);
    }
    else
    {
      ASSERT(FALSE);
    }
  }
  else  // All are DS nodes
  {
    CUINodeList nodesDeletedList;
 
    CResultPaneMultipleDeleteHandler deleteHandler(m_pComponentData, m_hwnd, 
                                      pDataObject, pObjCracker, &nodesDeletedList);
    deleteHandler.Delete();

    _DeleteNodeListFromUI(&nodesDeletedList);
  }
  
  //
  // Remove the '+' sign in the UI if this was the last container child in this container
  //
  if (pContainerNode != NULL &&
      pContainerNode->GetFolderInfo()->GetContainerList()->GetCount() == 0)
  {
    SCOPEDATAITEM sdi;
    memset(&sdi, 0, sizeof(SCOPEDATAITEM));

    sdi.ID = pContainerNode->GetFolderInfo()->GetScopeItem();
    sdi.mask |= SDI_CHILDREN;
    sdi.cChildren = 0;

    m_pComponentData->m_pScope->SetItem(&sdi);
  }
}


void CDSEvent::_Delete(IDataObject* pDataObject, CInternalFormatCracker* pObjCracker)
{
  CWaitCursor cwait;

  // protect against deletion with sheets up
  if (m_pComponentData->_WarningOnSheetsUp(pObjCracker)) 
    return;

  // do the actual deletion
  if (pObjCracker->GetCookieCount() == 1) 
  {
    _DeleteSingleSel(pDataObject, pObjCracker->GetCookie());
  } 
  else 
  { 
    _DeleteMultipleSel(pDataObject, pObjCracker);
  } 
}



BOOL AllObjectsHaveTheSameServerName(IN LPCWSTR lpszServerName,
                                   IN CObjectNamesFormatCracker* pObjectNamesFormatPaste)
{
  if (lpszServerName == NULL)
  {
    ASSERT(FALSE);
    return FALSE;
  }
  CComBSTR bstrCurrServerName;
  
  for (UINT k=0; k<pObjectNamesFormatPaste->GetCount(); k++)
  {
    HRESULT hr = GetServerFromLDAPPath(pObjectNamesFormatPaste->GetName(k), 
                                        &bstrCurrServerName);
    if (FAILED(hr) || (&bstrCurrServerName == NULL))
    {
      // something was wrong
      return FALSE;
    }
    if (_wcsicmp(lpszServerName, bstrCurrServerName) != 0)
    {
      // got something different
      return FALSE;
    }
  }
  return TRUE; // all are the same
}

BOOL HasSameObject(IN CUINode* pUINode, IN IDataObject* pPasteData)
{
  if (pUINode == NULL)
  {
    ASSERT(FALSE);
    return FALSE;
  }

  //
  // Check to see if the target is a DS node
  //
  CDSUINode* pDSTargetNode = NULL;
  BOOL bCookieIsDSUINode = FALSE;
  if(IS_CLASS(*pUINode, CDSUINode))
  {
    bCookieIsDSUINode = TRUE;
    pDSTargetNode = dynamic_cast<CDSUINode*>(pUINode);
  }

  CInternalFormatCracker ifc;
  HRESULT hr = ifc.Extract(pPasteData);
  if (SUCCEEDED(hr))
  {
    for (UINT k=0; k < ifc.GetCookieCount(); k++)
    {
      //
      // If the cookies are the same return TRUE
      //
      if (ifc.GetCookie(k) == pUINode)
      {
        return TRUE;
      }

      if (bCookieIsDSUINode && pDSTargetNode != NULL)
      {
        //
        // If its a DS node and their DNs are the same return TRUE
        //
        CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(ifc.GetCookie(k));
        if (pDSUINode != NULL)
        {
          if (_wcsicmp(pDSUINode->GetName(), pDSTargetNode->GetName()) == 0)
          {
            return TRUE;
          }
        }
      }
    }
  }
  return FALSE; // all are the different
}


HRESULT CDSEvent::_QueryPaste(IN CUINode* pUINode, // paste target data object (container)
                              IN IDataObject* pPasteData     // paste argument data object
                           )
{
  TRACE(L"CDSEvent::_QueryPaste()\n");
 
  HRESULT hr = S_OK;
  ASSERT(pUINode != NULL);
  ASSERT(pUINode->IsContainer());
  TRACE(L"MMCN_QUERY_PASTE on %s\n", pUINode->GetName());

  // First lets make sure we are talking within the same snapin type
  // For instance we will allow paste between instances of AD U&C
  // but we will not allow paste between AD S&S and AD U&C

  CInternalFormatCracker ifc;
  hr = ifc.Extract(pPasteData);
  if (FAILED(hr) || !ifc.HasData())
  {
    return S_FALSE;
  }

  if (m_pComponentData->QuerySnapinType() != ifc.GetSnapinType())
  {
     // The snapins are not of the same type so fail

     return S_FALSE;
  }


  if (!IS_CLASS(*pUINode, CDSUINode))
  {
    //
    // For non DS nodes we will delegate the operation to the node itself
    //
    hr = pUINode->QueryPaste(pPasteData, m_pComponentData);
    return hr;
  }

  // it is a DS object, extract the cookie
  CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);
  ASSERT(pCookie != NULL);
  TRACE(L"MMCN_QUERY_PASTE on %s\n",pCookie->GetPath());

  CObjectNamesFormatCracker objectNamesFormatPaste;
  hr = objectNamesFormatPaste.Extract(pPasteData);

  if (!objectNamesFormatPaste.HasData() || (objectNamesFormatPaste.GetCount() < 1))
  {
    // we have something that does not contain the
    // data format for DS operations
    return S_FALSE;
  }

  if (SNAPINTYPE_SITE == m_pComponentData->QuerySnapinType())
  {
    //
    // DSSite
    //
    if (_wcsicmp(pCookie->GetClass(), L"serversContainer") != 0)
    {
      //
      // Drops only allowed on sites
      //
      return S_FALSE;
    }

    //
    // We only allow servers to be moved between sites
    //
    for (UINT idx = 0; idx < objectNamesFormatPaste.GetCount(); idx++)
    {
      if (_wcsicmp(objectNamesFormatPaste.GetClass(idx), L"server") != 0)
      {
        return S_FALSE;
      }
    }

    // make sure all items have the same server in the LDAP path
    if (!AllObjectsHaveTheSameServerName(
                       m_pComponentData->GetBasePathsInfo()->GetServerName(), 
                       &objectNamesFormatPaste))
    {
      return S_FALSE;
    }

    return S_OK;
  }

  //
  // DSAdmin
  //

  // we do not allow drops on users, contacts,
  // but we do allow drops on computers
  // NTRAID#NTBUG9-342116-2001/05/07-sburns
  // NOTICE: we allow groups because we allow add to group semantics
  if ((_wcsicmp(pCookie->GetClass(), L"user") == 0) ||
#ifdef INETORGPERSON
      (_wcsicmp(pCookie->GetClass(), L"inetOrgPerson") == 0) ||
#endif
      (_wcsicmp(pCookie->GetClass(), L"contact") == 0))
  {
    return S_FALSE;
  }


  // make sure all items have the same server in the LDAP path
  if (!AllObjectsHaveTheSameServerName(
                    m_pComponentData->GetBasePathsInfo()->GetServerName(), 
                    &objectNamesFormatPaste))
  {
    return S_FALSE;
  }

  //
  // make sure we are not dropping an object on itself
  //
  if (HasSameObject(pUINode, pPasteData))
  {
    return S_FALSE;
  }

  if (_wcsicmp(pCookie->GetClass(), L"group") == 0)
  {
    //
    // Check to see if we are trying to add a group type to this group
    // that is illegal
    //

    //
    // Retrieve the group type
    //
    INT iGroupType = -1;
    CDSCookieInfoGroup* pExtraInfo = dynamic_cast<CDSCookieInfoGroup*>(pCookie->GetExtraInfo());
    if (pExtraInfo != NULL)
    {
      iGroupType = pExtraInfo->m_GroupType;
    }
    else
    {
      //
      // Couldn't retrieve the group type so don't allow anything to be added
      //
      return S_FALSE;
    }

    //
    // See if we are in native mode or mixed mode
    //
    BOOL bMixedMode = TRUE;
    CString szDomainRoot;
    m_pComponentData->GetBasePathsInfo()->GetDefaultRootPath(szDomainRoot);
    
    if (!szDomainRoot.IsEmpty())
    {
      //
      // bind to the domain object
      //
      CComPtr<IADs> spDomainObj;
      hr = DSAdminOpenObject(szDomainRoot,
                             IID_IADs,
                             (void **) &spDomainObj,
                             TRUE /*bServer*/);
      if (SUCCEEDED(hr)) 
      {
        //
        // retrieve the mixed node attribute
        //
        CComVariant Mixed;
        CComBSTR bsMixed(L"nTMixedDomain");
        spDomainObj->Get(bsMixed, &Mixed);
        bMixedMode = (BOOL)Mixed.bVal;
      }
    }

    //
    // Loop through the objects passed by the data object
    // looking for groups
    //
    for (UINT k=0; k < ifc.GetCookieCount(); k++)
    {
      CUINode* pNode = ifc.GetCookie(k);
      if (pNode != NULL)
      {
        //
        // Must be a DS node to be added to a group
        //
        if (!IS_CLASS(*pNode, CDSUINode))
        {
          return S_FALSE;
        }

        CDSCookie* pTempCookie = dynamic_cast<CDSCookie*>(pNode->GetNodeData());
        if (pTempCookie)
        {
          if (!m_pComponentData->CanAddCookieToGroup(pTempCookie, iGroupType, bMixedMode))
          {
            return S_FALSE;
          }
        }
      }
    }
  }

  return S_OK; // we allow to paste 
}



// given an LDAP path, it returns
// the LDAP path and the class of the container
// e.g. given "LDAP://foo.com/cn=a,cn=b,..."
// it returns "LDAP://foo.com/cn=b,..." and "b_class"
 
HRESULT GetContainerLdapPathAndClass(IN LPCWSTR lpszLdapPath, 
                                      OUT BSTR* pbstrSourceContainerPath,
                                      OUT BSTR* pbstrSourceContainerClass)
{
  if (*pbstrSourceContainerPath != NULL)
  {
    ::SysFreeString(*pbstrSourceContainerPath);
    *pbstrSourceContainerPath = NULL;
  }
  if (*pbstrSourceContainerClass != NULL)
  {
    ::SysFreeString(*pbstrSourceContainerClass);
    *pbstrSourceContainerClass = NULL;
  }

  // remove leaf element from path
  CPathCracker pathCracker;
  HRESULT hr = pathCracker.Set((LPWSTR)lpszLdapPath, ADS_SETTYPE_FULL);
  RETURN_IF_FAILED(hr);
  hr = pathCracker.RemoveLeafElement();
  RETURN_IF_FAILED(hr);
  
  CComBSTR bstrParentLdapPath;
  hr = pathCracker.Retrieve(ADS_FORMAT_X500, pbstrSourceContainerPath);
  RETURN_IF_FAILED(hr);

  // now try to bind and determine the class of the object
  CComPtr<IADs> spParentIADs;
  hr = DSAdminOpenObject(*pbstrSourceContainerPath,
                         IID_IADs, 
                         (void **)&spParentIADs,
                         TRUE /*bServer*/);
  RETURN_IF_FAILED(hr);
  
  CComBSTR bstrParentClass;
  hr = spParentIADs->get_Class(pbstrSourceContainerClass);
  RETURN_IF_FAILED(hr);

  return S_OK;
}

// given an LDAP path, it returns
// the DN of the container
// e.g. given "LDAP://foo.com/cn=a,cn=b,..."
// it returns "cn=b,..."

HRESULT GetContainerDN(IN LPCWSTR lpszLdapPath,
                       OUT BSTR* pbstrSourceContainerDN)
{
  if (*pbstrSourceContainerDN != NULL)
  {
    ::SysFreeString(*pbstrSourceContainerDN);
    *pbstrSourceContainerDN = NULL;
  }
  CPathCracker pathCracker;
  HRESULT hr = pathCracker.Set((LPWSTR)lpszLdapPath, ADS_SETTYPE_FULL);
  RETURN_IF_FAILED(hr);
  hr = pathCracker.RemoveLeafElement();
  RETURN_IF_FAILED(hr);
  return pathCracker.Retrieve(ADS_FORMAT_X500_DN, pbstrSourceContainerDN);
}


void CDSEvent::_Paste(
              IN CUINode* pUINode,    // paste target  (container)
              IN IDataObject* pPasteData,     // paste argument data object
              OUT LPDATAOBJECT* ppCutDataObj  // data object to return for a cut operation
              )
{
  TRACE(L"CDSEvent::_Paste()\n");

  ASSERT(pUINode != NULL);
  ASSERT(pUINode->IsContainer());
  TRACE(L"MMCN_PASTE on %s\n", pUINode->GetName());

  if (ppCutDataObj == NULL)
  {
    //
    // We only support copy in the Saved Queries tree
    //
    pUINode->Paste(pPasteData, m_pComponentData, NULL);
    return;
  }

  TRACE(L"ppCutDataObj != NULL, cut\n");
  *ppCutDataObj = NULL;

  if (!IS_CLASS(*pUINode, CDSUINode))
  {
    //
    // Delegate the paste for non DS nodes to the node itself
    //
    pUINode->Paste(pPasteData, m_pComponentData, ppCutDataObj);
    return;
  }
  
  // it is a DS object, extract the cookie
  CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);
  ASSERT(pCookie != NULL);
  TRACE(L"MMCN_PASTE on %s\n",pCookie->GetPath());


  CObjectNamesFormatCracker objectNamesFormatPaste;
  HRESULT hr = objectNamesFormatPaste.Extract(pPasteData);

  if (!objectNamesFormatPaste.HasData() || (objectNamesFormatPaste.GetCount() < 1))
  {
    // we have something that does not contain the
    // data format for DS operations
    ASSERT(FALSE);
    return;
  }
  
  UINT nPasteCount = objectNamesFormatPaste.GetCount();
#ifdef DBG
  // see what we are pasting
  for (UINT kTest=0; kTest<nPasteCount; kTest++)
  {
    TRACE(L"Pasting = %s\n", objectNamesFormatPaste.GetName(kTest));
  }
#endif

  // short circuit if the source container
  // is the same as this container (drop onto itself)
  CComBSTR bstrContainerDN;
  hr = GetContainerDN(objectNamesFormatPaste.GetName(0), &bstrContainerDN);
  if (FAILED(hr))
  {
    // something is really bad here...
    ASSERT(FALSE);
    return;
  }
  if (_wcsicmp(pCookie->GetPath(), bstrContainerDN) == 0)
  {
    TRACE(L"Dropping on the same container, short circuiting\n");
    return;
  }

  // make sure all items have the same server in the LDAP path
  if (!AllObjectsHaveTheSameServerName(
                    m_pComponentData->GetBasePathsInfo()->GetServerName(), 
                    &objectNamesFormatPaste))
  {
    ASSERT(FALSE);
    return;
  }

  // we do not allow drops on users,
  // but we do allow drops on computers
  // NTRAID#NTBUG9-342116-2001/05/07-sburns
  if ((_wcsicmp(pCookie->GetClass(), L"user") == 0) ||
#ifdef INETORGPERSON
      (_wcsicmp(pCookie->GetClass(), L"inetOrgPerson") == 0))
#endif
  {
    return;
  }
  
  // if it is a group, dropping means adding to group
  if (_wcsicmp(pCookie->GetClass(), L"group") == 0)
  {
    _PasteAddToGroup(dynamic_cast<CDSUINode*>(pUINode), &objectNamesFormatPaste, ppCutDataObj);
    return;
  }

  //
  // We also want the internal clipboard format so that we can change the path of 
  // object(s) that was/were the source of the move
  //
  CInternalFormatCracker ifc;
  hr = ifc.Extract(pPasteData);
  if (SUCCEEDED(hr))
  {
    _PasteDoMove(dynamic_cast<CDSUINode*>(pUINode), &objectNamesFormatPaste, &ifc, ppCutDataObj);
  }
  else
  {
    //
    // The move can succeed without the internal clipboard format but if the source
    // was from a saved query then it will not be updated with the new path.
    //
    _PasteDoMove(dynamic_cast<CDSUINode*>(pUINode), &objectNamesFormatPaste, NULL, ppCutDataObj);
  }

}


void CDSEvent::_PasteDoMove(CDSUINode* pTargetUINode, 
                            CObjectNamesFormatCracker* pObjectNamesFormatPaste,
                            CInternalFormatCracker* pInternalFC,
                            LPDATAOBJECT* ppCutDataObj)
{
  //
  // Get the UI source node
  //
  CUINode* pSourceNode = NULL;
  if (pInternalFC != NULL)
  {
    pSourceNode = pInternalFC->GetCookie()->GetParent();
  }  

  //
  // Get the actual source containers from the DS
  // There can be more than one source node especially if the move is from a 
  // Saved Query so make a list of all the parents
  //
  CUINodeList possibleMovedObjectList;

  for (UINT idx = 0; idx < pObjectNamesFormatPaste->GetCount(); idx++)
  {
    CUINode* pTempChildNode = NULL;

    CString szDN;
    StripADsIPath(pObjectNamesFormatPaste->GetName(idx), szDN);
    if (m_pComponentData->FindUINodeByDN(m_pComponentData->GetRootNode(),
                                         szDN,
                                         &pTempChildNode))
    {
      if (pTempChildNode != NULL)
      {
        possibleMovedObjectList.AddTail(pTempChildNode);
      }
    }
  }

  // bind to the first item in the paste selection and
  // try to get to the container object

  CComBSTR bstrSourceContainerPath;
  CComBSTR bstrSourceContainerClass;

  HRESULT hr = GetContainerLdapPathAndClass(pObjectNamesFormatPaste->GetName(0), 
                        &bstrSourceContainerPath,
                        &bstrSourceContainerClass);
  if (FAILED(hr))
  {
    ASSERT(FALSE);
    return;
  }
  // create a data object to specify the source container
  // the objects are moved from
  CComPtr<IDataObject> spDataObjectContainer;
  hr = CDSNotifyHandlerTransaction::BuildTransactionDataObject(
                           bstrSourceContainerPath, 
                           bstrSourceContainerClass,
                           TRUE /*bContainer*/,
                           m_pComponentData,
                           &spDataObjectContainer);

  if (FAILED(hr))
  {
    ASSERT(FALSE);
    return;
  }

  CMultiselectMoveHandler moveHandler(m_pComponentData, m_hwnd, NULL);
  hr = moveHandler.Initialize(spDataObjectContainer, 
                              pObjectNamesFormatPaste, 
                              pInternalFC);
  ASSERT(SUCCEEDED(hr));

  CString szTargetContainer;
  m_pComponentData->GetBasePathsInfo()->ComposeADsIPath(szTargetContainer, pTargetUINode->GetCookie()->GetPath());

  moveHandler.Move(szTargetContainer);

  *ppCutDataObj = NULL;
  CUINodeList nodesMoved;

  // -----------------------------------------------------------------
  // code to update the views if the extension says it moved items
  //
  TRACE(_T("Command: returned from extension commdand\n"));

  if (pSourceNode != NULL &&
      IS_CLASS(*pSourceNode, CDSUINode))
  {
    for (UINT index = 0; index < pInternalFC->GetCookieCount(); index ++) 
    {
      CUINode* pUINode = pInternalFC->GetCookie(index);

      // make sure the node moved is of the right type: for the time
      // being we just deal with DS objects
      if (!IS_CLASS(*pUINode, CDSUINode))
      {
        ASSERT(FALSE); // should not get here
        continue;
      }
      CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);

      if (pUINode->GetExtOp() & OPCODE_MOVE) 
      {
        if (pTargetUINode == NULL) 
        {
          // get the parent from the first node
          // assume that all have the same parent
          CUINode* pPossibleTargetNode = NULL;
          m_pComponentData->FindParentCookie(pCookie->GetPath(), &pPossibleTargetNode);
          if (pPossibleTargetNode != NULL)
          {
            pTargetUINode = dynamic_cast<CDSUINode*>(pPossibleTargetNode);
          }
        }

        if (pUINode->IsContainer()) 
        {
          HSCOPEITEM ItemID = 0, ParentItemID = 0;
          ItemID = pUINode->GetFolderInfo()->GetScopeItem();
          if (pSourceNode == NULL) 
          {
            // do it once for the first node, all the same
            hr = m_pComponentData->m_pScope->GetParentItem (ItemID,
                                                            &ParentItemID,
                                                            (MMC_COOKIE *)&pSourceNode);
          }

          // delete the scope item in MMC
          hr = m_pComponentData->m_pScope->DeleteItem(ItemID, TRUE);
          ASSERT(SUCCEEDED(hr));
#ifdef DBG
          if (FAILED(hr)) 
          {
            TRACE(_T("DeleteItem failed on %lx (%s).\n"),
                  ItemID, pUINode->GetName());
          }
          TRACE(_T("Move postprocessing - deleted scope node: %x (%s)\n"),
                ItemID, pUINode->GetName());
#endif
          if (pSourceNode) 
          {
            pSourceNode->GetFolderInfo()->RemoveNode(pUINode);
          }
        
          //
          // Remove all children and mark it as unexpanded so that it will be expanded
          // when selected
          //
          pUINode->GetFolderInfo()->DeleteAllContainerNodes();
          pUINode->GetFolderInfo()->DeleteAllLeafNodes();
          pUINode->GetFolderInfo()->ReSetExpanded();

          if ((pTargetUINode) && pTargetUINode->GetFolderInfo()->IsExpanded()) 
          {
            pUINode->ClearParent();
            pTargetUINode->GetFolderInfo()->AddNode(pUINode);
            hr = m_pComponentData->_AddScopeItem(pUINode, pTargetUINode->GetFolderInfo()->GetScopeItem());
#ifdef DBG
            if (FAILED(hr)) 
            {
              TRACE(_T("AddItem failed on %lx (%s).\n"),
                    ItemID, pUINode->GetName());
            }
            TRACE(_T("Move postprocessing - added scope node: %s\n"),
                  pUINode->GetName());
#endif
          } 
          else 
          {
            //
            // This object was created during the enumeration of the source container.
            // Since the target container hasn't been expanded yet we can just throw
            // this node away and it will be recreated if the target node ever gets
            // expanded
            //
            delete pUINode;
            pUINode = NULL;
          }
        } 
        else 
        {
          // not a container
          if ((pTargetUINode) &&
              (pTargetUINode->GetFolderInfo()->IsExpanded())) 
          {
            pUINode->ClearParent();
            pTargetUINode->GetFolderInfo()->AddNode(pUINode);
          }

          //
          // If the folder is not select (like on cut/paste) 
          // the FindItemByLParam() in UpdateAllViews will fail
          // and the node will not be removed from the UI.
          // So just remove it from the node list of the source
          // container.
          //
          if (pSourceNode && m_pSelectedFolderNode != pSourceNode)
          {
            pSourceNode->GetFolderInfo()->RemoveNode(pUINode);
          }
          nodesMoved.AddTail(pUINode);
        }
        if (pUINode) 
        {
          pUINode->SetExtOp(NULL);
        }
      }
    }
  }
  else if (pSourceNode != NULL && 
           IS_CLASS(*pSourceNode, CSavedQueryNode))
  {
    //
    // Refresh the target node so that we get new cookies
    // for all the moved objects.  It would just be too
    // difficult to do a deep copy of the cookies in the
    // saved query tree
    //
    if (pTargetUINode &&
        pTargetUINode->GetFolderInfo()->IsExpanded())
    {
      m_pComponentData->Refresh(pTargetUINode);
    }

    //
    // Mark the moved leaf objects with the opcode. Simply remove containers from
    // the UI and the list.  The move handler only marks the
    // selected items, not those found using FindUINodeByDN.
    //
    POSITION posPossible = possibleMovedObjectList.GetHeadPosition();
    while (posPossible)
    {
      CUINode* pPossibleMoved = possibleMovedObjectList.GetNext(posPossible);
      if (pPossibleMoved)
      {
        if (pPossibleMoved->IsContainer())
        {
          HSCOPEITEM ItemID = 0;
          ItemID = pPossibleMoved->GetFolderInfo()->GetScopeItem();

          // delete the scope item in MMC
          hr = m_pComponentData->m_pScope->DeleteItem(ItemID, TRUE);
          if (SUCCEEDED(hr))
          {
            hr = pPossibleMoved->GetParent()->GetFolderInfo()->RemoveNode(pPossibleMoved);
          }
        }
        else
        {
          pPossibleMoved->SetExtOp(OPCODE_MOVE);
        }
      }
    }

    //
    // Now reset the opcode for all the nodes in the saved query tree so
    // that they will still show up the next time the saved query node is selected
    //
    for (UINT index = 0; index < pInternalFC->GetCookieCount(); index ++) 
    {
      CUINode* pUINode = pInternalFC->GetCookie(index);

      if (pUINode) 
      {
        pUINode->SetExtOp(NULL);
      }
    } // for 
  } // IS_CLASS


  if (!nodesMoved.IsEmpty()) 
  {
    m_pFrame->UpdateAllViews(NULL, (LPARAM)&nodesMoved, DS_MULTIPLE_MOVE_OCCURRED);
  }
  //------------------------------ends here--------------------------------------
  m_pComponentData->SortResultPane(pTargetUINode);
}

void CDSEvent::_PasteAddToGroup(CDSUINode* pUINode, 
                                CObjectNamesFormatCracker* pObjectNamesFormatPaste,
                                LPDATAOBJECT*)
{
  if (_wcsicmp(pUINode->GetCookie()->GetClass(), L"group") != 0)
  {
    ASSERT(FALSE);
    return;
  }
  // get the LDAP path of the group we want to add to
  CString szGroupLdapPath;
  m_pComponentData->GetBasePathsInfo()->ComposeADsIPath(szGroupLdapPath,
                                          pUINode->GetCookie()->GetPath());
  AddDataObjListToGivenGroup(pObjectNamesFormatPaste,
                             szGroupLdapPath,
                             pUINode->GetCookie()->GetName(),
                             m_pComponentData->GetHWnd(),
                             m_pComponentData);
}




BOOL FindDSUINodeInListByDN(IN LPCWSTR lpszDN,
                        IN CUINodeList* pNodeList,
                        OUT CDSUINode** ppNode)
{
  *ppNode = NULL;
  for (POSITION pos = pNodeList->GetHeadPosition(); pos != NULL; )
  {
    CUINode* pCurrentNode = pNodeList->GetNext(pos);
    CDSUINode* pCurrDSUINode = dynamic_cast<CDSUINode*>(pCurrentNode);
    if (pCurrDSUINode == NULL)
    {
      // not a node with a cookie, just skip
      continue;
    }

    // get the cookie from the node
    if (_wcsicmp(lpszDN, pCurrDSUINode->GetCookie()->GetPath()) == 0)
    {
      *ppNode = pCurrDSUINode;
      return TRUE;
    }
  }// for

  return FALSE;
}
  
void FindListOfChildNodes(IN CDSUINode* pDSUIContainerNode, 
                         IN CObjectNamesFormatCracker* pObjectNamesFormat, 
                         INOUT CUINodeList* pNodesDeletedList)
{
  ASSERT(pDSUIContainerNode != NULL);
  ASSERT(pDSUIContainerNode->IsContainer());

  // it is a DS object, extract the cookie
  CDSCookie* pContainerCookie = pDSUIContainerNode->GetCookie();
  ASSERT(pContainerCookie != NULL);
  TRACE(L"FindListOfChildNodes(%s,...)\n",pContainerCookie->GetPath());

  //for each item in the list of paths, find it into the list
  // of children
  CPathCracker pathCracker;
  UINT nCount = pObjectNamesFormat->GetCount();
  for (UINT k=0; k<nCount; k++)
  {
    // from the LDAP path, get the DN
    HRESULT hr = pathCracker.Set((LPWSTR)pObjectNamesFormat->GetName(k), ADS_SETTYPE_FULL);
    ASSERT(SUCCEEDED(hr));
    CComBSTR bstrDN;
    hr = pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
    ASSERT(SUCCEEDED(hr));

    // find it into the lists of children
    CDSUINode* pFoundNode = NULL;
    if (FindDSUINodeInListByDN(bstrDN, 
                               pDSUIContainerNode->GetFolderInfo()->GetContainerList(),
                               &pFoundNode))
    {
      ASSERT(pFoundNode != NULL);
      pNodesDeletedList->AddTail(pFoundNode);
      continue;
    }
    if (FindDSUINodeInListByDN(bstrDN, 
                               pDSUIContainerNode->GetFolderInfo()->GetLeafList(),
                               &pFoundNode))
    {
      ASSERT(pFoundNode != NULL);
      pNodesDeletedList->AddTail(pFoundNode);
      continue;
    }
  } // for


}




void CDSEvent::_CutOrMove(IN IDataObject* pCutOrMoveData)
{
  TRACE(L"CDSEvent::_CutOrMove()\n");

  if (pCutOrMoveData == NULL)
  {
    //
    // With a single pass move operation we return a NULL data object
    // but the move was still successful
    //
    return;
  }

  CInternalFormatCracker ifc;
  HRESULT hr = ifc.Extract(pCutOrMoveData);
  if (SUCCEEDED(hr))
  {
    //
    // Non DS nodes
    //

    //
    // Build a list of the nodes to be deleted
    //
    CUINodeList nodesDeletedList;
    for (UINT nCount = 0; nCount < ifc.GetCookieCount(); nCount++)
    {
      CUINode* pUINode = ifc.GetCookie(nCount);
      if (pUINode != NULL)
      {
        nodesDeletedList.AddTail(pUINode);
      }
    }
    //
    // finally, delete the nodes from the UI
    //
    _DeleteNodeListFromUI(&nodesDeletedList);
  }
  else
  {
    //
    // DS Objects
    //
    CObjectNamesFormatCracker objectNamesFormatCutOrMove;
    hr = objectNamesFormatCutOrMove.Extract(pCutOrMoveData);
    if (SUCCEEDED(hr))
    {
      if (!objectNamesFormatCutOrMove.HasData() || (objectNamesFormatCutOrMove.GetCount() < 1))
      {
        // we have something that does not contain the
        // data format for DS operations
        ASSERT(FALSE);
        return;
      }

      // make sure all items have the same server in the LDAP path
      if (!AllObjectsHaveTheSameServerName(
                        m_pComponentData->GetBasePathsInfo()->GetServerName(), 
                        &objectNamesFormatCutOrMove))
      {
        ASSERT(FALSE);
        return;
      }

      // find the source container the objects are moved from
      // (we assume they all come from the same container)

      TRACE(L"GetName(0) = %s\n", objectNamesFormatCutOrMove.GetName(0));

      CComBSTR bstrContainerDN;
      hr = GetContainerDN(objectNamesFormatCutOrMove.GetName(0), &bstrContainerDN);
      if (FAILED(hr))
      {
        ASSERT(FALSE);
        return;
      }
      TRACE(L"GetContainerDN() bstrContainerDN = %s\n", bstrContainerDN);

      // find the container object in the folders
      // NOTICE: for the time being we ignore the query folders
      CUINode* pUINode = NULL;
      if (!FindCookieInSubtree(m_pComponentData->GetRootNode(), 
                               bstrContainerDN, 
                               m_pComponentData->QuerySnapinType(),
                               &pUINode))
      {
        // should never happen...
        return;
      }

      // found the container node
      ASSERT(pUINode != NULL);
      ASSERT(pUINode->IsContainer());

      if (!IS_CLASS(*pUINode, CDSUINode))
      {
        // we do not allow paste on non DS nodes,
        // so we should never get here...
        ASSERT(FALSE);
        return;
      }

      ASSERT(pUINode->GetFolderInfo()->IsExpanded());

      // need to remove the items that are in the data object
      // from the pUINode container: find the list of nodes
      // to be deleted in the 
      CUINodeList nodesDeletedList;
      FindListOfChildNodes(dynamic_cast<CDSUINode*>(pUINode), 
                          &objectNamesFormatCutOrMove, 
                          &nodesDeletedList);

      // finally, delete the nodes from the UI
      _DeleteNodeListFromUI(&nodesDeletedList);
    }
  }
}

void CDSEvent::HandleViewChange(LPDATAOBJECT pDataObject,
                                LPARAM arg,
                                LPARAM Action)
{
  HRESULT hr = S_OK;

  TRACE(_T("handle view change. action is %lx.\n"), Action);
  switch (Action) 
  {
  case DS_DELETE_OCCURRED:
    { 
      HRESULTITEM ItemID;
      hr = m_pResultData->FindItemByLParam(arg, &ItemID);
      if (!SUCCEEDED(hr)) 
      {
        break;
      }
      hr = m_pResultData->DeleteItem(ItemID, 0);
#ifdef DBG
      if (FAILED(hr)) {
        TRACE (_T("Delete Item Failed on IResultData. Item %lx, hr = %lx\n"),
               ItemID, hr);
      }
#endif
      // this will fail for all but the first update, we don't care
      hr = m_pSelectedFolderNode->GetFolderInfo()->DeleteNode(reinterpret_cast<CUINode*>(arg));
      _UpdateObjectCount(FALSE);
      break;
    }
  case DS_MULTIPLE_DELETE_OCCURRED:
    {
      TIMER(_T("updating result pane for mult. delete ..."));
      CUINodeList* pNodesDeletedList = reinterpret_cast<CUINodeList*>(arg); // gross

      for (POSITION pos = pNodesDeletedList->GetHeadPosition(); pos != NULL; )
      {
        CUINode* pCurrNode = pNodesDeletedList->GetNext(pos);
        ASSERT(pCurrNode != NULL);
        HRESULTITEM ItemID;
        hr = m_pResultData->FindItemByLParam((LPARAM)pCurrNode,
                                              &ItemID);
        if (FAILED(hr))
        {
          //
          // We cannot find the item by lParam if the node is not selected so 
          // just delete the node from the container
          //
          CUIFolderInfo* pFolderInfo = pCurrNode->GetParent()->GetFolderInfo();
          if (pFolderInfo != NULL)
          {
            hr = pFolderInfo->DeleteNode(pCurrNode);
          }
          continue;
        }
        hr = m_pResultData->DeleteItem(ItemID, 0);

        CUIFolderInfo* pSelectedFolderInfo = m_pSelectedFolderNode->GetFolderInfo();
        if (pSelectedFolderInfo != NULL)
        {
          // this will fail for all but the first update, we don't care
          hr = m_pSelectedFolderNode->GetFolderInfo()->DeleteNode(pCurrNode);
        }
      }
      _UpdateObjectCount(FALSE);
      TIMER(_T("updating result pane for mult. delete, done"));
    }
    break;
  case DS_RENAME_OCCURRED:
  case DS_UPDATE_OCCURRED:
    {
      HRESULTITEM ItemID;
      hr = m_pResultData->FindItemByLParam (arg, &ItemID);
      if (SUCCEEDED(hr)) {
        m_pResultData->UpdateItem (ItemID);
      }
      break;
    }
  case DS_MOVE_OCCURRED:
    {
      CDSUINode* pDSUINode = reinterpret_cast<CDSUINode*>(arg);
      CDSUINode* pDSSelectedFolderNode = dynamic_cast<CDSUINode*>(m_pSelectedFolderNode);

      // REVIEW_MARCOC_PORT: this is working for DS objects only
      // need to generalize for all folder types

      ASSERT(pDSUINode != NULL);
      ASSERT(pDSSelectedFolderNode != NULL);
      if ((pDSUINode == NULL) || (pDSSelectedFolderNode == NULL))
        break;

      // remove the result pane item
      HRESULTITEM ItemID;
      hr = m_pResultData->FindItemByLParam (arg, &ItemID);
      if (SUCCEEDED(hr)) 
      {
        hr = m_pSelectedFolderNode->GetFolderInfo()->RemoveNode(pDSUINode);
        hr = m_pResultData->DeleteItem(ItemID, 0);
      }
      
      CString szParent;
      hr = m_pComponentData->GetActiveDS()->GetParentDN(pDSUINode->GetCookie(), szParent);
      if (SUCCEEDED(hr))
      {
        if (szParent.CompareNoCase(pDSSelectedFolderNode->GetCookie()->GetPath()) == 0) 
        {
          _AddResultItem(pDSUINode);

          m_pComponentData->SortResultPane(pDSUINode->GetParent());
          _UpdateObjectCount(FALSE);
        }
      }

      break;
    }
  case DS_MULTIPLE_MOVE_OCCURRED:
    {
      CUINodeList* pNodesMovedList = reinterpret_cast<CUINodeList*>(arg); // gross

      //
      // If the selected folder is not a DS node then its probably a saved query
      // in which case we just want to break because we don't want to delete the results
      // of the saved query just change its path
      //
      CDSUINode* pDSSelectedFolderNode = dynamic_cast<CDSUINode*>(m_pSelectedFolderNode);
      if (pDSSelectedFolderNode == NULL)
        break;

      CString ObjPath; 
      CString szParent = L"";
      BOOL fInThisContainer = FALSE;

      for (POSITION pos = pNodesMovedList->GetHeadPosition(); pos != NULL; )
      {
        CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(pNodesMovedList->GetNext(pos));
        // REVIEW_MARCOC_PORT: this is working for DS objects only
        // need to generalize for all folder types
        if (pDSUINode == NULL)
        {
          ASSERT(FALSE);
          break; // can't do it, should be doing it in the future
        }

        if (!pDSUINode->IsContainer()) 
        {
          // it s a leaf node, delete from result pane
          HRESULTITEM ItemID;
          hr = m_pResultData->FindItemByLParam ((LPARAM)pDSUINode, &ItemID);
          if (SUCCEEDED(hr)) 
          {
            hr = m_pSelectedFolderNode->GetFolderInfo()->RemoveNode(pDSUINode);
            hr = m_pResultData->DeleteItem(ItemID, 0);
          }
      
          if (szParent.IsEmpty()) 
          { 
            hr = m_pComponentData->GetActiveDS()->GetParentDN(pDSUINode->GetCookie(), szParent);
            if (SUCCEEDED(hr))
            {
              if (szParent.CompareNoCase(pDSSelectedFolderNode->GetCookie()->GetPath()) == 0) 
              {
                fInThisContainer = TRUE;
              }
            }
          }
          if (fInThisContainer) 
          {
            _AddResultItem(pDSUINode);
          }
        }
      }
      _UpdateObjectCount(FALSE);
      break;
    }
  case DS_CREATE_OCCURRED_RESULT_PANE:
  case DS_CREATE_OCCURRED:
    {

      CUINode* pParent = NULL;
      CUINode* pTmpNode = NULL;

      if (pDataObject) 
      {
        CInternalFormatCracker dobjCracker;
        VERIFY(SUCCEEDED(dobjCracker.Extract(pDataObject)));
        pTmpNode = dobjCracker.GetCookie();
        if (Action == DS_CREATE_OCCURRED_RESULT_PANE) 
        {
          pParent = pTmpNode->GetParent();
        }
        else 
        {
          pParent = pTmpNode;
        }
      }
      else 
      {
        pParent = m_pSelectedFolderNode;
      }
      if (pParent == m_pSelectedFolderNode) 
      {
        // reset icon list, just in case it was a new type of object
        m_pComponentData->FillInIconStrip (m_pRsltImageList);

        //
        // Add and select the new item
        //
        _AddResultItem(reinterpret_cast<CUINode*>(arg), FALSE);
        m_pComponentData->SortResultPane(pParent);

        // Must select the result node after the sort to ensure visibility
        SelectResultNode(reinterpret_cast<CUINode*>(arg));

        _UpdateObjectCount(FALSE);
      }
      else
      {
        pParent->GetFolderInfo()->SetSortOnNextSelect(TRUE);
      }

      break;
    }
  case DS_HAVE_DATA:
    {
      CInternalFormatCracker dobjCracker;
      VERIFY(SUCCEEDED(dobjCracker.Extract(pDataObject)));
      CUINode* pContainerNode = dobjCracker.GetCookie();
      if (pContainerNode == m_pSelectedFolderNode) 
      {
        TIMER(_T("adding leaf items to view\n"));
        CUINodeList* pNodeList = reinterpret_cast<CUINodeList*>(arg);
        for (POSITION pos = pNodeList->GetHeadPosition(); pos != NULL; )
        {
          CUINode* pNewUINode = pNodeList->GetNext(pos);
          if (!pNewUINode->IsContainer())
          {
            // add to the scope pane
           _AddResultItem(pNewUINode);
          }
          _UpdateObjectCount(FALSE);
        }
      }
      break;
    }
  case DS_REFRESH_REQUESTED:
    {
      CUINode* pUINode = reinterpret_cast<CUINode*>(arg);
      if (pUINode == m_pSelectedFolderNode) {
        m_pResultData->DeleteAllRsltItems();
      
        _UpdateObjectCount (TRUE);
      }
      break;
    }
  case DS_VERB_UPDATE:
    {
      CUINode* pUINode = reinterpret_cast<CUINode*>(arg);
      if (pUINode == m_pSelectedFolderNode) 
      {
        CContextMenuVerbs* pMenuVerbs = pUINode->GetContextMenuVerbsObject(m_pComponentData);

        if (pMenuVerbs == NULL)
        {
          ASSERT(FALSE);
          return;
        }
        pMenuVerbs->LoadStandardVerbs(m_pConsoleVerb, 
                                      TRUE/*bScope*/, 
			 					                      TRUE /*bSelect*/,
                                      pUINode,
                                      pDataObject);
      }
      break;
    }
  case DS_DELAYED_EXPAND:
    {
      CUINode* pUINode = reinterpret_cast<CUINode*>(arg);
      ASSERT(pUINode->IsContainer());
      //    if (pCookie == m_pSelectedFolderNode) {
      m_pFrame->Expand (pUINode->GetFolderInfo()->GetScopeItem(),
                        TRUE);
      //}
    }
    break;
  case DS_ICON_STRIP_UPDATE:
    {
      // reset icon list, just in case it was a new type of object
      m_pComponentData->FillInIconStrip (m_pRsltImageList);
    }
    break;

  case DS_IS_COOKIE_SELECTION:
    {
      PUINODESELECTION pUINodeSel = reinterpret_cast<PUINODESELECTION>(arg); //gross
      if (pUINodeSel->IsSelection)
      {
        // got the snawer from some other view, just skip
        break;
      }
      if (pUINodeSel->pUINode == m_pSelectedFolderNode) 
      {
        // selected folder in this view
        pUINodeSel->IsSelection = TRUE;
      } 
      else 
      {
        // not selected in this view, but look for the parents
        // of the current selection
        CUINode* pParentNode = m_pSelectedFolderNode->GetParent();
        while (pParentNode) 
        {
          if (pUINodeSel->pUINode == pParentNode) 
          {
            pUINodeSel->IsSelection = TRUE;
            break;
          }
          else 
          {
            pParentNode = pParentNode->GetParent();
          }
        } // while
      }
    } // case
    break;

  case DS_SORT_RESULT_PANE:
    {
      CUINode* pUINode = reinterpret_cast<CUINode*>(arg);
      MMC_SORT_SET_DATA* pColumnData = NULL;
      TIMER(_T("sorting result pane, starting"));
      CDSColumnSet* pColumnSet = pUINode->GetColumnSet(m_pComponentData);
      if (pColumnSet == NULL)
        break;
    
      LPCWSTR lpszID = pColumnSet->GetColumnID();
      size_t iLen = wcslen(lpszID);
    
      // allocate enough memory for the struct and the column ID
      SColumnSetID* pNodeID = (SColumnSetID*)malloc(sizeof(SColumnSetID) + (iLen * sizeof(WCHAR)));
      if (pNodeID != NULL)
      {
        memset(pNodeID, 0, sizeof(SColumnSetID) + (iLen * sizeof(WCHAR)));
        pNodeID->cBytes = static_cast<ULONG>(iLen * sizeof(WCHAR));
        memcpy(pNodeID->id, lpszID, (iLen * sizeof(WCHAR)));

        CComPtr<IColumnData> spColumnData;
        hr = m_pFrame->QueryInterface(IID_IColumnData, (void**)&spColumnData);
        if (spColumnData != NULL)
        {
          hr = spColumnData->GetColumnSortData(pNodeID, &pColumnData);
        }

        if (hr == S_OK && pColumnData != NULL)
        {
          m_pResultData->Sort(pColumnData->pSortData->nColIndex, pColumnData->pSortData->dwSortOptions, NULL);
          CoTaskMemFree(pColumnData);
        }
        else
        {
          //
          // Sort by the name column ascending if the user hasn't persisted something else
          //
          m_pResultData->Sort(0, RSI_NOSORTICON, NULL);
        }
        free(pNodeID);
      }
      else
      {
        //
        // Sort by the name column ascending if the user hasn't persisted something else
        //
        m_pResultData->Sort(0, RSI_NOSORTICON, NULL);
      }
      break;
      TIMER(_T("sorting result pane, done"));

      if (pUINode != m_pSelectedFolderNode &&
          pUINode->IsContainer())
      {
         pUINode->GetFolderInfo()->SetSortOnNextSelect(TRUE);
      }
    }
    break;
  case DS_UPDATE_VISIBLE_COLUMNS:
    {
      CUINode* pUINode = reinterpret_cast<CUINode*>(arg);
      if (m_bUpdateAllViewsOrigin)
      {
        // this message originated from this instance,
        // it is handled separately
        break;
      }

      CDSColumnSet* pColumnSet = pUINode->GetColumnSet(m_pComponentData);
      if (pColumnSet == NULL)
        break;
    
      CComPtr<IColumnData> spColumnData;
      hr = m_pFrame->QueryInterface(IID_IColumnData, (void**)&spColumnData);
      if (spColumnData != NULL)
        hr = pColumnSet->LoadFromColumnData(spColumnData);
      if (FAILED(hr))
      {
        pColumnSet->SetAllColumnsToDefaultVisibility();
      }
      break;
    }
  case DS_UPDATE_OBJECT_COUNT:
    _UpdateObjectCount(FALSE);
    break;

  case DS_UNSELECT_OBJECT:
    {
      CUINode* pUINode = reinterpret_cast<CUINode*>(arg);
      if (pUINode != NULL)
      {
        HRESULTITEM ItemID;
        hr = m_pResultData->FindItemByLParam ((LPARAM)pUINode, &ItemID);
        if (SUCCEEDED(hr)) 
        {
          VERIFY(SUCCEEDED(m_pResultData->ModifyItemState(0 /*unused*/,
                                                          ItemID,
                                                          0 /*not adding*/,
                                                          LVIS_FOCUSED | LVIS_SELECTED)));
        }
      }
    }
    break;

  } // switch

}

void
CDSEvent::_UpdateObjectCount(BOOL fZero)
{
  if (!m_pSelectedFolderNode->IsContainer())
  {
    ASSERT(m_pSelectedFolderNode->IsContainer());
    return;
  }

  UINT cItems = 0;
  if (!fZero) 
  { 
    CUINodeList* pclFolders = m_pSelectedFolderNode->GetFolderInfo()->GetContainerList();
    CUINodeList* pclLeaves = m_pSelectedFolderNode->GetFolderInfo()->GetLeafList();

    if (pclFolders && pclLeaves)
    {
      cItems = (UINT)(pclFolders->GetCount() + pclLeaves->GetCount());
    }
  }
  else //set the count to 0
  {
    m_pSelectedFolderNode->GetFolderInfo()->SetTooMuchData(FALSE, 0);
  }
  
  CString csTemp;
  if (IS_CLASS(*m_pSelectedFolderNode, CSavedQueryNode))
  {
    CSavedQueryNode* pSavedQueryNode = dynamic_cast<CSavedQueryNode*>(m_pSelectedFolderNode);
    if (pSavedQueryNode && !pSavedQueryNode->IsValid())
    {
      VERIFY(csTemp.LoadString(IDS_DESCBAR_INVALID_SAVEDQUERY));
    }
  }

  if (csTemp.IsEmpty())
  {
    if (m_pSelectedFolderNode->GetFolderInfo()->HasTooMuchData())
    {
      UINT nApprox = m_pSelectedFolderNode->GetFolderInfo()->GetApproxTotalContained();
      nApprox = __max(nApprox, cItems);

      csTemp.Format(IDS_DESCBAR_TOO_MUCH_DATA, 
                    nApprox);
    }
    else
    {
      VERIFY(csTemp.LoadString(IDS_OBJECTS));
    }
  }

  CString csDescription;
  csDescription.Format (L"%d%s", cItems, csTemp);
  if (m_pComponentData->m_pQueryFilter &&
      m_pComponentData->m_pQueryFilter->IsFilteringActive()) 
  {
    CString csFilter;
    csFilter.LoadString (IDS_FILTERING_ON);
    csDescription += csFilter;
  }

  if (m_pResultData)
  {
    m_pResultData->SetDescBarText ((LPWSTR)(LPCWSTR)csDescription);
  }
}

HRESULT CDSEvent::_SetColumns(CUINode* pUINode)
{
  ASSERT(pUINode->IsContainer());

  TRACE(_T("CDSEvent::_SetColumns on container %s\n"),
        (LPWSTR)(LPCWSTR)pUINode->GetName());

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = S_OK;


  CDSColumnSet* pColumnSet = pUINode->GetColumnSet(m_pComponentData);
  if (pColumnSet == NULL)
    return hr;

  for (POSITION pos = pColumnSet->GetHeadPosition(); pos != NULL; )
  {
    CDSColumn* pColumn = (CDSColumn*)pColumnSet->GetNext(pos);
    int nWidth = (pColumn->IsVisible()) ? AUTO_WIDTH : HIDE_COLUMN;
    hr = m_pHeader->InsertColumn(pColumn->GetColumnNum(),
                                  pColumn->GetHeader(),
                                  pColumn->GetFormat(),
                                  nWidth);
    ASSERT(SUCCEEDED(hr));

    hr = m_pHeader->SetColumnWidth(pColumn->GetColumnNum(),
                                   pColumn->GetWidth());

    ASSERT(SUCCEEDED(hr));
  }

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsdlgs.cpp ===
//+----------------------------------------------------------------------------
//
//  DS Administration MMC snapin.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSDlgs.cpp
//
//  Contents:  TBD
//
//  History:   02-Oct-96 WayneSc    Created
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"

#include "dssnap.h"
#include "uiutil.h"

#include "DSDlgs.h"

#include "helpids.h"

#include "dsrole.h"   // DsRoleGetPrimaryDomainInformation
#include <lm.h>
#include <dsgetdc.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChangePassword dialog
CChangePassword::CChangePassword(CWnd* pParent /*=NULL*/)
  : CHelpDialog(CChangePassword::IDD, pParent)
{
  //{{AFX_DATA_INIT(CChangePassword)
  m_ConfirmPwd = _T("");
  m_NewPwd = _T("");
  m_ChangePwd = FALSE;
  //}}AFX_DATA_INIT

  m_bAllowMustChangePwdCheck = TRUE;
}

BOOL CChangePassword::OnInitDialog()
{
  CHelpDialog::OnInitDialog();

  SendDlgItemMessage(IDC_NEW_PASSWORD, EM_LIMITTEXT, (WPARAM)127, 0);
  SendDlgItemMessage(IDC_CONFIRM_PASSWORD, EM_LIMITTEXT, (WPARAM)127, 0);

  GetDlgItem(IDC_CHECK_PASSWORD_MUST_CHANGE)->EnableWindow(m_bAllowMustChangePwdCheck);

  return TRUE;
}

void CChangePassword::DoDataExchange(CDataExchange* pDX)
{
  CHelpDialog::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CChangePassword)
  DDX_Text(pDX, IDC_CONFIRM_PASSWORD, m_ConfirmPwd);
  DDX_Text(pDX, IDC_NEW_PASSWORD, m_NewPwd);
  DDX_Check(pDX, IDC_CHECK_PASSWORD_MUST_CHANGE, m_ChangePwd);
  //}}AFX_DATA_MAP
}

void CChangePassword::Clear()
{
  m_ConfirmPwd = _T("");
  m_NewPwd = _T("");

  SetDlgItemText(IDC_NEW_PASSWORD, L"");
  SetDlgItemText(IDC_CONFIRM_PASSWORD, L"");
}

BEGIN_MESSAGE_MAP(CChangePassword, CHelpDialog)
END_MESSAGE_MAP()

void CChangePassword::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_CHANGE_PASSWORD); 
  }
}

/////////////////////////////////////////////////////////////////////////////
// Helper functions for CChooseDomainDlg and CChooseDCDlg
//

//+---------------------------------------------------------------------------
//
//  Function:   BrowseDomainTree
//
//  Synopsis:   This function invokes IDsBrowseDomainTree::BrowseTo(), 
//    which brings up the domain tree browse dialog, and returns the 
//    selected domain's DNS name
//
// NOTE: the OUT parameter needs to be LocalFreeString() by the caller
// NOTE: this function will return S_FALSE if user clicks Cancel button
//
//----------------------------------------------------------------------------

HRESULT BrowseDomainTree(
    IN HWND hwndParent, 
    IN LPCTSTR pszServer,
    OUT LPTSTR *ppszDomainDnsName
)
{
  ASSERT(ppszDomainDnsName);
  ASSERT(!(*ppszDomainDnsName));  // prevent memory leak

  *ppszDomainDnsName = NULL;

  CComPtr<IDsBrowseDomainTree> spDsDomains;
  HRESULT hr = ::CoCreateInstance(CLSID_DsDomainTreeBrowser,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsBrowseDomainTree,
                          reinterpret_cast<void **>(&spDsDomains));
  if (SUCCEEDED(hr))
  {
    if (pszServer && *pszServer)
      hr = spDsDomains->SetComputer(pszServer, NULL, NULL); // use default credential

    if (SUCCEEDED(hr))
    {
      LPTSTR lpszDomainPath;
      hr = spDsDomains->BrowseTo(
                            hwndParent, //HWND hwndParent
                            &lpszDomainPath, // LPWSTR *ppszTargetPath
                            DBDTF_RETURNINBOUND);
      if ( (hr == S_OK) && lpszDomainPath)
      {
        *ppszDomainDnsName = lpszDomainPath; //should be freed by CoTaskMemFree later
      }
    }
  }

  return hr;
}

HRESULT GetDCOfDomain(
    IN CString&   csDomainName,
    OUT CString&  csDCName,
    IN BOOL       bForce
)
{
  ASSERT(csDomainName.IsEmpty() == FALSE);

  CString csServerName;
  DWORD dwErr = 0;

  csDCName.Empty();

  PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
  if (bForce)
    dwErr = DsGetDcName(NULL, csDomainName, NULL, NULL,
              DS_DIRECTORY_SERVICE_PREFERRED | DS_FORCE_REDISCOVERY, &pDCInfo);
  else
    dwErr = DsGetDcName(NULL, csDomainName, NULL, NULL,
              DS_DIRECTORY_SERVICE_PREFERRED, &pDCInfo);

  if (ERROR_SUCCESS == dwErr)
  {
    if ( !(pDCInfo->Flags & DS_DS_FLAG) )
    {
      // down level domain
      NetApiBufferFree(pDCInfo);
      return S_OK;
    }

    csDCName = pDCInfo->DomainControllerName;
    NetApiBufferFree(pDCInfo);
  }

  return HRESULT_FROM_WIN32(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDnsNameOfDomainOrForest
//
//  Synopsis:   Given a server name or a domain name (either NETBIOS or DNS), 
//              this function will return the DNS name for its domain or forest.
//
//  Parameters:
//    csName,      // a server name or a domain name
//    csDnsName,   // hold the returning DNS name
//    bIsInputADomainName, // TRUE if csName is a domain name, FALSE if it's a server name
//    bRequireDomain   // TRUE for a domain dns name, FALSE for a forest dns name
//
//----------------------------------------------------------------------------
HRESULT GetDnsNameOfDomainOrForest(
    IN CString&   csName,
    OUT CString&  csDnsName,
    IN BOOL       bIsInputADomainName,
    IN BOOL       bRequireDomain
)
{

  BOOL    bRetry = FALSE;
  PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBuffer = NULL;
  CString csServerName;
  DWORD dwErr = 0;

  csDnsName.Empty();

  do {
    if (bIsInputADomainName)
    {
      PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
      if (bRetry)
        dwErr = DsGetDcName(NULL, csName, NULL, NULL,
                  DS_DIRECTORY_SERVICE_PREFERRED | DS_FORCE_REDISCOVERY, &pDCInfo);
      else
        dwErr = DsGetDcName(NULL, csName, NULL, NULL,
                  DS_DIRECTORY_SERVICE_PREFERRED, &pDCInfo);

      if (ERROR_SUCCESS == dwErr)
      {
        if ( !(pDCInfo->Flags & DS_DS_FLAG) )
        {
          // down level domain
          NetApiBufferFree(pDCInfo);
          return S_OK;
        }

        DWORD dwExpectFlag = (bRequireDomain ?
                              DS_DNS_DOMAIN_FLAG :
                              DS_DNS_FOREST_FLAG);

        if (pDCInfo->Flags & dwExpectFlag)
        {
          // skip call to DsRoleGetPrimaryDomainInformation()
          csDnsName = (bRequireDomain ?
                        pDCInfo->DomainName :
                        pDCInfo->DnsForestName);
          NetApiBufferFree(pDCInfo);

          //
          // The DNS name is in absolute form, remove the ending dot
          //
          if (csDnsName.Right(1) == _T("."))
            csDnsName.SetAt(csDnsName.GetLength() - 1, _T('\0'));

          return S_OK;

        } else {
          csServerName = pDCInfo->DomainControllerName;
          NetApiBufferFree(pDCInfo);
        }
      } else
      { 
        return HRESULT_FROM_WIN32(dwErr);
      }
    } else
    {
      csServerName = csName;
    }

    dwErr = DsRoleGetPrimaryDomainInformation(
        csServerName, 
        DsRolePrimaryDomainInfoBasic,
        (PBYTE *)&pBuffer);
    if (RPC_S_SERVER_UNAVAILABLE == dwErr && bIsInputADomainName && !bRetry)
      bRetry = TRUE; // only retry once
    else
      break;

  } while (1);

  if (ERROR_SUCCESS == dwErr)
  {
    csDnsName = (bRequireDomain ?
                  pBuffer->DomainNameDns :
                  pBuffer->DomainForestName);
    if (csDnsName.IsEmpty())
    {
      if (pBuffer->Flags & DSROLE_PRIMARY_DS_RUNNING)
        csDnsName = pBuffer->DomainNameFlat;
    }

    DsRoleFreeMemory(pBuffer);

    //
    // In case the DNS name is in absolute form, remove the ending dot
    //
    if (csDnsName.Right(1) == _T("."))
      csDnsName.SetAt(csDnsName.GetLength() - 1, _T('\0'));

  }

  return HRESULT_FROM_WIN32(dwErr);
}

/////////////////////////////////////////////////////////////////////////////
// CChooseDomainDlg dialog


CChooseDomainDlg::CChooseDomainDlg(CWnd* pParent /*=NULL*/)
  : CHelpDialog(CChooseDomainDlg::IDD, pParent)
{
  //{{AFX_DATA_INIT(CChooseDomainDlg)
  m_csTargetDomain = _T("");
  m_bSaveCurrent = FALSE;
  //}}AFX_DATA_INIT
}


void CChooseDomainDlg::DoDataExchange(CDataExchange* pDX)
{
  CHelpDialog::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CChooseDomainDlg)
  DDX_Text(pDX, IDC_SELECTDOMAIN_DOMAIN, m_csTargetDomain);
  DDX_Check(pDX, IDC_SAVE_CURRENT_CHECK, m_bSaveCurrent);
  //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChooseDomainDlg, CHelpDialog)
  //{{AFX_MSG_MAP(CChooseDomainDlg)
  ON_BN_CLICKED(IDC_SELECTDOMAIN_BROWSE, OnSelectdomainBrowse)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseDomainDlg message handlers

void CChooseDomainDlg::OnSelectdomainBrowse() 
{
  CWaitCursor cwait;

  HRESULT hr = S_OK;
  LPTSTR lpszDomainDnsName = NULL;
  CString csDomainName, csDCName;

  GetDlgItemText(IDC_SELECTDOMAIN_DOMAIN, csDomainName);
  csDomainName.TrimLeft();
  csDomainName.TrimRight();
  if (!csDomainName.IsEmpty())
    hr = GetDCOfDomain(csDomainName, csDCName, FALSE);
  if (SUCCEEDED(hr))
  {
    hr = BrowseDomainTree(m_hWnd, csDCName, &lpszDomainDnsName);
    if ( FAILED(hr) &&
         !csDCName.IsEmpty() &&
         HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr )
    {
      // force the cached info in DsGetDcName to be refreshed
      hr = GetDCOfDomain(csDomainName, csDCName, TRUE);
      if (SUCCEEDED(hr))
        hr = BrowseDomainTree(m_hWnd, csDCName, &lpszDomainDnsName);
    }

    if ( (hr == S_OK) && lpszDomainDnsName )
    {
      SetDlgItemText(IDC_SELECTDOMAIN_DOMAIN, lpszDomainDnsName);
      CoTaskMemFree(lpszDomainDnsName);
    }
  }
  
  if (FAILED(hr)) {
    PVOID apv[1];
    apv[0] = static_cast<PVOID>(const_cast<LPTSTR>(static_cast<LPCTSTR>(csDomainName)));

    ReportErrorEx(m_hWnd,IDS_CANT_BROWSE_DOMAIN, hr,
                        MB_OK | MB_ICONERROR, apv, 1, 0);
  }

  GetDlgItem(IDC_SELECTDOMAIN_DOMAIN)->SetFocus();
}

void CChooseDomainDlg::OnOK() 
{
  CWaitCursor cwait;
  HRESULT hr = S_OK;
  CString csName, csDnsName;

  //
  // Validate contents in the domain edit box
  //
  GetDlgItemText(IDC_SELECTDOMAIN_DOMAIN, csName);
  if (csName.IsEmpty())
  {
    ReportMessageEx(m_hWnd, IDS_INCORRECT_INPUT,  
      MB_OK | MB_ICONSTOP);
    (GetDlgItem(IDC_SELECTDOMAIN_DOMAIN))->SetFocus();
    return;
  }
  hr = GetDnsNameOfDomainOrForest(
            csName, 
            csDnsName, 
            TRUE, 
            !m_bSiteRepl);
  if (csDnsName.IsEmpty())
  {
    PVOID apv[1];
    apv[0] = static_cast<PVOID>(const_cast<LPTSTR>(static_cast<LPCTSTR>(csName)));

    if (FAILED(hr))
      ReportErrorEx(m_hWnd, IDS_SELECTDOMAIN_INCORRECT_DOMAIN_DUETO, hr, 
        MB_OK | MB_ICONSTOP, apv, 1, 0);
    else
      ReportMessageEx(m_hWnd, IDS_SELECTDOMAIN_DOWNLEVEL_DOMAIN, 
        MB_OK | MB_ICONSTOP, apv, 1);

    SetDlgItemText(IDC_SELECTDOMAIN_DOMAIN, _T(""));
    (GetDlgItem (IDC_SELECTDOMAIN_DOMAIN))->SetFocus();
    return;
  }

  //
  // When exiting from the dialog
  // use DNS domain name;
  //
  SetDlgItemText(IDC_SELECTDOMAIN_DOMAIN, csDnsName);

  CHelpDialog::OnOK();
}


BOOL CChooseDomainDlg::OnInitDialog() 
{
  CHelpDialog::OnInitDialog();
  
  //
  // for siterepl snapin only, 
  // change dialog title to "Choose Target Forest"
  // change domain label to "Root domain:"
  // hide browse button
  //
  if (m_bSiteRepl)
  {
    CString csDlgTitle, csLabel;
    csDlgTitle.LoadString(IDS_SELECTDOMAIN_TITLE_FOREST);
    SetWindowText(csDlgTitle);
    csLabel.LoadString(IDS_SELECTDOMAIN_DOMAIN_LABEL);
    SetDlgItemText(IDC_SELECTDOMAIN_LABEL, csLabel);

    // Hide & Disable the Browse button for SiteRepl snapin
    (GetDlgItem(IDC_SELECTDOMAIN_BROWSE))->ShowWindow(SW_HIDE);
    (GetDlgItem(IDC_SELECTDOMAIN_BROWSE))->EnableWindow(FALSE);
  }
  return TRUE;  // return TRUE unless you set the focus to a control
                // EXCEPTION: OCX Property Pages should return FALSE
}

void CChooseDomainDlg::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_SELECT_DOMAIN); 
  }
}

/////////////////////////////////////////////////////////////////////////////
// CChooseDCDlg dialog

BEGIN_MESSAGE_MAP(CSelectDCEdit, CEdit)
  ON_WM_KILLFOCUS()
END_MESSAGE_MAP()

void CSelectDCEdit::OnKillFocus(CWnd* pNewWnd)
{
  //
  // subclass the domain edit control.
  // When focus moves to OK/Cancel/Browse button, do not invoke
  // RefreshDCListView
  //
  m_bHandleKillFocus = TRUE;
  if (pNewWnd)
  {
    int id = pNewWnd->GetDlgCtrlID();
    if (id == IDOK ||
        id == IDCANCEL ||
        id == IDC_SELECTDC_BROWSE)
    {
      m_bHandleKillFocus = FALSE;
    }
  }

  CEdit::OnKillFocus(pNewWnd);
}


CChooseDCDlg::CChooseDCDlg(CWnd* pParent /*=NULL*/)
  : CHelpDialog(CChooseDCDlg::IDD, pParent)
{
  //{{AFX_DATA_INIT(CChooseDCDlg)
  m_csTargetDomainController = _T("");
  m_csTargetDomain = _T("");
  //}}AFX_DATA_INIT
  m_csPrevDomain = _T("");
  m_pDCBufferManager = NULL;
  m_csAnyDC.LoadString(IDS_ANY_DOMAIN_CONTROLLER);
  m_csWaiting.LoadString(IDS_WAITING);
  m_csError.LoadString(IDS_ERROR);
}

CChooseDCDlg::~CChooseDCDlg()
{
  TRACE(_T("CChooseDCDlg::~CChooseDCDlg\n"));

  if (m_pDCBufferManager)
  {
    //
    // signal all related running threads to terminate
    //
    m_pDCBufferManager->SignalExit();

    //
    // decrement the reference count on the CDCBufferManager instance
    //
    m_pDCBufferManager->Release();
  }

  CHelpDialog::~CHelpDialog();
}

void CChooseDCDlg::DoDataExchange(CDataExchange* pDX)
{
  CHelpDialog::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CChooseDCDlg)
  DDX_Control(pDX, IDC_SELECTDC_DCLISTVIEW, m_hDCListView);
  DDX_Text(pDX, IDC_SELECTDC_DCEDIT, m_csTargetDomainController);
  DDX_Text(pDX, IDC_SELECTDC_DOMAIN, m_csTargetDomain);
  //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChooseDCDlg, CHelpDialog)
  //{{AFX_MSG_MAP(CChooseDCDlg)
  ON_NOTIFY(LVN_ITEMCHANGED, IDC_SELECTDC_DCLISTVIEW, OnItemchangedSelectdcDCListView)
  ON_EN_KILLFOCUS(IDC_SELECTDC_DOMAIN, OnKillfocusSelectdcDomain)
  ON_BN_CLICKED(IDC_SELECTDC_BROWSE, OnSelectdcBrowse)
  ON_NOTIFY(LVN_COLUMNCLICK, IDC_SELECTDC_DCLISTVIEW, OnColumnclickSelectdcDCListView)
	//}}AFX_MSG_MAP
  ON_MESSAGE(WM_USER_GETDC_THREAD_DONE, OnGetDCThreadDone)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseDCDlg message handlers
typedef struct _DCListViewItem
{
  CString csName;
  CString csSite;
} DCLISTVIEWITEM;

BOOL CChooseDCDlg::OnInitDialog() 
{
  CHelpDialog::OnInitDialog();

  //
  // sub-class the domain edit control, in order to intercept WM_KILLFOCUS
  // if the new focus will be set on Cancel button, don't process 
  // EN_KILLFOCUS (i.e., don't start the thread to refresh DC list view )
  //
  VERIFY(m_selectDCEdit.SubclassDlgItem(IDC_SELECTDC_DOMAIN, this));

  //
  // create instance of CDCBufferManager
  // m_pDCBufferManager will be set to NULL if CreateInstance() failed.
  //
  (void) CDCBufferManager::CreateInstance(m_hWnd, &m_pDCBufferManager);

  //
  // display currently targeted domain controller
  //
  CString csText, csFormat;
  csFormat.LoadString(IDS_SELECTDC_DCEDIT_TITLE);
  csText.Format(csFormat, m_csTargetDomainController);
  SetDlgItemText(IDC_SELECTDC_DCEDIT_TITLE, csText);

  //
  // calculate the listview column width
  //
  RECT      rect;
  ZeroMemory(&rect, sizeof(rect));
  (GetDlgItem(IDC_SELECTDC_DCLISTVIEW))->GetWindowRect(&rect);
  int nControlWidth = rect.right - rect.left;
  int nVScrollbarWidth = GetSystemMetrics(SM_CXVSCROLL);
  int nBorderWidth = GetSystemMetrics(SM_CXBORDER);
  int nControlNetWidth = nControlWidth - nVScrollbarWidth - 4 * nBorderWidth;
  int nWidth1 = nControlNetWidth / 2;
  int nWidth2 = nControlNetWidth - nWidth1;

  //
  // insert two columns of DC list view 
  //
  LV_COLUMN col;
  CString   cstrText;
  ZeroMemory(&col, sizeof(col));
  col.mask = LVCF_TEXT | LVCF_WIDTH;
  col.cx = nWidth1;
  cstrText.LoadString(IDS_SELECTDC_DCLISTVIEW_NAME);
  col.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrText));
  ListView_InsertColumn(m_hDCListView, 0, &col);
  col.cx = nWidth2;
  cstrText.LoadString(IDS_SELECTDC_DCLISTVIEW_SITE);
  col.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrText));
  ListView_InsertColumn(m_hDCListView, 1, &col);

  //
  // Set full row selection style
  //
  ListView_SetExtendedListViewStyleEx(m_hDCListView, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

  //
  // disable the list view control
  // In case we failed to create a CDCBufferManager instance, user can 
  // still use this dialog to type in a domain name and a DC name.
  //
  m_hDCListView.EnableWindow(FALSE);

  //
  // insert items into DC list view 
  //
  RefreshDCListView();

  if (!m_bSiteRepl)
  {
    //
    // Disable domain edit box and hide&disable Browse button for non-siterepl snapins
    //
    (reinterpret_cast<CEdit *>(GetDlgItem(IDC_SELECTDC_DOMAIN)))->SetReadOnly(TRUE);
    (GetDlgItem(IDC_SELECTDC_BROWSE))->ShowWindow(SW_HIDE);
    (GetDlgItem(IDC_SELECTDC_BROWSE))->EnableWindow(FALSE);

    //
    // for non-siterepl snapins, set focus to the DC edit box;
    // for siterepl snapin, the focus will be set on the domain edit box.
    //
    (GetDlgItem(IDC_SELECTDC_DCEDIT))->SetFocus();
    return FALSE;
  }

  return TRUE;  
  
  // return TRUE unless you set the focus to a control
  // EXCEPTION: OCX Property Pages should return FALSE
}

int CALLBACK ListViewCompareProc(
    IN LPARAM lParam1, 
    IN LPARAM lParam2, 
    IN LPARAM lParamSort)
{
  DCLISTVIEWITEM *pItem1 = (DCLISTVIEWITEM *)lParam1;
  DCLISTVIEWITEM *pItem2 = (DCLISTVIEWITEM *)lParam2;
  int iResult = 0;

  if (pItem1 && pItem2)
  {
    switch( lParamSort)
    {
    case 0:     // Sort by Name.
      iResult = pItem1->csName.CompareNoCase(pItem2->csName);
      break;
    case 1:     // Sort by Site.
      iResult = pItem1->csSite.CompareNoCase(pItem2->csSite);
      break;
    default:
      iResult = 0;
      break;
    }
  }

  return(iResult);
}

void CChooseDCDlg::OnColumnclickSelectdcDCListView(NMHDR* pNMHDR, LRESULT* pResult) 
{
  NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

  ListView_SortItems( m_hDCListView,
                      ListViewCompareProc,
                      (LPARAM)(pNMListView->iSubItem));
  
  *pResult = 0;
}

#define MAX_LENGTH_DCNAME 1024
void CChooseDCDlg::OnItemchangedSelectdcDCListView(NMHDR* pNMHDR, LRESULT* pResult) 
{
  NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

  //
  // set DC edit box to the currently selected item in the dc list view 
  //

  if ( (pNMListView->uChanged & LVIF_STATE) &&
       (pNMListView->uNewState & LVIS_SELECTED) )
  {
    TCHAR pszBuffer[MAX_LENGTH_DCNAME];
    
    ListView_GetItemText(
      (GetDlgItem(IDC_SELECTDC_DCLISTVIEW))->GetSafeHwnd(),
      pNMListView->iItem,
      0,
      pszBuffer,
      MAX_LENGTH_DCNAME * sizeof(TCHAR)
      );

    SetDlgItemText(IDC_SELECTDC_DCEDIT, pszBuffer);
  }

  *pResult = 0;
}

void CChooseDCDlg::OnKillfocusSelectdcDomain() 
{
  TRACE(_T("CChooseDCDlg::OnKillfocusSelectdcDomain\n"));

  //
  // when focus leaves domain edit box, refresh the items in the dc list view 
  // we do this only for siterepl snapin whose domain edit box is enabled. 
  //
  if (m_selectDCEdit.m_bHandleKillFocus)
  {
    if (m_bSiteRepl)
      RefreshDCListView();
  }
}

void CChooseDCDlg::OnSelectdcBrowse() 
{
  CWaitCursor cwait;

  //
  // bring up the domain tree browse dialog
  //
  HRESULT hr = S_OK;
  LPTSTR lpszDomainDnsName = NULL;
  CString csDomainName, csDCName;

  GetDlgItemText(IDC_SELECTDC_DOMAIN, csDomainName);
  csDomainName.TrimLeft();
  csDomainName.TrimRight();
  if (!csDomainName.IsEmpty())
    hr = GetDCOfDomain(csDomainName, csDCName, FALSE);
  if (SUCCEEDED(hr))
  {
    hr = BrowseDomainTree(m_hWnd, csDCName, &lpszDomainDnsName);
    if ( FAILED(hr) &&
         !csDCName.IsEmpty() &&
         HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr )
    {
      // force the cached info in DsGetDcName to be refreshed
      hr = GetDCOfDomain(csDomainName, csDCName, TRUE);
      if (SUCCEEDED(hr))
        hr = BrowseDomainTree(m_hWnd, csDCName, &lpszDomainDnsName);
    }

    if ( (hr == S_OK) && lpszDomainDnsName )
    {
      SetDlgItemText(IDC_SELECTDC_DOMAIN, lpszDomainDnsName);
      CoTaskMemFree(lpszDomainDnsName);

      RefreshDCListView();
    }
  }
  
  if (FAILED(hr)) {
    PVOID apv[1];
    apv[0] = static_cast<PVOID>(const_cast<LPTSTR>(static_cast<LPCTSTR>(csDomainName)));

    ReportErrorEx(m_hWnd,IDS_CANT_BROWSE_DOMAIN, hr,
                        MB_OK | MB_ICONERROR, apv, 1, 0);
  }

  GetDlgItem(IDC_SELECTDC_DOMAIN)->SetFocus();
}

void CChooseDCDlg::OnOK() 
{
  TRACE(_T("CChooseDCDlg::OnOK\n"));

  CWaitCursor wait;
  HRESULT hr = S_OK;

  CString csDnsForSelectedDomain;
  CString csDnsForCurrentForest, csDnsForSelectedForest;

  if (m_bSiteRepl)
  {
    hr = GetDnsNameOfDomainOrForest(
              m_csTargetDomain, 
              csDnsForCurrentForest, 
              TRUE, 
              FALSE); // get forest name
    if (csDnsForCurrentForest.IsEmpty())
      csDnsForCurrentForest = m_csTargetDomain;
  }

  //
  // Validate contents in the DC edit box
  //
  CString csDCEdit;
  GetDlgItemText(IDC_SELECTDC_DCEDIT, csDCEdit);

  // treat empty csDCEdit as same as m_csAnyDC
  if (!csDCEdit.IsEmpty() && m_csAnyDC.CompareNoCase(csDCEdit))
  {
    hr = GetDnsNameOfDomainOrForest(
              csDCEdit, 
              csDnsForSelectedDomain, 
              FALSE, 
              TRUE); // get domain name
    if (SUCCEEDED(hr) && m_bSiteRepl)
    {
      hr = GetDnsNameOfDomainOrForest(
              csDCEdit, 
              csDnsForSelectedForest, 
              FALSE, 
              FALSE); // get forest name
    }
    if (csDnsForSelectedDomain.IsEmpty() || (m_bSiteRepl && csDnsForSelectedForest.IsEmpty()) )
    {
      PVOID apv[1];
      apv[0] = static_cast<PVOID>(const_cast<LPTSTR>(static_cast<LPCTSTR>(csDCEdit)));
      
      if (FAILED(hr))
        ReportErrorEx(m_hWnd, IDS_SELECTDC_INCORRECT_DC_DUETO, hr, 
          MB_OK | MB_ICONSTOP, apv, 1, 0);
      else
        ReportMessageEx(m_hWnd, IDS_SELECTDC_DOWNLEVEL_DC, 
          MB_OK | MB_ICONSTOP, apv, 1);
     
      (GetDlgItem(IDC_SELECTDC_DCEDIT))->SetFocus();
      
      return;
    }

  } else
  {

    //
    // Validate contents in the domain edit box
    //
    CString csDomain;
    GetDlgItemText(IDC_SELECTDC_DOMAIN, csDomain);
    if (csDomain.IsEmpty())
    {
      ReportMessageEx(m_hWnd, IDS_INCORRECT_INPUT,  
        MB_OK | MB_ICONSTOP);
      (GetDlgItem(IDC_SELECTDC_DOMAIN))->SetFocus();
      return;
    }
    hr = GetDnsNameOfDomainOrForest(
              csDomain, 
              csDnsForSelectedDomain, 
              TRUE, 
              TRUE); // get domain name
    if (SUCCEEDED(hr) && m_bSiteRepl)
    {
      hr = GetDnsNameOfDomainOrForest(
              csDomain, 
              csDnsForSelectedForest, 
              TRUE, 
              FALSE); // get forest name
    }
    if (csDnsForSelectedDomain.IsEmpty() || (m_bSiteRepl && csDnsForSelectedForest.IsEmpty()) )
    {
      PVOID apv[1];
      apv[0] = static_cast<PVOID>(const_cast<LPTSTR>(static_cast<LPCTSTR>(csDomain)));

      if (FAILED(hr))
        ReportErrorEx(m_hWnd, IDS_SELECTDC_INCORRECT_DOMAIN_DUETO, hr, 
          MB_OK | MB_ICONSTOP, apv, 1, 0);
      else
        ReportMessageEx(m_hWnd, IDS_SELECTDC_DOWNLEVEL_DOMAIN, 
          MB_OK | MB_ICONSTOP, apv, 1);

      SetDlgItemText(IDC_SELECTDC_DOMAIN, _T(""));
      (GetDlgItem(IDC_SELECTDC_DOMAIN))->SetFocus();

      return;
    }
  }

  //
  // if the current selected forest/domain does not belong to the current administering forest/domain,
  // ask user if he really wants to administer the selected forest/domain 
  // via the selected DC (or any writable DC)?
  //
  if ( (m_bSiteRepl && csDnsForSelectedForest.CompareNoCase(csDnsForCurrentForest)) ||
       (!m_bSiteRepl && csDnsForSelectedDomain.CompareNoCase(m_csTargetDomain)) )
  { 
    int nArgs = 0;
    int id = 0;
    PVOID apv[3];
    apv[0] = static_cast<PVOID>(const_cast<LPTSTR>(static_cast<LPCTSTR>(m_bSiteRepl ? csDnsForCurrentForest : m_csTargetDomain)));
    apv[1] = static_cast<PVOID>(const_cast<LPTSTR>(static_cast<LPCTSTR>(m_bSiteRepl ? csDnsForSelectedForest : csDnsForSelectedDomain)));
    if (m_csAnyDC.CompareNoCase(csDCEdit))
    {
      nArgs = 3;
      apv[2] = static_cast<PVOID>(const_cast<LPTSTR>(static_cast<LPCTSTR>(csDCEdit)));
      id = (m_bSiteRepl ? 
            IDS_SELECTDC_UNMATCHED_DC_DOMAIN_SITEREPL : 
            IDS_SELECTDC_UNMATCHED_DC_DOMAIN);
    } else
    {
      nArgs = 2;
      id = (m_bSiteRepl ? 
            IDS_SELECTDC_UNMATCHED_DC_DOMAIN_SITEREPL_ANY : 
            IDS_SELECTDC_UNMATCHED_DC_DOMAIN_ANY);
    }
    
    if (IDYES != ReportMessageEx(m_hWnd, id, MB_YESNO, apv, nArgs))
    {
      (GetDlgItem(IDC_SELECTDC_DCEDIT))->SetFocus();
      return;
    }
  }

  //
  // When exiting from the dialog
  // use DNS domain name;
  // use blank string if "Any Writable DC"
  // clean list view control
  //
  SetDlgItemText(IDC_SELECTDC_DOMAIN, csDnsForSelectedDomain);
  if (0 == m_csAnyDC.CompareNoCase(csDCEdit))
    SetDlgItemText(IDC_SELECTDC_DCEDIT, _T(""));
  FreeDCItems(m_hDCListView);

  CHelpDialog::OnOK();
}

void CChooseDCDlg::OnCancel() 
{
  TRACE(_T("CChooseDCDlg::OnCancel\n"));

  //
  // When exiting from the dialog
  // clean list view control
  //
  FreeDCItems(m_hDCListView);

  CHelpDialog::OnCancel();
}

//+---------------------------------------------------------------------------
//
//  Function:   CChooseDCDlg::InsertSpecialMsg
//
//  Synopsis:   Insert "Waiting..." or "Error" into the list view control,
//              and disable the control to prevent it from being selected.
//
//----------------------------------------------------------------------------
void
CChooseDCDlg::InsertSpecialMsg(
    IN BOOL bWaiting
)
{
  LV_ITEM item;

  //
  // clear DC list view
  //
  FreeDCItems(m_hDCListView);

  ZeroMemory(&item, sizeof(item));
  item.mask = LVIF_TEXT;
  item.pszText = const_cast<LPTSTR>(
    static_cast<LPCTSTR>(bWaiting ? m_csWaiting: m_csError));
  ListView_InsertItem(m_hDCListView, &item);

  //
  // disable the list view to prevent user from clicking on "Waiting..."
  //
  m_hDCListView.EnableWindow(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   CChooseDCDlg::InsertDCListView
//
//  Synopsis:   Insert items into the list view control of the owner dialog.
//
//----------------------------------------------------------------------------
HRESULT
CChooseDCDlg::InsertDCListView(
    IN CDCSITEINFO   *pEntry
)
{
  ASSERT(pEntry);

  DWORD                        cInfo = pEntry->GetNumOfInfo(); 
  PDS_DOMAIN_CONTROLLER_INFO_1 pDCInfo = pEntry->GetDCInfo();

  ASSERT(cInfo > 0);
  ASSERT(pDCInfo);

  LV_ITEM         item;
  int             index = 0;
  DCLISTVIEWITEM  *pItem = NULL;
  DWORD           dwErr = 0;

  //
  // clear DC list view
  //
  FreeDCItems(m_hDCListView);

  //
  // insert DC list view
  //
  ZeroMemory(&item, sizeof(item));
  item.mask = LVIF_TEXT | LVIF_PARAM;

  for (DWORD i=0; i<cInfo; i++) {

    ASSERT(pDCInfo[i].NetbiosName || pDCInfo[i].DnsHostName);
    
    if (pDCInfo[i].DnsHostName)
      item.pszText = pDCInfo[i].DnsHostName;
    else
      item.pszText = pDCInfo[i].NetbiosName;

    pItem = new DCLISTVIEWITEM;
    if (!pItem)
    {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      break;
    }

    pItem->csName = item.pszText;
    if (pDCInfo[i].SiteName)
      pItem->csSite = pDCInfo[i].SiteName;
    else
      pItem->csSite = _T("");

    item.lParam = reinterpret_cast<LPARAM>(pItem);

    index = ListView_InsertItem(m_hDCListView, &item);
    ListView_SetItemText(m_hDCListView, index, 1, 
      const_cast<LPTSTR>(static_cast<LPCTSTR>(pItem->csSite)));
  }

  if (ERROR_NOT_ENOUGH_MEMORY != dwErr)
  {
    // add "All writable domain controllers" into the list-view .

    item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
    item.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(m_csAnyDC));
    item.state = LVIS_FOCUSED | LVIS_SELECTED;

    pItem = new DCLISTVIEWITEM;
    if (!pItem)
    {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
    } else
    {
      pItem->csName = _T(""); // always sorted as the top item
      pItem->csSite = _T("");

      item.lParam = reinterpret_cast<LPARAM>(pItem);

      index = ListView_InsertItem(m_hDCListView, &item);
      ListView_SetItemText(m_hDCListView, index, 1, 
        const_cast<LPTSTR>(static_cast<LPCTSTR>(pItem->csSite)));
    }
  }

  if (ERROR_NOT_ENOUGH_MEMORY == dwErr)
  {
    FreeDCItems(m_hDCListView);
    return E_OUTOFMEMORY;
  }

  m_hDCListView.EnableWindow(TRUE);

  return S_OK;
}

void CChooseDCDlg::OnGetDCThreadDone(WPARAM wParam, LPARAM lParam)
{
  ASSERT(m_pDCBufferManager);

  CDCSITEINFO* pEntry = reinterpret_cast<CDCSITEINFO*>(wParam);
  HRESULT hr = (HRESULT)lParam;

  ASSERT(pEntry);

  CString csDomain = pEntry->GetDomainName();
  CString csCurrentDomain;

  GetDlgItemText(IDC_SELECTDC_DOMAIN, csCurrentDomain);

  TRACE(_T("CChooseDCDlg::OnGetDCThreadDone targetDomain=%s, currentDomain=%s, hr=%x\n"),
    csDomain, csCurrentDomain, hr);

  if (csCurrentDomain.CompareNoCase(csDomain) == 0)
  {
    switch (pEntry->GetEntryType())
    {
    case BUFFER_ENTRY_TYPE_VALID:
      hr = InsertDCListView(pEntry);
      if (SUCCEEDED(hr))
        break;
      // fall through if error
    case BUFFER_ENTRY_TYPE_ERROR:
      RefreshDCListViewErrorReport(csDomain, hr);
      break;
    default:
      ASSERT(FALSE);
      break;
    }
  }
}

void CChooseDCDlg::RefreshDCListViewErrorReport(
    IN PCTSTR   pszDomainName, 
    IN HRESULT  hr
)
{
  PVOID apv[1];
  apv[0] = static_cast<PVOID>(const_cast<PTSTR>(pszDomainName));
  ReportErrorEx(m_hWnd, IDS_NO_DCS_FOUND, hr,
    MB_OK | MB_ICONINFORMATION, apv, 1, 0);

  InsertSpecialMsg(FALSE); // insert "Error"

  if (m_bSiteRepl)
    (GetDlgItem(IDC_SELECTDC_DOMAIN))->SetFocus();
  else
    (GetDlgItem(IDC_SELECTDC_DCEDIT))->SetFocus();
}

void CChooseDCDlg::RefreshDCListView()
{
  CString csDomain, csFormat, csText;

  GetDlgItemText(IDC_SELECTDC_DOMAIN, csDomain);
  if ( csDomain.IsEmpty() ||
      (0 == csDomain.CompareNoCase(m_csPrevDomain)) )
    return;

  TRACE(_T("CChooseDCDlg::RefreshDCListView for %s\n"), csDomain);

  //
  // update m_csPrevDomain
  // to prevent LoadInfo() from being invoked multiple times when 
  // a serial of WM_KILLFOCUS happening on the same DomainName
  //
  m_csPrevDomain = csDomain;

  //
  // clear dc edit box
  //
  SetDlgItemText(IDC_SELECTDC_DCEDIT, _T(""));

  //
  // update the msg on top of the dc list view 
  //
  csFormat.LoadString(IDS_SELECTDC_DCLISTVIEW_TITLE);
  csText.Format(csFormat, csDomain);
  SetDlgItemText(IDC_SELECTDC_DCLISTVIEW_TITLE, csText);

  if (m_pDCBufferManager)
  {
    //
    // insert "Waiting..." into the list view control
    //
    InsertSpecialMsg(TRUE);

    UpdateWindow();

    CWaitCursor cwait;

    //
    // Make sure csDomain is a valid domain name
    //
    CString csSelectedDomainDns;
    HRESULT hr = GetDnsNameOfDomainOrForest(
            csDomain,
            csSelectedDomainDns,
            TRUE,
            TRUE); // We're interested in domain name not forest name here
    if (FAILED(hr))
    {
      RefreshDCListViewErrorReport(csDomain, hr);
      return;
    }

    if (csSelectedDomainDns.IsEmpty())
    {
      // down-level domain
      PVOID apv[1];
      apv[0] = static_cast<PVOID>(const_cast<LPTSTR>(static_cast<LPCTSTR>(csDomain)));
      ReportMessageEx(m_hWnd, IDS_SELECTDC_DOWNLEVEL_DOMAIN,
        MB_OK | MB_ICONSTOP, apv, 1);

      InsertSpecialMsg(FALSE); // insert "Error"
      (GetDlgItem(IDC_SELECTDC_DOMAIN))->SetFocus();

      return;
    }

    //
    // start the thread to calculate a list of DCs in the current selected domain
    //
    CDCSITEINFO *pEntry = NULL;
    hr = m_pDCBufferManager->LoadInfo(csSelectedDomainDns, &pEntry);

    if (SUCCEEDED(hr))
    {
      //
      // Either we get a valid ptr back (ie. data is ready), insert it;
      // or, a thread is alreay in progress, wait until a THREAD_DONE message.
      //
      if (pEntry)
      {
        ASSERT(pEntry->GetEntryType() == BUFFER_ENTRY_TYPE_VALID);
        hr = InsertDCListView(pEntry);
      }
    }

    if (FAILED(hr))
      RefreshDCListViewErrorReport(csSelectedDomainDns, hr);
  }

  return;
}
//+---------------------------------------------------------------------------
//
//  Function:   CChooseDCDlg::FreeDCItems
//
//  Synopsis:   Clear the lParam associated with each item in the list view control.
//              The lParam is needed to support column-sorting.
//
//----------------------------------------------------------------------------
void
CChooseDCDlg::FreeDCItems(CListCtrl& clv)
{
  int index = -1;
  LPARAM lParam = 0;

  while ( -1 != (index = clv.GetNextItem(index, LVNI_ALL)) )
  {
    lParam = clv.GetItemData(index);

    if (lParam)
      delete ((DCLISTVIEWITEM *)lParam);
  }

  ListView_DeleteAllItems(clv.GetSafeHwnd());
}

void CChooseDCDlg::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_SELECT_DC); 
  }
}


/////////////////////////////////////////////////////////////////////////
// CDsAdminChooseDCObj

STDMETHODIMP CDsAdminChooseDCObj::InvokeDialog(
                              /*IN*/ HWND hwndParent,
                              /*IN*/ LPCWSTR lpszTargetDomain,
                              /*IN*/ LPCWSTR lpszTargetDomainController,
                              /*IN*/ ULONG uFlags,
                              /*OUT*/ BSTR* bstrSelectedDC)
{
  TRACE(L"CDsAdminChooseDCObj::InvokeDialog(\n");
  TRACE(L"                    HWND hwndParent = 0x%x\n", hwndParent);
  TRACE(L"                    LPCWSTR lpszTargetDomain = %s\n", lpszTargetDomain);
  TRACE(L"                    LPCWSTR lpszTargetDomainController = %s\n", lpszTargetDomainController);
  TRACE(L"                    ULONG uFlags = 0x%x\n", uFlags);
  TRACE(L"                    BSTR* bstrSelectedDC = 0x%x)\n", bstrSelectedDC);



  if (!::IsWindow(hwndParent) || (bstrSelectedDC == NULL))
  {
    TRACE(L"InvokeDialog() Failed, invalid arg.\n");
    return E_INVALIDARG;
  }

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  CChooseDCDlg DCdlg(CWnd::FromHandle(hwndParent));

  // load current bind info
  DCdlg.m_bSiteRepl = TRUE;
  DCdlg.m_csTargetDomain = lpszTargetDomain;
  DCdlg.m_csTargetDomainController = lpszTargetDomainController;

  //
  // invoke the dialog
  //
  HRESULT hr = S_FALSE;
  if (DCdlg.DoModal() == IDOK)
  {
    TRACE(L"DCdlg.DoModal() returned IDOK\n");
    TRACE(L"DCdlg.m_csTargetDomainController = <%s>\n", (LPCWSTR)(DCdlg.m_csTargetDomainController));
    TRACE(L"DCdlg.m_csTargetDomain = <%s>\n", (LPCWSTR)(DCdlg.m_csTargetDomain));

    LPCWSTR lpsz = NULL;
    if (DCdlg.m_csTargetDomainController.IsEmpty())
    {
      lpsz = DCdlg.m_csTargetDomain;
    }
    else
    {
      lpsz = DCdlg.m_csTargetDomainController;
    }
    *bstrSelectedDC = ::SysAllocString(lpsz);
    TRACE(L"returning *bstrSelectedDC = <%s>\n", *bstrSelectedDC);
    hr = S_OK;
  }

  TRACE(L"InvokeDialog() returning hr = 0x%x\n", hr);
  return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CRenameUserDlg dialog


CRenameUserDlg::CRenameUserDlg(CDSComponentData* pComponentData, CWnd* pParent /*=NULL*/)
  : m_pComponentData(pComponentData),
    CHelpDialog(CRenameUserDlg::IDD, pParent)
{
  //{{AFX_DATA_INIT(CRenameUserDlg)
  m_login = _T("");
  m_samaccountname = _T("");
  m_domain = _T("");
  m_dldomain = _T("");
  m_first = _T("");
  m_last = _T("");
  m_cn = _T("");
  m_oldcn = _T("");
  m_displayname = _T("");
  //}}AFX_DATA_INIT
}


void CRenameUserDlg::DoDataExchange(CDataExchange* pDX)
{
  CHelpDialog::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CRenameUserDlg)
  DDX_Text(pDX, IDC_EDIT_OBJECT_NAME, m_cn);
  DDX_Text(pDX, IDC_EDIT_DISPLAY_NAME, m_displayname);
  DDX_Text(pDX, IDC_FIRST_NAME_EDIT, m_first);
  DDX_Text(pDX, IDC_LAST_NAME_EDIT, m_last);
  DDX_Text(pDX, IDC_NT5_USER_EDIT, m_login);
  DDX_Text(pDX, IDC_NT4_USER_EDIT, m_samaccountname);
  DDX_Text(pDX, IDC_NT4_DOMAIN_EDIT, m_dldomain);
  DDX_CBString(pDX, IDC_NT5_DOMAIN_COMBO, m_domain);
  //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRenameUserDlg, CHelpDialog)
  //{{AFX_MSG_MAP(CRenameUserDlg)
  ON_EN_CHANGE(IDC_EDIT_OBJECT_NAME, OnObjectNameChange)
  ON_EN_CHANGE(IDC_FIRST_NAME_EDIT, OnNameChange)
  ON_EN_CHANGE(IDC_LAST_NAME_EDIT, OnNameChange)
  ON_EN_CHANGE(IDC_NT5_USER_EDIT, OnUserNameChange)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRenameUserDlg message handlers

BOOL CRenameUserDlg::OnInitDialog() 
{
  CHelpDialog::OnInitDialog();
  CString csdomain;

  m_nameFormatter.Initialize(m_pComponentData->GetBasePathsInfo(), 
                             L"user");

  ((CComboBox*)GetDlgItem (IDC_NT5_DOMAIN_COMBO))->AddString (m_domain);
  ((CComboBox*)GetDlgItem (IDC_NT5_DOMAIN_COMBO))->SetCurSel(0);

  POSITION pos = m_domains.GetHeadPosition();
  while (pos != NULL) {
    csdomain = m_domains.GetNext(INOUT pos);
    ((CComboBox*)GetDlgItem (IDC_NT5_DOMAIN_COMBO))->AddString (csdomain);
  }

  ((CEdit *)GetDlgItem(IDC_EDIT_OBJECT_NAME))->SetLimitText(64);
  ((CEdit *)GetDlgItem(IDC_FIRST_NAME_EDIT))->SetLimitText(64);
  ((CEdit *)GetDlgItem(IDC_LAST_NAME_EDIT))->SetLimitText(64);
  ((CEdit *)GetDlgItem(IDC_EDIT_DISPLAY_NAME))->SetLimitText(259);
  ((CEdit *)GetDlgItem(IDC_NT4_USER_EDIT))->SetLimitText(20);

  CString szObjectName;
  GetDlgItemText(IDC_EDIT_OBJECT_NAME, szObjectName);
  szObjectName.TrimLeft();
  szObjectName.TrimRight();
  if (szObjectName.IsEmpty())
  {
    GetDlgItem(IDOK)->EnableWindow(FALSE);
  }
  return TRUE;  // return TRUE unless you set the focus to a control
  // EXCEPTION: OCX Property Pages should return FALSE
}

void CRenameUserDlg::OnObjectNameChange()
{
  CString szObjectName;
  GetDlgItemText(IDC_EDIT_OBJECT_NAME, szObjectName);
  szObjectName.TrimLeft();
  szObjectName.TrimRight();
  if (szObjectName.IsEmpty())
  {
    GetDlgItem(IDOK)->EnableWindow(FALSE);
  }
  else
  {
    GetDlgItem(IDOK)->EnableWindow(TRUE);
  }
}

void CRenameUserDlg::OnNameChange()
{
  GetDlgItemText(IDC_EDIT_FIRST_NAME, OUT m_first);
  GetDlgItemText(IDC_EDIT_LAST_NAME, OUT m_last);

  m_first.TrimLeft();
  m_first.TrimRight();

  m_last.TrimLeft();
  m_last.TrimRight();

  m_nameFormatter.FormatName(m_cn, 
                             m_first.IsEmpty() ? NULL : (LPCWSTR)m_first, 
                             NULL,
                             m_last.IsEmpty() ? NULL : (LPCWSTR)m_last);

  SetDlgItemText(IDC_EDIT_DISPLAY_NAME, m_cn);
}

void CRenameUserDlg::OnUserNameChange()
{
  GetDlgItemText(IDC_NT5_USER_EDIT, m_login);
  SetDlgItemText(IDC_NT4_USER_EDIT, m_login);
}

void CRenameUserDlg::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_RENAME_USER); 
  }
}

/////////////////////////////////////////////////////////////////////////////
// CRenameGroupDlg message handlers

BOOL CRenameGroupDlg::OnInitDialog() 
{
  CHelpDialog::OnInitDialog();

  ((CEdit *)GetDlgItem(IDC_EDIT_OBJECT_NAME))->SetLimitText(64);
  ((CEdit *)GetDlgItem(IDC_NT4_USER_EDIT))->SetLimitText(m_samtextlimit);

  return TRUE;  // return TRUE unless you set the focus to a control
  // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CRenameGroupDlg dialog


CRenameGroupDlg::CRenameGroupDlg(CWnd* pParent /*=NULL*/)
  : CHelpDialog(CRenameGroupDlg::IDD, pParent)
{
  //{{AFX_DATA_INIT(CRenameGroupDlg)
  m_samaccountname = _T("");
  m_cn = _T("");
  m_samtextlimit = 256;
  //}}AFX_DATA_INIT
}


void CRenameGroupDlg::DoDataExchange(CDataExchange* pDX)
{
  CHelpDialog::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CRenameGroupDlg)
  DDX_Text(pDX, IDC_NT4_USER_EDIT, m_samaccountname);
  DDX_Text(pDX, IDC_EDIT_OBJECT_NAME, m_cn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRenameGroupDlg, CHelpDialog)
  //{{AFX_MSG_MAP(CRenameGroupDlg)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CRenameGroupDlg::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)
  {
     ::WinHelp(hWndControl,
               DSADMIN_CONTEXT_HELP_FILE,
               HELP_WM_HELP,
               (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_RENAME_GROUP); 
  }
}

/////////////////////////////////////////////////////////////////////////////
// CRenameContactDlg message handlers

BOOL CRenameContactDlg::OnInitDialog() 
{
  CHelpDialog::OnInitDialog();

  return TRUE;  // return TRUE unless you set the focus to a control
  // EXCEPTION: OCX Property Pages should return FALSE
}


void CRenameContactDlg::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_RENAME_CONTACT); 
  }
}

/////////////////////////////////////////////////////////////////////////////
// CRenameContactDlg dialog


CRenameContactDlg::CRenameContactDlg(CWnd* pParent /*=NULL*/)
  : CHelpDialog(CRenameContactDlg::IDD, pParent)
{
  //{{AFX_DATA_INIT(CRenameContactDlg)
  m_cn = _T("");
  m_first = _T("");
  m_last = _T("");
  m_disp = _T("");
  //}}AFX_DATA_INIT
}


void CRenameContactDlg::DoDataExchange(CDataExchange* pDX)
{
  CHelpDialog::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CRenameContactDlg)
  DDX_Text(pDX, IDC_EDIT_OBJECT_NAME, m_cn);
  DDX_Text(pDX, IDC_FIRST_NAME_EDIT, m_first);
  DDX_Text(pDX, IDC_LAST_NAME_EDIT, m_last);
  DDX_Text(pDX, IDC_DISP_NAME_EDIT, m_disp);
  //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRenameContactDlg, CHelpDialog)
  //{{AFX_MSG_MAP(CRenameContactDlg)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CRenameGenericDlg message handlers

BOOL CRenameGenericDlg::OnInitDialog() 
{
  CHelpDialog::OnInitDialog();

  ((CEdit *)GetDlgItem(IDC_EDIT_OBJECT_NAME))->SetLimitText(64);

  return TRUE;  // return TRUE unless you set the focus to a control
  // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CRenameGenericDlg dialog


CRenameGenericDlg::CRenameGenericDlg(CWnd* pParent /*=NULL*/)
  : CHelpDialog(CRenameGenericDlg::IDD, pParent)
{
  //{{AFX_DATA_INIT(CRenameGenericDlg)
  m_cn = _T("");
  //}}AFX_DATA_INIT
}


void CRenameGenericDlg::DoDataExchange(CDataExchange* pDX)
{
  CHelpDialog::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CRenameGenericDlg)
  DDX_Text(pDX, IDC_EDIT_OBJECT_NAME, m_cn);
  //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRenameGenericDlg, CHelpDialog)
  //{{AFX_MSG_MAP(CRenameGenericDlg)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()



void CRenameGenericDlg::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_RENAME_COMPUTER); 
  }
}

/////////////////////////////////////////////////////////////////////////////
// CSpecialMessageBox dialog


CSpecialMessageBox::CSpecialMessageBox(CWnd* pParent /*=NULL*/)
  : CDialog(CSpecialMessageBox::IDD, pParent)
{
  //{{AFX_DATA_INIT(CSpecialMessageBox)
  m_title = _T("");
  m_message = _T("");
  //}}AFX_DATA_INIT
}


void CSpecialMessageBox::DoDataExchange(CDataExchange* pDX)
{
  CDialog::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CSpecialMessageBox)
  DDX_Text(pDX, IDC_STATIC_MESSAGE, m_message);
  //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSpecialMessageBox, CDialog)
  //{{AFX_MSG_MAP(CSpecialMessageBox)
  ON_BN_CLICKED(IDC_BUTTON_YES, OnYesButton)
  ON_BN_CLICKED(IDC_BUTTON_NO, OnNoButton)
  ON_BN_CLICKED(IDC_BUTTON_YESTOALL, OnYesToAllButton)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSpecialMessageBox message handlers

BOOL CSpecialMessageBox::OnInitDialog() 
{
  CDialog::OnInitDialog();
  if (!m_title.IsEmpty()) {
    SetWindowText (m_title);
  }

  GetDlgItem(IDC_BUTTON_NO)->SetFocus();
  return FALSE;  // return TRUE unless you set the focus to a control
  // EXCEPTION: OCX Property Pages should return FALSE
}

void
CSpecialMessageBox::OnYesButton()
{
  CDialog::EndDialog (IDYES);
}

void
CSpecialMessageBox::OnNoButton()
{
  CDialog::EndDialog (IDNO);
}

void
CSpecialMessageBox::OnYesToAllButton()
{
  CDialog::EndDialog (IDC_BUTTON_YESTOALL);
}

#ifdef FIXUPDC

/////////////////////////////////////////////////////////////////////////////
// CFixupDC dialog


CFixupDC::CFixupDC(CWnd* pParent /*=NULL*/)
  : CHelpDialog(CFixupDC::IDD, pParent)
{
  //{{AFX_DATA_INIT(CFixupDC)
  m_strServer = _T("");
  //}}AFX_DATA_INIT
  
  for (int i=0; i<NUM_FIXUP_OPTIONS; i++) {
    m_bCheck[i] = FALSE;
  }
}

void CFixupDC::DoDataExchange(CDataExchange* pDX)
{
  CHelpDialog::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CFixupDC)
  DDX_Text(pDX, IDC_FIXUP_DC_SERVER, m_strServer);
  //}}AFX_DATA_MAP
  DDX_Check(pDX, IDC_FIXUP_DC_CHECK0, m_bCheck[0]);
  DDX_Check(pDX, IDC_FIXUP_DC_CHECK1, m_bCheck[1]);
  DDX_Check(pDX, IDC_FIXUP_DC_CHECK2, m_bCheck[2]);
  DDX_Check(pDX, IDC_FIXUP_DC_CHECK3, m_bCheck[3]);
  DDX_Check(pDX, IDC_FIXUP_DC_CHECK4, m_bCheck[4]);
  DDX_Check(pDX, IDC_FIXUP_DC_CHECK5, m_bCheck[5]);
}


BEGIN_MESSAGE_MAP(CFixupDC, CHelpDialog)
  //{{AFX_MSG_MAP(CFixupDC)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFixupDC message handlers

extern FixupOptionsMsg g_FixupOptionsMsg[];

BOOL CFixupDC::OnInitDialog() 
{
  CHelpDialog::OnInitDialog();
  
  HWND hCheck = NULL;
  GetDlgItem(IDC_FIXUP_DC_CHECK0, &hCheck);
  ::SetFocus(hCheck);

  for (int i=0; i<NUM_FIXUP_OPTIONS; i++)
    m_bCheck[i] = g_FixupOptionsMsg[i].bDefaultOn;

  UpdateData(FALSE);

  return FALSE;  // return TRUE unless you set the focus to a control
                // EXCEPTION: OCX Property Pages should return FALSE
}

void CFixupDC::OnOK() 
{
  UpdateData(TRUE);

  // make sure user has selected some checkboxes
  BOOL bCheck = FALSE;
  for (int i=0; !bCheck && (i<NUM_FIXUP_OPTIONS); i++) {
    bCheck = bCheck || m_bCheck[i];
  }
  if (!bCheck)
  {
    ReportMessageEx(m_hWnd, IDS_FIXUP_DC_SELECTION_WARNING, MB_OK);
    return;
  }
  
  CHelpDialog::OnOK();
}

void CFixupDC::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_FIXUP_DC); 
  }
}
#endif // FIXUPDC

/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog


CPasswordDlg::CPasswordDlg(CWnd* pParent /*=NULL*/)
  : CHelpDialog(CPasswordDlg::IDD, pParent)
{
  //{{AFX_DATA_INIT(CPasswordDlg)
  m_strPassword = _T("");
  m_strUserName = _T("");
  //}}AFX_DATA_INIT
}


void CPasswordDlg::DoDataExchange(CDataExchange* pDX)
{
  CHelpDialog::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CPasswordDlg)
  DDX_Text(pDX, IDC_PASSWORD, m_strPassword);
  DDX_Text(pDX, IDC_USER_NAME, m_strUserName);
  //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPasswordDlg, CHelpDialog)
  //{{AFX_MSG_MAP(CPasswordDlg)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg message handlers

void CPasswordDlg::OnOK() 
{
  UpdateData(TRUE);
  if (m_strUserName.IsEmpty()) {
    ReportMessageEx(m_hWnd, IDS_PASSWORD_DLG_WARNING, MB_OK);
    return;
  }

  CHelpDialog::OnOK();
}

void CPasswordDlg::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_PASSWORD); 
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\fsmoui.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       fsmoui.h
//
//--------------------------------------------------------------------------


#ifndef __FSMOUI_H__
#define __FSMOUI_H__

//////////////////////////////////////////////////////////////////
// CFsmoPropertyPage

class CFsmoPropertySheet; // fwd decl

class CFsmoPropertyPage : public CPropertyPage
{
public:
  CFsmoPropertyPage(CFsmoPropertySheet* pSheet, FSMO_TYPE fsmoType);

private:
	virtual BOOL OnInitDialog();

  afx_msg void OnChange();

  afx_msg void OnHelpInfo(HELPINFO* lpHelpInfo );

  void _SetFsmoServerStatus(BOOL bOnLine);
  BOOL AllowForcedTransfer(HRESULT hr);

  CFsmoPropertySheet* m_pSheet;
  FSMO_TYPE m_fsmoType;
  CString m_szFsmoOwnerServerName;  
  CToggleTextControlHelper m_fsmoServerState;

  DECLARE_MESSAGE_MAP()
};


//////////////////////////////////////////////////////////////////
// CFsmoPropertySheet

class CFsmoPropertySheet : public CPropertySheet
{
public:
  CFsmoPropertySheet(MyBasePathsInfo* pInfo, HWND HWndParent, 
                     IDisplayHelp* pIDisplayHelp,
                      LPCWSTR lpszDomain);

  
  MyBasePathsInfo* GetBasePathsInfo() { ASSERT(m_pInfo != NULL); return m_pInfo;}
  IDisplayHelp* GetIDisplayHelp() { ASSERT(m_spIDisplayHelp != NULL); return m_spIDisplayHelp;}


private:
  CFsmoPropertyPage m_page1;
  CFsmoPropertyPage m_page2;
  CFsmoPropertyPage m_page3;

  MyBasePathsInfo* m_pInfo;
  CComPtr<IDisplayHelp> m_spIDisplayHelp;

  static int CALLBACK PropSheetCallBack(HWND hwndDlg, UINT uMsg, LPARAM lParam);
};


#endif // __FSMOUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      dsUtil.cpp
//
//  Contents:  Utility functions
//
//  History:   08-Nov-99 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "dsutil.h"

#include "dssnap.h"
#include "gsz.h"
#include "helpids.h"
#include "querysup.h"

#include "wininet.h"
#include <dnsapi.h>
#include <objsel.h>
#include <ntldap.h>   // LDAP_MATCHING_RULE_BIT_AND_W
#include <lmaccess.h> // UF_SERVER_TRUST_ACCOUNT
#include <ntdsapi.h>  // DsRemoveDsServer
#include <ntsecapi.h> // Lsa*

UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

//
// Common DS strings
//
PCWSTR g_pszAllowedAttributesEffective  = L"allowedAttributesEffective";
PCWSTR g_pszPwdLastSet                  = L"pwdLastSet";


//
// This is a wrapper for ADsOpenObject.  It gives DSAdmin a single point to change
// global flags that are passed to ADsOpenObject without have to search and replace
// all occurrences in the code
// 
HRESULT DSAdminOpenObject(PCWSTR pszPath, 
                          REFIID refIID, 
                          PVOID* ppObject, 
                          BOOL bServer)
{
  HRESULT hr = S_OK;
  DWORD dwFlags = ADS_SECURE_AUTHENTICATION;

  if (bServer)
  {
    //
    // If we know we are connecting to a specific server and not domain in general
    // then pass the ADS_SERVER_BIND flag to save ADSI the trouble of figuring it out
    //
    dwFlags |= ADS_SERVER_BIND;
  }

  hr = ADsOpenObject((LPWSTR)pszPath, NULL, NULL, dwFlags, refIID, ppObject);

  return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetServerFromLDAPPath
//
//  Synopsis:   Gets the server portion of an LDAP Path
//
//	In:
//		LPCWSTR  - pointer to string to convert
//    
//	Out:
//		BSTR* - pointer to a BSTR containing the server name
//
//  Return:
//    HRESULT     - whether the operation completed successfully
//
//--------------------------------------------------------------------------

HRESULT GetServerFromLDAPPath(IN LPCWSTR lpszLdapPath, OUT BSTR* pbstrServerName)
{
  if (pbstrServerName == NULL)
  {
    return E_POINTER;
  }
  else if (*pbstrServerName != NULL)
  {
    ::SysFreeString(*pbstrServerName);
    *pbstrServerName = NULL;
  }

  CPathCracker pathCracker;
  HRESULT hr = pathCracker.Set((LPWSTR)lpszLdapPath, ADS_SETTYPE_FULL);
  RETURN_IF_FAILED(hr);

  return pathCracker.Retrieve(ADS_FORMAT_SERVER, pbstrServerName);
}



BOOL StripADsIPath(LPCWSTR lpszPath, CString& strref, bool bUseEscapedMode /* = true */)
{
  if (lpszPath == NULL) 
  {
    strref = L"";
    return FALSE;
  }

  if (wcslen(lpszPath) == 0) 
  {
    strref = lpszPath;
    return FALSE;
  }

  CPathCracker pathCracker;

  if ( bUseEscapedMode )
    pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_ON);

  pathCracker.SetDisplayType(ADS_DISPLAY_FULL);

  HRESULT hr = pathCracker.Set((PWSTR)lpszPath, ADS_SETTYPE_FULL);

  if (FAILED(hr))
  {
    TRACE(_T("StripADsIPath, IADsPathname::Set returned error 0x%x\n"), hr);
    strref = lpszPath;
    return FALSE;
  }

  CComBSTR bsX500DN;

  (void) pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bsX500DN);
  strref = bsX500DN;
  return TRUE;
}

////////////////////////////////////////////////////////////////////////
// support routines for Add To Group function

void RemovePortifPresent(CString *csGroup)
{
  CString x, y;
  int n = csGroup->Find (L":3268");
  if (n > 0) {
    x = csGroup->Left(n);
    y = csGroup->Right(csGroup->GetLength() - (n+5));
    *csGroup = x+y;
  }
}


#if (FALSE)                   
HRESULT AddDataObjListToGroup(IN CObjectNamesFormatCracker* pNames,
                              IN HWND hwnd)
{
  HRESULT hr = S_OK;
  TRACE (_T("CDSContextMenu::AddToGroup\n"));

  STGMEDIUM stgmedium =
  {
    TYMED_HGLOBAL,
    NULL,
    NULL
  };
  
  FORMATETC formatetc =
  {
    (CLIPFORMAT)g_cfDsObjectPicker,
    NULL,
    DVASPECT_CONTENT,
    -1,
    TYMED_HGLOBAL
  };
  
  // algorithm
  // examine selection, figure out classes
  // figure out what groups are possible
  // call object picker, get a group
  // for each object in selection
  //  if container
  //    procees_container()
  //  else
  //    process_leaf()
  //


  //
  // Create an instance of the object picker.
  //
  
  IDsObjectPicker * pDsObjectPicker = NULL;

  hr = CoCreateInstance(CLSID_DsObjectPicker,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IDsObjectPicker,
                        (void **) &pDsObjectPicker);
  if (FAILED(hr))
    return(hr);
  //
  // Prepare to initialize the object picker.
  //
  // first, get the name of DC that we are talking to.
  CComBSTR bstrDC;
  LPCWSTR lpszPath = pNames->GetName(0);
  GetServerFromLDAPPath(lpszPath, &bstrDC);

  //
  // Set up the array of scope initializer structures.
  //
  
  static const int     SCOPE_INIT_COUNT = 1;
  DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];
  int scopeindex = 0;
  ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);
  
  //
  //
  // The domain to which the target computer is joined.  Note we're
  // combining two scope types into flType here for convenience.
    //

  aScopeInit[scopeindex].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
  aScopeInit[scopeindex].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
  aScopeInit[scopeindex].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE |
                                   DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS | 
                                   DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;
  aScopeInit[scopeindex].FilterFlags.Uplevel.flNativeModeOnly =
    DSOP_FILTER_GLOBAL_GROUPS_SE
    | DSOP_FILTER_UNIVERSAL_GROUPS_SE
    | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
    | DSOP_FILTER_GLOBAL_GROUPS_DL
    | DSOP_FILTER_UNIVERSAL_GROUPS_DL
    | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL
    | DSOP_FILTER_BUILTIN_GROUPS;
  aScopeInit[scopeindex].FilterFlags.Uplevel.flMixedModeOnly =
    DSOP_FILTER_GLOBAL_GROUPS_SE
    | DSOP_FILTER_UNIVERSAL_GROUPS_SE
    | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
    | DSOP_FILTER_GLOBAL_GROUPS_DL
    | DSOP_FILTER_UNIVERSAL_GROUPS_DL
    | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL
    | DSOP_FILTER_BUILTIN_GROUPS;
  aScopeInit[scopeindex].pwzDcName = bstrDC;

  //
  // Put the scope init array into the object picker init array
  //
  
  DSOP_INIT_INFO  InitInfo;
  ZeroMemory(&InitInfo, sizeof(InitInfo));

  InitInfo.cbSize = sizeof(InitInfo);

  //
  // The pwzTargetComputer member allows the object picker to be
  // retargetted to a different computer.  It will behave as if it
  // were being run ON THAT COMPUTER.
  //

  InitInfo.pwzTargetComputer = bstrDC;
  InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
  InitInfo.aDsScopeInfos = aScopeInit;
  InitInfo.flOptions = 0;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

  hr = pDsObjectPicker->Initialize(&InitInfo);

  if (FAILED(hr)) 
  {
    ULONG i;
    
    for (i = 0; i < SCOPE_INIT_COUNT; i++) 
    {
      if (FAILED(InitInfo.aDsScopeInfos[i].hr)) 
      {
        TRACE(_T("Initialization failed because of scope %u\n"), i);
      }
    }

    ReportErrorEx (hwnd, IDS_OBJECT_PICKER_INIT_FAILED, hr,
                   MB_OK | MB_ICONERROR, NULL, 0);
    return hr;
  }

  IDataObject *pdo = NULL;
  //
  // Invoke the modal dialog.
  //
  
  hr = pDsObjectPicker->InvokeDialog(hwnd, &pdo);
  if (FAILED(hr))
    return(hr);

  
  //
  // If the user hit Cancel, hr == S_FALSE
  //
  if (hr == S_FALSE)
    return hr;

  bool fGotStgMedium = false;
  
  hr = pdo->GetData(&formatetc, &stgmedium);
  if (FAILED(hr))
    return hr;
    
  fGotStgMedium = true;
  
  PDS_SELECTION_LIST pSelList =
    (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
  
  if (!pSelList) 
  {
    TRACE(_T("GlobalLock error %u\n"), GetLastError());
    //
    // REVIEW_JEFFJON : should probably put some kind of error message
    //                  here even though we ignore the return value
    //
    return E_FAIL;
  }
  
  if (pDsObjectPicker) 
  {
    pDsObjectPicker->Release();
  }

  /////////////////////////////////////////////////////////////
  
  UINT index;
  DWORD cModified = 0;
  CString csClass;
  CString objDN;
  IDirectoryObject * pObj = NULL;
  INT answer = IDYES;
  BOOL error = FALSE;
  BOOL partial_success = FALSE;
  CWaitCursor CWait;
  CString csPath;

  if (pSelList != NULL) 
  {
    TRACE(_T("AddToGroup: binding to group path is %s\n"), pSelList->aDsSelection[0].pwzADsPath);
    CString csGroup = pSelList->aDsSelection[0].pwzADsPath;
    RemovePortifPresent(&csGroup);
    hr = DSAdminOpenObject(csGroup,
                           IID_IDirectoryObject, 
                           (void **)&pObj,
                           FALSE /*bServer*/);
    if (FAILED(hr)) 
    {
      PVOID apv[1] = {(BSTR)(LPWSTR)(LPCWSTR)pSelList->aDsSelection[0].pwzName};
      ReportErrorEx (hwnd,IDS_12_USER_OBJECT_NOT_ACCESSABLE,hr,
                     MB_OK | MB_ICONERROR, apv, 1);
      goto ExitGracefully;
    }
    
    for (index = 0; index < pNames->GetCount(); index++) 
    {
      csPath = pNames->GetName(index);
      TRACE(_T("AddToGroup: object path is %s\n"), csPath);
      csClass = pNames->GetClass(index);
      TRACE(_T("AddToGroup: object class is %s\n"), csClass);

      ADS_ATTR_INFO Attrinfo;
      ZeroMemory (&Attrinfo, sizeof (ADS_ATTR_INFO));
      PADS_ATTR_INFO pAttrs = &Attrinfo;
      
      Attrinfo.pszAttrName = L"member";
      Attrinfo.dwADsType = ADSTYPE_DN_STRING;
      Attrinfo.dwControlCode = ADS_ATTR_APPEND;
      ADSVALUE Value;
      
      pAttrs->pADsValues = &Value;
      pAttrs->dwNumValues = 1;
      
      // make sure there's no strange escaping in the path
      CComBSTR bstrPath;

      CPathCracker pathCracker;
      pathCracker.Set((LPTSTR)(LPCTSTR)csPath, ADS_SETTYPE_FULL);
      pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
      pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF);
      pathCracker.Retrieve( ADS_FORMAT_X500, &bstrPath);
      pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_ON);
      
      StripADsIPath(bstrPath, objDN);
      
      Value.DNString = (LPWSTR)(LPCWSTR)objDN;
      Value.dwType = ADSTYPE_DN_STRING;
      
      hr = pObj->SetObjectAttributes(pAttrs, 1, &cModified);
      if (FAILED(hr)) 
      {
        error = TRUE;
        // prep for display by getting obj name
        pathCracker.Set((LPWSTR)pNames->GetName(index), ADS_SETTYPE_FULL);
        pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
        CComBSTR ObjName;
        pathCracker.GetElement( 0, &ObjName );
        PVOID apv[2] = {(BSTR)(LPWSTR)(LPCWSTR)ObjName,
                        (BSTR)(LPWSTR)(LPCWSTR)pSelList->aDsSelection[0].pwzName};
        if ((pNames->GetCount() - index) == 1) 
        {
          ReportErrorEx (hwnd,IDS_12_MEMBER_ADD_FAILED,hr,
                         MB_OK | MB_ICONERROR, apv, 2);
        } 
        else 
        {
          int answer1;
          answer1 = ReportErrorEx (hwnd,IDS_12_MULTI_MEMBER_ADD_FAILED,hr,
                                  MB_YESNO | MB_ICONERROR, apv, 2);
          if (answer1 == IDNO) 
          {
            answer = IDCANCEL;
          }
        }
      } 
      else 
      {
        partial_success = TRUE;
      }

      if (answer == IDCANCEL) 
      {
        goto ExitGracefully;
      }
    }

ExitGracefully:
    if( error )
    {
      if (partial_success == TRUE) 
      {
        ReportErrorEx (hwnd, IDS_ADDTOGROUP_OPERATION_PARTIALLY_COMPLETED, S_OK,
                       MB_OK | MB_ICONINFORMATION, NULL, 0);
      } 
      else 
      {
        ReportErrorEx (hwnd, IDS_ADDTOGROUP_OPERATION_FAILED, S_OK,
                       MB_OK | MB_ICONINFORMATION, NULL, 0);
      }
    }
    else if( partial_success == TRUE )
    {
      ReportErrorEx (hwnd, IDS_ADDTOGROUP_OPERATION_COMPLETED, S_OK,
                     MB_OK | MB_ICONINFORMATION, NULL, 0);
    }
    else
    {
    //else we did nothing and appropriate messages are shown already
      ReportErrorEx (hwnd, IDS_ADDTOGROUP_OPERATION_FAILED, S_OK,
                       MB_OK | MB_ICONINFORMATION, NULL, 0);
    }

    if (pObj) 
    {
      pObj->Release();
    }
  }
  return hr;
}
#endif


HRESULT AddDataObjListToGroup(IN CObjectNamesFormatCracker* pNames,
                              IN HWND hwnd,
                              IN CDSComponentData* pComponentData)
{
  HRESULT hr = S_OK;
  TRACE (_T("CDSContextMenu::AddToGroup\n"));

  STGMEDIUM stgmedium =
  {
    TYMED_HGLOBAL,
    NULL,
    NULL
  };
  
  FORMATETC formatetc =
  {
    (CLIPFORMAT)g_cfDsObjectPicker,
    NULL,
    DVASPECT_CONTENT,
    -1,
    TYMED_HGLOBAL
  };
  
  // algorithm
  // examine selection, figure out classes
  // figure out what groups are possible
  // call object picker, get a group
  // for each object in selection
  //  if container
  //    procees_container()
  //  else
  //    process_leaf()
  //


  //
  // Create an instance of the object picker.
  //
  
  IDsObjectPicker * pDsObjectPicker = NULL;

  hr = CoCreateInstance(CLSID_DsObjectPicker,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IDsObjectPicker,
                        (void **) &pDsObjectPicker);
  if (FAILED(hr))
    return(hr);
  //
  // Prepare to initialize the object picker.
  //
  // first, get the name of DC that we are talking to.
  CComBSTR bstrDC;
  LPCWSTR lpszPath = pNames->GetName(0);
  GetServerFromLDAPPath(lpszPath, &bstrDC);

  //
  // Set up the array of scope initializer structures.
  //
  
  static const int     SCOPE_INIT_COUNT = 1;
  DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];
  int scopeindex = 0;
  ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);
  
  //
  //
  // The domain to which the target computer is joined.  Note we're
  // combining two scope types into flType here for convenience.
    //

  aScopeInit[scopeindex].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
  aScopeInit[scopeindex].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
  aScopeInit[scopeindex].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE | 
                                   DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS | 
                                   DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;
  aScopeInit[scopeindex].FilterFlags.Uplevel.flNativeModeOnly =
    DSOP_FILTER_GLOBAL_GROUPS_SE
    | DSOP_FILTER_UNIVERSAL_GROUPS_SE
    | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
    | DSOP_FILTER_GLOBAL_GROUPS_DL
    | DSOP_FILTER_UNIVERSAL_GROUPS_DL
    | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL
    | DSOP_FILTER_BUILTIN_GROUPS;
  aScopeInit[scopeindex].FilterFlags.Uplevel.flMixedModeOnly =
    DSOP_FILTER_GLOBAL_GROUPS_SE
    | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
    | DSOP_FILTER_GLOBAL_GROUPS_DL
    | DSOP_FILTER_UNIVERSAL_GROUPS_DL
    | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL
    | DSOP_FILTER_BUILTIN_GROUPS;
  aScopeInit[scopeindex].pwzDcName = bstrDC;

  //
  // Put the scope init array into the object picker init array
  //
  
  DSOP_INIT_INFO  InitInfo;
  ZeroMemory(&InitInfo, sizeof(InitInfo));

  InitInfo.cbSize = sizeof(InitInfo);

  //
  // The pwzTargetComputer member allows the object picker to be
  // retargetted to a different computer.  It will behave as if it
  // were being run ON THAT COMPUTER.
  //

  InitInfo.pwzTargetComputer = bstrDC;
  InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
  InitInfo.aDsScopeInfos = aScopeInit;
  InitInfo.flOptions = 0;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

  hr = pDsObjectPicker->Initialize(&InitInfo);

  if (FAILED(hr)) {
    ULONG i;
    
    for (i = 0; i < SCOPE_INIT_COUNT; i++) {
      if (FAILED(InitInfo.aDsScopeInfos[i].hr)) {
        TRACE(_T("Initialization failed because of scope %u\n"), i);
      }
    }

    ReportErrorEx (hwnd, IDS_OBJECT_PICKER_INIT_FAILED, hr,
                   MB_OK | MB_ICONERROR, NULL, 0);
    return hr;
  }

  IDataObject *pdo = NULL;
  //
  // Invoke the modal dialog.
  //
  
  hr = pDsObjectPicker->InvokeDialog(hwnd, &pdo);
  if (FAILED(hr))
    return(hr);

  
  //
  // If the user hit Cancel, hr == S_FALSE
  //
  if (hr == S_FALSE)
    return hr;

  bool fGotStgMedium = false;
  
  hr = pdo->GetData(&formatetc, &stgmedium);
  if (FAILED(hr))
    return hr;
    
  fGotStgMedium = true;
  
  PDS_SELECTION_LIST pSelList =
    (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
  
  if (!pSelList) 
  {
    TRACE(_T("GlobalLock error %u\n"), GetLastError());
    //
    // REVIEW_JEFFJON : should probably put some kind of error message
    //                  here even though we ignore the return value
    //
    return E_FAIL;
  }
  
  if (pDsObjectPicker) {
    pDsObjectPicker->Release();
  }

  hr = AddDataObjListToGivenGroup(pNames,
                                  pSelList->aDsSelection[0].pwzADsPath,
                                  pSelList->aDsSelection[0].pwzName,
                                  hwnd,
                                  pComponentData);

  ::GlobalFree(stgmedium.hGlobal);
  return hr;
}



HRESULT AddDataObjListToGivenGroup(CObjectNamesFormatCracker * pNames,
                                    LPCWSTR lpszGroupLDapPath,
                                    LPCWSTR lpszGroupName,
                                    HWND hwnd,
                                    CDSComponentData* pComponentData)
{
  HRESULT hr = S_OK;
  
  UINT index = 0;
  DWORD cModified = 0;
  CString csClass;
  CString objDN;
  IDirectoryObject * pObj = NULL;
  BOOL error = FALSE;
  BOOL partial_success = FALSE;
  CWaitCursor CWait;
  CString csPath;

  //
  // Prepare error structures for use with the multi-operation error dialog
  // These arrays may not be completely full depending on the number of errors
  // that occurr
  //
  HRESULT* phrArray = new HRESULT[pNames->GetCount()];
  if (!phrArray)
  {
    return E_OUTOFMEMORY;
  }
  memset(phrArray, 0, pNames->GetCount() * sizeof(HRESULT));

  PWSTR* pPathArray = new PWSTR[pNames->GetCount()];
  if (!pPathArray)
  {
    return E_OUTOFMEMORY;
  }
  memset(pPathArray, 0, pNames->GetCount() * sizeof(PWSTR));

  PWSTR* pClassArray = new PWSTR[pNames->GetCount()];
  if (!pClassArray)
  {
    return E_OUTOFMEMORY;
  }
  memset(pClassArray, 0, pNames->GetCount() * sizeof(PWSTR));

  UINT nErrorCount = 0;

  TRACE(_T("AddToGroup: binding to group path is %s\n"), lpszGroupLDapPath);
  CString csGroup = lpszGroupLDapPath;
  RemovePortifPresent(&csGroup);

  hr = DSAdminOpenObject(csGroup,
                         IID_IDirectoryObject, 
                         (void **)&pObj,
                         FALSE /*bServer*/);
  if (FAILED(hr)) 
  {
    PVOID apv[1] = {(BSTR)(LPWSTR)lpszGroupName};
    ReportErrorEx (hwnd,IDS_12_USER_OBJECT_NOT_ACCESSABLE,hr,
                   MB_OK | MB_ICONERROR, apv, 1);
    goto ExitGracefully;
  }
  
  for (index = 0; index < pNames->GetCount(); index++) 
  {
    // make sure there's no strange escaping in the path
    CComBSTR bstrDN;

    csPath = pNames->GetName(index);
    TRACE(_T("AddToGroup: object path is %s\n"), csPath);
    csClass = pNames->GetClass(index);
    TRACE(_T("AddToGroup: object class is %s\n"), csClass);

    ADS_ATTR_INFO Attrinfo;
    ZeroMemory (&Attrinfo, sizeof (ADS_ATTR_INFO));
    PADS_ATTR_INFO pAttrs = &Attrinfo;
    
    Attrinfo.pszAttrName = L"member";
    Attrinfo.dwADsType = ADSTYPE_DN_STRING;
    Attrinfo.dwControlCode = ADS_ATTR_APPEND;
    ADSVALUE Value;
    
    pAttrs->pADsValues = &Value;
    pAttrs->dwNumValues = 1;
    
    CPathCracker pathCracker;
    pathCracker.Set((LPTSTR)(LPCTSTR)csPath, ADS_SETTYPE_FULL);
    pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
    pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF);
    pathCracker.Retrieve( ADS_FORMAT_X500_DN, &bstrDN);
    pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_ON);
    
    objDN = bstrDN;
    
    Value.DNString = (LPWSTR)(LPCWSTR)objDN;
    Value.dwType = ADSTYPE_DN_STRING;
    
    hr = pObj->SetObjectAttributes(pAttrs, 1, &cModified);
    if (FAILED(hr)) 
    {
      error = TRUE;

      if (pNames->GetCount() > 1)
      {
        if (phrArray != NULL &&
            pPathArray != NULL &&
            pClassArray != NULL)
        {
          phrArray[nErrorCount] = hr;
          pPathArray[nErrorCount] = new WCHAR[wcslen(objDN) + 1];
          if (pPathArray[nErrorCount] != NULL)
          {
            wcscpy(pPathArray[nErrorCount], objDN);
          }

          pClassArray[nErrorCount] = new WCHAR[wcslen(csClass) + 1];
          if (pClassArray[nErrorCount] != NULL)
          {
            wcscpy(pClassArray[nErrorCount], csClass);
          }
          nErrorCount++;
        }
      } 
      else 
      {
        //
        // prep for display by getting obj name
        //
        CPathCracker pathCrackerToo;
        pathCrackerToo.Set((LPWSTR)pNames->GetName(index), ADS_SETTYPE_FULL);
        pathCrackerToo.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
        CComBSTR ObjName;
        pathCrackerToo.GetElement( 0, &ObjName );
        PVOID apv[2] = {(BSTR)(LPWSTR)(LPCWSTR)ObjName,
                        (BSTR)(LPWSTR)lpszGroupName};
        ReportErrorEx (hwnd,IDS_12_MEMBER_ADD_FAILED,hr,
                       MB_OK | MB_ICONERROR, apv, 2);
      }
    } 
    else 
    {
      partial_success = TRUE;
    }
  } // for

ExitGracefully:
  if (nErrorCount > 0 && pNames->GetCount() > 1)
  {
    //
    // Load the strings for the error dialog
    //
    CString szTitle;
    if (pComponentData->QuerySnapinType() == SNAPINTYPE_SITE)
    {
      VERIFY(szTitle.LoadString(IDS_SITESNAPINNAME));
    }
    else
    {
      VERIFY(szTitle.LoadString(IDS_DSSNAPINNAME));
    }

    CString szCaption;
    VERIFY(szCaption.LoadString(IDS_MULTI_ADDTOGROUP_ERROR_CAPTION));

    CString szHeader;
    VERIFY(szHeader.LoadString(IDS_COLUMN_NAME));

    CMultiselectErrorDialog errDialog(pComponentData);

    VERIFY(SUCCEEDED(errDialog.Initialize(pPathArray,
                                          pClassArray,
                                          phrArray,
                                          nErrorCount,
                                          szTitle,
                                          szCaption,
                                          szHeader)));

    errDialog.DoModal();
  }
  else if (nErrorCount == 0 && !error)
  {
    ReportErrorEx (hwnd, IDS_ADDTOGROUP_OPERATION_COMPLETED, S_OK,
                   MB_OK | MB_ICONINFORMATION, NULL, 0);
  }
  else
  {
    //
    // Do nothing if it was single select and there was a failure
    // The error should have already been reported.
    //
  }

  if (pObj) 
  {
    pObj->Release();
  }

  if (phrArray != NULL)
  {
    delete[] phrArray;
    phrArray = NULL;
  }

  if (pPathArray != NULL)
  {
    for (UINT nIdx = 0; nIdx < pNames->GetCount(); nIdx++)
    {
      if (pPathArray[nIdx] != NULL)
      {
        delete[] pPathArray[nIdx];
      }
    }
    delete[] pPathArray;
    pPathArray = NULL;
  }

  if (pClassArray != NULL)
  {
    for (UINT nIdx = 0; nIdx < pNames->GetCount(); nIdx++)
    {
      if (pClassArray[nIdx] != NULL)
      {
        delete[] pClassArray[nIdx];
      }
    }
    delete[] pClassArray;
    pClassArray = NULL;
  }

  return hr;
}





BOOL IsValidSiteName( LPCTSTR lpctszSiteName, BOOL* pfNonRfc )
{
  if (NULL != pfNonRfc)
    *pfNonRfc = FALSE;
  if (NULL == lpctszSiteName)
    return FALSE;
  if (NULL != wcschr( lpctszSiteName, _T('.') ))
    return FALSE;
  DWORD dw = ::DnsValidateDnsName_W( const_cast<LPTSTR>(lpctszSiteName) );
  switch (dw)
  {
    case DNS_ERROR_NON_RFC_NAME:
      if (NULL != pfNonRfc)
        *pfNonRfc = TRUE;
      // fall through
    case DNS_ERROR_RCODE_NO_ERROR:
      break;
    default:
      return FALSE;
  }
  return TRUE;
}

/*******************************************************************

    NAME:       GetAuthenticationID

    SYNOPSIS:   Retrieves the UserName associated with the credentials
                currently being used for network access.
                (runas /netonly credentials)

    RETURNS:    A win32 error code

    NOTE:       String returned must be freed with LocalFree

    HISTORY:
        JeffreyS    05-Aug-1999     Created
        Modified by hiteshr to return credentials
        JeffJon     21-Nov-2000     Modified to return a win32 error

********************************************************************/
ULONG
GetAuthenticationID(LPWSTR *ppszResult)
{        
    ULONG ulReturn = 0;
    HANDLE hLsa;
    NTSTATUS Status = 0;
    *ppszResult = NULL;
    //
    // These LSA calls are delay-loaded from secur32.dll using the linker's
    // delay-load mechanism.  Therefore, wrap with an exception handler.
    //
    __try
    {
        Status = LsaConnectUntrusted(&hLsa);

        if (Status == 0)
        {
            NEGOTIATE_CALLER_NAME_REQUEST Req = {0};
            PNEGOTIATE_CALLER_NAME_RESPONSE pResp;
            ULONG cbSize =0;
            NTSTATUS SubStatus =0;

            Req.MessageType = NegGetCallerName;

            Status = LsaCallAuthenticationPackage(
                            hLsa,
                            0,
                            &Req,
                            sizeof(Req),
                            (void**)&pResp,
                            &cbSize,
                            &SubStatus);

            if ((Status == 0) && (SubStatus == 0))
            {
                LocalAllocString(ppszResult,pResp->CallerName);
                LsaFreeReturnBuffer(pResp);
            }

            LsaDeregisterLogonProcess(hLsa);
        }
        ulReturn = LsaNtStatusToWinError(Status);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return ulReturn;
    
}

// IsLocalLogin
//Function determines if the user has logged in as
//Local user or to a domain

BOOL IsLocalLogin( void )
{

  DWORD nSize = 0;
  
  PWSTR pszUserName = NULL;

  if (ERROR_SUCCESS != GetAuthenticationID(&pszUserName))
    return false;

  CString strSamComName( pszUserName );
  int nPos = strSamComName.Find('\\');
  if( -1 == nPos ){
    LocalFree(pszUserName);
    return false;
  }
  CString strDomainOrLocalName( strSamComName.Mid(0,nPos) );

  WCHAR lpszName1[ MAX_COMPUTERNAME_LENGTH + 1 ];
  nSize = 	MAX_COMPUTERNAME_LENGTH + 1;
  GetComputerName( lpszName1, &nSize);
  CString strCompName ( (LPCWSTR)lpszName1 );
  
  LocalFree(pszUserName);

  return ( strDomainOrLocalName == strCompName );
}


// IsThisUserLoggedIn
//Function determines if the user is the same as the
//passed in DN.
//Parameter is either a DN or a full ADSI path
extern LPWSTR g_lpszLoggedInUser = NULL;

BOOL IsThisUserLoggedIn( LPCTSTR pwszUserDN )
{

  DWORD nSize = 0;
  BOOL result = FALSE;

  if (g_lpszLoggedInUser == NULL) {
    //get the size passing null pointer
    GetUserNameEx(NameFullyQualifiedDN , NULL, &nSize);
    
    if( nSize == 0 )
      return false;
    
    g_lpszLoggedInUser = new WCHAR[ nSize ];
    if( g_lpszLoggedInUser == NULL )
      return false;

    GetUserNameEx(NameFullyQualifiedDN, g_lpszLoggedInUser, &nSize );
  }
  CString csUserDN = pwszUserDN;
  CString csDN;
  (void) StripADsIPath(csUserDN, csDN);

  if (!_wcsicmp (g_lpszLoggedInUser, csDN)) {
    result = TRUE;
  }

  return result;
}


//+---------------------------------------------------------------------------
//
//  Function:   SetSecurityInfoMask
//
//  Synopsis:   Reads the security descriptor from the specied DS object
//
//  Arguments:  [IN  punk]          --  IUnknown from IDirectoryObject
//              [IN  si]            --  SecurityInformation
////  History:  25-Dec-2000         --  Hiteshr Created
//----------------------------------------------------------------------------
HRESULT
SetSecurityInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si)
{
    HRESULT hr = E_INVALIDARG;
    if (punk)
    {
        IADsObjectOptions *pOptions;
        hr = punk->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            VariantInit(&var);
            V_VT(&var) = VT_I4;
            V_I4(&var) = si;
            hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);
            pOptions->Release();
        }
    }
    return hr;
}

WCHAR const c_szSDProperty[]        = L"nTSecurityDescriptor";


//+---------------------------------------------------------------------------
//
//  Function:   DSReadObjectSecurity
//
//  Synopsis:   Reads the Dacl from the specied DS object
//
//  Arguments:  [in pDsObject]      -- IDirettoryObject for dsobject
//              [psdControl]        -- Control Setting for SD
//                                     They can be returned when calling
//                                      DSWriteObjectSecurity                 
//              [OUT ppDacl]        --  DACL returned here
//              
//
//  History     25-Oct-2000         -- hiteshr created
//
//  Notes:  If Object Doesn't have DACL, function will succeed but *ppDacl will
//          be NULL. 
//          Caller must free *ppDacl, if not NULL, by calling LocalFree
//
//----------------------------------------------------------------------------
HRESULT 
DSReadObjectSecurity(IN IDirectoryObject *pDsObject,
                     OUT SECURITY_DESCRIPTOR_CONTROL * psdControl,
                     OUT PACL *ppDacl)
{
   HRESULT hr = S_OK;
   PADS_ATTR_INFO pSDAttributeInfo = NULL;

   do // false loop
   {
      LPWSTR pszSDProperty = (LPWSTR)c_szSDProperty;
      DWORD dwAttributesReturned;
      PSECURITY_DESCRIPTOR pSD = NULL;
      PACL pAcl = NULL;

      if(!pDsObject || !ppDacl)
      {
         ASSERT(FALSE);
         hr = E_INVALIDARG;
         break;
      }

      *ppDacl = NULL;

      // Set the SECURITY_INFORMATION mask
      hr = SetSecurityInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
      {
         break;
      }

      //
      // Read the security descriptor
      //
      hr = pDsObject->GetObjectAttributes(&pszSDProperty,
                                         1,
                                         &pSDAttributeInfo,
                                         &dwAttributesReturned);
      if (SUCCEEDED(hr) && !pSDAttributeInfo)    
         hr = E_ACCESSDENIED;    // This happens for SACL if no SecurityPrivilege

      if(FAILED(hr))
      {
         break;
      }                

      ASSERT(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->dwADsType);
      ASSERT(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->pADsValues->dwType);

      pSD = (PSECURITY_DESCRIPTOR)pSDAttributeInfo->pADsValues->SecurityDescriptor.lpValue;

      ASSERT(IsValidSecurityDescriptor(pSD));


      //
      //Get the security descriptor control
      //
      if(psdControl)
      {
         DWORD dwRevision;
         if(!GetSecurityDescriptorControl(pSD, psdControl, &dwRevision))
         {
             hr = HRESULT_FROM_WIN32(GetLastError());
             break;
         }
      }

      //
      //Get pointer to DACL
      //
      BOOL bDaclPresent, bDaclDefaulted;
      if(!GetSecurityDescriptorDacl(pSD, 
                                   &bDaclPresent,
                                   &pAcl,
                                   &bDaclDefaulted))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         break;
      }

      if(!bDaclPresent ||
         !pAcl)
      {
         break;
      }

      ASSERT(IsValidAcl(pAcl));

      //
      //Make a copy of the DACL
      //
      *ppDacl = (PACL)LocalAlloc(LPTR,pAcl->AclSize);
      if(!*ppDacl)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
      CopyMemory(*ppDacl,pAcl,pAcl->AclSize);

    }while(0);


    if (pSDAttributeInfo)
        FreeADsMem(pSDAttributeInfo);

    return hr;
}

const GUID GUID_CONTROL_UserChangePassword =
    { 0xab721a53, 0x1e2f, 0x11d0,  { 0x98, 0x19, 0x00, 0xaa, 0x00, 0x40, 0x52, 0x9b}};

bool CanUserChangePassword(IN IDirectoryObject* pDirObject)
{
   bool bCanChangePassword = false;
   HRESULT hr = S_OK;

   do // false loop
   {
      //
      // Validate parameters
      //
      if (!pDirObject)
      {
         ASSERT(pDirObject);
         break;
      }

      SECURITY_DESCRIPTOR_CONTROL sdControl = {0};
      CSimpleAclHolder Dacl;
      hr = DSReadObjectSecurity(pDirObject,
                                &sdControl,
                                &(Dacl.m_pAcl));
      if (FAILED(hr))
      {
         break;
      }

      //
      // Create and Initialize the Self and World SIDs
      //
      CSidHolder selfSid;
      CSidHolder worldSid;

      PSID pSid = NULL;

      SID_IDENTIFIER_AUTHORITY NtAuth    = SECURITY_NT_AUTHORITY,
                               WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
      if (!AllocateAndInitializeSid(&NtAuth,
                                    1,
                                    SECURITY_PRINCIPAL_SELF_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid))
      {
         break;
      }

      selfSid.Attach(pSid, false);
      pSid = NULL;

      if (!AllocateAndInitializeSid(&WorldAuth,
                                    1,
                                    SECURITY_WORLD_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &pSid))
      {
         break;
      }

      worldSid.Attach(pSid, false);
      pSid = NULL;

      ULONG ulCount = 0, j = 0;
      PEXPLICIT_ACCESS rgEntries = NULL;

      DWORD dwErr = GetExplicitEntriesFromAcl(Dacl.m_pAcl, &ulCount, &rgEntries);

      if (ERROR_SUCCESS != dwErr)
      {
         break;
      }

      //
      // Are these ACEs already present?
      //
      bool bSelfAllowPresent = false;
      bool bWorldAllowPresent = false;
      bool bSelfDenyPresent = false;
      bool bWorldDenyPresent = false;

      //
      // Loop through looking for the can change password ACE for self and world
      //
      for (j = 0; j < ulCount; j++)
      {
         //
         // Look for deny ACEs
         //
         if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
             (rgEntries[j].grfAccessMode == DENY_ACCESS))
         {
            OBJECTS_AND_SID* pObjectsAndSid = NULL;
            pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;

            //
            // Look for the user can change password ACE
            //
            if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                            GUID_CONTROL_UserChangePassword))
            {
               //
               // See if it is for the self SID or the world SID
               //
               if (EqualSid(pObjectsAndSid->pSid, selfSid.Get())) 
               {
                  //
                  // Deny self found
                  //
                  bSelfDenyPresent = true;
               }
               else if (EqualSid(pObjectsAndSid->pSid, worldSid.Get()))
               {
                  //
                  // Deny world found
                  //
                  bWorldDenyPresent = true;
               }
            }
         }
         //
         // Look for allow ACEs
         //
         else if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
                  (rgEntries[j].grfAccessMode == GRANT_ACCESS))
         {
            OBJECTS_AND_SID* pObjectsAndSid = NULL;
            pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;

            //
            // Look for the user can change password ACE
            //
            if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                            GUID_CONTROL_UserChangePassword))
            {
               //
               // See if it is for the self SID or the world SID
               //
               if (EqualSid(pObjectsAndSid->pSid, selfSid.Get()))
               {
                  //
                  // Allow self found
                  //
                  bSelfAllowPresent = true;
               }
               else if (EqualSid(pObjectsAndSid->pSid, worldSid.Get()))
               {
                  //
                  // Allow world found
                  //
                  bWorldAllowPresent = true;
               }
            }
         }
      }

      if (bSelfDenyPresent || bWorldDenyPresent)
      {
         //
         // There is an explicit deny so we know that the user cannot change password
         //
         bCanChangePassword = false;
      }
      else if ((!bSelfDenyPresent && !bWorldDenyPresent) &&
               (bSelfAllowPresent || bWorldAllowPresent))
      {
         //
         // There is no explicit deny but there are explicit allows so we know that
         // the user can change password
         //
         bCanChangePassword = true;
      }
      else
      {
         //
         // We are not sure because the explicit entries are not telling us for
         // certain so it all depends on inheritence.  Most likely they will
         // be able to change their password unless the admin has changed something
         // higher up or through group membership
         //
         bCanChangePassword = true;
      }
   } while(false);

  return bCanChangePassword;
}


/////////////////////////////////////////////////////////////////////////////////
// CDSNotifyDataObject

class CDSNotifyDataObject : public IDataObject, public CComObjectRoot 
{
// ATL Maps
    DECLARE_NOT_AGGREGATABLE(CDSNotifyDataObject)
    BEGIN_COM_MAP(CDSNotifyDataObject)
        COM_INTERFACE_ENTRY(IDataObject)
    END_COM_MAP()

// Construction/Destruction
  CDSNotifyDataObject()
  {
    m_dwFlags = 0;
    m_dwProviderFlags = 0;
    m_pCLSIDNamespace = NULL;
  }
  ~CDSNotifyDataObject() {}

// Standard IDataObject methods
public:
// Implemented
  STDMETHOD(GetData)(FORMATETC * pformatetcIn, STGMEDIUM * pmedium);

// Not Implemented
private:
  STDMETHOD(GetDataHere)(FORMATETC*, STGMEDIUM*)    { return E_NOTIMPL; };
  STDMETHOD(EnumFormatEtc)(DWORD, IEnumFORMATETC**) { return E_NOTIMPL; };
  STDMETHOD(SetData)(FORMATETC*, STGMEDIUM*, BOOL)  { return E_NOTIMPL; };
  STDMETHOD(QueryGetData)(FORMATETC*)               { return E_NOTIMPL; };
  STDMETHOD(GetCanonicalFormatEtc)(FORMATETC*, FORMATETC*)    { return E_NOTIMPL; };
  STDMETHOD(DAdvise)(FORMATETC*, DWORD, IAdviseSink*, DWORD*) { return E_NOTIMPL; };
  STDMETHOD(DUnadvise)(DWORD)                       { return E_NOTIMPL; };
  STDMETHOD(EnumDAdvise)(IEnumSTATDATA**)           { return E_NOTIMPL; };

public:
  // Property Page Clipboard formats
  static CLIPFORMAT m_cfDsObjectNames;

  // initialization
  HRESULT Init(LPCWSTR lpszPath, LPCWSTR lpszClass, BOOL bContainer,
                                  CDSComponentData* pCD);
// Implementation
private:
  CString m_szPath;
  CString m_szClass;
  DWORD m_dwFlags;
  DWORD m_dwProviderFlags;
  const CLSID* m_pCLSIDNamespace;

};


CLIPFORMAT CDSNotifyDataObject::m_cfDsObjectNames = 
                                (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);


STDMETHODIMP CDSNotifyDataObject::GetData(FORMATETC * pFormatEtc, STGMEDIUM * pMedium)
{
  if ((pFormatEtc == NULL) || (pMedium == NULL))
  {
    return E_INVALIDARG;
  }
  if (IsBadWritePtr(pMedium, sizeof(STGMEDIUM)))
  {
    return E_INVALIDARG;
  }
  if (!(pFormatEtc->tymed & TYMED_HGLOBAL))
  {
    return DV_E_TYMED;
  }

  // we support only one clipboard format
  pMedium->tymed = TYMED_HGLOBAL;
  pMedium->pUnkForRelease = NULL;
  if (pFormatEtc->cfFormat != m_cfDsObjectNames)
  {
    return DV_E_FORMATETC;
  }

  // figure out how much storage we need
  int nPathLen = m_szPath.GetLength();
  int nClassLen = m_szClass.GetLength();
  int cbStruct = sizeof(DSOBJECTNAMES); //contains already a DSOBJECT embedded struct
  DWORD cbStorage = (nPathLen + 1 + nClassLen + 1) * sizeof(WCHAR);

  LPDSOBJECTNAMES pDSObj;
      
  pDSObj = (LPDSOBJECTNAMES)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                        cbStruct + cbStorage);
  
  if (pDSObj == NULL)
  {
    return STG_E_MEDIUMFULL;
  }

  // write the info
  pDSObj->clsidNamespace = *m_pCLSIDNamespace;
  pDSObj->cItems = 1;

  pDSObj->aObjects[0].dwFlags = m_dwFlags;
  pDSObj->aObjects[0].dwProviderFlags = m_dwProviderFlags;
  
  pDSObj->aObjects[0].offsetName = cbStruct;
  pDSObj->aObjects[0].offsetClass = cbStruct + (nPathLen + 1) * sizeof(WCHAR);

  _tcscpy((LPTSTR)((BYTE *)pDSObj + (pDSObj->aObjects[0].offsetName)), (LPCWSTR)m_szPath);

  _tcscpy((LPTSTR)((BYTE *)pDSObj + (pDSObj->aObjects[0].offsetClass)), (LPCWSTR)m_szClass);

  pMedium->hGlobal = (HGLOBAL)pDSObj;

  return S_OK;
}

HRESULT CDSNotifyDataObject::Init(LPCWSTR lpszPath, LPCWSTR lpszClass, BOOL bContainer,
                                  CDSComponentData* pCD)
{
  m_szPath = lpszPath;
  m_szClass = lpszClass;

  switch (pCD->QuerySnapinType())
  {
  case SNAPINTYPE_DS:
    m_pCLSIDNamespace = &CLSID_DSSnapin;
    break;
  case SNAPINTYPE_SITE:
    m_pCLSIDNamespace = &CLSID_SiteSnapin;
    break;
  default:
    m_pCLSIDNamespace = &CLSID_NULL;
  }

  m_dwProviderFlags = (pCD->IsAdvancedView()) ? DSPROVIDER_ADVANCED : 0;

  m_dwFlags = bContainer ? DSOBJECT_ISCONTAINER : 0;

  return S_OK;
}

/////////////////////////////////////////////////////////////////////
// CChangePasswordPrivilegeAction

static GUID UserChangePasswordGUID = 
  { 0xab721a53, 0x1e2f, 0x11d0,  { 0x98, 0x19, 0x00, 0xaa, 0x00, 0x40, 0x52, 0x9b}};


HRESULT CChangePasswordPrivilegeAction::Load(IADs * pIADs)
{
  // reset state, just in case
  m_bstrObjectLdapPath = (LPCWSTR)NULL;
  m_pDacl = NULL;
  m_SelfSid.Clear();
  m_WorldSid.Clear();

  // get the full LDAP path of the object
  HRESULT hr = pIADs->get_ADsPath(&m_bstrObjectLdapPath);
  ASSERT (SUCCEEDED(hr));
  if (FAILED(hr))
	{
		TRACE(_T("failed on pIADs->get_ADsPath()\n"));
		return hr;
	}

  UnescapePath(m_bstrObjectLdapPath, /*bDN*/ FALSE, m_bstrObjectLdapPath);

  // allocate SIDs
  hr = _SetSids();
  if (FAILED(hr))
	{
		TRACE(_T("failed on _SetSids()\n"));
		return hr;
	}

  // read info 
  TRACE(_T("GetNamedSecurityInfo(%s)\n"), m_bstrObjectLdapPath);

  DWORD dwErr = ::GetNamedSecurityInfo(
                        IN  m_bstrObjectLdapPath,
                        IN  SE_DS_OBJECT_ALL,
                        IN  DACL_SECURITY_INFORMATION,
                        OUT NULL,
                        OUT NULL,
                        OUT &(m_pDacl),
                        OUT NULL,
                        OUT &(m_SDHolder.m_pSD)); 

  TRACE(L"GetNamedSecurityInfo() returned dwErr = 0x%x\n", dwErr);

  if (dwErr != ERROR_SUCCESS)
  {
      TRACE(L"GetNamedSecurityInfo() failed!\n");
      return HRESULT_FROM_WIN32(dwErr);
  }
  
  return S_OK;
}

HRESULT CChangePasswordPrivilegeAction::Read(BOOL* pbPasswordCannotChange)
{
  *pbPasswordCannotChange = FALSE;
  // find about the existence of the deny ACEs

  ULONG ulCount, j;
  PEXPLICIT_ACCESS rgEntries;

  ASSERT(m_pDacl);
  DWORD dwErr = GetExplicitEntriesFromAcl(m_pDacl, &ulCount, &rgEntries);
  TRACE(L"GetExplicitEntriesFromAcl() returned dwErr = 0x%x\n", dwErr);

  if (dwErr != ERROR_SUCCESS)
  {
    TRACE(L"GetExplicitEntriesFromAcl() failed!\n");
    return HRESULT_FROM_WIN32(dwErr);
  }

  for (j = 0; j < ulCount; j++)
  {
    if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
        (rgEntries[j].grfAccessMode == DENY_ACCESS))
    {
      OBJECTS_AND_SID * pObjectsAndSid;
      pObjectsAndSid = (OBJECTS_AND_SID *)rgEntries[j].Trustee.ptstrName;
      
      if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                      UserChangePasswordGUID) &&
          (EqualSid(pObjectsAndSid->pSid, m_SelfSid.Get()) ||
           EqualSid(pObjectsAndSid->pSid, m_WorldSid.Get())))
      {
          *pbPasswordCannotChange = TRUE;
      } // if
    } // if
  } // for

  TRACE(L"*pbPasswordCannotChange = %d\n", *pbPasswordCannotChange);

  return S_OK;
}


HRESULT CChangePasswordPrivilegeAction::Revoke()
{
  DWORD dwErr = 0;

  EXPLICIT_ACCESS rgAccessEntry[2] = {0};
  OBJECTS_AND_SID rgObjectsAndSid[2] = {0};
  // initialize the entries (DENY ACE's)
  rgAccessEntry[0].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
  rgAccessEntry[0].grfAccessMode = DENY_ACCESS;
  rgAccessEntry[0].grfInheritance = NO_INHERITANCE;

  rgAccessEntry[1].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
  rgAccessEntry[1].grfAccessMode = DENY_ACCESS;
  rgAccessEntry[1].grfInheritance = NO_INHERITANCE;


  // build the trustee structs for change password
  BuildTrusteeWithObjectsAndSid(&(rgAccessEntry[0].Trustee), 
                                &(rgObjectsAndSid[0]),
                                &UserChangePasswordGUID,
                                NULL, // inherit guid
                                m_SelfSid.Get()
                                );

  BuildTrusteeWithObjectsAndSid(&(rgAccessEntry[1].Trustee), 
                                &(rgObjectsAndSid[1]),
                                &UserChangePasswordGUID,
                                NULL, // inherit guid
                                m_WorldSid.Get()
                                );

  // add the entries to the ACL
  TRACE(L"calling SetEntriesInAcl()\n");

  CSimpleAclHolder NewDacl;
  dwErr = ::SetEntriesInAcl(2, rgAccessEntry, m_pDacl, &(NewDacl.m_pAcl));

  TRACE(L"SetEntriesInAcl() returned dwErr = 0x%x\n", dwErr);

  if (dwErr != ERROR_SUCCESS)
  {
    TRACE(_T("SetEntriesInAccessList failed!\n"));
    return HRESULT_FROM_WIN32(dwErr);
  }

  // commit the changes
  TRACE(L"calling SetNamedSecurityInfo()\n");

  dwErr = ::SetNamedSecurityInfo(
                        IN   m_bstrObjectLdapPath,
                        IN   SE_DS_OBJECT_ALL,
                        IN   DACL_SECURITY_INFORMATION,
                        IN   NULL,
                        IN   NULL,
                        IN   NewDacl.m_pAcl,
                        IN   NULL);
  
  TRACE(L"SetNamedSecurityInfo() returned dwErr = 0x%x\n", dwErr);

  if (dwErr != ERROR_SUCCESS)
  {
    TRACE(_T("SetNamedSecurityInfo() failed!\n"));
    return HRESULT_FROM_WIN32(dwErr);
  }
  return S_OK;
}

HRESULT CChangePasswordPrivilegeAction::_SetSids()
{
  PSID pSidTemp;
  SID_IDENTIFIER_AUTHORITY NtAuth    = SECURITY_NT_AUTHORITY,
                           WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
  //
  // build SID's for Self and World.
  //
  if (!AllocateAndInitializeSid(&NtAuth,
                                1,
                                SECURITY_PRINCIPAL_SELF_RID,
                                0, 0, 0, 0, 0, 0, 0,
                                &pSidTemp))
  {
      TRACE(_T("AllocateAndInitializeSid failed!\n"));
      return HRESULT_FROM_WIN32(GetLastError());
  }
  m_SelfSid.Attach(pSidTemp, FALSE);

  if (!AllocateAndInitializeSid(&WorldAuth,
                                1,
                                SECURITY_WORLD_RID,
                                0, 0, 0, 0, 0, 0, 0,
                                &pSidTemp))
  {
      TRACE(_T("AllocateAndInitializeSid failed!\n"));
      return HRESULT_FROM_WIN32(GetLastError());
  }
  m_WorldSid.Attach(pSidTemp, FALSE);

  return S_OK;
}



/////////////////////////////////////////////////////////////////////
// CDSNotifyHandlerTransaction

CDSNotifyHandlerTransaction::CDSNotifyHandlerTransaction(CDSComponentData* pCD)
{
  m_bStarted = FALSE;
  m_uEvent = 0;

  m_pCD = pCD;
  if (m_pCD != NULL)
  {
    m_pMgr = pCD->GetNotifyHandlerManager();
    ASSERT(m_pMgr != NULL);
  }
}

UINT CDSNotifyHandlerTransaction::NeedNotifyCount()
{
  if ((m_pCD == NULL) || (m_pMgr == NULL))
    return 0; // we have no handler for doing notifications

  if (!m_pMgr->HasHandlers())
    return 0;
  return m_pMgr->NeedNotifyCount(m_uEvent);
}

void CDSNotifyHandlerTransaction::SetCheckListBox(CCheckListBox* pCheckListBox)
{
  if ((m_pCD == NULL) || (m_pMgr == NULL))
    return; // we have no handler for doing notifications

  ASSERT(m_pMgr->HasHandlers());
  m_pMgr->SetCheckListBox(pCheckListBox, m_uEvent);
}

void CDSNotifyHandlerTransaction::ReadFromCheckListBox(CCheckListBox* pCheckListBox)
{
  if ((m_pCD == NULL) || (m_pMgr == NULL))
    return; // we have no handler for doing notifications

  ASSERT(m_pMgr->HasHandlers());
  m_pMgr->ReadFromCheckListBox(pCheckListBox, m_uEvent);
}



HRESULT CDSNotifyHandlerTransaction::Begin(LPCWSTR lpszArg1Path, 
                                           LPCWSTR lpszArg1Class,
                                           BOOL bArg1Cont,
                                           LPCWSTR lpszArg2Path, 
                                           LPCWSTR lpszArg2Class,
                                           BOOL bArg2Cont)
{
  m_bStarted = TRUE;
  ASSERT(m_uEvent != 0);
  m_spArg1 = NULL;
  m_spArg2 = NULL;

  if ((m_pCD == NULL) || (m_pMgr == NULL))
  {
    return S_OK; // we have no handler for doing notifications
  }
  
  //
  // if needed, do delayed message handler initialization
  //
  m_pMgr->Load(m_pCD->GetBasePathsInfo());

  //
  // avoid building data objects if there are no handlers available
  //
  if (!m_pMgr->HasHandlers())
  {
    return S_OK;
  }

  //
  // build first argument data object
  //
  HRESULT hr = _BuildDataObject(lpszArg1Path, lpszArg1Class, bArg1Cont, &m_spArg1);
  if (FAILED(hr))
  {
    return hr;
  }

  //
  // if needed, build second argument
  //
  if ( (m_uEvent == DSA_NOTIFY_MOV) || (m_uEvent == DSA_NOTIFY_REN) )
  {
    hr = _BuildDataObject(lpszArg2Path, lpszArg2Class, bArg2Cont, &m_spArg2);
    if (FAILED(hr))
    {
      return hr;
    }
  }

  m_pMgr->Begin(m_uEvent, m_spArg1, m_spArg2);
  return S_OK;
}

HRESULT CDSNotifyHandlerTransaction::Begin(CDSCookie* pArg1Cookie, 
                                           LPCWSTR lpszArg2Path, 
                                           LPCWSTR lpszArg2Class, 
                                           BOOL bArg2Cont)
{
  m_bStarted = TRUE;
  ASSERT(m_uEvent != 0);
  if ((m_pCD == NULL) || (m_pMgr == NULL))
  {
    return S_OK; // we have no handler for doing notifications
  }

  //
  // get info from the node and cookie and call the other Begin() function
  //
  CString szPath;
  m_pCD->GetBasePathsInfo()->ComposeADsIPath(szPath, pArg1Cookie->GetPath());

  return Begin(szPath, pArg1Cookie->GetClass(), pArg1Cookie->IsContainerClass(),
                  lpszArg2Path, lpszArg2Class, bArg2Cont);
}

HRESULT CDSNotifyHandlerTransaction::Begin(IDataObject* pArg1, 
                                           LPCWSTR lpszArg2Path, 
                                           LPCWSTR lpszArg2Class, 
                                           BOOL bArg2Cont)
{
  m_bStarted = TRUE;
  ASSERT(m_uEvent != 0);
  m_spArg1 = NULL;
  m_spArg2 = NULL;
  HRESULT hr;

  if ((m_pCD == NULL) || (m_pMgr == NULL))
  {
    return S_OK; // we have no handler for doing notifications
  }
  
  //
  // if needed, do delayed message handler initialization
  //
  m_pMgr->Load(m_pCD->GetBasePathsInfo());

  //
  // avoid building data objects if there are no handlers available
  //
  if (!m_pMgr->HasHandlers())
  {
    return S_OK;
  }

  //
  // get the first argument as is
  //
  m_spArg1 = pArg1;

  //
  // if needed, build second argument
  //
  if ( (m_uEvent != DSA_NOTIFY_DEL) && (m_uEvent != DSA_NOTIFY_PROP) )
  {
    hr = _BuildDataObject(lpszArg2Path, lpszArg2Class, bArg2Cont, &m_spArg2);
    if (FAILED(hr))
    {
      return hr;
    }
  }

  m_pMgr->Begin(m_uEvent, m_spArg1, m_spArg2);
  return S_OK;
}

void CDSNotifyHandlerTransaction::Notify(ULONG nItem) 
{
  ASSERT(m_bStarted);
  ASSERT(m_uEvent != 0);
  if ((m_pCD == NULL) || (m_pMgr == NULL) || !m_pMgr->HasHandlers())
    return;

  m_pMgr->Notify(nItem, m_uEvent);
}


void CDSNotifyHandlerTransaction::End()
{
  ASSERT(m_bStarted);
  ASSERT(m_uEvent != 0);
  if ((m_pCD == NULL) || (m_pMgr == NULL) || !m_pMgr->HasHandlers())
    return;

  m_pMgr->End(m_uEvent);
  m_spArg1 = NULL;
  m_spArg2 = NULL;
  m_bStarted = FALSE;
}



HRESULT CDSNotifyHandlerTransaction::BuildTransactionDataObject(LPCWSTR lpszArgPath, 
                           LPCWSTR lpszArgClass,
                           BOOL bContainer,
                           CDSComponentData* pCD,
                           IDataObject** ppArg)
{

  (*ppArg) = NULL;
  ASSERT((lpszArgPath != NULL) && (lpszArgPath[0] != NULL));
  ASSERT((lpszArgClass != NULL) && (lpszArgClass[0] != NULL));

  //
  // need to build a data object and hang on to it
  //
  CComObject<CDSNotifyDataObject>* pObject;

  CComObject<CDSNotifyDataObject>::CreateInstance(&pObject);
  if (pObject == NULL)
  {
    return E_OUTOFMEMORY;
  }


  HRESULT hr = pObject->FinalConstruct();
  if (FAILED(hr))
  {
    delete pObject;
    return hr;
  }


  hr = pObject->Init(lpszArgPath, lpszArgClass, bContainer, pCD);
  if (FAILED(hr))
  {
    delete pObject;
    return hr;
  }

  hr = pObject->QueryInterface(IID_IDataObject,
                               reinterpret_cast<void**>(ppArg));
  if (FAILED(hr))
  {
    //
    // delete object by calling Release() 
    //
    (*ppArg)->Release();
    (*ppArg) = NULL; 
    return hr;
  }
  return hr;
}



HRESULT CDSNotifyHandlerTransaction::_BuildDataObject(LPCWSTR lpszArgPath, 
                                                      LPCWSTR lpszArgClass,
                                                      BOOL bContainer,
                                                      IDataObject** ppArg)
{
  ASSERT(m_uEvent != 0);
  ASSERT(m_pCD != NULL);
  return BuildTransactionDataObject(lpszArgPath, lpszArgClass,bContainer, m_pCD, ppArg);
}

/*
// JonN 6/2/00 99382
// SITEREPL:  Run interference when administrator attempts to
// delete critical object (NTDS Settings)
// reports own errors, returns true iff deletion should proceed
bool CUIOperationHandlerBase::CheckForNTDSDSAInSubtree(
        LPCTSTR lpszX500Path,
        LPCTSTR lpszItemName)
{
  if (NULL == GetComponentData())
  {
    ASSERT(FALSE);
    return false;
  }

  // set up subtree search
  CDSSearch Search(GetComponentData()->GetClassCache(), GetComponentData());
  CString strRootPath;
  GetComponentData()->GetBasePathsInfo()->ComposeADsIPath(strRootPath, lpszX500Path);
  HRESULT hr = Search.Init(strRootPath);

  // retrieve X500DN path to schema container
  CString strSchemaPath;
  GetComponentData()->GetBasePathsInfo()->GetSchemaPath(strSchemaPath);
  CPathCracker pathCracker;
  pathCracker.Set(const_cast<LPTSTR>((LPCTSTR)strSchemaPath),
                  ADS_SETTYPE_FULL);
  pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
  CComBSTR sbstrSchemaPathX500DN;
  pathCracker.Retrieve(ADS_FORMAT_X500_DN,&sbstrSchemaPathX500DN);

  // filter search
  CString strFilter;
  strFilter = L"(|(objectCategory=CN=NTDS-DSA,";
  strFilter += sbstrSchemaPathX500DN;
  strFilter += L")(&(objectCategory=CN=Computer,";
  strFilter += sbstrSchemaPathX500DN;
  strFilter += L")(userAccountControl:" LDAP_MATCHING_RULE_BIT_AND_W L":=8192)))";
  Search.SetFilterString((LPWSTR)(LPCWSTR)strFilter);

  Search.SetSearchScope(ADS_SCOPE_SUBTREE);

  LPWSTR pAttrs[2] = {L"objectClass",
                      L"distinguishedName"};
  Search.SetAttributeList (pAttrs, 2);
  hr = Search.DoQuery();
  if (SUCCEEDED(hr))
    hr = Search.GetNextRow();
  CString strX500PathDC;
  while (SUCCEEDED(hr) && hr != S_ADS_NOMORE_ROWS)
  {
    ADS_SEARCH_COLUMN Column;
    hr = Search.GetColumn (pAttrs[1], &Column);
    if (FAILED(hr) || Column.dwNumValues < 1) break;
    strX500PathDC = Column.pADsValues[Column.dwNumValues-1].CaseIgnoreString;
    Search.FreeColumn(&Column);
    if (lstrcmpi(lpszX500Path,strX500PathDC))
      break;

    // This is the object being deleted, this check does not apply here.
    // Continue the search.
    hr = Search.GetNextRow();
  }

  if (hr == S_ADS_NOMORE_ROWS)
    return true;
  else if (FAILED(hr))
    return true; // CODEWORK do we want to allow this operation to proceed?

  // retrieve the name of the DC
  CComBSTR sbstrDCName;
  bool fFoundNTDSDSA = FALSE;
  ADS_SEARCH_COLUMN Column;
  hr = Search.GetColumn (pAttrs[0], &Column);
  if (SUCCEEDED(hr) && Column.dwNumValues > 0)
  {
    fFoundNTDSDSA = !lstrcmpi( L"nTDSDSA",
      Column.pADsValues[Column.dwNumValues-1].CaseIgnoreString );
    Search.FreeColumn(&Column);
    pathCracker.Set((LPWSTR)(LPCWSTR)strX500PathDC, ADS_SETTYPE_DN);
    pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
    pathCracker.GetElement( (fFoundNTDSDSA)?1:0, &sbstrDCName );
  }


  // display an error message
  PVOID apv[2] = {(PVOID)lpszItemName, (PVOID)(LPCTSTR)sbstrDCName};
  (void) ReportErrorEx(GetParentHwnd(),IDS_12_CONTAINS_DC,hr,
                       MB_ICONERROR, apv, 2);

  // do not proceed with subtree deletion
  return false;

}
*/
//////////////////////////////////////////////////////////////////////////////////
// CheckForCriticalSystemObjectInSubtree
//
// description:
//   This function does a subtree search of the container that is passed in looking
//   for all objects that have isCriticalSystemObject=TRUE or NTDS Settings objects.
//
// parameters:
//   lpszX500Path - (IN) the X500 path of the container in which to search for
//                       critical system objects
//   lpszItemName - (IN) the displayable name of the container in which to search
//                       for critical system objects
//
// return value:
//   true - The container does not contain any critical system objects
//   false - The container does contain at least on critical system object
//////////////////////////////////////////////////////////////////////////////////
bool CUIOperationHandlerBase::CheckForCriticalSystemObjectInSubtree(
        LPCTSTR lpszX500Path,
        LPCTSTR lpszItemName)
{
  bool bRet = true;

  if (NULL == GetComponentData())
  {
    ASSERT(FALSE);
    return false;
  }

  CString szCriticalObjPath;

  // set up subtree search
  CDSSearch Search(GetComponentData()->GetClassCache(), GetComponentData());
  HRESULT hr = Search.Init(lpszX500Path);
  if (FAILED(hr))
  {
    ASSERT(FALSE && L"Failed to set the path in the search object");
    return false;
  }

  //
  // retrieve X500DN path to schema container
  //
  CString strSchemaPath;
  GetComponentData()->GetBasePathsInfo()->GetSchemaPath(strSchemaPath);
  CPathCracker pathCracker;
  pathCracker.Set(const_cast<LPTSTR>((LPCTSTR)strSchemaPath),
                  ADS_SETTYPE_FULL);
  pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
  CComBSTR sbstrSchemaPathX500DN;
  pathCracker.Retrieve(ADS_FORMAT_X500_DN,&sbstrSchemaPathX500DN);

  //
  // filter search
  //
  CString strFilter;
  strFilter = L"(|(&(objectClass=*)(isCriticalSystemObject=TRUE))";
  strFilter += L"(|(objectCategory=CN=NTDS-DSA,";
  strFilter += sbstrSchemaPathX500DN;

  //
  // 212232 JonN 10/27/00 Protect interSiteTransport objects
  //
  strFilter += L")(objectCategory=CN=Inter-Site-Transport,";
  strFilter += sbstrSchemaPathX500DN;

  strFilter += L")(&(objectCategory=CN=Computer,";
  strFilter += sbstrSchemaPathX500DN;
  strFilter += L")(userAccountControl:" LDAP_MATCHING_RULE_BIT_AND_W L":=8192))))";

  Search.SetFilterString((LPWSTR)(LPCWSTR)strFilter);

  Search.SetSearchScope(ADS_SCOPE_SUBTREE);

  LPWSTR pAttrs[4] = { L"aDSPath",
                       L"objectClass",
                       L"distinguishedName",
                       L"isCriticalSystemObject"};
  Search.SetAttributeList (pAttrs, 4);
  hr = Search.DoQuery();
  if (SUCCEEDED(hr))
  {
    hr = Search.GetNextRow();
  }

  if (hr == S_ADS_NOMORE_ROWS)
  {
    return true;
  }

  while (SUCCEEDED(hr) && hr != S_ADS_NOMORE_ROWS)
  {
    ADS_SEARCH_COLUMN PathColumn, CriticalColumn;

    hr = Search.GetColumn(pAttrs[3], &CriticalColumn);
    if (SUCCEEDED(hr) && CriticalColumn.pADsValues != NULL && CriticalColumn.pADsValues->Boolean)
    {
      //
      // We found a critical system object so report the error and then return
      //
      hr = Search.GetColumn(pAttrs[0], &PathColumn);
    
      if (SUCCEEDED(hr) && PathColumn.dwNumValues == 1 && PathColumn.pADsValues != NULL) 
      {
        //
        // Get the DN as a Windows style path
        //
        CComBSTR bstrLeaf;
        CPathCracker pathCrackerToo;
        HRESULT hrPathCracker = pathCrackerToo.Set(PathColumn.pADsValues->CaseIgnoreString, ADS_SETTYPE_FULL);
        if (SUCCEEDED(hr))
        {
          hrPathCracker = pathCrackerToo.put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);
          if (SUCCEEDED(hr))
          {
            hrPathCracker = pathCrackerToo.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
            if (SUCCEEDED(hr))
            {
              hrPathCracker = pathCrackerToo.Retrieve(ADS_FORMAT_LEAF, &bstrLeaf);
            }
          }
        }

        //
        // display an error message
        //
        if (wcslen(bstrLeaf))
        {
          PVOID apv[2] = {(PVOID)lpszItemName, (PVOID)(LPWSTR)bstrLeaf };
          (void) ReportErrorEx(GetParentHwnd(),IDS_CONTAINS_CRITICALSYSOBJ,S_OK,
                               MB_ICONERROR, apv, 2);
        }
        else
        {
          PVOID apv[2] = {(PVOID)lpszItemName, (PVOID)PathColumn.pADsValues->CaseIgnoreString };
          (void) ReportErrorEx(GetParentHwnd(),IDS_CONTAINS_CRITICALSYSOBJ,S_OK,
                               MB_ICONERROR, apv, 2);
        }

        Search.FreeColumn(&PathColumn);
        Search.FreeColumn(&CriticalColumn);
        bRet = false;
        break;
      }
      Search.FreeColumn(&CriticalColumn);
    }
    else
    {
      //
      // We found an NTDS Settings object.  Report the error and return.
      //
      hr = Search.GetColumn(pAttrs[0], &PathColumn);
    
      if (SUCCEEDED(hr) && PathColumn.dwNumValues == 1 && PathColumn.pADsValues != NULL) 
      {
        CString strX500PathDC = PathColumn.pADsValues[PathColumn.dwNumValues-1].CaseIgnoreString;
        Search.FreeColumn(&PathColumn);
        if (lstrcmpi(lpszX500Path,strX500PathDC))
        {
          //
          // retrieve the name of the DC
          //
          CComBSTR sbstrDCName;
          bool fFoundNTDSDSA = FALSE;
          ADS_SEARCH_COLUMN ClassColumn;
          hr = Search.GetColumn (pAttrs[1], &ClassColumn);
          if (SUCCEEDED(hr) && ClassColumn.dwNumValues > 0)
          {
            fFoundNTDSDSA = !lstrcmpi( L"nTDSDSA",
              ClassColumn.pADsValues[ClassColumn.dwNumValues-1].CaseIgnoreString );
            Search.FreeColumn(&ClassColumn);
            pathCracker.Set((LPWSTR)(LPCWSTR)strX500PathDC, ADS_SETTYPE_DN);
            pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
            pathCracker.GetElement( (fFoundNTDSDSA)?1:0, &sbstrDCName );
          }


          // display an error message
          PVOID apv[2] = {(PVOID)lpszItemName, (PVOID)(LPCTSTR)sbstrDCName};
          (void) ReportErrorEx(GetParentHwnd(),IDS_12_CONTAINS_DC,hr,
                               MB_ICONERROR, apv, 2);

          // do not proceed with subtree deletion
          bRet = false;
          break;
        }
      }
    }
    hr = Search.GetNextRow();
  }

  // do not proceed with subtree deletion
  return bRet;
}


/////////////////////////////////////////////////////////////////////
// CDeleteDCDialog

class CDeleteDCDialog : public CDialog
{
// Construction
public:
	CDeleteDCDialog(LPCTSTR lpszName, bool fIsComputer);

// Implementation
protected:

  // message handlers and MFC overrides
  virtual BOOL OnInitDialog();
  virtual void OnOK();

  DECLARE_MESSAGE_MAP()

private:
  CString m_strADsPath;
  bool    m_fIsComputer;
};


BEGIN_MESSAGE_MAP(CDeleteDCDialog, CDialog)
END_MESSAGE_MAP()

CDeleteDCDialog::CDeleteDCDialog(LPCTSTR lpszADsPath, bool fIsComputer)
	: CDialog(IDD_DELETE_DC_COMPUTER, NULL)
  , m_strADsPath(lpszADsPath)
  , m_fIsComputer(fIsComputer)
{
}

BOOL CDeleteDCDialog::OnInitDialog()
{
  // CODEWORK AfxInit?
	CDialog::OnInitDialog();

  CPathCracker pathCracker;
  pathCracker.Set(const_cast<LPWSTR>((LPCWSTR)m_strADsPath), ADS_SETTYPE_FULL);
  pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
  pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);

  CString strDisplay;
  CComBSTR sbstrName;
  if (m_fIsComputer)
  {
    pathCracker.GetElement( 0, &sbstrName );
    strDisplay.FormatMessage(IDS_DELETE_DC_COMPUTERACCOUNT, sbstrName);
  }
  else
  {
    CComBSTR sbstrSite;
    pathCracker.GetElement( 1, &sbstrName );
    pathCracker.GetElement( 3, &sbstrSite );
    CString strTemp;
    (void) GetDlgItemText(IDC_DELETE_DC_MAINTEXT, strTemp);
    strDisplay.FormatMessage( strTemp, sbstrName, sbstrSite );
  }
  (void) SetDlgItemText( IDC_DELETE_DC_MAINTEXT, strDisplay );

  CheckRadioButton( IDC_DELETE_DC_BADREASON1,
                    IDC_DELETE_DC_GOODREASON,
                    IDC_DELETE_DC_BADREASON1 );

	return TRUE;
}

void CDeleteDCDialog::OnOK()
{
  if (BST_CHECKED == IsDlgButtonChecked(IDC_DELETE_DC_GOODREASON))
  {
    CDialog::OnOK();
    return;
  }

  (void) ReportErrorEx((HWND)*this,
      (BST_CHECKED == IsDlgButtonChecked(IDC_DELETE_DC_BADREASON2))
          ? IDS_DELETE_DC_BADREASON2
          : IDS_DELETE_DC_BADREASON1,
      S_OK,MB_OK, NULL, 0);

  CDialog::OnCancel();
}


// JonN 6/15/00 13574
// Centralizes the checks to make sure this is an OK object to delete
// returns HRESULT_FROM_WIN32(ERROR_CANCELLED) on cancellation
// returns refAlreadyDeleted=true iff ObjectDeletionCheck already
//   attempted an alternate deletion method (e.g. DsRemoveDsServer).
HRESULT CUIOperationHandlerBase::ObjectDeletionCheck(
        LPCTSTR lpszADsPath,
        LPCTSTR lpszName, // shortname to display to user, may be NULL
        LPCTSTR lpszClass,
        bool& fAlternateDeleteMethod )
{
  fAlternateDeleteMethod = false;
  if (!_wcsicmp(L"user",lpszClass)
#ifdef INETORGPERSON
      || !_wcsicmp(L"inetOrgPerson", lpszClass)
#endif
     )
  {
    if (IsThisUserLoggedIn(lpszADsPath)) 
    {
      CComBSTR sbstrRDN;
      if (NULL == lpszName)
      {
        (void) DSPROP_RetrieveRDN( lpszADsPath, &sbstrRDN );
        lpszName = sbstrRDN;
      }

      PVOID apv[1] = {(PVOID)lpszName};
      if (IDYES != ReportMessageEx (GetParentHwnd(), IDS_12_USER_LOGGED_IN,
                                    MB_YESNO, apv, 1)) 
      {
        return HRESULT_FROM_WIN32(ERROR_CANCELLED);
      }
    }
    return S_OK;
  }

  bool fIsComputer = false;
  if (!_wcsicmp(L"computer",lpszClass)) 
  {
    //
    // Bind and figure out if the account is a DC
    //
    CComPtr<IADs> spIADs;
    HRESULT hr = ADsOpenObject ((LPWSTR)lpszADsPath,
                                NULL, NULL, ADS_SECURE_AUTHENTICATION,
                                IID_IADs,
                                (void **)&spIADs);
    CComVariant Var;
    if (SUCCEEDED(hr))
      hr = spIADs->Get(L"userAccountControl", &Var);
    if ( FAILED(hr) || !(Var.lVal & UF_SERVER_TRUST_ACCOUNT))
      return S_OK; // cannot be shown to be a DC
    fIsComputer = true;
  }
  else if (!_wcsicmp(L"nTDSDSA",lpszClass))
  {
    //
    // I would like to figure out the domain name so that I could
    // use fCommit==FALSE, but this is a little complicated.
    // Basic code is in proppage GetReplicatedDomainInfo(), but
    // is not exportable in its current form.  I will defer this
    // improvement for later.
    //
  }
  else if (!_wcsicmp(L"trustedDomain",lpszClass))
  {
    //
    // Give a strong warning if they are trying to delete a
    // TDO (Trusted Domain Object).  This could cause serious
    // problems but we want to allow them to clean up if necessary
    //
    PVOID apv[1] = {(PVOID)lpszName};
    if (IDYES == ReportMessageEx( GetParentHwnd(),
                                  IDS_WARNING_TDO_DELTEE,
                                  MB_YESNOCANCEL | MB_DEFBUTTON2 | MB_ICONWARNING,
                                  apv,
                                  1 ) ) 
    {
      fAlternateDeleteMethod = FALSE;
      return S_OK;
    }
    else
    {
      return HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
  }
  else if (!_wcsicmp(L"interSiteTransport",lpszClass))
  {
    //
    // 212232 JonN 10/27/00 Protect interSiteTransport objects
    //
    PVOID apv[1] = {(PVOID)lpszName};
    (void) ReportMessageEx( GetParentHwnd(),
                            IDS_1_ERROR_DELETE_CRITOBJ,
                            MB_OK | MB_ICONERROR,
                            apv,
                            1 );
    return HRESULT_FROM_WIN32(ERROR_CANCELLED);
  }
  else
  {
    return S_OK; // This is neither a computer nor an nTDSDSA nor a TDO
  }

  // This is either an nTDSDSA object, or a computer object
  //   which represents a DC

  CDeleteDCDialog dlg(lpszADsPath,fIsComputer);
  if (IDOK != dlg.DoModal())
    return HRESULT_FROM_WIN32(ERROR_CANCELLED);

  if (fIsComputer)
    return S_OK;

  // This is an nTDSDSA.  Delete using DsRemoveDsServer.

  fAlternateDeleteMethod = true;

  Smart_DsHandle shDS;
  BOOL fLastDcInDomain = FALSE;
  DWORD dwWinError = DsBind(
    m_pComponentData->GetBasePathsInfo()->GetServerName(),
    NULL,
    &shDS );
  if (ERROR_SUCCESS == dwWinError)
  {
    CPathCracker pathCracker;
    pathCracker.Set(const_cast<LPTSTR>(lpszADsPath), ADS_SETTYPE_FULL);
    pathCracker.RemoveLeafElement(); // pass DN to Server object
    CComBSTR sbstrDN;
    pathCracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrDN );

    dwWinError = DsRemoveDsServer( shDS,
                                   sbstrDN,
                                   NULL,
                                   &fLastDcInDomain,
                                   TRUE );
  }

  return HRESULT_FROM_WIN32(dwWinError);
}



///////////////////////////////////////////////////////////////////////////
// CSingleDeleteHandlerBase


/*
NOTICE: the function will return S_OK on success, S_FALSE if aborted
        by user, some FAILED(hr) otherwise
*/
HRESULT CSingleDeleteHandlerBase::Delete()
{
  HRESULT hr = S_OK;
  bool fAlternateDeleteMethod = false;

  // start the transaction 
  hr = BeginTransaction();
  ASSERT(SUCCEEDED(hr));


  if (GetTransaction()->NeedNotifyCount() > 0)
  {
    CString szMessage, szAssocData;
    szMessage.LoadString(IDS_CONFIRM_DELETE);
    szAssocData.LoadString(IDS_EXTENS_SINGLE_DEL);
    CConfirmOperationDialog dlg(GetParentHwnd(), GetTransaction());
    dlg.SetStrings(szMessage, szAssocData);
    if (IDNO == dlg.DoModal())
    {
      GetTransaction()->End();
      return S_FALSE;
    }
  }
  else
  {
    // this is just a message box, using ReportErrorEx for consistency of look
    UINT answer = ReportErrorEx(GetParentHwnd(),IDS_CONFIRM_DELETE,S_OK,
                                MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2, NULL, 0);
    if (answer == IDNO || answer == IDCANCEL) {
      return S_FALSE; // aborted by user
    }
  }

  CString szName;
  GetItemName(szName);

  hr = ObjectDeletionCheck(
        GetItemPath(),
        szName,
        GetItemClass(),
        fAlternateDeleteMethod );
  if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr)
    return S_FALSE; // CODEWORK doesn't end transaction?
  else if (FAILED(hr))
    return hr; // CODEWORK doesn't end transaction?

  // try to delete the object
  if (!fAlternateDeleteMethod)
    hr = DeleteObject();
  if (SUCCEEDED(hr))
  {
    // item deleted, notify extensions
    GetTransaction()->Notify(0);
  }
  else
  {
    // error in deleting item, check if it is a special error code
    if (hr == HRESULT_FROM_WIN32(ERROR_DS_CANT_ON_NON_LEAF)) 
    {
      // ask user to if he/she wants to delete the whole subtree
      PVOID apv[1] = {(LPWSTR)(LPCWSTR)szName};
      UINT answer = ReportErrorEx(GetParentHwnd(),IDS_12_OBJECT_HAS_CHILDREN,hr,
                                  MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2, apv, 1);
      if (answer == IDYES) 
      {
        // JonN 5/22/00 Watch for potential NTDSDSA deletion
        // JeffJon 8/10/00 Watch for potential critical object deletion (isCriticalSystemObject) bug #27377
        //
        if (CheckForCriticalSystemObjectInSubtree(GetItemPath(), szName))
        {
          //
          // try to delete the subtree and continue trying if we reach the 16k limit
          //
          do
          {
            hr = DeleteSubtree();
          } while (HRESULT_CODE(hr) == ERROR_DS_ADMIN_LIMIT_EXCEEDED);
          
          if (SUCCEEDED(hr))
          {
            GetTransaction()->Notify(0);
          }
          else
          {
            // failed subtree deletion, nothing can be done
            PVOID apvToo[1] = {(LPWSTR)(LPCWSTR)szName};
            ReportErrorEx(GetParentHwnd(), IDS_12_SUBTREE_DELETE_FAILED,hr,
                           MB_OK | MB_ICONERROR, apvToo, 1);
          }
        }
      }
    } 
    else if (hr == E_ACCESSDENIED)
    {
      PVOID apv[1] = {(BSTR)(LPWSTR)(LPCWSTR)szName};
      ReportErrorEx(GetParentHwnd(), IDS_12_DELETE_ACCESS_DENIED, hr, 
                     MB_OK | MB_ICONERROR, apv, 1);
    }
    else if (HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS)
    {
      PVOID apv[1] = {(BSTR)(LPWSTR)(LPCWSTR)szName};
      ReportErrorEx(GetParentHwnd(),IDS_12_DELETE_PRIMARY_GROUP_FAILED,hr,
                     MB_OK | MB_ICONERROR, apv, 1);
    }
    else 
    {
      PVOID apv[1] = {(BSTR)(LPWSTR)(LPCWSTR)szName};
      ReportErrorEx(GetParentHwnd(),IDS_12_DELETE_FAILED,hr,
                     MB_OK | MB_ICONERROR, apv, 1);
    }
  }

  if (SUCCEEDED(hr))
  {
    CStringList szDeletedPathList;
    szDeletedPathList.AddTail(GetItemPath());
    GetComponentData()->InvalidateSavedQueriesContainingObjects(szDeletedPathList);
  }
  return hr;

  GetTransaction()->End();
  return hr;
}


///////////////////////////////////////////////////////////////////////////
// CMultipleDeleteHandlerBase

void CMultipleDeleteHandlerBase::Delete()
{
  HRESULT hr = BeginTransaction();
  ASSERT(SUCCEEDED(hr));

  // ask confirmation to the user
  UINT cCookieTotalCount = GetItemCount();
  CString szFormat;
  szFormat.LoadString(IDS_CONFIRM_MULTI_DELETE);
  CString szMessage;
  szMessage.Format((LPCWSTR)szFormat, cCookieTotalCount);

  if (GetTransaction()->NeedNotifyCount() > 0)
  {
    CString szAssocData;
    szAssocData.LoadString(IDS_EXTENS_MULTIPLE_DEL);
    CConfirmOperationDialog dlg(GetParentHwnd(), GetTransaction());
    dlg.SetStrings(szMessage, szAssocData);
    if (IDNO == dlg.DoModal())
    {
      GetTransaction()->End();
      return;
    }
  }
  else
  {

    PVOID apv[1] = {(LPWSTR)(LPCWSTR)szMessage};
    if (ReportErrorEx(GetParentHwnd(),IDS_STRING,S_OK, 
                      MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2, 
                      apv, 1)== IDNO) 
    {
      return; // user aborted
    }
  }

  CMultipleDeleteProgressDialog dlg(GetParentHwnd(), GetComponentData(), this);
  dlg.DoModal();

}

void CMultipleDeleteHandlerBase::OnStart(HWND hwnd)
{
  SetParentHwnd(hwnd);
  m_confirmationUI.SetWindow(GetParentHwnd());
}


HRESULT CMultipleDeleteHandlerBase::OnDeleteStep(IN UINT i, 
                                                 OUT BOOL* pbContinue,
                                                 OUT CString& strrefPath,
                                                 OUT CString& strrefClass,
                                                 IN BOOL bSilent)
{
  ASSERT(i < GetItemCount());

  if (pbContinue == NULL)
  {
    return E_POINTER;
  }

  //
  // Initialize the OUT parameters
  //
  GetItemPath(i, strrefPath);
  strrefClass = GetItemClass(i);
  *pbContinue = TRUE;

  //
  // do the operation
  //
  HRESULT hr = DeleteObject(i);
  if ((SUCCEEDED(hr))) 
  {
    // item deleted, notify extensions and end transaction
    GetTransaction()->Notify(i);
    OnItemDeleted(i);
  }
  else
  {
    CString szName;
    GetItemName(i, szName);
    // error in deleting item, check if it is a special error code
    if (hr == HRESULT_FROM_WIN32(ERROR_DS_CANT_ON_NON_LEAF)) 
    {
      // ask confirmation for deleting subtree
      if (m_confirmationUI.CanDeleteSubtree(hr, szName, pbContinue))
      {
        // JeffJon 8/10/00 Watch for potential deletion of critical system objects
        if ( !CheckForCriticalSystemObjectInSubtree(strrefPath, szName))
        {
          // error already reported
          *pbContinue = FALSE;
          return E_FAIL;
        }

        //
        // Delete the subtree and continue deleting if the 16k limit is reached
        //
        do
        {
          hr = DeleteSubtree(i);
        } while (hr == ERROR_DS_ADMIN_LIMIT_EXCEEDED);

        if (SUCCEEDED(hr))
        {
          // item deleted, notify extensions and end transaction
          GetTransaction()->Notify(i);
          OnItemDeleted(i);
        }
        else
        {
          // we failed subtree deletion
          *pbContinue = m_confirmationUI.ErrorOnSubtreeDeletion(hr, szName); 
        }
      }
      else
      {
        //
        // This tells the calling function that we did not delete the object
        // but don't add it to the error reporting
        //
        hr = E_FAIL;
      }
    } 
    else 
    {
      // we failed deletion
      // JonN 7/20/00 If the HRESULT_FROM_WIN32(ERROR_CANCELLED) case,
      //              skip the confirmation UI and just cancel the series.
      if (bSilent)
      {
        *pbContinue = hr != HRESULT_FROM_WIN32(ERROR_CANCELLED);
      }
      else
      {
        *pbContinue = hr != HRESULT_FROM_WIN32(ERROR_CANCELLED) &&
                      m_confirmationUI.ErrorOnDeletion(hr, szName);
      }
    } // if (ERROR_DS_CANT_ON_NON_LEAF) 
  } // if (delete object)

  return hr;
}


//////////////////////////////////////////////////////////////////////////
// CMoveHandlerBase

HRESULT CMoveHandlerBase::Move(LPCWSTR lpszDestinationPath)
{
  // make sure destination data is reset
  m_spDSDestination = NULL;
  m_szDestPath.Empty();
  m_szDestClass.Empty();

  // check nomber of items
  UINT nCount = GetItemCount();
  if (nCount == 0)
  {
    return E_INVALIDARG;
  }

  // get the info about the destination container
  HRESULT hr = _BrowseForDestination(lpszDestinationPath);

  if (FAILED(hr) || (hr == S_FALSE))
  {
    return hr;
  }

  //
  // First check to see if we are trying to move into the same container
  // Using the path of the first object in the multiselect case is OK
  //
  CString szNewPath;
  GetNewPath(0, szNewPath);

  CPathCracker pathCracker;
  hr = pathCracker.Set((PWSTR)(PCWSTR)szNewPath, ADS_SETTYPE_FULL);
  if (SUCCEEDED(hr))
  {
    hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
    if (SUCCEEDED(hr))
    {
      hr = pathCracker.RemoveLeafElement();
      if (SUCCEEDED(hr))
      {
        CComBSTR sbstrContainerPath;
        hr = pathCracker.Retrieve(ADS_FORMAT_X500, &sbstrContainerPath);
        if (SUCCEEDED(hr))
        {
          if (0 == _wcsicmp(sbstrContainerPath, m_szDestPath))
          {
            //
            // The source and the target container are the same so we
            // don't have to do anything
            //
            return S_OK;
          }
        }
      }
    }
  }

  CStringList szMovedPathList;
  for (UINT nIdx = 0; nIdx < GetItemCount(); nIdx++)
  {
    CString szPath;
    GetItemPath(nIdx, szPath);
    szMovedPathList.AddTail(szPath);
  }

  //
  // Notice that we fall through on a failure trying to crack the source parent path
  // so reset the return value
  //
  hr = S_OK;

  // do the actual move operation
  if (nCount == 1)
  {
    BOOL bContinue = FALSE;
    do
    {
      //
      // Check to be sure we are not trying to drop on itself
      //
      if (m_szDestPath == szNewPath)
      {
        UINT nRet = ReportErrorEx(GetParentHwnd(), IDS_ERR_MSG_NO_MOVE_TO_SELF, S_OK, 
                                  MB_YESNO | MB_ICONERROR, NULL, 0);

        if (nRet == IDYES)
        {
          // get the info about the destination container
          hr = _BrowseForDestination(lpszDestinationPath);

          if (FAILED(hr) || (hr == S_FALSE))
          {
            return hr;
          }
        }
        else
        {
          break;
        }
      }
      else
      {
        bContinue = TRUE;
      }
    } while (!bContinue);

    if (bContinue)
    {
      hr = _MoveSingleSel(szNewPath);
      if (SUCCEEDED(hr))
      {
        GetComponentData()->InvalidateSavedQueriesContainingObjects(szMovedPathList);
      }
      return hr;
    }
    return S_FALSE;
  }
  hr = _MoveMultipleSel();
  return hr;
}


BOOL CMoveHandlerBase::_ReportFailure(BOOL bLast, HRESULT hr, LPCWSTR lpszName)
{
  TRACE(_T("Object Move Failed with hr: %lx\n"), hr);
  PVOID apv[1] = {(LPWSTR)lpszName};
  if (bLast)
  {
    // single selection or last one in multi selection
    ReportErrorEx(GetParentHwnd(),IDS_12_FAILED_TO_MOVE_OBJECT,hr,
                   MB_OK | MB_ICONERROR, apv, 1);
    return FALSE; // do not continue
  }
  return (ReportErrorEx(GetParentHwnd(),IDS_12_MULTI_FAILED_TO_MOVE_OBJECT,hr,
                                  MB_YESNO, apv, 1) == IDYES);
}


HRESULT CMoveHandlerBase::_MoveSingleSel(PCWSTR pszNewPath)
{
  if (!_BeginTransactionAndConfirmOperation())
    return S_FALSE;

  CComPtr<IDispatch> spDSTargetIDispatch;
  HRESULT hr = m_spDSDestination->MoveHere(const_cast<PWSTR>(pszNewPath),
                                  NULL,
                                  &spDSTargetIDispatch);
  if (FAILED(hr))
  {
    CString szName;
    GetName(0, szName);
    _ReportFailure(TRUE, hr, szName); 
  }
  else
  {
    // all went fine, notify extensions
    GetTransaction()->Notify(0);

    // give a chance to update UI (e.g. cookies)
    CComPtr<IADs> spIADsTarget;
    hr = spDSTargetIDispatch->QueryInterface (IID_IADs,
                                      (void **)&spIADsTarget);

    hr = OnItemMoved(0, spIADsTarget);
  }
  GetTransaction()->End();
  return hr;
}


HRESULT CMoveHandlerBase::_MoveMultipleSel()
{
  if (!_BeginTransactionAndConfirmOperation())
    return S_FALSE;

  CMultipleMoveProgressDialog dlg(GetParentHwnd(), GetComponentData(), this);
  dlg.DoModal();

  return S_OK;
}

HRESULT CMoveHandlerBase::_OnMoveStep(IN UINT i,
                                      OUT BOOL* pbCanContinue,
                                      OUT CString& strrefPath,
                                      OUT CString& strrefClass)
{
  ASSERT(m_spDSDestination != NULL);

  if (pbCanContinue == NULL)
  {
    return E_POINTER;
  }

  UINT nCount = GetItemCount();

  //
  // Initialize out parameters
  //
  GetItemPath(i, strrefPath);
  strrefClass = GetItemClass(i);
  *pbCanContinue = TRUE;
  
  if (strrefPath == m_szDestPath)
  {
    return S_OK;
  }

  // try to execute the move
  CString szNewPath;

  CComPtr<IDispatch> spDSTargetIDispatch;
  GetNewPath(i, szNewPath);
  HRESULT hr = m_spDSDestination->MoveHere((LPWSTR)(LPCWSTR)szNewPath,
                                  NULL,
                                  &spDSTargetIDispatch);
  
  if (FAILED(hr))
  {
    CString szName;
    GetName(i, szName);
    if (nCount == 1)
    {
      *pbCanContinue = _ReportFailure((i == nCount-1), hr, szName);
    }
  }
  else
  {
    // all went fine, notify extensions
    GetTransaction()->Notify(i);

    // give a chance to update UI (e.g. cookies)
    CComPtr<IADs> spIADsTarget;
    hr = spDSTargetIDispatch->QueryInterface (IID_IADs,
                                      (void **)&spIADsTarget);

    hr = OnItemMoved(i, spIADsTarget);
  }
  return hr;
}


void BuildBrowseQueryString(LPCWSTR lpszSchemaNamingContext, BOOL bAdvancedView,
                            CString& szQueryString)
{
  // allowed list of container classes
  static LPCWSTR lpszAllowedContainers[] = 
  {
    L"Organizational-Unit",
    L"Builtin-Domain",
    L"Lost-And-Found",
    L"container",
    NULL // end of table
  };

  CString sz = L"(|";
  for (int k=0; lpszAllowedContainers[k] != NULL; k++)
  {
    sz += L"(ObjectCategory=CN=";
    sz += lpszAllowedContainers[k];
    sz += L",";
    sz += lpszSchemaNamingContext;
    sz += L")";
  }
  sz += L")";

	if( bAdvancedView ) 
  {
    szQueryString = sz;
	}
  else
  {
    szQueryString.Format(L"(&%s(!showInAdvancedViewOnly=TRUE))", (LPCWSTR)sz);
  }
}



int BrowseCallback(HWND, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
  switch (uMsg) 
  {
  case DSBM_HELP:
    {
      TRACE(L"Browse Callback: msg is DSBM_HELP.\n");
      LPHELPINFO pHelp = (LPHELPINFO) lParam;
      TRACE(_T("CtrlId = %d, ContextId = 0x%x\n"),
            pHelp->iCtrlId, pHelp->dwContextId);
      if (pHelp->iCtrlId != DSBID_CONTAINERLIST)  {
        return 0; // not handled
      }
      ::WinHelp((HWND)pHelp->hItemHandle,
                DSADMIN_CONTEXT_HELP_FILE,
                HELP_WM_HELP,
                (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_BROWSE_CONTAINER); 
    }
    break;
  case DSBM_GETBROWSEDATA:
    {
      // called to change the LDAP query string
      TRACE(L"Browse Callback: msg is DSBM_HELP.\n");
      CDSComponentData* pCD = (CDSComponentData*)lpData;

      if ( (pCD == NULL) || (SNAPINTYPE_SITE == pCD->QuerySnapinType()) ||
            pCD->ExpandComputers() )
      {
        // if we are in site and repl we do not change the default
        // string because we do not have too many objects

        // if we expand computer, users, etc, we do not really
        // have a choice but allow (objectClass=*)
        TRACE(L"Browse Callback: DSBM_HELP, leave the default setting.\n");

        return 0; // just leave the default setting
      }

      DSBROWSEDATA* pdbd = (DSBROWSEDATA*)lParam;

      TRACE(L"pdbd->pszFilter = %s\n", pdbd->pszFilter);
      TRACE(L"pdbd->cchFilter = %d\n", pdbd->cchFilter);

      TRACE(L"pdbd->pszNameAttribute = %s\n", pdbd->pszNameAttribute);
      TRACE(L"pdbd->cchNameAttribute = %d\n", pdbd->cchNameAttribute);

       // need to change query string
      CString szQueryString;
      FilterElementStruct* pFilterElementStructDrillDown = &g_filterelementDsAdminHardcoded;
      BuildFilterElementString(szQueryString, pFilterElementStructDrillDown,
                               pCD->GetBasePathsInfo()->GetSchemaNamingContext());

      szQueryString = L"(|" + szQueryString + L")";
      /*
      BuildBrowseQueryString(pCD->GetBasePathsInfo()->GetSchemaNamingContext(),
                             pCD->IsAdvancedView(), szQueryString);
      */
      // copy over the new filter
      int nNewFilterLen = szQueryString.GetLength();
      ASSERT(nNewFilterLen < pdbd->cchFilter);
      if (nNewFilterLen >= pdbd->cchFilter)
      {
        return 0; // failed, filter string too long
      }

      wcscpy(pdbd->pszFilter, szQueryString);
      pdbd->cchFilter = nNewFilterLen;
      TRACE(L"New pdbd->pszFilter = %s\n", pdbd->pszFilter);
      TRACE(L"New pdbd->cchFilter = %d\n", pdbd->cchFilter);

    }
    break;
  } // switch

  return 1; // handled
}

HRESULT CMoveHandlerBase::_BrowseForDestination(LPCWSTR lpszDestinationPath) 

{
  m_spDSDestination = NULL;
  m_szDestPath.Empty();
  m_szDestClass.Empty();
  
  // check if we have to expand computers in the Browse for container UI
  CDSComponentData* pCD = GetComponentData();
  BOOL bExpandComputers = FALSE;
  if (pCD != NULL) 
  {
    bExpandComputers = pCD->ExpandComputers();
  }

  // determine if we have to show the Browse for container dialog
  CString strTargetContainer;

  if (lpszDestinationPath != NULL)
  {
    // we have the target container already, no need to
    // bring up UI
    strTargetContainer = lpszDestinationPath;
  }
  else
  {
    // no container, need Browse dialog
    CString strClassOfMovedItem;
    GetClassOfMovedItem(strClassOfMovedItem);
    if (0 == strClassOfMovedItem.CompareNoCase(L"server")) 
    {
      HICON hIcon = NULL;
      if (pCD != NULL)
      {
         MyBasePathsInfo* pBasePathsInfo = pCD->GetBasePathsInfo();
         ASSERT(pBasePathsInfo != NULL);
         hIcon = pBasePathsInfo->GetIcon(const_cast<LPTSTR>(gsz_site),
                                 DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON | DSGIF_DEFAULTISCONTAINER,
                                 16, 16);
      }
      CMoveServerDialog dlg( m_lpszBrowseRootPath, hIcon, CWnd::FromHandle(GetParentHwnd()) );
      INT_PTR result = dlg.DoModal();
      if (IDCANCEL == result)
        return S_FALSE;
      strTargetContainer = dlg.m_strTargetContainer;
    } 
    else 
    {
      PWSTR pszPath = new WCHAR[INTERNET_MAX_URL_LENGTH * 4];
      if (!pszPath)
      {
         return E_OUTOFMEMORY;
      }

      pszPath[0] = TEXT('\0');

      CString strTitle;
      strTitle.LoadString (IDS_MOVE_TITLE);

      DSBROWSEINFO dsbi;
      ::ZeroMemory( &dsbi, sizeof(dsbi) );

      CString str;
      str.LoadString(IDS_MOVE_TARGET);

      dsbi.hwndOwner = GetParentHwnd();
      // CODEWORK: Get DsBrowseForContainer to take const strings  
      dsbi.cbStruct = sizeof (DSBROWSEINFO);
      dsbi.pszCaption = (LPWSTR)((LPCWSTR)strTitle); // this is actually the caption
      dsbi.pszTitle = (LPWSTR)((LPCWSTR)str);
      dsbi.pszRoot = (LPWSTR)m_lpszBrowseRootPath;
      dsbi.pszPath = pszPath;
      dsbi.cchPath = INTERNET_MAX_URL_LENGTH * 4;
      dsbi.dwFlags = DSBI_RETURN_FORMAT |
        DSBI_EXPANDONOPEN;
      if( pCD && pCD->IsAdvancedView() ) 
      {
	      dsbi.dwFlags |= DSBI_INCLUDEHIDDEN;
      }
      if (bExpandComputers) 
      {
        dsbi.dwFlags |= DSBI_IGNORETREATASLEAF;
      }
      dsbi.pfnCallback = BrowseCallback;
      dsbi.lParam = (LPARAM)pCD;
      dsbi.dwReturnFormat = ADS_FORMAT_X500;
  
      DWORD result = DsBrowseForContainer( &dsbi ); // returns -1, 0, IDOK or IDCANCEL
      if (result != IDOK)
      {
        if (pszPath)
        {
           delete[] pszPath;
           pszPath = 0;
        }
        return S_FALSE; // canceled by user
      }
      strTargetContainer = dsbi.pszPath;

      if (pszPath)
      {
        delete[] pszPath;
        pszPath = 0;
      }
    } // class is not server
  } // have target container

  if ( strTargetContainer.IsEmpty() ) // ADSI doesn't like this
  {
    ASSERT(FALSE);
    return S_FALSE;
  }

  // try to open the target container
  CComPtr<IADsContainer> spDSDestination;
  HRESULT hr = DSAdminOpenObject(strTargetContainer,
                                 IID_IADsContainer,
                                 (void **)&spDSDestination,
                                 FALSE /*bServer*/);

  if (FAILED(hr))
  {
    CPathCracker pathCracker;
    pathCracker.Set(const_cast<LPTSTR>((LPCTSTR)strTargetContainer),
                       ADS_SETTYPE_FULL);
    pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
    CComBSTR DestName;
    pathCracker.GetElement( 0, &DestName );
    PVOID apv[1] = {(BSTR)DestName};
    ReportErrorEx(GetParentHwnd(),IDS_12_CONTAINER_NOT_FOUND,hr,
                   MB_OK | MB_ICONERROR, apv, 1);

    return hr;
  }

  // need the class of the destination container
  CComPtr<IADs> spIADs;
  hr = spDSDestination->QueryInterface(IID_IADs, (void**)&spIADs);
  if (FAILED(hr))
  {
    ASSERT(FALSE);
    return hr;
  }
  CComBSTR bstrClass;
  hr = spIADs->get_Class(&bstrClass);
  if (FAILED(hr))
  {
    ASSERT(FALSE);
    return hr;
  }

  // all went well, copy the output parameters
  m_spDSDestination = spDSDestination;
  m_szDestPath = strTargetContainer;
  m_szDestClass = bstrClass;
  m_bDestContainer = TRUE; // we do a move, it must be one
  return hr;
}

BOOL CMoveHandlerBase::_BeginTransactionAndConfirmOperation()
{
  // start the transaction
  HRESULT hr = BeginTransaction();
  ASSERT(SUCCEEDED(hr));
  // if needed, confirm
  if (GetTransaction()->NeedNotifyCount() > 0)
  {
    CString szMessage;
    CString szAssocData;
    UINT nCount = GetItemCount();
    if (nCount == 1)
    {
      szMessage.LoadString(IDS_CONFIRM_MOVE);
      szAssocData.LoadString(IDS_EXTENS_SINGLE_MOVE);
    }
    else
    {
      CString szMessageFormat;
      szMessageFormat.LoadString(IDS_CONFIRM_MULTIPLE_MOVE);
      szMessage.Format(szMessageFormat, nCount); 
      szAssocData.LoadString(IDS_EXTENS_MULTIPLE_MOVE);
    }
    CConfirmOperationDialog dlg(GetParentHwnd(), GetTransaction());
    dlg.SetStrings(szMessage, szAssocData);

    if (IDNO == dlg.DoModal())
    {
      GetTransaction()->End();
      return FALSE;
    }
  }
  return TRUE;
}

///////////////////////////////////////////////////////////////
// IsHomogenousDSSelection
//
// pDataObject must support the DSAdmin internal clipboard format
// 
// if the return value is true, szClassName will be the name of 
// the class of the homogenous selection
//
BOOL IsHomogenousDSSelection(LPDATAOBJECT pDataObject, CString& szClassName)
{
  BOOL bHomogenous = TRUE;
  szClassName = L"";

  if (pDataObject == NULL)
  {
    ASSERT(FALSE);
    return FALSE;
  }

  CInternalFormatCracker ifc;
  HRESULT hr = ifc.Extract(pDataObject);
  if (FAILED(hr))
  {
    ASSERT(FALSE);
    return FALSE;
  }

  CUINode* pUINode = ifc.GetCookie();
  ASSERT(pUINode != NULL);

  CDSUINode* pDSUINode = dynamic_cast<CDSUINode*>(pUINode);
  if (pDSUINode == NULL)
  {
    ASSERT(FALSE);
    return FALSE;
  }

  CDSCookie* pCookie = GetDSCookieFromUINode(pDSUINode);
  if (pCookie == NULL)
  {
    ASSERT(FALSE);
    return FALSE;
  }

  szClassName = pCookie->GetClass();
  ASSERT(!szClassName.IsEmpty());

  for (UINT idx = 1; idx < ifc.GetCookieCount(); idx++)
  {
    CUINode* pSelectedUINode = ifc.GetCookie(idx);
    ASSERT(pSelectedUINode);

    CDSUINode* pSelectedDSUINode = dynamic_cast<CDSUINode*>(pSelectedUINode);
    if (!pSelectedDSUINode)
    {
      bHomogenous = FALSE;
      break;
    }

    CDSCookie* pSelectedCookie = GetDSCookieFromUINode(pSelectedDSUINode);
    if (!pSelectedCookie)
    {
      ASSERT(FALSE);
      bHomogenous = FALSE;
      break;
    }

    if (wcscmp(szClassName, pSelectedCookie->GetClass()) != 0)
    {
      bHomogenous = FALSE;
      break;
    }
  }

  if (!bHomogenous)
  {
    szClassName = L"";
  }
  return bHomogenous;
}

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// Temporary Tab Collector stuff
//

//+----------------------------------------------------------------------------
//
//  Function:   AddPageProc
//
//  Synopsis:   The IShellPropSheetExt->AddPages callback.
//
//-----------------------------------------------------------------------------
BOOL CALLBACK AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall)
{
    TRACE(_T("xx.%03x> AddPageProc()\n"), GetCurrentThreadId());

    HRESULT hr;

    hr = ((LPPROPERTYSHEETCALLBACK)pCall)->AddPage(hPage);

    return hr == S_OK;
}


HRESULT GetDisplaySpecifierProperty(PCWSTR pszClassName,
                                    PCWSTR pszDisplayProperty,
                                    MyBasePathsInfo* pBasePathsInfo,
                                    CStringList& strListRef,
                                    bool bEnglishOnly)
{
  HRESULT hr = S_OK;

  //
  // Validate parameters
  // Note : pszClassName can be NULL and will retrieve the default-Display values
  //
  if (pszDisplayProperty == NULL ||
      pBasePathsInfo == NULL)
  {
    ASSERT(FALSE);
    return E_POINTER;
  }

  CComPtr<IADs> spIADs;
  if (!bEnglishOnly)
  {
    hr = pBasePathsInfo->GetDisplaySpecifier(pszClassName, IID_IADs, (PVOID*)&spIADs);
  }
  else
  {
    //
    // Build the path to the English display specifier container
    //
    CString szConfigDN = pBasePathsInfo->GetConfigNamingContext();
    CString szEnglishDisplaySpecifierDN = L"CN=409,CN=DisplaySpecifiers," + szConfigDN;
    CString szDisplayObjectDN = L"CN=" + CString(pszClassName) + L"-Display," + szEnglishDisplaySpecifierDN;

    CString szDisplayObjectPath;
    pBasePathsInfo->ComposeADsIPath(szDisplayObjectPath, szDisplayObjectDN);

    //
    // Open the object and get the property
    //
    hr = DSAdminOpenObject(szDisplayObjectPath,
                           IID_IADs,
                           (void**)&spIADs,
                           true);
  }
  if (SUCCEEDED(hr) && !!spIADs)
  {
    CComVariant var;
    hr = spIADs->Get((LPWSTR)pszDisplayProperty, &var);
    if (SUCCEEDED(hr))
    {
      hr = HrVariantToStringList(var, strListRef);
    }
  }
  return hr;
}

HRESULT TabCollect_GetDisplayGUIDs(LPCWSTR lpszClassName,
                                   LPCWSTR lpszDisplayProperty,
                                   MyBasePathsInfo* pBasePathsInfo,
                                   UINT*   pnCount,
                                   GUID**  ppGuids)
{
  HRESULT hr = S_OK;

  //
  // This should bind to the display specifiers, get the specified property and
  // sort the guids by ordered pairs and return the guids
  //
  if (pBasePathsInfo == NULL)
  {
    *pnCount = 0;
    *ppGuids = NULL;
    return E_FAIL;
  }

  CStringList szPropertyList;
  
  hr = GetDisplaySpecifierProperty(lpszClassName, lpszDisplayProperty, pBasePathsInfo, szPropertyList);
  if (FAILED(hr))
  {
    *pnCount = 0;
    *ppGuids = NULL;
    return hr;
  }

  if (szPropertyList.GetCount() < 1)
  {
    //
    // Couldn't find anything for the class, try to find something in the default-Display
    //
    hr = GetDisplaySpecifierProperty(L"default", lpszDisplayProperty, pBasePathsInfo, szPropertyList);
    if (FAILED(hr))
    {
      //
      // If still nothing is found revert to the English display specifiers
      //
      hr = GetDisplaySpecifierProperty(lpszClassName, lpszDisplayProperty, pBasePathsInfo, szPropertyList, true);
      if (FAILED(hr))
      {
        *pnCount = 0;
        *ppGuids = NULL;
        return hr;
      }
      if (szPropertyList.GetCount() < 1)
      {
        //
        // Now try the English default
        //
        hr = GetDisplaySpecifierProperty(L"default", lpszDisplayProperty, pBasePathsInfo, szPropertyList, true);
        if (FAILED(hr))
        {
          *pnCount = 0;
          *ppGuids = NULL;
          return hr;
        }
      }
    }
  }

  *pnCount = static_cast<UINT>(szPropertyList.GetCount());
  *ppGuids = new GUID[*pnCount];
  if (*ppGuids == NULL)
  {
    *pnCount = 0;
    *ppGuids = NULL;
    return hr;
  }

  int* pnIndex = new int[*pnCount];
  if (pnIndex == NULL)
  {
    *pnCount = 0;
    *ppGuids = NULL;
    return hr;
  }

  CString szIndex;
  CString szGUID;
  UINT itr = 0;

  POSITION pos = szPropertyList.GetHeadPosition();
  while (pos != NULL)
  {
    CString szItem = szPropertyList.GetNext(pos);

    int nComma = szItem.Find(L",");
    if (nComma == -1)
      continue;

    szIndex = szItem.Left(nComma);
    int nIndex = _wtoi((LPCWSTR)szIndex);
    if (nIndex <= 0)
      continue; // allow from 1 up

    // strip leading and traling blanks
    szGUID = szItem.Mid(nComma+1);
    szGUID.TrimLeft();
    szGUID.TrimRight();

    GUID guid;
    hr = ::CLSIDFromString((LPWSTR)(LPCWSTR)szGUID, &guid);
    if (SUCCEEDED(hr))
    {
      (*ppGuids)[itr] = guid;
      pnIndex[itr] = nIndex;
      itr++;
    }
  }

  //
  // Must sort the page list
  //
  while (TRUE)
  {
    BOOL bSwapped = FALSE;
    for (UINT k=1; k < *pnCount; k++)
    {
      if (pnIndex[k] < pnIndex[k-1])
      {
        // swap
        int nTemp = pnIndex[k];
        pnIndex[k] = pnIndex[k-1];
        pnIndex[k-1] = nTemp;
        GUID temp = *ppGuids[k];
        *ppGuids[k] = *ppGuids[k-1];
        *ppGuids[k-1] = temp;
        bSwapped = TRUE;
      }
    }

    if (!bSwapped)
    {
      break;
    }
  }

  //
  // Cleanup the index array
  //
  if (pnIndex != NULL)
  {
    delete[] pnIndex;
  }
  return hr;
}

//**********************************************************************

// Test code to improve the search process on cookies

BOOL _SearchTreeForCookie(IN CUINode* pContainerNode, // current container where to start the search
                           IN CPathCracker* pPathCracker, // path cracker with the tokenized search path
                           IN long nCurrentToken, // current token in the path cracker
                           IN BOOL bSearchSubcontainers, // flag to search subcontainers
                           OUT CUINode** ppUINode // returned node
                           )
{
  ASSERT(pContainerNode != NULL);
  ASSERT(pContainerNode->IsContainer());

  long nPathElements = 0;
  pPathCracker->GetNumElements(&nPathElements);

  if (nCurrentToken >= nPathElements)
  {
    // ran out of tokens to compare
    return FALSE;
  }

  CComBSTR bstrCurrentToken;
  pPathCracker->GetElement(nCurrentToken, &bstrCurrentToken);
  

  // decide which list to look into
  CUINodeList* pNodeList =  NULL;
  if (bSearchSubcontainers)
    pNodeList = pContainerNode->GetFolderInfo()->GetContainerList();
  else
    pNodeList = pContainerNode->GetFolderInfo()->GetLeafList();


  CPathCracker pathCrackerCurr;

  for (POSITION pos = pNodeList->GetHeadPosition(); pos != NULL; )
  {
    CUINode* pCurrentNode = pNodeList->GetNext(pos);
    if (!IS_CLASS(*pCurrentNode, CDSUINode))
    {
      // not a node with a cookie, just skip
      continue;
    }

    // get the cookie from the node
    CDSCookie* pCurrentCookie = GetDSCookieFromUINode(pCurrentNode);

    // build the naming token (leaf element of the path), e.g. "CN=foo"
    CComBSTR bstrCurrentNamingToken;
    pathCrackerCurr.Set((BSTR)pCurrentCookie->GetPath(), ADS_SETTYPE_DN);
    pathCrackerCurr.GetElement(0, &bstrCurrentNamingToken);
   
    
    // compare the current naming token with the current search token
    TRACE(L"comparing bstrCurrentToken = %s, bstrCurrentNamingToken = %s\n", 
                      bstrCurrentToken, bstrCurrentNamingToken);

    if (_wcsicmp(bstrCurrentToken, bstrCurrentNamingToken) == 0)
    {
      // the token matches, need to see if we are at the end of the
      // list of tokens
      if (nCurrentToken == 0)
      {
        *ppUINode = pCurrentNode;
        return TRUE; // got it!!!
      }
      else
      {
        // we match, but we have to go one level deeper
        BOOL bFound = FALSE;
        if (nCurrentToken == 1)
        {
          // try on leaf nodes, we are at the last level
          bFound = _SearchTreeForCookie(pCurrentNode, pPathCracker, nCurrentToken-1, FALSE, ppUINode);
        }
        
        if (bFound)
          return TRUE;
        
        // try on subcontainers
        return _SearchTreeForCookie(pCurrentNode, pPathCracker, nCurrentToken-1, TRUE, ppUINode);
      }
    }

    // if no match, we keep scanning at this level
  } // for

  return FALSE; // not found
}


BOOL FindCookieInSubtree(IN CUINode* pContainerNode, 
                          IN LPCWSTR lpszCookieDN,
                          IN SnapinType snapinType,
                          OUT CUINode** ppUINode)
{
  *ppUINode = NULL;


  if (!pContainerNode->IsContainer())
  {
    // not the right type of node
    return FALSE;
  }


  LPCWSTR lpszStartingContainerPath = NULL;
  long nAdjustLevel = 0;
  if (IS_CLASS(*pContainerNode, CDSUINode) )
  {
    lpszStartingContainerPath = dynamic_cast<CDSUINode*>(pContainerNode)->GetCookie()->GetPath();
    nAdjustLevel = 1;
  }
  else if (IS_CLASS(*pContainerNode, CRootNode) )
  {
    lpszStartingContainerPath = dynamic_cast<CRootNode*>(pContainerNode)->GetPath();
    if (snapinType == SNAPINTYPE_SITE)
    {
      nAdjustLevel = 1;
    }
  }

  if (lpszStartingContainerPath == NULL)
  {
    // bad node type
    return FALSE;
  }

  // instantiate a path cracker for the DN we are in search of
  CPathCracker pathCrackerDN;
  HRESULT hr = pathCrackerDN.Set((BSTR)lpszCookieDN, ADS_SETTYPE_DN);

  long nPathElementsDN = 0;
  hr = pathCrackerDN.GetNumElements(&nPathElementsDN);

  if ( FAILED(hr) || (nPathElementsDN <= 0) )
  {
    // bad path
    ASSERT(FALSE);
    return FALSE;
  }

  // instantiate a path cracker for the container node
  CPathCracker pathCrackerStartingContainer;
  pathCrackerStartingContainer.Set((BSTR)lpszStartingContainerPath, ADS_SETTYPE_DN);
  long nPathElementsStartingContainer = 0;
  pathCrackerStartingContainer.GetNumElements(&nPathElementsStartingContainer);

  if ( FAILED(hr) || (nPathElementsStartingContainer <= 0) )
  {
    // bad path
    ASSERT(FALSE);
    return FALSE;
  }

  // compute the level where we start the search from
  long nStartToken = nPathElementsDN - nPathElementsStartingContainer - nAdjustLevel;
  if ( nStartToken < 0)
  {
    return FALSE;
  }
  if (( nStartToken == 0) && (nAdjustLevel == 1) && snapinType != SNAPINTYPE_SITE)
  {
    return FALSE;
  }

  return _SearchTreeForCookie(pContainerNode, &pathCrackerDN, nStartToken /*current token*/, TRUE, ppUINode);
}


//**********************************************************************

///////////////////////////////////////////////////////////////////////////
// CMultiselectMoveDataObject


// helper function for CDSEvent::_Paste()
// to create a data object containing the successfully pasted items
HRESULT CMultiselectMoveDataObject::BuildPastedDataObject(
               IN CObjectNamesFormatCracker* pObjectNamesFormatPaste,
               IN CMultiselectMoveHandler* pMoveHandler,
               IN CDSComponentData* pCD,
               OUT IDataObject** ppSuccesfullyPastedDataObject)
{
  // verify input parameters
  if (ppSuccesfullyPastedDataObject == NULL)
  {
    return E_INVALIDARG;
  }

  *ppSuccesfullyPastedDataObject = NULL;
  
  if ((pObjectNamesFormatPaste == NULL) || (pMoveHandler == NULL) )
  {
    return E_INVALIDARG;
  }


  //
  // need to build a data object and hang on to it
  //
  CComObject<CMultiselectMoveDataObject>* pObject;

  CComObject<CMultiselectMoveDataObject>::CreateInstance(&pObject);
  if (pObject == NULL)
  {
    return E_OUTOFMEMORY;
  }


  HRESULT hr = pObject->FinalConstruct();
  if (FAILED(hr))
  {
    delete pObject;
    return hr;
  }

  hr = pObject->Init(pObjectNamesFormatPaste, pMoveHandler, pCD);
  if (FAILED(hr))
  {
    delete pObject;
    return hr;
  }

  hr = pObject->QueryInterface(IID_IDataObject,
                               reinterpret_cast<void**>(ppSuccesfullyPastedDataObject));
  if (FAILED(hr))
  {
    //
    // delete object by calling Release() 
    //
    (*ppSuccesfullyPastedDataObject)->Release();
    (*ppSuccesfullyPastedDataObject) = NULL; 
  }
  return hr;
}





CLIPFORMAT CMultiselectMoveDataObject::m_cfDsObjectNames = 
                                (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);


STDMETHODIMP CMultiselectMoveDataObject::GetData(FORMATETC * pFormatEtc, STGMEDIUM * pMedium)
{
  if ((pFormatEtc == NULL) || (pMedium == NULL))
  {
    return E_INVALIDARG;
  }
  if (IsBadWritePtr(pMedium, sizeof(STGMEDIUM)))
  {
    return E_INVALIDARG;
  }
  if (!(pFormatEtc->tymed & TYMED_HGLOBAL))
  {
    return DV_E_TYMED;
  }

  // we support only one clipboard format
  pMedium->tymed = TYMED_HGLOBAL;
  pMedium->pUnkForRelease = NULL;
  if (pFormatEtc->cfFormat != m_cfDsObjectNames)
  {
    return DV_E_FORMATETC;
  }

  // make a deep copy of the cached data
  pMedium->hGlobal = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                      m_nDSObjCachedBytes);
  if (pMedium->hGlobal == NULL)
  {
    return E_OUTOFMEMORY;
  }
  memcpy(pMedium->hGlobal, m_pDSObjCached, m_nDSObjCachedBytes);
  pMedium->tymed = TYMED_HGLOBAL;
  pMedium->pUnkForRelease = NULL;

  return S_OK;
}


HRESULT CMultiselectMoveDataObject::Init(
               IN CObjectNamesFormatCracker* pObjectNamesFormatPaste,
               IN CMultiselectMoveHandler* pMoveHandler,
               IN CDSComponentData* pCD)
{
  _Clear();



  // figure out how much storage we need

  //
  // this loop is to calc how much storage we need.
  //
  UINT nPasteCount = pObjectNamesFormatPaste->GetCount();
  UINT nSuccessfulPasteCount = 0;
  size_t cbStorage = 0;
  for (UINT i=0; i<nPasteCount; i++)
  {
    if (pMoveHandler->WasItemMoved(i))
    {
      nSuccessfulPasteCount++;
      cbStorage += (wcslen(pObjectNamesFormatPaste->GetClass(i)) + 1 +
                    wcslen(pObjectNamesFormatPaste->GetName(i)) + 1) * sizeof(WCHAR);
    }
  }

  if (nSuccessfulPasteCount == 0)
  {
    // no items were successfully pasted
    return E_INVALIDARG;
  }

  // NOTICE: contains already a DSOBJECT embedded struct, so we subtract 1
  DWORD cbStruct = sizeof(DSOBJECTNAMES) + 
    ((nSuccessfulPasteCount - 1) * sizeof(DSOBJECT));

  //
  // Allocate the needed storage
  //
  m_pDSObjCached = (LPDSOBJECTNAMES)malloc(cbStruct + cbStorage);
  
  if (m_pDSObjCached == NULL)
  {
    return E_OUTOFMEMORY;
  }
  m_nDSObjCachedBytes = static_cast<ULONG>(cbStruct + cbStorage);

  switch (pCD->QuerySnapinType())
  {
    case SNAPINTYPE_DS:
      m_pDSObjCached->clsidNamespace = CLSID_DSSnapin;
      break;
    case SNAPINTYPE_SITE:
      m_pDSObjCached->clsidNamespace = CLSID_SiteSnapin;
      break;
    default:
      m_pDSObjCached->clsidNamespace = CLSID_NULL;
  }

  m_pDSObjCached->cItems = nSuccessfulPasteCount;
  DWORD NextOffset = cbStruct;
  UINT index = 0;
  for (i=0; i<nPasteCount; i++)
  {
    if (pMoveHandler->WasItemMoved(i))
    {
      //
      // Set the data from the node and node data
      //

      size_t nNameLen = wcslen(pObjectNamesFormatPaste->GetName(i));
      size_t nClassLen = wcslen(pObjectNamesFormatPaste->GetClass(i));

      ASSERT((nNameLen > 0) && (nClassLen > 0));

      m_pDSObjCached->aObjects[index].dwFlags = pObjectNamesFormatPaste->IsContainer(i) ? DSOBJECT_ISCONTAINER : 0;
      m_pDSObjCached->aObjects[index].dwProviderFlags = (pCD->IsAdvancedView()) ?
        DSPROVIDER_ADVANCED : 0;
      m_pDSObjCached->aObjects[index].offsetName = NextOffset;
      m_pDSObjCached->aObjects[index].offsetClass = static_cast<ULONG>(NextOffset + 
        (nNameLen + 1) * sizeof(WCHAR));

      _tcscpy((LPTSTR)((BYTE *)m_pDSObjCached + NextOffset), pObjectNamesFormatPaste->GetName(i));
      NextOffset += static_cast<ULONG>((nNameLen + 1) * sizeof(WCHAR));

      _tcscpy((LPTSTR)((BYTE *)m_pDSObjCached + NextOffset), pObjectNamesFormatPaste->GetClass(i));
      NextOffset += static_cast<ULONG>((nClassLen + 1) * sizeof(WCHAR));

      index++;
    } // if
  } // for
  return S_OK;
}

void EscapeFilterElement(PCWSTR pszElement, CString& refszEscapedElement)
{
  // do LDAP escaping (as per RFC 2254)
  for (const WCHAR* pChar = pszElement; (*pChar) != NULL; pChar++)
  {
    switch (*pChar)
    {
    case L'*':
      refszEscapedElement += L"\\2a";
      break;
    case L'(':
      refszEscapedElement += L"\\28";
      break;
    case L')':
      refszEscapedElement += L"\\29";
      break;
    case L'\\':
      refszEscapedElement += L"\\5c";
      break;
    default:
      refszEscapedElement += (*pChar);
    } // switch
  } // for
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dsutil.h
//
//--------------------------------------------------------------------------

#ifndef __DSUTIL_H_
#define __DSUTIL_H_

#include "util.h"
#include "uiutil.h"
#include "dssnap.h"
#include "query.h"

//
// Common DS strings
//
extern PCWSTR g_pszAllowedAttributesEffective;
extern PCWSTR g_pszPwdLastSet;

HRESULT DSAdminOpenObject(PCWSTR pszPath, 
                          REFIID refIID, 
                          PVOID* ppInterface, 
                          BOOL bServer = FALSE);

/////////////////////////////////////////////////////////////////////////////////
// ADSI path helpers
//
HRESULT GetServerFromLDAPPath(IN LPCWSTR lpszLdapPath, OUT BSTR* pbstrServerName);

BOOL StripADsIPath(LPCWSTR lpszPath, CString& strref, bool bUseEscapedMode = true);

// remove escape characters from a path
// Arguments:
//    lpszPath = path to be escaped
//    bDN = if TRUE, the path os a distinguished name, if FALSE is an LDAP path
//    bstrUnescaped = returned unescaped path
//
inline HRESULT UnescapePath(IN LPCWSTR lpszPath, IN BOOL bDN, OUT CComBSTR& bstrUnescaped)
{
  CPathCracker pathCracker;

  pathCracker.Set((LPWSTR)lpszPath, bDN ? ADS_SETTYPE_DN : ADS_SETTYPE_FULL);
  pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF);

  bstrUnescaped = (LPCWSTR)NULL;
  HRESULT hr = pathCracker.Retrieve(bDN ? ADS_FORMAT_X500_DN : ADS_FORMAT_X500, &bstrUnescaped);
  return hr;
}

class CObjectNamesFormatCracker; // fwd decl

HRESULT AddDataObjListToGroup(CObjectNamesFormatCracker * pNames,
                               HWND hwnd,
                               CDSComponentData* pComponentData);

HRESULT AddDataObjListToGivenGroup(CObjectNamesFormatCracker * pNames,
                                    LPCWSTR lpszGroup,
                                    LPCWSTR lpszGroupName,
                                    HWND hwnd,
                                    CDSComponentData* pComponentData);


BOOL IsValidSiteName( LPCTSTR lpctszSiteName, BOOL* pfNonRfc = NULL );
BOOL IsLocalLogin( void );
BOOL IsThisUserLoggedIn( LPCTSTR pwszUserDN );

BOOL CALLBACK AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall);
BOOL IsHomogenousDSSelection(LPDATAOBJECT pDataObject, CString& szClassName);
BOOL CALLBACK AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCall);
HRESULT GetDisplaySpecifierProperty(PCWSTR pszClassName,
                                    PCWSTR pszDisplayProperty,
                                    MyBasePathsInfo* pBasePathsInfo,
                                    CStringList& strListRef,
                                    bool bEnglishOnly = false);

HRESULT TabCollect_GetDisplayGUIDs(LPCWSTR lpszClassName,
                                        LPCWSTR lpszDisplayProperty,
                                        MyBasePathsInfo* pBasePathsInfo,
                                        UINT*   pnCount,
                                        GUID**  ppGuids);


BOOL FindCookieInSubtree(IN CUINode* pContainerNode, 
                          IN LPCWSTR lpszCookieDN,
                          IN SnapinType snapinType,
                          OUT CUINode** ppUINode);

bool CanUserChangePassword(IN IDirectoryObject* pDirObject);

/////////////////////////////////////////////////////////////////////
// CChangePasswordPrivilegeAction

// helper class to handle the revoking and the reading of the
// change password control right on user objects

class CChangePasswordPrivilegeAction
{
public:
   CChangePasswordPrivilegeAction() : m_pDacl(NULL)
  {
  }

  HRESULT Load(IADs * pIADs);
  HRESULT Read(BOOL* pbPasswordCannotChange);
  HRESULT Revoke();

private:
  HRESULT _SetSids();

  CComBSTR m_bstrObjectLdapPath;

  CSimpleSecurityDescriptorHolder m_SDHolder;
  PACL m_pDacl;
  CSidHolder m_SelfSid;
  CSidHolder m_WorldSid;
};


/////////////////////////////////////////////////////////////////////
// CDSNotifyHandlerTransaction

class CDSNotifyHandlerManager; // fwd decl
class CDSComponentData;

class CDSNotifyHandlerTransaction
{
public:
  CDSNotifyHandlerTransaction(CDSComponentData* pCD);
  ~CDSNotifyHandlerTransaction()
  {
    if (m_bStarted)
      End();
  }

  void SetEventType(ULONG uEvent) 
  { 
    ASSERT(m_uEvent == 0);
    ASSERT(uEvent != 0);
    m_uEvent = uEvent;
  }

  // state veriables check
  UINT NeedNotifyCount();

  // handlers for visualization in confirnation dialog
  void SetCheckListBox(CCheckListBox* pCheckListBox);
  void ReadFromCheckListBox(CCheckListBox* pCheckListBox);

  // interfaces for transacted protocol
  HRESULT Begin(LPCWSTR lpszArg1Path, LPCWSTR lpszArg1Class, BOOL bArg1Cont,
             LPCWSTR lpszArg2Path, LPCWSTR lpszArg2Class, BOOL bArg2Cont);
  HRESULT Begin(CDSCookie* pArg1Cookie, 
             LPCWSTR lpszArg2Path, LPCWSTR lpszArg2Class, BOOL bArg2Cont);
  HRESULT Begin(IDataObject* pArg1, 
             LPCWSTR lpszArg2Path, LPCWSTR lpszArg2Class, BOOL bArg2Cont);

  void Notify(ULONG nItem); 
  void End();

  static HRESULT BuildTransactionDataObject(LPCWSTR lpszArgPath, 
                           LPCWSTR lpszArgClass,
                           BOOL bContainer,
                           CDSComponentData* pCD,
                           IDataObject** ppArg);
private:

  HRESULT _BuildDataObject(LPCWSTR lpszArgPath, 
                           LPCWSTR lpszArgClass,
                           BOOL bContainer,
                           IDataObject** ppArg);

  BOOL m_bStarted;
  CDSComponentData* m_pCD;
  CDSNotifyHandlerManager* m_pMgr;
  ULONG m_uEvent;

  CComPtr<IDataObject> m_spArg1;
  CComPtr<IDataObject> m_spArg2;

};



///////////////////////////////////////////////////////////////////////////
// CUIOperationHandlerBase

class CUIOperationHandlerBase
{
public:
  CUIOperationHandlerBase(CDSComponentData* pComponentData, HWND hwnd)
    : m_transaction(pComponentData)
  {
    m_pComponentData = pComponentData;
    m_hWndFrame = m_hWndParent = hwnd;
  }
  virtual ~CUIOperationHandlerBase(){}

protected:
  // accessor functions
  HWND GetParentHwnd() { return m_hWndParent;}
  void SetParentHwnd(HWND hwnd) { m_hWndParent = hwnd;}

  CDSComponentData* GetComponentData() { return m_pComponentData;}
  CDSNotifyHandlerTransaction* GetTransaction() { return &m_transaction;}

  // JonN 6/2/00 99382
  // SITEREPL:  Run interference when administrator attempts to
  // delete critical object (NTDS Settings)
  // reports own errors, returns true iff deletion should proceed
/*  bool CheckForNTDSDSAInSubtree(
        LPCTSTR lpszX500Path,
        LPCTSTR lpszItemName);
*/
  //
  // JeffJon 8/10/00 27377
  // Check for critical system objects in the subtree before
  // attempting a subtree delete. This includes objects with
  // isCriticalSystemObject=TRUE and NTDS Settings objects
  //
  bool CheckForCriticalSystemObjectInSubtree(
        LPCTSTR lpszX500Path,
        LPCTSTR lpszItemName);

  // JonN 6/15/00 13574
  // Centralizes the checks to make sure this is an OK object to delete
  // returns HRESULT_FROM_WIN32(ERROR_CANCELLED) on cancellation
  // returns fAlternateDeleteMethod=true iff ObjectDeletionCheck already
  //   attempted an alternate deletion method (e.g. DsRemoveDsServer).
  HRESULT ObjectDeletionCheck(
        LPCTSTR lpszADsPath,
        LPCTSTR lpszName, // shortname to display to user, may be NULL
        LPCTSTR lpszClass,
        bool& fAlternateDeleteMethod );
        
private:
  CDSComponentData* m_pComponentData;
  CDSNotifyHandlerTransaction m_transaction;

  HWND m_hWndFrame;   // MMC frame window
  HWND m_hWndParent; // window to parent any UI created in the handler
};


///////////////////////////////////////////////////////////////////////////
// CSingleDeleteHandlerBase

class CSingleDeleteHandlerBase : public CUIOperationHandlerBase
{
public:
  CSingleDeleteHandlerBase(CDSComponentData* pComponentData, HWND hwnd)
    : CUIOperationHandlerBase(pComponentData, hwnd)
  {
    GetTransaction()->SetEventType(DSA_NOTIFY_DEL);
  }

  HRESULT Delete();

protected:
  // hooks for customization
  virtual HRESULT BeginTransaction() = 0;
  virtual HRESULT DeleteObject() = 0;
  virtual HRESULT DeleteSubtree() = 0;
  virtual void    GetItemName(OUT CString& szName) = 0;
  virtual LPCWSTR GetItemClass() = 0;
  virtual LPCWSTR GetItemPath() = 0;
  
};






///////////////////////////////////////////////////////////////////////////
// CMultipleDeleteHandlerBase

class CMultipleDeleteHandlerBase : public CUIOperationHandlerBase
{
public:
  CMultipleDeleteHandlerBase(CDSComponentData* pComponentData, HWND hwnd)
    : CUIOperationHandlerBase(pComponentData, hwnd)
  {
    GetTransaction()->SetEventType(DSA_NOTIFY_DEL);
  }

  void Delete();

protected:

  // hooks for customization
  virtual UINT GetItemCount() = 0;
  virtual HRESULT BeginTransaction() = 0;
  virtual HRESULT DeleteObject(UINT i) = 0;
  virtual HRESULT DeleteSubtree(UINT i) = 0;
  virtual void    OnItemDeleted(UINT) {}
  virtual void    GetItemName(IN UINT i, OUT CString& szName) = 0;
  virtual void    GetItemPath(UINT i, CString& szPath) = 0;
  virtual PCWSTR  GetItemClass(UINT i) = 0;
  
private:
  CMultipleDeletionConfirmationUI m_confirmationUI;

  void OnStart(HWND hwnd);
  HRESULT OnDeleteStep(UINT i,
                       BOOL* pbContinue,
                       CString& strrefPath,
                       CString& strrefClass,
                       BOOL bSilent = TRUE);

  friend class CMultipleDeleteProgressDialog; // for m_confirmationUI

};


///////////////////////////////////////////////////////////////////////////
// CMoveHandlerBase

class CMultipleMoveProgressDialog; // fwd decl

class CMoveHandlerBase : public CUIOperationHandlerBase
{
public:
  CMoveHandlerBase(CDSComponentData* pComponentData, HWND hwnd,
                    LPCWSTR lpszBrowseRootPath)
    : CUIOperationHandlerBase(pComponentData, hwnd)
  {
    m_lpszBrowseRootPath = lpszBrowseRootPath;
    GetTransaction()->SetEventType(DSA_NOTIFY_MOV);
  }

  HRESULT Move(LPCWSTR lpszDestinationPath = NULL);
  

protected:
  // hooks for customization
  virtual UINT GetItemCount() = 0;
  virtual HRESULT BeginTransaction() = 0;
  virtual void GetNewPath(UINT i, CString& szNewPath) = 0;
  virtual void GetName(UINT i, CString& strref) = 0;
  virtual HRESULT OnItemMoved(UINT i, IADs* pIADs) = 0;
  virtual void GetClassOfMovedItem(CString& szClass) = 0;
  virtual void GetItemPath(UINT i, CString& szPath) = 0;
  virtual PCWSTR GetItemClass(UINT i) = 0;

  LPCWSTR GetDestPath() { return m_szDestPath;}
  LPCWSTR GetDestClass() { return m_szDestClass;}
  BOOL    IsDestContainer() { return m_bDestContainer; }
  
private:
  LPCWSTR m_lpszBrowseRootPath; // LDAP path where to point the browser dialog

  CComPtr<IADsContainer> m_spDSDestination;
  CString m_szDestPath;
  CString m_szDestClass;
  BOOL    m_bDestContainer;

  BOOL _ReportFailure(BOOL bLast, HRESULT hr, LPCWSTR lpszName);
  HRESULT _BrowseForDestination(LPCWSTR lpszDestinationPath);
  BOOL _BeginTransactionAndConfirmOperation();

  HRESULT _MoveSingleSel(PCWSTR pszNewName);
  HRESULT _MoveMultipleSel();
  HRESULT _OnMoveStep(IN UINT i,
                      OUT BOOL* pbCanContinue,
                      OUT CString& strrefPath,
                      OUT CString& strrefClass);
  
  friend class CMultipleMoveProgressDialog;
};

///////////////////////////////////////////////////////////////////////////
// CMultiselectMoveHandler

class CMultiselectMoveHandler : public CMoveHandlerBase
{
private:
  struct CMovedState
  {
    CMovedState()
    {
      m_bMoved = FALSE;
    }
    BOOL m_bMoved;
    CString m_szNewPath;
  };

public:
    CMultiselectMoveHandler(CDSComponentData* pComponentData, HWND hwnd, 
                            LPCWSTR lpszBrowseRootPath)
    : CMoveHandlerBase(pComponentData, hwnd, lpszBrowseRootPath)
  {
    m_pMovedArr = NULL;
  }

  virtual ~CMultiselectMoveHandler()
  {
    if (m_pMovedArr != NULL)
      delete[] m_pMovedArr;
  }

  BOOL WasItemMoved(UINT i) 
  {
    ASSERT(i < GetItemCount());
    return m_pMovedArr[i].m_bMoved;
  }
  LPCWSTR GetNewItemPath(UINT i) 
  {
    ASSERT(WasItemMoved(i));
    return m_pMovedArr[i].m_szNewPath;
  }


  HRESULT Initialize(IDataObject* pDataObject,
                      CObjectNamesFormatCracker* pObjectNamesFormatCracker,
                      CInternalFormatCracker* pInternalFormatCracker)
  {
    if ((pDataObject == NULL) || (pObjectNamesFormatCracker == NULL))
    {
      ASSERT(FALSE);
      return E_INVALIDARG;
    }
    m_pDataObject = pDataObject;
    m_pInternalFormatCracker = pInternalFormatCracker;
    m_pObjectNamesFormatCracker = pObjectNamesFormatCracker;

    if (m_pObjectNamesFormatCracker->GetCount() < 1)
    {
      ASSERT(FALSE); // something is just wrong...
      return E_INVALIDARG;
    }

    // allocate an array of CMovedState structs to keep track of what actually got moved
    // and what the new name is
    m_pMovedArr = new CMovedState[GetItemCount()];
    return S_OK;
  }

protected:
  virtual UINT GetItemCount() { return m_pObjectNamesFormatCracker->GetCount();}
  virtual HRESULT BeginTransaction()
  {
    return GetTransaction()->Begin(m_pDataObject,
                          GetDestPath(), GetDestClass(), IsDestContainer());
  }
  virtual void GetNewPath(UINT i, CString& szNewPath)
  {
    szNewPath = m_pObjectNamesFormatCracker->GetName(i);
  }
  virtual void GetName(UINT i, CString& strref)
  { 
    HRESULT hr = S_OK;
    if ((m_pInternalFormatCracker != NULL) && m_pInternalFormatCracker->HasData())
    {
      CUINode* pUINode = m_pInternalFormatCracker->GetCookie(i);
      CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);
      strref = pCookie->GetName();
    }
    else 
    {
      // REVIEW_MARCOC_PORT: this might be inefficent, need to make a member variable
      CPathCracker pathCracker;
      hr = pathCracker.Set((LPWSTR)m_pObjectNamesFormatCracker->GetName(i),
                              ADS_SETTYPE_FULL);
      hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);

      CComBSTR DestName;
      hr = pathCracker.GetElement( 0, &DestName );
      strref = DestName;
    }
  }
  virtual void GetItemPath(UINT i, CString& szPath)
  {
    szPath =  m_pObjectNamesFormatCracker->GetName(i);
  }

  virtual PCWSTR GetItemClass(UINT i)
  {
    return m_pObjectNamesFormatCracker->GetClass(i);
  }
  virtual HRESULT OnItemMoved(UINT i, IADs* pIADs)
  {
    HRESULT hr = S_OK;

    m_pMovedArr[i].m_bMoved = TRUE;

    CComBSTR bsPath;
    hr = pIADs->get_ADsPath(&bsPath);
    if (SUCCEEDED(hr))
    {
      // save the new LDAP path in the array
      m_pMovedArr[i].m_szNewPath = bsPath;
    }

    if ((m_pInternalFormatCracker != NULL) && m_pInternalFormatCracker->HasData())
    {
      CUINode* pUINode = m_pInternalFormatCracker->GetCookie(i);
      CDSCookie* pCookie = GetDSCookieFromUINode(pUINode);
      pUINode->SetExtOp(OPCODE_MOVE);

      if (SUCCEEDED(hr)) 
      {
        CUINode* pParentNode = pUINode->GetParent();
        if (pParentNode != NULL)
        {
          if (!IS_CLASS(*pParentNode, CSavedQueryNode))
          {
            //
            // set the new DN in the cookie
            //
            CString szPath;
            StripADsIPath(bsPath, szPath);
            pCookie->SetPath(szPath);
          }
        }
      }
    }
    return hr;
  }
  virtual void GetClassOfMovedItem(CString& szClass)
  {
    szClass.Empty();
    if (NULL == m_pObjectNamesFormatCracker)
      return;
    UINT nCount = GetItemCount();
    if (0 == nCount)
      return;
    szClass = m_pObjectNamesFormatCracker->GetClass(0);
    for (UINT i = 1; i < nCount; i++)
    {
      if (0 != szClass.CompareNoCase( m_pObjectNamesFormatCracker->GetClass(i) ))
      {
        szClass.Empty();
        return;
      }
    }
  }

protected:
  CMovedState* m_pMovedArr;
  CInternalFormatCracker*    m_pInternalFormatCracker;

private:
  IDataObject* m_pDataObject;
  CObjectNamesFormatCracker*   m_pObjectNamesFormatCracker;
};


///////////////////////////////////////////////////////////////////////////
// CMultiselectMoveDataObject

class CMultiselectMoveDataObject : public IDataObject, public CComObjectRoot 
{
// ATL Maps
    DECLARE_NOT_AGGREGATABLE(CMultiselectMoveDataObject)
    BEGIN_COM_MAP(CMultiselectMoveDataObject)
        COM_INTERFACE_ENTRY(IDataObject)
    END_COM_MAP()

// Construction/Destruction
  CMultiselectMoveDataObject()
  {
    m_pDSObjCached = NULL;
    m_nDSObjCachedBytes = 0;
  }
  ~CMultiselectMoveDataObject()
  {
    _Clear();
  }

// Standard IDataObject methods
public:
// Implemented
  STDMETHOD(GetData)(FORMATETC * pformatetcIn, STGMEDIUM * pmedium);

// Not Implemented
private:
  STDMETHOD(GetDataHere)(FORMATETC*, STGMEDIUM*)    { return E_NOTIMPL; };
  STDMETHOD(EnumFormatEtc)(DWORD, IEnumFORMATETC**) { return E_NOTIMPL; };
  STDMETHOD(SetData)(FORMATETC*, STGMEDIUM*,BOOL)   { return E_NOTIMPL; };
  STDMETHOD(QueryGetData)(FORMATETC*)               { return E_NOTIMPL; };
  STDMETHOD(GetCanonicalFormatEtc)(FORMATETC*, FORMATETC*) { return E_NOTIMPL; };
  STDMETHOD(DAdvise)(FORMATETC*, DWORD, IAdviseSink*, DWORD*) { return E_NOTIMPL; };
  STDMETHOD(DUnadvise)(DWORD)                       { return E_NOTIMPL; };
  STDMETHOD(EnumDAdvise)(IEnumSTATDATA**)           { return E_NOTIMPL; };

public:
  // Property Page Clipboard formats
  static CLIPFORMAT m_cfDsObjectNames;

  static HRESULT BuildPastedDataObject(
               IN CObjectNamesFormatCracker* pObjectNamesFormatPaste,
               IN CMultiselectMoveHandler* pMoveHandler,
               IN CDSComponentData* pCD,
               OUT IDataObject** ppSuccesfullyPastedDataObject);

protected:
  // initialization
  HRESULT Init(IN CObjectNamesFormatCracker* pObjectNamesFormatPaste,
               IN CMultiselectMoveHandler* pMoveHandler,
               IN CDSComponentData* pCD);

// Implementation
private:
  void _Clear()
  {
    if (m_pDSObjCached != NULL)
    {
      ::free(m_pDSObjCached);
      m_pDSObjCached = NULL;
      m_nDSObjCachedBytes = 0;
    }
  }  

  // chunk of memory with the clpboard format already computed
  LPDSOBJECTNAMES m_pDSObjCached;
  DWORD m_nDSObjCachedBytes;
};

////////////////////////////////////////////////////////////////////////

void EscapeFilterElement(PCWSTR pszElement, CString& refszEscapedElement);


#endif // __DSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dssnap.h ===
//+-------------------------------------------------------------------------
//
//  Windows NT Directory Service Administration SnapIn
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      dssnap.h
//
//  Contents:  DS App
//  
//  History:   02-Oct-96 WayneSc    Created
//
//--------------------------------------------------------------------------


#ifndef __DSSNAP_H__
#define __DSSNAP_H__

#ifndef __DSCOOKIE_H__
	#include "dscookie.h"	
#endif
#ifndef __DSCACHE_H__
	#include "dscache.h"	// CDSCache
#endif


#define OPCODE_MOVE        0x00000001L
#define OPCODE_DELETE      0x00000002L

// this isn't really a context menu op code, its a flag we use to know
// which icon to return for this object if the enumberation failed
// see dssnap.cpp->ChangeScopeItemIcon()
#define OPCODE_ENUM_FAILED 0x00000004L
// another pseudo opcode, to track whether we're enumerating or
// expanding
#define OPCODE_EXPAND_IN_PROGRESS 0x00000008L



#define DS_DELETE_OCCURRED              900
#define DS_RENAME_OCCURRED              901
#define DS_MOVE_OCCURRED                902
#define DS_CREATE_OCCURRED              903
#define DS_REFRESH_REQUESTED            904
#define DS_VERB_UPDATE                  905
#define DS_ICON_STRIP_UPDATE            907
#define DS_HAVE_DATA                    908
#define DS_UPDATE_OCCURRED              909
#define DS_MULTIPLE_DELETE_OCCURRED     910
#define DS_MULTIPLE_MOVE_OCCURRED       911
#define DS_CHECK_COLUMN_WIDTHS          912
#define DS_IS_COOKIE_SELECTION          913
#define DS_CREATE_OCCURRED_RESULT_PANE  914
#define DS_DELAYED_EXPAND               915
#define DS_SORT_RESULT_PANE             916
#define DS_UPDATE_VISIBLE_COLUMNS       917
#define DS_UPDATE_OBJECT_COUNT          918
#define DS_UNSELECT_OBJECT              919

#define DS_DEFAULT_COLUMN_COUNT         3

#define DEFAULT_NAME_COL_WIDTH          125
#define DEFAULT_TYPE_COL_WIDTH          175
#define DEFAULT_DESC_COL_WIDTH          400
#define NARROW_DESC_COL_WIDTH           200


// forward declarations

class CDSCookie;
class CDSQueryFilter;
class CHiddenWnd;
class CDSQueryResult;
class CWorkerThread;
struct CBackgroundThreadInfo;
class CFavoritesNodesHolder;

/////////////////////////////////////////////////////////////////////////////
// CTargetingInfo

class CTargetingInfo
{
public:
  CTargetingInfo()
  {
    m_dwFlags = 0x0;
    _InitFromCommandLine();
  }

  HRESULT Load(IStream* pStm);
  HRESULT Save(IStream* pStm, LPCWSTR lpszCurrentTargetName);

  BOOL GetSaveCurrent() 
  { 
    return (m_dwFlags & m_dwSaveDomainFlag) != 0;
  }
  void SetSaveCurrent(BOOL bSave)
  {
    if (bSave)
      m_dwFlags |= m_dwSaveDomainFlag;
    else
      m_dwFlags &= ~m_dwSaveDomainFlag;
  }

  LPCWSTR GetTargetString() { return m_szStoredTargetName; }
  LPCWSTR GetRootRDN() { return m_szRootRDN;}

#ifdef _MMC_ISNAPIN_PROPERTY
  HRESULT InitFromSnapinProperties(long cProps, //property count
                                  MMC_SNAPIN_PROPERTY*    pProps //properties array
                                  );
#endif // _MMC_ISNAPIN_PROPERTY

private:
  void _InitFromCommandLine();

  DWORD m_dwFlags;
  CString m_szStoredTargetName;
  CString m_szRootRDN;

  static const DWORD m_dwSaveDomainFlag;
};

/////////////////////////////////////////////////////////////////////////////
// CIconManager

class CIconManager
{
public:
  CIconManager()
  {
    m_pScpImageList = NULL;

    // set the special indexes to invalid values
    m_iRootIconIndex = m_iRootIconErrIndex = 
      m_iWaitIconIndex = m_iWarnIconIndex = 
      m_iFavoritesIconIndex = m_iQueryIconIndex = 
      m_iQueryInvalidIconIndex = 0;
  }
  ~CIconManager()
  {
  }

  HRESULT Init(IImageList* pScpImageList, SnapinType snapintype);

  HRESULT FillInIconStrip(IImageList* pImageList);
  HRESULT AddClassIcon(IN LPCWSTR lpszClass, 
                       IN MyBasePathsInfo* pPathInfo, 
                       IN DWORD dwFlags,
                       INOUT int* pnIndex);
  HRESULT AddIcon(IN HICON hiClass16, IN HICON hiClass32, INOUT int* pnIndex);

  int GetRootIndex() { return m_iRootIconIndex;}
  int GetRootErrIndex() { return m_iRootIconErrIndex;}

  int GetWaitIndex() { return m_iWaitIconIndex;}
  int GetWarnIndex() { return m_iWarnIconIndex;}

  int GetFavoritesIndex() { return m_iFavoritesIconIndex;}
  int GetQueryIndex() { return m_iQueryIconIndex;}
  int GetQueryInvalidIndex() { return m_iQueryInvalidIconIndex; }

private:
  IImageList* m_pScpImageList; // no addref, lifetime of IComponentData

  class CIconInfo
  {
  public:
    CIconInfo() { m_hiClass16 = m_hiClass32 = NULL;}
    HICON m_hiClass16;
    HICON m_hiClass32;
  };
  class CIconInfoList : public CList <CIconInfo*, CIconInfo*>
  {
  public:
    ~CIconInfoList()
    {
      while (!IsEmpty())
        delete RemoveHead();
    }
  };

  CIconInfoList m_IconInfoList; // list of icon handles
  
  // special icon indexes we need to know about
  int m_iRootIconIndex;
  int m_iRootIconErrIndex;
  int m_iWaitIconIndex;
  int m_iWarnIconIndex;
  int m_iFavoritesIconIndex;
  int m_iQueryIconIndex;
  int m_iQueryInvalidIconIndex;

  HRESULT _LoadIconFromResource(IN UINT nIconResID, INOUT int* pnIndex);
  int _GetBaseIndex() { return 1;}
  int _GetNextFreeIndex() 
        { return (int)(m_IconInfoList.GetCount() + _GetBaseIndex());} 
};

/////////////////////////////////////////////////////////////////////////////
// CInternalFormatCracker

class CInternalFormatCracker
{
public:
	CInternalFormatCracker()
	{
		m_pInternalFormat = NULL;
	}
	~CInternalFormatCracker()
	{
    _Free();
	}

  BOOL HasData() { return m_pInternalFormat != NULL;}

  HRESULT Extract(LPDATAOBJECT lpDataObject);
  LPDATAOBJECT ExtractMultiSelect(LPDATAOBJECT lpDataObject);
  CUINode* GetCookie(UINT nIndex = 0) 
  {
    ASSERT(m_pInternalFormat != NULL);
    if (nIndex == 0)
    {
      return m_pInternalFormat->m_cookie;
    }
    else if ( (m_pInternalFormat->m_p_cookies != NULL) && 
              (nIndex < m_pInternalFormat->m_cookie_count))
    {
      return m_pInternalFormat->m_p_cookies[nIndex-1];
    }
    ASSERT(FALSE);
    return NULL;
  }
  UINT GetCookieCount()
  {
    ASSERT(m_pInternalFormat != NULL);
    return m_pInternalFormat->m_cookie_count;
  }
  DATA_OBJECT_TYPES GetType()
  {
    ASSERT(m_pInternalFormat != NULL);
    return m_pInternalFormat->m_type;
  }
  SnapinType GetSnapinType()
  {
    ASSERT(m_pInternalFormat != NULL);
    return m_pInternalFormat->m_snapintype;
  }
private:
	INTERNAL* m_pInternalFormat;

  void _Free()
  {
    if (m_pInternalFormat != NULL)
    {
      ::GlobalFree(m_pInternalFormat);
      m_pInternalFormat = NULL;
    }
  }
};

//
// this is just a function to make sure we have
// consistent node types in the object cracker
//
template <class T>
BOOL AreAllNodesOfType(CInternalFormatCracker* pInternalObjectCracker)
{
  UINT nCount = pInternalObjectCracker->GetCookieCount();
  for (UINT k=0; k<nCount; k++)
  {
    if (!IS_CLASS(*(pInternalObjectCracker->GetCookie(k)), T))
      return FALSE;
  }
  return TRUE;
}

/////////////////////////////////////////////////////////////////////
// CObjectNamesFormatCracker

class CObjectNamesFormatCracker
{
public:
	CObjectNamesFormatCracker()
	{
		m_pDsObjectNames = NULL;
	}
	~CObjectNamesFormatCracker()
	{
    _Free();
	}

  BOOL HasData() { return m_pDsObjectNames != NULL;}

  HRESULT Extract(LPDATAOBJECT lpDataObject);

  UINT GetCount() 
  { 
    ASSERT(m_pDsObjectNames != NULL);
    return m_pDsObjectNames->cItems;
  }

  LPCWSTR GetName(UINT nIndex)
  {
    ASSERT(nIndex < GetCount());
    return (LPCWSTR)ByteOffset(m_pDsObjectNames, m_pDsObjectNames->aObjects[nIndex].offsetName);
  }

  LPCWSTR GetClass(UINT nIndex)
  {
    ASSERT(nIndex < GetCount());
    return (LPCWSTR)ByteOffset(m_pDsObjectNames, m_pDsObjectNames->aObjects[nIndex].offsetClass);
  }

  DWORD GetProviderFlags(UINT nIndex)
  {
    ASSERT(nIndex < GetCount());
    return m_pDsObjectNames->aObjects[nIndex].dwProviderFlags;
  }

  DWORD GetFlags(UINT nIndex)
  {
    ASSERT(nIndex < GetCount());
    return m_pDsObjectNames->aObjects[nIndex].dwFlags;
  }

  BOOL IsContainer(UINT nIndex)
  {
    ASSERT(nIndex < GetCount());
    return (GetFlags((nIndex) & DSOBJECT_ISCONTAINER) != 0);
  }

  void Reset() { _Free();}

  // Property Page Clipboard formats
  static CLIPFORMAT m_cfDsObjectNames;

private:
	LPDSOBJECTNAMES m_pDsObjectNames;

  void _Free()
  {
    if (m_pDsObjectNames != NULL)
    {
      ::GlobalFree(m_pDsObjectNames);
      m_pDsObjectNames = NULL;
    }
  }
};

/////////////////////////////////////////////////////////////////////
// CTopLevelCNInfo


class CTopLevelCNInfo
{
public:
	CTopLevelCNInfo()
	{
		m_nCount = 0;
		m_pStringArr = NULL;
		m_pdwFlags = NULL;
	}
	~CTopLevelCNInfo()
	{
		Free();
	}
	BOOL Alloc(UINT nCount)
	{
		CString* pstr = new CString[nCount];
		if (pstr == NULL)
			return FALSE;
		DWORD* pdw = new DWORD[nCount];
		if (pdw == NULL)
		{
			delete[] pstr;
			return FALSE;
		}
		ZeroMemory( pdw, nCount*sizeof(DWORD) );
		m_pStringArr = pstr;
		m_pdwFlags = pdw;
		m_nCount = nCount;
		return TRUE;
	}
	void Free()
	{
		m_nCount = 0;
		if (m_pStringArr != NULL)
		{
			delete[] m_pStringArr;
			m_pStringArr = NULL;
		}
		if (m_pdwFlags != NULL)
		{
			delete[] m_pdwFlags;
			m_pdwFlags = NULL;
		}
	}
	UINT m_nCount;
	CString* m_pStringArr;
	DWORD* m_pdwFlags;
};

#define TOPLEVEL_FLAG_SERVICES_NODE 0x1




/////////////////////////////////////////////////////////////////////
// CDSNotifyHandlerManager

class CDSNotifyHandlerManager
{
private:
  class CDSNotifyHandlerInfo
  {
  public:
    CDSNotifyHandlerInfo()
    {
      m_nRegisteredEvents = 0;
      m_nFlags = 0;
      m_bTransactionPending = FALSE;
      m_bNeedsNotify = FALSE;
    }
  
    CComPtr<IDsAdminNotifyHandler> m_spIDsAdminNotifyHandler;
    ULONG m_nRegisteredEvents;
    ULONG m_nFlags;
    CString m_szDisplayString;
    BOOL m_bTransactionPending;
    BOOL m_bNeedsNotify;
  };

public:

  CDSNotifyHandlerManager()
  {
    m_nArrSize = 0;
    m_pInfoArr = NULL;
    m_state = uninitialized;
  }
  
  ~CDSNotifyHandlerManager()
  {
    _Free();
  }

  BOOL HasHandlers() { return m_state == hasHandlers;}

  HRESULT Init();
  HRESULT Load(MyBasePathsInfo* pBasePathInfo); // do the actual extension loading and initialization

  // mapping to COM notification interfaces
  void Begin(ULONG uEvent, IDataObject* pArg1, IDataObject* pArg2);
  void Notify(ULONG nItem, ULONG uEvent);
  void End(ULONG uEvent);

  // state veriables check
  UINT NeedNotifyCount(ULONG uEvent);

  // handlers for visualization in confirnation dialog
  void SetCheckListBox(CCheckListBox* pCheckListBox, ULONG uEvent);
  void ReadFromCheckListBox(CCheckListBox* pCheckListBox, ULONG uEvent);

private:
  CDSNotifyHandlerInfo* m_pInfoArr;
  UINT m_nArrSize;

  enum HandlerState { uninitialized, hasHandlers, noHandlers};
  HandlerState m_state;

  void _Free()
  {
    if (m_pInfoArr != NULL)
    {
      ASSERT(m_nArrSize >0);
      delete[] m_pInfoArr;
    }
    m_nArrSize = 0;
    m_pInfoArr = NULL;
    m_state = uninitialized;
  }

};



/////////////////////////////////////////////////////////////////////
// CDSComponentData

typedef struct _UINODESELECTIONP {
  CUINode* pUINode;
  BOOL IsSelection;
} UINODESELECTION, * PUINODESELECTION;


class CDSComponentData:
  public IComponentData,
  public IExtendPropertySheet,
  public IExtendContextMenu,
  public IPersistStream,
#ifdef _MMC_ISNAPIN_PROPERTY
  public ISnapinProperties,
#endif
  public ISnapinHelp2,
  public CComObjectRoot
{
  BEGIN_COM_MAP(CDSComponentData)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStream)
#ifdef _MMC_ISNAPIN_PROPERTY
    COM_INTERFACE_ENTRY(ISnapinProperties)
#endif
    COM_INTERFACE_ENTRY(ISnapinHelp)
    COM_INTERFACE_ENTRY(ISnapinHelp2)
  END_COM_MAP()

  friend class CDSClassCacheItemBase;
  friend class CDSEvent;
  friend class CDSDataObject;
  friend class CDSDirect;
  friend class CDSContextMenu;

  CDSComponentData();
  HRESULT FinalConstruct();
  void FinalRelease();
  ~CDSComponentData();
  
public:
  // IComponentData interface members
  STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
  STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
  STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
  STDMETHOD(Destroy)();
  STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
  STDMETHOD(GetDisplayInfo)(LPSCOPEDATAITEM scopeInfo);
  STDMETHOD(CompareObjects) (IDataObject * pDataObject, IDataObject * pDataObject2);
  // IExtendPropertySheet interface
public:
  STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, 
                                 LONG_PTR handle,
                                 LPDATAOBJECT lpIDataObject);
  STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// IExtendContextMenu 
public:
  STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
                          LPCONTEXTMENUCALLBACK pCallbackUnknown,
                          long *pInsertionAllowed);
  STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

public:
  // IPersistStream interface members
  STDMETHOD(GetClassID)(CLSID *pClassID);
  STDMETHOD(IsDirty)();
  STDMETHOD(Load)(IStream *pStm);
  STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
  STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

// ISnapinHelp2 interface members
  STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
  STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFile);

#ifdef _MMC_ISNAPIN_PROPERTY
  // ISnapinProperties
  STDMETHOD(Initialize)         (Properties* pProperties);
  STDMETHOD(QueryPropertyNames) (ISnapinPropertiesCallback* pCallback);
  STDMETHOD(PropertiesChanged)  (long cProperties, MMC_SNAPIN_PROPERTY* pProperties);

#endif //_MMC_ISNAPIN_PROPERTY


public:

  virtual SnapinType QuerySnapinType() = 0;
  LPCWSTR GetRootPath(void) { return m_RootNode.GetPath(); }
  
  PDSDISPLAYSPECOPTIONS GetDsDisplaySpecOptions()
  {
    return m_DsDisplaySpecOptionsCFHolder.Get();
  }

  HRESULT AddClassIcon(IN LPCWSTR lpszClass, IN DWORD dwFlags, INOUT int* pnIndex);
  HRESULT FillInIconStrip(IImageList* pImageList);

  HWND GetHWnd() { return m_hwnd;}

  CRootNode* GetRootNode() { return &m_RootNode;}
  CDSDirect* GetActiveDS() { return m_ActiveDS;}

  BOOL ExpandComputers();
  BOOL IsAdvancedView();
  BOOL ViewServicesNode();


  HRESULT ToggleDisabled(CDSUINode* pDSUINode, BOOL bDisable);

  void AddScopeItemToUI(CUINode* pUINode, BOOL bSetSelected = FALSE);
  void AddListOfNodesToUI(CUINode* pUINode, CUINodeList* pNodeList);
  HRESULT ReadUINodeFromLdapPath(IN CDSUINode* pContainerDSUINode,
                                 IN LPCWSTR lpszLdapPath,
                                 OUT CDSUINode** ppSUINodeNew);
  HRESULT UpdateItem(CUINode* pNode);

private:
  HRESULT _OnExpand(CUINode* pNode, HSCOPEITEM hParent, MMC_NOTIFY_TYPE event);
  HRESULT _OnPreload(HSCOPEITEM hRoot);

  HRESULT BuildDsDisplaySpecOptionsStruct()
  {
    return m_DsDisplaySpecOptionsCFHolder.Init(GetBasePathsInfo());
  }

  HRESULT _AddScopeItem(CUINode* pUINode, HSCOPEITEM hParent, BOOL bSetSelected = FALSE);
  HRESULT _ChangeRootItemIcon(int nImage);
  HRESULT _ChangeResultItemIcon(CUINode* pUINode);
  HRESULT _UpdateScopeItem(CUINode* pNode);

  // command helpers (called from Command())
  HRESULT _CommandNewDSObject(long nCommandID, LPDATAOBJECT pDataObject);
  HRESULT _CommandShellExtension(long nCommandID, LPDATAOBJECT pDataObject);

  // create object handler
  HRESULT _CreateDSObject(IN CDSUINode* pContainerDSUINode, 
                        IN LPCWSTR lpszObjectClass,
                        IN CDSUINode* pCopyFromSUINode,
                        OUT CDSUINode** ppSUINodeNew);

  // copy object handler
  HRESULT _CanCopyDSObject(IDataObject* pCopyFromDsObject);
  HRESULT _CopyDSObject(IDataObject* pCopyFromDsObject);

  // deletion helpers
  HRESULT _DeleteFromBackendAndUI(IDataObject* pDataObject, CDSUINode* pDSUINode);
  HRESULT _DeleteFromBackEnd(IDataObject* pDataObject, CDSCookie* pCookie);

public: // expose to other objects
  HRESULT ChangeScopeItemIcon(CUINode* pUINode);
  HRESULT _DeleteSubtreeFromBackEnd(CDSCookie* pCookie);
  HRESULT RemoveContainerFromUI(CUINode* pUINode);

  HRESULT SetRenameMode(CUINode* pUINode);
  BOOL CanAddCookieToGroup(CDSCookie* pCookie, INT iGroupType, BOOL bMixedMode);

  HRESULT SelectScopeNode(CUINode* pUINode);
  void SortResultPane(CUINode* pUINode);
  CDSColumnSet* FindColumnSet(LPCWSTR lpszColumnID) 
  { 
    return (CDSColumnSet*)m_pClassCache->FindColumnSet(lpszColumnID); 
  }

  HRESULT ColumnsChanged(CDSEvent* pDSEvent,
                      CUINode* pUINode, 
                      MMC_VISIBLE_COLUMNS* pVisibleColumns, 
                      BOOL bRefresh);
  void ForceRefreshAll();

  HRESULT Refresh(CUINode* pNode, BOOL bFlushCache = FALSE, BOOL bFlushColumns = FALSE);
  HRESULT UpdateFromDS(CUINode* pUINode);
  BOOL IsSelectionAnywhere(CUINode* pUINode);
  // JonN 7/23/99
  // 373806: Site&Svcs:  Renaming an auto-generated connection should make it admin owned
  BOOL RenameConnectionFixup(CDSCookie* pCookie);

  void ClearSubtreeHelperForRename(CUINode* pUINode);
  CDSCache* GetClassCache() { return m_pClassCache; }

  HRESULT FillInChildList(CDSCookie * pCookie);
  CDSQueryFilter* GetQueryFilter() { return m_pQueryFilter; }
  BOOL IsPrimarySnapin() { return m_bRunAsPrimarySnapin; }

  void GetDomain();
  void GetDC();
  BOOL CanRefreshAll();
  void RefreshAll();

  void EditFSMO();
  void RaiseVersion(void);

  CUINode* MoveObjectInUI(CDSUINode* pDSUINode);
  HRESULT FindParentCookie(LPCWSTR lpszCookieDN, CUINode** ppParentUINode);
  BOOL    FindUINodeByDN(CUINode* pContainerNode,
                         PCWSTR pszDN,
                         CUINode** ppFoundNode);
  void    InvalidateSavedQueriesContainingObjects(const CUINodeList& refUINodeList);
  void    InvalidateSavedQueriesContainingObjects(const CStringList& refPathList);

private:

  HRESULT _Rename(CUINode* pNode, LPWSTR NewName);
  
  HRESULT CommitRenameToDS(CUINode* pUINode, CDSCookie* pCookie, LPCWSTR NewName);
  HRESULT RenameUser(CUINode* pUINode, CDSCookie* pCookie, LPCWSTR NewName);
  HRESULT RenameGroup(CUINode* pUINode, CDSCookie* pCookie, LPCWSTR NewName);
  HRESULT RenameNTDSConnection(CUINode* pUINode, CDSCookie* pCookie, LPCWSTR NewName);
  HRESULT RenameSubnet(CUINode* pUINode, CDSCookie* pCookie, LPCWSTR NewName);
  HRESULT RenameSite(CUINode* pUINode, CDSCookie* pCookie, LPCWSTR NewName);
  HRESULT RenameContact(CUINode* pUINode, CDSCookie* pCookie, LPCWSTR NewName);

  
  
  HRESULT _MoveObject(CDSUINode* pDSUINode);

  void ClearClassCacheAndRefreshRoot();

  STDMETHOD(_OnPropertyChange)(LPDATAOBJECT pDataObject, BOOL bScope);
  BOOL SortChildList (LPWSTR *ppszChildList, UINT cChildCount);

  int InsertAtTopContextMenu(LPCWSTR pwszParentClass, LPCWSTR pwszChildClass);
  BOOL IsNotHiddenClass (LPWSTR pwszClass, CDSCookie* pParentCookie);
#ifdef FIXUPDC
  HRESULT _FixupDC(LPCWSTR pwszPath);
#endif // FIXUPDC
  HRESULT _RunKCC(LPCWSTR pwszPath);

  // Memory reclamation routines
  void ReclaimCookies();
  void AddToLRUList (CUINode* pUINode);


  // namespace extension API's
  HRESULT _OnNamespaceExtensionExpand(LPDATAOBJECT lpDataObject, HSCOPEITEM pParent);

  // thread API's
  BOOL _StartBackgroundThread();
  void _WaitForBackGroundThreadStartAck();
  void _ShutDownBackgroundThread();
  BOOL _PostQueryToBackgroundThread(CUINode* pUINode);
  BOOL _PostMessageToBackgroundThread(UINT Msg, WPARAM wParam, LPARAM lParam);
  void _OnTooMuchData(CUINode* pUINode);
  void _OnHaveData(CUINode* pUINode, CThreadQueryResult* pResult);
  void _OnDone(CUINode* pUINode, HRESULT hr);
  void _OnSheetClose(CUINode* pUINode);
  void _OnSheetCreate(PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo);

  // sheet API's
  void _SheetLockCookie(CUINode* pNode);
  void _SheetUnlockCookie(CUINode* pNode);
  BOOL _WarningOnSheetsUp(CUINode* pNode, BOOL bShowMessage = TRUE, BOOL bActivate = TRUE);
  BOOL _WarningOnSheetsUp(CInternalFormatCracker* pInternalFormatCracker);

public:
  STDMETHOD(QueryFromWorkerThread)(CThreadQueryInfo* pQueryInfo,
                                   CWorkerThread* pWorkerThread);
  BOOL CanEnableVerb(CUINode* pUINode);
  int GetImage(CUINode* pNode, BOOL bOpen);
  UINT GetSerialNumber() {return m_SerialNumber++;}
  void Lock() { ::EnterCriticalSection(&m_cs);}
  void Unlock() { ::LeaveCriticalSection(&m_cs);}
  HWND GetHiddenWindow();

  MyBasePathsInfo* GetBasePathsInfo() { return &m_basePathsInfo;}
  CDSNotifyHandlerManager* GetNotifyHandlerManager() { return &m_notifyHandlerManager;}
  CFavoritesNodesHolder* GetFavoritesNodeHolder() { return m_pFavoritesNodesHolder; }
  CTargetingInfo* GetTargetingInfo() { return &m_targetingInfo; }

  void SetDirty(BOOL bDirty = TRUE) { m_bDirty = bDirty; }
private:
  // InitFunctions
  HRESULT _InitRootFromCurrentTargetInfo();
  HRESULT _InitRootFromBasePathsInfo(MyBasePathsInfo* pBasePathsInfo);

  HRESULT _InitRootFromValidBasePathsInfo();

private:
  CTargetingInfo   m_targetingInfo; // manage serialized targeting info
  CIconManager     m_iconManager;   // manage icon strip
  MyBasePathsInfo m_basePathsInfo; // container of base path info
  CDSNotifyHandlerManager m_notifyHandlerManager;

protected:    
  CRootNode    m_RootNode;      // Root node for the snapin
  BOOL         m_InitSuccess;   // successfully contacted DC for naming info?
  BOOL         m_InitAttempted; // already attempted to contact DC for naming info, don't show errors
  CDSDirect*   m_ActiveDS;
  CDSCache*    m_pClassCache;
  LPCONSOLENAMESPACE2 m_pScope;  // My interface pointer to the scope pane
  IConsole3*   m_pFrame;

#ifdef _MMC_ISNAPIN_PROPERTY
  Properties*   m_pProperties;   // pointer to MMC properties interface
#endif //_MMC_ISNAPIN_PROPERTY  

  HWND         m_hwnd;          // window handle of main window
  IImageList*  m_pScpImageList;

  CStringList  m_CreateInfo;
  IShellExtInit * m_pShlInit;               // Property sheet COM object pointer.
  CDsDisplaySpecOptionsCFHolder m_DsDisplaySpecOptionsCFHolder;  // cached clipbard format.

  UINT m_SerialNumber;          // monotonically increasing number used for tracking
                                // cookies to determine LRU
  CUINodeList  m_LRUList;       // node list for LRU reclamation

  BOOL m_bDirty;		// dirty flag for serialization on MMC stream
  INT  m_ColumnWidths[DS_DEFAULT_COLUMN_COUNT]; //save column widths here.

  BOOL m_bRunAsPrimarySnapin;	// TRUE if the snapin is not an extension
  BOOL m_bAddRootWhenExtended;	// TRUE adds root node folder

  CDSQueryFilter* m_pQueryFilter;
  LPCWSTR m_lpszSnapinHelpFile;

  CFavoritesNodesHolder* m_pFavoritesNodesHolder;

  // thread related variables
private:
  CRITICAL_SECTION  m_cs;

protected:
  void _DeleteHiddenWnd();
  CHiddenWnd*      m_pHiddenWnd;

  CBackgroundThreadInfo* m_pBackgroundThreadInfo; // info about dispatcher thread state

  CUINodeQueryTable  m_queryNodeTable; // table of cookies having a pending query

  // property sheet related variables
private:
  CUINodeSheetTable m_sheetNodeTable; // table of cookies having a sheet up
  friend class CHiddenWnd;      // to access thread notification handlers
};


/////////////////////////////////////////////////////////////////////
// CDSSnapin (DS standalone)

class CDSSnapin:
  public CDSComponentData,
  public CComCoClass<CDSSnapin, &CLSID_DSSnapin>
{
public:
  DECLARE_REGISTRY_CLSID()
  //DECLARE_REGISTRY(CDSSnapin, _T("DSSnap.SnapinObj.1"), _T("DSSnap.SnapinObj"), IDS_DSSNAPINNAME, THREADFLAGS_BOTH)

    CDSSnapin();

  virtual SnapinType QuerySnapinType();
};

/////////////////////////////////////////////////////////////////////
// CDSSnapinEx (DS namespace extension)

class CDSSnapinEx:
  public CDSComponentData,
  public CComCoClass<CDSSnapinEx, &CLSID_DSSnapinEx>
{
public:
  DECLARE_REGISTRY_CLSID()
  //DECLARE_REGISTRY(CDSSnapin, _T("DSSnapEx.SnapinObj.1"), _T("DSSnapEx.SnapinObj"), IDS_DSSNAPINNAMEEX, THREADFLAGS_BOTH)

    CDSSnapinEx();

  virtual SnapinType QuerySnapinType();
};

/////////////////////////////////////////////////////////////////////
// CSiteSnapin (Site manager standalone)

class CSiteSnapin:
  public CDSComponentData,
  public CComCoClass<CSiteSnapin, &CLSID_SiteSnapin>
{
public:
  DECLARE_REGISTRY_CLSID()
  //DECLARE_REGISTRY(CSiteSnapin, _T("SiteSnap.SnapinObj.1"), _T("SiteSnap.SnapinObj"), IDS_SITESNAPINNAME, THREADFLAGS_BOTH)

    CSiteSnapin();
  
  virtual SnapinType QuerySnapinType();
};


//////////////////////////////////////////////////////////////////////////
// CDSSnapinAbout

class CDSSnapinAbout :
	public CSnapinAbout,
	public CComCoClass<CDSSnapinAbout, &CLSID_DSAboutSnapin>

{
public:
  DECLARE_REGISTRY_CLSID()
    CDSSnapinAbout();
};

//////////////////////////////////////////////////////////////////////////
// CSitesSnapinAbout

class CSitesSnapinAbout :
	public CSnapinAbout,
	public CComCoClass<CSitesSnapinAbout, &CLSID_SitesAboutSnapin>

{
public:
  DECLARE_REGISTRY_CLSID()
    CSitesSnapinAbout();
};


#endif //__DSSNAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsthread.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dsthread.cpp
//
//--------------------------------------------------------------------------


// FILE: dsThread.cpp

#include "stdafx.h"

#include "dssnap.h"     // Note: this has to be before dsthread.h
#include "dsthread.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void WaitForThreadShutdown(HANDLE* phThreadArray, DWORD dwCount)
{
  TRACE(L"entering WaitForThreadShutdown()\n");
  while (TRUE)
  {
    //
    // NOTE: this will block the console.  This the intended behavior
    // to keep MMC from breaking on none re-entrant code.
    //
    DWORD dwWaitResult = WaitForMultipleObjectsEx(
                             dwCount, 
                             phThreadArray, // handle array
                             TRUE, // wait for all
                             INFINITE, // time-out
                             FALSE);// signal completion routine
    //TRACE(L"after MsgWaitForMultipleObjects()\n");
    //TRACE(L"dwWaitResult = 0x%x\n", dwWaitResult);
    if (dwWaitResult == WAIT_OBJECT_0 || 
        (WAIT_FAILED == dwWaitResult))
    {
      // woke up because the thread handle got signalled,
      // or because the handle is no longer valid (thread already terminated)
      // can proceed
      TRACE(L"WaitForMultipleObjectsEx() succeeded\n");
      break;
    }
    else 
    {
      TRACE(L"WaitForMultipleObjectsEx() return 0x%x\n", dwWaitResult);
    }
    /* Whistler bug #176012 MMC: Assert m_pScopeTree == 0
       This message pump causes the UI not to be blocked which means
       MMC can reach code that is not re-entrant.

    else
    {
      // woke up because there is a message in the queue
      // need to pump
      MSG msg;
      while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
      {
        TRACE(L"inside while(PeekMessage())\n");
        ASSERT(msg.message != WM_QUIT);
        DispatchMessage(&msg);
      }
    }*/
  } // while

  TRACE(L"exiting WaitForThreadShutdown()\n");
}

////////////////////////////////////////////////////////////////////
// CHiddenWnd

const UINT CHiddenWnd::s_ThreadStartNotificationMessage =	      WM_USER + 1;
const UINT CHiddenWnd::s_ThreadTooMuchDataNotificationMessage = WM_USER + 2;
const UINT CHiddenWnd::s_ThreadHaveDataNotificationMessage =	  WM_USER + 3;
const UINT CHiddenWnd::s_ThreadDoneNotificationMessage =	      WM_USER + 4;
const UINT CHiddenWnd::s_SheetCloseNotificationMessage =	      WM_DSA_SHEET_CLOSE_NOTIFY; // propcfg.h
const UINT CHiddenWnd::s_SheetCreateNotificationMessage =	      WM_DSA_SHEET_CREATE_NOTIFY; // propcfg.h
const UINT CHiddenWnd::s_RefreshAllNotificationMessage =        WM_USER + 7;
const UINT CHiddenWnd::s_ThreadShutDownNotificationMessage =    WM_USER + 8;

BOOL CHiddenWnd::Create()
{
  RECT rcPos;
  ZeroMemory(&rcPos, sizeof(RECT));
  HWND hWnd = CWindowImpl<CHiddenWnd>::Create( NULL, //HWND hWndParent, 
                      rcPos, //RECT& rcPos, 
                      NULL,  //LPCTSTR szWindowName = NULL, 
                      WS_POPUP,   //DWORD dwStyle = WS_CHILD | WS_VISIBLE, 
                      0x0,   //DWORD dwExStyle = 0, 
                      0      //UINT nID = 0 
                      );
  return hWnd != NULL;
}


LRESULT CHiddenWnd::OnThreadStartNotification(UINT, WPARAM, LPARAM, BOOL&)
{
	TRACE(_T("CHiddenWnd::OnThreadStartNotification()\n"));
	ASSERT(m_pCD != NULL);

	ASSERT(m_pCD->m_pBackgroundThreadInfo->m_state == notStarted);
  ASSERT(m_pCD->m_pBackgroundThreadInfo->m_nThreadID != 0);
  ASSERT(m_pCD->m_pBackgroundThreadInfo->m_hThreadHandle != NULL);

	m_pCD->m_pBackgroundThreadInfo->m_state = running;
	
	return 1;
}

LRESULT CHiddenWnd::OnThreadShutDownNotification(UINT, WPARAM, LPARAM, BOOL&)
{
	TRACE(_T("CHiddenWnd::OnThreadShutDownNotification()\n"));
	ASSERT(m_pCD != NULL);

	ASSERT(m_pCD->m_pBackgroundThreadInfo->m_state == shuttingDown);
	m_pCD->m_pBackgroundThreadInfo->m_state = terminated;
	
	return 1;
}

LRESULT CHiddenWnd::OnThreadTooMuchDataNotification(UINT, WPARAM wParam, LPARAM, BOOL&)
{
  TRACE(_T("CHiddenWnd::OnThreadTooMuchDataNotification()\n"));
  ASSERT(m_pCD != NULL);

  // ingnore if we are shutting down (i.e. not running state)
  if (m_pCD->m_pBackgroundThreadInfo->m_state == running)
  {
    CUINode* pUINode = reinterpret_cast<CUINode*>(wParam);
    m_pCD->_OnTooMuchData(pUINode);
  }
  
  return 1;
}


LRESULT CHiddenWnd::OnThreadHaveDataNotification(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
  TRACE(_T("CHiddenWnd::OnThreadHaveDataNotification()\n"));
  ASSERT(m_pCD != NULL);
  
  CUINode* pUINode = reinterpret_cast<CUINode*>(wParam);
  CThreadQueryResult* pResult = reinterpret_cast<CThreadQueryResult*>(lParam);

  // ingnore if we are shutting down (i.e. not running state)
  if (m_pCD->m_pBackgroundThreadInfo->m_state == running)
  {
    m_pCD->_OnHaveData(pUINode, pResult);
  }
  else
  {
    // going down, eat up data
    if (pResult != NULL)
      delete pResult;
  }
  
  return 1;
}

LRESULT CHiddenWnd::OnThreadDoneNotification(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
  HRESULT ReturnedHr = (HRESULT)lParam;
  ASSERT(m_pCD != NULL);

  // ingnore if we are shutting down (i.e. not running state)
  if (m_pCD->m_pBackgroundThreadInfo->m_state == running)
  {
    CUINode* pUINode = reinterpret_cast<CUINode*>(wParam);
    m_pCD->_OnDone(pUINode, ReturnedHr);
  }

  return 1;
}

LRESULT CHiddenWnd::OnSheetCloseNotification(UINT, WPARAM wParam, LPARAM, BOOL&)
{
  ASSERT(m_pCD != NULL);
  CUINode* pUINode = reinterpret_cast<CUINode*>(wParam);
  m_pCD->_OnSheetClose(pUINode);
  return 1;
}

LRESULT CHiddenWnd::OnSheetCreateNotification(UINT, WPARAM wParam, LPARAM, BOOL&)
{
  ASSERT(m_pCD != NULL);
  PDSA_SEC_PAGE_INFO pDsaSecondaryPageInfo = reinterpret_cast<PDSA_SEC_PAGE_INFO>(wParam);
  ASSERT(pDsaSecondaryPageInfo != NULL);

  // ingnore if we are shutting down (i.e. not running state)
  if (m_pCD->m_pBackgroundThreadInfo->m_state == running)
  {
    m_pCD->_OnSheetCreate(pDsaSecondaryPageInfo);
  }

  ::LocalFree(pDsaSecondaryPageInfo);

  return 1;
}


LRESULT CHiddenWnd::OnRefreshAllNotification(UINT, WPARAM, LPARAM, BOOL&)
{
  ASSERT(m_pCD != NULL);
  // ingnore if we are shutting down (i.e. not running state)
  if (m_pCD->m_pBackgroundThreadInfo->m_state == running)
  {
    m_pCD->ForceRefreshAll();
  }
  return 1;
}

////////////////////////////////////////////////////////////////////
// CBackgroundThreadBase

CBackgroundThreadBase::CBackgroundThreadBase() 
{ 
  m_bAutoDelete = TRUE; 
  m_hWnd = NULL;
  m_pCD = NULL;
}

CBackgroundThreadBase::~CBackgroundThreadBase() 
{
}


BOOL CBackgroundThreadBase::Start(HWND hWnd, CDSComponentData* pCD)
{
  // this function executes in the context of the parent thread
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  ASSERT(::IsWindow(hWnd));
  m_hWnd = hWnd;
  m_pCD = pCD;
 
	return CreateThread();
}

BOOL CBackgroundThreadBase::InitInstance()
{ 
  // this function executes in the context of the child thread
  
  HRESULT hr = ::CoInitialize(NULL);
  if (FAILED(hr))
    return FALSE;

  return SUCCEEDED(hr); 
}

int CBackgroundThreadBase::ExitInstance()
{
  ::CoUninitialize();

  PostExitNotification();

//  Sleep(1000);
  return CWinThread::ExitInstance();
}


BOOL CBackgroundThreadBase::PostMessageToWnd(UINT msg, WPARAM wParam, LPARAM lParam)
{
	ASSERT(::IsWindow(m_hWnd));
	return ::PostMessage(m_hWnd, msg, wParam, lParam);
}



////////////////////////////////////////////////////////////////////
// CDispatcherThread

#define WORKER_THREAD_COUNT 2

CDispatcherThread::CDispatcherThread()
{
  m_nArrCount = WORKER_THREAD_COUNT;
  m_pThreadInfoArr = (CBackgroundThreadInfo*)malloc(m_nArrCount*sizeof(CBackgroundThreadInfo));
  if (m_pThreadInfoArr != NULL)
  {
    ZeroMemory(m_pThreadInfoArr, m_nArrCount*sizeof(CBackgroundThreadInfo));
  }
}


CDispatcherThread::~CDispatcherThread()
{
  free(m_pThreadInfoArr);
}

int CDispatcherThread::Run()
{
  TRACE(_T("CDispatcherThread::Run() starting\n"));

  BOOL bShuttingDown = FALSE;
	MSG msg;
	// initialize the message pump
	::PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
	
	// get let the main thread know we are entering the loop
  PostMessageToWnd(CHiddenWnd::s_ThreadStartNotificationMessage,0,0); 

  BOOL bQuit = FALSE;
	while(!bQuit && ::GetMessage(&msg, NULL, 0, 0))
	{
		switch(msg.message)
		{
    case DISPATCH_THREAD_RUN_MSG:
      {
        if (bShuttingDown)
        {
          // going down, eat up the message
          CDSThreadQueryInfo* pQueryInfo = reinterpret_cast<CDSThreadQueryInfo*>(msg.lParam);

          // reclaim memory in the queue
          delete pQueryInfo;
        }
        else                
        {
          // get a thread from the thread pool
          UINT nEntry = GetThreadEntryFromPool();
          ASSERT(m_pThreadInfoArr[nEntry].m_nThreadID != 0);
          ASSERT(m_pThreadInfoArr[nEntry].m_state == running);

          // forward the processing request to the thread from the pool
          ::PostThreadMessage(m_pThreadInfoArr[nEntry].m_nThreadID, 
                    DISPATCH_THREAD_RUN_MSG, msg.wParam, msg.lParam);

          // move the thread to a busy state
          m_pThreadInfoArr[nEntry].m_state = busy;
        }
      }
			break;
    case DISPATCH_THREAD_DONE_MSG:
      {
        UINT nThreadID = (UINT)(msg.wParam);
        ReturnThreadToPool(nThreadID);
      }
      break;
    case THREAD_SHUTDOWN_MSG:
      {
        TRACE(L"CDispatcherThread got THREAD_SHUTDOWN_MSG\n");

        ASSERT(!bShuttingDown);

        // asked to shut down
        bShuttingDown = TRUE;
        // if no threads running, we go down immediately
        // otherwise we have to wait for them to terminate
        bQuit = BroadcastShutDownAllThreads();

        TRACE(L"BroadcastShutDownAllThreads() returned bQuit = %d\n", bQuit);
      }
      break;
    case THREAD_SHUTDOWN_ACK_MSG:
      {
        TRACE(L"CDispatcherThread got THREAD_SHUTDOWN_ACK_MSG\n");

        ASSERT(bShuttingDown);

        // worker thread has gone down
        UINT nThreadID = (UINT)(msg.wParam);
        bQuit = MarkThreadAsTerminated(nThreadID);
        TRACE(L"MarkThreadAsTerminated() returned bQuit = %d\n", bQuit);
      }
      break;
		default:
      {
        // unknown message, just let it through
       ::DispatchMessage(&msg);
      } // default
    } //switch
  } // while
  
  ASSERT(bShuttingDown);

  // wait now for all the thread handles to become signalled
  WaitForAllWorkerThreadsToExit();

  TRACE(_T("CDispatcherThread::Run() is terminating\n"));

	return ExitInstance();
}

void CDispatcherThread::PostExitNotification()
{
  // we are finally done shutting down, let the main thread know
  // that we are going down
  PostMessageToWnd(CHiddenWnd::s_ThreadShutDownNotificationMessage, 0, 0); 
  TRACE(_T("CDispatcherThread::PostExitNotification() posted thread shutdown notification\n"));

}


UINT CDispatcherThread::_GetEntryFromArray()
{
  UINT nFreeSlot = m_nArrCount; // set as "not found"
  for (UINT k=0; k<m_nArrCount; k++)
  {
    if ( (m_pThreadInfoArr[k].m_nThreadID == 0) && (nFreeSlot == m_nArrCount))
      nFreeSlot = k; // remember the first free slot
    if ((m_pThreadInfoArr[k].m_nThreadID != 0) && (m_pThreadInfoArr[k].m_state == running))
      return k; // found an idle running thread
  }
  // not found any idle thread, return an empty slot
  if (nFreeSlot == m_nArrCount)
  {
    // no free space anymore, need to reallocate array
    int nAlloc = m_nArrCount*2;
	  m_pThreadInfoArr = (CBackgroundThreadInfo*)realloc(m_pThreadInfoArr, sizeof(CBackgroundThreadInfo)*nAlloc);
    ::ZeroMemory(&m_pThreadInfoArr[m_nArrCount], sizeof(CBackgroundThreadInfo)*m_nArrCount);
    nFreeSlot = m_nArrCount; // first free in new block
  	m_nArrCount = nAlloc;
  }
  return nFreeSlot;
}

UINT CDispatcherThread::GetThreadEntryFromPool()
{
  UINT nEntry = _GetEntryFromArray();

  // if the entry is empty, need to 
  // spawn a thread and wait it is running
  if (m_pThreadInfoArr[nEntry].m_nThreadID == 0)
  {
    // create the thread
    CWorkerThread* pThreadObj = new CWorkerThread(m_nThreadID);
    ASSERT(pThreadObj != NULL);
    if (pThreadObj == NULL)
	    return 0;

    // start the the thread
    ASSERT(m_pThreadInfoArr[nEntry].m_hThreadHandle == NULL);
    ASSERT(m_pThreadInfoArr[nEntry].m_state == notStarted);

    ASSERT(pThreadObj->m_bAutoDelete);

    if (!pThreadObj->Start(GetHiddenWnd(),GetCD()))
	    return 0;


    ASSERT(pThreadObj->m_nThreadID != 0);
    ASSERT(pThreadObj->m_hThread != NULL);
  
    // copy the thread info we need from the thread object
    m_pThreadInfoArr[nEntry].m_hThreadHandle = pThreadObj->m_hThread;
    m_pThreadInfoArr[nEntry].m_nThreadID = pThreadObj->m_nThreadID;

    // wait for the thread to start
    MSG msg;
    while(TRUE)
	  {
		  if (::PeekMessage(&msg,(HWND)-1,WORKER_THREAD_START_MSG, WORKER_THREAD_START_MSG,
										  PM_REMOVE))
		  {
        TRACE(_T("CDispatcherThread::GetThreadFromPool() got WORKER_THREAD_START_MSG\n"));
        m_pThreadInfoArr[nEntry].m_state = running;
        break;
		  }
    } // while

  } // if

  ASSERT(m_pThreadInfoArr[nEntry].m_state == running);
  ASSERT(m_pThreadInfoArr[nEntry].m_nThreadID != 0);

  return nEntry;
}

void CDispatcherThread::ReturnThreadToPool(UINT nThreadID)
{
  ASSERT(nThreadID != 0);
  for (UINT k=0; k<m_nArrCount; k++)
  {
    if (m_pThreadInfoArr[k].m_nThreadID == nThreadID)
    {
      // return the thread to a busy state
      m_pThreadInfoArr[k].m_state = running;
      return;
    }
  }
  ASSERT(FALSE); // should never get here
}

BOOL CDispatcherThread::BroadcastShutDownAllThreads()
{
  BOOL bQuit = TRUE;
  for (UINT k=0; k<m_nArrCount; k++)
  {
    if (m_pThreadInfoArr[k].m_nThreadID != 0)
    {
      ::PostThreadMessage(m_pThreadInfoArr[k].m_nThreadID, THREAD_SHUTDOWN_MSG,0,0);
      bQuit = FALSE;
    }
  }
  TRACE(L"CDispatcherThread::BroadcastShutDownAllThreads() returning %d\n", bQuit);
  return bQuit;
}


BOOL CDispatcherThread::MarkThreadAsTerminated(UINT nThreadID)
{
  TRACE(L"CDispatcherThread::MarkThreadAsTerminated()\n");

  ASSERT(nThreadID != 0);
  for (UINT k=0; k<m_nArrCount; k++)
  {
    if (m_pThreadInfoArr[k].m_nThreadID == nThreadID)
    {
      // mark the thread as done
      TRACE(L"marking thread k = %d as terminated\n", k);
      ASSERT(m_pThreadInfoArr[k].m_state == running);
      m_pThreadInfoArr[k].m_state = terminated;
      break;
    }
  }

  // check if all the threads are terminated
  for (k=0; k<m_nArrCount; k++)
  {
    if ((m_pThreadInfoArr[k].m_nThreadID != 0) &&
         (m_pThreadInfoArr[k].m_state != terminated))
    {
      // at least one thread is still running
      return FALSE;
    }
  }
  // all the threads are gone (terminated state)
  return TRUE;
}


void CDispatcherThread::WaitForAllWorkerThreadsToExit()
{
  TRACE(L"CDispatcherThread::WaitForAllWorkerThreadsToExit()\n");

  // wait for the dispatcher thread handle to become signalled
  
  DWORD nCount = 0;

  HANDLE* pHandles = new HANDLE[m_nArrCount];
  if (!pHandles)
  {
    TRACE(L"Failed to allocate space for the handles\n");
    return;
  }

  ::ZeroMemory(pHandles, sizeof(HANDLE)*m_nArrCount);

  for (UINT k=0; k<m_nArrCount; k++)
  {
    if (m_pThreadInfoArr[k].m_nThreadID != 0)
    {
      TRACE(L"m_pThreadInfoArr[%d].m_state = %d\n", k, m_pThreadInfoArr[k].m_state);

      ASSERT(m_pThreadInfoArr[k].m_state == terminated);
      ASSERT(m_pThreadInfoArr[k].m_hThreadHandle != NULL);
      pHandles[nCount++] = m_pThreadInfoArr[k].m_hThreadHandle;
    }
  }

  if (nCount == 0)
  {
    TRACE(L"WARNING: no worker threads to wait for!!!\n");
    return;
  }
  
  TRACE(L"before WaitForThreadShutdown() loop on %d worker threads\n", nCount);

  WaitForThreadShutdown(pHandles, nCount);

  TRACE(L"after WaitForThreadShutdown() loop on worker threads\n"); 


#if (FALSE)

  TRACE(L"before WaitForMultipleObjects() on worker threads\n");

  WaitForMultipleObjects(nCount, pHandles, TRUE /*fWaitAll*/, INFINITE);

  TRACE(L"after WaitForMultipleObjects() on worker threads\n");
#endif

  delete[] pHandles;
  pHandles = 0;
}

////////////////////////////////////////////////////////////////////
// CWorkerThread

CWorkerThread::CWorkerThread(UINT nParentThreadID) 
  : m_nMaxQueueLength(49)
{
  ASSERT(nParentThreadID != 0);
  m_nParentThreadID = nParentThreadID;
  m_bQuit = FALSE;

  m_pCurrentQueryResult = NULL;
  m_currWParamCookie = 0;
}

CWorkerThread::~CWorkerThread()
{
  ASSERT(m_pCurrentQueryResult == NULL);
 
}

int CWorkerThread::Run()
{
  HRESULT hr = S_OK;
  TRACE(_T("CWorkerThread::Run() starting\n"));
  MSG msg;
  // initialize the message pump
  ::PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
  
  // get let the main thread know we are entering the loop
  ::PostThreadMessage(m_nParentThreadID, WORKER_THREAD_START_MSG, 0,0); 

  ASSERT(m_bQuit == FALSE);

  while(!m_bQuit && ::GetMessage(&msg, NULL, 0, 0))
  {
    if(msg.message == DISPATCH_THREAD_RUN_MSG)
    {
      m_currWParamCookie = msg.wParam;
      //::MessageBox(NULL, _T("Wait"), _T("Thread"), MB_OK);
      CThreadQueryInfo* pQueryInfo = reinterpret_cast<CThreadQueryInfo*>(msg.lParam);
      hr = GetCD()->QueryFromWorkerThread(pQueryInfo, this); 
      
      // make sure we flush the result set
      SendCurrentQueryResult();
      
      // if we had to many items, let the hidden window know
      if (pQueryInfo->m_bTooMuchData)
      {
        PostMessageToWnd(CHiddenWnd::s_ThreadTooMuchDataNotificationMessage, 
                         m_currWParamCookie, (LPARAM)0);
      }
      delete pQueryInfo; // not needed anymore

      // tell the hidden window we are done
      PostMessageToWnd(CHiddenWnd::s_ThreadDoneNotificationMessage, 
                       m_currWParamCookie, (LPARAM)hr);
      // tell the dispatcher thread we are done processing
      ::PostThreadMessage(m_nParentThreadID, DISPATCH_THREAD_DONE_MSG, m_nThreadID,0);
      m_currWParamCookie = 0; // reset
    }
    else if (msg.message == THREAD_SHUTDOWN_MSG)
    {
      TRACE(_T("CWorkerThread::Run() got THREAD_SHUTDOWN_MSG\n"));
      m_bQuit = TRUE;
    }
    else
    {
      // unknown message, just let it through
      ::DispatchMessage(&msg);
    }
  } // while
  
  TRACE(_T("CWorkerThread::Run() is terminating\n"));
  return ExitInstance();
}

void CWorkerThread::PostExitNotification()
{
  // we are finally done shutting down, let the main thread know
  // that we are going down
  ::PostThreadMessage(m_nParentThreadID, THREAD_SHUTDOWN_ACK_MSG, m_nThreadID,0);
  TRACE(_T("CWorkerThread::PostExitNotification() posted THREAD_SHUTDOWN_ACK_MSG, m_nThreadID = 0x%x\n"), 
          m_nThreadID);
}

void CWorkerThread::AddToQueryResult(CUINode* pUINode)
{
  ASSERT(!m_bQuit);

  if (m_pCurrentQueryResult == NULL)
  {
    m_pCurrentQueryResult = new CThreadQueryResult;
  }
  ASSERT(m_pCurrentQueryResult != NULL);
  m_pCurrentQueryResult->m_nodeList.AddTail(pUINode);
  if (m_pCurrentQueryResult->m_nodeList.GetCount() > m_nMaxQueueLength)
    SendCurrentQueryResult();


  // check to see if we are forced to abort
  MSG msg;
	if (::PeekMessage(&msg,(HWND)-1,THREAD_SHUTDOWN_MSG, THREAD_SHUTDOWN_MSG,
									PM_REMOVE))
	{
    TRACE(_T("CWorkerThread::AddToQueryResult() got THREAD_SHUTDOWN_MSG\n"));
    m_bQuit = TRUE;
	}
 
}

void CWorkerThread::SendCurrentQueryResult()
{
  if(m_pCurrentQueryResult != NULL)
  {
    // wParam has the cookie, that we just ship back
    PostMessageToWnd(CHiddenWnd::s_ThreadHaveDataNotificationMessage, 
                    m_currWParamCookie, reinterpret_cast<LPARAM>(m_pCurrentQueryResult)); 
    m_pCurrentQueryResult = NULL;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\dsthread.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dsthread.h
//
//--------------------------------------------------------------------------


#ifndef __DSTHREAD_H__
#define __DSTHREAD_H__

////////////////////////////////////////////////////////////////////
// thread messages

// dispatcher thread posts to worker thread to run query
#define DISPATCH_THREAD_RUN_MSG   (WM_USER + 100)

// worker thread posts to dispatcher thread once done with the query
#define DISPATCH_THREAD_DONE_MSG  (WM_USER + 101)

// worker thread posts to dispatcher thread to ack startup
#define WORKER_THREAD_START_MSG   (WM_USER + 102)

// message posted to threads to ask for shutdown
#define THREAD_SHUTDOWN_MSG   (WM_USER + 103)

// message posted to threads to ack shutdown
#define THREAD_SHUTDOWN_ACK_MSG   (WM_USER + 104)

void WaitForThreadShutdown(HANDLE* hThreadArray, DWORD dwCount);

////////////////////////////////////////////////////////////////////
// forward declarations

class CDSComponentData;

////////////////////////////////////////////////////////////////////
// CHiddenWnd

class CHiddenWnd : public CWindowImpl<CHiddenWnd>
{
public:
  DECLARE_WND_CLASS(L"DSAHiddenWindow")

  static const UINT s_ThreadStartNotificationMessage;
  static const UINT s_ThreadTooMuchDataNotificationMessage;
  static const UINT s_ThreadHaveDataNotificationMessage;
  static const UINT s_ThreadDoneNotificationMessage;
  static const UINT s_SheetCloseNotificationMessage;
  static const UINT s_SheetCreateNotificationMessage;
  static const UINT s_RefreshAllNotificationMessage;
  static const UINT s_ThreadShutDownNotificationMessage;

  CHiddenWnd(CDSComponentData* pCD)
  {
    ASSERT(pCD != NULL);
    m_pCD = pCD;
  }

	BOOL Create(); 	
	
  // message handlers
  LRESULT OnThreadStartNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnThreadTooMuchDataNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnThreadHaveDataNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnThreadDoneNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnSheetCloseNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnSheetCreateNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnRefreshAllNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnThreadShutDownNotification(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);


  BEGIN_MSG_MAP(CHiddenWnd)
    MESSAGE_HANDLER( CHiddenWnd::s_ThreadStartNotificationMessage, OnThreadStartNotification )
    MESSAGE_HANDLER( CHiddenWnd::s_ThreadTooMuchDataNotificationMessage, OnThreadTooMuchDataNotification )
    MESSAGE_HANDLER( CHiddenWnd::s_ThreadHaveDataNotificationMessage, OnThreadHaveDataNotification )
    MESSAGE_HANDLER( CHiddenWnd::s_ThreadDoneNotificationMessage, OnThreadDoneNotification )
    MESSAGE_HANDLER( CHiddenWnd::s_SheetCloseNotificationMessage, OnSheetCloseNotification )
    MESSAGE_HANDLER( CHiddenWnd::s_SheetCreateNotificationMessage, OnSheetCreateNotification )
    MESSAGE_HANDLER( CHiddenWnd::s_RefreshAllNotificationMessage, OnRefreshAllNotification )
    MESSAGE_HANDLER( CHiddenWnd::s_ThreadShutDownNotificationMessage, OnThreadShutDownNotification )
  END_MSG_MAP()

private:
  CDSComponentData* m_pCD;
};

////////////////////////////////////////////////////////////////////
// CBackgroundThreadInfo

enum ThreadState { notStarted=0, running, busy, shuttingDown, terminated };

struct CBackgroundThreadInfo
{
  CBackgroundThreadInfo()
  {
    m_nThreadID = 0;
    m_hThreadHandle = 0;
    m_state = notStarted;
  }

  UINT m_nThreadID;     // thread ID if the thread
  HANDLE m_hThreadHandle; // thread handle of the thread
  ThreadState m_state;
};


////////////////////////////////////////////////////////////////////
// CBackgroundThreadBase

class CBackgroundThreadBase : public CWinThread
{
public:
	CBackgroundThreadBase(); 
  ~CBackgroundThreadBase();

	BOOL Start(HWND hWnd, CDSComponentData* pCD);
	virtual BOOL InitInstance();// MFC override
  virtual int ExitInstance();
  virtual int Run() { return -1;} // // MFC override, need to override

protected:
	BOOL PostMessageToWnd(UINT msg, WPARAM wParam, LPARAM lParam);
  HWND GetHiddenWnd() { ASSERT(m_hWnd!= NULL); return m_hWnd;}
  CDSComponentData*  GetCD() { ASSERT(m_pCD); return m_pCD;}

  virtual void PostExitNotification() {}

private:
	HWND					m_hWnd;    // hidden window handle

  CDSComponentData* m_pCD;
};



////////////////////////////////////////////////////////////////////
// CDispatcherThread

class CDispatcherThread : public CBackgroundThreadBase
{
public:
	CDispatcherThread();
  ~CDispatcherThread();

  virtual int Run();

protected:
  virtual void PostExitNotification();

private:

  UINT GetThreadEntryFromPool();
  void ReturnThreadToPool(UINT nThreadID);
  BOOL BroadcastShutDownAllThreads();
  BOOL MarkThreadAsTerminated(UINT nThreadID);
  void WaitForAllWorkerThreadsToExit();

  UINT _GetEntryFromArray();
  UINT m_nArrCount;
  CBackgroundThreadInfo* m_pThreadInfoArr;
};



////////////////////////////////////////////////////////////////////
// CWorkerThread

class CWorkerThread : public CBackgroundThreadBase
{
public:
  CWorkerThread(UINT nParentThreadID);
  ~CWorkerThread();

  virtual int Run();

  void AddToQueryResult(CUINode* pUINode);
  void SendCurrentQueryResult();
  BOOL MustQuit() { return m_bQuit; }

protected:
  virtual void PostExitNotification();

private:
  UINT m_nParentThreadID;
  BOOL m_bQuit;

  CThreadQueryResult* m_pCurrentQueryResult;
  WPARAM m_currWParamCookie;

  const int m_nMaxQueueLength;
};






//////////////////////////////////////////////////////////////////////







#endif // __DSTHREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\fsmoui.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       fsmoui.cpp
//
//--------------------------------------------------------------------------


// File: fsmoui.cpp

#include "stdafx.h"

#include "dsutil.h"
#include "util.h"
#include "uiutil.h"

#include "fsmoui.h"

#include "helpids.h"
#include "dsgetdc.h"      //DsEnumerateDomainTrusts
#include "lm.h"           //NetApiBufferFree

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////
// CFsmoPropertyPage

BEGIN_MESSAGE_MAP(CFsmoPropertyPage, CPropertyPage)
  ON_BN_CLICKED(IDC_CHANGE_FSMO, OnChange)
  ON_WM_HELPINFO()
END_MESSAGE_MAP()


CFsmoPropertyPage::CFsmoPropertyPage(CFsmoPropertySheet* pSheet, FSMO_TYPE fsmoType)
{
  m_pSheet = pSheet;
  m_fsmoType = fsmoType;

  // load the caption (tab control text) depending on the FSMO type
  UINT nIDCaption = 0;
  switch (m_fsmoType)
  {
  case RID_POOL_FSMO:
    nIDCaption = IDS_RID_POOL_FSMO;
    break;
  case PDC_FSMO:
    nIDCaption = IDS_PDC_FSMO;
    break;
  case INFRASTUCTURE_FSMO:
    nIDCaption = IDS_INFRASTRUCTURE_FSMO;
    break;
  };
  Construct(IDD_FSMO_PAGE, nIDCaption);
}



BOOL CFsmoPropertyPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

  //
  // We just want a close button since we are not applying any changes
  // directly from this page
  //
  ::SendMessage(GetParent()->GetSafeHwnd(), PSM_CANCELTOCLOSE, 0, 0);

  // init the status (online/offline) control)
  m_fsmoServerState.Init(::GetDlgItem(m_hWnd, IDC_STATIC_FSMO_STATUS));

  // set the server we are focused on
  SetDlgItemText(IDC_EDIT_CURRENT_DC, m_pSheet->GetBasePathsInfo()->GetServerName());

  // set the FSMO description
  CString szDesc;
  switch (m_fsmoType)
  {
  case RID_POOL_FSMO:
    VERIFY(szDesc.LoadString(IDS_RID_POOL_FSMO_DESC));
    break;
  case PDC_FSMO:
    VERIFY(szDesc.LoadString(IDS_PDC_FSMO_DESC));
    break;
  case INFRASTUCTURE_FSMO:
    VERIFY(szDesc.LoadString(IDS_INFRASTRUCTURE_FSMO_DESC));
    break;
  };
  SetDlgItemText(IDC_STATIC_FSMO_DESC, szDesc);

  { // scope for the wait cursor object
    CWaitCursor wait;
    // retrieve the FSMO owner
    MyBasePathsInfo fsmoOwnerInfo;
    PWSTR pszFsmoOwner = 0;
    HRESULT hr = FindFsmoOwner(m_pSheet->GetBasePathsInfo(), m_fsmoType, &fsmoOwnerInfo, 
                               &pszFsmoOwner);
    if (SUCCEEDED(hr) && pszFsmoOwner)
    {
      m_szFsmoOwnerServerName = pszFsmoOwner;
      delete[] pszFsmoOwner;
      pszFsmoOwner = 0;
    }

    _SetFsmoServerStatus(SUCCEEDED(hr));
  }

  return TRUE; 
}

#ifdef DBG
UINT GetInfoFromIniFileIfDBG(LPCWSTR lpszSection, LPCWSTR lpszKey, INT nDefault = 0)
{
  static LPCWSTR lpszFile = L"\\system32\\dsadmin.ini";

  WCHAR szFilePath[2*MAX_PATH];
	UINT nLen = ::GetSystemWindowsDirectory(szFilePath, 2*MAX_PATH);
	if (nLen == 0)
		return nDefault;

  wcscat(szFilePath, lpszFile);
  return ::GetPrivateProfileInt(lpszSection, lpszKey, nDefault, szFilePath);
}
#endif


void CFsmoPropertyPage::OnChange()
{
// Test stuff
/*
  {
    HRESULT hrTest = E_OUTOFMEMORY;
    BOOL bTest = AllowForcedTransfer(hrTest);
    return;
  }
*/

  // verify we have different servers
  if (m_szFsmoOwnerServerName.CompareNoCase(m_pSheet->GetBasePathsInfo()->GetServerName()) == 0)
  {
    ReportErrorEx(m_hWnd,IDS_WARNING_FSMO_CHANGE_FOCUS,S_OK,
                   MB_OK | MB_ICONERROR, NULL, 0);
    return;
  }

  bool bConfirm = false;  //ask for confirmation only once

  if( m_fsmoType == INFRASTUCTURE_FSMO )
  {
     //check if target DC is GC
     //Try to bind to GC port, fails if not GC
    IADs    *pObject;
    HRESULT hr1;
    CString strServer = L"GC://";
    strServer += m_pSheet->GetBasePathsInfo()->GetServerName();
    hr1 = DSAdminOpenObject(strServer, 
                            IID_IADs,
                            (void**) &pObject,
                            TRUE /*bServer*/);

    if (SUCCEEDED(hr1)) 
    {
      //Release Interface, we don't need it
      pObject->Release();
      //Check if domain has any trusted domains
      DS_DOMAIN_TRUSTS *Domains;
      DWORD result;
      ULONG DomainCount=0;
      result = DsEnumerateDomainTrusts (
                  (LPWSTR)m_pSheet->GetBasePathsInfo()->GetServerName(),
                  DS_DOMAIN_DIRECT_OUTBOUND|
                  DS_DOMAIN_DIRECT_INBOUND,
                  &Domains,
                  &DomainCount
                  );

      if( HRESULT_CODE(result) == NO_ERROR  )
      {
        if( DomainCount > 0 )
        {

          //If all the trusted domains are downlevel, it doesn't matter
          bool bAllDownLevel = true;
          for( ULONG i = 0; i < DomainCount; ++i )
          {
            if( Domains[i].DnsDomainName != NULL )
            {
              bAllDownLevel = false;
              break;
            }
          }
        
          NetApiBufferFree( Domains );
  
          if( false == bAllDownLevel )
          {
            LPTSTR ptzFormat = NULL;
            LPTSTR ptzMessage = NULL;
            int cch = 0;
            INT_PTR retval;
            // load message format
            if (!LoadStringToTchar(IDS_IFSMO_TARGET_DC_IS_GC, &ptzFormat))
            {
                ASSERT(FALSE);
            }
            PVOID apv[2] = {
              NULL,
              (LPWSTR)m_pSheet->GetBasePathsInfo()->GetServerName()
            };

            // generate actual message
            cch =               FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                                | FORMAT_MESSAGE_FROM_STRING
                                | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                ptzFormat,
                                NULL,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (PTSTR)&ptzMessage, 0, (va_list*)apv);
            if (!cch)
            {
                ASSERT(FALSE);
            }


            CMoreInfoMessageBox dlg(m_hWnd, 
                    m_pSheet->GetIDisplayHelp(),
                    TRUE );
            dlg.SetMessage(ptzMessage);
            dlg.SetURL(DSADMIN_MOREINFO_FSMO_TARGET_DC_IS_GC);
            retval = dlg.DoModal();
        
            bConfirm = true;
            //clean up
            if( NULL != ptzFormat )
                delete ptzFormat;
            if( NULL != ptzMessage )
                 LocalFree(ptzMessage);

            if( retval == IDCANCEL )
              return;
          }
        }   

      }

    }
  }

  // make sure the user wants to do it
  if (!bConfirm && ReportErrorEx(m_hWnd,IDS_CHANGE_FSMO_CONFIRMATION,S_OK,
                   MB_YESNO | MB_ICONWARNING, NULL, 0) != IDYES)
    return;

  // try a graceful transfer
  HRESULT hr;
  
  { // scope for the wait cursor object
    CWaitCursor wait;

    if ( m_fsmoType == PDC_FSMO )
    {
      hr = CheckpointFsmoOwnerTransfer(m_pSheet->GetBasePathsInfo());

      TRACE(_T("back from Checkpoint API, hr is %lx\n"), hr);
      if (FAILED(hr))
      {
        //
        // See if we are in native mode or mixed mode
        //
        BOOL bMixedMode = TRUE;
        CString szDomainRoot;
        m_pSheet->GetBasePathsInfo()->GetDefaultRootPath(szDomainRoot);
    
        if (!szDomainRoot.IsEmpty())
        {
          //
          // bind to the domain object
          //
          CComPtr<IADs> spDomainObj;
          hr = DSAdminOpenObject(szDomainRoot,
                                 IID_IADs,
                                 (void **) &spDomainObj,
                                 TRUE /*bServer*/);
          if (SUCCEEDED(hr)) 
          {
            //
            // retrieve the mixed node attribute
            //
            CComVariant Mixed;
            CComBSTR bsMixed(L"nTMixedDomain");
            spDomainObj->Get(bsMixed, &Mixed);
            bMixedMode = (BOOL)Mixed.bVal;
          }
        }

        if (bMixedMode)
        {
          if (ReportErrorEx(m_hWnd, IDS_CHANGE_FSMO_CHECKPOINT_FAILED, S_OK,
                MB_OKCANCEL | MB_ICONWARNING, NULL, 0) != IDOK)
          {
            return;
          }
        }
        else
        {
          if (ReportErrorEx(m_hWnd, IDS_CHANGE_FSMO_CHECKPOINT_FAILED_NATIVEMODE, S_OK,
               MB_OKCANCEL | MB_ICONWARNING, NULL, 0) != IDOK)
          {
            return;
          }
        }
      }
    }
    hr = GracefulFsmoOwnerTransfer(m_pSheet->GetBasePathsInfo(), m_fsmoType);
  }

  if (FAILED(hr))
  {
    if (!AllowForcedTransfer(hr))
      return; 

    // try the forced transfer
    CWaitCursor wait;
    hr = ForcedFsmoOwnerTransfer(m_pSheet->GetBasePathsInfo(), m_fsmoType);
  }

  if (SUCCEEDED(hr))
  {
    m_szFsmoOwnerServerName = m_pSheet->GetBasePathsInfo()->GetServerName();
    _SetFsmoServerStatus(TRUE);
    ReportErrorEx(m_hWnd,IDS_CHANGE_FSMO_SUCCESS,S_OK,
                   MB_OK, NULL, 0);
  }
  else
  {
    ReportErrorEx(m_hWnd, IDS_ERROR_CHANGE_FSMO_OWNER, hr,
                  MB_OK | MB_ICONERROR, NULL, 0);
  }

}




void CFsmoPropertyPage::_SetFsmoServerStatus(BOOL bOnLine)
{
  // set the FSMO owner server name
  if (m_szFsmoOwnerServerName.IsEmpty())
  {
    CString szError;
    szError.LoadString(IDS_FSMO_SERVER_ERROR);
    SetDlgItemText(IDC_EDIT_CURRENT_FSMO_DC, szError);
  }
  else
  {
    SetDlgItemText(IDC_EDIT_CURRENT_FSMO_DC, m_szFsmoOwnerServerName);
  }
  // set the status of the FSMO owner server
  m_fsmoServerState.SetToggleState(bOnLine);
}

void CFsmoPropertyPage::OnHelpInfo(HELPINFO * pHelpInfo ) 
{
  TRACE(_T("OnHelpInfo: CtrlId = %d, ContextId = 0x%x\n"),
           pHelpInfo->iCtrlId, pHelpInfo->dwContextId);
  if (pHelpInfo->iCtrlId < 1)  {
    return;
  }

  DWORD_PTR HelpArray = 0;

  switch (m_fsmoType)
    {
    case RID_POOL_FSMO:
      HelpArray = (DWORD_PTR)g_aHelpIDs_IDD_RID_FSMO_PAGE;
      break;
    case PDC_FSMO:
      HelpArray = (DWORD_PTR)g_aHelpIDs_IDD_PDC_FSMO_PAGE;
      break;
    case INFRASTUCTURE_FSMO:
      HelpArray = (DWORD_PTR)g_aHelpIDs_IDD_INFRA_FSMO_PAGE;
      break;
    };
  
  ::WinHelp((HWND)pHelpInfo->hItemHandle,
            DSADMIN_CONTEXT_HELP_FILE,
            HELP_WM_HELP,
            HelpArray); 
}



void ChangeFormatParamOnString(CString& szFmt)
{
  int nPos = szFmt.Find(L"%1");
  if (nPos == -1)
    return;
  szFmt.SetAt(nPos+1, L's');
}


BOOL CFsmoPropertyPage::AllowForcedTransfer(HRESULT hr)
{
  BOOL bAllow = FALSE;
  PWSTR pszError = 0;
  StringErrorFromHr(hr, &pszError);

  // retrieve the DWORD error code 
  DWORD dwErr = (hr & 0x0000FFFF); 

  if ( (dwErr != ERROR_ACCESS_DENIED) && 
       ((m_fsmoType == PDC_FSMO) || (m_fsmoType == INFRASTUCTURE_FSMO)))
  {
    // allow forced, so ask
    CString szFmt, szMsg;
    szFmt.LoadString(IDS_CHANGE_FSMO_CONFIRMATION_FORCED);
    szMsg.Format(szFmt, pszError);

    CMoreInfoMessageBox dlg(m_hWnd, m_pSheet->GetIDisplayHelp(), TRUE);
    dlg.SetMessage(szMsg);
    dlg.SetURL((m_fsmoType == PDC_FSMO) ? 
                DSADMIN_MOREINFO_PDC_FSMO_TOPIC : 
                DSADMIN_MOREINFO_INFRASTUCTURE_FSMO_TOPIC);
    if (dlg.DoModal() == IDOK)
      bAllow = TRUE;
  }
  else
  {
    // warn only, no forced transfer option
    CString szFmt, szMsg;
    szFmt.LoadString(IDS_ERROR_CHANGE_FSMO_OWNER);

    // this format string has the replaceable parameter marked as %1
    // we need it changed into %s

    ChangeFormatParamOnString(szFmt);

    szMsg.Format(szFmt, pszError);

    CMoreInfoMessageBox dlg(m_hWnd, m_pSheet->GetIDisplayHelp(), FALSE);
    dlg.SetMessage(szMsg);
    dlg.SetURL(DSADMIN_MOREINFO_RID_POOL_FSMO_TOPIC);
    dlg.DoModal();
  }

  if (pszError)
  {
    delete[] pszError;
    pszError = 0;
  }

  
  return bAllow;
}
 


//////////////////////////////////////////////////////////////////
// CFsmoPropertySheet

int CALLBACK CFsmoPropertySheet::PropSheetCallBack(HWND hwndDlg, 
                                                   UINT uMsg, 
                                                   LPARAM)
{

  switch (uMsg) {
  case PSCB_INITIALIZED:
    DWORD dwStyle = GetWindowLong (hwndDlg, GWL_EXSTYLE);
    dwStyle |= WS_EX_CONTEXTHELP;
    SetWindowLong (hwndDlg, GWL_EXSTYLE, dwStyle);
    break;
  }
  return 0;
}


CFsmoPropertySheet::CFsmoPropertySheet(MyBasePathsInfo* pInfo, 
                                       HWND HWndParent,
                                       IDisplayHelp* pIDisplayHelp,
                                       LPCWSTR) :
  m_spIDisplayHelp(pIDisplayHelp), m_pInfo(pInfo),
    m_page1(this, RID_POOL_FSMO), m_page2(this, PDC_FSMO), m_page3(this, INFRASTUCTURE_FSMO)
{
  // build the sheet title
  CString szTitle;
  szTitle.LoadString(IDS_FSMO_SHEET_TITLE);

  // delayed construction
  Construct(szTitle, CWnd::FromHandle(HWndParent));
  m_psh.dwFlags |= PSH_NOAPPLYNOW | PSH_USECALLBACK;
  m_psh.pfnCallback = PropSheetCallBack;

  
  AddPage(&m_page1);
  AddPage(&m_page2);
  AddPage(&m_page3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\mybasepathsinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      MyBasePathsInfo.h
//
//  Contents:  Thin wrapper around dsadminlib CDSBasePathsInfo class
//             to deal with memory management of strings
//
//  History:   04/02/2001 jeffjon    Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"


void MyBasePathsInfo::ComposeADsIPath(CString& szPath, IN LPCWSTR lpszNamingContext)
{
  int result = 0;
  szPath.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::ComposeADsIPath(&pszPath, lpszNamingContext);
  
  if (pszPath && result)
  {
     szPath = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetSchemaPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetSchemaPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetConfigPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetConfigPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetDefaultRootPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetDefaultRootPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetRootDSEPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetRootDSEPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetAbstractSchemaPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetAbstractSchemaPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetPartitionsPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetPartitionsPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetSchemaObjectPath(IN LPCWSTR lpszObjClass, CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetSchemaObjectPath(lpszObjClass, &pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

void MyBasePathsInfo::GetInfrastructureObjectPath(CString& s)
{
  int result = 0;
  s.Empty();

  PWSTR pszPath = 0;
  result = CDSBasePathsInfo::GetInfrastructureObjectPath(&pszPath);
  
  if (pszPath && result)
  {
     s = pszPath;

     delete[] pszPath;
     pszPath = 0;
  }
  else
  {
     ASSERT(pszPath);
  }
  ASSERT(result);
}

HRESULT GetADSIServerName(CString& szServer, IN IUnknown* pUnk)
{
  PWSTR pszServer = 0;
  HRESULT hr = GetADSIServerName(&pszServer, pUnk);
  if (SUCCEEDED(hr) && pszServer)
  {
    szServer = pszServer;

    delete[] pszServer;
    pszServer = 0;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\gencreat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       gencreat.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	gencreat.cpp
//
//	Implementation of the "Generic Create" wizard.
//
//	DATATYPES SUPPORTED
//	- Unicode strings
//	- Unsigned long decimal integers (32 bits)
//	- Signed long decimal integers (32 bits)
//	- Numeric decimal strings
//	- Boolean flags
//
//	TO BE DONE
//	- 32 bit hexadecimal integers
//	- 64 bit hexadecimal integers
//	- Blob
//	- Distinguished Names with a "Browse" button
//
//	HISTORY
//	21-Aug-97	Dan Morin	Creation.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "util.h"
#include "uiutil.h"

#include "newobj.h"		// CNewADsObjectCreateInfo : NOTE: this has to be before gencreat.h
#include "gencreat.h"

#include "schemarc.h"


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
static const SCHEMA_ATTR_SYNTAX_INFO g_rgSchemaAttrSyntaxInfo[] =
{
  { L"2.5.5.1",  IDS_SCHEMA_ATTR_SYNTAX_DN, VT_BSTR },		  // "Distinguished Name"
  { L"2.5.5.2",  IDS_SCHEMA_ATTR_SYNTAX_OID, VT_BSTR },		  // "Object Identifier"
  { L"2.5.5.3",  IDS_SCHEMA_ATTR_SYNTAX_CASE_STR, VT_BSTR },    // "Case Sensitive String"
  { L"2.5.5.4",  IDS_SCHEMA_ATTR_SYNTAX_NOCASE_STR, VT_BSTR },  // "Case Insensitive String"
  { L"2.5.5.5",  IDS_SCHEMA_ATTR_SYNTAX_PRCS_STR, VT_BSTR },    // "Print Case String"
  { L"2.5.5.6",  IDS_SCHEMA_ATTR_SYNTAX_NUMSTR, VT_BSTR },      // "Numerical String"
  { L"2.5.5.7",  IDS_SCHEMA_ATTR_SYNTAX_OR_NAME, VT_BSTR },     // "OR Name"
  { L"2.5.5.8",  IDS_SCHEMA_ATTR_SYNTAX_BOOLEAN, VT_BOOL },     // "Boolean"
  { L"2.5.5.9",  IDS_SCHEMA_ATTR_SYNTAX_INTEGER, VT_I4 },       // "Integer"
  { L"2.5.5.10", IDS_SCHEMA_ATTR_SYNTAX_OCTET, VT_BSTR },       // "Octet String"
  { L"2.5.5.11", IDS_SCHEMA_ATTR_SYNTAX_UTC, VT_BSTR },         // "UTC Coded Time"
  { L"2.5.5.12", IDS_SCHEMA_ATTR_SYNTAX_UNICODE, VT_BSTR },     // "Unicode String"
  { L"2.5.5.13", IDS_SCHEMA_ATTR_SYNTAX_ADDRESS, VT_BSTR },     // "Address"
  { L"2.5.5.14", IDS_SCHEMA_ATTR_SYNTAX_DNADDR, VT_BSTR },      // "Distname Address"
  { L"2.5.5.15", IDS_SCHEMA_ATTR_SYNTAX_SEC_DESC, VT_BSTR },    // "NT Security Descriptor"
  { L"2.5.5.16", IDS_SCHEMA_ATTR_SYNTAX_LINT, VT_I8 },          // "Large Integer"
  { L"2.5.5.17", IDS_SCHEMA_ATTR_SYNTAX_SID, VT_BSTR },         // "SID"
  { NULL, IDS_UNKNOWN, VT_BSTR }		// Must be last
};


/////////////////////////////////////////////////////////////////////
//	PFindSchemaAttrSyntaxInfo()
//
//	Search the array g_rgSchemaAttrSyntaxInfo and match the
//	syntax OID.
//
//	This function NEVER return NULL.  If no match found, the
//	function will return pointer to the last entry in the table.
//	
const SCHEMA_ATTR_SYNTAX_INFO *
PFindSchemaAttrSyntaxInfo(LPCTSTR pszAttrSyntaxOID)
{
  ASSERT(pszAttrSyntaxOID != NULL);
  const int iSchemaAttrSyntaxInfoLast = ARRAYLEN(g_rgSchemaAttrSyntaxInfo) - 1;
  ASSERT(iSchemaAttrSyntaxInfoLast >= 0);
  for (int i = 0; i < iSchemaAttrSyntaxInfoLast; i++)
    {
      if (0 == lstrcmpi(pszAttrSyntaxOID, g_rgSchemaAttrSyntaxInfo[i].pszSyntaxOID))
        {
          return &g_rgSchemaAttrSyntaxInfo[i];
        }
    }
  ASSERT(g_rgSchemaAttrSyntaxInfo[iSchemaAttrSyntaxInfoLast].pszSyntaxOID == NULL);
  // Return pointer to the last entry in table
  return &g_rgSchemaAttrSyntaxInfo[iSchemaAttrSyntaxInfoLast];
} // PFindSchemaAttrSyntaxInfo()


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
class CGenericCreateWizPage : public CPropertyPageEx_Mine
{
  enum { IDD = IDD_CREATE_NEW_OBJECT_GENERIC_WIZARD }; 
protected:
  CCreateNewObjectGenericWizard * m_pParent;	// Pointer to parent holding the dat
  CPropertySheet * m_pPropertySheetParent;	// Pointer of the parent property sheet
  int m_iPage;								// Index of the current page
  CMandatoryADsAttribute * m_pAttribute;		// INOUT: Pointer to attribute to edit

protected:	
  VARTYPE m_vtEnum;				// IN: Datatype from SCHEMA_ATTR_SYNTAX_INFO.vtEnum
  VARIANT * m_pvarAttrValue;		// OUT: Pointer to variant in CMandatoryADsAttribute.m_varAttrValue

public:
  CGenericCreateWizPage(CCreateNewObjectGenericWizard * pParent,
                        int iIpage, INOUT CMandatoryADsAttribute * pAttribute);
  ~CGenericCreateWizPage()
  {
  }
  // Overrides
  // ClassWizard generate virtual function overrides
  //{{AFX_VIRTUAL(CGenericCreateWizPage)
public:
  virtual BOOL OnSetActive();
  virtual BOOL OnKillActive();
  virtual BOOL OnWizardFinish();
protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL

  // Implementation
protected:
  // Generated message map functions
  //{{AFX_MSG(CGenericCreateWizPage)
  virtual BOOL OnInitDialog();
  afx_msg void OnChangeEditAttributeValue();
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()

protected:
  void _UpdateWizardButtons(BOOL bValid);
  void _UpdateUI();
  
}; // CGenericCreateWizPage


/////////////////////////////////////////////////////////////////////
//	CGenericCreateWizPage() - Constructor
//
//	Initialize the member variables for a wizard page
//	and add the page to the property sheet.
//
CGenericCreateWizPage::CGenericCreateWizPage(
                                             CCreateNewObjectGenericWizard * pParent,
                                             int iPage,
                                             INOUT CMandatoryADsAttribute * pAttribute)
  : CPropertyPageEx_Mine(IDD)
{
  ASSERT(pParent != NULL);
  ASSERT(iPage >= 0);
  ASSERT(pAttribute != NULL);
  m_pParent = pParent;
  m_iPage = iPage;
  m_pAttribute = pAttribute;

  ASSERT(m_pAttribute->m_pSchemaAttrSyntaxInfo != NULL);
  m_vtEnum = m_pAttribute->m_pSchemaAttrSyntaxInfo->vtEnum;
  m_pvarAttrValue = &m_pAttribute->m_varAttrValue;

  // Add the page to the property sheet
  m_pPropertySheetParent = pParent->m_paPropertySheet;
  ASSERT(m_pPropertySheetParent != NULL);
  m_pPropertySheetParent->AddPage(this);
} // CGenericCreateWizPage::CGenericCreateWizPage()

/////////////////////////////////////////////////////////////////////
//	Validate the data and store it into a variant.
void CGenericCreateWizPage::DoDataExchange(CDataExchange* pDX)
{
  ASSERT(m_pAttribute != NULL);
  ASSERT(m_pAttribute->m_pSchemaAttrSyntaxInfo != NULL);
  // Get the description of the attribute.
  UINT uAttributeDescription = m_pAttribute->m_pSchemaAttrSyntaxInfo->uStringIdDesc;

  CPropertyPage::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CGenericCreateWizPage)
  // NOTE: the ClassWizard will add DDX and DDV calls here
  //}}AFX_DATA_MAP
  if (!pDX->m_bSaveAndValidate)
    return;
  VariantClear(INOUT m_pvarAttrValue);
  CString strAttrValue;
  GetDlgItemText(IDC_EDIT_ATTRIBUTE_VALUE, OUT strAttrValue);
  const TCHAR * pch = strAttrValue;
  ASSERT(pch != NULL);
  switch (m_vtEnum)
    {
    case VT_BOOL:
      {
        UINT uStringId = (UINT)ComboBox_GetSelectedItemLParam(HGetDlgItem(IDC_COMBO_ATTRIBUTE_VALUE));
        ASSERT(uStringId == IDS_TRUE || uStringId == IDS_FALSE);
        m_pvarAttrValue->boolVal = (uStringId == IDS_TRUE);
      }
    break;
    case VT_I4:		// 32-bit signed and unsigned integer
      m_pvarAttrValue->lVal = 0;
      if (!strAttrValue.IsEmpty())
        DDX_Text(pDX, IDC_EDIT_ATTRIBUTE_VALUE, OUT m_pvarAttrValue->lVal);
      break;
    case VT_I8:		// 64 bit integer
      {
        ASSERT(sizeof(VARIANT) == sizeof(*m_pvarAttrValue));
        ZeroMemory(OUT m_pvarAttrValue, sizeof(VARIANT));
        LARGE_INTEGER liVal;
        if (!strAttrValue.IsEmpty())
        {
          wtoli(strAttrValue, liVal);
          m_pvarAttrValue->llVal = liVal.QuadPart;
        }
      }
      break;
    case VT_BSTR:
      switch (uAttributeDescription)
        {
        case IDS_SCHEMA_ATTR_SYNTAX_NUMSTR: 	// Numeric string
          for ( ; *pch != _T('\0'); pch++)
            {
              if (*pch < _T('0') || *pch > _T('9'))
                {
                  ReportErrorEx(GetSafeHwnd(), IDS_ERR_INVALID_DIGIT, S_OK,
                                MB_OK, NULL, 0);
                  pDX->Fail();
                }
            }
          break;
        default:
          break;
        } // switch
      m_pvarAttrValue->bstrVal = ::SysAllocString(strAttrValue);
      break; // VT_BSTR

    default:
      m_pvarAttrValue->vt = VT_EMPTY;	// Just in case
      ASSERT(FALSE && "Unsupported variant type");
      return;
    } // switch
  m_pvarAttrValue->vt = m_vtEnum;
} // CGenericCreateWizPage::DoDataExchange()


BEGIN_MESSAGE_MAP(CGenericCreateWizPage, CPropertyPageEx_Mine)
  //{{AFX_MSG_MAP(CGenericCreateWizPage)
  ON_EN_CHANGE(IDC_EDIT_ATTRIBUTE_VALUE, OnChangeEditAttributeValue)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

  /////////////////////////////////////////////////////////////////////
BOOL CGenericCreateWizPage::OnInitDialog() 
{
  static const UINT rgzuStringId[] = { IDS_TRUE, IDS_FALSE, 0 };
  CPropertyPage::OnInitDialog();
  HWND hwndCombo = HGetDlgItem(IDC_COMBO_ATTRIBUTE_VALUE);
  switch (m_vtEnum)
  {
    case VT_BOOL:
      HideDlgItem(IDC_EDIT_ATTRIBUTE_VALUE, TRUE);
      HideDlgItem(IDC_COMBO_ATTRIBUTE_VALUE, FALSE);
      ComboBox_AddStrings(hwndCombo, rgzuStringId);
      ComboBox_SelectItemByLParam(hwndCombo, IDS_FALSE);
      break;
  }

  LPCTSTR pszAttrName = m_pAttribute->m_strAttrName;
  LPCTSTR pszAttrDescr = m_pAttribute->m_strAttrDescription;
  if (pszAttrDescr[0] == _T('\0'))
    pszAttrDescr = pszAttrName;
  CString strAttrType;
  VERIFY( strAttrType.LoadString(m_pAttribute->m_pSchemaAttrSyntaxInfo->uStringIdDesc) );
  SetDlgItemText(IDC_STATIC_ATTRIBUTE_NAME, pszAttrName);
  SetDlgItemText(IDC_STATIC_ATTRIBUTE_DESCRIPTION, pszAttrDescr);
  SetDlgItemText(IDC_STATIC_ATTRIBUTE_TYPE, strAttrType);
  return TRUE;
} // CGenericCreateWizPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////
//	Update the wizard buttons

void CGenericCreateWizPage::OnChangeEditAttributeValue() 
{
  _UpdateUI();
}


/////////////////////////////////////////////////////////////////////
//	Update the wizard buttons


void CGenericCreateWizPage::_UpdateWizardButtons(BOOL bValid)
{
  DWORD dwWizButtons = 0;

  if (m_pParent->m_cMandatoryAttributes > 1)
  {
    // we have multiple pages
    if (m_iPage == 0)
    {
      // first page
      dwWizButtons = bValid ? PSWIZB_NEXT : 0;
    }
    else if (m_iPage == (m_pParent->m_cMandatoryAttributes-1))
    {
      // last page
      dwWizButtons = bValid ? (PSWIZB_BACK|PSWIZB_FINISH) : (PSWIZB_BACK|PSWIZB_DISABLEDFINISH);
    }
    else
    {
      // intemediate pages
      dwWizButtons = bValid ? (PSWIZB_BACK|PSWIZB_NEXT) : PSWIZB_BACK;
    }
  }
  else
  {
    // single page wizard
    ASSERT(m_iPage == 0);
    CString szCaption;
    szCaption.LoadString(IDS_WIZARD_OK);
    PropSheet_SetFinishText(m_pPropertySheetParent->GetSafeHwnd(), (LPCWSTR)szCaption);
    dwWizButtons = bValid ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH;
  }
  m_pPropertySheetParent->SetWizardButtons(dwWizButtons);
}

void CGenericCreateWizPage::_UpdateUI()
{
  CString strName;
  GetDlgItemText(IDC_EDIT_ATTRIBUTE_VALUE, OUT strName);
  strName.TrimLeft();
  strName.TrimRight();
  _UpdateWizardButtons(!strName.IsEmpty());
} 


/////////////////////////////////////////////////////////////////////
BOOL CGenericCreateWizPage::OnSetActive() 
{
  const int nPage = m_iPage + 1;	// Current page
  const int cPages = m_pParent->m_cMandatoryAttributes;		// Total pages
  const TCHAR * pszClassName = m_pParent->m_pszObjectClass;
  ASSERT(pszClassName != NULL);
  CString strCaption;
  if (cPages > 1)
    strCaption.Format(IDS_sdd_CREATE_NEW_STEP, pszClassName, nPage, cPages);
  else
    strCaption.Format(IDS_s_CREATE_NEW, pszClassName);
  ASSERT(!strCaption.IsEmpty());
  m_pPropertySheetParent->SetWindowText(strCaption);
  _UpdateUI();
  return CPropertyPage::OnSetActive();
} // CGenericCreateWizPage::OnSetActive()

/////////////////////////////////////////////////////////////////////
BOOL CGenericCreateWizPage::OnKillActive() 
{
  return CPropertyPage::OnKillActive();
} // CGenericCreateWizPage::OnKillActive()


/////////////////////////////////////////////////////////////////////
//	Create and persist the object.
BOOL CGenericCreateWizPage::OnWizardFinish() 
{
  ASSERT(m_pParent != NULL);
  if (!UpdateData())
    {
      // DDX/DDV failed
      return FALSE;
    }
  HRESULT hr;
  CNewADsObjectCreateInfo * pNewADsObjectCreateInfo;	// Temporary storage
  pNewADsObjectCreateInfo = m_pParent->m_pNewADsObjectCreateInfo;
  ASSERT(pNewADsObjectCreateInfo != NULL);

  // Write each attribute into the temporary storage
  CMandatoryADsAttributeList* pList = m_pParent->m_paMandatoryAttributeList;
  int iPage = 0;
  for (POSITION pos = pList->GetHeadPosition(); pos != NULL; )
  {
    CMandatoryADsAttribute* pAttribute = pList->GetNext(pos);
    ASSERT(pAttribute != NULL);
    if (iPage == 0)
    {
      // first page is the naming attribute
      hr = pNewADsObjectCreateInfo->HrCreateNew(pAttribute->m_varAttrValue.bstrVal);
    }
    else
    {
      hr = pNewADsObjectCreateInfo->HrAddVariantCopyVar(const_cast<PWSTR>((LPCWSTR)pAttribute->m_strAttrName),
                                                        pAttribute->m_varAttrValue);
    }
    ASSERT(SUCCEEDED(hr));
    iPage++;
  }

  // Try to create and persist the object with all its attributes
  hr = pNewADsObjectCreateInfo->HrSetInfo();
  if (FAILED(hr))
    {
      // Failure to create object, prevent the wizard from terminating
      return FALSE;
    }
  return CPropertyPage::OnWizardFinish();
} // CGenericCreateWizPage::OnWizardFinish()


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
CCreateNewObjectGenericWizard::CCreateNewObjectGenericWizard()
{
  m_pNewADsObjectCreateInfo = NULL;
  m_paPropertySheet = NULL;
  m_cMandatoryAttributes = 0;
  m_paMandatoryAttributeList = NULL;
  m_pPageArr = NULL;
}

/////////////////////////////////////////////////////////////////////
CCreateNewObjectGenericWizard::~CCreateNewObjectGenericWizard()
{
  if (m_pPageArr != NULL)
  {
    for (int i=0; i< m_cMandatoryAttributes; i++)
      delete m_pPageArr[i];
    free(m_pPageArr);
  }
  delete m_paPropertySheet;
}


/////////////////////////////////////////////////////////////////////
//	FDoModal()
//
//	Query the mandatory attributes and create one wizard
//	page for each attribute.
//
BOOL
CCreateNewObjectGenericWizard::FDoModal(
                                        INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
{
  ASSERT(pNewADsObjectCreateInfo != NULL);
  m_pNewADsObjectCreateInfo = pNewADsObjectCreateInfo;
  m_pszObjectClass = m_pNewADsObjectCreateInfo->m_pszObjectClass;
  ASSERT(m_pszObjectClass != NULL);


  // Query the mandatory attributes
  m_paMandatoryAttributeList = 
          m_pNewADsObjectCreateInfo->GetMandatoryAttributeListFromCacheItem();
  ASSERT(m_paMandatoryAttributeList != NULL);
  m_cMandatoryAttributes = (int)m_paMandatoryAttributeList->GetCount();
  if (m_cMandatoryAttributes <= 0)
  {
    ReportErrorEx(pNewADsObjectCreateInfo->GetParentHwnd(),
                  IDS_ERR_CANNOT_FIND_MANDATORY_ATTRIBUTES,
                  S_OK, MB_OK, NULL, 0);
    return FALSE;
  }

  m_paPropertySheet = new CPropertySheet(L"", 
        CWnd::FromHandle(pNewADsObjectCreateInfo->GetParentHwnd()));

  // Create one wizard page for each attribute
  m_pPageArr = (CGenericCreateWizPage**)
      malloc(m_cMandatoryAttributes*sizeof(CGenericCreateWizPage*));

  if (m_pPageArr != NULL)
  {
    int iPage = 0;
    for (POSITION pos = m_paMandatoryAttributeList->GetHeadPosition(); pos != NULL; )
    {
      CMandatoryADsAttribute* pAttribute = m_paMandatoryAttributeList->GetNext(pos);
      ASSERT(pAttribute != NULL);
      m_pPageArr[iPage] = new CGenericCreateWizPage(this, iPage, INOUT pAttribute);
      iPage++;
    }
  }

  m_paPropertySheet->SetWizardMode();
  if (ID_WIZFINISH == m_paPropertySheet->DoModal())
    return TRUE;
  return FALSE;
} // FDoModal()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1997

Module Name:

    makefile.inc.

!ENDIF

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\mybasepathsinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      MyBasePathsInfo.h
//
//  Contents:  Thin wrapper around dsadminlib CDSBasePathsInfo class
//             to deal with memory management of strings
//
//  History:   04/02/2001 jeffjon    Created
//
//--------------------------------------------------------------------------

class MyBasePathsInfo : public CDSBasePathsInfo
{
public:
  // Functions from the base class that are wrapped to take references to 
  // CStrings

  void ComposeADsIPath(CString& szPath, IN LPCWSTR lpszNamingContext);

  void GetSchemaPath(CString& s);
  void GetConfigPath(CString& s);
  void GetDefaultRootPath(CString& s);
  void GetRootDSEPath(CString& s);
  void GetAbstractSchemaPath(CString& s);
  void GetPartitionsPath(CString& s);
  void GetSchemaObjectPath(IN LPCWSTR lpszObjClass, CString& s);
  void GetInfrastructureObjectPath(CString& s);
};

HRESULT GetADSIServerName(CString& szServer, IN IUnknown* pUnk);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\gencreat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       gencreat.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	gencreat.h
//
//	Class definition for the "Generic Create" wizard and other dialogs.
//
//	HISTORY
//	21-Aug-97	Dan Morin	Creation.
//
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
//	The following structure is to map a attribute syntax OID to
//	something that both the user and the developer better understand.
struct SCHEMA_ATTR_SYNTAX_INFO
{
  LPCTSTR pszSyntaxOID;	// OID of the attribute syntax (eg: "2.5.5.6")
  UINT uStringIdDesc;		// Resource Id describing the syntax OID. (eg: "Numerical String")
  VARTYPE vtEnum;			// Datatype of the attribute syntax (eg: VT_BSTR, VT_I4, VT_BOOL )	
};


const SCHEMA_ATTR_SYNTAX_INFO * PFindSchemaAttrSyntaxInfo(LPCTSTR pszAttrSyntaxOID);


/////////////////////////////////////////////////////////////////////
//	The following is a node in a linked-list of mandatory
//	attributes to create a new object.
class CMandatoryADsAttribute
{
public:
  CString m_strAttrName;			  // Name of the attribute (eg: "cn", "mail", "streetAddress" )
  CString m_strAttrDescription;	// Description of attribute (eg: "Common Name", "Email Addresses", "Street Address")
  const SCHEMA_ATTR_SYNTAX_INFO * m_pSchemaAttrSyntaxInfo;	// Pointer to the syntax info for the attribute.
public:
  CComVariant m_varAttrValue;				// OUT: Value of the attribute stored in a variant

public:
  CMandatoryADsAttribute(
                         LPCTSTR pszAttrName,
                         LPCTSTR pszAttrDesc,
                         LPCTSTR pszSyntaxOID)
  {
    m_strAttrName = pszAttrName;
    m_strAttrDescription = pszAttrDesc;
    m_pSchemaAttrSyntaxInfo = PFindSchemaAttrSyntaxInfo(pszSyntaxOID);
    ASSERT(m_pSchemaAttrSyntaxInfo != NULL);
  }

  ~CMandatoryADsAttribute()
  {
  }
}; // CMandatoryADsAttribute


class CMandatoryADsAttributeList : 
      public CList< CMandatoryADsAttribute*, CMandatoryADsAttribute* >
{
public:
  ~CMandatoryADsAttributeList()
  {
    _RemoveAll();
  }
private:
  void _RemoveAll()
  {
    while(!IsEmpty())
      delete RemoveHead();
  }
};

/////////////////////////////////////////////////////////////////////
//	The "Generic Create" wizard will build a list of attributes
//	and prompt the user to enter the value of the attribute.
class CCreateNewObjectGenericWizard
{
  friend class CGenericCreateWizPage;
protected:
  CNewADsObjectCreateInfo * m_pNewADsObjectCreateInfo;	// INOUT: Temporary storage to hold the attributes
  LPCTSTR m_pszObjectClass;	// IN: Class of object to create.

  CPropertySheet * m_paPropertySheet;		// Property sheet holding all the property pages
  int m_cMandatoryAttributes;				// Number of attributes in the list
  CMandatoryADsAttributeList* m_paMandatoryAttributeList;	// list of mandatory attributes

public:
  CCreateNewObjectGenericWizard();
  ~CCreateNewObjectGenericWizard();

  BOOL FDoModal(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);

protected:
  CGenericCreateWizPage** m_pPageArr;

}; // CCreateNewObjectGenericWizard
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\guids.cpp ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Administration SnapIn
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       guids.cxx
//
//  Contents:   guid allocations - guids are defined in dsclient.h
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

// initguid.h requires this.
//
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>

#include <dsclient.h>
#include <dsadmin.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\newobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       newobj.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	newobj.h
//
//	This file contains function prototypes to create new ADs object.
//
//	HISTORY
//	20-Aug-97	Dan Morin	Creation.
//
/////////////////////////////////////////////////////////////////////

#ifndef __NEWOBJ_H_INCLUDED__
#define __NEWOBJ_H_INCLUDED__

#ifndef __DSSNAP_H__
#include "dssnap.h"		// CDSComponentData
#endif
#ifndef __GSZ_H_INCLUDED__
#include "gsz.h"
#endif

#include "copyobj.h"


/////////////////////////////////////////////////////////////////////
//	typedef PFn_HrCreateADsObject()
//
//	Interface of the "create routine" to create a new ADs object.
//
//	Typically the routine brings a dialog so the user can enter
//	information relevant to create the object.  The routine
//	then validates the data and create the object.  If the data
//	is invalid and/or the object creation fails, the routine should
//	display an error message and return S_FALSE.
//
//	RETURN
//	S_OK - The object was created and persisted successfully.
//	S_FALSE - The user hit the "Cancel" button or object creation failed.
//	Return E_* - A very serious error occured.
//
typedef HRESULT (* PFn_HrCreateADsObject)(INOUT class CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);

BOOL FindHandlerFunction(/*IN*/ LPCWSTR lpszObjectClass, 
                         /*OUT*/ PFn_HrCreateADsObject* ppfFunc,
                         /*OUT*/ void** ppVoid);

HRESULT HrCreateFixedNameHelper(/*IN*/ LPCWSTR lpszObjectClass,
                                /*IN*/ LPCWSTR lpszAttrString, // typically "cn="
                                /*IN*/ IADsContainer* pIADsContainer);

/////////////////////////////////////////////////////////////////////
//	class CNewADsObjectCreateInfo
//
//	Class to store temporary data to create a new ADs object.
//
//	CONTROL FLOW
//	1.	Construct CNewADsObjectCreateInfo object.
//	2.	Use SetContainerInfo() to set additional pointers.
//	3.	Use HrDoModal() to invoke the dialog.
//		3.1.	Perform a lookup to match the objectclass to the best "create routine".
//		3.2.	The "create routine" will validate the data, use SetName() to set object name
//				and HrAddVariant*() and store each attribute into a list of variants.
//		3.3.	The "create routine" will use HrSetInfo() to create and persist object.
//			3.3.1.	If object creation fails, routine HrSetInfo() will display an error message.
//		3.4.	Routine HrDoModal() return S_OK if object was created successfully.
//	4.	Object CNewADsObjectCreateInfo returns pIADs pointer to caller.  Caller
//		must pIADs->Release() when no longer need reference to object.
//
//	REMARKS
//	The core of "create routine" is typically encapsulated inside a dialog object.
//	In fact, the object creation which uses HrSetInfo() is mostly done inside the OnOK() handler.
//
//	HISTORY
//	20-Aug-97	Dan Morin	Creation.
//







///////////////////////////////////////////////////////////////////////////
// CNewADsObjectCreateInfo

class CNewADsObjectCreateInfo
{
public:
  IADsContainer * m_pIADsContainer;		// IN: Container to create object
  LPCWSTR m_pszObjectClass;	// IN: Class of object to create. eg: "user", "computer", "volume".
  CString m_strDefaultObjectName;

private:

  MyBasePathsInfo* m_pBasePathsInfo;

  CDSClassCacheItemBase* m_pDsCacheItem;			// IN: Pointer to cache entry
  CDSComponentData* m_pCD;              
  IADs* m_pIADs;						// OUT: Pointer to IADs interface.  Caller must call pIADs->Release() when done.
  HWND m_hWnd;                  // IN: MMC console main window, for modal dialogs
  CString m_strObjectName;	// OUT: Name of object. eg: "danmorin", "mycomputer", "myvollume"
  CString	m_strADsName;		// OUT: OPTIONAL: Concatenated ADs name. eg: "cn=danmorin"
  CString m_szCacheNamingAttribute; // typically "cn" or "ou"
  CString m_szContainerCanonicalName; // for display purposes cached after first call
                                      // to GetContainerCanonicalName() 

  CCopyObjectHandlerBase* m_pCopyHandler;

private:

  class CVariantInfo
  {
  public:
    CVariantInfo() 
    {
      m_bPostCommit = FALSE;
    }
    ~CVariantInfo() { }

    const CVariantInfo& operator=(CVariantInfo& src)
    {
      m_bPostCommit = src.m_bPostCommit;
      m_szAttrName = src.m_szAttrName;
      HRESULT hr = ::VariantCopy(&m_varAttrValue, &src.m_varAttrValue);
      ASSERT(SUCCEEDED(hr));
      return *this;
    }

    HRESULT Write(IADs* pIADs, BOOL bPostCommit)
    {
      HRESULT hr = S_OK;
      if (bPostCommit == m_bPostCommit)
      {
	      CComBSTR bstrAttrName = m_szAttrName;
		    hr = pIADs->Put(IN bstrAttrName, IN m_varAttrValue);
      }
      return hr;
    }
    BOOL m_bPostCommit;   // TRUE if the attribute has to be written during post commit
    CString m_szAttrName; // Name of the attribute
    CComVariant m_varAttrValue;		// Value of the attribute (stored in a variant)
  };

  class CVariantInfoList : public CList<CVariantInfo*, CVariantInfo*>
  {
  public:
    ~CVariantInfoList() { Flush();}
    void Flush()
    {
      while (!IsEmpty())
        delete RemoveHead();
    }
    void Initialize(CVariantInfoList* pList)
    {
      Flush();
      for (POSITION pos = pList->GetHeadPosition(); pos != NULL; )
      {
        CVariantInfo* pCurrInfo = pList->GetNext(pos);
        CVariantInfo* pNewInfo = new CVariantInfo;
        *pNewInfo = *pCurrInfo;
        AddTail(pNewInfo);
      }
    }
    HRESULT Write(IADs* pIADs, BOOL bPostCommit)
    {
	    ASSERT(pIADs != NULL);
      HRESULT hr = S_OK;
      for (POSITION pos = GetHeadPosition(); pos != NULL; )
      {
        CVariantInfo* pVariantInfo = GetNext(pos);
        hr = pVariantInfo->Write(pIADs, bPostCommit);
	      if (FAILED(hr))
		      break;
      }
      return hr;
    }
  };
  CVariantInfoList m_defaultVariantList;


  BOOL m_bPostCommit;               // state to manage default variant list
  
  PVOID m_pvCreationParameter; // IN: Some of the HrCreate functions need this
  PFn_HrCreateADsObject m_pfnCreateObject; // function pointer for object creation
  DSCLASSCREATIONINFO*  m_pCreateInfo; //  loaded from the DS display specifiers

public:
  // Construction/Initialization
  CNewADsObjectCreateInfo(MyBasePathsInfo* pBasePathsInfo, LPCTSTR pszObjectClass);
  ~CNewADsObjectCreateInfo();
  void SetContainerInfo(IN IADsContainer * pIADsContainer, IN CDSClassCacheItemBase* pDsCacheItem,
                                                           IN CDSComponentData* pCD,
                                                           IN LPCWSTR lpszAttrString = NULL);

  // copy operations
  HRESULT SetCopyInfo(IADs* pIADsCopyFrom);
  HRESULT SetCopyInfo(LPCWSTR lpszCopyFromLDAPPath);

  IADs* GetCopyFromObject()
  {
    if (m_pCopyHandler == NULL)
      return NULL;
    return m_pCopyHandler->GetCopyFrom();
  }

  CCopyObjectHandlerBase* GetCopyHandler() { return m_pCopyHandler;}

  CMandatoryADsAttributeList* GetMandatoryAttributeListFromCacheItem()
  {
    ASSERT(m_pDsCacheItem != NULL);
    ASSERT(m_pCD != NULL);
    if ((m_pDsCacheItem == NULL) || (m_pCD == NULL))
      return NULL;
    return m_pDsCacheItem->GetMandatoryAttributeList(m_pCD);
  }
  
  BOOL IsStandaloneUI() { return (m_pDsCacheItem == NULL) || (m_pCD == NULL);}
  
  BOOL IsContainer()
  {
    if (m_pDsCacheItem == NULL)
    {
      // we do not know, so the default icon might not be a container...
      return FALSE;
    }
    return m_pDsCacheItem->IsContainer();
  }


  HRESULT HrLoadCreationInfo();

  HRESULT HrDoModal(HWND hWnd);
  HRESULT HrCreateNew(LPCWSTR pszName, BOOL bSilentError = FALSE, BOOL bAllowCopy = TRUE);
  HRESULT HrSetInfo(BOOL fSilentError = FALSE);
  HRESULT HrDeleteFromBackend();
  IADs* PGetIADsPtr() { return m_pIADs;}
  void SetIADsPtr(IADs* pIADs)
  {
    if (m_pIADs != NULL)
      m_pIADs->Release();
    m_pIADs = pIADs;
    if (m_pIADs != NULL)
      m_pIADs->AddRef();
  }
  const PVOID QueryCreationParameter() { return m_pvCreationParameter; }
  void SetCreationParameter(PVOID pVoid) { m_pvCreationParameter = pVoid; }
  HWND GetParentHwnd() { return m_hWnd;}

  MyBasePathsInfo* GetBasePathsInfo() { return m_pBasePathsInfo;}

public:
  void SetPostCommit(BOOL bPostCommit)
  {
    m_bPostCommit = bPostCommit;
  }

  HRESULT HrAddDefaultAttributes()
  {
    ASSERT(m_pIADs != NULL);
    return m_defaultVariantList.Write(m_pIADs, m_bPostCommit);
  }


  LPCWSTR GetName() { return m_strObjectName; }

  LPCWSTR GetContainerCanonicalName();
  HRESULT HrAddVariantFromName(BSTR bstrAttrName);

  //	The following are wrappers to easily create common variant types
  HRESULT HrAddVariantBstr(BSTR bstrAttrName, LPCWSTR pszAttrValue, BOOL bDefaultList = FALSE);
  HRESULT HrAddVariantBstrIfNotEmpty(BSTR bstrAttrName, LPCWSTR pszAttrValue, BOOL bDefaultList = FALSE);
  HRESULT HrAddVariantLong(BSTR bstrAttrName, LONG lAttrValue, BOOL bDefaultList = FALSE);
  HRESULT HrAddVariantBoolean(BSTR bstrAttrName, BOOL fAttrValue, BOOL bDefaultList = FALSE);
  HRESULT HrAddVariantCopyVar(BSTR bstrAttrName, VARIANT varSrc, BOOL bDefaultList = FALSE);

  HRESULT HrGetAttributeVariant(BSTR bstrAttrName, OUT VARIANT * pvarData);
  

public:
  DSCLASSCREATIONINFO*  GetCreateInfo()
  { 
    ASSERT(m_pCreateInfo != NULL); 
    return m_pCreateInfo;
  }

private:
  // Private routines
  HRESULT _RemoveAttribute(BSTR bstrAttrName, BOOL bDefaultList);

  // helpers for the default list
  VARIANT* _PAllocateVariantInfo(BSTR bstrAttrName);
  HRESULT _RemoveVariantInfo(BSTR bstrAttrName);

  // helpers for the ADSI object
  HRESULT _HrSetAttributeVariant(BSTR bstrAttrName, IN VARIANT * pvarData);
  HRESULT _HrClearAttribute(BSTR bstrAttrName);

}; // CNewADsObjectCreateInfo


/////////////////////////////////////////////////////////////////////
//
//	Prototype of the "create routines" to create new ADs objects.
//
//	All those routines have the same interface as PFn_HrCreateADsObject().
//
HRESULT HrCreateADsUser(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsVolume(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsComputer(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsPrintQueue(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsGroup(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsContact(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);

HRESULT HrCreateADsNtDsConnection(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);

// The CreationParameter for HrCreateADsFixedNamemust be an LPCWSTR for the name of the object.
// The user does not need to enter any further parameters.
HRESULT HrCreateADsFixedName(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);

#ifdef FRS_CREATE
HRESULT HrCreateADsNtFrsMember(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsNtFrsSubscriber(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT CreateADsNtFrsSubscriptions(CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
#endif // FRS_CREATE

HRESULT HrCreateADsServer(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsSubnet(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsSite(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsSiteLink(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsSiteLinkBridge(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsOrganizationalUnit(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);

HRESULT HrCreateADsSimpleObject(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsObjectGenericWizard(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);
HRESULT HrCreateADsObjectOverride(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo);

/////////////////////////////////////////////////////////////////////
//	Other misc routines.


/////////////////////////////////////////////////////////////////////////
// CDsAdminCreateObj

class CDsAdminCreateObj:
  public CComObjectRoot,
  public CComCoClass<CDsAdminCreateObj, &CLSID_DsAdminCreateObj>,
  public IDsAdminCreateObj
{
public:
  BEGIN_COM_MAP(CDsAdminCreateObj)
    COM_INTERFACE_ENTRY(IDsAdminCreateObj)
  END_COM_MAP()

  DECLARE_REGISTRY_CLSID()
  CDsAdminCreateObj()
  {
    m_pNewADsObjectCreateInfo = NULL;
  }
  ~CDsAdminCreateObj()
  {
    if (m_pNewADsObjectCreateInfo != NULL)
      delete m_pNewADsObjectCreateInfo;
  }

  // IDsAdminCreateObj
  STDMETHODIMP Initialize(IADsContainer* pADsContainerObj,
                          IADs* pADsCopySource,
                          LPCWSTR lpszClassName); 
  STDMETHODIMP CreateModal(HWND hwndParent,
                           IADs** ppADsObj);

private:
  // member variables
  CString m_szObjectClass;
  CString m_szNamingAttribute;
  CComPtr<IADsContainer> m_spADsContainerObj;
  MyBasePathsInfo m_basePathsInfo;
  CNewADsObjectCreateInfo* m_pNewADsObjectCreateInfo;

  HRESULT _GetNamingAttribute();
};

//+----------------------------------------------------------------------------
//
//  Class:      CSmartBytePtr
//
//  Purpose:    A simple smart pointer class that does allocation with
//              GlobalAlloc and cleanup with GlobalFree.
//
//-----------------------------------------------------------------------------
class CSmartBytePtr
{
public:
    CSmartBytePtr(void) {m_ptr = NULL; m_fDetached = FALSE;}
    CSmartBytePtr(DWORD dwSize) {
        m_ptr = (PBYTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, dwSize);
        m_fDetached = FALSE;
    }
    ~CSmartBytePtr(void) {if (!m_fDetached && m_ptr) GlobalFree(m_ptr);}

    BYTE* operator=(const CSmartBytePtr& src) {return src.m_ptr;}
    void operator=(BYTE* src) {if (!m_fDetached && m_ptr) GlobalFree(m_ptr); m_ptr = src;}
    operator const BYTE*() {return m_ptr;}
    operator BYTE*() {return m_ptr;}
    BYTE** operator&() {if (!m_fDetached && m_ptr) GlobalFree(m_ptr); return &m_ptr;}
    operator BOOL() const {return m_ptr != NULL;}
    BOOL operator!() {return m_ptr == NULL;}

    BYTE* Detach() {m_fDetached = TRUE; return m_ptr;}
    BOOL  ReAlloc(DWORD dwSize) {
        if (m_ptr) GlobalFree(m_ptr);
        m_ptr = (PBYTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, dwSize);
        m_fDetached = FALSE;
        return(m_ptr != NULL);
    }

private:
    BYTE  * m_ptr;
    BOOL    m_fDetached;
};

#endif // ~__NEWOBJ_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\newobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       newobj.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	newobj.cpp
//
//	Implementation of the CNewADsObjectCreateInfo class.
//
//	HISTORY
//	20-Aug-97	Dan Morin	Creation.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

#include "dsutil.h"
#include "util.h"
#include "uiutil.h"

#include "newobj.h"
#include "dscmn.h"    // CrackName()


///////////////////////////////////////////////////////////////////////
// GUIDs for the DS Admin default wizards


// {DE41B65A-8960-11d1-B93C-00A0C9A06D2D}
static const GUID USER_WIZ_GUID   = { 0xde41b65a, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
// {DE41B65B-8960-11d1-B93C-00A0C9A06D2D}
static const GUID VOLUME_WIZ_GUID = { 0xde41b65b, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
// {DE41B65C-8960-11d1-B93C-00A0C9A06D2D}
static const GUID COMPUTER_WIZ_GUID = { 0xde41b65c, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
// {DE41B65D-8960-11d1-B93C-00A0C9A06D2D}
static const GUID PRINTQUEUE_WIZ_GUID = { 0xde41b65d, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
// {DE41B65E-8960-11d1-B93C-00A0C9A06D2D}
static const GUID GROUP_WIZ_GUID = { 0xde41b65e, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
// {C05C260F-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID CONTACT_WIZ_GUID = { 0xc05c260f, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {DE41B65F-8960-11d1-B93C-00A0C9A06D2D}
static const GUID NTDSCONN_WIZ_GUID = { 0xde41b65f, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
// {DE41B660-8960-11d1-B93C-00A0C9A06D2D}
static const GUID FIXEDNAME_WIZ_GUID = { 0xde41b660, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
#ifdef FRS_CREATE
// {DE41B661-8960-11d1-B93C-00A0C9A06D2D}
static const GUID FRS_SUBSCRIBER_WIZ_GUID = { 0xde41b661, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
#endif // FRS_CREATE
// {DE41B662-8960-11d1-B93C-00A0C9A06D2D}
static const GUID SITE_WIZ_GUID = { 0xde41b662, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
// {DE41B663-8960-11d1-B93C-00A0C9A06D2D}
static const GUID SUBNET_WIZ_GUID = { 0xde41b663, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
// {DE41B664-8960-11d1-B93C-00A0C9A06D2D}
static const GUID OU_WIZ_GUID = { 0xde41b664, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };

// {DE41B667-8960-11d1-B93C-00A0C9A06D2D}
static const GUID SERVER_WIZ_GUID = { 0xde41b667, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
#ifdef FRS_CREATE
// {DE41B668-8960-11d1-B93C-00A0C9A06D2D}
static const GUID FRS_REPLICA_SET_WIZ_GUID = { 0xde41b668, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
// {C05C260C-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID FRS_MEMBER_WIZ_GUID = { 0xc05c260c, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
#endif // FRS_CREATE
// {C05C260D-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID SITE_LINK_WIZ_GUID = { 0xc05c260d, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C260E-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID SITE_LINK_BRIDGE_WIZ_GUID = { 0xc05c260e, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
/*
// {C05C2610-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c2610, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C2611-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c2611, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C2612-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c2612, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C2613-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c2613, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C2614-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c2614, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C2615-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c2615, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C2616-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c2616, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C2617-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c2617, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C2618-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c2618, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C2619-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c2619, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C261A-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c261a, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C261B-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c261b, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C261C-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c261c, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C261D-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c261d, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C261E-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c261e, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
// {C05C261F-9DCA-11D1-B9B2-00C04FD8D5B0}
static const GUID <<name>> = { 0xc05c261f, 0x9dca, 0x11d1, { 0xb9, 0xb2, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0 } };
*/
/////////////////////////////////////////////////////////////////////
//	Structure to build a lookup table to match an object class
//	to a "create routine".

// flags for the _CREATE_NEW_OBJECT::dwFlags field
#define CNOF_STANDALONE_UI 0x00000001

struct _CREATE_NEW_OBJECT	// cno
{
	LPCWSTR pszObjectClass;				// Class of object to create. eg: user, computer, volume.
	PFn_HrCreateADsObject pfnCreate;	// Pointer to "create routine" to create the new object
	const GUID* pWizardGUID;            // guid of the DS Admin create wizard
	PVOID pvCreationParameter;			// Optional creation parameter
  DWORD dwFlags;                  // miscellanea flags
};

/////////////////////////////////////////////////////////////////////
//
// Lookup table
//
// Each entry contains an attribute and a pointer to a routine to create the object.
// If the attribute is not found in the table, then the object will be created
// using the HrCreateADsObject() routine.
//
static const _CREATE_NEW_OBJECT g_rgcno[] =
	{
	{ gsz_user,                   HrCreateADsUser,                &USER_WIZ_GUID,       NULL, CNOF_STANDALONE_UI },
#ifdef INETORGPERSON
  { gsz_inetOrgPerson,          HrCreateADsUser,                &USER_WIZ_GUID,       NULL, CNOF_STANDALONE_UI },
#endif
	{ gsz_volume,                 HrCreateADsVolume,              &VOLUME_WIZ_GUID,     NULL, CNOF_STANDALONE_UI },
	{ gsz_computer,               HrCreateADsComputer,            &COMPUTER_WIZ_GUID,   NULL, CNOF_STANDALONE_UI },
	{ gsz_printQueue,             HrCreateADsPrintQueue,          &PRINTQUEUE_WIZ_GUID, NULL, CNOF_STANDALONE_UI },
	{ gsz_group,                  HrCreateADsGroup,               &GROUP_WIZ_GUID,      NULL, CNOF_STANDALONE_UI },
  { gsz_contact,                  HrCreateADsContact,           &CONTACT_WIZ_GUID,    NULL, CNOF_STANDALONE_UI },

	{ gsz_nTDSConnection,         HrCreateADsNtDsConnection,      &NTDSCONN_WIZ_GUID,   NULL, 0x0 },

	// Note that names of DS objects are not internationalized.  I will leave
	// this string out of the resource file to make sure that INTL doesn't try
	// to internationalize it.
	{ gsz_nTDSSiteSettings,       HrCreateADsFixedName,           &FIXEDNAME_WIZ_GUID, (PVOID)L"NTDS Site Settings", 0x0 },
	{ gsz_serversContainer,       HrCreateADsFixedName,           &FIXEDNAME_WIZ_GUID, (PVOID)L"Servers", 0x0 },
	// CODEWORK could have a special wizard but this will do for now
	{ gsz_licensingSiteSettings,  HrCreateADsFixedName,           &FIXEDNAME_WIZ_GUID, (PVOID)L"Licensing Site Settings", 0x0 },
	{ gsz_siteLink,               HrCreateADsSiteLink,            &SITE_LINK_WIZ_GUID,  NULL, 0x0 },
	{ gsz_siteLinkBridge,         HrCreateADsSiteLinkBridge,      &SITE_LINK_BRIDGE_WIZ_GUID, NULL, 0x0 },


#ifdef FRS_CREATE
	//
	// FRS stuff
	//
	{ gsz_nTFRSSettings,          HrCreateADsFixedName,           &FIXEDNAME_WIZ_GUID, (PVOID)L"FRS Settings", 0x0 },
	{ gsz_nTFRSReplicaSet,        HrCreateADsSimpleObject,        &FRS_REPLICA_SET_WIZ_GUID, NULL, 0x0 },
	{ gsz_nTFRSMember,            HrCreateADsNtFrsMember,         &FRS_MEMBER_WIZ_GUID, NULL, 0x0 },
	// CODEWORK fixed name doesn't mesh with the ability to create a subtree of these
	{ gsz_nTFRSSubscriptions,     CreateADsNtFrsSubscriptions,    &FIXEDNAME_WIZ_GUID, (PVOID)L"FRS Subscriptions", 0x0 },
	{ gsz_nTFRSSubscriber,        HrCreateADsNtFrsSubscriber,     &FRS_SUBSCRIBER_WIZ_GUID,     NULL, 0x0 },
#endif // FRS_CREATE

	{ gsz_server,                 HrCreateADsServer,              &SERVER_WIZ_GUID,     NULL, 0x0 },
	{ gsz_site,                   HrCreateADsSite,                &SITE_WIZ_GUID,       NULL, 0x0 },
	{ gsz_subnet,                 HrCreateADsSubnet,              &SUBNET_WIZ_GUID,     NULL, 0x0 },

	{ gsz_organizationalUnit,     HrCreateADsOrganizationalUnit,  &OU_WIZ_GUID,         NULL, CNOF_STANDALONE_UI },

	};

////////////////////////////////////////////////////////////////////////////
// MarcoC: 
// Test only: simple dump function to print the table above
// need this to dump formatted table for documentation.

/*
void DumpCreateTable()
{
	for (int i = 0; i < LENGTH(g_rgcno); i++)
	{
		ASSERT(g_rgcno[i].pszObjectClass != NULL);
    WCHAR szBuf[256];
    StringFromGUID2(*(g_rgcno[i].pWizardGUID), szBuf, 256);
    LPCWSTR lpsz = (g_rgcno[i].dwFlags & CNOF_STANDALONE_UI) ? L"Y" : L"N";
    TRACE(L"%s\t%s\t%s\n", g_rgcno[i].pszObjectClass, szBuf, lpsz);
	} // for
}
*/

////////////////////////////////////////////////////////////////////////////
// simple lookup function to return the internal handler inf given
// a class name
BOOL FindHandlerFunction(/*IN*/ LPCWSTR lpszObjectClass, 
                         /*OUT*/ PFn_HrCreateADsObject* ppfFunc,
                         /*OUT*/ void** ppVoid)
{
  *ppfFunc = NULL;
  *ppVoid = NULL;
	for (int i = 0; i < ARRAYLEN(g_rgcno); i++)
	{
		ASSERT(g_rgcno[i].pszObjectClass != NULL);
		ASSERT(g_rgcno[i].pfnCreate != NULL);
    // compare class name
		if (0 == lstrcmp(g_rgcno[i].pszObjectClass, lpszObjectClass))
		{
      // found matching class, get the function from it
			*ppfFunc = g_rgcno[i].pfnCreate;
			*ppVoid = g_rgcno[i].pvCreationParameter;
      return TRUE;
    } // if
	} // for
  return FALSE;
}


/////////////////////////////////////////////////////////////////////////////////////
// Hackarama fix

HRESULT HrCreateFixedNameHelper(/*IN*/ LPCWSTR lpszObjectClass,
                                /*IN*/ LPCWSTR lpszAttrString, // typically "cn="
                                /*IN*/ IADsContainer* pIADsContainer)
{
  // find the fixed name on the table
  LPCWSTR lpszName = NULL;
	for (int i = 0; i < ARRAYLEN(g_rgcno); i++)
	{
		ASSERT(g_rgcno[i].pszObjectClass != NULL);
    // compare class name
		if (0 == lstrcmp(g_rgcno[i].pszObjectClass, lpszObjectClass))
		{
			lpszName = (LPCWSTR)(g_rgcno[i].pvCreationParameter);
      break;
    } // if
	} // for

  ASSERT(lpszName != NULL);
  if (lpszName == NULL)
    return E_INVALIDARG;

  // create the temporary object
  CString szAdsName;
  szAdsName.Format(_T("%s%s"), (LPCWSTR)lpszAttrString, lpszName);
  IDispatch* pIDispatch = NULL;
  HRESULT hr = pIADsContainer->Create((LPTSTR)lpszObjectClass,
		                                    (LPTSTR)(LPCTSTR)szAdsName,
		                                    &pIDispatch);
  if (FAILED(hr))
    return hr; // could not create
  ASSERT(pIDispatch != NULL);

  IADs* pIADs = NULL;
	hr = pIDispatch->QueryInterface(IID_IADs, (LPVOID *)&pIADs);
  pIDispatch->Release();
	if (FAILED(hr)) 
    return hr; // should never happen!!!

  //commit object
  hr = pIADs->SetInfo();
  pIADs->Release();
  return hr;
}


////////////////////////////////////////////////////////////////////////////
// This function just returns the values from the internal table
// To be used when other type of data retrieval fails
// returns S_OK if the info was found, E_FAIL if not
STDAPI DsGetClassCreationInfoInternal(LPCWSTR pClassName, LPDSCLASSCREATIONINFO* ppInfo)
{
  if (ppInfo == NULL)
    return E_INVALIDARG;

  *ppInfo = (DSCLASSCREATIONINFO*)::LocalAlloc(LPTR, sizeof(DSCLASSCREATIONINFO));
  if (*ppInfo != NULL)
  {
    ZeroMemory(*ppInfo, sizeof(DSCLASSCREATIONINFO));

	  for (int i = 0; i < ARRAYLEN(g_rgcno); i++)
	  {
		  ASSERT(g_rgcno[i].pszObjectClass != NULL);
		  ASSERT(g_rgcno[i].pfnCreate != NULL);
		  if (0 == lstrcmp(g_rgcno[i].pszObjectClass, pClassName))
		  {
        // found matching class
        (*ppInfo)->dwFlags = DSCCIF_HASWIZARDPRIMARYPAGE;
        (*ppInfo)->clsidWizardPrimaryPage = *(g_rgcno[i].pWizardGUID);
			  return S_OK;
      } // if
	  } // for
  }
  return E_FAIL;
}


//////////////////////////////////////////////////////////////////////////////////
// NOTICE: this #define is used to enable externsibility testing without having
// to modify the schema.

//#ifdef _DEBUG
//  #define _TEST_OVERRIDE
//#endif

#ifdef _TEST_OVERRIDE

BOOL g_bTestCreateOverride = FALSE;
//BOOL g_bTestCreateOverride = TRUE;

// {DE41B658-8960-11d1-B93C-00A0C9A06D2D}
static const GUID CLSID_CCreateDlg = 
{ 0xde41b658, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };


// {DE41B659-8960-11d1-B93C-00A0C9A06D2D}
static const GUID CLSID_WizExt = 
{ 0xde41b659, 0x8960, 0x11d1, { 0xb9, 0x3c, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };


// {C03793D2-A7C8-11d1-B940-00A0C9A06D2D}
static const GUID CLSID_WizExtNoUI = 
{ 0xc03793d2, 0xa7c8, 0x11d1, { 0xb9, 0x40, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };


// {C03793D3-A7C8-11d1-B940-00A0C9A06D2D}
static const GUID CLSID_WizExtUser = 
{ 0xc03793d3, 0xa7c8, 0x11d1, { 0xb9, 0x40, 0x0, 0xa0, 0xc9, 0xa0, 0x6d, 0x2d } };
#endif // _TEST_OVERRIDE

///////////////////////////////////////////////////////////////////////////
// Wrapper function to do filtering and error handling
HRESULT DsGetClassCreationInfoEx(IN MyBasePathsInfo* pBasePathsInfo, 
                                 IN LPCWSTR pClassName, 
                                 OUT LPDSCLASSCREATIONINFO* ppInfo)
{
  TRACE(L"DsGetClassCreationInfoEx(_, pClassName = %s, _)\n", pClassName);

  HRESULT hr;
  // do some filtering, to ignore overrides
  if (0 == lstrcmp(gsz_printQueue, pClassName))
  {
    // ignore override of this class
    hr = ::DsGetClassCreationInfoInternal(pClassName, ppInfo);
    ASSERT(SUCCEEDED(hr));
    return hr;
  }

#ifdef _TEST_OVERRIDE
  if (g_bTestCreateOverride)
  {
    //
    // this is just to test extensions
    //
    if ( (0 == lstrcmp(L"contact", pClassName)) ||
          (0 == lstrcmp(L"organizationalUnit", pClassName)) )
    {
      hr = ::DsGetClassCreationInfoInternal(pClassName, ppInfo);
      // replace the dialog completely
      (*ppInfo)->clsidWizardPrimaryPage = CLSID_CCreateDlg;
      (*ppInfo)->dwFlags |= DSCCIF_HASWIZARDPRIMARYPAGE;
      return S_OK;
    }
    else if (0 == lstrcmp(gsz_user, pClassName))
    {
      // add user specific extension and generic extension
      hr = ::DsGetClassCreationInfoInternal(pClassName, ppInfo);
      ASSERT(SUCCEEDED(hr));
      LPDSCLASSCREATIONINFO pTempInfo = (*ppInfo);
      (*ppInfo) = (DSCLASSCREATIONINFO*)::LocalAlloc(LPTR, sizeof(DSCLASSCREATIONINFO)+ sizeof(GUID));
      (*ppInfo)->clsidWizardPrimaryPage = pTempInfo->clsidWizardPrimaryPage;
      (*ppInfo)->dwFlags = pTempInfo->dwFlags;
      (*ppInfo)->cWizardExtensions = 2;
      (*ppInfo)->aWizardExtensions[0] = CLSID_WizExtUser;
      (*ppInfo)->aWizardExtensions[1] = CLSID_WizExt;
      ::LocalFree(pTempInfo);
      return S_OK;
    }
    else
    {
      // add a general purpose extension for other known classes
      hr = ::DsGetClassCreationInfoInternal(pClassName, ppInfo);
      if(SUCCEEDED(hr))
      {
        (*ppInfo)->cWizardExtensions = 1;
        (*ppInfo)->aWizardExtensions[0] = CLSID_WizExt;
        return S_OK;
      }
    }
  } // g_bTestCreateOverride
#endif // _TEST_OVERRIDE

  // try the display specifiers in the back end (DSUIEXT.DLL)
  TRACE(L"calling pBasePathsInfo->GetClassCreationInfo()\n");
  hr = pBasePathsInfo->GetClassCreationInfo(pClassName, ppInfo);
  ASSERT(SUCCEEDED(hr));
  ASSERT((*ppInfo) != NULL);

  // protect from somebody erroneously putting CLSID_DsAdminCreateObj
  if ( (*ppInfo)->clsidWizardPrimaryPage == CLSID_DsAdminCreateObj)
  {
    // just remove entry, next check below will try to fix if possible
    TRACE(L"// just remove entry, next check below will try to fix if possible\n");
    (*ppInfo)->dwFlags &= ~DSCCIF_HASWIZARDPRIMARYPAGE;
    (*ppInfo)->clsidWizardPrimaryPage = CLSID_NULL;
  }

  if (((*ppInfo)->dwFlags & DSCCIF_HASWIZARDPRIMARYPAGE) == 0)
  {
    // something went wrong or there is no specifier at all for the primary wizard,
    // just call the internal implementation to get the primary wizard
    TRACE(L"// just call the internal implementation to get the primary wizard\n");
    LPDSCLASSCREATIONINFO pTempInfo;
    HRESULT hrInternal = DsGetClassCreationInfoInternal(pClassName, &pTempInfo);
    if (SUCCEEDED(hrInternal))
    {
      // it is a class we know about, modify the info we got from backend
      (*ppInfo)->dwFlags |= DSCCIF_HASWIZARDPRIMARYPAGE;
      (*ppInfo)->clsidWizardPrimaryPage = pTempInfo->clsidWizardPrimaryPage;
      ::LocalFree(pTempInfo);
    }
  }

  TRACE(L"DsGetClassCreationInfoEx() returning hr = 0x%x\n", hr);

  return hr;
}




/////////////////////////////////////////////////////////////////////
//////////////////// CNewADsObjectCreateInfo ////////////////////////
/////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////
CNewADsObjectCreateInfo::CNewADsObjectCreateInfo(
                MyBasePathsInfo* pBasePathsInfo,
	              LPCTSTR pszObjectClass)
{
	ASSERT(pszObjectClass != NULL);
  ASSERT(pBasePathsInfo != NULL);
	m_pBasePathsInfo = pBasePathsInfo;
	m_pszObjectClass = pszObjectClass;
  m_hWnd = NULL;
	m_pvCreationParameter = NULL;
  m_pfnCreateObject = NULL;
	m_pIADsContainer = NULL;
	m_pDsCacheItem = NULL;
  m_pCD = NULL;
	m_pIADs = NULL;
  m_pCreateInfo = NULL;

  m_bPostCommit = FALSE;
  m_pCopyHandler = NULL;
}

/////////////////////////////////////////////////////////////////////
CNewADsObjectCreateInfo::~CNewADsObjectCreateInfo()
{
  if (m_pCreateInfo != NULL)
  {
    ::LocalFree(m_pCreateInfo);
    m_pCreateInfo = NULL;
  }
  if (m_pCopyHandler != NULL)
  {
    delete m_pCopyHandler;
  }
}


/////////////////////////////////////////////////////////////////////
//	Another method to inizialize the object with additional pointers.
void
CNewADsObjectCreateInfo::SetContainerInfo(
	  IN IADsContainer * pIADsContainer,
	  IN CDSClassCacheItemBase* pDsCacheItem,
    IN CDSComponentData* pCD,
    IN LPCWSTR lpszAttrString)
{
  ASSERT(m_pIADs == NULL);
	ASSERT(pIADsContainer != NULL);
	if (pDsCacheItem != NULL)
  {
    m_szCacheNamingAttribute = pDsCacheItem->GetNamingAttribute();
  }
  else
  {
    m_szCacheNamingAttribute = lpszAttrString;
  }
  
	m_pIADsContainer = pIADsContainer;
	m_pDsCacheItem = pDsCacheItem;
  m_pCD = pCD;
}


/////////////////////////////////////////////////////////////////////

HRESULT CNewADsObjectCreateInfo::SetCopyInfo(IADs* pIADsCopyFrom)
{
  ASSERT(pIADsCopyFrom != NULL);

  CWaitCursor wait;

  // load the object cache
  HRESULT hr = pIADsCopyFrom->GetInfo();
  if (FAILED(hr))
  {
    TRACE(L"pIADsCopyFrom->GetInfo() failed with hr = 0x%x\n", hr);
    return hr;
  }

  // get the object class
  CComBSTR bstrClassName;
  hr = pIADsCopyFrom->get_Class(&bstrClassName);
  if (FAILED(hr))
  {
    TRACE(L"spIADsCopyFrom->get_Class() failed with hr = 0x%x\n", hr);
    return hr;
  }

  // make sure we are dealing with the right class type
  if (wcscmp(m_pszObjectClass, bstrClassName) != 0)
  {
    hr = E_INVALIDARG;
    TRACE(L"ERROR: wrong source object class m_pszObjectClass = %s, bstrClassName = %s\n", 
      m_pszObjectClass, bstrClassName);
    return hr;
  }

  // determine if this is a copyable class
  // and create the appropriate copy handler
  ASSERT(m_pCopyHandler == NULL);
  if (wcscmp(m_pszObjectClass, L"user") == 0
#ifdef INETORGPERSON
      || _wcsicmp(m_pszObjectClass, L"inetOrgPerson") == 0
#endif
     )
  {
    ASSERT(m_pCopyHandler == NULL);
    m_pCopyHandler = new CCopyUserHandler();
  }
  else
  {
    // default, do-nothing copy handler
    m_pCopyHandler = new CCopyObjectHandlerBase();
  } 
  
  if (m_pCopyHandler == NULL)
    return E_OUTOFMEMORY;

  hr = m_pCopyHandler->Init(m_pBasePathsInfo, pIADsCopyFrom);

  return hr;
}




HRESULT CNewADsObjectCreateInfo::SetCopyInfo(LPCWSTR lpszCopyFromLDAPPath)
{
  TRACE(L"CNewADsObjectCreateInfo::SetCopyInfo(%s)\n", lpszCopyFromLDAPPath);

  // bind to the object
  CComPtr<IADs> spIADsCopyFrom;
  HRESULT hr = S_OK;

  {
    CWaitCursor wait;
    hr = DSAdminOpenObject(lpszCopyFromLDAPPath,
                           IN IID_IADs,
                           OUT (LPVOID *) &spIADsCopyFrom,
                           TRUE /*bServer*/);
  }

  if (FAILED(hr))
  {
    TRACE(L"DSAdminOpenObject(%s) failed with hr = 0x%x\n", lpszCopyFromLDAPPath, hr);
    return hr;
  }

  // do the copy info setup using the bound pointer
  return SetCopyInfo(spIADsCopyFrom);
}





/////////////////////////////////////////////////////////////////////
//      gets the current container (in canonical form)

LPCWSTR CNewADsObjectCreateInfo::GetContainerCanonicalName()
{
  if (m_szContainerCanonicalName.IsEmpty())
  {
    CComPtr<IADs> spObj;
    HRESULT hr = m_pIADsContainer->QueryInterface(
                          IID_IADs, (void **)&spObj);
    if (SUCCEEDED(hr)) 
    {
      CComBSTR bsPath, bsDN;
      LPWSTR pszCanonical = NULL;

      spObj->get_ADsPath(&bsPath);

      CPathCracker pathCracker;
      pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
      pathCracker.Set(bsPath, ADS_SETTYPE_FULL);
      pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bsDN);

      hr = CrackName (bsDN, &pszCanonical, GET_OBJ_CAN_NAME, NULL);
      if (SUCCEEDED(hr))
        m_szContainerCanonicalName = pszCanonical;
      if (pszCanonical != NULL)
        LocalFreeStringW(&pszCanonical);
    }
  }
  return m_szContainerCanonicalName;
}

/////////////////////////////////////////////////////////////////////
//	_RemoveAttribute()

HRESULT CNewADsObjectCreateInfo::_RemoveAttribute(BSTR bstrAttrName, BOOL bDefaultList)
{
  if (bDefaultList)
    return _RemoveVariantInfo(bstrAttrName);
  else
    return _HrClearAttribute(bstrAttrName);
}




/////////////////////////////////////////////////////////////////////
//	_PAllocateVariantInfo()
//
//	Private routine to allocate and initialize a VARIANT_INFO structure.
//
//	Return pointer to VARIANT structure if successful, otherwise
//	return NULL.
//
//	INTERFACE NOTES
//	All allocated variants will be cleared when the class gets destroyed.
//

VARIANT* 
CNewADsObjectCreateInfo::_PAllocateVariantInfo(BSTR bstrAttrName)
{
  // first look if we have the attribute already in the list
  for (POSITION pos = m_defaultVariantList.GetHeadPosition(); pos != NULL; )
  {
    CVariantInfo* pCurrInfo = m_defaultVariantList.GetNext(pos);
    if (_wcsicmp (pCurrInfo->m_szAttrName, bstrAttrName) == 0)
    {
      // found, just recycle this one
      ::VariantClear(&pCurrInfo->m_varAttrValue);
      return &pCurrInfo->m_varAttrValue;
    }
  }

  // not found, create a new one and add to the list
  CVariantInfo* pVariantInfo = new CVariantInfo;
  if (pVariantInfo == NULL)
    return NULL;
  pVariantInfo->m_bPostCommit = m_bPostCommit;
  pVariantInfo->m_szAttrName = bstrAttrName;
  m_defaultVariantList.AddTail(pVariantInfo);
  return &pVariantInfo->m_varAttrValue;
}

/////////////////////////////////////////////////////////////////////
// 

HRESULT CNewADsObjectCreateInfo::_RemoveVariantInfo(BSTR bstrAttrName)
{
  POSITION deletePos = NULL;
  CVariantInfo* pCurrInfo = NULL;
  for (POSITION pos = m_defaultVariantList.GetHeadPosition(); pos != NULL; )
  {
    POSITION lastPos = pos;
    pCurrInfo = m_defaultVariantList.GetNext(pos);
    if (_wcsicmp (pCurrInfo->m_szAttrName, bstrAttrName) == 0)
    {
      // found
      deletePos = lastPos;
      break;
    }
  }
  if (deletePos != NULL)
  {
    m_defaultVariantList.RemoveAt(deletePos);
    delete pCurrInfo;
  }
  return S_OK;
}

/////////////////////////////////////////////////////////////////////
//	Add a BSTR variant where the value is name of the object.
//
//	Here are some examples where the name of the object is the
//	attribute value: "cn", "ou", "samAccountName"
//
HRESULT
CNewADsObjectCreateInfo::HrAddVariantFromName(BSTR bstrAttrName)
{
	ASSERT(bstrAttrName != NULL);
	ASSERT(!m_strObjectName.IsEmpty());
	return HrAddVariantBstr(bstrAttrName, m_strObjectName);
}


/////////////////////////////////////////////////////////////////////
//	Add a BSTR variant to the list.
HRESULT
CNewADsObjectCreateInfo::HrAddVariantBstr(BSTR bstrAttrName, LPCTSTR pszAttrValue,
                                          BOOL bDefaultList)
{
	ASSERT(bstrAttrName != NULL);

  // passing a NULL or empty string means remove the attribute
  if ( (pszAttrValue == NULL) || ((pszAttrValue != NULL) && (pszAttrValue[0] == NULL)) )
  {
    return _RemoveAttribute(bstrAttrName, bDefaultList);
  }


	ASSERT(pszAttrValue != NULL);
  HRESULT hr = S_OK;
  if (bDefaultList)
  {
    VARIANT * pVariant = _PAllocateVariantInfo(bstrAttrName);
	  if (pVariant == NULL)
		  hr = E_OUTOFMEMORY;
    else
    {
	    pVariant->vt = VT_BSTR;
	    pVariant->bstrVal = ::SysAllocString(pszAttrValue);
	    if (pVariant->bstrVal == NULL)
		    hr = E_OUTOFMEMORY;
    }
  }
  else
  {
    CComVariant v;
    v.vt = VT_BSTR;
	  v.bstrVal = ::SysAllocString(pszAttrValue);
	  if (v.bstrVal == NULL)
		  return E_OUTOFMEMORY;
    hr = _HrSetAttributeVariant(bstrAttrName, &v);
  }
  return hr;
}


/////////////////////////////////////////////////////////////////////
//	Add a BSTR variant to the list if the string value is not empty.
HRESULT
CNewADsObjectCreateInfo::HrAddVariantBstrIfNotEmpty(BSTR bstrAttrName, 
                                                    LPCWSTR pszAttrValue,
                                                    BOOL bDefaultList)
	{
	if (pszAttrValue == NULL)
		return S_OK;
	while (*pszAttrValue == _T(' '))
		pszAttrValue++;
	if (pszAttrValue[0] == _T('\0'))
		return S_OK;
	return HrAddVariantBstr(bstrAttrName, pszAttrValue, bDefaultList);
	}


/////////////////////////////////////////////////////////////////////
//	Add an integer variant to the list.
HRESULT CNewADsObjectCreateInfo::HrAddVariantLong(BSTR bstrAttrName, LONG lAttrValue,
                                          BOOL bDefaultList)
{
  ASSERT(bstrAttrName != NULL);
  HRESULT hr = S_OK;
  if (bDefaultList)
  {
	  VARIANT * pVariant = _PAllocateVariantInfo(bstrAttrName);
	  if (pVariant == NULL)
		  hr = E_OUTOFMEMORY;
    else
    {
	    pVariant->vt = VT_I4;
	    pVariant->lVal = lAttrValue;
    }
  }
  else
  {
    CComVariant v;
    v.vt = VT_I4;
	  v.lVal = lAttrValue;
    hr = _HrSetAttributeVariant(bstrAttrName, &v);
  }
  return hr;
}


/////////////////////////////////////////////////////////////////////
//	Add a boolean variant to the list.
HRESULT
CNewADsObjectCreateInfo::HrAddVariantBoolean(BSTR bstrAttrName, BOOL fAttrValue,
                                             BOOL bDefaultList)
{
  ASSERT(bstrAttrName != NULL);
  HRESULT hr = S_OK;
  if (bDefaultList)
  {
	  VARIANT * pVariant = _PAllocateVariantInfo(bstrAttrName);
	  if (pVariant == NULL)
		  hr = E_OUTOFMEMORY;
    else
    {
	    pVariant->vt = VT_BOOL;
      pVariant->boolVal = (VARIANT_BOOL)fAttrValue;
    }
  }
  else
  {
    CComVariant v;
    v.vt = VT_BOOL;
    v.boolVal = (VARIANT_BOOL)fAttrValue;
    hr = _HrSetAttributeVariant(bstrAttrName, &v);
  }
  return hr;
}

/////////////////////////////////////////////////////////////////////
//	HrAddVariantCopyVar()
//
//	Add an exact copy of an existing variant to the list.
//	This is the most generic routine to add a variant type that does
//	not have a frienldy wrapper.
//
//	INTERFACE NOTES
//	Depending on the type of variant to be copied, the routine may
//	allocate extra memory to store the data.
//	- If pvargSrc is a VT_BSTR, a copy of the string is made.
//	- If pvargSrc is a VT_ARRAY, the entire array is copied.
//	The user must clear the variant using ClearVariant(varSrc) when no longer needed.
//
HRESULT
CNewADsObjectCreateInfo::HrAddVariantCopyVar(IN BSTR bstrAttrName, IN VARIANT varSrc,
                                             BOOL bDefaultList)
{
  ASSERT(bstrAttrName != NULL);
  HRESULT hr = S_OK;
  if (bDefaultList)
  {
    VARIANT * pVariant = _PAllocateVariantInfo(bstrAttrName);
	  if (pVariant == NULL)
		  hr = E_OUTOFMEMORY;
    else
      hr = ::VariantCopy(OUT pVariant, IN &varSrc);
  }
  else
    hr = _HrSetAttributeVariant(bstrAttrName, IN &varSrc); 

  return hr;
} // HrAddVariantCopyVar()


/////////////////////////////////////////////////////////////////////
//	HrGetAttributeVariant()
//
//	Routine to get the attribute variant by calling pIADs->Get().
//
//	Sometimes there are attributes (typically flags) that
//	cannot be set directly.
//	1.  The flag must be read using pIADs->Get().
//	2.	The flag is updated by changing some bits (using binary operators)
//	3.	The flag is written back using pIADs->Put().
//
//	INTERFACE NOTES
//	- This routine is only available after the object has been
//	  successfully created.
//	- The variant does NOT need to be initialized.  The routine
//	  will initialize the variant for you.
//
HRESULT CNewADsObjectCreateInfo::HrGetAttributeVariant(BSTR bstrAttrName, OUT VARIANT * pvarData)
{
	ASSERT(bstrAttrName != NULL);
	ASSERT(pvarData != NULL);
	VariantInit(OUT pvarData);
	ASSERT(m_pIADs != NULL && "You must call HrSetInfo() first before extracting data from object.");

	return m_pIADs->Get(bstrAttrName, OUT pvarData);
} // HrGetAttributeVariant()


//////////////////////////////////////////////////////////////////////
// HrSetAttributeVariant
HRESULT
CNewADsObjectCreateInfo::_HrSetAttributeVariant(BSTR bstrAttrName, IN VARIANT * pvarData)
{
	ASSERT(bstrAttrName != NULL);
	ASSERT(pvarData != NULL);
	HRESULT hr = m_pIADs->Put(bstrAttrName, IN *pvarData);
  return hr;
}


//////////////////////////////////////////////////////////////////////
// _HrClearAttribute
HRESULT
CNewADsObjectCreateInfo::_HrClearAttribute(BSTR bstrAttrName)
{
  ASSERT(m_pIADs != NULL);
	ASSERT(bstrAttrName != NULL);
  HRESULT hr = S_OK;

  CComVariant varVal;

  // see if the attribute is there
  HRESULT hrFind = m_pIADs->Get(bstrAttrName, &varVal);
  if (SUCCEEDED(hrFind))
  {
    // found, need to clear the property
    if (m_bPostCommit)
    {
      // remove from the committed object
      hr = m_pIADs->PutEx(ADS_PROPERTY_CLEAR, bstrAttrName, varVal);
    }
    else
    {
      // remove from the cache of the temporary object
      IADsPropertyList* pPropList = NULL;
      hr = m_pIADs->QueryInterface(IID_IADsPropertyList, (void**)&pPropList);
      ASSERT(pPropList != NULL);
      if (SUCCEEDED(hr))
      {
        CComVariant v;
        v.vt = VT_BSTR;
        v.bstrVal = ::SysAllocString(bstrAttrName);
        hr = pPropList->ResetPropertyItem(v);
        pPropList->Release();
      }
    }
  }

  return hr;
}

/////////////////////////////////////////////////////////////////
// CNewADsObjectCreateInfo:: HrLoadCreationInfo()
//
//	The routine will do a lookup to match m_pszObjectClass
//	to the best "create routine".  If no match is found,
//	the create routine will point to the "Generic Create" wizard.
//

HRESULT CNewADsObjectCreateInfo::HrLoadCreationInfo()
{
	ASSERT(m_pszObjectClass != NULL);
	ASSERT(lstrlen(m_pszObjectClass) > 0);

  // Load the creation information from the display specifiers
  ASSERT(m_pCreateInfo == NULL);
  ASSERT(m_pfnCreateObject == NULL);

  HRESULT hr = ::DsGetClassCreationInfoEx(GetBasePathsInfo(), m_pszObjectClass, &m_pCreateInfo);
  if (FAILED(hr))
    return hr;

  ASSERT(m_pCreateInfo != NULL);

	// Set the default to point to the "Generic Create" wizard
	m_pfnCreateObject = HrCreateADsObjectGenericWizard;

	// Given an class name, search the lookup table for a specific create routine
  BOOL bFound = FALSE;
	for (int i = 0; i < ARRAYLEN(g_rgcno); i++)
	{
		ASSERT(g_rgcno[i].pszObjectClass != NULL);
		ASSERT(g_rgcno[i].pfnCreate != NULL);
    // compare class name
		if (0 == lstrcmp(g_rgcno[i].pszObjectClass, m_pszObjectClass))
		{
      // found matching class, compare provided GUID
      if ( (m_pCreateInfo->dwFlags & DSCCIF_HASWIZARDPRIMARYPAGE) && 
           (m_pCreateInfo->clsidWizardPrimaryPage == *(g_rgcno[i].pWizardGUID)) )
      {
        if ( IsStandaloneUI() && ((g_rgcno[i].dwFlags & CNOF_STANDALONE_UI)==0) )
        {
          return E_INVALIDARG;
        }
        else
        {
          // found matching GUID, this is our wizard
			    m_pfnCreateObject = g_rgcno[i].pfnCreate;
			    m_pvCreationParameter = g_rgcno[i].pvCreationParameter;
          bFound = TRUE;
        } // if
      } // if
      break;
    } // if
	} // for

  if (!bFound)
  {
    // we did not find any matching class name, but we might
    // have a derived class with a known wizard GUID
    for (i = 0; i < ARRAYLEN(g_rgcno); i++)
	  {
		  ASSERT(g_rgcno[i].pszObjectClass != NULL);
		  ASSERT(g_rgcno[i].pfnCreate != NULL);
      // found matching class
      if ((m_pCreateInfo->dwFlags & DSCCIF_HASWIZARDPRIMARYPAGE) && 
          (m_pCreateInfo->clsidWizardPrimaryPage == *(g_rgcno[i].pWizardGUID)))
      {
        if ( IsStandaloneUI() && ((g_rgcno[i].dwFlags & CNOF_STANDALONE_UI)==0) )
        {
          return E_INVALIDARG;
        }
        else
        {
          // found matching GUID, this is our wizard
			    m_pfnCreateObject = g_rgcno[i].pfnCreate;
			    m_pvCreationParameter = g_rgcno[i].pvCreationParameter;
          bFound = TRUE;
        } // if
        break;
      } // if
    } // for
  } // if

  if ( !bFound && (m_pCreateInfo->dwFlags & DSCCIF_HASWIZARDPRIMARYPAGE) && 
           (m_pCreateInfo->clsidWizardPrimaryPage != GUID_NULL) )
  {
    // we have a non null GUID,
    // assume this is provided a new dialog for creation
    m_pfnCreateObject = HrCreateADsObjectOverride;
  } // if

  ASSERT(m_pfnCreateObject != NULL);
	
  if ((m_pfnCreateObject == HrCreateADsObjectGenericWizard) && IsStandaloneUI())
  {
    // cannot call generic wizard under these conditions, just bail out
    m_pfnCreateObject = NULL;
    return E_INVALIDARG;
  }

  // finally we have a function pointer
  ASSERT(m_pfnCreateObject != NULL);
  return S_OK;
}
  
/////////////////////////////////////////////////////////////////////
//	HrDoModal()
//
//	Invoke a dialog to create a new object.
//
//	RETURNS
//	The return value depends on the return value of the "create routine".
//	S_OK - The object was created and persisted successfully.
//	S_FALSE - The user hit the "Cancel" button or object creation failed.
//
//	INTERFACE NOTES
//	The "create routine" will validate the data and create the object.
//	If the object creation fails, the routine should display an error
//	message and return S_FALSE.
//
//	EXTRA INFO
//	The "create routine" will validate the data and store each
//	attribute into a list of variants.
//

HRESULT
CNewADsObjectCreateInfo::HrDoModal(HWND hWnd)
{
	ASSERT(m_pszObjectClass != NULL);
	ASSERT(lstrlen(m_pszObjectClass) > 0);

  // Load the creation information from the display specifiers
  ASSERT(m_pCreateInfo != NULL);
  ASSERT(m_pfnCreateObject != NULL);
  if (m_pfnCreateObject == NULL)
    return E_INVALIDARG;

  ASSERT(hWnd != NULL);
  m_hWnd = hWnd;

  HRESULT hr = E_UNEXPECTED;
	TRY
	{
		// Invoke the "create routine" which will bring a wizard.
		hr = m_pfnCreateObject(INOUT this);
	}
	CATCH(CMemoryException, e)
	{
		hr = E_OUTOFMEMORY;
		ASSERT(e != NULL);
		e->Delete();
	}
	AND_CATCH_ALL(e)
	{
		hr = E_FAIL;
		ASSERT(e != NULL);
		e->Delete();
	}
	END_CATCH_ALL;
	return hr;
	} // HrDoModal()


/////////////////////////////////////////////////////////////////////
//	HrCreateNew()

HRESULT
CNewADsObjectCreateInfo::HrCreateNew(LPCWSTR pszName, BOOL bSilentError, BOOL bAllowCopy)
{
  ASSERT(m_bPostCommit == FALSE);
	ASSERT(m_pIADsContainer != NULL);

  CWaitCursor wait;

  // get rid of old object if there
  if (m_pIADs != NULL)
  {
    m_pIADs->Release();
    m_pIADs = NULL;
  }

  // set the given name
  m_strObjectName = pszName;
  ASSERT(!m_strObjectName.IsEmpty());
  if (m_strObjectName.IsEmpty())
    return E_INVALIDARG;
  
  m_strObjectName.TrimRight();
  m_strObjectName.TrimLeft();

  HRESULT hr;
  IDispatch * pIDispatch = NULL;
  
  CString strADsName = m_strADsName;
  if (strADsName.IsEmpty())
    {
      strADsName = m_szCacheNamingAttribute; // Typically "cn"
      strADsName += L"=";
      strADsName += GetName();
    }

  TRACE(_T("name, before escaping: %ws\n"), strADsName);
  CComBSTR bsEscapedName;

  CPathCracker pathCracker;
  hr = pathCracker.GetEscapedElement(0, //reserved
                                   (BSTR)(LPCWSTR)strADsName,
                                   &bsEscapedName);

#ifdef TESTING
  hr = _EscapeRDN ((BSTR)(LPCWSTR)strADsName,
                   &bsEscapedName);
  
#endif

  if (FAILED(hr))
    goto CleanUp;
  TRACE(_T("name, after escaping: %ws\n"), bsEscapedName);

  hr = m_pIADsContainer->Create(
                                IN (LPTSTR)m_pszObjectClass,
                                IN (LPTSTR)(LPCTSTR)bsEscapedName,
                                OUT &pIDispatch);
  if (FAILED(hr))
    goto CleanUp;
  ASSERT(pIDispatch != NULL);
  
  hr = pIDispatch->QueryInterface(IID_IADs, OUT (LPVOID *)&m_pIADs);
  if (FAILED(hr)) 
  {
    m_pIADs = NULL;
    goto CleanUp;
  }
  
  // if copy operation, do a bulk copy 
  if ((m_pCopyHandler != NULL) && bAllowCopy)
  {
    hr = m_pCopyHandler->CopyAtCreation(m_pIADs);
    if (FAILED(hr)) 
    {
      goto CleanUp;
    }
  }


  // write al the default attributes
  hr = HrAddDefaultAttributes();
  if (FAILED(hr)) 
  {
    goto CleanUp;
  }
  
  
CleanUp:
  if (pIDispatch != NULL)
    pIDispatch->Release();

  if (FAILED(hr)) 
  {
    if (!bSilentError)
    {
      PVOID apv[1] = {(LPWSTR)GetName()};
      ReportErrorEx (GetParentHwnd(),IDS_12_GENERIC_CREATION_FAILURE,hr,
                     MB_OK | MB_ICONERROR, apv, 1);
    }
    // reset to empty state
    m_strObjectName.Empty();
  }
  return hr;
}


/////////////////////////////////////////////////////////////////////
//	HrSetInfo()

HRESULT
CNewADsObjectCreateInfo::HrSetInfo(BOOL fSilentError)
{
  ASSERT(m_pIADsContainer != NULL);
  
  // we assume that HrCreateNew() has been already called
  ASSERT(m_pIADs != NULL);
  if (m_pIADs == NULL)
    return E_INVALIDARG;
  
  CWaitCursor wait;
  HRESULT hr;
  
  // Persist the object. This is it folks!!
  hr = m_pIADs->SetInfo();
  
  if (FAILED(hr)) 
  {
    if(!fSilentError)
    {
      PVOID apv[1] = {(LPWSTR)GetName()};
      ReportErrorEx (GetParentHwnd(),IDS_12_GENERIC_CREATION_FAILURE,hr,
                     MB_OK | MB_ICONERROR, apv, 1);
      m_strObjectName = L"";
    }
  }
  
  if (!FAILED(hr)) 
  {
    // Make sure re-fill the cache
    hr = m_pIADs->GetInfo();
    if (FAILED(hr))
    {
      if (!fSilentError)
      {
        PVOID apv[1] = {(LPWSTR)GetName()};
        ReportErrorEx (GetParentHwnd(),IDS_12_GENERIC_CREATION_FAILURE,hr,
                       MB_OK | MB_ICONERROR, apv, 1);
        m_strObjectName = L"";
      }
    }
  }
  
  return hr;
} // HrSetInfo()


////////////////////////////////////////////////////////////////////
// HrDeleteFromBackend()
//
//  deletes object from back end when post commit fails
//
HRESULT CNewADsObjectCreateInfo::HrDeleteFromBackend()
{
  ASSERT(m_pIADsContainer != NULL);
  ASSERT(m_pIADs != NULL);

  // get the name of the object
  CComBSTR bstrName;
  HRESULT hr = m_pIADs->get_Name(&bstrName);
  if (SUCCEEDED(hr))
  {
    // do the actual delete
    ASSERT(bstrName != NULL);
    hr = m_pIADsContainer->Delete((LPWSTR)m_pszObjectClass, bstrName);
  }

  // release the object only if we could delete it
  if (SUCCEEDED(hr))
    SetIADsPtr(NULL);
  return hr;
}


/////////////////////////////////////////////////////////////////////////
// CDsAdminCreateObj

HRESULT _ReBindToObj(INOUT CComPtr<IADs>& spIADs,
                     INOUT CString& szServerName)
{
  // get the path of the object

  CComBSTR bstrObjectLdapPath;
  HRESULT hr = spIADs->get_ADsPath(&bstrObjectLdapPath);
  if (FAILED(hr))
  {
    return hr;
  }

  // make sure we are bound to a server
  if (szServerName.IsEmpty())
  {
    hr = GetADSIServerName(szServerName, spIADs);
    if (FAILED(hr))
    {
      return hr;
    }
  }

  if (szServerName.IsEmpty())
  {
    return E_INVALIDARG;
  }

  // rebuild the LDAP path with the server
  CPathCracker pathCracker;

  CComBSTR bsX500DN;
  pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
  pathCracker.Set(bstrObjectLdapPath, ADS_SETTYPE_FULL);
  pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_ON);
  pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bsX500DN);

  CString szNewLdapPath;
  szNewLdapPath.Format(L"LDAP://%s/%s", (LPCWSTR)szServerName, bsX500DN);

  // bind to the object again
  CComPtr<IADs> spADsObjNew;
  hr = DSAdminOpenObject(szNewLdapPath,
                         IID_IADs, 
                         (void **)&spADsObjNew,
                         TRUE /*bServer*/);
  if (FAILED(hr))
  {
    return hr;
  }

  // update smart pointer
  spIADs = spADsObjNew;

  return S_OK;
  
}

HRESULT _ReBindToContainer(INOUT CComPtr<IADsContainer>& spADsContainerObj,
                           INOUT CString& szServerName)
{
  // get the path of the container
  CComPtr<IADs> spIADsCont;
  HRESULT hr = spADsContainerObj->QueryInterface(IID_IADs, (void**)&spIADsCont);
  if (FAILED(hr))
  {
    return hr;
  }

  hr = _ReBindToObj(spIADsCont, szServerName);
  if (FAILED(hr))
  {
    return hr;
  }

  CComPtr<IADsContainer> spADsContainerObjNew;
  hr = spIADsCont->QueryInterface(IID_IADsContainer, (void**)&spADsContainerObjNew);
  if (FAILED(hr))
  {
    return hr;
  }
  
  // update smart pointer
  spADsContainerObj = spADsContainerObjNew;

  return S_OK;
}





HRESULT CDsAdminCreateObj::Initialize(IADsContainer* pADsContainerObj,
                                      IADs* pADsCopySource,
                                      LPCWSTR lpszClassName)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  if ((pADsContainerObj == NULL) || (lpszClassName == NULL))
  {
    // must have valid pointers
    return E_INVALIDARG;
  }

  m_szObjectClass = lpszClassName;
  m_szObjectClass.TrimRight();
  m_szObjectClass.TrimLeft();
  if (m_szObjectClass.IsEmpty())
  {
    // passed blank?
    return E_INVALIDARG;
  }

  if ((pADsCopySource != NULL) && (m_szObjectClass != L"user")
#ifdef INETORGPERSON
      && (m_szObjectClass != L"inetOrgPerson")
#endif
     )
  {
    // we allow the copy operation only for users
    return E_INVALIDARG;
  }

  // make sure we have the right LDAP path
  m_spADsContainerObj = pADsContainerObj;
  CString szServerName;
  HRESULT hr = _ReBindToContainer(m_spADsContainerObj, szServerName);
  if (FAILED(hr))
  {
    return hr;
  }

 
  hr = m_basePathsInfo.InitFromContainer(m_spADsContainerObj);
  if (FAILED(hr))
  {
    return hr;
  }

  hr = _GetNamingAttribute();
  if (FAILED(hr))
  {
    return hr;
  }

  ASSERT(m_pNewADsObjectCreateInfo == NULL);
  if (m_pNewADsObjectCreateInfo != NULL)
    delete m_pNewADsObjectCreateInfo;

  m_pNewADsObjectCreateInfo = new CNewADsObjectCreateInfo(&m_basePathsInfo, m_szObjectClass);
  if (m_pNewADsObjectCreateInfo == NULL)
    return E_OUTOFMEMORY;

  m_pNewADsObjectCreateInfo->SetContainerInfo(m_spADsContainerObj, NULL, NULL, m_szNamingAttribute);

  
  // copy operation, need to set the copy source
  if (pADsCopySource != NULL)
  {
    CComPtr<IADs> spADsCopySource = pADsCopySource;
    hr = _ReBindToObj(spADsCopySource, szServerName);
    if (FAILED(hr))
    {
      return hr;
    }

    hr = m_pNewADsObjectCreateInfo->SetCopyInfo(spADsCopySource);
    if (FAILED(hr))
    {
      return hr;
    }
  }

  
  hr = m_pNewADsObjectCreateInfo->HrLoadCreationInfo();

  if (FAILED(hr))
  {
    delete m_pNewADsObjectCreateInfo;
    m_pNewADsObjectCreateInfo = NULL;
  }
  return hr;
}

HRESULT CDsAdminCreateObj::CreateModal(HWND hwndParent,
                           IADs** ppADsObj)
{
  if ( (m_pNewADsObjectCreateInfo == NULL)
      || (hwndParent == NULL) || (m_spADsContainerObj == NULL)
      || m_szObjectClass.IsEmpty() || m_szNamingAttribute.IsEmpty())
    return E_INVALIDARG;

  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  HRESULT hr = m_pNewADsObjectCreateInfo->HrDoModal(hwndParent);
  IADs* pIADs = m_pNewADsObjectCreateInfo->PGetIADsPtr();

  if ( (hr != S_FALSE) && SUCCEEDED(hr) && (ppADsObj != NULL))
  {
    *ppADsObj = pIADs;
    pIADs = NULL; // transfer ownership
  }

  if (pIADs != NULL)
    pIADs->Release();
  return hr;
}


HRESULT CDsAdminCreateObj::_GetNamingAttribute()
{
  CString szSchemaPath;
  m_basePathsInfo.GetAbstractSchemaPath(szSchemaPath);
  ASSERT(!szSchemaPath.IsEmpty());

  CString szSchemaClassPath;
  szSchemaClassPath.Format(L"%s/%s", (LPCWSTR)szSchemaPath, 
                                    (LPCWSTR)m_szObjectClass);

  CComPtr<IADsClass> spDsClass;
  CComBSTR bstr = szSchemaClassPath;
  HRESULT hr = DSAdminOpenObject(bstr,
                                 IID_IADsClass, 
                                 (void**)&spDsClass,
                                 TRUE /*bServer*/);
  if (FAILED(hr))
    return hr;

  CComVariant Var;
  hr = spDsClass->get_NamingProperties(&Var);
  if (FAILED(hr))
  {
    m_szNamingAttribute.Empty();
    return hr;
  }

  m_szNamingAttribute = Var.bstrVal;
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\helpids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       helpids.h
//
//--------------------------------------------------------------------------

#ifdef IDH_NO_HELP
#undef IDH_NO_HELP
#define IDH_NO_HELP static_cast<ULONG>(-1L)
#endif

#define DSADMIN_CONTEXT_HELP_FILE L"dsadmin.hlp"
#define DSADMIN_LINKED_HELP_FILE L"ADconcepts.chm"
#define DSADMIN_DEFAULT_TOPIC L"ADconcepts.chm::/dsadmin_top.htm"
#define DSSITES_DEFAULT_TOPIC L"ADconcepts.chm::/dssite_top.htm"

// FSMO transfer topics
#define DSADMIN_MOREINFO_RID_POOL_FSMO_TOPIC L"ADconcepts.chm::/FSMO_RID_POOL_ForcefulSeizure.htm"
#define DSADMIN_MOREINFO_PDC_FSMO_TOPIC L"ADconcepts.chm::/FSMO_PDC_ForcefulSeizure.htm"
#define DSADMIN_MOREINFO_INFRASTUCTURE_FSMO_TOPIC L"ADconcepts.chm::/FSMO_INFRASTRUCTURE_ForcefulSeizure.htm"

//
#define DSADMIN_MOREINFO_LOCAL_LOGIN_ERROR L"ADConcepts.chm::/sag_ADlocalNotAD.htm"
#define DSADMIN_MOREINFO_FSMO_TARGET_DC_IS_GC L"ADConcepts.chm::/sag_adGcInfFSMO.htm"

#define	IDH_BUILTIN_QUERY_CHECK_LIST	300000102
#define	IDH_CHANGE_FSMO_INFRA	300000552
#define	IDH_CHANGE_FSMO_PDC	300000202
#define	IDH_CHANGE_FSMO_RID	300000602
#define	IDH_CHECK_PASSWORD_MUST_CHANGE	300000052
#define	IDH_CONFIRM_PASSWORD	300000051
#define	IDH_DISP_NAME_EDIT	300000453
#define	IDH_EDIT_CURRENT_DC_INFRA	300000550
#define	IDH_EDIT_CURRENT_DC_PDC	300000200
#define	IDH_EDIT_CURRENT_DC_RID	300000600
#define	IDH_EDIT_CURRENT_FSMO_DC_INFRA	300000551
#define	IDH_EDIT_CURRENT_FSMO_DC_PDC	300000201
#define	IDH_EDIT_CURRENT_FSMO_DC_RID	300000601
#define	IDH_EDIT_CUSTOM_BUTTON	300000104
#define	IDH_EDIT_DISPLAY_NAME	300000153
#define	IDH_EDIT_OBJECT_NAME2	300000450
#define	IDH_EDIT_OBJECT_NAME3	300000500
#define	IDH_EDIT_OBJECT_NAME4	300000150
#define	IDH_FIRST_NAME_EDIT1	300000451
#define	IDH_FIRST_NAME_EDIT2	300000151
#define	IDH_LAST_NAME_EDIT1	300000452
#define	IDH_LAST_NAME_EDIT2	300000152
#define	IDH_MAX_ITEM_COUNT_EDIT	300000105
#define	IDH_NT4_DOMAIN_EDIT	300000156
#define	IDH_NT4_USER_EDIT1	300000501
#define	IDH_NT4_USER_EDIT3	300000157
#define	IDH_NT5_DOMAIN_COMBO	300000155
#define	IDH_NT5_USER_EDIT	300000154
#define	IDH_SELECTDC_DCEDIT	300000353
#define	IDH_SELECTDC_DCLISTVIEW	300000355
#define	IDH_SELECTDC_DOMAIN	300000350
#define	IDH_SELECTDOMAIN_BROWSE	300000401
#define	IDH_SELECTDOMAIN_DOMAIN	300000400
#define	IDH_SHOW_ALL_RADIO	300000100
#define	IDH_SHOW_BUILTIN_RADIO	300000101
#define	IDH_SHOW_CUSTOM_RADIO	300000103
#define	IDH_USER_NAME	300000300
#define IDH_BROWSE_FOR_OBJECT   300000650
#define IDH_SELECTDC_BROWSE	300000700
// for future expansion, use 300000706 to 300000725
#define IDH_SAVE_CURRENT_CHECK  300000707

//
// Name Mapping
//
#define IDH_EDIT_USER_ACCOUNT           300000701
#define IDH_LISTVIEW_X509               300000702
#define IDH_BUTTON_ADD                  300000703
#define IDH_BUTTON_EDIT                 300000704
#define IDH_BUTTON_REMOVE               300000705
#define IDH_LISTVIEW_KERBEROS           300000706
#define IDH_EDIT_KERBEROS_NAME          300000708

//
// New Saved Query dialog
//
#define IDH_NAME_EDIT                   300000801
#define IDH_DESCRIPTION_EDIT            300000802
#define IDH_ROOT_EDIT                   300000803
#define IDH_BROWSE_BUTTON               300000804
#define IDH_MULTI_LEVEL_CHECK           300000805
#define IDH_QUERY_STRING_EDIT           300000806
#define IDH_EDIT_BUTTON                 300000807
#define IDH_OK_BUTTON                   300000808
#define IDH_CANCEL_BUTTON               300000809

//
// Saved Query forms
//
#define IDH_NAME_COMBO                  300000810
#define IDH_NAME_EDIT_QUERY_FORM        300000811
#define IDH_DESCRIPTION_COMBO           300000812
#define IDH_DESCRIPTION_EDIT_QUERY_FORM 300000813
#define IDH_DISABLED_ACCOUNTS_CHECK     300000814
#define IDH_NON_EXPIRING_PWD_CHECK      300000815
#define IDH_LASTLOGON_COMBO             300000816

//
// Favorites folder property page
//
#define IDH_CN                          300000817
#define IDH_DESCRIPTION_EDIT_FAVORITES  300000818


//sites and services
#ifdef FIXUPDC
#define	IDH_FIXUP_DC_CHECK0	300000250
#define	IDH_FIXUP_DC_CHECK1	300000251
#define	IDH_FIXUP_DC_CHECK2	300000252
#define	IDH_FIXUP_DC_CHECK3	300000253
#define	IDH_FIXUP_DC_CHECK4	300000254
#define	IDH_FIXUP_DC_CHECK5	300000255
#endif // FIXUPDC

extern const DWORD g_aHelpIDs_IDD_CHANGE_PASSWORD[];
#ifdef FIXUPDC
extern const DWORD g_aHelpIDs_IDD_FIXUP_DC[];
#endif // FIXUPDC
extern const DWORD g_aHelpIDs_IDD_PASSWORD[];
extern const DWORD g_aHelpIDs_IDD_QUERY_FILTER[];
extern const DWORD g_aHelpIDs_IDD_RENAME_USER[];
extern const DWORD g_aHelpIDs_IDD_SELECT_DC[];
extern const DWORD g_aHelpIDs_IDD_SELECT_DOMAIN[];
extern const DWORD g_aHelpIDs_IDD_RENAME_GROUP[];
extern const DWORD g_aHelpIDs_IDD_RENAME_CONTACT[];
extern const DWORD g_aHelpIDs_IDD_RID_FSMO_PAGE[];
extern const DWORD g_aHelpIDs_IDD_PDC_FSMO_PAGE[];
extern const DWORD g_aHelpIDs_IDD_INFRA_FSMO_PAGE[];
extern const DWORD g_aHelpIDs_IDD_RENAME_COMPUTER[];
extern const DWORD g_aHelpIDs_IDD_BROWSE_CONTAINER[];
extern const DWORD g_aHelpIDs_IDD_CREATE_NEW_QUERY[];
extern const DWORD g_aHelpIDs_IDD_QUERY_STD_PAGE[];
extern const DWORD g_aHelpIDs_IDD_QUERY_USER_PAGE[];
extern const DWORD g_aHelpIDs_IDD_FAVORITES_PROPERTY_PAGE[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\gsz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       gsz.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	gsz.h - Constant global strings used everywhere in the project.
//
//	The purpose of this file is to avoid typos and string duplicates.
//
//	HISTORY
//	26-Aug-97	Dan Morin	Creation.
/////////////////////////////////////////////////////////////////////

#ifndef __GSZ_H_INCLUDED__
#define __GSZ_H_INCLUDED__

/////////////////////////////////////////////////////////////////////
//	Each variable has the following pattern gsz_<stringcontent>
//	with EXACT matching case of its content.
//
//	The preferred Hungarian type would be g_sz followed by an
//	uppercase, however gsz_ followed by the string itself makes
//	it easier to know the content of the string.
//
//	EXAMPLES
//	const TCHAR gsz_cn[]		= _T("cn");
//	const TCHAR gsz_lastName[]	= _T("lastName");
//	const TCHAR gsz_uNCName[]	= _T("uNCName");
//
//	SEE ALSO
//	Use the macro DEFINE_GSZ() to declare a new variable.  It will
//	save you some typing.
/////////////////////////////////////////////////////////////////////

#define DEFINE_GSZ(sz)	const TCHAR gsz_##sz[] = _T(#sz)

DEFINE_GSZ(cn);

///////////////////////////////////////
DEFINE_GSZ(user);
#ifdef INETORGPERSON
DEFINE_GSZ(inetOrgPerson);
#endif
	DEFINE_GSZ(sn);			// Surname
	DEFINE_GSZ(lastName);
	DEFINE_GSZ(samAccountName);

///////////////////////////////////////
DEFINE_GSZ(group);
DEFINE_GSZ(groupType);

///////////////////////////////////////
DEFINE_GSZ(contact);

///////////////////////////////////////
DEFINE_GSZ(volume);
DEFINE_GSZ(printQueue);
	DEFINE_GSZ(uNCName);

///////////////////////////////////////
DEFINE_GSZ(computer);
	DEFINE_GSZ(networkAddress);
	DEFINE_GSZ(userAccountControl);

///////////////////////////////////////
DEFINE_GSZ(nTDSConnection);
DEFINE_GSZ(nTDSSiteSettings);
DEFINE_GSZ(serversContainer);
DEFINE_GSZ(licensingSiteSettings);
DEFINE_GSZ(siteLink);
	DEFINE_GSZ(siteList);
DEFINE_GSZ(siteLinkBridge);
	DEFINE_GSZ(siteLinkList);
///////////////////////////////////////
DEFINE_GSZ(server);
DEFINE_GSZ(site);
DEFINE_GSZ(subnet);
	DEFINE_GSZ(siteObject);

#ifdef FRS_CREATE
///////////////////////////////////////
DEFINE_GSZ(nTFRSSettings);
DEFINE_GSZ(nTFRSReplicaSet);
DEFINE_GSZ(nTFRSMember);
DEFINE_GSZ(nTFRSSubscriptions);
DEFINE_GSZ(nTFRSSubscriber);
	DEFINE_GSZ(fRSRootPath);
	DEFINE_GSZ(fRSStagingPath);
#endif // FRS_CREATE

///////////////////////////////////////
DEFINE_GSZ(organizationalUnit);


//////////////////////////////////////
//-----------------------------------
DEFINE_GSZ(objectClass);
DEFINE_GSZ(nTSecurityDescriptor);
DEFINE_GSZ(instanceType);
DEFINE_GSZ(objectSid);
DEFINE_GSZ(objectCategory);

#endif // ~__GSZ_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\newobjcr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       newobjcr.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	newobjcr.cpp
//
//	This file contains implementation of functions to create
//	new ADs objects.
//
//	HISTORY
//	19-Aug-97	Dan Morin	Creation.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "newobj.h"

#include "dlgcreat.h"
#include "dscmn.h"    // CrackName()
#include "gencreat.h"
#include "querysup.h" // CDSSearch

extern "C"
{
#ifdef FRS_CREATE
#include "dsquery.h" // CLSID_DsFindFrsMembers
#endif // FRS_CREATE
#include <schedule.h>
}


#define BREAK_ON_TRUE(b) if (b) { ASSERT(FALSE); break; }
#define BREAK_ON_FAIL BREAK_ON_TRUE(FAILED(hr))
#define RETURN_IF_FAIL if (FAILED(hr)) { ASSERT(FALSE); return hr; }


//
// The schedule block has been redefined to have 1 byte for every hour.
// CODEWORK These should be defined in SCHEDULE.H.  JonN 2/9/98
//
#define INTERVAL_MASK       0x0F
#define RESERVED            0xF0
#define FIRST_15_MINUTES    0x01
#define SECOND_15_MINUTES   0x02
#define THIRD_15_MINUTES    0x04
#define FORTH_15_MINUTES    0x08

// The dialog has one bit per hour, the DS schedule has one byte per hour
#define cbDSScheduleArrayLength (24*7)

#define HeadersSizeNum(NumberOfSchedules) \
    (sizeof(SCHEDULE) + ((NumberOfSchedules)-1)*sizeof(SCHEDULE_HEADER))

inline ULONG HeadersSize(SCHEDULE* psched)
{
    return HeadersSizeNum(psched->NumberOfSchedules);
}


/////////////////////////////////////////////////////////////////////
//	HrCreateADsUser()
//
//	Create a new user.
//
HRESULT HrCreateADsUser(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
{
	ASSERT(pNewADsObjectCreateInfo != NULL);
#ifdef INETORGPERSON
	ASSERT(0 == lstrcmp(L"user", pNewADsObjectCreateInfo->m_pszObjectClass) || 0 == lstrcmp(L"inetOrgPerson", pNewADsObjectCreateInfo->m_pszObjectClass));
#else
	ASSERT(0 == lstrcmp(L"user", pNewADsObjectCreateInfo->m_pszObjectClass));
#endif
	CCreateNewUserWizard wiz(pNewADsObjectCreateInfo);
  return wiz.DoModal();
} // HrCreateADsUser()


/////////////////////////////////////////////////////////////////////
//	HrCreateADsVolume()
//
//	Create a new volume.
//
HRESULT
HrCreateADsVolume(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
{
  ASSERT(pNewADsObjectCreateInfo != NULL);
  ASSERT(0 == lstrcmp(L"volume", pNewADsObjectCreateInfo->m_pszObjectClass));
  CCreateNewVolumeWizard wiz(pNewADsObjectCreateInfo);
  return wiz.DoModal();
} // HrCreateADsVolume()


/////////////////////////////////////////////////////////////////////
//	HrCreateADsComputer()
//
//	Create a new computer.
//
HRESULT
HrCreateADsComputer(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
	{
	ASSERT(pNewADsObjectCreateInfo != NULL);
	ASSERT(0 == lstrcmp(L"computer", pNewADsObjectCreateInfo->m_pszObjectClass));
	CCreateNewComputerWizard wiz(pNewADsObjectCreateInfo);
  return wiz.DoModal();
	} // HrCreateADsComputer()


/////////////////////////////////////////////////////////////////////
//	HrCreateADsPrintQueue()
//
//	Create a new print queue object.
//
HRESULT
HrCreateADsPrintQueue(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
	{
	ASSERT(pNewADsObjectCreateInfo != NULL);
	ASSERT(0 == lstrcmp(L"printQueue", pNewADsObjectCreateInfo->m_pszObjectClass));
	CCreateNewPrintQWizard wiz(pNewADsObjectCreateInfo);
  return wiz.DoModal();
	} // HrCreateADsPrintQueue()


/////////////////////////////////////////////////////////////////////
//  HrCreateADsNtDsConnection()
//
//  Create a new NTDS-Connection object.  Note that this is not supported
//  if the parent is an FRS object.
//
HRESULT
HrCreateADsNtDsConnection(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
	{
	ASSERT(pNewADsObjectCreateInfo != NULL);
	ASSERT(0 == lstrcmp(L"nTDSConnection", pNewADsObjectCreateInfo->m_pszObjectClass));
	// do not allow this in the standalone case
	if (pNewADsObjectCreateInfo->IsStandaloneUI())
	{
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	// determine whether this is an NTDS connection or an FRS connection
	// CODEWORK this code can probably be removed
	CPathCracker pathCracker;
	HRESULT hr = S_OK;
	CString strConfigPath;
	CComBSTR sbstrParentPath;
	bool fParentIsFrs = false;
	{
		// determine whether this is an FRS instance
		CComQIPtr<IADs, &IID_IADs> spIADsParent( pNewADsObjectCreateInfo->m_pIADsContainer );
		ASSERT( !!spIADsParent );
		CComBSTR sbstrClass;
		hr = spIADsParent->get_ADsPath( &sbstrParentPath );
		RETURN_IF_FAIL;
		hr = spIADsParent->get_Class( &sbstrClass );
		RETURN_IF_FAIL;
		hr = DSPROP_IsFrsObject( sbstrClass, &fParentIsFrs );
		RETURN_IF_FAIL;

		// Determine which subtree should be searched
		if (fParentIsFrs)
		{
#ifndef FRS_CREATE
			// We shouldn't have seen the option to create a connection here
			ASSERT(FALSE);
			return S_FALSE;
#else
			sbstrClass.Empty();
			hr = spIADsParent->get_ADsPath( &sbstrClass );
			RETURN_IF_FAIL;
			hr = DSPROP_RemoveX500LeafElements( 1, &sbstrClass );
			RETURN_IF_FAIL;

			strConfigPath = sbstrClass;
#endif // FRS_CREATE
		}
		else
		{
			pNewADsObjectCreateInfo->GetBasePathsInfo()->GetConfigPath(strConfigPath);
		}
	}

	CCreateNewObjectCnWizard wiz(pNewADsObjectCreateInfo);

	// Get the target server path from the user.  The path is stored in a BSTR variant.
	CComBSTR sbstrTargetServer;
#ifdef FRS_CREATE
	if (fParentIsFrs)
	{
		hr = DSPROP_DSQuery(
			pNewADsObjectCreateInfo->GetParentHwnd(),
			strConfigPath,
			const_cast<CLSID*>(&CLSID_DsFindFrsMembers),
			&sbstrTargetServer );
	}
	else
#endif // FRS_CREATE
	{
		hr = DSPROP_PickNTDSDSA(
			pNewADsObjectCreateInfo->GetParentHwnd(),
			strConfigPath,
			&sbstrTargetServer );
	}
	if (hr == S_FALSE)
    {
		// User canceled the dialog
		return S_FALSE;
	}
	RETURN_IF_FAIL;
	if (sbstrTargetServer == sbstrParentPath)
	{
		// 6231: Shouldn't be able to create a connection to "yourself"
		ReportMessageEx( pNewADsObjectCreateInfo->GetParentHwnd(),
			IDS_CONNECTION_TO_SELF );
		return S_FALSE;
	}

	CComBSTR sbstrTargetServerX500DN;
	hr = pathCracker.Set( sbstrTargetServer, ADS_SETTYPE_FULL );
	RETURN_IF_FAIL;
	hr = pathCracker.SetDisplayType( ADS_DISPLAY_FULL );
	RETURN_IF_FAIL;
	hr = pathCracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrTargetServerX500DN );
	RETURN_IF_FAIL;

	// 33881: prevent duplicate connection objects
	{
		CDSSearch Search;
		Search.Init(sbstrParentPath);
		CString filter;
		filter.Format(L"(fromServer=%s)", sbstrTargetServerX500DN);
		Search.SetFilterString(const_cast<LPTSTR>((LPCTSTR) filter));
		LPWSTR pAttrs[1] =
		{
				L"name"
		};
		Search.SetAttributeList(pAttrs, 1);
		Search.SetSearchScope(ADS_SCOPE_SUBTREE);

		hr = Search.DoQuery();
		if (SUCCEEDED(hr))
		{
			hr = Search.GetNextRow();
			if (SUCCEEDED(hr) && S_ADS_NOMORE_ROWS != hr)
			{
				DWORD dwRetval = ReportMessageEx(
					pNewADsObjectCreateInfo->GetParentHwnd(),
					IDS_DUPLICATE_CONNECTION,
					MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING );
				if (IDYES != dwRetval)
					return S_FALSE;
			}
		}
	}

	hr = pNewADsObjectCreateInfo->HrAddVariantBstr(
			L"fromServer", sbstrTargetServerX500DN, TRUE );
	RETURN_IF_FAIL;

	{
		// NTDS: set default name to RDN of parent of target NTDS-DSA
		// FRS:  set default name to RDN of target NTFRS-Member
		CComBSTR bstrDefaultRDN;
		hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
		RETURN_IF_FAIL;
		hr = pathCracker.GetElement( (fParentIsFrs) ? 0 : 1, &bstrDefaultRDN );
		RETURN_IF_FAIL;
		ASSERT( !!bstrDefaultRDN && TEXT('\0') != *bstrDefaultRDN );
		pNewADsObjectCreateInfo->m_strDefaultObjectName = bstrDefaultRDN;
		hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
		RETURN_IF_FAIL;
	}

  //
	// Must do this before DoModal, OnOK will try to actually create the object
  //
	hr = pNewADsObjectCreateInfo->HrAddVariantLong(L"options", 0, TRUE);
	RETURN_IF_FAIL;
	hr = pNewADsObjectCreateInfo->HrAddVariantBoolean(L"enabledConnection", TRUE, TRUE);
	RETURN_IF_FAIL;

	{
		//
		// Store initial schedule
		//
		BYTE abyteSchedule[ HeadersSizeNum(1) + cbDSScheduleArrayLength ];
		ZeroMemory( &abyteSchedule, sizeof(abyteSchedule) );
		PSCHEDULE pNewScheduleBlock = (PSCHEDULE) abyteSchedule;
		pNewScheduleBlock->Size = sizeof(abyteSchedule);
		pNewScheduleBlock->NumberOfSchedules = 1;
		pNewScheduleBlock->Schedules[0].Type = SCHEDULE_INTERVAL;
		pNewScheduleBlock->Schedules[0].Offset = HeadersSizeNum(1);
		memset( ((BYTE*)pNewScheduleBlock)+pNewScheduleBlock->Schedules[0].Offset,
				 INTERVAL_MASK,
				 cbDSScheduleArrayLength ); // turn on all intervals

		CComVariant varSchedule;
		hr = BinaryToVariant( sizeof(abyteSchedule), abyteSchedule, &varSchedule );
		RETURN_IF_FAIL;
		hr = pNewADsObjectCreateInfo->HrAddVariantCopyVar(L"schedule", IN varSchedule, TRUE);
		RETURN_IF_FAIL;
	}

	// CODEWORK: Need to set the dialog caption
	hr = wiz.DoModal();

	return hr;
} // HrCreateADsNtDsConnection()


HRESULT
HrCreateADsFixedName(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
{
  // Store the object name in the temporary storage
  LPCWSTR pcsz = reinterpret_cast<LPCWSTR>(pNewADsObjectCreateInfo->QueryCreationParameter());
  ASSERT( NULL != pcsz );
  pNewADsObjectCreateInfo->HrCreateNew(pcsz);
  // Create and persist the object
  HRESULT hr = pNewADsObjectCreateInfo->HrSetInfo(TRUE /*fSilentError*/);
  
  if (SUCCEEDED(hr)) {
    CString csCaption, csMsg;
    csCaption.LoadString(IDS_CREATE_NEW_OBJECT_TITLE);
    csMsg.Format(IDS_s_CREATE_NEW_OBJECT_NOTICE, pNewADsObjectCreateInfo->GetName());
    ::MessageBox(
                 pNewADsObjectCreateInfo->GetParentHwnd(),
                 csMsg,
                 csCaption,
                 MB_OK | MB_SETFOREGROUND | MB_ICONINFORMATION);
  }
  
  return hr;
}


HRESULT
HrCreateADsSiteLink(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
    {
    ASSERT(pNewADsObjectCreateInfo != NULL);
    ASSERT(0 == lstrcmp(gsz_siteLink, pNewADsObjectCreateInfo->m_pszObjectClass));

    // load list of sites
    DSPROP_BSTR_BLOCK bstrblock;
    CComQIPtr<IADs, &IID_IADs> container(pNewADsObjectCreateInfo->m_pIADsContainer);
    if (container)
    {
        CComBSTR container_path;
        container->get_ADsPath(&container_path);
        HRESULT hr = DSPROP_RemoveX500LeafElements( 2, &container_path );
        if ( SUCCEEDED(hr) )
        {
            hr = DSPROP_ShallowSearch(
                &bstrblock,
                container_path,
                L"site" );
        }
        if ( FAILED(hr) )
        {
            ReportErrorEx (pNewADsObjectCreateInfo->GetParentHwnd(),
                           IDS_SITELINKERROR_READING_SITES,
                           hr,
                           MB_OK, NULL, 0);
            return S_FALSE;
        }
    }

    if ( 2 > bstrblock.QueryCount() )
    {
        ReportMessageEx(pNewADsObjectCreateInfo->GetParentHwnd(),
                        IDS_SITELINK_NOT_ENOUGH_SITES,
                        MB_OK | MB_ICONSTOP);
        // allow wizard to continue, CODEWORK note that this
        // doesn't quite work right when zero sites are detected
    }

    // set default cost to 100 (by request of JeffParh)
    HRESULT hr = pNewADsObjectCreateInfo->HrAddVariantLong(L"cost", 100L, TRUE);
    RETURN_IF_FAIL;

    // set default replInterval to 180 (by request of JeffParh)
    hr = pNewADsObjectCreateInfo->HrAddVariantLong(L"replInterval", 180L, TRUE);
    RETURN_IF_FAIL;

    CCreateNewSiteLinkWizard wiz(pNewADsObjectCreateInfo,bstrblock);
    return wiz.DoModal(); 
    }

HRESULT
HrCreateADsSiteLinkBridge(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
	{
	ASSERT(pNewADsObjectCreateInfo != NULL);
	ASSERT(0 == lstrcmp(gsz_siteLinkBridge, pNewADsObjectCreateInfo->m_pszObjectClass));

    // load list of site links
    DSPROP_BSTR_BLOCK bstrblock;
    CComQIPtr<IADs, &IID_IADs> container(pNewADsObjectCreateInfo->m_pIADsContainer);
    if (container)
    {
        CComBSTR container_path;
        container->get_ADsPath(&container_path);
        HRESULT hr = DSPROP_ShallowSearch(
            &bstrblock,
            container_path,
            L"siteLink" );
        if ( FAILED(hr) )
        {
            ReportErrorEx (pNewADsObjectCreateInfo->GetParentHwnd(),
                           IDS_SITELINKBRIDGEERROR_READING_SITELINKS,
                           hr,
                           MB_OK, NULL, 0);
            return S_FALSE;
        }
   }

   if ( 2 > bstrblock.QueryCount() )
   {
     ReportMessageEx(pNewADsObjectCreateInfo->GetParentHwnd(),
                     IDS_SITELINKBRIDGE_NOT_ENOUGH_SITELINKS,
                     MB_OK | MB_ICONSTOP);
     return S_FALSE; // do not allow wizard to continue
   }

	CCreateNewSiteLinkBridgeWizard wiz(pNewADsObjectCreateInfo,bstrblock);
	return wiz.DoModal(); 
	}

#ifdef FRS_CREATE
HRESULT
HrCreateADsNtFrsMember(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
	{
	ASSERT(pNewADsObjectCreateInfo != NULL);
	ASSERT(0 == lstrcmp(gsz_nTFRSMember, pNewADsObjectCreateInfo->m_pszObjectClass));

	//
	// set up Frs-Computer-Reference attribute
	//

	CComBSTR sbstrComputerPath;
	// pNewADsObjectCreateInfo->m_strDefaultObjectName = sbstrComputerRDN;
	HRESULT hr = DSPROP_PickComputer( pNewADsObjectCreateInfo->GetParentHwnd(), &sbstrComputerPath );
	RETURN_IF_FAIL;
	// Allow user to quit if user hit Cancel
	if (hr == S_FALSE)
		return S_FALSE;

	// set default name to RDN of target Computer
	hr = pathCracker.Set(sbstrComputerPath, ADS_SETTYPE_FULL);
	RETURN_IF_FAIL;
	hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
	RETURN_IF_FAIL;
	sbstrComputerPath.Empty();
	hr = pathCracker.GetElement( 0, &sbstrComputerPath );
	RETURN_IF_FAIL;
	pNewADsObjectCreateInfo->m_strDefaultObjectName = sbstrComputerPath;
	hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
	RETURN_IF_FAIL;

	// set frsComputerReference for new object
	sbstrComputerPath.Empty();
	hr = pathCracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrComputerPath );
	RETURN_IF_FAIL;
	hr = pNewADsObjectCreateInfo->HrAddVariantBstr(
		L"frsComputerReference", sbstrComputerPath, TRUE );
	RETURN_IF_FAIL;

	hr = HrCreateADsSimpleObject(pNewADsObjectCreateInfo);
	return hr;
	}

HRESULT
HrCreateADsNtFrsSubscriber(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
	{
	ASSERT(pNewADsObjectCreateInfo != NULL);
	ASSERT(0 == lstrcmp(gsz_nTFRSSubscriber, pNewADsObjectCreateInfo->m_pszObjectClass));

	// User finds target nTFRSMember object
	CComBSTR sbstrTargetMember;
	HRESULT hr = DSPROP_DSQuery(
		pNewADsObjectCreateInfo->GetParentHwnd(),
		NULL, // any member
		const_cast<CLSID*>(&CLSID_DsFindFrsMembers),
		&sbstrTargetMember );
	if (hr == S_FALSE)
		{
		// User canceled the dialog
		return S_FALSE;
		}
	RETURN_IF_FAIL;

	// set default name of new nTFRSSubscriber to RDN of target nTFRSMember
	hr = pathCracker.Set( sbstrTargetMember, ADS_SETTYPE_FULL );
	RETURN_IF_FAIL;
	hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
	RETURN_IF_FAIL;
	sbstrTargetMember.Empty();
	hr = pathCracker.GetElement( 0, &sbstrTargetMember );
	RETURN_IF_FAIL;
	pNewADsObjectCreateInfo->m_strDefaultObjectName = sbstrTargetMember;
	hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
	RETURN_IF_FAIL;

    // set fRSMemberReference attribute to target nTFRSMember
	sbstrTargetMember.Empty();
	hr = pathCracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrTargetMember );
	RETURN_IF_FAIL;
	hr = pNewADsObjectCreateInfo->HrAddVariantBstr(
		L"fRSMemberReference", sbstrTargetMember, TRUE );
	RETURN_IF_FAIL;

	CCreateNewFrsSubscriberWizard wiz(pNewADsObjectCreateInfo);
	return wiz.DoModal(); 
	}

//+----------------------------------------------------------------------------
//
//  Function:   CreateADsNtFrsSubscriptions
//
//  Purpose:    Create an NT-FRS-Subscriptions object and then grant its parent
//              (a computer object) full access.
//
//-----------------------------------------------------------------------------
HRESULT
CreateADsNtFrsSubscriptions(CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
{
    LPCWSTR pcsz = reinterpret_cast<LPCWSTR>(pNewADsObjectCreateInfo->QueryCreationParameter());
    ASSERT( NULL != pcsz );
    pNewADsObjectCreateInfo->HrCreateNew(pcsz);
    //
    // Create and persist the object. This must be done before attempting to modify
    // the Security Descriptor.
    //
    HRESULT hr = pNewADsObjectCreateInfo->HrSetInfo();
    if (FAILED(hr))
    {
        TRACE(_T("pNewADsObjectCreateInfo->HrSetInfo failed!\n"));
        return hr;
    }
    //
    // Create a new ACE on this object granting the parent full control. First, get the
    // parent's SID.
    //
    CComVariant varSID;
    CComPtr <IADs> pADS;
    hr = pNewADsObjectCreateInfo->m_pIADsContainer->QueryInterface(IID_IADs, (PVOID*)&pADS);
    if (FAILED(hr))
    {
        TRACE(_T("QueryInterface(IID_IADs) failed!\n"));
        return hr;
    }
    hr = pADS->Get(L"objectSid", &varSID);
    if (FAILED(hr))
    {
        TRACE(_T("Get(\"objectSid\") failed!\n"));
        return hr;
    }
    ASSERT((varSID.vt & ~VT_ARRAY) == VT_UI1);  // this better be an array of BYTEs.
    ASSERT(varSID.parray->cbElements && varSID.parray->pvData);
    //
    // Get this object's Security Descriptor.
    //
    CComPtr <IDirectoryObject> pDirObj;
    hr = pNewADsObjectCreateInfo->PGetIADsPtr()->QueryInterface(IID_IDirectoryObject, (PVOID*)&pDirObj);
    if (FAILED(hr))
    {
        TRACE(_T("QueryInterface(IID_IDirectoryObject) failed!\n"));
        return hr;
    }
    const PWSTR wzSecDescriptor = L"nTSecurityDescriptor";
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0;
    LPWSTR rgpwzAttrNames[] = {wzSecDescriptor};

    hr = pDirObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);

    if (FAILED(hr))
    {
        TRACE(_T("GetObjectAttributes(wzSecDescriptor) failed!\n"));
        return hr;
    }
    ASSERT(cAttrs == 1); // SD is a required attribute. Blow chunks if missing.
    ASSERT(pAttrs != NULL);
    ASSERT(pAttrs->pADsValues != NULL);

    if (!pAttrs->pADsValues->SecurityDescriptor.lpValue ||
        !pAttrs->pADsValues->SecurityDescriptor.dwLength)
    {
        TRACE(_T("IADS return bogus SD!\n"));
        FreeADsMem(pAttrs);
        return E_UNEXPECTED;
    }
    if (!IsValidSecurityDescriptor(pAttrs->pADsValues->SecurityDescriptor.lpValue))
    {
        TRACE(_T("IsValidSecurityDescriptor failed!\n"));
        FreeADsMem(pAttrs);
        return HRESULT_FROM_WIN32(GetLastError());
    }
    //
    // Can't modify a self-relative SD so convert it to an absolute one.
    //
    PSECURITY_DESCRIPTOR pAbsSD = NULL, pNewSD;
    PACL pDacl = NULL, pSacl = NULL;
    PSID pOwnerSid = NULL, pPriGrpSid = NULL;
    DWORD cbSD = 0, cbDacl = 0, cbSacl = 0, cbOwner = 0, cbPriGrp = 0;

    if (!MakeAbsoluteSD(pAttrs->pADsValues->SecurityDescriptor.lpValue,
                        pAbsSD, &cbSD, pDacl, &cbDacl,
                        pSacl, &cbSacl, pOwnerSid, &cbOwner,
                        pPriGrpSid, &cbPriGrp))
    {
        DWORD dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER)
        {
            TRACE(_T("MakeAbsoluteSD failed to return buffer sizes!\n"));
            FreeADsMem(pAttrs);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    if (!cbDacl)
    {
        TRACE(_T("SD missing DACL!\n"));
        FreeADsMem(pAttrs);
        return E_UNEXPECTED;
    }

    WORD wSizeNeeded = (WORD)(sizeof(ACCESS_ALLOWED_ACE) +      // the last element of
                       GetLengthSid(varSID.parray->pvData) -    // the ACE struct is the
                       sizeof(DWORD));                          // first DWORD of the SID.

    CSmartBytePtr spAbsSD(cbSD), spSacl(cbSacl);
    CSmartBytePtr spDacl(cbDacl + wSizeNeeded);
    CSmartBytePtr spOwnerSid(cbOwner), spPriGrpSid(cbPriGrp);
    pAbsSD = spAbsSD;
    pDacl = (PACL)(PBYTE)spDacl;
    pSacl = (PACL)(PBYTE)spSacl;
    pOwnerSid = spOwnerSid;
    pPriGrpSid = spPriGrpSid;
    if (!(pAbsSD && pDacl && pSacl && pOwnerSid && pPriGrpSid))
    {
        TRACE(_T("SD allocation failed!\n"));
        FreeADsMem(pAttrs);
        return E_OUTOFMEMORY;
    }

    if (!MakeAbsoluteSD(pAttrs->pADsValues->SecurityDescriptor.lpValue,
                        pAbsSD, &cbSD, pDacl, &cbDacl,
                        pSacl, &cbSacl, pOwnerSid, &cbOwner,
                        pPriGrpSid, &cbPriGrp))
    {
        TRACE(_T("MakeAbsoluteSD failed!\n"));
        FreeADsMem(pAttrs);
        return HRESULT_FROM_WIN32(GetLastError());
    }
    FreeADsMem(pAttrs);
    //
    // Add ACE. First tell the DACL that there is enough room.
    //
    ACL_SIZE_INFORMATION asi;
    if (!GetAclInformation(pDacl, &asi, sizeof(asi), AclSizeInformation))
    {
        TRACE(_T("GetAclInformation failed!\n"));
        return HRESULT_FROM_WIN32(GetLastError());
    }
    if (asi.AclBytesFree < wSizeNeeded)
    {
        pDacl->AclSize += wSizeNeeded;
    }

    if (!AddAccessAllowedAce(pDacl,
                             ACL_REVISION_DS,
                             STANDARD_RIGHTS_ALL   | ACTRL_DS_OPEN         | 
                             ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD |
                             ACTRL_DS_LIST         | ACTRL_DS_SELF         |
                             ACTRL_DS_READ_PROP    | ACTRL_DS_WRITE_PROP   |
                             ACTRL_DS_DELETE_TREE  | ACTRL_DS_LIST_OBJECT,
                             varSID.parray->pvData))
    {
        TRACE(_T("AddAccessAllowedAce failed!\n"));
        return HRESULT_FROM_WIN32(GetLastError());
    }
    //
    // Put the SD back together again (sort of like Humpty Dumpty)...
    //
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwRev;
    if (!GetSecurityDescriptorControl(pAbsSD, &sdc, &dwRev))
    {
        TRACE(_T("GetSecurityDescriptorControl failed!\n"));
        return HRESULT_FROM_WIN32(GetLastError());
    }
    SECURITY_DESCRIPTOR sd;
    if (!InitializeSecurityDescriptor(&sd, dwRev))
    {
        TRACE(_T("InitializeSecurityDescriptor failed!\n"));
        return HRESULT_FROM_WIN32(GetLastError());
    }
    if (!SetSecurityDescriptorOwner(&sd, pOwnerSid, sdc & SE_OWNER_DEFAULTED))
    {
        TRACE(_T("SetSecurityDescriptorOwner failed!\n"));
        return HRESULT_FROM_WIN32(GetLastError());
    }
    if (!SetSecurityDescriptorGroup(&sd, pPriGrpSid, sdc & SE_GROUP_DEFAULTED))
    {
        TRACE(_T("SetSecurityDescriptorOwner failed!\n"));
        return HRESULT_FROM_WIN32(GetLastError());
    }
    if (!SetSecurityDescriptorSacl(&sd, sdc & SE_SACL_PRESENT, pSacl, sdc & SE_SACL_DEFAULTED))
    {
        TRACE(_T("SetSecurityDescriptorOwner failed!\n"));
        return HRESULT_FROM_WIN32(GetLastError());
    }
    if (!SetSecurityDescriptorDacl(&sd, sdc & SE_DACL_PRESENT, pDacl, sdc & SE_DACL_DEFAULTED))
    {
        TRACE(_T("SetSecurityDescriptorOwner failed!\n"));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    DWORD dwSDlen = GetSecurityDescriptorLength(&sd);

    CSmartBytePtr spNewSD(dwSDlen);

    if (!spNewSD)
    {
        TRACE(_T("SD allocation failed!\n"));
        return E_OUTOFMEMORY;
    }
    pNewSD = (PSECURITY_DESCRIPTOR)spNewSD;

    if (!MakeSelfRelativeSD(&sd, pNewSD, &dwSDlen))
    {
        DWORD dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER)
        {
            TRACE(_T("MakeSelfRelativeSD failed, err: %d!\n"), dwErr);
            return HRESULT_FROM_WIN32(GetLastError());
        }
        if (!spNewSD.ReAlloc(dwSDlen))
        {
            TRACE(_T("Unable to re-alloc SD buffer!\n"));
            return E_OUTOFMEMORY;
        }
        if (!MakeSelfRelativeSD(&sd, pNewSD, &dwSDlen))
        {
            TRACE(_T("MakeSelfRelativeSD failed, err: %d!\n"), GetLastError());
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    dwSDlen = GetSecurityDescriptorLength(pNewSD);
    if (dwSDlen < SECURITY_DESCRIPTOR_MIN_LENGTH)
    {
        TRACE(_T("Bad computer security descriptor length!\n"));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!IsValidSecurityDescriptor(pNewSD))
    {
        TRACE(_T("IsValidSecurityDescriptor failed!\n"));
        return HRESULT_FROM_WIN32(GetLastError());
    }
    //
    // Save the modified SD back to this object.
    //
    DWORD cModified;
    ADSVALUE ADsValueSecurityDesc = {ADSTYPE_NT_SECURITY_DESCRIPTOR, NULL};
    ADS_ATTR_INFO AttrInfoSecurityDesc = {wzSecDescriptor, ADS_ATTR_UPDATE,
                                          ADSTYPE_NT_SECURITY_DESCRIPTOR,
                                          &ADsValueSecurityDesc, 1};
    ADsValueSecurityDesc.SecurityDescriptor.dwLength = dwSDlen;
    ADsValueSecurityDesc.SecurityDescriptor.lpValue = (PBYTE)pNewSD;

    ADS_ATTR_INFO rgAttrs[1];
    rgAttrs[0] = AttrInfoSecurityDesc;

    hr = pDirObj->SetObjectAttributes(rgAttrs, 1, &cModified);

    if (FAILED(hr))
    {
        TRACE(_T("SetObjectAttributes on SecurityDescriptor failed!\n"));
        return hr;
    }

    return S_OK;
}
#endif // FRS_CREATE


HRESULT
HrCreateADsSubnet(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
	{
	ASSERT(pNewADsObjectCreateInfo != NULL);
	ASSERT(0 == lstrcmp(L"subnet", pNewADsObjectCreateInfo->m_pszObjectClass));
	CreateNewSubnetWizard wiz(pNewADsObjectCreateInfo);
  return wiz.DoModal();
	}

// Note that this assumes that the site is the "grandparent" of the server.
// If it isn't, the wrong name will appear in the site field.
HRESULT ExtractServerAndSiteName(
	IN LPWSTR pwszServerDN,
	OUT BSTR* pbstrServerName,
	OUT BSTR* pbstrSiteName )
{
  CPathCracker pathCracker;
	*pbstrServerName = NULL;
	*pbstrSiteName = NULL;
	if ( NULL == pwszServerDN || L'\0' == *pwszServerDN )
		return S_OK;
	HRESULT hr = pathCracker.Set( pwszServerDN, ADS_SETTYPE_DN );
	RETURN_IF_FAIL;
	hr = pathCracker.SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
	RETURN_IF_FAIL;
	hr = pathCracker.GetElement( 0, pbstrServerName );
	RETURN_IF_FAIL;
	hr = pathCracker.GetElement( 2, pbstrSiteName );
	RETURN_IF_FAIL;
	hr = pathCracker.SetDisplayType( ADS_DISPLAY_FULL );
	RETURN_IF_FAIL;
	return S_OK;
}

HRESULT
HrCreateADsServer(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
	{
	HRESULT hr = S_OK;
#ifdef SERVER_COMPUTER_REFERENCE
	CComBSTR sbstrComputerPath;
	CComBSTR sbstrX500DN;
	CComBSTR sbstrComputerRDN;
	CComBSTR sbstrTemp;
	CComVariant svarServerReference;
	CComPtr<IADs> spIADsComputer;
	bool fSkipComputerModify = false;

	do
	{
        hr = DSPROP_PickComputer( pNewADsObjectCreateInfo->GetParentHwnd(), &sbstrComputerPath );
		BREAK_ON_FAIL;

		// Allow user to quit if user hit Cancel
		if (hr == S_FALSE)
		{
			DWORD dwRetval = ReportMessageEx(
				pNewADsObjectCreateInfo->GetParentHwnd(),
				IDS_SKIP_SERVER_REFERENCE,
				MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING );
			if (IDYES != dwRetval)
			{
				hr = S_FALSE;
				break;
			}
			fSkipComputerModify=true;
		}
		else
		{ // prepare to modify computer object

            /*
			// Since the dialog was in single-select mode and the user was able
			// to hit OK, there should be exactly one selection.
			BREAK_ON_TRUE(1 != pSelection->cItems);
            */

			// retrieve the ADsPath to the selected computer
			// hr = pathCracker.Set(pSelection->aDsSelection[0].pwzADsPath, ADS_SETTYPE_FULL);
			hr = pathCracker.Set(sbstrComputerPath, ADS_SETTYPE_FULL);
            sbstrComputerPath.Empty();
			BREAK_ON_FAIL;

			// if this is a GC: path, the server might have a read-only copy of
			// this object.  Change the path to an LDAP: path and remove the server.
			hr = pathCracker.Retrieve(ADS_FORMAT_PROVIDER,&sbstrTemp);
			BREAK_ON_FAIL;
			long lnFormatType = ADS_FORMAT_WINDOWS;
			if ( lstrcmp(sbstrTemp, TEXT("LDAP")) )
			{
				ASSERT( !lstrcmp(sbstrTemp, TEXT("GC")) );
#error CODEWORK this usage of ADS_SETTYPE_PROVIDER will no longer work!  JonN 2/12/99
				hr = pathCracker.Set(TEXT("LDAP"),ADS_SETTYPE_PROVIDER);
				BREAK_ON_FAIL;
				lnFormatType = ADS_FORMAT_WINDOWS_NO_SERVER;
			}
			sbstrTemp.Empty();

			hr = pathCracker.Retrieve(lnFormatType,&sbstrComputerPath);
			BREAK_ON_FAIL;
			// We preserve the servername in case Computer Picker returns one.

			// Extract the name of the computer object and make that the default name
			// of the new server object
			hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
			BREAK_ON_FAIL;
			hr = pathCracker.GetElement(0,&sbstrComputerRDN);
			BREAK_ON_FAIL;
			BREAK_ON_TRUE( !sbstrComputerRDN || TEXT('\0') == *sbstrComputerRDN );
			pNewADsObjectCreateInfo->m_strDefaultObjectName = sbstrComputerRDN;
			hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
			BREAK_ON_FAIL;

			// Now check whether the computer already references a server.
			// Note that we may be using a serverless path, ADSI will try to find a
			// replica on the same domain as the computer object.
			hr = DSAdminOpenObject(sbstrComputerPath,
				                     IID_IADs, 
                             (PVOID*)&spIADsComputer,
                             FALSE /*bServer*/
                             );
			// DSAdminOpenObject might fail if the initial path chosen by Computer Picker
			// is a GC: path.  The code above would munge the GC: path to an LDAP:
			// serverless path, and ADSI might choose a replica which hasn't
			// replicated this object yet.

			if ( SUCCEEDED(hr) )
			{
				hr = spIADsComputer->Get( L"serverReference", &svarServerReference );
			}

			if ( E_ADS_PROPERTY_NOT_FOUND == hr )
			{
				hr = S_OK;
			}
			else if ( FAILED(hr) )
			{
				PVOID apv[1] = { (BSTR)sbstrComputerRDN };
				DWORD dwRetval = ReportErrorEx(
					pNewADsObjectCreateInfo->GetParentHwnd(),
					IDS_12_SERVER_REFERENCE_FAILED,
					hr,
					MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING,
					apv,
					1 );

				if (IDYES != dwRetval)
				{
					hr = S_FALSE;
					break;
				}
				fSkipComputerModify=TRUE;
				hr = S_OK;
			}
			else
			{
				if ( VT_BSTR == V_VT(&svarServerReference) && NULL != V_BSTR(&svarServerReference) )
				{
					CComBSTR sbstrServerName;
					CComBSTR sbstrSiteName;
					hr = ExtractServerAndSiteName(
						V_BSTR(&svarServerReference), &sbstrServerName, &sbstrSiteName );
					BREAK_ON_FAIL;
					PVOID apv[3];
					apv[0] = (BSTR)sbstrComputerRDN;
					apv[1] = (BSTR)sbstrServerName;
					apv[2] = (BSTR)sbstrSiteName;
					DWORD dwRetval = ReportMessageEx(
						pNewADsObjectCreateInfo->GetParentHwnd(),
						IDS_123_COMPUTER_OBJECT_ALREADY_USED,
						MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING,
						apv,
						3 );

					if (IDYES != dwRetval)
					{
						hr = S_FALSE;
						break;
					}
				}
			}
		} // prepare to modify computer object
#endif // SERVER_COMPUTER_REFERENCE

		// This is the standard UI to create a simple object
		hr = HrCreateADsSimpleObject(pNewADsObjectCreateInfo);

#ifdef SERVER_COMPUTER_REFERENCE
		if ( FAILED(hr) || S_FALSE == hr )
		{
			break;
		}

		// If an error occurs after the server was successfully created, we use a
		// special error message.
		do { // false loop

			if (fSkipComputerModify)
				break; // CODEWORK also display a fancy message?

			// Get the path to the new Server object in X500 format
			hr = pNewADsObjectCreateInfo->PGetIADsPtr()->get_ADsPath(&sbstrTemp);
			BREAK_ON_FAIL;
			hr = pathCracker.Set(sbstrTemp,ADS_SETTYPE_FULL);
			BREAK_ON_FAIL;
			hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
			BREAK_ON_FAIL;
			hr = pathCracker.Retrieve(ADS_FORMAT_X500_DN,&sbstrX500DN);
			BREAK_ON_FAIL;

			// Set the computer object's serverReference attribute
			// to point to the new Server object
			svarServerReference = sbstrX500DN;
			hr = spIADsComputer->Put( L"serverReference", svarServerReference );
			BREAK_ON_FAIL;
			hr = spIADsComputer->SetInfo();
			BREAK_ON_FAIL;
		} while (false); // false loop

		if ( FAILED(hr) )
		{
			// The server was created but the computer could not be updated
			CComBSTR sbstrServerName;
			CComBSTR sbstrSiteName;
			(void) ExtractServerAndSiteName(
				V_BSTR(&svarServerReference), &sbstrServerName, &sbstrSiteName );
			PVOID apv[3];
			apv[0] = (BSTR)sbstrComputerRDN;
			apv[1] = (BSTR)sbstrServerName;
			apv[2] = (BSTR)sbstrSiteName;
			(void) ReportErrorEx(
				pNewADsObjectCreateInfo->GetParentHwnd(),
				IDS_1234_SERVER_REFERENCE_ERROR,
				hr,
				MB_OK | MB_ICONEXCLAMATION,
				apv,
				3 );
			hr = S_OK;
		}

	} while (false); // false loop
#endif // SERVER_COMPUTER_REFERENCE

	// cleanup

	return hr;
	}

HRESULT
HrCreateADsSite(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
{
	HRESULT hr = CreateNewSiteWizard(pNewADsObjectCreateInfo).DoModal();

	if ( !SUCCEEDED(hr) || S_FALSE == hr )
		return hr;

	// need to create sub objects
	IADs* pIADs = pNewADsObjectCreateInfo->PGetIADsPtr();
	ASSERT(pIADs != NULL);

	IADsContainer* pIADsContainer = NULL;
	hr = pIADs->QueryInterface(IID_IADsContainer, (void**)&pIADsContainer);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return S_OK; // should never happen
	}

	LPCWSTR lpszAttrString = L"cn=";
	hr = HrCreateFixedNameHelper(gsz_nTDSSiteSettings, lpszAttrString, pIADsContainer);
	ASSERT(SUCCEEDED(hr));
	hr = HrCreateFixedNameHelper(gsz_serversContainer, lpszAttrString, pIADsContainer);
	ASSERT(SUCCEEDED(hr));
	hr = HrCreateFixedNameHelper(gsz_licensingSiteSettings, lpszAttrString, pIADsContainer);
	ASSERT(SUCCEEDED(hr));
	pIADsContainer->Release();

	LPCWSTR pcszSiteName = pNewADsObjectCreateInfo->GetName();

	static bool g_DisplayedWarning = false;
	if (!g_DisplayedWarning)
	{
		g_DisplayedWarning = true;
		(void) ReportMessageEx(
			pNewADsObjectCreateInfo->GetParentHwnd(),
			IDS_NEW_SITE_INFO,
			MB_OK | MB_ICONINFORMATION | MB_HELP,
			(PVOID*)(&pcszSiteName),
			1,
			0,
			L"sag_ADsite_checklist_2.htm"
			);
	}
  
	return S_OK;
}

HRESULT
HrCreateADsOrganizationalUnit(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
	{
	ASSERT(pNewADsObjectCreateInfo != NULL);
	ASSERT(0 == lstrcmp(L"organizationalUnit", pNewADsObjectCreateInfo->m_pszObjectClass));
	CCreateNewOUWizard wiz(pNewADsObjectCreateInfo);
  return wiz.DoModal();
	}

HRESULT
HrCreateADsGroup(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
	{
	ASSERT(pNewADsObjectCreateInfo != NULL);
	ASSERT(0 == lstrcmp(L"group", pNewADsObjectCreateInfo->m_pszObjectClass));
  CCreateNewGroupWizard wiz(pNewADsObjectCreateInfo);
  return wiz.DoModal();
	}

HRESULT
HrCreateADsContact(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
	{
	ASSERT(pNewADsObjectCreateInfo != NULL);
	ASSERT(0 == lstrcmp(L"contact", pNewADsObjectCreateInfo->m_pszObjectClass));
  CCreateNewContactWizard wiz(pNewADsObjectCreateInfo);
  return wiz.DoModal();
	}



/////////////////////////////////////////////////////////////////////
//	HrCreateADsSimpleObject()
//
//	Create a simple object which "cn" is the
//	only mandatory attribute.
//
//	IMPLEMENTATION NOTES
//	Invoke a dialog asking for the cannonical name.
//
HRESULT HrCreateADsSimpleObject(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
{
	ASSERT(pNewADsObjectCreateInfo != NULL);
	CCreateNewObjectCnWizard wiz(pNewADsObjectCreateInfo);
  return wiz.DoModal();
} // HrCreateADsSimpleObject()


/////////////////////////////////////////////////////////////////////
//	HrCreateADsObjectGenericWizard()
//
//	Create an object invoking a "Generic Create" wizard.
//	The wizard will have as many pages as the number of mandatory attributes.
//
//	INTERFACE NOTES
//	This routine must have the same interface as PFn_HrCreateADsObject().
//
//	IMPLEMENTATION NOTES
//	The wizard will look into the Directory Schema and determine what are
//	the mandatory attributes.
//
//	REMARKS
//	Although the wizard is the most versatile tool to create a new
//	object, it is the least user-friendly way of doing so.  The wizard
//	has no understanding how the attributes relates.  Therefore it
//	is suggested to provide your own HrCreateADs*() routine to provide
//	a friendlier dialog to the user.
//
HRESULT
HrCreateADsObjectGenericWizard(INOUT CNewADsObjectCreateInfo * pNewADsObjectCreateInfo)
{
	ASSERT(pNewADsObjectCreateInfo != NULL);

  // cannot have a Generic Wizard when running as standalone object
  ASSERT(!pNewADsObjectCreateInfo->IsStandaloneUI());
  if (pNewADsObjectCreateInfo->IsStandaloneUI())
	return E_INVALIDARG;

	CCreateNewObjectGenericWizard dlg;
	if (dlg.FDoModal(INOUT pNewADsObjectCreateInfo))
		return S_OK;
	return S_FALSE;
} // HrCreateADsObjectGenericWizard()

/////////////////////////////////////////////////////////////////////
//	HrCreateADsObjectOverride()
// 
// handler for object creation using a replacement dialog

HRESULT
HrCreateADsObjectOverride(INOUT CNewADsObjectCreateInfo* pNewADsObjectCreateInfo)
{
  BOOL bHandled = FALSE;
  HRESULT hr = E_INVALIDARG;

  
  if (!pNewADsObjectCreateInfo->IsStandaloneUI())
  {
    // try to create the dialog creation handler (full UI replacement)
    // this functionality is not exposed by the standalone UI
    IDsAdminCreateObj* pCreateObj = NULL;
    hr = ::CoCreateInstance(pNewADsObjectCreateInfo->GetCreateInfo()->clsidWizardPrimaryPage, 
                          NULL, CLSCTX_INPROC_SERVER, 
                          IID_IDsAdminCreateObj, (void**)&pCreateObj);
    if (SUCCEEDED(hr))
    {
      // try to initialize handler
      hr = pCreateObj->Initialize(pNewADsObjectCreateInfo->m_pIADsContainer,
                                  pNewADsObjectCreateInfo->GetCopyFromObject(),
                                  pNewADsObjectCreateInfo->m_pszObjectClass);
      if (SUCCEEDED(hr))
      {
        // execute call for creation
        IADs* pADsObj = NULL;
        bHandled = TRUE;
        hr = pCreateObj->CreateModal(pNewADsObjectCreateInfo->GetParentHwnd(), &pADsObj);
        // can have S_OK, S_FALSE, and error
        if ((hr == S_OK) && pADsObj != NULL)
        {
          // hold to the returned, newly created object
          pNewADsObjectCreateInfo->SetIADsPtr(pADsObj); // it will addref
          pADsObj->Release();
        }
      }
      pCreateObj->Release();
    }
  } // not standalone UI

  // check if the dialog creation handler was properly called
  if (bHandled)
    return hr;


  // try to create a primary extension handler (partial UI replacement)
  CCreateNewObjectWizardBase wiz(pNewADsObjectCreateInfo);

  hr = wiz.InitPrimaryExtension();
  if (SUCCEEDED(hr))
  {
    bHandled = TRUE;
    hr = wiz.DoModal();
  }

  // check if the dialog creation handler was properly called
  if (bHandled)
    return hr;

  // The handler failed, need to recover, trying our internal creation UI
	PFn_HrCreateADsObject pfnCreateObject = NULL;
  PVOID pVoid = NULL;

  // we try to find a better handler than the generic wizard
  // by looking in our table
  if (!FindHandlerFunction(pNewADsObjectCreateInfo->m_pszObjectClass, 
                           &pfnCreateObject, &pVoid))
  {
    // failed any match
    if (pNewADsObjectCreateInfo->IsStandaloneUI())
    {
      // cannot have generic wizard on standalone UI
      return E_INVALIDARG;
    }
    else
    {
   	  // set the default to point to the "Generic Create" wizard

      ReportErrorEx(pNewADsObjectCreateInfo->GetParentHwnd(),
                    IDS_NO_CREATION_WIZARD,
                    S_OK,
                    MB_OK | MB_ICONWARNING,
                    NULL,
                    0);

  	  pfnCreateObject = HrCreateADsObjectGenericWizard;
    }
  }

  pNewADsObjectCreateInfo->SetCreationParameter(pVoid);
  ASSERT(pfnCreateObject != NULL);
  // call the function handler as last resort
  return pfnCreateObject(pNewADsObjectCreateInfo);

} // HrCreateADsObjectOverride()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\help.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       help.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "helpids.h"

const DWORD g_aHelpIDs_IDD_CHANGE_PASSWORD[]=
{
	IDC_NEW_PASSWORD, IDH_CONFIRM_PASSWORD,
	IDC_CONFIRM_PASSWORD,IDH_CONFIRM_PASSWORD,
	IDC_CHECK_PASSWORD_MUST_CHANGE,IDH_CHECK_PASSWORD_MUST_CHANGE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RID_FSMO_PAGE[]=
{
	IDC_EDIT_CURRENT_DC,IDH_EDIT_CURRENT_DC_RID,
	IDC_EDIT_CURRENT_FSMO_DC,IDH_EDIT_CURRENT_FSMO_DC_RID,
	IDC_CHANGE_FSMO,IDH_CHANGE_FSMO_RID,
  IDC_STATIC_FSMO_STATUS, IDH_NO_HELP,
  static_cast<ULONG>(IDC_STATIC), IDH_NO_HELP,
	IDC_STATIC_FSMO_DESC, IDH_NO_HELP,
	0,0
};

const DWORD g_aHelpIDs_IDD_PDC_FSMO_PAGE[]=
{
	IDC_CHANGE_FSMO,IDH_CHANGE_FSMO_PDC,
	IDC_EDIT_CURRENT_FSMO_DC,IDH_EDIT_CURRENT_FSMO_DC_PDC,
	IDC_EDIT_CURRENT_DC,IDH_EDIT_CURRENT_DC_PDC,
  IDC_STATIC_FSMO_STATUS, IDH_NO_HELP,
  static_cast<ULONG>(IDC_STATIC), IDH_NO_HELP,
	IDC_STATIC_FSMO_DESC, IDH_NO_HELP,
	0,0
};

const DWORD g_aHelpIDs_IDD_INFRA_FSMO_PAGE[]=
{
	IDC_EDIT_CURRENT_DC,IDH_EDIT_CURRENT_DC_INFRA,
	IDC_EDIT_CURRENT_FSMO_DC,IDH_EDIT_CURRENT_FSMO_DC_INFRA,
	IDC_CHANGE_FSMO,IDH_CHANGE_FSMO_INFRA,
  IDC_STATIC_FSMO_STATUS, IDH_NO_HELP,
  static_cast<ULONG>(IDC_STATIC), IDH_NO_HELP,
	IDC_STATIC_FSMO_DESC, IDH_NO_HELP,
  0,0
};

const DWORD g_aHelpIDs_IDD_PASSWORD[]=
{
	IDC_USER_NAME,IDH_USER_NAME,
	IDC_PASSWORD, IDH_CONFIRM_PASSWORD,
	0,0
};

const DWORD g_aHelpIDs_IDD_QUERY_FILTER[]=
{
	IDC_BUILTIN_QUERY_CHECK_LIST,IDH_BUILTIN_QUERY_CHECK_LIST,
	IDC_SHOW_BUILTIN_RADIO,IDH_SHOW_BUILTIN_RADIO,
	IDC_SHOW_CUSTOM_RADIO,IDH_SHOW_CUSTOM_RADIO,
	IDC_EDIT_CUSTOM_BUTTON,IDH_EDIT_CUSTOM_BUTTON,
	IDC_MAX_ITEM_COUNT_EDIT,IDH_MAX_ITEM_COUNT_EDIT,
	IDC_SHOW_ALL_RADIO,IDH_SHOW_ALL_RADIO,
	0,0
};

const DWORD g_aHelpIDs_IDD_RENAME_CONTACT[]=
{
	IDC_EDIT_OBJECT_NAME,IDH_EDIT_OBJECT_NAME2,
	IDC_FIRST_NAME_EDIT,IDH_FIRST_NAME_EDIT1,
	IDC_LAST_NAME_EDIT,IDH_LAST_NAME_EDIT1,
	IDC_DISP_NAME_EDIT,IDH_DISP_NAME_EDIT,
	0,0
};

const DWORD g_aHelpIDs_IDD_RENAME_GROUP[]=
{
	IDC_EDIT_OBJECT_NAME,IDH_EDIT_OBJECT_NAME3,
	IDC_NT4_USER_EDIT,IDH_NT4_USER_EDIT1,
	0,0
};

const DWORD g_aHelpIDs_IDD_RENAME_USER[]=
{
	IDC_NT5_DOMAIN_COMBO,IDH_NT5_DOMAIN_COMBO,
	IDC_LAST_NAME_EDIT,IDH_LAST_NAME_EDIT2,
	IDC_NT5_USER_EDIT,IDH_NT5_USER_EDIT,
	IDC_EDIT_OBJECT_NAME,IDH_EDIT_OBJECT_NAME4,
	IDC_NT4_DOMAIN_EDIT,IDH_NT4_DOMAIN_EDIT,
	IDC_NT4_USER_EDIT,IDH_NT4_USER_EDIT3,
	IDC_FIRST_NAME_EDIT,IDH_FIRST_NAME_EDIT2,
	IDC_EDIT_DISPLAY_NAME,IDH_EDIT_DISPLAY_NAME,
	0,0
};

const DWORD g_aHelpIDs_IDD_RENAME_COMPUTER[]= 
{
        0,0
};

const DWORD g_aHelpIDs_IDD_SELECT_DC[]=
{
	IDC_SELECTDC_DCLISTVIEW,IDH_SELECTDC_DCLISTVIEW,
	IDC_SELECTDC_DCEDIT,IDH_SELECTDC_DCEDIT,
	IDC_SELECTDC_DOMAIN,IDH_SELECTDC_DOMAIN,
	IDC_SELECTDC_BROWSE,IDH_SELECTDC_BROWSE,
  IDC_SELECTDC_DCEDIT_TITLE, IDH_NO_HELP,
	IDC_SELECTDC_DCLISTVIEW_TITLE, IDH_NO_HELP,
  static_cast<ULONG>(IDC_STATIC),IDH_NO_HELP,
  0,0
};

const DWORD g_aHelpIDs_IDD_SELECT_DOMAIN[]=
{
	IDC_SELECTDOMAIN_DOMAIN,IDH_SELECTDOMAIN_DOMAIN,
	IDC_SELECTDOMAIN_BROWSE,IDH_SELECTDOMAIN_BROWSE,
	IDC_SELECTDOMAIN_LABEL,IDH_SELECTDOMAIN_DOMAIN,
	IDC_SELECTDOMAIN_LABEL,IDH_NO_HELP,
  IDC_SAVE_CURRENT_CHECK,IDH_SAVE_CURRENT_CHECK,
  0,0
};

const DWORD g_aHelpIDs_IDD_BROWSE_CONTAINER[]=
{
  DSBID_CONTAINERLIST, IDH_BROWSE_FOR_OBJECT,
	0,0
};

const DWORD g_aHelpIDs_IDD_CREATE_NEW_QUERY[]=
{
  IDC_NAME_EDIT,              IDH_NAME_EDIT,
  IDC_DESCRIPTION_EDIT,       IDH_DESCRIPTION_EDIT,
  IDC_ROOT_EDIT,              IDH_ROOT_EDIT,
  IDC_BROWSE_BUTTON,          IDH_BROWSE_BUTTON,
  IDC_MULTI_LEVEL_CHECK,      IDH_MULTI_LEVEL_CHECK,
  IDC_QUERY_STRING_EDIT,      IDH_QUERY_STRING_EDIT,
  IDC_EDIT_BUTTON,            IDH_EDIT_BUTTON,
  IDOK,                       IDH_OK_BUTTON,
  IDCANCEL,                   IDH_CANCEL_BUTTON,
  0,0
};

const DWORD g_aHelpIDs_IDD_QUERY_STD_PAGE[]=
{
  IDC_NAME_COMBO,             IDH_NAME_COMBO,
  IDC_NAME_EDIT,              IDH_NAME_EDIT_QUERY_FORM,
  IDC_DESCRIPTION_COMBO,      IDH_DESCRIPTION_COMBO,
  IDC_DESCRIPTION_EDIT,       IDH_DESCRIPTION_EDIT_QUERY_FORM,
  0,0
};

const DWORD g_aHelpIDs_IDD_QUERY_USER_PAGE[]=
{
  IDC_NAME_COMBO,             IDH_NAME_COMBO,
  IDC_NAME_EDIT,              IDH_NAME_EDIT_QUERY_FORM,
  IDC_DESCRIPTION_COMBO,      IDH_DESCRIPTION_COMBO,
  IDC_DESCRIPTION_EDIT,       IDH_DESCRIPTION_EDIT_QUERY_FORM,
  IDC_DISABLED_ACCOUNTS_CHECK,IDH_DISABLED_ACCOUNTS_CHECK,
  IDC_NON_EXPIRING_PWD_CHECK, IDH_NON_EXPIRING_PWD_CHECK,
  IDC_LASTLOGON_COMBO,        IDH_LASTLOGON_COMBO,
  0,0
};

const DWORD g_aHelpIDs_IDD_FAVORITES_PROPERTY_PAGE[]=
{
  IDC_CN,                     IDH_CN,
  IDC_DESCRIPTION_EDIT,       IDH_DESCRIPTION_EDIT_FAVORITES,
  0,0
};

//Sites and Services
#ifdef FIXUPDC
const DWORD g_aHelpIDs_IDD_FIXUP_DC[]=
{
	IDC_FIXUP_DC_CHECK5,IDH_FIXUP_DC_CHECK5,
	IDC_FIXUP_DC_CHECK4,IDH_FIXUP_DC_CHECK4,
	IDC_FIXUP_DC_CHECK3,IDH_FIXUP_DC_CHECK3,
	IDC_FIXUP_DC_CHECK2,IDH_FIXUP_DC_CHECK2,
	IDC_FIXUP_DC_CHECK1,IDH_FIXUP_DC_CHECK1,
	IDC_FIXUP_DC_CHECK0,IDH_FIXUP_DC_CHECK0,
	0,0
};
#endif // FIXUPDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\newsite.cpp ===
// Copyright (C) Microsoft Corporation, 1998 - 1999
// 
// create new site and new subnet wizards
// 
// 4-24-98 sburns
// 9-23-98 jonn    Subclassed off New Subnet Wizard



#include "stdafx.h"
#include "resource.h"

#include "dsutil.h"

#include "newobj.h"

#include "dlgcreat.h"
#include "querysup.h"

#pragma warning (disable: 4100)

#include <utility>   // pair<>
#include <list>

#pragma warning (default: 4100)

extern "C"
{
#include <dsgetdc.h> // DsValidateSubnetName
}



#define BREAK_ON_FAILED_HRESULT(hr)                               \
   if (FAILED(hr))                                                \
   {                                                              \
      ASSERT(FALSE);                                              \
      break;                                                      \
   }

#define BREAK_ON_NULL(p)                                          \
   if (NULL == p)                                                 \
   {                                                              \
      ASSERT(FALSE);                                              \
      break;                                                      \
   }



// first in the pair is name of link, second is dn of the link
typedef std::pair< CComBSTR, CComBSTR > TargetLinkInfo;
typedef std::list< TargetLinkInfo > TargetLinkList;



CreateNewSiteWizard::CreateNewSiteWizard(
   CNewADsObjectCreateInfo* pNewADsObjectCreateInfo)
   :
   CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
{
   AddPage(&page);
}


CreateNewSubnetWizard::CreateNewSubnetWizard(
   CNewADsObjectCreateInfo* pNewADsObjectCreateInfo)
   :
   CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
{
   AddPage(&page);
}



BEGIN_MESSAGE_MAP(CreateAndChoosePage, CCreateNewNamedObjectPage)
   ON_WM_DESTROY()
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CreateNewSubnetPage, CreateAndChoosePage)
    ON_EN_CHANGE(IDC_SUBNET_ADDRESS, OnSubnetMaskChange)
    ON_EN_CHANGE(IDC_SUBNET_MASK, OnSubnetMaskChange)
END_MESSAGE_MAP()


CreateAndChoosePage::CreateAndChoosePage(UINT nIDTemplate)
   :
   CCreateNewNamedObjectPage(nIDTemplate),
   listview(0),
   listview_imagelist(0)
{
}


CreateNewSitePage::CreateNewSitePage()
   :
   CreateAndChoosePage(IDD_CREATE_NEW_SITE)
{
}


CreateNewSubnetPage::CreateNewSubnetPage()
   :
   CreateAndChoosePage(IDD_CREATE_NEW_SUBNET)
{
}


HRESULT
CreateNewSitePage::SetData(BOOL bSilent)
{
   if (0 < ListView_GetItemCount(listview))
   {
      if (0 >= ListView_GetSelectedCount(listview))
      {
        if (!bSilent)
        {
          ReportErrorEx (::GetParent(m_hWnd),IDS_NEW_SITE_SELECT_SITELINK,S_OK,
                         MB_OK, NULL, 0);
        }
        (void) this->PostMessage( WM_NEXTDLGCTL,
                                  (WPARAM)listview,
                                  TRUE );
        return E_FAIL;
      }
   }
   return CreateAndChoosePage::SetData(bSilent);
}



HRESULT
CreateNewSubnetPage::SetData(BOOL bSilent)
{
   CNewADsObjectCreateInfo* info = GetWiz()->GetInfo();
   ASSERT(info);
   HRESULT hr = E_FAIL;
   if (!info)
     return hr;
   int count = ListView_GetItemCount(listview);
   if (count > 0)
   {
      if (0 >= ListView_GetSelectedCount(listview))
      {
        if (!bSilent)
        {
          ReportErrorEx (::GetParent(m_hWnd),IDS_NEW_SUBNET_SELECT_SITE,S_OK,
                         MB_OK, NULL, 0);
        }
        (void) this->PostMessage( WM_NEXTDLGCTL,
                                  (WPARAM)listview,
                                  TRUE );
        return E_FAIL;
      }
      for (int i = 0; i < count; i++)
      {
         if (ListView_GetItemState(listview, i, LVIS_SELECTED))
         {
            LVITEM item = {0};
            item.mask = LVIF_PARAM;
            item.iItem = i;

            if (ListView_GetItem(listview, &item))
            {
               // the item.lParam field is the dn of the target site
               CComBSTR* dn = reinterpret_cast<CComBSTR*>(item.lParam);
               hr = info->HrAddVariantBstrIfNotEmpty(
                       const_cast<PWSTR>(gsz_siteObject),
                       *dn,
                       TRUE ); // HrCreateNew has not been called yet
               if ( FAILED(hr) )
               {
                 ASSERT(FALSE);
                 return hr;
               }

               // use the first site selected
               break;
            }
         }
      }
      ASSERT( i < count );
   }
   return CreateAndChoosePage::SetData(bSilent);
}



HRESULT
CreateNewSitePage::tweakSiteLink(LPCTSTR siteDN)
{
   ASSERT(siteDN);

   HRESULT hr = S_OK;
   do
   {
      // get the DN of the new site
      // this is a pointer alias: no need to AddRef/Release
      hr = E_FAIL;
      CPathCracker pathCracker;

      CCreateNewObjectWizardBase* pwiz = GetWiz();
      BREAK_ON_NULL(pwiz);
      CNewADsObjectCreateInfo* pinfo = pwiz->GetInfo();
      BREAK_ON_NULL(pinfo);
      IADs* piadsSite = pinfo->PGetIADsPtr();
      BREAK_ON_NULL(piadsSite);
      CComBSTR sbstrSitePath;
      hr = piadsSite->get_ADsPath( &sbstrSitePath );
      BREAK_ON_FAILED_HRESULT(hr);
      hr = pathCracker.Set(sbstrSitePath, ADS_SETTYPE_FULL);
      BREAK_ON_FAILED_HRESULT(hr);
      CComBSTR sbstrSiteDN;
      hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
      BREAK_ON_FAILED_HRESULT(hr);
      hr = pathCracker.Retrieve(ADS_FORMAT_X500_DN, &sbstrSiteDN);
      BREAK_ON_FAILED_HRESULT(hr);

      // munge together the path name of the site link object
      hr = pathCracker.Set( const_cast<LPTSTR>(siteDN), ADS_SETTYPE_DN);
      BREAK_ON_FAILED_HRESULT(hr);
      CComBSTR sbstrSiteLinkPath;
      hr = pathCracker.Retrieve(ADS_FORMAT_X500, &sbstrSiteLinkPath);
      BREAK_ON_FAILED_HRESULT(hr);

      // bind to the site link
      CComPtr<IADs> link;
      hr = DSAdminOpenObject(sbstrSiteLinkPath,
                             IID_IADs, 
                             (void**) &link,
                             FALSE /*bServer*/);
      BREAK_ON_FAILED_HRESULT(hr);
      ASSERT(link);

      // Add the DN of the new site to the siteList attr of the link object

      // build the new value
      CComVariant var;
      hr = ADsBuildVarArrayStr(&sbstrSiteDN, 1, &var);
      BREAK_ON_FAILED_HRESULT(hr);

      // write it.  whew.
      hr =
         link->PutEx(
            ADS_PROPERTY_APPEND,
            const_cast<LPTSTR>(gsz_siteList),
            var);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = link->SetInfo();
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      ReportError(hr, IDS_ERROR_TWEAKING_SITE_LINK, m_hWnd);
   }

   return hr;
}



HRESULT
CreateNewSitePage::OnPostCommit(BOOL bSilent)
{
   ASSERT(listview);

   int count = ListView_GetItemCount(listview);
   if (count > 0)
   {
      for (int i = 0; i < count; i++)
      {
         if (ListView_GetItemState(listview, i, LVIS_SELECTED))
         {
            LVITEM item = {0};
            item.mask = LVIF_PARAM;
            item.iItem = i;

            if (ListView_GetItem(listview, &item))
            {
               // the item.lParam field is the dn of the target link
               CComBSTR* dn = reinterpret_cast<CComBSTR*>(item.lParam);
               tweakSiteLink(*dn);

               // only tweak the first site link selected
               return S_OK;
            }
         }
      }
   }

   if (!bSilent)
   {
     ReportMessageEx(
        m_hWnd,
        IDS_NEWSITE_WARNING,
        MB_OK | MB_ICONWARNING,
        NULL,
        0,
        IDS_WARNING_TITLE);
   }

   return S_OK;
}
                  


HRESULT
RecursiveFind(const CString& lpcwszADsPathDirectory,
              LPCTSTR lpcwszTargetClass,
              TargetLinkList& links,
              LPWSTR pszAttribute = L"distinguishedName");

HRESULT
RecursiveFind(const CString& lpcwszADsPathDirectory,
              LPCTSTR lpcwszTargetClass,
              TargetLinkList& links,
              LPWSTR pszAttribute)
{
   links.clear();

   CDSSearch Search;
   Search.Init(lpcwszADsPathDirectory);
   CString filter;
   filter.Format(L"(objectClass=%s)", lpcwszTargetClass);
   Search.SetFilterString(const_cast<LPTSTR>((LPCTSTR) filter));
   LPWSTR pAttrs[2] =
   {
      L"name",
      pszAttribute
   };
   Search.SetAttributeList(pAttrs, 2);
   Search.SetSearchScope(ADS_SCOPE_SUBTREE);

   HRESULT hr = Search.DoQuery();
   while (SUCCEEDED(hr))
   {
      hr = Search.GetNextRow();
      if (S_ADS_NOMORE_ROWS == hr)
      {
         hr = S_OK;
         break;
      }
      BREAK_ON_FAILED_HRESULT(hr);

      ADS_SEARCH_COLUMN NameColumn;
      ::ZeroMemory(&NameColumn, sizeof(NameColumn));
      hr = Search.GetColumn (pAttrs[0], &NameColumn);
      BREAK_ON_FAILED_HRESULT(hr);
      ASSERT(ADSTYPE_CASE_IGNORE_STRING == NameColumn.pADsValues->dwType);

      ADS_SEARCH_COLUMN DistinguishedNameColumn;
      ::ZeroMemory(&DistinguishedNameColumn, sizeof(DistinguishedNameColumn));
      hr = Search.GetColumn (pAttrs[1], &DistinguishedNameColumn);
      BREAK_ON_FAILED_HRESULT(hr);
      ASSERT(ADSTYPE_DN_STRING          == DistinguishedNameColumn.pADsValues->dwType
          || ADSTYPE_CASE_IGNORE_STRING == DistinguishedNameColumn.pADsValues->dwType);

      links.push_back(
         TargetLinkInfo(
            NameColumn.pADsValues->CaseIgnoreString,
            DistinguishedNameColumn.pADsValues->DNString));

      Search.FreeColumn(&NameColumn);
      Search.FreeColumn(&DistinguishedNameColumn);
   }

#ifdef DBG
   // dump the list to the debugger
   for (
      TargetLinkList::iterator i = links.begin();
      i != links.end();
      i++)
   {
      OutputDebugString(i->first);
      OutputDebugString(L"\n");
      OutputDebugString(i->second);
      OutputDebugString(L"\n");
   }
#endif

   return hr;
}



BOOL
CreateAndChoosePage::OnSetActive()
{
   CComQIPtr<IADs, &IID_IADs> container(GetWiz()->GetInfo()->m_pIADsContainer);

   if (container)
   {
      CComBSTR container_path;
      container->get_ADsPath(&container_path);
      initListContents(container_path);
   }

   return Base::OnSetActive();
}



void
destroyListContents(HWND listview)
{
   ASSERT(listview);

   for (int i = ListView_GetItemCount(listview) - 1; i >= 0; i--)
   {
      LVITEM item = {0};
      item.mask = LVIF_PARAM;
      item.iItem = i;

      if (ListView_GetItem(listview, &item))
      {
         ASSERT(item.lParam);

         delete reinterpret_cast<CComBSTR*>(item.lParam);
         ListView_DeleteItem(listview, i);
         return;
      }
   }
}



void
CreateAndChoosePage::OnDestroy()
{
   destroyListContents(listview);

   Base::OnDestroy();
}



void
CreateNewSitePage::initListContents(LPCWSTR containerPath)
{
   ASSERT(listview);

   CWaitCursor cwait;

   TargetLinkList links;
   bool links_present = false;
   HRESULT hr = RecursiveFind(containerPath, gsz_siteLink, links);
   if (SUCCEEDED(hr))
   {
      // walk the list and add nodes
      for (
         TargetLinkList::iterator i = links.begin();
         i != links.end();
         i++)
      {
         LVITEM item = {0};
         memset(&item, 0, sizeof(item));

         // this is deleted in destroyListContents
         CComBSTR* dn = new CComBSTR(i->second);   
         item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
         item.iItem = 0;
         item.iSubItem = 0;
         item.pszText = static_cast<LPTSTR>(i->first);
         item.lParam = reinterpret_cast<LPARAM>(dn);
         item.iImage = 0;  // always the same, first image

         item.iItem = ListView_InsertItem(listview, &item);
         ASSERT(item.iItem >= 0);

         // add the transport sub-item to the list control
         CPathCracker pathCracker;
         hr =
            pathCracker.Set(
               static_cast<LPTSTR>(i->second),
               ADS_SETTYPE_DN);
         ASSERT(SUCCEEDED(hr));
         hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
         ASSERT(SUCCEEDED(hr));

         CComBSTR b;
         hr = pathCracker.GetElement(1, &b);
         ASSERT(SUCCEEDED(hr));
         hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
         ASSERT(SUCCEEDED(hr));

         item.mask = LVIF_TEXT; 
         item.iSubItem = 1;
         item.pszText = b;
         ListView_SetItem(listview, &item);

         links_present = true;
      }
      if (!links_present)
      {
         ReportError(hr, IDS_WARNING_NO_SITE_LINKS, m_hWnd);      
      }
   }
   else
   {
      ReportError(hr, IDS_CANT_FIND_SITE_LINKS, m_hWnd);      
   }

   if (!links_present)
   {
      GetDlgItem(IDC_LINKS)->EnableWindow(FALSE);
      GetDlgItem(IDC_SITE_TEXT)->EnableWindow(FALSE);
   }
   else // JonN 3/28/01 319675
   {
      ListView_SetItemState( listview, 0, LVIS_FOCUSED, LVIS_FOCUSED );
   }
}


void
CreateNewSubnetPage::initListContents(LPCWSTR containerPath)
{
   ASSERT(listview);

   CWaitCursor cwait;

   TargetLinkList links;
   bool links_present = false;

   CComBSTR sbstrSites;

   CPathCracker pathCracker;
   HRESULT hr = pathCracker.Set(
            const_cast<LPTSTR>(containerPath),
            ADS_SETTYPE_FULL);
   if (SUCCEEDED(hr))
      hr = pathCracker.RemoveLeafElement();
   if (SUCCEEDED(hr))
      hr = pathCracker.Retrieve(ADS_FORMAT_X500, &sbstrSites);

   if (SUCCEEDED(hr))
      hr = RecursiveFind((LPCTSTR)sbstrSites, gsz_site, links);
   if (SUCCEEDED(hr))
   {
      // walk the list and add nodes
      for (
         TargetLinkList::iterator i = links.begin();
         i != links.end();
         i++)
      {
         LVITEM item;
         memset(&item, 0, sizeof(item));

         // this is deleted in destroyListContents
         CComBSTR* dn = new CComBSTR(i->second);   
         item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
         item.iItem = 0;
         item.iSubItem = 0;
         item.pszText = static_cast<LPTSTR>(i->first);
         item.lParam = reinterpret_cast<LPARAM>(dn);
         item.iImage = 0;  // always the same, first image

         item.iItem = ListView_InsertItem(listview, &item);
         ASSERT(item.iItem >= 0);

         links_present = true;
      }
      if (!links_present)
      {
         ReportError(hr, IDS_NEWSUBNET_WARNING_NO_SITES, m_hWnd);
      }
   }
   else
   {
      ReportError(hr, IDS_NEWSUBNET_CANT_FIND_SITES, m_hWnd);
   }

   if (!links_present)
   {
      GetDlgItem(IDC_LINKS)->EnableWindow(FALSE);
      GetDlgItem(IDC_SITE_TEXT)->EnableWindow(FALSE);
   }
}



BOOL
CreateNewSitePage::OnInitDialog()
{
   Base::OnInitDialog();
   MyBasePathsInfo* pBasePathsInfo = GetWiz()->GetInfo()->GetBasePathsInfo();

   listview = ::GetDlgItem(m_hWnd, IDC_LINKS);
   ASSERT(listview);

   LVCOLUMN column = {0};
   column.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
   column.fmt = LVCFMT_LEFT;

   {  // open scope
      CString w;
      w.LoadString(IDS_NEW_SITE_NAME_COLUMN_WIDTH);
      w.TrimLeft();
      w.TrimRight();
      long width = _tcstol(w, 0, 10);
      ASSERT(width != 0 && width != LONG_MAX && width != LONG_MIN);
      column.cx = width;

      CString label;
      label.LoadString(IDS_NEW_SITE_NAME_COLUMN);
      column.pszText = const_cast<LPTSTR>((LPCTSTR) label);

      ListView_InsertColumn(listview, 0, &column);
   }  // close scope

   // add a column to the list view for parent transport.

   {  // open scope
      CString w;
      w.LoadString(IDS_NEW_SITE_XPORT_COLUMN_WIDTH);
      w.TrimLeft();
      w.TrimRight();
      long width = _tcstol(w, 0, 10);
      ASSERT(width != 0 && width != LONG_MAX && width != LONG_MIN);
      column.cx = width;

      CString label;
      label.LoadString(IDS_NEW_SITE_XPORT_COLUMN);
      column.pszText = const_cast<LPTSTR>((LPCTSTR) label);

      ListView_InsertColumn(listview, 1, &column);
   }  // close scope

   // create the image list containing the site link icon
   int cx = ::GetSystemMetrics(SM_CXSMICON);
   int cy = ::GetSystemMetrics(SM_CYSMICON);
   ASSERT(cx && cy);

   // deleted in OnDestroy
   listview_imagelist = ::ImageList_Create(cx, cy, ILC_MASK, 1, 0);
   ASSERT(listview_imagelist);

   HICON icon = pBasePathsInfo->GetIcon(
                         // someone really blew it with const correctness...
                         const_cast<LPTSTR>(gsz_siteLink),
                         DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON,
                         16,
                         16);
   ASSERT(icon);
      
   int i = ::ImageList_AddIcon(listview_imagelist, icon);
   ASSERT(i != -1);

   DestroyIcon(icon);

   ListView_SetImageList(listview, listview_imagelist, LVSIL_SMALL);

   ListView_SetExtendedListViewStyleEx(
      listview,
      LVS_EX_FULLROWSELECT,
      LVS_EX_FULLROWSELECT);

   return TRUE;
}


BOOL
CreateNewSubnetPage::OnInitDialog()
{
   Base::OnInitDialog();
   MyBasePathsInfo* pBasePathsInfo = GetWiz()->GetInfo()->GetBasePathsInfo();

  (void) SendDlgItemMessage( IDC_SUBNET_ADDRESS,
                             IPM_SETADDRESS,
                             0,
                             (LPARAM)MAKEIPADDRESS(0,0,0,0) );
  (void) SendDlgItemMessage( IDC_SUBNET_MASK,
                             IPM_SETADDRESS,
                             0,
                             (LPARAM)MAKEIPADDRESS(0,0,0,0) );

   listview = ::GetDlgItem(m_hWnd, IDC_LINKS);
   ASSERT(listview);

   {  // open scope
      LVCOLUMN column = {0};
      column.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
      column.fmt = LVCFMT_LEFT;

      CString w;
      w.LoadString(IDS_COLUMN_SITE_WIDTH);
      w.TrimLeft();
      w.TrimRight();
      long width = _tcstol(w, 0, 10);
      ASSERT(width != 0 && width != LONG_MAX && width != LONG_MIN);
      column.cx = width;

      CString label;
      label.LoadString(IDS_COLUMN_SITE_NAME);
      column.pszText = const_cast<LPTSTR>((LPCTSTR) label);

      ListView_InsertColumn(listview, 0, &column);
   }  // close scope

   // create the image list containing the site link icon
   int cx = ::GetSystemMetrics(SM_CXSMICON);
   int cy = ::GetSystemMetrics(SM_CYSMICON);
   ASSERT(cx && cy);

   // deleted in OnDestroy
   listview_imagelist = ::ImageList_Create(cx, cy, ILC_MASK, 1, 0);
   ASSERT(listview_imagelist);

   HICON icon = pBasePathsInfo->GetIcon(
                           // someone really blew it with const correctness...
                           const_cast<LPTSTR>(gsz_site),
                           DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON | DSGIF_DEFAULTISCONTAINER,
                           16,
                           16);
   ASSERT(icon);
      
   int i = ::ImageList_AddIcon(listview_imagelist, icon);
   ASSERT(i != -1);

   DestroyIcon(icon);

   ListView_SetImageList(listview, listview_imagelist, LVSIL_SMALL);

   ListView_SetExtendedListViewStyleEx(
      listview,
      LVS_EX_FULLROWSELECT,
      LVS_EX_FULLROWSELECT);

   return TRUE;
}

BOOL CreateNewSitePage::ValidateName(LPCTSTR pcszName)
{
  BOOL fNonRfcSiteName = FALSE;
  BOOL fValidSiteName = IsValidSiteName( pcszName, &fNonRfcSiteName );
  if ( !fValidSiteName )
  {
    ReportErrorEx (::GetParent(m_hWnd),IDS_SITE_NAME,S_OK,
                   MB_OK, NULL, 0);
  }
  else if ( fNonRfcSiteName )
  {
    PVOID apv[1];
    apv[0] = (PVOID)pcszName;
    if (IDYES != ReportMessageEx( ::GetParent(m_hWnd),
                                  IDS_1_NON_RFC_SITE_NAME,
                                  MB_YESNO | MB_ICONWARNING,
                                  apv,
                                  1 ) )
    {
      fValidSiteName = FALSE;
    }
  }
  if ( !fValidSiteName )
  {
    // Yes, this really does have to be PostMessage, SendMessage doesn't work
    // It also has to come after ReportErrorEx or else it doesn't work
    (void) this->PostMessage( WM_NEXTDLGCTL,
                              (WPARAM)::GetDlgItem(m_hWnd, IDC_EDIT_OBJECT_NAME),
                              TRUE );
    (void) ::PostMessage( ::GetDlgItem(m_hWnd, IDC_EDIT_OBJECT_NAME), EM_SETSEL, 0, -1 );
    return FALSE;
  }
  return TRUE;
}

// JonN 5/11/01 251560 Disable OK until site link chosen
BEGIN_MESSAGE_MAP(CreateNewSitePage, CreateAndChoosePage)
  ON_EN_CHANGE(IDC_EDIT_OBJECT_NAME, OnChange)
  ON_NOTIFY(LVN_ITEMCHANGED, IDC_LINKS, OnSelChange)
END_MESSAGE_MAP()

afx_msg void CreateNewSitePage::OnSelChange( NMHDR*, LRESULT* )
{
   OnChange();
}

void CreateNewSitePage::OnChange()
{
  if (0 >= ListView_GetSelectedCount(listview))
    GetWiz()->SetWizardButtons(this, FALSE);
  else
    OnNameChange(); // Enable the OK button only if the name is not empty
}

// no need to validate subnet name, MapMaskAndAddress does this
// return -32 for invalid mask
int CountBits( DWORD dwOctet )
{
  if ( 0xff < dwOctet )
  {
    ASSERT(FALSE);
    return -32;
  }
  for (int nBits = 0; dwOctet & 0x80; nBits++)
    dwOctet = (dwOctet & ~0x80) * 2;
  if (dwOctet != 0)
    return -32; // hole in the mask
  return nBits;
}

// returns <0 for invalid mask
int CountMaskedBits( DWORD dwMask )
{
  int nFirstOctet  = FIRST_IPADDRESS(dwMask);
  int nSecondOctet = SECOND_IPADDRESS(dwMask);
  int nThirdOctet  = THIRD_IPADDRESS(dwMask);
  int nFourthOctet = FOURTH_IPADDRESS(dwMask);
  if (nFirstOctet < 255)
  {
    if (0 != nSecondOctet || 0 != nThirdOctet || 0 != nFourthOctet)
      return -1;
    return CountBits(nFirstOctet);
  }
  if (nSecondOctet < 255)
  {
    if (255 != nFirstOctet || 0 != nThirdOctet || 0 != nFourthOctet)
      return -1;
    return 8 + CountBits(nSecondOctet);
  }
  if (nThirdOctet < 255)
  {
    if (255 != nFirstOctet || 255 != nSecondOctet || 0 != nFourthOctet)
      return -1;
    return 16 + CountBits(nThirdOctet);
  }
  if (255 != nFirstOctet || 255 != nSecondOctet || 255 != nThirdOctet)
    return -1;
  return 24 + CountBits(nFourthOctet);

}

// returns empty string for invalid address+mask
void MapMaskAndAddress(
    OUT CString& strrefSubnetName,
    IN DWORD dwAddress,
    IN DWORD dwMask )
{
  strrefSubnetName.Empty();

  dwAddress &= dwMask; // clear all bits set in the address and not in the mask

  int nMaskedBits = CountMaskedBits( dwMask );
  if (0 > nMaskedBits)
    return; // invalid mask

  strrefSubnetName.Format(L"%d.%d.%d.%d/%d",
                          FIRST_IPADDRESS(dwAddress),
                          SECOND_IPADDRESS(dwAddress),
                          THIRD_IPADDRESS(dwAddress),
                          FOURTH_IPADDRESS(dwAddress),
                          nMaskedBits);

  // final test for edge cases such as "0.0.0.0/0"
  if (ERROR_SUCCESS != ::DsValidateSubnetName( strrefSubnetName ))
    strrefSubnetName.Empty();
}

void CreateNewSubnetPage::OnSubnetMaskChange()
{
  DWORD dwAddress, dwMask;
  CString strSubnetName;
  // IPM_GETADDRESS returns the number of octets filled in.  Address is
  // invalid if any of the four is left blank.
  if (   4 == SendDlgItemMessage( IDC_SUBNET_ADDRESS,
                                  IPM_GETADDRESS,
                                  0,
                                  (LPARAM)&dwAddress )
      && 4 == SendDlgItemMessage( IDC_SUBNET_MASK,
                                  IPM_GETADDRESS,
                                  0,
                                  (LPARAM)&dwMask ) )
  {
    MapMaskAndAddress( strSubnetName, dwAddress, dwMask );
  }
  SetDlgItemText(IDC_EDIT_OBJECT_NAME, strSubnetName);
  OnNameChange();
}




BEGIN_MESSAGE_MAP(CMoveServerDialog, CDialog)
  //{{AFX_MSG_MAP(CMoveServerDialog)
  ON_WM_DESTROY()
  ON_NOTIFY(NM_DBLCLK, IDC_LINKS, OnDblclkListview)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()


CMoveServerDialog::CMoveServerDialog(LPCTSTR lpcszBrowseRootPath, HICON hIcon, CWnd* pParent /*=NULL*/)
  : CDialog(CMoveServerDialog::IDD, pParent)
  , m_strTargetContainer()
  , m_strBrowseRootPath(lpcszBrowseRootPath)
  , m_hIcon(hIcon)
  , listview(0)
  , listview_imagelist(0)
{}

BOOL
CMoveServerDialog::OnInitDialog()
{
   CDialog::OnInitDialog();

   CWaitCursor cwait;

   listview = ::GetDlgItem(m_hWnd, IDC_LINKS);
   ASSERT(listview);

   {  // open scope
      LVCOLUMN column = {0};
      column.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
      column.fmt = LVCFMT_LEFT;

      CString w;
      w.LoadString(IDS_COLUMN_SITE_WIDTH);
      w.TrimLeft();
      w.TrimRight();
      long width = _tcstol(w, 0, 10);
      ASSERT(width != 0 && width != LONG_MAX && width != LONG_MIN);
      column.cx = width;

      CString label;
      label.LoadString(IDS_COLUMN_SITE_NAME);
      column.pszText = const_cast<LPTSTR>((LPCTSTR) label);

      ListView_InsertColumn(listview, 0, &column);
   }  // close scope

   // create the image list containing the site link icon
   int cx = ::GetSystemMetrics(SM_CXSMICON);
   int cy = ::GetSystemMetrics(SM_CYSMICON);
   ASSERT(cx && cy);

   // deleted in OnDestroy
   listview_imagelist = ::ImageList_Create(cx, cy, ILC_MASK, 1, 0);
   ASSERT(listview_imagelist);
   ASSERT(m_hIcon != NULL);
   int i = ::ImageList_AddIcon(listview_imagelist, m_hIcon);
   ASSERT(i != -1);

   ListView_SetImageList(listview, listview_imagelist, LVSIL_SMALL);

   ListView_SetExtendedListViewStyleEx(
      listview,
      LVS_EX_FULLROWSELECT,
      LVS_EX_FULLROWSELECT);

   // add sites to listview
   TargetLinkList links;
   bool links_present = false;
   HRESULT hr = RecursiveFind(m_strBrowseRootPath, gsz_serversContainer, links, L"aDSPath");
   if (SUCCEEDED(hr))
   {
      // walk the list and add nodes
      for (
         TargetLinkList::iterator itr = links.begin();
         itr != links.end();
         ++itr)
      {
         LVITEM item;
         memset(&item, 0, sizeof(item));

         // Since the enumerated objects are of type serversContainer,
         // we display the name of the parent.  Also, the aDSPath attribute may
         // contain a server indication, which must be removed.

         CPathCracker pathCracker;
         hr = pathCracker.Set( itr->second, ADS_SETTYPE_FULL );
         BREAK_ON_FAILED_HRESULT(hr);
         hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
         BREAK_ON_FAILED_HRESULT(hr);
         CComBSTR sbstrName;
         hr = pathCracker.GetElement( 1L, &sbstrName );
         BREAK_ON_FAILED_HRESULT(hr);
         hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
         BREAK_ON_FAILED_HRESULT(hr);
         CComBSTR sbstrDN;
         hr = pathCracker.Retrieve( ADS_FORMAT_X500, &sbstrDN );
         BREAK_ON_FAILED_HRESULT(hr);

         // this is deleted in destroyListContents
         CComBSTR* dn = new CComBSTR(sbstrDN);   
         item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
         item.iItem = 0;
         item.iSubItem = 0;
         item.pszText = static_cast<LPTSTR>(sbstrName);
         item.lParam = reinterpret_cast<LPARAM>(dn);
         item.iImage = 0;  // always the same, first image

         item.iItem = ListView_InsertItem(listview, &item);
         ASSERT(item.iItem >= 0);

         links_present = true;
      }
      if (!links_present)
      {
         ReportError(hr, IDS_MOVESERVER_ERROR_NO_SITES, m_hWnd);
         OnCancel();
      }
   }

   if ( FAILED(hr) )
   {
      ReportError(hr, IDS_MOVESERVER_ERROR_ENUMERATING_SITES, m_hWnd);
      OnCancel();
   }

   return TRUE;  // return TRUE unless you set the focus to a control
                 // EXCEPTION: OCX Property Pages should return FALSE
}

void
CMoveServerDialog::OnDestroy()
{
   destroyListContents(listview);

   CDialog::OnDestroy();
}

void CMoveServerDialog::OnOK() 
{
   int count = ListView_GetItemCount(listview);
   if (count > 0)
   {
      if (0 >= ListView_GetSelectedCount(listview))
      {
        ReportErrorEx (m_hWnd,IDS_MOVESERVER_SELECT_SITE,S_OK,
                       MB_OK, NULL, 0);
        (void) this->PostMessage( WM_NEXTDLGCTL,
                                  (WPARAM)listview,
                                  TRUE );
        return;
      }
      for (int i = 0; i < count; i++)
      {
         if (ListView_GetItemState(listview, i, LVIS_SELECTED))
         {
            LVITEM item = {0};
            item.mask = LVIF_PARAM;
            item.iItem = i;

            if (ListView_GetItem(listview, &item))
            {
               // the item.lParam field is the dn of the target site
               CComBSTR* dn = reinterpret_cast<CComBSTR*>(item.lParam);
               m_strTargetContainer = *dn;

               // use the first site selected
               break;
            }
         }
      }
      ASSERT( i < count );
   }
   
   CDialog::OnOK();
}

void CMoveServerDialog::OnDblclkListview(NMHDR*, LRESULT*) 
{
   OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\newuser.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       newuser.cpp
//
//--------------------------------------------------------------------------


////////////////////////////////////////////////////////////////////////////////////
// newuser.cpp

#include "stdafx.h"

#include "dsutil.h"

#include "newobj.h"		// CNewADsObjectCreateInfo

#include "dlgcreat.h"
#include "querysup.h"

#include <windowsx.h>
#include <lmaccess.h>


///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
// NEW USER WIZARD

///////////////////////////////////////////////////////////////
// CCreateNewUserPage1

BEGIN_MESSAGE_MAP(CCreateNewUserPage1, CCreateNewObjectDataPage)
  ON_EN_CHANGE(IDC_EDIT_FIRST_NAME, OnNameChange)
  ON_EN_CHANGE(IDC_EDIT_INITIALS, OnNameChange)
  ON_EN_CHANGE(IDC_EDIT_LAST_NAME, OnNameChange)
  ON_EN_CHANGE(IDC_NT5_USER_EDIT, OnLoginNameChange)
  ON_EN_CHANGE(IDC_NT4_USER_EDIT, OnSAMNameChange)
  ON_EN_CHANGE(IDC_EDIT_FULL_NAME, OnFullNameChange)
END_MESSAGE_MAP()

CCreateNewUserPage1::CCreateNewUserPage1() : 
CCreateNewObjectDataPage(CCreateNewUserPage1::IDD)
{
  m_bForcingNameChange = FALSE;
}


BOOL CCreateNewUserPage1::OnInitDialog()
{
  CCreateNewObjectDataPage::OnInitDialog();
  VERIFY(_InitUI());
  return TRUE;
}


void CCreateNewUserPage1::GetSummaryInfo(CString& s)
{
  // get the UPN name
  CString strDomain;
  GetDlgItemText (IDC_NT5_DOMAIN_COMBO, OUT strDomain);
  CString strUPN = m_strLoginName + strDomain;

  // format the line 
  CString szFmt; 
  szFmt.LoadString(IDS_s_CREATE_NEW_SUMMARY_USER_UPN);
  CString szBuffer;
  szBuffer.Format((LPCWSTR)szFmt, (LPCWSTR)strUPN);
  s += szBuffer;
}


HRESULT CCreateNewUserPage1::SetData(BOOL bSilent)
{
  //
  // start with a new temporary object
  //
  HRESULT hr; 
  CString strDomain;

  GetDlgItemText (IDC_EDIT_FULL_NAME, OUT m_strFullName);
  GetDlgItemText (IDC_NT5_DOMAIN_COMBO, OUT strDomain);

  m_strLoginName.TrimRight();
  m_strLoginName.TrimLeft();

  //
  // First check for illegal characters
  //
  int iFind = m_strLoginName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS);
  if (iFind != -1 && !m_strLoginName.IsEmpty())
  {
    PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strLoginName};
    if (!bSilent && IDYES == ReportErrorEx (::GetParent(m_hWnd),IDS_LOGINNAME_ILLEGAL,S_OK,
                                            MB_YESNO | MB_ICONWARNING, apv, 1))
    {
      while (iFind != -1)
      {
        m_strLoginName.SetAt(iFind, L'_');
        iFind = m_strLoginName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS);
      }
      m_bForcingNameChange = TRUE;
      SetDlgItemText(IDC_NT5_USER_EDIT, m_strLoginName);
      m_bForcingNameChange = FALSE;
    }
    else
    {
      //
      // Set the focus to the edit box and select the text
      //
      GetDlgItem(IDC_NT5_USER_EDIT)->SetFocus();
      SendDlgItemMessage(IDC_NT5_USER_EDIT, EM_SETSEL, 0 , -1);
      return E_INVALIDARG;
    }
  }

  CString strUPN = m_strLoginName + strDomain;
  CString strDomainDNS = strDomain;
  CString strFilter;

  //
  // Store the object name in the temporary storage
  //
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();

  //
  // create a new temporary ADs object
  //
  hr = pNewADsObjectCreateInfo->HrCreateNew(m_strFullName);
  if (FAILED(hr))
  {
    return hr;
  }

  BOOL fDomainSearchFailed = FALSE;
  BOOL fGCSearchFailed = FALSE;

  //
  // now validate UPN with current domain before doing the put.
  //
  CDSSearch DSS;
  IDirectorySearch *pGCObj = NULL;

  //
  // validate UPN with GC before doing the put.
  //
  CString strDomainName = m_LocalDomain.Right (m_LocalDomain.GetLength() - 1);
  hr = DSPROP_GetGCSearchOnDomain((LPWSTR)(LPCWSTR)strDomainName,
                                  IID_IDirectorySearch, (void **)&pGCObj);
  if (SUCCEEDED(hr)) 
  {
    hr = DSS.Init (pGCObj);
    if (SUCCEEDED(hr)) 
    {
      //
      // NTRAID#NTBUG9-257580-2000/12/14-jeffjon,
      // We must get an escaped filter because the UPN may contain "special" characters
      //
      CString szEscapedUPN;
      EscapeFilterElement(strUPN, szEscapedUPN);

      LPWSTR pAttributes[1] = {L"cn"};
      strFilter = L"(userPrincipalName=";
      strFilter += szEscapedUPN;
      strFilter += L")";
      TRACE(_T("searching global catalog for %s...\n"), strUPN);


      DSS.SetFilterString ((LPWSTR)(LPCWSTR)strFilter);
      DSS.SetAttributeList (pAttributes, 1);
      DSS.SetSearchScope (ADS_SCOPE_SUBTREE);
      DSS.DoQuery();
      hr = DSS.GetNextRow();
      TRACE(_T("done searching global catalog for %s...\n"), strUPN);
    }
  }

  if (hr == S_OK) // this means a row was returned, so we're dup
  { 
    if (!bSilent)
    {
      PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strLoginName};
      ReportErrorEx (::GetParent(m_hWnd),IDS_UPN_DUP,hr,
                     MB_OK | MB_ICONWARNING, apv, 1);
    }
    return E_INVALIDARG;
  }
  if (hr != S_ADS_NOMORE_ROWS) // oops, had another problem
  { 
    fGCSearchFailed = TRUE;
  }

  CString strInitPath = L"LDAP://";
  strInitPath += m_LocalDomain.Right (m_LocalDomain.GetLength() - 1);
  TRACE(_T("Initialize Domain search object with: %s...\n"), strInitPath);
  HRESULT hr2 = DSS.Init (strInitPath);
  if (SUCCEEDED(hr2)) 
  {
    CString szEscapedUPN;
    EscapeFilterElement(strUPN, szEscapedUPN);

    LPWSTR pAttributes2[1] = {L"cn"};
    strFilter = L"(userPrincipalName=";
    strFilter += szEscapedUPN;
    strFilter += L")";
    TRACE(_T("searching current domain for %s...\n"), strUPN);
    DSS.SetAttributeList (pAttributes2, 1);
    DSS.SetFilterString ((LPWSTR)(LPCWSTR)strFilter);
    DSS.SetSearchScope (ADS_SCOPE_SUBTREE);
    DSS.DoQuery();
    hr2 = DSS.GetNextRow();
    TRACE(_T("done searching current domain for %s...\n"), strUPN);
  }

  if (hr2 == S_OK) // this means a row was returned, so we're dup
  { 
    if (!bSilent)
    {
      ReportErrorEx (::GetParent(m_hWnd),IDS_UPN_DUP,hr2,
                     MB_OK | MB_ICONWARNING, NULL, 0);
    }
    return E_INVALIDARG;
  }

  if (hr2 != S_ADS_NOMORE_ROWS)  // oops, had another problem
  {
    fDomainSearchFailed = TRUE;
  }

  if (fDomainSearchFailed || fGCSearchFailed) 
  {
    HRESULT hrSearch = S_OK;
    if (fDomainSearchFailed) 
    {
      hrSearch = hr2;
    } 
    else 
    {
      hrSearch = hr;
    }
    if (!bSilent)
    {
      ReportErrorEx (::GetParent(m_hWnd),IDS_UPN_SEARCH_FAILED,hrSearch,
                     MB_OK | MB_ICONWARNING, NULL, 0);
    }
  }

  if (pGCObj)
  {
    pGCObj->Release();
    pGCObj = NULL;
  }

  GetDlgItemText (IDC_NT4_USER_EDIT, OUT m_strSAMName);
  m_strSAMName.TrimLeft();
  m_strSAMName.TrimRight();

  //
  // First check for illegal characters
  //
  iFind = m_strSAMName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS_WITH_AT);
  if (iFind != -1 && !m_strSAMName.IsEmpty())
  {
    PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strSAMName};
    if (!bSilent && IDYES == ReportErrorEx (::GetParent(m_hWnd),IDS_SAMNAME_ILLEGAL,S_OK,
                                            MB_YESNO | MB_ICONWARNING, apv, 1))
    {
      while (iFind != -1)
      {
        m_strSAMName.SetAt(iFind, L'_');
        iFind = m_strSAMName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS_WITH_AT);
      }
      m_bForcingNameChange = TRUE;
      SetDlgItemText(IDC_NT4_USER_EDIT, m_strSAMName);
      m_bForcingNameChange = FALSE;
    }
    else
    {
      //
      // Set the focus to the edit box and select the text
      //
      GetDlgItem(IDC_NT4_USER_EDIT)->SetFocus();
      SendDlgItemMessage(IDC_NT4_USER_EDIT, EM_SETSEL, 0 , -1);
      return E_INVALIDARG;
    }
  }

  //
  // validate samAccountName with domain before doing the put.
  // There is no reason to verify the uniqueness against the GC
  // since sAMAccountName only has to be unique within the domain
  //
  CDSSearch DSSSAM;

  if (!fDomainSearchFailed && !fGCSearchFailed)
  {
    fDomainSearchFailed = FALSE;
    fGCSearchFailed = FALSE;

    hr2 = DSSSAM.Init (strInitPath);
    if (SUCCEEDED(hr2)) 
    {
      CString szEscapedSAMName;
      EscapeFilterElement(m_strSAMName, szEscapedSAMName);

      LPWSTR pAttributes2[1] = {L"cn"};
      strFilter = L"(samAccountName=";
      strFilter += szEscapedSAMName;
      strFilter += L")";
      TRACE(_T("searching current domain for %s...\n"), strUPN);
      DSSSAM.SetAttributeList (pAttributes2, 1);
      DSSSAM.SetFilterString ((LPWSTR)(LPCWSTR)strFilter);
      DSSSAM.SetSearchScope (ADS_SCOPE_SUBTREE);
      DSSSAM.DoQuery();
      hr2 = DSSSAM.GetNextRow();
      TRACE(_T("done searching current domain for %s...\n"), strUPN);
    }

    if (hr2 == S_OK) // this means a row was returned, so we're dup
    { 
      if (!bSilent)
      {
        ReportErrorEx (::GetParent(m_hWnd),IDS_SAMNAME_DUP,hr2,
                       MB_OK | MB_ICONWARNING, NULL, 0);
      }
      return E_INVALIDARG;
    }

    if (hr2 != S_ADS_NOMORE_ROWS)  // oops, had another problem
    {
      fDomainSearchFailed = TRUE;
    }

    if (fDomainSearchFailed) 
    {
      HRESULT hrSearch = S_OK;
      if (fDomainSearchFailed) 
      {
        hrSearch = hr2;
      } 
      else 
      {
        hrSearch = hr;
      }
      if (!bSilent)
      {
        ReportErrorEx (::GetParent(m_hWnd),IDS_UPN_SEARCH_FAILED,hrSearch,
                       MB_OK | MB_ICONWARNING, NULL, 0);
      }
    }
  }

  if (pGCObj)
  {
    pGCObj->Release();
  }

  hr = pNewADsObjectCreateInfo->HrAddVariantBstr(const_cast<PWSTR>(gsz_samAccountName), m_strSAMName);
  ASSERT(SUCCEEDED(hr));

  strUPN.TrimRight();
  strUPN.TrimLeft();
  hr = pNewADsObjectCreateInfo->HrAddVariantBstr(L"userPrincipalName", strUPN);
  ASSERT(SUCCEEDED(hr));

  m_strFullName.TrimLeft();
  m_strFullName.TrimRight();
  hr = pNewADsObjectCreateInfo->HrAddVariantBstr(L"displayName", m_strFullName);
  ASSERT(SUCCEEDED(hr));

  hr = pNewADsObjectCreateInfo->HrAddVariantBstrIfNotEmpty(L"givenName", m_strFirstName);
  ASSERT(SUCCEEDED(hr));
  hr = pNewADsObjectCreateInfo->HrAddVariantBstrIfNotEmpty(L"initials", m_strInitials);
  ASSERT(SUCCEEDED(hr));
  hr = pNewADsObjectCreateInfo->HrAddVariantBstrIfNotEmpty(L"sn", m_strLastName);
  ASSERT(SUCCEEDED(hr));

  return hr;
}


BOOL CCreateNewUserPage1::_InitUI()
{
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();
  IADs * pObj = NULL;
  CComBSTR bsPath;
  CComBSTR bsDN;
  LPWSTR pwzDomain = NULL;

  Edit_LimitText (GetDlgItem(IDC_EDIT_FULL_NAME)->m_hWnd, 64);
  Edit_LimitText (GetDlgItem(IDC_EDIT_LAST_NAME)->m_hWnd, 29);
  Edit_LimitText (GetDlgItem(IDC_EDIT_FIRST_NAME)->m_hWnd, 28);
  Edit_LimitText (GetDlgItem(IDC_EDIT_INITIALS)->m_hWnd, 4);
  Edit_LimitText (GetDlgItem(IDC_NT4_USER_EDIT)->m_hWnd, 20);
  Edit_LimitText (GetDlgItem(IDC_NT5_USER_EDIT)->m_hWnd, 256);

  HRESULT hr = pNewADsObjectCreateInfo->m_pIADsContainer->QueryInterface(
                  IID_IADs, (void **)&pObj);

  if (SUCCEEDED(hr)) 
  {
    // get the DN of the container from its LDAP path
    pObj->get_ADsPath (&bsPath);

    { // scope for smart pointer
      CPathCracker pathCracker;

      pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
      pathCracker.Set(bsPath, ADS_SETTYPE_FULL);
      pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bsDN);
    }

    // get the NT 5 (dns) domain name
    TRACE(L"CrackName(%s, &pwzDomain, GET_DNS_DOMAIN_NAME, NULL);\n", bsDN);
    hr = CrackName(bsDN, &pwzDomain, GET_DNS_DOMAIN_NAME, NULL);
    TRACE(L"CrackName returned hr = 0x%x, pwzDomain = <%s>\n", hr, pwzDomain);

    // get the NT 4 domain name from the DN
    LPWSTR pwzNT4Domain = NULL;
    TRACE(L"CrackName (%s, &pwzNT4Domain, GET_NT4_DOMAIN_NAME, NULL);\n", bsDN);
    hr = CrackName(bsDN, &pwzNT4Domain, GET_NT4_DOMAIN_NAME, NULL);
    TRACE(L"CrackName returned hr = 0x%x, pwzNT4Domain = <%s>\n", hr, pwzNT4Domain);

    // set the NT 4 domain name read only edit box
    if (pwzNT4Domain != NULL) 
    {
      CString szBuffer;
      szBuffer.Format(L"%s\\", pwzNT4Domain);
      SetDlgItemText(IDC_NT4_DOMAIN_EDIT, szBuffer);
      LocalFreeStringW(&pwzNT4Domain);
    }
  }

  TRACE(L"After CrackName() calls, pwzDomain = <%s>\n", pwzDomain);

  // if we do not have a domain name, we cannot proceed further,
  // this is a catastrophic failure
  if (pwzDomain == NULL)
  {
    // should never get here in normal operations
    HWND hWndWiz = ::GetParent(m_hWnd);
    ReportErrorEx(::GetParent(m_hWnd),IDS_ERR_FATAL,hr,
             MB_OK | MB_ICONERROR, NULL, 0);

    // bail out of the wizard
    VERIFY(::PostMessage(hWndWiz, WM_COMMAND, IDCANCEL, 0));
    return TRUE;
  }

  m_LocalDomain = L"@";
  m_LocalDomain += pwzDomain;

  CComboBox * pCC = (CComboBox *)GetDlgItem (IDC_NT5_DOMAIN_COMBO);

  // get the current domain (only present if we're going around a second time
  // due an error.) need this to prevent dups when on second trip.

  CString strDomain;
  GetDlgItemText (IDC_NT5_DOMAIN_COMBO, OUT strDomain);

  CStringList UPNs;

  // get UPN suffixes from this OU, if present
  CComVariant Var;
  hr = pObj->Get ( L"uPNSuffixes", &Var);
  if (SUCCEEDED(hr)) {
    hr = HrVariantToStringList (IN Var, UPNs);
    if (SUCCEEDED(hr)) {
      POSITION pos = UPNs.GetHeadPosition();
      CString csSuffix;
      while (pos != NULL) {
        csSuffix = L"@";
        csSuffix += UPNs.GetNext(INOUT pos);
        TRACE(_T("UPN suffix: %s\n"), csSuffix);
        pCC->AddString (csSuffix);
      }
    }

  } else {
    CString csPartitions;
    IADs * pPartitions = NULL;

  // get config path from main object
    csPartitions.Format(L"%sCN=Partitions,%s",
                        pNewADsObjectCreateInfo->GetBasePathsInfo()->GetProviderAndServerName(),
                        pNewADsObjectCreateInfo->GetBasePathsInfo()->GetConfigNamingContext());
  
    hr = DSAdminOpenObject(csPartitions,
                           IID_IADs, 
                           (void **)&pPartitions,
                           TRUE /*bServer*/);
    if (SUCCEEDED(hr)) {
      CComVariant sVar;
      hr = pPartitions->Get ( L"uPNSuffixes", &sVar);
      if (SUCCEEDED(hr)) {
        hr = HrVariantToStringList (IN sVar, UPNs);
        if (SUCCEEDED(hr)) {
          POSITION pos = UPNs.GetHeadPosition();
          CString csSuffix;
          while (pos != NULL) {
            csSuffix = L"@";
            csSuffix += UPNs.GetNext(INOUT pos);
            TRACE(_T("UPN suffix: %s\n"), csSuffix);
            if (wcscmp (strDomain, csSuffix)) {
              pCC->AddString (csSuffix);
            }
          }
        }
      }
      pPartitions->Release();
    }

    // get rest of domains in this tree
    CComPtr <IDsBrowseDomainTree> spDsDomains;
    hr = ::CoCreateInstance(CLSID_DsDomainTreeBrowser,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IDsBrowseDomainTree,
                            (LPVOID*)&spDsDomains);
    if (FAILED(hr)) {
      LocalFreeStringW(&pwzDomain);
      return FALSE;
    }
    LPCWSTR lpszServerName = GetWiz()->GetInfo()->GetBasePathsInfo()->GetServerName();
    hr = spDsDomains->SetComputer(lpszServerName, NULL, NULL);
    ASSERT(SUCCEEDED(hr));
    TRACE(L"returned from SetComputer(%s). hr is %lx\n", lpszServerName, hr);
    PDOMAIN_TREE pNewDomains = NULL;
    hr = spDsDomains->GetDomains(&pNewDomains, 0);
    TRACE(L"returned from GetDomains(), hr is %lx\n", hr);
    CString csRootDomain = L"@";
    INT pos;
    UINT iRoot;

    if (SUCCEEDED(hr) && pNewDomains) {
      TRACE(L"pNewDomains->dwCount = %d\n", pNewDomains->dwCount);
      for (UINT index = 0; index < pNewDomains->dwCount; index++) {
        TRACE(L"pNewDomains->aDomains[%d].pszName = <%s>\n", index, pNewDomains->aDomains[index].pszName);
        if (pNewDomains->aDomains[index].pszTrustParent == NULL) {
          //
          // Add the root domain only if it is a substring of the current
          // domain.
          //
          size_t cchRoot = wcslen(pNewDomains->aDomains[index].pszName);
          PWSTR pRoot = pwzDomain + wcslen(pwzDomain) - cchRoot;

          if (!_wcsicmp(pRoot, pNewDomains->aDomains[index].pszName))
            {
              csRootDomain += pNewDomains->aDomains[index].pszName;
              if (_wcsicmp (strDomain, csRootDomain)) {
                pos = pCC->AddString (csRootDomain);
              }
              iRoot = index;
            }
        }
      }
    }

    // If the local domain is not the root, add it as well.
    //
    CString csOtherDomain = L"@";

    if (_wcsicmp(csRootDomain, m_LocalDomain))
      {
        if (_wcsicmp (strDomain, m_LocalDomain)) {
          pos = pCC->AddString(m_LocalDomain);
        }
      }

    if (pNewDomains) {
      spDsDomains->FreeDomains(&pNewDomains);
    }
    LocalFreeStringW(&pwzDomain);
  }

  if (pObj) {
    pObj->Release();
    pObj = NULL;
  }

  //
  // If the local domain is not already in the list then add it
  //
  int iFind = pCC->FindStringExact(-1, m_LocalDomain);
  if (iFind == CB_ERR)
  {
    pCC->InsertString(0, m_LocalDomain);
    pCC->SetCurSel(0);
  }
  else
  {
    pCC->SetCurSel(iFind);
  }

  m_nameFormatter.Initialize(pNewADsObjectCreateInfo->GetBasePathsInfo(), 
                  pNewADsObjectCreateInfo->m_pszObjectClass);
  return TRUE;
}

BOOL CCreateNewUserPage1::GetData(IADs* pIADsCopyFrom)
{
  HRESULT hr = S_OK;
  if (pIADsCopyFrom != NULL)
  {
    // copy operation


    // we copy the UPN suffix
    CComVariant varData;
    hr = pIADsCopyFrom->Get(L"userPrincipalName", &varData);
    if (SUCCEEDED(hr))
    {
      // got something like "JoeB@acme.com."
      TRACE(L"source userPrincipalName: %s\n", varData.bstrVal);
      
      // need to get the suffix "@acme.com."
      for (LPWSTR lpszUPNSuffix = varData.bstrVal; lpszUPNSuffix != NULL; lpszUPNSuffix++)
      {
        if ((*lpszUPNSuffix) == L'@')
        {
          break;
        }
      }
      if (lpszUPNSuffix != NULL)
      {
        TRACE(L"source UPN suffix: %s\n", lpszUPNSuffix);
        
        // need to find out of the suffix is already there
        CComboBox * pDomainCombo = (CComboBox *)GetDlgItem(IDC_NT5_DOMAIN_COMBO);
        int iIndex = pDomainCombo->FindString(-1, lpszUPNSuffix);
        if (iIndex == CB_ERR)
        {
          // not found, just add at the top
          pDomainCombo->InsertString(0, lpszUPNSuffix);
          iIndex = 0;
        }
        
        ASSERT( (iIndex >= 0) && (iIndex < pDomainCombo->GetCount()));
        // set the selection to the source UPN suffix 
        pDomainCombo->SetCurSel(iIndex);
      }
    }
    return FALSE;
  }
  return (!m_strLoginName.IsEmpty() &&!m_strFullName.IsEmpty()); 
}


void CCreateNewUserPage1::OnNameChange()
{
  GetDlgItemText(IDC_EDIT_FIRST_NAME, OUT m_strFirstName);
  GetDlgItemText(IDC_EDIT_INITIALS, OUT m_strInitials);
  GetDlgItemText(IDC_EDIT_LAST_NAME, OUT m_strLastName);

  m_strFirstName.TrimLeft();
  m_strFirstName.TrimRight();

  m_strInitials.TrimLeft();
  m_strInitials.TrimRight();

  m_strLastName.TrimLeft();
  m_strLastName.TrimRight();

  m_nameFormatter.FormatName(m_strFullName, 
                             m_strFirstName.IsEmpty() ? NULL : (LPCWSTR)m_strFirstName, 
                             m_strInitials.IsEmpty() ? NULL : (LPCWSTR)m_strInitials,
                             m_strLastName.IsEmpty() ? NULL : (LPCWSTR)m_strLastName);


  SetDlgItemText (IDC_EDIT_FULL_NAME, 
                  IN m_strFullName);

  GetDlgItemText(IDC_NT5_USER_EDIT, OUT m_strLoginName);
  GetWiz()->SetWizardButtons(this, (!m_strLoginName.IsEmpty() &&
                                    !m_strFullName.IsEmpty() &&
                                    !m_strSAMName.IsEmpty()));
}

void CCreateNewUserPage1::OnLoginNameChange()
{
  if (!m_bForcingNameChange)
  {
    CString csSamName;
    GetDlgItemText(IDC_NT5_USER_EDIT, OUT m_strLoginName);
    csSamName = m_strLoginName.Left(20);
    SetDlgItemText (IDC_NT4_USER_EDIT, OUT csSamName);
  }
  GetWiz()->SetWizardButtons(this, (!m_strLoginName.IsEmpty() &&
                                    !m_strFullName.IsEmpty() &&
                                    !m_strSAMName.IsEmpty()));
}

void CCreateNewUserPage1::OnSAMNameChange()
{
  GetDlgItemText (IDC_NT4_USER_EDIT, OUT m_strSAMName);
  GetWiz()->SetWizardButtons(this, (!m_strLoginName.IsEmpty() &&
                                    !m_strFullName.IsEmpty() &&
                                    !m_strSAMName.IsEmpty()));
}

void CCreateNewUserPage1::OnFullNameChange()
{
  GetDlgItemText (IDC_EDIT_FULL_NAME, OUT m_strFullName);
  GetWiz()->SetWizardButtons(this, (!m_strLoginName.IsEmpty() &&
                                    !m_strFullName.IsEmpty() &&
                                    !m_strSAMName.IsEmpty()));
}

//
BOOL CCreateNewUserPage1::OnError( HRESULT hr )
{
  BOOL bRetVal = FALSE;

  if( HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS )
  {

    HRESULT Localhr;
    DWORD LastError; 
    WCHAR Buf1[256], Buf2[256];
    Localhr = ADsGetLastError (&LastError,
                               Buf1, 256, Buf2, 256);
    switch( LastError )
    {
      case ERROR_USER_EXISTS:
      {
        PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strSAMName};
        ReportErrorEx (::GetParent(m_hWnd),IDS_ERROR_USER_EXISTS,hr,
                   MB_OK|MB_ICONWARNING , apv, 1);
        bRetVal = TRUE;
      }
      break;

      case ERROR_DS_OBJ_STRING_NAME_EXISTS:
      {
        PVOID apv[1] = {(LPWSTR)(LPCWSTR)m_strFullName};
        ReportErrorEx (::GetParent(m_hWnd),IDS_ERROR_USER_DS_OBJ_STRING_NAME_EXISTS,hr,
                   MB_OK|MB_ICONWARNING , apv, 1);
        bRetVal = TRUE;
      }
      break;
    }
  }
  return bRetVal;
}




///////////////////////////////////////////////////////////////
// CCreateNewUserPage2

BEGIN_MESSAGE_MAP(CCreateNewUserPage2, CCreateNewObjectDataPage)
  ON_BN_CLICKED (IDC_CHECK_PASSWORD_MUST_CHANGE, OnPasswordPropsClick)
  ON_BN_CLICKED (IDC_CHECK_PASSWORD_NEVER_EXPIRES, OnPasswordPropsClick)
  ON_BN_CLICKED (IDC_CHECK_PASSWORD_CANNOT_CHANGE, OnPasswordPropsClick)
END_MESSAGE_MAP()

CCreateNewUserPage2::CCreateNewUserPage2() : 
CCreateNewObjectDataPage(CCreateNewUserPage2::IDD)
{
  m_pPage1 = NULL;
}

BOOL CCreateNewUserPage2::OnInitDialog()
{
  CCreateNewObjectDataPage::OnInitDialog();

  SendDlgItemMessage(IDC_EDIT_PASSWORD, EM_LIMITTEXT, (WPARAM)127, 0);
  SendDlgItemMessage(IDC_EDIT_PASSWORD_CONFIRM, EM_LIMITTEXT, (WPARAM)127, 0);
  return TRUE;
}

void CCreateNewUserPage2::_GetCheckBoxSummaryInfo(UINT nCtrlID, UINT nStringID, CString& s)
{
  if (IsDlgButtonChecked(nCtrlID))
  {
    CString sz;
    sz.LoadString(nStringID);
    s += sz;
    s += L"\n";
  }
}

void CCreateNewUserPage2::GetSummaryInfo(CString& s)
{
  _GetCheckBoxSummaryInfo(IDC_CHECK_PASSWORD_MUST_CHANGE,   IDS_USER_CREATE_DLG_PASSWORD_MUST_CHANGE, s);
  _GetCheckBoxSummaryInfo(IDC_CHECK_PASSWORD_CANNOT_CHANGE, IDS_USER_CREATE_DLG_PASSWORD_CANNOT_CHANGE, s);
  _GetCheckBoxSummaryInfo(IDC_CHECK_PASSWORD_NEVER_EXPIRES, IDS_USER_CREATE_DLG_PASSWORD_NEVER_EXPIRES, s);
  _GetCheckBoxSummaryInfo(IDC_CHECK_ACCOUNT_DISABLED,       IDS_USER_CREATE_DLG_ACCOUNT_DISABLED, s);
}


void
CCreateNewUserPage2::OnPasswordPropsClick()
{
  BOOL fPasswordMustChange = IsDlgButtonChecked(IDC_CHECK_PASSWORD_MUST_CHANGE);
  BOOL fPasswordCannotChange = IsDlgButtonChecked(IDC_CHECK_PASSWORD_CANNOT_CHANGE);
  BOOL fPasswordNeverExpires = IsDlgButtonChecked(IDC_CHECK_PASSWORD_NEVER_EXPIRES);

  if (fPasswordMustChange && fPasswordNeverExpires) 
  {
    ReportErrorEx (::GetParent(m_hWnd),IDS_PASSWORD_MUTEX,S_OK,
                   MB_OK, NULL, 0);
    CheckDlgButton(IDC_CHECK_PASSWORD_MUST_CHANGE, FALSE);
    fPasswordMustChange = FALSE;
  }

  if (fPasswordMustChange && fPasswordCannotChange)
  {
    ReportErrorEx (::GetParent(m_hWnd),IDS_ERR_BOTH_PW_BTNS,S_OK,
                   MB_OK, NULL, 0);
    CheckDlgButton(IDC_CHECK_PASSWORD_CANNOT_CHANGE, FALSE);
  }
}


HRESULT CCreateNewUserPage2::SetData(BOOL bSilent)
{
  CString strPassword;
  CString strPasswordConfirm;

  GetDlgItemText(IDC_EDIT_PASSWORD, OUT strPassword);
  GetDlgItemText(IDC_EDIT_PASSWORD_CONFIRM, OUT strPasswordConfirm);
  if (strPassword != strPasswordConfirm)
  {
    if (!bSilent)
    {
      ReportErrorEx (::GetParent(m_hWnd),IDS_PASSWORDS_DONT_MATCH,S_OK,
                     MB_OK, NULL, 0);
    }
    SetDlgItemText(IDC_EDIT_PASSWORD, L"");
    SetDlgItemText(IDC_EDIT_PASSWORD_CONFIRM, L"");
    SetDlgItemFocus(IDC_EDIT_PASSWORD);
    return E_INVALIDARG;
  }


  HRESULT hr = S_OK;
  // intelligent copy of path info, it if is a copy operation
  {
    CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();
    CCopyObjectHandlerBase* pCopyHandler = pNewADsObjectCreateInfo->GetCopyHandler();
    if (pCopyHandler != NULL)
    {
      IADs * pIADs = pNewADsObjectCreateInfo->PGetIADsPtr();
      ASSERT(pIADs != NULL);
      hr = pCopyHandler->Copy(pIADs, FALSE /*bPostCommit*/, ::GetParent(m_hWnd), 
                                                      m_pPage1->GetFullName());
    }
  }

  return hr;
}



//+----------------------------------------------------------------------------
//
//  Method:     _RevokeChangePasswordPrivilege
//
//  Purpose:    Revoke the user's change password privilege.
//
//-----------------------------------------------------------------------------
HRESULT RevokeChangePasswordPrivilege(IADs * pIADs)
{
  CChangePasswordPrivilegeAction ChangePasswordPrivilegeAction;

  HRESULT hr = ChangePasswordPrivilegeAction.Load(pIADs);
  if (FAILED(hr))
  {
    TRACE(L"ChangePasswordPrivilegeAction.Load() failed with hr = 0x%x\n", hr);
    return hr;
  }

  hr = ChangePasswordPrivilegeAction.Revoke();
  if (FAILED(hr))
  {
    TRACE(L"ChangePasswordPrivilegeAction.Revoke() failed with hr = 0x%x\n", hr);
    return hr;
  }
  return S_OK;
}



HRESULT CCreateNewUserPage2::OnPostCommit(BOOL bSilent)
{
  // local variables
  HRESULT hr = E_FAIL;
  PVOID apv[1] = {(LPWSTR)(m_pPage1->GetFullName())};
  CWaitCursor Wait;
  
  CComPtr <IDirectoryObject> pIDSObject; // smart pointer, no need to release
  CComPtr <IADsUser> pIADsUser; // smart pointer, no need to release

  BOOL bCanEnable = TRUE;
  
  CString strPassword;
  GetDlgItemText(IDC_EDIT_PASSWORD, OUT strPassword);

  BOOL fPasswordMustChange = IsDlgButtonChecked(IDC_CHECK_PASSWORD_MUST_CHANGE);
  BOOL fPasswordCannotChange = IsDlgButtonChecked(IDC_CHECK_PASSWORD_CANNOT_CHANGE);
  BOOL fPasswordNeverExpires = IsDlgButtonChecked(IDC_CHECK_PASSWORD_NEVER_EXPIRES);
  BOOL fAccountEnabled = !IsDlgButtonChecked(IDC_CHECK_ACCOUNT_DISABLED);

  CComVariant varAccountFlags;

  // get object info and useful interfaces
  CNewADsObjectCreateInfo* pNewADsObjectCreateInfo = GetWiz()->GetInfo();
  ASSERT(pNewADsObjectCreateInfo != NULL);

  IADs * pIADs = pNewADsObjectCreateInfo->PGetIADsPtr();
  ASSERT(pIADs != NULL);

  // get the IDirectoryObject interface
  hr = pIADs->QueryInterface(IID_IDirectoryObject, OUT (void **)&pIDSObject);
  ASSERT(pIDSObject != NULL);
  if (FAILED(hr))
  {
    ASSERT(FALSE); // should never get here in normal operations
    if (!bSilent)
    {
      ReportErrorEx(::GetParent(m_hWnd),IDS_ERR_FATAL,hr,
                    MB_OK | MB_ICONERROR, NULL, 0);
    }
    goto ExitCleanup;
  }

  // get the IADsUser interface
  hr = pIADs->QueryInterface(IID_IADsUser, OUT (void **)&pIADsUser);
  ASSERT(pIDSObject != NULL);
  if (FAILED(hr))
  {
    ASSERT(FALSE); // should never get here in normal operations
    if (!bSilent)
    {
      ReportErrorEx(::GetParent(m_hWnd),IDS_ERR_FATAL,hr,
                    MB_OK | MB_ICONERROR, NULL, 0);
    }
    goto ExitCleanup;
  }

  // try to set password

  ASSERT(pIADsUser != NULL);
  hr = pIADsUser->SetPassword(const_cast<LPTSTR>((LPCTSTR)strPassword));
  if (FAILED(hr)) 
  {
    if (hr != E_ACCESSDENIED) 
    {
      if (!bSilent)
      {
        // fatal error, put up error message 
        ReportErrorEx(::GetParent(m_hWnd),IDS_12_CANT_SET_PASSWORD,hr,
                      MB_OK | MB_ICONWARNING, apv, 1);
      }
      bCanEnable = FALSE;
      goto ExitCleanup;
    } 
    else 
    {
      if (!bSilent)
      {
        ReportErrorEx(::GetParent(m_hWnd),IDS_12_ACCESS_DENIED_SET_PASSWORD,hr,
                      MB_OK | MB_ICONWARNING, apv, 1);
      }
      bCanEnable = FALSE;
    }
  }
  if (fPasswordMustChange)
  {
    LPWSTR szPwdLastSet = L"pwdLastSet";
    ADSVALUE ADsValuePwdLastSet = {ADSTYPE_LARGE_INTEGER, NULL};
    ADS_ATTR_INFO AttrInfoPwdLastSet = {szPwdLastSet, ADS_ATTR_UPDATE,
                                        ADSTYPE_LARGE_INTEGER,
                                        &ADsValuePwdLastSet, 1};
    ADsValuePwdLastSet.LargeInteger.QuadPart = 0;
    ASSERT(pIDSObject != NULL);
    DWORD cAttrModified = 0;
    hr = pIDSObject->SetObjectAttributes(&AttrInfoPwdLastSet, 1, &cAttrModified);
    if (FAILED(hr))
    {
      ASSERT(cAttrModified == 0);
      // fatal error, put up error message and bail out
      if (!bSilent)
      {
        ReportErrorEx(::GetParent(m_hWnd),IDS_12_CANT_SET_PWD_MUST_CHANGE,hr,
                       MB_OK | MB_ICONERROR, apv, 1);
      }
      bCanEnable = FALSE;
    }
    ASSERT(cAttrModified == 1);
  } // if (fPasswordMustChange)

  if (fPasswordCannotChange)
  {
    hr = RevokeChangePasswordPrivilege(pIADs);
    if (FAILED(hr))
    {
      if (!bSilent)
      {
        // warning ad go on
        ReportErrorEx(::GetParent(m_hWnd),IDS_12_CANT_SET_PWD_CANNOT_CHANGE,hr,
                       MB_OK | MB_ICONWARNING, apv, 1);
      }
      bCanEnable = FALSE;
      hr = S_OK;
    }
  }

  // Set userAccountControl
  hr = pNewADsObjectCreateInfo->HrGetAttributeVariant(const_cast<PWSTR>(gsz_userAccountControl), OUT &varAccountFlags);

  { // scope for local variables
    // if copy operation, makes sure we get the right set of bits copied over
    CCopyUserHandler* pCopyUserHandler = 
                dynamic_cast<CCopyUserHandler*>(GetWiz()->GetInfo()->GetCopyHandler());
    if (pCopyUserHandler != NULL)
    {
      CComVariant varAccountControlSource;
      hr = pCopyUserHandler->GetCopyFrom()->Get((LPWSTR)gsz_userAccountControl, &varAccountControlSource);
      if (SUCCEEDED(hr))
      {
        ASSERT(varAccountControlSource.vt == VT_I4);
        // some bits are already set in the UI and the user can change them,
        // we will get them later on
        varAccountControlSource.vt &= ~UF_DONT_EXPIRE_PASSWD;
        varAccountControlSource.vt &= ~UF_ACCOUNTDISABLE;

        // add the remaining bits to the default ones after creation
        varAccountFlags.vt |= varAccountControlSource.vt;
      }
    }
  }

  if (SUCCEEDED(hr))
  {
    ASSERT(varAccountFlags.vt == VT_I4);
    if (fPasswordNeverExpires)
      varAccountFlags.lVal |= UF_DONT_EXPIRE_PASSWD;
    varAccountFlags.lVal &= ~UF_PASSWD_NOTREQD;

 // Update the userAccountControl attribute
    hr = pNewADsObjectCreateInfo->HrAddVariantCopyVar(const_cast<PWSTR>(gsz_userAccountControl), varAccountFlags);
    ASSERT(SUCCEEDED(hr));
    hr = pNewADsObjectCreateInfo->HrSetInfo(bSilent /* fSilentError */ );
    if (FAILED(hr))
    {
      if (HRESULT_CODE(hr) == ERROR_DS_UNWILLING_TO_PERFORM) 
      {
        DWORD status;
        WCHAR Buf1[256], Buf2[256];
        ADsGetLastError (&status, Buf1, 256, Buf2, 256);
        TRACE(_T("ADsGetLastError returned status of %lx, error: %s, name %s\n"),
              status, Buf1, Buf2);
      
        if ((status == ERROR_PASSWORD_RESTRICTION) &&
            strPassword.IsEmpty()) 
        {
          if (!bSilent)
          {
            ReportErrorEx(::GetParent(m_hWnd),IDS_NULL_PASSWORD,hr,
                          MB_OK | MB_ICONERROR, NULL, 0);
          }
          goto ExitCleanup;
        }
      } 
      // we failed, so we put up a warning and leave the object intact
      if (!bSilent)
      {
        ReportErrorEx(::GetParent(m_hWnd),IDS_12_CANT_GET_USERACCOUNTCONTROL,hr,
                      MB_OK | MB_ICONERROR, apv, 1);
      }
      // reset error code, just a warning 
      bCanEnable = FALSE;
      hr = S_OK;
    }
  }
  else
  {
    TRACE1("INFO: Unable to get userAccountControl for user %s.\n",
           m_pPage1->GetFullName());
    // put up message box, but continue
    if (!bSilent)
    {
      ReportErrorEx(::GetParent(m_hWnd),IDS_12_CANT_GET_USERACCOUNTCONTROL,hr,
                     MB_OK | MB_ICONERROR, apv, 1);
    }
    // reset error code, just a warning 
    hr = S_OK;
  }

  // finally, if all went well, we can enable the user account
  hr = S_OK;
  if (bCanEnable & fAccountEnabled)
  {
    hr = pNewADsObjectCreateInfo->HrGetAttributeVariant(const_cast<PWSTR>(gsz_userAccountControl), OUT &varAccountFlags);
    varAccountFlags.lVal &= ~UF_ACCOUNTDISABLE;
    hr = pNewADsObjectCreateInfo->HrAddVariantCopyVar(const_cast<PWSTR>(gsz_userAccountControl), varAccountFlags);
    hr = pNewADsObjectCreateInfo->HrSetInfo(bSilent /* fSilentError */ );
    if (FAILED(hr))
    {
      if (HRESULT_CODE(hr) == ERROR_DS_UNWILLING_TO_PERFORM) 
      {
        DWORD status;
        WCHAR Buf1[256], Buf2[256];
        ADsGetLastError (&status, Buf1, 256, Buf2, 256);
        TRACE(_T("ADsGetLastError returned status of %lx, error: %s, name %s\n"),
              status, Buf1, Buf2);
      
        if ((status == ERROR_PASSWORD_RESTRICTION) &&
            strPassword.IsEmpty()) 
        {
          //
          // NTRAID#Windows Bugs-367611-2001/04/14-jeffjon
          // DsAdmin:  When password policy set, create usr with blank psswrd 
          // and 2 error msgs appear.  One msg is enough
          //
          // This message is being handled from within the HrSetInfo above
          // and is actually more descriptive.  Probably a change to winerror.mc
          //
          /*
          if (!bSilent)
          {
            ReportErrorEx(::GetParent(m_hWnd),IDS_NULL_PASSWORD,hr,
                          MB_OK | MB_ICONERROR, NULL, 0);
          }
          */
          goto ExitCleanup;
        }
      } 
      // we failed, so we put up a warning and leave the object intact
      if (!bSilent)
      {
        ReportErrorEx(::GetParent(m_hWnd),IDS_12_CANT_GET_USERACCOUNTCONTROL,hr,
                      MB_OK | MB_ICONERROR, apv, 1);
      }
      // reset error code, just a warning 
      hr = S_OK;
    }
  }


  // try to set group membership, it if is a copy operation
  {
    CCopyObjectHandlerBase* pCopyHandler = GetWiz()->GetInfo()->GetCopyHandler();

    if (pCopyHandler != NULL)
    {
      hr = pCopyHandler->Copy(pIADs, TRUE /*bPostCommit*/,::GetParent(m_hWnd), 
                                                      m_pPage1->GetFullName());
      if (SUCCEEDED(hr))
      {
        hr = pNewADsObjectCreateInfo->HrSetInfo(bSilent/* fSilentError */ );
      }
      if (FAILED(hr))
      {
        // we failed, so we put up a warning and leave the object intact
        if (!bSilent)
        {
          ReportErrorEx(::GetParent(m_hWnd),IDS_12_CANT_SET_GROUP_MEMBERSHIP,hr,
                        MB_OK | MB_ICONERROR, apv, 1);
        }
        // reset error code, just a warning 
        hr = S_OK;
      }
    }
  }

ExitCleanup:

  return hr;
}

BOOL CCreateNewUserPage2::GetData(IADs* pIADsCopyFrom)
{
  if (pIADsCopyFrom != NULL)
  {
    CString szFmt; 
    szFmt.LoadString(IDS_s_COPY_SUMMARY_NAME);

    // we just get the CN of the object
    CComVariant varAccountControl;
    HRESULT hr = pIADsCopyFrom->Get((LPWSTR)gsz_userAccountControl, &varAccountControl);
    if (SUCCEEDED(hr))
    {
      BOOL bPasswordNeverExpires = (varAccountControl.lVal & UF_DONT_EXPIRE_PASSWD) != 0;
      BOOL bDisabled = (varAccountControl.lVal & UF_ACCOUNTDISABLE) != 0;

      CheckDlgButton(IDC_CHECK_PASSWORD_NEVER_EXPIRES, bPasswordNeverExpires);
      CheckDlgButton(IDC_CHECK_ACCOUNT_DISABLED, bDisabled);
    } // if

    
    CCopyUserHandler* pCopyUserHandler = 
      dynamic_cast<CCopyUserHandler*>(GetWiz()->GetInfo()->GetCopyHandler());
    ASSERT(pCopyUserHandler != NULL);

    if (pCopyUserHandler != NULL)
    {
      // set the cannot change password checkbox
      BOOL bPasswordCannotChange = pCopyUserHandler->PasswordCannotChange();
      CheckDlgButton(IDC_CHECK_PASSWORD_CANNOT_CHANGE, bPasswordCannotChange);

      if (!bPasswordCannotChange)
      {
        // set the must change password checkbox
        BOOL bPasswordMustChange = pCopyUserHandler->PasswordMustChange();
        CheckDlgButton(IDC_CHECK_PASSWORD_MUST_CHANGE, bPasswordMustChange);
      }
    }

  } // if

  return TRUE;
}


///////////////////////////////////////////////////////////////
// CCreateNewUserWizard
    
CCreateNewUserWizard::CCreateNewUserWizard(CNewADsObjectCreateInfo* pNewADsObjectCreateInfo) : 
    CCreateNewObjectWizardBase(pNewADsObjectCreateInfo)
{
  AddPage(&m_page1);
  AddPage(&m_page2);
  m_page2.SetPage1(&m_page1);
}


void CCreateNewUserWizard::GetSummaryInfoHeader(CString& s)
{
  IADs* pIADsCopyFrom = GetInfo()->GetCopyFromObject();
  if (pIADsCopyFrom != NULL)
  {
    CString szFmt; 
    szFmt.LoadString(IDS_s_COPY_SUMMARY_NAME);

    // we just get the CN of the object
    CComVariant varName;
    HRESULT hr = pIADsCopyFrom->Get(L"cn", &varName);
    if (SUCCEEDED(hr))
    {
      CString szTmp;
      szTmp.Format((LPCWSTR)szFmt, varName.bstrVal);
      s += szTmp;
      s += L"\n";
    }
  }
  CCreateNewObjectWizardBase::GetSummaryInfoHeader(s);
}

void CCreateNewUserWizard::OnFinishSetInfoFailed(HRESULT hr)
{

  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  if ( !( HRESULT_CODE(hr) == ERROR_OBJECT_ALREADY_EXISTS && 
        m_page1.OnError( hr ) ) )
  {
    // everything else is handled by the base class
    CCreateNewObjectWizardBase::OnFinishSetInfoFailed(hr);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\profile.h ===
/*********************************************************************************
/* File:
/* 		PROFILE.H
/* Author:
/*		Max-H. Windisch, SDE-T
/* Date:
/*		October 1996
/* Macros:
/*		BEGIN_PROFILING_BLOCK
/*		END_PROFILING_BLOCK
/*		DUMP_PROFILING_RESULTS
/*		IMPLEMENT_PROFILING
/*		IMPLEMENT_PROFILING_CONDITIONAL
/* Classes:
/*		CMaxLargeInteger
/*		CMaxTimerAbstraction
/*		CMaxMiniProfiler_Node_Base
/*		CMaxMiniProfiler_Node_Standard
/*		CMaxMiniProfiler_Node_NoHistory
/*		CMaxMiniProfiler_Base
/*		CMaxMiniProfiler_Standard
/*		CMaxMiniProfiler_NoHistory
/*		CMaxMultithreadProfiler
/*		CMaxProfilingDLLWrapper
/*		CMaxProfilingObject
/*		CMaxProfilingBlockWrapper
/* Summary:
/*		This mini profiler allows you to place BEGIN_PROFILING_BLOCK and
/*		END_PROFILING_BLOCK directives in your code, or use the
/*		CMaxProfilingBlockWrapper object, and collect results
/*		in a logfile on termination of the profiled application (or by
/*		using the DUMP_PROFILING_RESULTS macro).  The
/*		profiling blocks can be nested.  Each module (DLL/EXE) using
/*		the profiler must use IMPLEMENT_PROFILING or 
/*		IMPLEMENT_PROFILING_CONDITIONAL exactly once (defines
/*		static variables for the profiler)
/* More details:
/*		The default result file is c:/result.txt.  It is not erased
/*		automatically.  For each completed instance of a profiler, it
/*		contains: 1) a header, 2) the history of all profiled blocks (optional),
/*		3) merged results.  For merging, results are sorted by {level, name}, 
/*		merged, then sorted again by {full name}.  Therefore, block names 
/*		must be unique.  In any case, absolute results are always
/*		given (in seconds)
/* How to enable in your code:
/*		To enable the profiler, define MAX_PROFILING_ENABLED before including
/*		this file.  To use the profiler through s:/ds/util/maxprof.dll 
/*		(built in release), define MAX_PROFILING_ENABLED_DLL instead.  This
/*		allows to use one single instance of a profiler from multiple
/*		modules
/* Other comments:
/*		At runtime, you can disable history output by defining the following
/*		environment variable to YES: MAX_DISABLE_PROFILING_HISTORY.
/*		In DLL mode, if you define MAX_PROFILING_CONDITIONAL before including
/*		this file, the profiler will work only if the following environment
/*		variable is defined to YES: MAX_ENABLE_PROFILING
/* Note:
/*		It's on purpose that I avoid using virtual methods here
/*		
/* (c) Copyright 1996 Microsoft-Softimage Inc.
/********************************************************************************/
#ifndef __MAX_PROFILING_H // {
#define __MAX_PROFILING_H

#include <afx.h> // for CTime and CString
#include <assert.h> // for asserts
#include <fstream.h> // for streams
#include <iomanip.h>

//#pragma warning( disable : 4786 ) // stl antivirus ;-)
//#include <dsstlmfc.h> // for STL

#define MAX_ENV_ENABLE_PROFILING _T( "MAX_ENABLE_PROFILING" )
#define MAX_ENV_DISABLE_PROFILING_HISTORY _T( "MAX_DISABLE_PROFILING_HISTORY" )
#define MAX_ENV_YES _T( "YES" )
#define MAX_ENV_ALL _T( "ALL" )

#if !defined( DS_ON_AXP ) && !defined( _NO_THROW )
#define MAXPROFNOTHROW __declspec( nothrow )
#else
#define MAXPROFNOTHROW
#endif

#define MAX_PROFTAGNODE_TOP "PROFILER: ALL"
#define MAX_PROFTAGNODE_HEAPALLOCATION "PROFILER: HEAPALLOCATION"
#define MAX_PROFTAGNODE_BIAS "PROFILER: BIAS"
#define MAX_PROFTAGNODE_NOTHINGNESS "PROFILER: NOTHINGNESS"

// Note: disable profiling in _SHIP (unless specified otherwise by DS_PROFILE_SHIP),
//		 and in unix (not sure why)
#if ( defined _SHIP && !defined DS_PROFILE_SHIP ) || defined unix
#undef MAX_PROFILING_ENABLED_DLL
#undef MAX_PROFILING_ENABLED
#endif





/*********************************************************************************
/* Macros:
/*		BEGIN_PROFILING_BLOCK
/*		END_PROFILING_BLOCK
/*		DUMP_PROFILING_RESULTS
/*		IMPLEMENT_PROFILING
/*		IMPLEMENT_PROFILING_CONDITIONAL
/* Comments:
/*		. For simplified use of CMaxMiniProfiler's.
/*		. For the comment parameter, use a non-unicode string, without "return"
/*		  character
/*		. For the enabler parameter, use a unicode string (the name of your
/*		  environment variable)
/*		. Use unique comments, since the profiler might use them as sorting keys
/*		. The use of DUMP_PROFILING_RESULTS is not compulsory, since profilings
/*		  are always dumped at the end of a profiling session
/********************************************************************************/
#ifndef unix
	#define __MAX_RESULTFILE_NAME "c:\\result.txt"
#else
	#define __MAX_RESULTFILE_NAME "result.txt"
#endif

#ifdef MAX_PROFILING_ENABLED_DLL
	#define __MAX_MINIPROFILER_IMPLEMENTATION ;
#else
	#define __MAX_MINIPROFILER_IMPLEMENTATION \
		const char *CMaxMiniProfiler_Base::s_poDefaultFileName = __MAX_RESULTFILE_NAME; \
		CMaxTimerAbstraction CMaxMiniProfiler_Base::s_oOutOfBraceBiasApproximation; \
		CMaxTimerAbstraction CMaxMiniProfiler_Base::s_oInOfBraceBiasApproximation; \
		bool CMaxMiniProfiler_Base::s_bBiasIsKnown = false; \
		unsigned long CMaxMiniProfiler_Base::s_lHeapBlockSize = 5000;
#endif

#if defined MAX_PROFILING_ENABLED || defined MAX_PROFILING_ENABLED_DLL // {{
	#define BEGIN_PROFILING_BLOCK( comment ) \
		CMaxProfilingObject::SCreateNewNode( comment );
	#define END_PROFILING_BLOCK \
		CMaxProfilingObject::SCloseCurrentNode();
	#define DUMP_PROFILING_RESULTS \
		CMaxProfilingObject::SDumpResults();
	#define IMPLEMENT_PROFILING \
		__MAX_MINIPROFILER_IMPLEMENTATION \
		CMaxProfilingObject::MPOProfiler CMaxProfilingObject::s_oProfiler; \
		CMaxProfilingObject::__CBiasApproximation CMaxProfilingObject::s_oBiasApproximation;
	#define IMPLEMENT_PROFILING_CONDITIONAL( enabler ) \
		__MAX_MINIPROFILER_IMPLEMENTATION \
		CMaxProfilingObject::MPOProfiler CMaxProfilingObject::s_oProfiler( enabler ); \
		CMaxProfilingObject::__CBiasApproximation CMaxProfilingObject::s_oBiasApproximation;
#else // }{
	#define BEGIN_PROFILING_BLOCK( comment ) ( void )( comment );
	#define END_PROFILING_BLOCK ;
	#define DUMP_PROFILING_RESULTS ;
	#define IMPLEMENT_PROFILING ;
	#define IMPLEMENT_PROFILING_CONDITIONAL( enabler ) ;
#endif // }}





#if defined MAX_PROFILING_ENABLED || defined MAX_PROFILING_ENABLED_DLL || defined MAX_PROFILING_DLL_IMPLEMENTATION // {
/*********************************************************************************
/* Helper function:
/*		bGIsEnabledEnvVar
/* Comments:
/********************************************************************************/
MAXPROFNOTHROW static inline bool bGIsEnabledEnvVar( 
	const TCHAR *pszEnvironmentVariableName,
	const TCHAR *pszCriteria = MAX_ENV_YES )
{
const int nLength = 80;
TCHAR szBuffer[ nLength ];
DWORD dwValue;

	// NULL string means enabled (default)
	if ( NULL == pszEnvironmentVariableName )
		return true;

	dwValue = ::GetEnvironmentVariable( 
		pszEnvironmentVariableName, szBuffer, nLength );
	if ( dwValue > 0 && _tcsicmp( szBuffer, pszCriteria ) == 0 )
		return true;

	return false;
};
#endif // }





#if defined MAX_PROFILING_ENABLED || defined MAX_PROFILING_DLL_IMPLEMENTATION // {
/*********************************************************************************
/* Class:
/*		CMaxLargeInteger
/* Comments:
/*		Minimal encapsulation of LARGE_INTEGER, considered as a time value
/********************************************************************************/
class CMaxLargeInteger
{
	protected:
		LARGE_INTEGER m_oValue;

	public:
		MAXPROFNOTHROW CMaxLargeInteger( LONG lHighPart = 0, DWORD dwLowPart = 0 )
		{
			m_oValue.u.HighPart = lHighPart;
			m_oValue.u.LowPart = dwLowPart;
		}

		MAXPROFNOTHROW CMaxLargeInteger( LONGLONG llQuadPart )
		{
			m_oValue.QuadPart = llQuadPart;
		}

		MAXPROFNOTHROW CMaxLargeInteger operator +( const CMaxLargeInteger &roAdded ) const
		{
			return CMaxLargeInteger( m_oValue.QuadPart + roAdded.m_oValue.QuadPart );
		}

		MAXPROFNOTHROW CMaxLargeInteger operator -( const CMaxLargeInteger &roSubstracted ) const
		{
			return CMaxLargeInteger( m_oValue.QuadPart - roSubstracted.m_oValue.QuadPart );
		}

		MAXPROFNOTHROW CMaxLargeInteger operator /( unsigned long lDivisor ) const
		{
			return CMaxLargeInteger( m_oValue.QuadPart / ( LONGLONG )lDivisor );
		}

		MAXPROFNOTHROW bool operator <( const CMaxLargeInteger &roCompared ) const
		{
			return m_oValue.QuadPart < roCompared.m_oValue.QuadPart;
		}

		MAXPROFNOTHROW operator LARGE_INTEGER*()
		{
			return &m_oValue;
		}

		MAXPROFNOTHROW LONG lFGetHighPart() const
		{
			return m_oValue.u.HighPart;
		}

		MAXPROFNOTHROW DWORD dwFGetLowPart() const
		{
			return m_oValue.u.LowPart;
		}

		MAXPROFNOTHROW double dFInSecondsF( const CMaxLargeInteger &roFreq ) const
		{
		const DWORD dwMaxDword = 0xffffffff;
		double highunit;
		
			assert( 0 == roFreq.m_oValue.u.HighPart && 0 != roFreq.m_oValue.u.LowPart );

			highunit = ( ( double )dwMaxDword + 1.0 ) / ( double )roFreq.m_oValue.u.LowPart;
			return ( ( ( double )m_oValue.u.HighPart * highunit ) + ( ( double )m_oValue.u.LowPart / roFreq.m_oValue.u.LowPart ) );
		}
};

MAXPROFNOTHROW inline ostream& operator<<( ostream &os, const CMaxLargeInteger &val )
{
	return os << "(" << ( unsigned long )val.lFGetHighPart() << ";" << ( unsigned long )val.dwFGetLowPart() << ")";
};





/*********************************************************************************
/* Class:
/*		CMaxTimerAbstraction
/* Comments:
/*		Defines the interface CMaxMiniProfiler's expect from any timer
/*		implementation
/********************************************************************************/
class CMaxTimerAbstraction
{
	protected:
		CMaxLargeInteger m_oTime;
		static const CMaxLargeInteger s_oFrequency;

	public:
		MAXPROFNOTHROW CMaxTimerAbstraction(){ /* assumed to zero its internal value */ }
		MAXPROFNOTHROW CMaxTimerAbstraction( int ){ ::QueryPerformanceCounter( m_oTime ); }
		MAXPROFNOTHROW CMaxTimerAbstraction( const CMaxTimerAbstraction &roSrc ) : m_oTime( roSrc.m_oTime ){}
		MAXPROFNOTHROW const CMaxTimerAbstraction& operator =( const CMaxTimerAbstraction &roSrc ){ m_oTime = roSrc.m_oTime; return *this; }

	protected:
		// Note: not part of the interface; for internal use only
		MAXPROFNOTHROW CMaxTimerAbstraction( const CMaxLargeInteger &roSrc ) : m_oTime( roSrc ){};

	public:
		MAXPROFNOTHROW void FLog()
		{
			::QueryPerformanceCounter( m_oTime );
		}

		MAXPROFNOTHROW double dFInSeconds() const
		{
			return m_oTime.dFInSecondsF( s_oFrequency );
		}

	public:
		MAXPROFNOTHROW void FAdd( const CMaxTimerAbstraction &roAdded )
		{
			m_oTime = m_oTime + roAdded.m_oTime;
		}

		MAXPROFNOTHROW void FSubstract( const CMaxTimerAbstraction &roSubstracted )
		{
#if 0
			// special case for negative differences - hide them
			if ( m_oTime < roSubstracted.m_oTime )
			{
				m_oTime = CMaxLargeInteger( 0, 1 );
				return;
			}
#endif

			m_oTime = m_oTime - roSubstracted.m_oTime;
		}

		MAXPROFNOTHROW void FDivide( unsigned long lDivisor )
		{
			m_oTime = m_oTime / lDivisor;
		}

	public:
		MAXPROFNOTHROW static CMaxTimerAbstraction oSSum( const CMaxTimerAbstraction &roArg1, const CMaxTimerAbstraction &roArg2 )
		{
		CMaxTimerAbstraction sum;

			sum.m_oTime = roArg1.m_oTime + roArg2.m_oTime;
			return sum;
		}

		MAXPROFNOTHROW static CMaxTimerAbstraction oSDifference( const CMaxTimerAbstraction &roArg1, const CMaxTimerAbstraction &roArg2 )
		{
		CMaxTimerAbstraction difference;

#if 0
			// special case for negative differences - hide them
			if ( roArg1.m_oTime < roArg2.m_oTime )
				return CMaxTimerAbstraction( CMaxLargeInteger( 0, 1 ) );
#endif

			difference.m_oTime = roArg1.m_oTime - roArg2.m_oTime;
			return difference;
		}

		MAXPROFNOTHROW static bool bSLess( const CMaxTimerAbstraction &roArg1, const CMaxTimerAbstraction &roArg2 )
		{
			return roArg1.m_oTime < roArg2.m_oTime;
		}

		MAXPROFNOTHROW static CMaxTimerAbstraction oSFrequency()
		{
			return CMaxTimerAbstraction( s_oFrequency );
		}

	private:
		MAXPROFNOTHROW static CMaxLargeInteger oSCentralFrequency()
		{
		CMaxLargeInteger frequency;

			::QueryPerformanceFrequency( frequency );
			return frequency;
		}

	friend ostream& operator<<( ostream &os, const CMaxTimerAbstraction &val );
};

MAXPROFNOTHROW inline ostream& operator<<( ostream &os, const CMaxTimerAbstraction &val )
{
	return os << val.m_oTime;
};






/*********************************************************************************
/* Class:
/*		CMaxMiniProfiler_Node_Base
/* Comments:
/*		Basic profiling node that behaves like a chronometer, and provides
/*		standard logging services.  Both the Standard and NoHistory profilers
/*		use this basic implementation
/********************************************************************************/
class CMaxMiniProfiler_Node_Base
{
	public:
		typedef CString MMPNBString;

	public:

		// comparison by index
		// -------------------

		class CCompareIndexes
		{
			public:
				MAXPROFNOTHROW bool operator()( const CMaxMiniProfiler_Node_Base &o1, const CMaxMiniProfiler_Node_Base &o2 ) const
				{
					assert( &o1 != &o2 );
					return ( o1.m_lIndex < o2.m_lIndex );
				};
		};
		friend CCompareIndexes;

	protected:

		// acquired at initialization
		// --------------------------

		unsigned long m_lLevel;
		const char *m_pszTitle;

		unsigned long m_lIndex;
		
		// internal time counting mechanism
		// --------------------------------

		CMaxTimerAbstraction m_taOrigin;
		CMaxTimerAbstraction m_taDelta;
		unsigned int m_nCount;
#ifdef _DEBUG
		bool m_bIsCounting;
#endif
		
		// for final output
		// ----------------

		double m_dDelta;

	public:

		// constructor etc.
		// ----------------
		// Note: uses default assignment and copy constructor
		// Note: it doesn't cost anything to initialize lots of things here - this
		//		 is not done within profiling braces

		MAXPROFNOTHROW CMaxMiniProfiler_Node_Base()
			: m_lLevel( 0 )
			, m_pszTitle( NULL )
			, m_lIndex( 0 )
			, m_nCount( 0 )
			, m_dDelta( 0 )
#ifdef _DEBUG
			, m_bIsCounting( false )
#endif
		{
		};

		// chrono
		// ------

		MAXPROFNOTHROW void FStart()
		{
#ifdef _DEBUG
			assert( !m_bIsCounting );
			m_taOrigin.FLog();
			m_nCount++;
			m_bIsCounting = true;
#else
			m_taOrigin.FLog();
			m_nCount++;
#endif
		};

		MAXPROFNOTHROW void FStop()
		{
		CMaxTimerAbstraction destination( 1 );

#ifdef _DEBUG
			assert( m_bIsCounting );
			m_taDelta.FAdd( CMaxTimerAbstraction::oSDifference( destination, m_taOrigin ) );
			m_bIsCounting = false;
#else
			m_taDelta.FAdd( CMaxTimerAbstraction::oSDifference( destination, m_taOrigin ) );
#endif
		};

		// access to members
		// -----------------

		MAXPROFNOTHROW unsigned long lFGetLevel() const { return m_lLevel; };
		MAXPROFNOTHROW const char *pszFGetTitle() const { return m_pszTitle; };
		MAXPROFNOTHROW unsigned long lFGetIndex() const { return m_lIndex; };
		MAXPROFNOTHROW const CMaxTimerAbstraction &roFGetOrigin() const { return m_taOrigin; };
		MAXPROFNOTHROW CMaxTimerAbstraction &roFGetDelta() { return m_taDelta; };
		MAXPROFNOTHROW unsigned int nFGetCount() const { return m_nCount; };

		MAXPROFNOTHROW double dFGetDelta()
		{
			if ( 0 == m_dDelta )
				FComputeDelta();
			return m_dDelta;
		};

		// misc. services
		// --------------

		MAXPROFNOTHROW bool bFIsIn( const CMaxMiniProfiler_Node_Base &roNode ) const
		{
			// Note: times cannot be equal, so we don't need to worry about that
			if ( CMaxTimerAbstraction::bSLess( m_taOrigin, roNode.m_taOrigin ) )
			{
			CMaxTimerAbstraction d1 = m_taOrigin;
			CMaxTimerAbstraction d2 = roNode.m_taOrigin;

				d1.FAdd( m_taDelta );
				d2.FAdd( roNode.m_taDelta );
				if ( CMaxTimerAbstraction::bSLess( d2, d1 ) )
					return true;
			}
			return false;
		};

		MAXPROFNOTHROW void FConditionalRemove( const CMaxMiniProfiler_Node_Base &roNode, const CMaxTimerAbstraction &roBias )
		{
			if ( bFIsIn( roNode ) )
			{
				CMaxTimerAbstraction d = roNode.m_taDelta;
				d.FAdd( roBias );
				m_taDelta.FSubstract( d );
			}
		};

		// output to file
		// --------------

		void FOutput( ostream &os )
		{
			// don't output dead (merged) nodes
			if ( 0 == m_nCount )
				return;

			// output our index
			os << setw( 10 ) << m_lIndex << ": ";

			// indent
			STab( os, m_lLevel );

			// output our title
			os << "@@Name=";
			if ( NULL != m_pszTitle )
				os << m_pszTitle;

			// output our block count
			os << " @@Count=" << m_nCount;

			// output our delta t
			os << " @@Duration=";
			SStampDeltaInSeconds( os, dFGetDelta() );
		};

		void FStampAbsoluteRange( ostream &os ) const
		{
			SStampAbsoluteRange( os, m_taOrigin, m_taDelta );
		};

	protected:

		// computations at output time (outside of profiling)
		// --------------------------------------------------

		MAXPROFNOTHROW void FComputeDelta()
		{
			m_dDelta = m_taDelta.dFInSeconds();
		};

	public:

		// mini helpers for facilitated and standardized output of results
		// ---------------------------------------------------------------

		static ostream& STab( ostream &os, int level )
		{
			for ( int i = 0; i < level; i++ )
				os << " ";
			return os;
		};

		static ostream& SStampDeltaInSeconds( ostream &os, double delta )
		{
			os << delta << "s";
			return os;
		};

		static ostream& SStampAbsoluteRange( ostream &os, const CMaxTimerAbstraction &rO, const CMaxTimerAbstraction &rD )
		{
			os << "[origin" << rO;
			os << ",duration" << rD << "]";
			return os;
		};
};





/*********************************************************************************
/* Classes:
/*		CMaxMiniProfiler_Node_Standard
/* Comments:
/********************************************************************************/
class CMaxMiniProfiler_Node_Standard
	: public CMaxMiniProfiler_Node_Base
{
	public:

		// comparison by full titles
		// -------------------------

		class CCompareFullTitles
		{
			public:
				MAXPROFNOTHROW bool operator()( const CMaxMiniProfiler_Node_Standard &o1, const CMaxMiniProfiler_Node_Standard &o2 ) const
				{
					assert( &o1 != &o2 );
					return ( o1.m_oFullTitle < o2.m_oFullTitle );
				};
		};
		friend CCompareFullTitles;

		// comparison for node merging (a) level, b) full title, c) index)
		// ---------------------------------------------------------------

		class CCompareForNodeMerging
		{
			public:
				MAXPROFNOTHROW bool operator()( const CMaxMiniProfiler_Node_Standard &o1, const CMaxMiniProfiler_Node_Standard &o2 ) const
				{
					assert( &o1 != &o2 );

					if ( o1.m_lLevel < o2.m_lLevel )
						return true;
					else if ( o1.m_lLevel == o2.m_lLevel )
					{
						if ( o1.m_oFullTitle < o2.m_oFullTitle )
							return true;
						else if ( o1.m_oFullTitle == o2.m_oFullTitle )
						{
							if ( o1.m_lIndex < o2.m_lIndex )
								return true;
						}
					}

					return false;
				};
		};
		friend CCompareForNodeMerging;

		// for the unique algorithm; modifies the parameters
		// -------------------------------------------------

		class CMergeSimilarNodes
		{
			public:
				MAXPROFNOTHROW bool operator()( CMaxMiniProfiler_Node_Standard &o1, CMaxMiniProfiler_Node_Standard &o2 )
				{
					assert( &o1 != &o2 );

					if ( ( o1.m_lLevel == o2.m_lLevel ) && 
						( o1.m_oFullTitle == o2.m_oFullTitle ) )
					{
						if ( o1.m_nCount > 0 && o2.m_nCount > 0 )
						{
						CMaxMiniProfiler_Node_Standard &kept = ( o1.m_lIndex < o2.m_lIndex ) ? o1 : o2;
						CMaxMiniProfiler_Node_Standard &thrown = ( o1.m_lIndex < o2.m_lIndex ) ? o2 : o1;

							kept.m_nCount++;
							kept.m_taDelta.FAdd( thrown.m_taDelta );
							kept.m_dDelta = 0;
		
							thrown.m_nCount = 0;
							thrown.m_taDelta = CMaxTimerAbstraction();
							thrown.m_dDelta = 0;
						}

						return true;
					}

					return false;
				};
		};
		friend CMergeSimilarNodes;

	protected:

		MMPNBString m_oFullTitle;

	public:

		// initialization
		// --------------

		MAXPROFNOTHROW void FInitialize( unsigned long lLevel, const char *pszTitle )
		{
			m_lLevel = lLevel;
			m_pszTitle = pszTitle;
		};

		MAXPROFNOTHROW void FIndex( unsigned long lIndex )
		{
			m_lIndex = lIndex;
		};

		MAXPROFNOTHROW void FSetFullTitle( const MMPNBString &roFullTitle )
		{
			m_oFullTitle = roFullTitle;
		};

		// access to members
		// -----------------

		MAXPROFNOTHROW const MMPNBString &roFGetFullTitle() const { return m_oFullTitle; };
};





/*********************************************************************************
/* Class:
/*		CMaxMiniProfiler_Node_NoHistory
/* Comments:
/********************************************************************************/
class CMaxMiniProfiler_Node_NoHistory
	: public CMaxMiniProfiler_Node_Base
{
	public:

		// unique key to a profiler node
		// -----------------------------

		class CKey
		{
			public:
				unsigned long m_lLevel;
				ULONG_PTR m_lCheckSum;
				const char *m_pszTitle;

			public:
				MAXPROFNOTHROW CKey(
					unsigned long lLevel = 0,
					const char *pszTitle = NULL,
					ULONG_PTR lCheckSum = 0 )
					: m_lLevel( lLevel )
					, m_lCheckSum( lCheckSum )
					, m_pszTitle( pszTitle )
				{
				};
		};

		// comparison of unique keys
		// -------------------------

		class CCompareKeys
		{
			public:
				MAXPROFNOTHROW bool operator()( const CKey &o1, const CKey &o2 ) const
				{
					assert( &o1 != &o2 );
					if ( o1.m_lLevel < o2.m_lLevel )
						return true;
					else if ( o1.m_lLevel == o2.m_lLevel )
					{
						if ( o1.m_pszTitle < o2.m_pszTitle )
							return true;
						else if ( o1.m_pszTitle == o2.m_pszTitle )
						{
							if ( o1.m_lCheckSum < o2.m_lCheckSum )
								return true;
						}
					}

					return false;
				};
		};

	protected:

		CMaxTimerAbstraction m_oInternalOverhead;
		ULONG_PTR m_lCheckSum;

	public:

		MAXPROFNOTHROW CMaxMiniProfiler_Node_NoHistory()
			: CMaxMiniProfiler_Node_Base()
			, m_lCheckSum( 0 )
		{
		};

		// initialization
		// --------------

		MAXPROFNOTHROW void FInitialize( 
			unsigned long lLevel, 
			const char *pszTitle, 
			unsigned long lIndex, 
			const CMaxTimerAbstraction oInternalOverhead )
		{
			if ( 0 == m_lIndex )
			{
				m_lLevel = lLevel;
				m_pszTitle = pszTitle;
				m_lIndex = lIndex;
			}
#ifdef _DEBUG
			else
			{
				assert( lLevel == m_lLevel );
				assert( pszTitle == m_pszTitle );
			}
#endif
			m_oInternalOverhead.FAdd( oInternalOverhead );
		};

		MAXPROFNOTHROW void FSetCheckSum( 
			ULONG_PTR lCheckSum )
		{
			m_lCheckSum = lCheckSum;
		};

		// access to members
		// -----------------

		MAXPROFNOTHROW const CMaxTimerAbstraction &roFGetInternalOverhead() const { return m_oInternalOverhead; };
		MAXPROFNOTHROW ULONG_PTR lFGetCheckSum() const { return m_lCheckSum; };
};





/*********************************************************************************
/* Class:
/*		CMaxMiniProfiler_Base
/* Comments:
/********************************************************************************/
class CMaxMiniProfiler_Base
{
	protected:
		// output file name
		const char *m_poFileName;

		// internal info
		DWORD m_dwThreadId;
		CTime m_oStartTimeOfProfilings;

	protected:
		// Note: the lock in CMaxMultithreadProfiler takes care of protecting
		//		 the static data below in multithread mode

		// default values for initialization
		static const char *s_poDefaultFileName;
		static unsigned long s_lHeapBlockSize;

		// BIAS values
		static CMaxTimerAbstraction s_oOutOfBraceBiasApproximation;
		static CMaxTimerAbstraction s_oInOfBraceBiasApproximation;
		static bool s_bBiasIsKnown;

	public:

		// constructor / destructor
		// ------------------------
		
		CMaxMiniProfiler_Base(
			const TCHAR * = NULL )
			: m_poFileName( s_poDefaultFileName )
			, m_dwThreadId( ::GetCurrentThreadId() )
			, m_oStartTimeOfProfilings( CTime::GetCurrentTime() )
		{
		};

		~CMaxMiniProfiler_Base()
		{
		};

		// locking - public interface
		// --------------------------

		void FLockProfiler(){};
		void FUnlockProfiler(){};

		// bias approximation
		// ------------------
		// Note: the result of this operation is used at output time uniquely

		bool bFIsBiasKnown() const { return s_bBiasIsKnown; };

	protected:

		// for final output
		// ----------------

		void FOutputEmptySession()
		{
			// open the output file
			ofstream os( m_poFileName, ios::out | ios::ate );

			// just stamp a message saying that there was nothing to profile
			CTime t = CTime::GetCurrentTime();
			os << endl;
			os << "PROFILER INSTANTIATED THE ";
			os << t.GetYear() << "/" << t.GetMonth() << "/" << t.GetDay() << " BETWEEN ";
			SStampCTime( os, m_oStartTimeOfProfilings ) << " AND ";
			SStampCTime( os, t ) << " WAS NOT USED." << endl;
		};

		void FOutputHeaderCore( 
			ostream &os, 
			unsigned long lNumberOfOpenNodes,
			const CMaxMiniProfiler_Node_Base &roRootNode,
			unsigned long lTotalNumberOfNodes )
		{
			// stamp the current time in our logfile
			CTime t = CTime::GetCurrentTime();
			os << endl;
			os << "***************************" << endl;
			os << "*** @@ProfilingDate=" << t.GetYear() << "/" << t.GetMonth() << "/" << t.GetDay() << endl;
			os << "*** @@ProfilingStartTime=";
			SStampCTime( os, m_oStartTimeOfProfilings ) << endl;
			os << "*** @@ProfilingEndTime=";
			SStampCTime( os, t ) << endl;
			os << "*** @@ProfilingRange=";
			roRootNode.FStampAbsoluteRange( os );
			os << endl;
			if ( 0 != lNumberOfOpenNodes )
				os << "*** "<< lNumberOfOpenNodes << " NODES WERE NOT CLOSED BY THE USER" << endl;
			os << "***************************" << endl;

			// output the counter's frequency and thread id
			os << "*** @@CounterFrequency=" << CMaxTimerAbstraction::oSFrequency() << endl;
			os << "*** @@ThreadId=" << ( unsigned long )m_dwThreadId << endl;

			// output the profiler's finest possible unit of measurement
			CMaxTimerAbstraction origin( 1 ), destination( 1 );
			CMaxTimerAbstraction delta( CMaxTimerAbstraction::oSDifference( destination, origin ) );
			os << "*** @@FinestMeasurement=";
			CMaxMiniProfiler_Node_Base::SStampDeltaInSeconds( os, delta.dFInSeconds() ) << "=" << delta << endl;

			// output the profiler's approximated bias
			assert( s_bBiasIsKnown );
			os << "*** @@OutsideBias=";
			CMaxMiniProfiler_Node_Base::SStampDeltaInSeconds( os, s_oOutOfBraceBiasApproximation.dFInSeconds() ) << endl;
			os << "*** @@InsideBias=";
			CMaxMiniProfiler_Node_Base::SStampDeltaInSeconds( os, s_oInOfBraceBiasApproximation.dFInSeconds() ) << endl;

			// output the total number of blocks
			os << "*** @@TotalNumberOfBlocks=" << lTotalNumberOfNodes << endl;
		};

		void FOutputMergedSectionHeader( ostream &os ) const
		{
			os << "*** @@MergedResults=" << endl;
		};

		bool bFHistoryOutputDisabled() const
		{
			return bGIsEnabledEnvVar( MAX_ENV_DISABLE_PROFILING_HISTORY );
		};

	public:
		static ostream& SStampCTime( ostream &os, const CTime &roTime )
		{
			os << roTime.GetHour() << ":" << roTime.GetMinute() << ":" << roTime.GetSecond();
			return os;
		};

	private:
		CMaxMiniProfiler_Base( const CMaxMiniProfiler_Base &o );
		const CMaxMiniProfiler_Base& operator =( const CMaxMiniProfiler_Base & );
};





/*********************************************************************************
/* Functions:
/*		GOutputProfilings
/*		lGGetNumberOfProfilingSubNodes
/*		lGDetermineMaxLevelOfProfilings
/*		GRemoveInAndOutBiasFromProfilingNodes
/* Comments:
/*		Done this way to avoid virtuals at node level (and to have common
/*		output code for Standard and NoHistory profilers)
/********************************************************************************/
template <class TVectorItem>
void GOutputProfilings( 
	ostream &os, 
	std::vector<TVectorItem> &roProfilings,
	unsigned long lMaxLevel,
	double dPrecisionThreshold,
	bool bOutputAbsoluteTimeRange )
{
std::vector<TVectorItem>::iterator i;
std::vector<TVectorItem>::size_type n;
std::vector<std::vector<TVectorItem>::size_type> parents( 1 + lMaxLevel );

	parents[ 0 ] = 0;
	
	for ( i = roProfilings.begin(), n = 0; roProfilings.end() != i; i++, n++ )
	{
		// signal the validity of the node
		assert( 0 != ( *i ).nFGetCount() );
		os << ( ( ( ( *i ).dFGetDelta() / ( *i ).nFGetCount() ) < dPrecisionThreshold ) ? "X" : " " );

		// output the node
		( *i ).FOutput( os );

		// register it as the last parent of its level
		long currentlevel = ( *i ).lFGetLevel();
		parents[ currentlevel ] = n;

		// output the % for all parents of the node
		os << " @@PERCENT=";
		double deltat = ( *i ).dFGetDelta();
		for ( long j = currentlevel - 1; j >= 0; j-- )
			os << 100.0 * deltat / roProfilings[ parents[ j ] ].dFGetDelta() << "% ";

		// output the time range in units
		if ( bOutputAbsoluteTimeRange )
		{
			os << " @@Range=";
			( *i ).FStampAbsoluteRange( os );
		}

		// finish output for this node
		os << endl;
	}
};

template <class TVectorItem, class TVectorIterator>
unsigned long lGGetNumberOfProfilingSubNodes( 
	const std::vector<TVectorItem> &roProfilings,
	TVectorIterator &roOrg )
{
unsigned long level = ( *roOrg ).lFGetLevel();
unsigned long n;
TVectorIterator i = roOrg;
	
	i++;
	for ( n = 0; roProfilings.end() != i; i++, n++ )
		if ( ( *i ).lFGetLevel() <= level )
			break;

	return n;
};

template <class TVectorItem>
unsigned long lGDetermineMaxLevelOfProfilings(
	const std::vector<TVectorItem> &roProfilings )
{
unsigned long l = 0;
std::vector<TVectorItem>::const_iterator i;

	for ( i = roProfilings.begin(); roProfilings.end() != i; i++ )
		if ( ( *i ).lFGetLevel() > l )
			l = ( *i ).lFGetLevel();

	return l;
};

template <class TVectorItem>
void GRemoveInAndOutBiasFromProfilingNodes(
	std::vector<TVectorItem> &roProfilings,
	const CMaxTimerAbstraction &roOutOfBraceBiasApproximation,
	const CMaxTimerAbstraction &roInOfBraceBiasApproximation )
{
std::vector<TVectorItem>::iterator i;
unsigned long t, k;

	for ( i = roProfilings.begin(); roProfilings.end() != i; i++ )
	{
		CMaxTimerAbstraction &rtaDelta = ( *i ).roFGetDelta();
		t = ::lGGetNumberOfProfilingSubNodes( roProfilings, i );
		for ( k = 0; k < t; k++ )
			rtaDelta.FSubstract( roOutOfBraceBiasApproximation );
		for ( k = 0; k < t + 1; k++ )
			rtaDelta.FSubstract( roInOfBraceBiasApproximation );
	}
};





/*********************************************************************************
/* Class:
/*		CMaxMiniProfiler_Standard
/* Comments:
/********************************************************************************/
class CMaxMiniProfiler_Standard
	: public CMaxMiniProfiler_Base
{
	protected:
		typedef std::vector<CMaxMiniProfiler_Node_Standard> MMPNodes;
		typedef MMPNodes::size_type MMPNodesRandomAccess;
		typedef std::vector<MMPNodesRandomAccess> MMPNodesReferences;
		typedef std::stack<MMPNodesRandomAccess, MMPNodesReferences> MMPStack;
		typedef MMPStack::size_type MMPStackSizeType;

	protected:
		// profiling nodes
		MMPNodes m_oProfilings;
		MMPNodesRandomAccess m_oLastNode;
		
		// stack for nested blocks
		MMPStack m_oStack;

		// heap acquisition timings
		MMPNodes m_oHeapAcquisitionTimings;

	public:

		// constructor / destructor
		// ------------------------
		
		CMaxMiniProfiler_Standard(
			const TCHAR *pszSpecificEnabler = NULL )
			: CMaxMiniProfiler_Base( pszSpecificEnabler )
			, m_oProfilings( 0 )
			, m_oLastNode( 0 )
			, m_oHeapAcquisitionTimings( 0 )
		{
			FInitDumpingSession();
		};

		~CMaxMiniProfiler_Standard()
		{
			FDumpSession();
			FTermDumpingSession();
		};

		// dumping results - public interface
		// ----------------------------------

		void FDumpResults( bool bForced = false, bool = true )
		{
			if ( !bForced )
			{
				// can dump results only when all profiling nodes are closed
				// (except the main one); we don't want to artificially close the nodes 
				// here at this point
				if ( 1 != m_oStack.size() )
				{
					assert( false );
					return;
				}
			}

			// dump
			FDumpSession();
			FTermDumpingSession();

			// prepare for next dump
			FInitDumpingSession();
		};

		// profiling nodes generation
		// --------------------------
		// Note: FCreateNewNode and FCloseCurrentNode are meant to be as fast as possible;
		//		 also, the bracket between FStart and FStop is as small as possible

		void FCreateNewNode( const char *pszTitle )
		{
			assert( ( 0 == m_oStack.size() ) || ( ::GetCurrentThreadId() == m_dwThreadId ) );

			if ( m_oProfilings.size() == m_oLastNode )
				FReserveMoreHeap();

			// Note: this is time constant
			m_oStack.push( m_oLastNode );
			CMaxMiniProfiler_Node_Standard &roNode = m_oProfilings[ m_oLastNode++ ];
			roNode.FInitialize( static_cast<ULONG>(m_oStack.size()) - 1, pszTitle );
			roNode.FStart();
		};

		void FCloseCurrentNode()
		{
			assert( ( 1 == m_oStack.size() ) || ( ::GetCurrentThreadId() == m_dwThreadId ) );

			// Note: this is time constant
			if ( m_oStack.size() > 0 )
			{
				m_oProfilings[ m_oStack.top() ].FStop();
				m_oStack.pop();
			}
			else
				assert( false );
		};

		// bias approximation
		// ------------------
		// Note: the result of this operation is used at output time uniquely

		void FSetBiasApproximationFrom( unsigned long lBiasSample )
		{
		unsigned int i;

			assert( !s_bBiasIsKnown );

			// Note: this function should be called immediately after having created 
			//		 1 BIAS (b) node
			//		 and x NOTHINGNESS (N) subnodes (n1 ... nx),
			//		 where x = lBiasSample
			assert( m_oLastNode > 1 + lBiasSample );
			
			// our out of brace bias is equal to (b - (n1 + n2 + ... + nx)) / x
			s_oOutOfBraceBiasApproximation = m_oProfilings[ m_oLastNode - ( 1 + lBiasSample ) ].roFGetDelta();
			for ( i = lBiasSample; i > 0; i-- )
				s_oOutOfBraceBiasApproximation.FSubstract( m_oProfilings[ m_oLastNode - i ].roFGetDelta() );
			s_oOutOfBraceBiasApproximation.FDivide( lBiasSample );

			// our in of brace bias is equal to ((n1 + n2 + ... + nx) - N.x) / x
			// Note: on purpose, we re-evaluate N as many times as there are samples
			s_oInOfBraceBiasApproximation = CMaxTimerAbstraction();
			CMaxTimerAbstraction delta;
			for ( i = lBiasSample; i > 0; i-- )
			{
				CMaxTimerAbstraction origin( 1 ), destination( 1 );
				delta.FAdd( CMaxTimerAbstraction::oSDifference( destination, origin ) );
				s_oInOfBraceBiasApproximation.FAdd( m_oProfilings[ m_oLastNode - i ].roFGetDelta() );
			}
			s_oInOfBraceBiasApproximation.FSubstract( delta );
			s_oInOfBraceBiasApproximation.FDivide( lBiasSample );

#if 1
			// remove those BIAS and NOTHINGNESS nodes from the profiler's output nodes
			MMPNodes::iterator iter;
			MMPNodesRandomAccess n;
			for ( iter = m_oProfilings.begin(), n = 0; ( m_oProfilings.end() != iter ) && ( n < m_oLastNode - ( 1 + lBiasSample ) ); iter++, n++ );
			std::fill( iter, m_oProfilings.end(), CMaxMiniProfiler_Node_Standard() );
			m_oLastNode -= ( 1 + lBiasSample );
#endif

			s_bBiasIsKnown = true;
		};

	protected:

		// dumping session management
		// --------------------------

		void FInitDumpingSession()
		{
			// prepare some heap
			FReserveMoreHeap();

			// put a main node
			FCreateNewNode( MAX_PROFTAGNODE_TOP );

			// verify that we start cleanly
			assert( 1 == m_oStack.size() );
			assert( 0 == m_oStack.top() );
		};

		void FDumpSession()
		{
		MMPStackSizeType lNumberOfOpenNodes;

			// terminate our main node
			FCloseCurrentNode();

			// make sure all nodes are closed
			lNumberOfOpenNodes = m_oStack.size();
			while ( !m_oStack.empty() )
				FCloseCurrentNode();

			if ( m_oLastNode > 1 )
			{
			unsigned long lMaxLevel;

				// final trimming and initializations
				FTrimProfilings();
				FIndexProfilings();
				lMaxLevel = ::lGDetermineMaxLevelOfProfilings( m_oProfilings );
				FComputeFullTitles( lMaxLevel );

				// open the output file
				ofstream os( m_poFileName, ios::out | ios::ate );

				// output the raw profilings
				FOutputHeader( os, lNumberOfOpenNodes );
				if ( !bFHistoryOutputDisabled() )
					FOutputProfilings( os, true, lMaxLevel );

				// merge nodes and output merged results
				FMergeProfilings();
				FOutputMergedSectionHeader( os );
				FOutputProfilings( os, false, lMaxLevel );
			}
			else
				FOutputEmptySession();
		};

		void FTermDumpingSession()
		{
			while ( !m_oStack.empty() )
				m_oStack.pop();

			m_oLastNode = 0;
			
			m_oProfilings.erase( m_oProfilings.begin(), m_oProfilings.end() );
			m_oHeapAcquisitionTimings.erase( m_oHeapAcquisitionTimings.begin(), m_oHeapAcquisitionTimings.end() );
		};

	protected:

		// for final output
		// ----------------

		void FOutputHeader( ostream &os, MMPStackSizeType lNumberOfOpenNodes )
		{
			FOutputHeaderCore( os, static_cast<ULONG>(lNumberOfOpenNodes), m_oProfilings[ 0 ], static_cast<ULONG>(m_oLastNode) );
			
			// output the total number of heap allocations
			double dTotalTimeInAllocations = m_oHeapAcquisitionTimings[ 0 ].dFGetDelta();
			for ( MMPNodes::iterator i = m_oHeapAcquisitionTimings.begin(); m_oHeapAcquisitionTimings.end() != i; i++ )
				dTotalTimeInAllocations += ( *i ).dFGetDelta();
			os << "*** @@TotalNumberOfHeapAllocations=" << static_cast<ULONG>(m_oHeapAcquisitionTimings.size()) << "=";
			CMaxMiniProfiler_Node_Base::SStampDeltaInSeconds( os, dTotalTimeInAllocations ) << endl;

			// output the total profiling overhead
			double dTotalOverhead = 
				( ( double )( m_oLastNode - 1.0 ) * s_oOutOfBraceBiasApproximation.dFInSeconds() ) + 
				( ( double )m_oLastNode * s_oInOfBraceBiasApproximation.dFInSeconds() );
			double dTotalOverheadPercent = 
				100.0 * ( dTotalOverhead / ( dTotalOverhead + m_oProfilings[ 0 ].dFGetDelta() ) );
			os << "*** @@TotalProfilerOverhead=" << dTotalOverheadPercent << "%=";
			CMaxMiniProfiler_Node_Base::SStampDeltaInSeconds( os, dTotalOverhead ) << endl;

			// that's it
			os << "***************************" << endl;
			os << "*** @@History=" << endl;
		};

		void FOutputProfilings( ostream &os, bool bOutputAbsoluteTimeRange, unsigned long lMaxLevel )
		{
		double dPrecisionThreshold = 2.0 * ( s_oOutOfBraceBiasApproximation.dFInSeconds() + s_oInOfBraceBiasApproximation.dFInSeconds() );

			::GOutputProfilings( os, m_oProfilings, lMaxLevel, dPrecisionThreshold, bOutputAbsoluteTimeRange );
		};

		// final management of profiling nodes
		// -----------------------------------

		void FTrimProfilings()
		{
		MMPNodes::iterator i, j;
		MMPNodesRandomAccess n;

			// find the iterator that corresponds to the last node
			for ( i = m_oProfilings.begin(), n = 0; ( m_oProfilings.end() != i ) && ( n < m_oLastNode ); i++, n++ );

			// remove uninitialized nodes
			m_oProfilings.erase( i, m_oProfilings.end() );

			// remove heap allocation timings from affected nodes
			for ( i = m_oHeapAcquisitionTimings.begin(); m_oHeapAcquisitionTimings.end() != i; i++ )
				for ( j = m_oProfilings.begin(); m_oProfilings.end() != j; j++ )
					( *j ).FConditionalRemove( *i, s_oOutOfBraceBiasApproximation );

			// remove from nodes the profiling bias
			::GRemoveInAndOutBiasFromProfilingNodes( 
				m_oProfilings, s_oOutOfBraceBiasApproximation, s_oInOfBraceBiasApproximation );
		};

		void FIndexProfilings()
		{
		MMPNodes::iterator i;
		unsigned long n;

			for ( i = m_oProfilings.begin(), n = 1; m_oProfilings.end() != i; i++, n++ )
				( *i ).FIndex( n );
		};

		void FComputeFullTitles( unsigned long lMaxLevel )
		{
		MMPNodes::iterator i;
		MMPNodesRandomAccess j, n;
		MMPNodesReferences parents( 1 + lMaxLevel );

			parents[ 0 ] = 0;
			
			for ( i = m_oProfilings.begin(), n = 0; m_oProfilings.end() != i; i++, n++ )
			{
				// register the node as the last parent of its level
				unsigned long currentlevel = ( *i ).lFGetLevel();
				parents[ currentlevel ] = n;

				// compute the iterated node's full title
				CMaxMiniProfiler_Node_Base::MMPNBString fulltitle;
				for ( j = 0; j <= currentlevel; j++ )				
					fulltitle += CMaxMiniProfiler_Node_Base::MMPNBString( m_oProfilings[ parents[ j ] ].pszFGetTitle() );
				( *i ).FSetFullTitle( fulltitle );
			}
		};

		void FMergeProfilings()
		{
		MMPNodes::iterator i;

			// sort by level/name/index
			std::sort( m_oProfilings.begin(), m_oProfilings.end(), CMaxMiniProfiler_Node_Standard::CCompareForNodeMerging() );

			// merge the nodes that have same level/name
			i = std::unique( m_oProfilings.begin(), m_oProfilings.end(), CMaxMiniProfiler_Node_Standard::CMergeSimilarNodes() );
			m_oProfilings.erase( i, m_oProfilings.end() );

			// sort by full name
			std::sort( m_oProfilings.begin(), m_oProfilings.end(), CMaxMiniProfiler_Node_Standard::CCompareFullTitles() );
		};

	protected:

		// heap management
		// ---------------

		void FReserveMoreHeap()
		{
		CMaxMiniProfiler_Node_Standard node;

			// log the time we used to generate new heap
			node.FStart();
			node.FInitialize( 0, MAX_PROFTAGNODE_HEAPALLOCATION );

			// reserve a new chunk of nodes
			m_oProfilings.reserve( m_oProfilings.size() + s_lHeapBlockSize );
			m_oProfilings.insert( m_oProfilings.end(), 
				m_oProfilings.capacity() - m_oProfilings.size(), 
				CMaxMiniProfiler_Node_Standard() );

			// that's it
			m_oHeapAcquisitionTimings.push_back( node );
			m_oHeapAcquisitionTimings.back().FStop();
		};

	private:
		CMaxMiniProfiler_Standard( const CMaxMiniProfiler_Standard &o );
		const CMaxMiniProfiler_Standard& operator =( const CMaxMiniProfiler_Standard & );
};





/*********************************************************************************
/* Class:
/*		CMaxMiniProfiler_NoHistory
/* Comments:
/*		This implementation is targetted for massive amounts of nodes
/********************************************************************************/
class CMaxMiniProfiler_NoHistory
	: public CMaxMiniProfiler_Base
{
	protected:
		typedef CMaxMiniProfiler_Node_NoHistory::CKey MMPNHKey;
		typedef CMaxMiniProfiler_Node_NoHistory::CCompareKeys MMPNHKeyCompare;
		typedef std::map<MMPNHKey, CMaxMiniProfiler_Node_NoHistory, MMPNHKeyCompare> MMPNHNodes;
		typedef MMPNHNodes::iterator MMPNHNodesIterator;
		typedef std::vector<MMPNHNodesIterator> MMPNHNodesReferences;
		typedef std::stack<MMPNHNodesIterator, MMPNHNodesReferences> MMPNHStack;
		typedef MMPNHStack::size_type MMPNHStackSizeType;

	protected:
		typedef std::vector<CMaxMiniProfiler_Node_NoHistory> MMPNHFinalNodes;
		typedef MMPNHFinalNodes::iterator MMPNHFinalNodesIterator;

	protected:
		// profiling nodes
		MMPNHNodes m_oProfilings;
		unsigned long m_lLastNode;
		
		// stack for nested blocks
		MMPNHStack m_oStack;

	public:

		// constructor / destructor
		// ------------------------
		
		CMaxMiniProfiler_NoHistory(
			const TCHAR *pszSpecificEnabler = NULL )
			: CMaxMiniProfiler_Base( pszSpecificEnabler )
			, m_lLastNode( 0 )
		{
			FInitDumpingSession();
		};

		~CMaxMiniProfiler_NoHistory()
		{
			FDumpSession();
			FTermDumpingSession();
		};

		// dumping results - public interface
		// ----------------------------------

		void FDumpResults( bool bForced = false, bool = true )
		{
			if ( !bForced )
			{
				// can dump results only when all profiling nodes are closed
				// (except the main one); we don't want to artificially close the nodes 
				// here at this point
				if ( 1 != m_oStack.size() )
				{
					assert( false );
					return;
				}
			}

			// dump
			FDumpSession();
			FTermDumpingSession();

			// prepare for next dump
			FInitDumpingSession();
		};

		// profiling nodes generation
		// --------------------------
		// Note: FCreateNewNode and FCloseCurrentNode are meant to be as fast as possible;
		//		 also, the bracket between FStart and FStop is as small as possible

		void FCreateNewNode( const char *pszTitle )
		{
		MMPNHNodesIterator i;

			assert( ( 0 == m_oStack.size() ) || ( ::GetCurrentThreadId() == m_dwThreadId ) );

			// A) this is not time constant
			// ----------------------------
			// Note: therefore we measure how much time we spend here

			CMaxTimerAbstraction before( 1 );
			{
				// compute the checksum
				ULONG_PTR lCheckSum = ( ULONG_PTR )pszTitle;
				if ( !m_oStack.empty() )
					lCheckSum += ( *m_oStack.top() ).first.m_lCheckSum;

				// compute the key
				MMPNHKey oKey( static_cast<unsigned long>(m_oStack.size()), pszTitle, lCheckSum );

				// get the corresponding node, if any
				i = m_oProfilings.find( oKey );

				// otherwise, create a new node
				if ( m_oProfilings.end() == i )
					i = m_oProfilings.insert( MMPNHNodes::value_type( oKey, CMaxMiniProfiler_Node_NoHistory() ) ).first;
			}
			CMaxTimerAbstraction after( 1 );

			// B) this is time constant
			// ------------------------
			// Note: therefore taken care of by bias computation

			CMaxTimerAbstraction oInternalOverhead( CMaxTimerAbstraction::oSDifference( after, before ) );

			m_lLastNode++;
			( *i ).second.FInitialize( static_cast<unsigned long>(m_oStack.size()), pszTitle, m_lLastNode, oInternalOverhead );
			m_oStack.push( i );
			( *i ).second.FStart();
		};

		void FCloseCurrentNode()
		{
			assert( ( 1 == m_oStack.size() ) || ( ::GetCurrentThreadId() == m_dwThreadId ) );

			// Note: this is time constant
			if ( m_oStack.size() > 0 )
			{
				( *m_oStack.top() ).second.FStop();
				m_oStack.pop();
			}
			else
				assert( false );
		};

		// bias approximation
		// ------------------
		// Note: the result of this operation is used at output time uniquely

		void FSetBiasApproximationFrom( unsigned long lBiasSample )
		{
		unsigned int i;
		MMPNHNodes::iterator j, j1, j2;
		CMaxTimerAbstraction b, n, ib;

			assert( !s_bBiasIsKnown );

			// Note: this function should be called immediately after having created 
			//		 1 BIAS (b) node
			//		 and x NOTHINGNESS (N) subnodes (n1 ... nx),
			//		 where x = lBiasSample
			assert( m_lLastNode > 1 + lBiasSample );
			
			// find bias and nothingness nodes
			// Note: here we search by name, because it's not time critical and
			//		 we don't know the checksum
			CMaxMiniProfiler_Node_Base::MMPNBString id_bias( MAX_PROFTAGNODE_BIAS );
			CMaxMiniProfiler_Node_Base::MMPNBString id_nothingness( MAX_PROFTAGNODE_NOTHINGNESS );
			char cDone = 0;
			for ( j = m_oProfilings.begin(); ( m_oProfilings.end() != j ) && ( ( 1 | 2 ) != cDone ); j++ )
			{
			CMaxMiniProfiler_Node_Base::MMPNBString id_iterated( ( *j ).second.pszFGetTitle() );

				if ( id_iterated == id_bias )
				{
					assert( !( cDone & 1 ) );
					b = ( *j ).second.roFGetDelta();
					j1 = j;
					cDone |= 1;
				}
				else if ( id_iterated == id_nothingness )
				{
					assert( !( cDone & 2 ) );
					n = ( *j ).second.roFGetDelta();
					ib = ( *j ).second.roFGetInternalOverhead();
					j2 = j;
					cDone |= 2;
				}
			}
			assert( ( 1 | 2 ) == cDone );
			if ( cDone & 1 )
				m_oProfilings.erase( j1 );
			if ( cDone & 2 )
				m_oProfilings.erase( j2 );

			// our out of brace bias is equal to (b - (n1 + n2 + ... + nx) - (ib1 + ib2 + ... + ibx)) / x
			// Note: ib is the internal bias (or overhead), and is taken care of separately
			s_oOutOfBraceBiasApproximation = b;
			s_oOutOfBraceBiasApproximation.FSubstract( n );
			s_oOutOfBraceBiasApproximation.FSubstract( ib );
			s_oOutOfBraceBiasApproximation.FDivide( lBiasSample );

			// our in of brace bias is equal to ((n1 + n2 + ... + nx) - N.x) / x
			// Note: on purpose, we re-evaluate N as many times as there are samples
			CMaxTimerAbstraction delta;
			for ( i = lBiasSample; i > 0; i-- )
			{
				CMaxTimerAbstraction origin( 1 ), destination( 1 );
				delta.FAdd( CMaxTimerAbstraction::oSDifference( destination, origin ) );
			}
			s_oInOfBraceBiasApproximation = n;
			s_oInOfBraceBiasApproximation.FSubstract( delta );
			s_oInOfBraceBiasApproximation.FDivide( lBiasSample );

			s_bBiasIsKnown = true;
		};

	protected:

		// dumping session management
		// --------------------------

		void FInitDumpingSession()
		{
			// put a main node
			FCreateNewNode( MAX_PROFTAGNODE_TOP );

			// verify that we start cleanly
			assert( 1 == m_oStack.size() );
		};

		void FDumpSession()
		{
		MMPNHStackSizeType lNumberOfOpenNodes;
		MMPNHFinalNodes oFinalNodes;
		unsigned long lMaxLevel;

			// terminate our main node
			FCloseCurrentNode();

			// make sure all nodes are closed
			lNumberOfOpenNodes = m_oStack.size();
			while ( !m_oStack.empty() )
				FCloseCurrentNode();

			// get the final list of nodes, sorted by index
			FGetFinalNodes( oFinalNodes );

			if ( oFinalNodes.size() > 1 )
			{
				// final trimming and initializations
				::GRemoveInAndOutBiasFromProfilingNodes( 
					oFinalNodes, s_oOutOfBraceBiasApproximation, s_oInOfBraceBiasApproximation );
				lMaxLevel = ::lGDetermineMaxLevelOfProfilings( oFinalNodes );
				CMaxTimerAbstraction oTotalInternalOverhead = oFRemoveInternalOverheadFromFinalNodes( oFinalNodes );

				// open the output file
				ofstream os( m_poFileName, ios::out | ios::ate );

				// output the raw profilings
				FOutputHeader( oFinalNodes, os, lNumberOfOpenNodes, oTotalInternalOverhead );
				FOutputFinalNodes( oFinalNodes, os, lMaxLevel );
			}
			else
				FOutputEmptySession();
		};

		void FTermDumpingSession()
		{
			while ( !m_oStack.empty() )
				m_oStack.pop();

			m_oProfilings.erase( m_oProfilings.begin(), m_oProfilings.end() );
		};

	protected:

		// for final output
		// ----------------

		void FOutputHeader( 
			MMPNHFinalNodes &roFinalNodes,
			ostream &os, 
			MMPNHStackSizeType lNumberOfOpenNodes,
			const CMaxTimerAbstraction &roTotalInternalOverhead )
		{
			FOutputHeaderCore( os, static_cast<unsigned long>(lNumberOfOpenNodes), roFinalNodes[ 0 ], m_lLastNode );

			// output the total profiling overhead
			double dTotalOverhead = 
				( ( double )( m_lLastNode - 1.0 ) * s_oOutOfBraceBiasApproximation.dFInSeconds() ) + 
				( ( double )m_lLastNode * s_oInOfBraceBiasApproximation.dFInSeconds() ) +
				roTotalInternalOverhead.dFInSeconds();
			double dTotalOverheadPercent = 
				100.0 * ( dTotalOverhead / ( dTotalOverhead + roFinalNodes[ 0 ].dFGetDelta() ) );
			os << "*** @@TotalProfilerOverhead=" << dTotalOverheadPercent << "%=";
			CMaxMiniProfiler_Node_Base::SStampDeltaInSeconds( os, dTotalOverhead ) << endl;

			// that's it
			os << "***************************" << endl;
			FOutputMergedSectionHeader( os );
		};

		// final management of profiling nodes
		// -----------------------------------

		void FGetFinalNodes( MMPNHFinalNodes &roFinalNodes )
		{
			assert( !m_oProfilings.empty() );

			// copy the map of profiling nodes into a simple vector
			for ( MMPNHNodes::iterator i = m_oProfilings.begin(); m_oProfilings.end() != i; i++ )
			{
				( *i ).second.FSetCheckSum( ( *i ).first.m_lCheckSum );
				roFinalNodes.push_back( ( *i ).second );
			}

			// sort the vector by nodes indexes
			std::sort( roFinalNodes.begin(), roFinalNodes.end(), CMaxMiniProfiler_Node_Base::CCompareIndexes() );

			// reparent the lost nodes
			// Note: sorting by nodes indexes is not good enough when the profiled code has some
			//		 conditional branches; suppose a new node appears in a branch, its index might
			//		 be greater than nodes that don't belong to that branch; therefore reparenting
			//		 those lost nodes is necessary
			// Note: top node doesn't have a parent, so skip it
			// Note: this algorithm is O(n2) right now, and could be improved, but since it is
			//		 executed at output time only, I don't care
			MMPNHFinalNodesIterator j = roFinalNodes.begin();
			j++;
			while ( roFinalNodes.end() != j )
			{
			const MMPNHFinalNodesIterator oldj = j;
			bool bWrongParent = false;
			unsigned long lTargetLevel = ( *j ).lFGetLevel() - 1;
			ULONG_PTR lTargetCheckSum = ( *j ).lFGetCheckSum() - ( ULONG_PTR )( *j ).pszFGetTitle();

				// find the real parent of j (must appear before j in the sorted vector)
				for ( MMPNHFinalNodesIterator k = j; roFinalNodes.end() != k; k-- )
				{
				unsigned long lIteratedLevel = ( *k ).lFGetLevel();

					// the real parent must have a level equal to lTargetLevel
					if ( lIteratedLevel != lTargetLevel )
					{
						// maybe j didn't even have an immediate wrong parent
						if ( lIteratedLevel < lTargetLevel )
							bWrongParent = true;
						continue;
					}

					// the parent must have a checksum equal to lTargetCheckSum, 
					// otherwise it is a wrong parent
					if ( ( *k ).lFGetCheckSum() != lTargetCheckSum )
						bWrongParent = true;

					// we found the real parent
					else
					{
						// if no wrong parent was encountered, nothing to do
						if ( !bWrongParent )
						{
							j++;
							break;
						}

						// otherwise, we must move the node below its real parent
						else
						{
						CMaxMiniProfiler_Node_NoHistory nodecopy = *j;

							j++;
							k++;
							roFinalNodes.erase( oldj );
							roFinalNodes.insert( k, nodecopy );

							bWrongParent = false;
							break;
						}
					}
				}

				assert( !bWrongParent );
				assert( oldj != j );
			}
		}

		CMaxTimerAbstraction oFRemoveInternalOverheadFromFinalNodes( MMPNHFinalNodes &roFinalNodes )
		{
		CMaxTimerAbstraction oTotalOverhead;
		MMPNHFinalNodes::iterator i;
		std::vector<MMPNHFinalNodesIterator> parents;
		std::vector<MMPNHFinalNodesIterator>::iterator j;
		unsigned long l, s;

			for ( i = roFinalNodes.begin(); roFinalNodes.end() != i; i++ )
			{
				// get the current node level (l) and stack of parents size (s)
				l = ( *i ).lFGetLevel();
				s = static_cast<unsigned long>(parents.size());

				// get the iterated node's internal overhead
				const CMaxTimerAbstraction &roOverhead = ( *i ).roFGetInternalOverhead();
				oTotalOverhead.FAdd( roOverhead );

				// update the stack of parents
				if ( s > 0 )
				{
					while ( s > l )
					{
						parents.pop_back();
						s--;
					}
				}
				assert( l == s );

				// remove internal overhead from all parents
				for ( j = parents.begin(); parents.end() != j; j++ )
				{
					assert( ( *j ) != i );
					CMaxTimerAbstraction &rtaDelta = ( *( *j ) ).roFGetDelta();
					rtaDelta.FSubstract( roOverhead );
				}

				// insert the current node in the stack of parents
				parents.push_back( i );
			}

			return oTotalOverhead;
		};

		void FOutputFinalNodes( MMPNHFinalNodes &roFinalNodes, ostream &os, unsigned long lMaxLevel )
		{
		double dPrecisionThreshold = 2.0 * ( s_oOutOfBraceBiasApproximation.dFInSeconds() + s_oInOfBraceBiasApproximation.dFInSeconds() );

			::GOutputProfilings( os, roFinalNodes, lMaxLevel, dPrecisionThreshold, false );
		};

	private:
		CMaxMiniProfiler_NoHistory( const CMaxMiniProfiler_NoHistory &o );
		const CMaxMiniProfiler_NoHistory& operator =( const CMaxMiniProfiler_NoHistory & );
};





/*********************************************************************************
/* Class:
/*		CMaxMultithreadProfiler
/* Comments:
/*		Instantiates and manages one CMaxMiniProfiler per calling thread
/********************************************************************************/
template <class TMiniProfiler>
class CMaxMultithreadProfiler
{
	protected:
		typedef std::less<DWORD> MTPThreadIdsCompare;
		typedef std::map<DWORD, TMiniProfiler*, MTPThreadIdsCompare> MTPMap;

	protected:
		class __CMaxCriticalSection
		{
			protected:
				CRITICAL_SECTION m_oNTCriticalSection;

			public:
				__CMaxCriticalSection(){ ::InitializeCriticalSection( &m_oNTCriticalSection ); };
				~__CMaxCriticalSection(){ ::DeleteCriticalSection( &m_oNTCriticalSection ); };

				bool Lock() const { ::EnterCriticalSection( &( ( __CMaxCriticalSection * )this )->m_oNTCriticalSection ); return true; };
				bool Unlock() const { ::LeaveCriticalSection( &( ( __CMaxCriticalSection * )this )->m_oNTCriticalSection ); return true; };
			
				operator CRITICAL_SECTION*() const { return ( CRITICAL_SECTION* )&m_oNTCriticalSection; };
		};

	protected:
		MTPMap m_oProfilers;
		__CMaxCriticalSection m_oLockProfilers;

	public:
		CMaxMultithreadProfiler(
			const TCHAR * = NULL )
		{
			m_oProfilers[ ::GetCurrentThreadId() ] = new TMiniProfiler();
		};

		~CMaxMultithreadProfiler()
		{
			if ( !m_oProfilers.empty() )
				FFlushProfilers();
		};

		void FLockProfiler()
		{
			m_oLockProfilers.Lock();
		};

		void FUnlockProfiler()
		{
			m_oLockProfilers.Unlock();
		};

		void FDumpResults( bool bForced = false, bool bCurrentThreadOnly = true )
		{
			m_oLockProfilers.Lock();
			{
			DWORD id = ::GetCurrentThreadId();
			MTPMap::iterator i;

				if ( m_oProfilers.empty() )
				{
					m_oLockProfilers.Unlock();
					return;
				}

				for ( i = m_oProfilers.begin(); m_oProfilers.end() != i; i++ )
					if ( !bCurrentThreadOnly || ( ( *i ).first == id ) )
						( *i ).second->FDumpResults( bForced ); 

				if ( bForced )
					FFlushProfilers();
			}
			m_oLockProfilers.Unlock();
		};

		void FCreateNewNode( const char *pszTitle )
		{ 
			m_oLockProfilers.Lock();
			{
			DWORD id = ::GetCurrentThreadId();
			MTPMap::iterator i = m_oProfilers.find( id );

				if ( m_oProfilers.end() != i )
					( *i ).second->FCreateNewNode( pszTitle ); 
				else
				{
				TMiniProfiler *pNewProfiler = new TMiniProfiler();
					
					m_oProfilers[ id ] = pNewProfiler;
					pNewProfiler->FCreateNewNode( pszTitle ); 
				}
			}
			m_oLockProfilers.Unlock();
		};
		
		void FCloseCurrentNode()
		{ 
			m_oLockProfilers.Lock();
			{
			DWORD id = ::GetCurrentThreadId();
			MTPMap::iterator i = m_oProfilers.find( id );

				assert( m_oProfilers.end() != i );
				( *i ).second->FCloseCurrentNode(); 
			}
			m_oLockProfilers.Unlock();
		};

		bool bFIsBiasKnown() const 
		{ 
		bool b;

			m_oLockProfilers.Lock();
			assert( !m_oProfilers.empty() );
			b = ( *m_oProfilers.begin() ).second->bFIsBiasKnown();
			m_oLockProfilers.Unlock();

			return b;
		};

		void FSetBiasApproximationFrom( unsigned long lBiasSample )
		{
			m_oLockProfilers.Lock();
			assert( !m_oProfilers.empty() );
			( *m_oProfilers.begin() ).second->FSetBiasApproximationFrom( lBiasSample );
			m_oLockProfilers.Unlock();
		};

	protected:
		void FFlushProfilers()
		{
			m_oLockProfilers.Lock();
			assert( !m_oProfilers.empty() );
			for ( MTPMap::iterator i = m_oProfilers.begin(); m_oProfilers.end() != i; i++ )
				delete ( *i ).second;
			m_oProfilers.erase( m_oProfilers.begin(), m_oProfilers.end() );
			m_oLockProfilers.Unlock();
		};

	private:
		CMaxMultithreadProfiler( const CMaxMultithreadProfiler &o );
		const CMaxMultithreadProfiler& operator =( const CMaxMultithreadProfiler & );
};
#endif // }





#ifdef MAX_PROFILING_ENABLED_DLL // {
/*********************************************************************************
/* Class:
/*		CMaxProfilingDLLWrapper
/* Comments:
/*		For simplified use through the macros defined above
/********************************************************************************/
class CMaxProfilingDLLWrapper
{
	protected:
		class __CMaxLoadLibrary
		{
			protected:
				HINSTANCE m_hLibrary;

			public:
				__CMaxLoadLibrary( LPCTSTR pszLibraryFileName )
					: m_hLibrary( NULL )
				{
					if ( NULL != pszLibraryFileName )
						m_hLibrary = ::LoadLibrary( pszLibraryFileName );
				};

				~__CMaxLoadLibrary()
				{
					if ( NULL != m_hLibrary )
						::FreeLibrary( m_hLibrary );
				};

				operator HINSTANCE() const
				{ 
					return m_hLibrary; 
				};
		};

	protected:
		__CMaxLoadLibrary m_oLibrary;

	protected:
		void ( *m_pfn_LockProfiler )();
		void ( *m_pfn_UnlockProfiler )();
		void ( *m_pfn_DumpResults )( bool, bool );
		void ( *m_pfn_CreateNewNode )( const char * );
		void ( *m_pfn_CloseCurrentNode )();
		bool ( *m_pfn_IsBiasKnown )();
		void ( *m_pfn_SetBiasApproximationFrom )( unsigned long );

	protected:
		static void SLockProfiler_Bogus(){};
		static void SUnlockProfiler_Bogus(){};
		static void SDumpResults_Bogus( bool, bool ){};
		static void SCreateNewNode_Bogus( const char * ){};
		static void SCloseCurrentNode_Bogus(){};
		static bool bSIsBiasKnown_Bogus(){ return true; };
		static void SSetBiasApproximationFrom_Bogus( unsigned long ){};

	public:
		CMaxProfilingDLLWrapper(
			const TCHAR *pszSpecificEnabler = NULL )
#ifndef unix
			: m_oLibrary( _T( "s:\\ds\\util\\maxprof.dll" ) )
#else
			: m_oLibrary( NULL )
#endif
			, m_pfn_LockProfiler( NULL )
			, m_pfn_UnlockProfiler( NULL )
			, m_pfn_DumpResults( NULL )
			, m_pfn_CreateNewNode( NULL )
			, m_pfn_CloseCurrentNode( NULL )
			, m_pfn_IsBiasKnown( NULL )
			, m_pfn_SetBiasApproximationFrom( NULL )
		{
			// if the profiler is enabled, get the dll's entry points for profiling
			// (if possible)
			if ( bFProfilerEnabled( pszSpecificEnabler ) &&
				( NULL != ( HINSTANCE )m_oLibrary ) )
			{
				m_pfn_LockProfiler = ( void ( * )() )::GetProcAddress( m_oLibrary, "LockProfiler" );
				assert( NULL != m_pfn_LockProfiler );

				m_pfn_UnlockProfiler = ( void ( * )() )::GetProcAddress( m_oLibrary, "UnlockProfiler" );
				assert( NULL != m_pfn_UnlockProfiler );
				
				m_pfn_DumpResults = ( void ( * )( bool, bool ) )::GetProcAddress( m_oLibrary, "DumpResults" );
				assert( NULL != m_pfn_DumpResults );

				m_pfn_CreateNewNode = ( void ( * )( const char * ) )::GetProcAddress( m_oLibrary, "CreateNewNode" );
				assert( NULL != m_pfn_CreateNewNode );

				m_pfn_CloseCurrentNode = ( void ( * )() )::GetProcAddress( m_oLibrary, "CloseCurrentNode" );
				assert( NULL != m_pfn_CloseCurrentNode );

				m_pfn_IsBiasKnown = ( bool ( * )() )::GetProcAddress( m_oLibrary, "IsBiasKnown" );
				assert( NULL != m_pfn_IsBiasKnown );

				m_pfn_SetBiasApproximationFrom = ( void ( * )( unsigned long ) )::GetProcAddress( m_oLibrary, "SetBiasApproximationFrom" );
				assert( NULL != m_pfn_SetBiasApproximationFrom );
			}

			// otherwise, create bogus entry points
			// Note: this technique is preferred to using "if"s on each call, so this
			//		 switch does not affect the profiling mode at all
			else
			{
				m_pfn_LockProfiler = SLockProfiler_Bogus;
				m_pfn_UnlockProfiler = SUnlockProfiler_Bogus;
				m_pfn_DumpResults = SDumpResults_Bogus;
				m_pfn_CreateNewNode = SCreateNewNode_Bogus;
				m_pfn_CloseCurrentNode = SCloseCurrentNode_Bogus;
				m_pfn_IsBiasKnown = bSIsBiasKnown_Bogus;
				m_pfn_SetBiasApproximationFrom = SSetBiasApproximationFrom_Bogus;
			}
		};

		// Note: this is the easiest way to avoid a severe bug in the DLL version of the
		//		 profiler; basically, if a client DLL detaches the profiled process, the 
		//		 "titles" maintained by address by the profiling nodes become invalid, and 
		//		 can no longer be dereferenced; therefore, to avoid this problem, I make 
		//		 sure all profiling nodes are dumped when a client DLL detaches.  This
		//		 may affect results in some circumstances, but should be OK in most cases
		~CMaxProfilingDLLWrapper()
			{ FDumpResults( true, false ); };

		void FLockProfiler()
			{ ( *m_pfn_LockProfiler )(); };
		void FUnlockProfiler()
			{ ( *m_pfn_UnlockProfiler )(); };
		void FDumpResults( bool bForced = false, bool bCurrentThreadOnly = true )
			{ ( *m_pfn_DumpResults )( bForced, bCurrentThreadOnly ); };
		void FCreateNewNode( const char *pszTitle )
			{ ( *m_pfn_CreateNewNode )( pszTitle ); };
		void FCloseCurrentNode()
			{ ( *m_pfn_CloseCurrentNode )(); };
		bool bFIsBiasKnown() const
			{ return ( *m_pfn_IsBiasKnown )(); };
		void FSetBiasApproximationFrom( unsigned long lBiasSample )
			{ ( *m_pfn_SetBiasApproximationFrom )( lBiasSample ); };

	protected:
#ifdef MAX_PROFILING_CONDITIONAL
		bool bFProfilerEnabled( 
			const TCHAR *pszSpecificEnabler ) const
		{
			// Note: the global enabler allows you to enable/disable
			//		 all "subsystems" at once
			// Note: the specific enabler allows you to enable/disable
			//		 specific "subsystems", given that the global
			//		 enabler is set
			return ( bGIsEnabledEnvVar( MAX_ENV_ENABLE_PROFILING, MAX_ENV_ALL ) ||
				( bGIsEnabledEnvVar( pszSpecificEnabler ) && bGIsEnabledEnvVar( MAX_ENV_ENABLE_PROFILING ) ) );
		}
#else
		bool bFProfilerEnabled( const TCHAR * ) const
		{
			return true;
		}
#endif
};
#endif // }





#if defined MAX_PROFILING_ENABLED || defined MAX_PROFILING_ENABLED_DLL // {
//#ifdef _DEBUG
//	#pragma message( "MAXPROFILER Warning: beware of profilings generated with a DEBUG build." )
//#endif
/*********************************************************************************
/* Class:
/*		CMaxProfilingObject
/* Comments:
/*		For simplified use through the macros defined above.  The typedef
/*		allows easy substitution between multi-threaded (default) and 
/*		single-threaded profilers
/********************************************************************************/
class CMaxProfilingObject
{
	public:
#ifdef MAX_PROFILING_ENABLED_DLL
		typedef CMaxProfilingDLLWrapper MPOProfiler;
#else
		typedef CMaxMultithreadProfiler<CMaxMiniProfiler_Standard> MPOProfiler;
#endif

	protected:
		static MPOProfiler s_oProfiler;

	protected:
		class __CBiasApproximation
		{
			public:
				__CBiasApproximation()
				{
				const unsigned long lBiasSample = 20;

					// if bias has already been computed once, do nothing
					if ( CMaxProfilingObject::s_oProfiler.bFIsBiasKnown() )
						return;

					// compute bias through the used profiler
					CMaxProfilingObject::s_oProfiler.FLockProfiler();
					{
						CMaxProfilingObject::SCreateNewNode( MAX_PROFTAGNODE_BIAS );
						for ( int i = 0; i < lBiasSample; i++ )
						{
							CMaxProfilingObject::SCreateNewNode( MAX_PROFTAGNODE_NOTHINGNESS );
							CMaxProfilingObject::SCloseCurrentNode();
						}
						CMaxProfilingObject::SCloseCurrentNode();

						CMaxProfilingObject::s_oProfiler.FSetBiasApproximationFrom( lBiasSample );
					}
					CMaxProfilingObject::s_oProfiler.FUnlockProfiler();
				};
		};
		friend __CBiasApproximation;

	protected:
		static __CBiasApproximation s_oBiasApproximation;

	public:
		static void SDumpResults( bool bForced = false, bool bCurrentThreadOnly = true )
			{ s_oProfiler.FDumpResults( bForced, bCurrentThreadOnly ); };
		static void SCreateNewNode( const char *pszTitle )
			{ s_oProfiler.FCreateNewNode( pszTitle ); };
		static void SCloseCurrentNode()
			{ s_oProfiler.FCloseCurrentNode(); };
};
#endif // }





#ifndef MAX_PROFILING_DLL_IMPLEMENTATION // {
/*********************************************************************************
/* Class:
/*		CMaxProfilingBlockWrapper
/* Comments:
/*		As a substitute to the macros (Ray's request).  Hoping that those inlines
/*		disappear completely when profiling is turned off.  The alternative
/*		would have been to define a new set of macros taking an additional
/*		parameter (a unique name for each instance of the wrapper within the
/*		same scope)
/* Note:
/*		I use nothrow here, but the current implementations don't guaranty
/*		that no exception will be thrown
/********************************************************************************/
class CMaxProfilingBlockWrapper
{
	public:
		MAXPROFNOTHROW CMaxProfilingBlockWrapper( const char *pszTitle )
			{ BEGIN_PROFILING_BLOCK( pszTitle ); };
		MAXPROFNOTHROW ~CMaxProfilingBlockWrapper()
			{ END_PROFILING_BLOCK; };

	public:
		MAXPROFNOTHROW static void SDump()
			{ DUMP_PROFILING_RESULTS; };
};
#endif // }





/*********************************************************************************
/* Comments:
/*		Here is the code used to generate maxprof.dll
/*********************************************************************************
#define MAX_PROFILING_DLL_IMPLEMENTATION
#include <iomanip.h>
#include <profile.h>
#pragma warning( disable : 4786 )
__MAX_MINIPROFILER_IMPLEMENTATION
typedef CMaxMultithreadProfiler<CMaxMiniProfiler_NoHistory> GDllProfiler_Type1;
typedef CMaxMultithreadProfiler<CMaxMiniProfiler_Standard> GDllProfiler_Type2;
GDllProfiler_Type1 g_oProfiler;
__declspec(dllexport) void LockProfiler()
	{ g_oProfiler.FLockProfiler(); }
__declspec(dllexport) void UnlockProfiler()
	{ g_oProfiler.FUnlockProfiler(); }
__declspec(dllexport) void DumpResults( bool bForced, bool bCurrentThreadOnly )
	{ g_oProfiler.FDumpResults( bForced, bCurrentThreadOnly ); }
__declspec(dllexport) void CreateNewNode( const char *pszTitle )
	{ g_oProfiler.FCreateNewNode( pszTitle ); }
__declspec(dllexport) void CloseCurrentNode()
	{ g_oProfiler.FCloseCurrentNode(); }
__declspec(dllexport) bool IsBiasKnown()
	{ return g_oProfiler.bFIsBiasKnown(); }
__declspec(dllexport) void SetBiasApproximationFrom( unsigned long lBiasSample )
	{ g_oProfiler.FSetBiasApproximationFrom( lBiasSample ); }
#pragma warning( default : 4786 )
/*********************************************************************************
/* Comments:
/*		Here is the DEF file used to generate maxprof.dll
/*********************************************************************************
EXPORTS
	LockProfiler @1
	UnlockProfiler @2
	DumpResults @3
	CreateNewNode @4
	CloseCurrentNode @5
	IsBiasKnown @6
	SetBiasApproximationFrom @7
/********************************************************************************/

// Note: I don't reenable C4786, and I know it...

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\profile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       	profile.cpp
//
//  Description:	Definition of the code profiler found in profile.h
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#ifdef MAX_PROFILING_ENABLED
const CMaxLargeInteger CMaxTimerAbstraction::s_oFrequency = CMaxTimerAbstraction::oSCentralFrequency();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\querysup.h ===
// DSQuery.h : Declaration of the CDSQuery object
//             this is an internal helper object only, not exposed
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSQuery.h
//
//  Contents:  Query object for DS snapin
//
//  History:   04-dec-96 jimharr    Created
//
//--------------------------------------------------------------------------


#ifndef __DSQUERY_H__
#define __DSQUERY_H__

#include "dscmn.h" // DSPROP_BSTR_BLOCK

// this used to be 256, we dropped it to reduce latency on first page
// retrieval.
#define QUERY_PAGESIZE 50


#define CMD_OPTIONS 2

/////////////////////////////////////////////////////////////////////////////
// CDSSearch

class CDSSearch
{
public:
  CDSSearch();
  CDSSearch(CDSCache * pCache, CDSComponentData * pCD);
  ~CDSSearch();

// INTERFACES
public:
  HRESULT Init(IDirectorySearch * pObj);
  HRESULT Init(LPCWSTR lpszObjectPath);
  HRESULT DoQuery();
  HRESULT GetNextRow ();
  HRESULT GetColumn(LPWSTR Attribute,
                    PADS_SEARCH_COLUMN pColumnData);
  HRESULT FreeColumn(PADS_SEARCH_COLUMN pColumnData) {
    return m_pObj->FreeColumn(pColumnData);
  };
  HRESULT SetCookieFromData (CDSCookie* pCookie,
                              CDSColumnSet* pColumnSet);
  HRESULT SetCookieFromData (CDSCookie* pCookie,
                              CPathCracker& specialPerformancePathCracker,
                              CDSColumnSet* pColumnSet);
  HRESULT SetAttributeList (LPTSTR *pszAttribs, INT cAttrs);
  HRESULT SetAttributeListForContainerClass ( CDSColumnSet* pColumnSet);
  HRESULT SetSearchScope (ADS_SCOPEENUM scope);
  HRESULT SetFilterString (LPWSTR pszFilter) {
    m_pwszFilter = pszFilter;
    return S_OK;
  };

  //Attributes
public:
  IDirectorySearch   * m_pObj;
  ADS_SEARCH_HANDLE  m_SearchHandle;

protected:
  LPWSTR             m_pwszFilter;
  DSPROP_BSTR_BLOCK  m_pszAttribs;
  CDSCache         * m_pCache;
  CDSComponentData * m_pCD;
  ADS_SCOPEENUM      m_scope;

private:
  void _Reset();
  BOOL m_bInitialized;

  // JonN 6/29/99: must do extra work for container class nTFRSMember
  CString m_strContainerClassName;
  CMapStringToString m_mapMemberToComputer;
  
};
        


#endif //__DSQUERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\query.cpp ===
//+----------------------------------------------------------------------------
//
//  DS Administration MMC snapin.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       query.cpp
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"

#include "query.h"
#include "queryui.h"
#include "uiutil.h"
#include "xmlutil.h"
#include "ContextMenu.h"
#include "dataobj.h"

////////////////////////////////////////////////////////////////////////////
// CFavoritesNode

CFavoritesNode::CFavoritesNode()
   : m_bFavoritesRoot(0)
{
  MakeContainer();
  CDSColumnSet* pColumnSet = CDSColumnSet::CreateDescriptionColumnSet();
  if (pColumnSet != NULL)
  {
    GetFolderInfo()->SetColumnSet(pColumnSet);
  }
}

BOOL CFavoritesNode::DeepCopyChildren(CUINode* pUINodeToCopy)
{
  if (pUINodeToCopy == NULL)
  {
    ASSERT(FALSE);
    return FALSE;
  }

  //
  // We have to do a deep copy of the children for the favorites nodes
  //
  CUINodeList* pCopyContList = pUINodeToCopy->GetFolderInfo()->GetContainerList();
  CUINodeList* pNewContList = GetFolderInfo()->GetContainerList();

  if (pCopyContList != NULL && pNewContList != NULL)
  {
    POSITION pos = pCopyContList->GetHeadPosition();
    while (pos != NULL)
    {
      CUINode* pUINode = pCopyContList->GetNext(pos);
      if (pUINode != NULL)
      {
        if (IS_CLASS(*pUINode, CFavoritesNode))
        {
          CFavoritesNode* pNewNode = new CFavoritesNode(*(dynamic_cast<CFavoritesNode*>(pUINode)));
          if (pNewNode != NULL)
          {
            pNewNode->DeepCopyChildren(pUINode);
            pNewNode->SetParent(this);
            pNewContList->AddTail(pNewNode);
          }
        }
        else if (IS_CLASS(*pUINode, CSavedQueryNode))
        {
          CSavedQueryNode* pNewNode = new CSavedQueryNode(*(dynamic_cast<CSavedQueryNode*>(pUINode)));
          if (pNewNode != NULL)
          {
            pNewNode->SetParent(this);
            pNewContList->AddTail(pNewNode);
          }
        }
        else
        {
          //
          // CFavoritesNode should only contain CFavoritesNodes and CSavedQueryNodes
          //
          ASSERT(FALSE);
          continue;
        }
      }
    }
  }


  //
  // There shouldn't be any leaf nodes but we will try to copy just in case
  //
  CUINodeList* pCopyLeafList = pUINodeToCopy->GetFolderInfo()->GetLeafList();
  CUINodeList* pNewLeafList = GetFolderInfo()->GetLeafList();

  if (pCopyLeafList != NULL && pNewLeafList != NULL)
  {
    POSITION pos = pCopyLeafList->GetHeadPosition();
    while (pos != NULL)
    {
      CUINode* pUINode = pCopyLeafList->GetNext(pos);
      if (pUINode != NULL)
      {
        CUINode* pNewNode = NULL;

        //
        // In the future we would add class specific creation here as is above
        //

        //
        // CFavoritesNode should only contain CFavoritesNodes and CSavedQueryNodes
        //
        ASSERT(FALSE);

        if (pNewNode != NULL)
        {
          pNewLeafList->AddTail(pNewNode);
        }
      }
    }
  }
  return TRUE;
}

void CFavoritesNode::RemoveQueryResults()
{
  ASSERT(!IsSheetLocked());
  ASSERT(GetFolderInfo()->GetLeafList()->IsEmpty());

  CUINodeList* pContainerList = GetFolderInfo()->GetContainerList();
  for (POSITION pos = pContainerList->GetHeadPosition(); pos != NULL; )
  {
    CUINode* pCurrUINode = pContainerList->GetNext(pos);

    // we reset the expanded flag only on nodes below
    // the current node, because the current node is going
    // to get results back from the refresh command, while
    // the others will be added again and will be expanded as
    // new nodes
    pCurrUINode->GetFolderInfo()->ReSetExpanded();

    if (IS_CLASS(*pCurrUINode, CSavedQueryNode))
    {
      pCurrUINode->GetFolderInfo()->DeleteAllLeafNodes();
      pCurrUINode->GetFolderInfo()->DeleteAllContainerNodes();
    }
    else if (IS_CLASS(*pCurrUINode, CFavoritesNode))
    {
      // recurse down to other query folders
      dynamic_cast<CFavoritesNode*>(pCurrUINode)->RemoveQueryResults();
    }
  }

}

void CFavoritesNode::FindCookiesInQueries(LPCWSTR lpszCookieDN, CUINodeList* pNodeList)
{
  ASSERT(GetFolderInfo()->GetLeafList()->IsEmpty());

  CUINodeList* pContainerList = GetFolderInfo()->GetContainerList();
  for (POSITION pos = pContainerList->GetHeadPosition(); pos != NULL; )
  {
    CUINode* pCurrUINode = pContainerList->GetNext(pos);

    if (IS_CLASS(*pCurrUINode, CSavedQueryNode))
    {
      CSavedQueryNode* pSavedQueryNode = dynamic_cast<CSavedQueryNode*>(pCurrUINode);
      pSavedQueryNode->FindCookieByDN(lpszCookieDN, pNodeList);
    }
    else if (IS_CLASS(*pCurrUINode, CFavoritesNode))
    {
      // recurse down to other query folders
      dynamic_cast<CFavoritesNode*>(pCurrUINode)->FindCookiesInQueries(lpszCookieDN, pNodeList);
    }
  }
}

BOOL CFavoritesNode::IsDeleteAllowed(CDSComponentData* pComponentData, BOOL* pbHide)
{
  if (pComponentData->GetFavoritesNodeHolder()->GetFavoritesRoot() == this)
  {
    *pbHide = TRUE;
    return FALSE;
  }
  *pbHide = FALSE;
  return TRUE;
}

BOOL CFavoritesNode::ArePropertiesAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = FALSE;
  return TRUE;
}


BOOL CFavoritesNode::IsRenameAllowed(CDSComponentData* pComponentData, BOOL* pbHide)
{
  if (pComponentData->GetFavoritesNodeHolder()->GetFavoritesRoot() == this)
  {
    *pbHide = TRUE;
    return FALSE;
  }
  *pbHide = FALSE;
  return TRUE;
}

BOOL CFavoritesNode::IsRefreshAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = FALSE;
  return TRUE;
}

BOOL CFavoritesNode::IsCutAllowed(CDSComponentData* pComponentData, BOOL* pbHide)
{
  //
  // Don't allow cut on the favorites root
  //
  if (pComponentData->GetFavoritesNodeHolder()->GetFavoritesRoot() == this)
  {
    *pbHide = TRUE;
    return FALSE;
  }

  *pbHide = FALSE;
  return TRUE;
}

BOOL CFavoritesNode::IsCopyAllowed(CDSComponentData* pComponentData, BOOL* pbHide)
{
  //
  // Don't allow copy on the favorites root
  //
  if (pComponentData->GetFavoritesNodeHolder()->GetFavoritesRoot() == this)
  {
    *pbHide = TRUE;
    return FALSE;
  }

  *pbHide = FALSE;
  return TRUE;
}

BOOL CFavoritesNode::IsPasteAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = FALSE;
  return TRUE;
}

void CFavoritesNode::Paste(IDataObject* pPasteData, CDSComponentData* pComponentData, LPDATAOBJECT* ppCutDataObj)
{
  bool bIsCopy = (ppCutDataObj == 0);
  //
  // Extract the cookies from the data object
  //
  CInternalFormatCracker ifc;
  HRESULT hr = ifc.Extract(pPasteData);
  if (SUCCEEDED(hr))
  {
    //
    // Make sure all the nodes are either CFavoritesNode or CSavedQueryNode
    // and not the same node or a relative
    //
    for (UINT nCount = 0; nCount < ifc.GetCookieCount(); nCount++)
    {
      CUINode* pNode = ifc.GetCookie(nCount);
      if (pNode != NULL)
      {
        if (!IS_CLASS(*pNode, CFavoritesNode) && !IS_CLASS(*pNode, CSavedQueryNode))
        {
          //
          // Note this should be caught on the query paste
          //
          ASSERT(FALSE && L"!IS_CLASS(*pNode, CFavoritesNode) || !IS_CLASS(*pNode, CSavedQueryNode)");
          return;
        }

        if (pNode == this)
        {
          return;
        }

        if (IsRelative(pNode))
        {
          return;
        }
      }
    }

    //
    // Add the nodes to this container
    //
    CUINodeList nodesAddedList;
    for (UINT nCount = 0; nCount < ifc.GetCookieCount(); nCount++)
    {
      CUINode* pNode = ifc.GetCookie(nCount);
      if (pNode != NULL)
      {
        if (IS_CLASS(*pNode, CFavoritesNode))
        {
          //
          // Use the copy constructor to copy the node
          //
          CFavoritesNode* pCopyNode = new CFavoritesNode(*(dynamic_cast<CFavoritesNode*>(pNode)));
          if (pCopyNode != NULL)
          {
            if (bIsCopy)
            {
              //
              // Check to see if the name is unique and prepend "Copy of " if not
              //
              UINT nCopyOfCount = 0;
              CString szCopyOf;
              VERIFY(szCopyOf.LoadString(IDS_COPY_OF));
              CString szOriginalName = pCopyNode->GetName();
              CString szCopyName = szOriginalName;

              if (szCopyName.Find(szCopyOf) != -1)
              {
                nCopyOfCount = 1;
              }
            
              CString szMultipleCopyOf;
              VERIFY(szMultipleCopyOf.LoadString(IDS_MULTIPLE_COPY_OF));

              CUINode* pDupNode = NULL;
              while (!IsUniqueName(szCopyName, &pDupNode))
              {
                //
                // Puts the new name in the format "Copy of <original name>" or
                // "Copy of (#) <original name>"
                //
                if (nCopyOfCount == 0)
                {
                  szCopyName = szCopyOf + szOriginalName;
                }
                else
                {
                  CString szTemp;
                  szTemp.Format(szMultipleCopyOf, nCopyOfCount+1);

                  szCopyName = szTemp + szOriginalName;
                }
                ++nCopyOfCount;
              }
              pCopyNode->SetName(szCopyName);
            }
            else
            {
              CUINode* pDupNode = NULL;
              CString szNewName = pCopyNode->GetName();
              if (!IsUniqueName(szNewName, &pDupNode))
              {
                if (pDupNode == pCopyNode)
                {
                  //
                  // We are moving the node to the same container. Just silently ignore
                  //
                  continue;
                }

                CString szFormatMsg;
                VERIFY(szFormatMsg.LoadString(IDS_ERRMSG_NOT_UNIQUE_QUERY_NAME_INPLACE));

                CString szErrMsg;
                szErrMsg.Format(szFormatMsg, szNewName);

                CString szTitle;
                VERIFY(szTitle.LoadString(IDS_DSSNAPINNAME));

                MessageBox(pComponentData->GetHWnd(), szErrMsg, szTitle, MB_OK | MB_ICONSTOP);
                return;
              }
            }

            //
            // Make copies of all the children too
            //
            pCopyNode->DeepCopyChildren(pNode);
            pCopyNode->SetParent(this);

            //
            // Add it to the successfully pasted list
            //
            nodesAddedList.AddTail(pCopyNode);
          }
        }
        else if (IS_CLASS(*pNode, CSavedQueryNode))
        {
          CSavedQueryNode* pCopyNode = new CSavedQueryNode(*(dynamic_cast<CSavedQueryNode*>(pNode)));
          if (pCopyNode != NULL)
          {
            if (bIsCopy)
            {
              //
              // Check to see if the name is unique and prepend "Copy of " if not
              //
              UINT nCopyOfCount = 0;
              CString szCopyOf;
              VERIFY(szCopyOf.LoadString(IDS_COPY_OF));
              CString szOriginalName = pCopyNode->GetName();
              CString szCopyName = szOriginalName;

              if (szCopyName.Find(szCopyOf) != -1)
              {
                nCopyOfCount = 1;
              }
            
              CString szMultipleCopyOf;
              VERIFY(szMultipleCopyOf.LoadString(IDS_MULTIPLE_COPY_OF));

              CUINode* pDupNode = NULL;
              while (!IsUniqueName(szCopyName, &pDupNode))
              {
                //
                // Puts the new name in the format "Copy of <original name>" or
                // "Copy of (#) <original name>"
                //
                if (nCopyOfCount == 0)
                {
                  szCopyName = szCopyOf + szOriginalName;
                }
                else
                {
                  CString szTemp;
                  szTemp.Format(szMultipleCopyOf, nCopyOfCount+1);

                  szCopyName = szTemp + szOriginalName;
                }
                ++nCopyOfCount;
              }
              pCopyNode->SetName(szCopyName);
            }
            else
            {
              CUINode* pDupNode = NULL;
              CString szNewName = pCopyNode->GetName();
              if (!IsUniqueName(szNewName, &pDupNode))
              {
                if (pDupNode == pCopyNode)
                {
                  //
                  // We are moving the node to the same container. Just silently ignore
                  //
                  continue;
                }

                CString szFormatMsg;
                VERIFY(szFormatMsg.LoadString(IDS_ERRMSG_NOT_UNIQUE_QUERY_NAME_INPLACE));

                CString szErrMsg;
                szErrMsg.Format(szFormatMsg, szNewName);

                CString szTitle;
                VERIFY(szTitle.LoadString(IDS_DSSNAPINNAME));

                MessageBox(pComponentData->GetHWnd(), szErrMsg, szTitle, MB_OK | MB_ICONSTOP);
                return;
              }
            }

            pCopyNode->SetParent(this);

            //
            // Add it to the successfully pasted list
            //
            nodesAddedList.AddTail(pCopyNode);
          }
            
        }
        else
        {
          //
          // CFavoritesNode should only contain CFavoritesNodes and CSavedQueryNodes
          //
          ASSERT(FALSE);
        }
      }
    }

    //
    // if the node has been expanded then add the new nodes to the UI
    //
    if (GetFolderInfo()->IsExpanded())
    {
      //
      // add the items to the UI
      //
      pComponentData->AddListOfNodesToUI(this, &nodesAddedList);
    }
    else
    {
      //
      // If not then just add them to the folder's list of children
      //
      GetFolderInfo()->AddListofNodes(&nodesAddedList);
    }

    //
    // Only set the output DataObject if it is a cut operation
    //
    if (ppCutDataObj != NULL)
    {
      *ppCutDataObj = pPasteData;
      pPasteData->AddRef();
    }
  }

}

HRESULT CFavoritesNode::QueryPaste(IDataObject* pPasteData, CDSComponentData* pComponentData)
{
  HRESULT hr = S_OK;

  ASSERT(pComponentData);

  //
  // Extract the cookies from the data object
  //
  CInternalFormatCracker ifc;
  hr = ifc.Extract(pPasteData);
  if (SUCCEEDED(hr))
  {
    //
    // Don't allow drops across instances of the snapin
    //

    if (IsSameSnapin(pPasteData, pComponentData))
    {
      //
      // Make sure all the nodes are either CFavoritesNode or CSavedQueryNode
      //
      for (UINT nCount = 0; nCount < ifc.GetCookieCount(); nCount++)
      {
        CUINode* pNode = ifc.GetCookie(nCount);
        if (pNode != NULL)
        {
          if (!IS_CLASS(*pNode, CFavoritesNode) && !IS_CLASS(*pNode, CSavedQueryNode))
          {
            hr = S_FALSE;
            break;
          }
        }
      }
    }
    else
    {
       hr = S_FALSE;
    }
  }
  return hr;
}

bool CFavoritesNode::IsSameSnapin(IDataObject* pPasteData, CDSComponentData* pComponentData)
{
  bool bResult = true;

  STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };

  do
  {

    FORMATETC formatetc = { CDSDataObject::m_cfComponentData, NULL, 
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    HRESULT hr = pPasteData->GetData(&formatetc, &stgmedium);
    if (FAILED(hr)) 
    {
      bResult = false;
      break;
    }

    CDSComponentData** pPasteComponentData = reinterpret_cast<CDSComponentData**>(stgmedium.hGlobal);
    if (pPasteComponentData &&
        pComponentData != *pPasteComponentData)
    {
      bResult = false;
      break;
    }

  } while(false);

  if (stgmedium.hGlobal)
  {
     GlobalFree(stgmedium.hGlobal);
  }
  return bResult;
}

CContextMenuVerbs* CFavoritesNode::GetContextMenuVerbsObject(CDSComponentData* pComponentData)
{ 
  if (m_pMenuVerbs == NULL)
  {
    m_pMenuVerbs = new CFavoritesFolderMenuVerbs(pComponentData);
  }
  return m_pMenuVerbs;
}

HRESULT CFavoritesNode::Delete(CDSComponentData* pComponentData)
{
  HRESULT hr = S_OK;

  //
  // this is just a message box, using ReportErrorEx for consistency of look
  //
  int answer = ReportErrorEx(pComponentData->GetHWnd(),IDS_CONFIRM_DELETE_FAVORITES,S_OK,
                             MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2, NULL, 0);
  if (answer == IDNO) 
  {
    return S_FALSE; // aborted by user
  }

  if (IsContainer())
  {
    hr = pComponentData->RemoveContainerFromUI(this);
    delete this;
  }
  else
  {
    CUINode* pParentNode = GetParent();
    ASSERT(pParentNode->IsContainer());

    pParentNode->GetFolderInfo()->RemoveNode(this);
    //
    // The CDSEvent::_DeleteSingleSel() handles removing the node from the UI
    //
  }
  return hr;
}

HRESULT CFavoritesNode::DeleteMultiselect(CDSComponentData* pComponentData, CInternalFormatCracker* pObjCracker)
{
  ASSERT(pObjCracker != NULL);
  if (pObjCracker == NULL)
  {
    return S_FALSE;
  }

  UINT nQueryCount = 0;
  UINT nFolderCount = 0;
  for (UINT nIdx = 0; nIdx < pObjCracker->GetCookieCount(); nIdx++)
  {
    CUINode* pUINode = pObjCracker->GetCookie(nIdx);
    if (pUINode != NULL)
    {
      if (IS_CLASS(*pUINode, CFavoritesNode))
      {
        nFolderCount++;
      }
      else if (IS_CLASS(*pUINode, CSavedQueryNode))
      {
        nQueryCount++;
      }
      else
      {
        //
        // CFavoritesNode should only contain CFavoritesNodes and CSavedQueryNodes
        //
        ASSERT(FALSE);
        continue;
      }
    }
  }

  CString szFormatMessage;
  VERIFY(szFormatMessage.LoadString(IDS_CONFIRM_MULTI_DELETE_FAVORITES));

  if (!szFormatMessage.IsEmpty())
  {
    CString szConfirmMessage;
    szConfirmMessage.Format(szFormatMessage, nFolderCount, nQueryCount);

    CString szCaption;
    VERIFY(szCaption.LoadString(IDS_DSSNAPINNAME));

    //
    // this is just a message box, using ReportErrorEx for consistency of look
    //
    int answer = MessageBox(pComponentData->GetHWnd(),szConfirmMessage,szCaption,
                               MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2);
    if (answer == IDNO) 
    {
      return S_FALSE; // aborted by user
    }
  }
  else
  {
    return S_FALSE;
  }

  return CUINode::DeleteMultiselect(pComponentData, pObjCracker);
}

HRESULT CFavoritesNode::OnCommand(long lCommandID, CDSComponentData* pComponentData)
{
  HRESULT hr = S_OK;

  switch (lCommandID)
  {
    case IDM_NEW_FAVORITES_FOLDER:
      OnNewFavoritesFolder(pComponentData);
      break;
    case IDM_NEW_QUERY_FOLDER:
      OnNewSavedQuery(pComponentData);
      break;
    case IDM_IMPORT_QUERY:
      OnImportQuery(pComponentData);
      break;
    case IDM_GEN_TASK_MOVE:
      break;
    case IDM_VIEW_ADVANCED:
      {
        if (pComponentData->CanRefreshAll()) 
        {
          ASSERT( SNAPINTYPE_SITE != pComponentData->QuerySnapinType() );
          pComponentData->GetQueryFilter()->ToggleAdvancedView();
          pComponentData->SetDirty(TRUE);
          pComponentData->RefreshAll();
        }
      }
      break;

    default :
      ASSERT(FALSE); 
      break;
  }
  return hr;
}

//
// Checks to see if any existing children of this container
// already exist with the passed in name
//
BOOL CFavoritesNode::IsUniqueName(PCWSTR pszName, CUINode** ppDuplicateNode)
{
  BOOL bUnique = TRUE;

  CString szNewName = pszName;

  //
  // Trim whitespace
  //
  szNewName.TrimLeft();
  szNewName.TrimRight();

  //
  // Make sure the name is unique
  //
  CUINodeList* pNodeList = GetFolderInfo()->GetContainerList();
  if (pNodeList != NULL)
  {
    POSITION pos = pNodeList->GetHeadPosition();
    while (pos != NULL)
    {
      CUINode* pNode = pNodeList->GetNext(pos);
      if (pNode != NULL)
      {
        if (_wcsicmp(szNewName, pNode->GetName()) == 0)
        {
          bUnique = FALSE;

          //
          // Return the node that was found to have the duplicate name
          //
          if (ppDuplicateNode != NULL)
          {
            *ppDuplicateNode = pNode;
          }
          break;
        }
      }
    }
  }

  return bUnique;
}

HRESULT CFavoritesNode::Rename(LPCWSTR lpszNewName, CDSComponentData* pComponentData)
{
  HRESULT hr = S_OK;
  CString szNewName = lpszNewName;

  CString szTitle;
  VERIFY(szTitle.LoadString(IDS_DSSNAPINNAME));

  //
  // Trim whitespace
  //
  szNewName.TrimLeft();
  szNewName.TrimRight();

  if (szNewName.IsEmpty())
  {
    //
    // Don't allow empty names
    //
    CString szMessage;
    VERIFY(szMessage.LoadString(IDS_ERRMSG_NO_EMPTY_NAMES));
    MessageBox(pComponentData->GetHWnd(), szMessage, szTitle, MB_OK | MB_ICONSTOP);
    return S_FALSE;
  }

  CUINode* pDupNode = NULL;
  if (GetFavoritesNode() != NULL && !GetFavoritesNode()->IsUniqueName(szNewName, &pDupNode))
  {
    if (pDupNode == this)
    {
      //
      // We are renaming the node to the same name. Just silently ignore
      //
      return S_FALSE;
    }

    CString szFormatMsg;
    VERIFY(szFormatMsg.LoadString(IDS_ERRMSG_NOT_UNIQUE_QUERY_NAME_INPLACE));

    CString szErrMsg;
    szErrMsg.Format(szFormatMsg, szNewName);

    MessageBox(pComponentData->GetHWnd(), szErrMsg, szTitle, MB_OK | MB_ICONSTOP);
    return S_FALSE;
  }

  //
  // Set the name
  //
  SetName(szNewName);
  hr = pComponentData->UpdateItem(this);
  return hr;
}

void CFavoritesNode::OnImportQuery(CDSComponentData* pComponentData)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  //
  // Title for error message box
  //
  CString szTitle;
  VERIFY(szTitle.LoadString(IDS_DSSNAPINNAME));

  CString szFilter;
  VERIFY(szFilter.LoadString(IDS_QUERY_EXPORT_FILTER));

  CString szFileExt(L"xml");
  CString szFileView(L"*.xml");

  CFileDialog* pFileDlg = new CFileDialog(TRUE, 
                                          szFileExt, 
                                          szFileView, 
                                          OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST,
                                          szFilter);
  if (pFileDlg == NULL)
  {
    return;
  }

  if (pFileDlg->DoModal() == IDOK)
  {
    //
    // create an instance of the XML document
    //
    CComPtr<IXMLDOMDocument> spXMLDoc;

    HRESULT hr = ::CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_IXMLDOMDocument, (void**)&spXMLDoc);
    if (FAILED(hr))
    {
      TRACE(L"CoCreateInstance(CLSID_DOMDocument) failed with hr = 0x%x\n", hr);
      return;
    }

    //
    // Retrieve the file and path
    //
    CString szFileName;
    szFileName = pFileDlg->GetPathName();

    CSavedQueryNode* pNewSavedQuery = NULL;
    bool bQueryAdded = false;
    do // false loop
    {
      //
      // load the document from file
      //
      CComVariant xmlSource;
      xmlSource = szFileName;
      VARIANT_BOOL isSuccessful;
      hr = spXMLDoc->load(xmlSource, &isSuccessful);
      if (FAILED(hr) || !isSuccessful)
      {
        CString szErrMsg;
        szErrMsg.LoadString(IDS_ERRMSG_FAILED_LOAD_QUERY);
        MessageBox(pComponentData->GetHWnd(), szErrMsg, szTitle, MB_OK | MB_ICONSTOP);
        break;
      }
      //
      // Get the node interface to the beginning of the document
      //
      CComPtr<IXMLDOMNode> spXDOMNode;
      hr = spXMLDoc->QueryInterface(IID_IXMLDOMNode, (void **)&spXDOMNode);
      if (FAILED(hr))
      {
        CString szErrMsg;
        szErrMsg.LoadString(IDS_ERRMSG_FAILED_LOAD_QUERY);
        MessageBox(pComponentData->GetHWnd(), szErrMsg, szTitle, MB_OK | MB_ICONSTOP);
        break;
      }

      //
      // Get its child
      //
      CComPtr<IXMLDOMNode> spXDOMChild;
      hr = spXDOMNode->get_firstChild(&spXDOMChild);
      if (FAILED(hr) || !spXDOMChild)
      {
        CString szErrMsg;
        szErrMsg.LoadString(IDS_ERRMSG_FAILED_LOAD_QUERY);
        MessageBox(pComponentData->GetHWnd(), szErrMsg, szTitle, MB_OK | MB_ICONSTOP);
        break;
      }

      //
      // Load the saved query node from this child
      //
      hr = CSavedQueryNode::XMLLoad(pComponentData, spXDOMChild, &pNewSavedQuery);
      if (FAILED(hr) || !pNewSavedQuery)
      {
        CString szErrMsg;
        szErrMsg.LoadString(IDS_ERRMSG_FAILED_LOAD_QUERY);
        MessageBox(pComponentData->GetHWnd(), szErrMsg, szTitle, MB_OK | MB_ICONSTOP);
        break;
      }

      //
      // Open query in edit mode
      //
      CQueryDialog dlg(pNewSavedQuery, this, pComponentData, FALSE, TRUE);
      if (dlg.DoModal() == IDOK)
      {
        //
        // Add the node to the ui and select it
        //
        GetFolderInfo()->AddNode(pNewSavedQuery);
        pComponentData->AddScopeItemToUI(pNewSavedQuery, TRUE);
        bQueryAdded = true;
      }
    } while (false);

    //
    // There was an error or the user cancelled the dialog.  
    // Clean up the memory
    //
    if (!bQueryAdded && pNewSavedQuery)
    {
      delete pNewSavedQuery;
      pNewSavedQuery = 0;
    }
  } 

  if (pFileDlg != NULL)
  {
    delete pFileDlg;
    pFileDlg = NULL;
  }
}

void CFavoritesNode::OnNewFavoritesFolder(CDSComponentData* pComponentData)
{
  CFavoritesNode* pFav = new CFavoritesNode;

  CString szNewFolder;
  VERIFY(szNewFolder.LoadString(IDS_NEW_FOLDER));

  CUINodeList* pContainerList = GetFolderInfo()->GetContainerList();
  if (pContainerList != NULL)
  {
    CString szSearchString;
    szSearchString.Format(L"%s (%%u)", szNewFolder);

    //
    // Search for containers under this node that start with "New Folder (<number>)"
    //
    UINT nLargestNum = 0;
    POSITION pos = pContainerList->GetHeadPosition();
    while (pos != NULL)
    {
      CUINode* pUINode = pContainerList->GetNext(pos);

      UINT nFolderNum = 0;
      CString szNodeName;
      szNodeName = pUINode->GetName();

      if (szNodeName == szNewFolder)
      {
        if (nLargestNum < 1)
        {
          nLargestNum = 1;
        }
        continue;
      }

      if (swscanf(szNodeName, szSearchString, &nFolderNum) == 1)
      {
        if (nFolderNum > nLargestNum)
        {
          nLargestNum = nFolderNum;
        }
      }
    }

    CString szNewName;
    if (nLargestNum == 0)
    {
      szNewName = szNewFolder;
    }
    else
    {
      szNewName.Format(L"%s (%u)", szNewFolder, nLargestNum + 1);
    }

    pFav->SetName(szNewName);

  }
  else
  {
    pFav->SetName(szNewFolder);
  }
  pFav->SetDesc(L"");
  GetFolderInfo()->AddNode(pFav);

  //
  // Add node to UI and select it
  //
  pComponentData->AddScopeItemToUI(pFav, TRUE);

  //
  // Put the folder into rename mode
  //
  pComponentData->SetRenameMode(pFav);

}

void CFavoritesNode::OnNewSavedQuery(CDSComponentData* pComponentData)
{
  CSavedQueryNode* pQuery = new CSavedQueryNode(pComponentData->GetBasePathsInfo(),
                                                pComponentData->QuerySnapinType());
  
  CQueryDialog dlg(pQuery, this, pComponentData, TRUE);
  if (dlg.DoModal() == IDOK)
  {
    GetFolderInfo()->AddNode(pQuery);

    //
    // Add new node to UI and select it
    //
    pComponentData->AddScopeItemToUI(pQuery, TRUE);
  }
}


LPCWSTR CFavoritesNode::g_szObjXMLTag = L"FOLDER";

//
// This is used to start the loading at the embedded favorites root.
// All other favorites folders are loaded through the static method XMLLoad
//
HRESULT CFavoritesNode::Load(IXMLDOMNode* pXDN, 
                             CDSComponentData* pComponentData)
{
  //
  // check the name of the node
  //
  if (!XMLIsNodeName(pXDN, CFavoritesNode::g_szObjXMLTag))
  {
    //
    // should have checked before calling...
    //
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  //
  // get the list of child  nodes
  //
  CComPtr<IXMLDOMNode> spCurrChild;
  pXDN->get_firstChild(&spCurrChild);
  if (spCurrChild == NULL)
  {
    return E_INVALIDARG;
  }

  //
  // recurse down on children
  //
  while (spCurrChild != NULL)
  {
    CComBSTR bstrName, bstrDescription;
    CComBSTR bstrChildName;
    
    spCurrChild->get_nodeName(&bstrChildName);
    if (CompareXMLTags(bstrChildName, CFavoritesNode::g_szObjXMLTag))
    {
      //
      // we got a subfolder, need to build the subtree
      //
      CFavoritesNode* pSubNode = NULL;
      CFavoritesNode::XMLLoad(pComponentData, spCurrChild, &pSubNode);
      if (pSubNode != NULL)
      {
        //
        // got a subtree, add it to the list of children
        //
        GetFolderInfo()->AddNode(pSubNode);
      }
    }
    else if (CompareXMLTags(bstrChildName, CGenericUINode::g_szNameXMLTag))
    {
      XML_GetNodeText(spCurrChild, &bstrName);

      // Don't overwrite the name from the saved console if this is the query
      // root because the default saved console is always english.  In other
      // languages we need to use the string from the resource file.

      if (!IsFavoritesRoot())
      {
         SetName(bstrName);
      }
    }
    else if (CompareXMLTags(bstrChildName, CGenericUINode::g_szDecriptionXMLTag))
    {
      XML_GetNodeText(spCurrChild, &bstrDescription);

      // Don't overwrite the description from the saved console if this is the query
      // root because the default saved console is always english.  In other
      // languages we need to use the string from the resource file.

      if (!IsFavoritesRoot())
      {
         SetDesc(bstrDescription);
      }
      else
      {
         // If it is the favorites root and the description is not the same as the
         // default english description, then set it.  The user has the option to
         // change the description.  If IDS_SAVED_QUERIES_DESC gets changed this has
         // to be changed as well.

         if (_wcsicmp(bstrDescription, L"Folder to store your favorite queries") !=0)
         {
            SetDesc(bstrDescription);
         }
      }
    }
    else if (CompareXMLTags(bstrChildName, CSavedQueryNode::g_szObjXMLTag))
    {
      CSavedQueryNode* pQuery = NULL;
      CSavedQueryNode::XMLLoad(pComponentData, spCurrChild, &pQuery);
      if (pQuery != NULL)
      {
        GetFolderInfo()->AddNode(pQuery);
      }
    }
    CComPtr<IXMLDOMNode> temp = spCurrChild;
    spCurrChild = NULL;
    temp->get_nextSibling(&spCurrChild);
  }
  return S_OK;
}

HRESULT CFavoritesNode::XMLLoad(CDSComponentData* pComponentData,
                                IXMLDOMNode* pXDN, 
                                CFavoritesNode** ppNode)
{
  // check the name of the node
  if (!XMLIsNodeName(pXDN, CFavoritesNode::g_szObjXMLTag))
  {
    // should have checked before calling...
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  // get the list of child  nodes
  CComPtr<IXMLDOMNode> spCurrChild;
  pXDN->get_firstChild(&spCurrChild);
  if (spCurrChild == NULL)
  {
    return E_INVALIDARG;
  }

  // create a temporary node
  (*ppNode) = new CFavoritesNode;

  // recurse down on children
  while (spCurrChild != NULL)
  {
    CComBSTR bstrName, bstrDescription;
    CComBSTR bstrChildName;
    
    spCurrChild->get_nodeName(&bstrChildName);
    if (CompareXMLTags(bstrChildName, CFavoritesNode::g_szObjXMLTag))
    {
      // we got a subfolder, need to build the subtree
      CFavoritesNode* pSubNode = NULL;
      CFavoritesNode::XMLLoad(pComponentData, spCurrChild, &pSubNode);
      if (pSubNode != NULL)
      {
        // got a subtree, add it to the list of children
        (*ppNode)->GetFolderInfo()->AddNode(pSubNode);
      }
    }
    else if (CompareXMLTags(bstrChildName, CGenericUINode::g_szNameXMLTag))
    {
      XML_GetNodeText(spCurrChild, &bstrName);
      (*ppNode)->SetName(bstrName);
    }
    else if (CompareXMLTags(bstrChildName, CGenericUINode::g_szDecriptionXMLTag))
    {
      XML_GetNodeText(spCurrChild, &bstrDescription);
      (*ppNode)->SetDesc(bstrDescription);
    }
    else if (CompareXMLTags(bstrChildName, CSavedQueryNode::g_szObjXMLTag))
    {
      CSavedQueryNode* pQuery = NULL;
      CSavedQueryNode::XMLLoad(pComponentData, spCurrChild, &pQuery);
      if (pQuery != NULL)
      {
        (*ppNode)->GetFolderInfo()->AddNode(pQuery);
      }
    }
    CComPtr<IXMLDOMNode> temp = spCurrChild;
    spCurrChild = NULL;
    temp->get_nextSibling(&spCurrChild);
  }

  return S_OK;
}


HRESULT CFavoritesNode::XMLSave(IXMLDOMDocument* pXMLDoc,
               IXMLDOMNode** ppXMLDOMNode)
{
  CComPtr<IXMLDOMNode> spXMLDOMNode;
  HRESULT hr = XML_CreateDOMNode(pXMLDoc, NODE_ELEMENT, CFavoritesNode::g_szObjXMLTag, &spXMLDOMNode);
  if (FAILED(hr))
  {
    return hr;
  }

  hr = XMLSaveBase(pXMLDoc, spXMLDOMNode);
  if (FAILED(hr))
  {
    return hr;
  }

  // save the child nodes
  CUINodeList* pNodeList = GetFolderInfo()->GetContainerList();
  for (POSITION pos = pNodeList->GetHeadPosition(); pos != NULL; )
  {
    CGenericUINode* pCurrChildNode = dynamic_cast<CGenericUINode*>(pNodeList->GetNext(pos));
    if (pCurrChildNode == NULL)
    {
      ASSERT(FALSE); // should never happen
      continue;
    }
    CComPtr<IXMLDOMNode> spXMLDOMChildNode;
    hr = pCurrChildNode->XMLSave(pXMLDoc, &spXMLDOMChildNode);
    if (SUCCEEDED(hr))
    {
      CComPtr<IXMLDOMNode> p;
      CComVariant after;
      after.vt = VT_EMPTY;
      hr = spXMLDOMNode->appendChild(spXMLDOMChildNode, &p);
    }
  } // for

  (*ppXMLDOMNode) = spXMLDOMNode;
  (*ppXMLDOMNode)->AddRef();
  return S_OK;
}


HRESULT CFavoritesNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK pCall,
                                            LONG_PTR lNotifyHandle,
                                            LPDATAOBJECT pDataObject,
                                            CDSComponentData* pComponentData)
{
  HRESULT hr = S_FALSE;

  CFavoritesNodePropertyPage* pPropertyPage = 
    new CFavoritesNodePropertyPage(this, lNotifyHandle, pComponentData, pDataObject);
  if (pPropertyPage != NULL)
  {
  	HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(&pPropertyPage->m_psp);
  	if (hPage != NULL)
    {
      hr = pCall->AddPage(hPage);
    }
    else
    {
      hr = E_UNEXPECTED;
    }
  }
  else
  {
    hr = E_OUTOFMEMORY;
  }
  return hr;
}

//
// Function used in a recursive search through the saved query tree looking 
// for saved queries that contain objects with any of the DNs in the list 
// and invalidates that query
//
void CFavoritesNode::InvalidateSavedQueriesContainingObjects(CDSComponentData* pComponentData,
                                                             const CStringList& refDNList)
{
  ASSERT(IsContainer());

  //
  // Note favorites nodes should only contain containers, so we only have to look
  // through the folder list
  //
  CUINodeList* pContainerList = GetFolderInfo()->GetContainerList();
  POSITION pos = pContainerList->GetHeadPosition();
  while (pos)
  {
    CGenericUINode* pGenericUINode = dynamic_cast<CGenericUINode*>(pContainerList->GetNext(pos));
    if (pGenericUINode)
    {
      pGenericUINode->InvalidateSavedQueriesContainingObjects(pComponentData,
                                                              refDNList);
    }
  }
}


////////////////////////////////////////////////////////////////////////////
// CSavedQueryNode


BOOL CSavedQueryNode::IsFilterLastLogon()
{
  return m_bLastLogonFilter && m_dwLastLogonDays != (DWORD)-1;
}

CSavedQueryNode::CSavedQueryNode(MyBasePathsInfo* pBasePathsInfo, 
                                 SnapinType snapinType)
  : m_szRelativeRootPath(L""),
    m_szCurrentFullPath(L""),
    m_szQueryString(L""),
    m_szColumnID(L""),
    m_bOneLevel(FALSE),
    m_bQueryValid(TRUE),
    m_pPersistQueryImpl(NULL),
    m_bLastLogonFilter(FALSE),
    m_dwLastLogonDays((DWORD)-1),
    m_pBasePathsInfo(pBasePathsInfo)
{
  MakeContainer();

  CDSColumnSet* pColumnSet = NULL;
  pColumnSet = CDSColumnSet::CreateColumnSetFromString(NULL, snapinType);

  GUID guid = GUID_NULL;
  HRESULT hr = ::CoCreateGuid(&guid);
  if (SUCCEEDED(hr))
  {
    WCHAR lpszGuid[40];
    int iRet = ::StringFromGUID2(guid, lpszGuid, sizeof(lpszGuid)/sizeof(WCHAR));
    if (iRet > 0)
    {
      m_szColumnID = lpszGuid;
      pColumnSet->SetColumnID(lpszGuid);
      GetFolderInfo()->SetColumnSet(pColumnSet);
    }
  }
}

CSavedQueryNode::CSavedQueryNode(const CSavedQueryNode& copyNode) : CGenericUINode(copyNode)
{
  m_szRelativeRootPath    = copyNode.m_szRelativeRootPath;
  m_szQueryString         = copyNode.m_szQueryString;
  m_bOneLevel             = copyNode.m_bOneLevel;
  m_pBasePathsInfo        = copyNode.m_pBasePathsInfo;

  //
  // Create the IPersistQuery object
  //
	CComObject<CDSAdminPersistQueryFilterImpl>::CreateInstance(&m_pPersistQueryImpl);
	ASSERT(m_pPersistQueryImpl != NULL);

  if (m_pPersistQueryImpl != NULL)
  {
    //
	  // created with zero refcount,need to AddRef() to one
    //
	  m_pPersistQueryImpl->AddRef();
    copyNode.m_pPersistQueryImpl->Clone(m_pPersistQueryImpl);
  }

  m_bQueryValid = TRUE;

  m_bLastLogonFilter = copyNode.m_bLastLogonFilter;
  m_dwLastLogonDays = copyNode.m_dwLastLogonDays;

  //
  // Generate a new column set and new column set ID for the new node
  //
  CDSColumnSet* pColumnSet = NULL;
  pColumnSet = CDSColumnSet::CreateColumnSetFromString(NULL, SNAPINTYPE_DS);

  if (pColumnSet)
  {
    GUID guid = GUID_NULL;
    HRESULT hr = ::CoCreateGuid(&guid);
    if (SUCCEEDED(hr))
    {
      WCHAR lpszGuid[40];
      int iRet = ::StringFromGUID2(guid, lpszGuid, sizeof(lpszGuid)/sizeof(WCHAR));
      if (iRet > 0)
      {
        m_szColumnID = lpszGuid;
        pColumnSet->SetColumnID(lpszGuid);
        GetFolderInfo()->SetColumnSet(pColumnSet);
      }
    }
  }
}

void CSavedQueryNode::SetColumnID(CDSComponentData* pComponentData, PCWSTR pszColumnID)
{
  m_szColumnID = pszColumnID;
  GetColumnSet(pComponentData)->SetColumnID(pszColumnID);
}

void CSavedQueryNode::AppendLastLogonQuery(CString& szQuery, DWORD dwDays)
{
  LARGE_INTEGER li;
  GetCurrentTimeStampMinusInterval(dwDays, &li);

  CString szTime;
  litow(li, szTime);
  szQuery.Format(L"%s(lastLogonTimestamp<=%s)",szQuery, szTime);
}

LPCWSTR CSavedQueryNode::GetRootPath() 
{ 
  m_szCurrentFullPath = m_szRelativeRootPath + m_pBasePathsInfo->GetDefaultRootNamingContext();
  return m_szCurrentFullPath;
}

void CSavedQueryNode::SetRootPath(LPCWSTR lpszRootPath) 
{ 
  //
  // Strip the name down to make it a RDN to the defaultNamingContext
  //
  CString szTempPath = lpszRootPath;

  ASSERT(m_pBasePathsInfo != NULL);
  if (m_pBasePathsInfo != NULL)
  {
    //
    // We now have a full DN.  Strip the default root naming context to get the RDN.
    //
    CString szDefaultRootNamingContext = m_pBasePathsInfo->GetDefaultRootNamingContext();

    int iRootDN = szTempPath.Find(szDefaultRootNamingContext);
    if (iRootDN != -1)
    {
      szTempPath = szTempPath.Left(iRootDN);
    }
  }
  m_szRelativeRootPath = szTempPath;
}


LPCWSTR CSavedQueryNode::GetQueryString()
{ 
  //
  // If we are doing a last logon query we have to check to be sure
  // the lastLogonTimestamp is part of the query string.  If not, we have
  // to add it.  There is a case when we load that the lastLogonTimestamp 
  // might not be present.
  //
  if (IsFilterLastLogon())
  {
    int iFindLast = m_szQueryString.Find(L"lastLogonTimestamp");
    if (iFindLast == -1)
    {
      //
      // we didn't find it
      //
      CString szTemp;
      szTemp = m_szQueryString.Left(m_szQueryString.GetLength() - 1);
      
      AppendLastLogonQuery(szTemp, m_dwLastLogonDays);
      szTemp += L")";
      m_szQueryString = szTemp;
    }
  }
  return m_szQueryString;
}

void CSavedQueryNode::FindCookieByDN(LPCWSTR lpszCookieDN, CUINodeList* pNodeList)
{
  ASSERT(IsContainer());
  ASSERT(GetFolderInfo()->GetContainerList()->IsEmpty());

  CUINodeList* pList = GetFolderInfo()->GetLeafList();

  for (POSITION pos = pList->GetHeadPosition(); pos != NULL; )
  {
    CUINode* pCurrentNode = pList->GetNext(pos);
    ASSERT(!pCurrentNode->IsContainer());

    if (!IS_CLASS(*pCurrentNode, CDSUINode))
    {
      // not a node with a cookie, just skip
      ASSERT(FALSE); // should not be there
      continue;
    }

    // is this the right cookie? 
    CDSCookie* pCurrentCookie = GetDSCookieFromUINode(pCurrentNode);
    LPCWSTR lpszCurrentPath = pCurrentCookie->GetPath();
    
    if (_wcsicmp(lpszCurrentPath, lpszCookieDN) == 0)
    {
      // found, add to list and bail out (cannot have more than one)
      pNodeList->AddTail(pCurrentNode);
      return;
    }
  } // for

}


BOOL CSavedQueryNode::IsDeleteAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = FALSE;
  return TRUE;
}

BOOL CSavedQueryNode::IsRenameAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = FALSE;
  return TRUE;
}

BOOL CSavedQueryNode::IsRefreshAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = FALSE;
  return TRUE;
}

BOOL CSavedQueryNode::IsCutAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = FALSE;
  return TRUE;
}

BOOL CSavedQueryNode::IsCopyAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = FALSE;
  return TRUE;
}

BOOL CSavedQueryNode::IsPasteAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = FALSE;
  return TRUE;
}

CContextMenuVerbs* CSavedQueryNode::GetContextMenuVerbsObject(CDSComponentData* pComponentData)
{ 
  if (m_pMenuVerbs == NULL)
  {
    m_pMenuVerbs = new CSavedQueryMenuVerbs(pComponentData);
  }
  return m_pMenuVerbs;
}

HRESULT CSavedQueryNode::Delete(CDSComponentData* pComponentData)
{
  HRESULT hr = S_OK;

  //
  // this is just a message box, using ReportErrorEx for consistency of look
  //
  int answer = ReportErrorEx(pComponentData->GetHWnd(),IDS_CONFIRM_DELETE_QUERY,S_OK,
                             MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2, NULL, 0);
  if (answer == IDNO) 
  {
    return S_FALSE; // aborted by user
  }

  if (IsContainer())
  {
    hr = pComponentData->RemoveContainerFromUI(this);
    delete this;
  }
  else
  {
    CUINode* pParentNode = GetParent();
    ASSERT(pParentNode->IsContainer());

    pParentNode->GetFolderInfo()->RemoveNode(this);
    //
    // The CDSEvent::_DeleteSingleSel() handles removing the node from the UI
    //
  }
  return hr;
}

HRESULT CSavedQueryNode::OnCommand(long lCommandID, CDSComponentData* pComponentData)
{
  HRESULT hr = S_OK;

  switch (lCommandID)
  {
    case IDM_EXPORT_QUERY:
      OnExportQuery(pComponentData);
      break;
    case IDM_EDIT_QUERY:
      OnEditQuery(pComponentData);
      break;
    case IDM_VIEW_ADVANCED:
      {
        if (pComponentData->CanRefreshAll()) 
        {
          ASSERT( SNAPINTYPE_SITE != pComponentData->QuerySnapinType() );
          pComponentData->GetQueryFilter()->ToggleAdvancedView();
          pComponentData->SetDirty(TRUE);
          pComponentData->RefreshAll();
        }
      }
      break;
    default:
      ASSERT(FALSE);
      break;
  }

  return hr;
}

void CSavedQueryNode::OnEditQuery(CDSComponentData* pComponentData)
{
  CFavoritesNode* pFavNode = dynamic_cast<CFavoritesNode*>(GetParent());
  if (pFavNode != NULL)
  {
    CQueryDialog dlg(this, pFavNode, pComponentData, FALSE);
    if (dlg.DoModal() == IDOK)
    {
      pComponentData->UpdateItem(this);

      //
      // Removed on 11/06/2000 due to Whistler bug #120727:
      // DS Admin snapin - query executes immediately after editting, even when editted from results pane
      //
      //pComponentData->Refresh(this);
    }
  }
  else
  {
    //
    // This should always succeed.  Query nodes are only allowed as children of CFavoritesNode
    //
    ASSERT(FALSE);
  }
}

HRESULT CSavedQueryNode::Rename(LPCWSTR lpszNewName, CDSComponentData* pComponentData)
{
  HRESULT hr = S_OK;
  CString szNewName = lpszNewName;

  CString szTitle;
  VERIFY(szTitle.LoadString(IDS_DSSNAPINNAME));

  //
  // Trim whitespace
  //
  szNewName.TrimLeft();
  szNewName.TrimRight();

  if (szNewName.IsEmpty())
  {
    //
    // Don't allow empty names
    //
    CString szMessage;
    VERIFY(szMessage.LoadString(IDS_ERRMSG_NO_EMPTY_NAMES));
    MessageBox(pComponentData->GetHWnd(), szMessage, szTitle, MB_OK | MB_ICONSTOP);
    return S_FALSE;
  }

  CUINode* pDupNode = NULL;
  CFavoritesNode* pParent = GetFavoritesNode();
  if (pParent != NULL && !pParent->IsUniqueName(szNewName, &pDupNode))
  {
    if (pDupNode == this)
    {
      //
      // We are renaming the node to the same name. Just silently ignore.
      //
      return S_FALSE;
    }

    CString szFormatMsg;
    VERIFY(szFormatMsg.LoadString(IDS_ERRMSG_NOT_UNIQUE_QUERY_NAME_INPLACE));

    CString szErrMsg;
    szErrMsg.Format(szFormatMsg, szNewName);

    MessageBox(pComponentData->GetHWnd(), szErrMsg, szTitle, MB_OK | MB_ICONSTOP);
    return S_FALSE;
  }

  //
  // Set the name
  //
  SetName(szNewName);
  hr = pComponentData->UpdateItem(this);
  return hr;
}

void CSavedQueryNode::OnExportQuery(CDSComponentData*)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  CString szFilter;
  VERIFY(szFilter.LoadString(IDS_QUERY_EXPORT_FILTER));

  CString szFileExt(L"xml");
  CString szFileView(L"*.xml");

  CFileDialog* pFileDlg = new CFileDialog(FALSE, 
                                          szFileExt, 
                                          szFileView, 
                                          OFN_HIDEREADONLY | OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT,
                                          szFilter);

  if (pFileDlg == NULL)
  {
    return;
  }

  if (pFileDlg->DoModal() == IDOK)
  {
    //
    // create an instance of the XML document
    //
    CComPtr<IXMLDOMDocument> spXMLDoc;

    HRESULT hr = ::CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_IXMLDOMDocument, (void**)&spXMLDoc);
    if (FAILED(hr))
    {
      TRACE(L"CoCreateInstance(CLSID_DOMDocument) failed with hr = 0x%x\n", hr);
      return;
    }

    //
    // Retrieve the file and path
    //
    CString szFileName;
    szFileName = pFileDlg->GetPathName();

    //
    // save the node to the document
    //
    CComVariant xmlSource;
    xmlSource = szFileName;
    CComPtr<IXMLDOMNode> spXMLDOMChildNode;
    hr = XMLSave(spXMLDoc, &spXMLDOMChildNode);
    if (SUCCEEDED(hr))
    {
      CComPtr<IXMLDOMNode> spXDOMNode;
      hr = spXMLDoc->QueryInterface(IID_IXMLDOMNode, (void **)&spXDOMNode);
      if (SUCCEEDED(hr))
      {
        CComPtr<IXMLDOMNode> spXDOMNewNode;
        hr = spXDOMNode->appendChild(spXMLDOMChildNode, &spXDOMNewNode);
        if (SUCCEEDED(hr))
        {
          //
          // save the document to the file
          //
          hr = spXMLDoc->save(xmlSource);
          TRACE(L"Save returned with hr = 0x%x\n", hr);
        }
      }
    }
  }  

  if (pFileDlg != NULL)
  {
    delete pFileDlg;
    pFileDlg = NULL;
  }
}

LPCWSTR CSavedQueryNode::g_szObjXMLTag = L"QUERY";
LPCWSTR CSavedQueryNode::g_szDnXMLTag = L"DN";
LPCWSTR CSavedQueryNode::g_szOneLevelXMLTag = L"ONELEVEL";
LPCWSTR CSavedQueryNode::g_szQueryStringXMLTag = L"LDAPQUERY";
LPCWSTR CSavedQueryNode::g_szLastLogonFilterTag = L"FILTERLASTLOGON";
LPCWSTR CSavedQueryNode::g_szDSQueryPersistTag = L"DSQUERYUIDATA";
LPCWSTR CSavedQueryNode::g_szColumnIDTag = L"COLUMNID";

HRESULT CSavedQueryNode::XMLLoad(CDSComponentData* pComponentData,
                                 IXMLDOMNode* pXDN, 
                                 CSavedQueryNode** ppQuery)
{
  *ppQuery = NULL;

  // check the name of the node
  if (!XMLIsNodeName(pXDN, CSavedQueryNode::g_szObjXMLTag))
  {
    // should have checked before calling...
    ASSERT(FALSE);
    return E_INVALIDARG;
  }


  // get the list of child  nodes
  CComPtr<IXMLDOMNode> spCurrChild;
  pXDN->get_firstChild(&spCurrChild);
  if (spCurrChild == NULL)
  {
    return E_INVALIDARG;
  }

  // allocate a query object
  *ppQuery = new CSavedQueryNode(pComponentData->GetBasePathsInfo());

  CComBSTR bstrName, bstrDescription, bstrDN, bstrQueryString, bstrColumnID;
  CComBSTR bstrChildName;

  bool bGotName  = false;
  bool bGotDN    = false;
  bool bGotQuery = false;
  bool bGotScope = false;

  while (spCurrChild != NULL)
  {
    spCurrChild->get_nodeName(&bstrChildName);
    if (CompareXMLTags(bstrChildName, CGenericUINode::g_szNameXMLTag))
    {
      if (SUCCEEDED(XML_GetNodeText(spCurrChild, &bstrName)))
      {
        (*ppQuery)->SetName(bstrName);
        bGotName = true;
      }
    }
    else if (CompareXMLTags(bstrChildName, CGenericUINode::g_szDecriptionXMLTag))
    {
      if (SUCCEEDED(XML_GetNodeText(spCurrChild, &bstrDescription)))
      {
        (*ppQuery)->SetDesc(bstrDescription);
      }
    }
    else if (CompareXMLTags(bstrChildName, CSavedQueryNode::g_szDnXMLTag))
    {
      if (SUCCEEDED(XML_GetNodeText(spCurrChild, &bstrDN)))
      {
        (*ppQuery)->SetRootPath(bstrDN);
        bGotDN = true;
      }
    }
    else if (CompareXMLTags(bstrChildName, CSavedQueryNode::g_szQueryStringXMLTag))
    {
      if (SUCCEEDED(XML_GetNodeText(spCurrChild, &bstrQueryString)))
      {
        (*ppQuery)->SetQueryString(bstrQueryString);
        bGotQuery = true;
      }
    }
    else if (CompareXMLTags(bstrChildName, CSavedQueryNode::g_szOneLevelXMLTag))
    {
      BOOL b;
      if (SUCCEEDED(XML_GetNodeBOOL(spCurrChild, &b)))
      {
        (*ppQuery)->SetOneLevel(b);
        bGotScope = true;
      }
    }
    else if (CompareXMLTags(bstrChildName, CSavedQueryNode::g_szLastLogonFilterTag))
    {
      DWORD dwDays;
      if (SUCCEEDED(XML_GetNodeDWORD(spCurrChild, &dwDays)))
      {
        (*ppQuery)->SetLastLogonQuery(dwDays);
      }
      else
      {
        (*ppQuery)->SetLastLogonQuery((DWORD)-1);
      }
    }
    else if (CompareXMLTags(bstrChildName, CSavedQueryNode::g_szColumnIDTag))
    {
      if (SUCCEEDED(XML_GetNodeText(spCurrChild, &bstrColumnID)))
      {
        (*ppQuery)->SetColumnID(pComponentData, bstrColumnID);
      }
    }
    else if (CompareXMLTags(bstrChildName, CSavedQueryNode::g_szDSQueryPersistTag))
    {
      BYTE* pByteArray = NULL;
      ULONG nByteCount = 0;
      if (SUCCEEDED(XML_GetNodeBlob(spCurrChild, &pByteArray, &nByteCount)))
      {
        if (pByteArray != NULL && nByteCount > 0)
        {
          //
          // Create a dummy stream object
          //
          CComObject<CDummyStream>* pDummyStream;
          CComObject<CDummyStream>::CreateInstance(&pDummyStream);
          if (pDummyStream != NULL)
          {
            HRESULT hr = pDummyStream->SetStreamData(pByteArray, nByteCount);
            if (SUCCEEDED(hr))
            {
              //
              // Create a temporary CDSAdminPersistQueryFilterImpl object
              //
              CComObject<CDSAdminPersistQueryFilterImpl>* pPersistQueryImpl;
              CComObject<CDSAdminPersistQueryFilterImpl>::CreateInstance(&pPersistQueryImpl);

              if (pPersistQueryImpl != NULL)
              {
                //
                // Load the CDSAdminPersistQueryFilterImpl from the dummy stream
                //
                hr = pPersistQueryImpl->Load(pDummyStream);
                if (SUCCEEDED(hr))
                {
                  //
                  // Save the CDSAdminPersistQueryFilterImpl into the new query node
                  //
                  (*ppQuery)->SetQueryPersist(pPersistQueryImpl);
                }
              }
            }
          }
        }
      }
    }

    // iterate to next item
    CComPtr<IXMLDOMNode> temp = spCurrChild;
    spCurrChild = NULL;
    temp->get_nextSibling(&spCurrChild);
  }

  if (!bGotName  ||
      !bGotDN    ||
      !bGotQuery ||
      !bGotScope)
  {
    return E_FAIL;
  }
  return S_OK;
}

HRESULT CSavedQueryNode::XMLSave(IXMLDOMDocument* pXMLDoc,
               IXMLDOMNode** ppXMLDOMNode)
{
  // create the node for the object itself
  CComPtr<IXMLDOMNode> spXMLDOMNode;
  HRESULT hr = XML_CreateDOMNode(pXMLDoc, NODE_ELEMENT, CSavedQueryNode::g_szObjXMLTag, &spXMLDOMNode);
  RETURN_IF_FAILED(hr);

  // create inner nodes with member variables
  hr = XMLSaveBase(pXMLDoc, spXMLDOMNode);
  RETURN_IF_FAILED(hr);

  //
  // Root path
  //
  hr = XML_AppendTextDataNode(pXMLDoc, spXMLDOMNode, CSavedQueryNode::g_szDnXMLTag, m_szRelativeRootPath);
  RETURN_IF_FAILED(hr);

  //
  // Filter on last logon timestamp
  //
  hr = XML_AppendDWORDDataNode(pXMLDoc, spXMLDOMNode, CSavedQueryNode::g_szLastLogonFilterTag, m_dwLastLogonDays);
  RETURN_IF_FAILED(hr);

  //
  // Query string
  //

  //
  // Have to remove the last logon timestamp if its there
  //
  CString szSaveQueryString;
  if (IsFilterLastLogon())
  {
    int iFindLast = m_szQueryString.Find(L"lastLogonTimestamp");
    if (iFindLast != -1)
    {
      szSaveQueryString = m_szQueryString.Left(iFindLast - 1);
      szSaveQueryString += L")";
    }
    else
    {
      szSaveQueryString = m_szQueryString;
    }
  }
  else
  {
    szSaveQueryString = m_szQueryString;
  }
  hr = XML_AppendTextDataNode(pXMLDoc, spXMLDOMNode, CSavedQueryNode::g_szQueryStringXMLTag, szSaveQueryString);
  RETURN_IF_FAILED(hr);

  //
  // Is one level query flag
  //
  hr = XML_AppendBOOLDataNode(pXMLDoc, spXMLDOMNode, CSavedQueryNode::g_szOneLevelXMLTag, IsOneLevel());
  RETURN_IF_FAILED(hr);

  //
  // Column ID
  //
  hr = XML_AppendTextDataNode(pXMLDoc, spXMLDOMNode, CSavedQueryNode::g_szColumnIDTag, m_szColumnID);
  RETURN_IF_FAILED(hr);

  //
  // Create a dummy stream object to write the saved query UI info into
  //
  CComObject<CDummyStream>* pDummyStream;
  CComObject<CDummyStream>::CreateInstance(&pDummyStream);

  if (pDummyStream != NULL)
  {
    if (m_pPersistQueryImpl != NULL)
    {
      hr = m_pPersistQueryImpl->Save(pDummyStream);
      if (SUCCEEDED(hr))
      {
        BYTE* pByteArray = NULL;
        ULONG nByteCount = 0;
        nByteCount = pDummyStream->GetStreamData(&pByteArray);
        if (nByteCount > 0 && pByteArray != NULL)
        {
          hr = XML_AppendStructDataNode(pXMLDoc, spXMLDOMNode, CSavedQueryNode::g_szDSQueryPersistTag, pByteArray, nByteCount);
          RETURN_IF_FAILED(hr);
          delete[] pByteArray;
        }
      }
    }
  }

  (*ppXMLDOMNode) = spXMLDOMNode;
  (*ppXMLDOMNode)->AddRef();
  return hr;
}

void CSavedQueryNode::SetQueryPersist(CComObject<CDSAdminPersistQueryFilterImpl>* pPersistQueryImpl)
{
  if (m_pPersistQueryImpl != NULL)
  {
    m_pPersistQueryImpl->Release();
    m_pPersistQueryImpl = NULL;
  }
  m_pPersistQueryImpl = pPersistQueryImpl;
  m_pPersistQueryImpl->AddRef();
}

//
// Function used in a recursive search through the saved query tree looking 
// for saved queries that contain objects with any of the DNs in the list 
// and invalidates that query
//
void CSavedQueryNode::InvalidateSavedQueriesContainingObjects(CDSComponentData* pComponentData,
                                                              const CStringList& refDNList)
{
  ASSERT(IsContainer());

  CUINodeList nodeList;

  POSITION pos = refDNList.GetHeadPosition();
  while (pos)
  {
    CString szDN = refDNList.GetNext(pos);
    FindCookieByDN(szDN, &nodeList);
    if (nodeList.GetCount() > 0)
    {
      //
      // An object from the list was found, make the saved query invalid and
      // break
      //
      SetValid(FALSE);
      pComponentData->ChangeScopeItemIcon(this);
      break;
    }
  }
}


////////////////////////////////////////////////////////////////////////////
// CFavoritesNodesHolder

/* For test purposes Only
void CFavoritesNodesHolder::BuildTestTree(LPCWSTR lpszXMLFileName, SnapinType snapinType)
{
  if (lpszXMLFileName == NULL)
  {
    // no file name passed, build the hardwired version
    BuildTestTreeHardWired(snapinType);
    return;
  }

  if (!BuildTestTreefromXML(lpszXMLFileName, snapinType))
  {
    // we failed, use hardwired
    BuildTestTreeHardWired(snapinType);
  }
}
  
BOOL CFavoritesNodesHolder::BuildTestTreefromXML(LPCWSTR lpszXMLFileName, SnapinType)
{
  // create an instance of the XML document
  CComPtr<IXMLDOMDocument> spXMLDoc;

  HRESULT hr = ::CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
         IID_IXMLDOMDocument, (void**)&spXMLDoc);
  if (FAILED(hr))
  {
    TRACE(L"CoCreateInstance(CLSID_DOMDocument) failed with hr = 0x%x\n", hr);
    return FALSE;
  }

  // load the document from file
  CComVariant xmlSource;
  xmlSource = lpszXMLFileName;
  VARIANT_BOOL isSuccessful;
  hr = spXMLDoc->load(xmlSource, &isSuccessful);
  if (FAILED(hr))
  {
    CString szMsg;
    szMsg.Format(L"spXMLDoc->load() failed with hr = 0x%x\n", hr);
    TRACE((LPCWSTR)szMsg);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    AfxMessageBox(szMsg);
    return FALSE;
  }

  // get the root of the document
  CComPtr<IXMLDOMNode> spXDN;
  hr = spXMLDoc->QueryInterface(IID_IXMLDOMNode, (void **)&spXDN);
  if (FAILED(hr))
  {
    TRACE(L"spXMLDoc->QueryInterface(IID_IXMLDOMNode() failed with hr = 0x%x\n", hr);
    return FALSE;
  }

  // find where the FOLDER tree starts in the document
  CComPtr<IXMLDOMNode> spXMLFolderRootnode;
  hr = XML_FindSubtreeNode(spXDN, CFavoritesNode::g_szObjXMLTag, &spXMLFolderRootnode);
  if (FAILED(hr))
  {
    wprintf(L"XML_FindSubtreeNode() on FOLDER failed with hr = 0x%x\n", hr);
    return FALSE;
  }

  CFavoritesNode* pRootNode = NULL;
  if (spXMLFolderRootnode != NULL)
  {
    // have an XML root folder node, load it into the
    // in memory tree
    CFavoritesNode::XMLLoad(pComponentData, spXMLFolderRootnode, &pRootNode);
  }
  else
  {
    TRACE(L"XML_FindSubtreeNode() returned a NULL root folder node");
  }

  if (pRootNode == NULL)
  {
    TRACE(L"CFavoritesNode::XMLLoad() returned NULL root node\n");
    return FALSE;
  }

  // REVIEW_MARCOC: this is a hack to get things ported,
  // need to review XML schema
  // now we have a tree, need to graft underneath the folder root node
  
  // move the first level of children
  CUINodeList* pNodeList = pRootNode->GetFolderInfo()->GetContainerList();
  while (!pNodeList->IsEmpty())
  {
    CUINode* p = pNodeList->RemoveHead();
    p->ClearParent();
    m_favoritesRoot.GetFolderInfo()->AddNode(p);
  }
  // copy the info in the root
  m_favoritesRoot.SetName(pRootNode->GetName());
  m_favoritesRoot.SetDesc(pRootNode->GetDesc());

  // delete root
  delete pRootNode;

  return TRUE;
}
*/
/* For testing purposes only
void CFavoritesNodesHolder::BuildTestTreeHardWired(SnapinType snapinType)
{

  // fill in the root
  m_favoritesRoot.SetName(L"Saved Queries");
  m_favoritesRoot.SetDesc(L"Folder to store your favorite queries");

  // first level of children

  CFavoritesNode* pMostUsed = new CFavoritesNode;
  pMostUsed->SetName(L"Most Used");
  pMostUsed->SetDesc(L"Very handy queries, used all the time");
  m_favoritesRoot.GetFolderInfo()->AddNode(pMostUsed);

  CFavoritesNode* pMarketing = new CFavoritesNode;
  pMarketing->SetName(L"Marketing");
  m_favoritesRoot.GetFolderInfo()->AddNode(pMarketing);

  CFavoritesNode* pDevelopment = new CFavoritesNode;
  pDevelopment->SetName(L"Development");
  m_favoritesRoot.GetFolderInfo()->AddNode(pDevelopment);

  CFavoritesNode* pCustomerSupport = new CFavoritesNode;
  pCustomerSupport->SetName(L"Customer Support");
  m_favoritesRoot.GetFolderInfo()->AddNode(pCustomerSupport);


  // fill in under most used

  CSavedQueryNode* pQuery = new CSavedQueryNode(snapinType);
  pQuery->SetName(L"My contacts");
  pQuery->SetDesc(L"All the contacts in this domain");
  pQuery->SetRootPath(L"DC=marcocdev;DC=nttest;DC=microsoft;DC=com");
  pQuery->SetOneLevel(FALSE);
  pQuery->SetQueryString(L"(objectClass=contact)");

  pMostUsed->GetFolderInfo()->AddNode(pQuery);


  CFavoritesNode* pMyComputersFolder = new CFavoritesNode;
  pMyComputersFolder->SetName(L"My Computers");
  pMostUsed->GetFolderInfo()->AddNode(pMyComputersFolder);

  pQuery = new CSavedQueryNode(snapinType);
  pQuery->SetName(L"Workstations");
  pQuery->SetDesc(L"");
  pQuery->SetRootPath(L"DC=marcocdev;DC=nttest;DC=microsoft;DC=com");
  pQuery->SetOneLevel(FALSE);
  pQuery->SetQueryString(L"(objectClass=computer)");

  pMyComputersFolder->GetFolderInfo()->AddNode(pQuery);


  pQuery = new CSavedQueryNode(snapinType);
  pQuery->SetName(L"Servers");
  pQuery->SetDesc(L"");
  pQuery->SetRootPath(L"DC=marcocdev;DC=nttest;DC=microsoft;DC=com");
  pQuery->SetOneLevel(FALSE);
  pQuery->SetQueryString(L"(objectClass=computer)");

  pMyComputersFolder->GetFolderInfo()->AddNode(pQuery);


  pQuery = new CSavedQueryNode(snapinType);
  pQuery->SetName(L"All");
  pQuery->SetDesc(L"");
  pQuery->SetRootPath(L"DC=marcocdev;DC=nttest;DC=microsoft;DC=com");
  pQuery->SetOneLevel(FALSE);
  pQuery->SetQueryString(L"(objectClass=computer)");

  pMyComputersFolder->GetFolderInfo()->AddNode(pQuery);





  // fill in under development

  pQuery = new CSavedQueryNode(snapinType);
  pQuery->SetName(L"Users");
  pQuery->SetDesc(L"");
  pQuery->SetRootPath(L"DC=marcocdev;DC=nttest;DC=microsoft;DC=com");
  pQuery->SetOneLevel(TRUE);
  pQuery->SetQueryString(L"(objectClass=users)");
  pDevelopment->GetFolderInfo()->AddNode(pQuery);

  pQuery = new CSavedQueryNode(snapinType);
  pQuery->SetName(L"Computers");
  pQuery->SetDesc(L"");
  pQuery->SetRootPath(L"DC=marcocdev;DC=nttest;DC=microsoft;DC=com");
  pQuery->SetOneLevel(TRUE);
  pQuery->SetQueryString(L"(objectClass=computer)");
  pDevelopment->GetFolderInfo()->AddNode(pQuery);

  pQuery = new CSavedQueryNode(snapinType);
  pQuery->SetName(L"Groups");
  pQuery->SetDesc(L"");
  pQuery->SetRootPath(L"DC=marcocdev;DC=nttest;DC=microsoft;DC=com");
  pQuery->SetOneLevel(TRUE);
  pQuery->SetQueryString(L"(objectClass=group)");
  pDevelopment->GetFolderInfo()->AddNode(pQuery);

  pQuery = new CSavedQueryNode(snapinType);
  pQuery->SetName(L"Managers");
  pQuery->SetDesc(L"");
  pQuery->SetRootPath(L"DC=marcocdev;DC=nttest;DC=microsoft;DC=com");
  pQuery->SetOneLevel(TRUE);
  pQuery->SetQueryString(L"(objectClass=user)");
  pDevelopment->GetFolderInfo()->AddNode(pQuery);

}
*/

HRESULT CFavoritesNodesHolder::Save(IStream* pStm)
{
  //
  // create an instance of the XML document
  //
  CComPtr<IXMLDOMDocument> spXMLDoc;

  HRESULT hr = ::CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
                                  IID_IXMLDOMDocument, (void**)&spXMLDoc);
  if (FAILED(hr))
  {
    TRACE(L"CoCreateInstance(CLSID_DOMDocument) failed with hr = 0x%x\n", hr);
    return hr;
  }

  CComPtr<IXMLDOMNode> spXMLDOMChildNode;
  hr = m_favoritesRoot.XMLSave(spXMLDoc, &spXMLDOMChildNode);
  if (SUCCEEDED(hr))
  {
    if (SUCCEEDED(hr))
    {
      CComPtr<IXMLDOMNode> spXDOMNode;
      hr = spXMLDoc->QueryInterface(IID_IXMLDOMNode, (void **)&spXDOMNode);
      if (SUCCEEDED(hr))
      {
        CComPtr<IXMLDOMNode> spXDOMNewNode;
        hr = spXDOMNode->appendChild(spXMLDOMChildNode, &spXDOMNewNode);
        if (SUCCEEDED(hr))
        {
          //
          // save the document to the file
          //
          CComVariant xmlSource;
          xmlSource = pStm;
          hr = spXMLDoc->save(xmlSource);
          TRACE(L"Save returned with hr = 0x%x\n", hr);
        }
      }
    }
  }
  return hr;
}

HRESULT CFavoritesNodesHolder::Load(IStream* pStm, 
                                    CDSComponentData* pComponentData)
{
  //
  // create an instance of the XML document
  //
  CComPtr<IXMLDOMDocument> spXMLDoc;

  HRESULT hr = ::CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
                                  IID_IXMLDOMDocument, (void**)&spXMLDoc);
  if (FAILED(hr))
  {
    TRACE(L"CoCreateInstance(CLSID_DOMDocument) failed with hr = 0x%x\n", hr);
    return hr;
  }

  CComPtr<IUnknown> spUnknown;
  hr = pStm->QueryInterface(IID_IUnknown, (void**)&spUnknown);
  if (SUCCEEDED(hr))
  {
    CComVariant xmlSource;
    xmlSource = spUnknown;
    VARIANT_BOOL isSuccess;
    hr = spXMLDoc->load(xmlSource, &isSuccess);
    if (SUCCEEDED(hr))
    {
      //
      // get the root of the document
      //
      CComPtr<IXMLDOMNode> spXDN;
      hr = spXMLDoc->QueryInterface(IID_IXMLDOMNode, (void **)&spXDN);
      if (SUCCEEDED(hr))
      {
        //
        // find where the FOLDER tree starts in the document
        //
        CComPtr<IXMLDOMNode> spXMLFolderRootnode;
        hr = XML_FindSubtreeNode(spXDN, CFavoritesNode::g_szObjXMLTag, &spXMLFolderRootnode);
        if (SUCCEEDED(hr))
        {
          if (spXMLFolderRootnode != NULL)
          {
            //
            // have an XML root folder node, load it into the
            // in memory tree
            //
            hr = m_favoritesRoot.Load(spXMLFolderRootnode, pComponentData);
            if (FAILED(hr))
            {
              //
              // REVIEW_JEFFJON : provide a meaningful error message
              //
            }
          }
        }
      }
    }
  }
  return hr;
}

//
// Starts a recursive search through the saved query tree looking for saved queries that 
// contain objects with any of the DNs in the list and invalidates that query
//
void CFavoritesNodesHolder::InvalidateSavedQueriesContainingObjects(CDSComponentData* pComponentData,
                                                                    const CStringList& refDNList)
{
  GetFavoritesRoot()->InvalidateSavedQueriesContainingObjects(pComponentData,
                                                              refDNList);
}


////////////////////////////////////////////////////////////////////////////////////

HRESULT CDummyStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
  if (m_pByteArray == NULL || m_nByteCount == 0)
  {
    *pcbRead = 0;
    return S_FALSE;
  }

  if (pv == NULL)
  {
    *pcbRead = 0;
    return STG_E_INVALIDPOINTER;
  }

  ULONG nBytesPossible = m_nByteCount - m_nReadIndex;
  if (nBytesPossible <= 0)
  {
    *pcbRead = 0;
    return S_FALSE;
  }

  ULONG nBytesToRead = 0;
  if (nBytesPossible >= cb)
  {
    nBytesToRead = cb;
  }
  else
  {
    nBytesToRead = nBytesPossible;
  }

  memcpy(pv, &(m_pByteArray[m_nReadIndex]), nBytesToRead);
  *pcbRead = nBytesToRead;
  m_nReadIndex += nBytesToRead;
  return S_OK;
}

HRESULT CDummyStream::Write(void const *pv, ULONG cb, ULONG *pcbWritten)
{
  BYTE* pNewByteArray = new BYTE[m_nByteCount + cb];
  if (pNewByteArray == NULL)
  {
    *pcbWritten = 0;
    return E_OUTOFMEMORY;
  }

  if (m_pByteArray != NULL && m_nByteCount > 0)
  {
    memcpy(pNewByteArray, m_pByteArray, m_nByteCount);
  }
  memcpy(&(pNewByteArray[m_nByteCount]), pv, cb);

  if (m_pByteArray != NULL)
  {
    delete[] m_pByteArray;
  }
  m_pByteArray = pNewByteArray;
  *pcbWritten = cb;
  m_nByteCount = m_nByteCount + cb;
  return S_OK;
}

ULONG CDummyStream::GetStreamData(BYTE** ppByteArray)
{
  if (m_pByteArray == NULL)
  {
    *ppByteArray = NULL;
    return 0;
  }

  *ppByteArray = new BYTE[m_nByteCount];
  if (*ppByteArray == NULL)
  {
    return 0;
  }

  memcpy(*ppByteArray, m_pByteArray, m_nByteCount);
  return m_nByteCount;
}

HRESULT CDummyStream::SetStreamData(BYTE* pByteArray, ULONG nByteCount)
{
  if (m_pByteArray != NULL)
  {
    delete[] m_pByteArray;
    m_pByteArray = NULL;
  }

  m_pByteArray = pByteArray;
  m_nByteCount = nByteCount;
  m_nReadIndex = 0;
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\query.h ===
//+----------------------------------------------------------------------------
//
//  DS Administration MMC snapin.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       query.h
//
//--------------------------------------------------------------------------


#ifndef __QUERY_
#define __QUERY_

#include "dscookie.h"
#include "dsfilter.h"   // CDSAdminPersistQueryFilterImpl

////////////////////////////////////////////////////////////////////////////

class CFavoritesNode : public CGenericUINode
{
public:
  CFavoritesNode();

  void RemoveQueryResults();
  void FindCookiesInQueries(LPCWSTR lpszCookieDN, CUINodeList* pNodeList);

  //
  // These set the state of the standard context menu items
  //
  virtual BOOL IsDeleteAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsRenameAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsRefreshAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsCutAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsCopyAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsPasteAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL ArePropertiesAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL HasPropertyPages(LPDATAOBJECT) { return TRUE; }

  virtual CContextMenuVerbs* GetContextMenuVerbsObject(CDSComponentData* pComponentData);
  virtual HRESULT OnCommand(long lCommandID, CDSComponentData* pComponentData);

  virtual BOOL    IsUniqueName(PCWSTR pszName, CUINode** ppDuplicateNode);
  virtual HRESULT Rename(LPCWSTR lpszNewName, CDSComponentData* pComponentData);
  virtual HRESULT Delete(CDSComponentData* pComponentData);
  virtual HRESULT DeleteMultiselect(CDSComponentData* pComponentData, CInternalFormatCracker* pObjCracker);

  virtual void    Paste(IDataObject* pPasteData, CDSComponentData* pComponentData, LPDATAOBJECT* ppCutDataObj);
  virtual HRESULT QueryPaste(IDataObject* pPasteData, CDSComponentData* pComponentData);

  CFavoritesNode* GetFavoritesNode() { return dynamic_cast<CFavoritesNode*>(GetParent()); }
  virtual BOOL    IsFavoritesRoot()  { return m_bFavoritesRoot; }
  virtual void    SetRoot(BOOL bRoot) { m_bFavoritesRoot = bRoot; }

  virtual LPCWSTR GetDisplayString(int nCol, CDSColumnSet*)
  {
    if (IsFavoritesRoot())
    {
      if (nCol == 0)
        return GetName();
      else if (nCol == 2)
        return GetDesc();
    }
    else
    {
      if (nCol == 0)
        return GetName();
      else if (nCol == 1)
        return GetDesc();
    }
    return L"";
  }

  //
  // Context menu command handlers
  //
  void OnImportQuery(CDSComponentData* pComponentData);
  void OnNewFavoritesFolder(CDSComponentData* pComponentData);
  void OnNewSavedQuery(CDSComponentData* pComponentData);

  BOOL DeepCopyChildren(CUINode* pUINodeToCopy);

  virtual HRESULT XMLSave(IXMLDOMDocument* pXMLDoc,
    IXMLDOMNode** ppXMLDOMNode);

  //
  // Used to load the embedded favorites root node
  // All other favorites folders are loaded through the static method XMLLoad
  //
  HRESULT CFavoritesNode::Load(IXMLDOMNode* pXDN, CDSComponentData* pComponentData);

  //
  // static members for XML serialization
  //
  static HRESULT XMLLoad(CDSComponentData* pComponentData,
                         IXMLDOMNode* pXDN, 
                         CFavoritesNode** ppNode);
  static LPCWSTR g_szObjXMLTag;

  virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK pCall,
                                      LONG_PTR lNotifyHandle,
                                      LPDATAOBJECT pDataObject,
                                      CDSComponentData* pComponentData);

  virtual void InvalidateSavedQueriesContainingObjects(CDSComponentData* pComponentData,
                                                       const CStringList& refDNList);

private:
  bool IsSameSnapin(IDataObject* pPasteData, CDSComponentData* pComponentData);



  BOOL m_bFavoritesRoot;

};


////////////////////////////////////////////////////////////////////////////

HRESULT FilterDisabledAccounts(CUINodeList* pUINodeList);
HRESULT FilterNonExpiringPwds(CUINodeList* pUINodeList);

class CSavedQueryNode : public CGenericUINode
{
public:
  CSavedQueryNode(MyBasePathsInfo* pBasePathsInfo,
                  SnapinType snapinType = SNAPINTYPE_DS);
  CSavedQueryNode(const CSavedQueryNode& copyNode);

  void SetRootPath(LPCWSTR lpszRootPath);
  void SetQueryString(LPCWSTR lpszQueryString) { m_szQueryString = lpszQueryString;}

  LPCWSTR GetRootPath();
  LPCWSTR GetQueryString();
  void AppendLastLogonQuery(CString& szQuery, DWORD dwDays);

  CFavoritesNode* GetFavoritesNode() { return dynamic_cast<CFavoritesNode*>(GetParent()); }

  void SetOneLevel(BOOL bOneLevel) { m_bOneLevel = bOneLevel;}
  BOOL IsOneLevel() { return m_bOneLevel;}

  void SetValid(BOOL bValid) { m_bQueryValid = bValid; }
  BOOL IsValid() { return m_bQueryValid; }

  void SetQueryPersist(CComObject<CDSAdminPersistQueryFilterImpl>* pPersistQueryImpl);
  CComObject<CDSAdminPersistQueryFilterImpl>* GetQueryPersist() { return m_pPersistQueryImpl; }

  void FindCookieByDN(LPCWSTR lpszCookieDN, CUINodeList* pNodeList);

  void SetColumnID(CDSComponentData* pComponentData, PCWSTR pszColumnID);

  //
  // These set the state of the standard context menu items
  //
  virtual BOOL IsDeleteAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsRenameAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsRefreshAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsPasteAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsCutAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsCopyAllowed(CDSComponentData* pComponentData, BOOL* pbHide);

  virtual CContextMenuVerbs* GetContextMenuVerbsObject(CDSComponentData* pComponentData);
  virtual HRESULT OnCommand(long lCommandID, CDSComponentData* pComponentData);

  virtual HRESULT Delete(CDSComponentData* pComponentData);
  virtual HRESULT Rename(LPCWSTR lpszNewName, CDSComponentData* pComponentData);

  void OnEditQuery(CDSComponentData* pComponentData);
  void OnExportQuery(CDSComponentData* pComponentData);

  virtual HRESULT XMLSave(IXMLDOMDocument* pXMLDoc,
               IXMLDOMNode** ppXMLDOMNode);

  //
  // static members for XML serialization
  //
  static HRESULT XMLLoad(CDSComponentData* pComponentData,
                         IXMLDOMNode* pXDN, 
                         CSavedQueryNode** ppQuery);
  static LPCWSTR g_szObjXMLTag;
  static LPCWSTR g_szOneLevelXMLTag;
  static LPCWSTR g_szQueryStringXMLTag;
  static LPCWSTR g_szDSQueryPersistTag;
  static LPCWSTR g_szDisabledAccountsFilterTag;
  static LPCWSTR g_szNonExpiringPwdFilterTag;
  static LPCWSTR g_szLastLogonFilterTag;
  static LPCWSTR g_szColumnIDTag;

  BOOL   IsFilterDisabledAccounts();
  BOOL   IsFilterNonExpiringPwds();
  BOOL   IsFilterLastLogon();

  void   SetLastLogonQuery(DWORD dwLastLogonDays)
  { 
    if (dwLastLogonDays != (DWORD)-1)
    {
      m_bLastLogonFilter = TRUE;
    }
    m_dwLastLogonDays = dwLastLogonDays; 
  }

  DWORD  GetLastLogonDays() { return m_dwLastLogonDays; }

  virtual void InvalidateSavedQueriesContainingObjects(CDSComponentData* pComponentData,
                                                       const CStringList& refDNList);

private:
  CString m_szRelativeRootPath;
  CString m_szCurrentFullPath;

  CString m_szColumnID;
  CString m_szQueryString;
  BOOL    m_bOneLevel;
  
  BOOL    m_bQueryValid;

  BOOL    m_bLastLogonFilter;
  DWORD   m_dwLastLogonDays;

  MyBasePathsInfo* m_pBasePathsInfo;

  // 
  // for presisting DSQuery dialog info
  //
	CComObject<CDSAdminPersistQueryFilterImpl>* m_pPersistQueryImpl;
};

////////////////////////////////////////////////////////////////////////////

class CFavoritesNodesHolder
{
public:
  CFavoritesNodesHolder()
  {
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // fill in the root
    m_favoritesRoot.SetRoot(TRUE);

    CString szName;
    szName.LoadString(IDS_SAVED_QUERIES);
    m_favoritesRoot.SetName(szName);

    CString szDescription;
    szDescription.LoadString(IDS_SAVED_QUERIES_DESC);
    m_favoritesRoot.SetDesc(szDescription);
  }

  CFavoritesNode* GetFavoritesRoot() { return &m_favoritesRoot;}

  /* For test purposes ONLY
  void BuildTestTree(LPCWSTR lpszXMLFileName, SnapinType snapinType);
  BOOL BuildTestTreefromXML(LPCWSTR lpszXMLFileName, SnapinType snapinType);
  void BuildTestTreeHardWired(SnapinType snapinType);
  */

  HRESULT Save(IStream* pStm);
  HRESULT Load(IStream* pStm, CDSComponentData* pComponentData);

  virtual void InvalidateSavedQueriesContainingObjects(CDSComponentData* pComponentData,
                                                       const CStringList& refDNList);

private:
  CFavoritesNode m_favoritesRoot;
};


//////////////////////////////////////////////////////////////////////////////

class CDummyStream : 
  public IStream,
  public CComObjectRoot
{
  BEGIN_COM_MAP(CDummyStream)
    COM_INTERFACE_ENTRY(IStream)
  END_COM_MAP()

public:
  CDummyStream() 
  {
    m_pByteArray = NULL;
    m_nReadIndex = 0;
    m_nByteCount = 0;
  }
  ~CDummyStream()
  {
    if (m_pByteArray != NULL)
    {
      delete[] m_pByteArray;
      m_pByteArray = NULL;
    }
  }

  //
  // ISequentialStream Interfaces
  //
  HRESULT STDMETHODCALLTYPE Read(void *pv, ULONG cb, ULONG *pcbRead);
  HRESULT STDMETHODCALLTYPE Write(void const *pv, ULONG cb, ULONG *pcbWritten);

  //
  // IStream Interfaces (none of these are implemented)
  //
  HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER*) { return E_NOTIMPL; }
  HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER) { return E_NOTIMPL; }
  HRESULT STDMETHODCALLTYPE CopyTo(IStream*, ULARGE_INTEGER, ULARGE_INTEGER*, ULARGE_INTEGER*) { return E_NOTIMPL; }
  HRESULT STDMETHODCALLTYPE Commit(DWORD) { return E_NOTIMPL; }
  HRESULT STDMETHODCALLTYPE Revert(void) { return E_NOTIMPL; }
  HRESULT STDMETHODCALLTYPE LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
  HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
  HRESULT STDMETHODCALLTYPE Stat(STATSTG*, DWORD) { return E_NOTIMPL; }
  HRESULT STDMETHODCALLTYPE Clone(IStream**) { return E_NOTIMPL; }

  ULONG   GetStreamData(BYTE** ppByteArray);
  HRESULT SetStreamData(BYTE* pByteArray, ULONG nByteCount);

private:
  BYTE*   m_pByteArray;
  ULONG   m_nByteCount;

  ULONG   m_nReadIndex;
};


#endif // __QUERY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\querysup.cpp ===
// DSQuery.cpp : Implementation of ds routines and classes

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      querysup.cpp
//
//  Contents:  DS Enumeration routines and classes
//
//  History:   02-Oct-96 WayneSc    Created
//
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"

#include "dsutil.h"

#include "dssnap.h"     // NOTE: this must be befroe querysup.h
#include "querysup.h"

#include "dsdirect.h"

#include <lmaccess.h>



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern const INT g_nADsPath;
extern const INT g_nName;
extern const INT g_nDisplayName;
extern const INT g_nObjectClass;
extern const INT g_nGroupType;
extern const INT g_nDescription;
extern const INT g_nUserAccountControl;
extern const INT g_nSystemFlags;


///////////////////////////////////////////////////////////////////////////////
CDSSearch::CDSSearch()
{
  m_bInitialized = FALSE;
  m_pwszFilter = NULL;
  m_pCache = NULL;
  m_pCD = NULL;
  m_pObj = NULL;
  m_SearchHandle = NULL;
}

CDSSearch::CDSSearch(CDSCache *pCache, CDSComponentData *pCD)
{
  m_bInitialized = FALSE;
  m_pwszFilter = NULL;
  m_pCache = pCache;
  m_pCD = pCD;
  m_pObj = NULL;
  m_SearchHandle = NULL;
}


void CDSSearch::_Reset()
{
  if (m_pObj != NULL) 
  {
    if (m_SearchHandle) 
    {
      m_pObj->CloseSearchHandle (m_SearchHandle);
      m_SearchHandle = NULL;
    }
    m_pObj->Release();
    m_pObj = NULL;
  }
}

CDSSearch::~CDSSearch()
{
  _Reset();
}


HRESULT CDSSearch::Init(IDirectorySearch * pObj)
{
  HRESULT            hr = S_OK;
  _Reset();
  m_pObj = pObj;
  pObj->AddRef();
  m_bInitialized = TRUE;
  m_scope = ADS_SCOPE_ONELEVEL;
  
  return hr;
}

HRESULT CDSSearch::Init(LPCWSTR lpszObjectPath)
{
  HRESULT            hr;

  _Reset();

  hr = DSAdminOpenObject(lpszObjectPath,
                         IID_IDirectorySearch,
                         (void **)&m_pObj);
  if (SUCCEEDED(hr)) {
    m_bInitialized = TRUE;
  } else {
    m_bInitialized = FALSE;
    m_pObj = NULL;
  }
  return hr;
}

HRESULT CDSSearch::SetAttributeList (LPTSTR *pszAttribs, INT cAttrs)
{
  if ( !m_pszAttribs.SetCount(cAttrs) )
    return E_OUTOFMEMORY;
  for (INT i = 0; i < cAttrs; i++)
  {
    if ( !m_pszAttribs.Set(pszAttribs[i], i) )
      return E_OUTOFMEMORY;
  }
  return S_OK;
}

HRESULT CDSSearch::SetAttributeListForContainerClass (CDSColumnSet* pColumnSet)
{
  ASSERT(pColumnSet != NULL);

  PWSTR *pAttributes = new PWSTR[g_nStdCols + pColumnSet->GetNumCols()]; // leave extra space
  if (!pAttributes)
  {
    return E_OUTOFMEMORY;
  }

  int nCols = 0;
  for (int i=0; i < g_nStdCols; i++)
  {
    pAttributes[nCols++] = g_pStandardAttributes[i];
  }
  POSITION pos = pColumnSet->GetHeadPosition();
  while (pos != NULL)
  {
    CDSColumn* pCol = (CDSColumn*)pColumnSet->GetNext(pos);
    ASSERT(pCol != NULL);

      if (!(pCol->GetColumnType() == ATTR_COLTYPE_SPECIAL || pCol->GetColumnType() == ATTR_COLTYPE_MODIFIED_TIME) || 
            !pCol->IsVisible())
      continue;

    LPWSTR pNewAttribute = const_cast<LPWSTR>(pCol->GetColumnAttribute());

    //
    // JonN 2/8/99: Do not query the same attribute more than once
    //
    for (int j = 0; j < nCols; j++)
    {
      if ( pNewAttribute != NULL)
      {
        if ( 0 == _wcsicmp( pAttributes[j], pNewAttribute ) )
        {
          pNewAttribute = NULL;
          break;
        }
      }
    }

    if (NULL != pNewAttribute)
      pAttributes[nCols++] = pNewAttribute;
  }

  // JonN 6/29/99: remember the container class name (NULL is OK)
  m_strContainerClassName = pColumnSet->GetClassName();

  HRESULT hr = SetAttributeList (pAttributes, nCols);
  delete[] pAttributes;
  pAttributes = 0;

  return hr;
}

HRESULT CDSSearch::SetSearchScope (ADS_SCOPEENUM scope)
{
  if (m_bInitialized) {
    m_scope = scope;
  }
  return S_OK;
}


const int NUM_PREFS=4;
HRESULT _SetSearchPreference(IDirectorySearch* piSearch, ADS_SCOPEENUM scope)
{
  if (NULL == piSearch)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  ADS_SEARCHPREF_INFO aSearchPref[NUM_PREFS];
  aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
  aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[0].vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
  aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
  aSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[1].vValue.Integer = QUERY_PAGESIZE;
  aSearchPref[2].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
  aSearchPref[2].vValue.dwType = ADSTYPE_BOOLEAN;
  aSearchPref[2].vValue.Integer = FALSE;
  aSearchPref[3].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
  aSearchPref[3].vValue.dwType = ADSTYPE_INTEGER;
  aSearchPref[3].vValue.Integer = scope;

  return piSearch->SetSearchPreference (aSearchPref, NUM_PREFS);
}

HRESULT _FRSMemberQuery( IDirectorySearch* piAnyMember, CMapStringToString& strmap )
{
#define IFTRUERETURN(b) if (b) { return E_FAIL; }
#define IFFAILRETURN(hr) if (FAILED(hr)) { return hr; }

  // get path to container
  CComQIPtr<IADs, &IID_IADs> spIADsContainer( piAnyMember );
  IFTRUERETURN( !spIADsContainer );
  CComBSTR sbstr;
  HRESULT hr = spIADsContainer->get_ADsPath( &sbstr );
  IFFAILRETURN(hr);

  // remove leaf element from path (get path to grandparent)
  CPathCracker pathCracker;
  hr = pathCracker.Set(sbstr, ADS_SETTYPE_FULL);
  IFFAILRETURN(hr);
  hr = pathCracker.RemoveLeafElement();
  IFFAILRETURN(hr);
  sbstr.Empty();
  hr = pathCracker.Retrieve( ADS_FORMAT_X500, &sbstr );
  IFFAILRETURN(hr);

  // set up search
  CComPtr<IDirectorySearch> spSearch;
  hr = DSAdminOpenObject(sbstr,
                         IID_IDirectorySearch,
                         (void **)&spSearch);
  IFFAILRETURN(hr);
  hr = _SetSearchPreference(spSearch, ADS_SCOPE_ONELEVEL);
  IFFAILRETURN(hr);
  DSPROP_BSTR_BLOCK bstrblockAttribs;
  bstrblockAttribs.SetCount( 2 );
  IFTRUERETURN( !bstrblockAttribs.Set( L"distinguishedName", 0 ) );
  IFTRUERETURN( !bstrblockAttribs.Set( L"fRSComputerReference", 1 ) );

  // perform search
  ADS_SEARCH_HANDLE hSearch = NULL;
  hr = spSearch->ExecuteSearch (L"(objectClass=nTFRSMember)",
                                bstrblockAttribs,
                                bstrblockAttribs.QueryCount(),
                                &hSearch);

  // build mapping
  hr = spSearch->GetNextRow ( hSearch );
  while (hr == S_OK) {
    ADS_SEARCH_COLUMN adscol;
    hr = spSearch->GetColumn( hSearch, L"distinguishedName", &adscol );
    IFFAILRETURN(hr);
    CString strDistinguishedName;
    IFTRUERETURN( !ColumnExtractString( strDistinguishedName, NULL, &adscol ) );
    spSearch->FreeColumn( &adscol );

    hr = spSearch->GetColumn( hSearch, L"fRSComputerReference", &adscol );
    IFFAILRETURN(hr);
    CString strFRSComputerReference;
    IFTRUERETURN( !ColumnExtractString( strFRSComputerReference, NULL, &adscol ) );
    spSearch->FreeColumn( &adscol );

    strmap.SetAt( strDistinguishedName, strFRSComputerReference );

    hr = spSearch->GetNextRow( hSearch );
  }
  IFFAILRETURN(hr);
  return S_OK;
}

HRESULT CDSSearch::DoQuery()
{
  BEGIN_PROFILING_BLOCK("CDSSearch::DoQuery");

  if (!m_bInitialized)
    return E_ADS_BAD_PATHNAME;

  HRESULT hr = _SetSearchPreference(m_pObj, m_scope);

  if (SUCCEEDED(hr)) {
    hr = m_pObj->ExecuteSearch (m_pwszFilter,
                                m_pszAttribs,
                                m_pszAttribs.QueryCount(),
                                &m_SearchHandle);
  }

  //
  // JonN 6/29/99: If we are enumerating an nTFRSMember container, we must
  // now perform an auxiliary search for the fRSComputerReference attribute
  // on the nTFRSMember objects which are the parent container and
  // the siblings of the container.
  //
  if (SUCCEEDED(hr) && !m_strContainerClassName.Compare( _T("nTFRSMember") ) ) 
  {
    _FRSMemberQuery( m_pObj, m_mapMemberToComputer );
  }

  END_PROFILING_BLOCK;
  return hr;
}

HRESULT
CDSSearch::GetNextRow()
{
  BEGIN_PROFILING_BLOCK("CDSSearch::GetNextRow");

  DWORD status = ERROR_MORE_DATA;
  HRESULT hr = S_OK;
  HRESULT hr2 = S_OK;
  WCHAR Buffer1[512], Buffer2[512];
  if (!m_bInitialized) {
    END_PROFILING_BLOCK;
    return E_ADS_BAD_PATHNAME;
  }
  while (status == ERROR_MORE_DATA ) {
    hr = m_pObj->GetNextRow (m_SearchHandle);
    if (hr == S_ADS_NOMORE_ROWS) {
      hr2 = ADsGetLastError(&status, Buffer1, 512,
                      Buffer2, 512);
      ASSERT(SUCCEEDED(hr2));
    } else {
      status = 0;
    }
  }
  END_PROFILING_BLOCK;
  return hr;
}

HRESULT
CDSSearch::GetColumn(LPWSTR Attribute,
                     PADS_SEARCH_COLUMN pColumnData)
{
  if (m_bInitialized) {
    return m_pObj->GetColumn (m_SearchHandle,
                              Attribute,
                              pColumnData);
  }
  return E_ADS_BAD_PATHNAME;
}

HRESULT
CDSSearch::SetCookieFromData(CDSCookie* pCookie,
                             CDSColumnSet* pColumnSet)
{
   CPathCracker pathCracker;
   return SetCookieFromData(pCookie, pathCracker, pColumnSet);
}

HRESULT
CDSSearch::SetCookieFromData (CDSCookie* pCookie,
                              CPathCracker& specialPerformancePathCracker,
                              CDSColumnSet* pColumnSet)
{

  if (pCookie==NULL) {
    ASSERT(FALSE); // Invalid Arguments
    return E_INVALIDARG;
  }

  BEGIN_PROFILING_BLOCK("CDSSearch::SetCookieFromData");

  CString str;
  HRESULT hr = S_OK;
  BOOL BadArgs = FALSE;
  INT GroupType = 0;
  ADS_SEARCH_COLUMN ColumnData, ColumnData2;
  CString szClass;

  // ---------- Get Path --------------
  hr = m_pObj->GetColumn(m_SearchHandle,
                         m_pszAttribs[g_nADsPath],
                         &ColumnData);
  if (SUCCEEDED(hr) && ColumnExtractString( str, pCookie, &ColumnData )) 
  {
    CString szPath;
    StripADsIPath (str, szPath);
    pCookie->SetPath(szPath);
  } else {
    str.LoadString( IDS_DISPLAYTEXT_NONE );
    BadArgs = TRUE;
    TRACE(_T("cannot read ADsPath, tossing cookie... (hr is %lx)\n"),
          hr);
    ReportErrorEx (m_pCD->GetHWnd(), IDS_INVALID_ROW, S_OK,
                   MB_OK | MB_ICONINFORMATION, NULL, 0);
    goto badargs; 
  }    
  if (SUCCEEDED(hr))  m_pObj->FreeColumn (&ColumnData);

  // ---------- Get Name --------------
  hr = m_pObj->GetColumn(m_SearchHandle,
                         m_pszAttribs[g_nName],
                         &ColumnData);
  if (!(SUCCEEDED(hr) && ColumnExtractString( str, pCookie, &ColumnData ))) {
    CString Path;
    
//    CPathCracker pathCracker;
    Path = pCookie->GetPath();
    specialPerformancePathCracker.Set((LPWSTR)(LPCWSTR)Path,
                       ADS_SETTYPE_DN);
    specialPerformancePathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
    BSTR ObjName = NULL;
    specialPerformancePathCracker.GetElement( 0, &ObjName );
    str = ObjName;
  }
  pCookie->SetName(str);
  
  if (SUCCEEDED(hr)) m_pObj->FreeColumn (&ColumnData);
  
  // ---------- Get Class (and Group Type) --------------
  hr = m_pObj->GetColumn(m_SearchHandle,
                         m_pszAttribs[g_nObjectClass],
                         &ColumnData);

  if (SUCCEEDED(hr)) 
  {
    szClass = ColumnData.pADsValues[ColumnData.dwNumValues-1].CaseIgnoreString;
  }
  if (szClass.IsEmpty() || FAILED(hr)) 
  {
    szClass = L"Unknown";
  } 
  else 
  {
    HRESULT hr2 = m_pObj->GetColumn(m_SearchHandle,
                                    m_pszAttribs[g_nGroupType],
                                    &ColumnData2);
    if (SUCCEEDED(hr2)) 
    {
      GroupType =  ColumnData2.pADsValues[ColumnData2.dwNumValues-1].Integer;
      m_pObj->FreeColumn (&ColumnData2);
    }
  }
  if (SUCCEEDED(hr)) m_pObj->FreeColumn (&ColumnData);


  // ---------- Get Description --------------
  hr = m_pObj->GetColumn(m_SearchHandle,
                         m_pszAttribs[g_nDescription],
                         &ColumnData);
  if (SUCCEEDED(hr)) {
    if (ColumnExtractString( str, pCookie, &ColumnData)) {
      pCookie->SetDesc(str);
    }
    m_pObj->FreeColumn (&ColumnData);
  }
  else {
    pCookie->SetDesc(L"");
  }

  // ---------- Get AccountControl Flag word --------------
  hr = m_pObj->GetColumn(m_SearchHandle,
                         m_pszAttribs[g_nUserAccountControl],
                         &ColumnData);

  if (SUCCEEDED(hr)) 
  {
    if (ColumnData.pADsValues->dwType == ADSTYPE_INTEGER) 
    {
      if (((DWORD)ColumnData.pADsValues->Integer & UF_INTERDOMAIN_TRUST_ACCOUNT) ==  UF_INTERDOMAIN_TRUST_ACCOUNT) 
      {
        BadArgs = TRUE;
      } 
      else if ((((DWORD)ColumnData.pADsValues->Integer & UF_ACCOUNTDISABLE)) != UF_ACCOUNTDISABLE) 
      {
        pCookie->ReSetDisabled();
      } 
      else 
      {
        pCookie->SetDisabled();
      }

      if ((((DWORD)ColumnData.pADsValues->Integer & UF_DONT_EXPIRE_PASSWD)) != UF_DONT_EXPIRE_PASSWD)
      {
        pCookie->ReSetNonExpiringPwd();
      }
      else
      {
        pCookie->SetNonExpiringPwd();
      }
    } 
    else 
    {
      pCookie->ReSetDisabled();
      pCookie->ReSetNonExpiringPwd();
    }
    m_pObj->FreeColumn (&ColumnData);
  }

  // ---------- Get System Flags --------------
  pCookie->SetSystemFlags(0);
  hr = m_pObj->GetColumn(m_SearchHandle,
                         m_pszAttribs[g_nSystemFlags],
                         &ColumnData);
  if (SUCCEEDED(hr)) {
    if (ColumnData.pADsValues->dwType == ADSTYPE_INTEGER) {
      pCookie->SetSystemFlags(ColumnData.pADsValues->Integer);
    }
    m_pObj->FreeColumn (&ColumnData);
  }

  // ---------- Get Class Cache and Cookie Extra Info --------------
  // JonN 6/17/99: moved from BadArgs clause
  if (!BadArgs) 
  {
    CString szPath;
    m_pCD->GetBasePathsInfo()->ComposeADsIPath(szPath, pCookie->GetPath());

    CDSClassCacheItemBase* pItem = m_pCache->FindClassCacheItem(m_pCD, szClass, szPath);
    if (pItem != NULL) 
    {
      pCookie->SetCacheItem(pItem);
      if (szClass == L"group") 
      {
        CDSCookieInfoGroup* pExtraInfo = new CDSCookieInfoGroup;
        pExtraInfo->m_GroupType = GroupType;
        pCookie->SetExtraInfo(pExtraInfo);
      } else if (szClass == L"nTDSConnection") {
        CDSCookieInfoConnection* pExtraInfo = new CDSCookieInfoConnection;
        ASSERT( NULL != pExtraInfo );

        hr = m_pObj->GetColumn(m_SearchHandle,
                               L"fromServer",
                               &ColumnData);
        if (SUCCEEDED(hr)) {
          CString strFromServer;
          if ( ColumnExtractString( strFromServer, NULL, &ColumnData) ) {
            CString strFRSComputerReference;
            if ( m_mapMemberToComputer.Lookup( strFromServer, strFRSComputerReference ) )
            {
              pExtraInfo->m_strFRSComputerReference = strFRSComputerReference;
            }
          }
          m_pObj->FreeColumn (&ColumnData);
        }

        hr = m_pObj->GetColumn(m_SearchHandle,
                               L"options",
                               &ColumnData);
        if (SUCCEEDED(hr) && NULL != ColumnData.pADsValues) {
          pExtraInfo->m_nOptions = ColumnData.pADsValues[0].Integer;
          m_pObj->FreeColumn (&ColumnData);
        }

        pExtraInfo->m_fFRSConnection = !m_strContainerClassName.Compare( _T("nTFRSMember") );

        pCookie->SetExtraInfo(pExtraInfo);
      }
    } else {
      BadArgs = TRUE;
    }
  }


  hr = S_OK;

  // ----------  Get optional Columns -----------
  if ((pColumnSet != NULL)) {
    CStringList& strlist = pCookie->GetParentClassSpecificStrings();

    strlist.RemoveAll(); // remove contents, if we do an update
    
    POSITION pos = pColumnSet->GetHeadPosition();
    while (pos != NULL)
    {
      CDSColumn* pCol = (CDSColumn*)pColumnSet->GetNext(pos);
      if (!(pCol->GetColumnType() == ATTR_COLTYPE_SPECIAL || pCol->GetColumnType() == ATTR_COLTYPE_MODIFIED_TIME) || 
            !pCol->IsVisible())
        continue;
      str = L"";

      COLUMN_EXTRACTION_FUNCTION pfn = pCol->GetExtractionFunction();
      if (NULL == pfn) {
        pfn = ColumnExtractString;
      }

      hr = m_pObj->GetColumn(m_SearchHandle,
                             const_cast<LPWSTR>(pCol->GetColumnAttribute()),
                             &ColumnData);
      if (SUCCEEDED(hr)) {
        if ( NULL == pfn || !(pfn)( str, pCookie, &ColumnData ) )  {
          str = L" ";
        }

        // If the column is the modified time, then copy it into the cookie as a SYSTEMTIME so that
        // we can do a comparison for sorting
        if (pCol->GetColumnType() == ATTR_COLTYPE_MODIFIED_TIME)
        {
          pCookie->SetModifiedTime(&(ColumnData.pADsValues->UTCTime));
        }
        FreeColumn (&ColumnData);
      }
      else
      {
        if ( NULL == pfn || !(pfn)( str, pCookie, NULL ) )  {
          str = L" ";
        }
      }
      strlist.AddTail( str );
    }
  }

  hr = S_OK;

badargs:
  if (BadArgs) {
    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
  }

  END_PROFILING_BLOCK;
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\queryui.h ===
//+----------------------------------------------------------------------------
//
//  DS Administration MMC snapin.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       queryui.h
//
//--------------------------------------------------------------------------


#ifndef __QUERYUI_
#define __QUERYUI_

#include "query.h"
#include "dsfilter.h"
#include "helpids.h"
#include "uiutil.h"

#include <Cmnquery.h>  // IQueryForm

/////////////////////////////////////////////////////////////////////////////
// CQueryPageBase

class CQueryPageBase : public CHelpDialog
{
// Construction
public:
	CQueryPageBase(UINT nIDTemplate) : CHelpDialog(nIDTemplate)	{	};

	virtual void	Init() PURE;
	virtual HRESULT GetQueryParams(LPDSQUERYPARAMS* ppDsQueryParams) PURE;
  virtual HRESULT BuildQueryParams(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery) PURE;
	virtual HRESULT ClearForm() {Init(); return S_OK;}
  virtual HRESULT	Enable(BOOL) { return S_OK; }
  virtual HRESULT Persist(IPersistQuery*, BOOL) { return S_OK; }

  DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CStdQueryPage

class CStdQueryPage : public CQueryPageBase
{
// Construction
public:
	CStdQueryPage(PCWSTR pszFilterPrefix) : CQueryPageBase(IDD_QUERY_STD_PAGE)	
  {	
    m_szFilterPrefix = pszFilterPrefix;
  }

  CStdQueryPage(UINT nDlgID, PCWSTR pszFilterPrefix) : CQueryPageBase(nDlgID) 
  {
    m_szFilterPrefix = pszFilterPrefix;
  }

  virtual BOOL    OnInitDialog();
  virtual void    DoContextHelp(HWND hWndControl); 

  afx_msg void    OnNameComboChange();
  afx_msg void    OnDescriptionComboChange();

  void SelectComboAssociatedWithData(UINT nCtrlID, LRESULT lData);

	virtual void	  Init();
	virtual HRESULT GetQueryParams(LPDSQUERYPARAMS* ppDsQueryParams);
  virtual HRESULT BuildQueryParams(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery);
	virtual HRESULT ClearForm() {Init(); return S_OK;}
  virtual HRESULT	Enable(BOOL) { return S_OK; }
  virtual HRESULT Persist(IPersistQuery*, BOOL);

  DECLARE_MESSAGE_MAP()

protected:
  CString m_szFilterPrefix;
};

/////////////////////////////////////////////////////////////////////////////
// CUserComputerQueryPage

class CUserComputerQueryPage : public CStdQueryPage
{
// Construction
public:
  //
  // Note: this page can be used for both users and computers
  //
	CUserComputerQueryPage(UINT nDialogID, PCWSTR pszFilterPrefix) 
    : CStdQueryPage(nDialogID, pszFilterPrefix)	
  {	
  }

  virtual BOOL    OnInitDialog();
  virtual void    DoContextHelp(HWND hWndControl); 

	virtual void	  Init();
	virtual HRESULT GetQueryParams(LPDSQUERYPARAMS* ppDsQueryParams);
  virtual HRESULT Persist(IPersistQuery* pPersistQuery, BOOL fRead);

  DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CUserQueryPage

class CUserQueryPage : public CUserComputerQueryPage
{
// Construction
public:
  //
  // Note: this page can be used for both users and computers
  //
	CUserQueryPage(PCWSTR pszFilterPrefix) 
    : CUserComputerQueryPage(IDD_QUERY_USER_PAGE, pszFilterPrefix)	
  {	
    m_lLogonSelection = -1;
  }

  virtual BOOL    OnInitDialog();
  virtual void    DoContextHelp(HWND hWndControl); 

	virtual void	  Init();
	virtual HRESULT GetQueryParams(LPDSQUERYPARAMS* ppDsQueryParams);
  virtual HRESULT Persist(IPersistQuery* pPersistQuery, BOOL fRead);

  DECLARE_MESSAGE_MAP()

private:
  LRESULT m_lLogonSelection;
};

/////////////////////////////////////////////////////////////////////////////
// CQueryFormBase

class ATL_NO_VTABLE CQueryFormBase : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CQueryFormBase, &CLSID_DSAdminQueryUIForm>,
	public IQueryForm
{
public:
	CQueryFormBase()
	{
	}

  DECLARE_REGISTRY_CLSID()

  //
  // IQueryForm methods
  //
  STDMETHOD(Initialize)(THIS_ HKEY hkForm);
  STDMETHOD(AddForms)(THIS_ LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam);
  STDMETHOD(AddPages)(THIS_ LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam);

BEGIN_COM_MAP(CQueryFormBase)
	COM_INTERFACE_ENTRY(IQueryForm)
END_COM_MAP()
};


//////////////////////////////////////////////////////////////////////////////
// CQueryDialog

class CQueryDialog : public CHelpDialog
{
public:
  CQueryDialog(CSavedQueryNode* pQueryNode, 
               CFavoritesNode* pFavNode, 
               CDSComponentData* pComponentData,
               BOOL bNewQuery = TRUE,
               BOOL bImportQuery = FALSE);
  ~CQueryDialog();

  virtual BOOL OnInitDialog();
  virtual void OnOK();

  virtual void DoContextHelp(HWND hWndControl);
  
  afx_msg void OnBrowse();
  afx_msg void OnEditQuery();
  afx_msg void OnMultiLevelChange();
  afx_msg void OnNameChange();
  afx_msg void OnDescriptionChange();
  afx_msg BOOL OnNeedToolTipText(UINT nCtrlID, NMHDR* pTTTStruct, LRESULT* pResult);

  void SetDirty(BOOL bDirty = TRUE);
  void SetQueryRoot(PCWSTR pszPath);

  CSavedQueryNode* GetQueryNode() { return m_pQueryNode; }
  CFavoritesNode*  GetFavNode() { return m_pFavNode; }

  void SetQueryFilterDisplay();

  DECLARE_MESSAGE_MAP()

private:
  CSavedQueryNode*  m_pQueryNode;
  CFavoritesNode*   m_pFavNode;
  CDSComponentData* m_pComponentData;

  CString           m_szName;
  CString           m_szOriginalName;
  CString           m_szDescription;
  CString           m_szQueryRoot;
  CString           m_szQueryFilter;
  BOOL              m_bMultiLevel;

  BOOL              m_bNewQuery;
  BOOL              m_bImportQuery;
  BOOL              m_bInit;
  BOOL              m_bDirty;

  BOOL              m_bLastLogonFilter;
  DWORD             m_dwLastLogonData;

  // 
  // for presisting DSQuery dialog info
  //
	CComObject<CDSAdminPersistQueryFilterImpl>* m_pPersistQueryImpl;

};


/////////////////////////////////////////////////////////////////////////////////
// CFavoritesNodePropertyPage

class CFavoritesNodePropertyPage : public CHelpPropertyPage
{
public:
  CFavoritesNodePropertyPage(CFavoritesNode* pFavNode, 
                             LONG_PTR lNotifyHandle, 
                             CDSComponentData* pComponentData,
                             LPDATAOBJECT pDataObject)
    : m_pFavNode(pFavNode),
      m_lNotifyHandle(lNotifyHandle),
      m_pComponentData(pComponentData),
      m_pDataObject(pDataObject),
      CHelpPropertyPage(IDD_FAVORITES_PROPERTY_PAGE)
  {
  }

  ~CFavoritesNodePropertyPage() 
  {
    if (m_lNotifyHandle != NULL)
    {
      MMCFreeNotifyHandle(m_lNotifyHandle);
      m_lNotifyHandle = NULL;
    }
  }

  DECLARE_MESSAGE_MAP()

protected:
  virtual void DoContextHelp(HWND hWndControl);
  virtual BOOL OnInitDialog();
  virtual BOOL OnApply();
  afx_msg void OnDescriptionChange();

private:
  CFavoritesNode*     m_pFavNode;
  CDSComponentData*   m_pComponentData;
  LONG_PTR            m_lNotifyHandle;
  CString             m_szOldDescription;
  LPDATAOBJECT        m_pDataObject;
};

#endif // __QUERYUI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\queryui.cpp ===
//+----------------------------------------------------------------------------
//
//  DS Administration MMC snapin.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       queryui.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "resource.h"
#include "queryui.h"
#include "dssnap.h"
#include "uiutil.h"

#include <cmnquery.h> // DSFind
#include <dsquery.h>  // DSFind
#include <dsclient.h>  // BrowseForContainer

#include <dsqueryp.h> // COLUMNINFO and QueryParamsAddQueryString, QueryParamsAlloc helpers
#include <cmnquryp.h> // CQFF_ISNEVERLISTED
#include <lmaccess.h> // UF_ACCOUNTDISABLE and UF_DONT_EXPIRE_PASSWD
#include <ntldap.h>   // LDAP_MATCHING_RULE_BIT_AND_W

#define DSQF_LAST_LOGON_QUERY         0x00000001
#define DSQF_NON_EXPIRING_PWD_QUERY   0x00000004

//
// Used to set the maximum text length on fields in the new query dialog
//
#define MAX_QUERY_NAME_LENGTH 259
#define MAX_QUERY_DESC_LENGTH 1024

typedef struct 
{
  UINT  nDisplayStringID;
  PWSTR pszFormatString;
} QUERYSTRINGS, * PQUERYSTRINGS;

QUERYSTRINGS g_pQueryStrings[] = {
  { IDS_STARTSWITH, L"(%s=%s*)"   },
  { IDS_ENDSWITH,   L"(%s=*%s)"   },
  { IDS_ISEXACTLY,  L"(%s=%s)"    },
  { IDS_ISNOT,      L"(!%s=%s)"   },
  { IDS_PRESENT,    L"(%s=%s*)"   },  // NOTE: the second string needs to be NULL here
  { IDS_NOTPRESENT, L"(!%s=%s*)"  },  // NOTE: the second string needs to be NULL here
  { 0, NULL }
};

static const CString g_szUserAccountCtrlQuery = L"(userAccountControl:" + CString(LDAP_MATCHING_RULE_BIT_AND_W) + L":=%u)";

/*-----------------------------------------------------------------------------
/ QueryParamsAlloc
/ ----------------
/   Construct a block we can pass to the DS query handler which contains
/   all the parameters for the query.
/
/ In:
/   ppDsQueryParams -> receives the parameter block
/   pQuery -> LDAP query string to be used
/   iColumns = number of columns
/   pColumnInfo -> column info structure to use
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT QueryParamsAlloc(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery, LONG iColumns, LPCOLUMNINFO aColumnInfo)
{
  HRESULT hr = S_OK;
  LPDSQUERYPARAMS pDsQueryParams = NULL;
  size_t cbStruct;
  LONG i;

	ASSERT(!*ppDsQueryParams);

  TRACE(L"QueryParamsAlloc");

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if ( !pQuery || !iColumns || !ppDsQueryParams )
  {
    return E_INVALIDARG;
  }
	
  //
  // Compute the size of the structure we need to be using
  //
  cbStruct  = sizeof(DSQUERYPARAMS) + (sizeof(DSCOLUMN)*iColumns);
  cbStruct += (wcslen(pQuery) + 1) * sizeof(WCHAR);

  for (i = 0; i < iColumns; i++)
  {
    if (aColumnInfo[i].pPropertyName)
    {
      cbStruct += (wcslen(aColumnInfo[i].pPropertyName) + 1) * sizeof(WCHAR);
    }
  }

  pDsQueryParams = (LPDSQUERYPARAMS)CoTaskMemAlloc(cbStruct);

  if (!pDsQueryParams)
  {
    return E_OUTOFMEMORY;
  }

  //
  // Structure allocated so lets fill it with data
  //
  pDsQueryParams->cbStruct = static_cast<DWORD>(cbStruct);
  pDsQueryParams->dwFlags = 0;
  pDsQueryParams->hInstance = _Module.m_hInst;
  pDsQueryParams->iColumns = iColumns;
  pDsQueryParams->dwReserved = 0;

  cbStruct  = sizeof(DSQUERYPARAMS) + (sizeof(DSCOLUMN)*iColumns);

  pDsQueryParams->offsetQuery = static_cast<LONG>(cbStruct);
  CopyMemory(&(((LPBYTE)pDsQueryParams)[cbStruct]), pQuery, (wcslen(pQuery) + 1) * sizeof(WCHAR));  
  cbStruct += (wcslen(pQuery) + 1) * sizeof(WCHAR);

  for ( i = 0 ; i < iColumns ; i++ )
  {
    pDsQueryParams->aColumns[i].dwFlags = 0;
    pDsQueryParams->aColumns[i].fmt = aColumnInfo[i].fmt;
    pDsQueryParams->aColumns[i].cx = aColumnInfo[i].cx;
    pDsQueryParams->aColumns[i].idsName = aColumnInfo[i].idsName;
    pDsQueryParams->aColumns[i].dwReserved = 0;

    if ( aColumnInfo[i].pPropertyName ) 
    {
      pDsQueryParams->aColumns[i].offsetProperty = static_cast<LONG>(cbStruct);
      CopyMemory(&(((LPBYTE)pDsQueryParams)[cbStruct]), aColumnInfo[i].pPropertyName, (wcslen(aColumnInfo[i].pPropertyName) + 1) * sizeof(WCHAR));  
      cbStruct += (wcslen(aColumnInfo[i].pPropertyName) + 1) * sizeof(WCHAR);
    }
    else
    {
      pDsQueryParams->aColumns[i].offsetProperty = aColumnInfo[i].iPropertyIndex;
    }
  }

  *ppDsQueryParams = pDsQueryParams;
  return hr;
}

/*-----------------------------------------------------------------------------
/ QueryParamsAddQueryString
/ -------------------------
/   Given an existing DS query block appened the given LDAP query string into
/   it. We assume that the query block has been allocated by IMalloc (or CoTaskMemAlloc).
/
/ In:
/   ppDsQueryParams -> receives the parameter block
/   pQuery -> LDAP query string to be appended
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT QueryParamsAddQueryString(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery)
{
  HRESULT hr = S_OK;
  LPWSTR pOriginalQuery = NULL;
  LPDSQUERYPARAMS pDsQuery = *ppDsQueryParams;
  size_t cbQuery;
  LONG i;
  LPVOID  pv;

	ASSERT(*ppDsQueryParams);
	
  TRACE(_T("QueryParamsAddQueryString"));

  if ( pQuery )
  {
    if (!pDsQuery)
    {
      return E_INVALIDARG;
    }

    // Work out the size of the bits we are adding, take a copy of the
    // query string and finally re-alloc the query block (which may cause it
    // to move).
   
    cbQuery = ((wcslen(pQuery) + 1) * sizeof(WCHAR));
    TRACE(_T("DSQUERYPARAMS being resized by %d bytes"));

		i = static_cast<LONG>((wcslen((LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery)) + 1) * sizeof(WCHAR));
		pOriginalQuery = (WCHAR*) new BYTE[i];
    if (!pOriginalQuery)
    {
      return E_OUTOFMEMORY;
    }
		lstrcpyW(pOriginalQuery, (LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery));
		
    pv = CoTaskMemRealloc(*ppDsQueryParams, pDsQuery->cbStruct+cbQuery);
    if ( pv == NULL )
    {
      delete[] pOriginalQuery;
      pOriginalQuery = 0;
      return E_OUTOFMEMORY;
    }

    *ppDsQueryParams = (LPDSQUERYPARAMS) pv;

    pDsQuery = *ppDsQueryParams;            // if may have moved

    // Now move everything above the query string up, and fix all the
    // offsets that reference those items (probably the property table),
    // finally adjust the size to reflect the change

    MoveMemory(ByteOffset(pDsQuery, pDsQuery->offsetQuery+cbQuery), 
                 ByteOffset(pDsQuery, pDsQuery->offsetQuery), 
                 (pDsQuery->cbStruct - pDsQuery->offsetQuery));
            
    for ( i = 0 ; i < pDsQuery->iColumns ; i++ )
    {
      if ( pDsQuery->aColumns[i].offsetProperty > pDsQuery->offsetQuery )
      {
        pDsQuery->aColumns[i].offsetProperty += static_cast<LONG>(cbQuery);
      }
    }

    wcscpy((LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery), pOriginalQuery);
    wcscat((LPWSTR)ByteOffset(pDsQuery, pDsQuery->offsetQuery), pQuery);        

    pDsQuery->cbStruct += static_cast<DWORD>(cbQuery);

    delete[] pOriginalQuery;
    pOriginalQuery = 0;
  }

  return hr;
}


///////////////////////////////////////////////////////////////////////////////
// AddQueryUnitWithModifier

HRESULT AddQueryUnitWithModifier(UINT nModifierStringID, 
                                 PCWSTR pszAttrName, 
                                 PCWSTR pszValue,
                                 CString& szFilter)
{
  HRESULT hr = S_OK;

  ASSERT(pszAttrName != NULL);
  if (pszAttrName == NULL)
  {
    return E_INVALIDARG;
  }

  CString szNewFilter;

  PQUERYSTRINGS pQueryStrings = g_pQueryStrings;
  PWSTR pszFormatString = NULL;
  while (pQueryStrings->nDisplayStringID != 0)
  {
    if (nModifierStringID == pQueryStrings->nDisplayStringID)
    {
      pszFormatString = pQueryStrings->pszFormatString;
      break;
    }
    pQueryStrings++;
  }

  if (pszFormatString != NULL)
  {
    szNewFilter.Format(pszFormatString, pszAttrName, pszValue);
    szFilter += szNewFilter;
  }
  else
  {
    hr = E_INVALIDARG;
  }
  return hr;
}
///////////////////////////////////////////////////////////////////////////////
// CQueryPageBase
BEGIN_MESSAGE_MAP(CQueryPageBase, CHelpDialog)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////
// CStdQueryPage

#define FILTER_PREFIX_USER      L"(objectCategory=person)(objectClass=user)"
#define FILTER_PREFIX_COMPUTER  L"(objectCategory=computer)"
#define FILTER_PREFIX_GROUP     L"(objectCategory=group)"

#define ATTR_COL_NAME   L"name"
#define ATTR_COL_DESC   L"description"

COLUMNINFO	UserColumn[] =
{
  { 0, 40, IDS_QUERY_COL_NAME, 0, ATTR_COL_NAME },
  { 0, 40, IDS_QUERY_COL_DESC, 0, ATTR_COL_DESC }
};

int	cUserColumns = 2;

BEGIN_MESSAGE_MAP(CStdQueryPage, CQueryPageBase)
  ON_CBN_SELCHANGE(IDC_NAME_COMBO, OnNameComboChange)
  ON_CBN_SELCHANGE(IDC_DESCRIPTION_COMBO, OnDescriptionComboChange)
END_MESSAGE_MAP()

void CStdQueryPage::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)  
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_QUERY_STD_PAGE); 
  }
}

BOOL CStdQueryPage::OnInitDialog()
{
  CHelpDialog::OnInitDialog();

  PQUERYSTRINGS pQueryStrings = g_pQueryStrings;
  ASSERT(pQueryStrings != NULL);

  //
  // Fill in the combo boxes
  //
  while (pQueryStrings->nDisplayStringID != 0)
  {
    CString szComboString;
    VERIFY(szComboString.LoadString(pQueryStrings->nDisplayStringID));

    //
    // Fill in the Name combo
    //
    LRESULT lRes = SendDlgItemMessage(IDC_NAME_COMBO, CB_ADDSTRING, 0, (LPARAM)(PCWSTR)szComboString);
    if (lRes != CB_ERR)
    {
      lRes = SendDlgItemMessage(IDC_NAME_COMBO, CB_SETITEMDATA, (WPARAM)lRes, (LPARAM)pQueryStrings->nDisplayStringID);
      ASSERT(lRes != CB_ERR);
    }

    //
    // Fill in the Description combo
    //
    lRes = SendDlgItemMessage(IDC_DESCRIPTION_COMBO, CB_ADDSTRING, 0, (LPARAM)(PCWSTR)szComboString);
    if (lRes != CB_ERR)
    {
      lRes = SendDlgItemMessage(IDC_DESCRIPTION_COMBO, CB_SETITEMDATA, (WPARAM)lRes, (LPARAM)pQueryStrings->nDisplayStringID);
      ASSERT(lRes != CB_ERR);
    }

    pQueryStrings++;
  }

  //
  // Insert an empty so that there is a way to undo changes
  //
  LRESULT lBlankName = SendDlgItemMessage(IDC_NAME_COMBO, CB_ADDSTRING, 0, (LPARAM)L"");
  if (lBlankName != CB_ERR)
  {
    SendDlgItemMessage(IDC_NAME_COMBO, CB_SETITEMDATA, (WPARAM)lBlankName, (LPARAM)0);
  }

  //
  // Insert an empty so that there is a way to undo changes
  //
  LRESULT lBlankDesc = SendDlgItemMessage(IDC_DESCRIPTION_COMBO, CB_ADDSTRING, 0, (LPARAM)L"");
  if (lBlankDesc != CB_ERR)
  {
    SendDlgItemMessage(IDC_DESCRIPTION_COMBO, CB_SETITEMDATA, (WPARAM)lBlankDesc, (LPARAM)0);
  }
  
  //
  // Force the UI to enable and disable controls related to the combo boxes
  //
  OnNameComboChange();
  OnDescriptionComboChange();

  return FALSE;
}

void CStdQueryPage::OnNameComboChange()
{
  LRESULT lRes = SendDlgItemMessage(IDC_NAME_COMBO, CB_GETCURSEL, 0, 0);
  if (lRes != CB_ERR)
  {
    LRESULT lData = SendDlgItemMessage(IDC_NAME_COMBO, CB_GETITEMDATA, lRes, 0);
    if (lData != CB_ERR)
    {
      if (lData == IDS_PRESENT || lData == IDS_NOTPRESENT || lData == 0)
      {
        GetDlgItem(IDC_NAME_EDIT)->EnableWindow(FALSE);
        SetDlgItemText(IDC_NAME_EDIT, L"");
      }
      else
      {
        GetDlgItem(IDC_NAME_EDIT)->EnableWindow(TRUE);
      }
    }
  }
  else
  {
    GetDlgItem(IDC_NAME_EDIT)->EnableWindow(FALSE);
  }
}

void CStdQueryPage::OnDescriptionComboChange()
{
  LRESULT lRes = SendDlgItemMessage(IDC_DESCRIPTION_COMBO, CB_GETCURSEL, 0, 0);
  if (lRes != CB_ERR)
  {
    LRESULT lData = SendDlgItemMessage(IDC_DESCRIPTION_COMBO, CB_GETITEMDATA, lRes, 0);
    if (lData != CB_ERR)
    {
      if (lData == IDS_PRESENT || lData == IDS_NOTPRESENT || lData == 0)
      {
        GetDlgItem(IDC_DESCRIPTION_EDIT)->EnableWindow(FALSE);
        SetDlgItemText(IDC_DESCRIPTION_EDIT, L"");
      }
      else
      {
        GetDlgItem(IDC_DESCRIPTION_EDIT)->EnableWindow(TRUE);
      }
    }
  }
  else
  {
    GetDlgItem(IDC_DESCRIPTION_EDIT)->EnableWindow(FALSE);
  }
}

void CStdQueryPage::Init()
{
  //
  // Clear all controls
  //
  SetDlgItemText(IDC_NAME_EDIT, L"");
  SetDlgItemText(IDC_DESCRIPTION_EDIT, L"");

  //
  // Reselect the blank string in the combo boxes
  //
  LRESULT lRes = SendDlgItemMessage(IDC_NAME_COMBO, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)L"");
  if (lRes != CB_ERR)
  {
    SendDlgItemMessage(IDC_NAME_COMBO, CB_SETCURSEL, lRes, 0);
  }

  lRes = SendDlgItemMessage(IDC_DESCRIPTION_COMBO, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)L"");
  if (lRes != CB_ERR)
  {
    SendDlgItemMessage(IDC_DESCRIPTION_COMBO, CB_SETCURSEL, lRes, 0);
  }
}

HRESULT CStdQueryPage::GetQueryParams(LPDSQUERYPARAMS* ppDsQueryParams)
{
  HRESULT hr = S_OK;
	
  //
  // Build the filter string here
  //
	CString	szFilter;
  CString szName;
  CString szDescription;

  GetDlgItemText(IDC_NAME_EDIT, szName);
  GetDlgItemText(IDC_DESCRIPTION_EDIT, szDescription);

  //
  // Get the selection of the modifier combo
  //
  LRESULT lSel = SendDlgItemMessage(IDC_NAME_COMBO, CB_GETCURSEL, 0, 0);
  if (lSel != CB_ERR)
  {
    //
    // Retrieve the associated string ID
    //
    LRESULT lData = SendDlgItemMessage(IDC_NAME_COMBO, CB_GETITEMDATA, lSel, 0);
    if (lData != CB_ERR)
    {
      if (!szName.IsEmpty() || lData == IDS_PRESENT || lData == IDS_NOTPRESENT)
      {
        AddQueryUnitWithModifier(static_cast<UINT>(lData),
                                 ATTR_COL_NAME,
                                 szName,
                                 szFilter);
      }
    }
  }

  //
  // Get the selection of the modifier combo
  //
  lSel = SendDlgItemMessage(IDC_DESCRIPTION_COMBO, CB_GETCURSEL, 0, 0);
  if (lSel != CB_ERR)
  {
    //
    // Retrieve the associated string ID
    //
    LRESULT lData = SendDlgItemMessage(IDC_DESCRIPTION_COMBO, CB_GETITEMDATA, lSel, 0);
    if (lData != CB_ERR)
    {
      if (!szDescription.IsEmpty() || lData == IDS_PRESENT || lData == IDS_NOTPRESENT)
      {
        AddQueryUnitWithModifier(static_cast<UINT>(lData),
                                 ATTR_COL_DESC,
                                 szDescription,
                                 szFilter);
      }
    }
  }

  if (!szFilter.IsEmpty())
  {
    szFilter = m_szFilterPrefix + szFilter;
    hr = BuildQueryParams(ppDsQueryParams, (LPWSTR)(LPCWSTR)szFilter);
  }
  return hr;
}

HRESULT CStdQueryPage::BuildQueryParams(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery)
{
	ASSERT(pQuery);
	
	if(*ppDsQueryParams)
  {
		return QueryParamsAddQueryString(ppDsQueryParams, pQuery);
  }
  return QueryParamsAlloc(ppDsQueryParams, pQuery, cUserColumns, UserColumn);
}

HRESULT CStdQueryPage::Persist(IPersistQuery* pPersistQuery, BOOL fRead)
{
  HRESULT hr = S_OK;

  if (pPersistQuery == NULL)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  if (fRead)
  {
    //
    // Read the Name combo value
    //
    int iData = 0;
    hr = pPersistQuery->ReadInt(m_szFilterPrefix, L"NameCombo", &iData);
    if (FAILED(hr))
    {
      TRACE(_T("Failed to read int \"NameCombo\" from stream: 0x%x\n"), hr);
      ASSERT(FALSE);
      return hr;
    }

    //
    // Select the appropriate list box item
    //
    SelectComboAssociatedWithData(IDC_NAME_COMBO, iData);

    if (iData != 0 && iData != IDS_PRESENT && iData != IDS_NOTPRESENT)
    {
      //
      // Read the name edit value
      //
      WCHAR szBuf[MAX_PATH] = {0};
      hr = pPersistQuery->ReadString(m_szFilterPrefix, L"NameEdit", szBuf, MAX_PATH);
      if (FAILED(hr))
      {
        TRACE(_T("Failed to read string \"NameEdit\" from stream: 0x%x\n"), hr);
        ASSERT(FALSE);
        return hr;
      }

      if (szBuf != NULL)
      {
        SetDlgItemText(IDC_NAME_EDIT, szBuf);
      }
    }
    else
    {
      GetDlgItem(IDC_NAME_EDIT)->EnableWindow(FALSE);
    }

    //
    // Read the Description combo value
    //
    iData = 0;
    hr = pPersistQuery->ReadInt(m_szFilterPrefix, L"DescCombo", &iData);
    if (FAILED(hr))
    {
      TRACE(_T("Failed to read int \"DescCombo\" from stream: 0x%x\n"), hr);
      ASSERT(FALSE);
      return hr;
    }

    //
    // Select the appropriate list box item
    //
    SelectComboAssociatedWithData(IDC_DESCRIPTION_COMBO, iData);

    if (iData != 0 && iData != IDS_PRESENT && iData != IDS_NOTPRESENT)
    {
      //
      // Read the name edit value
      //
      WCHAR szBuf[MAX_PATH] = {0};
      hr = pPersistQuery->ReadString(m_szFilterPrefix, L"DescEdit", szBuf, MAX_PATH);
      if (FAILED(hr))
      {
        TRACE(_T("Failed to read string \"DescEdit\" from stream: 0x%x\n"), hr);
        ASSERT(FALSE);
        return hr;
      }

      if (szBuf != NULL)
      {
        SetDlgItemText(IDC_DESCRIPTION_EDIT, szBuf);
      }
    }
    else
    {
      GetDlgItem(IDC_DESCRIPTION_EDIT)->EnableWindow(FALSE);
    }
    OnNameComboChange();
    OnDescriptionComboChange();
  }
  else   // write
  {
    //
    // Write out the name info
    //
    LRESULT lSel = SendDlgItemMessage(IDC_NAME_COMBO, CB_GETCURSEL, 0, 0);
    if (lSel != CB_ERR)
    {
      //
      // Retrieve the associated string ID
      //
      LRESULT lData = SendDlgItemMessage(IDC_NAME_COMBO, CB_GETITEMDATA, lSel, 0);
      if (lData != CB_ERR)
      {
        hr = pPersistQuery->WriteInt(m_szFilterPrefix, L"NameCombo", static_cast<int>(lData));
        if (FAILED(hr))
        {
          ASSERT(FALSE);
          return hr;
        }

        if (lData != 0 && lData != IDS_PRESENT && lData != IDS_NOTPRESENT)
        {
          CString szName;
          GetDlgItemText(IDC_NAME_EDIT, szName);
          hr = pPersistQuery->WriteString(m_szFilterPrefix, L"NameEdit", szName);
          if (FAILED(hr))
          {
            ASSERT(FALSE);
            return hr;
          }
        }
      }
    }
    else
    {
      //
      // If there hasn't been a selection, write in the empty string value
      //
      hr = pPersistQuery->WriteInt(m_szFilterPrefix, L"NameCombo", 0);
    }


    //
    // Write out the description info
    //
    lSel = SendDlgItemMessage(IDC_DESCRIPTION_COMBO, CB_GETCURSEL, 0, 0);
    if (lSel != CB_ERR)
    {
      //
      // Retrieve the associated string ID
      //
      LRESULT lData = SendDlgItemMessage(IDC_DESCRIPTION_COMBO, CB_GETITEMDATA, lSel, 0);
      if (lData != CB_ERR)
      {
        hr = pPersistQuery->WriteInt(m_szFilterPrefix, L"DescCombo", static_cast<int>(lData));
        if (FAILED(hr))
        {
          ASSERT(FALSE);
          return hr;
        }

        if (lData != 0 && lData != IDS_PRESENT && lData != IDS_NOTPRESENT)
        {
          CString szDescription;
          GetDlgItemText(IDC_DESCRIPTION_EDIT, szDescription);
          hr = pPersistQuery->WriteString(m_szFilterPrefix, L"DescEdit", szDescription);
          if (FAILED(hr))
          {
            ASSERT(FALSE);
            return hr;
          }
        }
      }
    }
    else
    {
      //
      // If there hasn't been a selection, write in the empty string value
      //
      hr = pPersistQuery->WriteInt(m_szFilterPrefix, L"DescCombo", 0);
    }
  }
  return hr;
}

void CStdQueryPage::SelectComboAssociatedWithData(UINT nCtrlID, LRESULT lData)
{
  //
  // Selects the item with the associated data in a combo box
  //
  LRESULT lRes = SendDlgItemMessage(nCtrlID, CB_GETCOUNT, 0, 0);
  if (lRes != CB_ERR)
  {
    for (int idx = 0; idx < static_cast<int>(lRes); idx++)
    {
      LRESULT lRetData = SendDlgItemMessage(nCtrlID, CB_GETITEMDATA, (WPARAM)idx, 0);
      if (lRetData != CB_ERR)
      {
        if (lRetData == lData)
        {
          SendDlgItemMessage(nCtrlID, CB_SETCURSEL, (WPARAM)idx, 0);
          break;
        }
      }
    }
  }
}

///////////////////////////////////////////////////////////////////////////////
// CUserComputerQueryPage

BEGIN_MESSAGE_MAP(CUserComputerQueryPage, CStdQueryPage)
  ON_WM_HELPINFO()
END_MESSAGE_MAP()

BOOL CUserComputerQueryPage::OnInitDialog()
{
  return CStdQueryPage::OnInitDialog();
}

void CUserComputerQueryPage::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)  
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_QUERY_USER_PAGE); 
  }
}

void CUserComputerQueryPage::Init()
{
  //
  // Clear all controls
  //
  CStdQueryPage::Init();
}

HRESULT CUserComputerQueryPage::GetQueryParams(LPDSQUERYPARAMS* ppDsQueryParams)
{
  HRESULT hr = S_OK;
	
  //
  // Build the filter string here
  //
  hr = CStdQueryPage::GetQueryParams(ppDsQueryParams);

  CString szFilter;
  BOOL bDisabledAccounts = FALSE;

  //
  // Get disabled accounts check
  //
  LRESULT lRes = SendDlgItemMessage(IDC_DISABLED_ACCOUNTS_CHECK, BM_GETCHECK, 0, 0);
  if (lRes == BST_CHECKED)
  {
    bDisabledAccounts = TRUE;
  }


  if (bDisabledAccounts)
  {
    szFilter.Format(g_szUserAccountCtrlQuery, UF_ACCOUNTDISABLE);
    szFilter = m_szFilterPrefix + szFilter;

    hr = BuildQueryParams(ppDsQueryParams, (LPWSTR)(LPCWSTR)szFilter);
  }
  return hr;
}

HRESULT CUserComputerQueryPage::Persist(IPersistQuery* pPersistQuery, BOOL fRead)
{
  HRESULT hr = CStdQueryPage::Persist(pPersistQuery, fRead);
  if (FAILED(hr))
  {
    return hr;
  }

  if (pPersistQuery == NULL)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  if (fRead)
  {
    //
    // Read disabled accounts flag
    //
    int iData = 0;
    hr = pPersistQuery->ReadInt(m_szFilterPrefix, L"DisableCheck", &iData);
    if (FAILED(hr))
    {
      TRACE(_T("Failed to read int \"DisableCheck\" from stream: 0x%x\n"), hr);
      ASSERT(FALSE);
      return hr;
    }
    SendDlgItemMessage(IDC_DISABLED_ACCOUNTS_CHECK, BM_SETCHECK, (iData > 0) ? BST_CHECKED : BST_UNCHECKED, 0);

  }
  else
  {
    //
    // Write disabled accounts flag
    //
    LRESULT lRes = SendDlgItemMessage(IDC_DISABLED_ACCOUNTS_CHECK, BM_GETCHECK, 0, 0);
    if (lRes != -1)
    {
      int iRes = (lRes == BST_CHECKED) ? 1 : 0;
      hr = pPersistQuery->WriteInt(m_szFilterPrefix, L"DisableCheck", iRes);
      if (FAILED(hr))
      {
        ASSERT(FALSE);
        return hr;
      }
    }

  }
  return hr;
}



///////////////////////////////////////////////////////////////////////////////
// CUserQueryPage

BEGIN_MESSAGE_MAP(CUserQueryPage, CStdQueryPage)
END_MESSAGE_MAP()

BOOL CUserQueryPage::OnInitDialog()
{
  return CUserComputerQueryPage::OnInitDialog();
}

void CUserQueryPage::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)  
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_QUERY_USER_PAGE); 
  }
}

void CUserQueryPage::Init()
{
  //
  // Clear all controls
  //
  CUserComputerQueryPage::Init();
}

HRESULT CUserQueryPage::GetQueryParams(LPDSQUERYPARAMS* ppDsQueryParams)
{
  HRESULT hr = S_OK;
	
  //
  // Build the filter string here
  //
  hr = CUserComputerQueryPage::GetQueryParams(ppDsQueryParams);

  CString szFilter;
  BOOL bNonExpPwds = FALSE;
  BOOL bLastLogon = FALSE;
  DWORD dwLastLogonData = 0;

  //
  // Get non expiring password check
  //
  LRESULT lRes = SendDlgItemMessage(IDC_NON_EXPIRING_PWD_CHECK, BM_GETCHECK, 0, 0);
  if (lRes == BST_CHECKED)
  {
    bNonExpPwds = TRUE;
  }

  //
  // Get stale acccounts check
  //
  lRes = SendDlgItemMessage(IDC_LASTLOGON_COMBO, CB_GETCURSEL, 0, 0);
  if (lRes == CB_ERR)
  {
    lRes = m_lLogonSelection;
  }

  if (lRes != -1 || lRes != CB_ERR)
  {
    LRESULT lTextLen = SendDlgItemMessage(IDC_LASTLOGON_COMBO, CB_GETLBTEXTLEN, (WPARAM)lRes, 0);
    if (lTextLen != CB_ERR)
    {
      if (lTextLen > 0)
      {
        bLastLogon = TRUE;

        WCHAR* pszData = new WCHAR[lTextLen + 1];
        if (pszData != NULL)
        {
          LRESULT lData = SendDlgItemMessage(IDC_LASTLOGON_COMBO, CB_GETLBTEXT, (WPARAM)lRes, (LPARAM)pszData);
          if (lData != CB_ERR)
          {
            dwLastLogonData = static_cast<DWORD>(_wtol(pszData));
          }
          delete[] pszData;
          pszData = NULL;
        }
      }
    }
  }

  if (bNonExpPwds || bLastLogon)
  {
    if (bNonExpPwds)
    {
       szFilter.Format(g_szUserAccountCtrlQuery, UF_DONT_EXPIRE_PASSWD);
    }
    szFilter = m_szFilterPrefix + szFilter;

    hr = BuildQueryParams(ppDsQueryParams, (LPWSTR)(LPCWSTR)szFilter);
    if (SUCCEEDED(hr))
    {
      if (bLastLogon)
      {
        (*ppDsQueryParams)->dwFlags |= DSQF_LAST_LOGON_QUERY;
        (*ppDsQueryParams)->dwReserved = dwLastLogonData;
      }
    }
  }
  return hr;
}

HRESULT CUserQueryPage::Persist(IPersistQuery* pPersistQuery, BOOL fRead)
{
  HRESULT hr = CUserComputerQueryPage::Persist(pPersistQuery, fRead);
  if (FAILED(hr))
  {
    return hr;
  }

  if (pPersistQuery == NULL)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  if (fRead)
  {
    //
    // Read non expiring pwds flag
    //
    int iData = 0;
    hr = pPersistQuery->ReadInt(m_szFilterPrefix, L"NonExpPwdCheck", &iData);
    if (FAILED(hr))
    {
      TRACE(_T("Failed to read int \"NonExpPwdCheck\" from stream: 0x%x\n"), hr);
      ASSERT(FALSE);
      return hr;
    }
    SendDlgItemMessage(IDC_NON_EXPIRING_PWD_CHECK, BM_SETCHECK, (iData > 0) ? BST_CHECKED : BST_UNCHECKED, 0);

    iData = 0;
    hr = pPersistQuery->ReadInt(m_szFilterPrefix, L"LastLogonCombo", &iData);
    if (FAILED(hr))
    {
      TRACE(_T("Failed to read int \"LastLogonCombo\" from stream: 0x%x\n"), hr);
      ASSERT(FALSE);
      return hr;
    }
    SendDlgItemMessage(IDC_LASTLOGON_COMBO, CB_SETCURSEL, (WPARAM)iData, 0);
    m_lLogonSelection = iData;
  }
  else
  {
    //
    // Write non expiring pwd flag
    //
    LRESULT lRes = SendDlgItemMessage(IDC_NON_EXPIRING_PWD_CHECK, BM_GETCHECK, 0, 0);
    if (lRes != -1)
    {
      int iRes = (lRes == BST_CHECKED) ? 1 : 0;
      hr = pPersistQuery->WriteInt(m_szFilterPrefix, L"NonExpPwdCheck", iRes);
      if (FAILED(hr))
      {
        ASSERT(FALSE);
        return hr;
      }
    }

    //
    // Write last logon combo index
    //
    lRes = SendDlgItemMessage(IDC_LASTLOGON_COMBO, CB_GETCURSEL, 0, 0);
    if (lRes == CB_ERR)
    {
      if (m_lLogonSelection != -1)
      {
        lRes = m_lLogonSelection;
      }
      else
      {
        lRes = 0;
      }
    }
    hr = pPersistQuery->WriteInt(m_szFilterPrefix, L"LastLogonCombo", static_cast<int>(lRes));
    if (FAILED(hr))
    {
      ASSERT(FALSE);
      return hr;
    }
  }
  return hr;
}

///////////////////////////////////////////////////////////////////////////////
// CQueryFormBase

HRESULT PageProc(LPCQPAGE pPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT GetQueryParams(HWND hWnd, LPDSQUERYPARAMS* ppDsQueryParams);

STDMETHODIMP CQueryFormBase::Initialize(HKEY)
{
    // This method is called to initialize the query form object, it is called before
    // any pages are added.  hkForm should be ignored, in the future however it
    // will be a way to persist form state.

	HRESULT hr = S_OK;

	return hr;
}

STDMETHODIMP CQueryFormBase::AddForms(LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam)
{
  CQFORM cqf;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

  // This method is called to allow the form handler to register its query form(s),
  // each form is identifiered by a CLSID and registered via the pAddFormProc.  Here
  // we are going to register a test form.
  
  // When registering a form which is only applicable to a specific task, eg. Find a Domain
  // object, it is advised that the form be marked as hidden (CQFF_ISNEVERLISTED) which 
  // will cause it not to appear in the form picker control.  Then when the
  // client wants to use this form, they specify the form identifier and ask for the
  // picker control to be hidden. 

  if ( !pAddFormsProc )
  {
    return E_INVALIDARG;
  }

  cqf.cbStruct = sizeof(cqf);
  cqf.dwFlags = CQFF_NOGLOBALPAGES;
  cqf.clsid = CLSID_DSAdminQueryUIForm;
  cqf.hIcon = NULL;

	CString	title;
	title.LoadString(IDS_QUERY_TITLE_SAVEDQUERYFORM);
  cqf.pszTitle = (LPCTSTR)title;

  return pAddFormsProc(lParam, &cqf);
}

STDMETHODIMP CQueryFormBase::AddPages(LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam)
{
	HRESULT hr = S_OK;
  CQPAGE cqp;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

  // AddPages is called after AddForms, it allows us to add the pages for the
  // forms we have registered.  Each page is presented on a seperate tab within
  // the dialog.  A form is a dialog with a DlgProc and a PageProc.  
  //
  // When registering a page the entire structure passed to the callback is copied, 
  // the amount of data to be copied is defined by the cbStruct field, therefore
  // a page implementation can grow this structure to store extra information.   When
  // the page dialog is constructed via CreateDialog the CQPAGE strucuture is passed
  // as the create param.

  if ( !pAddPagesProc )
      return E_INVALIDARG;

  cqp.cbStruct = sizeof(cqp);
  cqp.dwFlags = 0x0;
  cqp.pPageProc = PageProc;
  cqp.hInstance = _Module.GetModuleInstance();
  cqp.pDlgProc = DlgProc;

  //
  // Add the user page
  //
  cqp.idPageName = IDS_QUERY_TITLE_USERPAGE;
  cqp.idPageTemplate = IDD_QUERY_USER_PAGE;
  cqp.lParam = (LPARAM)new CUserQueryPage(FILTER_PREFIX_USER);
  hr = pAddPagesProc(lParam, CLSID_DSAdminQueryUIForm, &cqp);

  //
  // Add the computer page (this is just a std page)
  //
  cqp.idPageName = IDS_QUERY_TITLE_COMPUTER_PAGE;
  cqp.idPageTemplate = IDD_QUERY_COMPUTER_PAGE;
  cqp.lParam = (LPARAM)new CUserComputerQueryPage(IDD_QUERY_COMPUTER_PAGE, FILTER_PREFIX_COMPUTER);
  hr = pAddPagesProc(lParam, CLSID_DSAdminQueryUIForm, &cqp);

  //
  // Add the group page (this is just a std page)
  //
  cqp.idPageName = IDS_QUERY_TITLE_GROUP_PAGE;
  cqp.idPageTemplate = IDD_QUERY_STD_PAGE;
  cqp.lParam = (LPARAM)new CStdQueryPage(IDD_QUERY_STD_PAGE, FILTER_PREFIX_GROUP);
  hr = pAddPagesProc(lParam, CLSID_DSAdminQueryUIForm, &cqp);

  //
  // Add more pages here if needed
  //
  return hr;
}

/*---------------------------------------------------------------------------*/

// The PageProc is used to perform general house keeping and communicate between
// the frame and the page. 
//
// All un-handled, or unknown reasons should result in an E_NOIMPL response
// from the proc.  
//
// In:
//  pPage -> CQPAGE structure (copied from the original passed to pAddPagesProc)
//  hwnd = handle of the dialog for the page
//  uMsg, wParam, lParam = message parameters for this event
//
// Out:
//  HRESULT
//
// uMsg reasons:
// ------------
//  CQPM_INIIIALIZE
//  CQPM_RELEASE
//      These are issued as a result of the page being declared or freed, they 
//      allow the caller to AddRef, Release or perform basic initialization
//      of the form object.
//
// CQPM_ENABLE
//      Enable is when the query form needs to enable or disable the controls
//      on its page.  wParam contains TRUE/FALSE indicating the state that
//      is required.
//
// CQPM_GETPARAMETERS
//      To collect the parameters for the query each page on the active form 
//      receives this event.  lParam is an LPVOID* which is set to point to the
//      parameter block to pass to the handler, if the pointer is non-NULL 
//      on entry the form needs to appened its query information to it.  The
//      parameter block is handler specific. 
//
//      Returning S_FALSE from this event causes the query to be canceled.
//
// CQPM_CLEARFORM
//      When the page window is created for the first time, or the user clicks
//      the clear search the page receives a CQPM_CLEARFORM notification, at 
//      which point it needs to clear out the edit controls it has and
//      return to a default state.
//
// CQPM_PERSIST:
//      When loading of saving a query, each page is called with an IPersistQuery
//      interface which allows them to read or write the configuration information
//      to save or restore their state.  lParam is a pointer to the IPersistQuery object,
//      and wParam is TRUE/FALSE indicating read or write accordingly.

HRESULT PageProc(LPCQPAGE pQueryPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  HRESULT hr = S_OK;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	CQueryPageBase*	pDialog = (CQueryPageBase*)pQueryPage->lParam;

	ASSERT(pDialog);

  switch ( uMsg )
  {
    // Initialize so AddRef the object we are associated with so that
    // we don't get unloaded.
    case CQPM_INITIALIZE:
      break;

    // Changed from qform sample to detach the hwnd, and delete the CDialog
    // ensure correct destruction etc.
    case CQPM_RELEASE:
		  pDialog->Detach();
	    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)0);
		  delete pDialog;
      break;

    // Enable so fix the state of our two controls within the window.

    case CQPM_ENABLE:
      SetFocus(GetDlgItem(hwnd, IDC_NAME_COMBO));
      break;

    // Fill out the parameter structure to return to the caller, this is 
    // handler specific.  In our case we constructure a query of the CN
    // and objectClass properties, and we show a columns displaying both
    // of these.  For further information about the DSQUERYPARAMs structure
    // see dsquery.h

    case CQPM_GETPARAMETERS:
      hr = pDialog->GetQueryParams((LPDSQUERYPARAMS*)lParam);
      break;

    // Clear form, therefore set the window text for these two controls
    // to zero.
    case CQPM_CLEARFORM:
      hr = pDialog->ClearForm();
      break;
        
    // persistance is not currently supported by this form.            
    case CQPM_PERSIST:
    {
      BOOL fRead = (BOOL)wParam;
      IPersistQuery* pPersistQuery = (IPersistQuery*)lParam;

      if ( !pPersistQuery )
      {
        return E_INVALIDARG;
      }

	    hr = pDialog->Persist(pPersistQuery, fRead);
      break;
    }

    default:
      hr = E_NOTIMPL;
      break;
  }

  return hr;
}

/*---------------------------------------------------------------------------*/

// The DlgProc is a standard Win32 dialog proc associated with the form
// window.  

INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  LPCQPAGE pQueryPage;
	CQueryPageBase*	pDialog;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if ( uMsg == WM_INITDIALOG )
  {
    // changed from qForm sample to save CDialog pointer
    // in the DWL_USER field of the dialog box instance.
    pQueryPage = (LPCQPAGE)lParam;
		pDialog = (CQueryPageBase*)pQueryPage->lParam;
		pDialog->Attach(hwnd);

    SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM)pDialog);

		return pDialog->OnInitDialog();

  }
  else
  {
    // CDialog pointer is stored in DWL_USER
    // dialog structure, note however that in some cases this will
    // be NULL as it is set on WM_INITDIALOG.

		pDialog = (CQueryPageBase*)GetWindowLongPtr(hwnd, DWLP_USER);
  }

	if(!pDialog)
  {
		return FALSE;
  }
	else
  {
		return AfxCallWndProc(pDialog, hwnd, uMsg, wParam, lParam);
  }
}


///////////////////////////////////////////////////////////////////////
// CQueryDialog

CQueryDialog::CQueryDialog(CSavedQueryNode* pQueryNode, 
                           CFavoritesNode* pFavNode, 
                           CDSComponentData* pComponentData,
                           BOOL bNewQuery,
                           BOOL bImportQuery)
  : CHelpDialog(IDD_CREATE_NEW_QUERY)
{
  m_bInit = FALSE;

  m_bNewQuery     = bNewQuery;
  m_bImportQuery  = bImportQuery;
  m_pComponentData = pComponentData;
  m_pQueryNode    = pQueryNode;
  m_pFavNode      = pFavNode;
  m_szName        = pQueryNode->GetName();
  m_szOriginalName = pQueryNode->GetName();
  m_szDescription = pQueryNode->GetDesc();
  m_szQueryRoot   = pQueryNode->GetRootPath();
  m_szQueryFilter = pQueryNode->GetQueryString();
  m_bMultiLevel   = !pQueryNode->IsOneLevel();

  m_bLastLogonFilter = pQueryNode->IsFilterLastLogon();
  m_dwLastLogonData = pQueryNode->GetLastLogonDays();

  m_pPersistQueryImpl = pQueryNode->GetQueryPersist();
  if (m_pPersistQueryImpl != NULL)
  {
    m_pPersistQueryImpl->AddRef();
  }
  else
  {
    //
    // Create the IPersistQuery object
    //
	  CComObject<CDSAdminPersistQueryFilterImpl>::CreateInstance(&m_pPersistQueryImpl);
	  ASSERT(m_pPersistQueryImpl != NULL);

    //
	  // created with zero refcount,need to AddRef() to one
    //
	  m_pPersistQueryImpl->AddRef();
  }
}


CQueryDialog::~CQueryDialog()
{
	if (m_pPersistQueryImpl != NULL)
  {
	  //
    // go to refcount of zero, to destroy object
    //
	  m_pPersistQueryImpl->Release();
  }
}

BEGIN_MESSAGE_MAP(CQueryDialog, CHelpDialog)
  ON_BN_CLICKED(IDC_BROWSE_BUTTON, OnBrowse)
  ON_BN_CLICKED(IDC_EDIT_BUTTON, OnEditQuery)
  ON_BN_CLICKED(IDC_MULTI_LEVEL_CHECK, OnMultiLevelChange)
  ON_EN_CHANGE(IDC_NAME_EDIT, OnNameChange)
  ON_EN_CHANGE(IDC_DESCRIPTION_EDIT, OnDescriptionChange)
  ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnNeedToolTipText)
END_MESSAGE_MAP()

void CQueryDialog::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)  
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_CREATE_NEW_QUERY); 
  }
}

BOOL CQueryDialog::OnInitDialog()
{
  CHelpDialog::OnInitDialog();

  if (m_pQueryNode == NULL)
  {
    ASSERT(FALSE);
    EndDialog(IDCANCEL);
  }


  //
  // Change the title for editing queries
  //
  if (!m_bNewQuery)
  {
    CString szTitle;
    VERIFY(szTitle.LoadString(IDS_SAVED_QUERIES_EDIT_TITLE));
    SetWindowText(szTitle);
  }

  //
  // Initialize the controls with data
  //
  SetDlgItemText(IDC_NAME_EDIT, m_szName);
  SendDlgItemMessage(IDC_NAME_EDIT, EM_SETLIMITTEXT, MAX_QUERY_NAME_LENGTH, 0);
  SetDlgItemText(IDC_DESCRIPTION_EDIT, m_szDescription);
  SendDlgItemMessage(IDC_DESCRIPTION_EDIT, EM_SETLIMITTEXT, MAX_QUERY_DESC_LENGTH, 0);
  SendDlgItemMessage(IDC_MULTI_LEVEL_CHECK, BM_SETCHECK, (m_bMultiLevel) ? BST_CHECKED : BST_UNCHECKED, 0);
  SetQueryFilterDisplay();

  EnableToolTips(TRUE);
  SetQueryRoot(m_szQueryRoot);

  SetDirty();
  m_bInit = TRUE;
  return TRUE;
}

void CQueryDialog::SetDirty(BOOL bDirty)
{
  if (m_bInit || m_bImportQuery)
  {
    m_szName.TrimLeft();
    m_szName.TrimRight();
    if (m_szName.IsEmpty() ||
        m_szQueryRoot.IsEmpty() ||
        m_szQueryFilter.IsEmpty())
    {
      m_bDirty = FALSE;
    }
    else
    {
      m_bDirty = bDirty;
    }
    GetDlgItem(IDOK)->EnableWindow(m_bDirty);
  }
}

void CQueryDialog::OnOK()
{
  if (m_bDirty)
  {
    if (m_pQueryNode != NULL)
    {
      GetDlgItemText(IDC_NAME_EDIT, m_szName);
      GetDlgItemText(IDC_DESCRIPTION_EDIT, m_szDescription);
      LRESULT lRes = SendDlgItemMessage(IDC_MULTI_LEVEL_CHECK, BM_GETCHECK, 0, 0);
      if (lRes == BST_CHECKED)
      {
        m_bMultiLevel = TRUE;
      }
      else
      {
        m_bMultiLevel = FALSE;
      }

      //
      // Trim white space
      //
      m_szName.TrimLeft();
      m_szName.TrimRight();

      if (wcscmp(m_szOriginalName, m_szName) != 0 || m_bImportQuery)
      {
        CUINode* pDupNode = NULL;
        if (!m_pFavNode->IsUniqueName(m_szName, &pDupNode))
        {
          CString szFormatMsg;
          VERIFY(szFormatMsg.LoadString(IDS_ERRMSG_NOT_UNIQUE_QUERY_NAME));
  
          CString szErrMsg;
          szErrMsg.Format(szFormatMsg, m_szName);

          CString szTitle;
          VERIFY(szTitle.LoadString(IDS_DSSNAPINNAME));

          MessageBox(szErrMsg, szTitle, MB_OK | MB_ICONSTOP);

          //
          // Set the focus to the name field and select all the text
          //
          GetDlgItem(IDC_NAME_EDIT)->SetFocus();
          SendDlgItemMessage(IDC_NAME_EDIT, EM_SETSEL, 0, -1);
          return;
        }
      }

     
      if (m_bLastLogonFilter)
      {
        m_pQueryNode->SetLastLogonQuery(m_dwLastLogonData);
      }

      m_pQueryNode->SetQueryString(m_szQueryFilter);
      m_pQueryNode->SetName(m_szName);
      m_pQueryNode->SetDesc(m_szDescription);
      m_pQueryNode->SetRootPath(m_szQueryRoot);
      m_pQueryNode->SetOneLevel((m_bMultiLevel == BST_CHECKED) ? FALSE : TRUE);
      m_pQueryNode->SetQueryPersist(m_pPersistQueryImpl);
    }
  }
  CHelpDialog::OnOK();
}

BOOL CQueryDialog::OnNeedToolTipText(UINT, NMHDR* pTTTStruct, LRESULT* /*ignored*/)
{
  BOOL bRes = FALSE;
  TOOLTIPTEXT* pTTText = reinterpret_cast<TOOLTIPTEXT*>(pTTTStruct);
  if (pTTText != NULL)
  {
    if (pTTText->uFlags & TTF_IDISHWND)
    {
      UINT nCtrlID = ::GetDlgCtrlID((HWND)pTTText->hdr.idFrom);
      if (nCtrlID == IDC_ROOT_EDIT)
      {
        pTTText->lpszText = (LPWSTR)(LPCWSTR)m_szQueryRoot;
        bRes = TRUE;
      }
    }
  }
  return bRes;
}

void CQueryDialog::OnEditQuery()
{
	CLIPFORMAT cfDsQueryParams = (CLIPFORMAT)::RegisterClipboardFormat(CFSTR_DSQUERYPARAMS);

  //
	// create a query object
  //
	HRESULT hr;
	CComPtr<ICommonQuery> spCommonQuery;
  hr = ::CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER,
                        IID_ICommonQuery, (PVOID *)&spCommonQuery);
  if (FAILED(hr))
  {
    ReportMessageEx(GetSafeHwnd(), IDS_ERRMSG_NO_DSQUERYUI);
    return;
  }
	
  //
	// setup structs to make the query
  //
  DSQUERYINITPARAMS dqip;
  OPENQUERYWINDOW oqw;
	ZeroMemory(&dqip, sizeof(DSQUERYINITPARAMS));
	ZeroMemory(&oqw, sizeof(OPENQUERYWINDOW));

  dqip.cbStruct = sizeof(dqip);
  dqip.dwFlags = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS |
                 DSQPF_ENABLEADMINFEATURES;
  dqip.pDefaultScope = NULL;

  CString szServerName = m_pComponentData->GetBasePathsInfo()->GetServerName();
  if (!szServerName.IsEmpty())
  {
    dqip.dwFlags |= DSQPF_HASCREDENTIALS;
    dqip.pServer = (PWSTR)(PCWSTR)szServerName;
  }

  oqw.cbStruct = sizeof(oqw);
  oqw.dwFlags = OQWF_OKCANCEL | OQWF_DEFAULTFORM | OQWF_SHOWOPTIONAL | /*OQWF_REMOVEFORMS |*/
		OQWF_REMOVESCOPES | OQWF_SAVEQUERYONOK | OQWF_HIDEMENUS | OQWF_HIDESEARCHUI;

	if (!m_pPersistQueryImpl->IsEmpty())
  {
	  oqw.dwFlags |= OQWF_LOADQUERY;
  }

  oqw.clsidHandler = CLSID_DsQuery;
  oqw.pHandlerParameters = &dqip;
  oqw.clsidDefaultForm = CLSID_DSAdminQueryUIForm;

  //
	// set the IPersistQuery pointer (smart pointer)
  //
	CComPtr<IPersistQuery> spIPersistQuery;
	hr = m_pPersistQueryImpl->QueryInterface(IID_IPersistQuery, (void**)&spIPersistQuery);
  if (FAILED(hr))
  {
    int iRes = ReportMessageEx(GetSafeHwnd(), IDS_ERRMSG_NO_PERSIST_QUERYUI, MB_OKCANCEL | MB_ICONINFORMATION);
    if (iRes == IDCANCEL)
    {
      return;
    }
  }

  //
	// now smart pointer has refcount=1 for it lifetime
  //
	oqw.pPersistQuery = spIPersistQuery;

  //
	// Get the HWND of the current dialog
  //
  HWND hWnd = GetSafeHwnd();

  //
	// make the call to get the query displayed
  //
	CComPtr<IDataObject> spQueryResultDataObject;
  hr = spCommonQuery->OpenQueryWindow(hWnd, &oqw, &spQueryResultDataObject);
  if (SUCCEEDED(hr) && spQueryResultDataObject != NULL)
  {
    //
	  // retrieve the query string from the data object
    //
	  FORMATETC fmte = {cfDsQueryParams, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	  STGMEDIUM medium = {TYMED_NULL, NULL, NULL};
	  hr = spQueryResultDataObject->GetData(&fmte, &medium);

	  if (SUCCEEDED(hr)) // we have data
	  {
      //
		  // get the query string
      //
		  LPDSQUERYPARAMS pDsQueryParams = (LPDSQUERYPARAMS)medium.hGlobal;
		  LPWSTR pwszFilter = (LPWSTR)ByteOffset(pDsQueryParams, pDsQueryParams->offsetQuery);
		  
      CString szTempFilter = pwszFilter;

      //
      // Check to see if we received a "special" query string
      //
      if (pDsQueryParams->dwFlags & DSQF_LAST_LOGON_QUERY)
      {
        m_bLastLogonFilter = TRUE;
        m_dwLastLogonData = pDsQueryParams->dwReserved;

        LARGE_INTEGER li;
        GetCurrentTimeStampMinusInterval(m_dwLastLogonData, &li);

        CString szTimeStamp;
        litow(li, szTimeStamp);

        szTempFilter.Format(L"%s(lastLogonTimestamp<=%s)", szTempFilter, szTimeStamp);
      }
      else
      {
        m_bLastLogonFilter = FALSE;
        m_dwLastLogonData = 0;
      }

 		  ::ReleaseStgMedium(&medium);

		  // REVIEW_MARCOC: this is a hack waiting for Diz to fix it...
		  // the query string should be a well formed expression. Period
		  // the query string is in the form (<foo>)(<bar>)...
		  // if more of one token, need to wrap as (& (<foo>)(<bar>)...)
		  PWSTR pChar = (LPWSTR)(LPCWSTR)szTempFilter;
		  int nLeftPar = 0;
		  while (*pChar != NULL)
		  {
			  if (*pChar == TEXT('('))
			  {
				  nLeftPar++;
				  if (nLeftPar > 1)
					  break;
			  }
			  pChar++;
		  }
		  if (nLeftPar > 1)
		  {
			  m_szQueryFilter.Format(_T("(&%s)"), (LPCWSTR)szTempFilter);
		  }
      else
      {
        m_szQueryFilter = szTempFilter;
      }

      SetDirty();
	  }
    else
    {
      //
      // The user removed all query data from DSQUERYUI
      //

      //
      // Remove filter data
      //
      m_szQueryFilter = L"";
      m_bLastLogonFilter = FALSE;
      m_dwLastLogonData = 0;
      SetDirty();
    }
  }
  SetQueryFilterDisplay();
	return;
}

void CQueryDialog::SetQueryFilterDisplay()
{
  if (m_bLastLogonFilter)
  {
    CString szTemp;
    szTemp.LoadString(IDS_HIDE_LASTLOGON_QUERY);
    SetDlgItemText(IDC_QUERY_STRING_EDIT, szTemp);
  }
  else
  {
    SetDlgItemText(IDC_QUERY_STRING_EDIT, m_szQueryFilter);
  }
}

void CQueryDialog::OnBrowse()
{
	DWORD result;

	CString szBrowseTitle;
	VERIFY(szBrowseTitle.LoadString(IDS_QUERY_BROWSE_TITLE));

  CString szBrowseCaption;
  VERIFY(szBrowseCaption.LoadString(IDS_QUERY_BROWSE_CAPTION));

	WCHAR szPath[2 * MAX_PATH+1];

  //
  // Get the root of the console
  CString szDNC = m_pComponentData->GetBasePathsInfo()->GetDefaultRootNamingContext();
  CString szRootPath;
  m_pComponentData->GetBasePathsInfo()->ComposeADsIPath(szRootPath, szDNC);

  DSBROWSEINFO dsbi;
	::ZeroMemory( &dsbi, sizeof(dsbi) );

	dsbi.hwndOwner = GetSafeHwnd();
	dsbi.cbStruct = sizeof (DSBROWSEINFO);
	dsbi.pszCaption = (LPWSTR)((LPCWSTR)szBrowseTitle);
	dsbi.pszTitle = (LPWSTR)((LPCWSTR)szBrowseCaption);
	dsbi.pszRoot = szRootPath;
	dsbi.pszPath = szPath;
	dsbi.cchPath = ((2 * MAX_PATH + 1) / sizeof(WCHAR));
	dsbi.dwFlags = DSBI_INCLUDEHIDDEN | DSBI_RETURN_FORMAT;
	dsbi.pfnCallback = NULL;
	dsbi.lParam = 0;
  dsbi.dwReturnFormat = ADS_FORMAT_X500;

	result = DsBrowseForContainer( &dsbi );

	if ( result == IDOK ) 
	{ 
    //
    // returns -1, 0, IDOK or IDCANCEL
		// get path from BROWSEINFO struct, put in text edit field
    //
		TRACE(_T("returned from DS Browse successfully with:\n %s\n"),
		dsbi.pszPath);

    CPathCracker pathCracker;
    HRESULT hr = pathCracker.Set(dsbi.pszPath, ADS_SETTYPE_FULL);
    if (SUCCEEDED(hr))
    {
      hr = pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
      if (SUCCEEDED(hr))
      {
        CComBSTR bstrDN;
        hr = pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bstrDN);
        if (SUCCEEDED(hr))
        {
          SetQueryRoot(bstrDN);
          SetDirty();
        }
      }
    }
  }
}

void CQueryDialog::SetQueryRoot(PCWSTR pszPath)
{
  m_szQueryRoot = pszPath;

  CPathCracker pathCracker;
  HRESULT hr = pathCracker.Set((LPWSTR)(LPCWSTR)m_szQueryRoot, ADS_SETTYPE_DN);
  if (SUCCEEDED(hr))
  {
    hr = pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
    if (SUCCEEDED(hr))
    {
      CComBSTR bstrDisplayPath;
      hr = pathCracker.GetElement(0, &bstrDisplayPath);
      if (SUCCEEDED(hr))
      {
        CString szDisplayString;
        szDisplayString.Format(L"...\\%s", bstrDisplayPath);
        SetDlgItemText(IDC_ROOT_EDIT, szDisplayString);
      }
      else
      {
        SetDlgItemText(IDC_ROOT_EDIT, m_szQueryRoot);
      }
    }
    else
    {
      SetDlgItemText(IDC_ROOT_EDIT, m_szQueryRoot);
    }
  }
  else
  {
    SetDlgItemText(IDC_ROOT_EDIT, m_szQueryRoot);
  }
}

void CQueryDialog::OnMultiLevelChange()
{
  SetDirty();
}

void CQueryDialog::OnNameChange()
{
  GetDlgItemText(IDC_NAME_EDIT, m_szName);
  if (m_szName.IsEmpty())
  {
    SetDirty(FALSE);
  }
  else
  {
    SetDirty();
  }
}

void CQueryDialog::OnDescriptionChange()
{
  SetDirty();
}



///////////////////////////////////////////////////////////////////////////
// CFavoritesNodePropertyPage
BEGIN_MESSAGE_MAP(CFavoritesNodePropertyPage, CHelpPropertyPage)
  ON_EN_CHANGE(IDC_DESCRIPTION_EDIT, OnDescriptionChange)
END_MESSAGE_MAP()

void CFavoritesNodePropertyPage::DoContextHelp(HWND hWndControl) 
{
  if (hWndControl)  
  {
    ::WinHelp(hWndControl,
              DSADMIN_CONTEXT_HELP_FILE,
              HELP_WM_HELP,
              (DWORD_PTR)(LPTSTR)g_aHelpIDs_IDD_FAVORITES_PROPERTY_PAGE); 
  }
}

BOOL CFavoritesNodePropertyPage::OnInitDialog()
{
  CHelpPropertyPage::OnInitDialog();

  m_szOldDescription = m_pFavNode->GetDesc();
  SetDlgItemText(IDC_CN, m_pFavNode->GetName());
  SetDlgItemText(IDC_DESCRIPTION_EDIT, m_szOldDescription);

  return FALSE;
}

void CFavoritesNodePropertyPage::OnDescriptionChange()
{
  CString szNewDescription;
  GetDlgItemText(IDC_DESCRIPTION_EDIT, szNewDescription);

  if (szNewDescription == m_szOldDescription)
  {
    SetModified(FALSE);
  }
  else
  {
    SetModified(TRUE);
  }
}

BOOL CFavoritesNodePropertyPage::OnApply()
{
  BOOL bRet = TRUE;

  CString szNewDescription;
  GetDlgItemText(IDC_DESCRIPTION_EDIT, szNewDescription);
  if (szNewDescription == m_szOldDescription)
  {
    return TRUE;
  }
  else
  {
    m_pFavNode->SetDesc(szNewDescription);

    if (m_lNotifyHandle != NULL && m_pDataObject != NULL)
    {
      MMCPropertyChangeNotify(m_lNotifyHandle, (LPARAM)m_pDataObject);
    }
  }

  m_szOldDescription = szNewDescription;
  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\rename.h ===
//+----------------------------------------------------------------------------
//
//  DS Administration MMC snapin.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       Rename.h
//
//  Contents:   Rename object functions
//
//  Classes:    CDSRenameObject
//
//  History:    28-Oct-99 JeffJon  Created
//
//--------------------------------------------------------------------------

#ifndef __RENAME_H_
#define __RENAME_H_

///////////////////////////////////////////////////////////////////////////
// Forward declarations
//
class CUINode;
class CDSCookie;
class CDSComponentData;

///////////////////////////////////////////////////////////////////////////
// CDSRenameObject
//

class CDSRenameObject
{
public:
  CDSRenameObject(CUINode* pUINode, 
                  CDSCookie* pCookie, 
                  LPCWSTR pszNewName, 
                  HWND hwnd,
                  CDSComponentData* pComponentData)
    : m_pUINode(pUINode), 
      m_pCookie(pCookie), 
      m_hwnd(hwnd),
      m_pComponentData(pComponentData)
  {
    m_szNewName = pszNewName;
  }

  virtual ~CDSRenameObject() {}

  virtual HRESULT DoRename();

protected:
  HRESULT CommitRenameToDS();
  HRESULT ValidateAndModifyName(CString& refName, 
                                PCWSTR pszIllegalChars, 
                                WCHAR wReplacementChar,
                                UINT nModifyStringID,
                                HWND hWnd);

  CUINode*          m_pUINode;
  CDSCookie*        m_pCookie;
  CString           m_szNewName;
  HWND              m_hwnd;
  CDSComponentData* m_pComponentData;
};


///////////////////////////////////////////////////////////////////////////
// CDSRenameUser
//

class CDSRenameUser : public CDSRenameObject
{
public:
  CDSRenameUser(CUINode* pUINode, 
                CDSCookie* pCookie, 
                LPCWSTR pszNewName, 
                HWND hwnd,
                CDSComponentData* pComponentData)
    : CDSRenameObject(pUINode, pCookie, pszNewName, hwnd, pComponentData) {}

  virtual HRESULT DoRename();
};

///////////////////////////////////////////////////////////////////////////
// CDSRenameGroup
//

class CDSRenameGroup : public CDSRenameObject
{
public:
  CDSRenameGroup(CUINode* pUINode, 
                 CDSCookie* pCookie, 
                 LPCWSTR pszNewName, 
                 HWND hwnd,
                 CDSComponentData* pComponentData)
    : CDSRenameObject(pUINode, pCookie, pszNewName, hwnd, pComponentData) {}

  virtual HRESULT DoRename();
};

///////////////////////////////////////////////////////////////////////////
// CDSRenameContact
//

class CDSRenameContact : public CDSRenameObject
{
public:
  CDSRenameContact(CUINode* pUINode, 
                   CDSCookie* pCookie, 
                   LPCWSTR pszNewName, 
                   HWND hwnd,
                   CDSComponentData* pComponentData)
    : CDSRenameObject(pUINode, pCookie, pszNewName, hwnd, pComponentData) {}

  virtual HRESULT DoRename();
};

///////////////////////////////////////////////////////////////////////////
// CDSRenameSite
//

class CDSRenameSite : public CDSRenameObject
{
public:
  CDSRenameSite(CUINode* pUINode, 
                CDSCookie* pCookie, 
                LPCWSTR pszNewName, 
                HWND hwnd,
                CDSComponentData* pComponentData)
    : CDSRenameObject(pUINode, pCookie, pszNewName, hwnd, pComponentData) {}

  virtual HRESULT DoRename();
};

///////////////////////////////////////////////////////////////////////////
// CDSRenameNTDSConnection
//

class CDSRenameNTDSConnection : public CDSRenameObject
{
public:
  CDSRenameNTDSConnection(CUINode* pUINode, 
                          CDSCookie* pCookie, 
                          LPCWSTR pszNewName, 
                          HWND hwnd,
                          CDSComponentData* pComponentData)
    : CDSRenameObject(pUINode, pCookie, pszNewName, hwnd, pComponentData) {}

  virtual HRESULT DoRename();
};

///////////////////////////////////////////////////////////////////////////
// CDSRenameSubnet
//

class CDSRenameSubnet : public CDSRenameObject
{
public:
  CDSRenameSubnet(CUINode* pUINode, 
                  CDSCookie* pCookie, 
                  LPCWSTR pszNewName, 
                  HWND hwnd,
                  CDSComponentData* pComponentData)
    : CDSRenameObject(pUINode, pCookie, pszNewName, hwnd, pComponentData) {}

  virtual HRESULT DoRename();
};


#endif // __RENAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\rename.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rename.cpp
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"

#include "dsutil.h"

#include "rename.h"

#include "dsdirect.h"
#include "dsdlgs.h"
#include "dssnap.h"
#include "querysup.h"

#include <dsgetdc.h> // DsValidateSubnetName


////////////////////////////////////////////////////////////////////////////
// CDSRenameObject
//

HRESULT CDSRenameObject::CommitRenameToDS()
{
  //
  // Verify data members
  //
  if (m_pUINode == NULL || m_pCookie == NULL || m_pComponentData == NULL)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  HRESULT hr = S_OK;
  hr = m_pComponentData->GetActiveDS()->RenameObject (m_pCookie, m_szNewName);
  if (FAILED(hr)) 
  {
    TRACE (_T("ADsI::RenameObject failed with hr = %lx\n"), hr);
    PVOID apv[1] = {(BSTR)(LPWSTR)(LPCWSTR)m_pCookie->GetName()};
    ReportErrorEx (m_hwnd,IDS_12_OBJECT_RENAME_FAILED,hr,
                   MB_OK | MB_ICONERROR, apv, 1);
  }

  if (SUCCEEDED(hr)) 
  {
    //
    // update the data to be displayed
    //
    hr = m_pComponentData->UpdateFromDS(m_pUINode);
  }

  if ((SUCCEEDED(hr) && (hr != S_FALSE)) && m_pUINode->IsContainer()) 
  {
    if (m_pComponentData->IsSelectionAnywhere (m_pUINode)) 
    {
      m_pComponentData->Refresh (m_pUINode);
    } 
    else 
    {
      m_pComponentData->ClearSubtreeHelperForRename(m_pUINode);
    }
  }
  return hr;
}

//+------------------------------------------------------------------
//
//  Function:   CDSRenameObject::ValidateAndModifyName
//
//  Synopsis:   Takes a string and prompts the user to replace it
//              with the replacement char if it contains any of the
//              "illegal" characters
//
//  Returns:    HRESULT - S_OK if the string does not contain any of
//                             illegal chars
//                        S_FALSE if the user chose to replace the
//                             illegal chars
//                        E_FAIL if the string contained illegal
//                             chars but the user did not choose
//                             to replace them
//
//---------------------------------------------------------------------
HRESULT CDSRenameObject::ValidateAndModifyName(CString& refName, 
                                               PCWSTR pszIllegalChars, 
                                               WCHAR wReplacementChar,
                                               UINT nModifyStringID,
                                               HWND hWnd)
{
  HRESULT hr = S_OK;

  int iFind = refName.FindOneOf(pszIllegalChars);
  if (iFind != -1 && !refName.IsEmpty())
  {
    PVOID apv[1] = {(LPWSTR)(LPCWSTR)refName};
    if (IDYES == ReportErrorEx (hWnd,nModifyStringID,S_OK,
                                MB_YESNO | MB_ICONWARNING, apv, 1))
    {
      while (iFind != -1)
      {
        refName.SetAt(iFind, wReplacementChar);
        iFind = refName.FindOneOf(pszIllegalChars);
        hr = S_FALSE;
      }
    }
    else
    {
      hr = E_FAIL;
    }
  }

  return hr;
}

HRESULT CDSRenameObject::DoRename()
{
  HRESULT hr = S_OK;
  hr = CommitRenameToDS();
  return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDSRenameUser
//

HRESULT CDSRenameUser::DoRename()
{
  //
  // Verify data members
  //
  if (m_pUINode == NULL || m_pCookie == NULL || m_pComponentData == NULL)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  HRESULT hr = S_OK;
  //
  // rename user : get the new name from the dialog
  //
  CRenameUserDlg dlgRename(m_pComponentData);

  dlgRename.m_cn = m_szNewName;
  if ((dlgRename.m_cn).GetLength() > 64) 
  {
    ReportErrorEx (m_hwnd, IDS_NAME_TOO_LONG, S_OK,
                   MB_OK | MB_ICONWARNING, NULL, 0, FALSE);
    dlgRename.m_cn = (dlgRename.m_cn).Left(64);
  }

  LPWSTR pAttrNames[] = {L"distinguishedName",
                         L"userPrincipalName",
                         L"sAMAccountName",
                         L"givenName",
                         L"displayName",
                         L"sn",
                         L"cn"};
  PADS_ATTR_INFO pAttrs = NULL;
  ULONG cAttrs = 0;
  LPWSTR pszLocalDomain = NULL;
  LPWSTR pszDomain      = NULL;
  LPWSTR pszUPN         = NULL;
  LPWSTR pszFirstName   = NULL;
  LPWSTR pszSurName     = NULL;
  LPWSTR pszSAMName     = NULL;
  LPWSTR pszDispName    = NULL;

  BOOL error = TRUE;
  BOOL fAccessDenied = FALSE;
  BOOL NoRename = FALSE;
  INT_PTR answer = IDCANCEL;

  //
  // Bind to the DS object
  //
  CComPtr<IDirectoryObject> spDirObj;
  CString szPath;
  m_pComponentData->GetBasePathsInfo()->ComposeADsIPath(szPath, m_pCookie->GetPath());
  hr = DSAdminOpenObject(szPath,
                         IID_IDirectoryObject, 
                         (void **)&spDirObj,
                         TRUE /*bServer*/);
  if (SUCCEEDED(hr)) 
  {
    //
    // Get the object attributes needed
    //
    hr = spDirObj->GetObjectAttributes (pAttrNames, sizeof(pAttrNames)/sizeof(LPWSTR), &pAttrs, &cAttrs);
    if (SUCCEEDED(hr)) 
    {
      for (UINT i = 0; i < cAttrs; i++) 
      {
        //
        // Distinguished Name
        //
        if (_wcsicmp (L"distinguishedName", pAttrs[i].pszAttrName) == 0) 
        {
          hr = CrackName (pAttrs[i].pADsValues->CaseIgnoreString,
                          &pszDomain, GET_NT4_DOMAIN_NAME, NULL);
          if (SUCCEEDED(hr)) 
          {
            ASSERT(pszDomain != NULL);
            if (pszDomain != NULL)
            {
              dlgRename.m_dldomain = pszDomain;
              dlgRename.m_dldomain += L'\\';
            }
          }

          //
          // get the Domain of this object, need it later.
          //
          CComBSTR bsDN;
          CPathCracker pathCracker;
          pathCracker.SetDisplayType(ADS_DISPLAY_FULL);
          pathCracker.Set((LPTSTR)(LPCTSTR)szPath, ADS_SETTYPE_FULL);
          pathCracker.Retrieve(ADS_FORMAT_X500_DN, &bsDN);
          
          //
          // get the NT 5 (dns) domain name
          //

          TRACE(L"CrackName(%s, &pszDomain, GET_DNS_DOMAIN_NAME, NULL);\n", bsDN);
          hr = CrackName(bsDN, &pszLocalDomain, GET_DNS_DOMAIN_NAME, NULL);
          TRACE(L"CrackName returned hr = 0x%x, pszLocalDomain = <%s>\n", hr, pszLocalDomain);
        } // if distinguishedName

        //
        // User Principle Name
        //
        if (_wcsicmp (L"userPrincipalName", pAttrs[i].pszAttrName) == 0) 
        {
          CString csTemp = pAttrs[i].pADsValues->CaseIgnoreString;
          INT loc = csTemp.Find (L'@');
          if (loc > 0) 
          {
            dlgRename.m_login = csTemp.Left(loc);
            dlgRename.m_domain = csTemp.Right (csTemp.GetLength() - loc);
          } 
          else 
          {
            dlgRename.m_login = csTemp;
            ASSERT (0 && L"can't find @ in upn");
          }
        } // if userPrincipalName

        // 
        // sAMAccountName
        //
        if (_wcsicmp (L"sAMAccountName", pAttrs[i].pszAttrName) == 0) 
        {
          dlgRename.m_samaccountname = pAttrs[i].pADsValues->CaseIgnoreString;
        } // if sAMAccountName

        //
        // givenName
        //
        if (_wcsicmp (L"givenName", pAttrs[i].pszAttrName) == 0) 
        {
          dlgRename.m_first = pAttrs[i].pADsValues->CaseIgnoreString;
        } // if givenName

        //
        // displayName
        //
        if (_wcsicmp (L"displayName", pAttrs[i].pszAttrName) == 0) 
        {
          dlgRename.m_displayname = pAttrs[i].pADsValues->CaseIgnoreString;
        } // if displayName

        //
        // sn
        //
        if (_wcsicmp (L"sn", pAttrs[i].pszAttrName) == 0) 
        {
          dlgRename.m_last = pAttrs[i].pADsValues->CaseIgnoreString;
        } // if sn

        //
        // cn
        //
        if (_wcsicmp (L"cn", pAttrs[i].pszAttrName) == 0) 
        {
          dlgRename.m_oldcn = pAttrs[i].pADsValues->CaseIgnoreString;
        } // if cn
      }
    }

    //
    // get UPN suffixes from this OU, if present
    //
    CComPtr<IADs> spIADs;
    CComPtr<IADs> spContIADs;
    CComBSTR bsParentPath;
    CStringList UPNs;

    hr = spDirObj->QueryInterface (IID_IADs, (void **)&spIADs);
    ASSERT (SUCCEEDED(hr));
    hr = spIADs->get_Parent(&bsParentPath);
    ASSERT (SUCCEEDED(hr));
    hr = DSAdminOpenObject(bsParentPath,
                           IID_IADs, 
                           (void **)&spContIADs,
                           TRUE /*bServer*/);
    
    ASSERT(SUCCEEDED(hr));

    CComVariant Var;
    hr = spContIADs->Get ( L"uPNSuffixes", &Var);
    if (SUCCEEDED(hr)) 
    {
      hr = HrVariantToStringList (Var, UPNs);
      if (SUCCEEDED(hr)) 
      {
        POSITION pos = UPNs.GetHeadPosition();
        CString csSuffix;

        while (pos != NULL) 
        {
          csSuffix = L"@";
          csSuffix += UPNs.GetNext(INOUT pos);
          TRACE(_T("UPN suffix: %s\n"), csSuffix);
          if (wcscmp (csSuffix, dlgRename.m_domain)) 
          {
            dlgRename.m_domains.AddTail (csSuffix);
          }
        }
      }
    } 
    else 
    {
      //
      // now get the domain options
      //
      CComPtr<IDsBrowseDomainTree> spDsDomains;
      hr = ::CoCreateInstance(CLSID_DsDomainTreeBrowser,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsBrowseDomainTree,
                              (LPVOID*)&spDsDomains);
      ASSERT(SUCCEEDED(hr));
      
      PDOMAIN_TREE pNewDomains = NULL;
      hr = spDsDomains->GetDomains(&pNewDomains, 0);
      if (SUCCEEDED(hr))
      {
        ASSERT(pNewDomains);
        for (UINT index = 0; index < pNewDomains->dwCount; index++) 
        {
          if (pNewDomains->aDomains[index].pszTrustParent == NULL) 
          {
            CString strAtDomain = "@";
            strAtDomain += pNewDomains->aDomains[index].pszName;
            if (wcscmp (strAtDomain, dlgRename.m_domain)) 
            {
              dlgRename.m_domains.AddTail (strAtDomain);
            }
          }
        }
        spDsDomains->FreeDomains(&pNewDomains);
      }
      
      LocalFreeStringW(&pszDomain);

      //
      // get UPN suffixes
      //
      CString csPartitions;
      CStringList UPNsList;

      //
      // get config path from main object
      //
      csPartitions = m_pComponentData->GetBasePathsInfo()->GetProviderAndServerName();
      csPartitions += L"CN=Partitions,";
      csPartitions += m_pComponentData->GetBasePathsInfo()->GetConfigNamingContext();
      CComPtr<IADs> spPartitions;
      hr = DSAdminOpenObject(csPartitions,
                             IID_IADs, 
                             (void **)&spPartitions,
                             TRUE /*bServer*/);
      if (SUCCEEDED(hr)) 
      {
        CComVariant sVar;
        hr = spPartitions->Get ( L"uPNSuffixes", &sVar);
        if (SUCCEEDED(hr)) 
        {
          hr = HrVariantToStringList (sVar, UPNsList);
          if (SUCCEEDED(hr)) 
          {
            POSITION pos = UPNsList.GetHeadPosition();
            CString csSuffix;

            while (pos != NULL) 
            {
              csSuffix = L"@";
              csSuffix += UPNsList.GetNext(INOUT pos);
              TRACE(_T("UPN suffix: %s\n"), csSuffix);
              if (wcscmp (csSuffix, dlgRename.m_domain)) 
              {
                dlgRename.m_domains.AddTail (csSuffix);
              }
            }
          }
        }
      }
    }

    while ((error) && (!fAccessDenied))
    {
      answer = dlgRename.DoModal();
      if (answer == IDOK) 
      {
        ADSVALUE avUPN          = {ADSTYPE_CASE_IGNORE_STRING, NULL};
        ADS_ATTR_INFO aiUPN     = {L"userPrincipalName", ADS_ATTR_UPDATE,
                                    ADSTYPE_CASE_IGNORE_STRING, &avUPN, 1};
        ADSVALUE avSAMName      = {ADSTYPE_CASE_IGNORE_STRING, NULL};
        ADS_ATTR_INFO aiSAMName = {L"sAMAccountName", ADS_ATTR_UPDATE,
                                    ADSTYPE_CASE_IGNORE_STRING, &avSAMName, 1};
        ADSVALUE avGiven        = {ADSTYPE_CASE_IGNORE_STRING, NULL};
        ADS_ATTR_INFO aiGiven   = {L"givenName", ADS_ATTR_UPDATE,
                                    ADSTYPE_CASE_IGNORE_STRING, &avGiven, 1};
        ADSVALUE avSurName      = {ADSTYPE_CASE_IGNORE_STRING, NULL};
        ADS_ATTR_INFO aiSurName = {L"sn", ADS_ATTR_UPDATE,
                                    ADSTYPE_CASE_IGNORE_STRING, &avSurName, 1};
        ADSVALUE avDispName     = {ADSTYPE_CASE_IGNORE_STRING, NULL};
        ADS_ATTR_INFO aiDispName = {L"displayName", ADS_ATTR_UPDATE,
                                    ADSTYPE_CASE_IGNORE_STRING, &avDispName, 1};

        ADS_ATTR_INFO rgAttrs[5];
        ULONG cModified = 0;
        cAttrs = 0;

        if (!dlgRename.m_login.IsEmpty() && !dlgRename.m_domain.IsEmpty()) 
        {
          dlgRename.m_login.TrimRight();
          dlgRename.m_login.TrimLeft();

          //
          // Check for illegal characters in the login name
          //
          HRESULT hrValidate = ValidateAndModifyName(dlgRename.m_login, 
                                                     INVALID_ACCOUNT_NAME_CHARS, 
                                                     L'_',
                                                     IDS_LOGINNAME_ILLEGAL,
                                                     m_hwnd);
          if (FAILED(hrValidate))
          {
            continue;
          }

          dlgRename.m_domain.TrimRight();
          dlgRename.m_domain.TrimLeft();
          CString csTemp = (dlgRename.m_login + dlgRename.m_domain);

          pszUPN = new WCHAR[wcslen(csTemp) + sizeof(WCHAR)];

          if (pszUPN != NULL)
          {
            wcscpy (pszUPN, csTemp);
            avUPN.CaseIgnoreString = pszUPN;
          }
        } 
        else 
        {
          aiUPN.dwControlCode = ADS_ATTR_CLEAR;
        }
        rgAttrs[cAttrs++] = aiUPN;

        //
        // test UPN for duplication
        // validate UPN with GC before doing the put.
        //
        BOOL fDomainSearchFailed = FALSE;
        BOOL fGCSearchFailed = FALSE;

        HRESULT hr2 = S_OK;
        BOOL dup = FALSE;
        CString strFilter;

        if (pszUPN != NULL && *pszUPN != '\0')
        {
          LPWSTR pAttributes[1] = {L"cn"};
          CComPtr<IDirectorySearch>  spGCObj = NULL;
          CDSSearch DSS (m_pComponentData->GetClassCache(), m_pComponentData);
          hr = DSPROP_GetGCSearchOnDomain(pszLocalDomain,
                                          IID_IDirectorySearch, 
                                          (void **)&spGCObj);
          if (FAILED(hr)) 
          {
            fGCSearchFailed = TRUE;
          } 
          else 
          {
            DSS.Init (spGCObj);
          
            strFilter = L"(userPrincipalName=";
            strFilter += pszUPN;
            strFilter += L")";
            DSS.SetAttributeList (pAttributes, 1);
            DSS.SetFilterString ((LPWSTR)(LPCWSTR)strFilter);
            DSS.SetSearchScope (ADS_SCOPE_SUBTREE);
            DSS.DoQuery();
            hr = DSS.GetNextRow();

            while ((hr == S_OK) && (dup == FALSE)) // this means a row was returned, so we're dup
            {
              ADS_SEARCH_COLUMN Col;
              hr = DSS.GetColumn(pAttributes[0], &Col);
              if (_wcsicmp(Col.pADsValues->CaseIgnoreString, dlgRename.m_oldcn)) 
              {
                dup = TRUE;
                ReportErrorEx (m_hwnd, IDS_UPN_DUP, hr,
                               MB_OK, NULL, 0);
              } 
              hr = DSS.GetNextRow();
            }
            if (hr != S_ADS_NOMORE_ROWS) 
            {
              fGCSearchFailed = TRUE;
            }
          
          }
          if (dup)
          {
            continue;
          }
          else 
          {
            CString strInitPath = L"LDAP://";
            strInitPath += pszLocalDomain;
            TRACE(_T("Initialize Domain search object with: %s...\n"), strInitPath);
            hr2 = DSS.Init (strInitPath);

            if (SUCCEEDED(hr2)) 
            {
              LPWSTR pAttributes2[1] = {L"cn"};
              strFilter = L"(userPrincipalName=";
              strFilter += pszUPN;
              strFilter += L")";
              TRACE(_T("searching current domain for %s...\n"), pszUPN);
              DSS.SetAttributeList (pAttributes2, 1);
              DSS.SetFilterString ((LPWSTR)(LPCWSTR)strFilter);
              DSS.SetSearchScope (ADS_SCOPE_SUBTREE);
              DSS.DoQuery();
              hr2 = DSS.GetNextRow();
              TRACE(_T("done searching current domain for %s...\n"), pszUPN);
            }

            while ((hr2 == S_OK) && (dup == FALSE))  // this means a row was returned, so we're dup
            {
              ADS_SEARCH_COLUMN Col;
              HRESULT hr3 = DSS.GetColumn(pAttributes[0], &Col);
              ASSERT (hr3 == S_OK);
              if (_wcsicmp(Col.pADsValues->CaseIgnoreString, dlgRename.m_oldcn)) 
              {
                dup = TRUE;
                ReportErrorEx (m_hwnd, IDS_UPN_DUP, hr,
                               MB_OK, NULL, 0);
              } 
              hr2 = DSS.GetNextRow();
            }
            if (hr2 != S_ADS_NOMORE_ROWS)  // oops, had another problem
            {
              fDomainSearchFailed = TRUE;
            }
          }
        }

        if (dup)
        {
          continue;
        }
        else 
        {
          if (fDomainSearchFailed || 
              fGCSearchFailed     || 
              pszUPN == NULL      ||
              *pszUPN == L'\0') 
          {
            if (fDomainSearchFailed) 
            {
              ReportErrorEx (m_hwnd,IDS_UPN_SEARCH_FAILED2,hr2,
                             MB_OK | MB_ICONWARNING, NULL, 0);
            } 
            else if (fGCSearchFailed)
            {
              ReportErrorEx (m_hwnd,IDS_UPN_SEARCH_FAILED2,hr,
                             MB_OK | MB_ICONWARNING, NULL, 0);
            }
            else
            {
              ReportErrorEx (m_hwnd, IDS_UPN_SEARCH_FAILED3, hr,
                             MB_OK | MB_ICONWARNING, NULL, 0);
            }
          }
        }

        dlgRename.m_cn.TrimRight();
        dlgRename.m_cn.TrimLeft();
        m_szNewName = dlgRename.m_cn;

        if (dlgRename.m_cn == dlgRename.m_oldcn)
        {
          NoRename = TRUE;
        }

        if (!dlgRename.m_displayname.IsEmpty()) 
        {
          dlgRename.m_displayname.TrimLeft();
          dlgRename.m_displayname.TrimRight();

          pszDispName = new WCHAR[wcslen(dlgRename.m_displayname) + sizeof(WCHAR)];
          if (pszDispName != NULL)
          {
            wcscpy (pszDispName, dlgRename.m_displayname);
            avDispName.CaseIgnoreString = pszDispName;
          }
        } 
        else 
        {
          aiDispName.dwControlCode = ADS_ATTR_CLEAR;
        }
        rgAttrs[cAttrs++] = aiDispName;

        if (!dlgRename.m_first.IsEmpty()) 
        {
          dlgRename.m_first.TrimLeft();
          dlgRename.m_first.TrimRight();

          pszFirstName = new WCHAR[wcslen(dlgRename.m_first) + sizeof(WCHAR)];
          if (pszFirstName != NULL)
          {
            wcscpy (pszFirstName, dlgRename.m_first);
            avGiven.CaseIgnoreString = pszFirstName;
          }
        } 
        else 
        {
          aiGiven.dwControlCode = ADS_ATTR_CLEAR;
        }
        rgAttrs[cAttrs++] = aiGiven;

        if (!dlgRename.m_last.IsEmpty()) 
        {
          dlgRename.m_last.TrimLeft();
          dlgRename.m_last.TrimRight();

          pszSurName = new WCHAR[wcslen(dlgRename.m_last) + sizeof(WCHAR)];
          if (pszSurName != NULL)
          {
            wcscpy (pszSurName, dlgRename.m_last);
            avSurName.CaseIgnoreString = pszSurName;
          }
        } 
        else 
        {
          aiSurName.dwControlCode = ADS_ATTR_CLEAR;
        }
        rgAttrs[cAttrs++] = aiSurName;

        if (!dlgRename.m_samaccountname.IsEmpty()) 
        {
          dlgRename.m_samaccountname.TrimLeft();
          dlgRename.m_samaccountname.TrimRight();

          //
          // Check for illegal characters in the SAM account name
          //
          HRESULT hrValidate = ValidateAndModifyName(dlgRename.m_samaccountname, 
                                                     INVALID_ACCOUNT_NAME_CHARS_WITH_AT, 
                                                     L'_',
                                                     IDS_SAMNAME_ILLEGAL,
                                                     m_hwnd);
          if (FAILED(hrValidate))
          {
            continue;
          }

          pszSAMName = new WCHAR[wcslen(dlgRename.m_samaccountname) + sizeof(WCHAR)];
          if (pszSAMName != NULL)
          {
            wcscpy (pszSAMName, dlgRename.m_samaccountname);
            avSAMName.CaseIgnoreString = pszSAMName;
          }
        } 
        else 
        {
          aiSAMName.dwControlCode = ADS_ATTR_CLEAR;
        }
        rgAttrs[cAttrs++] = aiSAMName;
        
        
        hr = spDirObj->SetObjectAttributes (rgAttrs, cAttrs, &cModified);
        if (FAILED(hr)) 
        {
          if (hr == E_ACCESSDENIED) 
          {
            fAccessDenied = TRUE;
            NoRename = TRUE;
          } 
          else 
          {
            ReportErrorEx (m_hwnd, IDS_NAME_CHANGE_FAILED, hr,
                           MB_OK|MB_ICONERROR, NULL, 0, 0, TRUE);
          }
        } 
        else 
        {
          error = FALSE;
        }
      } 
      else 
      {
        error = FALSE;
      }
    } 
  } 
  else 
  {
    answer = IDCANCEL;
    PVOID apv[1] = {(BSTR)(LPWSTR)(LPCWSTR)m_pCookie->GetName()};
    ReportErrorEx (m_hwnd,IDS_12_USER_OBJECT_NOT_ACCESSABLE,hr,
                   MB_OK | MB_ICONERROR, apv, 1);
  }
  if ((answer == IDOK) && (error == FALSE) && (NoRename == FALSE)) 
  {
    hr = CommitRenameToDS();
  }

  if (fAccessDenied) 
  {
    PVOID apv[1] = {(BSTR)(LPWSTR)(LPCWSTR)m_pCookie->GetName()};
    ReportErrorEx(::GetParent(m_hwnd),IDS_12_RENAME_NOT_ALLOWED,hr,
                  MB_OK | MB_ICONERROR, apv, 1);
  }
  
  //
  // Cleanup
  //
  if (pszLocalDomain != NULL)
  {
    LocalFreeStringW(&pszLocalDomain);
  }

  if (pszUPN != NULL)
  {
    delete pszUPN;
  }

  if (pszFirstName != NULL)
  {
    delete pszFirstName;
  }

  if (pszSurName != NULL)
  {
    delete pszSurName;
  }

  if (pszSAMName != NULL)
  {
    delete pszSAMName;
  }

  if (pszDispName != NULL)
  {
    delete pszDispName;
  }

  return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDSRenameGroup
//

HRESULT CDSRenameGroup::DoRename()
{
  //
  // Verify data members
  //
  if (m_pUINode == NULL || m_pCookie == NULL || m_pComponentData == NULL)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  //
  // Rename Group
  //
  
  HRESULT hr = S_OK;
  BOOL error = FALSE;
  BOOL fAccessDenied = FALSE;
  BOOL NoRename = FALSE;
  INT_PTR answer = IDCANCEL;

  CRenameGroupDlg dlgRename;
  dlgRename.m_cn = m_szNewName;

  //
  // Check the length of the new name
  //
  if ((dlgRename.m_cn).GetLength() > 64) 
  {
    ReportErrorEx (m_hwnd, IDS_NAME_TOO_LONG, S_OK,
                   MB_OK | MB_ICONWARNING, NULL, 0, FALSE);
    dlgRename.m_cn = (dlgRename.m_cn).Left(64);
  }

  //
  // Bind to the object
  //
  CComPtr<IADs> spIADs;
  CString szPath;
  m_pComponentData->GetBasePathsInfo()->ComposeADsIPath(szPath, m_pCookie->GetPath());
  hr = DSAdminOpenObject(szPath,
                         IID_IADs, 
                         (void **)&spIADs,
                         TRUE /*bServer*/);
  if (SUCCEEDED(hr)) 
  {
    //
    // Retrieve the sAMAccountName
    //

    CComVariant Var;
    hr = spIADs->Get (L"sAMAccountName", &Var);
    ASSERT (SUCCEEDED(hr));
    CString csSam = Var.bstrVal;

    dlgRename.m_samaccountname = csSam;

    error = TRUE;
    while ((error) && (!fAccessDenied))
    {
      answer = dlgRename.DoModal();
      if (answer == IDOK) 
      {
        dlgRename.m_cn.TrimRight();
        dlgRename.m_cn.TrimLeft();
        m_szNewName = dlgRename.m_cn;

        Var.vt = VT_BSTR;
        
        //
        // Trim whitespace from samaccountname
        //
        dlgRename.m_samaccountname.TrimLeft();
        dlgRename.m_samaccountname.TrimRight();

        //
        // Check for illegal characters in the login name
        //
        HRESULT hrValidate = ValidateAndModifyName(dlgRename.m_samaccountname, 
                                                   INVALID_ACCOUNT_NAME_CHARS, 
                                                   L'_',
                                                   IDS_GROUP_SAMNAME_ILLEGAL,
                                                   m_hwnd);
        if (FAILED(hrValidate))
        {
          continue;
        }

        csSam = dlgRename.m_samaccountname;

        //
        // Put changes to samaccountname
        //
        Var.bstrVal = SysAllocString(csSam);
        hr = spIADs->Put (L"sAMAccountName", Var);
        ASSERT (SUCCEEDED(hr));
        SysFreeString (Var.bstrVal);
        if (FAILED(hr)) 
        {
          continue;
        }
        
        //
        // Commit the changes
        //
        hr = spIADs->SetInfo();
        if (FAILED(hr)) 
        {
          if (hr == E_ACCESSDENIED) 
          {
            fAccessDenied = TRUE;
            NoRename = TRUE;
          } 
          else 
          {
            ReportErrorEx (m_hwnd, IDS_NAME_CHANGE_FAILED, hr,
                           MB_OK|MB_ICONERROR, NULL, 0, 0, TRUE);
          }
        } 
        else 
        {
          error = FALSE;
        }
      } 
      else 
      {
        error = FALSE;
      }
    }
  } 
  else 
  {
    answer = IDCANCEL;
  }

  if ((answer == IDOK) && (error == FALSE) && (NoRename == FALSE)) 
  {
    hr = CommitRenameToDS();
  }

  if (fAccessDenied) 
  {
    PVOID apv[1] = {(BSTR)(LPWSTR)(LPCWSTR)m_pCookie->GetName()};
    ReportErrorEx(::GetParent(m_hwnd),IDS_12_RENAME_NOT_ALLOWED,hr,
                  MB_OK | MB_ICONERROR, apv, 1);
  }

  return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDSRenameContact
//

HRESULT CDSRenameContact::DoRename()
{
  //
  // Verify data members
  //
  if (m_pUINode == NULL || m_pCookie == NULL || m_pComponentData == NULL)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  BOOL error = FALSE;
  BOOL fAccessDenied = FALSE;
  BOOL NoRename = FALSE;

  INT_PTR answer = IDCANCEL;
  HRESULT hr = S_OK;

  // 
  // rename contact
  //
  CRenameContactDlg dlgRename;
  dlgRename.m_cn = m_szNewName;

  //
  // Check the length of the new name
  //
  if ((dlgRename.m_cn).GetLength() > 64) 
  {
    ReportErrorEx (m_hwnd, IDS_NAME_TOO_LONG, S_OK,
                   MB_OK | MB_ICONWARNING, NULL, 0, FALSE);
    dlgRename.m_cn = (dlgRename.m_cn).Left(64);
  }

  //
  // Bind to the DS object
  //
  CComPtr<IADs> spIADs;
  CString szPath;
  m_pComponentData->GetBasePathsInfo()->ComposeADsIPath(szPath, m_pCookie->GetPath());
  hr = DSAdminOpenObject(szPath,
                         IID_IADs, 
                         (void **)&spIADs,
                         TRUE /*bServer*/);
  if (SUCCEEDED(hr)) 
  {
    //
    // Retrieve the needed attributes
    //

    //
    // givenName
    //
    CComVariant Var;
    hr = spIADs->Get (L"givenName", &Var);
    ASSERT (SUCCEEDED(hr) || (hr == E_ADS_PROPERTY_NOT_FOUND));
    if (SUCCEEDED(hr)) 
    {
      dlgRename.m_first = Var.bstrVal;
    }

    //
    // sur name
    //
    hr = spIADs->Get (L"sn", &Var);
    ASSERT (SUCCEEDED(hr) || (hr == E_ADS_PROPERTY_NOT_FOUND));
    if (SUCCEEDED(hr)) 
    {
      dlgRename.m_last = Var.bstrVal;
    }

    //
    // Display name
    //
    hr = spIADs->Get (L"displayName", &Var);
    ASSERT (SUCCEEDED(hr) || (hr == E_ADS_PROPERTY_NOT_FOUND));
    if (SUCCEEDED(hr)) 
    {
      dlgRename.m_disp = Var.bstrVal;
    }

    error = TRUE;
    while ((error) && (!fAccessDenied))
    {
      answer = dlgRename.DoModal();
      if (answer == IDOK) 
      {
        dlgRename.m_cn.TrimRight();
        dlgRename.m_cn.TrimLeft();
        m_szNewName = dlgRename.m_cn;

        Var.vt = VT_BSTR;
        
        //
        // Put givenName
        //
        if (!dlgRename.m_first.IsEmpty()) 
        {
          dlgRename.m_first.TrimLeft();
          dlgRename.m_first.TrimRight();
          Var.bstrVal = SysAllocString (dlgRename.m_first);
          hr = spIADs->Put (L"givenName", Var);
          ASSERT (SUCCEEDED(hr));
          SysFreeString(Var.bstrVal);
        }
        
        //
        // Put sur name
        //
        if (!dlgRename.m_last.IsEmpty()) 
        {
          dlgRename.m_last.TrimLeft();
          dlgRename.m_last.TrimRight();
          Var.bstrVal = SysAllocString(dlgRename.m_last);
          hr = spIADs->Put (L"sn", Var);
          ASSERT (SUCCEEDED(hr));
          SysFreeString (Var.bstrVal);
        }
        
        //
        // Put displayName
        //
        if (!dlgRename.m_disp.IsEmpty()) 
        {
          dlgRename.m_disp.TrimLeft();
          dlgRename.m_disp.TrimRight();
          Var.bstrVal = SysAllocString(dlgRename.m_disp);
          hr = spIADs->Put (L"displayName", Var);
          ASSERT (SUCCEEDED(hr));
          SysFreeString (Var.bstrVal);
        }
        
        //
        // Commit changes to DS object
        //
        hr = spIADs->SetInfo();
        if (FAILED(hr)) 
        {
          if (hr == E_ACCESSDENIED) 
          {
            fAccessDenied = TRUE;
            NoRename = TRUE;
          } 
          else 
          {
            ReportErrorEx (m_hwnd, IDS_NAME_CHANGE_FAILED, hr,
                           MB_OK|MB_ICONERROR, NULL, 0, 0, TRUE);
          }
        } 
        else 
        {
          error = FALSE;
        } 
      } 
      else 
      {
        error = FALSE;
      }
    }
  } 
  else 
  {
    answer = IDCANCEL;
  }

  if ((answer == IDOK) && (error == FALSE) && (NoRename == FALSE)) 
  {
    hr = CommitRenameToDS();
  }

  if (fAccessDenied) 
  {
    PVOID apv[1] = {(BSTR)(LPWSTR)(LPCWSTR)m_pCookie->GetName()};
    ReportErrorEx(::GetParent(m_hwnd),IDS_12_RENAME_NOT_ALLOWED,hr,
                  MB_OK | MB_ICONERROR, apv, 1);
  }

  return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDSRenameSite
//

HRESULT CDSRenameSite::DoRename()
{
  //
  // Verify data members
  //
  if (m_pUINode == NULL || m_pCookie == NULL || m_pComponentData == NULL)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  HRESULT hr = S_OK;

  //
  // Rename site
  //
  BOOL fNonRfcSiteName = FALSE;
  BOOL fValidSiteName = IsValidSiteName( m_szNewName, &fNonRfcSiteName );
  if ( !fValidSiteName ) 
  {
    ReportErrorEx (m_hwnd,IDS_SITE_NAME,S_OK,
                   MB_OK, NULL, 0);
  } 
  else if (fNonRfcSiteName) 
  {
    LPCWSTR pszNewName = m_szNewName;
    PVOID apv[1];
    apv[0] = (PVOID)pszNewName;
    if (IDYES != ReportMessageEx( m_hwnd,
                                  IDS_1_NON_RFC_SITE_NAME,
                                  MB_YESNO | MB_ICONWARNING,
                                  apv,
                                  1 ) ) 
    {
      fValidSiteName = FALSE;
    }
  }
  if ( fValidSiteName ) 
  {
    hr = CommitRenameToDS();
  }

  return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDSRenameNTDSConnection
//

HRESULT CDSRenameNTDSConnection::DoRename()
{
  //
  // Verify data members
  //
  if (m_pUINode == NULL || m_pCookie == NULL || m_pComponentData == NULL)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  HRESULT hr = S_OK;

  //
  // JonN 5/10/01 283026
  // Duplicate connection objects named
  // "<automatically generated>" can be created
  //
  CString strKCCGenerated;
  CString strNewName = m_szNewName;
  strNewName.TrimLeft();
  strNewName.TrimRight();
  strKCCGenerated.LoadString (IDS_CONNECTION_KCC_GENERATED);
  if ( !strNewName.CompareNoCase(strKCCGenerated) )
  {
    TRACE (_T("CDSRenameNTDSConnection::DoRename blocked rename"));
    ReportErrorEx (m_hwnd,IDS_CONNECTION_RENAME_KCCSTRING,hr,
                   MB_OK | MB_ICONWARNING, NULL, 0);
    return S_OK;
  }

  //
  // Rename nTDSConnection
  //
  if (m_pComponentData->RenameConnectionFixup(m_pCookie)) 
  {
    hr = CommitRenameToDS();
  }

  return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDSRenameSubnet
//

HRESULT CDSRenameSubnet::DoRename()
{
  //
  // Verify data members
  //
  if (m_pUINode == NULL || m_pCookie == NULL || m_pComponentData == NULL)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  HRESULT hr = S_OK;

  //
  // Rename subnet
  //
  DWORD dw = ::DsValidateSubnetName( m_szNewName );
  if (ERROR_SUCCESS == dw)
  {
    hr = CommitRenameToDS();
  } 
  else 
  {
    ReportErrorEx (m_hwnd,IDS_SUBNET_NAME,S_OK,
                   MB_OK, NULL, 0);
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\schemarc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       Schemarc.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	Schemarc.h
//
//	Default resource Id for the syntax description of Schema Attributes.
//
//	HISTORY
//	22-Aug-97	Dan Morin	Creation.
/////////////////////////////////////////////////////////////////////

#ifndef IDS_SCHEMA_ATTR_SYNTAX_BASE
	#define	IDS_SCHEMA_ATTR_SYNTAX_BASE	380		// Arbitrary chosen
#endif

#define	IDS_SCHEMA_ATTR_SYNTAX_DN				(IDS_SCHEMA_ATTR_SYNTAX_BASE+1)
#define	IDS_SCHEMA_ATTR_SYNTAX_OID				(IDS_SCHEMA_ATTR_SYNTAX_BASE+2)
#define	IDS_SCHEMA_ATTR_SYNTAX_CASE_STR			(IDS_SCHEMA_ATTR_SYNTAX_BASE+3)
#define	IDS_SCHEMA_ATTR_SYNTAX_NOCASE_STR		(IDS_SCHEMA_ATTR_SYNTAX_BASE+4)
#define	IDS_SCHEMA_ATTR_SYNTAX_PRCS_STR			(IDS_SCHEMA_ATTR_SYNTAX_BASE+5)
#define	IDS_SCHEMA_ATTR_SYNTAX_NUMSTR			(IDS_SCHEMA_ATTR_SYNTAX_BASE+6)
#define	IDS_SCHEMA_ATTR_SYNTAX_OR_NAME			(IDS_SCHEMA_ATTR_SYNTAX_BASE+7)
#define	IDS_SCHEMA_ATTR_SYNTAX_BOOLEAN			(IDS_SCHEMA_ATTR_SYNTAX_BASE+8)
#define	IDS_SCHEMA_ATTR_SYNTAX_INTEGER			(IDS_SCHEMA_ATTR_SYNTAX_BASE+9)
#define	IDS_SCHEMA_ATTR_SYNTAX_OCTET			(IDS_SCHEMA_ATTR_SYNTAX_BASE+10)
#define	IDS_SCHEMA_ATTR_SYNTAX_UTC          	(IDS_SCHEMA_ATTR_SYNTAX_BASE+11)
#define	IDS_SCHEMA_ATTR_SYNTAX_UNICODE      	(IDS_SCHEMA_ATTR_SYNTAX_BASE+12)
#define	IDS_SCHEMA_ATTR_SYNTAX_ADDRESS      	(IDS_SCHEMA_ATTR_SYNTAX_BASE+13)
#define	IDS_SCHEMA_ATTR_SYNTAX_DNADDR       	(IDS_SCHEMA_ATTR_SYNTAX_BASE+14)
#define	IDS_SCHEMA_ATTR_SYNTAX_SEC_DESC     	(IDS_SCHEMA_ATTR_SYNTAX_BASE+15)
#define	IDS_SCHEMA_ATTR_SYNTAX_LINT         	(IDS_SCHEMA_ATTR_SYNTAX_BASE+16)
#define	IDS_SCHEMA_ATTR_SYNTAX_SID          	(IDS_SCHEMA_ATTR_SYNTAX_BASE+17)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simcert.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       simcert.h
//
//--------------------------------------------------------------------------

//	SimCert.h - SIM Certificate Dialog


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSimCertificateDlg dialog
class CSimCertificateDlg : public CDialogEx
{
	friend CSimX509PropPage;

public:
	CSimCertificateDlg(CWnd* pParent = NULL);   // standard constructor

	//{{AFX_DATA(CSimCertificateDlg)
	enum { IDD = IDD_SIM_CERTIFICATE_PROPERTIES };
	BOOL	m_fCheckIssuer;
	BOOL	m_fCheckSubject;
	//}}AFX_DATA
	UINT m_uStringIdCaption;		// String Id for the caption


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSimCertificateDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSimCertificateDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnCheckIssuer();
	afx_msg void OnCheckSubject();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	HWND m_hwndListview;		// Handle of the listview control
	CString m_strData;			// Long string to store the whole certificate information

	void UpdateUI();
	void RefreshUI();
	void PopulateListview();
	bool AddListviewItems(UINT uStringId, LPCTSTR rgzpsz[]);

private:
	bool m_fCheckSubjectChanged;
}; // CSimCertificateDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simcert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       simcert.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	SimCert.cpp - Implementation of SIM Certificate Dialog
//
//	HISTORY
//	05-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "common.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


const TColumnHeaderItem rgzColumnHeaderCertificateProperties[] =
{
	{ IDS_SIM_ATTRIBUTE, 18 },
	{ IDS_SIM_INFORMATION, 75 },
	{ 0, 0 },
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSimCertificateDlg dialog
CSimCertificateDlg::CSimCertificateDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(CSimCertificateDlg::IDD, pParent),
	m_fCheckSubjectChanged (false)
{
	//{{AFX_DATA_INIT(CSimCertificateDlg)
	m_fCheckIssuer = TRUE;
	m_fCheckSubject = FALSE;
	//}}AFX_DATA_INIT
	m_uStringIdCaption = 0;
}

void CSimCertificateDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSimCertificateDlg)
	DDX_Check(pDX, IDC_CHECK_ISSUER, m_fCheckIssuer);
	DDX_Check(pDX, IDC_CHECK_SUBJECT, m_fCheckSubject);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSimCertificateDlg, CDialog)
	//{{AFX_MSG_MAP(CSimCertificateDlg)
	ON_BN_CLICKED(IDC_CHECK_ISSUER, OnCheckIssuer)
	ON_BN_CLICKED(IDC_CHECK_SUBJECT, OnCheckSubject)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////
BOOL CSimCertificateDlg::OnInitDialog() 
{
	if (m_uStringIdCaption)
	{
		CString strCaption;
		VERIFY( strCaption.LoadString(m_uStringIdCaption) );
		SetWindowText(strCaption);
	}
	m_hwndListview = ::GetDlgItem(m_hWnd, IDC_LISTVIEW);
	ListView_AddColumnHeaders(m_hwndListview, rgzColumnHeaderCertificateProperties);
	PopulateListview();
	CDialog::OnInitDialog();
	UpdateUI();
	return TRUE;
}


/////////////////////////////////////////////////////////////////////
void CSimCertificateDlg::PopulateListview()
{
	LPTSTR * pargzpsz = 0;	// Pointer to allocated array of pointer to strings
	LPCTSTR * pargzpszIssuer = 0;
	LPCTSTR * pargzpszSubject = 0;

	pargzpsz = SplitX509String(
		IN m_strData,
		OUT &pargzpszIssuer,
		OUT &pargzpszSubject,
		0);
	if (pargzpsz == NULL)
	{
		TRACE1("CSimCertificateDlg::PopulateListview() - Error parsing string %s.\n",
			(LPCTSTR)m_strData);
		return;
	}

	AddListviewItems(IDS_SIM_ISSUER, pargzpszIssuer);
	if ( !AddListviewItems(IDS_SIM_SUBJECT, pargzpszSubject) )
	{
		GetDlgItem (IDC_CHECK_SUBJECT)->EnableWindow (FALSE);
	}

	m_fCheckIssuer = pargzpszIssuer[0] != NULL;
	m_fCheckSubject = pargzpszSubject[0] != NULL;

	delete pargzpsz;
	delete pargzpszIssuer;
	delete pargzpszSubject;
} // CSimCertificateDlg::PopulateListview()


/////////////////////////////////////////////////////////////////////
//	Routine to add multiple listview items to make a fake tree.
//
bool CSimCertificateDlg::AddListviewItems(
	UINT uStringId,		// Issuer, Subject, AltSubject
	LPCTSTR rgzpsz[])	// Array of pointer to strings
{
	ASSERT(rgzpsz != NULL);
	
	if (rgzpsz[0] == NULL)
		return false;	// Empty array

	CString str;
	VERIFY( str.LoadString(uStringId) );

	CString strUI;
	strSimToUi(IN rgzpsz[0], OUT &strUI);

	LPCTSTR rgzpszT[] = { str, strUI, NULL };
	ListView_AddStrings(m_hwndListview, rgzpszT, (LPARAM)uStringId);

	rgzpszT[0] = _T(" ");
	for (int i = 1; rgzpsz[i] != NULL; i++)
	{
		strSimToUi(IN rgzpsz[i], OUT &strUI);
		rgzpszT[1] = strUI;
		ListView_AddStrings(m_hwndListview, rgzpszT);
	}

	return true;
} // CSimCertificateDlg::AddListviewItems()



/////////////////////////////////////////////////////////////////////
void
CSimCertificateDlg::OnOK()
{
	LPTSTR * pargzpsz;	// Pointer to allocated array of pointer to strings
	LPCTSTR * pargzpszIssuer;
	LPCTSTR * pargzpszSubject;

	pargzpsz = SplitX509String(
		IN m_strData,
		OUT &pargzpszIssuer,
		OUT &pargzpszSubject,
		0);
	if (pargzpsz == NULL)
		return;

	LPCTSTR * prgzpszIssuerT = m_fCheckIssuer ? pargzpszIssuer : NULL;

	LPCTSTR * prgzpszSubjectT = 0;
	if ( m_fCheckSubject )
	{
		prgzpszSubjectT = pargzpszSubject;
	}
	else
	{
		if ( m_fCheckSubjectChanged )
		{
			CString	text;
			CString	caption;

			VERIFY (caption.LoadString (IDS_DSSNAPINNAME));
			VERIFY (text.LoadString (IDS_SIM_REMOVING_SUBJECT_AS_ID));

			if ( IDNO == MessageBox (text, caption, MB_ICONWARNING | MB_YESNO) )
      {
        if (pargzpsz != NULL)
        {
      	  delete pargzpsz;
          pargzpsz = NULL;
        }

        if (pargzpszIssuer != NULL)
        {
	        delete pargzpszIssuer;
          pargzpszIssuer = NULL;
        }

        if (pargzpszSubject != NULL)
        {
	        delete pargzpszSubject;
          pargzpszSubject = NULL;
        }

				return;
      }
		}
		prgzpszSubjectT = NULL;
	}

	CString strDataT;		// Temporary string to hold the value
	int cSeparators;		// Number of separators added to the contatenated string
	cSeparators = UnsplitX509String(
		OUT &strDataT,
		IN prgzpszIssuerT,
		IN prgzpszSubjectT,
		0);

  if (pargzpsz != NULL)
  {
	  delete pargzpsz;
    pargzpsz = NULL;
  }

  if (pargzpszIssuer != NULL)
  {
	  delete pargzpszIssuer;
    pargzpszIssuer = NULL;
  }

  if (pargzpszSubject != NULL)
  {
	  delete pargzpszSubject;
    pargzpszSubject = NULL;
  }

	if (cSeparators == 0)
	{
		// The resulting does not contains anything useful
                ReportErrorEx (GetSafeHwnd(),IDS_SIM_ERR_INVALID_MAPPING,S_OK,
                               MB_OK | MB_ICONERROR, NULL, 0);
		return;
	}
	// The string seems valid, so keep it
	m_strData = strDataT;
	CDialog::OnOK();
} // CSimCertificateDlg::OnOK()


/////////////////////////////////////////////////////////////////////
void CSimCertificateDlg::UpdateUI()
{
	CheckDlgButton(IDC_CHECK_SUBJECT, m_fCheckSubject);
}

/////////////////////////////////////////////////////////////////////
void CSimCertificateDlg::RefreshUI()
{
	ListView_DeleteAllItems(m_hwndListview);
	PopulateListview();
	UpdateData(FALSE);
	UpdateUI();
}


void CSimCertificateDlg::OnCheckIssuer() 
{
	m_fCheckIssuer = IsDlgButtonChecked(IDC_CHECK_ISSUER);
	UpdateUI();
}

void CSimCertificateDlg::OnCheckSubject() 
{
	m_fCheckSubject = IsDlgButtonChecked(IDC_CHECK_SUBJECT);
	m_fCheckSubjectChanged = true;
	UpdateUI();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dssnap.rc
//
#define IDC_CHANGE_PASSWORD             0
#define IDC_MAP_CERTIFICATES            1
#define IDC_MOVE_OBJECT                 2
#define IDC_ENABLE_ACCOUNT              3
#define IDS_COLUMN_NAME                 3
#define ID_BUTTON_MORE_INFO             3
#define IDC_DISABLE_ACCOUNT             4
#define IDS_COLUMN_TYPE                 4
#define IDC_DELETE_OBJECT               5
#define IDS_COLUMN_DESCRIPTION          5
#define IDC_REPLICATE_NOW               6
#define IDS_PROVIDER                    6
#define IDC_ADD_OBJECTS_TO_GROUP        7
#define IDS_1_CANT_RESET_DOMAIN_CONTROLLER 7
#define IDC_COPY_OBJECT                 8
#define IDS_UPN_DUP                     8
#define IDS_ADD_TO_GROUP                9
#define IDC_RENAME_OBJECT               9
#define IDS_CANT_CREATE_NT5_PRINTERS    10
#define IDS_GROUP_BUILTIN_LOCAL         11
#define IDS_GROUP_RESOURCE              12
#define IDS_GROUP_DOMAIN_LOCAL          12
#define IDS_GROUP_ACCOUNT               13
#define IDS_GROUP_GLOBAL                13
#define IDS_GROUP_UNIVERSAL             14
#define IDS_INVALID_ROW                 15
#define IDS_1_CONTAINER_ADD_SUBTR       16
#define IDS_1_CONTAINER_ADD_SUBTREE     16
#define IDS_NO_DCS_FOUND                17
#define IDS_GROUP_SECURITY              18
#define IDS_GROUP_DISTRIBUTION          19
#define IDS_PASSWORDS_DONT_MATCH        20
#define IDS_NAME_CHANGE_FAILED          21
#define IDS_ADDTOGROUP_OPERATION_FAILED 22
#define IDS_UPN_SEARCH_FAILED           23
#define IDS_SHEETS_UP_RENAME            24
#define IDS_CANT_DELETE_BAD_NEW_OBJECT  25
#define IDS_1_FIND_ERROR                26
#define IDS_DISABLES_FAILED             27
#define IDS_ENABLES_FAILED              28
#define IDS_NYI                         29
#define IDS_DELETE                      30
#define IDS_CREATE_NEW                  31
#define IDS_RESET_ACCOUNT               32
#define IDS_1_CANT_CREATE_FIND          33
#define IDS_MOVE_TITLE                  34
#define IDS_DSSNAPINNAME                35
#define IDM_DS_OBJECT_FIND              36
#define IDS_SITESNAPINNAME              37
#define IDS_CONFIRM_DELETE              38
#define IDS_UNKNOWN                     39
#define IDS_SHEETS_UP_DELETE            40
#define IDS_NAME_TOO_LONG               41
#define IDS_HELPLESS                    42
#define IDS_PASSWORD_MUTEX              43
#define IDS_SNAPIN_PROVIDER             44
#define IDS_DS_MANAGER                  45
#define IDS_SITE_MANAGER                46
#define IDM_VIEW_COMPUTER_HACK          47
#define IDM_VIEW_ADVANCED               48
#define IDM_VIEW_FILTER_OPTIONS         49
#define IDS_ENABLED_SUCCESSFULLY        50
#define IDS_VIEW_FILTER_NO_CUSTOM       51
#define IDS_DS_MANAGER_EX               52
#define IDS_ERRMSG_TITLE                53
#define IDS_DSSNAPINNAMEEX              54
#define IDS_OBJECTS                     54
#define IDS_ANY_DOMAIN_CONTROLLER       55
#define IDS_DSCTXNAME                   56
#define IDS_CHANGE_PASSWORD             57
#define IDS_ENABLE_ACCOUNT              58
#define IDS_MAP_CERTIFICATES            59
#define IDS_DISABLE_ACCOUNT             60
#define IDS_MOVE_OBJECT                 61
#define IDS_COPY_OBJECT                 62
#define IDS_CONFIRM_MULTI_DELETE        63
#define IDS_FILTERING_ON                64
#define IDS_ERR_BOTH_PW_BTNS            65
#define IDS_REPLICATE_NOW               66
#define IDS_CONFIRM_RENAME              67
#define IDS_ERR_UNABLE_TO_WRITE_ALL_DATA 68
#define IDS_EXTENS_RENAME               68
#define IDS_STRING                      69
#define IDS_EXTENS_SINGLE_DEL           70
#define IDS_EXTENS_MULTIPLE_DEL         71
#define IDS_CONFIRM_MOVE                72
#define IDS_ERR_FATAL                   73
#define IDS_DISABLED_SUCCESSFULLY       74
#define IDS_EXTENS_SINGLE_MOVE          75
#define IDS_CONFIRM_MULTIPLE_MOVE       76
#define IDS_EXTENS_MULTIPLE_MOVE        77
#define IDS_12_RESET_ACCOUNT_FAILED     78
#define IDS_1_RESET_ACCOUNT_SUCCESSFULL 79
#define IDS_NULL_PASSWORD               80
#define IDS_12_INVALID_COMPUTER_NAME    81
#define IDS_12_NON_RFC_COMPUTER_NAME    82
#define IDS_12_COMPUTER_NAME_DOTTED     83
#define IDS_12_DISABLE_COMPUTER_P       84
#define IDS_MULTI_DISABLE_COMPUTER      85
#define IDS_FORMAT_USER_NAME            86
#define IDS_ENABLE_ACCOUNT_HELPSTRING   87
#define IDS_DISABLE_ACCOUNT_HELPSTRING  88
#define IDS_MAP_CERTS_HELPSTRING        89
#define IDS_CHANGE_PWD_HELPSTRING       90
#define IDS_MOVE_OBJECT_HELPSTRING      91
#define IDS_DELETE_OBJECT_HELPSTRING    92
#define IDS_REPLICATE_HELPSTRING        93
#define IDS_ADD_OBJECTS_HELPSTRING      94
#define IDS_OBJECT_PICKER_INIT_FAILED   95
#define IDS_12_RENAME_NOT_ALLOWED       96
#define IDS_NEW_COMPUTER_PRINCIPAL_DEFAULT 97
#define IDS_COPY_HELPSTRING             98
#define IDS_RENAME_HELPSTRING           99
#define IDS_VIEW_FILTER_USERGROUP       100
#define IDS_VIEW_FILTER_USERS           100
#define IDS_VIEW_FILTER_GROUPS          101
#define IDS_VIEW_FILTER_CONTACTS        102
#define IDD_RENAME_GENERIC              102
#define IDS_VIEW_FILTER_PRINTERVOL      103
#define IDS_VIEW_FILTER_PRINTERS        103
#define IDS_VIEW_FILTER_SHARED_FOLDERS  104
#define IDS_VIEW_FILTER_COMPUTERS       105
#define IDD_MULTIPLE_ERROR              106
#define IDS_VIEW_FILTER_SERVICES        106
#define IDD_CREATE_NEW_OBJECT_GENERIC_WIZARD 107
#define IDS_VIEW_FILTER_SITES           107
#define IDD_CREATE_NEW_PRINTQ           108
#define IDS_VIEW_FILTER_INTERSITE       108
#define IDD_CREATE_NEW_GROUP            109
#define IDS_VIEW_FILTER_FRS             109
#define IDS_SHEETS_UP_COLUMNS_CHANGED   110
#define IDM_VIEW_SERVICES_NODE          111
#define IDS_RENAME                      112
#define IDS_ERRMSG_DEFAULT_TEXT         113
#define IDS_ERRMSG_FALLBACK_TEXT        114
#define IDS_1_NON_RFC_SITE_NAME         115
#define IDS_12_INVALID_SAM_COMPUTER_NAME 116
#define IDS_12_SAM_COMPUTER_NAME_DOTTED 117
#define IDS_12_SAM_COMPUTER_NAME_NOT_VALIDATED 118
#define IDS_12_NON_RFC_SAM_COMPUTER_NAME 119
#define IDS_12_DELETE_ACCESS_DENIED     120
#define IDS_SAMNAME_DUP                 121
#define IDS_SAMNAME_ILLEGAL             122
#define IDS_LOGINNAME_ILLEGAL           123
#define IDS_12_DELETE_PRIMARY_GROUP_FAILED 124
#define IDS_WARNING_TDO_DELTEE          125
#define IDS_1_ERROR_DELETE_CRITOBJ      126
#define IDS_GROUP_SAMNAME_ILLEGAL       127
#define IDS_ERRMSG_UNKNOWN_HR           128
#define IDD_PROGRESS                    130
#define IDD_MULTISELECT_ERROR_DIALOG    145
#define IDM_GEN_TASK_RAISE_VERSION      146
#define IDI_DSADMIN                     203
#define IDC_EDIT_CURRENT_DC             203
#define IDI_ICON_ATTRIBUTE              204
#define IDI_SITEREPL                    205
#define IDC_EDIT_CURRENT_FSMO_DC        207
#define IDC_CHANGE_FSMO                 208
#define IDC_STATIC_FSMO_STATUS          210
#define IDC_EDIT_OBJECT_NAME            211
#define IDC_EDIT_DISPLAY_NAME           212
#define IDC_EDIT_SAM_NAME               212
#define IDC_USER_NAME                   213
#define IDC_EDIT_UNC_PATH               213
#define IDD_CHANGE_PASSWORD             215
#define IDC_NEW_PASSWORD                220
#define IDD_QUERY_FILTER                220
#define IDC_CONFIRM_PASSWORD            222
#define IDS_12_PASSWORD_DOES_NOT_EXPIRE 222
#define IDS_12_PASSWORD_CHANGE_SUCCESSFUL 223
#define IDD_CREATE_NEW_OBJECT_CN        224
#define IDS_12_PASSWORD_CHANGE_FAILED   224
#define IDS_12_USER_OBJECT_NOT_ACCESSABLE 225
#define IDD_CREATE_NEW_OBJECT_CN_UNC    225
#define IDD_CREATE_NEW_VOLUME           225
#define IDS_NEW_AND_CONFIRM_NOT_SAME    226
#define IDC_NEW_OBJECT_NAME             226
#define IDD_CREATE_NEW_COMPUTER         226
#define IDD_CREATE_NEW_USER             227
#define IDD_SELECT_DC                   228
#define IDS_12_USER_DISABLED_SUCCESSFULLY 228
#define IDS_12_USER_DISABLE_FAILED      229
#define IDS_12_USER_ENABLED_SUCCESSFULLY 231
#define IDS_12_USER_ENABLE_FAILED       232
#define IDS_CREATEOBJ                   233
#define IDC_GROUP                       233
#define IDC_RADIO_WORKSTATION           235
#define IDI_ICON_WAIT                   235
#define IDI_ICON_WARN                   236
#define IDC_RADIO_DOMAIN_CONTROLLER     236
#define IDC_STATIC_ATTRIBUTE_NAME       236
#define IDC_SHOW_ALL_RADIO              236
#define IDD_CREATE_NEW_FINISH           236
#define IDM_GEN_TASK_MOVE               237
#define IDC_STATIC_ATTRIBUTE_DESCRIPTION 237
#define IDC_SHOW_BUILTIN_RADIO          237
#define IDB_DSADMIN                     237
#define IDI_DSADMIN_ERR                 237
#define IDC_STATIC_ATTRIBUTE_TYPE       238
#define IDC_SHOW_CUSTOM_RADIO           238
#define IDB_DSADMIN_LG                  238
#define IDS_12_ACCESS_DENIED_SET_PASSWORD 238
#define IDB_SITEREPL                    239
#define IDC_COMBO_ATTRIBUTE_VALUE       239
#define IDB_SITEREPL_LG                 240
#define IDD_PASSWORD                    240
#define IDS_12_CONTAINER_NOT_FOUND      241
#define IDC_EDIT_NETWORK_ADDRESS        241
#define IDC_EDIT_DNS_NAME               241
#define IDS_1_CANT_GET_SCHEMA_CREATE_INFO 242
#define IDB_BUTTONS                     242
#define IDC_EDIT_PASSWORD               243
#define IDS_12_NAMING_ATTRIBUTE_NOT_AVAILABLE 243
#define IDD_SELECT_DOMAIN               243
#define IDC_EDIT_PASSWORD_CONFIRM       244
#define IDS_12_CANT_GET_GUID            244
#define IDD_FSMO_PAGE                   244
#define IDS_CANT_GET_ROOTDSE            245
#define IDD_CONFIRM_OPERATION_EXT       245
#define IDI_CONFIRM                     245
#define IDI_SITEREPL_ERR                246
#define IDS_12_COPY_READ_FAILED         246
#define IDS_12_CANT_SET_PASSWORD        247
#define IDC_FIRST_NAME_EDIT             248
#define IDC_EDIT_FIRST_NAME             248
#define IDS_12_CANT_SET_COMP_PWD        248
#define IDI_INFO                        248
#define IDS_MOVE_TARGET                 249
#define IDC_LAST_NAME_EDIT              249
#define IDC_EDIT_LAST_NAME              249
#define IDI_FAVORITES                   249
#define IDS_SUBNET_NAME                 250
#define IDC_EDIT_FULL_NAME              250
#define IDC_DISP_NAME_EDIT              250
#define IDS_COLUMN_SITE                 251
#define IDC_PASSWORD                    251
#define IDC_EDIT_ATTRIBUTE_VALUE        251
#define IDC_EDIT_DISP_NAME              251
#define IDI_QUERY                       251
#define IDS_DISPLAYTEXT_NONE            252
#define IDD_CREATE_NEW_QUERY            252
#define IDC_BUILTIN_QUERY_CHECK_LIST    253
#define IDM_GEN_TASK_SELECT_DC          253
#define IDC_LINKS                       253
#define IDC_CHECK_ACCOUNT_DISABLED      254
#define IDS_1_SCHEMA_NOT_FOUND          254
#define IDD_QUERY_STD_PAGE              254
#define IDC_CHECK_PASSWORD_CANNOT_CHANGE 255
#define IDS_12_CANT_GET_USERACCOUNTCONTROL 255
#define IDS_12_CANT_SET_PWD_MUST_CHANGE 256
#define IDD_QUERY_COMPUTER_PAGE         256
#define IDC_NT5_DOMAIN_COMBO            257
#define IDS_12_CANT_SET_PWD_CANNOT_CHANGE 257
#define IDI_QUERY_INVALID               257
#define IDC_CHECK_PASSWORD_NEVER_EXPIRES 258
#define IDC_STATIC_MESSAGE              258
#define IDS_12_CANT_SET_PASSWORD_AD     258
#define IDC_BUTTON_ADD                  259
#define IDC_EDIT_CUSTOM_BUTTON          259
#define IDC_BUTTON_YES                  259
#define IDC_CHANGE_PRINCIPAL_BUTTON     259
#define IDS_12_CANT_SET_GROUP_MEMBERSHIP 259
#define IDC_BUTTON_REMOVE               260
#define IDC_BUTTON_NO                   260
#define IDC_PRINCIPAL_EDIT              260
#define IDS_123_CANT_COPY_SOME_GROUP_MEMBERSHIP 260
#define IDC_CHECK_PASSWORD_MUST_CHANGE  261
#define IDC_BUTTON_YESTOALL             261
#define IDC_MAX_ITEM_COUNT_EDIT         261
#define IDS_123_CANT_COPY_SOME_GROUP_MEMBERSHIP_ACCESS_DENIED 261
#define IDC_EDIT_CONTAINER              262
#define IDS_123_CANT_COPY_PRIMARY_GROUP_NOT_FOUND 262
#define IDC_STATIC_ICON                 263
#define IDC_NAME                        264
#define IDS_12_OBJECT_RENAME_FAILED     272
#define IDC_PROG_STATIC                 273
#define IDS_TRUE                        280
#define IDS_FALSE                       281
#define IDS_SITE_NAME                   282
#define IDC_RADIO_SEC_GROUP             283
#define IDC_RADIO_RESOURCE              284
#define IDC_RADIO_ACCOUNT               285
#define IDC_RADIO_UNIVERSAL             286
#define IDC_RADIO_DISTRIBUTION_GROUP    288
#define IDD_RENAME_USER                 289
#define IDD_RENAME_GROUP                291
#define IDD_RENAME_CONTACT              292
#define IDS_COLUMN_READABLE_NAME        292
#define IDS_COLUMN_FROM_SERVER          293
#define IDS_COLUMN_FROM_SITE            294
#define IDS_CONNECTION_KCC_GENERATED    295
#define IDS_COLUMN_FROM_DOMAIN          296
#define IDS_COLUMN_FROM_COMPUTER        297
#define IDS_COLUMN_COMPUTER             298
#define IDS_CONFIRM_PASSWORD            299
#define IDC_SELECTDC_DOMAIN             300
#define IDC_SELECTDC_BROWSE             301
#define IDC_SELECTDC_DCEDIT             302
#define IDC_SELECTDC_DCLISTVIEW         303
#define IDC_SELECTDC_DCLISTVIEW_TITLE   304
#define IDC_SELECTDC_DCEDIT_TITLE       305
#define IDC_SELECTDOMAIN_LABEL          306
#define IDC_SELECTDOMAIN_DOMAIN         307
#define IDC_SELECTDOMAIN_BROWSE         308
#define IDC_STATIC_FSMO_DESC            308
#define IDS_COLUMN_COST                 309
#define IDS_COLUMN_REPLINTERVAL         310
#define IDC_EXTENS_LIST                 311
#define IDC_STATIC_OPERATION            312
#define IDC_STATIC_ASSOC_DATA           313
#define IDC_NT4_CHECK                   314
#define IDC_SAVE_CURRENT_CHECK          315
#define IDC_EDIT_INITIALS               316
#define IDC_DESCRIPTION_EDIT            317
#define IDC_ROOT_EDIT                   318
#define IDC_MULTI_LEVEL_CHECK           319
#define IDC_QUERY_FILTER_EDIT           320
#define IDC_EDIT_BUTTON                 321
#define IDC_BROWSE_BUTTON               322
#define IDC_NAME_COMBO                  323
#define IDC_DESCRIPTION_COMBO           324
#define IDC_GROUP_EDIT                  326
#define IDC_DISABLED_ACCOUNTS_CHECK     327
#define IDC_NON_EXPIRING_PWD_CHECK      328
#define IDC_ADVANCED_COMBO              329
#define IDC_ADVANCED_EDIT               330
#define IDC_QUERY_STRING_EDIT           331
#define IDC_LASTLOGON_COMBO             332
#define IDC_CN                          333
#define IDC_DS_ICON                     334
#define IDD_CREATE_NEW_USER1            401
#define IDD_CREATE_NEW_USER2            402
#define IDD_CREATE_NEW_CONTACT          411
#define IDD_CREATE_NEW_SITE_LINK        420
#define IDD_CREATE_NEW_SITE_LINK_BRIDGE 421
#define IDD_CREATE_NEW_SITE             422
#define IDD_CREATE_NEW_SUBNET           423
#define IDD_MOVE_SERVER                 424
#define IDD_FSMO_CONFIRM_FORCED         425
#define IDD_MSGBOX_OKCANCEL_MOREINFO    425
#define IDD_MSGBOX_OK_MOREINFO          426
#define IDD_QUERY_USER_PAGE             427
#define IDD_FAVORITES_PROPERTY_PAGE     428
#define IDC_DUELLING_LB_OUT             432
#define IDC_DUELLING_RB_ADD             433
#define IDC_DUELLING_RB_REMOVE          434
#define IDC_DUELLING_LB_IN              435
#define IDC_SUBNET_ADDRESS              440
#define IDC_SUBNET_MASK                 441
#define IDS_s_CREATE_NEW                500
#define IDS_sdd_CREATE_NEW_STEP         501
#define IDS_s_CREATE_NEW_SUMMARY_NAME   502
#define IDS_s_CREATE_NEW_SUMMARY_USER_UPN 503
#define IDS_s_COPY                      504
#define IDS_s_COPY_SUMMARY_NAME         505
#define IDS_COPY_OF                     506
#define IDS_MULTIPLE_COPY_OF            507
#define IDM_WHATS_THIS                  510
#define IDR_WHATS_THIS_CONTEXT_MENU1    511
#define IDS_12_GENERIC_CREATION_FAILURE 601
#define IDS_ERR_CANNOT_FIND_MANDATORY_ATTRIBUTES 602
#define IDS_12_UNABLE_TO_WRITE_ACCT_CTRL 603
#define IDS_ERR_INVALID_DIGIT           604
#define IDS_2_INVALID_ABSOLUTE_PATH     605
#define IDS_ERR_s_FAILED_TO_MOVE_OBJECT 606
#define IDS_ERR_s_FAILED_TO_RENAME_OBJECT 607
#define IDS_ERR_s_FAILED_TO_DELETE_OBJECT 608
#define IDS_12_MULTI_OBJECT_HAS_CHILDREN 609
#define IDS_123_COMPUTER_OBJECT_ALREADY_USED 611
#define IDS_1234_SERVER_REFERENCE_ERROR 612
#define IDS_SKIP_SERVER_REFERENCE       613
#define IDS_12_SERVER_REFERENCE_FAILED  614
#define IDS_12_MULTI_DELETE_FAILED      615
#define IDS_12_DELETE_FAILED            616
#define IDS_12_FAILED_TO_MOVE_OBJECT    617
#define IDS_12_MULTI_FAILED_TO_MOVE_OBJECT 618
#define IDS_SITELINK_NOT_ENOUGH_SITES   619
#define IDS_12_OBJECT_HAS_CHILDREN      620
#define IDS_12_SUBTREE_DELETE_FAILED    621
#define IDS_SITELINKBRIDGE_NOT_ENOUGH_SITELINKS 622
#define IDS_NEWSITE_WARNING             623
#define IDS_WARNING_TITLE               624
#define IDS_1_CANT_GET_DATA             625
#define IDS_12_CANT_GET_DATA            625
#define IDS_SNAPIN_VERSION              626
#define IDS_SNAPINABOUT_DESCRIPTION     627
#define IDS_SITES_SNAPINABOUT_DESCRIPTION 628
#define IDS_REPLNOW_TITLE               629
#define IDS_REPLNOW_SUCCEEDED_IMMEDIATE 630
#define IDS_REPLNOW_SUCCEEDED_DELAYED   631
#define IDS_REPLNOW_1_PARAMLOAD_ERROR   632
#define IDS_REPLNOW_3_FORCESYNC_ERROR   633
#define IDS_MSG_QUERY_TOO_MANY_ITEMS    634
#define IDS_12_FAILED_TO_CREATE_PRINTER 635
#define IDS_12_FAILED_TO_ACCESS_PRINTER 636
#define IDS_12_UNABLE_TO_WRITE_ACL      637
#define IDS_12_CANT_GET_SAM_ACCNT_NAME  638
#define IDS_12_MULTI_MEMBER_ADD_FAILED  639
#define IDS_12_MEMBER_ADD_FAILED        640
#define IDS_ADDTOGROUP_OPERATION_COMPLETED 641
#define IDS_ADDTOGROUP_OPERATION_PARTIALLY_COMPLETED 642
#define IDS_SITELINKBRIDGE_NEEDS_TWO_SITELINKS 643
#define IDS_SITELINK_NEEDS_TWO_SITES    644
#define IDS_12_UNABLE_TO_WRITE_COMP_ACL 645
#define IDS_MSG_QUERY_TOO_MANY_ITEMS_WITH_APPROX 646
#define IDS_DESCBAR_TOO_MUCH_DATA       647
#define IDS_DESCBAR_INVALID_SAVEDQUERY  648
#define IDS_RUN_KCC_TITLE               650
#define IDS_RUN_KCC_1_SUCCEEDED_LOCAL   651
#define IDS_RUN_KCC_1_PARAMLOAD_ERROR   652
#define IDS_RUN_KCC_1_FORCESYNC_ERROR   653
#define IDS_HOME_DIR_EXISTS             654
#define IDS_HOME_DIR_CREATE_FAILED      655
#define IDS_HOME_DIR_CREATE_NO_ACCESS   656
#define IDS_HOME_DIR_CREATE_FAIL        657
#define IDS_CANT_READ_HOME_DIR_SID      658
#define IDS_RUN_KCC_2_SUCCEEDED_REMOTE  659
#define IDC_EDIT1                       707
#define IDC_NT5_USER_EDIT               707
#define IDC_EDIT_SUMMARY                707
#define IDC_NAME_EDIT                   707
#define IDC_NT4_USER_EDIT               708
#define IDC_NT4_DOMAIN_EDIT             710
#define IDS_NEW_SITE_NAME_COLUMN_WIDTH  711
#define IDS_NEW_SITE_NAME_COLUMN        712
#define IDS_NEW_SITE_XPORT_COLUMN_WIDTH 713
#define IDS_NEW_SITE_XPORT_COLUMN       714
#define IDC_SITE_TEXT                   715
#define IDS_CANT_FIND_SITE_LINKS        716
#define IDS_ERROR_TWEAKING_SITE_LINK    717
#define IDS_CREATE_NEW_OBJECT_TITLE     718
#define IDS_s_CREATE_NEW_OBJECT_NOTICE  719
#define IDS_PASSWORD_DLG_WARNING        733
#define IDS_WARNING_NO_SITE_LINKS       734
#define IDS_SITELINKERROR_READING_SITES 735
#define IDS_SITELINK_DLGTEXT_ONE_SITE   736
#define IDS_SITELINKBRIDGEERROR_READING_SITELINKS 737
#define IDS_NEWSUBNET_WARNING_NO_SITES  738
#define IDS_NEWSUBNET_CANT_FIND_SITES   739
#define IDS_BUTTON_NEW_GROUP            740
#define IDS_BUTTON_NEW_USER             741
#define IDS_TOOLTIP_NEW_USER            742
#define IDS_TOOLTIP_NEW_GROUP           743
#define IDS_BUTTON_NEW_OU               744
#define IDS_TOOLTIP_NEW_OU              745
#define IDS_BUTTON_FILTER               746
#define IDS_TOOLTIP_FILTER              747
#define IDS_BUTTON_FIND                 748
#define IDS_TOOLTIP_FIND                749
#define IDS_BUTTON_ADD_MEMBER           750
#define IDS_TOOLTIP_ADD_MEMBER          751
#define IDS_NEW_SUBNET                  752
#define IDS_NEW_NTDSCONNECTION          753
#define IDS_NEW_SITELINK                754
#define IDS_NEW_SITELINKBRIDGE          755
#define IDS_NEW_SITE                    756
#define IDS_PROGRESS_DEL                757
#define IDS_PROGRESS_MOV                758
#define IDS_ERROR                       759
#define IDS_WAITING                     760
#define IDS_SELECTDC_DCEDIT_TITLE       761
#define IDS_SELECTDC_DCLISTVIEW_TITLE   762
#define IDS_SELECTDC_DCLISTVIEW_NAME    763
#define IDS_SELECTDC_DCLISTVIEW_SITE    764
#define IDS_SELECTDC_UNMATCHED_DC_DOMAIN 765
#define IDS_SELECTDC_UNMATCHED_DC_DOMAIN_ANY 766
#define IDS_SELECTDC_UNMATCHED_DC_DOMAIN_SITEREPL 767
#define IDS_SELECTDC_UNMATCHED_DC_DOMAIN_SITEREPL_ANY 768
#define IDS_SELECTDC_INCORRECT_DOMAIN_DUETO 769
#define IDS_SELECTDC_DOWNLEVEL_DOMAIN   770
#define IDS_SELECTDC_INCORRECT_DC_DUETO 771
#define IDS_SELECTDC_DOWNLEVEL_DC       772
#define IDM_GEN_TASK_SELECT_DOMAIN      773
#define IDM_GEN_TASK_SELECT_FOREST      774
#define IDS_SELECTDOMAIN_TITLE_FOREST   775
#define IDS_SELECTDOMAIN_DOMAIN_LABEL   776
#define IDS_SELECTDOMAIN_INCORRECT_DOMAIN_DUETO 777
#define IDS_SELECTDOMAIN_DOWNLEVEL_DOMAIN 778
#define IDS_INCORRECT_INPUT             779
#define IDM_GEN_TASK_EDIT_FSMO          780
#define IDS_COLUMN_SITE_NAME            781
#define IDS_NEW_SUBNET_SELECT_SITE      782
#define IDS_NEW_SITE_SELECT_SITELINK    783
#define IDM_GEN_TASK_RUN_KCC            784
#define IDS_MOVESERVER_ERROR_NO_SITES   785
#define IDS_MOVESERVER_ERROR_ENUMERATING_SITES 786
#define IDS_MOVESERVER_SELECT_SITE      787
#define IDS_WIZARD_OK                   788
#define IDS_COLUMN_SITE_WIDTH           792
#define IDS_CHANGE_FSMO_CHECKPOINT_FAILED 799
#define IDS_RID_POOL_FSMO               801
#define IDS_RID_POOL_FSMO_DESC          802
#define IDS_PDC_FSMO                    803
#define IDS_PDC_FSMO_DESC               804
#define IDS_IMD_FSMO                    805
#define IDS_INFRASTRUCTURE_FSMO         805
#define IDS_IMD_FSMO_DESC               806
#define IDS_INFRASTRUCTURE_FSMO_DESC    806
#define IDS_WARNING_FSMO_CHANGE_FOCUS   807
#define IDS_CHANGE_FSMO_CONFIRMATION    808
#define IDS_ERROR_CHANGE_FSMO_OWNER     809
#define IDS_CHANGE_FSMO_CONFIRMATION_FORCED 810
#define IDS_CHANGE_FSMO_SUCCESS         811
#define IDS_FSMO_SERVER_ERROR           812
#define IDS_FSMO_SHEET_TITLE            813
#define IDS_RETARGET_DOMAIN_FAILED      814
#define IDS_RETARGET_FOREST_FAILED      815
#define IDS_RETARGET_DC_FAILED          816
#define IDS_CANT_BROWSE_DOMAIN          817
#define IDS_USER_CREATE_DLG_PASSWORD_MUST_CHANGE 818
#define IDS_USER_CREATE_DLG_PASSWORD_CANNOT_CHANGE 819
#define IDS_USER_CREATE_DLG_PASSWORD_NEVER_EXPIRES 820
#define IDS_USER_CREATE_DLG_ACCOUNT_DISABLED 821
#define IDS_LOCAL_LOGIN_ERROR           822
#define IDS_ERROR_USER_EXISTS           823
#define IDS_ERROR_USER_DS_OBJ_STRING_NAME_EXISTS 824
#define IDS_NEW_SITE_INFO               825
#define IDS_COLUMN_DOMAIN               826
#define IDS_COMPUTER_CREATE_DLG_NT4_ACCOUNT 827
#define IDS_12_USER_LOGGED_IN           828
#define IDS_ERROR_COMPUTER_EXISTS       829
#define IDS_ERROR_COMPUTER_DS_OBJ_STRING_NAME_EXISTS 830
#define IDS_UPN_SEARCH_FAILED2          831
#define IDS_COLUMN_LOCATION             832
#define IDS_COLUMN_BRIDGEHEAD           833
#define IDS_SEPARATOR                   834
#define IDS_12_CONTAINS_DC              835
#define IDS_CHANGE_FSMO_CHECKPOINT_FAILED_NATIVEMODE 836
#define IDS_UPN_SEARCH_FAILED3          837
#define IDD_DELETE_DC_COMPUTER          850
#define IDC_DELETE_DC_MAINTEXT          851
#define IDS_DELETE_DC_COMPUTERACCOUNT   851
#define IDC_DELETE_DC_BADREASON1        852
#define IDS_DELETE_DC_BADREASON1        852
#define IDC_DELETE_DC_BADREASON2        853
#define IDS_DELETE_DC_BADREASON2        853
#define IDC_DELETE_DC_GOODREASON        854
#define IDS_QUERY_TITLE_SAVEDQUERYFORM  900
#define IDS_QUERY_TITLE_USERPAGE        901
#define IDS_QUERY_TITLE_GROUP_PAGE      902
#define IDS_QUERY_TITLE_COMPUTER_PAGE   903
#define IDS_NOT_VALID_LDAP_STRING       910
#define IDS_QUERY_COL_NAME              950
#define IDS_QUERY_COL_DESC              951
#define IDC_PROG_BAR                    1000
#define IDC_ERROR_LIST                  1249
#define IDS_COLUMN_SAM_ACCOUNT_NAME     4000
#define IDS_COLUMN_DISPLAY_NAME         4001
#define IDS_COLUMN_FIRST_NAME           4002
#define IDS_COLUMN_LAST_NAME            4003
#define IDS_COLUMN_UPN                  4004
#define IDS_COLUMN_MAIL                 4005
#define IDS_COLUMN_ALIAS_NAME           4006
#define IDS_COLUMN_BUSINESS_PHONE       4007
#define IDS_COLUMN_OFFICE               4008
#define IDS_COLUMN_TITLE                4009
#define IDS_COLUMN_DEPARTMENT           4010
#define IDS_COLUMN_MODIFIED             4011
#define IDS_COLUMN_TARGET_ADDRESS       4012
#define IDS_COLUMN_HOME_MDB             4013
#define IDS_COLUMN_TEXTENCODEORADDRESS  4014
#define IDS_COLUMN_COMPANY              4015
#define IDS_COLUMN_CITY                 4016
#define IDS_COLUMN_STATE                4017
#define IDS_COLUMN_COUNTRY              4018
#define IDS_COLUMN_ZIP_CODE             4019
#define IDS_IFSMO_TARGET_DC_IS_GC       4021
#define IDS_COLUMN_IMURL                4022
#define IDS_COLUMN_IMHOMEURL            4023
#define IDS_ADDTOGROUP_NOUSER           4050
#define IDS_CONNECTION_RENAME_WARNING   4051
#define IDS_CONNECTION_RENAME_ERROR     4052
#define IDS_CONNECTION_TO_SELF          4053
#define IDS_DUPLICATE_CONNECTION        4054
#define IDS_CONNECTION_RENAME_KCCSTRING 4055
#define MENU_MERGE_BASE                 5000
#define MENU_MERGE_LIMIT                6000
#define IDM_NEW_QUERY_FOLDER            8000
#define IDM_NEW_FAVORITES_FOLDER        8001
#define IDM_COPY_QUERY                  8002
#define IDM_EDIT_QUERY                  8003
#define IDM_EXPORT_QUERY                8004
#define IDS_QUERY_EXPORT_FILTER         8005
#define IDM_IMPORT_QUERY                8006
#define IDM_RUN_QUERY                   8007
#define IDS_ERRMSG_QUERY_ROOT_NOT_VALID 8007
#define IDS_ERRMSG_QUERY_FILTER_NOT_VALID 8008
#define IDS_ERRMSG_QUERY_FAILED         8009
#define IDS_SAVED_QUERIES               8010
#define IDS_SAVED_QUERIES_DESC          8011
#define IDS_NEW_FOLDER                  8050
#define IDS_CONFIRM_DELETE_FAVORITES    8051
#define IDS_CONFIRM_DELETE_QUERY        8052
#define IDS_CONFIRM_MULTI_DELETE_FAVORITES 8053
#define IDS_QUERY_BROWSE_CAPTION        8099
#define IDS_QUERY_BROWSE_TITLE          8100
#define IDS_ERRMSG_NO_DSQUERYUI         8101
#define IDS_ERRMSG_NO_PERSIST_QUERYUI   8102
#define IDS_ERRMSG_NOT_UNIQUE_QUERY_NAME 8103
#define IDS_SAVED_QUERIES_EDIT_TITLE    8104
#define IDS_ERRMSG_NOT_UNIQUE_QUERY_NAME_INPLACE 8105
#define IDS_ERRMSG_NO_EMPTY_NAMES       8106
#define IDS_HIDE_LASTLOGON_QUERY        8107
#define IDS_ERRMSG_FAILED_LOAD_QUERY    8108
#define IDS_STARTSWITH                  8200
#define IDS_ENDSWITH                    8201
#define IDS_ISEXACTLY                   8202
#define IDS_ISNOT                       8203
#define IDS_PRESENT                     8204
#define IDS_NOTPRESENT                  8205
#define IDS_FILTER_LAST_LOGON_VERSION   8210
#define IDS_MULTI_ADDTOGROUP_ERROR_CAPTION 8300
#define IDS_MULTI_DELETE_ERROR_CAPTION  8301
#define IDS_MULTI_MOVE_ERROR_CAPTION    8302
#define IDS_ERR_MSG_NO_MOVE_TO_SELF     8320
#define IDS_CONTAINS_CRITICALSYSOBJ     8321
#define IDS_NO_CREATION_WIZARD          8322
#define IDM_NEW_OBJECT_BASE             10000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        258
#define _APS_NEXT_COMMAND_VALUE         32819
#define _APS_NEXT_CONTROL_VALUE         336
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simdata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       simdata.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	SimData.cpp - Implementation of Security Identity Mapping
//
//	HISTORY
//	23-Jun-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "common.h"
#include "dsutil.h"
#include "helpids.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////

TCHAR szSchemaSim[] = _T("altSecurityIdentities");	// per Murlis 6/16/98

/////////////////////////////////////////////////////////////////////
void CSimEntry::SetString(CString& rstrData)
{
	m_strData = rstrData;
	LPCTSTR pszT = (LPCTSTR)rstrData;
	if (_wcsnicmp(szX509, pszT, wcslen (szX509)) == 0)
	{
		m_eDialogTarget = eX509;
	}
	else if (_wcsnicmp(szKerberos, pszT, wcslen (szKerberos)) == 0)
	{
		m_eDialogTarget = eKerberos;
	}
	else
	{
		m_eDialogTarget = eOther;
		TRACE1("INFO: Unknown string type \"%s\".\n", pszT);
	}
} // CSimEntry::SetString()


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
CSimData::CSimData()
: m_hwndParent (0)
{
	m_fIsDirty = FALSE;
	m_pSimEntryList = NULL;
	m_paPage1 = new CSimX509PropPage;
	m_paPage1->m_pData = this;
	m_paPage2 = new CSimKerberosPropPage;
	m_paPage2->m_pData = this;
	#ifdef _DEBUG
	m_paPage3 = new CSimOtherPropPage;
	m_paPage3->m_pData = this;
	#endif
}

CSimData::~CSimData()
	{
	delete m_paPage1;
	delete m_paPage2;
	#ifdef _DEBUG
	delete m_paPage3;
	#endif
	FlushSimList();
	}

/////////////////////////////////////////////////////////////////////
void CSimData::FlushSimList()
	{
	// Delete the list
	CSimEntry * pSimEntry = m_pSimEntryList;
	while (pSimEntry != NULL)
		{
		CSimEntry * pSimEntryT = pSimEntry;
		pSimEntry = pSimEntry->m_pNext;
		delete pSimEntryT;
		}
	m_pSimEntryList = NULL;
	}

/////////////////////////////////////////////////////////////////////
BOOL CSimData::FInit(CString strUserPath, CString strADsIPath, HWND hwndParent)
{
	m_hwndParent = hwndParent;
	m_strUserPath = strUserPath;
	m_strADsIPath = strADsIPath;

	if (!FQuerySimData())
		{
                ReportErrorEx (hwndParent,IDS_SIM_ERR_CANNOT_READ_SIM_DATA,S_OK,
                               MB_OK | MB_ICONERROR, NULL, 0);
		return FALSE;
		}
	return TRUE;
}


/////////////////////////////////////////////////////////////////////
//	Return FALSE if some data could not be written.
//	Otherwise return TRUE.
BOOL CSimData::FOnApply(HWND hwndParent)
{
	if (!m_fIsDirty)
		return TRUE;

    HRESULT hr = FUpdateSimData ();
	if ( FAILED (hr) )
	{
        ReportErrorEx (hwndParent,  IDS_SIM_ERR_CANNOT_WRITE_SIM_DATA,  hr,
                MB_OK | MB_ICONERROR, NULL, 0);
		return FALSE;
	}
	// Re-load the data
	(void)FQuerySimData();

	// We have successfully written all the data
	m_fIsDirty = FALSE;	// Clear the dirty bit
	return TRUE;
}


/////////////////////////////////////////////////////////////////////
void CSimData::GetUserAccountName(OUT CString * pstrName)
	{
	ASSERT(pstrName != NULL);
	*pstrName = m_strUserPath;
	}


/////////////////////////////////////////////////////////////////////
//	Query the database for the list of security identities.
//
//	Return FALSE if an error occured.
//
BOOL CSimData::FQuerySimData()
	{
	CWaitCursor wait;
	FlushSimList();

	HRESULT hr;
	IADs * pADs = NULL;
	hr = DSAdminOpenObject(m_strADsIPath,
                     		 IID_IADs, 
                         OUT (void **)&pADs,
                         TRUE /*bServer*/);
	if (FAILED(hr))
		{
		ASSERT(pADs == NULL);
		return FALSE;
		}
	ASSERT(pADs != NULL);
	CComVariant vtData;
	// Read data from database
	hr = pADs->Get(szSchemaSim, OUT &vtData);
	if (FAILED(hr))
		{
		if (hr == E_ADS_PROPERTY_NOT_FOUND)
			hr = S_OK;
		}
	else
		{
		CStringList stringlist;
		hr = HrVariantToStringList(IN vtData, OUT stringlist);
		if (FAILED(hr))
			goto End;
		POSITION pos = stringlist.GetHeadPosition();
		while (pos != NULL)
			{
			(void)PAddSimEntry(stringlist.GetNext(INOUT pos));
			} // while
		} // if...else
End:
	if (pADs != NULL)
		pADs->Release();
	return SUCCEEDED(hr);
	} // FQuerySimData()


/////////////////////////////////////////////////////////////////////
//	Update the list of security identities to the database.
//
//	Return FALSE if an error occured.
//
HRESULT CSimData::FUpdateSimData()
{
	CWaitCursor wait;
	HRESULT hr;
	IADs * pADs = NULL;
	hr = DSAdminOpenObject(m_strADsIPath,
                      	 IID_IADs, 
                         OUT (void **)&pADs,
                         TRUE /*bServer*/);
	if (FAILED(hr))
	{
		ASSERT(pADs == NULL);
		return FALSE;
	}
	ASSERT(pADs != NULL);

	// Build the string list
	CStringList stringlist;
	for (const CSimEntry * pSimEntry = m_pSimEntryList;
		pSimEntry != NULL;
		pSimEntry = pSimEntry->m_pNext)
	{
		switch (pSimEntry->m_eDialogTarget)
		{
		case eNone:
			ASSERT(FALSE && "Invalid Data");
		case eNil:
		case eOther:
			continue;
		} // switch
    	stringlist.AddHead(pSimEntry->PchGetString());
	} // for

	CComVariant vtData;
	hr = HrStringListToVariant(OUT vtData, IN stringlist);
	if (FAILED(hr))
		goto End;
	// Put data back to database
	hr = pADs->Put(szSchemaSim, IN vtData);
	if (FAILED(hr))
		goto End;
	// Persist the data (write to database)
	hr = pADs->SetInfo();

End:
	if (pADs != NULL)
		pADs->Release();
	return hr;
} // FUpdateSimData()


/////////////////////////////////////////////////////////////////////
//	Allocate a new CSimEntry node to the linked list
//
CSimEntry * CSimData::PAddSimEntry(CString& rstrData)
{
	CSimEntry * pSimEntry = new CSimEntry;
  if (pSimEntry)
  {
	  pSimEntry->SetString(rstrData);
	  pSimEntry->m_pNext = m_pSimEntryList;
  }
  m_pSimEntryList = pSimEntry;
	return pSimEntry;
}


/////////////////////////////////////////////////////////////////////
void CSimData::DeleteSimEntry(CSimEntry * pSimEntryDelete)
	{
	CSimEntry * p = m_pSimEntryList;
	CSimEntry * pPrev = NULL;
	
	while (p != NULL)
		{
		if (p == pSimEntryDelete)
			{
			if (pPrev == NULL)
				{
				ASSERT(pSimEntryDelete == m_pSimEntryList);
				m_pSimEntryList = p->m_pNext;
				}
			else
				{
				pPrev->m_pNext = p->m_pNext;
				}
			delete pSimEntryDelete;
			return;
			}
		pPrev = p;
		p = p->m_pNext;
		}
	TRACE0("ERROR: CSimData::DeleteSimEntry() - Node not found.\n");
	} // DeleteSimEntry()


/////////////////////////////////////////////////////////////////////
void CSimData::AddEntriesToListview(HWND hwndListview, DIALOG_TARGET_ENUM eDialogTarget)
	{
	CSimEntry * pSimEntry = m_pSimEntryList;
	while (pSimEntry != NULL)
		{
		if (pSimEntry->m_eDialogTarget == eDialogTarget)
			{
			ListView_AddString(hwndListview, pSimEntry->PchGetString());
			}
		pSimEntry = pSimEntry->m_pNext;
		}

	} // AddEntriesToListview()


/////////////////////////////////////////////////////////////////////
void CSimData::DoModal()
{
	CWnd	parentWnd;

	VERIFY (parentWnd.Attach (m_hwndParent));

	CSimPropertySheet ps(IDS_SIM_SECURITY_IDENTITY_MAPPING, &parentWnd);

	

	ps.AddPage(m_paPage1);
	ps.AddPage(m_paPage2);
#ifdef _DEBUG
	ps.AddPage(m_paPage3);
#endif

	(void)ps.DoModal();

	parentWnd.Detach ();
}

/////////////////////////////////////////////////////////////////////////////
// CSimPropertySheet

IMPLEMENT_DYNAMIC(CSimPropertySheet, CPropertySheet)

CSimPropertySheet::CSimPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CSimPropertySheet::CSimPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

CSimPropertySheet::~CSimPropertySheet()
{
}


BEGIN_MESSAGE_MAP(CSimPropertySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CSimPropertySheet)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSimPropertySheet message handlers

BOOL CSimPropertySheet::OnInitDialog() 
{
	BOOL bResult = CPropertySheet::OnInitDialog();
	
	DWORD	dwStyle = GetWindowLong (m_hWnd, GWL_STYLE);
	dwStyle |=  DS_CONTEXTHELP;
	SetWindowLong (m_hWnd, GWL_STYLE, dwStyle);

	DWORD	dwExStyle = GetWindowLong (m_hWnd, GWL_EXSTYLE);
	dwExStyle |= WS_EX_CONTEXTHELP;
	SetWindowLong (m_hWnd, GWL_EXSTYLE, dwExStyle);
	
	return bResult;
}

BOOL CSimPropertySheet::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    return TRUE;
}

void CSimPropertySheet::DoContextHelp (HWND hWndControl)
{
    const int	IDC_COMM_APPLYNOW = 12321;
	const int	IDH_COMM_APPLYNOW = 28447;
    const DWORD aHelpIDs_PropSheet[]=
    {
		IDC_COMM_APPLYNOW, IDH_COMM_APPLYNOW,
        0, 0
    };

	if ( !::WinHelp (
			hWndControl,
			IDC_COMM_APPLYNOW == ::GetDlgCtrlID (hWndControl) ? 
                    L"windows.hlp" : DSADMIN_CONTEXT_HELP_FILE,
			HELP_WM_HELP,
			(DWORD_PTR) aHelpIDs_PropSheet) )
	{
		TRACE1 ("WinHelp () failed: 0x%x\n", GetLastError ());        
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simprop.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       simprop.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	SimProp.cpp - Common code used by SIM property pages.
//
//	HISTORY
//	08-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "common.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CSimPropPage, CPropertyPage)

BEGIN_MESSAGE_MAP(CSimPropPage, CPropertyPageEx_Mine)
	//{{AFX_MSG_MAP(CSimPropPage)
	ON_NOTIFY(NM_CLICK, IDC_LISTVIEW, OnClickListview)
	ON_NOTIFY(NM_DBLCLK, IDC_LISTVIEW, OnDblclkListview)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LISTVIEW, OnItemchangedListview)
	ON_NOTIFY(LVN_KEYDOWN, IDC_LISTVIEW, OnKeydownListview)
	ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
	ON_EN_SETFOCUS(IDC_EDIT_USER_ACCOUNT, OnSetfocusEditUserAccount)
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CSimPropPage::CSimPropPage(UINT nIDTemplate) : CPropertyPageEx_Mine(nIDTemplate)
	{
	//{{AFX_DATA_INIT(CSimPropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pData = NULL;
	m_prgzColumnHeader = NULL;
	}

CSimPropPage::~CSimPropPage()
	{
	}

void CSimPropPage::DoDataExchange(CDataExchange* pDX)
	{
	ASSERT(m_pData != NULL);
	CPropertyPageEx_Mine::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSimPropPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
	if (!pDX->m_bSaveAndValidate)
		{
		CString strUser;
		m_pData->GetUserAccountName(OUT &strUser);
		SetDlgItemText(IDC_EDIT_USER_ACCOUNT, strUser);
		} // if
	} // DoDataExchange()

BOOL CSimPropPage::OnInitDialog() 
	{
	m_hwndListview = ::GetDlgItem(m_hWnd, IDC_LISTVIEW);
	if (m_prgzColumnHeader != NULL)
		{
		ListView_AddColumnHeaders(m_hwndListview, m_prgzColumnHeader);
		}
	CPropertyPageEx_Mine::OnInitDialog();
	UpdateUI();
	return TRUE; 
	}

void CSimPropPage::SetDirty()
	{
	ASSERT(m_pData != NULL);
	m_pData->m_fIsDirty = TRUE;
	SetModified();
	UpdateUI();
	}

void CSimPropPage::UpdateUI()
	{
	int iItemSelected = ListView_GetSelectedItem(m_hwndListview);
	EnableDlgItem(IDC_BUTTON_REMOVE, iItemSelected >= 0);
	EnableDlgItem(IDC_BUTTON_EDIT, iItemSelected >= 0);
	}

void CSimPropPage::OnClickListview(NMHDR*, LRESULT* pResult) 
	{
	UpdateUI();
	*pResult = 0;
	}

void CSimPropPage::OnDblclkListview(NMHDR*, LRESULT* pResult) 
	{
	UpdateUI();
	SendMessage(WM_COMMAND, IDC_BUTTON_EDIT);
	*pResult = 0;
	}

void CSimPropPage::OnItemchangedListview(NMHDR*, LRESULT* pResult) 
	{
	UpdateUI();
	*pResult = 0;
	}

void CSimPropPage::OnButtonRemove() 
	{
	int iItem;
	CSimEntry * pSimEntry = (CSimEntry *)ListView_GetItemLParam(m_hwndListview, -1, OUT &iItem);
	if (pSimEntry == NULL || iItem < 0)
		{
		Report(FALSE && "No item selected");
		return;
		}
	m_pData->DeleteSimEntry(pSimEntry);
	UpdateData(FALSE);
	SetDirty();
	}

void CSimPropPage::OnSetfocusEditUserAccount() 
	{
	// Clear the selection and rewind caret to beginning
	SendDlgItemMessage(IDC_EDIT_USER_ACCOUNT, EM_SETSEL, 0, 0);
	}

void CSimPropPage::OnKeydownListview(NMHDR* pNMHDR, LRESULT* pResult) 
	{
	LV_KEYDOWN * pLVKeyDow = (LV_KEYDOWN *)pNMHDR;
	switch (pLVKeyDow->wVKey)
		{
	case VK_INSERT:
		SendMessage(WM_COMMAND, IDC_BUTTON_ADD);
		break;
	case VK_DELETE:
		SendMessage(WM_COMMAND, IDC_BUTTON_REMOVE);
		break;
		} // switch
	*pResult = 0;
	}

BOOL CSimPropPage::OnHelp(WPARAM, LPARAM lParam)
{
    TRACE0 ("Entering CSimPropPage::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    TRACE0 ("Leaving CSimPropPage::OnHelp\n");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simdata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       simdata.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	SimData.h - Security Identity Mapping
//
//	Data object used to display SIM property pages
//


#ifndef __SIMDATA_H_INCLUDED__
#define __SIMDATA_H_INCLUDED__

#include "Cert.h"

// Forward Classes
class CSimData;
class CSimPropPage;
class CSimX509PropPage;
class CSimKerberosPropPage;
class CSimOtherPropPage;

enum DIALOG_TARGET_ENUM
	{
	eNone,			// No Property Page
	eX509,			// X509 Property Page
	eKerberos,		// Kerberos Property Page
	eOther,			// Other Property Page
	eNil			// String is invalid -> get rid of string
	};

/////////////////////////////////////////////////////////////////////
class CSimEntry	// Security Identity Mapping Entry
{
public:
	// Which dialog should the SIM entry should go
	
	DIALOG_TARGET_ENUM m_eDialogTarget;
	CSimEntry * m_pNext;
	CString m_strData;

	CSimEntry()
		{
		m_eDialogTarget = eNone;
		m_pNext = NULL;
		}

	LPCTSTR PchGetString() const
		{
		return (LPCTSTR)m_strData;
		}

	void SetString(CString& rstrData);
}; // CSimEntry


/////////////////////////////////////////////////////////////////////
class CSimData	// Data object for Security Identity Mapping
{
	friend CSimPropPage;
	friend CSimX509PropPage;
	friend CSimKerberosPropPage;
	friend CSimOtherPropPage;

protected:
	BOOL m_fIsDirty;
	// Allocated property pages
	CSimX509PropPage * m_paPage1;
	CSimKerberosPropPage * m_paPage2;
	#ifdef _DEBUG
	CSimOtherPropPage * m_paPage3;
	#endif

protected:
	CSimEntry * m_pSimEntryList;	// Linked  list of Kerberos Names to map to account
	CString m_strUserPath;
	CString m_strADsIPath;
	HWND m_hwndParent;

public:
	CSimData();
	~CSimData();
	void FlushSimList();

	BOOL FInit(CString strUserPath, CString strADsIPath, HWND hwndParent = NULL);
	void DoModal();
	BOOL FOnApply(HWND hwndParent = NULL);

	BOOL FQuerySimData();
	HRESULT FUpdateSimData();
	
	void GetUserAccountName(OUT CString * pstrName);
	CSimEntry * PAddSimEntry(CString& rstrData);
	void DeleteSimEntry(CSimEntry * pSimEntryDelete);
	void AddEntriesToListview(HWND hwndListview, DIALOG_TARGET_ENUM eDialogTarget);

};	// CSimData



#endif // ~__SIMDATA_H_INCLUDED__
/////////////////////////////////////////////////////////////////////////////
// CSimPropertySheet

class CSimPropertySheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CSimPropertySheet)

// Construction
public:
	CSimPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CSimPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSimPropertySheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CSimPropertySheet();

	// Generated message map functions
protected:
	//{{AFX_MSG(CSimPropertySheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
    BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	virtual void DoContextHelp (HWND hWndControl);
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simprop1.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       simprop1.cpp
//
//--------------------------------------------------------------------------

//	SimProp1.cpp

#include "stdafx.h"
#include "common.h"
#include "helpids.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


const TColumnHeaderItem rgzColumnHeader[] =
	{
	{ IDS_SIM_CERTIFICATE_FOR, 45 },
	{ IDS_SIM_ISSUED_BY, 45 },
	{ 0, 0 },
	};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSimX509PropPage property page
// IMPLEMENT_DYNCREATE(CSimX509PropPage, CSimPropPage)

CSimX509PropPage::CSimX509PropPage() : CSimPropPage(CSimX509PropPage::IDD)
{
	//{{AFX_DATA_INIT(CSimX509PropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_prgzColumnHeader = rgzColumnHeader;
	VERIFY( m_strAnySubject.LoadString(IDS_SIM_ANY_SUBJECT) );
	VERIFY( m_strAnyTrustedAuthority.LoadString(IDS_SIM_ANY_TRUSTED_AUTHORITY) );
}

CSimX509PropPage::~CSimX509PropPage()
{
}

void CSimX509PropPage::DoDataExchange(CDataExchange* pDX)
{
	ASSERT(m_pData != NULL);
	CSimPropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSimX509PropPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
	if (!pDX->m_bSaveAndValidate)
		{
		// Fill in the listview
		ListView_DeleteAllItems(m_hwndListview);
		for (CSimEntry * pSimEntry = m_pData->m_pSimEntryList;
			pSimEntry != NULL;
			pSimEntry = pSimEntry->m_pNext)
			{
			AddSimEntry(pSimEntry);
			} // for
		ListView_SelectItem(m_hwndListview, 0);
		} // if
} // DoDataExchange()

/////////////////////////////////////////////////////////////////////
void CSimX509PropPage::AddSimEntry(CSimEntry * pSimEntry)
	{
	ASSERT(pSimEntry != NULL);
	if (pSimEntry->m_eDialogTarget != eX509)
			return;
	LPTSTR * pargzpsz;	// Pointer to allocated array of pointer to strings
	pargzpsz = ParseSimString(pSimEntry->PchGetString());
	if (pargzpsz == NULL)
		return;	// Error parsing string

	ASSERT(0 == lstrcmpi(pargzpsz[0], szX509));
	// Find out the Subject
	LPCTSTR pszSubject = PchFindSimAttribute(pargzpsz, szSimSubject, _T("CN="));
	// Find out the Issuer
	LPCTSTR pszIssuer = PchFindSimAttribute(pargzpsz, szSimIssuer, _T("OU="));
	
	// Finally, add the strings to the listview
	CString strSubject = m_strAnySubject;
	CString strIssuer = m_strAnyTrustedAuthority;
	if (pszSubject != NULL)
		strSimToUi(IN pszSubject, OUT &strSubject);
	if (pszIssuer != NULL)
		strSimToUi(IN pszIssuer, OUT &strIssuer);
	const LPCTSTR rgzpsz[] = { strSubject, strIssuer,  NULL };
	ListView_AddStrings(m_hwndListview, IN rgzpsz, (LPARAM)pSimEntry);
	delete pargzpsz;
	} // AddSimEntry()


BEGIN_MESSAGE_MAP(CSimX509PropPage, CSimPropPage)
	//{{AFX_MSG_MAP(CSimX509PropPage)
	ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
	ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CSimX509PropPage::OnButtonAdd() 
{
	CString strFullPath;
	if (!UiGetCertificateFile(OUT &strFullPath))
		return;
	CCertificate cer;
	if (!cer.FLoadCertificate(strFullPath))
		return;
	CSimCertificateDlg dlg;
	dlg.m_uStringIdCaption = IDS_SIM_ADD_CERTIFICATE;
	cer.GetSimString(OUT &dlg.m_strData);
	if (IDOK != dlg.DoModal())
		return;
	CSimEntry * pSimEntry = m_pData->PAddSimEntry(dlg.m_strData);
	UpdateData(FALSE);
	ListView_SelectLParam(m_hwndListview, (LPARAM)pSimEntry);
	SetDirty();
}

void CSimX509PropPage::OnButtonEdit() 
{
	int iItem;
	CSimEntry * pSimEntry = (CSimEntry *)ListView_GetItemLParam(m_hwndListview, -1, OUT &iItem);
	if (pSimEntry == NULL || iItem < 0)
		{
		// No item selected
		return;
		}

	CSimCertificateDlg dlg;
	dlg.m_strData = pSimEntry->PchGetString();
	if (IDOK != dlg.DoModal())
		return;
	pSimEntry->SetString(dlg.m_strData);
	UpdateData(FALSE);
	ListView_SelectLParam(m_hwndListview, (LPARAM)pSimEntry);
	SetDirty();
}


BOOL CSimX509PropPage::OnApply() 
{
	if (!m_pData->FOnApply( GetSafeHwnd() ))
		{
		// Unable to write the information
		return FALSE;
		}
	UpdateData(FALSE);
	UpdateUI();
	return CPropertyPage::OnApply();
}

void CSimX509PropPage::DoContextHelp (HWND hWndControl)
{
   TRACE0 ("Entering CSimX509PropPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_EDIT_USER_ACCOUNT,  IDH_EDIT_USER_ACCOUNT,
        IDC_LISTVIEW,			IDH_LISTVIEW_X509,
        IDC_BUTTON_ADD,			IDH_BUTTON_ADD,
        IDC_BUTTON_EDIT,		IDH_BUTTON_EDIT,
		IDC_BUTTON_REMOVE,		IDH_BUTTON_REMOVE,
        IDCANCEL,               IDH_BUTTON_REMOVE, //IDH_CANCEL_BUTTON,
        IDOK,                   IDH_BUTTON_REMOVE, //IDH_OK_BUTTON,
        0, 0
    };
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            DSADMIN_CONTEXT_HELP_FILE,
            HELP_WM_HELP,
            (DWORD_PTR) help_map) )
    {
        TRACE1 ("WinHelp () failed: 0x%x\n", GetLastError ());        
    }
    TRACE0 ("Leaving CSimX509PropPage::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simprop2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       simprop2.cpp
//
//--------------------------------------------------------------------------

//	SimProp2.cpp

#include "stdafx.h"
#include "common.h"
#include "helpids.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////
const TColumnHeaderItem rgzColumnHeader[] =
	{
	{ IDS_SIM_KERBEROS_PRINCIPAL_NAME, 85 },
	{ 0, 0 },
	};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSimKerberosPropPage property page

// IMPLEMENT_DYNCREATE(CSimKerberosPropPage, CSimPropPage)

CSimKerberosPropPage::CSimKerberosPropPage() : CSimPropPage(CSimKerberosPropPage::IDD)
{
	//{{AFX_DATA_INIT(CSimKerberosPropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_prgzColumnHeader = rgzColumnHeader;
}

CSimKerberosPropPage::~CSimKerberosPropPage()
{
}

void CSimKerberosPropPage::DoDataExchange(CDataExchange* pDX)
{
	ASSERT(m_pData != NULL);
	CSimPropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSimKerberosPropPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP

	if (!pDX->m_bSaveAndValidate)
		{
		// Fill in the listview
		ListView_DeleteAllItems(m_hwndListview);
		for (CSimEntry * pSimEntry = m_pData->m_pSimEntryList;
			pSimEntry != NULL;
			pSimEntry = pSimEntry->m_pNext)
			{
			if (pSimEntry->m_eDialogTarget != eKerberos)
				continue;
			LPCTSTR pszT = pSimEntry->PchGetString();
			pszT += cchKerberos;
			ListView_AddString(m_hwndListview, pszT, (LPARAM)pSimEntry);
			} // for
		ListView_SelectItem(m_hwndListview, 0);
		} // if
} // CSimKerberosPropPage::DoDataExchange()


BEGIN_MESSAGE_MAP(CSimKerberosPropPage, CSimPropPage)
	//{{AFX_MSG_MAP(CSimKerberosPropPage)
	ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
	ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CSimKerberosPropPage::OnButtonAdd() 
	{
	CSimAddKerberosDlg dlg;
	if (dlg.DoModal() != IDOK)
		return;
	CString str = dlg.m_strName;
	str.TrimLeft();
	str.TrimRight();
	int iItem = ListView_FindString(m_hwndListview, str);
	if (iItem >= 0)
		{
		ListView_SelectItem(m_hwndListview, iItem);
		ReportErrorEx (GetSafeHwnd(),IDS_SIM_ERR_KERBEROS_NAME_ALREADY_EXISTS,S_OK,
                               MB_OK | MB_ICONINFORMATION, NULL, 0);
		return;
		}
	CString strTemp = szKerberos;
	strTemp += str;
	CSimEntry * pSimEntry = m_pData->PAddSimEntry(strTemp);
	UpdateData(FALSE);
	ListView_SelectLParam(m_hwndListview, (LPARAM)pSimEntry);
	SetDirty();
	} // OnButtonAdd()


void CSimKerberosPropPage::OnButtonEdit() 
	{
	int iItem;
	CSimEntry * pSimEntry = (CSimEntry *)ListView_GetItemLParam(m_hwndListview, -1, OUT &iItem);
	if (pSimEntry == NULL || iItem < 0)
		{
		// No item selected
		return;
		}
	CString str;
	ListView_GetItemString(m_hwndListview, iItem, 0, OUT str);
	// ASSERT(!str.IsEmpty());
	CSimAddKerberosDlg dlg;
	dlg.m_strName = str;
	if (dlg.DoModal() != IDOK)
		return;

	dlg.m_strName.TrimLeft();
	dlg.m_strName.TrimRight();
	if (str == dlg.m_strName)
		{
		// Strings are identical
		return;
		}
	int iItemT = ListView_FindString(m_hwndListview, dlg.m_strName);
	if (iItemT >= 0)
		{
		ListView_SelectItem(m_hwndListview, iItemT);
		ReportErrorEx (GetSafeHwnd(),IDS_SIM_ERR_KERBEROS_NAME_ALREADY_EXISTS,S_OK,
                               MB_OK | MB_ICONINFORMATION, NULL, 0);
		return;
		}
	CString strTemp = szKerberos;
	strTemp += dlg.m_strName;
	pSimEntry->SetString(strTemp);
	UpdateData(FALSE);
	ListView_SelectLParam(m_hwndListview, (LPARAM)pSimEntry);
	SetDirty();
	} // OnButtonEdit()


void CSimKerberosPropPage::DoContextHelp (HWND hWndControl)
{
   TRACE0 ("Entering CSimKerberosPropPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_EDIT_USER_ACCOUNT,  IDH_EDIT_USER_ACCOUNT,
        IDC_LISTVIEW,			IDH_LISTVIEW_KERBEROS,
        IDC_BUTTON_ADD,			IDH_BUTTON_ADD,
        IDC_BUTTON_EDIT,		IDH_BUTTON_EDIT,
		IDC_BUTTON_REMOVE,		IDH_BUTTON_REMOVE,
        0, 0
    };
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            DSADMIN_CONTEXT_HELP_FILE,
            HELP_WM_HELP,
            (DWORD_PTR) help_map) )
    {
        TRACE1 ("WinHelp () failed: 0x%x\n", GetLastError ());        
    }
    TRACE0 ("Leaving CSimKerberosPropPage::DoContextHelp\n");
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSimAddKerberosDlg dialog
CSimAddKerberosDlg::CSimAddKerberosDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSimAddKerberosDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSimAddKerberosDlg)
	//}}AFX_DATA_INIT
}


void CSimAddKerberosDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSimAddKerberosDlg)
	DDX_Text(pDX, IDC_EDIT_KERBEROS_NAME, m_strName);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSimAddKerberosDlg, CDialog)
	//{{AFX_MSG_MAP(CSimAddKerberosDlg)
	ON_EN_CHANGE(IDC_EDIT_KERBEROS_NAME, OnChangeEditKerberosName)
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
END_MESSAGE_MAP()

BOOL CSimAddKerberosDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	if ( m_strName.IsEmpty() )
    {
        GetDlgItem (IDOK)->EnableWindow (FALSE);
    }
    else
    {
		// Change the caption
		CString str;
		VERIFY( str.LoadString(IDS_SIM_EDIT_KERBEROS_NAME) );
		SetWindowText(str);
	}
	return TRUE;
}

void CSimAddKerberosDlg::OnChangeEditKerberosName() 
{
	UpdateData (TRUE);
    
    m_strName.TrimLeft ();
    m_strName.TrimRight ();

    GetDlgItem (IDOK)->EnableWindow (!m_strName.IsEmpty ());
}

void CSimAddKerberosDlg::DoContextHelp (HWND hWndControl)
{
   TRACE0 ("Entering CSimAddKerberosDlg::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_EDIT_KERBEROS_NAME,  IDH_EDIT_KERBEROS_NAME,
        0, 0
    };
    // Display context help for a control
    if ( !::WinHelp (
            hWndControl,
            DSADMIN_CONTEXT_HELP_FILE,
            HELP_WM_HELP,
            (DWORD_PTR) help_map) )
    {
        TRACE1 ("WinHelp () failed: 0x%x\n", GetLastError ());        
    }
    TRACE0 ("Leaving CSimAddKerberosDlg::DoContextHelp\n");
}

BOOL CSimAddKerberosDlg::OnHelp(WPARAM, LPARAM lParam)
{
    TRACE0 ("Entering CSimAddKerberosDlg::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    TRACE0 ("Leaving CSimAddKerberosDlg::OnHelp\n");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       simprop.h
//
//--------------------------------------------------------------------------

//	SimProp.h


class CSimPropPage : public CPropertyPageEx_Mine
{
	friend CSimData;

	DECLARE_DYNCREATE(CSimPropPage)

public:
	CSimPropPage(UINT nIDTemplate = 0);
	~CSimPropPage();

// Dialog Data
	//{{AFX_DATA(CSimPropPage)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSimPropPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSimPropPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonRemove();
	afx_msg void OnClickListview(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkListview(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedListview(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydownListview(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusEditUserAccount();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	virtual void DoContextHelp (HWND) {};

protected:
	CSimData * m_pData;
	HWND m_hwndListview;		// Handle of the listview control
	const TColumnHeaderItem * m_prgzColumnHeader;

protected:
	void SetDirty();
	void UpdateUI();

}; // CSimPropPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simprop1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       simprop1.h
//
//--------------------------------------------------------------------------

//	SimProp1.h


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSimX509PropPage property page
class CSimX509PropPage : public CSimPropPage
{
	friend CSimData;

//	DECLARE_DYNCREATE(CSimX509PropPage)

// Construction
public:
	CSimX509PropPage();
	~CSimX509PropPage();

// Dialog Data
	//{{AFX_DATA(CSimX509PropPage)
	enum { IDD = IDD_SIM_PROPPAGE_X509_CERTIFICATES };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSimX509PropPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSimX509PropPage)
	afx_msg void OnButtonAdd();
	afx_msg void OnButtonEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void DoContextHelp (HWND hWndControl);
protected:
	CString m_strAnySubject;
	CString m_strAnyTrustedAuthority;

protected:
	void AddSimEntry(CSimEntry * pSimEntry);

}; // CSimX509PropPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simprop3.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       simprop3.cpp
//
//--------------------------------------------------------------------------

// SimProp3.cpp : implementation file
//

#include "stdafx.h"
#include "common.h"

#ifdef _DEBUG

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////
const TColumnHeaderItem rgzColumnHeader[] =
	{
	{ IDS_SIM_KERBEROS_PRINCIPAL_NAME, 85 },
	{ 0, 0 },
	};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSimOtherPropPage property page
CSimOtherPropPage::CSimOtherPropPage() : CSimPropPage(CSimOtherPropPage::IDD)
{
	//{{AFX_DATA_INIT(CSimOtherPropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_prgzColumnHeader = rgzColumnHeader;
}


void CSimOtherPropPage::DoDataExchange(CDataExchange* pDX)
{
	CSimPropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSimOtherPropPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
	if (!pDX->m_bSaveAndValidate)
		{
		// Fill in the listview
		ListView_DeleteAllItems(m_hwndListview);
		for (CSimEntry * pSimEntry = m_pData->m_pSimEntryList;
			pSimEntry != NULL;
			pSimEntry = pSimEntry->m_pNext)
			{
			if (pSimEntry->m_eDialogTarget != eOther)
				continue;
			ListView_AddString(m_hwndListview, pSimEntry->PchGetString(), (LPARAM)pSimEntry);
			} // for
		ListView_SelectItem(m_hwndListview, 0);
		} // if
}


BEGIN_MESSAGE_MAP(CSimOtherPropPage, CSimPropPage)
	//{{AFX_MSG_MAP(CSimOtherPropPage)
	ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
	ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CSimOtherPropPage::OnButtonAdd() 
	{
	CSimAddKerberosDlg dlg;
	if (dlg.DoModal() != IDOK)
		return;
	CString str = dlg.m_strName;
	int iItem = ListView_FindString(m_hwndListview, str);
	if (iItem >= 0)
		{
		ListView_SelectItem(m_hwndListview, iItem);
		ReportErrorEx (GetSafeHwnd(),IDS_SIM_ERR_KERBEROS_NAME_ALREADY_EXISTS,S_OK,
                               MB_OK | MB_ICONINFORMATION, NULL, 0);
		return;
		}
	CSimEntry * pSimEntry = m_pData->PAddSimEntry(str);
	iItem = ListView_AddString(m_hwndListview, str, (LPARAM)pSimEntry);
	ListView_SelectItem(m_hwndListview, iItem);
	SetDirty();
	} // OnButtonAdd()

void CSimOtherPropPage::OnButtonEdit() 
	{
	int iItem;
	CSimEntry * pSimEntry = (CSimEntry *)ListView_GetItemLParam(m_hwndListview, -1, OUT &iItem);
	if (pSimEntry == NULL || iItem < 0)
		{
		// No item selected
		return;
		}
	CString str;
	ListView_GetItemString(m_hwndListview, iItem, 0, OUT str);
	ASSERT(!str.IsEmpty());
	CSimAddKerberosDlg dlg;
	dlg.m_strName = str;
	if (dlg.DoModal() != IDOK)
		return;

	if (str == dlg.m_strName)
		{
		// Strings are identical
		return;
		}
	int iItemT = ListView_FindString(m_hwndListview, dlg.m_strName);
	if (iItemT >= 0)
		{
		ListView_SelectItem(m_hwndListview, iItemT);
		ReportErrorEx (GetSafeHwnd(),IDS_SIM_ERR_KERBEROS_NAME_ALREADY_EXISTS,S_OK,
                               MB_OK | MB_ICONINFORMATION, NULL, 0);
		return;
		}
	CString strTemp = dlg.m_strName;
	pSimEntry->SetString(strTemp);
	UpdateData(FALSE);
	iItem = ListView_FindString(m_hwndListview, strTemp);
	ListView_SelectItem(m_hwndListview, iItem);
	SetDirty();
	} // OnButtonEdit()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simprop2.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       simprop2.h
//
//--------------------------------------------------------------------------

//	SimProp2.h


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSimKerberosPropPage property page
class CSimKerberosPropPage : public CSimPropPage
{
	friend CSimData;

//	DECLARE_DYNCREATE(CSimKerberosPropPage)

// Construction
public:
	CSimKerberosPropPage();
	~CSimKerberosPropPage();

// Dialog Data
	//{{AFX_DATA(CSimKerberosPropPage)
	enum { IDD = IDD_SIM_PROPPAGE_KERBEROS_NAMES };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSimKerberosPropPage)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual void DoContextHelp (HWND hWndControl);

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSimKerberosPropPage)
	afx_msg void OnButtonAdd();
	afx_msg void OnButtonEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:

}; // CSimKerberosPropPage


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSimAddKerberosDlg dialog - Add a Kerberos principal name to prop page
class CSimAddKerberosDlg : public CDialog
{
public:
	CSimAddKerberosDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSimAddKerberosDlg)
	enum { IDD = IDD_SIM_ADD_KERBEROS };
	CString	m_strName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSimAddKerberosDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
    virtual void DoContextHelp (HWND hWndControl);
    BOOL OnHelp(WPARAM, LPARAM lParam);

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSimAddKerberosDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditKerberosName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	CSimData * m_pData;

};  // CSimAddKerberosDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlwin.cpp>
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simprop3.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       simprop3.h
//
//--------------------------------------------------------------------------

// SimProp3.h : header file

#ifdef _DEBUG
/////////////////////////////////////////////////////////////////////////////
// CSimOtherPropPage property page
class CSimOtherPropPage : public CSimPropPage
{
	friend CSimData;

public:
	CSimOtherPropPage();   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSimOtherPropPage)
	enum { IDD = IDD_SIM_PROPPAGE_OTHERS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSimOtherPropPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSimOtherPropPage)
	afx_msg void OnButtonAdd();
	afx_msg void OnButtonEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:

}; // CSimOtherPropPage

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\stdabout.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdabout.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	StdAbout.h
//
//	HISTORY
//	31-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#ifndef __STDABOUT_H_INCLUDED__
#define __STDABOUT_H_INCLUDED__


class CSnapinAbout :
	public ISnapinAbout,
	public CComObjectRoot
{
BEGIN_COM_MAP(CSnapinAbout)
	COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()
public:
	CSnapinAbout();
   ~CSnapinAbout();

// ISnapinAbout
	STDMETHOD(GetSnapinDescription)(OUT LPOLESTR __RPC_FAR *lpDescription);
	STDMETHOD(GetProvider)(OUT LPOLESTR __RPC_FAR *lpName);
	STDMETHOD(GetSnapinVersion)(OUT LPOLESTR __RPC_FAR *lpVersion);
	STDMETHOD(GetSnapinImage)(OUT HICON __RPC_FAR *hAppIcon);
	STDMETHOD(GetStaticFolderImage)(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask);
protected:
	// The following data members MUST be initialized by the constructor
	// of the derived class.
	UINT m_uIdStrDestription;		// Resource Id of the description
	UINT m_uIdStrProvider;		// Resource Id of the provider (ie, Microsoft Corporation)
	UINT m_uIdStrVersion;			// Resource Id of the version of the snapin
	UINT m_uIdIconImage;			// Resource Id for the icon/image of the snapin
	UINT m_uIdBitmapSmallImage;
	UINT m_uIdBitmapSmallImageOpen;
	UINT m_uIdBitmapLargeImage;
   HBITMAP hBitmapSmallImage;
   HBITMAP hBitmapSmallImageOpen;
   HBITMAP hBitmapLargeImage;
	COLORREF m_crImageMask;

}; // CSnapinAbout()

#endif // ~__STDABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\stdabout.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       stdabout.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	StdAbout.cpp
//
//	Implementation of the ISnapinAbout interface
//
//	HISTORY
//	31-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////


#include "stdafx.h"

HRESULT
HrLoadOleString(UINT uStringId,					// IN: String Id to load from the resource
	              OUT LPOLESTR * ppaszOleString)	// OUT: Pointer to pointer to allocated OLE string
{
	if (ppaszOleString == NULL)
	{
		TRACE0("HrLoadOleString() - ppaszOleString is NULL.\n");
		return E_POINTER;
	}
	CString strT;		// Temporary string
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Needed for LoadString()
	VERIFY( strT.LoadString(uStringId) );
  *ppaszOleString = reinterpret_cast<LPOLESTR>
            (CoTaskMemAlloc((strT.GetLength() + 1)* sizeof(wchar_t)));

	if (*ppaszOleString == NULL)
  {
		return E_OUTOFMEMORY;
  }

	USES_CONVERSION;
  wcscpy(OUT *ppaszOleString, T2OLE((LPTSTR)(LPCTSTR)strT));
	return S_OK;
} // HrLoadOleString()













CSnapinAbout::CSnapinAbout() :
   hBitmapSmallImage(0),
   hBitmapSmallImageOpen(0),
   hBitmapLargeImage(0)
{
}

CSnapinAbout::~CSnapinAbout()
{
   if (hBitmapSmallImage)
   {
      DeleteObject(hBitmapSmallImage);
      hBitmapSmallImage = 0;
   }

   if (hBitmapSmallImageOpen)
   {
      DeleteObject(hBitmapSmallImageOpen);
      hBitmapSmallImageOpen = 0;
   }

   if (hBitmapLargeImage)
   {
      DeleteObject(hBitmapLargeImage);
      hBitmapLargeImage = 0;
   }
}

STDMETHODIMP CSnapinAbout::GetSnapinDescription(OUT LPOLESTR __RPC_FAR *lpDescription)
{
	return HrLoadOleString(m_uIdStrDestription, OUT lpDescription);
}

STDMETHODIMP CSnapinAbout::GetProvider(OUT LPOLESTR __RPC_FAR *lpName)
{
	return HrLoadOleString(m_uIdStrProvider, OUT lpName);
}

STDMETHODIMP CSnapinAbout::GetSnapinVersion(OUT LPOLESTR __RPC_FAR *lpVersion)
{
	return HrLoadOleString(m_uIdStrVersion, OUT lpVersion);
}

STDMETHODIMP CSnapinAbout::GetSnapinImage(OUT HICON __RPC_FAR *hAppIcon)
{
   if (hAppIcon == NULL)
      return E_POINTER;
   AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
   *hAppIcon = ::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_uIdIconImage));
   if (*hAppIcon == NULL)
	{
      ASSERT(FALSE && "Unable to load icon");
      return E_FAIL;
   }
return S_OK;
}

STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask)
	{	
	ASSERT(hSmallImage != NULL);
	ASSERT(hSmallImageOpen != NULL);
	ASSERT(hLargeImage != NULL);
	ASSERT(crMask != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
	HINSTANCE hInstance = AfxGetInstanceHandle();

   if (!hBitmapSmallImage)
   {
      hBitmapSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImage));
   }
   ASSERT(hBitmapSmallImage);
   *hSmallImage = hBitmapSmallImage;

   if (!hBitmapSmallImageOpen)
   {
      hBitmapSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImageOpen));
   }
   ASSERT(hBitmapSmallImageOpen);
	*hSmallImageOpen = hBitmapSmallImageOpen;

   if (!hBitmapLargeImage)
   {
      hBitmapLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapLargeImage));
   }
   ASSERT(hBitmapLargeImage);
	*hLargeImage = hBitmapLargeImage;

	*crMask = m_crImageMask;
	#ifdef _DEBUG
	if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
		{
		TRACE0("WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
		return E_FAIL;
		}
	#endif
	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       simutil.h
//
//--------------------------------------------------------------------------

//	SimUtil.h


BOOL UiGetCertificateFile(CString * pstrCertificateFilename);

LPTSTR * ParseSimString(LPCTSTR szSimString, int * pArgc = NULL);
void UnparseSimString(CString * pstrOut, const LPCTSTR rgzpsz[]);

LPCTSTR PchFindSimAttribute(const LPCTSTR rgzpsz[], LPCTSTR pszSeparatorTag, LPCTSTR pszAttributeTag);
int FindSimAttributes(LPCTSTR pszSeparatorTag, const LPCTSTR rgzpszIn[], LPCTSTR rgzpszOut[]);

void
ParseSimSeparators(
	const LPCTSTR rgzpszIn[],
	LPCTSTR rgzpszIssuer[],
	LPCTSTR rgzpszSubject[],
	LPCTSTR rgzpszAltSubject[]);

int UnparseSimSeparators(
	CString * pstrOut,
	const LPCTSTR rgzpszIssuer[],
	const LPCTSTR rgzpszSubject[],
	const LPCTSTR rgzpszAltSubject[]);

LPTSTR * SplitX509String(
	LPCTSTR pszX509,
	LPCTSTR * ppargzpszIssuer[],
	LPCTSTR * ppargzpszSubject[],
	LPCTSTR * ppargzpszAltSubject[]);

int UnsplitX509String(
	CString * pstrX509,
	const LPCTSTR rgzpszIssuer[],
	const LPCTSTR rgzpszSubject[],
	const LPCTSTR rgzpszAltSubject[]);

void strSimToUi(IN LPCTSTR pszSIM, OUT CString * pstrUI);
void strUiToSim(IN LPCTSTR pszUI, OUT CString * pstrSIM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sim.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_ALTERNTYPE                  129
#define IDD_SIM_PROPPAGE_X509_CERTIFICATES 201
#define IDD_SIM_PROPPAGE_KERBEROS_NAMES 202
#define IDD_SIM_CERTIFICATE_PROPERTIES  203
#define IDD_SIM_ADD_KERBEROS            204
#define IDD_SIM_PROPPAGE_OTHERS         211
#define IDD_SIM_ADD_OTHERSTRING         212
#define IDS_SIM_CERTIFICATE_FILTER      800
#define IDS_SIM_CERTIFICATE_FOR         1000
#define IDS_SIM_ISSUED_BY               1001
#define IDC_BUTTON_BROWSE               1002
#define IDS_SIM_KERBEROS_PRINCIPAL_NAME 1002
#define IDS_SIM_SECURITY_IDENTITY_MAPPING 1003
#define IDS_SIM_ATTRIBUTE               1004
#define IDS_SIM_INFORMATION             1005
#define IDS_SIM_ANY_SUBJECT             1006
#define IDC_LISTVIEW                    1007
#define IDS_SIM_ANY_TRUSTED_AUTHORITY   1007
#define IDC_BUTTON_EDIT                 1008
#define IDS_SIM_ADD_CERTIFICATE         1008
#define IDC_EDIT_KERBEROS_NAME          1009
#define IDS_SIM_EDIT_KERBEROS_NAME      1010
#define IDC_GROUP_IDENTITY_MAPPING      1011
#define IDC_CHECK_ISSUER                1012
#define IDC_CHECK_SUBJECT               1014
#define IDC_STATIC_CERTIFICATE_PATH     1019
#define IDC_EDIT_CERTIFICATE_PATH       1020
#define IDS_SIM_ISSUER                  1020
#define IDC_EDIT_USER_ACCOUNT           1021
#define IDS_SIM_SUBJECT                 1021
#define IDS_CERTFILEFORMATERR           1028
#define IDS_ADD_CERTIFICATE_MAPPING     1029
#define IDS_SIM_REMOVING_SUBJECT_AS_ID  1030
#define IDS_SIM_ERR_KERBEROS_NAME_ALREADY_EXISTS 2000
#define IDS_SIM_ERR_CANNOT_READ_SIM_DATA 2001
#define IDS_SIM_ERR_CANNOT_WRITE_SIM_DATA 2002
#define IDS_SIM_ERR_INVALID_MAPPING     2003
#define ID_VIEW_SECURITYIDENTITYMAPPING 32771

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        211
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef __STDAFX_H__
#define __STDAFX_H__

// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.

#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG

// common utility macros
#define RETURN_IF_FAILED(hr) if (FAILED(hr)) { return hr; }


// C++ RTTI
#include <typeinfo.h>
#define IS_CLASS(x,y) (typeid(x) == typeid(y))


#define STRICT
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NT_INCLUDED
#undef ASSERT
#undef ASSERTMSG

#define _ATL_NO_UUIDOF 

#define _USE_MFC

#ifdef _USE_MFC
    #define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

	#include <afxwin.h>         // MFC core and standard components
    #include <afxext.h>         // MFC extensions
    #include <afxtempl.h>		// MFC Template classes
    #include <afxdlgs.h>
	#include <afxdisp.h>        // MFC OLE Control Containment component

#ifndef _AFX_NO_AFXCMN_SUPPORT
    #include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#endif



///////////////////////////////////////////
// ASSERT's and TRACE's without debug CRT's
#if defined (DBG)
  #if !defined (_DEBUG)
    #define _USE_DSA_TRACE
    #define _USE_DSA_ASSERT
    #define _USE_DSA_TIMER
  #endif
#endif

#include "dbg.h"
///////////////////////////////////////////


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

interface IADsPathname; // fwd decl
class CThreadContext; // fwd decl

class CDsAdminModule : public CComModule
{
public:
  CDsAdminModule()
  {
  }

	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);

};


#define DECLARE_REGISTRY_CLSID() \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister) \
{ \
		return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister); \
}


extern CDsAdminModule _Module;



#include <atlcom.h>
#include <atlwin.h>

#include "dbgutil.h"
#define SECURITY_WIN32 
#include "security.h"

#include <activeds.h>
#include <iadsp.h>
#include <mmc.h>
#pragma comment(lib, "mmcuuid.lib")

#include <shlobj.h> // needed for dsclient.h
#include <dsclient.h>
#include <dsclintp.h>

#include <dspropp.h>
#include <propcfg.h> // private dsprop header

#include <stdabout.h>

#include <dsadmin.h>  // COM extensibility interfaces
#include <dsadminp.h>  // common functionality 

#define SECURITY_WIN32 
#include "security.h"
#include "pcrack.h" // CPathCracker


// macros

extern const CLSID CLSID_DSSnapin;
extern const CLSID CLSID_DSSnapinEx;
extern const CLSID CLSID_SiteSnapin;
extern const CLSID CLSID_DSContextMenu;
extern const CLSID CLSID_DSAboutSnapin;
extern const CLSID CLSID_SitesAboutSnapin;
extern const CLSID CLSID_DSAdminQueryUIForm;
extern const GUID cDefaultNodeType;

extern const wchar_t* cszDefaultNodeType;

// New Clipboard format that has the Type and Cookie
extern const wchar_t* SNAPIN_INTERNAL;

// these are from ntsam.h, i can't include it here.
//
// Group Flag Definitions to determine Type of Group
//

#define GROUP_TYPE_BUILTIN_LOCAL_GROUP   0x00000001
#define GROUP_TYPE_ACCOUNT_GROUP         0x00000002
#define GROUP_TYPE_RESOURCE_GROUP        0x00000004
#define GROUP_TYPE_UNIVERSAL_GROUP       0x00000008
#define GROUP_TYPE_SECURITY_ENABLED      0x80000000


// struct definitions

typedef struct _CREATEINFO {
  DWORD  dwSize;      // in bytes
  DWORD  cItems;      // how many entries;
  LPWSTR paClassNames[1]; // array of LPWSTR
} CREATEINFO, *PCREATEINFO;

typedef enum _SnapinType
{
	SNAPINTYPE_DS = 0,
	SNAPINTYPE_DSEX,
	SNAPINTYPE_SITE,
	SNAPINTYPE_NUMTYPES
} SnapinType;

extern int ResourceIDForSnapinType[SNAPINTYPE_NUMTYPES];

class CUINode;

struct INTERNAL 
{
  INTERNAL() 
  { 
    m_type = CCT_UNINITIALIZED; 
    m_cookie = NULL; 
    m_cookie_count = 0;
    m_p_cookies = NULL;
    m_snapintype = SNAPINTYPE_DS; 
  };
  ~INTERNAL() {}
  
  DATA_OBJECT_TYPES   m_type;     // What context is the data object.
  CUINode*            m_cookie;   // What object the cookie represents
  CString             m_string;
  SnapinType	        m_snapintype;
  CLSID               m_clsid;
  DWORD               m_cookie_count; // > 1 if multi-select
  CUINode**           m_p_cookies;    //rest of cookies here, as array
};


///////////////////////////////////////////////////
// NT 5.0 style ACL manipulation API's

#include <aclapi.h>

///////////////////////////////////////////////////
// Security Identity Mapping (SIM) Stuff
// Must include file "\nt\public\sdk\inc\wincrypt.h"
#include <wincrypt.h>  // CryptDecodeObject() found in crypt32.lib


// REVIEW_MARCOC:
// this is to allow new MMC interfaces and code based on
// the new ISnapinProperty (and related) interfaces
// comment/uncomment it to change functionality
//#define _MMC_ISNAPIN_PROPERTY

//
// REVIEW_JEFFJON : this is to enable inetOrgPerson to behave like a user class object
//                  For more information talk to JC Cannon
//
#define INETORGPERSON


//
// This is to enable profiling through the macros defined in profile.h
// Profile.h will turn on profiling if MAX_PROFILING_ENABLED is defined
// NOTE : profiling as implemented by profile.h does not work well with
//        multiple instances of the same snapin in one MMC console
//
#ifdef MAX_PROFILING_ENABLED
#pragma warning(push, 3)
   #include <list>
   #include <vector>
   #include <stack>
   #include <map>
   #include <algorithm>
#pragma warning (pop)
#endif
#include "profile.h"

#include "MyBasePathsInfo.h"

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\simutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       simutil.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
//	SimUtil.cpp
//
//	Utilities routines specific to the Security Identity Mapping project.
//
//	HISTORY
//	25-Jun-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "common.h"

const TCHAR szDefaultCertificateExtension[] = _T("cer");	// Not subject to localization

/////////////////////////////////////////////////////////////////////
//	UiGetCertificateFile()
//
//	Invoke the common dialog to get a certificate file.
//
//	Return FALSE if the user clicked on cancel button.
//
BOOL
UiGetCertificateFile(
	CString * pstrCertificateFilename)	// OUT: Name of the certificate file
{
	ASSERT(pstrCertificateFilename !=	NULL);

	BOOL	bResult = FALSE;
	CString strFilter;
	VERIFY( strFilter.LoadString(IDS_SIM_CERTIFICATE_FILTER) );
	CFileDialog* pDlg = new CFileDialog (
		TRUE,				// Open File
		szDefaultCertificateExtension,	// lpszDefExt
		NULL,				// lpszFileName
		OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,
		strFilter);			// lpszFilter 
	if ( pDlg )
	{
		CString strCaption;
		VERIFY( strCaption.LoadString(IDS_SIM_ADD_CERTIFICATE) );
		pDlg->m_ofn.lpstrTitle = (LPCTSTR)strCaption;

		if (pDlg->DoModal() == IDOK)
		{
			// Copy the string
			*pstrCertificateFilename = pDlg->GetPathName();
			bResult = TRUE;
		}

		delete pDlg;
	}


	return bResult;
} // UiGetCertificateFile()


/////////////////////////////////////////////////////////////////////
//	strSimToUi()
//
//	Convert a SIM string into a format the user understand.
//
//	The routine will remove any quotes and expand any escape characters
//	to a format friendly to the user.
//
void strSimToUi(
	LPCTSTR pszSIM,		// IN:
	CString * pstrUI)	// OUT:
{
	ASSERT(pszSIM != NULL);
	ASSERT(pstrUI != NULL);

	// Find out if the string contains a quote
	if (!wcschr(pszSIM, '"'))
	{
		// No quote found, so return the original string
		*pstrUI = pszSIM;
		return;
	}
	pstrUI->Empty();
	while (TRUE)
	{
		if (*pszSIM == '"')
		{
			pszSIM++;
		}
		if (*pszSIM == '\0')
			break;
		*pstrUI += *pszSIM++;
	} // while
} // strSimToUi()


/////////////////////////////////////////////////////////////////////
//	strUiToSim()
//
//	Convert a string typed by the user to a valid SIM format.
//
//	If the UI string contains special characters, the routine
//	will add quotes and other escape characters wherever necessary.
//
//	BACKGROUND INFORMATION
//	From the CryptoAPI SDK
//	Quote the RDN value if it contains leading or trailing
//	white space or one of the following characters:
//		",", "+", "=", """, "\n",  "<", ">", "#" or ";".
//	The quoting character is ". If the RDN Value contains a " it is double quoted ("").
//
void strUiToSim(
	LPCTSTR pszUI,		// IN:
	CString * pstrSIM)	// OUT:
{
	ASSERT(pszUI != NULL);
	ASSERT(pstrSIM != NULL);

  //
	// String containing special characters 
  //
	static const TCHAR szSpecialCharacters[] = _T(",+=<>#;\"\n");

  //
	// Skip the leading spaces
  //
	while (*pszUI == _T(' '))
  {
		pszUI++;
  }
	const TCHAR * pszDataString = pszUI;

  //
	// Find out wherever the string needs to be surrounded by quotes
  //
	const TCHAR * pchFirstSpecialToken = wcspbrk(pszUI, szSpecialCharacters);
	if (pchFirstSpecialToken != NULL && *pchFirstSpecialToken == '=')
	{
		pszDataString = pchFirstSpecialToken;
		pchFirstSpecialToken = wcspbrk(pchFirstSpecialToken + 1, szSpecialCharacters);
	}
	BOOL fNeedQuotes = (pchFirstSpecialToken != NULL) || 
			(pszDataString[0] == _T(' ')) || 
			(pszDataString[lstrlen(pszDataString)] == _T(' '));
	if (!fNeedQuotes)
	{
		*pstrSIM = pszUI;
		return;
	}
	pstrSIM->Empty();
	const TCHAR * pchSrc = pszUI;
	ASSERT(pszDataString != NULL);
	if (*pszDataString == '=')
	{
		// Copy string until the equal '=' sign
		ASSERT(pszDataString >= pchSrc);
		for (int cch = (int)((pszDataString - pchSrc) + 1); cch > 0; cch--)
		{
			ASSERT(*pchSrc != '\0' && "Unexpected end of string");
			*pstrSIM += *pchSrc++;
		}
	} // if
	// Add the openning quote
	*pstrSIM += '"';
	for ( ; *pchSrc != '\0'; pchSrc++)
	{
		if (*pchSrc == '"')
			*pstrSIM += '"';	// Add one more quote for each quote
		*pstrSIM += *pchSrc;
	} // while
	// Add the tailing quote
	*pstrSIM += '"';
} // strUiToSim()


//	Macro to make pointer 'DWORD aligned'
#define ALIGN_NEXT_DWORD_PTR(pv)		(( ((INT_PTR)(pv)) + 3) & ~3)


/////////////////////////////////////////////////////////////////////
//	ParseSimString()
//
//	Parse a SIM string into an array of zero-terminated string.
//
//	RETURN
//	Return a pointer to an allocated array of pointers to strings.
//	The array of pointers allocated with the new() operator,
//	therefore the caller must call ONCE delete() to free the memory.
//	The routine may return NULL if the input string has a syntax error.
//
//	INTERFACE NOTES
//	The format returned is the same as the API CommandLineToArgvW()
//	which is the same as main(int argc, char * argv[]).
//	- This routine will handle special characters such as quotes and
//	  commas that are embedded into strings.
//
//	EXTRA INFO
//	See strSimToUi() and strUiToSim().
//
//	EXAMPLE
//	LPTSTR * pargzpsz;	// Pointer to allocated array of pointer to strings
//	pargzpsz = ParseSimString("X509:<I>L=Internet<S>C=US, O=Microsoft, OU=DBSD, CN=Bob Bitter");
//	... The output will be 
//			"X509:"
//			"<I>"
//			"L=Internet"
//			"<S>"
//			"C=US"
//			"O=Microsoft"
//			"OU=DBSD"
//			"CN=Bob Bitter"
//	delete pargzpsz;
//
LPTSTR * 
ParseSimString(
	LPCTSTR szSimString,	// IN: String to parse
	int * pArgc)			// OUT: OPTIONAL: Argument count
	{
	ASSERT(szSimString != NULL);
	Endorse(pArgc == NULL);

	// Compute how much memory is needed for allocation.
	// The computation may allocate more memory than necessary depending
	// on the input string.
	CONST TCHAR * pchSrc;
	int cch = 0;
	int cStringCount = 2;		// Estimate of the number of strings
	for (pchSrc = szSimString; *pchSrc != _T('\0'); pchSrc++, cch++)
		{
		// Search for any character that will make a new string
		switch (*pchSrc)
			{
		case _T(':'):	// Colon
		case _T('<'):	// Angle bracket
		case _T('>'):	// Angle bracket
		case _T(','):	// Comma
			cStringCount++;
			break;
			} // switch
		} // for
	// Extra space for pointers and DWORD alignment
	cch += cStringCount * (2 * sizeof(TCHAR *)) + 16;

	// Allocate a single block of memory for all the data
	LPTSTR * pargzpsz = (LPTSTR *)new TCHAR[cch];
	ASSERT(pargzpsz != NULL && "new() should throw");
	TCHAR * pchDst = (TCHAR *)&pargzpsz[cStringCount+1];
#ifdef DEBUG
	DebugCode( int cStringCountT = cStringCount; )
#endif
	pargzpsz[0] = pchDst;
	pchSrc = szSimString;
	cStringCount = 0;
	int cchString = 0;

	// Scan the rest of the string
	TCHAR chSpecial = 0;
	while (TRUE)
		{
		// Make a new string
		*pchDst = '\0';
		if (cchString > 0)
			{
			pchDst++;
			pchDst = (TCHAR *)ALIGN_NEXT_DWORD_PTR(pchDst);
			pargzpsz[++cStringCount] = pchDst;
			cchString = 0;
			}
		*pchDst = '\0';

		if (chSpecial)
			{
			switch (chSpecial)
				{
			case _T('<'):
				for ( ; ; pchSrc++)
					{
					if (*pchSrc == '\0')
						goto Error;		// Unexpected end of string
					*pchDst++ = *pchSrc;
					cchString++;
					if (*pchSrc == _T('>'))
						{
						pchSrc++;
						break;
						}
					} // for
				break;
			case _T(','):
				while (*++pchSrc == _T(' '))
					;	// Skip the blanks
				break;	// Make a new string
				} // switch
			chSpecial = 0;
			continue;
			} // if
		
		while (chSpecial == '\0')
			{
			switch (*pchSrc)
				{
			case _T('\0'):
				goto Done;
			case _T('<'):
			case _T(','):
				chSpecial = *pchSrc;
				break;
			case _T(':'):
				*pchDst++ = *pchSrc++;
				cchString++;
				if (cStringCount == 0)
					chSpecial = _T(':');
				break;
			case _T('"'):	// The string contains quotes
				cchString++;
				*pchDst++ = *pchSrc++;	// Copy the first quiote
				if (*pchDst == _T('"'))
					{
					// Two consecutive quotes
					*pchDst++ = *pchSrc++;
					break;
					}
				// Skip until the next quote
				while (TRUE)
					{
					if (*pchSrc == _T('\0'))
						goto Error;	// Unexpected end of string
					if (*pchSrc == _T('"'))
						{
						*pchDst++ = *pchSrc++;
						break;
						}
					*pchDst++ = *pchSrc++;
					}
				break;
			default:
				*pchDst++ = *pchSrc++;
				cchString++;
				} // switch
			} // while
		} // while

Done:
	*pchDst = '\0';
	if (cchString > 0)
		cStringCount++;
#ifdef DEBUG
	ASSERT(cStringCount <= cStringCountT);
#endif
	pargzpsz[cStringCount] = NULL;
	if (pArgc != NULL)
		*pArgc = cStringCount;
	return pargzpsz;
Error:
	TRACE1("ParseSimString() - Error parsing string %s.\n", szSimString);
	delete pargzpsz;
	return NULL;
	} // ParseSimString()


/////////////////////////////////////////////////////////////////////
//	UnparseSimString()
//
//	This is the opposite of ParseSimString().  This routine
//	will concacenate an array of strings to produce
//	a single long SIM string.
//
//	INTERFACE NOTES
//	This toutine will concatenate the array of strings to the
//	existing CString object.
//
void
UnparseSimString(
	CString * pstrOut,			// INOUT: Pointer to concatenated string
	const LPCTSTR rgzpsz[])		// IN: Array of pointer to strings
	{
	ASSERT(rgzpsz != NULL);
	ASSERT(pstrOut != NULL);

	for (int i = 0; rgzpsz[i] != NULL; i++)
		{
		if (i > 0)
			*pstrOut += ",";
		*pstrOut += rgzpsz[i];
		} // for
	} // UnparseSimString()


/////////////////////////////////////////////////////////////////////
//	ParseSimSeparators()
//
//	Break up an array of pointer to string to sub-array
//	of pointer to string for Issuer, Subject and AltSubject.
//
//	INTERFACE NOTES
//	The output parameters must have enough storage to hold
//	the substrings.
//
void
ParseSimSeparators(
	const LPCTSTR rgzpszIn[],	// IN: Array of pointer to string			
	LPCTSTR rgzpszIssuer[],		// OUT: Substrings for Issuer
	LPCTSTR rgzpszSubject[],	// OUT: Substrings for Subject
	LPCTSTR rgzpszAltSubject[])	// OUT: Substrings for AltSubject
	{
	ASSERT(rgzpszIn != NULL);
	Endorse(rgzpszIssuer == NULL);
	Endorse(rgzpszSubject == NULL);
	Endorse(rgzpszAltSubject == NULL);

	if (rgzpszIssuer != NULL)
		{
		// Get the substrings for Issuer
		(void)FindSimAttributes(szSimIssuer, IN rgzpszIn, OUT rgzpszIssuer);
		}
	if (rgzpszSubject != NULL)
		{
		// Get the substrings for Subject
		(void)FindSimAttributes(szSimSubject, IN rgzpszIn, OUT rgzpszSubject);
		}
	if (rgzpszAltSubject != NULL)
		{
		// Get the substrings for AltSubject
		(void)FindSimAttributes(szSimAltSubject, IN rgzpszIn, OUT rgzpszAltSubject);
		}
	} // ParseSimSeparators()


/////////////////////////////////////////////////////////////////////
//	UnparseSimSeparators()
//
//	Append the strings for Issuer, Subject and AltSubject into
//	a single string.
//
//	INTERFACE NOTES
//	The routine will append to the existing CString object.
//
int
UnparseSimSeparators(
	CString * pstrOut,				// INOUT: Pointer to contatenated string
	const LPCTSTR rgzpszIssuer[],
	const LPCTSTR rgzpszSubject[],
	const LPCTSTR rgzpszAltSubject[])
	{
	ASSERT(pstrOut != NULL);
	int cSeparators = 0;		// Number of separators added to the contatenated string

	if (rgzpszIssuer != NULL && rgzpszIssuer[0] != NULL)
		{
		cSeparators++;
		*pstrOut += szSimIssuer;
		UnparseSimString(OUT pstrOut, rgzpszIssuer);
		}
	if (rgzpszSubject != NULL && rgzpszSubject[0] != NULL)
		{
		cSeparators++;
		*pstrOut += szSimSubject;
		UnparseSimString(OUT pstrOut, rgzpszSubject);
		}
	if (rgzpszAltSubject != NULL && rgzpszAltSubject[0] != NULL)
		{
		cSeparators++;
		*pstrOut += szSimAltSubject;
		UnparseSimString(OUT pstrOut, rgzpszAltSubject);
		}
	return cSeparators;
	} // UnparseSimSeparators()


/////////////////////////////////////////////////////////////////////
//	PchFindSimAttribute()
//
//	Search an array of strings for a given tag and an attribute.
//
//	Return pointer to string containing the attribute.  Routine
//	may return NULL if attribute is not found within the tags.
//
//	INTERFACE NOTES
//	The routine assumes that all tags start with an openning bracket '<'.
//
//	EXAMPLE
//	LPCTSTR pszIssuer = PchFindSimAttribute(pargzpsz, "<I>", "OU=");
//
LPCTSTR PchFindSimAttribute(
	const LPCTSTR rgzpsz[],		// IN: Array of pointer to strings
	LPCTSTR pszSeparatorTag,	// IN: Tag to search. eg: "<I>", "<S>" and "<AS>"
	LPCTSTR pszAttributeTag)	// IN: Attribute to searc for. eg: "CN=", "OU="
{
	ASSERT(rgzpsz != NULL);
	ASSERT(pszSeparatorTag != NULL);
	ASSERT(pszAttributeTag != NULL);
    size_t nLenAttrTag = wcslen (pszAttributeTag);

	for (int i = 0; rgzpsz[i] != NULL; i++)
	{
		if (_wcsicmp(pszSeparatorTag, rgzpsz[i]) != 0)
			continue;
		
		for (++i; ; i++)
		{
			if (rgzpsz[i] == NULL)
				return NULL;
			if (rgzpsz[i][0] == _T('<'))
			{
				// We have found another separator tag
				break;
			}
			if (_wcsnicmp(pszAttributeTag, rgzpsz[i], nLenAttrTag) == 0)
			{
				return rgzpsz[i];
			}
		} // for
	} // for
	return NULL;
} // PchFindSimAttribute()


/////////////////////////////////////////////////////////////////////
//	FindSimAttributes()
//
//	Search an array of strings for a given tag.  Fill an array of
//	strings that belongs to the tag.
//
//	Return number of strings belonging to the tab (which is
//	the length of rgzpszOut).
//
//	INTERFACE NOTES
//	This routine assumes parameter rgzpszOut has enough storage
//	to hold all the strings for the tag.  It is recommended to make
//	rgzpszOut the same length as rgzpszIn (for safety).
//	- The output array does not include the tag.
//
int FindSimAttributes(
	LPCTSTR pszSeparatorTag,	// IN: Tag to search. eg: "<I>", "<S>" and "<AS>"
	const LPCTSTR rgzpszIn[],	// IN: Array of pointer to strings
	LPCTSTR rgzpszOut[])		// OUT: Output array of pointer to strings for tag
{
	ASSERT(pszSeparatorTag != NULL);
	ASSERT(rgzpszIn != NULL);
	ASSERT(rgzpszOut != NULL);

	BOOL fTagFound = FALSE;
	int iOut = 0;	// Index for the output array
	for (int iIn = 0; rgzpszIn[iIn] != NULL; iIn++)
	{
		const LPCTSTR pszT = rgzpszIn[iIn];
		if (pszT[0] == '<')
		{
      fTagFound = (_wcsicmp(pszSeparatorTag, pszT) == 0) ? TRUE : FALSE;
		}
		else if (fTagFound)
		{
			rgzpszOut[iOut++] = pszT;
		}
	} // for
	rgzpszOut[iOut] = NULL;
	return iOut;
} // FindSimAttributes()


/////////////////////////////////////////////////////////////////////
//	SplitX509String()
//
//	Split a X509 string into its Issuer, Subject and AltSubject.
//
//	Return a pointer to an allocated array of pointers to strings allocated
//	by ParseSimString().
//
//	INTERFACE NOTES
//	As the hungarian name implies, the output parameters
//	are pointers to allcated arrays of substrings for the
//	Issuer, Subject and AltSubject respectively.
//	- The caller is responsible of freeing the memory for
//	both the return value and all the output parameters.
//
//
LPTSTR *
SplitX509String(
	LPCTSTR pszX509,					// IN: String to split
	LPCTSTR * ppargzpszIssuer[],		// OUT: Pointer to allocated array of Substrings for Issuer
	LPCTSTR * ppargzpszSubject[],		// OUT: Pointer to allocated array of Substrings for Subject
	LPCTSTR * ppargzpszAltSubject[])	// OUT: Pointer to allocated array of Substrings for AltSubject
	{
	ASSERT(pszX509 != NULL);
	Endorse(ppargzpszIssuer == NULL);
	Endorse(ppargzpszSubject == NULL);
	Endorse(ppargzpszAltSubject == NULL);

	LPTSTR * pargzpsz;	// Pointer to allocated array of pointer to strings
	int cNumStr;		// Number of strings
	pargzpsz = ParseSimString(IN pszX509, OUT &cNumStr);
	if (pargzpsz == NULL)
		{
		TRACE1("SplitX509String() - Error parsing string %s.\n", pszX509);
		return NULL;
		}
	ASSERT(cNumStr > 0);

	if (ppargzpszIssuer != NULL)
		{
		*ppargzpszIssuer = new LPCTSTR[cNumStr];
		// Get the substrings for Issuer
		(void)FindSimAttributes(szSimIssuer, IN pargzpsz, OUT *ppargzpszIssuer);
		}
	if (ppargzpszSubject != NULL)
		{
		*ppargzpszSubject = new LPCTSTR[cNumStr];
		// Get the substrings for Subject
		(void)FindSimAttributes(szSimSubject, IN pargzpsz, OUT *ppargzpszSubject);
		}
	if (ppargzpszAltSubject != NULL)
		{
		*ppargzpszAltSubject = new LPCTSTR[cNumStr];
		// Get the substrings for AltSubject
		(void)FindSimAttributes(szSimAltSubject, IN pargzpsz, OUT *ppargzpszAltSubject);
		}
	return pargzpsz;
	} // SplitX509String()


/////////////////////////////////////////////////////////////////////
int
UnsplitX509String(
	CString * pstrX509,					// OUT: Concatenated string
	const LPCTSTR rgzpszIssuer[],		// IN:
	const LPCTSTR rgzpszSubject[],		// IN:
	const LPCTSTR rgzpszAltSubject[])	// IN:
{
	ASSERT(pstrX509 != NULL);
	*pstrX509 = szX509;
	return UnparseSimSeparators(
		INOUT pstrX509,
		IN rgzpszIssuer,
		IN rgzpszSubject,
		IN rgzpszAltSubject);
} // UnsplitX509String()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\uinode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      uinode.h
//
//--------------------------------------------------------------------------

#ifndef __UINODE_
#define __UINODE_

// simple macro to do RTTI checking

#define IS_CLASS(x,y) (typeid(x) == typeid(y))

#include "dscolumn.h"

// FWD DECL
class CDSComponentData;
class CContextMenuVerbs;
class CInternalFormatCracker;


//
/////////////////////////////////////////////////////////////////////////////
// CThreadQueryInfo: base class for providing query information to post
// to worker threads, need to derive from it

class CThreadQueryInfo
{
public:
  CThreadQueryInfo()
  {
    m_nMaxItemCount = 0;
    m_bTooMuchData = FALSE;
  }
  virtual ~CThreadQueryInfo(){}

private:
  //
  // Do nothing copy constructor and operator =
  //
  CThreadQueryInfo(CThreadQueryInfo&) {}
  CThreadQueryInfo& operator=(CThreadQueryInfo&) {}

public:
  void SetMaxItemCount(UINT nMaxItemCount)
  {
    ASSERT(nMaxItemCount > 0);
    m_nMaxItemCount = nMaxItemCount;
  }
  UINT GetMaxItemCount() 
  { 
    ASSERT(m_nMaxItemCount > 0);
    return m_nMaxItemCount;
  }

public:
  BOOL m_bTooMuchData;
private:
  UINT m_nMaxItemCount;
};



////////////////////////////////////////////////////////////////////
// CNodeData: base class for node specific information for the 
//  MMC UI node, need to derive from it

class CNodeData
{
public:
  virtual ~CNodeData(){}

protected:
  CNodeData(){}; // make it protected to force a derivation
private:
  //
  // Do nothing copy constructor and operator =
  //
  CNodeData& operator=(CNodeData&) {}
};


////////////////////////////////////////////////////////////////////
// CUINodeList: list of node items (child nodes of a folder)

class CUINode; // fwd decl
typedef CList <CUINode *, CUINode*> CUINodeList;


////////////////////////////////////////////////////////////////////
// CUIFolderInfo: for folder specific data
#define SERIALNUM_NOT_TOUCHED 0x7fffffff

class CUIFolderInfo
{
public:
  CUIFolderInfo(CUINode* pUINode);
  CUIFolderInfo(const CUIFolderInfo& copyFolder);
  ~CUIFolderInfo()
  {
    DeleteAllContainerNodes();
    DeleteAllLeafNodes();
  }
protected:
  CUIFolderInfo() {}
private:
  //
  // Do nothing copy constructor and operator =
  //
  CUIFolderInfo& operator=(CUIFolderInfo&) {}

public:
  // Node management methods
  void DeleteAllContainerNodes();
  void DeleteAllLeafNodes();

  HRESULT AddNode(CUINode* pUINode);
  HRESULT AddListofNodes(CUINodeList* pNodeList);
  HRESULT DeleteNode(CUINode* pUINode); // deletes node 
  HRESULT RemoveNode(CUINode* pUINode); // leaves node intact.
  

  virtual CDSColumnSet* GetColumnSet(PCWSTR pszClass, CDSComponentData* pCD);
  void SetColumnSet(CDSColumnSet* pColumnSet)
  {
    if (m_pColumnSet != NULL)
    {
      delete m_pColumnSet;
    }
    m_pColumnSet = pColumnSet;
  }

  void SetSortOnNextSelect(BOOL bSort = TRUE) { m_bSortOnNextSelect = bSort; }
  BOOL GetSortOnNextSelect() { return m_bSortOnNextSelect; }

  void SetScopeItem(HSCOPEITEM hScopeItem) { m_hScopeItem = hScopeItem;}
  HSCOPEITEM GetScopeItem() { return m_hScopeItem; }

  // methods for expanded once flag
  BOOL IsExpanded() {	return m_bExpandedOnce; }
  void SetExpanded() { m_bExpandedOnce = TRUE; }
  void ReSetExpanded() { m_bExpandedOnce = FALSE; }

  // methods to manage LRU serial number
  void UpdateSerialNumber(CDSComponentData* pCD);
  UINT GetSerialNumber(void) { return m_SerialNumber; }
  static const UINT nSerialNomberNotTouched;


  // methods to manage cached object count
  void AddToCount(UINT increment);
  void SubtractFromCount(UINT decrement);
  void ResetCount() { m_cObjectsContained = 0;}
  UINT GetObjectCount() { return m_cObjectsContained; }

  void SetTooMuchData(BOOL bSet, UINT nApproximateTotal);
  BOOL HasTooMuchData() { return m_bTooMuchData; }
  UINT GetApproxTotalContained() { return m_nApproximateTotalContained; }

  CUINode* GetParentNode(); 
  CUINodeList* GetLeafList() { return &m_LeafNodes; } 
  CUINodeList* GetContainerList() { return &m_ContainerNodes; } 

  void SetNode(CUINode* pUINode) { m_pUINode = pUINode; }

private:
  CUINode*      m_pUINode;            // node the this folder info belong to
  CUINodeList   m_ContainerNodes;     // list of child folder nodes
  CUINodeList   m_LeafNodes;          // list of child leaf nodes

  CDSColumnSet* m_pColumnSet;         // Column set assigned to this container

  HSCOPEITEM    m_hScopeItem;         // handle from MMC tree control
  BOOL          m_bExpandedOnce;      // expansion flag
  UINT          m_cObjectsContained;  // THIS is how many objects are here.
  UINT          m_SerialNumber;       // LRU value for scavenging folders
  
  BOOL          m_bTooMuchData;       // Flag to specify when the container has hit the TooMuchData limit
  int           m_nApproximateTotalContained; // The approximate count of objects in this container retrieved from the msDS-Approx-Immed-Subordinates attribute

  BOOL          m_bSortOnNextSelect;  // Used to determine whether we should sort this container when it is selected next
};




////////////////////////////////////////////////////////////////////
// CUINode: objects inserted in the MMC UI, the same class is used
// for the scope pane and the result pane. The presence of folder
// info makes it a container


class CUINode
{
public:
  CUINode(CUINode* pParentNode = NULL);
  CUINode(const CUINode& copyNode);
  virtual ~CUINode();

private:
  //
  // Do nothing copy constructor and operator =
  //
  CUINode& operator=(CUINode&) {}

public:

  // Value management functions (to be overritten)
  virtual void SetName(LPCWSTR lpszName) = 0;
  virtual LPCWSTR GetName() = 0;

  virtual void SetDesc(LPCWSTR lpszDesc) = 0;
  virtual LPCWSTR GetDesc() = 0;

  virtual int GetImage(BOOL bOpen) = 0;
  virtual GUID* GetGUID() = 0; 

  virtual LPCWSTR GetDisplayString(int nCol, CDSColumnSet*)
  {
    if (nCol == 0)
      return GetName();
    else if (nCol == 1)
      return GetDesc();
    return L"";
  }

  CNodeData* GetNodeData()
  {
    return m_pNodeData;
  }
  CUIFolderInfo* GetFolderInfo()
  {
    ASSERT(m_pFolderInfo != NULL); // must check using IsContainer()
    return m_pFolderInfo;
  }
  BOOL IsContainer() { return m_pFolderInfo != NULL;}
  BOOL IsSnapinRoot() { return m_pParentNode == NULL;}

  void MakeContainer()
  {
    ASSERT(!IsContainer());
    m_pFolderInfo = new CUIFolderInfo(this);
  }

  virtual CDSColumnSet* GetColumnSet(CDSComponentData* pComponentData);

  void IncrementSheetLockCount();
  void DecrementSheetLockCount();
  BOOL IsSheetLocked() { return (m_nSheetLockCount > 0);}

  void SetExtOp(int opcode) { m_extension_op=opcode;}
  DWORD GetExtOp() { return m_extension_op; }

  virtual BOOL IsRelative(CUINode* pUINode);

  CUINode* GetParent() { return m_pParentNode; }
  void ClearParent() { m_pParentNode = NULL; }
  void SetParent(CUINode* pParentNode) { m_pParentNode = pParentNode; }

  //
  // These set the state of the standard context menu items
  //
  virtual BOOL IsDeleteAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsRenameAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsRefreshAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL ArePropertiesAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsCutAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsCopyAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsPasteAllowed(CDSComponentData* pComponentData, BOOL* pbHide);
  virtual BOOL IsPrintAllowed(CDSComponentData* pComponentData, BOOL* pbHide);

  virtual CContextMenuVerbs* GetContextMenuVerbsObject(CDSComponentData* pComponentData);
  virtual HRESULT OnCommand(long, CDSComponentData*) { return S_OK; }

  virtual BOOL HasPropertyPages(LPDATAOBJECT) { return FALSE; }

  virtual HRESULT Delete(CDSComponentData* pComponentData);
  virtual HRESULT DeleteMultiselect(CDSComponentData* pComponentData, CInternalFormatCracker* pObjCracker);
  virtual HRESULT Rename(LPCWSTR lpszNewName, CDSComponentData* pComponentData);
  virtual void    Paste(IDataObject*, CDSComponentData*, LPDATAOBJECT*) {}
  virtual HRESULT QueryPaste(IDataObject*, CDSComponentData*) { return S_FALSE; }

  virtual HRESULT CreatePropertyPages(LPPROPERTYSHEETCALLBACK,
                                      LONG_PTR,
                                      LPDATAOBJECT,
                                      CDSComponentData*) { return S_FALSE; }

protected:
  CNodeData*      m_pNodeData;        // node specific information
  CContextMenuVerbs* m_pMenuVerbs;    // Context menus

private:
  CUIFolderInfo*  m_pFolderInfo;      // container specific information
  CUINode*        m_pParentNode;      // back pointer to the parent node
  ULONG           m_nSheetLockCount;  // sheet lock counter
 
  int         m_extension_op;
};



////////////////////////////////////////////////////////////////////
// CUINodeTableBase: base class to support locking of nodes

class CUINodeTableBase
{
public:
  CUINodeTableBase();
  ~CUINodeTableBase();
private:
  //
  // Do nothing copy constructor and operator =
  //
  CUINodeTableBase(CUINodeTableBase&) {}
  CUINodeTableBase& operator=(CUINodeTableBase&) {}

public:

  void Add(CUINode* pNode);
  BOOL Remove(CUINode* pNode);
  BOOL IsPresent(CUINode* pNode);
  void Reset();
  UINT GetCount();

protected:
  UINT m_nEntries;
  CUINode** m_pCookieArr;
};

////////////////////////////////////////////////////////////////////
// CUINodeQueryTable

class CUINodeQueryTable : public CUINodeTableBase
{
public:
  CUINodeQueryTable() {}
  void RemoveDescendants(CUINode* pNode);
  BOOL IsLocked(CUINode* pNode);

private:
  CUINodeQueryTable(const CUINodeQueryTable&) {}
  CUINodeQueryTable& operator=(const CUINodeQueryTable&) {}
};

////////////////////////////////////////////////////////////////////
// CUINodeSheetTable

class CUINodeSheetTable : public CUINodeTableBase
{
public:
  CUINodeSheetTable() {}
  void BringToForeground(CUINode* pNode, CDSComponentData* pCD, BOOL bActivate);
private:
  CUINodeSheetTable(const CUINodeSheetTable&) {}
  CUINodeSheetTable& operator=(const CUINodeSheetTable&) {}
};



/////////////////////////////////////////////////////////////////////////////
// CGenericUINode : generic UI node, not corresponding to a DS object

class CGenericUINode : public CUINode
{
public:
  CGenericUINode(CUINode* pParentNode = NULL);
  CGenericUINode(const CGenericUINode& copyNode);
private:
  //
  // Do nothing copy constructor and operator =
  //
  CGenericUINode& operator=(CGenericUINode&) {}

public:

  // override of pure virtual functions
  virtual void SetName(LPCWSTR lpszName) { m_strName = lpszName;}
  virtual LPCWSTR GetName() { return m_strName; }
  
  virtual void SetDesc(LPCWSTR lpszDesc) { m_strDesc = lpszDesc;}
  virtual LPCWSTR GetDesc() { return m_strDesc; }

  int GetImage(BOOL) { return m_nImage; }
  virtual GUID* GetGUID() { return (GUID*)&GUID_NULL; } 

  virtual HRESULT XMLSave(IXMLDOMDocument*, IXMLDOMNode**) { return S_OK;}

  HRESULT XMLSaveBase(IXMLDOMDocument* pXMLDoc,
                                    IXMLDOMNode* pXMLDOMNode);

  static LPCWSTR g_szNameXMLTag;
  static LPCWSTR g_szDecriptionXMLTag;
  static LPCWSTR g_szDnXMLTag;

  virtual void InvalidateSavedQueriesContainingObjects(CDSComponentData* /*pComponentData*/,
                                                       const CStringList& /*refDNList*/) {}

private:
  CString m_strName;
  CString m_strDesc;
  int m_nImage;

};

/////////////////////////////////////////////////////////////////////////////
// CRootNode: root of the namespace

class CRootNode : public CGenericUINode
{
public:
  CRootNode()
  {
    MakeContainer();
  }

private:
  //
  // Do nothing copy constructor and operator =
  //
  CRootNode(CRootNode&) {}
  CRootNode& operator=(CRootNode&) {}

public:

  LPCWSTR GetPath() { return m_szPath;}
  void SetPath(LPCWSTR lpszPath) { m_szPath = lpszPath;}

  //
  // These set the state of the standard context menu items
  //
  virtual BOOL IsRefreshAllowed(CDSComponentData* pComponentData, BOOL* pbHide);

  virtual CContextMenuVerbs* GetContextMenuVerbsObject(CDSComponentData* pComponentData);
  virtual HRESULT OnCommand(long lCommandID, CDSComponentData* pComponentData);

private:
  CString m_szPath;
};



#endif // __UINODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\uinode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      DSCookie.cpp
//
//  Contents:  TBD
//
//  History:   02-Oct-96 WayneSc    Created
//
//--------------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"

#include "uinode.h"
#include "dscmn.h"    // CrackName()

#include "ContextMenu.h"
#include "dsfilter.h"
#include "xmlutil.h"
#include <notify.h>



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



////////////////////////////////////////////////////////////////////
// CUIFolderInfo

const UINT CUIFolderInfo::nSerialNomberNotTouched = 0x7fffffff;

CUIFolderInfo::CUIFolderInfo(CUINode* pUINode)
{
  ASSERT(pUINode != NULL);
  m_pUINode = pUINode;
  m_hScopeItem = NULL;
  m_bExpandedOnce = FALSE;
  m_cObjectsContained = 0;
  m_SerialNumber = SERIALNUM_NOT_TOUCHED;
  m_pColumnSet = NULL;
  m_bTooMuchData = FALSE;
  m_nApproximateTotalContained = 0;
  m_bSortOnNextSelect = FALSE;
}

CUIFolderInfo::CUIFolderInfo(const CUIFolderInfo&)
{
  //
  // The node is probably still being created so don't copy it
  //
  m_pUINode = NULL;

  //
  // Don't copy the scope item
  //
  m_hScopeItem = 0;

  //
  // Don't mark as expanded
  //
  m_bExpandedOnce = FALSE;

  //
  // Shouldn't contain any object either
  //
  m_cObjectsContained = 0;
  m_SerialNumber = SERIALNUM_NOT_TOUCHED;
  m_pColumnSet = NULL;

  m_bTooMuchData = FALSE;
  m_nApproximateTotalContained = 0;
  m_bSortOnNextSelect = FALSE;
}

CDSColumnSet* CUIFolderInfo::GetColumnSet(PCWSTR pszClass, CDSComponentData* pCD)
{
  if (m_pColumnSet == NULL)
  {
    ASSERT(pCD != NULL);
    if (_wcsicmp(m_pUINode->GetName(), L"ForeignSecurityPrincipals") == 0)
    {
      m_pColumnSet = pCD->FindColumnSet(L"ForeignSecurityPrincipals");
    }
    else
    {
      m_pColumnSet = pCD->FindColumnSet(pszClass);
    }
    ASSERT(m_pColumnSet != NULL);
  }
  return m_pColumnSet;
}

void CUIFolderInfo::UpdateSerialNumber(CDSComponentData * pCD)
{ 
  m_SerialNumber = pCD->GetSerialNumber(); 
  //  TRACE(_T("cookie (%s)serial number updated: %d.\n"),
  //      m_strName, m_SerialNumber);
  CUINode* pParentNode = GetParentNode();
  if (pParentNode != NULL) 
    pParentNode->GetFolderInfo()->UpdateSerialNumber(pCD); 
}

void CUIFolderInfo::AddToCount(UINT increment)
{
  m_cObjectsContained += increment;
  //  TRACE(_T("cookie (%s) count increased to: %d.\n"),
  //      m_strName, m_cObjectsContained);
  CUINode* pParentNode = GetParentNode();
  if (pParentNode != NULL) 
    pParentNode->GetFolderInfo()->AddToCount(increment); 
}

void CUIFolderInfo::SubtractFromCount(UINT decrement)
{
  if (m_cObjectsContained == 0) 
    return;
  m_cObjectsContained -= decrement;
  //  TRACE(_T("cookie (%s) count decreased to: %d.\n"),
  //      m_strName, m_cObjectsContained);
  CUINode* pParentNode = GetParentNode();
  if (pParentNode != NULL) 
    pParentNode->GetFolderInfo()->SubtractFromCount(decrement); 
}

CUINode* CUIFolderInfo::GetParentNode() 
{ 
  ASSERT(m_pUINode != NULL);
  return m_pUINode->GetParent();
}

void CUIFolderInfo::DeleteAllLeafNodes(void)
{
  SubtractFromCount ((UINT)m_LeafNodes.GetCount());
  while (!m_LeafNodes.IsEmpty()) 
    delete m_LeafNodes.RemoveTail();	
}


void CUIFolderInfo::DeleteAllContainerNodes(void)
{
  SubtractFromCount ((UINT)m_ContainerNodes.GetCount());
  while (!m_ContainerNodes.IsEmpty()) 
    delete m_ContainerNodes.RemoveTail();	
}


HRESULT CUIFolderInfo::AddNode(CUINode* pUINode)
{
  if (pUINode==NULL) 
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }
  
  if (pUINode->IsContainer())
    m_ContainerNodes.AddTail(pUINode);
  else
    m_LeafNodes.AddTail(pUINode);
 
  AddToCount(1);
  pUINode->SetParent(m_pUINode);
  return S_OK;

}

HRESULT CUIFolderInfo::AddListofNodes(CUINodeList* pNodeList)
{
  HRESULT hr = S_OK;

  if (pNodeList == NULL)
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }

  POSITION pos = pNodeList->GetHeadPosition();
  while (pos != NULL)
  {
    CUINode* pUINode = pNodeList->GetNext(pos);
    if (pUINode != NULL)
    {
      AddNode(pUINode);
    }
    else
    {
      hr = E_POINTER;
    }
  }
  return hr;
}


HRESULT CUIFolderInfo::DeleteNode(CUINode* pUINode)
{
  if (pUINode==NULL) 
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }
  
  HRESULT hr = RemoveNode(pUINode);
  if (SUCCEEDED(hr))
  {
    delete pUINode;
  }
  
  return hr;
}

HRESULT CUIFolderInfo::RemoveNode(CUINode* pUINode)
{
  if (pUINode==NULL) 
  {
    ASSERT(FALSE);
    return E_INVALIDARG;
  }
   
  
  HRESULT hr=E_FAIL;
  POSITION pos;
  CUINodeList* pList=NULL;
  
  if (pUINode->IsContainer())
  {
    pList=&m_ContainerNodes;
  }
  else
  {
    pList=&m_LeafNodes;
  }
  
  pos = pList->Find(pUINode);
  if (pos != NULL) 
  {
    pList->RemoveAt(pos);
    hr = S_OK;
  }
  
  SubtractFromCount(1);
  return hr;
}
 
void CUIFolderInfo::SetTooMuchData(BOOL bSet, UINT nApproximateTotal)
{
  m_bTooMuchData = bSet;
  if (!bSet)
  {
    m_nApproximateTotalContained = 0;
  }
  else
  {
    m_nApproximateTotalContained = nApproximateTotal;
  }
}



////////////////////////////////////////////////////////////////////
// CUINode

CUINode::CUINode(CUINode* pParentNode)
{
  m_pParentNode = pParentNode;
  m_pNodeData = NULL;
  m_pFolderInfo = NULL;
  m_nSheetLockCount = 0;
  m_extension_op = 0;
  m_pMenuVerbs = NULL;
}

CUINode::CUINode(const CUINode& copyNode)
{
  m_pParentNode     = copyNode.m_pParentNode;

  if (copyNode.m_pNodeData != NULL)
  {
    m_pNodeData     = new CNodeData(*(copyNode.m_pNodeData));
  }
  else
  {
    m_pNodeData     = NULL;
  }

  if (copyNode.m_pFolderInfo != NULL)
  {
    m_pFolderInfo   = new CUIFolderInfo(*(copyNode.m_pFolderInfo));
    m_pFolderInfo->SetNode(this);
  }
  else
  {
    m_pFolderInfo   = NULL;
  }

  m_nSheetLockCount = copyNode.m_nSheetLockCount;
  m_extension_op    = copyNode.m_extension_op;
  m_pMenuVerbs      = NULL;
}

CUINode::~CUINode()
{
  ASSERT(m_nSheetLockCount == 0);
  if (m_pNodeData != NULL)
  {
    delete m_pNodeData;
  }

  if (m_pFolderInfo != NULL)
  {
    delete m_pFolderInfo;
  }

  if (m_pMenuVerbs != NULL)
  {
    delete m_pMenuVerbs;
  }
}

BOOL CUINode::IsRelative(CUINode* pUINode)
{
  BOOL bRet = FALSE;
  if (pUINode == this)
  {
    bRet = TRUE;
  }
  else
  {
    if (!IsSnapinRoot())
    {
      bRet = GetParent()->IsRelative(pUINode);
    }
  }
  return bRet;
}

void CUINode::IncrementSheetLockCount() 
{ 
	++m_nSheetLockCount; 
	if (m_pParentNode != NULL) 
		m_pParentNode->IncrementSheetLockCount(); 
}

void CUINode::DecrementSheetLockCount() 
{ 
  ASSERT(m_nSheetLockCount > 0);
	--m_nSheetLockCount; 
	if (m_pParentNode != NULL) 
		m_pParentNode->DecrementSheetLockCount();
}

BOOL CUINode::IsDeleteAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = TRUE;
  return FALSE;
}

BOOL CUINode::IsRenameAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = TRUE;
  return FALSE;
}

BOOL CUINode::IsRefreshAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = TRUE;
  return FALSE;
}

BOOL CUINode::ArePropertiesAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = TRUE;
  return FALSE;
}

BOOL CUINode::IsCutAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = TRUE;
  return FALSE;
}

BOOL CUINode::IsCopyAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = TRUE;
  return FALSE;
}

BOOL CUINode::IsPasteAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = TRUE;
  return FALSE;
}

BOOL CUINode::IsPrintAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = TRUE;
  return FALSE;
}

CDSColumnSet* CUINode::GetColumnSet(CDSComponentData* pComponentData)
{
  CDSColumnSet* pColumnSet = NULL;
  if (IsContainer())
  {
    pColumnSet = m_pFolderInfo->GetColumnSet(DEFAULT_COLUMN_SET, pComponentData);
  }
  return pColumnSet;
}

CContextMenuVerbs* CUINode::GetContextMenuVerbsObject(CDSComponentData* pComponentData)
{ 
  if (m_pMenuVerbs == NULL)
  {
    if (pComponentData->QuerySnapinType() == SNAPINTYPE_SITE)
    {
      m_pMenuVerbs = new CSARContextMenuVerbs(pComponentData);
    }
    else
    {
      m_pMenuVerbs = new CDSAdminContextMenuVerbs(pComponentData);
    }
  }
  return m_pMenuVerbs;
}

HRESULT CUINode::Delete(CDSComponentData* pComponentData)
{
  HRESULT hr = S_OK;

  if (IsContainer())
  {
    hr = pComponentData->RemoveContainerFromUI(this);
    delete this;
  }
  else
  {
    CUINode* pParentNode = GetParent();
    ASSERT(pParentNode->IsContainer());

    pParentNode->GetFolderInfo()->RemoveNode(this);
    //
    // The CDSEvent::_DeleteSingleSel() handles removing the node from the UI
    //
  }
  return hr;
}

HRESULT CUINode::DeleteMultiselect(CDSComponentData* pComponentData, CInternalFormatCracker* pObjCracker)
{
  HRESULT hr = S_OK;

  //
  // Multiselection should always delegate to the container
  //
  ASSERT(IsContainer());
  if (IsContainer())
  {
    for (UINT nIdx = 0; nIdx < pObjCracker->GetCookieCount(); nIdx++)
    {
      CUINode* pUINode = pObjCracker->GetCookie(nIdx);
      if (pUINode != NULL)
      {
        if (pUINode->IsContainer())
        {
          hr = pComponentData->RemoveContainerFromUI(pUINode);
          delete pUINode;
        }
        else
        {
          GetFolderInfo()->RemoveNode(pUINode);
        }
      }
    }
  }
  else
  {
    hr = S_FALSE;
  }
  return hr;
}

HRESULT CUINode::Rename(LPCWSTR lpszNewName, CDSComponentData* pComponentData)
{
  HRESULT hr = S_OK;

  SetName(lpszNewName);
  hr = pComponentData->UpdateItem(this);
  return hr;
}

////////////////////////////////////////////////////////////////////
// CUINodeTableBase

#define NUMBER_OF_COOKIE_TABLE_ENTRIES 4 // default count, expandable at run time

CUINodeTableBase::CUINodeTableBase()
{
  m_nEntries = NUMBER_OF_COOKIE_TABLE_ENTRIES;
  m_pCookieArr =(CUINode**)malloc(m_nEntries*sizeof(CUINode*));
  if (m_pCookieArr != NULL)
  {
    ZeroMemory(m_pCookieArr, m_nEntries*sizeof(CUINode*));
  }
}

CUINodeTableBase::~CUINodeTableBase()
{
  free(m_pCookieArr);
}

void CUINodeTableBase::Add(CUINode* pNode)
{
  ASSERT(!IsPresent(pNode)); 
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] == NULL)
    {
      m_pCookieArr[k] = pNode;
      return;
    }
  }
  // not space left, need to allocate
 	int nAlloc = m_nEntries*2;
	m_pCookieArr = (CUINode**)realloc(m_pCookieArr, sizeof(CUINode*)*nAlloc);
  ::ZeroMemory(&m_pCookieArr[m_nEntries], sizeof(CDSCookie*)*m_nEntries);
  m_pCookieArr[m_nEntries] = pNode;
  m_nEntries = nAlloc;
}

BOOL CUINodeTableBase::Remove(CUINode* pNode)
{
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] == pNode)
    {
      m_pCookieArr[k] = NULL;
      return TRUE; // found
    }
  }
  return FALSE; // not found
}


BOOL CUINodeTableBase::IsPresent(CUINode* pNode)
{
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] == pNode)
      return TRUE;
  }
  return FALSE;
}

void CUINodeTableBase::Reset()
{
  for (UINT k=0; k<m_nEntries; k++)
  {
    m_pCookieArr[k] = NULL;
  }
 
}

UINT CUINodeTableBase::GetCount()
{
  UINT nCount = 0;
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] != NULL)
      nCount++;
  }
  return nCount;
}


////////////////////////////////////////////////////////////////////
// CUINodeQueryTable

void CUINodeQueryTable::RemoveDescendants(CUINode* pNode)
{
  // cannot do this while the cookie has a pending operation
  ASSERT(!IsPresent(pNode)); 
  // remove all the cookies that have the given cookie as parent
  // or ancestor,
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] != NULL)
    {
      CUINode* pAncestorNode = m_pCookieArr[k]->GetParent();
      while (pAncestorNode != NULL)
      {
        if (pAncestorNode == pNode)
        {
          m_pCookieArr[k] = NULL;
        }
        pAncestorNode = pAncestorNode->GetParent();
      }
    }
  }
}


BOOL CUINodeQueryTable::IsLocked(CUINode* pNode)
{
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] != NULL)
    {
      // found the cookie itself?
      if (pNode == m_pCookieArr[k])
        return TRUE;
      // look if the cookie is an ancestor of the current cookie
      CUINode* pAncestorNode = m_pCookieArr[k]->GetParent();
      while (pAncestorNode != NULL)
      {
        if (pAncestorNode == pNode)
          return TRUE;
        pAncestorNode = pAncestorNode->GetParent();
      }
    }
  }
  return FALSE; 
}



////////////////////////////////////////////////////////////////////
// CUINodeSheetTable

void CUINodeSheetTable::BringToForeground(CUINode* pNode, CDSComponentData* pCD, BOOL bActivate)
{
  ASSERT(pCD != NULL);
  ASSERT(pNode != NULL);

  //
  // look for the cookie itself and for all the cookies that have the 
  // given cookie as parent or ancestor
  //
  for (UINT k=0; k<m_nEntries; k++)
  {
    if (m_pCookieArr[k] != NULL)
    {
      CUINode* pAncestorNode = m_pCookieArr[k];
      while (pAncestorNode != NULL)
      {
        if (pAncestorNode == pNode)
        {
          CString szADSIPath;

          if (IS_CLASS(*pNode, CDSUINode))
          {
            CDSCookie* pCookie = GetDSCookieFromUINode(pNode);
            if (pCookie != NULL)
            {
              pCD->GetBasePathsInfo()->ComposeADsIPath(szADSIPath, pCookie->GetPath());

              //
              // the first one will be also activated
              //
              TRACE(L"BringSheetToForeground(%s, %d)\n", (LPCWSTR)szADSIPath, bActivate);
              VERIFY(BringSheetToForeground((LPWSTR)(LPCWSTR)szADSIPath, bActivate));
              if (bActivate)
              {
                bActivate = FALSE;
              }
            }
          }
        }
        pAncestorNode = pAncestorNode->GetParent();
      }
    } // if
  } // for

}


/////////////////////////////////////////////////////////////////////////////
// CGenericUINode 

CGenericUINode::CGenericUINode(CUINode* pParentNode) : CUINode(pParentNode)
{
  m_nImage = 0;
}

CGenericUINode::CGenericUINode(const CGenericUINode& copyNode) : CUINode(copyNode)
{
  m_nImage  = copyNode.m_nImage;
  m_strName = copyNode.m_strName;
  m_strDesc = copyNode.m_strDesc;
}

LPCWSTR CGenericUINode::g_szNameXMLTag = L"NAME";
LPCWSTR CGenericUINode::g_szDecriptionXMLTag = L"DESCRIPTION";

HRESULT CGenericUINode::XMLSaveBase(IXMLDOMDocument* pXMLDoc,
                                    IXMLDOMNode* pXMLDOMNode)
{
  HRESULT hr = XML_AppendTextDataNode(pXMLDoc, pXMLDOMNode, CGenericUINode::g_szNameXMLTag, GetName());
  RETURN_IF_FAILED(hr);
  hr = XML_AppendTextDataNode(pXMLDoc, pXMLDOMNode, CGenericUINode::g_szDecriptionXMLTag, GetDesc());
  return hr;
}



//////////////////////////////////////////////////////////////////////////////
// CRootNode

BOOL CRootNode::IsRefreshAllowed(CDSComponentData*, BOOL* pbHide)
{
  *pbHide = FALSE;
  return TRUE;
}

CContextMenuVerbs* CRootNode::GetContextMenuVerbsObject(CDSComponentData* pComponentData)
{
  if (m_pMenuVerbs == NULL)
  {
    m_pMenuVerbs = new CSnapinRootMenuVerbs(pComponentData);
  }
  return m_pMenuVerbs;
}


HRESULT CRootNode::OnCommand(long lCommandID, CDSComponentData* pComponentData) 
{
  HRESULT hr = S_OK;

  switch (lCommandID)
  {
    case IDM_GEN_TASK_SELECT_DOMAIN:
    case IDM_GEN_TASK_SELECT_FOREST:
      if (pComponentData->CanRefreshAll()) 
      {
        pComponentData->GetDomain();
      }
      break;
    case IDM_GEN_TASK_SELECT_DC:
      if (pComponentData->CanRefreshAll()) 
      {
        pComponentData->GetDC();
      }
      break;
    case IDM_VIEW_SERVICES_NODE:
      {
        if (pComponentData->CanRefreshAll()) 
        {
          ASSERT( SNAPINTYPE_SITE == pComponentData->QuerySnapinType() );
          pComponentData->GetQueryFilter()->ToggleViewServicesNode();
          pComponentData->SetDirty();
          if (pComponentData->GetRootNode()->GetFolderInfo()->IsExpanded())
          {
            pComponentData->Refresh(pComponentData->GetRootNode(), FALSE /*bFlushCache*/ );
          }
        }
      }
      break;
    case IDM_GEN_TASK_EDIT_FSMO:
      {
        pComponentData->EditFSMO();
      }
      break;

    case IDM_GEN_TASK_RAISE_VERSION:
       pComponentData->RaiseVersion();
       break;

    case IDM_VIEW_ADVANCED:
      {
        if (pComponentData->CanRefreshAll()) 
        {
          ASSERT( SNAPINTYPE_SITE != pComponentData->QuerySnapinType() );
          pComponentData->GetQueryFilter()->ToggleAdvancedView();
          pComponentData->SetDirty();
          if (pComponentData->GetRootNode()->GetFolderInfo()->IsExpanded())
          {
            pComponentData->Refresh(pComponentData->GetRootNode(), TRUE /*bFlushCache*/ );
          }
        }
      }
      break;
    case IDM_VIEW_COMPUTER_HACK:
      if (pComponentData->CanRefreshAll()) 
      {
        pComponentData->Lock();
        pComponentData->GetQueryFilter()->ToggleExpandComputers();
        pComponentData->Unlock();
        BOOL fDoRefresh = pComponentData->GetClassCache()->ToggleExpandSpecialClasses(pComponentData->GetQueryFilter()->ExpandComputers());
        pComponentData->SetDirty();

        if (fDoRefresh) 
        {
          if (pComponentData->GetRootNode()->GetFolderInfo()->IsExpanded())
          {
            pComponentData->Refresh(pComponentData->GetRootNode(), TRUE /*bFlushCache*/ );
          }
        }
      }
      break;
    default:
      ASSERT(FALSE);
      break;
  }
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\snapin\dsadmin\uiutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      Util.cpp
//
//  Contents:  Utility functions
//
//  History:   08-Nov-99 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include "util.h"
#include "uiutil.h"
#include "dsutil.h"

#include "dsdlgs.h"
#include "helpids.h"


/////////////////////////////////////////////////////////////////////
// Combo box Utilities
//
int ComboBox_AddString(HWND hwndCombobox, UINT uStringId)
{
	ASSERT(IsWindow(hwndCombobox));
	CString str;
	VERIFY( str.LoadString(uStringId) );
	LRESULT i = SendMessage(hwndCombobox, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)str);
	Report(i >= 0);
	SendMessage(hwndCombobox, CB_SETITEMDATA, (WPARAM)i, uStringId);
	return (int)i;
}

void ComboBox_AddStrings(HWND hwndCombobox, const UINT rgzuStringId[])
{
	ASSERT(IsWindow(hwndCombobox));
	ASSERT(rgzuStringId != NULL);
	CString str;
	for (const UINT * puStringId = rgzuStringId; *puStringId != 0; puStringId++)
	{
		VERIFY( str.LoadString(*puStringId) );
		LRESULT i = SendMessage(hwndCombobox, CB_ADDSTRING, 0, (LPARAM)(LPCTSTR)str);
		Report(i >= 0);
		SendMessage(hwndCombobox, CB_SETITEMDATA, (WPARAM)i, *puStringId);
	}
}

int ComboBox_FindItemByLParam(HWND hwndCombobox, LPARAM lParam)
{
	ASSERT(IsWindow(hwndCombobox));
	Report(lParam != CB_ERR && "Ambiguous parameter.");
	LRESULT iItem = SendMessage(hwndCombobox, CB_GETCOUNT, 0, 0);
	ASSERT(iItem >= 0);
	while (iItem-- > 0)
	{
		LRESULT l = SendMessage(hwndCombobox, CB_GETITEMDATA, (WPARAM)iItem, 0);
		Report(l != CB_ERR);
		if (l == lParam)
    {
			return ((int)iItem);
    }
  }
	return -1;
}

int ComboBox_SelectItemByLParam(HWND hwndCombobox, LPARAM lParam)
{
	ASSERT(IsWindow(hwndCombobox));
	int iItem = ComboBox_FindItemByLParam(hwndCombobox, lParam);
	if (iItem >= 0)
	{
		SendMessage(hwndCombobox, CB_SETCURSEL, iItem, 0);
	}
	return iItem;
}


LPARAM ComboBox_GetSelectedItemLParam(HWND hwndCombobox)
{
	LRESULT iItem = SendMessage(hwndCombobox, CB_GETCURSEL, 0, 0);
	if (iItem < 0)
	{
		// No item selected
		return NULL;
	}
	LRESULT lParam = SendMessage(hwndCombobox, CB_GETITEMDATA, (WPARAM)iItem, 0);
	if (lParam == CB_ERR)
	{
		Report(FALSE && "Ambiguous return value.");
		return NULL;
	}
	return (LPARAM)lParam;
}

/////////////////////////////////////////////////////////////////////
// Dialog Utilities
//

HWND HGetDlgItem(HWND hdlg, INT nIdDlgItem)
{
	ASSERT(IsWindow(hdlg));
	ASSERT(IsWindow(GetDlgItem(hdlg, nIdDlgItem)));
	return GetDlgItem(hdlg, nIdDlgItem);
} // HGetDlgItem()

void SetDlgItemFocus(HWND hdlg, INT nIdDlgItem)
{
	SetFocus(HGetDlgItem(hdlg, nIdDlgItem));
}

void EnableDlgItem(HWND hdlg, INT nIdDlgItem, BOOL fEnable)
{
	EnableWindow(HGetDlgItem(hdlg, nIdDlgItem), fEnable);
}

void HideDlgItem(HWND hdlg, INT nIdDlgItem, BOOL fHideItem)
{
	HWND hwndCtl = HGetDlgItem(hdlg, nIdDlgItem);
	ShowWindow(hwndCtl, fHideItem ? SW_HIDE : SW_SHOW);
	EnableWindow(hwndCtl, !fHideItem);
}

void EnableDlgItemGroup(HWND hdlg,				// IN: Parent dialog of the controls
                        const UINT rgzidCtl[],	// IN: Group (array) of control Ids to be enabled (or disabled)
	                      BOOL fEnableAll)		// IN: TRUE => We want to enable the controls; FALSE => We want to disable the controls
{
	ASSERT(IsWindow(hdlg));
	ASSERT(rgzidCtl != NULL);
	for (const UINT * pidCtl = rgzidCtl; *pidCtl != 0; pidCtl++)
	{
		EnableWindow(HGetDlgItem(hdlg, *pidCtl), fEnableAll);
	}
} // EnableDlgItemGroup()


void HideDlgItemGroup(HWND hdlg,				// IN: Parent dialog of the controls
	                    const UINT rgzidCtl[],	// IN: Group (array) of control Ids to be shown (or hidden)
	                    BOOL fHideAll)			// IN: TRUE => We want to hide all the controls; FALSE => We want to show all the controls
{
	ASSERT(IsWindow(hdlg));
	ASSERT(rgzidCtl != NULL);
	for (const UINT * pidCtl = rgzidCtl; *pidCtl != 0; pidCtl++)
	{
		HideDlgItem(hdlg, *pidCtl, fHideAll);
	}
} // HideDlgItemGroup()

/////////////////////////////////////////////////////////////////////
// List View Utilities
//

void ListView_AddColumnHeaders(HWND hwndListview,		// IN: Handle of the listview we want to add columns
                              const TColumnHeaderItem rgzColumnHeader[])	// IN: Array of column header items
{
	RECT rcClient;
	INT cxTotalWidth;		// Total width of the listview control
	LV_COLUMN lvColumn;
	INT cxColumn;	// Width of the individual column
	CString str;

	ASSERT(IsWindow(hwndListview));
	ASSERT(rgzColumnHeader != NULL);

	GetClientRect(hwndListview, OUT &rcClient);
	cxTotalWidth = rcClient.right;
	
	for (INT i = 0; rgzColumnHeader[i].uStringId != 0; i++)
	{
		if (!str.LoadString(rgzColumnHeader[i].uStringId))
		{
			TRACE(L"Unable to load string Id=%d\n", rgzColumnHeader[i].uStringId);
			ASSERT(FALSE && "String not found");
			continue;
		}
		lvColumn.mask = LVCF_TEXT;
		lvColumn.pszText = (LPTSTR)(LPCTSTR)str;
		cxColumn = rgzColumnHeader[i].nColWidth;
		if (cxColumn > 0)
		{
			ASSERT(cxColumn <= 100);
			cxColumn = (cxTotalWidth * cxColumn) / 100;
			lvColumn.mask |= LVCF_WIDTH;
			lvColumn.cx = cxColumn;
		}

		int iColRet = ListView_InsertColumn(hwndListview, i, IN &lvColumn);
		Report(iColRet == i);
	} // for
} // ListView_AddColumnHeaders()

int ListView_AddString(HWND hwndListview,
                       const LPCTSTR psz,	// IN: String to insert
 	                     LPARAM lParam)		// IN: User-defined parameter
{
	ASSERT(IsWindow(hwndListview));
	ASSERT(psz != NULL);

	LV_ITEM lvItem;
	int iItem;
	GarbageInit(&lvItem, sizeof(lvItem));

	lvItem.mask = LVIF_TEXT | LVIF_PARAM;
	lvItem.lParam = lParam;
	lvItem.iSubItem = 0;
	lvItem.pszText = const_cast<LPTSTR>(psz);
	iItem = ListView_InsertItem(hwndListview, IN &lvItem);
	Report(iItem >= 0);
	return iItem;
} // ListView_AddString()

int ListView_AddStrings(HWND hwndListview,
	                      const LPCTSTR rgzpsz[],	// IN: Array of strings
	                      LPARAM lParam)			// IN: User-defined parameter
{
	ASSERT(IsWindow(hwndListview));
	ASSERT(rgzpsz != NULL);

	LV_ITEM lvItem;
	int iItem;
	GarbageInit(&lvItem, sizeof(lvItem));

	lvItem.mask = LVIF_TEXT | LVIF_PARAM;
	lvItem.lParam = lParam;
	lvItem.iSubItem = 0;
	lvItem.pszText = const_cast<LPTSTR>(rgzpsz[0]);
	iItem = ListView_InsertItem(hwndListview, IN &lvItem);
	Report(iItem >= 0);
	if (rgzpsz[0] == NULL)
  {
		return iItem;
  }

	lvItem.iItem = iItem;
	lvItem.mask = LVIF_TEXT;
	for (lvItem.iSubItem = 1 ; rgzpsz[lvItem.iSubItem] != NULL; lvItem.iSubItem++)
	{
		lvItem.pszText = const_cast<LPTSTR>(rgzpsz[lvItem.iSubItem]);
		VERIFY( ListView_SetItem(hwndListview, IN &lvItem) );
	}
	return iItem;
} // ListView_AddStrings()

void ListView_SelectItem(HWND hwndListview,
	                       int iItem)
{
	ASSERT(IsWindow(hwndListview));
	ASSERT(iItem >= 0);

	ListView_SetItemState(hwndListview, iItem, LVIS_SELECTED, LVIS_SELECTED);
} // ListView_SelectItem()

int ListView_GetSelectedItem(HWND hwndListview)
{
	ASSERT(IsWindow(hwndListview));
	return ListView_GetNextItem(hwndListview, -1, LVNI_SELECTED);
}

void ListView_SetItemString(HWND hwndListview,
	                          int iItem,
	                          int iSubItem,
	                          IN const CString& rstrText)
{
	ASSERT(IsWindow(hwndListview));
	ASSERT(iItem >= 0);
	ASSERT(iSubItem >= 0);
	ListView_SetItemText(hwndListview, iItem, iSubItem,
		const_cast<LPTSTR>((LPCTSTR)rstrText));
} // ListView_SetItemString()

int ListView_GetItemString(HWND hwndListview, 	
                           int iItem,
                           int iSubItem,
                           OUT CString& rstrText)
{
	ASSERT(IsWindow(hwndListview));
	if (iItem == -1)
	{
		// Find out the selected item
		iItem = ListView_GetSelectedItem(hwndListview);
		if (iItem == -1)
		{
			// No item selected
			rstrText.Empty();
			return -1;
		}
	}
	ASSERT(iItem >= 0);
	const int cchBuffer = 1024;	// Initial buffer
	TCHAR * psz = rstrText.GetBuffer(cchBuffer);
	ASSERT(psz != NULL);
	*psz = '\0';
	ListView_GetItemText(hwndListview, iItem, iSubItem, OUT psz, cchBuffer-1);
	rstrText.ReleaseBuffer();
	Report((rstrText.GetLength() < cchBuffer - 16) && "Buffer too small to hold entire string");
	rstrText.FreeExtra();
	return iItem;
} // ListView_GetItemString()

LPARAM ListView_GetItemLParam(HWND hwndListview,
	                            int iItem,
	                            int * piItem)	// OUT: OPTIONAL: Pointer to the index of the listview item
{
	ASSERT(IsWindow(hwndListview));
	Endorse(piItem == NULL);	// TRUE => Don't care about the index
	if (iItem == -1)
	{
		// Find out the selected item
		iItem = ListView_GetSelectedItem(hwndListview);
		if (iItem == -1)
		{
			// No item selected
			if (piItem != NULL)
      {
				*piItem = -1;
      }
			return NULL;
		}
	}
	ASSERT(iItem >= 0);
	if (piItem != NULL)
  {
		*piItem = iItem;
  }
	LV_ITEM lvItem;
	GarbageInit(&lvItem, sizeof(lvItem));
	lvItem.mask = LVIF_PARAM;
	lvItem.iItem = iItem;
	lvItem.iSubItem = 0;
	lvItem.lParam = 0;	// Just in case
	VERIFY(ListView_GetItem(hwndListview, OUT &lvItem));
	return lvItem.lParam;
} // ListView_GetItemLParam()

int ListView_FindString(HWND hwndListview,
                      	LPCTSTR pszTextSearch)
{
	ASSERT(IsWindow(hwndListview));
	ASSERT(pszTextSearch != NULL);

	LV_FINDINFO lvFindInfo;
	GarbageInit(&lvFindInfo, sizeof(lvFindInfo));
	lvFindInfo.flags = LVFI_STRING;
	lvFindInfo.psz = pszTextSearch;
	return ListView_FindItem(hwndListview, -1, &lvFindInfo);
} // ListView_FindString()

int ListView_FindLParam(HWND hwndListview,
	                      LPARAM lParam)
{
	ASSERT(IsWindow(hwndListview));

	LV_FINDINFO lvFindInfo;
	GarbageInit(&lvFindInfo, sizeof(lvFindInfo));
	lvFindInfo.flags = LVFI_PARAM;
	lvFindInfo.lParam = lParam;
	return ListView_FindItem(hwndListview, -1, &lvFindInfo);
} // ListView_FindLParam()

int ListView_SelectLParam(HWND hwndListview,
	                        LPARAM lParam)
{
	int iItem = ListView_FindLParam(hwndListview, lParam);
	if (iItem >= 0)
  {
		ListView_SelectItem(hwndListview, iItem);
	}
	else
	{
		TRACE2("ListView_SelectLParam() - Unable to find lParam=%x (%d).\n",
			lParam, lParam);
	}
	return iItem;
} // ListView_SelectLParam()


////////////////////////////////////////////////////////////////////////////
// CMultiselectErrorDialog
BEGIN_MESSAGE_MAP(CMultiselectErrorDialog, CDialog)
END_MESSAGE_MAP()

HRESULT CMultiselectErrorDialog::Initialize(CUINode** ppNodeArray,
                                            HRESULT* pErrorArray,
                                            UINT nErrorCount,
                                            PCWSTR pszTitle, 
                                            PCWSTR pszCaption,
                                            PCWSTR pszColumnHeader)
{
  ASSERT(ppNodeArray != NULL);
  ASSERT(pErrorArray != NULL);
  ASSERT(pszTitle != NULL);
  ASSERT(pszCaption != NULL);
  ASSERT(pszColumnHeader != NULL);

  if (ppNodeArray == NULL ||
      pErrorArray == NULL ||
      pszTitle == NULL ||
      pszCaption == NULL ||
      pszColumnHeader == NULL)
  {
    return E_POINTER;
  }

  m_ppNodeList = ppNodeArray;
  m_pErrorArray = pErrorArray;
  m_nErrorCount = nErrorCount;
  m_szTitle = pszTitle;
  m_szCaption = pszCaption;
  m_szColumnHeader = pszColumnHeader;

  return S_OK;
}

HRESULT CMultiselectErrorDialog::Initialize(PWSTR*    pPathArray,
                                            PWSTR*    pClassArray,
                                            HRESULT*  pErrorArray,
                                            UINT      nErrorCount,
                                            PCWSTR    pszTitle, 
                                            PCWSTR    pszCaption,
                                            PCWSTR    pszColumnHeader)
{
  ASSERT(pPathArray != NULL);
  ASSERT(pClassArray != NULL);
  ASSERT(pErrorArray != NULL);
  ASSERT(pszTitle != NULL);
  ASSERT(pszCaption != NULL);
  ASSERT(pszColumnHeader != NULL);

  if (pPathArray == NULL ||
      pClassArray == NULL ||
      pErrorArray == NULL ||
      pszTitle == NULL ||
      pszCaption == NULL ||
      pszColumnHeader == NULL)
  {
    return E_POINTER;
  }

  m_pPathArray = pPathArray;
  m_pClassArray = pClassArray;
  m_pErrorArray = pErrorArray;
  m_nErrorCount = nErrorCount;
  m_szTitle     = pszTitle;
  m_szCaption   = pszCaption;
  m_szColumnHeader = pszColumnHeader;

  return S_OK;
}

const int OBJ_LIST_NAME_COL_WIDTH = 100;
const int IDX_NAME_COL = 0;
const int IDX_ERR_COL = 1;

BOOL CMultiselectErrorDialog::OnInitDialog()
{
  CDialog::OnInitDialog();

  SetWindowText(m_szTitle);
  SetDlgItemText(IDC_STATIC_MESSAGE, m_szCaption);

  HWND hList = GetDlgItem(IDC_ERROR_LIST)->GetSafeHwnd();
  ListView_SetExtendedListViewStyle(hList, LVS_EX_FULLROWSELECT);

  //
  // Create the image list
  //
  m_hImageList = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK, 1, 1);
  ASSERT(m_hImageList != NULL);
 
  if (m_hImageList != NULL)
  {
    ListView_SetImageList(hList, m_hImageList, LVSIL_SMALL);
  }

  //
  // Set the column headings.
  //
  RECT rect;
  ::GetClientRect(hList, &rect);

  LV_COLUMN lvc = {0};
  lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
  lvc.fmt = LVCFMT_LEFT;
  lvc.cx = OBJ_LIST_NAME_COL_WIDTH;
  lvc.pszText = (PWSTR)(PCWSTR)m_szColumnHeader;
  lvc.iSubItem = IDX_NAME_COL;

  ListView_InsertColumn(hList, IDX_NAME_COL, &lvc);

  CString szError;
  VERIFY(szError.LoadString(IDS_ERROR));

  lvc.cx = rect.right - OBJ_LIST_NAME_COL_WIDTH;
  lvc.pszText = (PWSTR)(PCWSTR)szError;
  lvc.iSubItem = IDX_ERR_COL;

  ListView_InsertColumn(hList, IDX_ERR_COL, &lvc);

  //
  // Insert the errors
  //

  //
  // Use the node list if its not NULL
  //
  if (m_ppNodeList != NULL)
  {
    ASSERT(m_pErrorArray != NULL && m_ppNodeList != NULL);

    for (UINT nIdx = 0; nIdx < m_nErrorCount; nIdx++)
    {
      CUINode* pNode = m_ppNodeList[nIdx];
      if (pNode != NULL)
      {
        if (nIdx < m_nErrorCount && FAILED(m_pErrorArray[nIdx]))
        {
          //
          // Create the list view item
          //
          LV_ITEM lvi = {0};
          lvi.mask = LVIF_TEXT | LVIF_PARAM;
          lvi.iSubItem = IDX_NAME_COL;

          lvi.lParam = (LPARAM)pNode->GetName();
          lvi.pszText = (PWSTR)pNode->GetName();
          lvi.iItem = nIdx;

          if (m_hImageList != NULL)
          {
            //
            // REVIEW_JEFFJON : this will add multiple icons of the same class
            //                  need to provide a better means for managing the icons
            //
            CDSCookie* pCookie = GetDSCookieFromUINode(pNode);
            if (pCookie != NULL)
            {
              HICON icon = m_pComponentData->GetBasePathsInfo()->GetIcon(
                             // someone really blew it with const correctness...
                             const_cast<LPTSTR>(pCookie->GetClass()),
                             DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON,
                             16,
                             16);
      
              int i = ::ImageList_AddIcon(m_hImageList, icon);
              ASSERT(i != -1);
              if (i != -1)
              {
                lvi.mask |= LVIF_IMAGE;
                lvi.iImage = i;
              }
            }
          }

          //
          // Insert the new item
          //
          int NewIndex = ListView_InsertItem(hList, &lvi);
          ASSERT(NewIndex != -1);
          if (NewIndex == -1)
          {
            continue;
          }

          //
          // Get the error message
          //
          PWSTR pszErrMessage;
          int iChar = cchLoadHrMsg(m_pErrorArray[nIdx], &pszErrMessage, TRUE);
      	  if (pszErrMessage != NULL && iChar > 0)
	        {
            ListView_SetItemText(hList, NewIndex, IDX_ERR_COL, pszErrMessage);
            LocalFree(pszErrMessage);
          }
        }
      }
    }
  }
  else if (m_pPathArray != NULL)   // if the node list is NULL then use the string list
  {
    ASSERT(m_pErrorArray != NULL && m_pPathArray != NULL);

    for (UINT nIdx = 0; nIdx < m_nErrorCount; nIdx++)
    {
      if (nIdx < m_nErrorCount && FAILED(m_pErrorArray[nIdx]))
      {
        //
        // Use the path cracker to retrieve the name of the object
        //
        PCWSTR pszPath = m_pPathArray[nIdx];
        CPathCracker pathCracker;
        VERIFY(SUCCEEDED(pathCracker.Set((BSTR)(PWSTR)pszPath, ADS_SETTYPE_DN)));
        VERIFY(SUCCEEDED(pathCracker.put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX)));
        VERIFY(SUCCEEDED(pathCracker.SetDisplayType(ADS_DISPLAY_VALUE_ONLY)));

        CComBSTR bstrName;
        VERIFY(SUCCEEDED(pathCracker.GetElement(0, &bstrName)));

        //
        // Create the list view item
        //
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iSubItem = IDX_NAME_COL;

        //
        // Make the LPARAM be the path to the object
        // Not used at this time but may be useful in 
        // the future for bringing up property pages or
        // other special features.
        //
        lvi.lParam = (LPARAM)m_pPathArray[nIdx];
        lvi.pszText = (PWSTR)bstrName;
        lvi.iItem = nIdx;

        if (m_hImageList != NULL)
        {
          //
          // REVIEW_JEFFJON : this will add multiple icons of the same class
          //                  need to provide a better means for managing the icons
          //
          ASSERT(m_pClassArray[nIdx] != NULL);
          HICON icon = m_pComponentData->GetBasePathsInfo()->GetIcon(
                         // someone really blew it with const correctness...
                         const_cast<LPTSTR>(m_pClassArray[nIdx]),
                         DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON,
                         16,
                         16);
  
          int i = ::ImageList_AddIcon(m_hImageList, icon);
          ASSERT(i != -1);
          if (i != -1)
          {
            lvi.mask |= LVIF_IMAGE;
            lvi.iImage = i;
          }
        }

        //
        // Insert the new item
        //
        int NewIndex = ListView_InsertItem(hList, &lvi);
        ASSERT(NewIndex != -1);
        if (NewIndex == -1)
        {
          continue;
        }

        //
        // Get the error message
        //
        PWSTR pszErrMessage;
        int iChar = cchLoadHrMsg(m_pErrorArray[nIdx], &pszErrMessage, TRUE);
      	if (pszErrMessage != NULL && iChar > 0)
	      {
          //
          // REVIEW_JEFFJON : this is a hack to get rid of two extra characters
          //                  at the end of the error message
          //
          size_t iLen = wcslen(pszErrMessage);
          pszErrMessage[iLen - 2] = L'\0';
          
          ListView_SetItemText(hList, NewIndex, IDX_ERR_COL, pszErrMessage);
          LocalFree(pszErrMessage);
        }
      }
    }
  }
  UpdateListboxHorizontalExtent();
  return TRUE;
}

void CMultiselectErrorDialog::UpdateListboxHorizontalExtent()
{
  CListCtrl* pListView = reinterpret_cast<CListCtrl*>(GetDlgItem(IDC_ERROR_LIST));
  pListView->SetColumnWidth(IDX_ERR_COL, LVSCW_AUTOSIZE);
}

/////////////////////////////////////////////////////////////////////
// MFC Utilities
//
// CDialogEx
//

CDialogEx::CDialogEx(UINT nIDTemplate, CWnd * pParentWnd) : CDialog(nIDTemplate, pParentW